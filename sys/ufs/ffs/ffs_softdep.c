begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 1998, 2000 Marshall Kirk McKusick. All Rights Reserved.  *  * The soft updates code is derived from the appendix of a University  * of Michigan technical report (Gregory R. Ganger and Yale N. Patt,  * "Soft Updates: A Solution to the Metadata Update Problem in File  * Systems", CSE-TR-254-95, August 1995).  *  * Further information about soft updates can be obtained from:  *  *	Marshall Kirk McKusick		http://www.mckusick.com/softdep/  *	1614 Oxford Street		mckusick@mckusick.com  *	Berkeley, CA 94709-1608		+1-510-843-9542  *	USA  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY MARSHALL KIRK MCKUSICK ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL MARSHALL KIRK MCKUSICK BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	from: @(#)ffs_softdep.c	9.59 (McKusick) 6/21/00  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * For now we want the safety net that the DIAGNOSTIC and DEBUG flags provide.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DIAGNOSTIC
end_ifndef

begin_define
define|#
directive|define
name|DIAGNOSTIC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG
end_ifndef

begin_define
define|#
directive|define
name|DEBUG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/dir.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/quota.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/inode.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/ufsmount.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ffs/fs.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ffs/softdep.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ffs/ffs_extern.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/ufs_extern.h>
end_include

begin_comment
comment|/*  * These definitions need to be adapted to the system to which  * this file is being ported.  */
end_comment

begin_comment
comment|/*  * malloc types defined for the softdep system.  */
end_comment

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_PAGEDEP
argument_list|,
literal|"pagedep"
argument_list|,
literal|"File page dependencies"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_INODEDEP
argument_list|,
literal|"inodedep"
argument_list|,
literal|"Inode dependencies"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NEWBLK
argument_list|,
literal|"newblk"
argument_list|,
literal|"New block allocation"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_BMSAFEMAP
argument_list|,
literal|"bmsafemap"
argument_list|,
literal|"Block or frag allocated from cyl group map"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_ALLOCDIRECT
argument_list|,
literal|"allocdirect"
argument_list|,
literal|"Block or frag dependency for an inode"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_INDIRDEP
argument_list|,
literal|"indirdep"
argument_list|,
literal|"Indirect block dependencies"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_ALLOCINDIR
argument_list|,
literal|"allocindir"
argument_list|,
literal|"Block dependency for an indirect block"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_FREEFRAG
argument_list|,
literal|"freefrag"
argument_list|,
literal|"Previously used frag for an inode"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_FREEBLKS
argument_list|,
literal|"freeblks"
argument_list|,
literal|"Blocks freed from an inode"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_FREEFILE
argument_list|,
literal|"freefile"
argument_list|,
literal|"Inode deallocated"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_DIRADD
argument_list|,
literal|"diradd"
argument_list|,
literal|"New directory entry"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_MKDIR
argument_list|,
literal|"mkdir"
argument_list|,
literal|"New directory"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_DIRREM
argument_list|,
literal|"dirrem"
argument_list|,
literal|"Directory entry deleted"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|M_SOFTDEP_FLAGS
value|(M_WAITOK | M_USE_RESERVE)
end_define

begin_define
define|#
directive|define
name|D_PAGEDEP
value|0
end_define

begin_define
define|#
directive|define
name|D_INODEDEP
value|1
end_define

begin_define
define|#
directive|define
name|D_NEWBLK
value|2
end_define

begin_define
define|#
directive|define
name|D_BMSAFEMAP
value|3
end_define

begin_define
define|#
directive|define
name|D_ALLOCDIRECT
value|4
end_define

begin_define
define|#
directive|define
name|D_INDIRDEP
value|5
end_define

begin_define
define|#
directive|define
name|D_ALLOCINDIR
value|6
end_define

begin_define
define|#
directive|define
name|D_FREEFRAG
value|7
end_define

begin_define
define|#
directive|define
name|D_FREEBLKS
value|8
end_define

begin_define
define|#
directive|define
name|D_FREEFILE
value|9
end_define

begin_define
define|#
directive|define
name|D_DIRADD
value|10
end_define

begin_define
define|#
directive|define
name|D_MKDIR
value|11
end_define

begin_define
define|#
directive|define
name|D_DIRREM
value|12
end_define

begin_define
define|#
directive|define
name|D_LAST
value|D_DIRREM
end_define

begin_comment
comment|/*   * translate from workitem type to memory type  * MUST match the defines above, such that memtype[D_XXX] == M_XXX  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|malloc_type
modifier|*
name|memtype
index|[]
init|=
block|{
name|M_PAGEDEP
block|,
name|M_INODEDEP
block|,
name|M_NEWBLK
block|,
name|M_BMSAFEMAP
block|,
name|M_ALLOCDIRECT
block|,
name|M_INDIRDEP
block|,
name|M_ALLOCINDIR
block|,
name|M_FREEFRAG
block|,
name|M_FREEBLKS
block|,
name|M_FREEFILE
block|,
name|M_DIRADD
block|,
name|M_MKDIR
block|,
name|M_DIRREM
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DtoM
parameter_list|(
name|type
parameter_list|)
value|(memtype[type])
end_define

begin_comment
comment|/*  * Names of malloc types.  */
end_comment

begin_define
define|#
directive|define
name|TYPENAME
parameter_list|(
name|type
parameter_list|)
define|\
value|((unsigned)(type)< D_LAST ? memtype[type]->ks_shortdesc : "???")
end_define

begin_define
define|#
directive|define
name|CURPROC
value|curproc
end_define

begin_comment
comment|/*  * End system adaptaion definitions.  */
end_comment

begin_comment
comment|/*  * Internal function prototypes.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|softdep_error
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|drain_output
name|__P
argument_list|(
operator|(
expr|struct
name|vnode
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|getdirtybuf
name|__P
argument_list|(
operator|(
expr|struct
name|buf
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clear_remove
name|__P
argument_list|(
operator|(
expr|struct
name|proc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clear_inodedeps
name|__P
argument_list|(
operator|(
expr|struct
name|proc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|flush_pagedep_deps
name|__P
argument_list|(
operator|(
expr|struct
name|vnode
operator|*
operator|,
expr|struct
name|mount
operator|*
operator|,
expr|struct
name|diraddhd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|flush_inodedep_deps
name|__P
argument_list|(
operator|(
expr|struct
name|fs
operator|*
operator|,
name|ino_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|handle_written_filepage
name|__P
argument_list|(
operator|(
expr|struct
name|pagedep
operator|*
operator|,
expr|struct
name|buf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|diradd_inode_written
name|__P
argument_list|(
operator|(
expr|struct
name|diradd
operator|*
operator|,
expr|struct
name|inodedep
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|handle_written_inodeblock
name|__P
argument_list|(
operator|(
expr|struct
name|inodedep
operator|*
operator|,
expr|struct
name|buf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_allocdirect_partdone
name|__P
argument_list|(
operator|(
expr|struct
name|allocdirect
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_allocindir_partdone
name|__P
argument_list|(
operator|(
expr|struct
name|allocindir
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|initiate_write_filepage
name|__P
argument_list|(
operator|(
expr|struct
name|pagedep
operator|*
operator|,
expr|struct
name|buf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_written_mkdir
name|__P
argument_list|(
operator|(
expr|struct
name|mkdir
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|initiate_write_inodeblock
name|__P
argument_list|(
operator|(
expr|struct
name|inodedep
operator|*
operator|,
expr|struct
name|buf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_workitem_freefile
name|__P
argument_list|(
operator|(
expr|struct
name|freefile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_workitem_remove
name|__P
argument_list|(
operator|(
expr|struct
name|dirrem
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|dirrem
modifier|*
name|newdirrem
name|__P
argument_list|(
operator|(
expr|struct
name|buf
operator|*
operator|,
expr|struct
name|inode
operator|*
operator|,
expr|struct
name|inode
operator|*
operator|,
name|int
operator|,
expr|struct
name|dirrem
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_diradd
name|__P
argument_list|(
operator|(
expr|struct
name|diradd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_allocindir
name|__P
argument_list|(
operator|(
expr|struct
name|allocindir
operator|*
operator|,
expr|struct
name|inodedep
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|indir_trunc
name|__P
argument_list|(
operator|(
expr|struct
name|inode
operator|*
operator|,
name|ufs_daddr_t
operator|,
name|int
operator|,
name|ufs_lbn_t
operator|,
name|long
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|deallocate_dependencies
name|__P
argument_list|(
operator|(
expr|struct
name|buf
operator|*
operator|,
expr|struct
name|inodedep
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_allocdirect
name|__P
argument_list|(
operator|(
expr|struct
name|allocdirectlst
operator|*
operator|,
expr|struct
name|allocdirect
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_inode_unwritten
name|__P
argument_list|(
operator|(
expr|struct
name|inodedep
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|free_inodedep
name|__P
argument_list|(
operator|(
expr|struct
name|inodedep
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_workitem_freeblocks
name|__P
argument_list|(
operator|(
expr|struct
name|freeblks
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|merge_inode_lists
name|__P
argument_list|(
operator|(
expr|struct
name|inodedep
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|setup_allocindir_phase2
name|__P
argument_list|(
operator|(
expr|struct
name|buf
operator|*
operator|,
expr|struct
name|inode
operator|*
operator|,
expr|struct
name|allocindir
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|allocindir
modifier|*
name|newallocindir
name|__P
argument_list|(
operator|(
expr|struct
name|inode
operator|*
operator|,
name|int
operator|,
name|ufs_daddr_t
operator|,
name|ufs_daddr_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_workitem_freefrag
name|__P
argument_list|(
operator|(
expr|struct
name|freefrag
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|freefrag
modifier|*
name|newfreefrag
name|__P
argument_list|(
operator|(
expr|struct
name|inode
operator|*
operator|,
name|ufs_daddr_t
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|allocdirect_merge
name|__P
argument_list|(
operator|(
expr|struct
name|allocdirectlst
operator|*
operator|,
expr|struct
name|allocdirect
operator|*
operator|,
expr|struct
name|allocdirect
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bmsafemap
modifier|*
name|bmsafemap_lookup
name|__P
argument_list|(
operator|(
expr|struct
name|buf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|newblk_lookup
name|__P
argument_list|(
operator|(
expr|struct
name|fs
operator|*
operator|,
name|ufs_daddr_t
operator|,
name|int
operator|,
expr|struct
name|newblk
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|inodedep_lookup
name|__P
argument_list|(
operator|(
expr|struct
name|fs
operator|*
operator|,
name|ino_t
operator|,
name|int
operator|,
expr|struct
name|inodedep
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pagedep_lookup
name|__P
argument_list|(
operator|(
expr|struct
name|inode
operator|*
operator|,
name|ufs_lbn_t
operator|,
name|int
operator|,
expr|struct
name|pagedep
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pause_timer
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|request_cleanup
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|process_worklist_item
name|__P
argument_list|(
operator|(
expr|struct
name|mount
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_to_worklist
name|__P
argument_list|(
operator|(
expr|struct
name|worklist
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Exported softdep operations.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|softdep_disk_io_initiation
name|__P
argument_list|(
operator|(
expr|struct
name|buf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|softdep_disk_write_complete
name|__P
argument_list|(
operator|(
expr|struct
name|buf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|softdep_deallocate_dependencies
name|__P
argument_list|(
operator|(
expr|struct
name|buf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|softdep_fsync
name|__P
argument_list|(
operator|(
expr|struct
name|vnode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|softdep_process_worklist
name|__P
argument_list|(
operator|(
expr|struct
name|mount
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|softdep_move_dependencies
name|__P
argument_list|(
operator|(
expr|struct
name|buf
operator|*
operator|,
expr|struct
name|buf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|softdep_count_dependencies
name|__P
argument_list|(
operator|(
expr|struct
name|buf
operator|*
name|bp
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|bio_ops
name|bioops
init|=
block|{
name|softdep_disk_io_initiation
block|,
comment|/* io_start */
name|softdep_disk_write_complete
block|,
comment|/* io_complete */
name|softdep_deallocate_dependencies
block|,
comment|/* io_deallocate */
name|softdep_fsync
block|,
comment|/* io_fsync */
name|softdep_process_worklist
block|,
comment|/* io_sync */
name|softdep_move_dependencies
block|,
comment|/* io_movedeps */
name|softdep_count_dependencies
block|,
comment|/* io_countdeps */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Locking primitives.  *  * For a uniprocessor, all we need to do is protect against disk  * interrupts. For a multiprocessor, this lock would have to be  * a mutex. A single mutex is used throughout this file, though  * finer grain locking could be used if contention warranted it.  *  * For a multiprocessor, the sleep call would accept a lock and  * release it after the sleep processing was complete. In a uniprocessor  * implementation there is no such interlock, so we simple mark  * the places where it needs to be done with the `interlocked' form  * of the lock calls. Since the uniprocessor sleep already interlocks  * the spl, there is nothing that really needs to be done.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
comment|/* NOT */
name|DEBUG
end_ifndef

begin_struct
specifier|static
struct|struct
name|lockit
block|{
name|int
name|lkt_spl
decl_stmt|;
block|}
name|lk
init|=
block|{
literal|0
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ACQUIRE_LOCK
parameter_list|(
name|lk
parameter_list|)
value|(lk)->lkt_spl = splbio()
end_define

begin_define
define|#
directive|define
name|FREE_LOCK
parameter_list|(
name|lk
parameter_list|)
value|splx((lk)->lkt_spl)
end_define

begin_define
define|#
directive|define
name|ACQUIRE_LOCK_INTERLOCKED
parameter_list|(
name|lk
parameter_list|)
end_define

begin_define
define|#
directive|define
name|FREE_LOCK_INTERLOCKED
parameter_list|(
name|lk
parameter_list|)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* DEBUG */
end_comment

begin_struct
specifier|static
struct|struct
name|lockit
block|{
name|int
name|lkt_spl
decl_stmt|;
name|pid_t
name|lkt_held
decl_stmt|;
block|}
name|lk
init|=
block|{
literal|0
block|,
operator|-
literal|1
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|lockcnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|acquire_lock
name|__P
argument_list|(
operator|(
expr|struct
name|lockit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_lock
name|__P
argument_list|(
operator|(
expr|struct
name|lockit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|acquire_lock_interlocked
name|__P
argument_list|(
operator|(
expr|struct
name|lockit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_lock_interlocked
name|__P
argument_list|(
operator|(
expr|struct
name|lockit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ACQUIRE_LOCK
parameter_list|(
name|lk
parameter_list|)
value|acquire_lock(lk)
end_define

begin_define
define|#
directive|define
name|FREE_LOCK
parameter_list|(
name|lk
parameter_list|)
value|free_lock(lk)
end_define

begin_define
define|#
directive|define
name|ACQUIRE_LOCK_INTERLOCKED
parameter_list|(
name|lk
parameter_list|)
value|acquire_lock_interlocked(lk)
end_define

begin_define
define|#
directive|define
name|FREE_LOCK_INTERLOCKED
parameter_list|(
name|lk
parameter_list|)
value|free_lock_interlocked(lk)
end_define

begin_function
specifier|static
name|void
name|acquire_lock
parameter_list|(
name|lk
parameter_list|)
name|struct
name|lockit
modifier|*
name|lk
decl_stmt|;
block|{
name|pid_t
name|holder
decl_stmt|;
if|if
condition|(
name|lk
operator|->
name|lkt_held
operator|!=
operator|-
literal|1
condition|)
block|{
name|holder
operator|=
name|lk
operator|->
name|lkt_held
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|lk
argument_list|)
expr_stmt|;
if|if
condition|(
name|holder
operator|==
name|CURPROC
operator|->
name|p_pid
condition|)
name|panic
argument_list|(
literal|"softdep_lock: locking against myself"
argument_list|)
expr_stmt|;
else|else
name|panic
argument_list|(
literal|"softdep_lock: lock held by %d"
argument_list|,
name|holder
argument_list|)
expr_stmt|;
block|}
name|lk
operator|->
name|lkt_spl
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|lk
operator|->
name|lkt_held
operator|=
name|CURPROC
operator|->
name|p_pid
expr_stmt|;
name|lockcnt
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_lock
parameter_list|(
name|lk
parameter_list|)
name|struct
name|lockit
modifier|*
name|lk
decl_stmt|;
block|{
if|if
condition|(
name|lk
operator|->
name|lkt_held
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"softdep_unlock: lock not held"
argument_list|)
expr_stmt|;
name|lk
operator|->
name|lkt_held
operator|=
operator|-
literal|1
expr_stmt|;
name|splx
argument_list|(
name|lk
operator|->
name|lkt_spl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|acquire_lock_interlocked
parameter_list|(
name|lk
parameter_list|)
name|struct
name|lockit
modifier|*
name|lk
decl_stmt|;
block|{
name|pid_t
name|holder
decl_stmt|;
if|if
condition|(
name|lk
operator|->
name|lkt_held
operator|!=
operator|-
literal|1
condition|)
block|{
name|holder
operator|=
name|lk
operator|->
name|lkt_held
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|lk
argument_list|)
expr_stmt|;
if|if
condition|(
name|holder
operator|==
name|CURPROC
operator|->
name|p_pid
condition|)
name|panic
argument_list|(
literal|"softdep_lock_interlocked: locking against self"
argument_list|)
expr_stmt|;
else|else
name|panic
argument_list|(
literal|"softdep_lock_interlocked: lock held by %d"
argument_list|,
name|holder
argument_list|)
expr_stmt|;
block|}
name|lk
operator|->
name|lkt_held
operator|=
name|CURPROC
operator|->
name|p_pid
expr_stmt|;
name|lockcnt
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_lock_interlocked
parameter_list|(
name|lk
parameter_list|)
name|struct
name|lockit
modifier|*
name|lk
decl_stmt|;
block|{
if|if
condition|(
name|lk
operator|->
name|lkt_held
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"softdep_unlock_interlocked: lock not held"
argument_list|)
expr_stmt|;
name|lk
operator|->
name|lkt_held
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_comment
comment|/*  * Place holder for real semaphores.  */
end_comment

begin_struct
struct|struct
name|sema
block|{
name|int
name|value
decl_stmt|;
name|pid_t
name|holder
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|prio
decl_stmt|;
name|int
name|timo
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|void
name|sema_init
name|__P
argument_list|(
operator|(
expr|struct
name|sema
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sema_get
name|__P
argument_list|(
operator|(
expr|struct
name|sema
operator|*
operator|,
expr|struct
name|lockit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sema_release
name|__P
argument_list|(
operator|(
expr|struct
name|sema
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|sema_init
parameter_list|(
name|semap
parameter_list|,
name|name
parameter_list|,
name|prio
parameter_list|,
name|timo
parameter_list|)
name|struct
name|sema
modifier|*
name|semap
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|prio
decl_stmt|,
name|timo
decl_stmt|;
block|{
name|semap
operator|->
name|holder
operator|=
operator|-
literal|1
expr_stmt|;
name|semap
operator|->
name|value
operator|=
literal|0
expr_stmt|;
name|semap
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|semap
operator|->
name|prio
operator|=
name|prio
expr_stmt|;
name|semap
operator|->
name|timo
operator|=
name|timo
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sema_get
parameter_list|(
name|semap
parameter_list|,
name|interlock
parameter_list|)
name|struct
name|sema
modifier|*
name|semap
decl_stmt|;
name|struct
name|lockit
modifier|*
name|interlock
decl_stmt|;
block|{
if|if
condition|(
name|semap
operator|->
name|value
operator|++
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|interlock
operator|!=
name|NULL
condition|)
name|FREE_LOCK_INTERLOCKED
argument_list|(
name|interlock
argument_list|)
expr_stmt|;
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|semap
argument_list|,
name|semap
operator|->
name|prio
argument_list|,
name|semap
operator|->
name|name
argument_list|,
name|semap
operator|->
name|timo
argument_list|)
expr_stmt|;
if|if
condition|(
name|interlock
operator|!=
name|NULL
condition|)
block|{
name|ACQUIRE_LOCK_INTERLOCKED
argument_list|(
name|interlock
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|interlock
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|semap
operator|->
name|holder
operator|=
name|CURPROC
operator|->
name|p_pid
expr_stmt|;
if|if
condition|(
name|interlock
operator|!=
name|NULL
condition|)
name|FREE_LOCK
argument_list|(
name|interlock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sema_release
parameter_list|(
name|semap
parameter_list|)
name|struct
name|sema
modifier|*
name|semap
decl_stmt|;
block|{
if|if
condition|(
name|semap
operator|->
name|value
operator|<=
literal|0
operator|||
name|semap
operator|->
name|holder
operator|!=
name|CURPROC
operator|->
name|p_pid
condition|)
block|{
if|if
condition|(
name|lk
operator|.
name|lkt_held
operator|!=
operator|-
literal|1
condition|)
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"sema_release: not held"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|--
name|semap
operator|->
name|value
operator|>
literal|0
condition|)
block|{
name|semap
operator|->
name|value
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
name|semap
argument_list|)
expr_stmt|;
block|}
name|semap
operator|->
name|holder
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Worklist queue management.  * These routines require that the lock be held.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
comment|/* NOT */
name|DEBUG
end_ifndef

begin_define
define|#
directive|define
name|WORKLIST_INSERT
parameter_list|(
name|head
parameter_list|,
name|item
parameter_list|)
value|do {	\ 	(item)->wk_state |= ONWORKLIST;		\ 	LIST_INSERT_HEAD(head, item, wk_list);	\ } while (0)
end_define

begin_define
define|#
directive|define
name|WORKLIST_REMOVE
parameter_list|(
name|item
parameter_list|)
value|do {		\ 	(item)->wk_state&= ~ONWORKLIST;	\ 	LIST_REMOVE(item, wk_list);		\ } while (0)
end_define

begin_define
define|#
directive|define
name|WORKITEM_FREE
parameter_list|(
name|item
parameter_list|,
name|type
parameter_list|)
value|FREE(item, DtoM(type))
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* DEBUG */
end_comment

begin_decl_stmt
specifier|static
name|void
name|worklist_insert
name|__P
argument_list|(
operator|(
expr|struct
name|workhead
operator|*
operator|,
expr|struct
name|worklist
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|worklist_remove
name|__P
argument_list|(
operator|(
expr|struct
name|worklist
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|workitem_free
name|__P
argument_list|(
operator|(
expr|struct
name|worklist
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|WORKLIST_INSERT
parameter_list|(
name|head
parameter_list|,
name|item
parameter_list|)
value|worklist_insert(head, item)
end_define

begin_define
define|#
directive|define
name|WORKLIST_REMOVE
parameter_list|(
name|item
parameter_list|)
value|worklist_remove(item)
end_define

begin_define
define|#
directive|define
name|WORKITEM_FREE
parameter_list|(
name|item
parameter_list|,
name|type
parameter_list|)
value|workitem_free((struct worklist *)item, type)
end_define

begin_function
specifier|static
name|void
name|worklist_insert
parameter_list|(
name|head
parameter_list|,
name|item
parameter_list|)
name|struct
name|workhead
modifier|*
name|head
decl_stmt|;
name|struct
name|worklist
modifier|*
name|item
decl_stmt|;
block|{
if|if
condition|(
name|lk
operator|.
name|lkt_held
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"worklist_insert: lock not held"
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|wk_state
operator|&
name|ONWORKLIST
condition|)
block|{
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"worklist_insert: already on list"
argument_list|)
expr_stmt|;
block|}
name|item
operator|->
name|wk_state
operator||=
name|ONWORKLIST
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|head
argument_list|,
name|item
argument_list|,
name|wk_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|worklist_remove
parameter_list|(
name|item
parameter_list|)
name|struct
name|worklist
modifier|*
name|item
decl_stmt|;
block|{
if|if
condition|(
name|lk
operator|.
name|lkt_held
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"worklist_remove: lock not held"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|item
operator|->
name|wk_state
operator|&
name|ONWORKLIST
operator|)
operator|==
literal|0
condition|)
block|{
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"worklist_remove: not on list"
argument_list|)
expr_stmt|;
block|}
name|item
operator|->
name|wk_state
operator|&=
operator|~
name|ONWORKLIST
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|item
argument_list|,
name|wk_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|workitem_free
parameter_list|(
name|item
parameter_list|,
name|type
parameter_list|)
name|struct
name|worklist
modifier|*
name|item
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
if|if
condition|(
name|item
operator|->
name|wk_state
operator|&
name|ONWORKLIST
condition|)
block|{
if|if
condition|(
name|lk
operator|.
name|lkt_held
operator|!=
operator|-
literal|1
condition|)
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"workitem_free: still on list"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|item
operator|->
name|wk_type
operator|!=
name|type
condition|)
block|{
if|if
condition|(
name|lk
operator|.
name|lkt_held
operator|!=
operator|-
literal|1
condition|)
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"workitem_free: type mismatch"
argument_list|)
expr_stmt|;
block|}
name|FREE
argument_list|(
name|item
argument_list|,
name|DtoM
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_comment
comment|/*  * Workitem queue management  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|workhead
name|softdep_workitem_pending
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|num_on_worklist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of worklist items to be processed */
end_comment

begin_decl_stmt
specifier|static
name|int
name|softdep_worklist_busy
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 => trying to do unmount */
end_comment

begin_decl_stmt
specifier|static
name|int
name|softdep_worklist_req
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* serialized waiters */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_softdeps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum number of structs before slowdown */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tickdelay
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of ticks to pause during slowdown */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|stat_countp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* statistic to count in proc_waiting timeout */
end_comment

begin_decl_stmt
specifier|static
name|int
name|proc_waiting
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tracks whether we have a timeout posted */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|callout_handle
name|handle
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* handle on posted proc_waiting timeout */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|proc
modifier|*
name|filesys_syncer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* proc of filesystem syncer process */
end_comment

begin_decl_stmt
specifier|static
name|int
name|req_clear_inodedeps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* syncer process flush some inodedeps */
end_comment

begin_define
define|#
directive|define
name|FLUSH_INODES
value|1
end_define

begin_decl_stmt
specifier|static
name|int
name|req_clear_remove
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* syncer process flush some freeblks */
end_comment

begin_define
define|#
directive|define
name|FLUSH_REMOVE
value|2
end_define

begin_comment
comment|/*  * runtime statistics  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stat_worklist_push
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of worklist cleanups */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stat_blk_limit_push
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of times block limit neared */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stat_ino_limit_push
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of times inode limit neared */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stat_blk_limit_hit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of times block slowdown imposed */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stat_ino_limit_hit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of times inode slowdown imposed */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stat_sync_limit_hit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of synchronous slowdowns imposed */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stat_indir_blk_ptrs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bufs redirtied as indir ptrs not written */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stat_inode_bitmap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bufs redirtied as inode bitmap not written */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stat_direct_blk_ptrs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bufs redirtied as direct ptrs not written */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stat_dir_entry
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bufs redirtied as dir entry cannot write */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|max_softdeps
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|max_softdeps
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|tickdelay
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|tickdelay
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|worklist_push
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|stat_worklist_push
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|blk_limit_push
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|stat_blk_limit_push
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|ino_limit_push
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|stat_ino_limit_push
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|blk_limit_hit
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|stat_blk_limit_hit
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|ino_limit_hit
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|stat_ino_limit_hit
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|sync_limit_hit
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|stat_sync_limit_hit
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|indir_blk_ptrs
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|stat_indir_blk_ptrs
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|inode_bitmap
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|stat_inode_bitmap
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|direct_blk_ptrs
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|stat_direct_blk_ptrs
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|dir_entry
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|stat_dir_entry
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_comment
comment|/*  * Add an item to the end of the work queue.  * This routine requires that the lock be held.  * This is the only routine that adds items to the list.  * The following routine is the only one that removes items  * and does so in order from first to last.  */
end_comment

begin_function
specifier|static
name|void
name|add_to_worklist
parameter_list|(
name|wk
parameter_list|)
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
block|{
specifier|static
name|struct
name|worklist
modifier|*
name|worklist_tail
decl_stmt|;
if|if
condition|(
name|wk
operator|->
name|wk_state
operator|&
name|ONWORKLIST
condition|)
block|{
if|if
condition|(
name|lk
operator|.
name|lkt_held
operator|!=
operator|-
literal|1
condition|)
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"add_to_worklist: already on list"
argument_list|)
expr_stmt|;
block|}
name|wk
operator|->
name|wk_state
operator||=
name|ONWORKLIST
expr_stmt|;
if|if
condition|(
name|LIST_FIRST
argument_list|(
operator|&
name|softdep_workitem_pending
argument_list|)
operator|==
name|NULL
condition|)
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|softdep_workitem_pending
argument_list|,
name|wk
argument_list|,
name|wk_list
argument_list|)
expr_stmt|;
else|else
name|LIST_INSERT_AFTER
argument_list|(
name|worklist_tail
argument_list|,
name|wk
argument_list|,
name|wk_list
argument_list|)
expr_stmt|;
name|worklist_tail
operator|=
name|wk
expr_stmt|;
name|num_on_worklist
operator|+=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process that runs once per second to handle items in the background queue.  *  * Note that we ensure that everything is done in the order in which they  * appear in the queue. The code below depends on this property to ensure  * that blocks of a file are freed before the inode itself is freed. This  * ordering ensures that no new<vfsid, inum, lbn> triples will be generated  * until all the old ones have been purged from the dependency lists.  */
end_comment

begin_function
specifier|static
name|int
name|softdep_process_worklist
parameter_list|(
name|matchmnt
parameter_list|)
name|struct
name|mount
modifier|*
name|matchmnt
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|CURPROC
decl_stmt|;
name|int
name|matchcnt
decl_stmt|,
name|loopcount
decl_stmt|;
name|long
name|starttime
decl_stmt|;
comment|/* 	 * Record the process identifier of our caller so that we can give 	 * this process preferential treatment in request_cleanup below. 	 */
name|filesys_syncer
operator|=
name|p
expr_stmt|;
name|matchcnt
operator|=
literal|0
expr_stmt|;
comment|/* 	 * There is no danger of having multiple processes run this 	 * code, but we have to single-thread it when softdep_flushfiles() 	 * is in operation to get an accurate count of the number of items 	 * related to its mount point that are in the list. 	 */
if|if
condition|(
name|matchmnt
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|softdep_worklist_busy
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|softdep_worklist_busy
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* 	 * If requested, try removing inode or removal dependencies. 	 */
if|if
condition|(
name|req_clear_inodedeps
condition|)
block|{
name|clear_inodedeps
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|req_clear_inodedeps
operator|-=
literal|1
expr_stmt|;
name|wakeup_one
argument_list|(
operator|&
name|proc_waiting
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|req_clear_remove
condition|)
block|{
name|clear_remove
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|req_clear_remove
operator|-=
literal|1
expr_stmt|;
name|wakeup_one
argument_list|(
operator|&
name|proc_waiting
argument_list|)
expr_stmt|;
block|}
name|loopcount
operator|=
literal|1
expr_stmt|;
name|starttime
operator|=
name|time_second
expr_stmt|;
while|while
condition|(
name|num_on_worklist
operator|>
literal|0
condition|)
block|{
name|matchcnt
operator|+=
name|process_worklist_item
argument_list|(
name|matchmnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * If a umount operation wants to run the worklist 		 * accurately, abort. 		 */
if|if
condition|(
name|softdep_worklist_req
operator|&&
name|matchmnt
operator|==
name|NULL
condition|)
block|{
name|matchcnt
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
comment|/* 		 * If requested, try removing inode or removal dependencies. 		 */
if|if
condition|(
name|req_clear_inodedeps
condition|)
block|{
name|clear_inodedeps
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|req_clear_inodedeps
operator|-=
literal|1
expr_stmt|;
name|wakeup_one
argument_list|(
operator|&
name|proc_waiting
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|req_clear_remove
condition|)
block|{
name|clear_remove
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|req_clear_remove
operator|-=
literal|1
expr_stmt|;
name|wakeup_one
argument_list|(
operator|&
name|proc_waiting
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * We do not generally want to stop for buffer space, but if 		 * we are really being a buffer hog, we will stop and wait. 		 */
if|if
condition|(
name|loopcount
operator|++
operator|%
literal|128
operator|==
literal|0
condition|)
name|bwillwrite
argument_list|()
expr_stmt|;
comment|/* 		 * Never allow processing to run for more than one 		 * second. Otherwise the other syncer tasks may get 		 * excessively backlogged. 		 */
if|if
condition|(
name|starttime
operator|!=
name|time_second
operator|&&
name|matchmnt
operator|==
name|NULL
condition|)
block|{
name|matchcnt
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|matchmnt
operator|==
name|NULL
condition|)
block|{
operator|--
name|softdep_worklist_busy
expr_stmt|;
if|if
condition|(
name|softdep_worklist_req
operator|&&
name|softdep_worklist_busy
operator|==
literal|0
condition|)
name|wakeup
argument_list|(
operator|&
name|softdep_worklist_req
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|matchcnt
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process one item on the worklist.  */
end_comment

begin_function
specifier|static
name|int
name|process_worklist_item
parameter_list|(
name|matchmnt
parameter_list|,
name|flags
parameter_list|)
name|struct
name|mount
modifier|*
name|matchmnt
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
name|struct
name|dirrem
modifier|*
name|dirrem
decl_stmt|;
name|struct
name|fs
modifier|*
name|matchfs
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|matchcnt
init|=
literal|0
decl_stmt|;
name|matchfs
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|matchmnt
operator|!=
name|NULL
condition|)
name|matchfs
operator|=
name|VFSTOUFS
argument_list|(
name|matchmnt
argument_list|)
operator|->
name|um_fs
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
comment|/* 	 * Normally we just process each item on the worklist in order. 	 * However, if we are in a situation where we cannot lock any 	 * inodes, we have to skip over any dirrem requests whose 	 * vnodes are resident and locked. 	 */
name|LIST_FOREACH
argument_list|(
argument|wk
argument_list|,
argument|&softdep_workitem_pending
argument_list|,
argument|wk_list
argument_list|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|LK_NOWAIT
operator|)
operator|==
literal|0
operator|||
name|wk
operator|->
name|wk_type
operator|!=
name|D_DIRREM
condition|)
break|break;
name|dirrem
operator|=
name|WK_DIRREM
argument_list|(
name|wk
argument_list|)
expr_stmt|;
name|vp
operator|=
name|ufs_ihashlookup
argument_list|(
name|VFSTOUFS
argument_list|(
name|dirrem
operator|->
name|dm_mnt
argument_list|)
operator|->
name|um_dev
argument_list|,
name|dirrem
operator|->
name|dm_oldinum
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|==
name|NULL
operator|||
operator|!
name|VOP_ISLOCKED
argument_list|(
name|vp
argument_list|,
name|CURPROC
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|wk
operator|==
literal|0
condition|)
block|{
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|WORKLIST_REMOVE
argument_list|(
name|wk
argument_list|)
expr_stmt|;
name|num_on_worklist
operator|-=
literal|1
expr_stmt|;
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|wk
operator|->
name|wk_type
condition|)
block|{
case|case
name|D_DIRREM
case|:
comment|/* removal of a directory entry */
if|if
condition|(
name|WK_DIRREM
argument_list|(
name|wk
argument_list|)
operator|->
name|dm_mnt
operator|==
name|matchmnt
condition|)
name|matchcnt
operator|+=
literal|1
expr_stmt|;
name|handle_workitem_remove
argument_list|(
name|WK_DIRREM
argument_list|(
name|wk
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|D_FREEBLKS
case|:
comment|/* releasing blocks and/or fragments from a file */
if|if
condition|(
name|WK_FREEBLKS
argument_list|(
name|wk
argument_list|)
operator|->
name|fb_fs
operator|==
name|matchfs
condition|)
name|matchcnt
operator|+=
literal|1
expr_stmt|;
name|handle_workitem_freeblocks
argument_list|(
name|WK_FREEBLKS
argument_list|(
name|wk
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|D_FREEFRAG
case|:
comment|/* releasing a fragment when replaced as a file grows */
if|if
condition|(
name|WK_FREEFRAG
argument_list|(
name|wk
argument_list|)
operator|->
name|ff_fs
operator|==
name|matchfs
condition|)
name|matchcnt
operator|+=
literal|1
expr_stmt|;
name|handle_workitem_freefrag
argument_list|(
name|WK_FREEFRAG
argument_list|(
name|wk
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|D_FREEFILE
case|:
comment|/* releasing an inode when its link count drops to 0 */
if|if
condition|(
name|WK_FREEFILE
argument_list|(
name|wk
argument_list|)
operator|->
name|fx_fs
operator|==
name|matchfs
condition|)
name|matchcnt
operator|+=
literal|1
expr_stmt|;
name|handle_workitem_freefile
argument_list|(
name|WK_FREEFILE
argument_list|(
name|wk
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"%s_process_worklist: Unknown type %s"
argument_list|,
literal|"softdep"
argument_list|,
name|TYPENAME
argument_list|(
name|wk
operator|->
name|wk_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
return|return
operator|(
name|matchcnt
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Move dependencies from one buffer to another.  */
end_comment

begin_function
specifier|static
name|void
name|softdep_move_dependencies
parameter_list|(
name|oldbp
parameter_list|,
name|newbp
parameter_list|)
name|struct
name|buf
modifier|*
name|oldbp
decl_stmt|;
name|struct
name|buf
modifier|*
name|newbp
decl_stmt|;
block|{
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|,
modifier|*
name|wktail
decl_stmt|;
if|if
condition|(
name|LIST_FIRST
argument_list|(
operator|&
name|newbp
operator|->
name|b_dep
argument_list|)
operator|!=
name|NULL
condition|)
name|panic
argument_list|(
literal|"softdep_move_dependencies: need merge code"
argument_list|)
expr_stmt|;
name|wktail
operator|=
literal|0
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|wk
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|oldbp
operator|->
name|b_dep
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|wk
argument_list|,
name|wk_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|wktail
operator|==
literal|0
condition|)
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|newbp
operator|->
name|b_dep
argument_list|,
name|wk
argument_list|,
name|wk_list
argument_list|)
expr_stmt|;
else|else
name|LIST_INSERT_AFTER
argument_list|(
name|wktail
argument_list|,
name|wk
argument_list|,
name|wk_list
argument_list|)
expr_stmt|;
name|wktail
operator|=
name|wk
expr_stmt|;
block|}
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Purge the work list of all items associated with a particular mount point.  */
end_comment

begin_function
name|int
name|softdep_flushfiles
parameter_list|(
name|oldmnt
parameter_list|,
name|flags
parameter_list|,
name|p
parameter_list|)
name|struct
name|mount
modifier|*
name|oldmnt
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|devvp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|loopcnt
decl_stmt|;
comment|/* 	 * Await our turn to clear out the queue, then serialize access. 	 */
while|while
condition|(
name|softdep_worklist_busy
operator|!=
literal|0
condition|)
block|{
name|softdep_worklist_req
operator|+=
literal|1
expr_stmt|;
name|tsleep
argument_list|(
operator|&
name|softdep_worklist_req
argument_list|,
name|PRIBIO
argument_list|,
literal|"softflush"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|softdep_worklist_req
operator|-=
literal|1
expr_stmt|;
block|}
name|softdep_worklist_busy
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ffs_flushfiles
argument_list|(
name|oldmnt
argument_list|,
name|flags
argument_list|,
name|p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|softdep_worklist_busy
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|softdep_worklist_req
condition|)
name|wakeup
argument_list|(
operator|&
name|softdep_worklist_req
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Alternately flush the block device associated with the mount 	 * point and process any dependencies that the flushing 	 * creates. In theory, this loop can happen at most twice, 	 * but we give it a few extra just to be sure. 	 */
name|devvp
operator|=
name|VFSTOUFS
argument_list|(
name|oldmnt
argument_list|)
operator|->
name|um_devvp
expr_stmt|;
for|for
control|(
name|loopcnt
operator|=
literal|10
init|;
name|loopcnt
operator|>
literal|0
condition|;
control|)
block|{
if|if
condition|(
name|softdep_process_worklist
argument_list|(
name|oldmnt
argument_list|)
operator|==
literal|0
condition|)
block|{
name|loopcnt
operator|--
expr_stmt|;
comment|/* 			 * Do another flush in case any vnodes were brought in 			 * as part of the cleanup operations. 			 */
if|if
condition|(
operator|(
name|error
operator|=
name|ffs_flushfiles
argument_list|(
name|oldmnt
argument_list|,
name|flags
argument_list|,
name|p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
comment|/* 			 * If we still found nothing to do, we are really done. 			 */
if|if
condition|(
name|softdep_process_worklist
argument_list|(
name|oldmnt
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
name|vn_lock
argument_list|(
name|devvp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_FSYNC
argument_list|(
name|devvp
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
name|MNT_WAIT
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|devvp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
name|softdep_worklist_busy
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|softdep_worklist_req
condition|)
name|wakeup
argument_list|(
operator|&
name|softdep_worklist_req
argument_list|)
expr_stmt|;
comment|/* 	 * If we are unmounting then it is an error to fail. If we 	 * are simply trying to downgrade to read-only, then filesystem 	 * activity can keep us busy forever, so we just fail with EBUSY. 	 */
if|if
condition|(
name|loopcnt
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|oldmnt
operator|->
name|mnt_kern_flag
operator|&
name|MNTK_UNMOUNT
condition|)
name|panic
argument_list|(
literal|"softdep_flushfiles: looping"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Structure hashing.  *   * There are three types of structures that can be looked up:  *	1) pagedep structures identified by mount point, inode number,  *	   and logical block.  *	2) inodedep structures identified by mount point and inode number.  *	3) newblk structures identified by mount point and  *	   physical block number.  *  * The "pagedep" and "inodedep" dependency structures are hashed  * separately from the file blocks and inodes to which they correspond.  * This separation helps when the in-memory copy of an inode or  * file block must be replaced. It also obviates the need to access  * an inode or file page when simply updating (or de-allocating)  * dependency structures. Lookup of newblk structures is needed to  * find newly allocated blocks when trying to associate them with  * their allocdirect or allocindir structure.  *  * The lookup routines optionally create and hash a new instance when  * an existing entry is not found.  */
end_comment

begin_define
define|#
directive|define
name|DEPALLOC
value|0x0001
end_define

begin_comment
comment|/* allocate structure if lookup fails */
end_comment

begin_define
define|#
directive|define
name|NODELAY
value|0x0002
end_define

begin_comment
comment|/* cannot do background work */
end_comment

begin_comment
comment|/*  * Structures and routines associated with pagedep caching.  */
end_comment

begin_expr_stmt
name|LIST_HEAD
argument_list|(
name|pagedep_hashhead
argument_list|,
name|pagedep
argument_list|)
operator|*
name|pagedep_hashtbl
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|u_long
name|pagedep_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of hash table - 1 */
end_comment

begin_define
define|#
directive|define
name|PAGEDEP_HASH
parameter_list|(
name|mp
parameter_list|,
name|inum
parameter_list|,
name|lbn
parameter_list|)
define|\
value|(&pagedep_hashtbl[((((register_t)(mp))>> 13) + (inum) + (lbn))& \ 	    pagedep_hash])
end_define

begin_decl_stmt
specifier|static
name|struct
name|sema
name|pagedep_in_progress
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Look up a pagedep. Return 1 if found, 0 if not found.  * If not found, allocate if DEPALLOC flag is passed.  * Found or allocated entry is returned in pagedeppp.  * This routine must be called with splbio interrupts blocked.  */
end_comment

begin_function
specifier|static
name|int
name|pagedep_lookup
parameter_list|(
name|ip
parameter_list|,
name|lbn
parameter_list|,
name|flags
parameter_list|,
name|pagedeppp
parameter_list|)
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|ufs_lbn_t
name|lbn
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|struct
name|pagedep
modifier|*
modifier|*
name|pagedeppp
decl_stmt|;
block|{
name|struct
name|pagedep
modifier|*
name|pagedep
decl_stmt|;
name|struct
name|pagedep_hashhead
modifier|*
name|pagedephd
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|lk
operator|.
name|lkt_held
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"pagedep_lookup: lock not held"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mp
operator|=
name|ITOV
argument_list|(
name|ip
argument_list|)
operator|->
name|v_mount
expr_stmt|;
name|pagedephd
operator|=
name|PAGEDEP_HASH
argument_list|(
name|mp
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
name|lbn
argument_list|)
expr_stmt|;
name|top
label|:
name|LIST_FOREACH
argument_list|(
argument|pagedep
argument_list|,
argument|pagedephd
argument_list|,
argument|pd_hash
argument_list|)
if|if
condition|(
name|ip
operator|->
name|i_number
operator|==
name|pagedep
operator|->
name|pd_ino
operator|&&
name|lbn
operator|==
name|pagedep
operator|->
name|pd_lbn
operator|&&
name|mp
operator|==
name|pagedep
operator|->
name|pd_mnt
condition|)
break|break;
if|if
condition|(
name|pagedep
condition|)
block|{
operator|*
name|pagedeppp
operator|=
name|pagedep
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|DEPALLOC
operator|)
operator|==
literal|0
condition|)
block|{
operator|*
name|pagedeppp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|sema_get
argument_list|(
operator|&
name|pagedep_in_progress
argument_list|,
operator|&
name|lk
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|MALLOC
argument_list|(
name|pagedep
argument_list|,
expr|struct
name|pagedep
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pagedep
argument_list|)
argument_list|,
name|M_PAGEDEP
argument_list|,
name|M_SOFTDEP_FLAGS
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|pagedep
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pagedep
argument_list|)
argument_list|)
expr_stmt|;
name|pagedep
operator|->
name|pd_list
operator|.
name|wk_type
operator|=
name|D_PAGEDEP
expr_stmt|;
name|pagedep
operator|->
name|pd_mnt
operator|=
name|mp
expr_stmt|;
name|pagedep
operator|->
name|pd_ino
operator|=
name|ip
operator|->
name|i_number
expr_stmt|;
name|pagedep
operator|->
name|pd_lbn
operator|=
name|lbn
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|pagedep
operator|->
name|pd_dirremhd
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|pagedep
operator|->
name|pd_pendinghd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DAHASHSZ
condition|;
name|i
operator|++
control|)
name|LIST_INIT
argument_list|(
operator|&
name|pagedep
operator|->
name|pd_diraddhd
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|pagedephd
argument_list|,
name|pagedep
argument_list|,
name|pd_hash
argument_list|)
expr_stmt|;
name|sema_release
argument_list|(
operator|&
name|pagedep_in_progress
argument_list|)
expr_stmt|;
operator|*
name|pagedeppp
operator|=
name|pagedep
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Structures and routines associated with inodedep caching.  */
end_comment

begin_expr_stmt
name|LIST_HEAD
argument_list|(
name|inodedep_hashhead
argument_list|,
name|inodedep
argument_list|)
operator|*
name|inodedep_hashtbl
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_long
name|inodedep_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of hash table - 1 */
end_comment

begin_decl_stmt
specifier|static
name|long
name|num_inodedep
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of inodedep allocated */
end_comment

begin_define
define|#
directive|define
name|INODEDEP_HASH
parameter_list|(
name|fs
parameter_list|,
name|inum
parameter_list|)
define|\
value|(&inodedep_hashtbl[((((register_t)(fs))>> 13) + (inum))& inodedep_hash])
end_define

begin_decl_stmt
specifier|static
name|struct
name|sema
name|inodedep_in_progress
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Look up a inodedep. Return 1 if found, 0 if not found.  * If not found, allocate if DEPALLOC flag is passed.  * Found or allocated entry is returned in inodedeppp.  * This routine must be called with splbio interrupts blocked.  */
end_comment

begin_function
specifier|static
name|int
name|inodedep_lookup
parameter_list|(
name|fs
parameter_list|,
name|inum
parameter_list|,
name|flags
parameter_list|,
name|inodedeppp
parameter_list|)
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|ino_t
name|inum
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|struct
name|inodedep
modifier|*
modifier|*
name|inodedeppp
decl_stmt|;
block|{
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|inodedep_hashhead
modifier|*
name|inodedephd
decl_stmt|;
name|int
name|firsttry
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|lk
operator|.
name|lkt_held
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"inodedep_lookup: lock not held"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|firsttry
operator|=
literal|1
expr_stmt|;
name|inodedephd
operator|=
name|INODEDEP_HASH
argument_list|(
name|fs
argument_list|,
name|inum
argument_list|)
expr_stmt|;
name|top
label|:
name|LIST_FOREACH
argument_list|(
argument|inodedep
argument_list|,
argument|inodedephd
argument_list|,
argument|id_hash
argument_list|)
if|if
condition|(
name|inum
operator|==
name|inodedep
operator|->
name|id_ino
operator|&&
name|fs
operator|==
name|inodedep
operator|->
name|id_fs
condition|)
break|break;
if|if
condition|(
name|inodedep
condition|)
block|{
operator|*
name|inodedeppp
operator|=
name|inodedep
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|DEPALLOC
operator|)
operator|==
literal|0
condition|)
block|{
operator|*
name|inodedeppp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If we are over our limit, try to improve the situation. 	 */
if|if
condition|(
name|num_inodedep
operator|>
name|max_softdeps
operator|&&
name|firsttry
operator|&&
name|speedup_syncer
argument_list|()
operator|==
literal|0
operator|&&
operator|(
name|flags
operator|&
name|NODELAY
operator|)
operator|==
literal|0
operator|&&
name|request_cleanup
argument_list|(
name|FLUSH_INODES
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|firsttry
operator|=
literal|0
expr_stmt|;
goto|goto
name|top
goto|;
block|}
if|if
condition|(
name|sema_get
argument_list|(
operator|&
name|inodedep_in_progress
argument_list|,
operator|&
name|lk
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|num_inodedep
operator|+=
literal|1
expr_stmt|;
name|MALLOC
argument_list|(
name|inodedep
argument_list|,
expr|struct
name|inodedep
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|inodedep
argument_list|)
argument_list|,
name|M_INODEDEP
argument_list|,
name|M_SOFTDEP_FLAGS
argument_list|)
expr_stmt|;
name|inodedep
operator|->
name|id_list
operator|.
name|wk_type
operator|=
name|D_INODEDEP
expr_stmt|;
name|inodedep
operator|->
name|id_fs
operator|=
name|fs
expr_stmt|;
name|inodedep
operator|->
name|id_ino
operator|=
name|inum
expr_stmt|;
name|inodedep
operator|->
name|id_state
operator|=
name|ALLCOMPLETE
expr_stmt|;
name|inodedep
operator|->
name|id_nlinkdelta
operator|=
literal|0
expr_stmt|;
name|inodedep
operator|->
name|id_savedino
operator|=
name|NULL
expr_stmt|;
name|inodedep
operator|->
name|id_savedsize
operator|=
operator|-
literal|1
expr_stmt|;
name|inodedep
operator|->
name|id_buf
operator|=
name|NULL
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|inodedep
operator|->
name|id_pendinghd
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inowait
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|inodedep
operator|->
name|id_bufwait
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoupdt
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|inodedep
operator|->
name|id_newinoupdt
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|inodedephd
argument_list|,
name|inodedep
argument_list|,
name|id_hash
argument_list|)
expr_stmt|;
name|sema_release
argument_list|(
operator|&
name|inodedep_in_progress
argument_list|)
expr_stmt|;
operator|*
name|inodedeppp
operator|=
name|inodedep
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Structures and routines associated with newblk caching.  */
end_comment

begin_expr_stmt
name|LIST_HEAD
argument_list|(
name|newblk_hashhead
argument_list|,
name|newblk
argument_list|)
operator|*
name|newblk_hashtbl
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|u_long
name|newblk_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of hash table - 1 */
end_comment

begin_define
define|#
directive|define
name|NEWBLK_HASH
parameter_list|(
name|fs
parameter_list|,
name|inum
parameter_list|)
define|\
value|(&newblk_hashtbl[((((register_t)(fs))>> 13) + (inum))& newblk_hash])
end_define

begin_decl_stmt
specifier|static
name|struct
name|sema
name|newblk_in_progress
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Look up a newblk. Return 1 if found, 0 if not found.  * If not found, allocate if DEPALLOC flag is passed.  * Found or allocated entry is returned in newblkpp.  */
end_comment

begin_function
specifier|static
name|int
name|newblk_lookup
parameter_list|(
name|fs
parameter_list|,
name|newblkno
parameter_list|,
name|flags
parameter_list|,
name|newblkpp
parameter_list|)
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|ufs_daddr_t
name|newblkno
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|struct
name|newblk
modifier|*
modifier|*
name|newblkpp
decl_stmt|;
block|{
name|struct
name|newblk
modifier|*
name|newblk
decl_stmt|;
name|struct
name|newblk_hashhead
modifier|*
name|newblkhd
decl_stmt|;
name|newblkhd
operator|=
name|NEWBLK_HASH
argument_list|(
name|fs
argument_list|,
name|newblkno
argument_list|)
expr_stmt|;
name|top
label|:
name|LIST_FOREACH
argument_list|(
argument|newblk
argument_list|,
argument|newblkhd
argument_list|,
argument|nb_hash
argument_list|)
if|if
condition|(
name|newblkno
operator|==
name|newblk
operator|->
name|nb_newblkno
operator|&&
name|fs
operator|==
name|newblk
operator|->
name|nb_fs
condition|)
break|break;
if|if
condition|(
name|newblk
condition|)
block|{
operator|*
name|newblkpp
operator|=
name|newblk
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|DEPALLOC
operator|)
operator|==
literal|0
condition|)
block|{
operator|*
name|newblkpp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|sema_get
argument_list|(
operator|&
name|newblk_in_progress
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|top
goto|;
name|MALLOC
argument_list|(
name|newblk
argument_list|,
expr|struct
name|newblk
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|newblk
argument_list|)
argument_list|,
name|M_NEWBLK
argument_list|,
name|M_SOFTDEP_FLAGS
argument_list|)
expr_stmt|;
name|newblk
operator|->
name|nb_state
operator|=
literal|0
expr_stmt|;
name|newblk
operator|->
name|nb_fs
operator|=
name|fs
expr_stmt|;
name|newblk
operator|->
name|nb_newblkno
operator|=
name|newblkno
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|newblkhd
argument_list|,
name|newblk
argument_list|,
name|nb_hash
argument_list|)
expr_stmt|;
name|sema_release
argument_list|(
operator|&
name|newblk_in_progress
argument_list|)
expr_stmt|;
operator|*
name|newblkpp
operator|=
name|newblk
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Executed during filesystem system initialization before  * mounting any file systems.  */
end_comment

begin_function
name|void
name|softdep_initialize
parameter_list|()
block|{
name|LIST_INIT
argument_list|(
operator|&
name|mkdirlisthd
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|softdep_workitem_pending
argument_list|)
expr_stmt|;
name|max_softdeps
operator|=
name|min
argument_list|(
name|desiredvnodes
operator|*
literal|8
argument_list|,
name|M_INODEDEP
operator|->
name|ks_limit
operator|/
operator|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|inodedep
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|pagedep_hashtbl
operator|=
name|hashinit
argument_list|(
name|desiredvnodes
operator|/
literal|5
argument_list|,
name|M_PAGEDEP
argument_list|,
operator|&
name|pagedep_hash
argument_list|)
expr_stmt|;
name|sema_init
argument_list|(
operator|&
name|pagedep_in_progress
argument_list|,
literal|"pagedep"
argument_list|,
name|PRIBIO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|inodedep_hashtbl
operator|=
name|hashinit
argument_list|(
name|desiredvnodes
argument_list|,
name|M_INODEDEP
argument_list|,
operator|&
name|inodedep_hash
argument_list|)
expr_stmt|;
name|sema_init
argument_list|(
operator|&
name|inodedep_in_progress
argument_list|,
literal|"inodedep"
argument_list|,
name|PRIBIO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|newblk_hashtbl
operator|=
name|hashinit
argument_list|(
literal|64
argument_list|,
name|M_NEWBLK
argument_list|,
operator|&
name|newblk_hash
argument_list|)
expr_stmt|;
name|sema_init
argument_list|(
operator|&
name|newblk_in_progress
argument_list|,
literal|"newblk"
argument_list|,
name|PRIBIO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called at mount time to notify the dependency code that a  * filesystem wishes to use it.  */
end_comment

begin_function
name|int
name|softdep_mount
parameter_list|(
name|devvp
parameter_list|,
name|mp
parameter_list|,
name|fs
parameter_list|,
name|cred
parameter_list|)
name|struct
name|vnode
modifier|*
name|devvp
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
block|{
name|struct
name|csum
name|cstotal
decl_stmt|;
name|struct
name|cg
modifier|*
name|cgp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|cyl
decl_stmt|;
name|mp
operator|->
name|mnt_flag
operator|&=
operator|~
name|MNT_ASYNC
expr_stmt|;
name|mp
operator|->
name|mnt_flag
operator||=
name|MNT_SOFTDEP
expr_stmt|;
comment|/* 	 * When doing soft updates, the counters in the 	 * superblock may have gotten out of sync, so we have 	 * to scan the cylinder groups and recalculate them. 	 */
if|if
condition|(
name|fs
operator|->
name|fs_clean
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|bzero
argument_list|(
operator|&
name|cstotal
argument_list|,
sizeof|sizeof
name|cstotal
argument_list|)
expr_stmt|;
for|for
control|(
name|cyl
operator|=
literal|0
init|;
name|cyl
operator|<
name|fs
operator|->
name|fs_ncg
condition|;
name|cyl
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|bread
argument_list|(
name|devvp
argument_list|,
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|cgtod
argument_list|(
name|fs
argument_list|,
name|cyl
argument_list|)
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_cgsize
argument_list|,
name|cred
argument_list|,
operator|&
name|bp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|cgp
operator|=
operator|(
expr|struct
name|cg
operator|*
operator|)
name|bp
operator|->
name|b_data
expr_stmt|;
name|cstotal
operator|.
name|cs_nffree
operator|+=
name|cgp
operator|->
name|cg_cs
operator|.
name|cs_nffree
expr_stmt|;
name|cstotal
operator|.
name|cs_nbfree
operator|+=
name|cgp
operator|->
name|cg_cs
operator|.
name|cs_nbfree
expr_stmt|;
name|cstotal
operator|.
name|cs_nifree
operator|+=
name|cgp
operator|->
name|cg_cs
operator|.
name|cs_nifree
expr_stmt|;
name|cstotal
operator|.
name|cs_ndir
operator|+=
name|cgp
operator|->
name|cg_cs
operator|.
name|cs_ndir
expr_stmt|;
name|fs
operator|->
name|fs_cs
argument_list|(
name|fs
argument_list|,
name|cyl
argument_list|)
operator|=
name|cgp
operator|->
name|cg_cs
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|cstotal
argument_list|,
operator|&
name|fs
operator|->
name|fs_cstotal
argument_list|,
sizeof|sizeof
name|cstotal
argument_list|)
condition|)
name|printf
argument_list|(
literal|"ffs_mountfs: superblock updated for soft updates\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bcopy
argument_list|(
operator|&
name|cstotal
argument_list|,
operator|&
name|fs
operator|->
name|fs_cstotal
argument_list|,
sizeof|sizeof
name|cstotal
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Protecting the freemaps (or bitmaps).  *   * To eliminate the need to execute fsck before mounting a file system  * after a power failure, one must (conservatively) guarantee that the  * on-disk copy of the bitmaps never indicate that a live inode or block is  * free.  So, when a block or inode is allocated, the bitmap should be  * updated (on disk) before any new pointers.  When a block or inode is  * freed, the bitmap should not be updated until all pointers have been  * reset.  The latter dependency is handled by the delayed de-allocation  * approach described below for block and inode de-allocation.  The former  * dependency is handled by calling the following procedure when a block or  * inode is allocated. When an inode is allocated an "inodedep" is created  * with its DEPCOMPLETE flag cleared until its bitmap is written to disk.  * Each "inodedep" is also inserted into the hash indexing structure so  * that any additional link additions can be made dependent on the inode  * allocation.  *   * The ufs file system maintains a number of free block counts (e.g., per  * cylinder group, per cylinder and per<cylinder, rotational position> pair)  * in addition to the bitmaps.  These counts are used to improve efficiency  * during allocation and therefore must be consistent with the bitmaps.  * There is no convenient way to guarantee post-crash consistency of these  * counts with simple update ordering, for two main reasons: (1) The counts  * and bitmaps for a single cylinder group block are not in the same disk  * sector.  If a disk write is interrupted (e.g., by power failure), one may  * be written and the other not.  (2) Some of the counts are located in the  * superblock rather than the cylinder group block. So, we focus our soft  * updates implementation on protecting the bitmaps. When mounting a  * filesystem, we recompute the auxiliary counts from the bitmaps.  */
end_comment

begin_comment
comment|/*  * Called just after updating the cylinder group block to allocate an inode.  */
end_comment

begin_function
name|void
name|softdep_setup_inomapdep
parameter_list|(
name|bp
parameter_list|,
name|ip
parameter_list|,
name|newinum
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
comment|/* buffer for cylgroup block with inode map */
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
comment|/* inode related to allocation */
name|ino_t
name|newinum
decl_stmt|;
comment|/* new inode number being allocated */
block|{
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|bmsafemap
modifier|*
name|bmsafemap
decl_stmt|;
comment|/* 	 * Create a dependency for the newly allocated inode. 	 * Panic if it already exists as something is seriously wrong. 	 * Otherwise add it to the dependency list for the buffer holding 	 * the cylinder group map from which it was allocated. 	 */
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inodedep_lookup
argument_list|(
name|ip
operator|->
name|i_fs
argument_list|,
name|newinum
argument_list|,
name|DEPALLOC
operator||
name|NODELAY
argument_list|,
operator|&
name|inodedep
argument_list|)
operator|)
condition|)
block|{
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"softdep_setup_inomapdep: found inode"
argument_list|)
expr_stmt|;
block|}
name|inodedep
operator|->
name|id_buf
operator|=
name|bp
expr_stmt|;
name|inodedep
operator|->
name|id_state
operator|&=
operator|~
name|DEPCOMPLETE
expr_stmt|;
name|bmsafemap
operator|=
name|bmsafemap_lookup
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|bmsafemap
operator|->
name|sm_inodedephd
argument_list|,
name|inodedep
argument_list|,
name|id_deps
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called just after updating the cylinder group block to  * allocate block or fragment.  */
end_comment

begin_function
name|void
name|softdep_setup_blkmapdep
parameter_list|(
name|bp
parameter_list|,
name|fs
parameter_list|,
name|newblkno
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
comment|/* buffer for cylgroup block with block map */
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
comment|/* filesystem doing allocation */
name|ufs_daddr_t
name|newblkno
decl_stmt|;
comment|/* number of newly allocated block */
block|{
name|struct
name|newblk
modifier|*
name|newblk
decl_stmt|;
name|struct
name|bmsafemap
modifier|*
name|bmsafemap
decl_stmt|;
comment|/* 	 * Create a dependency for the newly allocated block. 	 * Add it to the dependency list for the buffer holding 	 * the cylinder group map from which it was allocated. 	 */
if|if
condition|(
name|newblk_lookup
argument_list|(
name|fs
argument_list|,
name|newblkno
argument_list|,
name|DEPALLOC
argument_list|,
operator|&
name|newblk
argument_list|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"softdep_setup_blkmapdep: found block"
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|newblk
operator|->
name|nb_bmsafemap
operator|=
name|bmsafemap
operator|=
name|bmsafemap_lookup
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|bmsafemap
operator|->
name|sm_newblkhd
argument_list|,
name|newblk
argument_list|,
name|nb_deps
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find the bmsafemap associated with a cylinder group buffer.  * If none exists, create one. The buffer must be locked when  * this routine is called and this routine must be called with  * splbio interrupts blocked.  */
end_comment

begin_function
specifier|static
name|struct
name|bmsafemap
modifier|*
name|bmsafemap_lookup
parameter_list|(
name|bp
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
name|struct
name|bmsafemap
modifier|*
name|bmsafemap
decl_stmt|;
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|lk
operator|.
name|lkt_held
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"bmsafemap_lookup: lock not held"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|LIST_FOREACH
argument_list|(
argument|wk
argument_list|,
argument|&bp->b_dep
argument_list|,
argument|wk_list
argument_list|)
if|if
condition|(
name|wk
operator|->
name|wk_type
operator|==
name|D_BMSAFEMAP
condition|)
return|return
operator|(
name|WK_BMSAFEMAP
argument_list|(
name|wk
argument_list|)
operator|)
return|;
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|bmsafemap
argument_list|,
expr|struct
name|bmsafemap
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bmsafemap
argument_list|)
argument_list|,
name|M_BMSAFEMAP
argument_list|,
name|M_SOFTDEP_FLAGS
argument_list|)
expr_stmt|;
name|bmsafemap
operator|->
name|sm_list
operator|.
name|wk_type
operator|=
name|D_BMSAFEMAP
expr_stmt|;
name|bmsafemap
operator|->
name|sm_list
operator|.
name|wk_state
operator|=
literal|0
expr_stmt|;
name|bmsafemap
operator|->
name|sm_buf
operator|=
name|bp
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|bmsafemap
operator|->
name|sm_allocdirecthd
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|bmsafemap
operator|->
name|sm_allocindirhd
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|bmsafemap
operator|->
name|sm_inodedephd
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|bmsafemap
operator|->
name|sm_newblkhd
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|WORKLIST_INSERT
argument_list|(
operator|&
name|bp
operator|->
name|b_dep
argument_list|,
operator|&
name|bmsafemap
operator|->
name|sm_list
argument_list|)
expr_stmt|;
return|return
operator|(
name|bmsafemap
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Direct block allocation dependencies.  *   * When a new block is allocated, the corresponding disk locations must be  * initialized (with zeros or new data) before the on-disk inode points to  * them.  Also, the freemap from which the block was allocated must be  * updated (on disk) before the inode's pointer. These two dependencies are  * independent of each other and are needed for all file blocks and indirect  * blocks that are pointed to directly by the inode.  Just before the  * "in-core" version of the inode is updated with a newly allocated block  * number, a procedure (below) is called to setup allocation dependency  * structures.  These structures are removed when the corresponding  * dependencies are satisfied or when the block allocation becomes obsolete  * (i.e., the file is deleted, the block is de-allocated, or the block is a  * fragment that gets upgraded).  All of these cases are handled in  * procedures described later.  *   * When a file extension causes a fragment to be upgraded, either to a larger  * fragment or to a full block, the on-disk location may change (if the  * previous fragment could not simply be extended). In this case, the old  * fragment must be de-allocated, but not until after the inode's pointer has  * been updated. In most cases, this is handled by later procedures, which  * will construct a "freefrag" structure to be added to the workitem queue  * when the inode update is complete (or obsolete).  The main exception to  * this is when an allocation occurs while a pending allocation dependency  * (for the same block pointer) remains.  This case is handled in the main  * allocation dependency setup procedure by immediately freeing the  * unreferenced fragments.  */
end_comment

begin_function
name|void
name|softdep_setup_allocdirect
parameter_list|(
name|ip
parameter_list|,
name|lbn
parameter_list|,
name|newblkno
parameter_list|,
name|oldblkno
parameter_list|,
name|newsize
parameter_list|,
name|oldsize
parameter_list|,
name|bp
parameter_list|)
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
comment|/* inode to which block is being added */
name|ufs_lbn_t
name|lbn
decl_stmt|;
comment|/* block pointer within inode */
name|ufs_daddr_t
name|newblkno
decl_stmt|;
comment|/* disk block number being added */
name|ufs_daddr_t
name|oldblkno
decl_stmt|;
comment|/* previous block number, 0 unless frag */
name|long
name|newsize
decl_stmt|;
comment|/* size of new block */
name|long
name|oldsize
decl_stmt|;
comment|/* size of new block */
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
comment|/* bp for allocated block */
block|{
name|struct
name|allocdirect
modifier|*
name|adp
decl_stmt|,
modifier|*
name|oldadp
decl_stmt|;
name|struct
name|allocdirectlst
modifier|*
name|adphead
decl_stmt|;
name|struct
name|bmsafemap
modifier|*
name|bmsafemap
decl_stmt|;
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|pagedep
modifier|*
name|pagedep
decl_stmt|;
name|struct
name|newblk
modifier|*
name|newblk
decl_stmt|;
name|MALLOC
argument_list|(
name|adp
argument_list|,
expr|struct
name|allocdirect
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|allocdirect
argument_list|)
argument_list|,
name|M_ALLOCDIRECT
argument_list|,
name|M_SOFTDEP_FLAGS
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|adp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|allocdirect
argument_list|)
argument_list|)
expr_stmt|;
name|adp
operator|->
name|ad_list
operator|.
name|wk_type
operator|=
name|D_ALLOCDIRECT
expr_stmt|;
name|adp
operator|->
name|ad_lbn
operator|=
name|lbn
expr_stmt|;
name|adp
operator|->
name|ad_newblkno
operator|=
name|newblkno
expr_stmt|;
name|adp
operator|->
name|ad_oldblkno
operator|=
name|oldblkno
expr_stmt|;
name|adp
operator|->
name|ad_newsize
operator|=
name|newsize
expr_stmt|;
name|adp
operator|->
name|ad_oldsize
operator|=
name|oldsize
expr_stmt|;
name|adp
operator|->
name|ad_state
operator|=
name|ATTACHED
expr_stmt|;
if|if
condition|(
name|newblkno
operator|==
name|oldblkno
condition|)
name|adp
operator|->
name|ad_freefrag
operator|=
name|NULL
expr_stmt|;
else|else
name|adp
operator|->
name|ad_freefrag
operator|=
name|newfreefrag
argument_list|(
name|ip
argument_list|,
name|oldblkno
argument_list|,
name|oldsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|newblk_lookup
argument_list|(
name|ip
operator|->
name|i_fs
argument_list|,
name|newblkno
argument_list|,
literal|0
argument_list|,
operator|&
name|newblk
argument_list|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"softdep_setup_allocdirect: lost block"
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|inodedep_lookup
argument_list|(
name|ip
operator|->
name|i_fs
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
name|DEPALLOC
operator||
name|NODELAY
argument_list|,
operator|&
name|inodedep
argument_list|)
expr_stmt|;
name|adp
operator|->
name|ad_inodedep
operator|=
name|inodedep
expr_stmt|;
if|if
condition|(
name|newblk
operator|->
name|nb_state
operator|==
name|DEPCOMPLETE
condition|)
block|{
name|adp
operator|->
name|ad_state
operator||=
name|DEPCOMPLETE
expr_stmt|;
name|adp
operator|->
name|ad_buf
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|bmsafemap
operator|=
name|newblk
operator|->
name|nb_bmsafemap
expr_stmt|;
name|adp
operator|->
name|ad_buf
operator|=
name|bmsafemap
operator|->
name|sm_buf
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|newblk
argument_list|,
name|nb_deps
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|bmsafemap
operator|->
name|sm_allocdirecthd
argument_list|,
name|adp
argument_list|,
name|ad_deps
argument_list|)
expr_stmt|;
block|}
name|LIST_REMOVE
argument_list|(
name|newblk
argument_list|,
name|nb_hash
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|newblk
argument_list|,
name|M_NEWBLK
argument_list|)
expr_stmt|;
name|WORKLIST_INSERT
argument_list|(
operator|&
name|bp
operator|->
name|b_dep
argument_list|,
operator|&
name|adp
operator|->
name|ad_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|lbn
operator|>=
name|NDADDR
condition|)
block|{
comment|/* allocating an indirect block */
if|if
condition|(
name|oldblkno
operator|!=
literal|0
condition|)
block|{
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"softdep_setup_allocdirect: non-zero indir"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Allocating a direct block. 		 * 		 * If we are allocating a directory block, then we must 		 * allocate an associated pagedep to track additions and 		 * deletions. 		 */
if|if
condition|(
operator|(
name|ip
operator|->
name|i_mode
operator|&
name|IFMT
operator|)
operator|==
name|IFDIR
operator|&&
name|pagedep_lookup
argument_list|(
name|ip
argument_list|,
name|lbn
argument_list|,
name|DEPALLOC
argument_list|,
operator|&
name|pagedep
argument_list|)
operator|==
literal|0
condition|)
name|WORKLIST_INSERT
argument_list|(
operator|&
name|bp
operator|->
name|b_dep
argument_list|,
operator|&
name|pagedep
operator|->
name|pd_list
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The list of allocdirects must be kept in sorted and ascending 	 * order so that the rollback routines can quickly determine the 	 * first uncommitted block (the size of the file stored on disk 	 * ends at the end of the lowest committed fragment, or if there 	 * are no fragments, at the end of the highest committed block). 	 * Since files generally grow, the typical case is that the new 	 * block is to be added at the end of the list. We speed this 	 * special case by checking against the last allocdirect in the 	 * list before laboriously traversing the list looking for the 	 * insertion point. 	 */
name|adphead
operator|=
operator|&
name|inodedep
operator|->
name|id_newinoupdt
expr_stmt|;
name|oldadp
operator|=
name|TAILQ_LAST
argument_list|(
name|adphead
argument_list|,
name|allocdirectlst
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldadp
operator|==
name|NULL
operator|||
name|oldadp
operator|->
name|ad_lbn
operator|<=
name|lbn
condition|)
block|{
comment|/* insert at end of list */
name|TAILQ_INSERT_TAIL
argument_list|(
name|adphead
argument_list|,
name|adp
argument_list|,
name|ad_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldadp
operator|!=
name|NULL
operator|&&
name|oldadp
operator|->
name|ad_lbn
operator|==
name|lbn
condition|)
name|allocdirect_merge
argument_list|(
name|adphead
argument_list|,
name|adp
argument_list|,
name|oldadp
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
return|return;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|oldadp
argument_list|,
argument|adphead
argument_list|,
argument|ad_next
argument_list|)
block|{
if|if
condition|(
name|oldadp
operator|->
name|ad_lbn
operator|>=
name|lbn
condition|)
break|break;
block|}
if|if
condition|(
name|oldadp
operator|==
name|NULL
condition|)
block|{
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"softdep_setup_allocdirect: lost entry"
argument_list|)
expr_stmt|;
block|}
comment|/* insert in middle of list */
name|TAILQ_INSERT_BEFORE
argument_list|(
name|oldadp
argument_list|,
name|adp
argument_list|,
name|ad_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldadp
operator|->
name|ad_lbn
operator|==
name|lbn
condition|)
name|allocdirect_merge
argument_list|(
name|adphead
argument_list|,
name|adp
argument_list|,
name|oldadp
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Replace an old allocdirect dependency with a newer one.  * This routine must be called with splbio interrupts blocked.  */
end_comment

begin_function
specifier|static
name|void
name|allocdirect_merge
parameter_list|(
name|adphead
parameter_list|,
name|newadp
parameter_list|,
name|oldadp
parameter_list|)
name|struct
name|allocdirectlst
modifier|*
name|adphead
decl_stmt|;
comment|/* head of list holding allocdirects */
name|struct
name|allocdirect
modifier|*
name|newadp
decl_stmt|;
comment|/* allocdirect being added */
name|struct
name|allocdirect
modifier|*
name|oldadp
decl_stmt|;
comment|/* existing allocdirect being checked */
block|{
name|struct
name|freefrag
modifier|*
name|freefrag
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|lk
operator|.
name|lkt_held
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"allocdirect_merge: lock not held"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|newadp
operator|->
name|ad_oldblkno
operator|!=
name|oldadp
operator|->
name|ad_newblkno
operator|||
name|newadp
operator|->
name|ad_oldsize
operator|!=
name|oldadp
operator|->
name|ad_newsize
operator|||
name|newadp
operator|->
name|ad_lbn
operator|>=
name|NDADDR
condition|)
block|{
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"allocdirect_check: old %d != new %d || lbn %ld>= %d"
argument_list|,
name|newadp
operator|->
name|ad_oldblkno
argument_list|,
name|oldadp
operator|->
name|ad_newblkno
argument_list|,
name|newadp
operator|->
name|ad_lbn
argument_list|,
name|NDADDR
argument_list|)
expr_stmt|;
block|}
name|newadp
operator|->
name|ad_oldblkno
operator|=
name|oldadp
operator|->
name|ad_oldblkno
expr_stmt|;
name|newadp
operator|->
name|ad_oldsize
operator|=
name|oldadp
operator|->
name|ad_oldsize
expr_stmt|;
comment|/* 	 * If the old dependency had a fragment to free or had never 	 * previously had a block allocated, then the new dependency 	 * can immediately post its freefrag and adopt the old freefrag. 	 * This action is done by swapping the freefrag dependencies. 	 * The new dependency gains the old one's freefrag, and the 	 * old one gets the new one and then immediately puts it on 	 * the worklist when it is freed by free_allocdirect. It is 	 * not possible to do this swap when the old dependency had a 	 * non-zero size but no previous fragment to free. This condition 	 * arises when the new block is an extension of the old block. 	 * Here, the first part of the fragment allocated to the new 	 * dependency is part of the block currently claimed on disk by 	 * the old dependency, so cannot legitimately be freed until the 	 * conditions for the new dependency are fulfilled. 	 */
if|if
condition|(
name|oldadp
operator|->
name|ad_freefrag
operator|!=
name|NULL
operator|||
name|oldadp
operator|->
name|ad_oldblkno
operator|==
literal|0
condition|)
block|{
name|freefrag
operator|=
name|newadp
operator|->
name|ad_freefrag
expr_stmt|;
name|newadp
operator|->
name|ad_freefrag
operator|=
name|oldadp
operator|->
name|ad_freefrag
expr_stmt|;
name|oldadp
operator|->
name|ad_freefrag
operator|=
name|freefrag
expr_stmt|;
block|}
name|free_allocdirect
argument_list|(
name|adphead
argument_list|,
name|oldadp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a new freefrag structure if needed.  */
end_comment

begin_function
specifier|static
name|struct
name|freefrag
modifier|*
name|newfreefrag
parameter_list|(
name|ip
parameter_list|,
name|blkno
parameter_list|,
name|size
parameter_list|)
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|ufs_daddr_t
name|blkno
decl_stmt|;
name|long
name|size
decl_stmt|;
block|{
name|struct
name|freefrag
modifier|*
name|freefrag
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
if|if
condition|(
name|blkno
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|fs
operator|=
name|ip
operator|->
name|i_fs
expr_stmt|;
if|if
condition|(
name|fragnum
argument_list|(
name|fs
argument_list|,
name|blkno
argument_list|)
operator|+
name|numfrags
argument_list|(
name|fs
argument_list|,
name|size
argument_list|)
operator|>
name|fs
operator|->
name|fs_frag
condition|)
name|panic
argument_list|(
literal|"newfreefrag: frag size"
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|freefrag
argument_list|,
expr|struct
name|freefrag
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|freefrag
argument_list|)
argument_list|,
name|M_FREEFRAG
argument_list|,
name|M_SOFTDEP_FLAGS
argument_list|)
expr_stmt|;
name|freefrag
operator|->
name|ff_list
operator|.
name|wk_type
operator|=
name|D_FREEFRAG
expr_stmt|;
name|freefrag
operator|->
name|ff_state
operator|=
name|ip
operator|->
name|i_uid
operator|&
operator|~
name|ONWORKLIST
expr_stmt|;
comment|/* XXX - used below */
name|freefrag
operator|->
name|ff_inum
operator|=
name|ip
operator|->
name|i_number
expr_stmt|;
name|freefrag
operator|->
name|ff_fs
operator|=
name|fs
expr_stmt|;
name|freefrag
operator|->
name|ff_devvp
operator|=
name|ip
operator|->
name|i_devvp
expr_stmt|;
name|freefrag
operator|->
name|ff_blkno
operator|=
name|blkno
expr_stmt|;
name|freefrag
operator|->
name|ff_fragsize
operator|=
name|size
expr_stmt|;
return|return
operator|(
name|freefrag
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This workitem de-allocates fragments that were replaced during  * file block allocation.  */
end_comment

begin_function
specifier|static
name|void
name|handle_workitem_freefrag
parameter_list|(
name|freefrag
parameter_list|)
name|struct
name|freefrag
modifier|*
name|freefrag
decl_stmt|;
block|{
name|struct
name|inode
name|tip
decl_stmt|;
name|tip
operator|.
name|i_fs
operator|=
name|freefrag
operator|->
name|ff_fs
expr_stmt|;
name|tip
operator|.
name|i_devvp
operator|=
name|freefrag
operator|->
name|ff_devvp
expr_stmt|;
name|tip
operator|.
name|i_dev
operator|=
name|freefrag
operator|->
name|ff_devvp
operator|->
name|v_rdev
expr_stmt|;
name|tip
operator|.
name|i_number
operator|=
name|freefrag
operator|->
name|ff_inum
expr_stmt|;
name|tip
operator|.
name|i_uid
operator|=
name|freefrag
operator|->
name|ff_state
operator|&
operator|~
name|ONWORKLIST
expr_stmt|;
comment|/* XXX - set above */
name|ffs_blkfree
argument_list|(
operator|&
name|tip
argument_list|,
name|freefrag
operator|->
name|ff_blkno
argument_list|,
name|freefrag
operator|->
name|ff_fragsize
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|freefrag
argument_list|,
name|M_FREEFRAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Indirect block allocation dependencies.  *   * The same dependencies that exist for a direct block also exist when  * a new block is allocated and pointed to by an entry in a block of  * indirect pointers. The undo/redo states described above are also  * used here. Because an indirect block contains many pointers that  * may have dependencies, a second copy of the entire in-memory indirect  * block is kept. The buffer cache copy is always completely up-to-date.  * The second copy, which is used only as a source for disk writes,  * contains only the safe pointers (i.e., those that have no remaining  * update dependencies). The second copy is freed when all pointers  * are safe. The cache is not allowed to replace indirect blocks with  * pending update dependencies. If a buffer containing an indirect  * block with dependencies is written, these routines will mark it  * dirty again. It can only be successfully written once all the  * dependencies are removed. The ffs_fsync routine in conjunction with  * softdep_sync_metadata work together to get all the dependencies  * removed so that a file can be successfully written to disk. Three  * procedures are used when setting up indirect block pointer  * dependencies. The division is necessary because of the organization  * of the "balloc" routine and because of the distinction between file  * pages and file metadata blocks.  */
end_comment

begin_comment
comment|/*  * Allocate a new allocindir structure.  */
end_comment

begin_function
specifier|static
name|struct
name|allocindir
modifier|*
name|newallocindir
parameter_list|(
name|ip
parameter_list|,
name|ptrno
parameter_list|,
name|newblkno
parameter_list|,
name|oldblkno
parameter_list|)
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
comment|/* inode for file being extended */
name|int
name|ptrno
decl_stmt|;
comment|/* offset of pointer in indirect block */
name|ufs_daddr_t
name|newblkno
decl_stmt|;
comment|/* disk block number being added */
name|ufs_daddr_t
name|oldblkno
decl_stmt|;
comment|/* previous block number, 0 if none */
block|{
name|struct
name|allocindir
modifier|*
name|aip
decl_stmt|;
name|MALLOC
argument_list|(
name|aip
argument_list|,
expr|struct
name|allocindir
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|allocindir
argument_list|)
argument_list|,
name|M_ALLOCINDIR
argument_list|,
name|M_SOFTDEP_FLAGS
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|aip
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|allocindir
argument_list|)
argument_list|)
expr_stmt|;
name|aip
operator|->
name|ai_list
operator|.
name|wk_type
operator|=
name|D_ALLOCINDIR
expr_stmt|;
name|aip
operator|->
name|ai_state
operator|=
name|ATTACHED
expr_stmt|;
name|aip
operator|->
name|ai_offset
operator|=
name|ptrno
expr_stmt|;
name|aip
operator|->
name|ai_newblkno
operator|=
name|newblkno
expr_stmt|;
name|aip
operator|->
name|ai_oldblkno
operator|=
name|oldblkno
expr_stmt|;
name|aip
operator|->
name|ai_freefrag
operator|=
name|newfreefrag
argument_list|(
name|ip
argument_list|,
name|oldblkno
argument_list|,
name|ip
operator|->
name|i_fs
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
return|return
operator|(
name|aip
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called just before setting an indirect block pointer  * to a newly allocated file page.  */
end_comment

begin_function
name|void
name|softdep_setup_allocindir_page
parameter_list|(
name|ip
parameter_list|,
name|lbn
parameter_list|,
name|bp
parameter_list|,
name|ptrno
parameter_list|,
name|newblkno
parameter_list|,
name|oldblkno
parameter_list|,
name|nbp
parameter_list|)
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
comment|/* inode for file being extended */
name|ufs_lbn_t
name|lbn
decl_stmt|;
comment|/* allocated block number within file */
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
comment|/* buffer with indirect blk referencing page */
name|int
name|ptrno
decl_stmt|;
comment|/* offset of pointer in indirect block */
name|ufs_daddr_t
name|newblkno
decl_stmt|;
comment|/* disk block number being added */
name|ufs_daddr_t
name|oldblkno
decl_stmt|;
comment|/* previous block number, 0 if none */
name|struct
name|buf
modifier|*
name|nbp
decl_stmt|;
comment|/* buffer holding allocated page */
block|{
name|struct
name|allocindir
modifier|*
name|aip
decl_stmt|;
name|struct
name|pagedep
modifier|*
name|pagedep
decl_stmt|;
name|aip
operator|=
name|newallocindir
argument_list|(
name|ip
argument_list|,
name|ptrno
argument_list|,
name|newblkno
argument_list|,
name|oldblkno
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
comment|/* 	 * If we are allocating a directory page, then we must 	 * allocate an associated pagedep to track additions and 	 * deletions. 	 */
if|if
condition|(
operator|(
name|ip
operator|->
name|i_mode
operator|&
name|IFMT
operator|)
operator|==
name|IFDIR
operator|&&
name|pagedep_lookup
argument_list|(
name|ip
argument_list|,
name|lbn
argument_list|,
name|DEPALLOC
argument_list|,
operator|&
name|pagedep
argument_list|)
operator|==
literal|0
condition|)
name|WORKLIST_INSERT
argument_list|(
operator|&
name|nbp
operator|->
name|b_dep
argument_list|,
operator|&
name|pagedep
operator|->
name|pd_list
argument_list|)
expr_stmt|;
name|WORKLIST_INSERT
argument_list|(
operator|&
name|nbp
operator|->
name|b_dep
argument_list|,
operator|&
name|aip
operator|->
name|ai_list
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|setup_allocindir_phase2
argument_list|(
name|bp
argument_list|,
name|ip
argument_list|,
name|aip
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called just before setting an indirect block pointer to a  * newly allocated indirect block.  */
end_comment

begin_function
name|void
name|softdep_setup_allocindir_meta
parameter_list|(
name|nbp
parameter_list|,
name|ip
parameter_list|,
name|bp
parameter_list|,
name|ptrno
parameter_list|,
name|newblkno
parameter_list|)
name|struct
name|buf
modifier|*
name|nbp
decl_stmt|;
comment|/* newly allocated indirect block */
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
comment|/* inode for file being extended */
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
comment|/* indirect block referencing allocated block */
name|int
name|ptrno
decl_stmt|;
comment|/* offset of pointer in indirect block */
name|ufs_daddr_t
name|newblkno
decl_stmt|;
comment|/* disk block number being added */
block|{
name|struct
name|allocindir
modifier|*
name|aip
decl_stmt|;
name|aip
operator|=
name|newallocindir
argument_list|(
name|ip
argument_list|,
name|ptrno
argument_list|,
name|newblkno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|WORKLIST_INSERT
argument_list|(
operator|&
name|nbp
operator|->
name|b_dep
argument_list|,
operator|&
name|aip
operator|->
name|ai_list
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|setup_allocindir_phase2
argument_list|(
name|bp
argument_list|,
name|ip
argument_list|,
name|aip
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called to finish the allocation of the "aip" allocated  * by one of the two routines above.  */
end_comment

begin_function
specifier|static
name|void
name|setup_allocindir_phase2
parameter_list|(
name|bp
parameter_list|,
name|ip
parameter_list|,
name|aip
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
comment|/* in-memory copy of the indirect block */
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
comment|/* inode for file being extended */
name|struct
name|allocindir
modifier|*
name|aip
decl_stmt|;
comment|/* allocindir allocated by the above routines */
block|{
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
name|struct
name|indirdep
modifier|*
name|indirdep
decl_stmt|,
modifier|*
name|newindirdep
decl_stmt|;
name|struct
name|bmsafemap
modifier|*
name|bmsafemap
decl_stmt|;
name|struct
name|allocindir
modifier|*
name|oldaip
decl_stmt|;
name|struct
name|freefrag
modifier|*
name|freefrag
decl_stmt|;
name|struct
name|newblk
modifier|*
name|newblk
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_lblkno
operator|>=
literal|0
condition|)
name|panic
argument_list|(
literal|"setup_allocindir_phase2: not indir blk"
argument_list|)
expr_stmt|;
for|for
control|(
name|indirdep
operator|=
name|NULL
operator|,
name|newindirdep
operator|=
name|NULL
init|;
condition|;
control|)
block|{
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|wk
argument_list|,
argument|&bp->b_dep
argument_list|,
argument|wk_list
argument_list|)
block|{
if|if
condition|(
name|wk
operator|->
name|wk_type
operator|!=
name|D_INDIRDEP
condition|)
continue|continue;
name|indirdep
operator|=
name|WK_INDIRDEP
argument_list|(
name|wk
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|indirdep
operator|==
name|NULL
operator|&&
name|newindirdep
condition|)
block|{
name|indirdep
operator|=
name|newindirdep
expr_stmt|;
name|WORKLIST_INSERT
argument_list|(
operator|&
name|bp
operator|->
name|b_dep
argument_list|,
operator|&
name|indirdep
operator|->
name|ir_list
argument_list|)
expr_stmt|;
name|newindirdep
operator|=
name|NULL
expr_stmt|;
block|}
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
if|if
condition|(
name|indirdep
condition|)
block|{
if|if
condition|(
name|newblk_lookup
argument_list|(
name|ip
operator|->
name|i_fs
argument_list|,
name|aip
operator|->
name|ai_newblkno
argument_list|,
literal|0
argument_list|,
operator|&
name|newblk
argument_list|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"setup_allocindir: lost block"
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
if|if
condition|(
name|newblk
operator|->
name|nb_state
operator|==
name|DEPCOMPLETE
condition|)
block|{
name|aip
operator|->
name|ai_state
operator||=
name|DEPCOMPLETE
expr_stmt|;
name|aip
operator|->
name|ai_buf
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|bmsafemap
operator|=
name|newblk
operator|->
name|nb_bmsafemap
expr_stmt|;
name|aip
operator|->
name|ai_buf
operator|=
name|bmsafemap
operator|->
name|sm_buf
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|newblk
argument_list|,
name|nb_deps
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|bmsafemap
operator|->
name|sm_allocindirhd
argument_list|,
name|aip
argument_list|,
name|ai_deps
argument_list|)
expr_stmt|;
block|}
name|LIST_REMOVE
argument_list|(
name|newblk
argument_list|,
name|nb_hash
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|newblk
argument_list|,
name|M_NEWBLK
argument_list|)
expr_stmt|;
name|aip
operator|->
name|ai_indirdep
operator|=
name|indirdep
expr_stmt|;
comment|/* 			 * Check to see if there is an existing dependency 			 * for this block. If there is, merge the old 			 * dependency into the new one. 			 */
if|if
condition|(
name|aip
operator|->
name|ai_oldblkno
operator|==
literal|0
condition|)
name|oldaip
operator|=
name|NULL
expr_stmt|;
else|else
name|LIST_FOREACH
argument_list|(
argument|oldaip
argument_list|,
argument|&indirdep->ir_deplisthd
argument_list|,
argument|ai_next
argument_list|)
if|if
condition|(
name|oldaip
operator|->
name|ai_offset
operator|==
name|aip
operator|->
name|ai_offset
condition|)
break|break;
if|if
condition|(
name|oldaip
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|oldaip
operator|->
name|ai_newblkno
operator|!=
name|aip
operator|->
name|ai_oldblkno
condition|)
block|{
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"setup_allocindir_phase2: blkno"
argument_list|)
expr_stmt|;
block|}
name|aip
operator|->
name|ai_oldblkno
operator|=
name|oldaip
operator|->
name|ai_oldblkno
expr_stmt|;
name|freefrag
operator|=
name|oldaip
operator|->
name|ai_freefrag
expr_stmt|;
name|oldaip
operator|->
name|ai_freefrag
operator|=
name|aip
operator|->
name|ai_freefrag
expr_stmt|;
name|aip
operator|->
name|ai_freefrag
operator|=
name|freefrag
expr_stmt|;
name|free_allocindir
argument_list|(
name|oldaip
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|indirdep
operator|->
name|ir_deplisthd
argument_list|,
name|aip
argument_list|,
name|ai_next
argument_list|)
expr_stmt|;
operator|(
operator|(
name|ufs_daddr_t
operator|*
operator|)
name|indirdep
operator|->
name|ir_savebp
operator|->
name|b_data
operator|)
index|[
name|aip
operator|->
name|ai_offset
index|]
operator|=
name|aip
operator|->
name|ai_oldblkno
expr_stmt|;
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newindirdep
condition|)
block|{
if|if
condition|(
name|indirdep
operator|->
name|ir_savebp
operator|!=
name|NULL
condition|)
name|brelse
argument_list|(
name|newindirdep
operator|->
name|ir_savebp
argument_list|)
expr_stmt|;
name|WORKITEM_FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|newindirdep
argument_list|,
name|D_INDIRDEP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|indirdep
condition|)
break|break;
name|MALLOC
argument_list|(
name|newindirdep
argument_list|,
expr|struct
name|indirdep
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|indirdep
argument_list|)
argument_list|,
name|M_INDIRDEP
argument_list|,
name|M_SOFTDEP_FLAGS
argument_list|)
expr_stmt|;
name|newindirdep
operator|->
name|ir_list
operator|.
name|wk_type
operator|=
name|D_INDIRDEP
expr_stmt|;
name|newindirdep
operator|->
name|ir_state
operator|=
name|ATTACHED
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|newindirdep
operator|->
name|ir_deplisthd
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|newindirdep
operator|->
name|ir_donehd
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_blkno
operator|==
name|bp
operator|->
name|b_lblkno
condition|)
block|{
name|VOP_BMAP
argument_list|(
name|bp
operator|->
name|b_vp
argument_list|,
name|bp
operator|->
name|b_lblkno
argument_list|,
name|NULL
argument_list|,
operator|&
name|bp
operator|->
name|b_blkno
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|newindirdep
operator|->
name|ir_savebp
operator|=
name|getblk
argument_list|(
name|ip
operator|->
name|i_devvp
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|BUF_KERNPROC
argument_list|(
name|newindirdep
operator|->
name|ir_savebp
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
name|newindirdep
operator|->
name|ir_savebp
operator|->
name|b_data
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Block de-allocation dependencies.  *   * When blocks are de-allocated, the on-disk pointers must be nullified before  * the blocks are made available for use by other files.  (The true  * requirement is that old pointers must be nullified before new on-disk  * pointers are set.  We chose this slightly more stringent requirement to  * reduce complexity.) Our implementation handles this dependency by updating  * the inode (or indirect block) appropriately but delaying the actual block  * de-allocation (i.e., freemap and free space count manipulation) until  * after the updated versions reach stable storage.  After the disk is  * updated, the blocks can be safely de-allocated whenever it is convenient.  * This implementation handles only the common case of reducing a file's  * length to zero. Other cases are handled by the conventional synchronous  * write approach.  *  * The ffs implementation with which we worked double-checks  * the state of the block pointers and file size as it reduces  * a file's length.  Some of this code is replicated here in our  * soft updates implementation.  The freeblks->fb_chkcnt field is  * used to transfer a part of this information to the procedure  * that eventually de-allocates the blocks.  *  * This routine should be called from the routine that shortens  * a file's length, before the inode's size or block pointers  * are modified. It will save the block pointer information for  * later release and zero the inode so that the calling routine  * can release it.  */
end_comment

begin_function
name|void
name|softdep_setup_freeblocks
parameter_list|(
name|ip
parameter_list|,
name|length
parameter_list|)
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
comment|/* The inode whose length is to be reduced */
name|off_t
name|length
decl_stmt|;
comment|/* The new length for the file */
block|{
name|struct
name|freeblks
modifier|*
name|freeblks
decl_stmt|;
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|allocdirect
modifier|*
name|adp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|,
name|delay
decl_stmt|;
name|fs
operator|=
name|ip
operator|->
name|i_fs
expr_stmt|;
if|if
condition|(
name|length
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"softde_setup_freeblocks: non-zero length"
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|freeblks
argument_list|,
expr|struct
name|freeblks
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|freeblks
argument_list|)
argument_list|,
name|M_FREEBLKS
argument_list|,
name|M_SOFTDEP_FLAGS
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|freeblks
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|freeblks
argument_list|)
argument_list|)
expr_stmt|;
name|freeblks
operator|->
name|fb_list
operator|.
name|wk_type
operator|=
name|D_FREEBLKS
expr_stmt|;
name|freeblks
operator|->
name|fb_uid
operator|=
name|ip
operator|->
name|i_uid
expr_stmt|;
name|freeblks
operator|->
name|fb_previousinum
operator|=
name|ip
operator|->
name|i_number
expr_stmt|;
name|freeblks
operator|->
name|fb_devvp
operator|=
name|ip
operator|->
name|i_devvp
expr_stmt|;
name|freeblks
operator|->
name|fb_fs
operator|=
name|fs
expr_stmt|;
name|freeblks
operator|->
name|fb_oldsize
operator|=
name|ip
operator|->
name|i_size
expr_stmt|;
name|freeblks
operator|->
name|fb_newsize
operator|=
name|length
expr_stmt|;
name|freeblks
operator|->
name|fb_chkcnt
operator|=
name|ip
operator|->
name|i_blocks
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDADDR
condition|;
name|i
operator|++
control|)
block|{
name|freeblks
operator|->
name|fb_dblks
index|[
name|i
index|]
operator|=
name|ip
operator|->
name|i_db
index|[
name|i
index|]
expr_stmt|;
name|ip
operator|->
name|i_db
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NIADDR
condition|;
name|i
operator|++
control|)
block|{
name|freeblks
operator|->
name|fb_iblks
index|[
name|i
index|]
operator|=
name|ip
operator|->
name|i_ib
index|[
name|i
index|]
expr_stmt|;
name|ip
operator|->
name|i_ib
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|ip
operator|->
name|i_blocks
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|i_size
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Push the zero'ed inode to to its disk buffer so that we are free 	 * to delete its dependencies below. Once the dependencies are gone 	 * the buffer can be safely released. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|bread
argument_list|(
name|ip
operator|->
name|i_devvp
argument_list|,
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|ino_to_fsba
argument_list|(
name|fs
argument_list|,
name|ip
operator|->
name|i_number
argument_list|)
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|fs
operator|->
name|fs_bsize
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|softdep_error
argument_list|(
literal|"softdep_setup_freeblocks"
argument_list|,
name|error
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
expr|struct
name|dinode
operator|*
operator|)
name|bp
operator|->
name|b_data
operator|+
name|ino_to_fsbo
argument_list|(
name|fs
argument_list|,
name|ip
operator|->
name|i_number
argument_list|)
operator|)
operator|=
name|ip
operator|->
name|i_din
expr_stmt|;
comment|/* 	 * Find and eliminate any inode dependencies. 	 */
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inodedep_lookup
argument_list|(
name|fs
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
name|DEPALLOC
argument_list|,
operator|&
name|inodedep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inodedep
operator|->
name|id_state
operator|&
name|IOSTARTED
operator|)
operator|!=
literal|0
condition|)
block|{
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"softdep_setup_freeblocks: inode busy"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Add the freeblks structure to the list of operations that 	 * must await the zero'ed inode being written to disk. If we 	 * still have a bitmap dependency (delay == 0), then the inode 	 * has never been written to disk, so we can process the 	 * freeblks below once we have deleted the dependencies. 	 */
name|delay
operator|=
operator|(
name|inodedep
operator|->
name|id_state
operator|&
name|DEPCOMPLETE
operator|)
expr_stmt|;
if|if
condition|(
name|delay
condition|)
name|WORKLIST_INSERT
argument_list|(
operator|&
name|inodedep
operator|->
name|id_bufwait
argument_list|,
operator|&
name|freeblks
operator|->
name|fb_list
argument_list|)
expr_stmt|;
comment|/* 	 * Because the file length has been truncated to zero, any 	 * pending block allocation dependency structures associated 	 * with this inode are obsolete and can simply be de-allocated. 	 * We must first merge the two dependency lists to get rid of 	 * any duplicate freefrag structures, then purge the merged list. 	 */
name|merge_inode_lists
argument_list|(
name|inodedep
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|adp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoupdt
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|free_allocdirect
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoupdt
argument_list|,
name|adp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|bdwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * We must wait for any I/O in progress to finish so that 	 * all potential buffers on the dirty list will be visible. 	 * Once they are all there, walk the list and get rid of 	 * any dependencies. 	 */
name|vp
operator|=
name|ITOV
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|drain_output
argument_list|(
name|vp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|getdirtybuf
argument_list|(
operator|&
name|TAILQ_FIRST
argument_list|(
operator|&
name|vp
operator|->
name|v_dirtyblkhd
argument_list|)
argument_list|,
name|MNT_WAIT
argument_list|)
condition|)
block|{
name|bp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|vp
operator|->
name|v_dirtyblkhd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inodedep_lookup
argument_list|(
name|fs
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
literal|0
argument_list|,
operator|&
name|inodedep
argument_list|)
expr_stmt|;
name|deallocate_dependencies
argument_list|(
name|bp
argument_list|,
name|inodedep
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_INVAL
operator||
name|B_NOCACHE
expr_stmt|;
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inodedep_lookup
argument_list|(
name|fs
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
literal|0
argument_list|,
operator|&
name|inodedep
argument_list|)
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|free_inodedep
argument_list|(
name|inodedep
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
comment|/* 	 * If the inode has never been written to disk (delay == 0), 	 * then we can process the freeblks now that we have deleted 	 * the dependencies. 	 */
if|if
condition|(
operator|!
name|delay
condition|)
name|handle_workitem_freeblocks
argument_list|(
name|freeblks
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reclaim any dependency structures from a buffer that is about to  * be reallocated to a new vnode. The buffer must be locked, thus,  * no I/O completion operations can occur while we are manipulating  * its associated dependencies. The mutex is held so that other I/O's  * associated with related dependencies do not occur.  */
end_comment

begin_function
specifier|static
name|void
name|deallocate_dependencies
parameter_list|(
name|bp
parameter_list|,
name|inodedep
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
block|{
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
name|struct
name|indirdep
modifier|*
name|indirdep
decl_stmt|;
name|struct
name|allocindir
modifier|*
name|aip
decl_stmt|;
name|struct
name|pagedep
modifier|*
name|pagedep
decl_stmt|;
name|struct
name|dirrem
modifier|*
name|dirrem
decl_stmt|;
name|struct
name|diradd
modifier|*
name|dap
decl_stmt|;
name|int
name|i
decl_stmt|;
while|while
condition|(
operator|(
name|wk
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|bp
operator|->
name|b_dep
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|wk
operator|->
name|wk_type
condition|)
block|{
case|case
name|D_INDIRDEP
case|:
name|indirdep
operator|=
name|WK_INDIRDEP
argument_list|(
name|wk
argument_list|)
expr_stmt|;
comment|/* 			 * None of the indirect pointers will ever be visible, 			 * so they can simply be tossed. GOINGAWAY ensures 			 * that allocated pointers will be saved in the buffer 			 * cache until they are freed. Note that they will 			 * only be able to be found by their physical address 			 * since the inode mapping the logical address will 			 * be gone. The save buffer used for the safe copy 			 * was allocated in setup_allocindir_phase2 using 			 * the physical address so it could be used for this 			 * purpose. Hence we swap the safe copy with the real 			 * copy, allowing the safe copy to be freed and holding 			 * on to the real copy for later use in indir_trunc. 			 */
if|if
condition|(
name|indirdep
operator|->
name|ir_state
operator|&
name|GOINGAWAY
condition|)
block|{
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"deallocate_dependencies: already gone"
argument_list|)
expr_stmt|;
block|}
name|indirdep
operator|->
name|ir_state
operator||=
name|GOINGAWAY
expr_stmt|;
while|while
condition|(
operator|(
name|aip
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|indirdep
operator|->
name|ir_deplisthd
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|free_allocindir
argument_list|(
name|aip
argument_list|,
name|inodedep
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_lblkno
operator|>=
literal|0
operator|||
name|bp
operator|->
name|b_blkno
operator|!=
name|indirdep
operator|->
name|ir_savebp
operator|->
name|b_lblkno
condition|)
block|{
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"deallocate_dependencies: not indir"
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
name|indirdep
operator|->
name|ir_savebp
operator|->
name|b_data
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
name|WORKLIST_REMOVE
argument_list|(
name|wk
argument_list|)
expr_stmt|;
name|WORKLIST_INSERT
argument_list|(
operator|&
name|indirdep
operator|->
name|ir_savebp
operator|->
name|b_dep
argument_list|,
name|wk
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|D_PAGEDEP
case|:
name|pagedep
operator|=
name|WK_PAGEDEP
argument_list|(
name|wk
argument_list|)
expr_stmt|;
comment|/* 			 * None of the directory additions will ever be 			 * visible, so they can simply be tossed. 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DAHASHSZ
condition|;
name|i
operator|++
control|)
while|while
condition|(
operator|(
name|dap
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|pagedep
operator|->
name|pd_diraddhd
index|[
name|i
index|]
argument_list|)
operator|)
condition|)
name|free_diradd
argument_list|(
name|dap
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|dap
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|pagedep
operator|->
name|pd_pendinghd
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|free_diradd
argument_list|(
name|dap
argument_list|)
expr_stmt|;
comment|/* 			 * Copy any directory remove dependencies to the list 			 * to be processed after the zero'ed inode is written. 			 * If the inode has already been written, then they  			 * can be dumped directly onto the work list. 			 */
name|LIST_FOREACH
argument_list|(
argument|dirrem
argument_list|,
argument|&pagedep->pd_dirremhd
argument_list|,
argument|dm_next
argument_list|)
block|{
name|LIST_REMOVE
argument_list|(
name|dirrem
argument_list|,
name|dm_next
argument_list|)
expr_stmt|;
name|dirrem
operator|->
name|dm_dirinum
operator|=
name|pagedep
operator|->
name|pd_ino
expr_stmt|;
if|if
condition|(
name|inodedep
operator|==
name|NULL
operator|||
operator|(
name|inodedep
operator|->
name|id_state
operator|&
name|ALLCOMPLETE
operator|)
operator|==
name|ALLCOMPLETE
condition|)
name|add_to_worklist
argument_list|(
operator|&
name|dirrem
operator|->
name|dm_list
argument_list|)
expr_stmt|;
else|else
name|WORKLIST_INSERT
argument_list|(
operator|&
name|inodedep
operator|->
name|id_bufwait
argument_list|,
operator|&
name|dirrem
operator|->
name|dm_list
argument_list|)
expr_stmt|;
block|}
name|WORKLIST_REMOVE
argument_list|(
operator|&
name|pagedep
operator|->
name|pd_list
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|pagedep
argument_list|,
name|pd_hash
argument_list|)
expr_stmt|;
name|WORKITEM_FREE
argument_list|(
name|pagedep
argument_list|,
name|D_PAGEDEP
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|D_ALLOCINDIR
case|:
name|free_allocindir
argument_list|(
name|WK_ALLOCINDIR
argument_list|(
name|wk
argument_list|)
argument_list|,
name|inodedep
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|D_ALLOCDIRECT
case|:
case|case
name|D_INODEDEP
case|:
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"deallocate_dependencies: Unexpected type %s"
argument_list|,
name|TYPENAME
argument_list|(
name|wk
operator|->
name|wk_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
default|default:
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"deallocate_dependencies: Unknown type %s"
argument_list|,
name|TYPENAME
argument_list|(
name|wk
operator|->
name|wk_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Free an allocdirect. Generate a new freefrag work request if appropriate.  * This routine must be called with splbio interrupts blocked.  */
end_comment

begin_function
specifier|static
name|void
name|free_allocdirect
parameter_list|(
name|adphead
parameter_list|,
name|adp
parameter_list|,
name|delay
parameter_list|)
name|struct
name|allocdirectlst
modifier|*
name|adphead
decl_stmt|;
name|struct
name|allocdirect
modifier|*
name|adp
decl_stmt|;
name|int
name|delay
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|lk
operator|.
name|lkt_held
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"free_allocdirect: lock not held"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|adp
operator|->
name|ad_state
operator|&
name|DEPCOMPLETE
operator|)
operator|==
literal|0
condition|)
name|LIST_REMOVE
argument_list|(
name|adp
argument_list|,
name|ad_deps
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
name|adphead
argument_list|,
name|adp
argument_list|,
name|ad_next
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|adp
operator|->
name|ad_state
operator|&
name|COMPLETE
operator|)
operator|==
literal|0
condition|)
name|WORKLIST_REMOVE
argument_list|(
operator|&
name|adp
operator|->
name|ad_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|adp
operator|->
name|ad_freefrag
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|delay
condition|)
name|WORKLIST_INSERT
argument_list|(
operator|&
name|adp
operator|->
name|ad_inodedep
operator|->
name|id_bufwait
argument_list|,
operator|&
name|adp
operator|->
name|ad_freefrag
operator|->
name|ff_list
argument_list|)
expr_stmt|;
else|else
name|add_to_worklist
argument_list|(
operator|&
name|adp
operator|->
name|ad_freefrag
operator|->
name|ff_list
argument_list|)
expr_stmt|;
block|}
name|WORKITEM_FREE
argument_list|(
name|adp
argument_list|,
name|D_ALLOCDIRECT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Prepare an inode to be freed. The actual free operation is not  * done until the zero'ed inode has been written to disk.  */
end_comment

begin_function
name|void
name|softdep_freefile
parameter_list|(
name|pvp
parameter_list|,
name|ino
parameter_list|,
name|mode
parameter_list|)
name|struct
name|vnode
modifier|*
name|pvp
decl_stmt|;
name|ino_t
name|ino
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|{
name|struct
name|inode
modifier|*
name|ip
init|=
name|VTOI
argument_list|(
name|pvp
argument_list|)
decl_stmt|;
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|freefile
modifier|*
name|freefile
decl_stmt|;
comment|/* 	 * This sets up the inode de-allocation dependency. 	 */
name|MALLOC
argument_list|(
name|freefile
argument_list|,
expr|struct
name|freefile
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|freefile
argument_list|)
argument_list|,
name|M_FREEFILE
argument_list|,
name|M_SOFTDEP_FLAGS
argument_list|)
expr_stmt|;
name|freefile
operator|->
name|fx_list
operator|.
name|wk_type
operator|=
name|D_FREEFILE
expr_stmt|;
name|freefile
operator|->
name|fx_list
operator|.
name|wk_state
operator|=
literal|0
expr_stmt|;
name|freefile
operator|->
name|fx_mode
operator|=
name|mode
expr_stmt|;
name|freefile
operator|->
name|fx_oldinum
operator|=
name|ino
expr_stmt|;
name|freefile
operator|->
name|fx_devvp
operator|=
name|ip
operator|->
name|i_devvp
expr_stmt|;
name|freefile
operator|->
name|fx_fs
operator|=
name|ip
operator|->
name|i_fs
expr_stmt|;
comment|/* 	 * If the inodedep does not exist, then the zero'ed inode has 	 * been written to disk. If the allocated inode has never been 	 * written to disk, then the on-disk inode is zero'ed. In either 	 * case we can free the file immediately. 	 */
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
if|if
condition|(
name|inodedep_lookup
argument_list|(
name|ip
operator|->
name|i_fs
argument_list|,
name|ino
argument_list|,
literal|0
argument_list|,
operator|&
name|inodedep
argument_list|)
operator|==
literal|0
operator|||
name|check_inode_unwritten
argument_list|(
name|inodedep
argument_list|)
condition|)
block|{
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|handle_workitem_freefile
argument_list|(
name|freefile
argument_list|)
expr_stmt|;
return|return;
block|}
name|WORKLIST_INSERT
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inowait
argument_list|,
operator|&
name|freefile
operator|->
name|fx_list
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check to see if an inode has never been written to disk. If  * so free the inodedep and return success, otherwise return failure.  * This routine must be called with splbio interrupts blocked.  *  * If we still have a bitmap dependency, then the inode has never  * been written to disk. Drop the dependency as it is no longer  * necessary since the inode is being deallocated. We set the  * ALLCOMPLETE flags since the bitmap now properly shows that the  * inode is not allocated. Even if the inode is actively being  * written, it has been rolled back to its zero'ed state, so we  * are ensured that a zero inode is what is on the disk. For short  * lived files, this change will usually result in removing all the  * dependencies from the inode so that it can be freed immediately.  */
end_comment

begin_function
specifier|static
name|int
name|check_inode_unwritten
parameter_list|(
name|inodedep
parameter_list|)
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|inodedep
operator|->
name|id_state
operator|&
name|DEPCOMPLETE
operator|)
operator|!=
literal|0
operator|||
name|LIST_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_pendinghd
argument_list|)
operator|!=
name|NULL
operator|||
name|LIST_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_bufwait
argument_list|)
operator|!=
name|NULL
operator|||
name|LIST_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inowait
argument_list|)
operator|!=
name|NULL
operator|||
name|TAILQ_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoupdt
argument_list|)
operator|!=
name|NULL
operator|||
name|TAILQ_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_newinoupdt
argument_list|)
operator|!=
name|NULL
operator|||
name|inodedep
operator|->
name|id_nlinkdelta
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|inodedep
operator|->
name|id_state
operator||=
name|ALLCOMPLETE
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|inodedep
argument_list|,
name|id_deps
argument_list|)
expr_stmt|;
name|inodedep
operator|->
name|id_buf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|inodedep
operator|->
name|id_state
operator|&
name|ONWORKLIST
condition|)
name|WORKLIST_REMOVE
argument_list|(
operator|&
name|inodedep
operator|->
name|id_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|inodedep
operator|->
name|id_savedino
operator|!=
name|NULL
condition|)
block|{
name|FREE
argument_list|(
name|inodedep
operator|->
name|id_savedino
argument_list|,
name|M_INODEDEP
argument_list|)
expr_stmt|;
name|inodedep
operator|->
name|id_savedino
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|free_inodedep
argument_list|(
name|inodedep
argument_list|)
operator|==
literal|0
condition|)
block|{
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"check_inode_unwritten: busy inode"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Try to free an inodedep structure. Return 1 if it could be freed.  */
end_comment

begin_function
specifier|static
name|int
name|free_inodedep
parameter_list|(
name|inodedep
parameter_list|)
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|inodedep
operator|->
name|id_state
operator|&
name|ONWORKLIST
operator|)
operator|!=
literal|0
operator|||
operator|(
name|inodedep
operator|->
name|id_state
operator|&
name|ALLCOMPLETE
operator|)
operator|!=
name|ALLCOMPLETE
operator|||
name|LIST_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_pendinghd
argument_list|)
operator|!=
name|NULL
operator|||
name|LIST_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_bufwait
argument_list|)
operator|!=
name|NULL
operator|||
name|LIST_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inowait
argument_list|)
operator|!=
name|NULL
operator|||
name|TAILQ_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoupdt
argument_list|)
operator|!=
name|NULL
operator|||
name|TAILQ_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_newinoupdt
argument_list|)
operator|!=
name|NULL
operator|||
name|inodedep
operator|->
name|id_nlinkdelta
operator|!=
literal|0
operator|||
name|inodedep
operator|->
name|id_savedino
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|LIST_REMOVE
argument_list|(
name|inodedep
argument_list|,
name|id_hash
argument_list|)
expr_stmt|;
name|WORKITEM_FREE
argument_list|(
name|inodedep
argument_list|,
name|D_INODEDEP
argument_list|)
expr_stmt|;
name|num_inodedep
operator|-=
literal|1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This workitem routine performs the block de-allocation.  * The workitem is added to the pending list after the updated  * inode block has been written to disk.  As mentioned above,  * checks regarding the number of blocks de-allocated (compared  * to the number of blocks allocated for the file) are also  * performed in this function.  */
end_comment

begin_function
specifier|static
name|void
name|handle_workitem_freeblocks
parameter_list|(
name|freeblks
parameter_list|)
name|struct
name|freeblks
modifier|*
name|freeblks
decl_stmt|;
block|{
name|struct
name|inode
name|tip
decl_stmt|;
name|ufs_daddr_t
name|bn
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|int
name|i
decl_stmt|,
name|level
decl_stmt|,
name|bsize
decl_stmt|;
name|long
name|nblocks
decl_stmt|,
name|blocksreleased
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|,
name|allerror
init|=
literal|0
decl_stmt|;
name|ufs_lbn_t
name|baselbns
index|[
name|NIADDR
index|]
decl_stmt|,
name|tmpval
decl_stmt|;
name|tip
operator|.
name|i_number
operator|=
name|freeblks
operator|->
name|fb_previousinum
expr_stmt|;
name|tip
operator|.
name|i_devvp
operator|=
name|freeblks
operator|->
name|fb_devvp
expr_stmt|;
name|tip
operator|.
name|i_dev
operator|=
name|freeblks
operator|->
name|fb_devvp
operator|->
name|v_rdev
expr_stmt|;
name|tip
operator|.
name|i_fs
operator|=
name|freeblks
operator|->
name|fb_fs
expr_stmt|;
name|tip
operator|.
name|i_size
operator|=
name|freeblks
operator|->
name|fb_oldsize
expr_stmt|;
name|tip
operator|.
name|i_uid
operator|=
name|freeblks
operator|->
name|fb_uid
expr_stmt|;
name|fs
operator|=
name|freeblks
operator|->
name|fb_fs
expr_stmt|;
name|tmpval
operator|=
literal|1
expr_stmt|;
name|baselbns
index|[
literal|0
index|]
operator|=
name|NDADDR
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NIADDR
condition|;
name|i
operator|++
control|)
block|{
name|tmpval
operator|*=
name|NINDIR
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|baselbns
index|[
name|i
index|]
operator|=
name|baselbns
index|[
name|i
operator|-
literal|1
index|]
operator|+
name|tmpval
expr_stmt|;
block|}
name|nblocks
operator|=
name|btodb
argument_list|(
name|fs
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
name|blocksreleased
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Indirect blocks first. 	 */
for|for
control|(
name|level
operator|=
operator|(
name|NIADDR
operator|-
literal|1
operator|)
init|;
name|level
operator|>=
literal|0
condition|;
name|level
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|bn
operator|=
name|freeblks
operator|->
name|fb_iblks
index|[
name|level
index|]
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|error
operator|=
name|indir_trunc
argument_list|(
operator|&
name|tip
argument_list|,
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|bn
argument_list|)
argument_list|,
name|level
argument_list|,
name|baselbns
index|[
name|level
index|]
argument_list|,
operator|&
name|blocksreleased
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|allerror
operator|=
name|error
expr_stmt|;
name|ffs_blkfree
argument_list|(
operator|&
name|tip
argument_list|,
name|bn
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
name|blocksreleased
operator|+=
name|nblocks
expr_stmt|;
block|}
comment|/* 	 * All direct blocks or frags. 	 */
for|for
control|(
name|i
operator|=
operator|(
name|NDADDR
operator|-
literal|1
operator|)
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|bn
operator|=
name|freeblks
operator|->
name|fb_dblks
index|[
name|i
index|]
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|bsize
operator|=
name|blksize
argument_list|(
name|fs
argument_list|,
operator|&
name|tip
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ffs_blkfree
argument_list|(
operator|&
name|tip
argument_list|,
name|bn
argument_list|,
name|bsize
argument_list|)
expr_stmt|;
name|blocksreleased
operator|+=
name|btodb
argument_list|(
name|bsize
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|freeblks
operator|->
name|fb_chkcnt
operator|!=
name|blocksreleased
condition|)
name|printf
argument_list|(
literal|"handle_workitem_freeblocks: block count\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|allerror
condition|)
name|softdep_error
argument_list|(
literal|"handle_workitem_freeblks"
argument_list|,
name|allerror
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DIAGNOSTIC */
name|WORKITEM_FREE
argument_list|(
name|freeblks
argument_list|,
name|D_FREEBLKS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Release blocks associated with the inode ip and stored in the indirect  * block dbn. If level is greater than SINGLE, the block is an indirect block  * and recursive calls to indirtrunc must be used to cleanse other indirect  * blocks.  */
end_comment

begin_function
specifier|static
name|int
name|indir_trunc
parameter_list|(
name|ip
parameter_list|,
name|dbn
parameter_list|,
name|level
parameter_list|,
name|lbn
parameter_list|,
name|countp
parameter_list|)
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|ufs_daddr_t
name|dbn
decl_stmt|;
name|int
name|level
decl_stmt|;
name|ufs_lbn_t
name|lbn
decl_stmt|;
name|long
modifier|*
name|countp
decl_stmt|;
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|ufs_daddr_t
modifier|*
name|bap
decl_stmt|;
name|ufs_daddr_t
name|nb
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
name|struct
name|indirdep
modifier|*
name|indirdep
decl_stmt|;
name|int
name|i
decl_stmt|,
name|lbnadd
decl_stmt|,
name|nblocks
decl_stmt|;
name|int
name|error
decl_stmt|,
name|allerror
init|=
literal|0
decl_stmt|;
name|fs
operator|=
name|ip
operator|->
name|i_fs
expr_stmt|;
name|lbnadd
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|level
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|lbnadd
operator|*=
name|NINDIR
argument_list|(
name|fs
argument_list|)
expr_stmt|;
comment|/* 	 * Get buffer of block pointers to be freed. This routine is not 	 * called until the zero'ed inode has been written, so it is safe 	 * to free blocks as they are encountered. Because the inode has 	 * been zero'ed, calls to bmap on these blocks will fail. So, we 	 * have to use the on-disk address and the block device for the 	 * filesystem to look them up. If the file was deleted before its 	 * indirect blocks were all written to disk, the routine that set 	 * us up (deallocate_dependencies) will have arranged to leave 	 * a complete copy of the indirect block in memory for our use. 	 * Otherwise we have to read the blocks in from the disk. 	 */
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|=
name|incore
argument_list|(
name|ip
operator|->
name|i_devvp
argument_list|,
name|dbn
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|wk
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|bp
operator|->
name|b_dep
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|wk
operator|->
name|wk_type
operator|!=
name|D_INDIRDEP
operator|||
operator|(
name|indirdep
operator|=
name|WK_INDIRDEP
argument_list|(
name|wk
argument_list|)
operator|)
operator|->
name|ir_savebp
operator|!=
name|bp
operator|||
operator|(
name|indirdep
operator|->
name|ir_state
operator|&
name|GOINGAWAY
operator|)
operator|==
literal|0
condition|)
block|{
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"indir_trunc: lost indirdep"
argument_list|)
expr_stmt|;
block|}
name|WORKLIST_REMOVE
argument_list|(
name|wk
argument_list|)
expr_stmt|;
name|WORKITEM_FREE
argument_list|(
name|indirdep
argument_list|,
name|D_INDIRDEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|LIST_FIRST
argument_list|(
operator|&
name|bp
operator|->
name|b_dep
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"indir_trunc: dangling dep"
argument_list|)
expr_stmt|;
block|}
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|error
operator|=
name|bread
argument_list|(
name|ip
operator|->
name|i_devvp
argument_list|,
name|dbn
argument_list|,
operator|(
name|int
operator|)
name|fs
operator|->
name|fs_bsize
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Recursively free indirect blocks. 	 */
name|bap
operator|=
operator|(
name|ufs_daddr_t
operator|*
operator|)
name|bp
operator|->
name|b_data
expr_stmt|;
name|nblocks
operator|=
name|btodb
argument_list|(
name|fs
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|NINDIR
argument_list|(
name|fs
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|nb
operator|=
name|bap
index|[
name|i
index|]
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|level
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|indir_trunc
argument_list|(
name|ip
argument_list|,
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|nb
argument_list|)
argument_list|,
name|level
operator|-
literal|1
argument_list|,
name|lbn
operator|+
operator|(
name|i
operator|*
name|lbnadd
operator|)
argument_list|,
name|countp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|allerror
operator|=
name|error
expr_stmt|;
block|}
name|ffs_blkfree
argument_list|(
name|ip
argument_list|,
name|nb
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
operator|*
name|countp
operator|+=
name|nblocks
expr_stmt|;
block|}
name|bp
operator|->
name|b_flags
operator||=
name|B_INVAL
operator||
name|B_NOCACHE
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|allerror
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free an allocindir.  * This routine must be called with splbio interrupts blocked.  */
end_comment

begin_function
specifier|static
name|void
name|free_allocindir
parameter_list|(
name|aip
parameter_list|,
name|inodedep
parameter_list|)
name|struct
name|allocindir
modifier|*
name|aip
decl_stmt|;
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
block|{
name|struct
name|freefrag
modifier|*
name|freefrag
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|lk
operator|.
name|lkt_held
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"free_allocindir: lock not held"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|aip
operator|->
name|ai_state
operator|&
name|DEPCOMPLETE
operator|)
operator|==
literal|0
condition|)
name|LIST_REMOVE
argument_list|(
name|aip
argument_list|,
name|ai_deps
argument_list|)
expr_stmt|;
if|if
condition|(
name|aip
operator|->
name|ai_state
operator|&
name|ONWORKLIST
condition|)
name|WORKLIST_REMOVE
argument_list|(
operator|&
name|aip
operator|->
name|ai_list
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|aip
argument_list|,
name|ai_next
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|freefrag
operator|=
name|aip
operator|->
name|ai_freefrag
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|inodedep
operator|==
name|NULL
condition|)
name|add_to_worklist
argument_list|(
operator|&
name|freefrag
operator|->
name|ff_list
argument_list|)
expr_stmt|;
else|else
name|WORKLIST_INSERT
argument_list|(
operator|&
name|inodedep
operator|->
name|id_bufwait
argument_list|,
operator|&
name|freefrag
operator|->
name|ff_list
argument_list|)
expr_stmt|;
block|}
name|WORKITEM_FREE
argument_list|(
name|aip
argument_list|,
name|D_ALLOCINDIR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Directory entry addition dependencies.  *   * When adding a new directory entry, the inode (with its incremented link  * count) must be written to disk before the directory entry's pointer to it.  * Also, if the inode is newly allocated, the corresponding freemap must be  * updated (on disk) before the directory entry's pointer. These requirements  * are met via undo/redo on the directory entry's pointer, which consists  * simply of the inode number.  *   * As directory entries are added and deleted, the free space within a  * directory block can become fragmented.  The ufs file system will compact  * a fragmented directory block to make space for a new entry. When this  * occurs, the offsets of previously added entries change. Any "diradd"  * dependency structures corresponding to these entries must be updated with  * the new offsets.  */
end_comment

begin_comment
comment|/*  * This routine is called after the in-memory inode's link  * count has been incremented, but before the directory entry's  * pointer to the inode has been set.  */
end_comment

begin_function
name|void
name|softdep_setup_directory_add
parameter_list|(
name|bp
parameter_list|,
name|dp
parameter_list|,
name|diroffset
parameter_list|,
name|newinum
parameter_list|,
name|newdirbp
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
comment|/* buffer containing directory block */
name|struct
name|inode
modifier|*
name|dp
decl_stmt|;
comment|/* inode for directory */
name|off_t
name|diroffset
decl_stmt|;
comment|/* offset of new entry in directory */
name|long
name|newinum
decl_stmt|;
comment|/* inode referenced by new directory entry */
name|struct
name|buf
modifier|*
name|newdirbp
decl_stmt|;
comment|/* non-NULL => contents of new mkdir */
block|{
name|int
name|offset
decl_stmt|;
comment|/* offset of new entry within directory block */
name|ufs_lbn_t
name|lbn
decl_stmt|;
comment|/* block in directory containing new entry */
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|struct
name|diradd
modifier|*
name|dap
decl_stmt|;
name|struct
name|pagedep
modifier|*
name|pagedep
decl_stmt|;
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|mkdir
modifier|*
name|mkdir1
decl_stmt|,
modifier|*
name|mkdir2
decl_stmt|;
comment|/* 	 * Whiteouts have no dependencies. 	 */
if|if
condition|(
name|newinum
operator|==
name|WINO
condition|)
block|{
if|if
condition|(
name|newdirbp
operator|!=
name|NULL
condition|)
name|bdwrite
argument_list|(
name|newdirbp
argument_list|)
expr_stmt|;
return|return;
block|}
name|fs
operator|=
name|dp
operator|->
name|i_fs
expr_stmt|;
name|lbn
operator|=
name|lblkno
argument_list|(
name|fs
argument_list|,
name|diroffset
argument_list|)
expr_stmt|;
name|offset
operator|=
name|blkoff
argument_list|(
name|fs
argument_list|,
name|diroffset
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|dap
argument_list|,
expr|struct
name|diradd
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|diradd
argument_list|)
argument_list|,
name|M_DIRADD
argument_list|,
name|M_SOFTDEP_FLAGS
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|dap
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|diradd
argument_list|)
argument_list|)
expr_stmt|;
name|dap
operator|->
name|da_list
operator|.
name|wk_type
operator|=
name|D_DIRADD
expr_stmt|;
name|dap
operator|->
name|da_offset
operator|=
name|offset
expr_stmt|;
name|dap
operator|->
name|da_newinum
operator|=
name|newinum
expr_stmt|;
name|dap
operator|->
name|da_state
operator|=
name|ATTACHED
expr_stmt|;
if|if
condition|(
name|newdirbp
operator|==
name|NULL
condition|)
block|{
name|dap
operator|->
name|da_state
operator||=
name|DEPCOMPLETE
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dap
operator|->
name|da_state
operator||=
name|MKDIR_BODY
operator||
name|MKDIR_PARENT
expr_stmt|;
name|MALLOC
argument_list|(
name|mkdir1
argument_list|,
expr|struct
name|mkdir
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mkdir
argument_list|)
argument_list|,
name|M_MKDIR
argument_list|,
name|M_SOFTDEP_FLAGS
argument_list|)
expr_stmt|;
name|mkdir1
operator|->
name|md_list
operator|.
name|wk_type
operator|=
name|D_MKDIR
expr_stmt|;
name|mkdir1
operator|->
name|md_state
operator|=
name|MKDIR_BODY
expr_stmt|;
name|mkdir1
operator|->
name|md_diradd
operator|=
name|dap
expr_stmt|;
name|MALLOC
argument_list|(
name|mkdir2
argument_list|,
expr|struct
name|mkdir
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mkdir
argument_list|)
argument_list|,
name|M_MKDIR
argument_list|,
name|M_SOFTDEP_FLAGS
argument_list|)
expr_stmt|;
name|mkdir2
operator|->
name|md_list
operator|.
name|wk_type
operator|=
name|D_MKDIR
expr_stmt|;
name|mkdir2
operator|->
name|md_state
operator|=
name|MKDIR_PARENT
expr_stmt|;
name|mkdir2
operator|->
name|md_diradd
operator|=
name|dap
expr_stmt|;
comment|/* 		 * Dependency on "." and ".." being written to disk. 		 */
name|mkdir1
operator|->
name|md_buf
operator|=
name|newdirbp
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|mkdirlisthd
argument_list|,
name|mkdir1
argument_list|,
name|md_mkdirs
argument_list|)
expr_stmt|;
name|WORKLIST_INSERT
argument_list|(
operator|&
name|newdirbp
operator|->
name|b_dep
argument_list|,
operator|&
name|mkdir1
operator|->
name|md_list
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|bdwrite
argument_list|(
name|newdirbp
argument_list|)
expr_stmt|;
comment|/* 		 * Dependency on link count increase for parent directory 		 */
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
if|if
condition|(
name|inodedep_lookup
argument_list|(
name|dp
operator|->
name|i_fs
argument_list|,
name|dp
operator|->
name|i_number
argument_list|,
literal|0
argument_list|,
operator|&
name|inodedep
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|inodedep
operator|->
name|id_state
operator|&
name|ALLCOMPLETE
operator|)
operator|==
name|ALLCOMPLETE
condition|)
block|{
name|dap
operator|->
name|da_state
operator|&=
operator|~
name|MKDIR_PARENT
expr_stmt|;
name|WORKITEM_FREE
argument_list|(
name|mkdir2
argument_list|,
name|D_MKDIR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|mkdirlisthd
argument_list|,
name|mkdir2
argument_list|,
name|md_mkdirs
argument_list|)
expr_stmt|;
name|WORKLIST_INSERT
argument_list|(
operator|&
name|inodedep
operator|->
name|id_bufwait
argument_list|,
operator|&
name|mkdir2
operator|->
name|md_list
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Link into parent directory pagedep to await its being written. 	 */
if|if
condition|(
name|pagedep_lookup
argument_list|(
name|dp
argument_list|,
name|lbn
argument_list|,
name|DEPALLOC
argument_list|,
operator|&
name|pagedep
argument_list|)
operator|==
literal|0
condition|)
name|WORKLIST_INSERT
argument_list|(
operator|&
name|bp
operator|->
name|b_dep
argument_list|,
operator|&
name|pagedep
operator|->
name|pd_list
argument_list|)
expr_stmt|;
name|dap
operator|->
name|da_pagedep
operator|=
name|pagedep
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|pagedep
operator|->
name|pd_diraddhd
index|[
name|DIRADDHASH
argument_list|(
name|offset
argument_list|)
index|]
argument_list|,
name|dap
argument_list|,
name|da_pdlist
argument_list|)
expr_stmt|;
comment|/* 	 * Link into its inodedep. Put it on the id_bufwait list if the inode 	 * is not yet written. If it is written, do the post-inode write 	 * processing to put it on the id_pendinghd list. 	 */
operator|(
name|void
operator|)
name|inodedep_lookup
argument_list|(
name|fs
argument_list|,
name|newinum
argument_list|,
name|DEPALLOC
argument_list|,
operator|&
name|inodedep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inodedep
operator|->
name|id_state
operator|&
name|ALLCOMPLETE
operator|)
operator|==
name|ALLCOMPLETE
condition|)
name|diradd_inode_written
argument_list|(
name|dap
argument_list|,
name|inodedep
argument_list|)
expr_stmt|;
else|else
name|WORKLIST_INSERT
argument_list|(
operator|&
name|inodedep
operator|->
name|id_bufwait
argument_list|,
operator|&
name|dap
operator|->
name|da_list
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This procedure is called to change the offset of a directory  * entry when compacting a directory block which must be owned  * exclusively by the caller. Note that the actual entry movement  * must be done in this procedure to ensure that no I/O completions  * occur while the move is in progress.  */
end_comment

begin_function
name|void
name|softdep_change_directoryentry_offset
parameter_list|(
name|dp
parameter_list|,
name|base
parameter_list|,
name|oldloc
parameter_list|,
name|newloc
parameter_list|,
name|entrysize
parameter_list|)
name|struct
name|inode
modifier|*
name|dp
decl_stmt|;
comment|/* inode for directory */
name|caddr_t
name|base
decl_stmt|;
comment|/* address of dp->i_offset */
name|caddr_t
name|oldloc
decl_stmt|;
comment|/* address of old directory location */
name|caddr_t
name|newloc
decl_stmt|;
comment|/* address of new directory location */
name|int
name|entrysize
decl_stmt|;
comment|/* size of directory entry */
block|{
name|int
name|offset
decl_stmt|,
name|oldoffset
decl_stmt|,
name|newoffset
decl_stmt|;
name|struct
name|pagedep
modifier|*
name|pagedep
decl_stmt|;
name|struct
name|diradd
modifier|*
name|dap
decl_stmt|;
name|ufs_lbn_t
name|lbn
decl_stmt|;
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|lbn
operator|=
name|lblkno
argument_list|(
name|dp
operator|->
name|i_fs
argument_list|,
name|dp
operator|->
name|i_offset
argument_list|)
expr_stmt|;
name|offset
operator|=
name|blkoff
argument_list|(
name|dp
operator|->
name|i_fs
argument_list|,
name|dp
operator|->
name|i_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|pagedep_lookup
argument_list|(
name|dp
argument_list|,
name|lbn
argument_list|,
literal|0
argument_list|,
operator|&
name|pagedep
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
name|oldoffset
operator|=
name|offset
operator|+
operator|(
name|oldloc
operator|-
name|base
operator|)
expr_stmt|;
name|newoffset
operator|=
name|offset
operator|+
operator|(
name|newloc
operator|-
name|base
operator|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|dap
argument_list|,
argument|&pagedep->pd_diraddhd[DIRADDHASH(oldoffset)]
argument_list|,
argument|da_pdlist
argument_list|)
block|{
if|if
condition|(
name|dap
operator|->
name|da_offset
operator|!=
name|oldoffset
condition|)
continue|continue;
name|dap
operator|->
name|da_offset
operator|=
name|newoffset
expr_stmt|;
if|if
condition|(
name|DIRADDHASH
argument_list|(
name|newoffset
argument_list|)
operator|==
name|DIRADDHASH
argument_list|(
name|oldoffset
argument_list|)
condition|)
break|break;
name|LIST_REMOVE
argument_list|(
name|dap
argument_list|,
name|da_pdlist
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|pagedep
operator|->
name|pd_diraddhd
index|[
name|DIRADDHASH
argument_list|(
name|newoffset
argument_list|)
index|]
argument_list|,
name|dap
argument_list|,
name|da_pdlist
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dap
operator|==
name|NULL
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|dap
argument_list|,
argument|&pagedep->pd_pendinghd
argument_list|,
argument|da_pdlist
argument_list|)
block|{
if|if
condition|(
name|dap
operator|->
name|da_offset
operator|==
name|oldoffset
condition|)
block|{
name|dap
operator|->
name|da_offset
operator|=
name|newoffset
expr_stmt|;
break|break;
block|}
block|}
block|}
name|done
label|:
name|bcopy
argument_list|(
name|oldloc
argument_list|,
name|newloc
argument_list|,
name|entrysize
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free a diradd dependency structure. This routine must be called  * with splbio interrupts blocked.  */
end_comment

begin_function
specifier|static
name|void
name|free_diradd
parameter_list|(
name|dap
parameter_list|)
name|struct
name|diradd
modifier|*
name|dap
decl_stmt|;
block|{
name|struct
name|dirrem
modifier|*
name|dirrem
decl_stmt|;
name|struct
name|pagedep
modifier|*
name|pagedep
decl_stmt|;
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|mkdir
modifier|*
name|mkdir
decl_stmt|,
modifier|*
name|nextmd
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|lk
operator|.
name|lkt_held
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"free_diradd: lock not held"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|WORKLIST_REMOVE
argument_list|(
operator|&
name|dap
operator|->
name|da_list
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|dap
argument_list|,
name|da_pdlist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dap
operator|->
name|da_state
operator|&
name|DIRCHG
operator|)
operator|==
literal|0
condition|)
block|{
name|pagedep
operator|=
name|dap
operator|->
name|da_pagedep
expr_stmt|;
block|}
else|else
block|{
name|dirrem
operator|=
name|dap
operator|->
name|da_previous
expr_stmt|;
name|pagedep
operator|=
name|dirrem
operator|->
name|dm_pagedep
expr_stmt|;
name|dirrem
operator|->
name|dm_dirinum
operator|=
name|pagedep
operator|->
name|pd_ino
expr_stmt|;
name|add_to_worklist
argument_list|(
operator|&
name|dirrem
operator|->
name|dm_list
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inodedep_lookup
argument_list|(
name|VFSTOUFS
argument_list|(
name|pagedep
operator|->
name|pd_mnt
argument_list|)
operator|->
name|um_fs
argument_list|,
name|dap
operator|->
name|da_newinum
argument_list|,
literal|0
argument_list|,
operator|&
name|inodedep
argument_list|)
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|free_inodedep
argument_list|(
name|inodedep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dap
operator|->
name|da_state
operator|&
operator|(
name|MKDIR_PARENT
operator||
name|MKDIR_BODY
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|mkdir
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|mkdirlisthd
argument_list|)
init|;
name|mkdir
condition|;
name|mkdir
operator|=
name|nextmd
control|)
block|{
name|nextmd
operator|=
name|LIST_NEXT
argument_list|(
name|mkdir
argument_list|,
name|md_mkdirs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mkdir
operator|->
name|md_diradd
operator|!=
name|dap
condition|)
continue|continue;
name|dap
operator|->
name|da_state
operator|&=
operator|~
name|mkdir
operator|->
name|md_state
expr_stmt|;
name|WORKLIST_REMOVE
argument_list|(
operator|&
name|mkdir
operator|->
name|md_list
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|mkdir
argument_list|,
name|md_mkdirs
argument_list|)
expr_stmt|;
name|WORKITEM_FREE
argument_list|(
name|mkdir
argument_list|,
name|D_MKDIR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dap
operator|->
name|da_state
operator|&
operator|(
name|MKDIR_PARENT
operator||
name|MKDIR_BODY
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"free_diradd: unfound ref"
argument_list|)
expr_stmt|;
block|}
block|}
name|WORKITEM_FREE
argument_list|(
name|dap
argument_list|,
name|D_DIRADD
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Directory entry removal dependencies.  *   * When removing a directory entry, the entry's inode pointer must be  * zero'ed on disk before the corresponding inode's link count is decremented  * (possibly freeing the inode for re-use). This dependency is handled by  * updating the directory entry but delaying the inode count reduction until  * after the directory block has been written to disk. After this point, the  * inode count can be decremented whenever it is convenient.  */
end_comment

begin_comment
comment|/*  * This routine should be called immediately after removing  * a directory entry.  The inode's link count should not be  * decremented by the calling procedure -- the soft updates  * code will do this task when it is safe.  */
end_comment

begin_function
name|void
name|softdep_setup_remove
parameter_list|(
name|bp
parameter_list|,
name|dp
parameter_list|,
name|ip
parameter_list|,
name|isrmdir
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
comment|/* buffer containing directory block */
name|struct
name|inode
modifier|*
name|dp
decl_stmt|;
comment|/* inode for the directory being modified */
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
comment|/* inode for directory entry being removed */
name|int
name|isrmdir
decl_stmt|;
comment|/* indicates if doing RMDIR */
block|{
name|struct
name|dirrem
modifier|*
name|dirrem
decl_stmt|,
modifier|*
name|prevdirrem
decl_stmt|;
comment|/* 	 * Allocate a new dirrem if appropriate and ACQUIRE_LOCK. 	 */
name|dirrem
operator|=
name|newdirrem
argument_list|(
name|bp
argument_list|,
name|dp
argument_list|,
name|ip
argument_list|,
name|isrmdir
argument_list|,
operator|&
name|prevdirrem
argument_list|)
expr_stmt|;
comment|/* 	 * If the COMPLETE flag is clear, then there were no active 	 * entries and we want to roll back to a zeroed entry until 	 * the new inode is committed to disk. If the COMPLETE flag is 	 * set then we have deleted an entry that never made it to 	 * disk. If the entry we deleted resulted from a name change, 	 * then the old name still resides on disk. We cannot delete 	 * its inode (returned to us in prevdirrem) until the zeroed 	 * directory entry gets to disk. The new inode has never been 	 * referenced on the disk, so can be deleted immediately. 	 */
if|if
condition|(
operator|(
name|dirrem
operator|->
name|dm_state
operator|&
name|COMPLETE
operator|)
operator|==
literal|0
condition|)
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|dirrem
operator|->
name|dm_pagedep
operator|->
name|pd_dirremhd
argument_list|,
name|dirrem
argument_list|,
name|dm_next
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|prevdirrem
operator|!=
name|NULL
condition|)
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|dirrem
operator|->
name|dm_pagedep
operator|->
name|pd_dirremhd
argument_list|,
name|prevdirrem
argument_list|,
name|dm_next
argument_list|)
expr_stmt|;
name|dirrem
operator|->
name|dm_dirinum
operator|=
name|dirrem
operator|->
name|dm_pagedep
operator|->
name|pd_ino
expr_stmt|;
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|handle_workitem_remove
argument_list|(
name|dirrem
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Allocate a new dirrem if appropriate and return it along with  * its associated pagedep. Called without a lock, returns with lock.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|num_dirrem
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of dirrem allocated */
end_comment

begin_function
specifier|static
name|struct
name|dirrem
modifier|*
name|newdirrem
parameter_list|(
name|bp
parameter_list|,
name|dp
parameter_list|,
name|ip
parameter_list|,
name|isrmdir
parameter_list|,
name|prevdirremp
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
comment|/* buffer containing directory block */
name|struct
name|inode
modifier|*
name|dp
decl_stmt|;
comment|/* inode for the directory being modified */
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
comment|/* inode for directory entry being removed */
name|int
name|isrmdir
decl_stmt|;
comment|/* indicates if doing RMDIR */
name|struct
name|dirrem
modifier|*
modifier|*
name|prevdirremp
decl_stmt|;
comment|/* previously referenced inode, if any */
block|{
name|int
name|offset
decl_stmt|;
name|ufs_lbn_t
name|lbn
decl_stmt|;
name|struct
name|diradd
modifier|*
name|dap
decl_stmt|;
name|struct
name|dirrem
modifier|*
name|dirrem
decl_stmt|;
name|struct
name|pagedep
modifier|*
name|pagedep
decl_stmt|;
comment|/* 	 * Whiteouts have no deletion dependencies. 	 */
if|if
condition|(
name|ip
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"newdirrem: whiteout"
argument_list|)
expr_stmt|;
comment|/* 	 * If we are over our limit, try to improve the situation. 	 * Limiting the number of dirrem structures will also limit 	 * the number of freefile and freeblks structures. 	 */
if|if
condition|(
name|num_dirrem
operator|>
name|max_softdeps
operator|/
literal|2
operator|&&
name|speedup_syncer
argument_list|()
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|request_cleanup
argument_list|(
name|FLUSH_REMOVE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|num_dirrem
operator|+=
literal|1
expr_stmt|;
name|MALLOC
argument_list|(
name|dirrem
argument_list|,
expr|struct
name|dirrem
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dirrem
argument_list|)
argument_list|,
name|M_DIRREM
argument_list|,
name|M_SOFTDEP_FLAGS
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|dirrem
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dirrem
argument_list|)
argument_list|)
expr_stmt|;
name|dirrem
operator|->
name|dm_list
operator|.
name|wk_type
operator|=
name|D_DIRREM
expr_stmt|;
name|dirrem
operator|->
name|dm_state
operator|=
name|isrmdir
condition|?
name|RMDIR
else|:
literal|0
expr_stmt|;
name|dirrem
operator|->
name|dm_mnt
operator|=
name|ITOV
argument_list|(
name|ip
argument_list|)
operator|->
name|v_mount
expr_stmt|;
name|dirrem
operator|->
name|dm_oldinum
operator|=
name|ip
operator|->
name|i_number
expr_stmt|;
operator|*
name|prevdirremp
operator|=
name|NULL
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|lbn
operator|=
name|lblkno
argument_list|(
name|dp
operator|->
name|i_fs
argument_list|,
name|dp
operator|->
name|i_offset
argument_list|)
expr_stmt|;
name|offset
operator|=
name|blkoff
argument_list|(
name|dp
operator|->
name|i_fs
argument_list|,
name|dp
operator|->
name|i_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|pagedep_lookup
argument_list|(
name|dp
argument_list|,
name|lbn
argument_list|,
name|DEPALLOC
argument_list|,
operator|&
name|pagedep
argument_list|)
operator|==
literal|0
condition|)
name|WORKLIST_INSERT
argument_list|(
operator|&
name|bp
operator|->
name|b_dep
argument_list|,
operator|&
name|pagedep
operator|->
name|pd_list
argument_list|)
expr_stmt|;
name|dirrem
operator|->
name|dm_pagedep
operator|=
name|pagedep
expr_stmt|;
comment|/* 	 * Check for a diradd dependency for the same directory entry. 	 * If present, then both dependencies become obsolete and can 	 * be de-allocated. Check for an entry on both the pd_dirraddhd 	 * list and the pd_pendinghd list. 	 */
name|LIST_FOREACH
argument_list|(
argument|dap
argument_list|,
argument|&pagedep->pd_diraddhd[DIRADDHASH(offset)]
argument_list|,
argument|da_pdlist
argument_list|)
if|if
condition|(
name|dap
operator|->
name|da_offset
operator|==
name|offset
condition|)
break|break;
if|if
condition|(
name|dap
operator|==
name|NULL
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|dap
argument_list|,
argument|&pagedep->pd_pendinghd
argument_list|,
argument|da_pdlist
argument_list|)
if|if
condition|(
name|dap
operator|->
name|da_offset
operator|==
name|offset
condition|)
break|break;
if|if
condition|(
name|dap
operator|==
name|NULL
condition|)
return|return
operator|(
name|dirrem
operator|)
return|;
block|}
comment|/* 	 * Must be ATTACHED at this point. 	 */
if|if
condition|(
operator|(
name|dap
operator|->
name|da_state
operator|&
name|ATTACHED
operator|)
operator|==
literal|0
condition|)
block|{
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"newdirrem: not ATTACHED"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dap
operator|->
name|da_newinum
operator|!=
name|ip
operator|->
name|i_number
condition|)
block|{
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"newdirrem: inum %d should be %d"
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
name|dap
operator|->
name|da_newinum
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we are deleting a changed name that never made it to disk, 	 * then return the dirrem describing the previous inode (which 	 * represents the inode currently referenced from this entry on disk). 	 */
if|if
condition|(
operator|(
name|dap
operator|->
name|da_state
operator|&
name|DIRCHG
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|prevdirremp
operator|=
name|dap
operator|->
name|da_previous
expr_stmt|;
name|dap
operator|->
name|da_state
operator|&=
operator|~
name|DIRCHG
expr_stmt|;
name|dap
operator|->
name|da_pagedep
operator|=
name|pagedep
expr_stmt|;
block|}
comment|/* 	 * We are deleting an entry that never made it to disk. 	 * Mark it COMPLETE so we can delete its inode immediately. 	 */
name|dirrem
operator|->
name|dm_state
operator||=
name|COMPLETE
expr_stmt|;
name|free_diradd
argument_list|(
name|dap
argument_list|)
expr_stmt|;
return|return
operator|(
name|dirrem
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Directory entry change dependencies.  *   * Changing an existing directory entry requires that an add operation  * be completed first followed by a deletion. The semantics for the addition  * are identical to the description of adding a new entry above except  * that the rollback is to the old inode number rather than zero. Once  * the addition dependency is completed, the removal is done as described  * in the removal routine above.  */
end_comment

begin_comment
comment|/*  * This routine should be called immediately after changing  * a directory entry.  The inode's link count should not be  * decremented by the calling procedure -- the soft updates  * code will perform this task when it is safe.  */
end_comment

begin_function
name|void
name|softdep_setup_directory_change
parameter_list|(
name|bp
parameter_list|,
name|dp
parameter_list|,
name|ip
parameter_list|,
name|newinum
parameter_list|,
name|isrmdir
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
comment|/* buffer containing directory block */
name|struct
name|inode
modifier|*
name|dp
decl_stmt|;
comment|/* inode for the directory being modified */
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
comment|/* inode for directory entry being removed */
name|long
name|newinum
decl_stmt|;
comment|/* new inode number for changed entry */
name|int
name|isrmdir
decl_stmt|;
comment|/* indicates if doing RMDIR */
block|{
name|int
name|offset
decl_stmt|;
name|struct
name|diradd
modifier|*
name|dap
init|=
name|NULL
decl_stmt|;
name|struct
name|dirrem
modifier|*
name|dirrem
decl_stmt|,
modifier|*
name|prevdirrem
decl_stmt|;
name|struct
name|pagedep
modifier|*
name|pagedep
decl_stmt|;
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|offset
operator|=
name|blkoff
argument_list|(
name|dp
operator|->
name|i_fs
argument_list|,
name|dp
operator|->
name|i_offset
argument_list|)
expr_stmt|;
comment|/* 	 * Whiteouts do not need diradd dependencies. 	 */
if|if
condition|(
name|newinum
operator|!=
name|WINO
condition|)
block|{
name|MALLOC
argument_list|(
name|dap
argument_list|,
expr|struct
name|diradd
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|diradd
argument_list|)
argument_list|,
name|M_DIRADD
argument_list|,
name|M_SOFTDEP_FLAGS
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|dap
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|diradd
argument_list|)
argument_list|)
expr_stmt|;
name|dap
operator|->
name|da_list
operator|.
name|wk_type
operator|=
name|D_DIRADD
expr_stmt|;
name|dap
operator|->
name|da_state
operator|=
name|DIRCHG
operator||
name|ATTACHED
operator||
name|DEPCOMPLETE
expr_stmt|;
name|dap
operator|->
name|da_offset
operator|=
name|offset
expr_stmt|;
name|dap
operator|->
name|da_newinum
operator|=
name|newinum
expr_stmt|;
block|}
comment|/* 	 * Allocate a new dirrem and ACQUIRE_LOCK. 	 */
name|dirrem
operator|=
name|newdirrem
argument_list|(
name|bp
argument_list|,
name|dp
argument_list|,
name|ip
argument_list|,
name|isrmdir
argument_list|,
operator|&
name|prevdirrem
argument_list|)
expr_stmt|;
name|pagedep
operator|=
name|dirrem
operator|->
name|dm_pagedep
expr_stmt|;
comment|/* 	 * The possible values for isrmdir: 	 *	0 - non-directory file rename 	 *	1 - directory rename within same directory 	 *   inum - directory rename to new directory of given inode number 	 * When renaming to a new directory, we are both deleting and 	 * creating a new directory entry, so the link count on the new 	 * directory should not change. Thus we do not need the followup 	 * dirrem which is usually done in handle_workitem_remove. We set 	 * the DIRCHG flag to tell handle_workitem_remove to skip the  	 * followup dirrem. 	 */
if|if
condition|(
name|isrmdir
operator|>
literal|1
condition|)
name|dirrem
operator|->
name|dm_state
operator||=
name|DIRCHG
expr_stmt|;
comment|/* 	 * Whiteouts have no additional dependencies, 	 * so just put the dirrem on the correct list. 	 */
if|if
condition|(
name|newinum
operator|==
name|WINO
condition|)
block|{
if|if
condition|(
operator|(
name|dirrem
operator|->
name|dm_state
operator|&
name|COMPLETE
operator|)
operator|==
literal|0
condition|)
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|pagedep
operator|->
name|pd_dirremhd
argument_list|,
name|dirrem
argument_list|,
name|dm_next
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dirrem
operator|->
name|dm_dirinum
operator|=
name|pagedep
operator|->
name|pd_ino
expr_stmt|;
name|add_to_worklist
argument_list|(
operator|&
name|dirrem
operator|->
name|dm_list
argument_list|)
expr_stmt|;
block|}
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If the COMPLETE flag is clear, then there were no active 	 * entries and we want to roll back to the previous inode until 	 * the new inode is committed to disk. If the COMPLETE flag is 	 * set, then we have deleted an entry that never made it to disk. 	 * If the entry we deleted resulted from a name change, then the old 	 * inode reference still resides on disk. Any rollback that we do 	 * needs to be to that old inode (returned to us in prevdirrem). If 	 * the entry we deleted resulted from a create, then there is 	 * no entry on the disk, so we want to roll back to zero rather 	 * than the uncommitted inode. In either of the COMPLETE cases we 	 * want to immediately free the unwritten and unreferenced inode. 	 */
if|if
condition|(
operator|(
name|dirrem
operator|->
name|dm_state
operator|&
name|COMPLETE
operator|)
operator|==
literal|0
condition|)
block|{
name|dap
operator|->
name|da_previous
operator|=
name|dirrem
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|prevdirrem
operator|!=
name|NULL
condition|)
block|{
name|dap
operator|->
name|da_previous
operator|=
name|prevdirrem
expr_stmt|;
block|}
else|else
block|{
name|dap
operator|->
name|da_state
operator|&=
operator|~
name|DIRCHG
expr_stmt|;
name|dap
operator|->
name|da_pagedep
operator|=
name|pagedep
expr_stmt|;
block|}
name|dirrem
operator|->
name|dm_dirinum
operator|=
name|pagedep
operator|->
name|pd_ino
expr_stmt|;
name|add_to_worklist
argument_list|(
operator|&
name|dirrem
operator|->
name|dm_list
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Link into its inodedep. Put it on the id_bufwait list if the inode 	 * is not yet written. If it is written, do the post-inode write 	 * processing to put it on the id_pendinghd list. 	 */
if|if
condition|(
name|inodedep_lookup
argument_list|(
name|dp
operator|->
name|i_fs
argument_list|,
name|newinum
argument_list|,
name|DEPALLOC
argument_list|,
operator|&
name|inodedep
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|inodedep
operator|->
name|id_state
operator|&
name|ALLCOMPLETE
operator|)
operator|==
name|ALLCOMPLETE
condition|)
block|{
name|dap
operator|->
name|da_state
operator||=
name|COMPLETE
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|pagedep
operator|->
name|pd_pendinghd
argument_list|,
name|dap
argument_list|,
name|da_pdlist
argument_list|)
expr_stmt|;
name|WORKLIST_INSERT
argument_list|(
operator|&
name|inodedep
operator|->
name|id_pendinghd
argument_list|,
operator|&
name|dap
operator|->
name|da_list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|pagedep
operator|->
name|pd_diraddhd
index|[
name|DIRADDHASH
argument_list|(
name|offset
argument_list|)
index|]
argument_list|,
name|dap
argument_list|,
name|da_pdlist
argument_list|)
expr_stmt|;
name|WORKLIST_INSERT
argument_list|(
operator|&
name|inodedep
operator|->
name|id_bufwait
argument_list|,
operator|&
name|dap
operator|->
name|da_list
argument_list|)
expr_stmt|;
block|}
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called whenever the link count on an inode is changed.  * It creates an inode dependency so that the new reference(s)  * to the inode cannot be committed to disk until the updated  * inode has been written.  */
end_comment

begin_function
name|void
name|softdep_change_linkcnt
parameter_list|(
name|ip
parameter_list|)
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
comment|/* the inode with the increased link count */
block|{
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inodedep_lookup
argument_list|(
name|ip
operator|->
name|i_fs
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
name|DEPALLOC
argument_list|,
operator|&
name|inodedep
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_nlink
operator|<
name|ip
operator|->
name|i_effnlink
condition|)
block|{
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"softdep_change_linkcnt: bad delta"
argument_list|)
expr_stmt|;
block|}
name|inodedep
operator|->
name|id_nlinkdelta
operator|=
name|ip
operator|->
name|i_nlink
operator|-
name|ip
operator|->
name|i_effnlink
expr_stmt|;
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This workitem decrements the inode's link count.  * If the link count reaches zero, the file is removed.  */
end_comment

begin_function
specifier|static
name|void
name|handle_workitem_remove
parameter_list|(
name|dirrem
parameter_list|)
name|struct
name|dirrem
modifier|*
name|dirrem
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|CURPROC
decl_stmt|;
comment|/* XXX */
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|ino_t
name|oldinum
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|VFS_VGET
argument_list|(
name|dirrem
operator|->
name|dm_mnt
argument_list|,
name|dirrem
operator|->
name|dm_oldinum
argument_list|,
operator|&
name|vp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|softdep_error
argument_list|(
literal|"handle_workitem_remove: vget"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
name|ip
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inodedep_lookup
argument_list|(
name|ip
operator|->
name|i_fs
argument_list|,
name|dirrem
operator|->
name|dm_oldinum
argument_list|,
literal|0
argument_list|,
operator|&
name|inodedep
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"handle_workitem_remove: lost inodedep"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Normal file deletion. 	 */
if|if
condition|(
operator|(
name|dirrem
operator|->
name|dm_state
operator|&
name|RMDIR
operator|)
operator|==
literal|0
condition|)
block|{
name|ip
operator|->
name|i_nlink
operator|--
expr_stmt|;
name|ip
operator|->
name|i_flag
operator||=
name|IN_CHANGE
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_nlink
operator|<
name|ip
operator|->
name|i_effnlink
condition|)
block|{
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"handle_workitem_remove: bad file delta"
argument_list|)
expr_stmt|;
block|}
name|inodedep
operator|->
name|id_nlinkdelta
operator|=
name|ip
operator|->
name|i_nlink
operator|-
name|ip
operator|->
name|i_effnlink
expr_stmt|;
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|num_dirrem
operator|-=
literal|1
expr_stmt|;
name|WORKITEM_FREE
argument_list|(
name|dirrem
argument_list|,
name|D_DIRREM
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Directory deletion. Decrement reference count for both the 	 * just deleted parent directory entry and the reference for ".". 	 * Next truncate the directory to length zero. When the 	 * truncation completes, arrange to have the reference count on 	 * the parent decremented to account for the loss of "..". 	 */
name|ip
operator|->
name|i_nlink
operator|-=
literal|2
expr_stmt|;
name|ip
operator|->
name|i_flag
operator||=
name|IN_CHANGE
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_nlink
operator|<
name|ip
operator|->
name|i_effnlink
condition|)
block|{
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"handle_workitem_remove: bad dir delta"
argument_list|)
expr_stmt|;
block|}
name|inodedep
operator|->
name|id_nlinkdelta
operator|=
name|ip
operator|->
name|i_nlink
operator|-
name|ip
operator|->
name|i_effnlink
expr_stmt|;
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|UFS_TRUNCATE
argument_list|(
name|vp
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
name|p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|softdep_error
argument_list|(
literal|"handle_workitem_remove: truncate"
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* 	 * Rename a directory to a new parent. Since, we are both deleting 	 * and creating a new directory entry, the link count on the new 	 * directory should not change. Thus we skip the followup dirrem. 	 */
if|if
condition|(
name|dirrem
operator|->
name|dm_state
operator|&
name|DIRCHG
condition|)
block|{
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|num_dirrem
operator|-=
literal|1
expr_stmt|;
name|WORKITEM_FREE
argument_list|(
name|dirrem
argument_list|,
name|D_DIRREM
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If the inodedep does not exist, then the zero'ed inode has 	 * been written to disk. If the allocated inode has never been 	 * written to disk, then the on-disk inode is zero'ed. In either 	 * case we can remove the file immediately. 	 */
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|dirrem
operator|->
name|dm_state
operator|=
literal|0
expr_stmt|;
name|oldinum
operator|=
name|dirrem
operator|->
name|dm_oldinum
expr_stmt|;
name|dirrem
operator|->
name|dm_oldinum
operator|=
name|dirrem
operator|->
name|dm_dirinum
expr_stmt|;
if|if
condition|(
name|inodedep_lookup
argument_list|(
name|ip
operator|->
name|i_fs
argument_list|,
name|oldinum
argument_list|,
literal|0
argument_list|,
operator|&
name|inodedep
argument_list|)
operator|==
literal|0
operator|||
name|check_inode_unwritten
argument_list|(
name|inodedep
argument_list|)
condition|)
block|{
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|handle_workitem_remove
argument_list|(
name|dirrem
argument_list|)
expr_stmt|;
return|return;
block|}
name|WORKLIST_INSERT
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inowait
argument_list|,
operator|&
name|dirrem
operator|->
name|dm_list
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Inode de-allocation dependencies.  *   * When an inode's link count is reduced to zero, it can be de-allocated. We  * found it convenient to postpone de-allocation until after the inode is  * written to disk with its new link count (zero).  At this point, all of the  * on-disk inode's block pointers are nullified and, with careful dependency  * list ordering, all dependencies related to the inode will be satisfied and  * the corresponding dependency structures de-allocated.  So, if/when the  * inode is reused, there will be no mixing of old dependencies with new  * ones.  This artificial dependency is set up by the block de-allocation  * procedure above (softdep_setup_freeblocks) and completed by the  * following procedure.  */
end_comment

begin_function
specifier|static
name|void
name|handle_workitem_freefile
parameter_list|(
name|freefile
parameter_list|)
name|struct
name|freefile
modifier|*
name|freefile
decl_stmt|;
block|{
name|struct
name|vnode
name|vp
decl_stmt|;
name|struct
name|inode
name|tip
decl_stmt|;
name|struct
name|inodedep
modifier|*
name|idp
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|error
operator|=
name|inodedep_lookup
argument_list|(
name|freefile
operator|->
name|fx_fs
argument_list|,
name|freefile
operator|->
name|fx_oldinum
argument_list|,
literal|0
argument_list|,
operator|&
name|idp
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|panic
argument_list|(
literal|"handle_workitem_freefile: inodedep survived"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tip
operator|.
name|i_devvp
operator|=
name|freefile
operator|->
name|fx_devvp
expr_stmt|;
name|tip
operator|.
name|i_dev
operator|=
name|freefile
operator|->
name|fx_devvp
operator|->
name|v_rdev
expr_stmt|;
name|tip
operator|.
name|i_fs
operator|=
name|freefile
operator|->
name|fx_fs
expr_stmt|;
name|vp
operator|.
name|v_data
operator|=
operator|&
name|tip
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ffs_freefile
argument_list|(
operator|&
name|vp
argument_list|,
name|freefile
operator|->
name|fx_oldinum
argument_list|,
name|freefile
operator|->
name|fx_mode
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|softdep_error
argument_list|(
literal|"handle_workitem_freefile"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|WORKITEM_FREE
argument_list|(
name|freefile
argument_list|,
name|D_FREEFILE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Disk writes.  *   * The dependency structures constructed above are most actively used when file  * system blocks are written to disk.  No constraints are placed on when a  * block can be written, but unsatisfied update dependencies are made safe by  * modifying (or replacing) the source memory for the duration of the disk  * write.  When the disk write completes, the memory block is again brought  * up-to-date.  *  * In-core inode structure reclamation.  *   * Because there are a finite number of "in-core" inode structures, they are  * reused regularly.  By transferring all inode-related dependencies to the  * in-memory inode block and indexing them separately (via "inodedep"s), we  * can allow "in-core" inode structures to be reused at any time and avoid  * any increase in contention.  *  * Called just before entering the device driver to initiate a new disk I/O.  * The buffer must be locked, thus, no I/O completion operations can occur  * while we are manipulating its associated dependencies.  */
end_comment

begin_function
specifier|static
name|void
name|softdep_disk_io_initiation
parameter_list|(
name|bp
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
comment|/* structure describing disk write to occur */
block|{
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|,
modifier|*
name|nextwk
decl_stmt|;
name|struct
name|indirdep
modifier|*
name|indirdep
decl_stmt|;
comment|/* 	 * We only care about write operations. There should never 	 * be dependencies for reads. 	 */
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
name|panic
argument_list|(
literal|"softdep_disk_io_initiation: read"
argument_list|)
expr_stmt|;
comment|/* 	 * Do any necessary pre-I/O processing. 	 */
for|for
control|(
name|wk
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|bp
operator|->
name|b_dep
argument_list|)
init|;
name|wk
condition|;
name|wk
operator|=
name|nextwk
control|)
block|{
name|nextwk
operator|=
name|LIST_NEXT
argument_list|(
name|wk
argument_list|,
name|wk_list
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|wk
operator|->
name|wk_type
condition|)
block|{
case|case
name|D_PAGEDEP
case|:
name|initiate_write_filepage
argument_list|(
name|WK_PAGEDEP
argument_list|(
name|wk
argument_list|)
argument_list|,
name|bp
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|D_INODEDEP
case|:
name|initiate_write_inodeblock
argument_list|(
name|WK_INODEDEP
argument_list|(
name|wk
argument_list|)
argument_list|,
name|bp
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|D_INDIRDEP
case|:
name|indirdep
operator|=
name|WK_INDIRDEP
argument_list|(
name|wk
argument_list|)
expr_stmt|;
if|if
condition|(
name|indirdep
operator|->
name|ir_state
operator|&
name|GOINGAWAY
condition|)
name|panic
argument_list|(
literal|"disk_io_initiation: indirdep gone"
argument_list|)
expr_stmt|;
comment|/* 			 * If there are no remaining dependencies, this 			 * will be writing the real pointers, so the 			 * dependency can be freed. 			 */
if|if
condition|(
name|LIST_FIRST
argument_list|(
operator|&
name|indirdep
operator|->
name|ir_deplisthd
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|indirdep
operator|->
name|ir_savebp
operator|->
name|b_flags
operator||=
name|B_INVAL
operator||
name|B_NOCACHE
expr_stmt|;
name|brelse
argument_list|(
name|indirdep
operator|->
name|ir_savebp
argument_list|)
expr_stmt|;
comment|/* inline expand WORKLIST_REMOVE(wk); */
name|wk
operator|->
name|wk_state
operator|&=
operator|~
name|ONWORKLIST
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|wk
argument_list|,
name|wk_list
argument_list|)
expr_stmt|;
name|WORKITEM_FREE
argument_list|(
name|indirdep
argument_list|,
name|D_INDIRDEP
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * Replace up-to-date version with safe version. 			 */
name|MALLOC
argument_list|(
name|indirdep
operator|->
name|ir_saveddata
argument_list|,
name|caddr_t
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|,
name|M_INDIRDEP
argument_list|,
name|M_SOFTDEP_FLAGS
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|indirdep
operator|->
name|ir_state
operator|&=
operator|~
name|ATTACHED
expr_stmt|;
name|indirdep
operator|->
name|ir_state
operator||=
name|UNDONE
expr_stmt|;
name|bcopy
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
name|indirdep
operator|->
name|ir_saveddata
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|indirdep
operator|->
name|ir_savebp
operator|->
name|b_data
argument_list|,
name|bp
operator|->
name|b_data
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|D_MKDIR
case|:
case|case
name|D_BMSAFEMAP
case|:
case|case
name|D_ALLOCDIRECT
case|:
case|case
name|D_ALLOCINDIR
case|:
continue|continue;
default|default:
name|panic
argument_list|(
literal|"handle_disk_io_initiation: Unexpected type %s"
argument_list|,
name|TYPENAME
argument_list|(
name|wk
operator|->
name|wk_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Called from within the procedure above to deal with unsatisfied  * allocation dependencies in a directory. The buffer must be locked,  * thus, no I/O completion operations can occur while we are  * manipulating its associated dependencies.  */
end_comment

begin_function
specifier|static
name|void
name|initiate_write_filepage
parameter_list|(
name|pagedep
parameter_list|,
name|bp
parameter_list|)
name|struct
name|pagedep
modifier|*
name|pagedep
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
name|struct
name|diradd
modifier|*
name|dap
decl_stmt|;
name|struct
name|direct
modifier|*
name|ep
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|pagedep
operator|->
name|pd_state
operator|&
name|IOSTARTED
condition|)
block|{
comment|/* 		 * This can only happen if there is a driver that does not 		 * understand chaining. Here biodone will reissue the call 		 * to strategy for the incomplete buffers. 		 */
name|printf
argument_list|(
literal|"initiate_write_filepage: already started\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pagedep
operator|->
name|pd_state
operator||=
name|IOSTARTED
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DAHASHSZ
condition|;
name|i
operator|++
control|)
block|{
name|LIST_FOREACH
argument_list|(
argument|dap
argument_list|,
argument|&pagedep->pd_diraddhd[i]
argument_list|,
argument|da_pdlist
argument_list|)
block|{
name|ep
operator|=
operator|(
expr|struct
name|direct
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|bp
operator|->
name|b_data
operator|+
name|dap
operator|->
name|da_offset
operator|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|d_ino
operator|!=
name|dap
operator|->
name|da_newinum
condition|)
block|{
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"%s: dir inum %d != new %d"
argument_list|,
literal|"initiate_write_filepage"
argument_list|,
name|ep
operator|->
name|d_ino
argument_list|,
name|dap
operator|->
name|da_newinum
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dap
operator|->
name|da_state
operator|&
name|DIRCHG
condition|)
name|ep
operator|->
name|d_ino
operator|=
name|dap
operator|->
name|da_previous
operator|->
name|dm_oldinum
expr_stmt|;
else|else
name|ep
operator|->
name|d_ino
operator|=
literal|0
expr_stmt|;
name|dap
operator|->
name|da_state
operator|&=
operator|~
name|ATTACHED
expr_stmt|;
name|dap
operator|->
name|da_state
operator||=
name|UNDONE
expr_stmt|;
block|}
block|}
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called from within the procedure above to deal with unsatisfied  * allocation dependencies in an inodeblock. The buffer must be  * locked, thus, no I/O completion operations can occur while we  * are manipulating its associated dependencies.  */
end_comment

begin_function
specifier|static
name|void
name|initiate_write_inodeblock
parameter_list|(
name|inodedep
parameter_list|,
name|bp
parameter_list|)
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
comment|/* The inode block */
block|{
name|struct
name|allocdirect
modifier|*
name|adp
decl_stmt|,
modifier|*
name|lastadp
decl_stmt|;
name|struct
name|dinode
modifier|*
name|dp
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|ufs_lbn_t
name|prevlbn
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|deplist
decl_stmt|;
if|if
condition|(
name|inodedep
operator|->
name|id_state
operator|&
name|IOSTARTED
condition|)
name|panic
argument_list|(
literal|"initiate_write_inodeblock: already started"
argument_list|)
expr_stmt|;
name|inodedep
operator|->
name|id_state
operator||=
name|IOSTARTED
expr_stmt|;
name|fs
operator|=
name|inodedep
operator|->
name|id_fs
expr_stmt|;
name|dp
operator|=
operator|(
expr|struct
name|dinode
operator|*
operator|)
name|bp
operator|->
name|b_data
operator|+
name|ino_to_fsbo
argument_list|(
name|fs
argument_list|,
name|inodedep
operator|->
name|id_ino
argument_list|)
expr_stmt|;
comment|/* 	 * If the bitmap is not yet written, then the allocated 	 * inode cannot be written to disk. 	 */
if|if
condition|(
operator|(
name|inodedep
operator|->
name|id_state
operator|&
name|DEPCOMPLETE
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|inodedep
operator|->
name|id_savedino
operator|!=
name|NULL
condition|)
name|panic
argument_list|(
literal|"initiate_write_inodeblock: already doing I/O"
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|inodedep
operator|->
name|id_savedino
argument_list|,
expr|struct
name|dinode
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dinode
argument_list|)
argument_list|,
name|M_INODEDEP
argument_list|,
name|M_SOFTDEP_FLAGS
argument_list|)
expr_stmt|;
operator|*
name|inodedep
operator|->
name|id_savedino
operator|=
operator|*
name|dp
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|dp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dinode
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If no dependencies, then there is nothing to roll back. 	 */
name|inodedep
operator|->
name|id_savedsize
operator|=
name|dp
operator|->
name|di_size
expr_stmt|;
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoupdt
argument_list|)
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * Set the dependencies to busy. 	 */
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
for|for
control|(
name|deplist
operator|=
literal|0
operator|,
name|adp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoupdt
argument_list|)
init|;
name|adp
condition|;
name|adp
operator|=
name|TAILQ_NEXT
argument_list|(
name|adp
argument_list|,
name|ad_next
argument_list|)
control|)
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|deplist
operator|!=
literal|0
operator|&&
name|prevlbn
operator|>=
name|adp
operator|->
name|ad_lbn
condition|)
block|{
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"softdep_write_inodeblock: lbn order"
argument_list|)
expr_stmt|;
block|}
name|prevlbn
operator|=
name|adp
operator|->
name|ad_lbn
expr_stmt|;
if|if
condition|(
name|adp
operator|->
name|ad_lbn
operator|<
name|NDADDR
operator|&&
name|dp
operator|->
name|di_db
index|[
name|adp
operator|->
name|ad_lbn
index|]
operator|!=
name|adp
operator|->
name|ad_newblkno
condition|)
block|{
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"%s: direct pointer #%ld mismatch %d != %d"
argument_list|,
literal|"softdep_write_inodeblock"
argument_list|,
name|adp
operator|->
name|ad_lbn
argument_list|,
name|dp
operator|->
name|di_db
index|[
name|adp
operator|->
name|ad_lbn
index|]
argument_list|,
name|adp
operator|->
name|ad_newblkno
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|adp
operator|->
name|ad_lbn
operator|>=
name|NDADDR
operator|&&
name|dp
operator|->
name|di_ib
index|[
name|adp
operator|->
name|ad_lbn
operator|-
name|NDADDR
index|]
operator|!=
name|adp
operator|->
name|ad_newblkno
condition|)
block|{
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"%s: indirect pointer #%ld mismatch %d != %d"
argument_list|,
literal|"softdep_write_inodeblock"
argument_list|,
name|adp
operator|->
name|ad_lbn
operator|-
name|NDADDR
argument_list|,
name|dp
operator|->
name|di_ib
index|[
name|adp
operator|->
name|ad_lbn
operator|-
name|NDADDR
index|]
argument_list|,
name|adp
operator|->
name|ad_newblkno
argument_list|)
expr_stmt|;
block|}
name|deplist
operator||=
literal|1
operator|<<
name|adp
operator|->
name|ad_lbn
expr_stmt|;
if|if
condition|(
operator|(
name|adp
operator|->
name|ad_state
operator|&
name|ATTACHED
operator|)
operator|==
literal|0
condition|)
block|{
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"softdep_write_inodeblock: Unknown state 0x%x"
argument_list|,
name|adp
operator|->
name|ad_state
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DIAGNOSTIC */
name|adp
operator|->
name|ad_state
operator|&=
operator|~
name|ATTACHED
expr_stmt|;
name|adp
operator|->
name|ad_state
operator||=
name|UNDONE
expr_stmt|;
block|}
comment|/* 	 * The on-disk inode cannot claim to be any larger than the last 	 * fragment that has been written. Otherwise, the on-disk inode 	 * might have fragments that were not the last block in the file 	 * which would corrupt the filesystem. 	 */
for|for
control|(
name|lastadp
operator|=
name|NULL
operator|,
name|adp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoupdt
argument_list|)
init|;
name|adp
condition|;
name|lastadp
operator|=
name|adp
operator|,
name|adp
operator|=
name|TAILQ_NEXT
argument_list|(
name|adp
argument_list|,
name|ad_next
argument_list|)
control|)
block|{
if|if
condition|(
name|adp
operator|->
name|ad_lbn
operator|>=
name|NDADDR
condition|)
break|break;
name|dp
operator|->
name|di_db
index|[
name|adp
operator|->
name|ad_lbn
index|]
operator|=
name|adp
operator|->
name|ad_oldblkno
expr_stmt|;
comment|/* keep going until hitting a rollback to a frag */
if|if
condition|(
name|adp
operator|->
name|ad_oldsize
operator|==
literal|0
operator|||
name|adp
operator|->
name|ad_oldsize
operator|==
name|fs
operator|->
name|fs_bsize
condition|)
continue|continue;
name|dp
operator|->
name|di_size
operator|=
name|fs
operator|->
name|fs_bsize
operator|*
name|adp
operator|->
name|ad_lbn
operator|+
name|adp
operator|->
name|ad_oldsize
expr_stmt|;
for|for
control|(
name|i
operator|=
name|adp
operator|->
name|ad_lbn
operator|+
literal|1
init|;
name|i
operator|<
name|NDADDR
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|dp
operator|->
name|di_db
index|[
name|i
index|]
operator|!=
literal|0
operator|&&
operator|(
name|deplist
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"softdep_write_inodeblock: lost dep1"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DIAGNOSTIC */
name|dp
operator|->
name|di_db
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NIADDR
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|dp
operator|->
name|di_ib
index|[
name|i
index|]
operator|!=
literal|0
operator|&&
operator|(
name|deplist
operator|&
operator|(
operator|(
literal|1
operator|<<
name|NDADDR
operator|)
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"softdep_write_inodeblock: lost dep2"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DIAGNOSTIC */
name|dp
operator|->
name|di_ib
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If we have zero'ed out the last allocated block of the file, 	 * roll back the size to the last currently allocated block. 	 * We know that this last allocated block is a full-sized as 	 * we already checked for fragments in the loop above. 	 */
if|if
condition|(
name|lastadp
operator|!=
name|NULL
operator|&&
name|dp
operator|->
name|di_size
operator|<=
operator|(
name|lastadp
operator|->
name|ad_lbn
operator|+
literal|1
operator|)
operator|*
name|fs
operator|->
name|fs_bsize
condition|)
block|{
for|for
control|(
name|i
operator|=
name|lastadp
operator|->
name|ad_lbn
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|dp
operator|->
name|di_db
index|[
name|i
index|]
operator|!=
literal|0
condition|)
break|break;
name|dp
operator|->
name|di_size
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
name|fs
operator|->
name|fs_bsize
expr_stmt|;
block|}
comment|/* 	 * The only dependencies are for indirect blocks. 	 * 	 * The file size for indirect block additions is not guaranteed. 	 * Such a guarantee would be non-trivial to achieve. The conventional 	 * synchronous write implementation also does not make this guarantee. 	 * Fsck should catch and fix discrepancies. Arguably, the file size 	 * can be over-estimated without destroying integrity when the file 	 * moves into the indirect blocks (i.e., is large). If we want to 	 * postpone fsck, we are stuck with this argument. 	 */
for|for
control|(
init|;
name|adp
condition|;
name|adp
operator|=
name|TAILQ_NEXT
argument_list|(
name|adp
argument_list|,
name|ad_next
argument_list|)
control|)
name|dp
operator|->
name|di_ib
index|[
name|adp
operator|->
name|ad_lbn
operator|-
name|NDADDR
index|]
operator|=
literal|0
expr_stmt|;
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine is called during the completion interrupt  * service routine for a disk write (from the procedure called  * by the device driver to inform the file system caches of  * a request completion).  It should be called early in this  * procedure, before the block is made available to other  * processes or other routines are called.  */
end_comment

begin_function
specifier|static
name|void
name|softdep_disk_write_complete
parameter_list|(
name|bp
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
comment|/* describes the completed disk write */
block|{
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
name|struct
name|workhead
name|reattach
decl_stmt|;
name|struct
name|newblk
modifier|*
name|newblk
decl_stmt|;
name|struct
name|allocindir
modifier|*
name|aip
decl_stmt|;
name|struct
name|allocdirect
modifier|*
name|adp
decl_stmt|;
name|struct
name|indirdep
modifier|*
name|indirdep
decl_stmt|;
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|bmsafemap
modifier|*
name|bmsafemap
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|lk
operator|.
name|lkt_held
operator|!=
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"softdep_disk_write_complete: lock is held"
argument_list|)
expr_stmt|;
name|lk
operator|.
name|lkt_held
operator|=
operator|-
literal|2
expr_stmt|;
endif|#
directive|endif
name|LIST_INIT
argument_list|(
operator|&
name|reattach
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|wk
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|bp
operator|->
name|b_dep
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|WORKLIST_REMOVE
argument_list|(
name|wk
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|wk
operator|->
name|wk_type
condition|)
block|{
case|case
name|D_PAGEDEP
case|:
if|if
condition|(
name|handle_written_filepage
argument_list|(
name|WK_PAGEDEP
argument_list|(
name|wk
argument_list|)
argument_list|,
name|bp
argument_list|)
condition|)
name|WORKLIST_INSERT
argument_list|(
operator|&
name|reattach
argument_list|,
name|wk
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|D_INODEDEP
case|:
if|if
condition|(
name|handle_written_inodeblock
argument_list|(
name|WK_INODEDEP
argument_list|(
name|wk
argument_list|)
argument_list|,
name|bp
argument_list|)
condition|)
name|WORKLIST_INSERT
argument_list|(
operator|&
name|reattach
argument_list|,
name|wk
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|D_BMSAFEMAP
case|:
name|bmsafemap
operator|=
name|WK_BMSAFEMAP
argument_list|(
name|wk
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|newblk
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|bmsafemap
operator|->
name|sm_newblkhd
argument_list|)
operator|)
condition|)
block|{
name|newblk
operator|->
name|nb_state
operator||=
name|DEPCOMPLETE
expr_stmt|;
name|newblk
operator|->
name|nb_bmsafemap
operator|=
name|NULL
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|newblk
argument_list|,
name|nb_deps
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|adp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|bmsafemap
operator|->
name|sm_allocdirecthd
argument_list|)
operator|)
condition|)
block|{
name|adp
operator|->
name|ad_state
operator||=
name|DEPCOMPLETE
expr_stmt|;
name|adp
operator|->
name|ad_buf
operator|=
name|NULL
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|adp
argument_list|,
name|ad_deps
argument_list|)
expr_stmt|;
name|handle_allocdirect_partdone
argument_list|(
name|adp
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|aip
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|bmsafemap
operator|->
name|sm_allocindirhd
argument_list|)
operator|)
condition|)
block|{
name|aip
operator|->
name|ai_state
operator||=
name|DEPCOMPLETE
expr_stmt|;
name|aip
operator|->
name|ai_buf
operator|=
name|NULL
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|aip
argument_list|,
name|ai_deps
argument_list|)
expr_stmt|;
name|handle_allocindir_partdone
argument_list|(
name|aip
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|inodedep
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|bmsafemap
operator|->
name|sm_inodedephd
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|inodedep
operator|->
name|id_state
operator||=
name|DEPCOMPLETE
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|inodedep
argument_list|,
name|id_deps
argument_list|)
expr_stmt|;
name|inodedep
operator|->
name|id_buf
operator|=
name|NULL
expr_stmt|;
block|}
name|WORKITEM_FREE
argument_list|(
name|bmsafemap
argument_list|,
name|D_BMSAFEMAP
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|D_MKDIR
case|:
name|handle_written_mkdir
argument_list|(
name|WK_MKDIR
argument_list|(
name|wk
argument_list|)
argument_list|,
name|MKDIR_BODY
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|D_ALLOCDIRECT
case|:
name|adp
operator|=
name|WK_ALLOCDIRECT
argument_list|(
name|wk
argument_list|)
expr_stmt|;
name|adp
operator|->
name|ad_state
operator||=
name|COMPLETE
expr_stmt|;
name|handle_allocdirect_partdone
argument_list|(
name|adp
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|D_ALLOCINDIR
case|:
name|aip
operator|=
name|WK_ALLOCINDIR
argument_list|(
name|wk
argument_list|)
expr_stmt|;
name|aip
operator|->
name|ai_state
operator||=
name|COMPLETE
expr_stmt|;
name|handle_allocindir_partdone
argument_list|(
name|aip
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|D_INDIRDEP
case|:
name|indirdep
operator|=
name|WK_INDIRDEP
argument_list|(
name|wk
argument_list|)
expr_stmt|;
if|if
condition|(
name|indirdep
operator|->
name|ir_state
operator|&
name|GOINGAWAY
condition|)
block|{
name|lk
operator|.
name|lkt_held
operator|=
operator|-
literal|1
expr_stmt|;
name|panic
argument_list|(
literal|"disk_write_complete: indirdep gone"
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|indirdep
operator|->
name|ir_saveddata
argument_list|,
name|bp
operator|->
name|b_data
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|indirdep
operator|->
name|ir_saveddata
argument_list|,
name|M_INDIRDEP
argument_list|)
expr_stmt|;
name|indirdep
operator|->
name|ir_saveddata
operator|=
literal|0
expr_stmt|;
name|indirdep
operator|->
name|ir_state
operator|&=
operator|~
name|UNDONE
expr_stmt|;
name|indirdep
operator|->
name|ir_state
operator||=
name|ATTACHED
expr_stmt|;
while|while
condition|(
operator|(
name|aip
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|indirdep
operator|->
name|ir_donehd
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|handle_allocindir_partdone
argument_list|(
name|aip
argument_list|)
expr_stmt|;
if|if
condition|(
name|aip
operator|==
name|LIST_FIRST
argument_list|(
operator|&
name|indirdep
operator|->
name|ir_donehd
argument_list|)
condition|)
block|{
name|lk
operator|.
name|lkt_held
operator|=
operator|-
literal|1
expr_stmt|;
name|panic
argument_list|(
literal|"disk_write_complete: not gone"
argument_list|)
expr_stmt|;
block|}
block|}
name|WORKLIST_INSERT
argument_list|(
operator|&
name|reattach
argument_list|,
name|wk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DELWRI
operator|)
operator|==
literal|0
condition|)
name|stat_indir_blk_ptrs
operator|++
expr_stmt|;
name|bdirty
argument_list|(
name|bp
argument_list|)
expr_stmt|;
continue|continue;
default|default:
name|lk
operator|.
name|lkt_held
operator|=
operator|-
literal|1
expr_stmt|;
name|panic
argument_list|(
literal|"handle_disk_write_complete: Unknown type %s"
argument_list|,
name|TYPENAME
argument_list|(
name|wk
operator|->
name|wk_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
comment|/* 	 * Reattach any requests that must be redone. 	 */
while|while
condition|(
operator|(
name|wk
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|reattach
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|WORKLIST_REMOVE
argument_list|(
name|wk
argument_list|)
expr_stmt|;
name|WORKLIST_INSERT
argument_list|(
operator|&
name|bp
operator|->
name|b_dep
argument_list|,
name|wk
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|lk
operator|.
name|lkt_held
operator|!=
operator|-
literal|2
condition|)
name|panic
argument_list|(
literal|"softdep_disk_write_complete: lock lost"
argument_list|)
expr_stmt|;
name|lk
operator|.
name|lkt_held
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Called from within softdep_disk_write_complete above. Note that  * this routine is always called from interrupt level with further  * splbio interrupts blocked.  */
end_comment

begin_function
specifier|static
name|void
name|handle_allocdirect_partdone
parameter_list|(
name|adp
parameter_list|)
name|struct
name|allocdirect
modifier|*
name|adp
decl_stmt|;
comment|/* the completed allocdirect */
block|{
name|struct
name|allocdirect
modifier|*
name|listadp
decl_stmt|;
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|long
name|bsize
decl_stmt|;
if|if
condition|(
operator|(
name|adp
operator|->
name|ad_state
operator|&
name|ALLCOMPLETE
operator|)
operator|!=
name|ALLCOMPLETE
condition|)
return|return;
if|if
condition|(
name|adp
operator|->
name|ad_buf
operator|!=
name|NULL
condition|)
block|{
name|lk
operator|.
name|lkt_held
operator|=
operator|-
literal|1
expr_stmt|;
name|panic
argument_list|(
literal|"handle_allocdirect_partdone: dangling dep"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The on-disk inode cannot claim to be any larger than the last 	 * fragment that has been written. Otherwise, the on-disk inode 	 * might have fragments that were not the last block in the file 	 * which would corrupt the filesystem. Thus, we cannot free any 	 * allocdirects after one whose ad_oldblkno claims a fragment as 	 * these blocks must be rolled back to zero before writing the inode. 	 * We check the currently active set of allocdirects in id_inoupdt. 	 */
name|inodedep
operator|=
name|adp
operator|->
name|ad_inodedep
expr_stmt|;
name|bsize
operator|=
name|inodedep
operator|->
name|id_fs
operator|->
name|fs_bsize
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|listadp
argument_list|,
argument|&inodedep->id_inoupdt
argument_list|,
argument|ad_next
argument_list|)
block|{
comment|/* found our block */
if|if
condition|(
name|listadp
operator|==
name|adp
condition|)
break|break;
comment|/* continue if ad_oldlbn is not a fragment */
if|if
condition|(
name|listadp
operator|->
name|ad_oldsize
operator|==
literal|0
operator|||
name|listadp
operator|->
name|ad_oldsize
operator|==
name|bsize
condition|)
continue|continue;
comment|/* hit a fragment */
return|return;
block|}
comment|/* 	 * If we have reached the end of the current list without 	 * finding the just finished dependency, then it must be 	 * on the future dependency list. Future dependencies cannot 	 * be freed until they are moved to the current list. 	 */
if|if
condition|(
name|listadp
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|TAILQ_FOREACH
argument_list|(
argument|listadp
argument_list|,
argument|&inodedep->id_newinoupdt
argument_list|,
argument|ad_next
argument_list|)
comment|/* found our block */
if|if
condition|(
name|listadp
operator|==
name|adp
condition|)
break|break;
if|if
condition|(
name|listadp
operator|==
name|NULL
condition|)
block|{
name|lk
operator|.
name|lkt_held
operator|=
operator|-
literal|1
expr_stmt|;
name|panic
argument_list|(
literal|"handle_allocdirect_partdone: lost dep"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEBUG */
return|return;
block|}
comment|/* 	 * If we have found the just finished dependency, then free 	 * it along with anything that follows it that is complete. 	 */
for|for
control|(
init|;
name|adp
condition|;
name|adp
operator|=
name|listadp
control|)
block|{
name|listadp
operator|=
name|TAILQ_NEXT
argument_list|(
name|adp
argument_list|,
name|ad_next
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|adp
operator|->
name|ad_state
operator|&
name|ALLCOMPLETE
operator|)
operator|!=
name|ALLCOMPLETE
condition|)
return|return;
name|free_allocdirect
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoupdt
argument_list|,
name|adp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Called from within softdep_disk_write_complete above. Note that  * this routine is always called from interrupt level with further  * splbio interrupts blocked.  */
end_comment

begin_function
specifier|static
name|void
name|handle_allocindir_partdone
parameter_list|(
name|aip
parameter_list|)
name|struct
name|allocindir
modifier|*
name|aip
decl_stmt|;
comment|/* the completed allocindir */
block|{
name|struct
name|indirdep
modifier|*
name|indirdep
decl_stmt|;
if|if
condition|(
operator|(
name|aip
operator|->
name|ai_state
operator|&
name|ALLCOMPLETE
operator|)
operator|!=
name|ALLCOMPLETE
condition|)
return|return;
if|if
condition|(
name|aip
operator|->
name|ai_buf
operator|!=
name|NULL
condition|)
block|{
name|lk
operator|.
name|lkt_held
operator|=
operator|-
literal|1
expr_stmt|;
name|panic
argument_list|(
literal|"handle_allocindir_partdone: dangling dependency"
argument_list|)
expr_stmt|;
block|}
name|indirdep
operator|=
name|aip
operator|->
name|ai_indirdep
expr_stmt|;
if|if
condition|(
name|indirdep
operator|->
name|ir_state
operator|&
name|UNDONE
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|aip
argument_list|,
name|ai_next
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|indirdep
operator|->
name|ir_donehd
argument_list|,
name|aip
argument_list|,
name|ai_next
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
operator|(
name|ufs_daddr_t
operator|*
operator|)
name|indirdep
operator|->
name|ir_savebp
operator|->
name|b_data
operator|)
index|[
name|aip
operator|->
name|ai_offset
index|]
operator|=
name|aip
operator|->
name|ai_newblkno
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|aip
argument_list|,
name|ai_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|aip
operator|->
name|ai_freefrag
operator|!=
name|NULL
condition|)
name|add_to_worklist
argument_list|(
operator|&
name|aip
operator|->
name|ai_freefrag
operator|->
name|ff_list
argument_list|)
expr_stmt|;
name|WORKITEM_FREE
argument_list|(
name|aip
argument_list|,
name|D_ALLOCINDIR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called from within softdep_disk_write_complete above to restore  * in-memory inode block contents to their most up-to-date state. Note  * that this routine is always called from interrupt level with further  * splbio interrupts blocked.  */
end_comment

begin_function
specifier|static
name|int
name|handle_written_inodeblock
parameter_list|(
name|inodedep
parameter_list|,
name|bp
parameter_list|)
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
comment|/* buffer containing the inode block */
block|{
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|,
modifier|*
name|filefree
decl_stmt|;
name|struct
name|allocdirect
modifier|*
name|adp
decl_stmt|,
modifier|*
name|nextadp
decl_stmt|;
name|struct
name|dinode
modifier|*
name|dp
decl_stmt|;
name|int
name|hadchanges
decl_stmt|;
if|if
condition|(
operator|(
name|inodedep
operator|->
name|id_state
operator|&
name|IOSTARTED
operator|)
operator|==
literal|0
condition|)
block|{
name|lk
operator|.
name|lkt_held
operator|=
operator|-
literal|1
expr_stmt|;
name|panic
argument_list|(
literal|"handle_written_inodeblock: not started"
argument_list|)
expr_stmt|;
block|}
name|inodedep
operator|->
name|id_state
operator|&=
operator|~
name|IOSTARTED
expr_stmt|;
name|inodedep
operator|->
name|id_state
operator||=
name|COMPLETE
expr_stmt|;
name|dp
operator|=
operator|(
expr|struct
name|dinode
operator|*
operator|)
name|bp
operator|->
name|b_data
operator|+
name|ino_to_fsbo
argument_list|(
name|inodedep
operator|->
name|id_fs
argument_list|,
name|inodedep
operator|->
name|id_ino
argument_list|)
expr_stmt|;
comment|/* 	 * If we had to rollback the inode allocation because of 	 * bitmaps being incomplete, then simply restore it. 	 * Keep the block dirty so that it will not be reclaimed until 	 * all associated dependencies have been cleared and the 	 * corresponding updates written to disk. 	 */
if|if
condition|(
name|inodedep
operator|->
name|id_savedino
operator|!=
name|NULL
condition|)
block|{
operator|*
name|dp
operator|=
operator|*
name|inodedep
operator|->
name|id_savedino
expr_stmt|;
name|FREE
argument_list|(
name|inodedep
operator|->
name|id_savedino
argument_list|,
name|M_INODEDEP
argument_list|)
expr_stmt|;
name|inodedep
operator|->
name|id_savedino
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DELWRI
operator|)
operator|==
literal|0
condition|)
name|stat_inode_bitmap
operator|++
expr_stmt|;
name|bdirty
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Roll forward anything that had to be rolled back before  	 * the inode could be updated. 	 */
name|hadchanges
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|adp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoupdt
argument_list|)
init|;
name|adp
condition|;
name|adp
operator|=
name|nextadp
control|)
block|{
name|nextadp
operator|=
name|TAILQ_NEXT
argument_list|(
name|adp
argument_list|,
name|ad_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|adp
operator|->
name|ad_state
operator|&
name|ATTACHED
condition|)
block|{
name|lk
operator|.
name|lkt_held
operator|=
operator|-
literal|1
expr_stmt|;
name|panic
argument_list|(
literal|"handle_written_inodeblock: new entry"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|adp
operator|->
name|ad_lbn
operator|<
name|NDADDR
condition|)
block|{
if|if
condition|(
name|dp
operator|->
name|di_db
index|[
name|adp
operator|->
name|ad_lbn
index|]
operator|!=
name|adp
operator|->
name|ad_oldblkno
condition|)
block|{
name|lk
operator|.
name|lkt_held
operator|=
operator|-
literal|1
expr_stmt|;
name|panic
argument_list|(
literal|"%s: %s #%ld mismatch %d != %d"
argument_list|,
literal|"handle_written_inodeblock"
argument_list|,
literal|"direct pointer"
argument_list|,
name|adp
operator|->
name|ad_lbn
argument_list|,
name|dp
operator|->
name|di_db
index|[
name|adp
operator|->
name|ad_lbn
index|]
argument_list|,
name|adp
operator|->
name|ad_oldblkno
argument_list|)
expr_stmt|;
block|}
name|dp
operator|->
name|di_db
index|[
name|adp
operator|->
name|ad_lbn
index|]
operator|=
name|adp
operator|->
name|ad_newblkno
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dp
operator|->
name|di_ib
index|[
name|adp
operator|->
name|ad_lbn
operator|-
name|NDADDR
index|]
operator|!=
literal|0
condition|)
block|{
name|lk
operator|.
name|lkt_held
operator|=
operator|-
literal|1
expr_stmt|;
name|panic
argument_list|(
literal|"%s: %s #%ld allocated as %d"
argument_list|,
literal|"handle_written_inodeblock"
argument_list|,
literal|"indirect pointer"
argument_list|,
name|adp
operator|->
name|ad_lbn
operator|-
name|NDADDR
argument_list|,
name|dp
operator|->
name|di_ib
index|[
name|adp
operator|->
name|ad_lbn
operator|-
name|NDADDR
index|]
argument_list|)
expr_stmt|;
block|}
name|dp
operator|->
name|di_ib
index|[
name|adp
operator|->
name|ad_lbn
operator|-
name|NDADDR
index|]
operator|=
name|adp
operator|->
name|ad_newblkno
expr_stmt|;
block|}
name|adp
operator|->
name|ad_state
operator|&=
operator|~
name|UNDONE
expr_stmt|;
name|adp
operator|->
name|ad_state
operator||=
name|ATTACHED
expr_stmt|;
name|hadchanges
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|hadchanges
operator|&&
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DELWRI
operator|)
operator|==
literal|0
condition|)
name|stat_direct_blk_ptrs
operator|++
expr_stmt|;
comment|/* 	 * Reset the file size to its most up-to-date value. 	 */
if|if
condition|(
name|inodedep
operator|->
name|id_savedsize
operator|==
operator|-
literal|1
condition|)
block|{
name|lk
operator|.
name|lkt_held
operator|=
operator|-
literal|1
expr_stmt|;
name|panic
argument_list|(
literal|"handle_written_inodeblock: bad size"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dp
operator|->
name|di_size
operator|!=
name|inodedep
operator|->
name|id_savedsize
condition|)
block|{
name|dp
operator|->
name|di_size
operator|=
name|inodedep
operator|->
name|id_savedsize
expr_stmt|;
name|hadchanges
operator|=
literal|1
expr_stmt|;
block|}
name|inodedep
operator|->
name|id_savedsize
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 	 * If there were any rollbacks in the inode block, then it must be 	 * marked dirty so that its will eventually get written back in 	 * its correct form. 	 */
if|if
condition|(
name|hadchanges
condition|)
name|bdirty
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * Process any allocdirects that completed during the update. 	 */
if|if
condition|(
operator|(
name|adp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoupdt
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|handle_allocdirect_partdone
argument_list|(
name|adp
argument_list|)
expr_stmt|;
comment|/* 	 * Process deallocations that were held pending until the 	 * inode had been written to disk. Freeing of the inode 	 * is delayed until after all blocks have been freed to 	 * avoid creation of new<vfsid, inum, lbn> triples 	 * before the old ones have been deleted. 	 */
name|filefree
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|wk
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_bufwait
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|WORKLIST_REMOVE
argument_list|(
name|wk
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|wk
operator|->
name|wk_type
condition|)
block|{
case|case
name|D_FREEFILE
case|:
comment|/* 			 * We defer adding filefree to the worklist until 			 * all other additions have been made to ensure 			 * that it will be done after all the old blocks 			 * have been freed. 			 */
if|if
condition|(
name|filefree
operator|!=
name|NULL
condition|)
block|{
name|lk
operator|.
name|lkt_held
operator|=
operator|-
literal|1
expr_stmt|;
name|panic
argument_list|(
literal|"handle_written_inodeblock: filefree"
argument_list|)
expr_stmt|;
block|}
name|filefree
operator|=
name|wk
expr_stmt|;
continue|continue;
case|case
name|D_MKDIR
case|:
name|handle_written_mkdir
argument_list|(
name|WK_MKDIR
argument_list|(
name|wk
argument_list|)
argument_list|,
name|MKDIR_PARENT
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|D_DIRADD
case|:
name|diradd_inode_written
argument_list|(
name|WK_DIRADD
argument_list|(
name|wk
argument_list|)
argument_list|,
name|inodedep
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|D_FREEBLKS
case|:
case|case
name|D_FREEFRAG
case|:
case|case
name|D_DIRREM
case|:
name|add_to_worklist
argument_list|(
name|wk
argument_list|)
expr_stmt|;
continue|continue;
default|default:
name|lk
operator|.
name|lkt_held
operator|=
operator|-
literal|1
expr_stmt|;
name|panic
argument_list|(
literal|"handle_written_inodeblock: Unknown type %s"
argument_list|,
name|TYPENAME
argument_list|(
name|wk
operator|->
name|wk_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
if|if
condition|(
name|filefree
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|free_inodedep
argument_list|(
name|inodedep
argument_list|)
operator|==
literal|0
condition|)
block|{
name|lk
operator|.
name|lkt_held
operator|=
operator|-
literal|1
expr_stmt|;
name|panic
argument_list|(
literal|"handle_written_inodeblock: live inodedep"
argument_list|)
expr_stmt|;
block|}
name|add_to_worklist
argument_list|(
name|filefree
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If no outstanding dependencies, free it. 	 */
if|if
condition|(
name|free_inodedep
argument_list|(
name|inodedep
argument_list|)
operator|||
name|TAILQ_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoupdt
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|hadchanges
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process a diradd entry after its dependent inode has been written.  * This routine must be called with splbio interrupts blocked.  */
end_comment

begin_function
specifier|static
name|void
name|diradd_inode_written
parameter_list|(
name|dap
parameter_list|,
name|inodedep
parameter_list|)
name|struct
name|diradd
modifier|*
name|dap
decl_stmt|;
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
block|{
name|struct
name|pagedep
modifier|*
name|pagedep
decl_stmt|;
name|dap
operator|->
name|da_state
operator||=
name|COMPLETE
expr_stmt|;
if|if
condition|(
operator|(
name|dap
operator|->
name|da_state
operator|&
name|ALLCOMPLETE
operator|)
operator|==
name|ALLCOMPLETE
condition|)
block|{
if|if
condition|(
name|dap
operator|->
name|da_state
operator|&
name|DIRCHG
condition|)
name|pagedep
operator|=
name|dap
operator|->
name|da_previous
operator|->
name|dm_pagedep
expr_stmt|;
else|else
name|pagedep
operator|=
name|dap
operator|->
name|da_pagedep
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|dap
argument_list|,
name|da_pdlist
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|pagedep
operator|->
name|pd_pendinghd
argument_list|,
name|dap
argument_list|,
name|da_pdlist
argument_list|)
expr_stmt|;
block|}
name|WORKLIST_INSERT
argument_list|(
operator|&
name|inodedep
operator|->
name|id_pendinghd
argument_list|,
operator|&
name|dap
operator|->
name|da_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle the completion of a mkdir dependency.  */
end_comment

begin_function
specifier|static
name|void
name|handle_written_mkdir
parameter_list|(
name|mkdir
parameter_list|,
name|type
parameter_list|)
name|struct
name|mkdir
modifier|*
name|mkdir
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
name|struct
name|diradd
modifier|*
name|dap
decl_stmt|;
name|struct
name|pagedep
modifier|*
name|pagedep
decl_stmt|;
if|if
condition|(
name|mkdir
operator|->
name|md_state
operator|!=
name|type
condition|)
block|{
name|lk
operator|.
name|lkt_held
operator|=
operator|-
literal|1
expr_stmt|;
name|panic
argument_list|(
literal|"handle_written_mkdir: bad type"
argument_list|)
expr_stmt|;
block|}
name|dap
operator|=
name|mkdir
operator|->
name|md_diradd
expr_stmt|;
name|dap
operator|->
name|da_state
operator|&=
operator|~
name|type
expr_stmt|;
if|if
condition|(
operator|(
name|dap
operator|->
name|da_state
operator|&
operator|(
name|MKDIR_PARENT
operator||
name|MKDIR_BODY
operator|)
operator|)
operator|==
literal|0
condition|)
name|dap
operator|->
name|da_state
operator||=
name|DEPCOMPLETE
expr_stmt|;
if|if
condition|(
operator|(
name|dap
operator|->
name|da_state
operator|&
name|ALLCOMPLETE
operator|)
operator|==
name|ALLCOMPLETE
condition|)
block|{
if|if
condition|(
name|dap
operator|->
name|da_state
operator|&
name|DIRCHG
condition|)
name|pagedep
operator|=
name|dap
operator|->
name|da_previous
operator|->
name|dm_pagedep
expr_stmt|;
else|else
name|pagedep
operator|=
name|dap
operator|->
name|da_pagedep
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|dap
argument_list|,
name|da_pdlist
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|pagedep
operator|->
name|pd_pendinghd
argument_list|,
name|dap
argument_list|,
name|da_pdlist
argument_list|)
expr_stmt|;
block|}
name|LIST_REMOVE
argument_list|(
name|mkdir
argument_list|,
name|md_mkdirs
argument_list|)
expr_stmt|;
name|WORKITEM_FREE
argument_list|(
name|mkdir
argument_list|,
name|D_MKDIR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called from within softdep_disk_write_complete above.  * A write operation was just completed. Removed inodes can  * now be freed and associated block pointers may be committed.  * Note that this routine is always called from interrupt level  * with further splbio interrupts blocked.  */
end_comment

begin_function
specifier|static
name|int
name|handle_written_filepage
parameter_list|(
name|pagedep
parameter_list|,
name|bp
parameter_list|)
name|struct
name|pagedep
modifier|*
name|pagedep
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
comment|/* buffer containing the written page */
block|{
name|struct
name|dirrem
modifier|*
name|dirrem
decl_stmt|;
name|struct
name|diradd
modifier|*
name|dap
decl_stmt|,
modifier|*
name|nextdap
decl_stmt|;
name|struct
name|direct
modifier|*
name|ep
decl_stmt|;
name|int
name|i
decl_stmt|,
name|chgs
decl_stmt|;
if|if
condition|(
operator|(
name|pagedep
operator|->
name|pd_state
operator|&
name|IOSTARTED
operator|)
operator|==
literal|0
condition|)
block|{
name|lk
operator|.
name|lkt_held
operator|=
operator|-
literal|1
expr_stmt|;
name|panic
argument_list|(
literal|"handle_written_filepage: not started"
argument_list|)
expr_stmt|;
block|}
name|pagedep
operator|->
name|pd_state
operator|&=
operator|~
name|IOSTARTED
expr_stmt|;
comment|/* 	 * Process any directory removals that have been committed. 	 */
while|while
condition|(
operator|(
name|dirrem
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|pagedep
operator|->
name|pd_dirremhd
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|dirrem
argument_list|,
name|dm_next
argument_list|)
expr_stmt|;
name|dirrem
operator|->
name|dm_dirinum
operator|=
name|pagedep
operator|->
name|pd_ino
expr_stmt|;
name|add_to_worklist
argument_list|(
operator|&
name|dirrem
operator|->
name|dm_list
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Free any directory additions that have been committed. 	 */
while|while
condition|(
operator|(
name|dap
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|pagedep
operator|->
name|pd_pendinghd
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|free_diradd
argument_list|(
name|dap
argument_list|)
expr_stmt|;
comment|/* 	 * Uncommitted directory entries must be restored. 	 */
for|for
control|(
name|chgs
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DAHASHSZ
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|dap
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|pagedep
operator|->
name|pd_diraddhd
index|[
name|i
index|]
argument_list|)
init|;
name|dap
condition|;
name|dap
operator|=
name|nextdap
control|)
block|{
name|nextdap
operator|=
name|LIST_NEXT
argument_list|(
name|dap
argument_list|,
name|da_pdlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|dap
operator|->
name|da_state
operator|&
name|ATTACHED
condition|)
block|{
name|lk
operator|.
name|lkt_held
operator|=
operator|-
literal|1
expr_stmt|;
name|panic
argument_list|(
literal|"handle_written_filepage: attached"
argument_list|)
expr_stmt|;
block|}
name|ep
operator|=
operator|(
expr|struct
name|direct
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|bp
operator|->
name|b_data
operator|+
name|dap
operator|->
name|da_offset
operator|)
expr_stmt|;
name|ep
operator|->
name|d_ino
operator|=
name|dap
operator|->
name|da_newinum
expr_stmt|;
name|dap
operator|->
name|da_state
operator|&=
operator|~
name|UNDONE
expr_stmt|;
name|dap
operator|->
name|da_state
operator||=
name|ATTACHED
expr_stmt|;
name|chgs
operator|=
literal|1
expr_stmt|;
comment|/* 			 * If the inode referenced by the directory has 			 * been written out, then the dependency can be 			 * moved to the pending list. 			 */
if|if
condition|(
operator|(
name|dap
operator|->
name|da_state
operator|&
name|ALLCOMPLETE
operator|)
operator|==
name|ALLCOMPLETE
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|dap
argument_list|,
name|da_pdlist
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|pagedep
operator|->
name|pd_pendinghd
argument_list|,
name|dap
argument_list|,
name|da_pdlist
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * If there were any rollbacks in the directory, then it must be 	 * marked dirty so that its will eventually get written back in 	 * its correct form. 	 */
if|if
condition|(
name|chgs
condition|)
block|{
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DELWRI
operator|)
operator|==
literal|0
condition|)
name|stat_dir_entry
operator|++
expr_stmt|;
name|bdirty
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If no dependencies remain, the pagedep will be freed. 	 * Otherwise it will remain to update the page before it 	 * is written back to disk. 	 */
if|if
condition|(
name|LIST_FIRST
argument_list|(
operator|&
name|pagedep
operator|->
name|pd_pendinghd
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DAHASHSZ
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|LIST_FIRST
argument_list|(
operator|&
name|pagedep
operator|->
name|pd_diraddhd
index|[
name|i
index|]
argument_list|)
operator|!=
name|NULL
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|DAHASHSZ
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|pagedep
argument_list|,
name|pd_hash
argument_list|)
expr_stmt|;
name|WORKITEM_FREE
argument_list|(
name|pagedep
argument_list|,
name|D_PAGEDEP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Writing back in-core inode structures.  *   * The file system only accesses an inode's contents when it occupies an  * "in-core" inode structure.  These "in-core" structures are separate from  * the page frames used to cache inode blocks.  Only the latter are  * transferred to/from the disk.  So, when the updated contents of the  * "in-core" inode structure are copied to the corresponding in-memory inode  * block, the dependencies are also transferred.  The following procedure is  * called when copying a dirty "in-core" inode to a cached inode block.  */
end_comment

begin_comment
comment|/*  * Called when an inode is loaded from disk. If the effective link count  * differed from the actual link count when it was last flushed, then we  * need to ensure that the correct effective link count is put back.  */
end_comment

begin_function
name|void
name|softdep_load_inodeblock
parameter_list|(
name|ip
parameter_list|)
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
comment|/* the "in_core" copy of the inode */
block|{
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
comment|/* 	 * Check for alternate nlink count. 	 */
name|ip
operator|->
name|i_effnlink
operator|=
name|ip
operator|->
name|i_nlink
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
if|if
condition|(
name|inodedep_lookup
argument_list|(
name|ip
operator|->
name|i_fs
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
literal|0
argument_list|,
operator|&
name|inodedep
argument_list|)
operator|==
literal|0
condition|)
block|{
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
return|return;
block|}
name|ip
operator|->
name|i_effnlink
operator|-=
name|inodedep
operator|->
name|id_nlinkdelta
expr_stmt|;
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine is called just before the "in-core" inode  * information is to be copied to the in-memory inode block.  * Recall that an inode block contains several inodes. If  * the force flag is set, then the dependencies will be  * cleared so that the update can always be made. Note that  * the buffer is locked when this routine is called, so we  * will never be in the middle of writing the inode block   * to disk.  */
end_comment

begin_function
name|void
name|softdep_update_inodeblock
parameter_list|(
name|ip
parameter_list|,
name|bp
parameter_list|,
name|waitfor
parameter_list|)
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
comment|/* the "in_core" copy of the inode */
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
comment|/* the buffer containing the inode block */
name|int
name|waitfor
decl_stmt|;
comment|/* nonzero => update must be allowed */
block|{
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
name|int
name|error
decl_stmt|,
name|gotit
decl_stmt|;
comment|/* 	 * If the effective link count is not equal to the actual link 	 * count, then we must track the difference in an inodedep while 	 * the inode is (potentially) tossed out of the cache. Otherwise, 	 * if there is no existing inodedep, then there are no dependencies 	 * to track. 	 */
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
if|if
condition|(
name|inodedep_lookup
argument_list|(
name|ip
operator|->
name|i_fs
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
literal|0
argument_list|,
operator|&
name|inodedep
argument_list|)
operator|==
literal|0
condition|)
block|{
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_effnlink
operator|!=
name|ip
operator|->
name|i_nlink
condition|)
name|panic
argument_list|(
literal|"softdep_update_inodeblock: bad link count"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|inodedep
operator|->
name|id_nlinkdelta
operator|!=
name|ip
operator|->
name|i_nlink
operator|-
name|ip
operator|->
name|i_effnlink
condition|)
block|{
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"softdep_update_inodeblock: bad delta"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Changes have been initiated. Anything depending on these 	 * changes cannot occur until this inode has been written. 	 */
name|inodedep
operator|->
name|id_state
operator|&=
operator|~
name|COMPLETE
expr_stmt|;
if|if
condition|(
operator|(
name|inodedep
operator|->
name|id_state
operator|&
name|ONWORKLIST
operator|)
operator|==
literal|0
condition|)
name|WORKLIST_INSERT
argument_list|(
operator|&
name|bp
operator|->
name|b_dep
argument_list|,
operator|&
name|inodedep
operator|->
name|id_list
argument_list|)
expr_stmt|;
comment|/* 	 * Any new dependencies associated with the incore inode must  	 * now be moved to the list associated with the buffer holding 	 * the in-memory copy of the inode. Once merged process any 	 * allocdirects that are completed by the merger. 	 */
name|merge_inode_lists
argument_list|(
name|inodedep
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoupdt
argument_list|)
operator|!=
name|NULL
condition|)
name|handle_allocdirect_partdone
argument_list|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoupdt
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Now that the inode has been pushed into the buffer, the 	 * operations dependent on the inode being written to disk 	 * can be moved to the id_bufwait so that they will be 	 * processed when the buffer I/O completes. 	 */
while|while
condition|(
operator|(
name|wk
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inowait
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|WORKLIST_REMOVE
argument_list|(
name|wk
argument_list|)
expr_stmt|;
name|WORKLIST_INSERT
argument_list|(
operator|&
name|inodedep
operator|->
name|id_bufwait
argument_list|,
name|wk
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Newly allocated inodes cannot be written until the bitmap 	 * that allocates them have been written (indicated by 	 * DEPCOMPLETE being set in id_state). If we are doing a 	 * forced sync (e.g., an fsync on a file), we force the bitmap 	 * to be written so that the update can be done. 	 */
if|if
condition|(
operator|(
name|inodedep
operator|->
name|id_state
operator|&
name|DEPCOMPLETE
operator|)
operator|!=
literal|0
operator|||
name|waitfor
operator|==
literal|0
condition|)
block|{
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
return|return;
block|}
name|gotit
operator|=
name|getdirtybuf
argument_list|(
operator|&
name|inodedep
operator|->
name|id_buf
argument_list|,
name|MNT_WAIT
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
if|if
condition|(
name|gotit
operator|&&
operator|(
name|error
operator|=
name|VOP_BWRITE
argument_list|(
name|inodedep
operator|->
name|id_buf
operator|->
name|b_vp
argument_list|,
name|inodedep
operator|->
name|id_buf
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|softdep_error
argument_list|(
literal|"softdep_update_inodeblock: bwrite"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inodedep
operator|->
name|id_state
operator|&
name|DEPCOMPLETE
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"softdep_update_inodeblock: update failed"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Merge the new inode dependency list (id_newinoupdt) into the old  * inode dependency list (id_inoupdt). This routine must be called  * with splbio interrupts blocked.  */
end_comment

begin_function
specifier|static
name|void
name|merge_inode_lists
parameter_list|(
name|inodedep
parameter_list|)
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
block|{
name|struct
name|allocdirect
modifier|*
name|listadp
decl_stmt|,
modifier|*
name|newadp
decl_stmt|;
name|newadp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_newinoupdt
argument_list|)
expr_stmt|;
for|for
control|(
name|listadp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoupdt
argument_list|)
init|;
name|listadp
operator|&&
name|newadp
condition|;
control|)
block|{
if|if
condition|(
name|listadp
operator|->
name|ad_lbn
operator|<
name|newadp
operator|->
name|ad_lbn
condition|)
block|{
name|listadp
operator|=
name|TAILQ_NEXT
argument_list|(
name|listadp
argument_list|,
name|ad_next
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|inodedep
operator|->
name|id_newinoupdt
argument_list|,
name|newadp
argument_list|,
name|ad_next
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_BEFORE
argument_list|(
name|listadp
argument_list|,
name|newadp
argument_list|,
name|ad_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|listadp
operator|->
name|ad_lbn
operator|==
name|newadp
operator|->
name|ad_lbn
condition|)
block|{
name|allocdirect_merge
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoupdt
argument_list|,
name|newadp
argument_list|,
name|listadp
argument_list|)
expr_stmt|;
name|listadp
operator|=
name|newadp
expr_stmt|;
block|}
name|newadp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_newinoupdt
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|newadp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_newinoupdt
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|inodedep
operator|->
name|id_newinoupdt
argument_list|,
name|newadp
argument_list|,
name|ad_next
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoupdt
argument_list|,
name|newadp
argument_list|,
name|ad_next
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * If we are doing an fsync, then we must ensure that any directory  * entries for the inode have been written after the inode gets to disk.  */
end_comment

begin_function
specifier|static
name|int
name|softdep_fsync
parameter_list|(
name|vp
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
comment|/* the "in_core" copy of the inode */
block|{
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|pagedep
modifier|*
name|pagedep
decl_stmt|;
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
name|struct
name|diradd
modifier|*
name|dap
decl_stmt|;
name|struct
name|mount
modifier|*
name|mnt
decl_stmt|;
name|struct
name|vnode
modifier|*
name|pvp
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|CURPROC
decl_stmt|;
comment|/* XXX */
name|int
name|error
decl_stmt|,
name|flushparent
decl_stmt|;
name|ino_t
name|parentino
decl_stmt|;
name|ufs_lbn_t
name|lbn
decl_stmt|;
name|ip
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|fs
operator|=
name|ip
operator|->
name|i_fs
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
if|if
condition|(
name|inodedep_lookup
argument_list|(
name|fs
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
literal|0
argument_list|,
operator|&
name|inodedep
argument_list|)
operator|==
literal|0
condition|)
block|{
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|LIST_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inowait
argument_list|)
operator|!=
name|NULL
operator|||
name|LIST_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_bufwait
argument_list|)
operator|!=
name|NULL
operator|||
name|TAILQ_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoupdt
argument_list|)
operator|!=
name|NULL
operator|||
name|TAILQ_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_newinoupdt
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"softdep_fsync: pending ops"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|error
operator|=
literal|0
operator|,
name|flushparent
operator|=
literal|0
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|wk
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_pendinghd
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|wk
operator|->
name|wk_type
operator|!=
name|D_DIRADD
condition|)
block|{
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"softdep_fsync: Unexpected type %s"
argument_list|,
name|TYPENAME
argument_list|(
name|wk
operator|->
name|wk_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dap
operator|=
name|WK_DIRADD
argument_list|(
name|wk
argument_list|)
expr_stmt|;
comment|/* 		 * Flush our parent if this directory entry 		 * has a MKDIR_PARENT dependency. 		 */
if|if
condition|(
name|dap
operator|->
name|da_state
operator|&
name|DIRCHG
condition|)
name|pagedep
operator|=
name|dap
operator|->
name|da_previous
operator|->
name|dm_pagedep
expr_stmt|;
else|else
name|pagedep
operator|=
name|dap
operator|->
name|da_pagedep
expr_stmt|;
name|mnt
operator|=
name|pagedep
operator|->
name|pd_mnt
expr_stmt|;
name|parentino
operator|=
name|pagedep
operator|->
name|pd_ino
expr_stmt|;
name|lbn
operator|=
name|pagedep
operator|->
name|pd_lbn
expr_stmt|;
if|if
condition|(
operator|(
name|dap
operator|->
name|da_state
operator|&
operator|(
name|MKDIR_BODY
operator||
name|COMPLETE
operator|)
operator|)
operator|!=
name|COMPLETE
condition|)
block|{
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"softdep_fsync: dirty"
argument_list|)
expr_stmt|;
block|}
name|flushparent
operator|=
name|dap
operator|->
name|da_state
operator|&
name|MKDIR_PARENT
expr_stmt|;
comment|/* 		 * If we are being fsync'ed as part of vgone'ing this vnode, 		 * then we will not be able to release and recover the 		 * vnode below, so we just have to give up on writing its 		 * directory entry out. It will eventually be written, just 		 * not now, but then the user was not asking to have it 		 * written, so we are not breaking any promises. 		 */
if|if
condition|(
name|vp
operator|->
name|v_flag
operator|&
name|VXLOCK
condition|)
break|break;
comment|/* 		 * We prevent deadlock by always fetching inodes from the 		 * root, moving down the directory tree. Thus, when fetching 		 * our parent directory, we must unlock ourselves before 		 * requesting the lock on our parent. See the comment in 		 * ufs_lookup for details on possible races. 		 */
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|error
operator|=
name|VFS_VGET
argument_list|(
name|mnt
argument_list|,
name|parentino
argument_list|,
operator|&
name|pvp
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|flushparent
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|UFS_UPDATE
argument_list|(
name|pvp
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|vput
argument_list|(
name|pvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* 		 * Flush directory page containing the inode's name. 		 */
name|error
operator|=
name|bread
argument_list|(
name|pvp
argument_list|,
name|lbn
argument_list|,
name|blksize
argument_list|(
name|fs
argument_list|,
name|VTOI
argument_list|(
name|pvp
argument_list|)
argument_list|,
name|lbn
argument_list|)
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|VOP_BWRITE
argument_list|(
name|bp
operator|->
name|b_vp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|pvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
if|if
condition|(
name|inodedep_lookup
argument_list|(
name|fs
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
literal|0
argument_list|,
operator|&
name|inodedep
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Flush all the dirty bitmaps associated with the block device  * before flushing the rest of the dirty blocks so as to reduce  * the number of dependencies that will have to be rolled back.  */
end_comment

begin_function
name|void
name|softdep_fsync_mountdev
parameter_list|(
name|vp
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|nbp
decl_stmt|;
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
if|if
condition|(
operator|!
name|vn_isdisk
argument_list|(
name|vp
argument_list|,
name|NULL
argument_list|)
condition|)
name|panic
argument_list|(
literal|"softdep_fsync_mountdev: vnode not a disk"
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|vp
operator|->
name|v_dirtyblkhd
argument_list|)
init|;
name|bp
condition|;
name|bp
operator|=
name|nbp
control|)
block|{
name|nbp
operator|=
name|TAILQ_NEXT
argument_list|(
name|bp
argument_list|,
name|b_vnbufs
argument_list|)
expr_stmt|;
comment|/*  		 * If it is already scheduled, skip to the next buffer. 		 */
if|if
condition|(
name|BUF_LOCK
argument_list|(
name|bp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_NOWAIT
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DELWRI
operator|)
operator|==
literal|0
condition|)
block|{
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"softdep_fsync_mountdev: not dirty"
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * We are only interested in bitmaps with outstanding 		 * dependencies. 		 */
if|if
condition|(
operator|(
name|wk
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|bp
operator|->
name|b_dep
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|wk
operator|->
name|wk_type
operator|!=
name|D_BMSAFEMAP
operator|||
operator|(
name|bp
operator|->
name|b_xflags
operator|&
name|BX_BKGRDINPROG
operator|)
condition|)
block|{
name|BUF_UNLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|bremfree
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bawrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
comment|/* 		 * Since we may have slept during the I/O, we need  		 * to start from a known point. 		 */
name|nbp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|vp
operator|->
name|v_dirtyblkhd
argument_list|)
expr_stmt|;
block|}
name|drain_output
argument_list|(
name|vp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine is called when we are trying to synchronously flush a  * file. This routine must eliminate any filesystem metadata dependencies  * so that the syncing routine can succeed by pushing the dirty blocks  * associated with the file. If any I/O errors occur, they are returned.  */
end_comment

begin_function
name|int
name|softdep_sync_metadata
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_fsync_args
comment|/* { 		struct vnode *a_vp; 		struct ucred *a_cred; 		int a_waitfor; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|pagedep
modifier|*
name|pagedep
decl_stmt|;
name|struct
name|allocdirect
modifier|*
name|adp
decl_stmt|;
name|struct
name|allocindir
modifier|*
name|aip
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|nbp
decl_stmt|;
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|,
name|waitfor
decl_stmt|;
comment|/* 	 * Check whether this vnode is involved in a filesystem 	 * that is doing soft dependency processing. 	 */
if|if
condition|(
operator|!
name|vn_isdisk
argument_list|(
name|vp
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|DOINGSOFTDEP
argument_list|(
name|vp
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|vp
operator|->
name|v_specmountpoint
operator|==
name|NULL
operator|||
operator|(
name|vp
operator|->
name|v_specmountpoint
operator|->
name|mnt_flag
operator|&
name|MNT_SOFTDEP
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Ensure that any direct block dependencies have been cleared. 	 */
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|flush_inodedep_deps
argument_list|(
name|VTOI
argument_list|(
name|vp
argument_list|)
operator|->
name|i_fs
argument_list|,
name|VTOI
argument_list|(
name|vp
argument_list|)
operator|->
name|i_number
argument_list|)
operator|)
condition|)
block|{
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * For most files, the only metadata dependencies are the 	 * cylinder group maps that allocate their inode or blocks. 	 * The block allocation dependencies can be found by traversing 	 * the dependency lists for any buffers that remain on their 	 * dirty buffer list. The inode allocation dependency will 	 * be resolved when the inode is updated with MNT_WAIT. 	 * This work is done in two passes. The first pass grabs most 	 * of the buffers and begins asynchronously writing them. The 	 * only way to wait for these asynchronous writes is to sleep 	 * on the filesystem vnode which may stay busy for a long time 	 * if the filesystem is active. So, instead, we make a second 	 * pass over the dependencies blocking on each write. In the 	 * usual case we will be blocking against a write that we 	 * initiated, so when it is done the dependency will have been 	 * resolved. Thus the second pass is expected to end quickly. 	 */
name|waitfor
operator|=
name|MNT_NOWAIT
expr_stmt|;
name|top
label|:
comment|/* 	 * We must wait for any I/O in progress to finish so that 	 * all potential buffers on the dirty list will be visible. 	 */
name|drain_output
argument_list|(
name|vp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|getdirtybuf
argument_list|(
operator|&
name|TAILQ_FIRST
argument_list|(
operator|&
name|vp
operator|->
name|v_dirtyblkhd
argument_list|)
argument_list|,
name|MNT_WAIT
argument_list|)
operator|==
literal|0
condition|)
block|{
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|bp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|vp
operator|->
name|v_dirtyblkhd
argument_list|)
expr_stmt|;
name|loop
label|:
comment|/* 	 * As we hold the buffer locked, none of its dependencies 	 * will disappear. 	 */
name|LIST_FOREACH
argument_list|(
argument|wk
argument_list|,
argument|&bp->b_dep
argument_list|,
argument|wk_list
argument_list|)
block|{
switch|switch
condition|(
name|wk
operator|->
name|wk_type
condition|)
block|{
case|case
name|D_ALLOCDIRECT
case|:
name|adp
operator|=
name|WK_ALLOCDIRECT
argument_list|(
name|wk
argument_list|)
expr_stmt|;
if|if
condition|(
name|adp
operator|->
name|ad_state
operator|&
name|DEPCOMPLETE
condition|)
break|break;
name|nbp
operator|=
name|adp
operator|->
name|ad_buf
expr_stmt|;
if|if
condition|(
name|getdirtybuf
argument_list|(
operator|&
name|nbp
argument_list|,
name|waitfor
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
if|if
condition|(
name|waitfor
operator|==
name|MNT_NOWAIT
condition|)
block|{
name|bawrite
argument_list|(
name|nbp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_BWRITE
argument_list|(
name|nbp
operator|->
name|b_vp
argument_list|,
name|nbp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|bawrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
break|break;
case|case
name|D_ALLOCINDIR
case|:
name|aip
operator|=
name|WK_ALLOCINDIR
argument_list|(
name|wk
argument_list|)
expr_stmt|;
if|if
condition|(
name|aip
operator|->
name|ai_state
operator|&
name|DEPCOMPLETE
condition|)
break|break;
name|nbp
operator|=
name|aip
operator|->
name|ai_buf
expr_stmt|;
if|if
condition|(
name|getdirtybuf
argument_list|(
operator|&
name|nbp
argument_list|,
name|waitfor
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
if|if
condition|(
name|waitfor
operator|==
name|MNT_NOWAIT
condition|)
block|{
name|bawrite
argument_list|(
name|nbp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_BWRITE
argument_list|(
name|nbp
operator|->
name|b_vp
argument_list|,
name|nbp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|bawrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
break|break;
case|case
name|D_INDIRDEP
case|:
name|restart
label|:
name|LIST_FOREACH
argument_list|(
argument|aip
argument_list|,
argument|&WK_INDIRDEP(wk)->ir_deplisthd
argument_list|,
argument|ai_next
argument_list|)
block|{
if|if
condition|(
name|aip
operator|->
name|ai_state
operator|&
name|DEPCOMPLETE
condition|)
continue|continue;
name|nbp
operator|=
name|aip
operator|->
name|ai_buf
expr_stmt|;
if|if
condition|(
name|getdirtybuf
argument_list|(
operator|&
name|nbp
argument_list|,
name|MNT_WAIT
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|restart
goto|;
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_BWRITE
argument_list|(
name|nbp
operator|->
name|b_vp
argument_list|,
name|nbp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|bawrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
break|break;
case|case
name|D_INODEDEP
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|flush_inodedep_deps
argument_list|(
name|WK_INODEDEP
argument_list|(
name|wk
argument_list|)
operator|->
name|id_fs
argument_list|,
name|WK_INODEDEP
argument_list|(
name|wk
argument_list|)
operator|->
name|id_ino
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|bawrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
break|break;
case|case
name|D_PAGEDEP
case|:
comment|/* 			 * We are trying to sync a directory that may 			 * have dependencies on both its own metadata 			 * and/or dependencies on the inodes of any 			 * recently allocated files. We walk its diradd 			 * lists pushing out the associated inode. 			 */
name|pagedep
operator|=
name|WK_PAGEDEP
argument_list|(
name|wk
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DAHASHSZ
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|LIST_FIRST
argument_list|(
operator|&
name|pagedep
operator|->
name|pd_diraddhd
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|error
operator|=
name|flush_pagedep_deps
argument_list|(
name|vp
argument_list|,
name|pagedep
operator|->
name|pd_mnt
argument_list|,
operator|&
name|pagedep
operator|->
name|pd_diraddhd
index|[
name|i
index|]
argument_list|)
operator|)
condition|)
block|{
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|bawrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
break|break;
case|case
name|D_MKDIR
case|:
comment|/* 			 * This case should never happen if the vnode has 			 * been properly sync'ed. However, if this function 			 * is used at a place where the vnode has not yet 			 * been sync'ed, this dependency can show up. So, 			 * rather than panic, just flush it. 			 */
name|nbp
operator|=
name|WK_MKDIR
argument_list|(
name|wk
argument_list|)
operator|->
name|md_buf
expr_stmt|;
if|if
condition|(
name|getdirtybuf
argument_list|(
operator|&
name|nbp
argument_list|,
name|waitfor
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
if|if
condition|(
name|waitfor
operator|==
name|MNT_NOWAIT
condition|)
block|{
name|bawrite
argument_list|(
name|nbp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_BWRITE
argument_list|(
name|nbp
operator|->
name|b_vp
argument_list|,
name|nbp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|bawrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
break|break;
case|case
name|D_BMSAFEMAP
case|:
comment|/* 			 * This case should never happen if the vnode has 			 * been properly sync'ed. However, if this function 			 * is used at a place where the vnode has not yet 			 * been sync'ed, this dependency can show up. So, 			 * rather than panic, just flush it. 			 */
name|nbp
operator|=
name|WK_BMSAFEMAP
argument_list|(
name|wk
argument_list|)
operator|->
name|sm_buf
expr_stmt|;
if|if
condition|(
name|getdirtybuf
argument_list|(
operator|&
name|nbp
argument_list|,
name|waitfor
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
if|if
condition|(
name|waitfor
operator|==
name|MNT_NOWAIT
condition|)
block|{
name|bawrite
argument_list|(
name|nbp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_BWRITE
argument_list|(
name|nbp
operator|->
name|b_vp
argument_list|,
name|nbp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|bawrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
break|break;
default|default:
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"softdep_sync_metadata: Unknown type %s"
argument_list|,
name|TYPENAME
argument_list|(
name|wk
operator|->
name|wk_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
operator|(
name|void
operator|)
name|getdirtybuf
argument_list|(
operator|&
name|TAILQ_NEXT
argument_list|(
name|bp
argument_list|,
name|b_vnbufs
argument_list|)
argument_list|,
name|MNT_WAIT
argument_list|)
expr_stmt|;
name|nbp
operator|=
name|TAILQ_NEXT
argument_list|(
name|bp
argument_list|,
name|b_vnbufs
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|bawrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbp
operator|!=
name|NULL
condition|)
block|{
name|bp
operator|=
name|nbp
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
comment|/* 	 * The brief unlock is to allow any pent up dependency 	 * processing to be done.  Then proceed with the second pass. 	 */
if|if
condition|(
name|waitfor
operator|==
name|MNT_NOWAIT
condition|)
block|{
name|waitfor
operator|=
name|MNT_WAIT
expr_stmt|;
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
comment|/* 	 * If we have managed to get rid of all the dirty buffers, 	 * then we are done. For certain directories and block 	 * devices, we may need to do further work. 	 */
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|vp
operator|->
name|v_dirtyblkhd
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
comment|/* 	 * If we are trying to sync a block device, some of its buffers may 	 * contain metadata that cannot be written until the contents of some 	 * partially written files have been written to disk. The only easy 	 * way to accomplish this is to sync the entire filesystem (luckily 	 * this happens rarely). 	 * 	 * We must wait for any I/O in progress to finish so that 	 * all potential buffers on the dirty list will be visible. 	 */
name|drain_output
argument_list|(
name|vp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|vn_isdisk
argument_list|(
name|vp
argument_list|,
name|NULL
argument_list|)
operator|&&
name|vp
operator|->
name|v_specmountpoint
operator|&&
operator|!
name|VOP_ISLOCKED
argument_list|(
name|vp
argument_list|,
name|NULL
argument_list|)
operator|&&
operator|(
name|error
operator|=
name|VFS_SYNC
argument_list|(
name|vp
operator|->
name|v_specmountpoint
argument_list|,
name|MNT_WAIT
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Flush the dependencies associated with an inodedep.  * Called with splbio blocked.  */
end_comment

begin_function
specifier|static
name|int
name|flush_inodedep_deps
parameter_list|(
name|fs
parameter_list|,
name|ino
parameter_list|)
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|ino_t
name|ino
decl_stmt|;
block|{
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|allocdirect
modifier|*
name|adp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|waitfor
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
comment|/* 	 * This work is done in two passes. The first pass grabs most 	 * of the buffers and begins asynchronously writing them. The 	 * only way to wait for these asynchronous writes is to sleep 	 * on the filesystem vnode which may stay busy for a long time 	 * if the filesystem is active. So, instead, we make a second 	 * pass over the dependencies blocking on each write. In the 	 * usual case we will be blocking against a write that we 	 * initiated, so when it is done the dependency will have been 	 * resolved. Thus the second pass is expected to end quickly. 	 * We give a brief window at the top of the loop to allow 	 * any pending I/O to complete. 	 */
for|for
control|(
name|waitfor
operator|=
name|MNT_NOWAIT
init|;
condition|;
control|)
block|{
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
if|if
condition|(
name|inodedep_lookup
argument_list|(
name|fs
argument_list|,
name|ino
argument_list|,
literal|0
argument_list|,
operator|&
name|inodedep
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|TAILQ_FOREACH
argument_list|(
argument|adp
argument_list|,
argument|&inodedep->id_inoupdt
argument_list|,
argument|ad_next
argument_list|)
block|{
if|if
condition|(
name|adp
operator|->
name|ad_state
operator|&
name|DEPCOMPLETE
condition|)
continue|continue;
name|bp
operator|=
name|adp
operator|->
name|ad_buf
expr_stmt|;
if|if
condition|(
name|getdirtybuf
argument_list|(
operator|&
name|bp
argument_list|,
name|waitfor
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|waitfor
operator|==
name|MNT_NOWAIT
condition|)
continue|continue;
break|break;
block|}
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
if|if
condition|(
name|waitfor
operator|==
name|MNT_NOWAIT
condition|)
block|{
name|bawrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_BWRITE
argument_list|(
name|bp
operator|->
name|b_vp
argument_list|,
name|bp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|adp
operator|!=
name|NULL
condition|)
continue|continue;
name|TAILQ_FOREACH
argument_list|(
argument|adp
argument_list|,
argument|&inodedep->id_newinoupdt
argument_list|,
argument|ad_next
argument_list|)
block|{
if|if
condition|(
name|adp
operator|->
name|ad_state
operator|&
name|DEPCOMPLETE
condition|)
continue|continue;
name|bp
operator|=
name|adp
operator|->
name|ad_buf
expr_stmt|;
if|if
condition|(
name|getdirtybuf
argument_list|(
operator|&
name|bp
argument_list|,
name|waitfor
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|waitfor
operator|==
name|MNT_NOWAIT
condition|)
continue|continue;
break|break;
block|}
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
if|if
condition|(
name|waitfor
operator|==
name|MNT_NOWAIT
condition|)
block|{
name|bawrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_BWRITE
argument_list|(
name|bp
operator|->
name|b_vp
argument_list|,
name|bp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|adp
operator|!=
name|NULL
condition|)
continue|continue;
comment|/* 		 * If pass2, we are done, otherwise do pass 2. 		 */
if|if
condition|(
name|waitfor
operator|==
name|MNT_WAIT
condition|)
break|break;
name|waitfor
operator|=
name|MNT_WAIT
expr_stmt|;
block|}
comment|/* 	 * Try freeing inodedep in case all dependencies have been removed. 	 */
if|if
condition|(
name|inodedep_lookup
argument_list|(
name|fs
argument_list|,
name|ino
argument_list|,
literal|0
argument_list|,
operator|&
name|inodedep
argument_list|)
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|free_inodedep
argument_list|(
name|inodedep
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Eliminate a pagedep dependency by flushing out all its diradd dependencies.  * Called with splbio blocked.  */
end_comment

begin_function
specifier|static
name|int
name|flush_pagedep_deps
parameter_list|(
name|pvp
parameter_list|,
name|mp
parameter_list|,
name|diraddhdp
parameter_list|)
name|struct
name|vnode
modifier|*
name|pvp
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|diraddhd
modifier|*
name|diraddhdp
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|CURPROC
decl_stmt|;
comment|/* XXX */
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|struct
name|diradd
modifier|*
name|dap
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|gotit
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|ino_t
name|inum
decl_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|dap
operator|=
name|LIST_FIRST
argument_list|(
name|diraddhdp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Flush ourselves if this directory entry 		 * has a MKDIR_PARENT dependency. 		 */
if|if
condition|(
name|dap
operator|->
name|da_state
operator|&
name|MKDIR_PARENT
condition|)
block|{
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|UFS_UPDATE
argument_list|(
name|pvp
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
comment|/* 			 * If that cleared dependencies, go on to next. 			 */
if|if
condition|(
name|dap
operator|!=
name|LIST_FIRST
argument_list|(
name|diraddhdp
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|dap
operator|->
name|da_state
operator|&
name|MKDIR_PARENT
condition|)
block|{
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"flush_pagedep_deps: MKDIR_PARENT"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * A newly allocated directory must have its "." and 		 * ".." entries written out before its name can be 		 * committed in its parent. We do not want or need 		 * the full semantics of a synchronous VOP_FSYNC as 		 * that may end up here again, once for each directory 		 * level in the filesystem. Instead, we push the blocks 		 * and wait for them to clear. We have to fsync twice 		 * because the first call may choose to defer blocks 		 * that still have dependencies, but deferral will 		 * happen at most once. 		 */
name|inum
operator|=
name|dap
operator|->
name|da_newinum
expr_stmt|;
if|if
condition|(
name|dap
operator|->
name|da_state
operator|&
name|MKDIR_BODY
condition|)
block|{
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|VFS_VGET
argument_list|(
name|mp
argument_list|,
name|inum
argument_list|,
operator|&
name|vp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_FSYNC
argument_list|(
name|vp
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
name|MNT_NOWAIT
argument_list|,
name|p
argument_list|)
operator|)
operator|||
operator|(
name|error
operator|=
name|VOP_FSYNC
argument_list|(
name|vp
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
name|MNT_NOWAIT
argument_list|,
name|p
argument_list|)
operator|)
condition|)
block|{
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
break|break;
block|}
name|drain_output
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
comment|/* 			 * If that cleared dependencies, go on to next. 			 */
if|if
condition|(
name|dap
operator|!=
name|LIST_FIRST
argument_list|(
name|diraddhdp
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|dap
operator|->
name|da_state
operator|&
name|MKDIR_BODY
condition|)
block|{
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"flush_pagedep_deps: MKDIR_BODY"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Flush the inode on which the directory entry depends. 		 * Having accounted for MKDIR_PARENT and MKDIR_BODY above, 		 * the only remaining dependency is that the updated inode 		 * count must get pushed to disk. The inode has already 		 * been pushed into its inode buffer (via VOP_UPDATE) at 		 * the time of the reference count change. So we need only 		 * locate that buffer, ensure that there will be no rollback 		 * caused by a bitmap dependency, then write the inode buffer. 		 */
if|if
condition|(
name|inodedep_lookup
argument_list|(
name|ump
operator|->
name|um_fs
argument_list|,
name|inum
argument_list|,
literal|0
argument_list|,
operator|&
name|inodedep
argument_list|)
operator|==
literal|0
condition|)
block|{
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"flush_pagedep_deps: lost inode"
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If the inode still has bitmap dependencies, 		 * push them to disk. 		 */
if|if
condition|(
operator|(
name|inodedep
operator|->
name|id_state
operator|&
name|DEPCOMPLETE
operator|)
operator|==
literal|0
condition|)
block|{
name|gotit
operator|=
name|getdirtybuf
argument_list|(
operator|&
name|inodedep
operator|->
name|id_buf
argument_list|,
name|MNT_WAIT
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
if|if
condition|(
name|gotit
operator|&&
operator|(
name|error
operator|=
name|VOP_BWRITE
argument_list|(
name|inodedep
operator|->
name|id_buf
operator|->
name|b_vp
argument_list|,
name|inodedep
operator|->
name|id_buf
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
if|if
condition|(
name|dap
operator|!=
name|LIST_FIRST
argument_list|(
name|diraddhdp
argument_list|)
condition|)
continue|continue;
block|}
comment|/* 		 * If the inode is still sitting in a buffer waiting 		 * to be written, push it to disk. 		 */
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bread
argument_list|(
name|ump
operator|->
name|um_devvp
argument_list|,
name|fsbtodb
argument_list|(
name|ump
operator|->
name|um_fs
argument_list|,
name|ino_to_fsba
argument_list|(
name|ump
operator|->
name|um_fs
argument_list|,
name|inum
argument_list|)
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|ump
operator|->
name|um_fs
operator|->
name|fs_bsize
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_BWRITE
argument_list|(
name|bp
operator|->
name|b_vp
argument_list|,
name|bp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
comment|/* 		 * If we have failed to get rid of all the dependencies 		 * then something is seriously wrong. 		 */
if|if
condition|(
name|dap
operator|==
name|LIST_FIRST
argument_list|(
name|diraddhdp
argument_list|)
condition|)
block|{
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"flush_pagedep_deps: flush failed"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
condition|)
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * A large burst of file addition or deletion activity can drive the  * memory load excessively high. First attempt to slow things down  * using the techniques below. If that fails, this routine requests  * the offending operations to fall back to running synchronously  * until the memory load returns to a reasonable level.  */
end_comment

begin_function
name|int
name|softdep_slowdown
parameter_list|(
name|vp
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
block|{
name|int
name|max_softdeps_hard
decl_stmt|;
name|max_softdeps_hard
operator|=
name|max_softdeps
operator|*
literal|11
operator|/
literal|10
expr_stmt|;
if|if
condition|(
name|num_dirrem
operator|<
name|max_softdeps_hard
operator|/
literal|2
operator|&&
name|num_inodedep
operator|<
name|max_softdeps_hard
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|stat_sync_limit_hit
operator|+=
literal|1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If memory utilization has gotten too high, deliberately slow things  * down and speed up the I/O processing.  */
end_comment

begin_function
specifier|static
name|int
name|request_cleanup
parameter_list|(
name|resource
parameter_list|,
name|islocked
parameter_list|)
name|int
name|resource
decl_stmt|;
name|int
name|islocked
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|CURPROC
decl_stmt|;
comment|/* 	 * We never hold up the filesystem syncer process. 	 */
if|if
condition|(
name|p
operator|==
name|filesys_syncer
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * First check to see if the work list has gotten backlogged. 	 * If it has, co-opt this process to help clean up two entries. 	 * Because this process may hold inodes locked, we cannot 	 * handle any remove requests that might block on a locked 	 * inode as that could lead to deadlock. 	 */
if|if
condition|(
name|num_on_worklist
operator|>
name|max_softdeps
operator|/
literal|10
condition|)
block|{
if|if
condition|(
name|islocked
condition|)
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|process_worklist_item
argument_list|(
name|NULL
argument_list|,
name|LK_NOWAIT
argument_list|)
expr_stmt|;
name|process_worklist_item
argument_list|(
name|NULL
argument_list|,
name|LK_NOWAIT
argument_list|)
expr_stmt|;
name|stat_worklist_push
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|islocked
condition|)
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * If we are resource constrained on inode dependencies, try 	 * flushing some dirty inodes. Otherwise, we are constrained 	 * by file deletions, so try accelerating flushes of directories 	 * with removal dependencies. We would like to do the cleanup 	 * here, but we probably hold an inode locked at this point and  	 * that might deadlock against one that we try to clean. So, 	 * the best that we can do is request the syncer daemon to do 	 * the cleanup for us. 	 */
switch|switch
condition|(
name|resource
condition|)
block|{
case|case
name|FLUSH_INODES
case|:
name|stat_ino_limit_push
operator|+=
literal|1
expr_stmt|;
name|req_clear_inodedeps
operator|+=
literal|1
expr_stmt|;
name|stat_countp
operator|=
operator|&
name|stat_ino_limit_hit
expr_stmt|;
break|break;
case|case
name|FLUSH_REMOVE
case|:
name|stat_blk_limit_push
operator|+=
literal|1
expr_stmt|;
name|req_clear_remove
operator|+=
literal|1
expr_stmt|;
name|stat_countp
operator|=
operator|&
name|stat_blk_limit_hit
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|islocked
condition|)
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"request_cleanup: unknown type"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Hopefully the syncer daemon will catch up and awaken us. 	 * We wait at most tickdelay before proceeding in any case. 	 */
if|if
condition|(
name|islocked
operator|==
literal|0
condition|)
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|proc_waiting
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|handle
operator|.
name|callout
operator|==
name|NULL
condition|)
name|handle
operator|=
name|timeout
argument_list|(
name|pause_timer
argument_list|,
literal|0
argument_list|,
name|tickdelay
operator|>
literal|2
condition|?
name|tickdelay
else|:
literal|2
argument_list|)
expr_stmt|;
name|FREE_LOCK_INTERLOCKED
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|proc_waiting
argument_list|,
name|PPAUSE
argument_list|,
literal|"softupdate"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK_INTERLOCKED
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|proc_waiting
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|islocked
operator|==
literal|0
condition|)
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Awaken processes pausing in request_cleanup and clear proc_waiting  * to indicate that there is no longer a timer running.  */
end_comment

begin_function
name|void
name|pause_timer
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
operator|*
name|stat_countp
operator|+=
literal|1
expr_stmt|;
name|wakeup_one
argument_list|(
operator|&
name|proc_waiting
argument_list|)
expr_stmt|;
if|if
condition|(
name|proc_waiting
operator|>
literal|0
condition|)
name|handle
operator|=
name|timeout
argument_list|(
name|pause_timer
argument_list|,
literal|0
argument_list|,
name|tickdelay
operator|>
literal|2
condition|?
name|tickdelay
else|:
literal|2
argument_list|)
expr_stmt|;
else|else
name|handle
operator|.
name|callout
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Flush out a directory with at least one removal dependency in an effort to  * reduce the number of dirrem, freefile, and freeblks dependency structures.  */
end_comment

begin_function
specifier|static
name|void
name|clear_remove
parameter_list|(
name|p
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|pagedep_hashhead
modifier|*
name|pagedephd
decl_stmt|;
name|struct
name|pagedep
modifier|*
name|pagedep
decl_stmt|;
specifier|static
name|int
name|next
init|=
literal|0
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|cnt
decl_stmt|;
name|ino_t
name|ino
decl_stmt|;
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|pagedep_hash
condition|;
name|cnt
operator|++
control|)
block|{
name|pagedephd
operator|=
operator|&
name|pagedep_hashtbl
index|[
name|next
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|next
operator|>=
name|pagedep_hash
condition|)
name|next
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|pagedep
argument_list|,
argument|pagedephd
argument_list|,
argument|pd_hash
argument_list|)
block|{
if|if
condition|(
name|LIST_FIRST
argument_list|(
operator|&
name|pagedep
operator|->
name|pd_dirremhd
argument_list|)
operator|==
name|NULL
condition|)
continue|continue;
name|mp
operator|=
name|pagedep
operator|->
name|pd_mnt
expr_stmt|;
name|ino
operator|=
name|pagedep
operator|->
name|pd_ino
expr_stmt|;
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|VFS_VGET
argument_list|(
name|mp
argument_list|,
name|ino
argument_list|,
operator|&
name|vp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|softdep_error
argument_list|(
literal|"clear_remove: vget"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_FSYNC
argument_list|(
name|vp
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
name|MNT_NOWAIT
argument_list|,
name|p
argument_list|)
operator|)
condition|)
name|softdep_error
argument_list|(
literal|"clear_remove: fsync"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|drain_output
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Clear out a block of dirty inodes in an effort to reduce  * the number of inodedep dependency structures.  */
end_comment

begin_function
specifier|static
name|void
name|clear_inodedeps
parameter_list|(
name|p
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|inodedep_hashhead
modifier|*
name|inodedephd
decl_stmt|;
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
specifier|static
name|int
name|next
init|=
literal|0
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|int
name|error
decl_stmt|,
name|cnt
decl_stmt|;
name|ino_t
name|firstino
decl_stmt|,
name|lastino
decl_stmt|,
name|ino
decl_stmt|;
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
comment|/* 	 * Pick a random inode dependency to be cleared. 	 * We will then gather up all the inodes in its block  	 * that have dependencies and flush them out. 	 */
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|inodedep_hash
condition|;
name|cnt
operator|++
control|)
block|{
name|inodedephd
operator|=
operator|&
name|inodedep_hashtbl
index|[
name|next
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|next
operator|>=
name|inodedep_hash
condition|)
name|next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|inodedep
operator|=
name|LIST_FIRST
argument_list|(
name|inodedephd
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
name|inodedep
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * Ugly code to find mount point given pointer to superblock. 	 */
name|fs
operator|=
name|inodedep
operator|->
name|id_fs
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|mp
argument_list|,
argument|&mountlist
argument_list|,
argument|mnt_list
argument_list|)
if|if
condition|(
operator|(
name|mp
operator|->
name|mnt_flag
operator|&
name|MNT_SOFTDEP
operator|)
operator|&&
name|fs
operator|==
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
operator|->
name|um_fs
condition|)
break|break;
comment|/* 	 * Find the last inode in the block with dependencies. 	 */
name|firstino
operator|=
name|inodedep
operator|->
name|id_ino
operator|&
operator|~
operator|(
name|INOPB
argument_list|(
name|fs
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|lastino
operator|=
name|firstino
operator|+
name|INOPB
argument_list|(
name|fs
argument_list|)
operator|-
literal|1
init|;
name|lastino
operator|>
name|firstino
condition|;
name|lastino
operator|--
control|)
if|if
condition|(
name|inodedep_lookup
argument_list|(
name|fs
argument_list|,
name|lastino
argument_list|,
literal|0
argument_list|,
operator|&
name|inodedep
argument_list|)
operator|!=
literal|0
condition|)
break|break;
comment|/* 	 * Asynchronously push all but the last inode with dependencies. 	 * Synchronously push the last inode with dependencies to ensure 	 * that the inode block gets written to free up the inodedeps. 	 */
for|for
control|(
name|ino
operator|=
name|firstino
init|;
name|ino
operator|<=
name|lastino
condition|;
name|ino
operator|++
control|)
block|{
if|if
condition|(
name|inodedep_lookup
argument_list|(
name|fs
argument_list|,
name|ino
argument_list|,
literal|0
argument_list|,
operator|&
name|inodedep
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|VFS_VGET
argument_list|(
name|mp
argument_list|,
name|ino
argument_list|,
operator|&
name|vp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|softdep_error
argument_list|(
literal|"clear_inodedeps: vget"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ino
operator|==
name|lastino
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_FSYNC
argument_list|(
name|vp
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
name|MNT_WAIT
argument_list|,
name|p
argument_list|)
operator|)
condition|)
name|softdep_error
argument_list|(
literal|"clear_inodedeps: fsync1"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_FSYNC
argument_list|(
name|vp
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
name|MNT_NOWAIT
argument_list|,
name|p
argument_list|)
operator|)
condition|)
name|softdep_error
argument_list|(
literal|"clear_inodedeps: fsync2"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|drain_output
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
block|}
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Function to determine if the buffer has outstanding dependencies  * that will cause a roll-back if the buffer is written. If wantcount  * is set, return number of dependencies, otherwise just yes or no.  */
end_comment

begin_function
specifier|static
name|int
name|softdep_count_dependencies
parameter_list|(
name|bp
parameter_list|,
name|wantcount
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|wantcount
decl_stmt|;
block|{
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|indirdep
modifier|*
name|indirdep
decl_stmt|;
name|struct
name|allocindir
modifier|*
name|aip
decl_stmt|;
name|struct
name|pagedep
modifier|*
name|pagedep
decl_stmt|;
name|struct
name|diradd
modifier|*
name|dap
decl_stmt|;
name|int
name|i
decl_stmt|,
name|retval
decl_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|wk
argument_list|,
argument|&bp->b_dep
argument_list|,
argument|wk_list
argument_list|)
block|{
switch|switch
condition|(
name|wk
operator|->
name|wk_type
condition|)
block|{
case|case
name|D_INODEDEP
case|:
name|inodedep
operator|=
name|WK_INODEDEP
argument_list|(
name|wk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inodedep
operator|->
name|id_state
operator|&
name|DEPCOMPLETE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* bitmap allocation dependency */
name|retval
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|wantcount
condition|)
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoupdt
argument_list|)
condition|)
block|{
comment|/* direct block pointer dependency */
name|retval
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|wantcount
condition|)
goto|goto
name|out
goto|;
block|}
continue|continue;
case|case
name|D_INDIRDEP
case|:
name|indirdep
operator|=
name|WK_INDIRDEP
argument_list|(
name|wk
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|aip
argument_list|,
argument|&indirdep->ir_deplisthd
argument_list|,
argument|ai_next
argument_list|)
block|{
comment|/* indirect block pointer dependency */
name|retval
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|wantcount
condition|)
goto|goto
name|out
goto|;
block|}
continue|continue;
case|case
name|D_PAGEDEP
case|:
name|pagedep
operator|=
name|WK_PAGEDEP
argument_list|(
name|wk
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DAHASHSZ
condition|;
name|i
operator|++
control|)
block|{
name|LIST_FOREACH
argument_list|(
argument|dap
argument_list|,
argument|&pagedep->pd_diraddhd[i]
argument_list|,
argument|da_pdlist
argument_list|)
block|{
comment|/* directory entry dependency */
name|retval
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|wantcount
condition|)
goto|goto
name|out
goto|;
block|}
block|}
continue|continue;
case|case
name|D_BMSAFEMAP
case|:
case|case
name|D_ALLOCDIRECT
case|:
case|case
name|D_ALLOCINDIR
case|:
case|case
name|D_MKDIR
case|:
comment|/* never a dependency on these blocks */
continue|continue;
default|default:
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"softdep_check_for_rollback: Unexpected type %s"
argument_list|,
name|TYPENAME
argument_list|(
name|wk
operator|->
name|wk_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
name|out
label|:
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * Acquire exclusive access to a buffer.  * Must be called with splbio blocked.  * Return 1 if buffer was acquired.  */
end_comment

begin_function
specifier|static
name|int
name|getdirtybuf
parameter_list|(
name|bpp
parameter_list|,
name|waitfor
parameter_list|)
name|struct
name|buf
modifier|*
modifier|*
name|bpp
decl_stmt|;
name|int
name|waitfor
decl_stmt|;
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|bp
operator|=
operator|*
name|bpp
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|BUF_LOCK
argument_list|(
name|bp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_NOWAIT
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|bp
operator|->
name|b_xflags
operator|&
name|BX_BKGRDINPROG
operator|)
operator|==
literal|0
condition|)
break|break;
name|BUF_UNLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|waitfor
operator|!=
name|MNT_WAIT
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|bp
operator|->
name|b_xflags
operator||=
name|BX_BKGRDWAIT
expr_stmt|;
name|FREE_LOCK_INTERLOCKED
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|tsleep
argument_list|(
operator|&
name|bp
operator|->
name|b_xflags
argument_list|,
name|PRIBIO
argument_list|,
literal|"getbuf"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK_INTERLOCKED
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|waitfor
operator|!=
name|MNT_WAIT
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|FREE_LOCK_INTERLOCKED
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
if|if
condition|(
name|BUF_LOCK
argument_list|(
name|bp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_SLEEPFAIL
argument_list|)
operator|!=
name|ENOLCK
condition|)
name|panic
argument_list|(
literal|"getdirtybuf: inconsistent lock"
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK_INTERLOCKED
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DELWRI
operator|)
operator|==
literal|0
condition|)
block|{
name|BUF_UNLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|bremfree
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Wait for pending output on a vnode to complete.  * Must be called with vnode locked.  */
end_comment

begin_function
specifier|static
name|void
name|drain_output
parameter_list|(
name|vp
parameter_list|,
name|islocked
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|islocked
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|islocked
condition|)
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
while|while
condition|(
name|vp
operator|->
name|v_numoutput
condition|)
block|{
name|vp
operator|->
name|v_flag
operator||=
name|VBWAIT
expr_stmt|;
name|FREE_LOCK_INTERLOCKED
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|vp
operator|->
name|v_numoutput
argument_list|,
name|PRIBIO
operator|+
literal|1
argument_list|,
literal|"drainvp"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK_INTERLOCKED
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|islocked
condition|)
name|FREE_LOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called whenever a buffer that is being invalidated or reallocated  * contains dependencies. This should only happen if an I/O error has  * occurred. The routine is called with the buffer locked.  */
end_comment

begin_function
specifier|static
name|void
name|softdep_deallocate_dependencies
parameter_list|(
name|bp
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"softdep_deallocate_dependencies: dangling deps"
argument_list|)
expr_stmt|;
name|softdep_error
argument_list|(
name|bp
operator|->
name|b_vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_mntonname
argument_list|,
name|bp
operator|->
name|b_error
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"softdep_deallocate_dependencies: unrecovered I/O error"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Function to handle asynchronous write errors in the filesystem.  */
end_comment

begin_function
name|void
name|softdep_error
parameter_list|(
name|func
parameter_list|,
name|error
parameter_list|)
name|char
modifier|*
name|func
decl_stmt|;
name|int
name|error
decl_stmt|;
block|{
comment|/* XXX should do something better! */
name|printf
argument_list|(
literal|"%s: got error %d while accessing filesystem\n"
argument_list|,
name|func
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

