begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2000 Marshall Kirk McKusick. All Rights Reserved.  *  * Further information about snapshots can be obtained from:  *  *	Marshall Kirk McKusick		http://www.mckusick.com/softdep/  *	1614 Oxford Street		mckusick@mckusick.com  *	Berkeley, CA 94709-1608		+1-510-843-9542  *	USA  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY MARSHALL KIRK MCKUSICK ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL MARSHALL KIRK MCKUSICK BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)ffs_snapshot.c	8.11 (McKusick) 7/23/00  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/extattr.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/quota.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/ufsmount.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/inode.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/ufs_extern.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ffs/fs.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ffs/ffs_extern.h>
end_include

begin_define
define|#
directive|define
name|KERNCRED
value|proc0.p_ucred
end_define

begin_define
define|#
directive|define
name|CURPROC
value|curproc
end_define

begin_define
define|#
directive|define
name|DEBUG
end_define

begin_decl_stmt
specifier|static
name|int
name|indiracct
name|__P
argument_list|(
operator|(
expr|struct
name|vnode
operator|*
operator|,
expr|struct
name|vnode
operator|*
operator|,
name|int
operator|,
name|ufs_daddr_t
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|snapacct
name|__P
argument_list|(
operator|(
expr|struct
name|vnode
operator|*
operator|,
name|ufs_daddr_t
operator|*
operator|,
name|ufs_daddr_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|readblock
name|__P
argument_list|(
operator|(
expr|struct
name|buf
operator|*
operator|,
name|daddr_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_decl_stmt
name|int
name|snapdebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|snapdebug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|snapdebug
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_comment
comment|/*  * Create a snapshot file and initialize it for the filesystem.  */
end_comment

begin_function
name|int
name|ffs_snapshot
parameter_list|(
name|mp
parameter_list|,
name|snapfile
parameter_list|)
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|char
modifier|*
name|snapfile
decl_stmt|;
block|{
name|ufs_daddr_t
name|rlbn
decl_stmt|;
name|ufs_daddr_t
name|lbn
decl_stmt|,
name|blkno
decl_stmt|,
name|copyblkno
decl_stmt|,
name|inoblks
index|[
name|FSMAXSNAP
index|]
decl_stmt|;
name|int
name|error
decl_stmt|,
name|cg
decl_stmt|,
name|snaploc
decl_stmt|,
name|indiroff
decl_stmt|,
name|numblks
decl_stmt|;
name|int
name|i
decl_stmt|,
name|size
decl_stmt|,
name|base
decl_stmt|,
name|len
decl_stmt|,
name|loc
decl_stmt|,
name|inoblkcnt
decl_stmt|;
name|int
name|blksperindir
decl_stmt|,
name|flag
init|=
name|mp
operator|->
name|mnt_flag
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
init|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
operator|->
name|um_fs
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|CURPROC
decl_stmt|;
name|struct
name|inode
modifier|*
name|devip
decl_stmt|,
modifier|*
name|ip
decl_stmt|,
modifier|*
name|xp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|nbp
decl_stmt|,
modifier|*
name|ibp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|,
modifier|*
name|devvp
decl_stmt|;
name|struct
name|nameidata
name|nd
decl_stmt|;
name|struct
name|mount
modifier|*
name|wrtmp
decl_stmt|;
name|struct
name|dinode
modifier|*
name|dip
decl_stmt|;
name|struct
name|vattr
name|vat
decl_stmt|;
name|struct
name|cg
modifier|*
name|cgp
decl_stmt|;
comment|/* 	 * Need to serialize access to snapshot code per filesystem. 	 */
comment|/* 	 * Assign a snapshot slot in the superblock. 	 */
for|for
control|(
name|snaploc
operator|=
literal|0
init|;
name|snaploc
operator|<
name|FSMAXSNAP
condition|;
name|snaploc
operator|++
control|)
if|if
condition|(
name|fs
operator|->
name|fs_snapinum
index|[
name|snaploc
index|]
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|snaploc
operator|==
name|FSMAXSNAP
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
comment|/* 	 * Create the snapshot file. 	 */
name|restart
label|:
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|CREATE
argument_list|,
name|LOCKPARENT
operator||
name|LOCKLEAF
argument_list|,
name|UIO_USERSPACE
argument_list|,
name|snapfile
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|.
name|ni_vp
operator|!=
name|NULL
condition|)
block|{
name|vput
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|)
expr_stmt|;
name|error
operator|=
name|EEXIST
expr_stmt|;
block|}
if|if
condition|(
name|nd
operator|.
name|ni_dvp
operator|->
name|v_mount
operator|!=
name|mp
condition|)
name|error
operator|=
name|EXDEV
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|.
name|ni_dvp
operator|==
name|nd
operator|.
name|ni_vp
condition|)
name|vrele
argument_list|(
name|nd
operator|.
name|ni_dvp
argument_list|)
expr_stmt|;
else|else
name|vput
argument_list|(
name|nd
operator|.
name|ni_dvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|VATTR_NULL
argument_list|(
operator|&
name|vat
argument_list|)
expr_stmt|;
name|vat
operator|.
name|va_type
operator|=
name|VREG
expr_stmt|;
name|vat
operator|.
name|va_mode
operator|=
name|S_IRUSR
expr_stmt|;
name|vat
operator|.
name|va_vaflags
operator||=
name|VA_EXCLUSIVE
expr_stmt|;
if|if
condition|(
name|VOP_GETWRITEMOUNT
argument_list|(
name|nd
operator|.
name|ni_dvp
argument_list|,
operator|&
name|wrtmp
argument_list|)
condition|)
name|wrtmp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|wrtmp
operator|!=
name|mp
condition|)
name|panic
argument_list|(
literal|"ffs_snapshot: mount mismatch"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vn_start_write
argument_list|(
name|NULL
argument_list|,
operator|&
name|wrtmp
argument_list|,
name|V_NOWAIT
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|nd
operator|.
name|ni_dvp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|vn_start_write
argument_list|(
name|NULL
argument_list|,
operator|&
name|wrtmp
argument_list|,
name|V_XSLEEP
operator||
name|PCATCH
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
goto|goto
name|restart
goto|;
block|}
name|VOP_LEASE
argument_list|(
name|nd
operator|.
name|ni_dvp
argument_list|,
name|p
argument_list|,
name|KERNCRED
argument_list|,
name|LEASE_WRITE
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_CREATE
argument_list|(
name|nd
operator|.
name|ni_dvp
argument_list|,
operator|&
name|nd
operator|.
name|ni_vp
argument_list|,
operator|&
name|nd
operator|.
name|ni_cnd
argument_list|,
operator|&
name|vat
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|nd
operator|.
name|ni_dvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
name|vn_finished_write
argument_list|(
name|wrtmp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|vp
operator|=
name|nd
operator|.
name|ni_vp
expr_stmt|;
name|ip
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|devvp
operator|=
name|ip
operator|->
name|i_devvp
expr_stmt|;
name|devip
operator|=
name|VTOI
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate and copy the last block contents so as to be able 	 * to set size to that of the filesystem. 	 */
name|numblks
operator|=
name|howmany
argument_list|(
name|fs
operator|->
name|fs_size
argument_list|,
name|fs
operator|->
name|fs_frag
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_BALLOC
argument_list|(
name|vp
argument_list|,
name|lblktosize
argument_list|(
name|fs
argument_list|,
call|(
name|off_t
call|)
argument_list|(
name|numblks
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
name|B_CLRBUF
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|ip
operator|->
name|i_size
operator|=
name|lblktosize
argument_list|(
name|fs
argument_list|,
operator|(
name|off_t
operator|)
name|numblks
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_flag
operator||=
name|IN_CHANGE
operator||
name|IN_UPDATE
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|readblock
argument_list|(
name|bp
argument_list|,
name|numblks
operator|-
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|bawrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * Preallocate critical data structures so that we can copy 	 * them in without further allocation after we suspend all 	 * operations on the filesystem. We would like to just release 	 * the allocated buffers without writing them since they will 	 * be filled in below once we are ready to go, but this upsets 	 * the soft update code, so we go ahead and write the new buffers. 	 * 	 * Allocate all indirect blocks. Also allocate shadow copies 	 * for each of the indirect blocks. 	 */
for|for
control|(
name|blkno
operator|=
name|NDADDR
init|;
name|blkno
operator|<
name|numblks
condition|;
name|blkno
operator|+=
name|NINDIR
argument_list|(
name|fs
argument_list|)
control|)
block|{
name|error
operator|=
name|VOP_BALLOC
argument_list|(
name|vp
argument_list|,
name|lblktosize
argument_list|(
name|fs
argument_list|,
operator|(
name|off_t
operator|)
name|blkno
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
name|B_METAONLY
argument_list|,
operator|&
name|ibp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|copyblkno
operator|=
name|fragstoblks
argument_list|(
name|fs
argument_list|,
name|dbtofsb
argument_list|(
name|fs
argument_list|,
name|ibp
operator|->
name|b_blkno
argument_list|)
argument_list|)
expr_stmt|;
name|bdwrite
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_BALLOC
argument_list|(
name|vp
argument_list|,
name|lblktosize
argument_list|(
name|fs
argument_list|,
operator|(
name|off_t
operator|)
name|copyblkno
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
literal|0
argument_list|,
operator|&
name|nbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|bawrite
argument_list|(
name|nbp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Allocate shadow blocks to copy all of the other snapshot inodes 	 * so that we will be able to expunge them from this snapshot. 	 */
for|for
control|(
name|loc
operator|=
literal|0
operator|,
name|inoblkcnt
operator|=
literal|0
init|;
name|loc
operator|<
name|snaploc
condition|;
name|loc
operator|++
control|)
block|{
name|blkno
operator|=
name|fragstoblks
argument_list|(
name|fs
argument_list|,
name|ino_to_fsba
argument_list|(
name|fs
argument_list|,
name|fs
operator|->
name|fs_snapinum
index|[
name|loc
index|]
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|inoblkcnt
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|inoblks
index|[
name|i
index|]
operator|==
name|blkno
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|inoblkcnt
condition|)
block|{
name|inoblks
index|[
name|inoblkcnt
operator|++
index|]
operator|=
name|blkno
expr_stmt|;
name|error
operator|=
name|VOP_BALLOC
argument_list|(
name|vp
argument_list|,
name|lblktosize
argument_list|(
name|fs
argument_list|,
operator|(
name|off_t
operator|)
name|blkno
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
literal|0
argument_list|,
operator|&
name|nbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|bawrite
argument_list|(
name|nbp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Allocate all cylinder group blocks. 	 */
for|for
control|(
name|cg
operator|=
literal|0
init|;
name|cg
operator|<
name|fs
operator|->
name|fs_ncg
condition|;
name|cg
operator|++
control|)
block|{
name|error
operator|=
name|VOP_BALLOC
argument_list|(
name|vp
argument_list|,
call|(
name|off_t
call|)
argument_list|(
name|cgtod
argument_list|(
name|fs
argument_list|,
name|cg
argument_list|)
argument_list|)
operator|<<
name|fs
operator|->
name|fs_fshift
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
literal|0
argument_list|,
operator|&
name|nbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|bawrite
argument_list|(
name|nbp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Allocate copies for the superblock and its summary information. 	 */
name|error
operator|=
name|VOP_BALLOC
argument_list|(
name|vp
argument_list|,
call|(
name|off_t
call|)
argument_list|(
name|SBOFF
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
literal|0
argument_list|,
operator|&
name|nbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|bawrite
argument_list|(
name|nbp
argument_list|)
expr_stmt|;
name|blkno
operator|=
name|fragstoblks
argument_list|(
name|fs
argument_list|,
name|fs
operator|->
name|fs_csaddr
argument_list|)
expr_stmt|;
name|len
operator|=
name|howmany
argument_list|(
name|fs
operator|->
name|fs_cssize
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
for|for
control|(
name|loc
operator|=
literal|0
init|;
name|loc
operator|<
name|len
condition|;
name|loc
operator|++
control|)
block|{
name|error
operator|=
name|VOP_BALLOC
argument_list|(
name|vp
argument_list|,
name|lblktosize
argument_list|(
name|fs
argument_list|,
call|(
name|off_t
call|)
argument_list|(
name|blkno
operator|+
name|loc
argument_list|)
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
literal|0
argument_list|,
operator|&
name|nbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|bawrite
argument_list|(
name|nbp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Change inode to snapshot type file. 	 */
name|ip
operator|->
name|i_flags
operator||=
name|SF_IMMUTABLE
operator||
name|SF_SNAPSHOT
expr_stmt|;
name|ip
operator|->
name|i_flag
operator||=
name|IN_CHANGE
operator||
name|IN_UPDATE
expr_stmt|;
comment|/* 	 * Ensure that the snapshot is completely on disk. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_FSYNC
argument_list|(
name|vp
argument_list|,
name|KERNCRED
argument_list|,
name|MNT_WAIT
argument_list|,
name|p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * All allocations are done, so we can now snapshot the system. 	 * 	 * Suspend operation on filesystem. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|vn_finished_write
argument_list|(
name|wrtmp
argument_list|)
expr_stmt|;
name|vfs_write_suspend
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|mnt_kern_flag
operator|&
name|MNTK_SUSPENDED
condition|)
break|break;
name|vn_start_write
argument_list|(
name|NULL
argument_list|,
operator|&
name|wrtmp
argument_list|,
name|V_WAIT
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * First, copy all the cylinder group maps. All the unallocated 	 * blocks are marked BLK_NOCOPY so that the snapshot knows that 	 * it need not copy them if they are later written. 	 */
name|len
operator|=
name|howmany
argument_list|(
name|fs
operator|->
name|fs_fpg
argument_list|,
name|fs
operator|->
name|fs_frag
argument_list|)
expr_stmt|;
for|for
control|(
name|cg
operator|=
literal|0
init|;
name|cg
operator|<
name|fs
operator|->
name|fs_ncg
condition|;
name|cg
operator|++
control|)
block|{
name|error
operator|=
name|bread
argument_list|(
name|ip
operator|->
name|i_devvp
argument_list|,
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|cgtod
argument_list|(
name|fs
argument_list|,
name|cg
argument_list|)
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|fs
operator|->
name|fs_cgsize
argument_list|,
name|KERNCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
goto|goto
name|out1
goto|;
block|}
name|cgp
operator|=
operator|(
expr|struct
name|cg
operator|*
operator|)
name|bp
operator|->
name|b_data
expr_stmt|;
if|if
condition|(
operator|!
name|cg_chkmagic
argument_list|(
name|cgp
argument_list|)
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|out1
goto|;
block|}
name|error
operator|=
name|bread
argument_list|(
name|vp
argument_list|,
name|fragstoblks
argument_list|(
name|fs
argument_list|,
name|cgtod
argument_list|(
name|fs
argument_list|,
name|cg
argument_list|)
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
operator|&
name|nbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|nbp
argument_list|)
expr_stmt|;
goto|goto
name|out1
goto|;
block|}
name|bcopy
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
name|nbp
operator|->
name|b_data
argument_list|,
name|fs
operator|->
name|fs_cgsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|fs_cgsize
operator|<
name|fs
operator|->
name|fs_bsize
condition|)
name|bzero
argument_list|(
operator|&
name|nbp
operator|->
name|b_data
index|[
name|fs
operator|->
name|fs_cgsize
index|]
argument_list|,
name|fs
operator|->
name|fs_bsize
operator|-
name|fs
operator|->
name|fs_cgsize
argument_list|)
expr_stmt|;
name|nbp
operator|->
name|b_flags
operator||=
name|B_VALIDSUSPWRT
expr_stmt|;
name|bawrite
argument_list|(
name|nbp
argument_list|)
expr_stmt|;
name|base
operator|=
name|cg
operator|*
name|fs
operator|->
name|fs_fpg
operator|/
name|fs
operator|->
name|fs_frag
expr_stmt|;
if|if
condition|(
name|base
operator|+
name|len
operator|>
name|numblks
condition|)
name|len
operator|=
name|numblks
operator|-
name|base
expr_stmt|;
name|loc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|base
operator|<
name|NDADDR
condition|)
block|{
for|for
control|(
init|;
name|loc
operator|<
name|NDADDR
condition|;
name|loc
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ffs_isblock
argument_list|(
name|fs
argument_list|,
name|cg_blksfree
argument_list|(
name|cgp
argument_list|)
argument_list|,
name|loc
argument_list|)
condition|)
continue|continue;
name|ip
operator|->
name|i_db
index|[
name|loc
index|]
operator|=
name|BLK_NOCOPY
expr_stmt|;
block|}
block|}
name|error
operator|=
name|VOP_BALLOC
argument_list|(
name|vp
argument_list|,
name|lblktosize
argument_list|(
name|fs
argument_list|,
call|(
name|off_t
call|)
argument_list|(
name|base
operator|+
name|loc
argument_list|)
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
name|B_METAONLY
argument_list|,
operator|&
name|ibp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
goto|goto
name|out1
goto|;
block|}
name|indiroff
operator|=
operator|(
name|base
operator|+
name|loc
operator|-
name|NDADDR
operator|)
operator|%
name|NINDIR
argument_list|(
name|fs
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|loc
operator|<
name|len
condition|;
name|loc
operator|++
operator|,
name|indiroff
operator|++
control|)
block|{
if|if
condition|(
name|indiroff
operator|>=
name|NINDIR
argument_list|(
name|fs
argument_list|)
condition|)
block|{
name|ibp
operator|->
name|b_flags
operator||=
name|B_VALIDSUSPWRT
expr_stmt|;
name|bawrite
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_BALLOC
argument_list|(
name|vp
argument_list|,
name|lblktosize
argument_list|(
name|fs
argument_list|,
call|(
name|off_t
call|)
argument_list|(
name|base
operator|+
name|loc
argument_list|)
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
name|B_METAONLY
argument_list|,
operator|&
name|ibp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
goto|goto
name|out1
goto|;
block|}
name|indiroff
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ffs_isblock
argument_list|(
name|fs
argument_list|,
name|cg_blksfree
argument_list|(
name|cgp
argument_list|)
argument_list|,
name|loc
argument_list|)
condition|)
continue|continue;
operator|(
operator|(
name|ufs_daddr_t
operator|*
operator|)
operator|(
name|ibp
operator|->
name|b_data
operator|)
operator|)
index|[
name|indiroff
index|]
operator|=
name|BLK_NOCOPY
expr_stmt|;
block|}
name|bqrelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|ibp
operator|->
name|b_flags
operator||=
name|B_VALIDSUSPWRT
expr_stmt|;
name|bdwrite
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Snapshot the superblock and its summary information. 	 */
name|error
operator|=
name|VOP_BALLOC
argument_list|(
name|vp
argument_list|,
call|(
name|off_t
call|)
argument_list|(
name|SBOFF
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
literal|0
argument_list|,
operator|&
name|nbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out1
goto|;
name|bcopy
argument_list|(
name|fs
argument_list|,
name|nbp
operator|->
name|b_data
argument_list|,
name|fs
operator|->
name|fs_sbsize
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|fs
operator|*
operator|)
operator|(
name|nbp
operator|->
name|b_data
operator|)
operator|)
operator|->
name|fs_clean
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|fs_sbsize
operator|<
name|fs
operator|->
name|fs_bsize
condition|)
name|bzero
argument_list|(
operator|&
name|nbp
operator|->
name|b_data
index|[
name|fs
operator|->
name|fs_sbsize
index|]
argument_list|,
name|fs
operator|->
name|fs_bsize
operator|-
name|fs
operator|->
name|fs_sbsize
argument_list|)
expr_stmt|;
name|nbp
operator|->
name|b_flags
operator||=
name|B_VALIDSUSPWRT
expr_stmt|;
name|bawrite
argument_list|(
name|nbp
argument_list|)
expr_stmt|;
name|blkno
operator|=
name|fragstoblks
argument_list|(
name|fs
argument_list|,
name|fs
operator|->
name|fs_csaddr
argument_list|)
expr_stmt|;
name|len
operator|=
name|howmany
argument_list|(
name|fs
operator|->
name|fs_cssize
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|)
operator|-
literal|1
expr_stmt|;
name|size
operator|=
name|fs
operator|->
name|fs_bsize
expr_stmt|;
for|for
control|(
name|loc
operator|=
literal|0
init|;
name|loc
operator|<=
name|len
condition|;
name|loc
operator|++
control|)
block|{
name|error
operator|=
name|VOP_BALLOC
argument_list|(
name|vp
argument_list|,
name|lblktosize
argument_list|(
name|fs
argument_list|,
call|(
name|off_t
call|)
argument_list|(
name|blkno
operator|+
name|loc
argument_list|)
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
literal|0
argument_list|,
operator|&
name|nbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out1
goto|;
if|if
condition|(
name|loc
operator|==
name|len
condition|)
block|{
name|readblock
argument_list|(
name|nbp
argument_list|,
name|blkno
operator|+
name|loc
argument_list|)
expr_stmt|;
name|size
operator|=
name|fs
operator|->
name|fs_cssize
operator|%
name|fs
operator|->
name|fs_bsize
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|fs
operator|->
name|fs_csp
index|[
name|loc
index|]
argument_list|,
name|nbp
operator|->
name|b_data
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|nbp
operator|->
name|b_flags
operator||=
name|B_VALIDSUSPWRT
expr_stmt|;
name|bawrite
argument_list|(
name|nbp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Copy the shadow blocks for the snapshot inodes so that 	 * the copies can can be expunged. 	 */
for|for
control|(
name|loc
operator|=
literal|0
init|;
name|loc
operator|<
name|inoblkcnt
condition|;
name|loc
operator|++
control|)
block|{
name|error
operator|=
name|VOP_BALLOC
argument_list|(
name|vp
argument_list|,
name|lblktosize
argument_list|(
name|fs
argument_list|,
operator|(
name|off_t
operator|)
name|inoblks
index|[
name|loc
index|]
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
literal|0
argument_list|,
operator|&
name|nbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out1
goto|;
name|readblock
argument_list|(
name|nbp
argument_list|,
name|inoblks
index|[
name|loc
index|]
argument_list|)
expr_stmt|;
name|nbp
operator|->
name|b_flags
operator||=
name|B_VALIDSUSPWRT
expr_stmt|;
name|bdwrite
argument_list|(
name|nbp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Copy allocation information from other snapshots and then 	 * expunge them from the view of the current snapshot. 	 */
for|for
control|(
name|xp
operator|=
name|devip
operator|->
name|i_copyonwrite
init|;
name|xp
condition|;
name|xp
operator|=
name|xp
operator|->
name|i_copyonwrite
control|)
block|{
comment|/* 		 * Before expunging a snapshot inode, note all the 		 * blocks that it claims with BLK_SNAP so that fsck will 		 * be able to account for those blocks properly and so 		 * that this snapshot knows that it need not copy them 		 * if the other snapshot holding them is freed. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|snapacct
argument_list|(
name|vp
argument_list|,
operator|&
name|xp
operator|->
name|i_db
index|[
literal|0
index|]
argument_list|,
operator|&
name|xp
operator|->
name|i_ib
index|[
name|NIADDR
index|]
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out1
goto|;
name|blksperindir
operator|=
literal|1
expr_stmt|;
name|lbn
operator|=
operator|-
name|NDADDR
expr_stmt|;
name|len
operator|=
name|numblks
operator|-
name|NDADDR
expr_stmt|;
name|rlbn
operator|=
name|NDADDR
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|len
operator|>
literal|0
operator|&&
name|i
operator|<
name|NIADDR
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|indiracct
argument_list|(
name|vp
argument_list|,
name|ITOV
argument_list|(
name|xp
argument_list|)
argument_list|,
name|i
argument_list|,
name|xp
operator|->
name|i_ib
index|[
name|i
index|]
argument_list|,
name|lbn
argument_list|,
name|rlbn
argument_list|,
name|len
argument_list|,
name|blksperindir
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out1
goto|;
name|blksperindir
operator|*=
name|NINDIR
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|lbn
operator|-=
name|blksperindir
operator|+
literal|1
expr_stmt|;
name|len
operator|-=
name|blksperindir
expr_stmt|;
name|rlbn
operator|+=
name|blksperindir
expr_stmt|;
block|}
comment|/* 		 * Set copied snapshot inode to be a zero length file. 		 */
name|blkno
operator|=
name|fragstoblks
argument_list|(
name|fs
argument_list|,
name|ino_to_fsba
argument_list|(
name|fs
argument_list|,
name|xp
operator|->
name|i_number
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_BALLOC
argument_list|(
name|vp
argument_list|,
name|lblktosize
argument_list|(
name|fs
argument_list|,
operator|(
name|off_t
operator|)
name|blkno
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
literal|0
argument_list|,
operator|&
name|nbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out1
goto|;
name|dip
operator|=
operator|(
expr|struct
name|dinode
operator|*
operator|)
name|nbp
operator|->
name|b_data
operator|+
name|ino_to_fsbo
argument_list|(
name|fs
argument_list|,
name|xp
operator|->
name|i_number
argument_list|)
expr_stmt|;
name|dip
operator|->
name|di_size
operator|=
literal|0
expr_stmt|;
name|dip
operator|->
name|di_blocks
operator|=
literal|0
expr_stmt|;
name|dip
operator|->
name|di_flags
operator|&=
operator|~
operator|(
name|SF_IMMUTABLE
operator||
name|SF_SNAPSHOT
operator|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|dip
operator|->
name|di_db
index|[
literal|0
index|]
argument_list|,
operator|(
name|NDADDR
operator|+
name|NIADDR
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|ufs_daddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|nbp
operator|->
name|b_flags
operator||=
name|B_VALIDSUSPWRT
expr_stmt|;
name|bdwrite
argument_list|(
name|nbp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Copy all indirect blocks to their shadows (allocated above) 	 * to avoid deadlock in ffs_copyonwrite. 	 */
for|for
control|(
name|blkno
operator|=
name|NDADDR
init|;
name|blkno
operator|<
name|numblks
condition|;
name|blkno
operator|+=
name|NINDIR
argument_list|(
name|fs
argument_list|)
control|)
block|{
name|error
operator|=
name|VOP_BALLOC
argument_list|(
name|vp
argument_list|,
name|lblktosize
argument_list|(
name|fs
argument_list|,
operator|(
name|off_t
operator|)
name|blkno
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
name|B_METAONLY
argument_list|,
operator|&
name|ibp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out1
goto|;
name|copyblkno
operator|=
name|fragstoblks
argument_list|(
name|fs
argument_list|,
name|dbtofsb
argument_list|(
name|fs
argument_list|,
name|ibp
operator|->
name|b_blkno
argument_list|)
argument_list|)
expr_stmt|;
name|bqrelse
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_BALLOC
argument_list|(
name|vp
argument_list|,
name|lblktosize
argument_list|(
name|fs
argument_list|,
operator|(
name|off_t
operator|)
name|copyblkno
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
literal|0
argument_list|,
operator|&
name|nbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out1
goto|;
name|error
operator|=
name|VOP_BALLOC
argument_list|(
name|vp
argument_list|,
name|lblktosize
argument_list|(
name|fs
argument_list|,
operator|(
name|off_t
operator|)
name|blkno
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
name|B_METAONLY
argument_list|,
operator|&
name|ibp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|nbp
argument_list|)
expr_stmt|;
goto|goto
name|out1
goto|;
block|}
name|bcopy
argument_list|(
name|ibp
operator|->
name|b_data
argument_list|,
name|nbp
operator|->
name|b_data
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
name|bqrelse
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
name|nbp
operator|->
name|b_flags
operator||=
name|B_VALIDSUSPWRT
expr_stmt|;
name|bawrite
argument_list|(
name|nbp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Record snapshot inode. Since this is the newest snapshot, 	 * it must be placed at the end of the list. 	 */
name|fs
operator|->
name|fs_snapinum
index|[
name|snaploc
index|]
operator|=
name|ip
operator|->
name|i_number
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_copyonwrite
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"ffs_snapshot: %d already on list"
argument_list|,
name|ip
operator|->
name|i_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|devip
operator|->
name|i_copyonwrite
operator|==
literal|0
condition|)
block|{
name|devvp
operator|->
name|v_flag
operator||=
name|VCOPYONWRITE
expr_stmt|;
name|devip
operator|->
name|i_copyonwrite
operator|=
name|ip
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|xp
operator|=
name|devip
operator|->
name|i_copyonwrite
init|;
name|xp
operator|->
name|i_copyonwrite
operator|!=
literal|0
condition|;
control|)
name|xp
operator|=
name|xp
operator|->
name|i_copyonwrite
expr_stmt|;
name|xp
operator|->
name|i_copyonwrite
operator|=
name|ip
expr_stmt|;
block|}
name|vp
operator|->
name|v_flag
operator||=
name|VSYSTEM
expr_stmt|;
comment|/* 	 * Resume operation on filesystem. 	 */
name|out1
label|:
name|vfs_write_resume
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
name|vn_start_write
argument_list|(
name|NULL
argument_list|,
operator|&
name|wrtmp
argument_list|,
name|V_WAIT
argument_list|)
expr_stmt|;
name|out
label|:
name|mp
operator|->
name|mnt_flag
operator|=
name|flag
expr_stmt|;
operator|(
name|void
operator|)
name|VOP_FSYNC
argument_list|(
name|vp
argument_list|,
name|KERNCRED
argument_list|,
name|MNT_WAIT
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
else|else
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|vn_finished_write
argument_list|(
name|wrtmp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Descend an indirect block chain for vnode cancelvp accounting for all  * its indirect blocks in snapvp.  */
end_comment

begin_function
specifier|static
name|int
name|indiracct
parameter_list|(
name|snapvp
parameter_list|,
name|cancelvp
parameter_list|,
name|level
parameter_list|,
name|blkno
parameter_list|,
name|lbn
parameter_list|,
name|rlbn
parameter_list|,
name|remblks
parameter_list|,
name|blksperindir
parameter_list|)
name|struct
name|vnode
modifier|*
name|snapvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|cancelvp
decl_stmt|;
name|int
name|level
decl_stmt|;
name|ufs_daddr_t
name|blkno
decl_stmt|;
name|int
name|lbn
decl_stmt|;
name|int
name|rlbn
decl_stmt|;
name|int
name|remblks
decl_stmt|;
name|int
name|blksperindir
decl_stmt|;
block|{
name|int
name|subblksperindir
decl_stmt|,
name|error
decl_stmt|,
name|last
decl_stmt|,
name|num
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|indir
name|indirs
index|[
name|NIADDR
operator|+
literal|2
index|]
decl_stmt|;
name|ufs_daddr_t
modifier|*
name|bap
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ufs_getlbns
argument_list|(
name|cancelvp
argument_list|,
name|rlbn
argument_list|,
name|indirs
argument_list|,
operator|&
name|num
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|lbn
operator|!=
name|indirs
index|[
name|num
operator|-
literal|1
operator|-
name|level
index|]
operator|.
name|in_lbn
operator|||
name|blkno
operator|==
literal|0
operator|||
name|num
operator|<
literal|2
condition|)
name|panic
argument_list|(
literal|"indiracct: botched params"
argument_list|)
expr_stmt|;
comment|/* 	 * We have to expand bread here since it will deadlock looking 	 * up the block number for any blocks that are not in the cache. 	 */
name|fs
operator|=
name|VTOI
argument_list|(
name|cancelvp
argument_list|)
operator|->
name|i_fs
expr_stmt|;
name|bp
operator|=
name|getblk
argument_list|(
name|cancelvp
argument_list|,
name|lbn
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_blkno
operator|=
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|blkno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_DONE
operator||
name|B_DELWRI
operator|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|error
operator|=
name|readblock
argument_list|(
name|bp
argument_list|,
name|fragstoblks
argument_list|(
name|fs
argument_list|,
name|blkno
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Account for the block pointers in this indirect block. 	 */
name|last
operator|=
name|howmany
argument_list|(
name|remblks
argument_list|,
name|blksperindir
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
operator|>
name|NINDIR
argument_list|(
name|fs
argument_list|)
condition|)
name|last
operator|=
name|NINDIR
argument_list|(
name|fs
argument_list|)
expr_stmt|;
if|if
condition|(
name|snapvp
operator|!=
name|cancelvp
condition|)
block|{
name|bap
operator|=
operator|(
name|ufs_daddr_t
operator|*
operator|)
name|bp
operator|->
name|b_data
expr_stmt|;
block|}
else|else
block|{
name|MALLOC
argument_list|(
name|bap
argument_list|,
name|ufs_daddr_t
operator|*
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
operator|(
name|caddr_t
operator|)
name|bap
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
name|bqrelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|snapacct
argument_list|(
name|snapvp
argument_list|,
operator|&
name|bap
index|[
literal|0
index|]
argument_list|,
operator|&
name|bap
index|[
name|last
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|level
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Account for the block pointers in each of the indirect blocks 	 * in the levels below us. 	 */
name|subblksperindir
operator|=
name|blksperindir
operator|/
name|NINDIR
argument_list|(
name|fs
argument_list|)
expr_stmt|;
for|for
control|(
name|lbn
operator|++
operator|,
name|level
operator|--
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|last
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|indiracct
argument_list|(
name|snapvp
argument_list|,
name|cancelvp
argument_list|,
name|level
argument_list|,
name|bap
index|[
name|i
index|]
argument_list|,
name|lbn
argument_list|,
name|rlbn
argument_list|,
name|remblks
argument_list|,
name|subblksperindir
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|rlbn
operator|+=
name|blksperindir
expr_stmt|;
name|lbn
operator|-=
name|blksperindir
expr_stmt|;
name|remblks
operator|-=
name|blksperindir
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|snapvp
operator|!=
name|cancelvp
condition|)
name|bqrelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
else|else
name|FREE
argument_list|(
name|bap
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Account for a set of blocks allocated in a snapshot inode.  */
end_comment

begin_function
specifier|static
name|int
name|snapacct
parameter_list|(
name|vp
parameter_list|,
name|oldblkp
parameter_list|,
name|lastblkp
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|ufs_daddr_t
modifier|*
name|oldblkp
decl_stmt|,
decl|*
name|lastblkp
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|inode
modifier|*
name|ip
init|=
name|VTOI
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
init|=
name|ip
operator|->
name|i_fs
decl_stmt|;
name|ufs_daddr_t
name|lbn
decl_stmt|,
name|blkno
decl_stmt|,
modifier|*
name|blkp
decl_stmt|;
name|struct
name|buf
modifier|*
name|ibp
decl_stmt|;
name|int
name|error
decl_stmt|;
for|for
control|(
init|;
name|oldblkp
operator|<
name|lastblkp
condition|;
name|oldblkp
operator|++
control|)
block|{
name|blkno
operator|=
operator|*
name|oldblkp
expr_stmt|;
if|if
condition|(
name|blkno
operator|==
literal|0
operator|||
name|blkno
operator|==
name|BLK_NOCOPY
operator|||
name|blkno
operator|==
name|BLK_SNAP
condition|)
continue|continue;
name|lbn
operator|=
name|fragstoblks
argument_list|(
name|fs
argument_list|,
name|blkno
argument_list|)
expr_stmt|;
if|if
condition|(
name|lbn
operator|<
name|NDADDR
condition|)
block|{
name|blkp
operator|=
operator|&
name|ip
operator|->
name|i_db
index|[
name|lbn
index|]
expr_stmt|;
name|ip
operator|->
name|i_flag
operator||=
name|IN_CHANGE
operator||
name|IN_UPDATE
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|VOP_BALLOC
argument_list|(
name|vp
argument_list|,
name|lblktosize
argument_list|(
name|fs
argument_list|,
operator|(
name|off_t
operator|)
name|lbn
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
name|B_METAONLY
argument_list|,
operator|&
name|ibp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|blkp
operator|=
operator|&
operator|(
operator|(
name|ufs_daddr_t
operator|*
operator|)
operator|(
name|ibp
operator|->
name|b_data
operator|)
operator|)
index|[
operator|(
name|lbn
operator|-
name|NDADDR
operator|)
operator|%
name|NINDIR
argument_list|(
name|fs
argument_list|)
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|blkp
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"snapacct: bad block"
argument_list|)
expr_stmt|;
operator|*
name|blkp
operator|=
name|BLK_SNAP
expr_stmt|;
if|if
condition|(
name|lbn
operator|>=
name|NDADDR
condition|)
block|{
name|ibp
operator|->
name|b_flags
operator||=
name|B_VALIDSUSPWRT
expr_stmt|;
name|bdwrite
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Prepare a snapshot file for being removed.  */
end_comment

begin_function
name|void
name|ffs_snapremove
parameter_list|(
name|vp
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
block|{
name|struct
name|inode
modifier|*
name|ip
decl_stmt|,
modifier|*
name|xp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|devvp
decl_stmt|;
name|struct
name|buf
modifier|*
name|ibp
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|ufs_daddr_t
name|blkno
decl_stmt|,
name|dblk
decl_stmt|;
name|int
name|error
decl_stmt|,
name|snaploc
decl_stmt|,
name|loc
decl_stmt|,
name|last
decl_stmt|;
name|ip
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|fs
operator|=
name|ip
operator|->
name|i_fs
expr_stmt|;
comment|/* 	 * Delete snapshot inode from superblock. Keep list dense. 	 */
for|for
control|(
name|snaploc
operator|=
literal|0
init|;
name|snaploc
operator|<
name|FSMAXSNAP
condition|;
name|snaploc
operator|++
control|)
if|if
condition|(
name|fs
operator|->
name|fs_snapinum
index|[
name|snaploc
index|]
operator|==
name|ip
operator|->
name|i_number
condition|)
break|break;
if|if
condition|(
name|snaploc
operator|<
name|FSMAXSNAP
condition|)
block|{
for|for
control|(
name|snaploc
operator|++
init|;
name|snaploc
operator|<
name|FSMAXSNAP
condition|;
name|snaploc
operator|++
control|)
block|{
if|if
condition|(
name|fs
operator|->
name|fs_snapinum
index|[
name|snaploc
index|]
operator|==
literal|0
condition|)
break|break;
name|fs
operator|->
name|fs_snapinum
index|[
name|snaploc
operator|-
literal|1
index|]
operator|=
name|fs
operator|->
name|fs_snapinum
index|[
name|snaploc
index|]
expr_stmt|;
block|}
name|fs
operator|->
name|fs_snapinum
index|[
name|snaploc
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Delete from incore list. 	 * Clear copy-on-write flag if last snapshot. 	 */
name|devvp
operator|=
name|ip
operator|->
name|i_devvp
expr_stmt|;
for|for
control|(
name|xp
operator|=
name|VTOI
argument_list|(
name|devvp
argument_list|)
init|;
name|xp
condition|;
name|xp
operator|=
name|xp
operator|->
name|i_copyonwrite
control|)
block|{
if|if
condition|(
name|xp
operator|->
name|i_copyonwrite
operator|!=
name|ip
condition|)
continue|continue;
name|xp
operator|->
name|i_copyonwrite
operator|=
name|ip
operator|->
name|i_copyonwrite
expr_stmt|;
name|ip
operator|->
name|i_copyonwrite
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|xp
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ffs_snapremove: lost snapshot vnode %d\n"
argument_list|,
name|ip
operator|->
name|i_number
argument_list|)
expr_stmt|;
name|vref
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|VTOI
argument_list|(
name|devvp
argument_list|)
operator|->
name|i_copyonwrite
operator|==
literal|0
condition|)
name|devvp
operator|->
name|v_flag
operator|&=
operator|~
name|VCOPYONWRITE
expr_stmt|;
comment|/* 	 * Clear all BLK_NOCOPY fields. Pass any block claims to other 	 * snapshots that want them (see ffs_snapblkfree below). 	 */
for|for
control|(
name|blkno
operator|=
literal|1
init|;
name|blkno
operator|<
name|NDADDR
condition|;
name|blkno
operator|++
control|)
block|{
name|dblk
operator|=
name|ip
operator|->
name|i_db
index|[
name|blkno
index|]
expr_stmt|;
if|if
condition|(
name|dblk
operator|==
name|BLK_NOCOPY
operator|||
name|dblk
operator|==
name|BLK_SNAP
operator|||
operator|(
name|dblk
operator|==
name|blkstofrags
argument_list|(
name|fs
argument_list|,
name|blkno
argument_list|)
operator|&&
name|ffs_snapblkfree
argument_list|(
name|ip
argument_list|,
name|dblk
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|)
operator|)
condition|)
name|ip
operator|->
name|i_db
index|[
name|blkno
index|]
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|blkno
operator|=
name|NDADDR
init|;
name|blkno
operator|<
name|fs
operator|->
name|fs_size
condition|;
name|blkno
operator|+=
name|NINDIR
argument_list|(
name|fs
argument_list|)
control|)
block|{
name|error
operator|=
name|VOP_BALLOC
argument_list|(
name|vp
argument_list|,
name|lblktosize
argument_list|(
name|fs
argument_list|,
operator|(
name|off_t
operator|)
name|blkno
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
name|B_METAONLY
argument_list|,
operator|&
name|ibp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
continue|continue;
if|if
condition|(
operator|(
name|last
operator|=
name|fs
operator|->
name|fs_size
operator|-
name|blkno
operator|)
operator|>
name|NINDIR
argument_list|(
name|fs
argument_list|)
condition|)
name|last
operator|=
name|NINDIR
argument_list|(
name|fs
argument_list|)
expr_stmt|;
for|for
control|(
name|loc
operator|=
literal|0
init|;
name|loc
operator|<
name|last
condition|;
name|loc
operator|++
control|)
block|{
name|dblk
operator|=
operator|(
operator|(
name|ufs_daddr_t
operator|*
operator|)
operator|(
name|ibp
operator|->
name|b_data
operator|)
operator|)
index|[
name|loc
index|]
expr_stmt|;
if|if
condition|(
name|dblk
operator|==
name|BLK_NOCOPY
operator|||
name|dblk
operator|==
name|BLK_SNAP
operator|||
operator|(
name|dblk
operator|==
name|blkstofrags
argument_list|(
name|fs
argument_list|,
name|blkno
argument_list|)
operator|&&
name|ffs_snapblkfree
argument_list|(
name|ip
argument_list|,
name|dblk
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|)
operator|)
condition|)
operator|(
operator|(
name|ufs_daddr_t
operator|*
operator|)
operator|(
name|ibp
operator|->
name|b_data
operator|)
operator|)
index|[
name|loc
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|bawrite
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Clear snapshot flag and drop reference. 	 */
name|ip
operator|->
name|i_flags
operator|&=
operator|~
operator|(
name|SF_IMMUTABLE
operator||
name|SF_SNAPSHOT
operator|)
expr_stmt|;
name|ip
operator|->
name|i_flag
operator||=
name|IN_CHANGE
operator||
name|IN_UPDATE
expr_stmt|;
name|vrele
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Notification that a block is being freed. Return zero if the free  * should be allowed to proceed. Return non-zero if the snapshot file  * wants to claim the block. The block will be claimed if it is an  * uncopied part of one of the snapshots. It will be freed if it is  * either a BLK_NOCOPY or has already been copied in all of the snapshots.  * If a fragment is being freed, then all snapshots that care about  * it must make a copy since a snapshot file can only claim full sized  * blocks. Note that if more than one snapshot file maps the block,  * we can pick one at random to claim it. Since none of the snapshots  * can change, we are assurred that they will all see the same unmodified  * image. When deleting a snapshot file (see ffs_snapremove above), we  * must push any of these claimed blocks to one of the other snapshots  * that maps it. These claimed blocks are easily identified as they will  * have a block number equal to their logical block number within the  * snapshot. A copied block can never have this property because they  * must always have been allocated from a BLK_NOCOPY location.  */
end_comment

begin_function
name|int
name|ffs_snapblkfree
parameter_list|(
name|freeip
parameter_list|,
name|bno
parameter_list|,
name|size
parameter_list|)
name|struct
name|inode
modifier|*
name|freeip
decl_stmt|;
name|ufs_daddr_t
name|bno
decl_stmt|;
name|long
name|size
decl_stmt|;
block|{
name|struct
name|buf
modifier|*
name|ibp
decl_stmt|,
modifier|*
name|cbp
decl_stmt|,
modifier|*
name|savedcbp
init|=
literal|0
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
init|=
name|freeip
operator|->
name|i_fs
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|CURPROC
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|ufs_daddr_t
name|lbn
decl_stmt|,
name|blkno
decl_stmt|;
name|int
name|indiroff
init|=
literal|0
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|,
name|claimedblk
init|=
literal|0
decl_stmt|;
name|lbn
operator|=
name|fragstoblks
argument_list|(
name|fs
argument_list|,
name|bno
argument_list|)
expr_stmt|;
for|for
control|(
name|ip
operator|=
name|VTOI
argument_list|(
name|freeip
operator|->
name|i_devvp
argument_list|)
operator|->
name|i_copyonwrite
init|;
name|ip
condition|;
name|ip
operator|=
name|ip
operator|->
name|i_copyonwrite
control|)
block|{
name|vp
operator|=
name|ITOV
argument_list|(
name|ip
argument_list|)
expr_stmt|;
comment|/* 		 * Lookup block being written. 		 */
if|if
condition|(
name|lbn
operator|<
name|NDADDR
condition|)
block|{
name|blkno
operator|=
name|ip
operator|->
name|i_db
index|[
name|lbn
index|]
expr_stmt|;
block|}
else|else
block|{
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_flag
operator||=
name|P_COWINPROGRESS
expr_stmt|;
name|error
operator|=
name|VOP_BALLOC
argument_list|(
name|vp
argument_list|,
name|lblktosize
argument_list|(
name|fs
argument_list|,
operator|(
name|off_t
operator|)
name|lbn
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
name|B_METAONLY
argument_list|,
operator|&
name|ibp
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_flag
operator|&=
operator|~
name|P_COWINPROGRESS
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|indiroff
operator|=
operator|(
name|lbn
operator|-
name|NDADDR
operator|)
operator|%
name|NINDIR
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|blkno
operator|=
operator|(
operator|(
name|ufs_daddr_t
operator|*
operator|)
operator|(
name|ibp
operator|->
name|b_data
operator|)
operator|)
index|[
name|indiroff
index|]
expr_stmt|;
block|}
comment|/* 		 * Check to see if block needs to be copied. 		 */
switch|switch
condition|(
name|blkno
condition|)
block|{
comment|/* 		 * If the snapshot has already copied the block (default), 		 * or does not care about the block, it is not needed. 		 */
default|default:
case|case
name|BLK_NOCOPY
case|:
if|if
condition|(
name|lbn
operator|>=
name|NDADDR
condition|)
name|bqrelse
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
continue|continue;
comment|/* 		 * No previous snapshot claimed the block, so it will be 		 * freed and become a BLK_NOCOPY (don't care) for us. 		 */
case|case
name|BLK_SNAP
case|:
if|if
condition|(
name|claimedblk
condition|)
name|panic
argument_list|(
literal|"snapblkfree: inconsistent block type"
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|lbn
operator|<
name|NDADDR
condition|)
block|{
name|ip
operator|->
name|i_db
index|[
name|lbn
index|]
operator|=
name|BLK_NOCOPY
expr_stmt|;
name|ip
operator|->
name|i_flag
operator||=
name|IN_CHANGE
operator||
name|IN_UPDATE
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|(
name|ufs_daddr_t
operator|*
operator|)
operator|(
name|ibp
operator|->
name|b_data
operator|)
operator|)
index|[
name|indiroff
index|]
operator|=
name|BLK_NOCOPY
expr_stmt|;
name|bdwrite
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
block|}
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
continue|continue;
comment|/* 		 * A block that we map is being freed. If it has not been 		 * claimed yet, we will claim or copy it (below). 		 */
case|case
literal|0
case|:
name|claimedblk
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* 		 * If this is a full size block, we will just grab it 		 * and assign it to the snapshot inode. Otherwise we 		 * will proceed to copy it. See explanation for this 		 * routine as to why only a single snapshot needs to 		 * claim this block. 		 */
if|if
condition|(
name|size
operator|==
name|fs
operator|->
name|fs_bsize
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|snapdebug
condition|)
name|printf
argument_list|(
literal|"%s %d lbn %d from inum %d\n"
argument_list|,
literal|"Grabonremove: snapino"
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
name|lbn
argument_list|,
name|freeip
operator|->
name|i_number
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|lbn
operator|<
name|NDADDR
condition|)
block|{
name|ip
operator|->
name|i_db
index|[
name|lbn
index|]
operator|=
name|bno
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|(
name|ufs_daddr_t
operator|*
operator|)
operator|(
name|ibp
operator|->
name|b_data
operator|)
operator|)
index|[
name|indiroff
index|]
operator|=
name|bno
expr_stmt|;
name|bdwrite
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
block|}
name|ip
operator|->
name|i_blocks
operator|+=
name|btodb
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_flag
operator||=
name|IN_CHANGE
operator||
name|IN_UPDATE
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|lbn
operator|>=
name|NDADDR
condition|)
name|bqrelse
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
comment|/* 		 * Allocate the block into which to do the copy. Note that this 		 * allocation will never require any additional allocations for 		 * the snapshot inode. 		 */
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_flag
operator||=
name|P_COWINPROGRESS
expr_stmt|;
name|error
operator|=
name|VOP_BALLOC
argument_list|(
name|vp
argument_list|,
name|lblktosize
argument_list|(
name|fs
argument_list|,
operator|(
name|off_t
operator|)
name|lbn
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
literal|0
argument_list|,
operator|&
name|cbp
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_flag
operator|&=
operator|~
name|P_COWINPROGRESS
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|snapdebug
condition|)
name|printf
argument_list|(
literal|"%s%d lbn %d for inum %d size %ld to blkno %d\n"
argument_list|,
literal|"Copyonremove: snapino "
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
name|lbn
argument_list|,
name|freeip
operator|->
name|i_number
argument_list|,
name|size
argument_list|,
name|cbp
operator|->
name|b_blkno
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * If we have already read the old block contents, then 		 * simply copy them to the new block. 		 */
if|if
condition|(
name|savedcbp
operator|!=
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|savedcbp
operator|->
name|b_data
argument_list|,
name|cbp
operator|->
name|b_data
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
name|bawrite
argument_list|(
name|cbp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Otherwise, read the old block contents into the buffer. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|readblock
argument_list|(
name|cbp
argument_list|,
name|lbn
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|savedcbp
operator|=
name|cbp
expr_stmt|;
block|}
if|if
condition|(
name|savedcbp
condition|)
name|bawrite
argument_list|(
name|savedcbp
argument_list|)
expr_stmt|;
comment|/* 	 * If we have been unable to allocate a block in which to do 	 * the copy, then return non-zero so that the fragment will 	 * not be freed. Although space will be lost, the snapshot 	 * will stay consistent. 	 */
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Associate snapshot files when mounting.  */
end_comment

begin_function
name|void
name|ffs_snapshot_mount
parameter_list|(
name|mp
parameter_list|)
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
block|{
name|struct
name|ufsmount
modifier|*
name|ump
init|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
init|=
name|ump
operator|->
name|um_fs
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|CURPROC
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|,
modifier|*
modifier|*
name|listtailp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|snaploc
decl_stmt|,
name|loc
decl_stmt|;
name|listtailp
operator|=
operator|&
name|VTOI
argument_list|(
name|ump
operator|->
name|um_devvp
argument_list|)
operator|->
name|i_copyonwrite
expr_stmt|;
for|for
control|(
name|snaploc
operator|=
literal|0
init|;
name|snaploc
operator|<
name|FSMAXSNAP
condition|;
name|snaploc
operator|++
control|)
block|{
if|if
condition|(
name|fs
operator|->
name|fs_snapinum
index|[
name|snaploc
index|]
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|error
operator|=
name|VFS_VGET
argument_list|(
name|mp
argument_list|,
name|fs
operator|->
name|fs_snapinum
index|[
name|snaploc
index|]
argument_list|,
operator|&
name|vp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ffs_snapshot_mount: vget failed %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ip
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ip
operator|->
name|i_flags
operator|&
name|SF_SNAPSHOT
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ffs_snapshot_mount: non-snapshot inode %d\n"
argument_list|,
name|fs
operator|->
name|fs_snapinum
index|[
name|snaploc
index|]
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
for|for
control|(
name|loc
operator|=
name|snaploc
operator|+
literal|1
init|;
name|loc
operator|<
name|FSMAXSNAP
condition|;
name|loc
operator|++
control|)
block|{
if|if
condition|(
name|fs
operator|->
name|fs_snapinum
index|[
name|loc
index|]
operator|==
literal|0
condition|)
break|break;
name|fs
operator|->
name|fs_snapinum
index|[
name|loc
operator|-
literal|1
index|]
operator|=
name|fs
operator|->
name|fs_snapinum
index|[
name|loc
index|]
expr_stmt|;
block|}
name|fs
operator|->
name|fs_snapinum
index|[
name|loc
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|snaploc
operator|--
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ip
operator|->
name|i_copyonwrite
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"ffs_snapshot_mount: %d already on list"
argument_list|,
name|ip
operator|->
name|i_number
argument_list|)
expr_stmt|;
operator|*
name|listtailp
operator|=
name|ip
expr_stmt|;
name|listtailp
operator|=
operator|&
name|ip
operator|->
name|i_copyonwrite
expr_stmt|;
name|vp
operator|->
name|v_flag
operator||=
name|VSYSTEM
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|ump
operator|->
name|um_devvp
operator|->
name|v_flag
operator||=
name|VCOPYONWRITE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Disassociate snapshot files when unmounting.  */
end_comment

begin_function
name|void
name|ffs_snapshot_unmount
parameter_list|(
name|mp
parameter_list|)
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
block|{
name|struct
name|ufsmount
modifier|*
name|ump
init|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
decl_stmt|;
name|struct
name|inode
modifier|*
name|devip
init|=
name|VTOI
argument_list|(
name|ump
operator|->
name|um_devvp
argument_list|)
decl_stmt|;
name|struct
name|inode
modifier|*
name|xp
decl_stmt|;
while|while
condition|(
operator|(
name|xp
operator|=
name|devip
operator|->
name|i_copyonwrite
operator|)
operator|!=
literal|0
condition|)
block|{
name|devip
operator|->
name|i_copyonwrite
operator|=
name|xp
operator|->
name|i_copyonwrite
expr_stmt|;
name|xp
operator|->
name|i_copyonwrite
operator|=
literal|0
expr_stmt|;
name|vrele
argument_list|(
name|ITOV
argument_list|(
name|xp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ump
operator|->
name|um_devvp
operator|->
name|v_flag
operator|&=
operator|~
name|VCOPYONWRITE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check for need to copy block that is about to be written,  * copying the block if necessary.  */
end_comment

begin_function
name|int
name|ffs_copyonwrite
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_copyonwrite_args
comment|/* { 		struct vnode *a_vp; 		struct buf *a_bp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|buf
modifier|*
name|ibp
decl_stmt|,
modifier|*
name|cbp
decl_stmt|,
modifier|*
name|savedcbp
init|=
literal|0
decl_stmt|,
modifier|*
name|bp
init|=
name|ap
operator|->
name|a_bp
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
init|=
name|VTOI
argument_list|(
name|bp
operator|->
name|b_vp
argument_list|)
operator|->
name|i_fs
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|CURPROC
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|ufs_daddr_t
name|lbn
decl_stmt|,
name|blkno
decl_stmt|;
name|int
name|indiroff
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|lbn
operator|=
name|fragstoblks
argument_list|(
name|fs
argument_list|,
name|dbtofsb
argument_list|(
name|fs
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|P_COWINPROGRESS
condition|)
name|panic
argument_list|(
literal|"ffs_copyonwrite: recursive call"
argument_list|)
expr_stmt|;
for|for
control|(
name|ip
operator|=
name|VTOI
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
operator|->
name|i_copyonwrite
init|;
name|ip
condition|;
name|ip
operator|=
name|ip
operator|->
name|i_copyonwrite
control|)
block|{
name|vp
operator|=
name|ITOV
argument_list|(
name|ip
argument_list|)
expr_stmt|;
comment|/* 		 * We ensure that everything of our own that needs to be 		 * copied will be done at the time that ffs_snapshot is 		 * called. Thus we can skip the check here which can 		 * deadlock in doing the lookup in VOP_BALLOC. 		 */
if|if
condition|(
name|bp
operator|->
name|b_vp
operator|==
name|vp
condition|)
continue|continue;
comment|/* 		 * Check to see if block needs to be copied. We have to 		 * be able to do the VOP_BALLOC without blocking, otherwise 		 * we may get in a deadlock with another process also 		 * trying to allocate. If we find outselves unable to 		 * get the buffer lock, we unlock the snapshot vnode, 		 * sleep briefly, and try again. 		 */
name|retry
label|:
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_SHARED
operator||
name|LK_RETRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|lbn
operator|<
name|NDADDR
condition|)
block|{
name|blkno
operator|=
name|ip
operator|->
name|i_db
index|[
name|lbn
index|]
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|p_flag
operator||=
name|P_COWINPROGRESS
expr_stmt|;
name|error
operator|=
name|VOP_BALLOC
argument_list|(
name|vp
argument_list|,
name|lblktosize
argument_list|(
name|fs
argument_list|,
operator|(
name|off_t
operator|)
name|lbn
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
name|B_METAONLY
operator||
name|B_NOWAIT
argument_list|,
operator|&
name|ibp
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_flag
operator|&=
operator|~
name|P_COWINPROGRESS
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|EWOULDBLOCK
condition|)
break|break;
name|tsleep
argument_list|(
name|vp
argument_list|,
name|p
operator|->
name|p_usrpri
argument_list|,
literal|"nap"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|indiroff
operator|=
operator|(
name|lbn
operator|-
name|NDADDR
operator|)
operator|%
name|NINDIR
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|blkno
operator|=
operator|(
operator|(
name|ufs_daddr_t
operator|*
operator|)
operator|(
name|ibp
operator|->
name|b_data
operator|)
operator|)
index|[
name|indiroff
index|]
expr_stmt|;
name|bqrelse
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|blkno
operator|==
name|BLK_SNAP
operator|&&
name|bp
operator|->
name|b_lblkno
operator|>=
literal|0
condition|)
name|panic
argument_list|(
literal|"ffs_copyonwrite: bad copy block"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|blkno
operator|!=
literal|0
condition|)
block|{
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Allocate the block into which to do the copy. Note that this 		 * allocation will never require any additional allocations for 		 * the snapshot inode. 		 */
name|p
operator|->
name|p_flag
operator||=
name|P_COWINPROGRESS
expr_stmt|;
name|error
operator|=
name|VOP_BALLOC
argument_list|(
name|vp
argument_list|,
name|lblktosize
argument_list|(
name|fs
argument_list|,
operator|(
name|off_t
operator|)
name|lbn
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
name|B_NOWAIT
argument_list|,
operator|&
name|cbp
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_flag
operator|&=
operator|~
name|P_COWINPROGRESS
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|!=
name|EWOULDBLOCK
condition|)
break|break;
name|tsleep
argument_list|(
name|vp
argument_list|,
name|p
operator|->
name|p_usrpri
argument_list|,
literal|"nap"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|snapdebug
condition|)
block|{
name|printf
argument_list|(
literal|"Copyonwrite: snapino %d lbn %d for "
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
name|lbn
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_vp
operator|==
name|ap
operator|->
name|a_vp
condition|)
name|printf
argument_list|(
literal|"fs metadata"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"inum %d"
argument_list|,
name|VTOI
argument_list|(
name|bp
operator|->
name|b_vp
argument_list|)
operator|->
name|i_number
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" lblkno %d to blkno %d\n"
argument_list|,
name|bp
operator|->
name|b_lblkno
argument_list|,
name|cbp
operator|->
name|b_blkno
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 		 * If we have already read the old block contents, then 		 * simply copy them to the new block. 		 */
if|if
condition|(
name|savedcbp
operator|!=
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|savedcbp
operator|->
name|b_data
argument_list|,
name|cbp
operator|->
name|b_data
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
name|bawrite
argument_list|(
name|cbp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Otherwise, read the old block contents into the buffer. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|readblock
argument_list|(
name|cbp
argument_list|,
name|lbn
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|savedcbp
operator|=
name|cbp
expr_stmt|;
block|}
if|if
condition|(
name|savedcbp
condition|)
name|bawrite
argument_list|(
name|savedcbp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read the specified block into the given buffer.  * Much of this boiler-plate comes from bwrite().  */
end_comment

begin_function
specifier|static
name|int
name|readblock
parameter_list|(
name|bp
parameter_list|,
name|lbn
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|daddr_t
name|lbn
decl_stmt|;
block|{
name|struct
name|uio
name|auio
decl_stmt|;
name|struct
name|iovec
name|aiov
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|CURPROC
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
init|=
name|VTOI
argument_list|(
name|bp
operator|->
name|b_vp
argument_list|)
decl_stmt|;
name|aiov
operator|.
name|iov_base
operator|=
name|bp
operator|->
name|b_data
expr_stmt|;
name|aiov
operator|.
name|iov_len
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|auio
operator|.
name|uio_iov
operator|=
operator|&
name|aiov
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_offset
operator|=
name|dbtob
argument_list|(
name|fsbtodb
argument_list|(
name|ip
operator|->
name|i_fs
argument_list|,
name|blkstofrags
argument_list|(
name|ip
operator|->
name|i_fs
argument_list|,
name|lbn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|auio
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|auio
operator|.
name|uio_procp
operator|=
name|p
expr_stmt|;
return|return
operator|(
name|physio
argument_list|(
name|ip
operator|->
name|i_devvp
operator|->
name|v_rdev
argument_list|,
operator|&
name|auio
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

