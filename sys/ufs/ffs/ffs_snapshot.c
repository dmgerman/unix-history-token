begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright 2000 Marshall Kirk McKusick. All Rights Reserved.  *  * Further information about snapshots can be obtained from:  *  *	Marshall Kirk McKusick		http://www.mckusick.com/softdep/  *	1614 Oxford Street		mckusick@mckusick.com  *	Berkeley, CA 94709-1608		+1-510-843-9542  *	USA  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY MARSHALL KIRK MCKUSICK ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL MARSHALL KIRK MCKUSICK BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)ffs_snapshot.c	8.11 (McKusick) 7/23/00  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_quota.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/extattr.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/quota.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/ufsmount.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/inode.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/ufs_extern.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ffs/fs.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ffs/ffs_extern.h>
end_include

begin_define
define|#
directive|define
name|KERNCRED
value|thread0.td_ucred
end_define

begin_define
define|#
directive|define
name|DEBUG
value|1
end_define

begin_include
include|#
directive|include
file|"opt_ffs.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NO_FFS_SNAPSHOT
end_ifdef

begin_function
name|int
name|ffs_snapshot
parameter_list|(
name|mp
parameter_list|,
name|snapfile
parameter_list|)
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|char
modifier|*
name|snapfile
decl_stmt|;
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ffs_snapblkfree
parameter_list|(
name|fs
parameter_list|,
name|devvp
parameter_list|,
name|bno
parameter_list|,
name|size
parameter_list|,
name|inum
parameter_list|)
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|struct
name|vnode
modifier|*
name|devvp
decl_stmt|;
name|ufs2_daddr_t
name|bno
decl_stmt|;
name|long
name|size
decl_stmt|;
name|ino_t
name|inum
decl_stmt|;
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ffs_snapremove
parameter_list|(
name|vp
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
block|{ }
end_function

begin_function
name|void
name|ffs_snapshot_mount
parameter_list|(
name|mp
parameter_list|)
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
block|{ }
end_function

begin_function
name|void
name|ffs_snapshot_unmount
parameter_list|(
name|mp
parameter_list|)
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
block|{ }
end_function

begin_function
name|void
name|ffs_snapgone
parameter_list|(
name|ip
parameter_list|)
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
block|{ }
end_function

begin_function
name|int
name|ffs_copyonwrite
parameter_list|(
name|devvp
parameter_list|,
name|bp
parameter_list|)
name|struct
name|vnode
modifier|*
name|devvp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|TAILQ_HEAD
argument_list|(
name|snaphead
argument_list|,
name|inode
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|snapdata
block|{
name|struct
name|snaphead
name|sn_head
decl_stmt|;
name|daddr_t
name|sn_listsize
decl_stmt|;
name|daddr_t
modifier|*
name|sn_blklist
decl_stmt|;
name|struct
name|lock
name|sn_lock
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|cgaccount
parameter_list|(
name|int
parameter_list|,
name|struct
name|vnode
modifier|*
parameter_list|,
name|struct
name|buf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|expunge_ufs1
parameter_list|(
name|struct
name|vnode
modifier|*
parameter_list|,
name|struct
name|inode
modifier|*
parameter_list|,
name|struct
name|fs
modifier|*
parameter_list|,
name|int
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|struct
name|vnode
modifier|*
parameter_list|,
name|ufs1_daddr_t
modifier|*
parameter_list|,
name|ufs1_daddr_t
modifier|*
parameter_list|,
name|struct
name|fs
modifier|*
parameter_list|,
name|ufs_lbn_t
parameter_list|,
name|int
parameter_list|)
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|indiracct_ufs1
parameter_list|(
name|struct
name|vnode
modifier|*
parameter_list|,
name|struct
name|vnode
modifier|*
parameter_list|,
name|int
parameter_list|,
name|ufs1_daddr_t
parameter_list|,
name|ufs_lbn_t
parameter_list|,
name|ufs_lbn_t
parameter_list|,
name|ufs_lbn_t
parameter_list|,
name|ufs_lbn_t
parameter_list|,
name|struct
name|fs
modifier|*
parameter_list|,
name|int
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|struct
name|vnode
modifier|*
parameter_list|,
name|ufs1_daddr_t
modifier|*
parameter_list|,
name|ufs1_daddr_t
modifier|*
parameter_list|,
name|struct
name|fs
modifier|*
parameter_list|,
name|ufs_lbn_t
parameter_list|,
name|int
parameter_list|)
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fullacct_ufs1
parameter_list|(
name|struct
name|vnode
modifier|*
parameter_list|,
name|ufs1_daddr_t
modifier|*
parameter_list|,
name|ufs1_daddr_t
modifier|*
parameter_list|,
name|struct
name|fs
modifier|*
parameter_list|,
name|ufs_lbn_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|snapacct_ufs1
parameter_list|(
name|struct
name|vnode
modifier|*
parameter_list|,
name|ufs1_daddr_t
modifier|*
parameter_list|,
name|ufs1_daddr_t
modifier|*
parameter_list|,
name|struct
name|fs
modifier|*
parameter_list|,
name|ufs_lbn_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mapacct_ufs1
parameter_list|(
name|struct
name|vnode
modifier|*
parameter_list|,
name|ufs1_daddr_t
modifier|*
parameter_list|,
name|ufs1_daddr_t
modifier|*
parameter_list|,
name|struct
name|fs
modifier|*
parameter_list|,
name|ufs_lbn_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|expunge_ufs2
parameter_list|(
name|struct
name|vnode
modifier|*
parameter_list|,
name|struct
name|inode
modifier|*
parameter_list|,
name|struct
name|fs
modifier|*
parameter_list|,
name|int
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|struct
name|vnode
modifier|*
parameter_list|,
name|ufs2_daddr_t
modifier|*
parameter_list|,
name|ufs2_daddr_t
modifier|*
parameter_list|,
name|struct
name|fs
modifier|*
parameter_list|,
name|ufs_lbn_t
parameter_list|,
name|int
parameter_list|)
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|indiracct_ufs2
parameter_list|(
name|struct
name|vnode
modifier|*
parameter_list|,
name|struct
name|vnode
modifier|*
parameter_list|,
name|int
parameter_list|,
name|ufs2_daddr_t
parameter_list|,
name|ufs_lbn_t
parameter_list|,
name|ufs_lbn_t
parameter_list|,
name|ufs_lbn_t
parameter_list|,
name|ufs_lbn_t
parameter_list|,
name|struct
name|fs
modifier|*
parameter_list|,
name|int
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|struct
name|vnode
modifier|*
parameter_list|,
name|ufs2_daddr_t
modifier|*
parameter_list|,
name|ufs2_daddr_t
modifier|*
parameter_list|,
name|struct
name|fs
modifier|*
parameter_list|,
name|ufs_lbn_t
parameter_list|,
name|int
parameter_list|)
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fullacct_ufs2
parameter_list|(
name|struct
name|vnode
modifier|*
parameter_list|,
name|ufs2_daddr_t
modifier|*
parameter_list|,
name|ufs2_daddr_t
modifier|*
parameter_list|,
name|struct
name|fs
modifier|*
parameter_list|,
name|ufs_lbn_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|snapacct_ufs2
parameter_list|(
name|struct
name|vnode
modifier|*
parameter_list|,
name|ufs2_daddr_t
modifier|*
parameter_list|,
name|ufs2_daddr_t
modifier|*
parameter_list|,
name|struct
name|fs
modifier|*
parameter_list|,
name|ufs_lbn_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mapacct_ufs2
parameter_list|(
name|struct
name|vnode
modifier|*
parameter_list|,
name|ufs2_daddr_t
modifier|*
parameter_list|,
name|ufs2_daddr_t
modifier|*
parameter_list|,
name|struct
name|fs
modifier|*
parameter_list|,
name|ufs_lbn_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|readblock
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|buf
modifier|*
parameter_list|,
name|ufs2_daddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|process_deferred_inactive
parameter_list|(
name|struct
name|mount
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|try_free_snapdata
parameter_list|(
name|struct
name|vnode
modifier|*
name|devvp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * To ensure the consistency of snapshots across crashes, we must  * synchronously write out copied blocks before allowing the  * originals to be modified. Because of the rather severe speed  * penalty that this imposes, the following flag allows this  * crash persistence to be disabled.  */
end_comment

begin_decl_stmt
name|int
name|dopersistence
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|dopersistence
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|dopersistence
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|snapdebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|snapdebug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|snapdebug
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|collectsnapstats
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|collectsnapstats
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|collectsnapstats
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_comment
comment|/*  * Create a snapshot file and initialize it for the filesystem.  */
end_comment

begin_function
name|int
name|ffs_snapshot
parameter_list|(
name|mp
parameter_list|,
name|snapfile
parameter_list|)
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|char
modifier|*
name|snapfile
decl_stmt|;
block|{
name|ufs2_daddr_t
name|numblks
decl_stmt|,
name|blkno
decl_stmt|,
modifier|*
name|blkp
decl_stmt|,
modifier|*
name|snapblklist
decl_stmt|;
name|int
name|error
decl_stmt|,
name|cg
decl_stmt|,
name|snaploc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|size
decl_stmt|,
name|len
decl_stmt|,
name|loc
decl_stmt|;
name|int
name|flag
init|=
name|mp
operator|->
name|mnt_flag
decl_stmt|;
name|struct
name|timespec
name|starttime
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|,
name|endtime
decl_stmt|;
name|char
name|saved_nice
init|=
literal|0
decl_stmt|;
name|long
name|redo
init|=
literal|0
decl_stmt|,
name|snaplistsize
init|=
literal|0
decl_stmt|;
name|int32_t
modifier|*
name|lp
decl_stmt|;
name|void
modifier|*
name|space
decl_stmt|;
name|struct
name|fs
modifier|*
name|copy_fs
init|=
name|NULL
decl_stmt|,
modifier|*
name|fs
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|,
modifier|*
name|xp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|nbp
decl_stmt|,
modifier|*
name|ibp
decl_stmt|,
modifier|*
name|sbp
init|=
name|NULL
decl_stmt|;
name|struct
name|nameidata
name|nd
decl_stmt|;
name|struct
name|mount
modifier|*
name|wrtmp
decl_stmt|;
name|struct
name|vattr
name|vat
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|,
modifier|*
name|xvp
decl_stmt|,
modifier|*
name|mvp
decl_stmt|,
modifier|*
name|devvp
decl_stmt|;
name|struct
name|uio
name|auio
decl_stmt|;
name|struct
name|iovec
name|aiov
decl_stmt|;
name|struct
name|snapdata
modifier|*
name|sn
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|fs
operator|=
name|ump
operator|->
name|um_fs
expr_stmt|;
name|sn
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Need to serialize access to snapshot code per filesystem. 	 */
comment|/* 	 * Assign a snapshot slot in the superblock. 	 */
name|UFS_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
for|for
control|(
name|snaploc
operator|=
literal|0
init|;
name|snaploc
operator|<
name|FSMAXSNAP
condition|;
name|snaploc
operator|++
control|)
if|if
condition|(
name|fs
operator|->
name|fs_snapinum
index|[
name|snaploc
index|]
operator|==
literal|0
condition|)
break|break;
name|UFS_UNLOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
name|snaploc
operator|==
name|FSMAXSNAP
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
comment|/* 	 * Create the snapshot file. 	 */
name|restart
label|:
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|CREATE
argument_list|,
name|LOCKPARENT
operator||
name|LOCKLEAF
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|snapfile
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|.
name|ni_vp
operator|!=
name|NULL
condition|)
block|{
name|vput
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|)
expr_stmt|;
name|error
operator|=
name|EEXIST
expr_stmt|;
block|}
if|if
condition|(
name|nd
operator|.
name|ni_dvp
operator|->
name|v_mount
operator|!=
name|mp
condition|)
name|error
operator|=
name|EXDEV
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|.
name|ni_dvp
operator|==
name|nd
operator|.
name|ni_vp
condition|)
name|vrele
argument_list|(
name|nd
operator|.
name|ni_dvp
argument_list|)
expr_stmt|;
else|else
name|vput
argument_list|(
name|nd
operator|.
name|ni_dvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|VATTR_NULL
argument_list|(
operator|&
name|vat
argument_list|)
expr_stmt|;
name|vat
operator|.
name|va_type
operator|=
name|VREG
expr_stmt|;
name|vat
operator|.
name|va_mode
operator|=
name|S_IRUSR
expr_stmt|;
name|vat
operator|.
name|va_vaflags
operator||=
name|VA_EXCLUSIVE
expr_stmt|;
if|if
condition|(
name|VOP_GETWRITEMOUNT
argument_list|(
name|nd
operator|.
name|ni_dvp
argument_list|,
operator|&
name|wrtmp
argument_list|)
condition|)
name|wrtmp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|wrtmp
operator|!=
name|mp
condition|)
name|panic
argument_list|(
literal|"ffs_snapshot: mount mismatch"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vn_start_write
argument_list|(
name|NULL
argument_list|,
operator|&
name|wrtmp
argument_list|,
name|V_NOWAIT
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|nd
operator|.
name|ni_dvp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|vn_start_write
argument_list|(
name|NULL
argument_list|,
operator|&
name|wrtmp
argument_list|,
name|V_XSLEEP
operator||
name|PCATCH
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
goto|goto
name|restart
goto|;
block|}
name|VOP_LEASE
argument_list|(
name|nd
operator|.
name|ni_dvp
argument_list|,
name|td
argument_list|,
name|KERNCRED
argument_list|,
name|LEASE_WRITE
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_CREATE
argument_list|(
name|nd
operator|.
name|ni_dvp
argument_list|,
operator|&
name|nd
operator|.
name|ni_vp
argument_list|,
operator|&
name|nd
operator|.
name|ni_cnd
argument_list|,
operator|&
name|vat
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|nd
operator|.
name|ni_dvp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
name|vn_finished_write
argument_list|(
name|wrtmp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|nd
operator|.
name|ni_dvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|vp
operator|=
name|nd
operator|.
name|ni_vp
expr_stmt|;
name|ip
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|devvp
operator|=
name|ip
operator|->
name|i_devvp
expr_stmt|;
comment|/* 	 * Allocate and copy the last block contents so as to be able 	 * to set size to that of the filesystem. 	 */
name|numblks
operator|=
name|howmany
argument_list|(
name|fs
operator|->
name|fs_size
argument_list|,
name|fs
operator|->
name|fs_frag
argument_list|)
expr_stmt|;
name|error
operator|=
name|UFS_BALLOC
argument_list|(
name|vp
argument_list|,
name|lblktosize
argument_list|(
name|fs
argument_list|,
call|(
name|off_t
call|)
argument_list|(
name|numblks
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
name|BA_CLRBUF
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|ip
operator|->
name|i_size
operator|=
name|lblktosize
argument_list|(
name|fs
argument_list|,
operator|(
name|off_t
operator|)
name|numblks
argument_list|)
expr_stmt|;
name|DIP_SET
argument_list|(
name|ip
argument_list|,
name|i_size
argument_list|,
name|ip
operator|->
name|i_size
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_flag
operator||=
name|IN_CHANGE
operator||
name|IN_UPDATE
expr_stmt|;
name|error
operator|=
name|readblock
argument_list|(
name|vp
argument_list|,
name|bp
argument_list|,
name|numblks
operator|-
literal|1
argument_list|)
expr_stmt|;
name|bawrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Preallocate critical data structures so that we can copy 	 * them in without further allocation after we suspend all 	 * operations on the filesystem. We would like to just release 	 * the allocated buffers without writing them since they will 	 * be filled in below once we are ready to go, but this upsets 	 * the soft update code, so we go ahead and write the new buffers. 	 * 	 * Allocate all indirect blocks and mark all of them as not 	 * needing to be copied. 	 */
for|for
control|(
name|blkno
operator|=
name|NDADDR
init|;
name|blkno
operator|<
name|numblks
condition|;
name|blkno
operator|+=
name|NINDIR
argument_list|(
name|fs
argument_list|)
control|)
block|{
name|error
operator|=
name|UFS_BALLOC
argument_list|(
name|vp
argument_list|,
name|lblktosize
argument_list|(
name|fs
argument_list|,
operator|(
name|off_t
operator|)
name|blkno
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|BA_METAONLY
argument_list|,
operator|&
name|ibp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|bawrite
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Allocate copies for the superblock and its summary information. 	 */
name|error
operator|=
name|UFS_BALLOC
argument_list|(
name|vp
argument_list|,
name|fs
operator|->
name|fs_sblockloc
argument_list|,
name|fs
operator|->
name|fs_sbsize
argument_list|,
name|KERNCRED
argument_list|,
literal|0
argument_list|,
operator|&
name|nbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|bawrite
argument_list|(
name|nbp
argument_list|)
expr_stmt|;
name|blkno
operator|=
name|fragstoblks
argument_list|(
name|fs
argument_list|,
name|fs
operator|->
name|fs_csaddr
argument_list|)
expr_stmt|;
name|len
operator|=
name|howmany
argument_list|(
name|fs
operator|->
name|fs_cssize
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
for|for
control|(
name|loc
operator|=
literal|0
init|;
name|loc
operator|<
name|len
condition|;
name|loc
operator|++
control|)
block|{
name|error
operator|=
name|UFS_BALLOC
argument_list|(
name|vp
argument_list|,
name|lblktosize
argument_list|(
name|fs
argument_list|,
call|(
name|off_t
call|)
argument_list|(
name|blkno
operator|+
name|loc
argument_list|)
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
literal|0
argument_list|,
operator|&
name|nbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|bawrite
argument_list|(
name|nbp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Allocate all cylinder group blocks. 	 */
for|for
control|(
name|cg
operator|=
literal|0
init|;
name|cg
operator|<
name|fs
operator|->
name|fs_ncg
condition|;
name|cg
operator|++
control|)
block|{
name|error
operator|=
name|UFS_BALLOC
argument_list|(
name|vp
argument_list|,
name|lfragtosize
argument_list|(
name|fs
argument_list|,
name|cgtod
argument_list|(
name|fs
argument_list|,
name|cg
argument_list|)
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
literal|0
argument_list|,
operator|&
name|nbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|bawrite
argument_list|(
name|nbp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Copy all the cylinder group maps. Although the 	 * filesystem is still active, we hope that only a few 	 * cylinder groups will change between now and when we 	 * suspend operations. Thus, we will be able to quickly 	 * touch up the few cylinder groups that changed during 	 * the suspension period. 	 */
name|len
operator|=
name|howmany
argument_list|(
name|fs
operator|->
name|fs_ncg
argument_list|,
name|NBBY
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|space
argument_list|,
name|void
operator|*
argument_list|,
name|len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|UFS_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|fs
operator|->
name|fs_active
operator|=
name|space
expr_stmt|;
name|UFS_UNLOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
for|for
control|(
name|cg
operator|=
literal|0
init|;
name|cg
operator|<
name|fs
operator|->
name|fs_ncg
condition|;
name|cg
operator|++
control|)
block|{
name|error
operator|=
name|UFS_BALLOC
argument_list|(
name|vp
argument_list|,
name|lfragtosize
argument_list|(
name|fs
argument_list|,
name|cgtod
argument_list|(
name|fs
argument_list|,
name|cg
argument_list|)
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
literal|0
argument_list|,
operator|&
name|nbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|cgaccount
argument_list|(
name|cg
argument_list|,
name|vp
argument_list|,
name|nbp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bawrite
argument_list|(
name|nbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
block|}
ifdef|#
directive|ifdef
name|QUOTA
comment|/* 	 * Turn off disk quotas for snapshot file. 	 */
operator|(
name|void
operator|)
name|chkdq
argument_list|(
name|ip
argument_list|,
operator|-
name|DIP
argument_list|(
name|ip
argument_list|,
name|i_blocks
argument_list|)
argument_list|,
name|KERNCRED
argument_list|,
name|FORCE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXQUOTAS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ip
operator|->
name|i_dquot
index|[
name|i
index|]
operator|!=
name|NODQUOT
condition|)
block|{
name|dqrele
argument_list|(
name|vp
argument_list|,
name|ip
operator|->
name|i_dquot
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_dquot
index|[
name|i
index|]
operator|=
name|NODQUOT
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* 	 * Change inode to snapshot type file. 	 */
name|ip
operator|->
name|i_flags
operator||=
name|SF_SNAPSHOT
expr_stmt|;
name|DIP_SET
argument_list|(
name|ip
argument_list|,
name|i_flags
argument_list|,
name|ip
operator|->
name|i_flags
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_flag
operator||=
name|IN_CHANGE
operator||
name|IN_UPDATE
expr_stmt|;
comment|/* 	 * Ensure that the snapshot is completely on disk. 	 * Since we have marked it as a snapshot it is safe to 	 * unlock it as no process will be allowed to write to it. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|ffs_syncvnode
argument_list|(
name|vp
argument_list|,
name|MNT_WAIT
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
comment|/* 	 * All allocations are done, so we can now snapshot the system. 	 * 	 * Recind nice scheduling while running with the filesystem suspended. 	 */
if|if
condition|(
name|td
operator|->
name|td_proc
operator|->
name|p_nice
operator|>
literal|0
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|saved_nice
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_nice
expr_stmt|;
name|sched_nice
argument_list|(
name|td
operator|->
name|td_proc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Suspend operation on filesystem. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|vn_finished_write
argument_list|(
name|wrtmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|vfs_write_suspend
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|vn_start_write
argument_list|(
name|NULL
argument_list|,
operator|&
name|wrtmp
argument_list|,
name|V_WAIT
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|td
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|mp
operator|->
name|mnt_kern_flag
operator|&
name|MNTK_SUSPENDED
condition|)
break|break;
name|vn_start_write
argument_list|(
name|NULL
argument_list|,
operator|&
name|wrtmp
argument_list|,
name|V_WAIT
argument_list|)
expr_stmt|;
block|}
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_effnlink
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
comment|/* Snapshot file unlinked */
goto|goto
name|out1
goto|;
block|}
if|if
condition|(
name|collectsnapstats
condition|)
name|nanotime
argument_list|(
operator|&
name|starttime
argument_list|)
expr_stmt|;
comment|/* The last block might have changed.  Copy it again to be sure. */
name|error
operator|=
name|UFS_BALLOC
argument_list|(
name|vp
argument_list|,
name|lblktosize
argument_list|(
name|fs
argument_list|,
call|(
name|off_t
call|)
argument_list|(
name|numblks
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
name|BA_CLRBUF
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out1
goto|;
name|error
operator|=
name|readblock
argument_list|(
name|vp
argument_list|,
name|bp
argument_list|,
name|numblks
operator|-
literal|1
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_VALIDSUSPWRT
expr_stmt|;
name|bawrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out1
goto|;
comment|/* 	 * First, copy all the cylinder group maps that have changed. 	 */
for|for
control|(
name|cg
operator|=
literal|0
init|;
name|cg
operator|<
name|fs
operator|->
name|fs_ncg
condition|;
name|cg
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ACTIVECGNUM
argument_list|(
name|fs
argument_list|,
name|cg
argument_list|)
operator|&
name|ACTIVECGOFF
argument_list|(
name|cg
argument_list|)
operator|)
operator|!=
literal|0
condition|)
continue|continue;
name|redo
operator|++
expr_stmt|;
name|error
operator|=
name|UFS_BALLOC
argument_list|(
name|vp
argument_list|,
name|lfragtosize
argument_list|(
name|fs
argument_list|,
name|cgtod
argument_list|(
name|fs
argument_list|,
name|cg
argument_list|)
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
literal|0
argument_list|,
operator|&
name|nbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out1
goto|;
name|error
operator|=
name|cgaccount
argument_list|(
name|cg
argument_list|,
name|vp
argument_list|,
name|nbp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|bawrite
argument_list|(
name|nbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out1
goto|;
block|}
comment|/* 	 * Grab a copy of the superblock and its summary information. 	 * We delay writing it until the suspension is released below. 	 */
name|error
operator|=
name|bread
argument_list|(
name|vp
argument_list|,
name|lblkno
argument_list|(
name|fs
argument_list|,
name|fs
operator|->
name|fs_sblockloc
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
operator|&
name|sbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
name|sbp
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out1
goto|;
block|}
name|loc
operator|=
name|blkoff
argument_list|(
name|fs
argument_list|,
name|fs
operator|->
name|fs_sblockloc
argument_list|)
expr_stmt|;
name|copy_fs
operator|=
operator|(
expr|struct
name|fs
operator|*
operator|)
operator|(
name|sbp
operator|->
name|b_data
operator|+
name|loc
operator|)
expr_stmt|;
name|bcopy
argument_list|(
name|fs
argument_list|,
name|copy_fs
argument_list|,
name|fs
operator|->
name|fs_sbsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fs
operator|->
name|fs_flags
operator|&
operator|(
name|FS_UNCLEAN
operator||
name|FS_NEEDSFSCK
operator|)
operator|)
operator|==
literal|0
condition|)
name|copy_fs
operator|->
name|fs_clean
operator|=
literal|1
expr_stmt|;
name|size
operator|=
name|fs
operator|->
name|fs_bsize
operator|<
name|SBLOCKSIZE
condition|?
name|fs
operator|->
name|fs_bsize
else|:
name|SBLOCKSIZE
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|fs_sbsize
operator|<
name|size
condition|)
name|bzero
argument_list|(
operator|&
name|sbp
operator|->
name|b_data
index|[
name|loc
operator|+
name|fs
operator|->
name|fs_sbsize
index|]
argument_list|,
name|size
operator|-
name|fs
operator|->
name|fs_sbsize
argument_list|)
expr_stmt|;
name|size
operator|=
name|blkroundup
argument_list|(
name|fs
argument_list|,
name|fs
operator|->
name|fs_cssize
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|fs_contigsumsize
operator|>
literal|0
condition|)
name|size
operator|+=
name|fs
operator|->
name|fs_ncg
operator|*
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
expr_stmt|;
name|space
operator|=
name|malloc
argument_list|(
operator|(
name|u_long
operator|)
name|size
argument_list|,
name|M_UFSMNT
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|copy_fs
operator|->
name|fs_csp
operator|=
name|space
expr_stmt|;
name|bcopy
argument_list|(
name|fs
operator|->
name|fs_csp
argument_list|,
name|copy_fs
operator|->
name|fs_csp
argument_list|,
name|fs
operator|->
name|fs_cssize
argument_list|)
expr_stmt|;
name|space
operator|=
operator|(
name|char
operator|*
operator|)
name|space
operator|+
name|fs
operator|->
name|fs_cssize
expr_stmt|;
name|loc
operator|=
name|howmany
argument_list|(
name|fs
operator|->
name|fs_cssize
argument_list|,
name|fs
operator|->
name|fs_fsize
argument_list|)
expr_stmt|;
name|i
operator|=
name|fs
operator|->
name|fs_frag
operator|-
name|loc
operator|%
name|fs
operator|->
name|fs_frag
expr_stmt|;
name|len
operator|=
operator|(
name|i
operator|==
name|fs
operator|->
name|fs_frag
operator|)
condition|?
literal|0
else|:
name|i
operator|*
name|fs
operator|->
name|fs_fsize
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|bread
argument_list|(
name|devvp
argument_list|,
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|fs
operator|->
name|fs_csaddr
operator|+
name|loc
argument_list|)
argument_list|,
name|len
argument_list|,
name|KERNCRED
argument_list|,
operator|&
name|bp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|copy_fs
operator|->
name|fs_csp
argument_list|,
name|M_UFSMNT
argument_list|)
expr_stmt|;
name|bawrite
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
name|sbp
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out1
goto|;
block|}
name|bcopy
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
name|space
argument_list|,
operator|(
name|u_int
operator|)
name|len
argument_list|)
expr_stmt|;
name|space
operator|=
operator|(
name|char
operator|*
operator|)
name|space
operator|+
name|len
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_INVAL
operator||
name|B_NOCACHE
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fs
operator|->
name|fs_contigsumsize
operator|>
literal|0
condition|)
block|{
name|copy_fs
operator|->
name|fs_maxcluster
operator|=
name|lp
operator|=
name|space
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fs
operator|->
name|fs_ncg
condition|;
name|i
operator|++
control|)
operator|*
name|lp
operator|++
operator|=
name|fs
operator|->
name|fs_contigsumsize
expr_stmt|;
block|}
comment|/* 	 * We must check for active files that have been unlinked 	 * (e.g., with a zero link count). We have to expunge all 	 * trace of these files from the snapshot so that they are 	 * not reclaimed prematurely by fsck or unnecessarily dumped. 	 * We turn off the MNTK_SUSPENDED flag to avoid a panic from 	 * spec_strategy about writing on a suspended filesystem. 	 * Note that we skip unlinked snapshot files as they will 	 * be handled separately below. 	 * 	 * We also calculate the needed size for the snapshot list. 	 */
name|snaplistsize
operator|=
name|fs
operator|->
name|fs_ncg
operator|+
name|howmany
argument_list|(
name|fs
operator|->
name|fs_cssize
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|)
operator|+
name|FSMAXSNAP
operator|+
literal|1
comment|/* superblock */
operator|+
literal|1
comment|/* last block */
operator|+
literal|1
comment|/* size */
expr_stmt|;
name|MNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_kern_flag
operator|&=
operator|~
name|MNTK_SUSPENDED
expr_stmt|;
name|loop
label|:
name|MNT_VNODE_FOREACH
argument_list|(
argument|xvp
argument_list|,
argument|mp
argument_list|,
argument|mvp
argument_list|)
block|{
name|VI_LOCK
argument_list|(
name|xvp
argument_list|)
expr_stmt|;
name|MNT_IUNLOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|xvp
operator|->
name|v_iflag
operator|&
name|VI_DOOMED
operator|)
operator|||
operator|(
name|xvp
operator|->
name|v_usecount
operator|==
literal|0
operator|&&
operator|(
name|xvp
operator|->
name|v_iflag
operator|&
operator|(
name|VI_OWEINACT
operator||
name|VI_DOINGINACT
operator|)
operator|)
operator|==
literal|0
operator|)
operator|||
name|xvp
operator|->
name|v_type
operator|==
name|VNON
operator|||
operator|(
name|VTOI
argument_list|(
name|xvp
argument_list|)
operator|->
name|i_flags
operator|&
name|SF_SNAPSHOT
operator|)
condition|)
block|{
name|VI_UNLOCK
argument_list|(
name|xvp
argument_list|)
expr_stmt|;
name|MNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * We can skip parent directory vnode because it must have 		 * this snapshot file in it. 		 */
if|if
condition|(
name|xvp
operator|==
name|nd
operator|.
name|ni_dvp
condition|)
block|{
name|VI_UNLOCK
argument_list|(
name|xvp
argument_list|)
expr_stmt|;
name|MNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|vholdl
argument_list|(
name|xvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vn_lock
argument_list|(
name|xvp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_INTERLOCK
argument_list|,
name|td
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|MNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|MNT_VNODE_FOREACH_ABORT_ILOCKED
argument_list|(
name|mp
argument_list|,
name|mvp
argument_list|)
expr_stmt|;
name|vdrop
argument_list|(
name|xvp
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
name|VI_LOCK
argument_list|(
name|xvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|xvp
operator|->
name|v_usecount
operator|==
literal|0
operator|&&
operator|(
name|xvp
operator|->
name|v_iflag
operator|&
operator|(
name|VI_OWEINACT
operator||
name|VI_DOINGINACT
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|VI_UNLOCK
argument_list|(
name|xvp
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|xvp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|vdrop
argument_list|(
name|xvp
argument_list|)
expr_stmt|;
name|MNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|VI_UNLOCK
argument_list|(
name|xvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|snapdebug
condition|)
name|vprint
argument_list|(
literal|"ffs_snapshot: busy vnode"
argument_list|,
name|xvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|VOP_GETATTR
argument_list|(
name|xvp
argument_list|,
operator|&
name|vat
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
operator|==
literal|0
operator|&&
name|vat
operator|.
name|va_nlink
operator|>
literal|0
condition|)
block|{
name|VOP_UNLOCK
argument_list|(
name|xvp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|vdrop
argument_list|(
name|xvp
argument_list|)
expr_stmt|;
name|MNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|xp
operator|=
name|VTOI
argument_list|(
name|xvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffs_checkfreefile
argument_list|(
name|copy_fs
argument_list|,
name|vp
argument_list|,
name|xp
operator|->
name|i_number
argument_list|)
condition|)
block|{
name|VOP_UNLOCK
argument_list|(
name|xvp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|vdrop
argument_list|(
name|xvp
argument_list|)
expr_stmt|;
name|MNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * If there is a fragment, clear it here. 		 */
name|blkno
operator|=
literal|0
expr_stmt|;
name|loc
operator|=
name|howmany
argument_list|(
name|xp
operator|->
name|i_size
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|loc
operator|<
name|NDADDR
condition|)
block|{
name|len
operator|=
name|fragroundup
argument_list|(
name|fs
argument_list|,
name|blkoff
argument_list|(
name|fs
argument_list|,
name|xp
operator|->
name|i_size
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
literal|0
operator|&&
name|len
operator|<
name|fs
operator|->
name|fs_bsize
condition|)
block|{
name|ffs_blkfree
argument_list|(
name|ump
argument_list|,
name|copy_fs
argument_list|,
name|vp
argument_list|,
name|DIP
argument_list|(
name|xp
argument_list|,
name|i_db
index|[
name|loc
index|]
argument_list|)
argument_list|,
name|len
argument_list|,
name|xp
operator|->
name|i_number
argument_list|)
expr_stmt|;
name|blkno
operator|=
name|DIP
argument_list|(
name|xp
argument_list|,
name|i_db
index|[
name|loc
index|]
argument_list|)
expr_stmt|;
name|DIP_SET
argument_list|(
name|xp
argument_list|,
name|i_db
index|[
name|loc
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|snaplistsize
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|xp
operator|->
name|i_ump
operator|->
name|um_fstype
operator|==
name|UFS1
condition|)
name|error
operator|=
name|expunge_ufs1
argument_list|(
name|vp
argument_list|,
name|xp
argument_list|,
name|copy_fs
argument_list|,
name|fullacct_ufs1
argument_list|,
name|BLK_NOCOPY
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|expunge_ufs2
argument_list|(
name|vp
argument_list|,
name|xp
argument_list|,
name|copy_fs
argument_list|,
name|fullacct_ufs2
argument_list|,
name|BLK_NOCOPY
argument_list|)
expr_stmt|;
if|if
condition|(
name|blkno
condition|)
name|DIP_SET
argument_list|(
name|xp
argument_list|,
name|i_db
index|[
name|loc
index|]
argument_list|,
name|blkno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|ffs_freefile
argument_list|(
name|ump
argument_list|,
name|copy_fs
argument_list|,
name|vp
argument_list|,
name|xp
operator|->
name|i_number
argument_list|,
name|xp
operator|->
name|i_mode
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|xvp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|vdrop
argument_list|(
name|xvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|copy_fs
operator|->
name|fs_csp
argument_list|,
name|M_UFSMNT
argument_list|)
expr_stmt|;
name|bawrite
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
name|sbp
operator|=
name|NULL
expr_stmt|;
name|MNT_VNODE_FOREACH_ABORT
argument_list|(
name|mp
argument_list|,
name|mvp
argument_list|)
expr_stmt|;
goto|goto
name|out1
goto|;
block|}
name|MNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
name|MNT_IUNLOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
comment|/* 	 * If there already exist snapshots on this filesystem, grab a 	 * reference to their shared lock. If this is the first snapshot 	 * on this filesystem, we need to allocate a lock for the snapshots 	 * to share. In either case, acquire the snapshot lock and give 	 * up our original private lock. 	 */
name|VI_LOCK
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
name|sn
operator|=
name|devvp
operator|->
name|v_rdev
operator|->
name|si_snapdata
expr_stmt|;
if|if
condition|(
name|sn
operator|!=
name|NULL
condition|)
block|{
name|xp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sn
operator|->
name|sn_head
argument_list|)
expr_stmt|;
name|VI_UNLOCK
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
name|VI_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_vnlock
operator|=
operator|&
name|sn
operator|->
name|sn_lock
expr_stmt|;
block|}
else|else
block|{
name|VI_UNLOCK
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
name|sn
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|sn
argument_list|,
name|M_UFSMNT
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sn
operator|->
name|sn_head
argument_list|)
expr_stmt|;
name|lockinit
argument_list|(
operator|&
name|sn
operator|->
name|sn_lock
argument_list|,
name|PVFS
argument_list|,
literal|"snaplk"
argument_list|,
name|VLKTIMEOUT
argument_list|,
name|LK_CANRECURSE
operator||
name|LK_NOSHARE
argument_list|)
expr_stmt|;
name|VI_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_vnlock
operator|=
operator|&
name|sn
operator|->
name|sn_lock
expr_stmt|;
name|mp_fixme
argument_list|(
literal|"si_snapdata setting is racey."
argument_list|)
expr_stmt|;
name|devvp
operator|->
name|v_rdev
operator|->
name|si_snapdata
operator|=
name|sn
expr_stmt|;
name|xp
operator|=
name|NULL
expr_stmt|;
block|}
name|lockmgr
argument_list|(
name|vp
operator|->
name|v_vnlock
argument_list|,
name|LK_INTERLOCK
operator||
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|VI_MTX
argument_list|(
name|vp
argument_list|)
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|lockmgr
argument_list|(
operator|&
name|vp
operator|->
name|v_lock
argument_list|,
name|LK_RELEASE
argument_list|,
name|NULL
argument_list|,
name|td
argument_list|)
expr_stmt|;
comment|/* 	 * If this is the first snapshot on this filesystem, then we need 	 * to allocate the space for the list of preallocated snapshot blocks. 	 * This list will be refined below, but this preliminary one will 	 * keep us out of deadlock until the full one is ready. 	 */
if|if
condition|(
name|xp
operator|==
name|NULL
condition|)
block|{
name|MALLOC
argument_list|(
name|snapblklist
argument_list|,
name|daddr_t
operator|*
argument_list|,
name|snaplistsize
operator|*
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
argument_list|,
name|M_UFSMNT
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|blkp
operator|=
operator|&
name|snapblklist
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|blkp
operator|++
operator|=
name|lblkno
argument_list|(
name|fs
argument_list|,
name|fs
operator|->
name|fs_sblockloc
argument_list|)
expr_stmt|;
name|blkno
operator|=
name|fragstoblks
argument_list|(
name|fs
argument_list|,
name|fs
operator|->
name|fs_csaddr
argument_list|)
expr_stmt|;
for|for
control|(
name|cg
operator|=
literal|0
init|;
name|cg
operator|<
name|fs
operator|->
name|fs_ncg
condition|;
name|cg
operator|++
control|)
block|{
if|if
condition|(
name|fragstoblks
argument_list|(
name|fs
argument_list|,
name|cgtod
argument_list|(
name|fs
argument_list|,
name|cg
argument_list|)
operator|>
name|blkno
argument_list|)
condition|)
break|break;
operator|*
name|blkp
operator|++
operator|=
name|fragstoblks
argument_list|(
name|fs
argument_list|,
name|cgtod
argument_list|(
name|fs
argument_list|,
name|cg
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
name|howmany
argument_list|(
name|fs
operator|->
name|fs_cssize
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
for|for
control|(
name|loc
operator|=
literal|0
init|;
name|loc
operator|<
name|len
condition|;
name|loc
operator|++
control|)
operator|*
name|blkp
operator|++
operator|=
name|blkno
operator|+
name|loc
expr_stmt|;
for|for
control|(
init|;
name|cg
operator|<
name|fs
operator|->
name|fs_ncg
condition|;
name|cg
operator|++
control|)
operator|*
name|blkp
operator|++
operator|=
name|fragstoblks
argument_list|(
name|fs
argument_list|,
name|cgtod
argument_list|(
name|fs
argument_list|,
name|cg
argument_list|)
argument_list|)
expr_stmt|;
name|snapblklist
index|[
literal|0
index|]
operator|=
name|blkp
operator|-
name|snapblklist
expr_stmt|;
name|VI_LOCK
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sn
operator|->
name|sn_blklist
operator|!=
name|NULL
condition|)
name|panic
argument_list|(
literal|"ffs_snapshot: non-empty list"
argument_list|)
expr_stmt|;
name|sn
operator|->
name|sn_blklist
operator|=
name|snapblklist
expr_stmt|;
name|sn
operator|->
name|sn_listsize
operator|=
name|blkp
operator|-
name|snapblklist
expr_stmt|;
name|VI_UNLOCK
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Record snapshot inode. Since this is the newest snapshot, 	 * it must be placed at the end of the list. 	 */
name|VI_LOCK
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
name|fs
operator|->
name|fs_snapinum
index|[
name|snaploc
index|]
operator|=
name|ip
operator|->
name|i_number
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_nextsnap
operator|.
name|tqe_prev
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"ffs_snapshot: %d already on list"
argument_list|,
name|ip
operator|->
name|i_number
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sn
operator|->
name|sn_head
argument_list|,
name|ip
argument_list|,
name|i_nextsnap
argument_list|)
expr_stmt|;
name|devvp
operator|->
name|v_vflag
operator||=
name|VV_COPYONWRITE
expr_stmt|;
name|VI_UNLOCK
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
name|ASSERT_VOP_LOCKED
argument_list|(
name|vp
argument_list|,
literal|"ffs_snapshot vp"
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_vflag
operator||=
name|VV_SYSTEM
expr_stmt|;
name|out1
label|:
name|KASSERT
argument_list|(
operator|(
name|sn
operator|!=
name|NULL
operator|&&
name|sbp
operator|!=
name|NULL
operator|&&
name|error
operator|==
literal|0
operator|)
operator|||
operator|(
name|sn
operator|==
name|NULL
operator|&&
name|sbp
operator|==
name|NULL
operator|&&
name|error
operator|!=
literal|0
operator|)
argument_list|,
operator|(
literal|"email phk@ and mckusick@"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Resume operation on filesystem. 	 */
name|vfs_write_resume
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
name|vn_start_write
argument_list|(
name|NULL
argument_list|,
operator|&
name|wrtmp
argument_list|,
name|V_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|collectsnapstats
operator|&&
name|starttime
operator|.
name|tv_sec
operator|>
literal|0
condition|)
block|{
name|nanotime
argument_list|(
operator|&
name|endtime
argument_list|)
expr_stmt|;
name|timespecsub
argument_list|(
operator|&
name|endtime
argument_list|,
operator|&
name|starttime
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: suspended %ld.%03ld sec, redo %ld of %d\n"
argument_list|,
name|vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_mntonname
argument_list|,
operator|(
name|long
operator|)
name|endtime
operator|.
name|tv_sec
argument_list|,
name|endtime
operator|.
name|tv_nsec
operator|/
literal|1000000
argument_list|,
name|redo
argument_list|,
name|fs
operator|->
name|fs_ncg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sbp
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Copy allocation information from all the snapshots in 	 * this snapshot and then expunge them from its view. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|xp
argument_list|,
argument|&sn->sn_head
argument_list|,
argument|i_nextsnap
argument_list|)
block|{
if|if
condition|(
name|xp
operator|==
name|ip
condition|)
break|break;
if|if
condition|(
name|xp
operator|->
name|i_ump
operator|->
name|um_fstype
operator|==
name|UFS1
condition|)
name|error
operator|=
name|expunge_ufs1
argument_list|(
name|vp
argument_list|,
name|xp
argument_list|,
name|fs
argument_list|,
name|snapacct_ufs1
argument_list|,
name|BLK_SNAP
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|expunge_ufs2
argument_list|(
name|vp
argument_list|,
name|xp
argument_list|,
name|fs
argument_list|,
name|snapacct_ufs2
argument_list|,
name|BLK_SNAP
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|xp
operator|->
name|i_effnlink
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ffs_freefile
argument_list|(
name|ump
argument_list|,
name|copy_fs
argument_list|,
name|vp
argument_list|,
name|xp
operator|->
name|i_number
argument_list|,
name|xp
operator|->
name|i_mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|fs
operator|->
name|fs_snapinum
index|[
name|snaploc
index|]
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
comment|/* 	 * Allocate space for the full list of preallocated snapshot blocks. 	 */
name|MALLOC
argument_list|(
name|snapblklist
argument_list|,
name|daddr_t
operator|*
argument_list|,
name|snaplistsize
operator|*
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
argument_list|,
name|M_UFSMNT
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_snapblklist
operator|=
operator|&
name|snapblklist
index|[
literal|1
index|]
expr_stmt|;
comment|/* 	 * Expunge the blocks used by the snapshots from the set of 	 * blocks marked as used in the snapshot bitmaps. Also, collect 	 * the list of allocated blocks in i_snapblklist. 	 */
if|if
condition|(
name|ip
operator|->
name|i_ump
operator|->
name|um_fstype
operator|==
name|UFS1
condition|)
name|error
operator|=
name|expunge_ufs1
argument_list|(
name|vp
argument_list|,
name|ip
argument_list|,
name|copy_fs
argument_list|,
name|mapacct_ufs1
argument_list|,
name|BLK_SNAP
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|expunge_ufs2
argument_list|(
name|vp
argument_list|,
name|ip
argument_list|,
name|copy_fs
argument_list|,
name|mapacct_ufs2
argument_list|,
name|BLK_SNAP
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|fs
operator|->
name|fs_snapinum
index|[
name|snaploc
index|]
operator|=
literal|0
expr_stmt|;
name|FREE
argument_list|(
name|snapblklist
argument_list|,
name|M_UFSMNT
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|snaplistsize
operator|<
name|ip
operator|->
name|i_snapblklist
operator|-
name|snapblklist
condition|)
name|panic
argument_list|(
literal|"ffs_snapshot: list too small"
argument_list|)
expr_stmt|;
name|snaplistsize
operator|=
name|ip
operator|->
name|i_snapblklist
operator|-
name|snapblklist
expr_stmt|;
name|snapblklist
index|[
literal|0
index|]
operator|=
name|snaplistsize
expr_stmt|;
name|ip
operator|->
name|i_snapblklist
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Write out the list of allocated blocks to the end of the snapshot. 	 */
name|auio
operator|.
name|uio_iov
operator|=
operator|&
name|aiov
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|aiov
operator|.
name|iov_base
operator|=
operator|(
name|void
operator|*
operator|)
name|snapblklist
expr_stmt|;
name|aiov
operator|.
name|iov_len
operator|=
name|snaplistsize
operator|*
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
name|aiov
operator|.
name|iov_len
expr_stmt|;
empty_stmt|;
name|auio
operator|.
name|uio_offset
operator|=
name|ip
operator|->
name|i_size
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|auio
operator|.
name|uio_rw
operator|=
name|UIO_WRITE
expr_stmt|;
name|auio
operator|.
name|uio_td
operator|=
name|td
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_WRITE
argument_list|(
name|vp
argument_list|,
operator|&
name|auio
argument_list|,
name|IO_UNIT
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|fs
operator|->
name|fs_snapinum
index|[
name|snaploc
index|]
operator|=
literal|0
expr_stmt|;
name|FREE
argument_list|(
name|snapblklist
argument_list|,
name|M_UFSMNT
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Write the superblock and its summary information 	 * to the snapshot. 	 */
name|blkno
operator|=
name|fragstoblks
argument_list|(
name|fs
argument_list|,
name|fs
operator|->
name|fs_csaddr
argument_list|)
expr_stmt|;
name|len
operator|=
name|howmany
argument_list|(
name|fs
operator|->
name|fs_cssize
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
name|space
operator|=
name|copy_fs
operator|->
name|fs_csp
expr_stmt|;
for|for
control|(
name|loc
operator|=
literal|0
init|;
name|loc
operator|<
name|len
condition|;
name|loc
operator|++
control|)
block|{
name|error
operator|=
name|bread
argument_list|(
name|vp
argument_list|,
name|blkno
operator|+
name|loc
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
operator|&
name|nbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|nbp
argument_list|)
expr_stmt|;
name|fs
operator|->
name|fs_snapinum
index|[
name|snaploc
index|]
operator|=
literal|0
expr_stmt|;
name|FREE
argument_list|(
name|snapblklist
argument_list|,
name|M_UFSMNT
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|bcopy
argument_list|(
name|space
argument_list|,
name|nbp
operator|->
name|b_data
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
name|space
operator|=
operator|(
name|char
operator|*
operator|)
name|space
operator|+
name|fs
operator|->
name|fs_bsize
expr_stmt|;
name|bawrite
argument_list|(
name|nbp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * As this is the newest list, it is the most inclusive, so 	 * should replace the previous list. 	 */
name|VI_LOCK
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
name|space
operator|=
name|sn
operator|->
name|sn_blklist
expr_stmt|;
name|sn
operator|->
name|sn_blklist
operator|=
name|snapblklist
expr_stmt|;
name|sn
operator|->
name|sn_listsize
operator|=
name|snaplistsize
expr_stmt|;
name|VI_UNLOCK
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|space
operator|!=
name|NULL
condition|)
name|FREE
argument_list|(
name|space
argument_list|,
name|M_UFSMNT
argument_list|)
expr_stmt|;
comment|/* 	 * If another process is currently writing the buffer containing 	 * the inode for this snapshot then a deadlock can occur. Drop 	 * the snapshot lock until the buffer has been written. 	 */
name|VREF
argument_list|(
name|vp
argument_list|)
expr_stmt|;
comment|/* Protect against ffs_snapgone() */
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bread
argument_list|(
name|ip
operator|->
name|i_devvp
argument_list|,
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|ino_to_fsba
argument_list|(
name|fs
argument_list|,
name|ip
operator|->
name|i_number
argument_list|)
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|fs
operator|->
name|fs_bsize
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|nbp
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|nbp
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_effnlink
operator|==
literal|0
condition|)
name|error
operator|=
name|ENOENT
expr_stmt|;
comment|/* Snapshot file unlinked */
else|else
name|vrele
argument_list|(
name|vp
argument_list|)
expr_stmt|;
comment|/* Drop extra reference */
name|done
label|:
name|FREE
argument_list|(
name|copy_fs
operator|->
name|fs_csp
argument_list|,
name|M_UFSMNT
argument_list|)
expr_stmt|;
name|bawrite
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|saved_nice
operator|>
literal|0
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|sched_nice
argument_list|(
name|td
operator|->
name|td_proc
argument_list|,
name|saved_nice
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
block|}
name|UFS_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|fs_active
operator|!=
literal|0
condition|)
block|{
name|FREE
argument_list|(
name|fs
operator|->
name|fs_active
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|fs
operator|->
name|fs_active
operator|=
literal|0
expr_stmt|;
block|}
name|UFS_UNLOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_flag
operator|=
name|flag
expr_stmt|;
if|if
condition|(
name|error
condition|)
operator|(
name|void
operator|)
name|ffs_truncate
argument_list|(
name|vp
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
name|NOCRED
argument_list|,
name|td
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ffs_syncvnode
argument_list|(
name|vp
argument_list|,
name|MNT_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
else|else
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|nd
operator|.
name|ni_dvp
argument_list|)
expr_stmt|;
name|vn_finished_write
argument_list|(
name|wrtmp
argument_list|)
expr_stmt|;
name|process_deferred_inactive
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copy a cylinder group map. All the unallocated blocks are marked  * BLK_NOCOPY so that the snapshot knows that it need not copy them  * if they are later written. If passno is one, then this is a first  * pass, so only setting needs to be done. If passno is 2, then this  * is a revision to a previous pass which must be undone as the  * replacement pass is done.  */
end_comment

begin_function
specifier|static
name|int
name|cgaccount
parameter_list|(
name|cg
parameter_list|,
name|vp
parameter_list|,
name|nbp
parameter_list|,
name|passno
parameter_list|)
name|int
name|cg
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|buf
modifier|*
name|nbp
decl_stmt|;
name|int
name|passno
decl_stmt|;
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|ibp
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|struct
name|cg
modifier|*
name|cgp
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|ufs2_daddr_t
name|base
decl_stmt|,
name|numblks
decl_stmt|;
name|int
name|error
decl_stmt|,
name|len
decl_stmt|,
name|loc
decl_stmt|,
name|indiroff
decl_stmt|;
name|ip
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|fs
operator|=
name|ip
operator|->
name|i_fs
expr_stmt|;
name|error
operator|=
name|bread
argument_list|(
name|ip
operator|->
name|i_devvp
argument_list|,
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|cgtod
argument_list|(
name|fs
argument_list|,
name|cg
argument_list|)
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|fs
operator|->
name|fs_cgsize
argument_list|,
name|KERNCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|cgp
operator|=
operator|(
expr|struct
name|cg
operator|*
operator|)
name|bp
operator|->
name|b_data
expr_stmt|;
if|if
condition|(
operator|!
name|cg_chkmagic
argument_list|(
name|cgp
argument_list|)
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|UFS_LOCK
argument_list|(
name|ip
operator|->
name|i_ump
argument_list|)
expr_stmt|;
name|ACTIVESET
argument_list|(
name|fs
argument_list|,
name|cg
argument_list|)
expr_stmt|;
name|UFS_UNLOCK
argument_list|(
name|ip
operator|->
name|i_ump
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
name|nbp
operator|->
name|b_data
argument_list|,
name|fs
operator|->
name|fs_cgsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|fs_cgsize
operator|<
name|fs
operator|->
name|fs_bsize
condition|)
name|bzero
argument_list|(
operator|&
name|nbp
operator|->
name|b_data
index|[
name|fs
operator|->
name|fs_cgsize
index|]
argument_list|,
name|fs
operator|->
name|fs_bsize
operator|-
name|fs
operator|->
name|fs_cgsize
argument_list|)
expr_stmt|;
name|cgp
operator|=
operator|(
expr|struct
name|cg
operator|*
operator|)
name|nbp
operator|->
name|b_data
expr_stmt|;
name|bqrelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|passno
operator|==
literal|2
condition|)
name|nbp
operator|->
name|b_flags
operator||=
name|B_VALIDSUSPWRT
expr_stmt|;
name|numblks
operator|=
name|howmany
argument_list|(
name|fs
operator|->
name|fs_size
argument_list|,
name|fs
operator|->
name|fs_frag
argument_list|)
expr_stmt|;
name|len
operator|=
name|howmany
argument_list|(
name|fs
operator|->
name|fs_fpg
argument_list|,
name|fs
operator|->
name|fs_frag
argument_list|)
expr_stmt|;
name|base
operator|=
name|cgbase
argument_list|(
name|fs
argument_list|,
name|cg
argument_list|)
operator|/
name|fs
operator|->
name|fs_frag
expr_stmt|;
if|if
condition|(
name|base
operator|+
name|len
operator|>=
name|numblks
condition|)
name|len
operator|=
name|numblks
operator|-
name|base
operator|-
literal|1
expr_stmt|;
name|loc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|base
operator|<
name|NDADDR
condition|)
block|{
for|for
control|(
init|;
name|loc
operator|<
name|NDADDR
condition|;
name|loc
operator|++
control|)
block|{
if|if
condition|(
name|ffs_isblock
argument_list|(
name|fs
argument_list|,
name|cg_blksfree
argument_list|(
name|cgp
argument_list|)
argument_list|,
name|loc
argument_list|)
condition|)
name|DIP_SET
argument_list|(
name|ip
argument_list|,
name|i_db
index|[
name|loc
index|]
argument_list|,
name|BLK_NOCOPY
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|passno
operator|==
literal|2
operator|&&
name|DIP
argument_list|(
name|ip
argument_list|,
name|i_db
index|[
name|loc
index|]
argument_list|)
operator|==
name|BLK_NOCOPY
condition|)
name|DIP_SET
argument_list|(
name|ip
argument_list|,
name|i_db
index|[
name|loc
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|passno
operator|==
literal|1
operator|&&
name|DIP
argument_list|(
name|ip
argument_list|,
name|i_db
index|[
name|loc
index|]
argument_list|)
operator|==
name|BLK_NOCOPY
condition|)
name|panic
argument_list|(
literal|"ffs_snapshot: lost direct block"
argument_list|)
expr_stmt|;
block|}
block|}
name|error
operator|=
name|UFS_BALLOC
argument_list|(
name|vp
argument_list|,
name|lblktosize
argument_list|(
name|fs
argument_list|,
call|(
name|off_t
call|)
argument_list|(
name|base
operator|+
name|loc
argument_list|)
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
name|BA_METAONLY
argument_list|,
operator|&
name|ibp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
name|indiroff
operator|=
operator|(
name|base
operator|+
name|loc
operator|-
name|NDADDR
operator|)
operator|%
name|NINDIR
argument_list|(
name|fs
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|loc
operator|<
name|len
condition|;
name|loc
operator|++
operator|,
name|indiroff
operator|++
control|)
block|{
if|if
condition|(
name|indiroff
operator|>=
name|NINDIR
argument_list|(
name|fs
argument_list|)
condition|)
block|{
if|if
condition|(
name|passno
operator|==
literal|2
condition|)
name|ibp
operator|->
name|b_flags
operator||=
name|B_VALIDSUSPWRT
expr_stmt|;
name|bawrite
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
name|error
operator|=
name|UFS_BALLOC
argument_list|(
name|vp
argument_list|,
name|lblktosize
argument_list|(
name|fs
argument_list|,
call|(
name|off_t
call|)
argument_list|(
name|base
operator|+
name|loc
argument_list|)
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
name|BA_METAONLY
argument_list|,
operator|&
name|ibp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
name|indiroff
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ip
operator|->
name|i_ump
operator|->
name|um_fstype
operator|==
name|UFS1
condition|)
block|{
if|if
condition|(
name|ffs_isblock
argument_list|(
name|fs
argument_list|,
name|cg_blksfree
argument_list|(
name|cgp
argument_list|)
argument_list|,
name|loc
argument_list|)
condition|)
operator|(
operator|(
name|ufs1_daddr_t
operator|*
operator|)
operator|(
name|ibp
operator|->
name|b_data
operator|)
operator|)
index|[
name|indiroff
index|]
operator|=
name|BLK_NOCOPY
expr_stmt|;
elseif|else
if|if
condition|(
name|passno
operator|==
literal|2
operator|&&
operator|(
operator|(
name|ufs1_daddr_t
operator|*
operator|)
operator|(
name|ibp
operator|->
name|b_data
operator|)
operator|)
index|[
name|indiroff
index|]
operator|==
name|BLK_NOCOPY
condition|)
operator|(
operator|(
name|ufs1_daddr_t
operator|*
operator|)
operator|(
name|ibp
operator|->
name|b_data
operator|)
operator|)
index|[
name|indiroff
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|passno
operator|==
literal|1
operator|&&
operator|(
operator|(
name|ufs1_daddr_t
operator|*
operator|)
operator|(
name|ibp
operator|->
name|b_data
operator|)
operator|)
index|[
name|indiroff
index|]
operator|==
name|BLK_NOCOPY
condition|)
name|panic
argument_list|(
literal|"ffs_snapshot: lost indirect block"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ffs_isblock
argument_list|(
name|fs
argument_list|,
name|cg_blksfree
argument_list|(
name|cgp
argument_list|)
argument_list|,
name|loc
argument_list|)
condition|)
operator|(
operator|(
name|ufs2_daddr_t
operator|*
operator|)
operator|(
name|ibp
operator|->
name|b_data
operator|)
operator|)
index|[
name|indiroff
index|]
operator|=
name|BLK_NOCOPY
expr_stmt|;
elseif|else
if|if
condition|(
name|passno
operator|==
literal|2
operator|&&
operator|(
operator|(
name|ufs2_daddr_t
operator|*
operator|)
operator|(
name|ibp
operator|->
name|b_data
operator|)
operator|)
index|[
name|indiroff
index|]
operator|==
name|BLK_NOCOPY
condition|)
operator|(
operator|(
name|ufs2_daddr_t
operator|*
operator|)
operator|(
name|ibp
operator|->
name|b_data
operator|)
operator|)
index|[
name|indiroff
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|passno
operator|==
literal|1
operator|&&
operator|(
operator|(
name|ufs2_daddr_t
operator|*
operator|)
operator|(
name|ibp
operator|->
name|b_data
operator|)
operator|)
index|[
name|indiroff
index|]
operator|==
name|BLK_NOCOPY
condition|)
name|panic
argument_list|(
literal|"ffs_snapshot: lost indirect block"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|passno
operator|==
literal|2
condition|)
name|ibp
operator|->
name|b_flags
operator||=
name|B_VALIDSUSPWRT
expr_stmt|;
name|bdwrite
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Before expunging a snapshot inode, note all the  * blocks that it claims with BLK_SNAP so that fsck will  * be able to account for those blocks properly and so  * that this snapshot knows that it need not copy them  * if the other snapshot holding them is freed. This code  * is reproduced once each for UFS1 and UFS2.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|expunge_ufs1
argument_list|(
name|snapvp
argument_list|,
name|cancelip
argument_list|,
name|fs
argument_list|,
name|acctfunc
argument_list|,
name|expungetype
argument_list|)
decl|struct
name|vnode
modifier|*
name|snapvp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|inode
modifier|*
name|cancelip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|acctfunc
function_decl|)
parameter_list|(
name|struct
name|vnode
modifier|*
parameter_list|,
name|ufs1_daddr_t
modifier|*
parameter_list|,
name|ufs1_daddr_t
modifier|*
parameter_list|,
name|struct
name|fs
modifier|*
parameter_list|,
name|ufs_lbn_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|expungetype
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|error
decl_stmt|,
name|indiroff
decl_stmt|;
name|ufs_lbn_t
name|lbn
decl_stmt|,
name|rlbn
decl_stmt|;
name|ufs2_daddr_t
name|len
decl_stmt|,
name|blkno
decl_stmt|,
name|numblks
decl_stmt|,
name|blksperindir
decl_stmt|;
name|struct
name|ufs1_dinode
modifier|*
name|dip
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
comment|/* 	 * Prepare to expunge the inode. If its inode block has not 	 * yet been copied, then allocate and fill the copy. 	 */
name|lbn
operator|=
name|fragstoblks
argument_list|(
name|fs
argument_list|,
name|ino_to_fsba
argument_list|(
name|fs
argument_list|,
name|cancelip
operator|->
name|i_number
argument_list|)
argument_list|)
expr_stmt|;
name|blkno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lbn
operator|<
name|NDADDR
condition|)
block|{
name|blkno
operator|=
name|VTOI
argument_list|(
name|snapvp
argument_list|)
operator|->
name|i_din1
operator|->
name|di_db
index|[
name|lbn
index|]
expr_stmt|;
block|}
else|else
block|{
name|td
operator|->
name|td_pflags
operator||=
name|TDP_COWINPROGRESS
expr_stmt|;
name|error
operator|=
name|ffs_balloc_ufs1
argument_list|(
name|snapvp
argument_list|,
name|lblktosize
argument_list|(
name|fs
argument_list|,
operator|(
name|off_t
operator|)
name|lbn
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
name|BA_METAONLY
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_pflags
operator|&=
operator|~
name|TDP_COWINPROGRESS
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|indiroff
operator|=
operator|(
name|lbn
operator|-
name|NDADDR
operator|)
operator|%
name|NINDIR
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|blkno
operator|=
operator|(
operator|(
name|ufs1_daddr_t
operator|*
operator|)
operator|(
name|bp
operator|->
name|b_data
operator|)
operator|)
index|[
name|indiroff
index|]
expr_stmt|;
name|bqrelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|blkno
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|bread
argument_list|(
name|snapvp
argument_list|,
name|lbn
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
operator|&
name|bp
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
else|else
block|{
name|error
operator|=
name|ffs_balloc_ufs1
argument_list|(
name|snapvp
argument_list|,
name|lblktosize
argument_list|(
name|fs
argument_list|,
operator|(
name|off_t
operator|)
name|lbn
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|readblock
argument_list|(
name|snapvp
argument_list|,
name|bp
argument_list|,
name|lbn
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Set a snapshot inode to be a zero length file, regular files 	 * or unlinked snapshots to be completely unallocated. 	 */
name|dip
operator|=
operator|(
expr|struct
name|ufs1_dinode
operator|*
operator|)
name|bp
operator|->
name|b_data
operator|+
name|ino_to_fsbo
argument_list|(
name|fs
argument_list|,
name|cancelip
operator|->
name|i_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|expungetype
operator|==
name|BLK_NOCOPY
operator|||
name|cancelip
operator|->
name|i_effnlink
operator|==
literal|0
condition|)
name|dip
operator|->
name|di_mode
operator|=
literal|0
expr_stmt|;
name|dip
operator|->
name|di_size
operator|=
literal|0
expr_stmt|;
name|dip
operator|->
name|di_blocks
operator|=
literal|0
expr_stmt|;
name|dip
operator|->
name|di_flags
operator|&=
operator|~
name|SF_SNAPSHOT
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|dip
operator|->
name|di_db
index|[
literal|0
index|]
argument_list|,
operator|(
name|NDADDR
operator|+
name|NIADDR
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|ufs1_daddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|bdwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * Now go through and expunge all the blocks in the file 	 * using the function requested. 	 */
name|numblks
operator|=
name|howmany
argument_list|(
name|cancelip
operator|->
name|i_size
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
call|(
modifier|*
name|acctfunc
call|)
argument_list|(
name|snapvp
argument_list|,
operator|&
name|cancelip
operator|->
name|i_din1
operator|->
name|di_db
index|[
literal|0
index|]
argument_list|,
operator|&
name|cancelip
operator|->
name|i_din1
operator|->
name|di_db
index|[
name|NDADDR
index|]
argument_list|,
name|fs
argument_list|,
literal|0
argument_list|,
name|expungetype
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
call|(
modifier|*
name|acctfunc
call|)
argument_list|(
name|snapvp
argument_list|,
operator|&
name|cancelip
operator|->
name|i_din1
operator|->
name|di_ib
index|[
literal|0
index|]
argument_list|,
operator|&
name|cancelip
operator|->
name|i_din1
operator|->
name|di_ib
index|[
name|NIADDR
index|]
argument_list|,
name|fs
argument_list|,
operator|-
literal|1
argument_list|,
name|expungetype
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|blksperindir
operator|=
literal|1
expr_stmt|;
name|lbn
operator|=
operator|-
name|NDADDR
expr_stmt|;
name|len
operator|=
name|numblks
operator|-
name|NDADDR
expr_stmt|;
name|rlbn
operator|=
name|NDADDR
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|len
operator|>
literal|0
operator|&&
name|i
operator|<
name|NIADDR
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|indiracct_ufs1
argument_list|(
name|snapvp
argument_list|,
name|ITOV
argument_list|(
name|cancelip
argument_list|)
argument_list|,
name|i
argument_list|,
name|cancelip
operator|->
name|i_din1
operator|->
name|di_ib
index|[
name|i
index|]
argument_list|,
name|lbn
argument_list|,
name|rlbn
argument_list|,
name|len
argument_list|,
name|blksperindir
argument_list|,
name|fs
argument_list|,
name|acctfunc
argument_list|,
name|expungetype
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|blksperindir
operator|*=
name|NINDIR
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|lbn
operator|-=
name|blksperindir
operator|+
literal|1
expr_stmt|;
name|len
operator|-=
name|blksperindir
expr_stmt|;
name|rlbn
operator|+=
name|blksperindir
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Descend an indirect block chain for vnode cancelvp accounting for all  * its indirect blocks in snapvp.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|indiracct_ufs1
argument_list|(
name|snapvp
argument_list|,
name|cancelvp
argument_list|,
name|level
argument_list|,
name|blkno
argument_list|,
name|lbn
argument_list|,
name|rlbn
argument_list|,
name|remblks
argument_list|,
name|blksperindir
argument_list|,
name|fs
argument_list|,
name|acctfunc
argument_list|,
name|expungetype
argument_list|)
decl|struct
name|vnode
modifier|*
name|snapvp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vnode
modifier|*
name|cancelvp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ufs1_daddr_t
name|blkno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ufs_lbn_t
name|lbn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ufs_lbn_t
name|rlbn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ufs_lbn_t
name|remblks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ufs_lbn_t
name|blksperindir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|acctfunc
function_decl|)
parameter_list|(
name|struct
name|vnode
modifier|*
parameter_list|,
name|ufs1_daddr_t
modifier|*
parameter_list|,
name|ufs1_daddr_t
modifier|*
parameter_list|,
name|struct
name|fs
modifier|*
parameter_list|,
name|ufs_lbn_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|expungetype
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|error
decl_stmt|,
name|num
decl_stmt|,
name|i
decl_stmt|;
name|ufs_lbn_t
name|subblksperindir
decl_stmt|;
name|struct
name|indir
name|indirs
index|[
name|NIADDR
operator|+
literal|2
index|]
decl_stmt|;
name|ufs1_daddr_t
name|last
decl_stmt|,
modifier|*
name|bap
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
name|blkno
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|expungetype
operator|==
name|BLK_NOCOPY
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|panic
argument_list|(
literal|"indiracct_ufs1: missing indir"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|ufs_getlbns
argument_list|(
name|cancelvp
argument_list|,
name|rlbn
argument_list|,
name|indirs
argument_list|,
operator|&
name|num
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|lbn
operator|!=
name|indirs
index|[
name|num
operator|-
literal|1
operator|-
name|level
index|]
operator|.
name|in_lbn
operator|||
name|num
operator|<
literal|2
condition|)
name|panic
argument_list|(
literal|"indiracct_ufs1: botched params"
argument_list|)
expr_stmt|;
comment|/* 	 * We have to expand bread here since it will deadlock looking 	 * up the block number for any blocks that are not in the cache. 	 */
name|bp
operator|=
name|getblk
argument_list|(
name|cancelvp
argument_list|,
name|lbn
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_blkno
operator|=
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|blkno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_DONE
operator||
name|B_DELWRI
operator|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|error
operator|=
name|readblock
argument_list|(
name|cancelvp
argument_list|,
name|bp
argument_list|,
name|fragstoblks
argument_list|(
name|fs
argument_list|,
name|blkno
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Account for the block pointers in this indirect block. 	 */
name|last
operator|=
name|howmany
argument_list|(
name|remblks
argument_list|,
name|blksperindir
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
operator|>
name|NINDIR
argument_list|(
name|fs
argument_list|)
condition|)
name|last
operator|=
name|NINDIR
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|bap
argument_list|,
name|ufs1_daddr_t
operator|*
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
operator|(
name|caddr_t
operator|)
name|bap
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
name|bqrelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|acctfunc
call|)
argument_list|(
name|snapvp
argument_list|,
operator|&
name|bap
index|[
literal|0
index|]
argument_list|,
operator|&
name|bap
index|[
name|last
index|]
argument_list|,
name|fs
argument_list|,
name|level
operator|==
literal|0
condition|?
name|rlbn
else|:
operator|-
literal|1
argument_list|,
name|expungetype
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|level
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Account for the block pointers in each of the indirect blocks 	 * in the levels below us. 	 */
name|subblksperindir
operator|=
name|blksperindir
operator|/
name|NINDIR
argument_list|(
name|fs
argument_list|)
expr_stmt|;
for|for
control|(
name|lbn
operator|++
operator|,
name|level
operator|--
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|last
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|indiracct_ufs1
argument_list|(
name|snapvp
argument_list|,
name|cancelvp
argument_list|,
name|level
argument_list|,
name|bap
index|[
name|i
index|]
argument_list|,
name|lbn
argument_list|,
name|rlbn
argument_list|,
name|remblks
argument_list|,
name|subblksperindir
argument_list|,
name|fs
argument_list|,
name|acctfunc
argument_list|,
name|expungetype
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|rlbn
operator|+=
name|blksperindir
expr_stmt|;
name|lbn
operator|-=
name|blksperindir
expr_stmt|;
name|remblks
operator|-=
name|blksperindir
expr_stmt|;
block|}
name|out
label|:
name|FREE
argument_list|(
name|bap
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Do both snap accounting and map accounting.  */
end_comment

begin_function
specifier|static
name|int
name|fullacct_ufs1
parameter_list|(
name|vp
parameter_list|,
name|oldblkp
parameter_list|,
name|lastblkp
parameter_list|,
name|fs
parameter_list|,
name|lblkno
parameter_list|,
name|exptype
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|ufs1_daddr_t
modifier|*
name|oldblkp
decl_stmt|,
decl|*
name|lastblkp
decl_stmt|;
end_function

begin_decl_stmt
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ufs_lbn_t
name|lblkno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|exptype
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* BLK_SNAP or BLK_NOCOPY */
end_comment

begin_block
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|snapacct_ufs1
argument_list|(
name|vp
argument_list|,
name|oldblkp
argument_list|,
name|lastblkp
argument_list|,
name|fs
argument_list|,
name|lblkno
argument_list|,
name|exptype
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
name|mapacct_ufs1
argument_list|(
name|vp
argument_list|,
name|oldblkp
argument_list|,
name|lastblkp
argument_list|,
name|fs
argument_list|,
name|lblkno
argument_list|,
name|exptype
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Identify a set of blocks allocated in a snapshot inode.  */
end_comment

begin_function
specifier|static
name|int
name|snapacct_ufs1
parameter_list|(
name|vp
parameter_list|,
name|oldblkp
parameter_list|,
name|lastblkp
parameter_list|,
name|fs
parameter_list|,
name|lblkno
parameter_list|,
name|expungetype
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|ufs1_daddr_t
modifier|*
name|oldblkp
decl_stmt|,
decl|*
name|lastblkp
decl_stmt|;
end_function

begin_decl_stmt
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ufs_lbn_t
name|lblkno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|expungetype
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* BLK_SNAP or BLK_NOCOPY */
end_comment

begin_block
block|{
name|struct
name|inode
modifier|*
name|ip
init|=
name|VTOI
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|ufs1_daddr_t
name|blkno
decl_stmt|,
modifier|*
name|blkp
decl_stmt|;
name|ufs_lbn_t
name|lbn
decl_stmt|;
name|struct
name|buf
modifier|*
name|ibp
decl_stmt|;
name|int
name|error
decl_stmt|;
for|for
control|(
init|;
name|oldblkp
operator|<
name|lastblkp
condition|;
name|oldblkp
operator|++
control|)
block|{
name|blkno
operator|=
operator|*
name|oldblkp
expr_stmt|;
if|if
condition|(
name|blkno
operator|==
literal|0
operator|||
name|blkno
operator|==
name|BLK_NOCOPY
operator|||
name|blkno
operator|==
name|BLK_SNAP
condition|)
continue|continue;
name|lbn
operator|=
name|fragstoblks
argument_list|(
name|fs
argument_list|,
name|blkno
argument_list|)
expr_stmt|;
if|if
condition|(
name|lbn
operator|<
name|NDADDR
condition|)
block|{
name|blkp
operator|=
operator|&
name|ip
operator|->
name|i_din1
operator|->
name|di_db
index|[
name|lbn
index|]
expr_stmt|;
name|ip
operator|->
name|i_flag
operator||=
name|IN_CHANGE
operator||
name|IN_UPDATE
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|ffs_balloc_ufs1
argument_list|(
name|vp
argument_list|,
name|lblktosize
argument_list|(
name|fs
argument_list|,
operator|(
name|off_t
operator|)
name|lbn
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
name|BA_METAONLY
argument_list|,
operator|&
name|ibp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|blkp
operator|=
operator|&
operator|(
operator|(
name|ufs1_daddr_t
operator|*
operator|)
operator|(
name|ibp
operator|->
name|b_data
operator|)
operator|)
index|[
operator|(
name|lbn
operator|-
name|NDADDR
operator|)
operator|%
name|NINDIR
argument_list|(
name|fs
argument_list|)
index|]
expr_stmt|;
block|}
comment|/* 		 * If we are expunging a snapshot vnode and we 		 * find a block marked BLK_NOCOPY, then it is 		 * one that has been allocated to this snapshot after 		 * we took our current snapshot and can be ignored. 		 */
if|if
condition|(
name|expungetype
operator|==
name|BLK_SNAP
operator|&&
operator|*
name|blkp
operator|==
name|BLK_NOCOPY
condition|)
block|{
if|if
condition|(
name|lbn
operator|>=
name|NDADDR
condition|)
name|brelse
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|blkp
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"snapacct_ufs1: bad block"
argument_list|)
expr_stmt|;
operator|*
name|blkp
operator|=
name|expungetype
expr_stmt|;
if|if
condition|(
name|lbn
operator|>=
name|NDADDR
condition|)
name|bdwrite
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Account for a set of blocks allocated in a snapshot inode.  */
end_comment

begin_function
specifier|static
name|int
name|mapacct_ufs1
parameter_list|(
name|vp
parameter_list|,
name|oldblkp
parameter_list|,
name|lastblkp
parameter_list|,
name|fs
parameter_list|,
name|lblkno
parameter_list|,
name|expungetype
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|ufs1_daddr_t
modifier|*
name|oldblkp
decl_stmt|,
decl|*
name|lastblkp
decl_stmt|;
end_function

begin_decl_stmt
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ufs_lbn_t
name|lblkno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|expungetype
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|ufs1_daddr_t
name|blkno
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|ino_t
name|inum
decl_stmt|;
name|int
name|acctit
decl_stmt|;
name|ip
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|inum
operator|=
name|ip
operator|->
name|i_number
expr_stmt|;
if|if
condition|(
name|lblkno
operator|==
operator|-
literal|1
condition|)
name|acctit
operator|=
literal|0
expr_stmt|;
else|else
name|acctit
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
name|oldblkp
operator|<
name|lastblkp
condition|;
name|oldblkp
operator|++
operator|,
name|lblkno
operator|++
control|)
block|{
name|blkno
operator|=
operator|*
name|oldblkp
expr_stmt|;
if|if
condition|(
name|blkno
operator|==
literal|0
operator|||
name|blkno
operator|==
name|BLK_NOCOPY
condition|)
continue|continue;
if|if
condition|(
name|acctit
operator|&&
name|expungetype
operator|==
name|BLK_SNAP
operator|&&
name|blkno
operator|!=
name|BLK_SNAP
condition|)
operator|*
name|ip
operator|->
name|i_snapblklist
operator|++
operator|=
name|lblkno
expr_stmt|;
if|if
condition|(
name|blkno
operator|==
name|BLK_SNAP
condition|)
name|blkno
operator|=
name|blkstofrags
argument_list|(
name|fs
argument_list|,
name|lblkno
argument_list|)
expr_stmt|;
name|ffs_blkfree
argument_list|(
name|ip
operator|->
name|i_ump
argument_list|,
name|fs
argument_list|,
name|vp
argument_list|,
name|blkno
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|inum
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Before expunging a snapshot inode, note all the  * blocks that it claims with BLK_SNAP so that fsck will  * be able to account for those blocks properly and so  * that this snapshot knows that it need not copy them  * if the other snapshot holding them is freed. This code  * is reproduced once each for UFS1 and UFS2.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|expunge_ufs2
argument_list|(
name|snapvp
argument_list|,
name|cancelip
argument_list|,
name|fs
argument_list|,
name|acctfunc
argument_list|,
name|expungetype
argument_list|)
decl|struct
name|vnode
modifier|*
name|snapvp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|inode
modifier|*
name|cancelip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|acctfunc
function_decl|)
parameter_list|(
name|struct
name|vnode
modifier|*
parameter_list|,
name|ufs2_daddr_t
modifier|*
parameter_list|,
name|ufs2_daddr_t
modifier|*
parameter_list|,
name|struct
name|fs
modifier|*
parameter_list|,
name|ufs_lbn_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|expungetype
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|error
decl_stmt|,
name|indiroff
decl_stmt|;
name|ufs_lbn_t
name|lbn
decl_stmt|,
name|rlbn
decl_stmt|;
name|ufs2_daddr_t
name|len
decl_stmt|,
name|blkno
decl_stmt|,
name|numblks
decl_stmt|,
name|blksperindir
decl_stmt|;
name|struct
name|ufs2_dinode
modifier|*
name|dip
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
comment|/* 	 * Prepare to expunge the inode. If its inode block has not 	 * yet been copied, then allocate and fill the copy. 	 */
name|lbn
operator|=
name|fragstoblks
argument_list|(
name|fs
argument_list|,
name|ino_to_fsba
argument_list|(
name|fs
argument_list|,
name|cancelip
operator|->
name|i_number
argument_list|)
argument_list|)
expr_stmt|;
name|blkno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lbn
operator|<
name|NDADDR
condition|)
block|{
name|blkno
operator|=
name|VTOI
argument_list|(
name|snapvp
argument_list|)
operator|->
name|i_din2
operator|->
name|di_db
index|[
name|lbn
index|]
expr_stmt|;
block|}
else|else
block|{
name|td
operator|->
name|td_pflags
operator||=
name|TDP_COWINPROGRESS
expr_stmt|;
name|error
operator|=
name|ffs_balloc_ufs2
argument_list|(
name|snapvp
argument_list|,
name|lblktosize
argument_list|(
name|fs
argument_list|,
operator|(
name|off_t
operator|)
name|lbn
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
name|BA_METAONLY
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_pflags
operator|&=
operator|~
name|TDP_COWINPROGRESS
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|indiroff
operator|=
operator|(
name|lbn
operator|-
name|NDADDR
operator|)
operator|%
name|NINDIR
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|blkno
operator|=
operator|(
operator|(
name|ufs2_daddr_t
operator|*
operator|)
operator|(
name|bp
operator|->
name|b_data
operator|)
operator|)
index|[
name|indiroff
index|]
expr_stmt|;
name|bqrelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|blkno
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|bread
argument_list|(
name|snapvp
argument_list|,
name|lbn
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
operator|&
name|bp
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
else|else
block|{
name|error
operator|=
name|ffs_balloc_ufs2
argument_list|(
name|snapvp
argument_list|,
name|lblktosize
argument_list|(
name|fs
argument_list|,
operator|(
name|off_t
operator|)
name|lbn
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|readblock
argument_list|(
name|snapvp
argument_list|,
name|bp
argument_list|,
name|lbn
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Set a snapshot inode to be a zero length file, regular files 	 * to be completely unallocated. 	 */
name|dip
operator|=
operator|(
expr|struct
name|ufs2_dinode
operator|*
operator|)
name|bp
operator|->
name|b_data
operator|+
name|ino_to_fsbo
argument_list|(
name|fs
argument_list|,
name|cancelip
operator|->
name|i_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|expungetype
operator|==
name|BLK_NOCOPY
condition|)
name|dip
operator|->
name|di_mode
operator|=
literal|0
expr_stmt|;
name|dip
operator|->
name|di_size
operator|=
literal|0
expr_stmt|;
name|dip
operator|->
name|di_blocks
operator|=
literal|0
expr_stmt|;
name|dip
operator|->
name|di_flags
operator|&=
operator|~
name|SF_SNAPSHOT
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|dip
operator|->
name|di_db
index|[
literal|0
index|]
argument_list|,
operator|(
name|NDADDR
operator|+
name|NIADDR
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|ufs2_daddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|bdwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * Now go through and expunge all the blocks in the file 	 * using the function requested. 	 */
name|numblks
operator|=
name|howmany
argument_list|(
name|cancelip
operator|->
name|i_size
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
call|(
modifier|*
name|acctfunc
call|)
argument_list|(
name|snapvp
argument_list|,
operator|&
name|cancelip
operator|->
name|i_din2
operator|->
name|di_db
index|[
literal|0
index|]
argument_list|,
operator|&
name|cancelip
operator|->
name|i_din2
operator|->
name|di_db
index|[
name|NDADDR
index|]
argument_list|,
name|fs
argument_list|,
literal|0
argument_list|,
name|expungetype
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
call|(
modifier|*
name|acctfunc
call|)
argument_list|(
name|snapvp
argument_list|,
operator|&
name|cancelip
operator|->
name|i_din2
operator|->
name|di_ib
index|[
literal|0
index|]
argument_list|,
operator|&
name|cancelip
operator|->
name|i_din2
operator|->
name|di_ib
index|[
name|NIADDR
index|]
argument_list|,
name|fs
argument_list|,
operator|-
literal|1
argument_list|,
name|expungetype
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|blksperindir
operator|=
literal|1
expr_stmt|;
name|lbn
operator|=
operator|-
name|NDADDR
expr_stmt|;
name|len
operator|=
name|numblks
operator|-
name|NDADDR
expr_stmt|;
name|rlbn
operator|=
name|NDADDR
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|len
operator|>
literal|0
operator|&&
name|i
operator|<
name|NIADDR
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|indiracct_ufs2
argument_list|(
name|snapvp
argument_list|,
name|ITOV
argument_list|(
name|cancelip
argument_list|)
argument_list|,
name|i
argument_list|,
name|cancelip
operator|->
name|i_din2
operator|->
name|di_ib
index|[
name|i
index|]
argument_list|,
name|lbn
argument_list|,
name|rlbn
argument_list|,
name|len
argument_list|,
name|blksperindir
argument_list|,
name|fs
argument_list|,
name|acctfunc
argument_list|,
name|expungetype
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|blksperindir
operator|*=
name|NINDIR
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|lbn
operator|-=
name|blksperindir
operator|+
literal|1
expr_stmt|;
name|len
operator|-=
name|blksperindir
expr_stmt|;
name|rlbn
operator|+=
name|blksperindir
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Descend an indirect block chain for vnode cancelvp accounting for all  * its indirect blocks in snapvp.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|indiracct_ufs2
argument_list|(
name|snapvp
argument_list|,
name|cancelvp
argument_list|,
name|level
argument_list|,
name|blkno
argument_list|,
name|lbn
argument_list|,
name|rlbn
argument_list|,
name|remblks
argument_list|,
name|blksperindir
argument_list|,
name|fs
argument_list|,
name|acctfunc
argument_list|,
name|expungetype
argument_list|)
decl|struct
name|vnode
modifier|*
name|snapvp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vnode
modifier|*
name|cancelvp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ufs2_daddr_t
name|blkno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ufs_lbn_t
name|lbn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ufs_lbn_t
name|rlbn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ufs_lbn_t
name|remblks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ufs_lbn_t
name|blksperindir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|acctfunc
function_decl|)
parameter_list|(
name|struct
name|vnode
modifier|*
parameter_list|,
name|ufs2_daddr_t
modifier|*
parameter_list|,
name|ufs2_daddr_t
modifier|*
parameter_list|,
name|struct
name|fs
modifier|*
parameter_list|,
name|ufs_lbn_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|expungetype
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|error
decl_stmt|,
name|num
decl_stmt|,
name|i
decl_stmt|;
name|ufs_lbn_t
name|subblksperindir
decl_stmt|;
name|struct
name|indir
name|indirs
index|[
name|NIADDR
operator|+
literal|2
index|]
decl_stmt|;
name|ufs2_daddr_t
name|last
decl_stmt|,
modifier|*
name|bap
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
name|blkno
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|expungetype
operator|==
name|BLK_NOCOPY
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|panic
argument_list|(
literal|"indiracct_ufs2: missing indir"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|ufs_getlbns
argument_list|(
name|cancelvp
argument_list|,
name|rlbn
argument_list|,
name|indirs
argument_list|,
operator|&
name|num
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|lbn
operator|!=
name|indirs
index|[
name|num
operator|-
literal|1
operator|-
name|level
index|]
operator|.
name|in_lbn
operator|||
name|num
operator|<
literal|2
condition|)
name|panic
argument_list|(
literal|"indiracct_ufs2: botched params"
argument_list|)
expr_stmt|;
comment|/* 	 * We have to expand bread here since it will deadlock looking 	 * up the block number for any blocks that are not in the cache. 	 */
name|bp
operator|=
name|getblk
argument_list|(
name|cancelvp
argument_list|,
name|lbn
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_blkno
operator|=
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|blkno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_DONE
operator||
name|B_DELWRI
operator|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|error
operator|=
name|readblock
argument_list|(
name|cancelvp
argument_list|,
name|bp
argument_list|,
name|fragstoblks
argument_list|(
name|fs
argument_list|,
name|blkno
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Account for the block pointers in this indirect block. 	 */
name|last
operator|=
name|howmany
argument_list|(
name|remblks
argument_list|,
name|blksperindir
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
operator|>
name|NINDIR
argument_list|(
name|fs
argument_list|)
condition|)
name|last
operator|=
name|NINDIR
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|bap
argument_list|,
name|ufs2_daddr_t
operator|*
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
operator|(
name|caddr_t
operator|)
name|bap
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
name|bqrelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|acctfunc
call|)
argument_list|(
name|snapvp
argument_list|,
operator|&
name|bap
index|[
literal|0
index|]
argument_list|,
operator|&
name|bap
index|[
name|last
index|]
argument_list|,
name|fs
argument_list|,
name|level
operator|==
literal|0
condition|?
name|rlbn
else|:
operator|-
literal|1
argument_list|,
name|expungetype
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|level
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Account for the block pointers in each of the indirect blocks 	 * in the levels below us. 	 */
name|subblksperindir
operator|=
name|blksperindir
operator|/
name|NINDIR
argument_list|(
name|fs
argument_list|)
expr_stmt|;
for|for
control|(
name|lbn
operator|++
operator|,
name|level
operator|--
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|last
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|indiracct_ufs2
argument_list|(
name|snapvp
argument_list|,
name|cancelvp
argument_list|,
name|level
argument_list|,
name|bap
index|[
name|i
index|]
argument_list|,
name|lbn
argument_list|,
name|rlbn
argument_list|,
name|remblks
argument_list|,
name|subblksperindir
argument_list|,
name|fs
argument_list|,
name|acctfunc
argument_list|,
name|expungetype
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|rlbn
operator|+=
name|blksperindir
expr_stmt|;
name|lbn
operator|-=
name|blksperindir
expr_stmt|;
name|remblks
operator|-=
name|blksperindir
expr_stmt|;
block|}
name|out
label|:
name|FREE
argument_list|(
name|bap
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Do both snap accounting and map accounting.  */
end_comment

begin_function
specifier|static
name|int
name|fullacct_ufs2
parameter_list|(
name|vp
parameter_list|,
name|oldblkp
parameter_list|,
name|lastblkp
parameter_list|,
name|fs
parameter_list|,
name|lblkno
parameter_list|,
name|exptype
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|ufs2_daddr_t
modifier|*
name|oldblkp
decl_stmt|,
decl|*
name|lastblkp
decl_stmt|;
end_function

begin_decl_stmt
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ufs_lbn_t
name|lblkno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|exptype
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* BLK_SNAP or BLK_NOCOPY */
end_comment

begin_block
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|snapacct_ufs2
argument_list|(
name|vp
argument_list|,
name|oldblkp
argument_list|,
name|lastblkp
argument_list|,
name|fs
argument_list|,
name|lblkno
argument_list|,
name|exptype
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
name|mapacct_ufs2
argument_list|(
name|vp
argument_list|,
name|oldblkp
argument_list|,
name|lastblkp
argument_list|,
name|fs
argument_list|,
name|lblkno
argument_list|,
name|exptype
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Identify a set of blocks allocated in a snapshot inode.  */
end_comment

begin_function
specifier|static
name|int
name|snapacct_ufs2
parameter_list|(
name|vp
parameter_list|,
name|oldblkp
parameter_list|,
name|lastblkp
parameter_list|,
name|fs
parameter_list|,
name|lblkno
parameter_list|,
name|expungetype
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|ufs2_daddr_t
modifier|*
name|oldblkp
decl_stmt|,
decl|*
name|lastblkp
decl_stmt|;
end_function

begin_decl_stmt
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ufs_lbn_t
name|lblkno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|expungetype
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* BLK_SNAP or BLK_NOCOPY */
end_comment

begin_block
block|{
name|struct
name|inode
modifier|*
name|ip
init|=
name|VTOI
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|ufs2_daddr_t
name|blkno
decl_stmt|,
modifier|*
name|blkp
decl_stmt|;
name|ufs_lbn_t
name|lbn
decl_stmt|;
name|struct
name|buf
modifier|*
name|ibp
decl_stmt|;
name|int
name|error
decl_stmt|;
for|for
control|(
init|;
name|oldblkp
operator|<
name|lastblkp
condition|;
name|oldblkp
operator|++
control|)
block|{
name|blkno
operator|=
operator|*
name|oldblkp
expr_stmt|;
if|if
condition|(
name|blkno
operator|==
literal|0
operator|||
name|blkno
operator|==
name|BLK_NOCOPY
operator|||
name|blkno
operator|==
name|BLK_SNAP
condition|)
continue|continue;
name|lbn
operator|=
name|fragstoblks
argument_list|(
name|fs
argument_list|,
name|blkno
argument_list|)
expr_stmt|;
if|if
condition|(
name|lbn
operator|<
name|NDADDR
condition|)
block|{
name|blkp
operator|=
operator|&
name|ip
operator|->
name|i_din2
operator|->
name|di_db
index|[
name|lbn
index|]
expr_stmt|;
name|ip
operator|->
name|i_flag
operator||=
name|IN_CHANGE
operator||
name|IN_UPDATE
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|ffs_balloc_ufs2
argument_list|(
name|vp
argument_list|,
name|lblktosize
argument_list|(
name|fs
argument_list|,
operator|(
name|off_t
operator|)
name|lbn
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
name|BA_METAONLY
argument_list|,
operator|&
name|ibp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|blkp
operator|=
operator|&
operator|(
operator|(
name|ufs2_daddr_t
operator|*
operator|)
operator|(
name|ibp
operator|->
name|b_data
operator|)
operator|)
index|[
operator|(
name|lbn
operator|-
name|NDADDR
operator|)
operator|%
name|NINDIR
argument_list|(
name|fs
argument_list|)
index|]
expr_stmt|;
block|}
comment|/* 		 * If we are expunging a snapshot vnode and we 		 * find a block marked BLK_NOCOPY, then it is 		 * one that has been allocated to this snapshot after 		 * we took our current snapshot and can be ignored. 		 */
if|if
condition|(
name|expungetype
operator|==
name|BLK_SNAP
operator|&&
operator|*
name|blkp
operator|==
name|BLK_NOCOPY
condition|)
block|{
if|if
condition|(
name|lbn
operator|>=
name|NDADDR
condition|)
name|brelse
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|blkp
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"snapacct_ufs2: bad block"
argument_list|)
expr_stmt|;
operator|*
name|blkp
operator|=
name|expungetype
expr_stmt|;
if|if
condition|(
name|lbn
operator|>=
name|NDADDR
condition|)
name|bdwrite
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Account for a set of blocks allocated in a snapshot inode.  */
end_comment

begin_function
specifier|static
name|int
name|mapacct_ufs2
parameter_list|(
name|vp
parameter_list|,
name|oldblkp
parameter_list|,
name|lastblkp
parameter_list|,
name|fs
parameter_list|,
name|lblkno
parameter_list|,
name|expungetype
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|ufs2_daddr_t
modifier|*
name|oldblkp
decl_stmt|,
decl|*
name|lastblkp
decl_stmt|;
end_function

begin_decl_stmt
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ufs_lbn_t
name|lblkno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|expungetype
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|ufs2_daddr_t
name|blkno
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|ino_t
name|inum
decl_stmt|;
name|int
name|acctit
decl_stmt|;
name|ip
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|inum
operator|=
name|ip
operator|->
name|i_number
expr_stmt|;
if|if
condition|(
name|lblkno
operator|==
operator|-
literal|1
condition|)
name|acctit
operator|=
literal|0
expr_stmt|;
else|else
name|acctit
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
name|oldblkp
operator|<
name|lastblkp
condition|;
name|oldblkp
operator|++
operator|,
name|lblkno
operator|++
control|)
block|{
name|blkno
operator|=
operator|*
name|oldblkp
expr_stmt|;
if|if
condition|(
name|blkno
operator|==
literal|0
operator|||
name|blkno
operator|==
name|BLK_NOCOPY
condition|)
continue|continue;
if|if
condition|(
name|acctit
operator|&&
name|expungetype
operator|==
name|BLK_SNAP
operator|&&
name|blkno
operator|!=
name|BLK_SNAP
condition|)
operator|*
name|ip
operator|->
name|i_snapblklist
operator|++
operator|=
name|lblkno
expr_stmt|;
if|if
condition|(
name|blkno
operator|==
name|BLK_SNAP
condition|)
name|blkno
operator|=
name|blkstofrags
argument_list|(
name|fs
argument_list|,
name|lblkno
argument_list|)
expr_stmt|;
name|ffs_blkfree
argument_list|(
name|ip
operator|->
name|i_ump
argument_list|,
name|fs
argument_list|,
name|vp
argument_list|,
name|blkno
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|inum
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Decrement extra reference on snapshot when last name is removed.  * It will not be freed until the last open reference goes away.  */
end_comment

begin_function
name|void
name|ffs_snapgone
parameter_list|(
name|ip
parameter_list|)
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
block|{
name|struct
name|inode
modifier|*
name|xp
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|int
name|snaploc
decl_stmt|;
name|struct
name|snapdata
modifier|*
name|sn
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
comment|/* 	 * Find snapshot in incore list. 	 */
name|xp
operator|=
name|NULL
expr_stmt|;
name|sn
operator|=
name|ip
operator|->
name|i_devvp
operator|->
name|v_rdev
operator|->
name|si_snapdata
expr_stmt|;
if|if
condition|(
name|sn
operator|!=
name|NULL
condition|)
name|TAILQ_FOREACH
argument_list|(
argument|xp
argument_list|,
argument|&sn->sn_head
argument_list|,
argument|i_nextsnap
argument_list|)
if|if
condition|(
name|xp
operator|==
name|ip
condition|)
break|break;
if|if
condition|(
name|xp
operator|!=
name|NULL
condition|)
name|vrele
argument_list|(
name|ITOV
argument_list|(
name|ip
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|snapdebug
condition|)
name|printf
argument_list|(
literal|"ffs_snapgone: lost snapshot vnode %d\n"
argument_list|,
name|ip
operator|->
name|i_number
argument_list|)
expr_stmt|;
comment|/* 	 * Delete snapshot inode from superblock. Keep list dense. 	 */
name|fs
operator|=
name|ip
operator|->
name|i_fs
expr_stmt|;
name|ump
operator|=
name|ip
operator|->
name|i_ump
expr_stmt|;
name|UFS_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
for|for
control|(
name|snaploc
operator|=
literal|0
init|;
name|snaploc
operator|<
name|FSMAXSNAP
condition|;
name|snaploc
operator|++
control|)
if|if
condition|(
name|fs
operator|->
name|fs_snapinum
index|[
name|snaploc
index|]
operator|==
name|ip
operator|->
name|i_number
condition|)
break|break;
if|if
condition|(
name|snaploc
operator|<
name|FSMAXSNAP
condition|)
block|{
for|for
control|(
name|snaploc
operator|++
init|;
name|snaploc
operator|<
name|FSMAXSNAP
condition|;
name|snaploc
operator|++
control|)
block|{
if|if
condition|(
name|fs
operator|->
name|fs_snapinum
index|[
name|snaploc
index|]
operator|==
literal|0
condition|)
break|break;
name|fs
operator|->
name|fs_snapinum
index|[
name|snaploc
operator|-
literal|1
index|]
operator|=
name|fs
operator|->
name|fs_snapinum
index|[
name|snaploc
index|]
expr_stmt|;
block|}
name|fs
operator|->
name|fs_snapinum
index|[
name|snaploc
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|UFS_UNLOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Prepare a snapshot file for being removed.  */
end_comment

begin_function
name|void
name|ffs_snapremove
parameter_list|(
name|vp
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
block|{
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|struct
name|vnode
modifier|*
name|devvp
decl_stmt|;
name|struct
name|buf
modifier|*
name|ibp
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|ufs2_daddr_t
name|numblks
decl_stmt|,
name|blkno
decl_stmt|,
name|dblk
decl_stmt|;
name|int
name|error
decl_stmt|,
name|loc
decl_stmt|,
name|last
decl_stmt|;
name|struct
name|snapdata
modifier|*
name|sn
decl_stmt|;
name|ip
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|fs
operator|=
name|ip
operator|->
name|i_fs
expr_stmt|;
name|devvp
operator|=
name|ip
operator|->
name|i_devvp
expr_stmt|;
comment|/* 	 * If active, delete from incore list (this snapshot may 	 * already have been in the process of being deleted, so 	 * would not have been active). 	 * 	 * Clear copy-on-write flag if last snapshot. 	 */
name|VI_LOCK
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_nextsnap
operator|.
name|tqe_prev
operator|!=
literal|0
condition|)
block|{
name|sn
operator|=
name|devvp
operator|->
name|v_rdev
operator|->
name|si_snapdata
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sn
operator|->
name|sn_head
argument_list|,
name|ip
argument_list|,
name|i_nextsnap
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_nextsnap
operator|.
name|tqe_prev
operator|=
literal|0
expr_stmt|;
name|VI_UNLOCK
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
name|lockmgr
argument_list|(
operator|&
name|vp
operator|->
name|v_lock
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|NULL
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|VI_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|vp
operator|->
name|v_vnlock
operator|==
operator|&
name|sn
operator|->
name|sn_lock
argument_list|,
operator|(
literal|"ffs_snapremove: lost lock mutation"
operator|)
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_vnlock
operator|=
operator|&
name|vp
operator|->
name|v_lock
expr_stmt|;
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|VI_LOCK
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
name|lockmgr
argument_list|(
operator|&
name|sn
operator|->
name|sn_lock
argument_list|,
name|LK_RELEASE
argument_list|,
name|NULL
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|try_free_snapdata
argument_list|(
name|devvp
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
else|else
name|VI_UNLOCK
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
comment|/* 	 * Clear all BLK_NOCOPY fields. Pass any block claims to other 	 * snapshots that want them (see ffs_snapblkfree below). 	 */
for|for
control|(
name|blkno
operator|=
literal|1
init|;
name|blkno
operator|<
name|NDADDR
condition|;
name|blkno
operator|++
control|)
block|{
name|dblk
operator|=
name|DIP
argument_list|(
name|ip
argument_list|,
name|i_db
index|[
name|blkno
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|dblk
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|dblk
operator|==
name|BLK_NOCOPY
operator|||
name|dblk
operator|==
name|BLK_SNAP
condition|)
name|DIP_SET
argument_list|(
name|ip
argument_list|,
name|i_db
index|[
name|blkno
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|dblk
operator|==
name|blkstofrags
argument_list|(
name|fs
argument_list|,
name|blkno
argument_list|)
operator|&&
name|ffs_snapblkfree
argument_list|(
name|fs
argument_list|,
name|ip
operator|->
name|i_devvp
argument_list|,
name|dblk
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|ip
operator|->
name|i_number
argument_list|)
operator|)
condition|)
block|{
name|DIP_SET
argument_list|(
name|ip
argument_list|,
name|i_blocks
argument_list|,
name|DIP
argument_list|(
name|ip
argument_list|,
name|i_blocks
argument_list|)
operator|-
name|btodb
argument_list|(
name|fs
operator|->
name|fs_bsize
argument_list|)
argument_list|)
expr_stmt|;
name|DIP_SET
argument_list|(
name|ip
argument_list|,
name|i_db
index|[
name|blkno
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|numblks
operator|=
name|howmany
argument_list|(
name|ip
operator|->
name|i_size
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
for|for
control|(
name|blkno
operator|=
name|NDADDR
init|;
name|blkno
operator|<
name|numblks
condition|;
name|blkno
operator|+=
name|NINDIR
argument_list|(
name|fs
argument_list|)
control|)
block|{
name|error
operator|=
name|UFS_BALLOC
argument_list|(
name|vp
argument_list|,
name|lblktosize
argument_list|(
name|fs
argument_list|,
operator|(
name|off_t
operator|)
name|blkno
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
name|BA_METAONLY
argument_list|,
operator|&
name|ibp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
continue|continue;
if|if
condition|(
name|fs
operator|->
name|fs_size
operator|-
name|blkno
operator|>
name|NINDIR
argument_list|(
name|fs
argument_list|)
condition|)
name|last
operator|=
name|NINDIR
argument_list|(
name|fs
argument_list|)
expr_stmt|;
else|else
name|last
operator|=
name|fs
operator|->
name|fs_size
operator|-
name|blkno
expr_stmt|;
for|for
control|(
name|loc
operator|=
literal|0
init|;
name|loc
operator|<
name|last
condition|;
name|loc
operator|++
control|)
block|{
if|if
condition|(
name|ip
operator|->
name|i_ump
operator|->
name|um_fstype
operator|==
name|UFS1
condition|)
block|{
name|dblk
operator|=
operator|(
operator|(
name|ufs1_daddr_t
operator|*
operator|)
operator|(
name|ibp
operator|->
name|b_data
operator|)
operator|)
index|[
name|loc
index|]
expr_stmt|;
if|if
condition|(
name|dblk
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|dblk
operator|==
name|BLK_NOCOPY
operator|||
name|dblk
operator|==
name|BLK_SNAP
condition|)
operator|(
operator|(
name|ufs1_daddr_t
operator|*
operator|)
operator|(
name|ibp
operator|->
name|b_data
operator|)
operator|)
index|[
name|loc
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|dblk
operator|==
name|blkstofrags
argument_list|(
name|fs
argument_list|,
name|blkno
argument_list|)
operator|&&
name|ffs_snapblkfree
argument_list|(
name|fs
argument_list|,
name|ip
operator|->
name|i_devvp
argument_list|,
name|dblk
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|ip
operator|->
name|i_number
argument_list|)
operator|)
condition|)
block|{
name|ip
operator|->
name|i_din1
operator|->
name|di_blocks
operator|-=
name|btodb
argument_list|(
name|fs
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
operator|(
operator|(
name|ufs1_daddr_t
operator|*
operator|)
operator|(
name|ibp
operator|->
name|b_data
operator|)
operator|)
index|[
name|loc
index|]
operator|=
literal|0
expr_stmt|;
block|}
continue|continue;
block|}
name|dblk
operator|=
operator|(
operator|(
name|ufs2_daddr_t
operator|*
operator|)
operator|(
name|ibp
operator|->
name|b_data
operator|)
operator|)
index|[
name|loc
index|]
expr_stmt|;
if|if
condition|(
name|dblk
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|dblk
operator|==
name|BLK_NOCOPY
operator|||
name|dblk
operator|==
name|BLK_SNAP
condition|)
operator|(
operator|(
name|ufs2_daddr_t
operator|*
operator|)
operator|(
name|ibp
operator|->
name|b_data
operator|)
operator|)
index|[
name|loc
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|dblk
operator|==
name|blkstofrags
argument_list|(
name|fs
argument_list|,
name|blkno
argument_list|)
operator|&&
name|ffs_snapblkfree
argument_list|(
name|fs
argument_list|,
name|ip
operator|->
name|i_devvp
argument_list|,
name|dblk
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|ip
operator|->
name|i_number
argument_list|)
operator|)
condition|)
block|{
name|ip
operator|->
name|i_din2
operator|->
name|di_blocks
operator|-=
name|btodb
argument_list|(
name|fs
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
operator|(
operator|(
name|ufs2_daddr_t
operator|*
operator|)
operator|(
name|ibp
operator|->
name|b_data
operator|)
operator|)
index|[
name|loc
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|bawrite
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Clear snapshot flag and drop reference. 	 */
name|ip
operator|->
name|i_flags
operator|&=
operator|~
name|SF_SNAPSHOT
expr_stmt|;
name|DIP_SET
argument_list|(
name|ip
argument_list|,
name|i_flags
argument_list|,
name|ip
operator|->
name|i_flags
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_flag
operator||=
name|IN_CHANGE
operator||
name|IN_UPDATE
expr_stmt|;
ifdef|#
directive|ifdef
name|QUOTA
comment|/* 	 * Reenable disk quotas for ex-snapshot file. 	 */
if|if
condition|(
operator|!
name|getinoquota
argument_list|(
name|ip
argument_list|)
condition|)
operator|(
name|void
operator|)
name|chkdq
argument_list|(
name|ip
argument_list|,
name|DIP
argument_list|(
name|ip
argument_list|,
name|i_blocks
argument_list|)
argument_list|,
name|KERNCRED
argument_list|,
name|FORCE
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Notification that a block is being freed. Return zero if the free  * should be allowed to proceed. Return non-zero if the snapshot file  * wants to claim the block. The block will be claimed if it is an  * uncopied part of one of the snapshots. It will be freed if it is  * either a BLK_NOCOPY or has already been copied in all of the snapshots.  * If a fragment is being freed, then all snapshots that care about  * it must make a copy since a snapshot file can only claim full sized  * blocks. Note that if more than one snapshot file maps the block,  * we can pick one at random to claim it. Since none of the snapshots  * can change, we are assurred that they will all see the same unmodified  * image. When deleting a snapshot file (see ffs_snapremove above), we  * must push any of these claimed blocks to one of the other snapshots  * that maps it. These claimed blocks are easily identified as they will  * have a block number equal to their logical block number within the  * snapshot. A copied block can never have this property because they  * must always have been allocated from a BLK_NOCOPY location.  */
end_comment

begin_function
name|int
name|ffs_snapblkfree
parameter_list|(
name|fs
parameter_list|,
name|devvp
parameter_list|,
name|bno
parameter_list|,
name|size
parameter_list|,
name|inum
parameter_list|)
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|struct
name|vnode
modifier|*
name|devvp
decl_stmt|;
name|ufs2_daddr_t
name|bno
decl_stmt|;
name|long
name|size
decl_stmt|;
name|ino_t
name|inum
decl_stmt|;
block|{
name|struct
name|buf
modifier|*
name|ibp
decl_stmt|,
modifier|*
name|cbp
decl_stmt|,
modifier|*
name|savedcbp
init|=
literal|0
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|NULL
decl_stmt|;
name|ufs_lbn_t
name|lbn
decl_stmt|;
name|ufs2_daddr_t
name|blkno
decl_stmt|;
name|int
name|indiroff
init|=
literal|0
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|,
name|claimedblk
init|=
literal|0
decl_stmt|;
name|struct
name|snapdata
modifier|*
name|sn
decl_stmt|;
name|lbn
operator|=
name|fragstoblks
argument_list|(
name|fs
argument_list|,
name|bno
argument_list|)
expr_stmt|;
name|retry
label|:
name|VI_LOCK
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
name|sn
operator|=
name|devvp
operator|->
name|v_rdev
operator|->
name|si_snapdata
expr_stmt|;
if|if
condition|(
name|sn
operator|==
name|NULL
condition|)
block|{
name|VI_UNLOCK
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|lockmgr
argument_list|(
operator|&
name|sn
operator|->
name|sn_lock
argument_list|,
name|LK_INTERLOCK
operator||
name|LK_EXCLUSIVE
operator||
name|LK_SLEEPFAIL
argument_list|,
name|VI_MTX
argument_list|(
name|devvp
argument_list|)
argument_list|,
name|td
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|retry
goto|;
name|TAILQ_FOREACH
argument_list|(
argument|ip
argument_list|,
argument|&sn->sn_head
argument_list|,
argument|i_nextsnap
argument_list|)
block|{
name|vp
operator|=
name|ITOV
argument_list|(
name|ip
argument_list|)
expr_stmt|;
comment|/* 		 * Lookup block being written. 		 */
if|if
condition|(
name|lbn
operator|<
name|NDADDR
condition|)
block|{
name|blkno
operator|=
name|DIP
argument_list|(
name|ip
argument_list|,
name|i_db
index|[
name|lbn
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|td
operator|->
name|td_pflags
operator||=
name|TDP_COWINPROGRESS
expr_stmt|;
name|error
operator|=
name|UFS_BALLOC
argument_list|(
name|vp
argument_list|,
name|lblktosize
argument_list|(
name|fs
argument_list|,
operator|(
name|off_t
operator|)
name|lbn
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
name|BA_METAONLY
argument_list|,
operator|&
name|ibp
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_pflags
operator|&=
operator|~
name|TDP_COWINPROGRESS
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|indiroff
operator|=
operator|(
name|lbn
operator|-
name|NDADDR
operator|)
operator|%
name|NINDIR
argument_list|(
name|fs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_ump
operator|->
name|um_fstype
operator|==
name|UFS1
condition|)
name|blkno
operator|=
operator|(
operator|(
name|ufs1_daddr_t
operator|*
operator|)
operator|(
name|ibp
operator|->
name|b_data
operator|)
operator|)
index|[
name|indiroff
index|]
expr_stmt|;
else|else
name|blkno
operator|=
operator|(
operator|(
name|ufs2_daddr_t
operator|*
operator|)
operator|(
name|ibp
operator|->
name|b_data
operator|)
operator|)
index|[
name|indiroff
index|]
expr_stmt|;
block|}
comment|/* 		 * Check to see if block needs to be copied. 		 */
if|if
condition|(
name|blkno
operator|==
literal|0
condition|)
block|{
comment|/* 			 * A block that we map is being freed. If it has not 			 * been claimed yet, we will claim or copy it (below). 			 */
name|claimedblk
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|blkno
operator|==
name|BLK_SNAP
condition|)
block|{
comment|/* 			 * No previous snapshot claimed the block, 			 * so it will be freed and become a BLK_NOCOPY 			 * (don't care) for us. 			 */
if|if
condition|(
name|claimedblk
condition|)
name|panic
argument_list|(
literal|"snapblkfree: inconsistent block type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lbn
operator|<
name|NDADDR
condition|)
block|{
name|DIP_SET
argument_list|(
name|ip
argument_list|,
name|i_db
index|[
name|lbn
index|]
argument_list|,
name|BLK_NOCOPY
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_flag
operator||=
name|IN_CHANGE
operator||
name|IN_UPDATE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ip
operator|->
name|i_ump
operator|->
name|um_fstype
operator|==
name|UFS1
condition|)
block|{
operator|(
operator|(
name|ufs1_daddr_t
operator|*
operator|)
operator|(
name|ibp
operator|->
name|b_data
operator|)
operator|)
index|[
name|indiroff
index|]
operator|=
name|BLK_NOCOPY
expr_stmt|;
name|bdwrite
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|(
name|ufs2_daddr_t
operator|*
operator|)
operator|(
name|ibp
operator|->
name|b_data
operator|)
operator|)
index|[
name|indiroff
index|]
operator|=
name|BLK_NOCOPY
expr_stmt|;
name|bdwrite
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
else|else
comment|/* BLK_NOCOPY or default */
block|{
comment|/* 			 * If the snapshot has already copied the block 			 * (default), or does not care about the block, 			 * it is not needed. 			 */
if|if
condition|(
name|lbn
operator|>=
name|NDADDR
condition|)
name|bqrelse
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * If this is a full size block, we will just grab it 		 * and assign it to the snapshot inode. Otherwise we 		 * will proceed to copy it. See explanation for this 		 * routine as to why only a single snapshot needs to 		 * claim this block. 		 */
if|if
condition|(
name|size
operator|==
name|fs
operator|->
name|fs_bsize
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|snapdebug
condition|)
name|printf
argument_list|(
literal|"%s %d lbn %jd from inum %d\n"
argument_list|,
literal|"Grabonremove: snapino"
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
operator|(
name|intmax_t
operator|)
name|lbn
argument_list|,
name|inum
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|lbn
operator|<
name|NDADDR
condition|)
block|{
name|DIP_SET
argument_list|(
name|ip
argument_list|,
name|i_db
index|[
name|lbn
index|]
argument_list|,
name|bno
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ip
operator|->
name|i_ump
operator|->
name|um_fstype
operator|==
name|UFS1
condition|)
block|{
operator|(
operator|(
name|ufs1_daddr_t
operator|*
operator|)
operator|(
name|ibp
operator|->
name|b_data
operator|)
operator|)
index|[
name|indiroff
index|]
operator|=
name|bno
expr_stmt|;
name|bdwrite
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|(
name|ufs2_daddr_t
operator|*
operator|)
operator|(
name|ibp
operator|->
name|b_data
operator|)
operator|)
index|[
name|indiroff
index|]
operator|=
name|bno
expr_stmt|;
name|bdwrite
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
block|}
name|DIP_SET
argument_list|(
name|ip
argument_list|,
name|i_blocks
argument_list|,
name|DIP
argument_list|(
name|ip
argument_list|,
name|i_blocks
argument_list|)
operator|+
name|btodb
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_flag
operator||=
name|IN_CHANGE
operator||
name|IN_UPDATE
expr_stmt|;
name|lockmgr
argument_list|(
name|vp
operator|->
name|v_vnlock
argument_list|,
name|LK_RELEASE
argument_list|,
name|NULL
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|lbn
operator|>=
name|NDADDR
condition|)
name|bqrelse
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
comment|/* 		 * Allocate the block into which to do the copy. Note that this 		 * allocation will never require any additional allocations for 		 * the snapshot inode. 		 */
name|td
operator|->
name|td_pflags
operator||=
name|TDP_COWINPROGRESS
expr_stmt|;
name|error
operator|=
name|UFS_BALLOC
argument_list|(
name|vp
argument_list|,
name|lblktosize
argument_list|(
name|fs
argument_list|,
operator|(
name|off_t
operator|)
name|lbn
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
literal|0
argument_list|,
operator|&
name|cbp
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_pflags
operator|&=
operator|~
name|TDP_COWINPROGRESS
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|snapdebug
condition|)
name|printf
argument_list|(
literal|"%s%d lbn %jd %s %d size %ld to blkno %jd\n"
argument_list|,
literal|"Copyonremove: snapino "
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
operator|(
name|intmax_t
operator|)
name|lbn
argument_list|,
literal|"for inum"
argument_list|,
name|inum
argument_list|,
name|size
argument_list|,
operator|(
name|intmax_t
operator|)
name|cbp
operator|->
name|b_blkno
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * If we have already read the old block contents, then 		 * simply copy them to the new block. Note that we need 		 * to synchronously write snapshots that have not been 		 * unlinked, and hence will be visible after a crash, 		 * to ensure their integrity. 		 */
if|if
condition|(
name|savedcbp
operator|!=
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|savedcbp
operator|->
name|b_data
argument_list|,
name|cbp
operator|->
name|b_data
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
name|bawrite
argument_list|(
name|cbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dopersistence
operator|&&
name|ip
operator|->
name|i_effnlink
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|ffs_syncvnode
argument_list|(
name|vp
argument_list|,
name|MNT_WAIT
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Otherwise, read the old block contents into the buffer. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|readblock
argument_list|(
name|vp
argument_list|,
name|cbp
argument_list|,
name|lbn
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|bzero
argument_list|(
name|cbp
operator|->
name|b_data
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
name|bawrite
argument_list|(
name|cbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dopersistence
operator|&&
name|ip
operator|->
name|i_effnlink
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|ffs_syncvnode
argument_list|(
name|vp
argument_list|,
name|MNT_WAIT
argument_list|)
expr_stmt|;
break|break;
block|}
name|savedcbp
operator|=
name|cbp
expr_stmt|;
block|}
comment|/* 	 * Note that we need to synchronously write snapshots that 	 * have not been unlinked, and hence will be visible after 	 * a crash, to ensure their integrity. 	 */
if|if
condition|(
name|savedcbp
condition|)
block|{
name|vp
operator|=
name|savedcbp
operator|->
name|b_vp
expr_stmt|;
name|bawrite
argument_list|(
name|savedcbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dopersistence
operator|&&
name|VTOI
argument_list|(
name|vp
argument_list|)
operator|->
name|i_effnlink
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|ffs_syncvnode
argument_list|(
name|vp
argument_list|,
name|MNT_WAIT
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we have been unable to allocate a block in which to do 	 * the copy, then return non-zero so that the fragment will 	 * not be freed. Although space will be lost, the snapshot 	 * will stay consistent. 	 */
name|lockmgr
argument_list|(
name|vp
operator|->
name|v_vnlock
argument_list|,
name|LK_RELEASE
argument_list|,
name|NULL
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Associate snapshot files when mounting.  */
end_comment

begin_function
name|void
name|ffs_snapshot_mount
parameter_list|(
name|mp
parameter_list|)
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
block|{
name|struct
name|ufsmount
modifier|*
name|ump
init|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
decl_stmt|;
name|struct
name|vnode
modifier|*
name|devvp
init|=
name|ump
operator|->
name|um_devvp
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
init|=
name|ump
operator|->
name|um_fs
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|snapdata
modifier|*
name|sn
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|struct
name|uio
name|auio
decl_stmt|;
name|struct
name|iovec
name|aiov
decl_stmt|;
name|void
modifier|*
name|snapblklist
decl_stmt|;
name|char
modifier|*
name|reason
decl_stmt|;
name|daddr_t
name|snaplistsize
decl_stmt|;
name|int
name|error
decl_stmt|,
name|snaploc
decl_stmt|,
name|loc
decl_stmt|;
comment|/* 	 * XXX The following needs to be set before ffs_truncate or 	 * VOP_READ can be called. 	 */
name|mp
operator|->
name|mnt_stat
operator|.
name|f_iosize
operator|=
name|fs
operator|->
name|fs_bsize
expr_stmt|;
comment|/* 	 * Process each snapshot listed in the superblock. 	 */
name|vp
operator|=
name|NULL
expr_stmt|;
name|sn
operator|=
name|devvp
operator|->
name|v_rdev
operator|->
name|si_snapdata
expr_stmt|;
for|for
control|(
name|snaploc
operator|=
literal|0
init|;
name|snaploc
operator|<
name|FSMAXSNAP
condition|;
name|snaploc
operator|++
control|)
block|{
if|if
condition|(
name|fs
operator|->
name|fs_snapinum
index|[
name|snaploc
index|]
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|error
operator|=
name|ffs_vget
argument_list|(
name|mp
argument_list|,
name|fs
operator|->
name|fs_snapinum
index|[
name|snaploc
index|]
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
operator|&
name|vp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ffs_snapshot_mount: vget failed %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ip
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ip
operator|->
name|i_flags
operator|&
name|SF_SNAPSHOT
operator|)
operator|==
literal|0
operator|||
name|ip
operator|->
name|i_size
operator|==
name|lblktosize
argument_list|(
name|fs
argument_list|,
name|howmany
argument_list|(
name|fs
operator|->
name|fs_size
argument_list|,
name|fs
operator|->
name|fs_frag
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|ip
operator|->
name|i_flags
operator|&
name|SF_SNAPSHOT
operator|)
operator|==
literal|0
condition|)
block|{
name|reason
operator|=
literal|"non-snapshot"
expr_stmt|;
block|}
else|else
block|{
name|reason
operator|=
literal|"old format snapshot"
expr_stmt|;
operator|(
name|void
operator|)
name|ffs_truncate
argument_list|(
name|vp
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
name|NOCRED
argument_list|,
name|td
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ffs_syncvnode
argument_list|(
name|vp
argument_list|,
name|MNT_WAIT
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"ffs_snapshot_mount: %s inode %d\n"
argument_list|,
name|reason
argument_list|,
name|fs
operator|->
name|fs_snapinum
index|[
name|snaploc
index|]
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|vp
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|loc
operator|=
name|snaploc
operator|+
literal|1
init|;
name|loc
operator|<
name|FSMAXSNAP
condition|;
name|loc
operator|++
control|)
block|{
if|if
condition|(
name|fs
operator|->
name|fs_snapinum
index|[
name|loc
index|]
operator|==
literal|0
condition|)
break|break;
name|fs
operator|->
name|fs_snapinum
index|[
name|loc
operator|-
literal|1
index|]
operator|=
name|fs
operator|->
name|fs_snapinum
index|[
name|loc
index|]
expr_stmt|;
block|}
name|fs
operator|->
name|fs_snapinum
index|[
name|loc
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|snaploc
operator|--
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * If there already exist snapshots on this filesystem, grab a 		 * reference to their shared lock. If this is the first snapshot 		 * on this filesystem, we need to allocate a lock for the 		 * snapshots to share. In either case, acquire the snapshot 		 * lock and give up our original private lock. 		 */
name|VI_LOCK
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sn
operator|!=
name|NULL
condition|)
block|{
name|VI_UNLOCK
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
name|VI_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_vnlock
operator|=
operator|&
name|sn
operator|->
name|sn_lock
expr_stmt|;
block|}
else|else
block|{
name|VI_UNLOCK
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
name|sn
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|sn
argument_list|,
name|M_UFSMNT
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sn
operator|->
name|sn_head
argument_list|)
expr_stmt|;
name|lockinit
argument_list|(
operator|&
name|sn
operator|->
name|sn_lock
argument_list|,
name|PVFS
argument_list|,
literal|"snaplk"
argument_list|,
name|VLKTIMEOUT
argument_list|,
name|LK_CANRECURSE
operator||
name|LK_NOSHARE
argument_list|)
expr_stmt|;
name|VI_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_vnlock
operator|=
operator|&
name|sn
operator|->
name|sn_lock
expr_stmt|;
name|devvp
operator|->
name|v_rdev
operator|->
name|si_snapdata
operator|=
name|sn
expr_stmt|;
block|}
name|lockmgr
argument_list|(
name|vp
operator|->
name|v_vnlock
argument_list|,
name|LK_INTERLOCK
operator||
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|VI_MTX
argument_list|(
name|vp
argument_list|)
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|lockmgr
argument_list|(
operator|&
name|vp
operator|->
name|v_lock
argument_list|,
name|LK_RELEASE
argument_list|,
name|NULL
argument_list|,
name|td
argument_list|)
expr_stmt|;
comment|/* 		 * Link it onto the active snapshot list. 		 */
name|VI_LOCK
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_nextsnap
operator|.
name|tqe_prev
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"ffs_snapshot_mount: %d already on list"
argument_list|,
name|ip
operator|->
name|i_number
argument_list|)
expr_stmt|;
else|else
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sn
operator|->
name|sn_head
argument_list|,
name|ip
argument_list|,
name|i_nextsnap
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_vflag
operator||=
name|VV_SYSTEM
expr_stmt|;
name|VI_UNLOCK
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * No usable snapshots found. 	 */
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * Allocate the space for the block hints list. We always want to 	 * use the list from the newest snapshot. 	 */
name|auio
operator|.
name|uio_iov
operator|=
operator|&
name|aiov
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|aiov
operator|.
name|iov_base
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|snaplistsize
expr_stmt|;
name|aiov
operator|.
name|iov_len
operator|=
sizeof|sizeof
argument_list|(
name|snaplistsize
argument_list|)
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
name|aiov
operator|.
name|iov_len
expr_stmt|;
name|auio
operator|.
name|uio_offset
operator|=
name|lblktosize
argument_list|(
name|fs
argument_list|,
name|howmany
argument_list|(
name|fs
operator|->
name|fs_size
argument_list|,
name|fs
operator|->
name|fs_frag
argument_list|)
argument_list|)
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|auio
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|auio
operator|.
name|uio_td
operator|=
name|td
expr_stmt|;
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_READ
argument_list|(
name|vp
argument_list|,
operator|&
name|auio
argument_list|,
name|IO_UNIT
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ffs_snapshot_mount: read_1 failed %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return;
block|}
name|MALLOC
argument_list|(
name|snapblklist
argument_list|,
name|void
operator|*
argument_list|,
name|snaplistsize
operator|*
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
argument_list|,
name|M_UFSMNT
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|aiov
operator|.
name|iov_base
operator|=
name|snapblklist
expr_stmt|;
name|aiov
operator|.
name|iov_len
operator|=
name|snaplistsize
operator|*
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
name|aiov
operator|.
name|iov_len
expr_stmt|;
name|auio
operator|.
name|uio_offset
operator|-=
sizeof|sizeof
argument_list|(
name|snaplistsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_READ
argument_list|(
name|vp
argument_list|,
operator|&
name|auio
argument_list|,
name|IO_UNIT
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ffs_snapshot_mount: read_2 failed %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|snapblklist
argument_list|,
name|M_UFSMNT
argument_list|)
expr_stmt|;
return|return;
block|}
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|VI_LOCK
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
name|ASSERT_VOP_LOCKED
argument_list|(
name|devvp
argument_list|,
literal|"ffs_snapshot_mount"
argument_list|)
expr_stmt|;
name|sn
operator|->
name|sn_listsize
operator|=
name|snaplistsize
expr_stmt|;
name|sn
operator|->
name|sn_blklist
operator|=
operator|(
name|daddr_t
operator|*
operator|)
name|snapblklist
expr_stmt|;
name|devvp
operator|->
name|v_vflag
operator||=
name|VV_COPYONWRITE
expr_stmt|;
name|VI_UNLOCK
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Disassociate snapshot files when unmounting.  */
end_comment

begin_function
name|void
name|ffs_snapshot_unmount
parameter_list|(
name|mp
parameter_list|)
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|devvp
init|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
operator|->
name|um_devvp
decl_stmt|;
name|struct
name|snapdata
modifier|*
name|sn
decl_stmt|;
name|struct
name|inode
modifier|*
name|xp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|VI_LOCK
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
name|sn
operator|=
name|devvp
operator|->
name|v_rdev
operator|->
name|si_snapdata
expr_stmt|;
while|while
condition|(
name|sn
operator|!=
name|NULL
operator|&&
operator|(
name|xp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sn
operator|->
name|sn_head
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|vp
operator|=
name|ITOV
argument_list|(
name|xp
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sn
operator|->
name|sn_head
argument_list|,
name|xp
argument_list|,
name|i_nextsnap
argument_list|)
expr_stmt|;
name|xp
operator|->
name|i_nextsnap
operator|.
name|tqe_prev
operator|=
literal|0
expr_stmt|;
name|lockmgr
argument_list|(
operator|&
name|sn
operator|->
name|sn_lock
argument_list|,
name|LK_INTERLOCK
operator||
name|LK_EXCLUSIVE
argument_list|,
name|VI_MTX
argument_list|(
name|devvp
argument_list|)
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|VI_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|lockmgr
argument_list|(
operator|&
name|vp
operator|->
name|v_lock
argument_list|,
name|LK_INTERLOCK
operator||
name|LK_EXCLUSIVE
argument_list|,
name|VI_MTX
argument_list|(
name|vp
argument_list|)
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|VI_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|vp
operator|->
name|v_vnlock
operator|==
operator|&
name|sn
operator|->
name|sn_lock
argument_list|,
operator|(
literal|"ffs_snapshot_unmount: lost lock mutation"
operator|)
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_vnlock
operator|=
operator|&
name|vp
operator|->
name|v_lock
expr_stmt|;
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|lockmgr
argument_list|(
operator|&
name|vp
operator|->
name|v_lock
argument_list|,
name|LK_RELEASE
argument_list|,
name|NULL
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|lockmgr
argument_list|(
operator|&
name|sn
operator|->
name|sn_lock
argument_list|,
name|LK_RELEASE
argument_list|,
name|NULL
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|xp
operator|->
name|i_effnlink
operator|>
literal|0
condition|)
name|vrele
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|VI_LOCK
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
name|sn
operator|=
name|devvp
operator|->
name|v_rdev
operator|->
name|si_snapdata
expr_stmt|;
block|}
name|try_free_snapdata
argument_list|(
name|devvp
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|ASSERT_VOP_LOCKED
argument_list|(
name|devvp
argument_list|,
literal|"ffs_snapshot_unmount"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check for need to copy block that is about to be written,  * copying the block if necessary.  */
end_comment

begin_function
name|int
name|ffs_copyonwrite
parameter_list|(
name|devvp
parameter_list|,
name|bp
parameter_list|)
name|struct
name|vnode
modifier|*
name|devvp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
name|struct
name|snapdata
modifier|*
name|sn
decl_stmt|;
name|struct
name|buf
modifier|*
name|ibp
decl_stmt|,
modifier|*
name|cbp
decl_stmt|,
modifier|*
name|savedcbp
init|=
literal|0
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
literal|0
decl_stmt|;
name|ufs2_daddr_t
name|lbn
decl_stmt|,
name|blkno
decl_stmt|,
modifier|*
name|snapblklist
decl_stmt|;
name|int
name|lower
decl_stmt|,
name|upper
decl_stmt|,
name|mid
decl_stmt|,
name|indiroff
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|int
name|launched_async_io
decl_stmt|,
name|prev_norunningbuf
decl_stmt|;
name|long
name|saved_runningbufspace
decl_stmt|;
if|if
condition|(
operator|(
name|VTOI
argument_list|(
name|bp
operator|->
name|b_vp
argument_list|)
operator|->
name|i_flags
operator|&
name|SF_SNAPSHOT
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Update on a snapshot file */
if|if
condition|(
name|td
operator|->
name|td_pflags
operator|&
name|TDP_COWINPROGRESS
condition|)
name|panic
argument_list|(
literal|"ffs_copyonwrite: recursive call"
argument_list|)
expr_stmt|;
comment|/* 	 * First check to see if it is in the preallocated list. 	 * By doing this check we avoid several potential deadlocks. 	 */
name|VI_LOCK
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
name|sn
operator|=
name|devvp
operator|->
name|v_rdev
operator|->
name|si_snapdata
expr_stmt|;
if|if
condition|(
name|sn
operator|==
name|NULL
operator|||
name|TAILQ_FIRST
argument_list|(
operator|&
name|sn
operator|->
name|sn_head
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|VI_UNLOCK
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* No snapshot */
block|}
name|ip
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sn
operator|->
name|sn_head
argument_list|)
expr_stmt|;
name|fs
operator|=
name|ip
operator|->
name|i_fs
expr_stmt|;
name|lbn
operator|=
name|fragstoblks
argument_list|(
name|fs
argument_list|,
name|dbtofsb
argument_list|(
name|fs
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|)
argument_list|)
expr_stmt|;
name|snapblklist
operator|=
name|sn
operator|->
name|sn_blklist
expr_stmt|;
name|upper
operator|=
name|sn
operator|->
name|sn_listsize
operator|-
literal|1
expr_stmt|;
name|lower
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|lower
operator|<=
name|upper
condition|)
block|{
name|mid
operator|=
operator|(
name|lower
operator|+
name|upper
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|snapblklist
index|[
name|mid
index|]
operator|==
name|lbn
condition|)
break|break;
if|if
condition|(
name|snapblklist
index|[
name|mid
index|]
operator|<
name|lbn
condition|)
name|lower
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
else|else
name|upper
operator|=
name|mid
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|lower
operator|<=
name|upper
condition|)
block|{
name|VI_UNLOCK
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|launched_async_io
operator|=
literal|0
expr_stmt|;
name|prev_norunningbuf
operator|=
name|td
operator|->
name|td_pflags
operator|&
name|TDP_NORUNNINGBUF
expr_stmt|;
comment|/* 	 * Since I/O on bp isn't yet in progress and it may be blocked 	 * for a long time waiting on snaplk, back it out of 	 * runningbufspace, possibly waking other threads waiting for space. 	 */
name|saved_runningbufspace
operator|=
name|bp
operator|->
name|b_runningbufspace
expr_stmt|;
if|if
condition|(
name|saved_runningbufspace
operator|!=
literal|0
condition|)
name|runningbufwakeup
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * Not in the precomputed list, so check the snapshots. 	 */
while|while
condition|(
name|lockmgr
argument_list|(
operator|&
name|sn
operator|->
name|sn_lock
argument_list|,
name|LK_INTERLOCK
operator||
name|LK_EXCLUSIVE
operator||
name|LK_SLEEPFAIL
argument_list|,
name|VI_MTX
argument_list|(
name|devvp
argument_list|)
argument_list|,
name|td
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|VI_LOCK
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
name|sn
operator|=
name|devvp
operator|->
name|v_rdev
operator|->
name|si_snapdata
expr_stmt|;
if|if
condition|(
name|sn
operator|==
name|NULL
operator|||
name|TAILQ_FIRST
argument_list|(
operator|&
name|sn
operator|->
name|sn_head
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|VI_UNLOCK
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|saved_runningbufspace
operator|!=
literal|0
condition|)
block|{
name|bp
operator|->
name|b_runningbufspace
operator|=
name|saved_runningbufspace
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|runningbufspace
argument_list|,
name|bp
operator|->
name|b_runningbufspace
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Snapshot gone */
block|}
block|}
name|TAILQ_FOREACH
argument_list|(
argument|ip
argument_list|,
argument|&sn->sn_head
argument_list|,
argument|i_nextsnap
argument_list|)
block|{
name|vp
operator|=
name|ITOV
argument_list|(
name|ip
argument_list|)
expr_stmt|;
comment|/* 		 * We ensure that everything of our own that needs to be 		 * copied will be done at the time that ffs_snapshot is 		 * called. Thus we can skip the check here which can 		 * deadlock in doing the lookup in UFS_BALLOC. 		 */
if|if
condition|(
name|bp
operator|->
name|b_vp
operator|==
name|vp
condition|)
continue|continue;
comment|/* 		 * Check to see if block needs to be copied. We do not have 		 * to hold the snapshot lock while doing this lookup as it 		 * will never require any additional allocations for the 		 * snapshot inode. 		 */
if|if
condition|(
name|lbn
operator|<
name|NDADDR
condition|)
block|{
name|blkno
operator|=
name|DIP
argument_list|(
name|ip
argument_list|,
name|i_db
index|[
name|lbn
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|td
operator|->
name|td_pflags
operator||=
name|TDP_COWINPROGRESS
operator||
name|TDP_NORUNNINGBUF
expr_stmt|;
name|error
operator|=
name|UFS_BALLOC
argument_list|(
name|vp
argument_list|,
name|lblktosize
argument_list|(
name|fs
argument_list|,
operator|(
name|off_t
operator|)
name|lbn
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
name|BA_METAONLY
argument_list|,
operator|&
name|ibp
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_pflags
operator|&=
operator|~
name|TDP_COWINPROGRESS
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|indiroff
operator|=
operator|(
name|lbn
operator|-
name|NDADDR
operator|)
operator|%
name|NINDIR
argument_list|(
name|fs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_ump
operator|->
name|um_fstype
operator|==
name|UFS1
condition|)
name|blkno
operator|=
operator|(
operator|(
name|ufs1_daddr_t
operator|*
operator|)
operator|(
name|ibp
operator|->
name|b_data
operator|)
operator|)
index|[
name|indiroff
index|]
expr_stmt|;
else|else
name|blkno
operator|=
operator|(
operator|(
name|ufs2_daddr_t
operator|*
operator|)
operator|(
name|ibp
operator|->
name|b_data
operator|)
operator|)
index|[
name|indiroff
index|]
expr_stmt|;
name|bqrelse
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|blkno
operator|==
name|BLK_SNAP
operator|&&
name|bp
operator|->
name|b_lblkno
operator|>=
literal|0
condition|)
name|panic
argument_list|(
literal|"ffs_copyonwrite: bad copy block"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|blkno
operator|!=
literal|0
condition|)
continue|continue;
comment|/* 		 * Allocate the block into which to do the copy. Since 		 * multiple processes may all try to copy the same block, 		 * we have to recheck our need to do a copy if we sleep 		 * waiting for the lock. 		 * 		 * Because all snapshots on a filesystem share a single 		 * lock, we ensure that we will never be in competition 		 * with another process to allocate a block. 		 */
name|td
operator|->
name|td_pflags
operator||=
name|TDP_COWINPROGRESS
operator||
name|TDP_NORUNNINGBUF
expr_stmt|;
name|error
operator|=
name|UFS_BALLOC
argument_list|(
name|vp
argument_list|,
name|lblktosize
argument_list|(
name|fs
argument_list|,
operator|(
name|off_t
operator|)
name|lbn
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
literal|0
argument_list|,
operator|&
name|cbp
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_pflags
operator|&=
operator|~
name|TDP_COWINPROGRESS
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|snapdebug
condition|)
block|{
name|printf
argument_list|(
literal|"Copyonwrite: snapino %d lbn %jd for "
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
operator|(
name|intmax_t
operator|)
name|lbn
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_vp
operator|==
name|devvp
condition|)
name|printf
argument_list|(
literal|"fs metadata"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"inum %d"
argument_list|,
name|VTOI
argument_list|(
name|bp
operator|->
name|b_vp
argument_list|)
operator|->
name|i_number
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" lblkno %jd to blkno %jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|bp
operator|->
name|b_lblkno
argument_list|,
operator|(
name|intmax_t
operator|)
name|cbp
operator|->
name|b_blkno
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 		 * If we have already read the old block contents, then 		 * simply copy them to the new block. Note that we need 		 * to synchronously write snapshots that have not been 		 * unlinked, and hence will be visible after a crash, 		 * to ensure their integrity. 		 */
if|if
condition|(
name|savedcbp
operator|!=
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|savedcbp
operator|->
name|b_data
argument_list|,
name|cbp
operator|->
name|b_data
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
name|bawrite
argument_list|(
name|cbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dopersistence
operator|&&
name|ip
operator|->
name|i_effnlink
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|ffs_syncvnode
argument_list|(
name|vp
argument_list|,
name|MNT_WAIT
argument_list|)
expr_stmt|;
else|else
name|launched_async_io
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Otherwise, read the old block contents into the buffer. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|readblock
argument_list|(
name|vp
argument_list|,
name|cbp
argument_list|,
name|lbn
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|bzero
argument_list|(
name|cbp
operator|->
name|b_data
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
name|bawrite
argument_list|(
name|cbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dopersistence
operator|&&
name|ip
operator|->
name|i_effnlink
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|ffs_syncvnode
argument_list|(
name|vp
argument_list|,
name|MNT_WAIT
argument_list|)
expr_stmt|;
else|else
name|launched_async_io
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|savedcbp
operator|=
name|cbp
expr_stmt|;
block|}
comment|/* 	 * Note that we need to synchronously write snapshots that 	 * have not been unlinked, and hence will be visible after 	 * a crash, to ensure their integrity. 	 */
if|if
condition|(
name|savedcbp
condition|)
block|{
name|vp
operator|=
name|savedcbp
operator|->
name|b_vp
expr_stmt|;
name|bawrite
argument_list|(
name|savedcbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dopersistence
operator|&&
name|VTOI
argument_list|(
name|vp
argument_list|)
operator|->
name|i_effnlink
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|ffs_syncvnode
argument_list|(
name|vp
argument_list|,
name|MNT_WAIT
argument_list|)
expr_stmt|;
else|else
name|launched_async_io
operator|=
literal|1
expr_stmt|;
block|}
name|lockmgr
argument_list|(
name|vp
operator|->
name|v_vnlock
argument_list|,
name|LK_RELEASE
argument_list|,
name|NULL
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_pflags
operator|=
operator|(
name|td
operator|->
name|td_pflags
operator|&
operator|~
name|TDP_NORUNNINGBUF
operator|)
operator||
name|prev_norunningbuf
expr_stmt|;
if|if
condition|(
name|launched_async_io
operator|&&
operator|(
name|td
operator|->
name|td_pflags
operator|&
name|TDP_NORUNNINGBUF
operator|)
operator|==
literal|0
condition|)
name|waitrunningbufspace
argument_list|()
expr_stmt|;
comment|/* 	 * I/O on bp will now be started, so count it in runningbufspace. 	 */
if|if
condition|(
name|saved_runningbufspace
operator|!=
literal|0
condition|)
block|{
name|bp
operator|->
name|b_runningbufspace
operator|=
name|saved_runningbufspace
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|runningbufspace
argument_list|,
name|bp
operator|->
name|b_runningbufspace
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read the specified block into the given buffer.  * Much of this boiler-plate comes from bwrite().  */
end_comment

begin_function
specifier|static
name|int
name|readblock
parameter_list|(
name|vp
parameter_list|,
name|bp
parameter_list|,
name|lbn
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|ufs2_daddr_t
name|lbn
decl_stmt|;
block|{
name|struct
name|inode
modifier|*
name|ip
init|=
name|VTOI
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|bio
modifier|*
name|bip
decl_stmt|;
name|bip
operator|=
name|g_alloc_bio
argument_list|()
expr_stmt|;
name|bip
operator|->
name|bio_cmd
operator|=
name|BIO_READ
expr_stmt|;
name|bip
operator|->
name|bio_offset
operator|=
name|dbtob
argument_list|(
name|fsbtodb
argument_list|(
name|ip
operator|->
name|i_fs
argument_list|,
name|blkstofrags
argument_list|(
name|ip
operator|->
name|i_fs
argument_list|,
name|lbn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|bip
operator|->
name|bio_data
operator|=
name|bp
operator|->
name|b_data
expr_stmt|;
name|bip
operator|->
name|bio_length
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|g_io_request
argument_list|(
name|bip
argument_list|,
name|ip
operator|->
name|i_devvp
operator|->
name|v_bufobj
operator|.
name|bo_private
argument_list|)
expr_stmt|;
do|do
name|msleep
argument_list|(
name|bip
argument_list|,
name|NULL
argument_list|,
name|PRIBIO
argument_list|,
literal|"snaprdb"
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
do|while
condition|(
operator|!
operator|(
name|bip
operator|->
name|bio_flags
operator|&
name|BIO_DONE
operator|)
condition|)
do|;
name|bp
operator|->
name|b_error
operator|=
name|bip
operator|->
name|bio_error
expr_stmt|;
name|g_destroy_bio
argument_list|(
name|bip
argument_list|)
expr_stmt|;
return|return
operator|(
name|bp
operator|->
name|b_error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process file deletes that were deferred by ufs_inactive() due to  * the file system being suspended.  */
end_comment

begin_function
specifier|static
name|void
name|process_deferred_inactive
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|,
modifier|*
name|mvp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|int
name|error
decl_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
operator|(
name|void
operator|)
name|vn_start_secondary_write
argument_list|(
name|NULL
argument_list|,
operator|&
name|mp
argument_list|,
name|V_WAIT
argument_list|)
expr_stmt|;
name|MNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|loop
label|:
name|MNT_VNODE_FOREACH
argument_list|(
argument|vp
argument_list|,
argument|mp
argument_list|,
argument|mvp
argument_list|)
block|{
name|VI_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vp
operator|->
name|v_iflag
operator|&
operator|(
name|VI_DOOMED
operator||
name|VI_OWEINACT
operator|)
operator|)
operator|!=
name|VI_OWEINACT
operator|||
name|vp
operator|->
name|v_usecount
operator|>
literal|0
operator|||
name|vp
operator|->
name|v_type
operator|==
name|VNON
condition|)
block|{
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|MNT_IUNLOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|vholdl
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|error
operator|=
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_INTERLOCK
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|vdrop
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|MNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
continue|continue;
comment|/* vnode recycled */
name|MNT_VNODE_FOREACH_ABORT_ILOCKED
argument_list|(
name|mp
argument_list|,
name|mvp
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
name|VI_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vp
operator|->
name|v_iflag
operator|&
name|VI_OWEINACT
operator|)
operator|==
literal|0
condition|)
block|{
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|vdrop
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|MNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|VNASSERT
argument_list|(
operator|(
name|vp
operator|->
name|v_iflag
operator|&
name|VI_DOINGINACT
operator|)
operator|==
literal|0
argument_list|,
name|vp
argument_list|,
operator|(
literal|"process_deferred_inactive: "
literal|"recursed on VI_DOINGINACT"
operator|)
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_iflag
operator||=
name|VI_DOINGINACT
expr_stmt|;
name|vp
operator|->
name|v_iflag
operator|&=
operator|~
name|VI_OWEINACT
expr_stmt|;
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|VOP_INACTIVE
argument_list|(
name|vp
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|VI_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|VNASSERT
argument_list|(
name|vp
operator|->
name|v_iflag
operator|&
name|VI_DOINGINACT
argument_list|,
name|vp
argument_list|,
operator|(
literal|"process_deferred_inactive: lost VI_DOINGINACT"
operator|)
argument_list|)
expr_stmt|;
name|VNASSERT
argument_list|(
operator|(
name|vp
operator|->
name|v_iflag
operator|&
name|VI_OWEINACT
operator|)
operator|==
literal|0
argument_list|,
name|vp
argument_list|,
operator|(
literal|"process_deferred_inactive: got VI_OWEINACT"
operator|)
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_iflag
operator|&=
operator|~
name|VI_DOINGINACT
expr_stmt|;
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|vdrop
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|MNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
name|MNT_IUNLOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|vn_finished_secondary_write
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Try to free snapdata associated with devvp */
end_comment

begin_function
specifier|static
name|void
name|try_free_snapdata
parameter_list|(
name|struct
name|vnode
modifier|*
name|devvp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|snapdata
modifier|*
name|sn
decl_stmt|;
name|ufs2_daddr_t
modifier|*
name|snapblklist
decl_stmt|;
name|sn
operator|=
name|devvp
operator|->
name|v_rdev
operator|->
name|si_snapdata
expr_stmt|;
if|if
condition|(
name|sn
operator|==
name|NULL
operator|||
name|TAILQ_FIRST
argument_list|(
operator|&
name|sn
operator|->
name|sn_head
argument_list|)
operator|!=
name|NULL
operator|||
operator|(
name|devvp
operator|->
name|v_vflag
operator|&
name|VV_COPYONWRITE
operator|)
operator|==
literal|0
condition|)
block|{
name|VI_UNLOCK
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
return|return;
block|}
name|devvp
operator|->
name|v_rdev
operator|->
name|si_snapdata
operator|=
name|NULL
expr_stmt|;
name|devvp
operator|->
name|v_vflag
operator|&=
operator|~
name|VV_COPYONWRITE
expr_stmt|;
name|snapblklist
operator|=
name|sn
operator|->
name|sn_blklist
expr_stmt|;
name|sn
operator|->
name|sn_blklist
operator|=
name|NULL
expr_stmt|;
name|sn
operator|->
name|sn_listsize
operator|=
literal|0
expr_stmt|;
name|lockmgr
argument_list|(
operator|&
name|sn
operator|->
name|sn_lock
argument_list|,
name|LK_DRAIN
operator||
name|LK_INTERLOCK
argument_list|,
name|VI_MTX
argument_list|(
name|devvp
argument_list|)
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|lockmgr
argument_list|(
operator|&
name|sn
operator|->
name|sn_lock
argument_list|,
name|LK_RELEASE
argument_list|,
name|NULL
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|lockdestroy
argument_list|(
operator|&
name|sn
operator|->
name|sn_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sn
argument_list|,
name|M_UFSMNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|snapblklist
operator|!=
name|NULL
condition|)
name|FREE
argument_list|(
name|snapblklist
argument_list|,
name|M_UFSMNT
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

