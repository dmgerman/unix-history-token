begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2000 Marshall Kirk McKusick. All Rights Reserved.  *  * Further information about snapshots can be obtained from:  *  *	Marshall Kirk McKusick		http://www.mckusick.com/softdep/  *	1614 Oxford Street		mckusick@mckusick.com  *	Berkeley, CA 94709-1608		+1-510-843-9542  *	USA  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY MARSHALL KIRK MCKUSICK ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL MARSHALL KIRK MCKUSICK BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)ffs_snapshot.c	8.11 (McKusick) 7/23/00  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/extattr.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/quota.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/ufsmount.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/inode.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/ufs_extern.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ffs/fs.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ffs/ffs_extern.h>
end_include

begin_define
define|#
directive|define
name|KERNCRED
value|proc0.p_ucred
end_define

begin_define
define|#
directive|define
name|DEBUG
value|1
end_define

begin_decl_stmt
specifier|static
name|int
name|cgaccount
name|__P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|vnode
operator|*
operator|,
expr|struct
name|buf
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|expunge
name|__P
argument_list|(
operator|(
expr|struct
name|vnode
operator|*
operator|,
expr|struct
name|inode
operator|*
operator|,
expr|struct
name|fs
operator|*
operator|,
name|int
argument_list|(
argument|*
argument_list|)
name|__P
argument_list|(
operator|(
expr|struct
name|vnode
operator|*
operator|,
name|ufs_daddr_t
operator|*
operator|,
name|ufs_daddr_t
operator|*
operator|,
expr|struct
name|fs
operator|*
operator|,
name|ufs_daddr_t
operator|,
name|int
operator|)
argument_list|)
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|indiracct
name|__P
argument_list|(
operator|(
expr|struct
name|vnode
operator|*
operator|,
expr|struct
name|vnode
operator|*
operator|,
name|int
operator|,
name|ufs_daddr_t
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
expr|struct
name|fs
operator|*
operator|,
name|int
argument_list|(
argument|*
argument_list|)
name|__P
argument_list|(
operator|(
expr|struct
name|vnode
operator|*
operator|,
name|ufs_daddr_t
operator|*
operator|,
name|ufs_daddr_t
operator|*
operator|,
expr|struct
name|fs
operator|*
operator|,
name|ufs_daddr_t
operator|,
name|int
operator|)
argument_list|)
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fullacct
name|__P
argument_list|(
operator|(
expr|struct
name|vnode
operator|*
operator|,
name|ufs_daddr_t
operator|*
operator|,
name|ufs_daddr_t
operator|*
operator|,
expr|struct
name|fs
operator|*
operator|,
name|ufs_daddr_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|snapacct
name|__P
argument_list|(
operator|(
expr|struct
name|vnode
operator|*
operator|,
name|ufs_daddr_t
operator|*
operator|,
name|ufs_daddr_t
operator|*
operator|,
expr|struct
name|fs
operator|*
operator|,
name|ufs_daddr_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mapacct
name|__P
argument_list|(
operator|(
expr|struct
name|vnode
operator|*
operator|,
name|ufs_daddr_t
operator|*
operator|,
name|ufs_daddr_t
operator|*
operator|,
expr|struct
name|fs
operator|*
operator|,
name|ufs_daddr_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ffs_copyonwrite
name|__P
argument_list|(
operator|(
expr|struct
name|vnode
operator|*
operator|,
expr|struct
name|buf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|readblock
name|__P
argument_list|(
operator|(
expr|struct
name|buf
operator|*
operator|,
name|daddr_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * To ensure the consistency of snapshots across crashes, we must  * synchronously write out copied blocks before allowing the  * originals to be modified. Because of the rather severe speed  * penalty that this imposes, the following flag allows this  * crash persistence to be disabled.  */
end_comment

begin_decl_stmt
name|int
name|dopersistence
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|dopersistence
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|dopersistence
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|snapdebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|snapdebug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|snapdebug
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|collectsnapstats
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|collectsnapstats
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|collectsnapstats
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_comment
comment|/*  * Create a snapshot file and initialize it for the filesystem.  */
end_comment

begin_function
name|int
name|ffs_snapshot
parameter_list|(
name|mp
parameter_list|,
name|snapfile
parameter_list|)
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|char
modifier|*
name|snapfile
decl_stmt|;
block|{
name|ufs_daddr_t
name|blkno
decl_stmt|;
name|int
name|error
decl_stmt|,
name|cg
decl_stmt|,
name|snaploc
decl_stmt|,
name|numblks
decl_stmt|;
name|int
name|i
decl_stmt|,
name|size
decl_stmt|,
name|len
decl_stmt|,
name|loc
decl_stmt|;
name|int
name|flag
init|=
name|mp
operator|->
name|mnt_flag
decl_stmt|;
name|struct
name|timespec
name|starttime
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|,
name|endtime
decl_stmt|;
name|char
name|saved_nice
init|=
literal|0
decl_stmt|;
name|long
name|redo
init|=
literal|0
decl_stmt|;
name|int32_t
modifier|*
name|lp
decl_stmt|;
name|void
modifier|*
name|space
decl_stmt|;
name|struct
name|fs
modifier|*
name|copy_fs
init|=
name|NULL
decl_stmt|,
modifier|*
name|fs
init|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
operator|->
name|um_fs
decl_stmt|;
name|struct
name|snaphead
modifier|*
name|snaphead
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|,
modifier|*
name|xp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|nbp
decl_stmt|,
modifier|*
name|ibp
decl_stmt|,
modifier|*
name|sbp
init|=
name|NULL
decl_stmt|;
name|struct
name|nameidata
name|nd
decl_stmt|;
name|struct
name|mount
modifier|*
name|wrtmp
decl_stmt|;
name|struct
name|vattr
name|vat
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|,
modifier|*
name|xvp
decl_stmt|,
modifier|*
name|nvp
decl_stmt|;
comment|/* 	 * Need to serialize access to snapshot code per filesystem. 	 */
comment|/* 	 * Assign a snapshot slot in the superblock. 	 */
for|for
control|(
name|snaploc
operator|=
literal|0
init|;
name|snaploc
operator|<
name|FSMAXSNAP
condition|;
name|snaploc
operator|++
control|)
if|if
condition|(
name|fs
operator|->
name|fs_snapinum
index|[
name|snaploc
index|]
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|snaploc
operator|==
name|FSMAXSNAP
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
comment|/* 	 * Create the snapshot file. 	 */
name|restart
label|:
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|CREATE
argument_list|,
name|LOCKPARENT
operator||
name|LOCKLEAF
argument_list|,
name|UIO_USERSPACE
argument_list|,
name|snapfile
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|.
name|ni_vp
operator|!=
name|NULL
condition|)
block|{
name|vput
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|)
expr_stmt|;
name|error
operator|=
name|EEXIST
expr_stmt|;
block|}
if|if
condition|(
name|nd
operator|.
name|ni_dvp
operator|->
name|v_mount
operator|!=
name|mp
condition|)
name|error
operator|=
name|EXDEV
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|.
name|ni_dvp
operator|==
name|nd
operator|.
name|ni_vp
condition|)
name|vrele
argument_list|(
name|nd
operator|.
name|ni_dvp
argument_list|)
expr_stmt|;
else|else
name|vput
argument_list|(
name|nd
operator|.
name|ni_dvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|VATTR_NULL
argument_list|(
operator|&
name|vat
argument_list|)
expr_stmt|;
name|vat
operator|.
name|va_type
operator|=
name|VREG
expr_stmt|;
name|vat
operator|.
name|va_mode
operator|=
name|S_IRUSR
expr_stmt|;
name|vat
operator|.
name|va_vaflags
operator||=
name|VA_EXCLUSIVE
expr_stmt|;
if|if
condition|(
name|VOP_GETWRITEMOUNT
argument_list|(
name|nd
operator|.
name|ni_dvp
argument_list|,
operator|&
name|wrtmp
argument_list|)
condition|)
name|wrtmp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|wrtmp
operator|!=
name|mp
condition|)
name|panic
argument_list|(
literal|"ffs_snapshot: mount mismatch"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vn_start_write
argument_list|(
name|NULL
argument_list|,
operator|&
name|wrtmp
argument_list|,
name|V_NOWAIT
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|nd
operator|.
name|ni_dvp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|vn_start_write
argument_list|(
name|NULL
argument_list|,
operator|&
name|wrtmp
argument_list|,
name|V_XSLEEP
operator||
name|PCATCH
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
goto|goto
name|restart
goto|;
block|}
name|VOP_LEASE
argument_list|(
name|nd
operator|.
name|ni_dvp
argument_list|,
name|td
argument_list|,
name|KERNCRED
argument_list|,
name|LEASE_WRITE
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_CREATE
argument_list|(
name|nd
operator|.
name|ni_dvp
argument_list|,
operator|&
name|nd
operator|.
name|ni_vp
argument_list|,
operator|&
name|nd
operator|.
name|ni_cnd
argument_list|,
operator|&
name|vat
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|nd
operator|.
name|ni_dvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
name|vn_finished_write
argument_list|(
name|wrtmp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|vp
operator|=
name|nd
operator|.
name|ni_vp
expr_stmt|;
name|ip
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate and copy the last block contents so as to be able 	 * to set size to that of the filesystem. 	 */
name|numblks
operator|=
name|howmany
argument_list|(
name|fs
operator|->
name|fs_size
argument_list|,
name|fs
operator|->
name|fs_frag
argument_list|)
expr_stmt|;
name|error
operator|=
name|UFS_BALLOC
argument_list|(
name|vp
argument_list|,
name|lblktosize
argument_list|(
name|fs
argument_list|,
call|(
name|off_t
call|)
argument_list|(
name|numblks
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
name|B_CLRBUF
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|ip
operator|->
name|i_size
operator|=
name|lblktosize
argument_list|(
name|fs
argument_list|,
operator|(
name|off_t
operator|)
name|numblks
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_flag
operator||=
name|IN_CHANGE
operator||
name|IN_UPDATE
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|readblock
argument_list|(
name|bp
argument_list|,
name|numblks
operator|-
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|bawrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * Preallocate critical data structures so that we can copy 	 * them in without further allocation after we suspend all 	 * operations on the filesystem. We would like to just release 	 * the allocated buffers without writing them since they will 	 * be filled in below once we are ready to go, but this upsets 	 * the soft update code, so we go ahead and write the new buffers. 	 * 	 * Allocate all indirect blocks and mark all of them as not 	 * needing to be copied. 	 */
for|for
control|(
name|blkno
operator|=
name|NDADDR
init|;
name|blkno
operator|<
name|numblks
condition|;
name|blkno
operator|+=
name|NINDIR
argument_list|(
name|fs
argument_list|)
control|)
block|{
name|error
operator|=
name|UFS_BALLOC
argument_list|(
name|vp
argument_list|,
name|lblktosize
argument_list|(
name|fs
argument_list|,
operator|(
name|off_t
operator|)
name|blkno
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|B_METAONLY
argument_list|,
operator|&
name|ibp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|bdwrite
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Allocate copies for the superblock and its summary information. 	 */
name|error
operator|=
name|UFS_BALLOC
argument_list|(
name|vp
argument_list|,
call|(
name|off_t
call|)
argument_list|(
name|SBOFF
argument_list|)
argument_list|,
name|SBSIZE
argument_list|,
name|KERNCRED
argument_list|,
literal|0
argument_list|,
operator|&
name|nbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|bawrite
argument_list|(
name|nbp
argument_list|)
expr_stmt|;
name|blkno
operator|=
name|fragstoblks
argument_list|(
name|fs
argument_list|,
name|fs
operator|->
name|fs_csaddr
argument_list|)
expr_stmt|;
name|len
operator|=
name|howmany
argument_list|(
name|fs
operator|->
name|fs_cssize
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
for|for
control|(
name|loc
operator|=
literal|0
init|;
name|loc
operator|<
name|len
condition|;
name|loc
operator|++
control|)
block|{
name|error
operator|=
name|UFS_BALLOC
argument_list|(
name|vp
argument_list|,
name|lblktosize
argument_list|(
name|fs
argument_list|,
call|(
name|off_t
call|)
argument_list|(
name|blkno
operator|+
name|loc
argument_list|)
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
literal|0
argument_list|,
operator|&
name|nbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|bawrite
argument_list|(
name|nbp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Allocate all cylinder group blocks. 	 */
for|for
control|(
name|cg
operator|=
literal|0
init|;
name|cg
operator|<
name|fs
operator|->
name|fs_ncg
condition|;
name|cg
operator|++
control|)
block|{
name|error
operator|=
name|UFS_BALLOC
argument_list|(
name|vp
argument_list|,
call|(
name|off_t
call|)
argument_list|(
name|cgtod
argument_list|(
name|fs
argument_list|,
name|cg
argument_list|)
argument_list|)
operator|<<
name|fs
operator|->
name|fs_fshift
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
literal|0
argument_list|,
operator|&
name|nbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|bdwrite
argument_list|(
name|nbp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Copy all the cylinder group maps. Although the 	 * filesystem is still active, we hope that only a few 	 * cylinder groups will change between now and when we 	 * suspend operations. Thus, we will be able to quickly 	 * touch up the few cylinder groups that changed during 	 * the suspension period. 	 */
name|len
operator|=
name|howmany
argument_list|(
name|fs
operator|->
name|fs_ncg
argument_list|,
name|NBBY
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|fs
operator|->
name|fs_active
argument_list|,
name|int
operator|*
argument_list|,
name|len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|fs
operator|->
name|fs_active
argument_list|,
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|cg
operator|=
literal|0
init|;
name|cg
operator|<
name|fs
operator|->
name|fs_ncg
condition|;
name|cg
operator|++
control|)
block|{
name|error
operator|=
name|bread
argument_list|(
name|vp
argument_list|,
name|fragstoblks
argument_list|(
name|fs
argument_list|,
name|cgtod
argument_list|(
name|fs
argument_list|,
name|cg
argument_list|)
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
operator|&
name|nbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|nbp
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|cgaccount
argument_list|(
name|cg
argument_list|,
name|vp
argument_list|,
name|nbp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bawrite
argument_list|(
name|nbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Change inode to snapshot type file. 	 */
name|ip
operator|->
name|i_flags
operator||=
name|SF_SNAPSHOT
expr_stmt|;
name|ip
operator|->
name|i_flag
operator||=
name|IN_CHANGE
operator||
name|IN_UPDATE
expr_stmt|;
comment|/* 	 * Ensure that the snapshot is completely on disk. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_FSYNC
argument_list|(
name|vp
argument_list|,
name|KERNCRED
argument_list|,
name|MNT_WAIT
argument_list|,
name|td
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * All allocations are done, so we can now snapshot the system. 	 * 	 * Recind nice scheduling while running with the filesystem suspended. 	 */
if|if
condition|(
name|td
operator|->
name|td_ksegrp
operator|->
name|kg_nice
operator|>
literal|0
condition|)
block|{
name|saved_nice
operator|=
name|td
operator|->
name|td_ksegrp
operator|->
name|kg_nice
expr_stmt|;
name|td
operator|->
name|td_ksegrp
operator|->
name|kg_nice
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Suspend operation on filesystem. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|vn_finished_write
argument_list|(
name|wrtmp
argument_list|)
expr_stmt|;
name|vfs_write_suspend
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|mnt_kern_flag
operator|&
name|MNTK_SUSPENDED
condition|)
break|break;
name|vn_start_write
argument_list|(
name|NULL
argument_list|,
operator|&
name|wrtmp
argument_list|,
name|V_WAIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|collectsnapstats
condition|)
name|nanotime
argument_list|(
operator|&
name|starttime
argument_list|)
expr_stmt|;
comment|/* 	 * First, copy all the cylinder group maps that have changed. 	 */
for|for
control|(
name|cg
operator|=
literal|0
init|;
name|cg
operator|<
name|fs
operator|->
name|fs_ncg
condition|;
name|cg
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ACTIVECGNUM
argument_list|(
name|fs
argument_list|,
name|cg
argument_list|)
operator|&
name|ACTIVECGOFF
argument_list|(
name|cg
argument_list|)
operator|)
operator|!=
literal|0
condition|)
continue|continue;
name|redo
operator|++
expr_stmt|;
name|error
operator|=
name|bread
argument_list|(
name|vp
argument_list|,
name|fragstoblks
argument_list|(
name|fs
argument_list|,
name|cgtod
argument_list|(
name|fs
argument_list|,
name|cg
argument_list|)
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
operator|&
name|nbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|nbp
argument_list|)
expr_stmt|;
goto|goto
name|out1
goto|;
block|}
name|error
operator|=
name|cgaccount
argument_list|(
name|cg
argument_list|,
name|vp
argument_list|,
name|nbp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|bawrite
argument_list|(
name|nbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out1
goto|;
block|}
comment|/* 	 * Grab a copy of the superblock and its summary information. 	 * We delay writing it until the suspension is released below. 	 */
name|error
operator|=
name|bread
argument_list|(
name|vp
argument_list|,
name|lblkno
argument_list|(
name|fs
argument_list|,
name|SBOFF
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
operator|&
name|sbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
name|sbp
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out1
goto|;
block|}
name|copy_fs
operator|=
operator|(
expr|struct
name|fs
operator|*
operator|)
operator|(
name|sbp
operator|->
name|b_data
operator|+
name|blkoff
argument_list|(
name|fs
argument_list|,
name|SBOFF
argument_list|)
operator|)
expr_stmt|;
name|bcopy
argument_list|(
name|fs
argument_list|,
name|copy_fs
argument_list|,
name|fs
operator|->
name|fs_sbsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fs
operator|->
name|fs_flags
operator|&
operator|(
name|FS_UNCLEAN
operator||
name|FS_NEEDSFSCK
operator|)
operator|)
operator|==
literal|0
condition|)
name|copy_fs
operator|->
name|fs_clean
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|fs_sbsize
operator|<
name|SBSIZE
condition|)
name|bzero
argument_list|(
operator|&
name|sbp
operator|->
name|b_data
index|[
name|blkoff
argument_list|(
name|fs
argument_list|,
name|SBOFF
argument_list|)
operator|+
name|fs
operator|->
name|fs_sbsize
index|]
argument_list|,
name|SBSIZE
operator|-
name|fs
operator|->
name|fs_sbsize
argument_list|)
expr_stmt|;
name|size
operator|=
name|blkroundup
argument_list|(
name|fs
argument_list|,
name|fs
operator|->
name|fs_cssize
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|fs_contigsumsize
operator|>
literal|0
condition|)
name|size
operator|+=
name|fs
operator|->
name|fs_ncg
operator|*
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
expr_stmt|;
name|space
operator|=
name|malloc
argument_list|(
operator|(
name|u_long
operator|)
name|size
argument_list|,
name|M_UFSMNT
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|copy_fs
operator|->
name|fs_csp
operator|=
name|space
expr_stmt|;
name|bcopy
argument_list|(
name|fs
operator|->
name|fs_csp
argument_list|,
name|copy_fs
operator|->
name|fs_csp
argument_list|,
name|fs
operator|->
name|fs_cssize
argument_list|)
expr_stmt|;
operator|(
name|char
operator|*
operator|)
name|space
operator|+=
name|fs
operator|->
name|fs_cssize
expr_stmt|;
name|loc
operator|=
name|howmany
argument_list|(
name|fs
operator|->
name|fs_cssize
argument_list|,
name|fs
operator|->
name|fs_fsize
argument_list|)
expr_stmt|;
name|i
operator|=
name|fs
operator|->
name|fs_frag
operator|-
name|loc
operator|%
name|fs
operator|->
name|fs_frag
expr_stmt|;
name|len
operator|=
operator|(
name|i
operator|==
name|fs
operator|->
name|fs_frag
operator|)
condition|?
literal|0
else|:
name|i
operator|*
name|fs
operator|->
name|fs_fsize
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|bread
argument_list|(
name|ip
operator|->
name|i_devvp
argument_list|,
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|fs
operator|->
name|fs_csaddr
operator|+
name|loc
argument_list|)
argument_list|,
name|len
argument_list|,
name|KERNCRED
argument_list|,
operator|&
name|bp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|copy_fs
operator|->
name|fs_csp
argument_list|,
name|M_UFSMNT
argument_list|)
expr_stmt|;
name|bawrite
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
name|sbp
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out1
goto|;
block|}
name|bcopy
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
name|space
argument_list|,
operator|(
name|u_int
operator|)
name|len
argument_list|)
expr_stmt|;
operator|(
name|char
operator|*
operator|)
name|space
operator|+=
name|len
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_INVAL
operator||
name|B_NOCACHE
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fs
operator|->
name|fs_contigsumsize
operator|>
literal|0
condition|)
block|{
name|copy_fs
operator|->
name|fs_maxcluster
operator|=
name|lp
operator|=
name|space
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fs
operator|->
name|fs_ncg
condition|;
name|i
operator|++
control|)
operator|*
name|lp
operator|++
operator|=
name|fs
operator|->
name|fs_contigsumsize
expr_stmt|;
block|}
comment|/* 	 * We must check for active files that have been unlinked 	 * (e.g., with a zero link count). We have to expunge all 	 * trace of these files from the snapshot so that they are 	 * not reclaimed prematurely by fsck or unnecessarily dumped. 	 * We turn off the MNTK_SUSPENDED flag to avoid a panic from 	 * spec_strategy about writing on a suspended filesystem. 	 */
name|mp
operator|->
name|mnt_kern_flag
operator|&=
operator|~
name|MNTK_SUSPENDED
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|mntvnode_mtx
argument_list|)
expr_stmt|;
name|loop
label|:
for|for
control|(
name|xvp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|mp
operator|->
name|mnt_nvnodelist
argument_list|)
init|;
name|xvp
condition|;
name|xvp
operator|=
name|nvp
control|)
block|{
comment|/* 		 * Make sure this vnode wasn't reclaimed in getnewvnode(). 		 * Start over if it has (it won't be on the list anymore). 		 */
if|if
condition|(
name|xvp
operator|->
name|v_mount
operator|!=
name|mp
condition|)
goto|goto
name|loop
goto|;
name|nvp
operator|=
name|TAILQ_NEXT
argument_list|(
name|xvp
argument_list|,
name|v_nmntvnodes
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|mntvnode_mtx
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|xvp
operator|->
name|v_interlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|xvp
operator|->
name|v_usecount
operator|==
literal|0
operator|||
name|xvp
operator|->
name|v_type
operator|==
name|VNON
operator|||
operator|(
name|VOP_GETATTR
argument_list|(
name|xvp
argument_list|,
operator|&
name|vat
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_ucred
argument_list|,
name|td
argument_list|)
operator|==
literal|0
operator|&&
name|vat
operator|.
name|va_nlink
operator|>
literal|0
operator|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|xvp
operator|->
name|v_interlock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|mntvnode_mtx
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|snapdebug
condition|)
name|vprint
argument_list|(
literal|"ffs_snapshot: busy vnode"
argument_list|,
name|xvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vn_lock
argument_list|(
name|xvp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_INTERLOCK
argument_list|,
name|td
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|loop
goto|;
name|xp
operator|=
name|VTOI
argument_list|(
name|xvp
argument_list|)
expr_stmt|;
comment|/* 		 * If there is a fragment, clear it here. 		 */
name|blkno
operator|=
literal|0
expr_stmt|;
name|loc
operator|=
name|howmany
argument_list|(
name|xp
operator|->
name|i_size
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|loc
operator|<
name|NDADDR
condition|)
block|{
name|len
operator|=
name|fragroundup
argument_list|(
name|fs
argument_list|,
name|blkoff
argument_list|(
name|fs
argument_list|,
name|xp
operator|->
name|i_size
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|fs
operator|->
name|fs_bsize
condition|)
block|{
name|ffs_blkfree
argument_list|(
name|copy_fs
argument_list|,
name|vp
argument_list|,
name|xp
operator|->
name|i_db
index|[
name|loc
index|]
argument_list|,
name|len
argument_list|,
name|xp
operator|->
name|i_number
argument_list|)
expr_stmt|;
name|blkno
operator|=
name|xp
operator|->
name|i_db
index|[
name|loc
index|]
expr_stmt|;
name|xp
operator|->
name|i_db
index|[
name|loc
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|error
operator|=
name|expunge
argument_list|(
name|vp
argument_list|,
name|xp
argument_list|,
name|copy_fs
argument_list|,
name|fullacct
argument_list|,
name|BLK_NOCOPY
argument_list|)
expr_stmt|;
if|if
condition|(
name|blkno
condition|)
name|xp
operator|->
name|i_db
index|[
name|loc
index|]
operator|=
name|blkno
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|ffs_freefile
argument_list|(
name|copy_fs
argument_list|,
name|vp
argument_list|,
name|xp
operator|->
name|i_number
argument_list|,
name|xp
operator|->
name|i_mode
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|xvp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|copy_fs
operator|->
name|fs_csp
argument_list|,
name|M_UFSMNT
argument_list|)
expr_stmt|;
name|bawrite
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
name|sbp
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out1
goto|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|mntvnode_mtx
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|mntvnode_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Record snapshot inode. Since this is the newest snapshot, 	 * it must be placed at the end of the list. 	 */
name|fs
operator|->
name|fs_snapinum
index|[
name|snaploc
index|]
operator|=
name|ip
operator|->
name|i_number
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_nextsnap
operator|.
name|tqe_prev
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"ffs_snapshot: %d already on list"
argument_list|,
name|ip
operator|->
name|i_number
argument_list|)
expr_stmt|;
name|snaphead
operator|=
operator|&
name|ip
operator|->
name|i_devvp
operator|->
name|v_rdev
operator|->
name|si_snapshots
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
name|snaphead
argument_list|,
name|ip
argument_list|,
name|i_nextsnap
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_devvp
operator|->
name|v_rdev
operator|->
name|si_copyonwrite
operator|=
name|ffs_copyonwrite
expr_stmt|;
name|ip
operator|->
name|i_devvp
operator|->
name|v_flag
operator||=
name|VCOPYONWRITE
expr_stmt|;
name|vp
operator|->
name|v_flag
operator||=
name|VSYSTEM
expr_stmt|;
name|out1
label|:
comment|/* 	 * Resume operation on filesystem. 	 */
name|vfs_write_resume
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
if|if
condition|(
name|saved_nice
operator|>
literal|0
condition|)
name|td
operator|->
name|td_ksegrp
operator|->
name|kg_nice
operator|=
name|saved_nice
expr_stmt|;
name|vn_start_write
argument_list|(
name|NULL
argument_list|,
operator|&
name|wrtmp
argument_list|,
name|V_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|collectsnapstats
operator|&&
name|starttime
operator|.
name|tv_sec
operator|>
literal|0
condition|)
block|{
name|nanotime
argument_list|(
operator|&
name|endtime
argument_list|)
expr_stmt|;
name|timespecsub
argument_list|(
operator|&
name|endtime
argument_list|,
operator|&
name|starttime
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: suspended %d.%03ld sec, redo %ld of %d\n"
argument_list|,
name|vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_mntonname
argument_list|,
name|endtime
operator|.
name|tv_sec
argument_list|,
name|endtime
operator|.
name|tv_nsec
operator|/
literal|1000000
argument_list|,
name|redo
argument_list|,
name|fs
operator|->
name|fs_ncg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sbp
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Copy allocation information from all the snapshots in 	 * this snapshot and then expunge them from its view. 	 */
name|snaphead
operator|=
operator|&
name|ip
operator|->
name|i_devvp
operator|->
name|v_rdev
operator|->
name|si_snapshots
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|xp
argument_list|,
argument|snaphead
argument_list|,
argument|i_nextsnap
argument_list|)
block|{
if|if
condition|(
name|xp
operator|==
name|ip
condition|)
break|break;
if|if
condition|(
operator|(
name|error
operator|=
name|expunge
argument_list|(
name|vp
argument_list|,
name|xp
argument_list|,
name|fs
argument_list|,
name|snapacct
argument_list|,
name|BLK_SNAP
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|fs
operator|->
name|fs_snapinum
index|[
name|snaploc
index|]
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
comment|/* 	 * Expunge the blocks used by the snapshots from the set of 	 * blocks marked as used in the snapshot bitmaps. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|expunge
argument_list|(
name|vp
argument_list|,
name|ip
argument_list|,
name|copy_fs
argument_list|,
name|mapacct
argument_list|,
name|BLK_SNAP
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|fs
operator|->
name|fs_snapinum
index|[
name|snaploc
index|]
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Write the superblock and its summary information 	 * to the snapshot. 	 */
name|blkno
operator|=
name|fragstoblks
argument_list|(
name|fs
argument_list|,
name|fs
operator|->
name|fs_csaddr
argument_list|)
expr_stmt|;
name|len
operator|=
name|howmany
argument_list|(
name|fs
operator|->
name|fs_cssize
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
name|space
operator|=
name|copy_fs
operator|->
name|fs_csp
expr_stmt|;
for|for
control|(
name|loc
operator|=
literal|0
init|;
name|loc
operator|<
name|len
condition|;
name|loc
operator|++
control|)
block|{
name|error
operator|=
name|bread
argument_list|(
name|vp
argument_list|,
name|blkno
operator|+
name|loc
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
operator|&
name|nbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|nbp
argument_list|)
expr_stmt|;
name|fs
operator|->
name|fs_snapinum
index|[
name|snaploc
index|]
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|bcopy
argument_list|(
name|space
argument_list|,
name|nbp
operator|->
name|b_data
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
name|space
operator|=
operator|(
name|char
operator|*
operator|)
name|space
operator|+
name|fs
operator|->
name|fs_bsize
expr_stmt|;
name|bawrite
argument_list|(
name|nbp
argument_list|)
expr_stmt|;
block|}
name|done
label|:
name|free
argument_list|(
name|copy_fs
operator|->
name|fs_csp
argument_list|,
name|M_UFSMNT
argument_list|)
expr_stmt|;
name|bawrite
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|fs
operator|->
name|fs_active
operator|!=
literal|0
condition|)
block|{
name|FREE
argument_list|(
name|fs
operator|->
name|fs_active
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|fs
operator|->
name|fs_active
operator|=
literal|0
expr_stmt|;
block|}
name|mp
operator|->
name|mnt_flag
operator|=
name|flag
expr_stmt|;
if|if
condition|(
name|error
condition|)
operator|(
name|void
operator|)
name|UFS_TRUNCATE
argument_list|(
name|vp
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
name|NOCRED
argument_list|,
name|td
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|VOP_FSYNC
argument_list|(
name|vp
argument_list|,
name|KERNCRED
argument_list|,
name|MNT_WAIT
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
else|else
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|vn_finished_write
argument_list|(
name|wrtmp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copy a cylinder group map. All the unallocated blocks are marked  * BLK_NOCOPY so that the snapshot knows that it need not copy them  * if they are later written. If how is one, then this is a first  * pass, so only setting needs to be done. If how is 2, then this  * is a revision to a previous pass which must be undone as the  * replacement pass is done.  */
end_comment

begin_function
specifier|static
name|int
name|cgaccount
parameter_list|(
name|cg
parameter_list|,
name|vp
parameter_list|,
name|nbp
parameter_list|,
name|passno
parameter_list|)
name|int
name|cg
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|buf
modifier|*
name|nbp
decl_stmt|;
name|int
name|passno
decl_stmt|;
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|ibp
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|struct
name|cg
modifier|*
name|cgp
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|int
name|error
decl_stmt|,
name|numblks
decl_stmt|,
name|base
decl_stmt|,
name|len
decl_stmt|,
name|loc
decl_stmt|,
name|indiroff
decl_stmt|;
name|ip
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|fs
operator|=
name|ip
operator|->
name|i_fs
expr_stmt|;
name|error
operator|=
name|bread
argument_list|(
name|ip
operator|->
name|i_devvp
argument_list|,
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|cgtod
argument_list|(
name|fs
argument_list|,
name|cg
argument_list|)
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|fs
operator|->
name|fs_cgsize
argument_list|,
name|KERNCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|cgp
operator|=
operator|(
expr|struct
name|cg
operator|*
operator|)
name|bp
operator|->
name|b_data
expr_stmt|;
if|if
condition|(
operator|!
name|cg_chkmagic
argument_list|(
name|cgp
argument_list|)
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|atomic_set_int
argument_list|(
operator|&
name|ACTIVECGNUM
argument_list|(
name|fs
argument_list|,
name|cg
argument_list|)
argument_list|,
name|ACTIVECGOFF
argument_list|(
name|cg
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
name|nbp
operator|->
name|b_data
argument_list|,
name|fs
operator|->
name|fs_cgsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|fs_cgsize
operator|<
name|fs
operator|->
name|fs_bsize
condition|)
name|bzero
argument_list|(
operator|&
name|nbp
operator|->
name|b_data
index|[
name|fs
operator|->
name|fs_cgsize
index|]
argument_list|,
name|fs
operator|->
name|fs_bsize
operator|-
name|fs
operator|->
name|fs_cgsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|passno
operator|==
literal|2
condition|)
name|nbp
operator|->
name|b_flags
operator||=
name|B_VALIDSUSPWRT
expr_stmt|;
name|numblks
operator|=
name|howmany
argument_list|(
name|fs
operator|->
name|fs_size
argument_list|,
name|fs
operator|->
name|fs_frag
argument_list|)
expr_stmt|;
name|len
operator|=
name|howmany
argument_list|(
name|fs
operator|->
name|fs_fpg
argument_list|,
name|fs
operator|->
name|fs_frag
argument_list|)
expr_stmt|;
name|base
operator|=
name|cg
operator|*
name|fs
operator|->
name|fs_fpg
operator|/
name|fs
operator|->
name|fs_frag
expr_stmt|;
if|if
condition|(
name|base
operator|+
name|len
operator|>=
name|numblks
condition|)
name|len
operator|=
name|numblks
operator|-
name|base
operator|-
literal|1
expr_stmt|;
name|loc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|base
operator|<
name|NDADDR
condition|)
block|{
for|for
control|(
init|;
name|loc
operator|<
name|NDADDR
condition|;
name|loc
operator|++
control|)
block|{
if|if
condition|(
name|ffs_isblock
argument_list|(
name|fs
argument_list|,
name|cg_blksfree
argument_list|(
name|cgp
argument_list|)
argument_list|,
name|loc
argument_list|)
condition|)
name|ip
operator|->
name|i_db
index|[
name|loc
index|]
operator|=
name|BLK_NOCOPY
expr_stmt|;
elseif|else
if|if
condition|(
name|passno
operator|==
literal|2
operator|&&
name|ip
operator|->
name|i_db
index|[
name|loc
index|]
operator|==
name|BLK_NOCOPY
condition|)
name|ip
operator|->
name|i_db
index|[
name|loc
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|passno
operator|==
literal|1
operator|&&
name|ip
operator|->
name|i_db
index|[
name|loc
index|]
operator|==
name|BLK_NOCOPY
condition|)
name|panic
argument_list|(
literal|"ffs_snapshot: lost direct block"
argument_list|)
expr_stmt|;
block|}
block|}
name|error
operator|=
name|UFS_BALLOC
argument_list|(
name|vp
argument_list|,
name|lblktosize
argument_list|(
name|fs
argument_list|,
call|(
name|off_t
call|)
argument_list|(
name|base
operator|+
name|loc
argument_list|)
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
name|B_METAONLY
argument_list|,
operator|&
name|ibp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|indiroff
operator|=
operator|(
name|base
operator|+
name|loc
operator|-
name|NDADDR
operator|)
operator|%
name|NINDIR
argument_list|(
name|fs
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|loc
operator|<
name|len
condition|;
name|loc
operator|++
operator|,
name|indiroff
operator|++
control|)
block|{
if|if
condition|(
name|indiroff
operator|>=
name|NINDIR
argument_list|(
name|fs
argument_list|)
condition|)
block|{
if|if
condition|(
name|passno
operator|==
literal|2
condition|)
name|ibp
operator|->
name|b_flags
operator||=
name|B_VALIDSUSPWRT
expr_stmt|;
name|bawrite
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
name|error
operator|=
name|UFS_BALLOC
argument_list|(
name|vp
argument_list|,
name|lblktosize
argument_list|(
name|fs
argument_list|,
call|(
name|off_t
call|)
argument_list|(
name|base
operator|+
name|loc
argument_list|)
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
name|B_METAONLY
argument_list|,
operator|&
name|ibp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|indiroff
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ffs_isblock
argument_list|(
name|fs
argument_list|,
name|cg_blksfree
argument_list|(
name|cgp
argument_list|)
argument_list|,
name|loc
argument_list|)
condition|)
operator|(
operator|(
name|ufs_daddr_t
operator|*
operator|)
operator|(
name|ibp
operator|->
name|b_data
operator|)
operator|)
index|[
name|indiroff
index|]
operator|=
name|BLK_NOCOPY
expr_stmt|;
elseif|else
if|if
condition|(
name|passno
operator|==
literal|2
operator|&&
operator|(
operator|(
name|ufs_daddr_t
operator|*
operator|)
operator|(
name|ibp
operator|->
name|b_data
operator|)
operator|)
index|[
name|indiroff
index|]
operator|==
name|BLK_NOCOPY
condition|)
operator|(
operator|(
name|ufs_daddr_t
operator|*
operator|)
operator|(
name|ibp
operator|->
name|b_data
operator|)
operator|)
index|[
name|indiroff
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|passno
operator|==
literal|1
operator|&&
operator|(
operator|(
name|ufs_daddr_t
operator|*
operator|)
operator|(
name|ibp
operator|->
name|b_data
operator|)
operator|)
index|[
name|indiroff
index|]
operator|==
name|BLK_NOCOPY
condition|)
name|panic
argument_list|(
literal|"ffs_snapshot: lost indirect block"
argument_list|)
expr_stmt|;
block|}
name|bqrelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|passno
operator|==
literal|2
condition|)
name|ibp
operator|->
name|b_flags
operator||=
name|B_VALIDSUSPWRT
expr_stmt|;
name|bdwrite
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Before expunging a snapshot inode, note all the  * blocks that it claims with BLK_SNAP so that fsck will  * be able to account for those blocks properly and so  * that this snapshot knows that it need not copy them  * if the other snapshot holding them is freed.  */
end_comment

begin_function_decl
specifier|static
name|int
name|expunge
parameter_list|(
name|snapvp
parameter_list|,
name|cancelip
parameter_list|,
name|fs
parameter_list|,
name|acctfunc
parameter_list|,
name|expungetype
parameter_list|)
name|struct
name|vnode
modifier|*
name|snapvp
decl_stmt|;
name|struct
name|inode
modifier|*
name|cancelip
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
function_decl|int
parameter_list|(
function_decl|*acctfunc
end_function_decl

begin_expr_stmt
unit|)
name|__P
argument_list|(
operator|(
expr|struct
name|vnode
operator|*
operator|,
name|ufs_daddr_t
operator|*
operator|,
name|ufs_daddr_t
operator|*
operator|,
expr|struct
name|fs
operator|*
operator|,
name|ufs_daddr_t
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|expungetype
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|len
decl_stmt|,
name|error
decl_stmt|,
name|numblks
decl_stmt|,
name|blksperindir
decl_stmt|;
name|ufs_daddr_t
name|lbn
decl_stmt|,
name|rlbn
decl_stmt|,
name|blkno
decl_stmt|,
name|indiroff
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|dinode
modifier|*
name|dip
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|numblks
operator|=
name|howmany
argument_list|(
name|cancelip
operator|->
name|i_size
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
call|(
modifier|*
name|acctfunc
call|)
argument_list|(
name|snapvp
argument_list|,
operator|&
name|cancelip
operator|->
name|i_db
index|[
literal|0
index|]
argument_list|,
operator|&
name|cancelip
operator|->
name|i_ib
index|[
name|NIADDR
index|]
argument_list|,
name|fs
argument_list|,
literal|0
argument_list|,
name|expungetype
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|blksperindir
operator|=
literal|1
expr_stmt|;
name|lbn
operator|=
operator|-
name|NDADDR
expr_stmt|;
name|len
operator|=
name|numblks
operator|-
name|NDADDR
expr_stmt|;
name|rlbn
operator|=
name|NDADDR
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|len
operator|>
literal|0
operator|&&
name|i
operator|<
name|NIADDR
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|indiracct
argument_list|(
name|snapvp
argument_list|,
name|ITOV
argument_list|(
name|cancelip
argument_list|)
argument_list|,
name|i
argument_list|,
name|cancelip
operator|->
name|i_ib
index|[
name|i
index|]
argument_list|,
name|lbn
argument_list|,
name|rlbn
argument_list|,
name|len
argument_list|,
name|blksperindir
argument_list|,
name|fs
argument_list|,
name|acctfunc
argument_list|,
name|expungetype
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|blksperindir
operator|*=
name|NINDIR
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|lbn
operator|-=
name|blksperindir
operator|+
literal|1
expr_stmt|;
name|len
operator|-=
name|blksperindir
expr_stmt|;
name|rlbn
operator|+=
name|blksperindir
expr_stmt|;
block|}
comment|/* 	 * Prepare to expunge the inode. If its inode block has not 	 * yet been copied, then allocate and fill the copy. 	 */
name|lbn
operator|=
name|fragstoblks
argument_list|(
name|fs
argument_list|,
name|ino_to_fsba
argument_list|(
name|fs
argument_list|,
name|cancelip
operator|->
name|i_number
argument_list|)
argument_list|)
expr_stmt|;
name|blkno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lbn
operator|<
name|NDADDR
condition|)
block|{
name|blkno
operator|=
name|cancelip
operator|->
name|i_db
index|[
name|lbn
index|]
expr_stmt|;
block|}
else|else
block|{
name|td
operator|->
name|td_proc
operator|->
name|p_flag
operator||=
name|P_COWINPROGRESS
expr_stmt|;
name|error
operator|=
name|UFS_BALLOC
argument_list|(
name|snapvp
argument_list|,
name|lblktosize
argument_list|(
name|fs
argument_list|,
operator|(
name|off_t
operator|)
name|lbn
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
name|B_METAONLY
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_proc
operator|->
name|p_flag
operator|&=
operator|~
name|P_COWINPROGRESS
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|indiroff
operator|=
operator|(
name|lbn
operator|-
name|NDADDR
operator|)
operator|%
name|NINDIR
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|blkno
operator|=
operator|(
operator|(
name|ufs_daddr_t
operator|*
operator|)
operator|(
name|bp
operator|->
name|b_data
operator|)
operator|)
index|[
name|indiroff
index|]
expr_stmt|;
name|bqrelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|UFS_BALLOC
argument_list|(
name|snapvp
argument_list|,
name|lblktosize
argument_list|(
name|fs
argument_list|,
operator|(
name|off_t
operator|)
name|lbn
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|blkno
operator|==
literal|0
operator|&&
operator|(
name|error
operator|=
name|readblock
argument_list|(
name|bp
argument_list|,
name|lbn
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Set a snapshot inode to be a zero length file, regular files 	 * to be completely unallocated. 	 */
name|dip
operator|=
operator|(
expr|struct
name|dinode
operator|*
operator|)
name|bp
operator|->
name|b_data
operator|+
name|ino_to_fsbo
argument_list|(
name|fs
argument_list|,
name|cancelip
operator|->
name|i_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|expungetype
operator|==
name|BLK_NOCOPY
condition|)
name|dip
operator|->
name|di_mode
operator|=
literal|0
expr_stmt|;
name|dip
operator|->
name|di_size
operator|=
literal|0
expr_stmt|;
name|dip
operator|->
name|di_blocks
operator|=
literal|0
expr_stmt|;
name|dip
operator|->
name|di_flags
operator|&=
operator|~
name|SF_SNAPSHOT
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|dip
operator|->
name|di_db
index|[
literal|0
index|]
argument_list|,
operator|(
name|NDADDR
operator|+
name|NIADDR
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|ufs_daddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|bdwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Descend an indirect block chain for vnode cancelvp accounting for all  * its indirect blocks in snapvp.  */
end_comment

begin_function_decl
specifier|static
name|int
name|indiracct
parameter_list|(
name|snapvp
parameter_list|,
name|cancelvp
parameter_list|,
name|level
parameter_list|,
name|blkno
parameter_list|,
name|lbn
parameter_list|,
name|rlbn
parameter_list|,
name|remblks
parameter_list|,
name|blksperindir
parameter_list|,
name|fs
parameter_list|,
name|acctfunc
parameter_list|,
name|expungetype
parameter_list|)
name|struct
name|vnode
modifier|*
name|snapvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|cancelvp
decl_stmt|;
name|int
name|level
decl_stmt|;
name|ufs_daddr_t
name|blkno
decl_stmt|;
name|int
name|lbn
decl_stmt|;
name|int
name|rlbn
decl_stmt|;
name|int
name|remblks
decl_stmt|;
name|int
name|blksperindir
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
function_decl|int
parameter_list|(
function_decl|*acctfunc
end_function_decl

begin_expr_stmt
unit|)
name|__P
argument_list|(
operator|(
expr|struct
name|vnode
operator|*
operator|,
name|ufs_daddr_t
operator|*
operator|,
name|ufs_daddr_t
operator|*
operator|,
expr|struct
name|fs
operator|*
operator|,
name|ufs_daddr_t
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|expungetype
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|subblksperindir
decl_stmt|,
name|error
decl_stmt|,
name|last
decl_stmt|,
name|num
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|indir
name|indirs
index|[
name|NIADDR
operator|+
literal|2
index|]
decl_stmt|;
name|ufs_daddr_t
modifier|*
name|bap
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ufs_getlbns
argument_list|(
name|cancelvp
argument_list|,
name|rlbn
argument_list|,
name|indirs
argument_list|,
operator|&
name|num
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|lbn
operator|!=
name|indirs
index|[
name|num
operator|-
literal|1
operator|-
name|level
index|]
operator|.
name|in_lbn
operator|||
name|blkno
operator|==
literal|0
operator|||
name|num
operator|<
literal|2
condition|)
name|panic
argument_list|(
literal|"indiracct: botched params"
argument_list|)
expr_stmt|;
comment|/* 	 * We have to expand bread here since it will deadlock looking 	 * up the block number for any blocks that are not in the cache. 	 */
name|bp
operator|=
name|getblk
argument_list|(
name|cancelvp
argument_list|,
name|lbn
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_blkno
operator|=
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|blkno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_DONE
operator||
name|B_DELWRI
operator|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|error
operator|=
name|readblock
argument_list|(
name|bp
argument_list|,
name|fragstoblks
argument_list|(
name|fs
argument_list|,
name|blkno
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Account for the block pointers in this indirect block. 	 */
name|last
operator|=
name|howmany
argument_list|(
name|remblks
argument_list|,
name|blksperindir
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
operator|>
name|NINDIR
argument_list|(
name|fs
argument_list|)
condition|)
name|last
operator|=
name|NINDIR
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|bap
argument_list|,
name|ufs_daddr_t
operator|*
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
operator|(
name|caddr_t
operator|)
name|bap
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
name|bqrelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|acctfunc
call|)
argument_list|(
name|snapvp
argument_list|,
operator|&
name|bap
index|[
literal|0
index|]
argument_list|,
operator|&
name|bap
index|[
name|last
index|]
argument_list|,
name|fs
argument_list|,
name|rlbn
argument_list|,
name|expungetype
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|level
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Account for the block pointers in each of the indirect blocks 	 * in the levels below us. 	 */
name|subblksperindir
operator|=
name|blksperindir
operator|/
name|NINDIR
argument_list|(
name|fs
argument_list|)
expr_stmt|;
for|for
control|(
name|lbn
operator|++
operator|,
name|level
operator|--
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|last
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|indiracct
argument_list|(
name|snapvp
argument_list|,
name|cancelvp
argument_list|,
name|level
argument_list|,
name|bap
index|[
name|i
index|]
argument_list|,
name|lbn
argument_list|,
name|rlbn
argument_list|,
name|remblks
argument_list|,
name|subblksperindir
argument_list|,
name|fs
argument_list|,
name|acctfunc
argument_list|,
name|expungetype
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|rlbn
operator|+=
name|blksperindir
expr_stmt|;
name|lbn
operator|-=
name|blksperindir
expr_stmt|;
name|remblks
operator|-=
name|blksperindir
expr_stmt|;
block|}
name|out
label|:
name|FREE
argument_list|(
name|bap
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Do both snap accounting and map accounting.  */
end_comment

begin_function
specifier|static
name|int
name|fullacct
parameter_list|(
name|vp
parameter_list|,
name|oldblkp
parameter_list|,
name|lastblkp
parameter_list|,
name|fs
parameter_list|,
name|lblkno
parameter_list|,
name|expungetype
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|ufs_daddr_t
modifier|*
name|oldblkp
decl_stmt|,
decl|*
name|lastblkp
decl_stmt|;
end_function

begin_decl_stmt
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ufs_daddr_t
name|lblkno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|expungetype
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* BLK_SNAP or BLK_NOCOPY */
end_comment

begin_block
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|snapacct
argument_list|(
name|vp
argument_list|,
name|oldblkp
argument_list|,
name|lastblkp
argument_list|,
name|fs
argument_list|,
name|lblkno
argument_list|,
name|expungetype
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
name|mapacct
argument_list|(
name|vp
argument_list|,
name|oldblkp
argument_list|,
name|lastblkp
argument_list|,
name|fs
argument_list|,
name|lblkno
argument_list|,
name|expungetype
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Identify a set of blocks allocated in a snapshot inode.  */
end_comment

begin_function
specifier|static
name|int
name|snapacct
parameter_list|(
name|vp
parameter_list|,
name|oldblkp
parameter_list|,
name|lastblkp
parameter_list|,
name|fs
parameter_list|,
name|lblkno
parameter_list|,
name|expungetype
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|ufs_daddr_t
modifier|*
name|oldblkp
decl_stmt|,
decl|*
name|lastblkp
decl_stmt|;
end_function

begin_decl_stmt
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ufs_daddr_t
name|lblkno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|expungetype
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* BLK_SNAP or BLK_NOCOPY */
end_comment

begin_block
block|{
name|struct
name|inode
modifier|*
name|ip
init|=
name|VTOI
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|ufs_daddr_t
name|lbn
decl_stmt|,
name|blkno
decl_stmt|,
modifier|*
name|blkp
decl_stmt|;
name|struct
name|buf
modifier|*
name|ibp
decl_stmt|;
name|int
name|error
decl_stmt|;
for|for
control|(
init|;
name|oldblkp
operator|<
name|lastblkp
condition|;
name|oldblkp
operator|++
control|)
block|{
name|blkno
operator|=
operator|*
name|oldblkp
expr_stmt|;
if|if
condition|(
name|blkno
operator|==
literal|0
operator|||
name|blkno
operator|==
name|BLK_NOCOPY
operator|||
name|blkno
operator|==
name|BLK_SNAP
condition|)
continue|continue;
name|lbn
operator|=
name|fragstoblks
argument_list|(
name|fs
argument_list|,
name|blkno
argument_list|)
expr_stmt|;
if|if
condition|(
name|lbn
operator|<
name|NDADDR
condition|)
block|{
name|blkp
operator|=
operator|&
name|ip
operator|->
name|i_db
index|[
name|lbn
index|]
expr_stmt|;
name|ip
operator|->
name|i_flag
operator||=
name|IN_CHANGE
operator||
name|IN_UPDATE
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|UFS_BALLOC
argument_list|(
name|vp
argument_list|,
name|lblktosize
argument_list|(
name|fs
argument_list|,
operator|(
name|off_t
operator|)
name|lbn
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
name|B_METAONLY
argument_list|,
operator|&
name|ibp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|blkp
operator|=
operator|&
operator|(
operator|(
name|ufs_daddr_t
operator|*
operator|)
operator|(
name|ibp
operator|->
name|b_data
operator|)
operator|)
index|[
operator|(
name|lbn
operator|-
name|NDADDR
operator|)
operator|%
name|NINDIR
argument_list|(
name|fs
argument_list|)
index|]
expr_stmt|;
block|}
comment|/* 		 * If we are expunging a snapshot vnode and we 		 * find a block marked BLK_NOCOPY, then it is 		 * one that has been allocated to this snapshot after 		 * we took our current snapshot and can be ignored. 		 */
if|if
condition|(
name|expungetype
operator|==
name|BLK_SNAP
operator|&&
operator|*
name|blkp
operator|==
name|BLK_NOCOPY
condition|)
block|{
if|if
condition|(
name|lbn
operator|>=
name|NDADDR
condition|)
name|brelse
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|blkp
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"snapacct: bad block"
argument_list|)
expr_stmt|;
operator|*
name|blkp
operator|=
name|expungetype
expr_stmt|;
if|if
condition|(
name|lbn
operator|>=
name|NDADDR
condition|)
name|bdwrite
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Account for a set of blocks allocated in a snapshot inode.  */
end_comment

begin_function
specifier|static
name|int
name|mapacct
parameter_list|(
name|vp
parameter_list|,
name|oldblkp
parameter_list|,
name|lastblkp
parameter_list|,
name|fs
parameter_list|,
name|lblkno
parameter_list|,
name|expungetype
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|ufs_daddr_t
modifier|*
name|oldblkp
decl_stmt|,
decl|*
name|lastblkp
decl_stmt|;
end_function

begin_decl_stmt
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ufs_daddr_t
name|lblkno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|expungetype
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|ufs_daddr_t
name|blkno
decl_stmt|;
name|ino_t
name|inum
decl_stmt|;
name|inum
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
operator|->
name|i_number
expr_stmt|;
for|for
control|(
init|;
name|oldblkp
operator|<
name|lastblkp
condition|;
name|oldblkp
operator|++
operator|,
name|lblkno
operator|++
control|)
block|{
name|blkno
operator|=
operator|*
name|oldblkp
expr_stmt|;
if|if
condition|(
name|blkno
operator|==
literal|0
operator|||
name|blkno
operator|==
name|BLK_NOCOPY
condition|)
continue|continue;
if|if
condition|(
name|blkno
operator|==
name|BLK_SNAP
condition|)
name|blkno
operator|=
name|blkstofrags
argument_list|(
name|fs
argument_list|,
name|lblkno
argument_list|)
expr_stmt|;
name|ffs_blkfree
argument_list|(
name|fs
argument_list|,
name|vp
argument_list|,
name|blkno
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|inum
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Decrement extra reference on snapshot when last name is removed.  * It will not be freed until the last open reference goes away.  */
end_comment

begin_function
name|void
name|ffs_snapgone
parameter_list|(
name|ip
parameter_list|)
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
block|{
name|struct
name|inode
modifier|*
name|xp
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|int
name|snaploc
decl_stmt|;
comment|/* 	 * Find snapshot in incore list. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|xp
argument_list|,
argument|&ip->i_devvp->v_rdev->si_snapshots
argument_list|,
argument|i_nextsnap
argument_list|)
if|if
condition|(
name|xp
operator|==
name|ip
condition|)
break|break;
if|if
condition|(
name|xp
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"ffs_snapgone: lost snapshot vnode %d\n"
argument_list|,
name|ip
operator|->
name|i_number
argument_list|)
expr_stmt|;
else|else
name|vrele
argument_list|(
name|ITOV
argument_list|(
name|ip
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Delete snapshot inode from superblock. Keep list dense. 	 */
name|fs
operator|=
name|ip
operator|->
name|i_fs
expr_stmt|;
for|for
control|(
name|snaploc
operator|=
literal|0
init|;
name|snaploc
operator|<
name|FSMAXSNAP
condition|;
name|snaploc
operator|++
control|)
if|if
condition|(
name|fs
operator|->
name|fs_snapinum
index|[
name|snaploc
index|]
operator|==
name|ip
operator|->
name|i_number
condition|)
break|break;
if|if
condition|(
name|snaploc
operator|<
name|FSMAXSNAP
condition|)
block|{
for|for
control|(
name|snaploc
operator|++
init|;
name|snaploc
operator|<
name|FSMAXSNAP
condition|;
name|snaploc
operator|++
control|)
block|{
if|if
condition|(
name|fs
operator|->
name|fs_snapinum
index|[
name|snaploc
index|]
operator|==
literal|0
condition|)
break|break;
name|fs
operator|->
name|fs_snapinum
index|[
name|snaploc
operator|-
literal|1
index|]
operator|=
name|fs
operator|->
name|fs_snapinum
index|[
name|snaploc
index|]
expr_stmt|;
block|}
name|fs
operator|->
name|fs_snapinum
index|[
name|snaploc
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Prepare a snapshot file for being removed.  */
end_comment

begin_function
name|void
name|ffs_snapremove
parameter_list|(
name|vp
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
block|{
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|struct
name|vnode
modifier|*
name|devvp
decl_stmt|;
name|struct
name|buf
modifier|*
name|ibp
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|ufs_daddr_t
name|blkno
decl_stmt|,
name|dblk
decl_stmt|;
name|int
name|error
decl_stmt|,
name|numblks
decl_stmt|,
name|loc
decl_stmt|,
name|last
decl_stmt|;
name|ip
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|fs
operator|=
name|ip
operator|->
name|i_fs
expr_stmt|;
comment|/* 	 * If active, delete from incore list (this snapshot may 	 * already have been in the process of being deleted, so 	 * would not have been active). 	 * 	 * Clear copy-on-write flag if last snapshot. 	 */
if|if
condition|(
name|ip
operator|->
name|i_nextsnap
operator|.
name|tqe_prev
operator|!=
literal|0
condition|)
block|{
name|devvp
operator|=
name|ip
operator|->
name|i_devvp
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|devvp
operator|->
name|v_rdev
operator|->
name|si_snapshots
argument_list|,
name|ip
argument_list|,
name|i_nextsnap
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_nextsnap
operator|.
name|tqe_prev
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|devvp
operator|->
name|v_rdev
operator|->
name|si_snapshots
argument_list|)
operator|==
literal|0
condition|)
block|{
name|devvp
operator|->
name|v_rdev
operator|->
name|si_copyonwrite
operator|=
literal|0
expr_stmt|;
name|devvp
operator|->
name|v_flag
operator|&=
operator|~
name|VCOPYONWRITE
expr_stmt|;
block|}
block|}
comment|/* 	 * Clear all BLK_NOCOPY fields. Pass any block claims to other 	 * snapshots that want them (see ffs_snapblkfree below). 	 */
for|for
control|(
name|blkno
operator|=
literal|1
init|;
name|blkno
operator|<
name|NDADDR
condition|;
name|blkno
operator|++
control|)
block|{
name|dblk
operator|=
name|ip
operator|->
name|i_db
index|[
name|blkno
index|]
expr_stmt|;
if|if
condition|(
name|dblk
operator|==
name|BLK_NOCOPY
operator|||
name|dblk
operator|==
name|BLK_SNAP
condition|)
name|ip
operator|->
name|i_db
index|[
name|blkno
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|dblk
operator|==
name|blkstofrags
argument_list|(
name|fs
argument_list|,
name|blkno
argument_list|)
operator|&&
name|ffs_snapblkfree
argument_list|(
name|fs
argument_list|,
name|ip
operator|->
name|i_devvp
argument_list|,
name|dblk
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|ip
operator|->
name|i_number
argument_list|)
operator|)
condition|)
block|{
name|ip
operator|->
name|i_blocks
operator|-=
name|btodb
argument_list|(
name|fs
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_db
index|[
name|blkno
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|numblks
operator|=
name|howmany
argument_list|(
name|ip
operator|->
name|i_size
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
for|for
control|(
name|blkno
operator|=
name|NDADDR
init|;
name|blkno
operator|<
name|numblks
condition|;
name|blkno
operator|+=
name|NINDIR
argument_list|(
name|fs
argument_list|)
control|)
block|{
name|error
operator|=
name|UFS_BALLOC
argument_list|(
name|vp
argument_list|,
name|lblktosize
argument_list|(
name|fs
argument_list|,
operator|(
name|off_t
operator|)
name|blkno
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
name|B_METAONLY
argument_list|,
operator|&
name|ibp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
continue|continue;
if|if
condition|(
operator|(
name|last
operator|=
name|fs
operator|->
name|fs_size
operator|-
name|blkno
operator|)
operator|>
name|NINDIR
argument_list|(
name|fs
argument_list|)
condition|)
name|last
operator|=
name|NINDIR
argument_list|(
name|fs
argument_list|)
expr_stmt|;
for|for
control|(
name|loc
operator|=
literal|0
init|;
name|loc
operator|<
name|last
condition|;
name|loc
operator|++
control|)
block|{
name|dblk
operator|=
operator|(
operator|(
name|ufs_daddr_t
operator|*
operator|)
operator|(
name|ibp
operator|->
name|b_data
operator|)
operator|)
index|[
name|loc
index|]
expr_stmt|;
if|if
condition|(
name|dblk
operator|==
name|BLK_NOCOPY
operator|||
name|dblk
operator|==
name|BLK_SNAP
condition|)
operator|(
operator|(
name|ufs_daddr_t
operator|*
operator|)
operator|(
name|ibp
operator|->
name|b_data
operator|)
operator|)
index|[
name|loc
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|dblk
operator|==
name|blkstofrags
argument_list|(
name|fs
argument_list|,
name|blkno
argument_list|)
operator|&&
name|ffs_snapblkfree
argument_list|(
name|fs
argument_list|,
name|ip
operator|->
name|i_devvp
argument_list|,
name|dblk
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|ip
operator|->
name|i_number
argument_list|)
operator|)
condition|)
block|{
name|ip
operator|->
name|i_blocks
operator|-=
name|btodb
argument_list|(
name|fs
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
operator|(
operator|(
name|ufs_daddr_t
operator|*
operator|)
operator|(
name|ibp
operator|->
name|b_data
operator|)
operator|)
index|[
name|loc
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|bawrite
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Clear snapshot flag and drop reference. 	 */
name|ip
operator|->
name|i_flags
operator|&=
operator|~
name|SF_SNAPSHOT
expr_stmt|;
name|ip
operator|->
name|i_flag
operator||=
name|IN_CHANGE
operator||
name|IN_UPDATE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Notification that a block is being freed. Return zero if the free  * should be allowed to proceed. Return non-zero if the snapshot file  * wants to claim the block. The block will be claimed if it is an  * uncopied part of one of the snapshots. It will be freed if it is  * either a BLK_NOCOPY or has already been copied in all of the snapshots.  * If a fragment is being freed, then all snapshots that care about  * it must make a copy since a snapshot file can only claim full sized  * blocks. Note that if more than one snapshot file maps the block,  * we can pick one at random to claim it. Since none of the snapshots  * can change, we are assurred that they will all see the same unmodified  * image. When deleting a snapshot file (see ffs_snapremove above), we  * must push any of these claimed blocks to one of the other snapshots  * that maps it. These claimed blocks are easily identified as they will  * have a block number equal to their logical block number within the  * snapshot. A copied block can never have this property because they  * must always have been allocated from a BLK_NOCOPY location.  */
end_comment

begin_function
name|int
name|ffs_snapblkfree
parameter_list|(
name|fs
parameter_list|,
name|devvp
parameter_list|,
name|bno
parameter_list|,
name|size
parameter_list|,
name|inum
parameter_list|)
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|struct
name|vnode
modifier|*
name|devvp
decl_stmt|;
name|ufs_daddr_t
name|bno
decl_stmt|;
name|long
name|size
decl_stmt|;
name|ino_t
name|inum
decl_stmt|;
block|{
name|struct
name|buf
modifier|*
name|ibp
decl_stmt|,
modifier|*
name|cbp
decl_stmt|,
modifier|*
name|savedcbp
init|=
literal|0
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|ufs_daddr_t
name|lbn
decl_stmt|,
name|blkno
decl_stmt|;
name|int
name|indiroff
init|=
literal|0
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|,
name|claimedblk
init|=
literal|0
decl_stmt|;
name|struct
name|snaphead
modifier|*
name|snaphead
decl_stmt|;
name|lbn
operator|=
name|fragstoblks
argument_list|(
name|fs
argument_list|,
name|bno
argument_list|)
expr_stmt|;
name|snaphead
operator|=
operator|&
name|devvp
operator|->
name|v_rdev
operator|->
name|si_snapshots
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ip
argument_list|,
argument|snaphead
argument_list|,
argument|i_nextsnap
argument_list|)
block|{
name|vp
operator|=
name|ITOV
argument_list|(
name|ip
argument_list|)
expr_stmt|;
comment|/* 		 * Lookup block being written. 		 */
if|if
condition|(
name|lbn
operator|<
name|NDADDR
condition|)
block|{
name|blkno
operator|=
name|ip
operator|->
name|i_db
index|[
name|lbn
index|]
expr_stmt|;
block|}
else|else
block|{
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_proc
operator|->
name|p_flag
operator||=
name|P_COWINPROGRESS
expr_stmt|;
name|error
operator|=
name|UFS_BALLOC
argument_list|(
name|vp
argument_list|,
name|lblktosize
argument_list|(
name|fs
argument_list|,
operator|(
name|off_t
operator|)
name|lbn
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
name|B_METAONLY
argument_list|,
operator|&
name|ibp
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_proc
operator|->
name|p_flag
operator|&=
operator|~
name|P_COWINPROGRESS
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|indiroff
operator|=
operator|(
name|lbn
operator|-
name|NDADDR
operator|)
operator|%
name|NINDIR
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|blkno
operator|=
operator|(
operator|(
name|ufs_daddr_t
operator|*
operator|)
operator|(
name|ibp
operator|->
name|b_data
operator|)
operator|)
index|[
name|indiroff
index|]
expr_stmt|;
block|}
comment|/* 		 * Check to see if block needs to be copied. 		 */
switch|switch
condition|(
name|blkno
condition|)
block|{
comment|/* 		 * If the snapshot has already copied the block (default), 		 * or does not care about the block, it is not needed. 		 */
default|default:
case|case
name|BLK_NOCOPY
case|:
if|if
condition|(
name|lbn
operator|>=
name|NDADDR
condition|)
name|bqrelse
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
continue|continue;
comment|/* 		 * No previous snapshot claimed the block, so it will be 		 * freed and become a BLK_NOCOPY (don't care) for us. 		 */
case|case
name|BLK_SNAP
case|:
if|if
condition|(
name|claimedblk
condition|)
name|panic
argument_list|(
literal|"snapblkfree: inconsistent block type"
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|lbn
operator|<
name|NDADDR
condition|)
block|{
name|ip
operator|->
name|i_db
index|[
name|lbn
index|]
operator|=
name|BLK_NOCOPY
expr_stmt|;
name|ip
operator|->
name|i_flag
operator||=
name|IN_CHANGE
operator||
name|IN_UPDATE
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|(
name|ufs_daddr_t
operator|*
operator|)
operator|(
name|ibp
operator|->
name|b_data
operator|)
operator|)
index|[
name|indiroff
index|]
operator|=
name|BLK_NOCOPY
expr_stmt|;
name|bdwrite
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
block|}
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
continue|continue;
comment|/* 		 * A block that we map is being freed. If it has not been 		 * claimed yet, we will claim or copy it (below). 		 */
case|case
literal|0
case|:
name|claimedblk
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* 		 * If this is a full size block, we will just grab it 		 * and assign it to the snapshot inode. Otherwise we 		 * will proceed to copy it. See explanation for this 		 * routine as to why only a single snapshot needs to 		 * claim this block. 		 */
if|if
condition|(
name|size
operator|==
name|fs
operator|->
name|fs_bsize
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|snapdebug
condition|)
name|printf
argument_list|(
literal|"%s %d lbn %d from inum %d\n"
argument_list|,
literal|"Grabonremove: snapino"
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
name|lbn
argument_list|,
name|inum
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|lbn
operator|<
name|NDADDR
condition|)
block|{
name|ip
operator|->
name|i_db
index|[
name|lbn
index|]
operator|=
name|bno
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|(
name|ufs_daddr_t
operator|*
operator|)
operator|(
name|ibp
operator|->
name|b_data
operator|)
operator|)
index|[
name|indiroff
index|]
operator|=
name|bno
expr_stmt|;
name|bdwrite
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
block|}
name|ip
operator|->
name|i_blocks
operator|+=
name|btodb
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_flag
operator||=
name|IN_CHANGE
operator||
name|IN_UPDATE
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|lbn
operator|>=
name|NDADDR
condition|)
name|bqrelse
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
comment|/* 		 * Allocate the block into which to do the copy. Note that this 		 * allocation will never require any additional allocations for 		 * the snapshot inode. 		 */
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_proc
operator|->
name|p_flag
operator||=
name|P_COWINPROGRESS
expr_stmt|;
name|error
operator|=
name|UFS_BALLOC
argument_list|(
name|vp
argument_list|,
name|lblktosize
argument_list|(
name|fs
argument_list|,
operator|(
name|off_t
operator|)
name|lbn
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
literal|0
argument_list|,
operator|&
name|cbp
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_proc
operator|->
name|p_flag
operator|&=
operator|~
name|P_COWINPROGRESS
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|snapdebug
condition|)
name|printf
argument_list|(
literal|"%s%d lbn %d for inum %d size %ld to blkno %d\n"
argument_list|,
literal|"Copyonremove: snapino "
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
name|lbn
argument_list|,
name|inum
argument_list|,
name|size
argument_list|,
name|cbp
operator|->
name|b_blkno
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * If we have already read the old block contents, then 		 * simply copy them to the new block. Note that we need 		 * to synchronously write snapshots that have not been 		 * unlinked, and hence will be visible after a crash, 		 * to ensure their integrity. 		 */
if|if
condition|(
name|savedcbp
operator|!=
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|savedcbp
operator|->
name|b_data
argument_list|,
name|cbp
operator|->
name|b_data
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
name|bawrite
argument_list|(
name|cbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dopersistence
operator|&&
name|ip
operator|->
name|i_effnlink
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|VOP_FSYNC
argument_list|(
name|vp
argument_list|,
name|KERNCRED
argument_list|,
name|MNT_WAIT
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Otherwise, read the old block contents into the buffer. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|readblock
argument_list|(
name|cbp
argument_list|,
name|lbn
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|bzero
argument_list|(
name|cbp
operator|->
name|b_data
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
name|bawrite
argument_list|(
name|cbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dopersistence
operator|&&
name|ip
operator|->
name|i_effnlink
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|VOP_FSYNC
argument_list|(
name|vp
argument_list|,
name|KERNCRED
argument_list|,
name|MNT_WAIT
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
break|break;
block|}
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|savedcbp
operator|=
name|cbp
expr_stmt|;
block|}
comment|/* 	 * Note that we need to synchronously write snapshots that 	 * have not been unlinked, and hence will be visible after 	 * a crash, to ensure their integrity. 	 */
if|if
condition|(
name|savedcbp
condition|)
block|{
name|vp
operator|=
name|savedcbp
operator|->
name|b_vp
expr_stmt|;
name|bawrite
argument_list|(
name|savedcbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dopersistence
operator|&&
name|VTOI
argument_list|(
name|vp
argument_list|)
operator|->
name|i_effnlink
operator|>
literal|0
condition|)
block|{
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|td
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|VOP_FSYNC
argument_list|(
name|vp
argument_list|,
name|KERNCRED
argument_list|,
name|MNT_WAIT
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * If we have been unable to allocate a block in which to do 	 * the copy, then return non-zero so that the fragment will 	 * not be freed. Although space will be lost, the snapshot 	 * will stay consistent. 	 */
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Associate snapshot files when mounting.  */
end_comment

begin_function
name|void
name|ffs_snapshot_mount
parameter_list|(
name|mp
parameter_list|)
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
block|{
name|struct
name|ufsmount
modifier|*
name|ump
init|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
init|=
name|ump
operator|->
name|um_fs
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|snaphead
modifier|*
name|snaphead
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|int
name|error
decl_stmt|,
name|snaploc
decl_stmt|,
name|loc
decl_stmt|;
name|snaphead
operator|=
operator|&
name|ump
operator|->
name|um_devvp
operator|->
name|v_rdev
operator|->
name|si_snapshots
expr_stmt|;
for|for
control|(
name|snaploc
operator|=
literal|0
init|;
name|snaploc
operator|<
name|FSMAXSNAP
condition|;
name|snaploc
operator|++
control|)
block|{
if|if
condition|(
name|fs
operator|->
name|fs_snapinum
index|[
name|snaploc
index|]
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|error
operator|=
name|VFS_VGET
argument_list|(
name|mp
argument_list|,
name|fs
operator|->
name|fs_snapinum
index|[
name|snaploc
index|]
argument_list|,
operator|&
name|vp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ffs_snapshot_mount: vget failed %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ip
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ip
operator|->
name|i_flags
operator|&
name|SF_SNAPSHOT
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ffs_snapshot_mount: non-snapshot inode %d\n"
argument_list|,
name|fs
operator|->
name|fs_snapinum
index|[
name|snaploc
index|]
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
for|for
control|(
name|loc
operator|=
name|snaploc
operator|+
literal|1
init|;
name|loc
operator|<
name|FSMAXSNAP
condition|;
name|loc
operator|++
control|)
block|{
if|if
condition|(
name|fs
operator|->
name|fs_snapinum
index|[
name|loc
index|]
operator|==
literal|0
condition|)
break|break;
name|fs
operator|->
name|fs_snapinum
index|[
name|loc
operator|-
literal|1
index|]
operator|=
name|fs
operator|->
name|fs_snapinum
index|[
name|loc
index|]
expr_stmt|;
block|}
name|fs
operator|->
name|fs_snapinum
index|[
name|loc
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|snaploc
operator|--
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ip
operator|->
name|i_nextsnap
operator|.
name|tqe_prev
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"ffs_snapshot_mount: %d already on list"
argument_list|,
name|ip
operator|->
name|i_number
argument_list|)
expr_stmt|;
else|else
name|TAILQ_INSERT_TAIL
argument_list|(
name|snaphead
argument_list|,
name|ip
argument_list|,
name|i_nextsnap
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_flag
operator||=
name|VSYSTEM
expr_stmt|;
name|ump
operator|->
name|um_devvp
operator|->
name|v_rdev
operator|->
name|si_copyonwrite
operator|=
name|ffs_copyonwrite
expr_stmt|;
name|ump
operator|->
name|um_devvp
operator|->
name|v_flag
operator||=
name|VCOPYONWRITE
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Disassociate snapshot files when unmounting.  */
end_comment

begin_function
name|void
name|ffs_snapshot_unmount
parameter_list|(
name|mp
parameter_list|)
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
block|{
name|struct
name|ufsmount
modifier|*
name|ump
init|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
decl_stmt|;
name|struct
name|snaphead
modifier|*
name|snaphead
init|=
operator|&
name|ump
operator|->
name|um_devvp
operator|->
name|v_rdev
operator|->
name|si_snapshots
decl_stmt|;
name|struct
name|inode
modifier|*
name|xp
decl_stmt|;
while|while
condition|(
operator|(
name|xp
operator|=
name|TAILQ_FIRST
argument_list|(
name|snaphead
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
name|snaphead
argument_list|,
name|xp
argument_list|,
name|i_nextsnap
argument_list|)
expr_stmt|;
name|xp
operator|->
name|i_nextsnap
operator|.
name|tqe_prev
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|xp
operator|->
name|i_effnlink
operator|>
literal|0
condition|)
name|vrele
argument_list|(
name|ITOV
argument_list|(
name|xp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ump
operator|->
name|um_devvp
operator|->
name|v_rdev
operator|->
name|si_copyonwrite
operator|=
literal|0
expr_stmt|;
name|ump
operator|->
name|um_devvp
operator|->
name|v_flag
operator|&=
operator|~
name|VCOPYONWRITE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check for need to copy block that is about to be written,  * copying the block if necessary.  */
end_comment

begin_function
specifier|static
name|int
name|ffs_copyonwrite
parameter_list|(
name|devvp
parameter_list|,
name|bp
parameter_list|)
name|struct
name|vnode
modifier|*
name|devvp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
name|struct
name|buf
modifier|*
name|ibp
decl_stmt|,
modifier|*
name|cbp
decl_stmt|,
modifier|*
name|savedcbp
init|=
literal|0
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|ufs_daddr_t
name|lbn
decl_stmt|,
name|blkno
decl_stmt|;
name|int
name|indiroff
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|fs
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|devvp
operator|->
name|v_rdev
operator|->
name|si_snapshots
argument_list|)
operator|->
name|i_fs
expr_stmt|;
name|lbn
operator|=
name|fragstoblks
argument_list|(
name|fs
argument_list|,
name|dbtofsb
argument_list|(
name|fs
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_proc
operator|->
name|p_flag
operator|&
name|P_COWINPROGRESS
condition|)
name|panic
argument_list|(
literal|"ffs_copyonwrite: recursive call"
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ip
argument_list|,
argument|&devvp->v_rdev->si_snapshots
argument_list|,
argument|i_nextsnap
argument_list|)
block|{
name|vp
operator|=
name|ITOV
argument_list|(
name|ip
argument_list|)
expr_stmt|;
comment|/* 		 * We ensure that everything of our own that needs to be 		 * copied will be done at the time that ffs_snapshot is 		 * called. Thus we can skip the check here which can 		 * deadlock in doing the lookup in UFS_BALLOC. 		 */
if|if
condition|(
name|bp
operator|->
name|b_vp
operator|==
name|vp
condition|)
continue|continue;
comment|/* 		 * Check to see if block needs to be copied. We have to 		 * be able to do the UFS_BALLOC without blocking, otherwise 		 * we may get in a deadlock with another process also 		 * trying to allocate. If we find outselves unable to 		 * get the buffer lock, we unlock the snapshot vnode, 		 * sleep briefly, and try again. 		 */
name|retry
label|:
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|lbn
operator|<
name|NDADDR
condition|)
block|{
name|blkno
operator|=
name|ip
operator|->
name|i_db
index|[
name|lbn
index|]
expr_stmt|;
block|}
else|else
block|{
name|td
operator|->
name|td_proc
operator|->
name|p_flag
operator||=
name|P_COWINPROGRESS
expr_stmt|;
name|error
operator|=
name|UFS_BALLOC
argument_list|(
name|vp
argument_list|,
name|lblktosize
argument_list|(
name|fs
argument_list|,
operator|(
name|off_t
operator|)
name|lbn
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
name|B_METAONLY
operator||
name|B_NOWAIT
argument_list|,
operator|&
name|ibp
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_proc
operator|->
name|p_flag
operator|&=
operator|~
name|P_COWINPROGRESS
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|EWOULDBLOCK
condition|)
break|break;
name|tsleep
argument_list|(
name|vp
argument_list|,
name|td
operator|->
name|td_ksegrp
operator|->
name|kg_user_pri
argument_list|,
literal|"nap"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|indiroff
operator|=
operator|(
name|lbn
operator|-
name|NDADDR
operator|)
operator|%
name|NINDIR
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|blkno
operator|=
operator|(
operator|(
name|ufs_daddr_t
operator|*
operator|)
operator|(
name|ibp
operator|->
name|b_data
operator|)
operator|)
index|[
name|indiroff
index|]
expr_stmt|;
name|bqrelse
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|blkno
operator|==
name|BLK_SNAP
operator|&&
name|bp
operator|->
name|b_lblkno
operator|>=
literal|0
condition|)
name|panic
argument_list|(
literal|"ffs_copyonwrite: bad copy block"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|blkno
operator|!=
literal|0
condition|)
block|{
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Allocate the block into which to do the copy. Note that this 		 * allocation will never require any additional allocations for 		 * the snapshot inode. 		 */
name|td
operator|->
name|td_proc
operator|->
name|p_flag
operator||=
name|P_COWINPROGRESS
expr_stmt|;
name|error
operator|=
name|UFS_BALLOC
argument_list|(
name|vp
argument_list|,
name|lblktosize
argument_list|(
name|fs
argument_list|,
operator|(
name|off_t
operator|)
name|lbn
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|KERNCRED
argument_list|,
name|B_NOWAIT
argument_list|,
operator|&
name|cbp
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_proc
operator|->
name|p_flag
operator|&=
operator|~
name|P_COWINPROGRESS
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|EWOULDBLOCK
condition|)
break|break;
name|tsleep
argument_list|(
name|vp
argument_list|,
name|td
operator|->
name|td_ksegrp
operator|->
name|kg_user_pri
argument_list|,
literal|"nap"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|snapdebug
condition|)
block|{
name|printf
argument_list|(
literal|"Copyonwrite: snapino %d lbn %d for "
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
name|lbn
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_vp
operator|==
name|devvp
condition|)
name|printf
argument_list|(
literal|"fs metadata"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"inum %d"
argument_list|,
name|VTOI
argument_list|(
name|bp
operator|->
name|b_vp
argument_list|)
operator|->
name|i_number
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" lblkno %d to blkno %d\n"
argument_list|,
name|bp
operator|->
name|b_lblkno
argument_list|,
name|cbp
operator|->
name|b_blkno
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 		 * If we have already read the old block contents, then 		 * simply copy them to the new block. Note that we need 		 * to synchronously write snapshots that have not been 		 * unlinked, and hence will be visible after a crash, 		 * to ensure their integrity. 		 */
if|if
condition|(
name|savedcbp
operator|!=
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|savedcbp
operator|->
name|b_data
argument_list|,
name|cbp
operator|->
name|b_data
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
name|bawrite
argument_list|(
name|cbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dopersistence
operator|&&
name|ip
operator|->
name|i_effnlink
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|VOP_FSYNC
argument_list|(
name|vp
argument_list|,
name|KERNCRED
argument_list|,
name|MNT_WAIT
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Otherwise, read the old block contents into the buffer. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|readblock
argument_list|(
name|cbp
argument_list|,
name|lbn
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|bzero
argument_list|(
name|cbp
operator|->
name|b_data
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
name|bawrite
argument_list|(
name|cbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dopersistence
operator|&&
name|ip
operator|->
name|i_effnlink
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|VOP_FSYNC
argument_list|(
name|vp
argument_list|,
name|KERNCRED
argument_list|,
name|MNT_WAIT
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
break|break;
block|}
name|savedcbp
operator|=
name|cbp
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Note that we need to synchronously write snapshots that 	 * have not been unlinked, and hence will be visible after 	 * a crash, to ensure their integrity. 	 */
if|if
condition|(
name|savedcbp
condition|)
block|{
name|vp
operator|=
name|savedcbp
operator|->
name|b_vp
expr_stmt|;
name|bawrite
argument_list|(
name|savedcbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dopersistence
operator|&&
name|VTOI
argument_list|(
name|vp
argument_list|)
operator|->
name|i_effnlink
operator|>
literal|0
condition|)
block|{
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|td
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|VOP_FSYNC
argument_list|(
name|vp
argument_list|,
name|KERNCRED
argument_list|,
name|MNT_WAIT
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read the specified block into the given buffer.  * Much of this boiler-plate comes from bwrite().  */
end_comment

begin_function
specifier|static
name|int
name|readblock
parameter_list|(
name|bp
parameter_list|,
name|lbn
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|daddr_t
name|lbn
decl_stmt|;
block|{
name|struct
name|uio
name|auio
decl_stmt|;
name|struct
name|iovec
name|aiov
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
init|=
name|VTOI
argument_list|(
name|bp
operator|->
name|b_vp
argument_list|)
decl_stmt|;
name|aiov
operator|.
name|iov_base
operator|=
name|bp
operator|->
name|b_data
expr_stmt|;
name|aiov
operator|.
name|iov_len
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|auio
operator|.
name|uio_iov
operator|=
operator|&
name|aiov
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_offset
operator|=
name|dbtob
argument_list|(
name|fsbtodb
argument_list|(
name|ip
operator|->
name|i_fs
argument_list|,
name|blkstofrags
argument_list|(
name|ip
operator|->
name|i_fs
argument_list|,
name|lbn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|auio
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|auio
operator|.
name|uio_td
operator|=
name|td
expr_stmt|;
return|return
operator|(
name|physio
argument_list|(
name|ip
operator|->
name|i_devvp
operator|->
name|v_rdev
argument_list|,
operator|&
name|auio
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

