begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1991, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)lfs_segment.c	8.5 (Berkeley) 1/4/94  * $Id$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<miscfs/specfs/specdev.h>
end_include

begin_include
include|#
directive|include
file|<miscfs/fifofs/fifo.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/quota.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/inode.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/dir.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/ufsmount.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/ufs_extern.h>
end_include

begin_include
include|#
directive|include
file|<ufs/lfs/lfs.h>
end_include

begin_include
include|#
directive|include
file|<ufs/lfs/lfs_extern.h>
end_include

begin_decl_stmt
specifier|extern
name|int
name|count_lock_queue
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|caddr_t
name|lfs_alloc_buffer
name|__P
argument_list|(
operator|(
name|int
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lfs_reclaim_buffers
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAX_ACTIVE
value|10
end_define

begin_define
define|#
directive|define
name|MAX_IO_BUFS
value|256
end_define

begin_define
define|#
directive|define
name|MAX_IO_SIZE
value|(1024*512)
end_define

begin_decl_stmt
specifier|static
name|int
name|lfs_total_io_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lfs_total_io_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|lfs_total_free_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lfs_free_needed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lfs_in_buffer_reclaim
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
name|lfs_freebuf
block|{
name|int
name|size
decl_stmt|;
name|caddr_t
name|address
decl_stmt|;
block|}
name|lfs_freebufs
index|[
name|MAX_IO_BUFS
index|]
struct|;
end_struct

begin_function
name|void
name|lfs_free_buffer
parameter_list|(
name|caddr_t
name|address
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|lfs_freebufs
index|[
name|lfs_total_free_count
index|]
operator|.
name|address
operator|=
name|address
expr_stmt|;
name|lfs_freebufs
index|[
name|lfs_total_free_count
index|]
operator|.
name|size
operator|=
name|size
expr_stmt|;
operator|++
name|lfs_total_free_count
expr_stmt|;
if|if
condition|(
name|lfs_free_needed
condition|)
block|{
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|lfs_free_needed
argument_list|)
expr_stmt|;
name|lfs_free_needed
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|lfs_reclaim_buffers
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
name|int
name|reclaimed
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|lfs_in_buffer_reclaim
condition|)
return|return;
name|lfs_in_buffer_reclaim
operator|=
literal|1
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lfs_total_free_count
condition|;
name|i
operator|++
control|)
block|{
name|reclaimed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|lfs_freebufs
index|[
name|i
index|]
operator|.
name|address
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lfs_freebufs
index|[
name|i
index|]
operator|.
name|address
argument_list|,
name|M_SEGMENT
argument_list|)
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
block|}
name|lfs_total_io_size
operator|-=
name|lfs_freebufs
index|[
name|i
index|]
operator|.
name|size
expr_stmt|;
name|lfs_total_io_count
operator|-=
literal|1
expr_stmt|;
block|}
name|lfs_in_buffer_reclaim
operator|=
literal|0
expr_stmt|;
name|lfs_total_free_count
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|reclaimed
condition|)
block|{
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|lfs_free_needed
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|caddr_t
name|lfs_alloc_buffer
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|caddr_t
name|rtval
decl_stmt|;
if|if
condition|(
name|lfs_total_free_count
condition|)
name|lfs_reclaim_buffers
argument_list|()
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
comment|/* XXX can't this just be splbio?? */
while|while
condition|(
operator|(
operator|(
name|lfs_total_io_count
operator|+
literal|1
operator|)
operator|>=
name|MAX_IO_BUFS
operator|)
operator|||
operator|(
name|lfs_total_io_size
operator|>=
name|MAX_IO_SIZE
operator|)
condition|)
block|{
name|lfs_free_needed
operator|=
literal|1
expr_stmt|;
name|tsleep
argument_list|(
operator|&
name|lfs_free_needed
argument_list|,
name|PRIBIO
argument_list|,
literal|"lfsalc"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|lfs_reclaim_buffers
argument_list|()
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|lfs_total_io_size
operator|+=
name|size
expr_stmt|;
name|lfs_total_io_count
operator|+=
literal|1
expr_stmt|;
name|rtval
operator|=
name|malloc
argument_list|(
name|size
argument_list|,
name|M_SEGMENT
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
return|return
name|rtval
return|;
block|}
end_function

begin_comment
comment|/*  * Determine if it's OK to start a partial in this segment, or if we need  * to go on to a new segment.  */
end_comment

begin_define
define|#
directive|define
name|LFS_PARTIAL_FITS
parameter_list|(
name|fs
parameter_list|)
define|\
value|((fs)->lfs_dbpseg - ((fs)->lfs_offset - (fs)->lfs_curseg)> \ 	1<< (fs)->lfs_fsbtodb)
end_define

begin_decl_stmt
specifier|static
name|void
name|lfs_callback
name|__P
argument_list|(
operator|(
expr|struct
name|buf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lfs_gather
name|__P
argument_list|(
operator|(
expr|struct
name|lfs
operator|*
operator|,
expr|struct
name|segment
operator|*
operator|,
expr|struct
name|vnode
operator|*
operator|,
name|int
argument_list|(
argument|*
argument_list|)
name|__P
argument_list|(
operator|(
expr|struct
name|lfs
operator|*
operator|,
expr|struct
name|buf
operator|*
operator|)
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|lfs_iset
name|__P
argument_list|(
operator|(
expr|struct
name|inode
operator|*
operator|,
name|daddr_t
operator|,
name|time_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lfs_match_data
name|__P
argument_list|(
operator|(
expr|struct
name|lfs
operator|*
operator|,
expr|struct
name|buf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lfs_match_dindir
name|__P
argument_list|(
operator|(
expr|struct
name|lfs
operator|*
operator|,
expr|struct
name|buf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lfs_match_indir
name|__P
argument_list|(
operator|(
expr|struct
name|lfs
operator|*
operator|,
expr|struct
name|buf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|TRIPLE
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|lfs_match_tindir
name|__P
argument_list|(
operator|(
expr|struct
name|lfs
operator|*
operator|,
expr|struct
name|buf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|lfs_newseg
name|__P
argument_list|(
operator|(
expr|struct
name|lfs
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lfs_shellsort
name|__P
argument_list|(
operator|(
expr|struct
name|buf
operator|*
operator|*
operator|,
name|daddr_t
operator|*
operator|,
specifier|register
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lfs_supercallback
name|__P
argument_list|(
operator|(
expr|struct
name|buf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lfs_writefile
name|__P
argument_list|(
operator|(
expr|struct
name|lfs
operator|*
operator|,
expr|struct
name|segment
operator|*
operator|,
expr|struct
name|vnode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lfs_writevnodes
name|__P
argument_list|(
operator|(
expr|struct
name|lfs
operator|*
name|fs
operator|,
expr|struct
name|mount
operator|*
name|mp
operator|,
expr|struct
name|segment
operator|*
name|sp
operator|,
name|int
name|dirops
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Statistics Counters */
end_comment

begin_define
define|#
directive|define
name|DOSTATS
end_define

begin_decl_stmt
name|struct
name|lfs_stats
name|lfs_stats
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* op values to lfs_writevnodes */
end_comment

begin_define
define|#
directive|define
name|VN_REG
value|0
end_define

begin_define
define|#
directive|define
name|VN_DIROP
value|1
end_define

begin_define
define|#
directive|define
name|VN_EMPTY
value|2
end_define

begin_comment
comment|/*  * Ifile and meta data blocks are not marked busy, so segment writes MUST be  * single threaded.  Currently, there are two paths into lfs_segwrite, sync()  * and getnewbuf().  They both mark the file system busy.  Lfs_vflush()  * explicitly marks the file system busy.  So lfs_segwrite is safe.  I think.  */
end_comment

begin_function
name|int
name|lfs_vflush
parameter_list|(
name|vp
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
block|{
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|struct
name|lfs
modifier|*
name|fs
decl_stmt|;
name|struct
name|segment
modifier|*
name|sp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|fs
operator|=
name|VFSTOUFS
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
operator|->
name|um_lfs
expr_stmt|;
comment|/* XXX 	 * lfs_segwrite uses lfs_writevnodes to flush dirty vnodes. 	 * lfs_writevnodes (by way of a check with lfs_vref) passes over 	 * locked vnodes.  Since we usually come here with vp locked, anytime 	 * we just happen to call lfs_vflush and we are past the "MAX_ACTIVE" 	 * threshold, we used to call lfs_seqwrite and assume it would take 	 * care of the problem... but of course it didn't.  Now the question 	 * remains, is this the right thing to do, or should lfs_seqwrite or 	 * lfs_writevnodes be fixed to handle locked vnodes?? 	 */
if|if
condition|(
name|fs
operator|->
name|lfs_nactive
operator|>
name|MAX_ACTIVE
condition|)
block|{
name|error
operator|=
name|lfs_segwrite
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|,
name|SEGM_SYNC
operator||
name|SEGM_CKP
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|lfs_seglock
argument_list|(
name|fs
argument_list|,
name|SEGM_SYNC
argument_list|)
expr_stmt|;
name|sp
operator|=
name|fs
operator|->
name|lfs_sp
expr_stmt|;
name|ip
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_dirtyblkhd
operator|.
name|lh_first
operator|==
name|NULL
condition|)
name|lfs_writevnodes
argument_list|(
name|fs
argument_list|,
name|vp
operator|->
name|v_mount
argument_list|,
name|sp
argument_list|,
name|VN_EMPTY
argument_list|)
expr_stmt|;
do|do
block|{
do|do
block|{
if|if
condition|(
name|vp
operator|->
name|v_dirtyblkhd
operator|.
name|lh_first
operator|!=
name|NULL
condition|)
name|lfs_writefile
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
name|vp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|lfs_writeinode
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
name|ip
argument_list|)
condition|)
do|;
block|}
do|while
condition|(
name|lfs_writeseg
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|)
operator|&&
name|ip
operator|->
name|i_number
operator|==
name|LFS_IFILE_INUM
condition|)
do|;
if|if
condition|(
name|vp
operator|->
name|v_dirtyblkhd
operator|.
name|lh_first
operator|!=
name|NULL
condition|)
name|panic
argument_list|(
literal|"lfs_vflush: dirty bufs!!!"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DOSTATS
operator|++
name|lfs_stats
operator|.
name|nwrites
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|seg_flags
operator|&
name|SEGM_SYNC
condition|)
operator|++
name|lfs_stats
operator|.
name|nsync_writes
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|seg_flags
operator|&
name|SEGM_CKP
condition|)
operator|++
name|lfs_stats
operator|.
name|ncheckpoints
expr_stmt|;
endif|#
directive|endif
name|lfs_segunlock
argument_list|(
name|fs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lfs_writevnodes
parameter_list|(
name|fs
parameter_list|,
name|mp
parameter_list|,
name|sp
parameter_list|,
name|op
parameter_list|)
name|struct
name|lfs
modifier|*
name|fs
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|segment
modifier|*
name|sp
decl_stmt|;
name|int
name|op
decl_stmt|;
block|{
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|loop
label|:
for|for
control|(
name|vp
operator|=
name|mp
operator|->
name|mnt_vnodelist
operator|.
name|lh_first
init|;
name|vp
operator|!=
name|NULL
condition|;
name|vp
operator|=
name|vp
operator|->
name|v_mntvnodes
operator|.
name|le_next
control|)
block|{
comment|/* 		 * If the vnode that we are about to sync is no longer 		 * associated with this mount point, start over. 		 */
if|if
condition|(
name|vp
operator|->
name|v_mount
operator|!=
name|mp
condition|)
goto|goto
name|loop
goto|;
comment|/* XXX ignore dirops for now 		if (op == VN_DIROP&& !(vp->v_flag& VDIROP) || 		    op != VN_DIROP&& (vp->v_flag& VDIROP)) 			continue; 		*/
if|if
condition|(
name|op
operator|==
name|VN_EMPTY
operator|&&
name|vp
operator|->
name|v_dirtyblkhd
operator|.
name|lh_first
condition|)
continue|continue;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VNON
condition|)
continue|continue;
if|if
condition|(
name|lfs_vref
argument_list|(
name|vp
argument_list|)
condition|)
continue|continue;
comment|/* 		 * Write the inode/file if dirty and it's not the 		 * the IFILE. 		 */
name|ip
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ip
operator|->
name|i_flag
operator|&
operator|(
name|IN_ACCESS
operator||
name|IN_CHANGE
operator||
name|IN_MODIFIED
operator||
name|IN_UPDATE
operator|)
operator|||
name|vp
operator|->
name|v_dirtyblkhd
operator|.
name|lh_first
operator|!=
name|NULL
operator|)
operator|&&
name|ip
operator|->
name|i_number
operator|!=
name|LFS_IFILE_INUM
condition|)
block|{
if|if
condition|(
name|vp
operator|->
name|v_dirtyblkhd
operator|.
name|lh_first
operator|!=
name|NULL
condition|)
name|lfs_writefile
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
name|vp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lfs_writeinode
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
name|ip
argument_list|)
expr_stmt|;
block|}
name|vp
operator|->
name|v_flag
operator|&=
operator|~
name|VDIROP
expr_stmt|;
name|lfs_vunref
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|lfs_segwrite
parameter_list|(
name|mp
parameter_list|,
name|flags
parameter_list|)
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|int
name|flags
decl_stmt|;
comment|/* Do a checkpoint. */
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|struct
name|lfs
modifier|*
name|fs
decl_stmt|;
name|struct
name|segment
modifier|*
name|sp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|SEGUSE
modifier|*
name|segusep
decl_stmt|;
name|daddr_t
name|ibno
decl_stmt|;
name|CLEANERINFO
modifier|*
name|cip
decl_stmt|;
name|int
name|clean
decl_stmt|,
name|do_ckp
decl_stmt|,
name|error
decl_stmt|,
name|i
decl_stmt|;
name|fs
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
operator|->
name|um_lfs
expr_stmt|;
comment|/*  	 * If we have fewer than 2 clean segments, wait until cleaner 	 * writes.  	 */
do|do
block|{
name|LFS_CLEANERINFO
argument_list|(
name|cip
argument_list|,
name|fs
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|clean
operator|=
name|cip
operator|->
name|clean
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|clean
operator|<=
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"lfs_segwrite: ran out of clean segments, waiting for cleaner\n"
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|lfs_allclean_wakeup
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|tsleep
argument_list|(
operator|&
name|fs
operator|->
name|lfs_avail
argument_list|,
name|PRIBIO
operator|+
literal|1
argument_list|,
literal|"lfs writer"
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
do|while
condition|(
name|clean
operator|<=
literal|2
condition|)
do|;
comment|/* 	 * Allocate a segment structure and enough space to hold pointers to 	 * the maximum possible number of buffers which can be described in a 	 * single summary block. 	 */
name|do_ckp
operator|=
name|flags
operator|&
name|SEGM_CKP
operator|||
name|fs
operator|->
name|lfs_nactive
operator|>
name|MAX_ACTIVE
expr_stmt|;
name|lfs_seglock
argument_list|(
name|fs
argument_list|,
name|flags
operator||
operator|(
name|do_ckp
condition|?
name|SEGM_CKP
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|sp
operator|=
name|fs
operator|->
name|lfs_sp
expr_stmt|;
name|lfs_writevnodes
argument_list|(
name|fs
argument_list|,
name|mp
argument_list|,
name|sp
argument_list|,
name|VN_REG
argument_list|)
expr_stmt|;
comment|/* XXX ignore ordering of dirops for now */
comment|/* XXX 	fs->lfs_writer = 1; 	if (fs->lfs_dirops&& (error = 	    tsleep(&fs->lfs_writer, PRIBIO + 1, "lfs writer", 0))) { 		free(sp->bpp, M_SEGMENT); 		free(sp, M_SEGMENT); 		fs->lfs_writer = 0; 		return (error); 	}  	lfs_writevnodes(fs, mp, sp, VN_DIROP); 	*/
comment|/* 	 * If we are doing a checkpoint, mark everything since the 	 * last checkpoint as no longer ACTIVE. 	 */
if|if
condition|(
name|do_ckp
condition|)
for|for
control|(
name|ibno
operator|=
name|fs
operator|->
name|lfs_cleansz
operator|+
name|fs
operator|->
name|lfs_segtabsz
init|;
operator|--
name|ibno
operator|>=
name|fs
operator|->
name|lfs_cleansz
condition|;
control|)
block|{
if|if
condition|(
name|bread
argument_list|(
name|fs
operator|->
name|lfs_ivnode
argument_list|,
name|ibno
argument_list|,
name|fs
operator|->
name|lfs_bsize
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
condition|)
name|panic
argument_list|(
literal|"lfs: ifile read"
argument_list|)
expr_stmt|;
name|segusep
operator|=
operator|(
name|SEGUSE
operator|*
operator|)
name|bp
operator|->
name|b_data
expr_stmt|;
for|for
control|(
name|i
operator|=
name|fs
operator|->
name|lfs_sepb
init|;
name|i
operator|--
condition|;
name|segusep
operator|++
control|)
name|segusep
operator|->
name|su_flags
operator|&=
operator|~
name|SEGUSE_ACTIVE
expr_stmt|;
name|error
operator|=
name|VOP_BWRITE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|do_ckp
operator|||
name|fs
operator|->
name|lfs_doifile
condition|)
block|{
name|redo
label|:
name|vp
operator|=
name|fs
operator|->
name|lfs_ivnode
expr_stmt|;
while|while
condition|(
name|vget
argument_list|(
name|vp
argument_list|,
literal|1
argument_list|)
condition|)
empty_stmt|;
name|ip
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_dirtyblkhd
operator|.
name|lh_first
operator|!=
name|NULL
condition|)
name|lfs_writefile
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
name|vp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lfs_writeinode
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
name|ip
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lfs_writeseg
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|)
operator|&&
name|do_ckp
condition|)
goto|goto
name|redo
goto|;
block|}
else|else
operator|(
name|void
operator|)
name|lfs_writeseg
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|)
expr_stmt|;
comment|/* 	 * If the I/O count is non-zero, sleep until it reaches zero.  At the 	 * moment, the user's process hangs around so we can sleep. 	 */
comment|/* XXX ignore dirops for now 	fs->lfs_writer = 0; 	fs->lfs_doifile = 0; 	wakeup(&fs->lfs_dirops); 	*/
ifdef|#
directive|ifdef
name|DOSTATS
operator|++
name|lfs_stats
operator|.
name|nwrites
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|seg_flags
operator|&
name|SEGM_SYNC
condition|)
operator|++
name|lfs_stats
operator|.
name|nsync_writes
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|seg_flags
operator|&
name|SEGM_CKP
condition|)
operator|++
name|lfs_stats
operator|.
name|ncheckpoints
expr_stmt|;
endif|#
directive|endif
name|lfs_segunlock
argument_list|(
name|fs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write the dirty blocks associated with a vnode.  */
end_comment

begin_function
specifier|static
name|void
name|lfs_writefile
parameter_list|(
name|fs
parameter_list|,
name|sp
parameter_list|,
name|vp
parameter_list|)
name|struct
name|lfs
modifier|*
name|fs
decl_stmt|;
name|struct
name|segment
modifier|*
name|sp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|finfo
modifier|*
name|fip
decl_stmt|;
name|IFILE
modifier|*
name|ifp
decl_stmt|;
if|if
condition|(
name|sp
operator|->
name|seg_bytes_left
operator|<
name|fs
operator|->
name|lfs_bsize
operator|||
name|sp
operator|->
name|sum_bytes_left
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|finfo
argument_list|)
condition|)
operator|(
name|void
operator|)
name|lfs_writeseg
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|sum_bytes_left
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|finfo
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
expr_stmt|;
operator|++
operator|(
operator|(
name|SEGSUM
operator|*
operator|)
operator|(
name|sp
operator|->
name|segsum
operator|)
operator|)
operator|->
name|ss_nfinfo
expr_stmt|;
name|fip
operator|=
name|sp
operator|->
name|fip
expr_stmt|;
name|fip
operator|->
name|fi_nblocks
operator|=
literal|0
expr_stmt|;
name|fip
operator|->
name|fi_ino
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
operator|->
name|i_number
expr_stmt|;
name|LFS_IENTRY
argument_list|(
name|ifp
argument_list|,
name|fs
argument_list|,
name|fip
operator|->
name|fi_ino
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|fip
operator|->
name|fi_version
operator|=
name|ifp
operator|->
name|if_version
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * It may not be necessary to write the meta-data blocks at this point, 	 * as the roll-forward recovery code should be able to reconstruct the 	 * list. 	 */
name|lfs_gather
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
name|vp
argument_list|,
name|lfs_match_data
argument_list|)
expr_stmt|;
name|lfs_gather
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
name|vp
argument_list|,
name|lfs_match_indir
argument_list|)
expr_stmt|;
name|lfs_gather
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
name|vp
argument_list|,
name|lfs_match_dindir
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TRIPLE
name|lfs_gather
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
name|vp
argument_list|,
name|lfs_match_tindir
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fip
operator|=
name|sp
operator|->
name|fip
expr_stmt|;
if|if
condition|(
name|fip
operator|->
name|fi_nblocks
operator|!=
literal|0
condition|)
block|{
name|sp
operator|->
name|fip
operator|=
operator|(
expr|struct
name|finfo
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|fip
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|finfo
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
operator|*
operator|(
name|fip
operator|->
name|fi_nblocks
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|sp
operator|->
name|start_lbp
operator|=
operator|&
name|sp
operator|->
name|fip
operator|->
name|fi_blocks
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|->
name|sum_bytes_left
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|finfo
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
expr_stmt|;
operator|--
operator|(
operator|(
name|SEGSUM
operator|*
operator|)
operator|(
name|sp
operator|->
name|segsum
operator|)
operator|)
operator|->
name|ss_nfinfo
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|lfs_writeinode
parameter_list|(
name|fs
parameter_list|,
name|sp
parameter_list|,
name|ip
parameter_list|)
name|struct
name|lfs
modifier|*
name|fs
decl_stmt|;
name|struct
name|segment
modifier|*
name|sp
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|ibp
decl_stmt|;
name|IFILE
modifier|*
name|ifp
decl_stmt|;
name|SEGUSE
modifier|*
name|sup
decl_stmt|;
name|daddr_t
name|daddr
decl_stmt|;
name|ino_t
name|ino
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|ndx
decl_stmt|;
name|int
name|redo_ifile
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ip
operator|->
name|i_flag
operator|&
operator|(
name|IN_ACCESS
operator||
name|IN_CHANGE
operator||
name|IN_MODIFIED
operator||
name|IN_UPDATE
operator|)
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Allocate a new inode block if necessary. */
if|if
condition|(
name|sp
operator|->
name|ibp
operator|==
name|NULL
condition|)
block|{
comment|/* Allocate a new segment if necessary. */
if|if
condition|(
name|sp
operator|->
name|seg_bytes_left
operator|<
name|fs
operator|->
name|lfs_bsize
operator|||
name|sp
operator|->
name|sum_bytes_left
operator|<
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
condition|)
operator|(
name|void
operator|)
name|lfs_writeseg
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|)
expr_stmt|;
comment|/* Get next inode block. */
name|daddr
operator|=
name|fs
operator|->
name|lfs_offset
expr_stmt|;
name|fs
operator|->
name|lfs_offset
operator|+=
name|fsbtodb
argument_list|(
name|fs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sp
operator|->
name|ibp
operator|=
operator|*
name|sp
operator|->
name|cbpp
operator|++
operator|=
name|lfs_newbuf
argument_list|(
name|VTOI
argument_list|(
name|fs
operator|->
name|lfs_ivnode
argument_list|)
operator|->
name|i_devvp
argument_list|,
name|daddr
argument_list|,
name|fs
operator|->
name|lfs_bsize
argument_list|)
expr_stmt|;
comment|/* Zero out inode numbers */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|INOPB
argument_list|(
name|fs
argument_list|)
condition|;
operator|++
name|i
control|)
operator|(
operator|(
expr|struct
name|dinode
operator|*
operator|)
name|sp
operator|->
name|ibp
operator|->
name|b_data
operator|)
index|[
name|i
index|]
operator|.
name|di_inumber
operator|=
literal|0
expr_stmt|;
operator|++
name|sp
operator|->
name|start_bpp
expr_stmt|;
name|fs
operator|->
name|lfs_avail
operator|-=
name|fsbtodb
argument_list|(
name|fs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Set remaining space counters. */
name|sp
operator|->
name|seg_bytes_left
operator|-=
name|fs
operator|->
name|lfs_bsize
expr_stmt|;
name|sp
operator|->
name|sum_bytes_left
operator|-=
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
expr_stmt|;
name|ndx
operator|=
name|LFS_SUMMARY_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
operator|-
name|sp
operator|->
name|ninodes
operator|/
name|INOPB
argument_list|(
name|fs
argument_list|)
operator|-
literal|1
expr_stmt|;
operator|(
operator|(
name|daddr_t
operator|*
operator|)
operator|(
name|sp
operator|->
name|segsum
operator|)
operator|)
index|[
name|ndx
index|]
operator|=
name|daddr
expr_stmt|;
block|}
comment|/* Update the inode times and copy the inode onto the inode page. */
if|if
condition|(
name|ip
operator|->
name|i_flag
operator|&
name|IN_MODIFIED
condition|)
operator|--
name|fs
operator|->
name|lfs_uinodes
expr_stmt|;
name|ITIMES
argument_list|(
name|ip
argument_list|,
operator|&
name|time
argument_list|,
operator|&
name|time
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_flag
operator|&=
operator|~
operator|(
name|IN_ACCESS
operator||
name|IN_CHANGE
operator||
name|IN_MODIFIED
operator||
name|IN_UPDATE
operator|)
expr_stmt|;
name|bp
operator|=
name|sp
operator|->
name|ibp
expr_stmt|;
operator|(
operator|(
expr|struct
name|dinode
operator|*
operator|)
name|bp
operator|->
name|b_data
operator|)
index|[
name|sp
operator|->
name|ninodes
operator|%
name|INOPB
argument_list|(
name|fs
argument_list|)
index|]
operator|=
name|ip
operator|->
name|i_din
expr_stmt|;
comment|/* Increment inode count in segment summary block. */
operator|++
operator|(
operator|(
name|SEGSUM
operator|*
operator|)
operator|(
name|sp
operator|->
name|segsum
operator|)
operator|)
operator|->
name|ss_ninos
expr_stmt|;
comment|/* If this page is full, set flag to allocate a new page. */
if|if
condition|(
operator|++
name|sp
operator|->
name|ninodes
operator|%
name|INOPB
argument_list|(
name|fs
argument_list|)
operator|==
literal|0
condition|)
name|sp
operator|->
name|ibp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * If updating the ifile, update the super-block.  Update the disk 	 * address and access times for this inode in the ifile. 	 */
name|ino
operator|=
name|ip
operator|->
name|i_number
expr_stmt|;
if|if
condition|(
name|ino
operator|==
name|LFS_IFILE_INUM
condition|)
block|{
name|daddr
operator|=
name|fs
operator|->
name|lfs_idaddr
expr_stmt|;
name|fs
operator|->
name|lfs_idaddr
operator|=
name|bp
operator|->
name|b_blkno
expr_stmt|;
block|}
else|else
block|{
name|LFS_IENTRY
argument_list|(
name|ifp
argument_list|,
name|fs
argument_list|,
name|ino
argument_list|,
name|ibp
argument_list|)
expr_stmt|;
name|daddr
operator|=
name|ifp
operator|->
name|if_daddr
expr_stmt|;
name|ifp
operator|->
name|if_daddr
operator|=
name|bp
operator|->
name|b_blkno
expr_stmt|;
name|error
operator|=
name|VOP_BWRITE
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * No need to update segment usage if there was no former inode address 	 * or if the last inode address is in the current partial segment. 	 */
if|if
condition|(
name|daddr
operator|!=
name|LFS_UNUSED_DADDR
operator|&&
operator|!
operator|(
name|daddr
operator|>=
name|fs
operator|->
name|lfs_lastpseg
operator|&&
name|daddr
operator|<=
name|bp
operator|->
name|b_blkno
operator|)
condition|)
block|{
name|LFS_SEGENTRY
argument_list|(
name|sup
argument_list|,
name|fs
argument_list|,
name|datosn
argument_list|(
name|fs
argument_list|,
name|daddr
argument_list|)
argument_list|,
name|bp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|sup
operator|->
name|su_nbytes
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|dinode
argument_list|)
condition|)
block|{
comment|/* XXX -- Change to a panic. */
name|printf
argument_list|(
literal|"lfs: negative bytes (segment %ld)\n"
argument_list|,
name|datosn
argument_list|(
name|fs
argument_list|,
name|daddr
argument_list|)
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"negative bytes"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|sup
operator|->
name|su_nbytes
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|dinode
argument_list|)
expr_stmt|;
name|redo_ifile
operator|=
operator|(
name|ino
operator|==
name|LFS_IFILE_INUM
operator|&&
operator|!
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_GATHERED
operator|)
operator|)
expr_stmt|;
name|error
operator|=
name|VOP_BWRITE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|redo_ifile
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lfs_gatherblock
parameter_list|(
name|sp
parameter_list|,
name|bp
parameter_list|,
name|sptr
parameter_list|)
name|struct
name|segment
modifier|*
name|sp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
modifier|*
name|sptr
decl_stmt|;
block|{
name|struct
name|lfs
modifier|*
name|fs
decl_stmt|;
name|int
name|version
decl_stmt|;
comment|/* 	 * If full, finish this segment.  We may be doing I/O, so 	 * release and reacquire the splbio(). 	 */
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|sp
operator|->
name|vp
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"lfs_gatherblock: Null vp in segment"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fs
operator|=
name|sp
operator|->
name|fs
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|sum_bytes_left
operator|<
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
operator|||
name|sp
operator|->
name|seg_bytes_left
operator|<
name|fs
operator|->
name|lfs_bsize
condition|)
block|{
if|if
condition|(
name|sptr
condition|)
name|splx
argument_list|(
operator|*
name|sptr
argument_list|)
expr_stmt|;
name|lfs_updatemeta
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|version
operator|=
name|sp
operator|->
name|fip
operator|->
name|fi_version
expr_stmt|;
operator|(
name|void
operator|)
name|lfs_writeseg
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|fip
operator|->
name|fi_version
operator|=
name|version
expr_stmt|;
name|sp
operator|->
name|fip
operator|->
name|fi_ino
operator|=
name|VTOI
argument_list|(
name|sp
operator|->
name|vp
argument_list|)
operator|->
name|i_number
expr_stmt|;
comment|/* Add the current file to the segment summary. */
operator|++
operator|(
operator|(
name|SEGSUM
operator|*
operator|)
operator|(
name|sp
operator|->
name|segsum
operator|)
operator|)
operator|->
name|ss_nfinfo
expr_stmt|;
name|sp
operator|->
name|sum_bytes_left
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|finfo
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|sptr
condition|)
operator|*
name|sptr
operator|=
name|splbio
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Insert into the buffer list, update the FINFO block. */
name|bp
operator|->
name|b_flags
operator||=
name|B_GATHERED
expr_stmt|;
operator|*
name|sp
operator|->
name|cbpp
operator|++
operator|=
name|bp
expr_stmt|;
name|sp
operator|->
name|fip
operator|->
name|fi_blocks
index|[
name|sp
operator|->
name|fip
operator|->
name|fi_nblocks
operator|++
index|]
operator|=
name|bp
operator|->
name|b_lblkno
expr_stmt|;
name|sp
operator|->
name|sum_bytes_left
operator|-=
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
expr_stmt|;
name|sp
operator|->
name|seg_bytes_left
operator|-=
name|fs
operator|->
name|lfs_bsize
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|lfs_gather
parameter_list|(
name|fs
parameter_list|,
name|sp
parameter_list|,
name|vp
parameter_list|,
name|match
parameter_list|)
name|struct
name|lfs
modifier|*
name|fs
decl_stmt|;
name|struct
name|segment
modifier|*
name|sp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
function_decl|int
parameter_list|(
function_decl|*match
end_function_decl

begin_expr_stmt
unit|)
name|__P
argument_list|(
operator|(
expr|struct
name|lfs
operator|*
operator|,
expr|struct
name|buf
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|sp
operator|->
name|vp
operator|=
name|vp
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|loop
label|:
for|for
control|(
name|bp
operator|=
name|vp
operator|->
name|v_dirtyblkhd
operator|.
name|lh_first
init|;
name|bp
condition|;
name|bp
operator|=
name|bp
operator|->
name|b_vnbufs
operator|.
name|le_next
control|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_BUSY
operator|||
operator|!
name|match
argument_list|(
name|fs
argument_list|,
name|bp
argument_list|)
operator|||
name|bp
operator|->
name|b_flags
operator|&
name|B_GATHERED
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|!
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DELWRI
operator|)
condition|)
name|panic
argument_list|(
literal|"lfs_gather: bp not B_DELWRI"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_LOCKED
operator|)
condition|)
name|panic
argument_list|(
literal|"lfs_gather: bp not B_LOCKED"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|lfs_gatherblock
argument_list|(
name|sp
argument_list|,
name|bp
argument_list|,
operator|&
name|s
argument_list|)
condition|)
goto|goto
name|loop
goto|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|lfs_updatemeta
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|vp
operator|=
name|NULL
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Update the metadata that points to the blocks listed in the FINFO  * array.  */
end_comment

begin_function
name|void
name|lfs_updatemeta
parameter_list|(
name|sp
parameter_list|)
name|struct
name|segment
modifier|*
name|sp
decl_stmt|;
block|{
name|SEGUSE
modifier|*
name|sup
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|lfs
modifier|*
name|fs
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|indir
name|a
index|[
name|NIADDR
operator|+
literal|2
index|]
decl_stmt|,
modifier|*
name|ap
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|daddr_t
name|daddr
decl_stmt|,
name|lbn
decl_stmt|,
name|off
decl_stmt|;
name|int
name|db_per_fsb
decl_stmt|,
name|error
decl_stmt|,
name|i
decl_stmt|,
name|nblocks
decl_stmt|,
name|num
decl_stmt|;
name|vp
operator|=
name|sp
operator|->
name|vp
expr_stmt|;
name|nblocks
operator|=
operator|&
name|sp
operator|->
name|fip
operator|->
name|fi_blocks
index|[
name|sp
operator|->
name|fip
operator|->
name|fi_nblocks
index|]
operator|-
name|sp
operator|->
name|start_lbp
expr_stmt|;
if|if
condition|(
name|vp
operator|==
name|NULL
operator|||
name|nblocks
operator|==
literal|0
condition|)
return|return;
comment|/* Sort the blocks. */
if|if
condition|(
operator|!
operator|(
name|sp
operator|->
name|seg_flags
operator|&
name|SEGM_CLEAN
operator|)
condition|)
name|lfs_shellsort
argument_list|(
name|sp
operator|->
name|start_bpp
argument_list|,
name|sp
operator|->
name|start_lbp
argument_list|,
name|nblocks
argument_list|)
expr_stmt|;
comment|/* 	 * Assign disk addresses, and update references to the logical 	 * block and the segment usage information. 	 */
name|fs
operator|=
name|sp
operator|->
name|fs
expr_stmt|;
name|db_per_fsb
operator|=
name|fsbtodb
argument_list|(
name|fs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nblocks
init|;
name|i
operator|--
condition|;
operator|++
name|sp
operator|->
name|start_bpp
control|)
block|{
name|lbn
operator|=
operator|*
name|sp
operator|->
name|start_lbp
operator|++
expr_stmt|;
operator|(
operator|*
name|sp
operator|->
name|start_bpp
operator|)
operator|->
name|b_blkno
operator|=
name|off
operator|=
name|fs
operator|->
name|lfs_offset
expr_stmt|;
name|fs
operator|->
name|lfs_offset
operator|+=
name|db_per_fsb
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|ufs_bmaparray
argument_list|(
name|vp
argument_list|,
name|lbn
argument_list|,
operator|&
name|daddr
argument_list|,
name|a
argument_list|,
operator|&
name|num
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
name|panic
argument_list|(
literal|"lfs_updatemeta: ufs_bmaparray %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ip
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|num
condition|)
block|{
case|case
literal|0
case|:
name|ip
operator|->
name|i_db
index|[
name|lbn
index|]
operator|=
name|off
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|ip
operator|->
name|i_ib
index|[
name|a
index|[
literal|0
index|]
operator|.
name|in_off
index|]
operator|=
name|off
expr_stmt|;
break|break;
default|default:
name|ap
operator|=
operator|&
name|a
index|[
name|num
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|bread
argument_list|(
name|vp
argument_list|,
name|ap
operator|->
name|in_lbn
argument_list|,
name|fs
operator|->
name|lfs_bsize
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
condition|)
name|panic
argument_list|(
literal|"lfs_updatemeta: bread bno %d"
argument_list|,
name|ap
operator|->
name|in_lbn
argument_list|)
expr_stmt|;
comment|/* 			 * Bread may create a new indirect block which needs 			 * to get counted for the inode. 			 */
if|if
condition|(
name|bp
operator|->
name|b_blkno
operator|==
operator|-
literal|1
operator|&&
operator|!
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_CACHE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Updatemeta allocating indirect block: shouldn't happen\n"
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_blocks
operator|+=
name|btodb
argument_list|(
name|fs
operator|->
name|lfs_bsize
argument_list|)
expr_stmt|;
name|fs
operator|->
name|lfs_bfree
operator|-=
name|btodb
argument_list|(
name|fs
operator|->
name|lfs_bsize
argument_list|)
expr_stmt|;
block|}
operator|(
operator|(
name|daddr_t
operator|*
operator|)
name|bp
operator|->
name|b_data
operator|)
index|[
name|ap
operator|->
name|in_off
index|]
operator|=
name|off
expr_stmt|;
name|VOP_BWRITE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
comment|/* Update segment usage information. */
if|if
condition|(
name|daddr
operator|!=
name|UNASSIGNED
operator|&&
operator|!
operator|(
name|daddr
operator|>=
name|fs
operator|->
name|lfs_lastpseg
operator|&&
name|daddr
operator|<=
name|off
operator|)
condition|)
block|{
name|LFS_SEGENTRY
argument_list|(
name|sup
argument_list|,
name|fs
argument_list|,
name|datosn
argument_list|(
name|fs
argument_list|,
name|daddr
argument_list|)
argument_list|,
name|bp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|sup
operator|->
name|su_nbytes
operator|<
name|fs
operator|->
name|lfs_bsize
condition|)
block|{
comment|/* XXX -- Change to a panic. */
name|printf
argument_list|(
literal|"lfs: negative bytes (segment %ld)\n"
argument_list|,
name|datosn
argument_list|(
name|fs
argument_list|,
name|daddr
argument_list|)
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"Negative Bytes"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|sup
operator|->
name|su_nbytes
operator|-=
name|fs
operator|->
name|lfs_bsize
expr_stmt|;
name|error
operator|=
name|VOP_BWRITE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Start a new segment.  */
end_comment

begin_function
name|int
name|lfs_initseg
parameter_list|(
name|fs
parameter_list|)
name|struct
name|lfs
modifier|*
name|fs
decl_stmt|;
block|{
name|struct
name|segment
modifier|*
name|sp
decl_stmt|;
name|SEGUSE
modifier|*
name|sup
decl_stmt|;
name|SEGSUM
modifier|*
name|ssp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|repeat
decl_stmt|;
name|sp
operator|=
name|fs
operator|->
name|lfs_sp
expr_stmt|;
name|repeat
operator|=
literal|0
expr_stmt|;
comment|/* Advance to the next segment. */
if|if
condition|(
operator|!
name|LFS_PARTIAL_FITS
argument_list|(
name|fs
argument_list|)
condition|)
block|{
comment|/* Wake up any cleaning procs waiting on this file system. */
name|wakeup
argument_list|(
operator|&
name|lfs_allclean_wakeup
argument_list|)
expr_stmt|;
name|lfs_newseg
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|repeat
operator|=
literal|1
expr_stmt|;
name|fs
operator|->
name|lfs_offset
operator|=
name|fs
operator|->
name|lfs_curseg
expr_stmt|;
name|sp
operator|->
name|seg_number
operator|=
name|datosn
argument_list|(
name|fs
argument_list|,
name|fs
operator|->
name|lfs_curseg
argument_list|)
expr_stmt|;
name|sp
operator|->
name|seg_bytes_left
operator|=
name|fs
operator|->
name|lfs_dbpseg
operator|*
name|DEV_BSIZE
expr_stmt|;
comment|/* 		 * If the segment contains a superblock, update the offset 		 * and summary address to skip over it. 		 */
name|LFS_SEGENTRY
argument_list|(
name|sup
argument_list|,
name|fs
argument_list|,
name|sp
operator|->
name|seg_number
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sup
operator|->
name|su_flags
operator|&
name|SEGUSE_SUPERBLOCK
condition|)
block|{
name|fs
operator|->
name|lfs_offset
operator|+=
name|LFS_SBPAD
operator|/
name|DEV_BSIZE
expr_stmt|;
name|sp
operator|->
name|seg_bytes_left
operator|-=
name|LFS_SBPAD
expr_stmt|;
block|}
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|->
name|seg_number
operator|=
name|datosn
argument_list|(
name|fs
argument_list|,
name|fs
operator|->
name|lfs_curseg
argument_list|)
expr_stmt|;
name|sp
operator|->
name|seg_bytes_left
operator|=
operator|(
name|fs
operator|->
name|lfs_dbpseg
operator|-
operator|(
name|fs
operator|->
name|lfs_offset
operator|-
name|fs
operator|->
name|lfs_curseg
operator|)
operator|)
operator|*
name|DEV_BSIZE
expr_stmt|;
block|}
name|fs
operator|->
name|lfs_lastpseg
operator|=
name|fs
operator|->
name|lfs_offset
expr_stmt|;
name|sp
operator|->
name|fs
operator|=
name|fs
expr_stmt|;
name|sp
operator|->
name|ibp
operator|=
name|NULL
expr_stmt|;
name|sp
operator|->
name|ninodes
operator|=
literal|0
expr_stmt|;
comment|/* Get a new buffer for SEGSUM and enter it into the buffer list. */
name|sp
operator|->
name|cbpp
operator|=
name|sp
operator|->
name|bpp
expr_stmt|;
operator|*
name|sp
operator|->
name|cbpp
operator|=
name|lfs_newbuf
argument_list|(
name|VTOI
argument_list|(
name|fs
operator|->
name|lfs_ivnode
argument_list|)
operator|->
name|i_devvp
argument_list|,
name|fs
operator|->
name|lfs_offset
argument_list|,
name|LFS_SUMMARY_SIZE
argument_list|)
expr_stmt|;
name|sp
operator|->
name|segsum
operator|=
operator|(
operator|*
name|sp
operator|->
name|cbpp
operator|)
operator|->
name|b_data
expr_stmt|;
name|bzero
argument_list|(
name|sp
operator|->
name|segsum
argument_list|,
name|LFS_SUMMARY_SIZE
argument_list|)
expr_stmt|;
name|sp
operator|->
name|start_bpp
operator|=
operator|++
name|sp
operator|->
name|cbpp
expr_stmt|;
name|fs
operator|->
name|lfs_offset
operator|+=
name|LFS_SUMMARY_SIZE
operator|/
name|DEV_BSIZE
expr_stmt|;
comment|/* Set point to SEGSUM, initialize it. */
name|ssp
operator|=
name|sp
operator|->
name|segsum
expr_stmt|;
name|ssp
operator|->
name|ss_next
operator|=
name|fs
operator|->
name|lfs_nextseg
expr_stmt|;
name|ssp
operator|->
name|ss_nfinfo
operator|=
name|ssp
operator|->
name|ss_ninos
operator|=
literal|0
expr_stmt|;
comment|/* Set pointer to first FINFO, initialize it. */
name|sp
operator|->
name|fip
operator|=
operator|(
expr|struct
name|finfo
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|sp
operator|->
name|segsum
operator|+
sizeof|sizeof
argument_list|(
name|SEGSUM
argument_list|)
operator|)
expr_stmt|;
name|sp
operator|->
name|fip
operator|->
name|fi_nblocks
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|start_lbp
operator|=
operator|&
name|sp
operator|->
name|fip
operator|->
name|fi_blocks
index|[
literal|0
index|]
expr_stmt|;
name|sp
operator|->
name|seg_bytes_left
operator|-=
name|LFS_SUMMARY_SIZE
expr_stmt|;
name|sp
operator|->
name|sum_bytes_left
operator|=
name|LFS_SUMMARY_SIZE
operator|-
sizeof|sizeof
argument_list|(
name|SEGSUM
argument_list|)
expr_stmt|;
return|return
operator|(
name|repeat
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the next segment to write.  */
end_comment

begin_function
specifier|static
name|void
name|lfs_newseg
parameter_list|(
name|fs
parameter_list|)
name|struct
name|lfs
modifier|*
name|fs
decl_stmt|;
block|{
name|CLEANERINFO
modifier|*
name|cip
decl_stmt|;
name|SEGUSE
modifier|*
name|sup
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|curseg
decl_stmt|,
name|isdirty
decl_stmt|,
name|sn
decl_stmt|;
name|LFS_SEGENTRY
argument_list|(
name|sup
argument_list|,
name|fs
argument_list|,
name|datosn
argument_list|(
name|fs
argument_list|,
name|fs
operator|->
name|lfs_nextseg
argument_list|)
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|sup
operator|->
name|su_flags
operator||=
name|SEGUSE_DIRTY
operator||
name|SEGUSE_ACTIVE
expr_stmt|;
name|sup
operator|->
name|su_nbytes
operator|=
literal|0
expr_stmt|;
name|sup
operator|->
name|su_nsums
operator|=
literal|0
expr_stmt|;
name|sup
operator|->
name|su_ninos
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|VOP_BWRITE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|LFS_CLEANERINFO
argument_list|(
name|cip
argument_list|,
name|fs
argument_list|,
name|bp
argument_list|)
expr_stmt|;
operator|--
name|cip
operator|->
name|clean
expr_stmt|;
operator|++
name|cip
operator|->
name|dirty
expr_stmt|;
operator|(
name|void
operator|)
name|VOP_BWRITE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|fs
operator|->
name|lfs_lastseg
operator|=
name|fs
operator|->
name|lfs_curseg
expr_stmt|;
name|fs
operator|->
name|lfs_curseg
operator|=
name|fs
operator|->
name|lfs_nextseg
expr_stmt|;
for|for
control|(
name|sn
operator|=
name|curseg
operator|=
name|datosn
argument_list|(
name|fs
argument_list|,
name|fs
operator|->
name|lfs_curseg
argument_list|)
init|;
condition|;
control|)
block|{
name|sn
operator|=
operator|(
name|sn
operator|+
literal|1
operator|)
operator|%
name|fs
operator|->
name|lfs_nseg
expr_stmt|;
if|if
condition|(
name|sn
operator|==
name|curseg
condition|)
name|panic
argument_list|(
literal|"lfs_nextseg: no clean segments"
argument_list|)
expr_stmt|;
name|LFS_SEGENTRY
argument_list|(
name|sup
argument_list|,
name|fs
argument_list|,
name|sn
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|isdirty
operator|=
name|sup
operator|->
name|su_flags
operator|&
name|SEGUSE_DIRTY
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isdirty
condition|)
break|break;
block|}
operator|++
name|fs
operator|->
name|lfs_nactive
expr_stmt|;
name|fs
operator|->
name|lfs_nextseg
operator|=
name|sntoda
argument_list|(
name|fs
argument_list|,
name|sn
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DOSTATS
operator|++
name|lfs_stats
operator|.
name|segsused
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|lfs_writeseg
parameter_list|(
name|fs
parameter_list|,
name|sp
parameter_list|)
name|struct
name|lfs
modifier|*
name|fs
decl_stmt|;
name|struct
name|segment
modifier|*
name|sp
decl_stmt|;
block|{
name|struct
name|buf
modifier|*
modifier|*
name|bpp
decl_stmt|,
modifier|*
name|bp
decl_stmt|,
modifier|*
name|cbp
decl_stmt|;
name|SEGUSE
modifier|*
name|sup
decl_stmt|;
name|SEGSUM
modifier|*
name|ssp
decl_stmt|;
name|dev_t
name|i_dev
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|u_long
modifier|*
name|datap
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|int
name|ch_per_blk
decl_stmt|,
name|do_again
decl_stmt|,
name|i
decl_stmt|,
name|nblocks
decl_stmt|,
name|num
decl_stmt|,
name|s
decl_stmt|;
name|int
argument_list|(
argument|*strategy
argument_list|)
name|__P
argument_list|(
operator|(
expr|struct
name|vop_strategy_args
operator|*
operator|)
argument_list|)
expr_stmt|;
name|struct
name|vop_strategy_args
name|vop_strategy_a
decl_stmt|;
name|u_short
name|ninos
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* 	 * If there are no buffers other than the segment summary to write 	 * and it is not a checkpoint, don't do anything.  On a checkpoint, 	 * even if there aren't any buffers, you need to write the superblock. 	 */
if|if
condition|(
operator|(
name|nblocks
operator|=
name|sp
operator|->
name|cbpp
operator|-
name|sp
operator|->
name|bpp
operator|)
operator|==
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ssp
operator|=
operator|(
name|SEGSUM
operator|*
operator|)
name|sp
operator|->
name|segsum
expr_stmt|;
comment|/* Update the segment usage information. */
name|LFS_SEGENTRY
argument_list|(
name|sup
argument_list|,
name|fs
argument_list|,
name|sp
operator|->
name|seg_number
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|ninos
operator|=
operator|(
name|ssp
operator|->
name|ss_ninos
operator|+
name|INOPB
argument_list|(
name|fs
argument_list|)
operator|-
literal|1
operator|)
operator|/
name|INOPB
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|sup
operator|->
name|su_nbytes
operator|+=
name|nblocks
operator|-
literal|1
operator|-
name|ninos
operator|<<
name|fs
operator|->
name|lfs_bshift
expr_stmt|;
name|sup
operator|->
name|su_nbytes
operator|+=
name|ssp
operator|->
name|ss_ninos
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dinode
argument_list|)
expr_stmt|;
name|sup
operator|->
name|su_nbytes
operator|+=
name|LFS_SUMMARY_SIZE
expr_stmt|;
name|sup
operator|->
name|su_lastmod
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
name|sup
operator|->
name|su_ninos
operator|+=
name|ninos
expr_stmt|;
operator|++
name|sup
operator|->
name|su_nsums
expr_stmt|;
name|do_again
operator|=
operator|!
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_GATHERED
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|VOP_BWRITE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * Compute checksum across data and then across summary; the first 	 * block (the summary block) is skipped.  Set the create time here 	 * so that it's guaranteed to be later than the inode mod times. 	 * 	 * XXX 	 * Fix this to do it inline, instead of malloc/copy. 	 */
name|datap
operator|=
name|dp
operator|=
name|malloc
argument_list|(
name|nblocks
operator|*
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|,
name|M_SEGMENT
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
for|for
control|(
name|bpp
operator|=
name|sp
operator|->
name|bpp
operator|,
name|i
operator|=
name|nblocks
operator|-
literal|1
init|;
name|i
operator|--
condition|;
control|)
block|{
if|if
condition|(
operator|(
operator|*
operator|++
name|bpp
operator|)
operator|->
name|b_flags
operator|&
name|B_INVAL
condition|)
block|{
if|if
condition|(
name|copyin
argument_list|(
operator|(
operator|*
name|bpp
operator|)
operator|->
name|b_saveaddr
argument_list|,
name|dp
operator|++
argument_list|,
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|)
condition|)
name|panic
argument_list|(
literal|"lfs_writeseg: copyin failed"
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|dp
operator|++
operator|=
operator|(
operator|(
name|u_long
operator|*
operator|)
operator|(
operator|*
name|bpp
operator|)
operator|->
name|b_data
operator|)
index|[
literal|0
index|]
expr_stmt|;
block|}
name|ssp
operator|->
name|ss_create
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
name|ssp
operator|->
name|ss_datasum
operator|=
name|cksum
argument_list|(
name|datap
argument_list|,
operator|(
name|nblocks
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|)
expr_stmt|;
name|ssp
operator|->
name|ss_sumsum
operator|=
name|cksum
argument_list|(
operator|&
name|ssp
operator|->
name|ss_datasum
argument_list|,
name|LFS_SUMMARY_SIZE
operator|-
sizeof|sizeof
argument_list|(
name|ssp
operator|->
name|ss_sumsum
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|datap
argument_list|,
name|M_SEGMENT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|fs
operator|->
name|lfs_bfree
operator|<
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|ninos
argument_list|)
operator|+
name|LFS_SUMMARY_SIZE
operator|/
name|DEV_BSIZE
condition|)
name|panic
argument_list|(
literal|"lfs_writeseg: No diskspace for summary"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fs
operator|->
name|lfs_bfree
operator|-=
operator|(
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|ninos
argument_list|)
operator|+
name|LFS_SUMMARY_SIZE
operator|/
name|DEV_BSIZE
operator|)
expr_stmt|;
name|i_dev
operator|=
name|VTOI
argument_list|(
name|fs
operator|->
name|lfs_ivnode
argument_list|)
operator|->
name|i_dev
expr_stmt|;
name|strategy
operator|=
name|VTOI
argument_list|(
name|fs
operator|->
name|lfs_ivnode
argument_list|)
operator|->
name|i_devvp
operator|->
name|v_op
index|[
name|VOFFSET
argument_list|(
name|vop_strategy
argument_list|)
index|]
expr_stmt|;
comment|/* 	 * When we simply write the blocks we lose a rotation for every block 	 * written.  To avoid this problem, we allocate memory in chunks, copy 	 * the buffers into the chunk and write the chunk.  MAXPHYS is the 	 * largest size I/O devices can handle. 	 * When the data is copied to the chunk, turn off the the B_LOCKED bit 	 * and brelse the buffer (which will move them to the LRU list).  Add 	 * the B_CALL flag to the buffer header so we can count I/O's for the 	 * checkpoints and so we can release the allocated memory. 	 * 	 * XXX 	 * This should be removed if the new virtual memory system allows us to 	 * easily make the buffers contiguous in kernel memory and if that's 	 * fast enough. 	 */
name|ch_per_blk
operator|=
name|MAXPHYS
operator|/
name|fs
operator|->
name|lfs_bsize
expr_stmt|;
for|for
control|(
name|bpp
operator|=
name|sp
operator|->
name|bpp
operator|,
name|i
operator|=
name|nblocks
init|;
name|i
condition|;
control|)
block|{
name|num
operator|=
name|ch_per_blk
expr_stmt|;
if|if
condition|(
name|num
operator|>
name|i
condition|)
name|num
operator|=
name|i
expr_stmt|;
name|i
operator|-=
name|num
expr_stmt|;
name|size
operator|=
name|num
operator|*
name|fs
operator|->
name|lfs_bsize
expr_stmt|;
name|cbp
operator|=
name|lfs_newbuf
argument_list|(
name|VTOI
argument_list|(
name|fs
operator|->
name|lfs_ivnode
argument_list|)
operator|->
name|i_devvp
argument_list|,
operator|(
operator|*
name|bpp
operator|)
operator|->
name|b_blkno
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|b_dev
operator|=
name|i_dev
expr_stmt|;
name|cbp
operator|->
name|b_flags
operator||=
name|B_ASYNC
operator||
name|B_BUSY
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
operator|++
name|fs
operator|->
name|lfs_iocount
expr_stmt|;
for|for
control|(
name|p
operator|=
name|cbp
operator|->
name|b_data
init|;
name|num
operator|--
condition|;
control|)
block|{
name|bp
operator|=
operator|*
name|bpp
operator|++
expr_stmt|;
comment|/* 			 * Fake buffers from the cleaner are marked as B_INVAL. 			 * We need to copy the data from user space rather than 			 * from the buffer indicated. 			 * XXX == what do I do on an error? 			 */
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_INVAL
condition|)
block|{
if|if
condition|(
name|copyin
argument_list|(
name|bp
operator|->
name|b_saveaddr
argument_list|,
name|p
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|)
condition|)
name|panic
argument_list|(
literal|"lfs_writeseg: copyin failed"
argument_list|)
expr_stmt|;
block|}
else|else
name|bcopy
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
name|p
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
name|p
operator|+=
name|bp
operator|->
name|b_bcount
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_LOCKED
condition|)
operator|--
name|locked_queue_count
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_ERROR
operator||
name|B_READ
operator||
name|B_DELWRI
operator||
name|B_LOCKED
operator||
name|B_GATHERED
operator|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_CALL
condition|)
block|{
comment|/* if B_CALL, it was created with newbuf */
if|if
condition|(
operator|!
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_INVAL
operator|)
condition|)
name|lfs_free_buffer
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
name|roundup
argument_list|(
name|bp
operator|->
name|b_bufsize
argument_list|,
name|DEV_BSIZE
argument_list|)
argument_list|)
expr_stmt|;
name|relpbuf
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bremfree
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_DONE
expr_stmt|;
name|reassignbuf
argument_list|(
name|bp
argument_list|,
name|bp
operator|->
name|b_vp
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
name|cbp
operator|->
name|b_bcount
operator|=
name|p
operator|-
operator|(
name|char
operator|*
operator|)
name|cbp
operator|->
name|b_data
expr_stmt|;
operator|++
name|cbp
operator|->
name|b_vp
operator|->
name|v_numoutput
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 		 * XXXX This is a gross and disgusting hack.  Since these 		 * buffers are physically addressed, they hang off the 		 * device vnode (devvp).  As a result, they have no way 		 * of getting to the LFS superblock or lfs structure to 		 * keep track of the number of I/O's pending.  So, I am 		 * going to stuff the fs into the saveaddr field of 		 * the buffer (yuk). 		 */
name|cbp
operator|->
name|b_saveaddr
operator|=
operator|(
name|caddr_t
operator|)
name|fs
expr_stmt|;
name|vop_strategy_a
operator|.
name|a_desc
operator|=
name|VDESC
argument_list|(
name|vop_strategy
argument_list|)
expr_stmt|;
name|vop_strategy_a
operator|.
name|a_bp
operator|=
name|cbp
expr_stmt|;
call|(
name|strategy
call|)
argument_list|(
operator|&
name|vop_strategy_a
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * XXX 	 * Vinvalbuf can move locked buffers off the locked queue 	 * and we have no way of knowing about this.  So, after 	 * doing a big write, we recalculate how many bufers are 	 * really still left on the locked queue. 	 */
name|locked_queue_count
operator|=
name|count_lock_queue
argument_list|()
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|locked_queue_count
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DOSTATS
operator|++
name|lfs_stats
operator|.
name|psegwrites
expr_stmt|;
name|lfs_stats
operator|.
name|blocktot
operator|+=
name|nblocks
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|lfs_sp
operator|->
name|seg_flags
operator|&
name|SEGM_SYNC
condition|)
operator|++
name|lfs_stats
operator|.
name|psyncwrites
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|lfs_sp
operator|->
name|seg_flags
operator|&
name|SEGM_CLEAN
condition|)
block|{
operator|++
name|lfs_stats
operator|.
name|pcleanwrites
expr_stmt|;
name|lfs_stats
operator|.
name|cleanblocks
operator|+=
name|nblocks
operator|-
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|lfs_initseg
argument_list|(
name|fs
argument_list|)
operator|||
name|do_again
operator|)
return|;
block|}
end_function

begin_function
name|void
name|lfs_writesuper
parameter_list|(
name|fs
parameter_list|)
name|struct
name|lfs
modifier|*
name|fs
decl_stmt|;
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|dev_t
name|i_dev
decl_stmt|;
name|int
argument_list|(
argument|*strategy
argument_list|)
name|__P
argument_list|(
operator|(
expr|struct
name|vop_strategy_args
operator|*
operator|)
argument_list|)
expr_stmt|;
name|int
name|s
decl_stmt|;
name|struct
name|vop_strategy_args
name|vop_strategy_a
decl_stmt|;
name|i_dev
operator|=
name|VTOI
argument_list|(
name|fs
operator|->
name|lfs_ivnode
argument_list|)
operator|->
name|i_dev
expr_stmt|;
name|strategy
operator|=
name|VTOI
argument_list|(
name|fs
operator|->
name|lfs_ivnode
argument_list|)
operator|->
name|i_devvp
operator|->
name|v_op
index|[
name|VOFFSET
argument_list|(
name|vop_strategy
argument_list|)
index|]
expr_stmt|;
comment|/* Checksum the superblock and copy it into a buffer. */
name|fs
operator|->
name|lfs_cksum
operator|=
name|cksum
argument_list|(
name|fs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lfs
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|fs
operator|->
name|lfs_cksum
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|=
name|lfs_newbuf
argument_list|(
name|VTOI
argument_list|(
name|fs
operator|->
name|lfs_ivnode
argument_list|)
operator|->
name|i_devvp
argument_list|,
name|fs
operator|->
name|lfs_sboffs
index|[
literal|0
index|]
argument_list|,
name|LFS_SBPAD
argument_list|)
expr_stmt|;
operator|*
operator|(
expr|struct
name|lfs
operator|*
operator|)
name|bp
operator|->
name|b_data
operator|=
operator|*
name|fs
expr_stmt|;
comment|/* XXX Toggle between first two superblocks; for now just write first */
name|bp
operator|->
name|b_dev
operator|=
name|i_dev
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_BUSY
operator||
name|B_CALL
operator||
name|B_ASYNC
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_DONE
operator||
name|B_ERROR
operator||
name|B_READ
operator||
name|B_DELWRI
operator|)
expr_stmt|;
name|bp
operator|->
name|b_iodone
operator|=
name|lfs_supercallback
expr_stmt|;
name|vop_strategy_a
operator|.
name|a_desc
operator|=
name|VDESC
argument_list|(
name|vop_strategy
argument_list|)
expr_stmt|;
name|vop_strategy_a
operator|.
name|a_bp
operator|=
name|bp
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
operator|++
name|bp
operator|->
name|b_vp
operator|->
name|v_numoutput
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
call|(
name|strategy
call|)
argument_list|(
operator|&
name|vop_strategy_a
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Logical block number match routines used when traversing the dirty block  * chain.  */
end_comment

begin_function
specifier|static
name|int
name|lfs_match_data
parameter_list|(
name|fs
parameter_list|,
name|bp
parameter_list|)
name|struct
name|lfs
modifier|*
name|fs
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
return|return
operator|(
name|bp
operator|->
name|b_lblkno
operator|>=
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lfs_match_indir
parameter_list|(
name|fs
parameter_list|,
name|bp
parameter_list|)
name|struct
name|lfs
modifier|*
name|fs
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
name|int
name|lbn
decl_stmt|;
name|lbn
operator|=
name|bp
operator|->
name|b_lblkno
expr_stmt|;
return|return
operator|(
name|lbn
operator|<
literal|0
operator|&&
operator|(
operator|-
name|lbn
operator|-
name|NDADDR
operator|)
operator|%
name|NINDIR
argument_list|(
name|fs
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lfs_match_dindir
parameter_list|(
name|fs
parameter_list|,
name|bp
parameter_list|)
name|struct
name|lfs
modifier|*
name|fs
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
name|int
name|lbn
decl_stmt|;
name|lbn
operator|=
name|bp
operator|->
name|b_lblkno
expr_stmt|;
return|return
operator|(
name|lbn
operator|<
literal|0
operator|&&
operator|(
operator|-
name|lbn
operator|-
name|NDADDR
operator|)
operator|%
name|NINDIR
argument_list|(
name|fs
argument_list|)
operator|==
literal|1
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TRIPLE
end_ifdef

begin_function
specifier|static
name|int
name|lfs_match_tindir
parameter_list|(
name|fs
parameter_list|,
name|bp
parameter_list|)
name|struct
name|lfs
modifier|*
name|fs
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
name|int
name|lbn
decl_stmt|;
name|lbn
operator|=
name|bp
operator|->
name|b_lblkno
expr_stmt|;
return|return
operator|(
name|lbn
operator|<
literal|0
operator|&&
operator|(
operator|-
name|lbn
operator|-
name|NDADDR
operator|)
operator|%
name|NINDIR
argument_list|(
name|fs
argument_list|)
operator|==
literal|2
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Allocate a new buffer header.  */
end_comment

begin_function
name|struct
name|buf
modifier|*
name|lfs_newbuf
parameter_list|(
name|vp
parameter_list|,
name|daddr
parameter_list|,
name|size
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|daddr_t
name|daddr
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|size_t
name|nbytes
decl_stmt|;
name|nbytes
operator|=
name|roundup
argument_list|(
name|size
argument_list|,
name|DEV_BSIZE
argument_list|)
expr_stmt|;
name|bp
operator|=
name|getpbuf
argument_list|()
expr_stmt|;
if|if
condition|(
name|nbytes
condition|)
name|bp
operator|->
name|b_data
operator|=
name|lfs_alloc_buffer
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_bufsize
operator|=
name|size
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
name|size
expr_stmt|;
name|bp
operator|->
name|b_lblkno
operator|=
name|daddr
expr_stmt|;
name|bp
operator|->
name|b_blkno
operator|=
name|daddr
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_iodone
operator|=
name|lfs_callback
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_BUSY
operator||
name|B_CALL
operator||
name|B_NOCACHE
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lfs_callback
parameter_list|(
name|bp
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
name|struct
name|lfs
modifier|*
name|fs
decl_stmt|;
name|fs
operator|=
operator|(
expr|struct
name|lfs
operator|*
operator|)
name|bp
operator|->
name|b_saveaddr
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|fs
operator|->
name|lfs_iocount
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"lfs_callback: zero iocount"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|--
name|fs
operator|->
name|lfs_iocount
operator|==
literal|0
condition|)
name|wakeup
argument_list|(
operator|&
name|fs
operator|->
name|lfs_iocount
argument_list|)
expr_stmt|;
name|lfs_free_buffer
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
name|roundup
argument_list|(
name|bp
operator|->
name|b_bufsize
argument_list|,
name|DEV_BSIZE
argument_list|)
argument_list|)
expr_stmt|;
name|relpbuf
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lfs_supercallback
parameter_list|(
name|bp
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
if|if
condition|(
name|bp
operator|->
name|b_data
condition|)
name|lfs_free_buffer
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
name|roundup
argument_list|(
name|bp
operator|->
name|b_bufsize
argument_list|,
name|DEV_BSIZE
argument_list|)
argument_list|)
expr_stmt|;
name|relpbuf
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Shellsort (diminishing increment sort) from Data Structures and  * Algorithms, Aho, Hopcraft and Ullman, 1983 Edition, page 290;  * see also Knuth Vol. 3, page 84.  The increments are selected from  * formula (8), page 95.  Roughly O(N^3/2).  */
end_comment

begin_comment
comment|/*  * This is our own private copy of shellsort because we want to sort  * two parallel arrays (the array of buffer pointers and the array of  * logical block numbers) simultaneously.  Note that we cast the array  * of logical block numbers to a unsigned in this routine so that the  * negative block numbers (meta data blocks) sort AFTER the data blocks.  */
end_comment

begin_function
specifier|static
name|void
name|lfs_shellsort
parameter_list|(
name|bp_array
parameter_list|,
name|lb_array
parameter_list|,
name|nmemb
parameter_list|)
name|struct
name|buf
modifier|*
modifier|*
name|bp_array
decl_stmt|;
name|daddr_t
modifier|*
name|lb_array
decl_stmt|;
specifier|register
name|int
name|nmemb
decl_stmt|;
block|{
specifier|static
name|int
name|__rsshell_increments
index|[]
init|=
block|{
literal|4
block|,
literal|1
block|,
literal|0
block|}
decl_stmt|;
specifier|register
name|int
name|incr
decl_stmt|,
modifier|*
name|incrp
decl_stmt|,
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp_temp
decl_stmt|;
name|u_long
name|lb_temp
decl_stmt|;
for|for
control|(
name|incrp
operator|=
name|__rsshell_increments
init|;
name|incr
operator|=
operator|*
name|incrp
operator|++
condition|;
control|)
for|for
control|(
name|t1
operator|=
name|incr
init|;
name|t1
operator|<
name|nmemb
condition|;
operator|++
name|t1
control|)
for|for
control|(
name|t2
operator|=
name|t1
operator|-
name|incr
init|;
name|t2
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
name|lb_array
index|[
name|t2
index|]
operator|>
name|lb_array
index|[
name|t2
operator|+
name|incr
index|]
condition|)
block|{
name|lb_temp
operator|=
name|lb_array
index|[
name|t2
index|]
expr_stmt|;
name|lb_array
index|[
name|t2
index|]
operator|=
name|lb_array
index|[
name|t2
operator|+
name|incr
index|]
expr_stmt|;
name|lb_array
index|[
name|t2
operator|+
name|incr
index|]
operator|=
name|lb_temp
expr_stmt|;
name|bp_temp
operator|=
name|bp_array
index|[
name|t2
index|]
expr_stmt|;
name|bp_array
index|[
name|t2
index|]
operator|=
name|bp_array
index|[
name|t2
operator|+
name|incr
index|]
expr_stmt|;
name|bp_array
index|[
name|t2
operator|+
name|incr
index|]
operator|=
name|bp_temp
expr_stmt|;
name|t2
operator|-=
name|incr
expr_stmt|;
block|}
else|else
break|break;
block|}
end_function

begin_comment
comment|/*  * Check VXLOCK.  Return 1 if the vnode is locked.  Otherwise, vget it.  */
end_comment

begin_function
name|int
name|lfs_vref
parameter_list|(
name|vp
parameter_list|)
specifier|register
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|vp
operator|->
name|v_flag
operator|&
name|VXLOCK
operator|)
operator|||
operator|(
name|vp
operator|->
name|v_usecount
operator|==
literal|0
operator|&&
name|vp
operator|->
name|v_freelist
operator|.
name|tqe_prev
operator|==
operator|(
expr|struct
name|vnode
operator|*
operator|*
operator|)
literal|0xdeadb
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
name|vget
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|lfs_vunref
parameter_list|(
name|vp
parameter_list|)
specifier|register
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
block|{
comment|/*      * This is vrele except that we do not want to VOP_INACTIVE      * this vnode. Rather than inline vrele here, we flag the vnode      * to tell lfs_inactive not to run on this vnode. Not as gross as      * a global.      */
name|vp
operator|->
name|v_flag
operator||=
name|VNINACT
expr_stmt|;
name|vrele
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_flag
operator|&=
operator|~
name|VNINACT
expr_stmt|;
block|}
end_function

end_unit

