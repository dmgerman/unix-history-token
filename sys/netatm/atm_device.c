begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * ===================================  * HARP  |  Host ATM Research Platform  * ===================================  *  *  * This Host ATM Research Platform ("HARP") file (the "Software") is  * made available by Network Computing Services, Inc. ("NetworkCS")  * "AS IS".  NetworkCS does not provide maintenance, improvements or  * support of any kind.  *  * NETWORKCS MAKES NO WARRANTIES OR REPRESENTATIONS, EXPRESS OR IMPLIED,  * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE, AS TO ANY ELEMENT OF THE  * SOFTWARE OR ANY SUPPORT PROVIDED IN CONNECTION WITH THIS SOFTWARE.  * In no event shall NetworkCS be responsible for any damages, including  * but not limited to consequential damages, arising from or relating to  * any use of the Software or related support.  *  * Copyright 1994-1998 Network Computing Services, Inc.  *  * Copies of this Software may be made, however, the above copyright  * notice must be reproduced on all copies.  *  *	@(#) $FreeBSD$  *  */
end_comment

begin_comment
comment|/*  * Core ATM Services  * -----------------  *  * ATM device support functions  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netatm/port.h>
end_include

begin_include
include|#
directive|include
file|<netatm/queue.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sys.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sap.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_cm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_if.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_vc.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_stack.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_var.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"@(#) $FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Private structures for managing allocated kernel memory resources  *  * For each allocation of kernel memory, one Mem_ent will be used.    * The Mem_ent structures will be allocated in blocks inside of a   * Mem_blk structure.  */
end_comment

begin_define
define|#
directive|define
name|MEM_NMEMENT
value|10
end_define

begin_comment
comment|/* How many Mem_ent's in a Mem_blk */
end_comment

begin_struct
struct|struct
name|mem_ent
block|{
name|void
modifier|*
name|me_kaddr
decl_stmt|;
comment|/* Allocated memory address */
name|u_int
name|me_ksize
decl_stmt|;
comment|/* Allocated memory length */
name|void
modifier|*
name|me_uaddr
decl_stmt|;
comment|/* Memory address returned to caller */
name|u_int
name|me_flags
decl_stmt|;
comment|/* Flags (see below) */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|mem_ent
name|Mem_ent
typedef|;
end_typedef

begin_comment
comment|/*  * Memory entry flags  */
end_comment

begin_define
define|#
directive|define
name|MEF_NONCACHE
value|1
end_define

begin_comment
comment|/* Memory is noncacheable */
end_comment

begin_struct
struct|struct
name|mem_blk
block|{
name|struct
name|mem_blk
modifier|*
name|mb_next
decl_stmt|;
comment|/* Next block in chain */
name|Mem_ent
name|mb_mement
index|[
name|MEM_NMEMENT
index|]
decl_stmt|;
comment|/* Allocated memory entries */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|mem_blk
name|Mem_blk
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|Mem_blk
modifier|*
name|atm_mem_head
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|t_atm_cause
name|atm_dev_cause
init|=
block|{
name|T_ATM_ITU_CODING
block|,
name|T_ATM_LOC_USER
block|,
name|T_ATM_CAUSE_VPCI_VCI_ASSIGNMENT_FAILURE
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * ATM Device Stack Instantiation  *  * Called at splnet.  *  * Arguments  *	ssp		pointer to array of stack definition pointers  *			for connection  *			ssp[0] points to upper layer's stack definition  *			ssp[1] points to this layer's stack definition  *			ssp[2] points to lower layer's stack definition  *	cvcp		pointer to connection vcc for this stack  *  * Returns  *	0		instantiation successful  *	err		instantiation failed - reason indicated  *  */
end_comment

begin_function
name|int
name|atm_dev_inst
parameter_list|(
name|ssp
parameter_list|,
name|cvcp
parameter_list|)
name|struct
name|stack_defn
modifier|*
modifier|*
name|ssp
decl_stmt|;
name|Atm_connvc
modifier|*
name|cvcp
decl_stmt|;
block|{
name|Cmn_unit
modifier|*
name|cup
init|=
operator|(
name|Cmn_unit
operator|*
operator|)
name|cvcp
operator|->
name|cvc_attr
operator|.
name|nif
operator|->
name|nif_pif
decl_stmt|;
name|Cmn_vcc
modifier|*
name|cvp
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* 	 * Check to see if device has been initialized 	 */
if|if
condition|(
operator|(
name|cup
operator|->
name|cu_flags
operator|&
name|CUF_INITED
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* 	 * Validate lower SAP 	 */
comment|/* 	 * Device driver is the lowest layer - no need to validate 	 */
comment|/* 	 * Validate PVC vpi.vci 	 */
if|if
condition|(
name|cvcp
operator|->
name|cvc_attr
operator|.
name|called
operator|.
name|addr
operator|.
name|address_format
operator|==
name|T_ATM_PVC_ADDR
condition|)
block|{
comment|/* 		 * Look through existing circuits - return error if found 		 */
name|Atm_addr_pvc
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
operator|(
name|Atm_addr_pvc
operator|*
operator|)
name|cvcp
operator|->
name|cvc_attr
operator|.
name|called
operator|.
name|addr
operator|.
name|address
expr_stmt|;
if|if
condition|(
name|atm_dev_vcc_find
argument_list|(
name|cup
argument_list|,
name|ATM_PVC_GET_VPI
argument_list|(
name|pp
argument_list|)
argument_list|,
name|ATM_PVC_GET_VCI
argument_list|(
name|pp
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
name|EADDRINUSE
operator|)
return|;
block|}
comment|/* 	 * Validate our SAP type 	 */
switch|switch
condition|(
operator|(
operator|*
operator|(
name|ssp
operator|+
literal|1
operator|)
operator|)
operator|->
name|sd_sap
condition|)
block|{
case|case
name|SAP_CPCS_AAL3_4
case|:
case|case
name|SAP_CPCS_AAL5
case|:
case|case
name|SAP_ATM
case|:
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * Allocate a VCC control block 	 */
if|if
condition|(
operator|(
name|cvp
operator|=
operator|(
name|Cmn_vcc
operator|*
operator|)
name|atm_allocate
argument_list|(
name|cup
operator|->
name|cu_vcc_pool
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|cvp
operator|->
name|cv_state
operator|=
name|CVS_INST
expr_stmt|;
name|cvp
operator|->
name|cv_toku
operator|=
operator|(
operator|*
name|ssp
operator|)
operator|->
name|sd_toku
expr_stmt|;
name|cvp
operator|->
name|cv_upper
operator|=
operator|(
operator|*
name|ssp
operator|)
operator|->
name|sd_upper
expr_stmt|;
name|cvp
operator|->
name|cv_connvc
operator|=
name|cvcp
expr_stmt|;
comment|/* 	 * Let device have a look at the connection request 	 */
name|err
operator|=
call|(
modifier|*
name|cup
operator|->
name|cu_instvcc
call|)
argument_list|(
name|cup
argument_list|,
name|cvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|atm_free
argument_list|(
operator|(
name|caddr_t
operator|)
name|cvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/* 	 * Looks good so far, so link in device VCC 	 */
name|LINK2TAIL
argument_list|(
name|cvp
argument_list|,
name|Cmn_vcc
argument_list|,
name|cup
operator|->
name|cu_vcc
argument_list|,
name|cv_next
argument_list|)
expr_stmt|;
comment|/* 	 * Save my token 	 */
operator|(
operator|*
operator|++
name|ssp
operator|)
operator|->
name|sd_toku
operator|=
name|cvp
expr_stmt|;
comment|/* 	 * Pass instantiation down the stack 	 */
comment|/* 	 * No need - we're the lowest point. 	 */
comment|/* err = (*(ssp + 1))->sd_inst(ssp, cvcp); */
comment|/* 	 * Save the lower layer's interface info 	 */
comment|/* 	 * No need - we're the lowest point 	 */
comment|/* cvp->cv_lower = (*++ssp)->sd_lower; */
comment|/* cvp->cv_tok1 = (*ssp)->sd_toku; */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ATM Device Stack Command Handler  *  * Arguments  *	cmd		stack command code  *	tok		session token (Cmn_vcc)  *	arg1		command specific argument  *	arg2		command specific argument  *  * Returns  *	none  *  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|atm_dev_lower
parameter_list|(
name|cmd
parameter_list|,
name|tok
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|int
name|cmd
decl_stmt|;
name|void
modifier|*
name|tok
decl_stmt|;
name|int
name|arg1
decl_stmt|;
name|int
name|arg2
decl_stmt|;
block|{
name|Cmn_vcc
modifier|*
name|cvp
init|=
operator|(
name|Cmn_vcc
operator|*
operator|)
name|tok
decl_stmt|;
name|Atm_connvc
modifier|*
name|cvcp
init|=
name|cvp
operator|->
name|cv_connvc
decl_stmt|;
name|Cmn_unit
modifier|*
name|cup
init|=
operator|(
name|Cmn_unit
operator|*
operator|)
name|cvcp
operator|->
name|cvc_attr
operator|.
name|nif
operator|->
name|nif_pif
decl_stmt|;
name|struct
name|vccb
modifier|*
name|vcp
decl_stmt|;
name|u_int
name|state
decl_stmt|;
name|int
name|s
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|CPCS_INIT
case|:
comment|/* 		 * Sanity check 		 */
if|if
condition|(
name|cvp
operator|->
name|cv_state
operator|!=
name|CVS_INST
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"atm_dev_lower: INIT: tok=%p, state=%d\n"
argument_list|,
name|tok
argument_list|,
name|cvp
operator|->
name|cv_state
argument_list|)
expr_stmt|;
break|break;
block|}
name|vcp
operator|=
name|cvp
operator|->
name|cv_connvc
operator|->
name|cvc_vcc
expr_stmt|;
comment|/* 		 * Validate SVC vpi.vci 		 */
if|if
condition|(
name|vcp
operator|->
name|vc_type
operator|&
name|VCC_SVC
condition|)
block|{
if|if
condition|(
name|atm_dev_vcc_find
argument_list|(
name|cup
argument_list|,
name|vcp
operator|->
name|vc_vpi
argument_list|,
name|vcp
operator|->
name|vc_vci
argument_list|,
name|vcp
operator|->
name|vc_type
operator|&
operator|(
name|VCC_IN
operator||
name|VCC_OUT
operator|)
argument_list|)
operator|!=
name|cvp
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"atm_dev_lower: dup SVC (%d,%d) tok=%p\n"
argument_list|,
name|vcp
operator|->
name|vc_vpi
argument_list|,
name|vcp
operator|->
name|vc_vci
argument_list|,
name|tok
argument_list|)
expr_stmt|;
name|atm_cm_abort
argument_list|(
name|cvp
operator|->
name|cv_connvc
argument_list|,
operator|&
name|atm_dev_cause
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* 		 * Tell the device to open the VCC 		 */
name|cvp
operator|->
name|cv_state
operator|=
name|CVS_INITED
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|cup
operator|->
name|cu_openvcc
call|)
argument_list|(
name|cup
argument_list|,
name|cvp
argument_list|)
condition|)
block|{
name|atm_cm_abort
argument_list|(
name|cvp
operator|->
name|cv_connvc
argument_list|,
operator|&
name|atm_dev_cause
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPCS_TERM
case|:
block|{
name|KBuffer
modifier|*
name|m
decl_stmt|,
modifier|*
name|prev
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|int
modifier|*
name|ip
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* 		 * Disconnect the VCC - ignore return code 		 */
if|if
condition|(
operator|(
name|cvp
operator|->
name|cv_state
operator|==
name|CVS_INITED
operator|)
operator|||
operator|(
name|cvp
operator|->
name|cv_state
operator|==
name|CVS_ACTIVE
operator|)
condition|)
block|{
call|(
name|void
call|)
argument_list|(
operator|*
name|cup
operator|->
name|cu_closevcc
argument_list|)
argument_list|(
name|cup
argument_list|,
name|cvp
argument_list|)
expr_stmt|;
block|}
name|cvp
operator|->
name|cv_state
operator|=
name|CVS_TERM
expr_stmt|;
comment|/* 		 * Remove from interface list 		 */
name|UNLINK
argument_list|(
name|cvp
argument_list|,
name|Cmn_vcc
argument_list|,
name|cup
operator|->
name|cu_vcc
argument_list|,
name|cv_next
argument_list|)
expr_stmt|;
comment|/* 		 * Free any buffers from this VCC on the ATM interrupt queue 		 */
name|prev
operator|=
name|NULL
expr_stmt|;
name|IF_LOCK
argument_list|(
operator|&
name|atm_intrq
argument_list|)
expr_stmt|;
for|for
control|(
name|m
operator|=
name|atm_intrq
operator|.
name|ifq_head
init|;
name|m
condition|;
name|m
operator|=
name|next
control|)
block|{
name|next
operator|=
name|KB_QNEXT
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* 			 * See if this entry is for the terminating VCC 			 */
name|KB_DATASTART
argument_list|(
name|m
argument_list|,
name|ip
argument_list|,
name|int
operator|*
argument_list|)
expr_stmt|;
name|ip
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|ip
operator|==
operator|(
name|int
operator|)
name|cvp
condition|)
block|{
comment|/* 				 * Yep, so dequeue the entry 				 */
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
name|atm_intrq
operator|.
name|ifq_head
operator|=
name|next
expr_stmt|;
else|else
name|KB_QNEXT
argument_list|(
name|prev
argument_list|)
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
name|atm_intrq
operator|.
name|ifq_tail
operator|=
name|prev
expr_stmt|;
name|atm_intrq
operator|.
name|ifq_len
operator|--
expr_stmt|;
comment|/* 				 * Free the unwanted buffers 				 */
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|prev
operator|=
name|m
expr_stmt|;
block|}
block|}
name|IF_UNLOCK
argument_list|(
operator|&
name|atm_intrq
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 		 * Free VCC resources 		 */
operator|(
name|void
operator|)
name|atm_free
argument_list|(
operator|(
name|caddr_t
operator|)
name|cvp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CPCS_UNITDATA_INV
case|:
comment|/* 		 * Sanity check 		 * 		 * Use temp state variable since we dont want to lock out 		 * interrupts, but initial VC activation interrupt may 		 * happen here, changing state somewhere in the middle. 		 */
name|state
operator|=
name|cvp
operator|->
name|cv_state
expr_stmt|;
if|if
condition|(
operator|(
name|state
operator|!=
name|CVS_ACTIVE
operator|)
operator|&&
operator|(
name|state
operator|!=
name|CVS_INITED
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"atm_dev_lower: UNITDATA: tok=%p, state=%d\n"
argument_list|,
name|tok
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|KB_FREEALL
argument_list|(
operator|(
name|KBuffer
operator|*
operator|)
name|arg1
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * Hand the data off to the device 		 */
call|(
modifier|*
name|cup
operator|->
name|cu_output
call|)
argument_list|(
name|cup
argument_list|,
name|cvp
argument_list|,
operator|(
name|KBuffer
operator|*
operator|)
name|arg1
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPCS_UABORT_INV
case|:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"atm_dev_lower: unimplemented stack cmd 0x%x, tok=%p\n"
argument_list|,
name|cmd
argument_list|,
name|tok
argument_list|)
expr_stmt|;
break|break;
default|default:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"atm_dev_lower: unknown stack cmd 0x%x, tok=%p\n"
argument_list|,
name|cmd
argument_list|,
name|tok
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * Allocate kernel memory block  *   * This function will allocate a kernel memory block of the type specified  * in the flags parameter.  The returned address will point to a memory  * block of the requested size and alignment.  The memory block will also   * be zeroed.  The alloc/free functions will manage/mask both the OS-specific   * kernel memory management requirements and the bookkeeping required to  * deal with data alignment issues.   *  * This function should not be called from interrupt level.  *  * Arguments:  *	size	size of memory block to allocate  *	align	data alignment requirement   *	flags	allocation flags (ATM_DEV_*)  *  * Returns:  *	uaddr	pointer to aligned memory block  *	NULL	unable to allocate memory  *  */
end_comment

begin_function
name|void
modifier|*
name|atm_dev_alloc
parameter_list|(
name|size
parameter_list|,
name|align
parameter_list|,
name|flags
parameter_list|)
name|u_int
name|size
decl_stmt|;
name|u_int
name|align
decl_stmt|;
name|u_int
name|flags
decl_stmt|;
block|{
name|Mem_blk
modifier|*
name|mbp
decl_stmt|;
name|Mem_ent
modifier|*
name|mep
decl_stmt|;
name|u_int
name|kalign
decl_stmt|,
name|ksize
decl_stmt|;
name|int
name|s
decl_stmt|,
name|i
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* 	 * Find a free Mem_ent 	 */
name|mep
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|mbp
operator|=
name|atm_mem_head
init|;
name|mbp
operator|&&
name|mep
operator|==
name|NULL
condition|;
name|mbp
operator|=
name|mbp
operator|->
name|mb_next
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MEM_NMEMENT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mbp
operator|->
name|mb_mement
index|[
name|i
index|]
operator|.
name|me_uaddr
operator|==
name|NULL
condition|)
block|{
name|mep
operator|=
operator|&
name|mbp
operator|->
name|mb_mement
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* 	 * If there are no free Mem_ent's, then allocate a new Mem_blk 	 * and link it into the chain 	 */
if|if
condition|(
name|mep
operator|==
name|NULL
condition|)
block|{
name|mbp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Mem_blk
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbp
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"atm_dev_alloc: Mem_blk failure\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|mbp
operator|->
name|mb_next
operator|=
name|atm_mem_head
expr_stmt|;
name|atm_mem_head
operator|=
name|mbp
expr_stmt|;
name|mep
operator|=
name|mbp
operator|->
name|mb_mement
expr_stmt|;
block|}
comment|/* 	 * Now we need to get the kernel's allocation alignment minimum 	 * 	 * This is obviously very OS-specific stuff 	 */
name|kalign
operator|=
name|MINALLOCSIZE
expr_stmt|;
comment|/* 	 * Figure out how much memory we must allocate to satify the 	 * user's size and alignment needs 	 */
if|if
condition|(
name|align
operator|<=
name|kalign
condition|)
name|ksize
operator|=
name|size
expr_stmt|;
else|else
name|ksize
operator|=
name|size
operator|+
name|align
operator|-
name|kalign
expr_stmt|;
comment|/* 	 * Finally, go get the memory 	 */
if|if
condition|(
name|flags
operator|&
name|ATM_DEV_NONCACHE
condition|)
block|{
name|mep
operator|->
name|me_kaddr
operator|=
name|malloc
argument_list|(
name|ksize
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mep
operator|->
name|me_kaddr
operator|=
name|malloc
argument_list|(
name|ksize
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mep
operator|->
name|me_kaddr
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"atm_dev_alloc: %skernel memory unavailable\n"
argument_list|,
operator|(
name|flags
operator|&
name|ATM_DEV_NONCACHE
operator|)
condition|?
literal|"non-cacheable "
else|:
literal|""
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Calculate correct alignment address to pass back to user 	 */
name|mep
operator|->
name|me_uaddr
operator|=
operator|(
name|void
operator|*
operator|)
name|roundup
argument_list|(
operator|(
name|u_int
operator|)
name|mep
operator|->
name|me_kaddr
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|mep
operator|->
name|me_ksize
operator|=
name|ksize
expr_stmt|;
name|mep
operator|->
name|me_flags
operator|=
name|flags
expr_stmt|;
comment|/* 	 * Clear memory for user 	 */
name|bzero
argument_list|(
name|mep
operator|->
name|me_uaddr
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ATM_DEBUG4
argument_list|(
literal|"atm_dev_alloc: size=%d, align=%d, flags=%d, uaddr=%p\n"
argument_list|,
name|size
argument_list|,
name|align
argument_list|,
name|flags
argument_list|,
name|mep
operator|->
name|me_uaddr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|mep
operator|->
name|me_uaddr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free kernel memory block  *   * This function will free a kernel memory block previously allocated by  * the atm_dev_alloc function.    *  * This function should not be called from interrupt level.  *  * Arguments:  *	uaddr	pointer to allocated aligned memory block  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|atm_dev_free
parameter_list|(
name|uaddr
parameter_list|)
specifier|volatile
name|void
modifier|*
name|uaddr
decl_stmt|;
block|{
name|Mem_blk
modifier|*
name|mbp
decl_stmt|;
name|Mem_ent
modifier|*
name|mep
decl_stmt|;
name|int
name|s
decl_stmt|,
name|i
decl_stmt|;
name|ATM_DEBUG1
argument_list|(
literal|"atm_dev_free: uaddr=%p\n"
argument_list|,
name|uaddr
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* 	 * Protect ourselves... 	 */
if|if
condition|(
name|uaddr
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"atm_dev_free: trying to free null address"
argument_list|)
expr_stmt|;
comment|/* 	 * Find our associated entry 	 */
name|mep
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|mbp
operator|=
name|atm_mem_head
init|;
name|mbp
operator|&&
name|mep
operator|==
name|NULL
condition|;
name|mbp
operator|=
name|mbp
operator|->
name|mb_next
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MEM_NMEMENT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mbp
operator|->
name|mb_mement
index|[
name|i
index|]
operator|.
name|me_uaddr
operator|==
name|uaddr
condition|)
block|{
name|mep
operator|=
operator|&
name|mbp
operator|->
name|mb_mement
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* 	 * If we didn't find our entry, then unceremoniously let the caller 	 * know they screwed up (it certainly couldn't be a bug here...) 	 */
if|if
condition|(
name|mep
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"atm_dev_free: trying to free unknown address"
argument_list|)
expr_stmt|;
comment|/* 	 * Give the memory space back to the kernel 	 */
if|if
condition|(
name|mep
operator|->
name|me_flags
operator|&
name|ATM_DEV_NONCACHE
condition|)
block|{
name|free
argument_list|(
name|mep
operator|->
name|me_kaddr
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
name|mep
operator|->
name|me_kaddr
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Free our entry 	 */
name|mep
operator|->
name|me_uaddr
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Compress buffer chain  *   * This function will compress a supplied buffer chain into a minimum number  * of kernel buffers.  Typically, this function will be used because the  * number of buffers in an output buffer chain is too large for a device's  * DMA capabilities.  This should only be called as a last resort, since  * all the data copying will surely kill any hopes of decent performance.  *  * Arguments:  *	m	pointer to source buffer chain  *  * Returns:  *	n	pointer to compressed buffer chain  *  */
end_comment

begin_function
name|KBuffer
modifier|*
name|atm_dev_compress
parameter_list|(
name|m
parameter_list|)
name|KBuffer
modifier|*
name|m
decl_stmt|;
block|{
name|KBuffer
modifier|*
name|n
decl_stmt|,
modifier|*
name|n0
decl_stmt|,
modifier|*
modifier|*
name|np
decl_stmt|;
name|int
name|len
decl_stmt|,
name|space
decl_stmt|;
name|caddr_t
name|src
decl_stmt|,
name|dst
decl_stmt|;
name|n
operator|=
name|n0
operator|=
name|NULL
expr_stmt|;
name|np
operator|=
operator|&
name|n0
expr_stmt|;
name|dst
operator|=
name|NULL
expr_stmt|;
name|space
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Copy each source buffer into compressed chain 	 */
while|while
condition|(
name|m
condition|)
block|{
if|if
condition|(
name|space
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Allocate another buffer for compressed chain 			 */
name|KB_ALLOCEXT
argument_list|(
name|n
argument_list|,
name|ATM_DEV_CMPR_LG
argument_list|,
name|KB_F_NOWAIT
argument_list|,
name|KB_T_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
block|{
name|space
operator|=
name|ATM_DEV_CMPR_LG
expr_stmt|;
block|}
else|else
block|{
name|KB_ALLOC
argument_list|(
name|n
argument_list|,
name|ATM_DEV_CMPR_SM
argument_list|,
name|KB_F_NOWAIT
argument_list|,
name|KB_T_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
block|{
name|space
operator|=
name|ATM_DEV_CMPR_SM
expr_stmt|;
block|}
else|else
block|{
comment|/* 					 * Unable to get any new buffers, so 					 * just return the partially compressed 					 * chain and hope... 					 */
operator|*
name|np
operator|=
name|m
expr_stmt|;
break|break;
block|}
block|}
name|KB_HEADSET
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|KB_LEN
argument_list|(
name|n
argument_list|)
operator|=
literal|0
expr_stmt|;
name|KB_BFRSTART
argument_list|(
name|n
argument_list|,
name|dst
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
operator|*
name|np
operator|=
name|n
expr_stmt|;
name|np
operator|=
operator|&
name|KB_NEXT
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Copy what we can from source buffer 		 */
name|len
operator|=
name|MIN
argument_list|(
name|space
argument_list|,
name|KB_LEN
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|KB_DATASTART
argument_list|(
name|m
argument_list|,
name|src
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* 		 * Adjust for copied data 		 */
name|dst
operator|+=
name|len
expr_stmt|;
name|space
operator|-=
name|len
expr_stmt|;
name|KB_HEADADJ
argument_list|(
name|m
argument_list|,
operator|-
name|len
argument_list|)
expr_stmt|;
name|KB_TAILADJ
argument_list|(
name|n
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* 		 * If we've exhausted our current source buffer, free it 		 * and move to the next one 		 */
if|if
condition|(
name|KB_LEN
argument_list|(
name|m
argument_list|)
operator|==
literal|0
condition|)
block|{
name|KB_FREEONE
argument_list|(
name|m
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|n0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Locate VCC entry  *   * This function will return the VCC entry for a specified interface and  * VPI/VCI value.  *  * Arguments:  *	cup	pointer to interface unit structure  *	vpi	VPI value  *	vci	VCI value  *	type	VCC type  *  * Returns:  *	vcp	pointer to located VCC entry matching  *	NULL	no VCC found  *  */
end_comment

begin_function
name|Cmn_vcc
modifier|*
name|atm_dev_vcc_find
parameter_list|(
name|cup
parameter_list|,
name|vpi
parameter_list|,
name|vci
parameter_list|,
name|type
parameter_list|)
name|Cmn_unit
modifier|*
name|cup
decl_stmt|;
name|u_int
name|vpi
decl_stmt|;
name|u_int
name|vci
decl_stmt|;
name|u_int
name|type
decl_stmt|;
block|{
name|Cmn_vcc
modifier|*
name|cvp
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
comment|/* 	 * Go find VCC 	 * 	 * (Probably should stick in a hash table some time) 	 */
for|for
control|(
name|cvp
operator|=
name|cup
operator|->
name|cu_vcc
init|;
name|cvp
condition|;
name|cvp
operator|=
name|cvp
operator|->
name|cv_next
control|)
block|{
name|struct
name|vccb
modifier|*
name|vcp
decl_stmt|;
name|vcp
operator|=
name|cvp
operator|->
name|cv_connvc
operator|->
name|cvc_vcc
expr_stmt|;
if|if
condition|(
operator|(
name|vcp
operator|->
name|vc_vci
operator|==
name|vci
operator|)
operator|&&
operator|(
name|vcp
operator|->
name|vc_vpi
operator|==
name|vpi
operator|)
operator|&&
operator|(
operator|(
name|vcp
operator|->
name|vc_type
operator|&
name|type
operator|)
operator|==
name|type
operator|)
condition|)
break|break;
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|cvp
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_comment
comment|/*  * Module unloading notification  *   * This function must be called just prior to unloading the module from   * memory.  All allocated memory will be freed here and anything else that  * needs cleaning up.  *  * Arguments:  *	none  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|atm_unload
parameter_list|()
block|{
name|Mem_blk
modifier|*
name|mbp
decl_stmt|;
name|Mem_ent
modifier|*
name|mep
decl_stmt|;
name|int
name|s
decl_stmt|,
name|i
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* 	 * Free up all of our memory management storage 	 */
while|while
condition|(
name|mbp
operator|=
name|atm_mem_head
condition|)
block|{
comment|/* 		 * Make sure users have freed up all of their memory 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MEM_NMEMENT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mbp
operator|->
name|mb_mement
index|[
name|i
index|]
operator|.
name|me_uaddr
operator|!=
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"atm_unload: unfreed memory"
argument_list|)
expr_stmt|;
block|}
block|}
name|atm_mem_head
operator|=
name|mbp
operator|->
name|mb_next
expr_stmt|;
comment|/* 		 * Hand this block back to the kernel 		 */
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|mbp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* notdef */
end_comment

begin_comment
comment|/*  * Print a PDU  *   * Arguments:  *	cup	pointer to device unit  *	cvp	pointer to VCC control block  *	m	pointer to pdu buffer chain  *	msg	pointer to message string  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|atm_dev_pdu_print
parameter_list|(
name|cup
parameter_list|,
name|cvp
parameter_list|,
name|m
parameter_list|,
name|msg
parameter_list|)
name|Cmn_unit
modifier|*
name|cup
decl_stmt|;
name|Cmn_vcc
modifier|*
name|cvp
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s vcc=(%d,%d)"
argument_list|,
name|msg
argument_list|,
name|cvp
operator|->
name|cv_connvc
operator|->
name|cvc_vcc
operator|->
name|vc_vpi
argument_list|,
name|cvp
operator|->
name|cv_connvc
operator|->
name|cvc_vcc
operator|->
name|vc_vci
argument_list|)
expr_stmt|;
name|atm_pdu_print
argument_list|(
name|m
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

