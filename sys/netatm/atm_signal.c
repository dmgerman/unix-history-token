begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * ===================================  * HARP  |  Host ATM Research Platform  * ===================================  *  *  * This Host ATM Research Platform ("HARP") file (the "Software") is  * made available by Network Computing Services, Inc. ("NetworkCS")  * "AS IS".  NetworkCS does not provide maintenance, improvements or  * support of any kind.  *  * NETWORKCS MAKES NO WARRANTIES OR REPRESENTATIONS, EXPRESS OR IMPLIED,  * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE, AS TO ANY ELEMENT OF THE  * SOFTWARE OR ANY SUPPORT PROVIDED IN CONNECTION WITH THIS SOFTWARE.  * In no event shall NetworkCS be responsible for any damages, including  * but not limited to consequential damages, arising from or relating to  * any use of the Software or related support.  *  * Copyright 1994-1998 Network Computing Services, Inc.  *  * Copies of this Software may be made, however, the above copyright  * notice must be reproduced on all copies.  *  *	@(#) $FreeBSD$  *  */
end_comment

begin_comment
comment|/*  * Core ATM Services  * -----------------  *  * General ATM signalling management  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netatm/port.h>
end_include

begin_include
include|#
directive|include
file|<netatm/queue.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sys.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sap.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_cm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_if.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sigmgr.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_stack.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_var.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"@(#) $FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Local variables  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sigmgr
modifier|*
name|atm_sigmgr_head
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|stack_defn
modifier|*
name|atm_stack_head
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Register a new Signalling Manager  *   * Each Signalling Manager must register itself here upon completing  * its internal initialization.  This applies to both linked and loaded  * managers.  *  * Arguments:  *	smp	pointer to Signalling Manager description  *  * Returns:  *	0 	registration was successful   *	errno	registration failed - reason indicated  *  */
end_comment

begin_function
name|int
name|atm_sigmgr_register
parameter_list|(
name|smp
parameter_list|)
name|struct
name|sigmgr
modifier|*
name|smp
decl_stmt|;
block|{
name|struct
name|sigmgr
modifier|*
name|smp2
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
comment|/* 	 * See if we need to be initialized 	 */
if|if
condition|(
operator|!
name|atm_init
condition|)
name|atm_initialize
argument_list|()
expr_stmt|;
comment|/* 	 * Make sure there's only one instance of each protocol 	 */
for|for
control|(
name|smp2
operator|=
name|atm_sigmgr_head
init|;
name|smp2
operator|!=
name|NULL
condition|;
name|smp2
operator|=
name|smp2
operator|->
name|sm_next
control|)
block|{
if|if
condition|(
name|smp
operator|->
name|sm_proto
operator|==
name|smp2
operator|->
name|sm_proto
condition|)
block|{
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
block|}
comment|/* 	 * Looks okay, link it in 	 */
name|LINK2TAIL
argument_list|(
name|smp
argument_list|,
expr|struct
name|sigmgr
argument_list|,
name|atm_sigmgr_head
argument_list|,
name|sm_next
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * De-register a Signalling Manager  *   * Each Signalling Manager must de-register (is this really a word?)  * itself before removing itself from the system.  This really only  * applies to managers about to be modunload'ed.  It is the signal  * manager's responsibility to ensure that all its protocol instances  * have been successfully terminated before de-registering itself.  *  * Arguments:  *	smp	pointer to Signalling Manager description  *  * Returns:  *	0 	deregistration was successful   *	errno	deregistration failed - reason indicated  *  */
end_comment

begin_function
name|int
name|atm_sigmgr_deregister
parameter_list|(
name|smp
parameter_list|)
name|struct
name|sigmgr
modifier|*
name|smp
decl_stmt|;
block|{
name|int
name|found
decl_stmt|,
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
comment|/* 	 * Unlink descriptor 	 */
name|UNLINKF
argument_list|(
name|smp
argument_list|,
expr|struct
name|sigmgr
argument_list|,
name|atm_sigmgr_head
argument_list|,
name|sm_next
argument_list|,
name|found
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attach a Signalling Manager to an ATM physical interface  *   * Each ATM physical interface must have a signalling manager attached to   * itself for the signalling protocol to be run across this interface.  The   * interface must be registered and completely initialized before the attach,   * since the signalling manager may initiate virtual circuit activity as part   * its response to this call.  *  * Called at splnet.  *  * Arguments:  *	pip	pointer to atm physical interface control block  * 	proto	requested signalling protocol  *  * Returns:  *	0	attach successful  *	errno	attach failed - reason indicated  *  */
end_comment

begin_function
name|int
name|atm_sigmgr_attach
parameter_list|(
name|pip
parameter_list|,
name|proto
parameter_list|)
name|struct
name|atm_pif
modifier|*
name|pip
decl_stmt|;
name|u_char
name|proto
decl_stmt|;
block|{
name|struct
name|atm_pif
modifier|*
name|tp
decl_stmt|;
name|struct
name|sigmgr
modifier|*
name|smp
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* 	 * Make sure interface is registered 	 */
for|for
control|(
name|tp
operator|=
name|atm_interface_head
init|;
name|tp
operator|!=
name|NULL
condition|;
name|tp
operator|=
name|tp
operator|->
name|pif_next
control|)
block|{
if|if
condition|(
name|tp
operator|==
name|pip
condition|)
break|break;
block|}
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
comment|/* 	 * Make sure no signalling manager is already attached 	 */
if|if
condition|(
name|pip
operator|->
name|pif_sigmgr
operator|!=
name|NULL
condition|)
block|{
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
comment|/* 	 * Must have at least one network interface defined 	 */
if|if
condition|(
name|pip
operator|->
name|pif_nif
operator|==
name|NULL
condition|)
return|return
operator|(
name|ETOOMANYREFS
operator|)
return|;
comment|/* 	 * Find requested protocol 	 */
for|for
control|(
name|smp
operator|=
name|atm_sigmgr_head
init|;
name|smp
operator|!=
name|NULL
condition|;
name|smp
operator|=
name|smp
operator|->
name|sm_next
control|)
block|{
if|if
condition|(
name|smp
operator|->
name|sm_proto
operator|==
name|proto
condition|)
break|break;
block|}
if|if
condition|(
name|smp
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|EPROTONOSUPPORT
operator|)
return|;
block|}
comment|/* 	 * Tell the signal manager about it 	 */
name|err
operator|=
call|(
modifier|*
name|smp
operator|->
name|sm_attach
call|)
argument_list|(
name|smp
argument_list|,
name|pip
argument_list|)
expr_stmt|;
comment|/* 	 * Tell all registered convergence modules about this 	 */
if|if
condition|(
operator|!
name|err
condition|)
block|{
name|struct
name|atm_nif
modifier|*
name|nip
decl_stmt|;
name|struct
name|atm_ncm
modifier|*
name|ncp
decl_stmt|;
for|for
control|(
name|nip
operator|=
name|pip
operator|->
name|pif_nif
init|;
name|nip
condition|;
name|nip
operator|=
name|nip
operator|->
name|nif_pnext
control|)
block|{
for|for
control|(
name|ncp
operator|=
name|atm_netconv_head
init|;
name|ncp
condition|;
name|ncp
operator|=
name|ncp
operator|->
name|ncm_next
control|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
call|(
modifier|*
name|ncp
operator|->
name|ncm_stat
call|)
argument_list|(
name|NCM_SIGATTACH
argument_list|,
name|nip
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|err
condition|)
break|break;
block|}
if|if
condition|(
name|err
condition|)
block|{
comment|/* 			 * Someone's unhappy, so back all this out 			 */
operator|(
name|void
operator|)
name|atm_sigmgr_detach
argument_list|(
name|pip
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Detach an ATM physical interface from a Signalling Manager  *   * The ATM interface must be detached from the signalling manager  * before the interface can be de-registered.    *  * Called at splnet.  *  * Arguments:  *	pip	pointer to atm physical interface control block  *  * Returns:  *	0	detach successful  *	errno	detach failed - reason indicated  *  */
end_comment

begin_function
name|int
name|atm_sigmgr_detach
parameter_list|(
name|pip
parameter_list|)
name|struct
name|atm_pif
modifier|*
name|pip
decl_stmt|;
block|{
name|struct
name|atm_pif
modifier|*
name|tp
decl_stmt|;
name|struct
name|atm_nif
modifier|*
name|nip
decl_stmt|;
name|struct
name|atm_ncm
modifier|*
name|ncp
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* 	 * Make sure interface is registered 	 */
for|for
control|(
name|tp
operator|=
name|atm_interface_head
init|;
name|tp
operator|!=
name|NULL
condition|;
name|tp
operator|=
name|tp
operator|->
name|pif_next
control|)
block|{
if|if
condition|(
name|tp
operator|==
name|pip
condition|)
break|break;
block|}
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
comment|/* 	 * Make sure a signalling manager is attached 	 */
if|if
condition|(
name|pip
operator|->
name|pif_sigmgr
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
comment|/* 	 * Tell all registered convergence modules about this 	 */
for|for
control|(
name|nip
operator|=
name|pip
operator|->
name|pif_nif
init|;
name|nip
condition|;
name|nip
operator|=
name|nip
operator|->
name|nif_pnext
control|)
block|{
for|for
control|(
name|ncp
operator|=
name|atm_netconv_head
init|;
name|ncp
condition|;
name|ncp
operator|=
name|ncp
operator|->
name|ncm_next
control|)
block|{
call|(
name|void
call|)
argument_list|(
operator|*
name|ncp
operator|->
name|ncm_stat
argument_list|)
argument_list|(
name|NCM_SIGDETACH
argument_list|,
name|nip
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Tell the signal manager about it 	 * 	 * NOTE: 	 * The only reason this should ever fail is if things are really 	 * hosed up somewhere, in which case doing a bunch of NCM_SIGATTACH's 	 * here just doesn't seem to help much. 	 */
name|err
operator|=
call|(
modifier|*
name|pip
operator|->
name|pif_sigmgr
operator|->
name|sm_detach
call|)
argument_list|(
name|pip
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Register an ATM Stack Service  *   * Each ATM stack service provider must register its provided service(s) here.  * Each service must be registered separately.  Service providers include   * both loaded and linked kernel modules.  Device driver services are NOT   * registered here - their service registry is performed implicitly through   * the device interface structure stack services list (pif_services).  *  * Arguments:  *	sdp	pointer to stack service definition block  *  * Returns:  *	0	registration successful  *	errno	registration failed - reason indicated  *  */
end_comment

begin_function
name|int
name|atm_stack_register
parameter_list|(
name|sdp
parameter_list|)
name|struct
name|stack_defn
modifier|*
name|sdp
decl_stmt|;
block|{
name|struct
name|stack_defn
modifier|*
name|tdp
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
comment|/* 	 * See if we need to be initialized 	 */
if|if
condition|(
operator|!
name|atm_init
condition|)
name|atm_initialize
argument_list|()
expr_stmt|;
comment|/* 	 * Ensure no duplicates 	 */
for|for
control|(
name|tdp
operator|=
name|atm_stack_head
init|;
name|tdp
operator|!=
name|NULL
condition|;
name|tdp
operator|=
name|tdp
operator|->
name|sd_next
control|)
block|{
if|if
condition|(
name|tdp
operator|->
name|sd_sap
operator|==
name|sdp
operator|->
name|sd_sap
condition|)
break|break;
block|}
if|if
condition|(
name|tdp
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
comment|/* 	 * Add stack to list 	 */
name|LINK2TAIL
argument_list|(
name|sdp
argument_list|,
expr|struct
name|stack_defn
argument_list|,
name|atm_stack_head
argument_list|,
name|sd_next
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * De-register an ATM Stack Service  *   * Each ATM stack service provider must de-register its registered service(s)  * before terminating the service.  Specifically, loaded kernel modules  * must de-register their services before unloading themselves.  *  * Arguments:  *	sdp	pointer to stack service definition block  *  * Returns:  *	0	de-registration successful   *	errno	de-registration failed - reason indicated  *  */
end_comment

begin_function
name|int
name|atm_stack_deregister
parameter_list|(
name|sdp
parameter_list|)
name|struct
name|stack_defn
modifier|*
name|sdp
decl_stmt|;
block|{
name|int
name|found
decl_stmt|,
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
comment|/* 	 * Remove service from list 	 */
name|UNLINKF
argument_list|(
name|sdp
argument_list|,
expr|struct
name|stack_defn
argument_list|,
name|atm_stack_head
argument_list|,
name|sd_next
argument_list|,
name|found
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create and Instantiate a Stack  *   * For the requested stack list, locate the stack service definitions   * necessary to build the stack to implement the listed services.  * The stack service definitions provided by the interface device-driver  * are always preferred, since they are (hopefully) done with   * hardware assistance from the interface card.  *  * After the stack has been built, the selected services are called to   * notify them of the new stack instantiation.  Each service should then   * allocate all the resources it requires for this new stack instance.    * The service should then wait for subsequent protocol notification  * via its stack command handlers.  *  * Must be called at splnet.  *  * Arguments:  *	cvp	pointer to connection vcc block for the created stack  *	tlp	pointer to stack list  *	upf	top-of-stack CM upper command handler  *  * Returns:  *	0	stack successfully created  *	errno	failed - reason indicated  *  */
end_comment

begin_decl_stmt
name|int
name|atm_create_stack
argument_list|(
name|cvp
argument_list|,
name|tlp
argument_list|,
name|upf
argument_list|)
name|Atm_connvc
modifier|*
name|cvp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|stack_list
modifier|*
name|tlp
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|upf
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_block
block|{
name|struct
name|stack_defn
modifier|*
name|sdp
decl_stmt|,
name|usd
decl_stmt|;
name|struct
name|stack_inst
name|svs
decl_stmt|;
name|struct
name|atm_pif
modifier|*
name|pip
init|=
name|cvp
operator|->
name|cvc_attr
operator|.
name|nif
operator|->
name|nif_pif
decl_stmt|;
name|int
name|i
decl_stmt|,
name|err
decl_stmt|;
comment|/* 	 * Initialize stack (element 0 is for owner's services) 	 */
name|svs
operator|.
name|si_srvc
index|[
literal|1
index|]
operator|=
name|sdp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Locate service provider for each service in the 	 * stack list.  We prefer interface driver providers 	 * over kernel module providers. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|STACK_CNT
condition|;
name|i
operator|++
control|)
block|{
name|Sap_t
name|sap
decl_stmt|;
comment|/* Stack list is 0-terminated */
if|if
condition|(
operator|(
name|sap
operator|=
name|tlp
operator|->
name|sl_sap
index|[
name|i
index|]
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/* 		 * Search interface's services 		 */
for|for
control|(
name|sdp
operator|=
name|pip
operator|->
name|pif_services
init|;
name|sdp
condition|;
name|sdp
operator|=
name|sdp
operator|->
name|sd_next
control|)
if|if
condition|(
name|sdp
operator|->
name|sd_sap
operator|==
name|sap
condition|)
break|break;
if|if
condition|(
name|sdp
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Search kernel services 			 */
for|for
control|(
name|sdp
operator|=
name|atm_stack_head
init|;
name|sdp
condition|;
name|sdp
operator|=
name|sdp
operator|->
name|sd_next
control|)
if|if
condition|(
name|sdp
operator|->
name|sd_sap
operator|==
name|sap
condition|)
break|break;
block|}
if|if
condition|(
name|sdp
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Requested service id not found 			 */
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
comment|/* 		 * Save stack definition for this service 		 */
name|svs
operator|.
name|si_srvc
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|sdp
expr_stmt|;
comment|/* 		 * Quit loop if this service is terminal, ie. if 		 * it takes care of the rest of the stack. 		 */
if|if
condition|(
name|sdp
operator|->
name|sd_flag
operator|&
name|SDF_TERM
condition|)
break|break;
block|}
comment|/* 	 * Ensure stack instance array is located and terminated 	 */
if|if
condition|(
operator|(
name|svs
operator|.
name|si_srvc
index|[
literal|1
index|]
operator|==
name|NULL
operator|)
operator|||
operator|!
operator|(
name|sdp
operator|->
name|sd_flag
operator|&
name|SDF_TERM
operator|)
condition|)
block|{
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
comment|/* 	 * Setup owner service definition 	 */
name|KM_ZERO
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|usd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|stack_defn
argument_list|)
argument_list|)
expr_stmt|;
name|usd
operator|.
name|sd_upper
operator|=
name|upf
expr_stmt|;
name|usd
operator|.
name|sd_toku
operator|=
name|cvp
expr_stmt|;
name|svs
operator|.
name|si_srvc
index|[
literal|0
index|]
operator|=
operator|&
name|usd
expr_stmt|;
comment|/* 	 * Instantiate the stack 	 */
name|err
operator|=
operator|(
operator|*
name|svs
operator|.
name|si_srvc
index|[
literal|1
index|]
operator|->
name|sd_inst
operator|)
operator|(
operator|&
name|svs
operator|.
name|si_srvc
index|[
literal|0
index|]
operator|,
name|cvp
operator|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/* 	 * Save top 'o stack info 	 */
name|cvp
operator|->
name|cvc_lower
operator|=
name|svs
operator|.
name|si_srvc
index|[
literal|1
index|]
operator|->
name|sd_lower
expr_stmt|;
name|cvp
operator|->
name|cvc_tokl
operator|=
name|svs
operator|.
name|si_srvc
index|[
literal|1
index|]
operator|->
name|sd_toku
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

end_unit

