begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * ===================================  * HARP  |  Host ATM Research Platform  * ===================================  *  *  * This Host ATM Research Platform ("HARP") file (the "Software") is  * made available by Network Computing Services, Inc. ("NetworkCS")  * "AS IS".  NetworkCS does not provide maintenance, improvements or  * support of any kind.  *  * NETWORKCS MAKES NO WARRANTIES OR REPRESENTATIONS, EXPRESS OR IMPLIED,  * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE, AS TO ANY ELEMENT OF THE  * SOFTWARE OR ANY SUPPORT PROVIDED IN CONNECTION WITH THIS SOFTWARE.  * In no event shall NetworkCS be responsible for any damages, including  * but not limited to consequential damages, arising from or relating to  * any use of the Software or related support.  *  * Copyright 1994-1998 Network Computing Services, Inc.  *  * Copies of this Software may be made, however, the above copyright  * notice must be reproduced on all copies.  *  *	@(#) $FreeBSD$  *  */
end_comment

begin_comment
comment|/*  * Core ATM Services  * -----------------  *  * Miscellaneous ATM subroutines  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_include
include|#
directive|include
file|<net/intrq.h>
end_include

begin_include
include|#
directive|include
file|<netatm/port.h>
end_include

begin_include
include|#
directive|include
file|<netatm/queue.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sys.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sap.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_cm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_if.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_stack.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_var.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"@(#) $FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Global variables  */
end_comment

begin_decl_stmt
name|struct
name|atm_pif
modifier|*
name|atm_interface_head
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|atm_ncm
modifier|*
name|atm_netconv_head
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Atm_endpoint
modifier|*
name|atm_endpoints
index|[
name|ENDPT_MAX
operator|+
literal|1
index|]
init|=
block|{
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|stackq_entry
modifier|*
name|atm_stackq_head
init|=
name|NULL
decl_stmt|,
modifier|*
name|atm_stackq_tail
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|atm_sock_stat
name|atm_sock_stat
init|=
block|{
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|atm_init
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|atm_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|atm_dev_print
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|atm_print_data
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|atm_version
init|=
name|ATM_VERSION
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|timeval
name|atm_debugtime
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uma_zone_t
name|atm_attributes_zone
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Local functions  */
end_comment

begin_function_decl
specifier|static
name|KTimeout_ret
name|atm_timexp
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Local variables  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|atm_time
modifier|*
name|atm_timeq
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uma_zone_t
name|atm_stackq_zone
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Initialize ATM kernel  *   * Performs any initialization required before things really get underway.  * Called from ATM domain initialization or from first registration function   * which gets called.  *  * Arguments:  *	none  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|atm_initialize
parameter_list|()
block|{
comment|/* 	 * Never called from interrupts, so no locking needed 	 */
if|if
condition|(
name|atm_init
condition|)
return|return;
name|atm_init
operator|=
literal|1
expr_stmt|;
name|atm_intrq
operator|.
name|ifq_maxlen
operator|=
name|ATM_INTRQ_MAX
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|atm_intrq
operator|.
name|ifq_mtx
argument_list|,
literal|"atm_inq"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|atmintrq_present
operator|=
literal|1
expr_stmt|;
name|atm_attributes_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"atm attributes"
argument_list|,
sizeof|sizeof
argument_list|(
name|Atm_attributes
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|atm_attributes_zone
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"atm_initialize: unable to create attributes zone"
argument_list|)
expr_stmt|;
name|uma_zone_set_max
argument_list|(
name|atm_attributes_zone
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|atm_stackq_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"atm stackq"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|stackq_entry
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|atm_stackq_zone
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"atm_initialize: unable to create stackq zone"
argument_list|)
expr_stmt|;
name|uma_zone_set_max
argument_list|(
name|atm_stackq_zone
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|register_netisr
argument_list|(
name|NETISR_ATM
argument_list|,
name|atm_intr
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize subsystems 	 */
name|atm_sock_init
argument_list|()
expr_stmt|;
name|atm_cm_init
argument_list|()
expr_stmt|;
name|atm_aal5_init
argument_list|()
expr_stmt|;
comment|/* 	 * Prime the timer 	 */
operator|(
name|void
operator|)
name|timeout
argument_list|(
name|atm_timexp
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
name|hz
operator|/
name|ATM_HZ
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle timer tick expiration  *   * Decrement tick count in first block on timer queue.  If there  * are blocks with expired timers, call their timeout function.  * This function is called ATM_HZ times per second.  *  * Arguments:  *	arg	argument passed on timeout() call  *  * Returns:  *	none  *  */
end_comment

begin_function
specifier|static
name|KTimeout_ret
name|atm_timexp
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|atm_time
modifier|*
name|tip
decl_stmt|;
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
comment|/* 	 * Decrement tick count 	 */
if|if
condition|(
operator|(
operator|(
name|tip
operator|=
name|atm_timeq
operator|)
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|--
name|tip
operator|->
name|ti_ticks
operator|>
literal|0
operator|)
condition|)
block|{
goto|goto
name|restart
goto|;
block|}
comment|/* 	 * Stack queue should have been drained 	 */
name|KASSERT
argument_list|(
name|atm_stackq_head
operator|==
name|NULL
argument_list|,
operator|(
literal|"atm_timexp: stack queue not empty"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Dispatch expired timers 	 */
while|while
condition|(
operator|(
operator|(
name|tip
operator|=
name|atm_timeq
operator|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|tip
operator|->
name|ti_ticks
operator|==
literal|0
operator|)
condition|)
block|{
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|struct
name|atm_time
modifier|*
parameter_list|)
function_decl|;
comment|/* 		 * Remove expired block from queue 		 */
name|atm_timeq
operator|=
name|tip
operator|->
name|ti_next
expr_stmt|;
name|tip
operator|->
name|ti_flag
operator|&=
operator|~
name|TIF_QUEUED
expr_stmt|;
comment|/* 		 * Call timeout handler (with network interrupts locked out) 		 */
name|func
operator|=
name|tip
operator|->
name|ti_func
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
call|(
modifier|*
name|func
call|)
argument_list|(
name|tip
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* 		 * Drain any deferred calls 		 */
name|STACK_DRAIN
argument_list|()
expr_stmt|;
block|}
name|restart
label|:
comment|/* 	 * Restart the timer 	 */
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|timeout
argument_list|(
name|atm_timexp
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
name|hz
operator|/
name|ATM_HZ
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Schedule a control block timeout  *   * Place the supplied timer control block on the timer queue.  The  * function (func) will be called in 't' timer ticks with the  * control block address as its only argument.  There are ATM_HZ  * timer ticks per second.  The ticks value stored in each block is  * a delta of the number of ticks from the previous block in the queue.  * Thus, for each tick interval, only the first block in the queue   * needs to have its tick value decremented.  *  * Arguments:  *	tip	pointer to timer control block  *	t	number of timer ticks until expiration  *	func	pointer to function to call at expiration   *  * Returns:  *	none  *  */
end_comment

begin_decl_stmt
name|void
name|atm_timeout
argument_list|(
name|tip
argument_list|,
name|t
argument_list|,
name|func
argument_list|)
decl|struct
name|atm_time
modifier|*
name|tip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|t
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|struct
name|atm_time
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_block
block|{
name|struct
name|atm_time
modifier|*
name|tip1
decl_stmt|,
modifier|*
name|tip2
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* 	 * Check for double queueing error 	 */
if|if
condition|(
name|tip
operator|->
name|ti_flag
operator|&
name|TIF_QUEUED
condition|)
name|panic
argument_list|(
literal|"atm_timeout: double queueing"
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure we delay at least a little bit 	 */
if|if
condition|(
name|t
operator|<=
literal|0
condition|)
name|t
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Find out where we belong on the queue 	 */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
for|for
control|(
name|tip1
operator|=
name|NULL
operator|,
name|tip2
operator|=
name|atm_timeq
init|;
name|tip2
operator|&&
operator|(
name|tip2
operator|->
name|ti_ticks
operator|<=
name|t
operator|)
condition|;
name|tip1
operator|=
name|tip2
operator|,
name|tip2
operator|=
name|tip1
operator|->
name|ti_next
control|)
block|{
name|t
operator|-=
name|tip2
operator|->
name|ti_ticks
expr_stmt|;
block|}
comment|/* 	 * Place ourselves on queue and update timer deltas 	 */
if|if
condition|(
name|tip1
operator|==
name|NULL
condition|)
name|atm_timeq
operator|=
name|tip
expr_stmt|;
else|else
name|tip1
operator|->
name|ti_next
operator|=
name|tip
expr_stmt|;
name|tip
operator|->
name|ti_next
operator|=
name|tip2
expr_stmt|;
if|if
condition|(
name|tip2
condition|)
name|tip2
operator|->
name|ti_ticks
operator|-=
name|t
expr_stmt|;
comment|/* 	 * Setup timer block 	 */
name|tip
operator|->
name|ti_flag
operator||=
name|TIF_QUEUED
expr_stmt|;
name|tip
operator|->
name|ti_ticks
operator|=
name|t
expr_stmt|;
name|tip
operator|->
name|ti_func
operator|=
name|func
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/*  * Cancel a timeout  *   * Remove the supplied timer control block from the timer queue.  *  * Arguments:  *	tip	pointer to timer control block  *  * Returns:  *	0	control block successfully dequeued  * 	1	control block not on timer queue  *  */
end_comment

begin_function
name|int
name|atm_untimeout
parameter_list|(
name|tip
parameter_list|)
name|struct
name|atm_time
modifier|*
name|tip
decl_stmt|;
block|{
name|struct
name|atm_time
modifier|*
name|tip1
decl_stmt|,
modifier|*
name|tip2
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* 	 * Is control block queued? 	 */
if|if
condition|(
operator|(
name|tip
operator|->
name|ti_flag
operator|&
name|TIF_QUEUED
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * Find control block on the queue 	 */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
for|for
control|(
name|tip1
operator|=
name|NULL
operator|,
name|tip2
operator|=
name|atm_timeq
init|;
name|tip2
operator|&&
operator|(
name|tip2
operator|!=
name|tip
operator|)
condition|;
name|tip1
operator|=
name|tip2
operator|,
name|tip2
operator|=
name|tip1
operator|->
name|ti_next
control|)
block|{ 	}
if|if
condition|(
name|tip2
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Remove block from queue and update timer deltas 	 */
name|tip2
operator|=
name|tip
operator|->
name|ti_next
expr_stmt|;
if|if
condition|(
name|tip1
operator|==
name|NULL
condition|)
name|atm_timeq
operator|=
name|tip2
expr_stmt|;
else|else
name|tip1
operator|->
name|ti_next
operator|=
name|tip2
expr_stmt|;
if|if
condition|(
name|tip2
condition|)
name|tip2
operator|->
name|ti_ticks
operator|+=
name|tip
operator|->
name|ti_ticks
expr_stmt|;
comment|/* 	 * Reset timer block 	 */
name|tip
operator|->
name|ti_flag
operator|&=
operator|~
name|TIF_QUEUED
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Queue a Stack Call   *   * Queues a stack call which must be deferred to the global stack queue.  * The call parameters are stored in entries which are allocated from the  * stack queue storage pool.  *  * Arguments:  *	cmd	stack command  *	func	destination function  *	token	destination layer's token  *	cvp	pointer to  connection vcc  *	arg1	command argument  *	arg2	command argument  *  * Returns:  *	0 	call queued  *	errno	call not queued - reason indicated  *  */
end_comment

begin_decl_stmt
name|int
name|atm_stack_enq
argument_list|(
name|cmd
argument_list|,
name|func
argument_list|,
name|token
argument_list|,
name|cvp
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|void
modifier|*
name|token
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Atm_connvc
modifier|*
name|cvp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|arg1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|arg2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|stackq_entry
modifier|*
name|sqp
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
comment|/* 	 * Get a new queue entry for this call 	 */
name|sqp
operator|=
name|uma_zalloc
argument_list|(
name|atm_stackq_zone
argument_list|,
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sqp
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* 	 * Fill in new entry 	 */
name|sqp
operator|->
name|sq_next
operator|=
name|NULL
expr_stmt|;
name|sqp
operator|->
name|sq_cmd
operator|=
name|cmd
expr_stmt|;
name|sqp
operator|->
name|sq_func
operator|=
name|func
expr_stmt|;
name|sqp
operator|->
name|sq_token
operator|=
name|token
expr_stmt|;
name|sqp
operator|->
name|sq_arg1
operator|=
name|arg1
expr_stmt|;
name|sqp
operator|->
name|sq_arg2
operator|=
name|arg2
expr_stmt|;
name|sqp
operator|->
name|sq_connvc
operator|=
name|cvp
expr_stmt|;
comment|/* 	 * Put new entry at end of queue 	 */
if|if
condition|(
name|atm_stackq_head
operator|==
name|NULL
condition|)
name|atm_stackq_head
operator|=
name|sqp
expr_stmt|;
else|else
name|atm_stackq_tail
operator|->
name|sq_next
operator|=
name|sqp
expr_stmt|;
name|atm_stackq_tail
operator|=
name|sqp
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Drain the Stack Queue  *   * Dequeues and processes entries from the global stack queue.    *  * Arguments:  *	none  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|atm_stack_drain
parameter_list|()
block|{
name|struct
name|stackq_entry
modifier|*
name|sqp
decl_stmt|,
modifier|*
name|qprev
decl_stmt|,
modifier|*
name|qnext
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
name|int
name|cnt
decl_stmt|;
comment|/* 	 * Loop thru entire queue until queue is empty 	 *	(but panic rather loop forever) 	 */
do|do
block|{
name|cnt
operator|=
literal|0
expr_stmt|;
name|qprev
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|sqp
operator|=
name|atm_stackq_head
init|;
name|sqp
condition|;
control|)
block|{
comment|/* 			 * Got an eligible entry, do STACK_CALL stuff 			 */
if|if
condition|(
name|sqp
operator|->
name|sq_cmd
operator|&
name|STKCMD_UP
condition|)
block|{
if|if
condition|(
name|sqp
operator|->
name|sq_connvc
operator|->
name|cvc_downcnt
condition|)
block|{
comment|/* 					 * Cant process now, skip it 					 */
name|qprev
operator|=
name|sqp
expr_stmt|;
name|sqp
operator|=
name|sqp
operator|->
name|sq_next
expr_stmt|;
continue|continue;
block|}
comment|/* 				 * OK, dispatch the call 				 */
name|sqp
operator|->
name|sq_connvc
operator|->
name|cvc_upcnt
operator|++
expr_stmt|;
call|(
modifier|*
name|sqp
operator|->
name|sq_func
call|)
argument_list|(
name|sqp
operator|->
name|sq_cmd
argument_list|,
name|sqp
operator|->
name|sq_token
argument_list|,
name|sqp
operator|->
name|sq_arg1
argument_list|,
name|sqp
operator|->
name|sq_arg2
argument_list|)
expr_stmt|;
name|sqp
operator|->
name|sq_connvc
operator|->
name|cvc_upcnt
operator|--
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sqp
operator|->
name|sq_connvc
operator|->
name|cvc_upcnt
condition|)
block|{
comment|/* 					 * Cant process now, skip it 					 */
name|qprev
operator|=
name|sqp
expr_stmt|;
name|sqp
operator|=
name|sqp
operator|->
name|sq_next
expr_stmt|;
continue|continue;
block|}
comment|/* 				 * OK, dispatch the call 				 */
name|sqp
operator|->
name|sq_connvc
operator|->
name|cvc_downcnt
operator|++
expr_stmt|;
call|(
modifier|*
name|sqp
operator|->
name|sq_func
call|)
argument_list|(
name|sqp
operator|->
name|sq_cmd
argument_list|,
name|sqp
operator|->
name|sq_token
argument_list|,
name|sqp
operator|->
name|sq_arg1
argument_list|,
name|sqp
operator|->
name|sq_arg2
argument_list|)
expr_stmt|;
name|sqp
operator|->
name|sq_connvc
operator|->
name|cvc_downcnt
operator|--
expr_stmt|;
block|}
comment|/* 			 * Dequeue processed entry and free it 			 */
name|cnt
operator|++
expr_stmt|;
name|qnext
operator|=
name|sqp
operator|->
name|sq_next
expr_stmt|;
if|if
condition|(
name|qprev
condition|)
name|qprev
operator|->
name|sq_next
operator|=
name|qnext
expr_stmt|;
else|else
name|atm_stackq_head
operator|=
name|qnext
expr_stmt|;
if|if
condition|(
name|qnext
operator|==
name|NULL
condition|)
name|atm_stackq_tail
operator|=
name|qprev
expr_stmt|;
name|uma_zfree
argument_list|(
name|atm_stackq_zone
argument_list|,
name|sqp
argument_list|)
expr_stmt|;
name|sqp
operator|=
name|qnext
expr_stmt|;
block|}
block|}
do|while
condition|(
name|cnt
operator|>
literal|0
condition|)
do|;
comment|/* 	 * Make sure entire queue was drained 	 */
if|if
condition|(
name|atm_stackq_head
operator|!=
name|NULL
condition|)
name|panic
argument_list|(
literal|"atm_stack_drain: Queue not emptied"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process Interrupt Queue  *   * Processes entries on the ATM interrupt queue.  This queue is used by  * device interface drivers in order to schedule events from the driver's   * lower (interrupt) half to the driver's stack services.  *  * The interrupt routines must store the stack processing function to call  * and a token (typically a driver/stack control block) at the front of the  * queued buffer.  We assume that the function pointer and token values are   * both contained (and properly aligned) in the first buffer of the chain.  *  * Arguments:  *	none  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|atm_intr
parameter_list|()
block|{
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|caddr_t
name|cp
decl_stmt|;
name|atm_intr_func_t
name|func
decl_stmt|;
name|void
modifier|*
name|token
decl_stmt|;
name|int
name|s
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Get next buffer from queue 		 */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|atm_intrq
argument_list|,
name|m
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
comment|/* 		 * Get function to call and token value 		 */
name|KB_DATASTART
argument_list|(
name|m
argument_list|,
name|cp
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|func
operator|=
operator|*
operator|(
name|atm_intr_func_t
operator|*
operator|)
name|cp
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|func
argument_list|)
expr_stmt|;
name|token
operator|=
operator|*
operator|(
name|void
operator|*
operator|*
operator|)
name|cp
expr_stmt|;
name|KB_HEADADJ
argument_list|(
name|m
argument_list|,
operator|-
operator|(
sizeof|sizeof
argument_list|(
name|func
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|token
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|KB_LEN
argument_list|(
name|m
argument_list|)
operator|==
literal|0
condition|)
block|{
name|KBuffer
modifier|*
name|m1
decl_stmt|;
name|KB_UNLINKHEAD
argument_list|(
name|m
argument_list|,
name|m1
argument_list|)
expr_stmt|;
name|m
operator|=
name|m1
expr_stmt|;
block|}
comment|/* 		 * Call processing function 		 */
call|(
modifier|*
name|func
call|)
argument_list|(
name|token
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* 		 * Drain any deferred calls 		 */
name|STACK_DRAIN
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Print a pdu buffer chain  *   * Arguments:  *	m	pointer to pdu buffer chain  *	msg	pointer to message header string  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|atm_pdu_print
parameter_list|(
name|m
parameter_list|,
name|msg
parameter_list|)
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
block|{
name|caddr_t
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|c
init|=
literal|' '
decl_stmt|;
name|printf
argument_list|(
literal|"%s:"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
name|KB_DATASTART
argument_list|(
name|m
argument_list|,
name|cp
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%cbfr=%p data=%p len=%d: "
argument_list|,
name|c
argument_list|,
name|m
argument_list|,
name|cp
argument_list|,
name|KB_LEN
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'\t'
expr_stmt|;
if|if
condition|(
name|atm_print_data
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|KB_LEN
argument_list|(
name|m
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%2x "
argument_list|,
operator|(
name|u_char
operator|)
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"<end_bfr>\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|m
operator|=
name|KB_NEXT
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

