begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * ===================================  * HARP  |  Host ATM Research Platform  * ===================================  *  *  * This Host ATM Research Platform ("HARP") file (the "Software") is  * made available by Network Computing Services, Inc. ("NetworkCS")  * "AS IS".  NetworkCS does not provide maintenance, improvements or  * support of any kind.  *  * NETWORKCS MAKES NO WARRANTIES OR REPRESENTATIONS, EXPRESS OR IMPLIED,  * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE, AS TO ANY ELEMENT OF THE  * SOFTWARE OR ANY SUPPORT PROVIDED IN CONNECTION WITH THIS SOFTWARE.  * In no event shall NetworkCS be responsible for any damages, including  * but not limited to consequential damages, arising from or relating to  * any use of the Software or related support.  *  * Copyright 1994-1998 Network Computing Services, Inc.  *  * Copies of this Software may be made, however, the above copyright  * notice must be reproduced on all copies.  *  *	@(#) $FreeBSD$  *  */
end_comment

begin_comment
comment|/*  * Core ATM Services  * -----------------  *  * Miscellaneous ATM subroutines  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_include
include|#
directive|include
file|<netatm/port.h>
end_include

begin_include
include|#
directive|include
file|<netatm/queue.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sys.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sap.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_cm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_if.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_stack.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_var.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"@(#) $FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Global variables  */
end_comment

begin_decl_stmt
name|struct
name|atm_pif
modifier|*
name|atm_interface_head
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|atm_ncm
modifier|*
name|atm_netconv_head
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Atm_endpoint
modifier|*
name|atm_endpoints
index|[
name|ENDPT_MAX
operator|+
literal|1
index|]
init|=
block|{
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sp_info
modifier|*
name|atm_pool_head
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|stackq_entry
modifier|*
name|atm_stackq_head
init|=
name|NULL
decl_stmt|,
modifier|*
name|atm_stackq_tail
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|sgi
end_ifdef

begin_decl_stmt
name|int
name|atm_intr_index
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|atm_sock_stat
name|atm_sock_stat
init|=
block|{
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|atm_init
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|atm_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|atm_dev_print
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|atm_print_data
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|atm_version
init|=
name|ATM_VERSION
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|timeval
name|atm_debugtime
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|atmintrq_present
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sp_info
name|atm_attributes_pool
init|=
block|{
literal|"atm attributes pool"
block|,
comment|/* si_name */
sizeof|sizeof
argument_list|(
name|Atm_attributes
argument_list|)
block|,
comment|/* si_blksiz */
literal|10
block|,
comment|/* si_blkcnt */
literal|100
comment|/* si_maxallow */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Local functions  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|atm_compact
name|__P
argument_list|(
operator|(
expr|struct
name|atm_time
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|KTimeout_ret
name|atm_timexp
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Local variables  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|atm_time
modifier|*
name|atm_timeq
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|atm_time
name|atm_compactimer
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sp_info
name|atm_stackq_pool
init|=
block|{
literal|"Service stack queue pool"
block|,
comment|/* si_name */
sizeof|sizeof
argument_list|(
expr|struct
name|stackq_entry
argument_list|)
block|,
comment|/* si_blksiz */
literal|10
block|,
comment|/* si_blkcnt */
literal|10
comment|/* si_maxallow */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Initialize ATM kernel  *   * Performs any initialization required before things really get underway.  * Called from ATM domain initialization or from first registration function   * which gets called.  *  * Arguments:  *	none  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|atm_initialize
parameter_list|()
block|{
comment|/* 	 * Never called from interrupts, so no locking needed 	 */
if|if
condition|(
name|atm_init
condition|)
return|return;
name|atm_init
operator|=
literal|1
expr_stmt|;
name|atm_intrq
operator|.
name|ifq_maxlen
operator|=
name|ATM_INTRQ_MAX
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|atm_intrq
operator|.
name|ifq_mtx
argument_list|,
literal|"atm_inq"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|sgi
name|atm_intr_index
operator|=
name|register_isr
argument_list|(
name|atm_intr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|register_netisr
argument_list|(
name|NETISR_ATM
argument_list|,
name|atm_intr
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize subsystems 	 */
name|atm_aal5_init
argument_list|()
expr_stmt|;
comment|/* 	 * Prime the timer 	 */
operator|(
name|void
operator|)
name|timeout
argument_list|(
name|atm_timexp
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
name|hz
operator|/
name|ATM_HZ
argument_list|)
expr_stmt|;
comment|/* 	 * Start the compaction timer 	 */
name|atm_timeout
argument_list|(
operator|&
name|atm_compactimer
argument_list|,
name|SPOOL_COMPACT
argument_list|,
name|atm_compact
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a Control Block  *   * Gets a new control block allocated from the specified storage pool,   * acquiring memory for new pool chunks if required.  The returned control  * block's contents will be cleared.  *  * Arguments:  *	sip	pointer to sp_info for storage pool  *  * Returns:  *	addr	pointer to allocated control block  *	0 	allocation failed  *  */
end_comment

begin_function
name|void
modifier|*
name|atm_allocate
parameter_list|(
name|sip
parameter_list|)
name|struct
name|sp_info
modifier|*
name|sip
decl_stmt|;
block|{
name|void
modifier|*
name|bp
decl_stmt|;
name|struct
name|sp_chunk
modifier|*
name|scp
decl_stmt|;
name|struct
name|sp_link
modifier|*
name|slp
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
comment|/* 	 * Count calls 	 */
name|sip
operator|->
name|si_allocs
operator|++
expr_stmt|;
comment|/* 	 * Are there any free in the pool? 	 */
if|if
condition|(
name|sip
operator|->
name|si_free
condition|)
block|{
comment|/* 		 * Find first chunk with a free block 		 */
for|for
control|(
name|scp
operator|=
name|sip
operator|->
name|si_poolh
init|;
name|scp
condition|;
name|scp
operator|=
name|scp
operator|->
name|sc_next
control|)
block|{
if|if
condition|(
name|scp
operator|->
name|sc_freeh
operator|!=
name|NULL
condition|)
break|break;
block|}
block|}
else|else
block|{
comment|/* 		 * No free blocks - have to allocate a new 		 * chunk (but put a limit to this) 		 */
name|struct
name|sp_link
modifier|*
name|slp_next
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 		 * First time for this pool?? 		 */
if|if
condition|(
name|sip
operator|->
name|si_chunksiz
operator|==
literal|0
condition|)
block|{
name|size_t
name|n
decl_stmt|;
comment|/* 			 * Initialize pool information 			 */
name|n
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sp_chunk
argument_list|)
operator|+
name|sip
operator|->
name|si_blkcnt
operator|*
operator|(
name|sip
operator|->
name|si_blksiz
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sp_link
argument_list|)
operator|)
expr_stmt|;
name|sip
operator|->
name|si_chunksiz
operator|=
name|roundup
argument_list|(
name|n
argument_list|,
name|SPOOL_ROUNDUP
argument_list|)
expr_stmt|;
comment|/* 			 * Place pool on kernel chain 			 */
name|LINK2TAIL
argument_list|(
name|sip
argument_list|,
expr|struct
name|sp_info
argument_list|,
name|atm_pool_head
argument_list|,
name|si_next
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sip
operator|->
name|si_chunks
operator|>=
name|sip
operator|->
name|si_maxallow
condition|)
block|{
name|sip
operator|->
name|si_fails
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|scp
operator|=
operator|(
expr|struct
name|sp_chunk
operator|*
operator|)
name|KM_ALLOC
argument_list|(
name|sip
operator|->
name|si_chunksiz
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|==
name|NULL
condition|)
block|{
name|sip
operator|->
name|si_fails
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|scp
operator|->
name|sc_next
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|sc_info
operator|=
name|sip
expr_stmt|;
name|scp
operator|->
name|sc_magic
operator|=
name|SPOOL_MAGIC
expr_stmt|;
name|scp
operator|->
name|sc_used
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Divy up chunk into free blocks 		 */
name|slp
operator|=
operator|(
expr|struct
name|sp_link
operator|*
operator|)
operator|(
name|scp
operator|+
literal|1
operator|)
expr_stmt|;
name|scp
operator|->
name|sc_freeh
operator|=
name|slp
expr_stmt|;
for|for
control|(
name|i
operator|=
name|sip
operator|->
name|si_blkcnt
init|;
name|i
operator|>
literal|1
condition|;
name|i
operator|--
control|)
block|{
name|slp_next
operator|=
operator|(
expr|struct
name|sp_link
operator|*
operator|)
operator|(
call|(
name|caddr_t
call|)
argument_list|(
name|slp
operator|+
literal|1
argument_list|)
operator|+
name|sip
operator|->
name|si_blksiz
operator|)
expr_stmt|;
name|slp
operator|->
name|sl_u
operator|.
name|slu_next
operator|=
name|slp_next
expr_stmt|;
name|slp
operator|=
name|slp_next
expr_stmt|;
block|}
name|slp
operator|->
name|sl_u
operator|.
name|slu_next
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|sc_freet
operator|=
name|slp
expr_stmt|;
comment|/* 		 * Add new chunk to end of pool 		 */
if|if
condition|(
name|sip
operator|->
name|si_poolh
condition|)
name|sip
operator|->
name|si_poolt
operator|->
name|sc_next
operator|=
name|scp
expr_stmt|;
else|else
name|sip
operator|->
name|si_poolh
operator|=
name|scp
expr_stmt|;
name|sip
operator|->
name|si_poolt
operator|=
name|scp
expr_stmt|;
name|sip
operator|->
name|si_chunks
operator|++
expr_stmt|;
name|sip
operator|->
name|si_total
operator|+=
name|sip
operator|->
name|si_blkcnt
expr_stmt|;
name|sip
operator|->
name|si_free
operator|+=
name|sip
operator|->
name|si_blkcnt
expr_stmt|;
if|if
condition|(
name|sip
operator|->
name|si_chunks
operator|>
name|sip
operator|->
name|si_maxused
condition|)
name|sip
operator|->
name|si_maxused
operator|=
name|sip
operator|->
name|si_chunks
expr_stmt|;
block|}
comment|/* 	 * Allocate the first free block in chunk 	 */
name|slp
operator|=
name|scp
operator|->
name|sc_freeh
expr_stmt|;
name|scp
operator|->
name|sc_freeh
operator|=
name|slp
operator|->
name|sl_u
operator|.
name|slu_next
expr_stmt|;
name|scp
operator|->
name|sc_used
operator|++
expr_stmt|;
name|sip
operator|->
name|si_free
operator|--
expr_stmt|;
name|bp
operator|=
operator|(
name|slp
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* 	 * Save link back to pool chunk 	 */
name|slp
operator|->
name|sl_u
operator|.
name|slu_chunk
operator|=
name|scp
expr_stmt|;
comment|/* 	 * Clear out block 	 */
name|KM_ZERO
argument_list|(
name|bp
argument_list|,
name|sip
operator|->
name|si_blksiz
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free a Control Block  *   * Returns a previously allocated control block back to the owners   * storage pool.    *  * Arguments:  *	bp	pointer to block to be freed  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|atm_free
parameter_list|(
name|bp
parameter_list|)
name|void
modifier|*
name|bp
decl_stmt|;
block|{
name|struct
name|sp_info
modifier|*
name|sip
decl_stmt|;
name|struct
name|sp_chunk
modifier|*
name|scp
decl_stmt|;
name|struct
name|sp_link
modifier|*
name|slp
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
comment|/* 	 * Get containing chunk and pool info 	 */
name|slp
operator|=
operator|(
expr|struct
name|sp_link
operator|*
operator|)
name|bp
expr_stmt|;
name|slp
operator|--
expr_stmt|;
name|scp
operator|=
name|slp
operator|->
name|sl_u
operator|.
name|slu_chunk
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|sc_magic
operator|!=
name|SPOOL_MAGIC
condition|)
name|panic
argument_list|(
literal|"atm_free: chunk magic missing"
argument_list|)
expr_stmt|;
name|sip
operator|=
name|scp
operator|->
name|sc_info
expr_stmt|;
comment|/* 	 * Add block to free chain 	 */
if|if
condition|(
name|scp
operator|->
name|sc_freeh
condition|)
block|{
name|scp
operator|->
name|sc_freet
operator|->
name|sl_u
operator|.
name|slu_next
operator|=
name|slp
expr_stmt|;
name|scp
operator|->
name|sc_freet
operator|=
name|slp
expr_stmt|;
block|}
else|else
name|scp
operator|->
name|sc_freeh
operator|=
name|scp
operator|->
name|sc_freet
operator|=
name|slp
expr_stmt|;
name|slp
operator|->
name|sl_u
operator|.
name|slu_next
operator|=
name|NULL
expr_stmt|;
name|sip
operator|->
name|si_free
operator|++
expr_stmt|;
name|scp
operator|->
name|sc_used
operator|--
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Storage Pool Compaction  *   * Called periodically in order to perform compaction of the  * storage pools.  Each pool will be checked to see if any chunks   * can be freed, taking some care to avoid freeing too many chunks  * in order to avoid memory thrashing.  *  * Called at splnet.  *  * Arguments:  *	tip	pointer to timer control block (atm_compactimer)  *  * Returns:  *	none  *  */
end_comment

begin_function
specifier|static
name|void
name|atm_compact
parameter_list|(
name|tip
parameter_list|)
name|struct
name|atm_time
modifier|*
name|tip
decl_stmt|;
block|{
name|struct
name|sp_info
modifier|*
name|sip
decl_stmt|;
name|struct
name|sp_chunk
modifier|*
name|scp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|sp_chunk
modifier|*
name|scp_prev
decl_stmt|;
comment|/* 	 * Check out all storage pools 	 */
for|for
control|(
name|sip
operator|=
name|atm_pool_head
init|;
name|sip
condition|;
name|sip
operator|=
name|sip
operator|->
name|si_next
control|)
block|{
comment|/* 		 * Always keep a minimum number of chunks around 		 */
if|if
condition|(
name|sip
operator|->
name|si_chunks
operator|<=
name|SPOOL_MIN_CHUNK
condition|)
continue|continue;
comment|/* 		 * Maximum chunks to free at one time will leave 		 * pool with at least 50% utilization, but never 		 * go below minimum chunk count. 		 */
name|i
operator|=
operator|(
operator|(
name|sip
operator|->
name|si_free
operator|*
literal|2
operator|)
operator|-
name|sip
operator|->
name|si_total
operator|)
operator|/
name|sip
operator|->
name|si_blkcnt
expr_stmt|;
name|i
operator|=
name|MIN
argument_list|(
name|i
argument_list|,
name|sip
operator|->
name|si_chunks
operator|-
name|SPOOL_MIN_CHUNK
argument_list|)
expr_stmt|;
comment|/* 		 * Look for chunks to free 		 */
name|scp_prev
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|scp
operator|=
name|sip
operator|->
name|si_poolh
init|;
name|scp
operator|&&
name|i
operator|>
literal|0
condition|;
control|)
block|{
if|if
condition|(
name|scp
operator|->
name|sc_used
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Found a chunk to free, so do it 				 */
if|if
condition|(
name|scp_prev
condition|)
block|{
name|scp_prev
operator|->
name|sc_next
operator|=
name|scp
operator|->
name|sc_next
expr_stmt|;
if|if
condition|(
name|sip
operator|->
name|si_poolt
operator|==
name|scp
condition|)
name|sip
operator|->
name|si_poolt
operator|=
name|scp_prev
expr_stmt|;
block|}
else|else
name|sip
operator|->
name|si_poolh
operator|=
name|scp
operator|->
name|sc_next
expr_stmt|;
name|KM_FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|scp
argument_list|,
name|sip
operator|->
name|si_chunksiz
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
comment|/* 				 * Update pool controls 				 */
name|sip
operator|->
name|si_chunks
operator|--
expr_stmt|;
name|sip
operator|->
name|si_total
operator|-=
name|sip
operator|->
name|si_blkcnt
expr_stmt|;
name|sip
operator|->
name|si_free
operator|-=
name|sip
operator|->
name|si_blkcnt
expr_stmt|;
name|i
operator|--
expr_stmt|;
if|if
condition|(
name|scp_prev
condition|)
name|scp
operator|=
name|scp_prev
operator|->
name|sc_next
expr_stmt|;
else|else
name|scp
operator|=
name|sip
operator|->
name|si_poolh
expr_stmt|;
block|}
else|else
block|{
name|scp_prev
operator|=
name|scp
expr_stmt|;
name|scp
operator|=
name|scp
operator|->
name|sc_next
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Restart the compaction timer 	 */
name|atm_timeout
argument_list|(
operator|&
name|atm_compactimer
argument_list|,
name|SPOOL_COMPACT
argument_list|,
name|atm_compact
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Release a Storage Pool  *   * Frees all dynamic storage acquired for a storage pool.  * This function is normally called just prior to a module's unloading.  *  * Arguments:  *	sip	pointer to sp_info for storage pool  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|atm_release_pool
parameter_list|(
name|sip
parameter_list|)
name|struct
name|sp_info
modifier|*
name|sip
decl_stmt|;
block|{
name|struct
name|sp_chunk
modifier|*
name|scp
decl_stmt|,
modifier|*
name|scp_next
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
comment|/* 	 * Free each chunk in pool 	 */
for|for
control|(
name|scp
operator|=
name|sip
operator|->
name|si_poolh
init|;
name|scp
condition|;
name|scp
operator|=
name|scp_next
control|)
block|{
comment|/* 		 * Check for memory leaks 		 */
if|if
condition|(
name|scp
operator|->
name|sc_used
condition|)
name|panic
argument_list|(
literal|"atm_release_pool: unfreed blocks"
argument_list|)
expr_stmt|;
name|scp_next
operator|=
name|scp
operator|->
name|sc_next
expr_stmt|;
name|KM_FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|scp
argument_list|,
name|sip
operator|->
name|si_chunksiz
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Update pool controls 	 */
name|sip
operator|->
name|si_poolh
operator|=
name|NULL
expr_stmt|;
name|sip
operator|->
name|si_chunks
operator|=
literal|0
expr_stmt|;
name|sip
operator|->
name|si_total
operator|=
literal|0
expr_stmt|;
name|sip
operator|->
name|si_free
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Unlink pool from active chain 	 */
name|sip
operator|->
name|si_chunksiz
operator|=
literal|0
expr_stmt|;
name|UNLINK
argument_list|(
name|sip
argument_list|,
expr|struct
name|sp_info
argument_list|,
name|atm_pool_head
argument_list|,
name|si_next
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Handle timer tick expiration  *   * Decrement tick count in first block on timer queue.  If there  * are blocks with expired timers, call their timeout function.  * This function is called ATM_HZ times per second.  *  * Arguments:  *	arg	argument passed on timeout() call  *  * Returns:  *	none  *  */
end_comment

begin_function
specifier|static
name|KTimeout_ret
name|atm_timexp
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|atm_time
modifier|*
name|tip
decl_stmt|;
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
comment|/* 	 * Decrement tick count 	 */
if|if
condition|(
operator|(
operator|(
name|tip
operator|=
name|atm_timeq
operator|)
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|--
name|tip
operator|->
name|ti_ticks
operator|>
literal|0
operator|)
condition|)
block|{
goto|goto
name|restart
goto|;
block|}
comment|/* 	 * Stack queue should have been drained 	 */
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|atm_stackq_head
operator|!=
name|NULL
condition|)
name|panic
argument_list|(
literal|"atm_timexp: stack queue not empty"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Dispatch expired timers 	 */
while|while
condition|(
operator|(
operator|(
name|tip
operator|=
name|atm_timeq
operator|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|tip
operator|->
name|ti_ticks
operator|==
literal|0
operator|)
condition|)
block|{
name|void
argument_list|(
argument|*func
argument_list|)
name|__P
argument_list|(
operator|(
expr|struct
name|atm_time
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Remove expired block from queue 		 */
name|atm_timeq
operator|=
name|tip
operator|->
name|ti_next
expr_stmt|;
name|tip
operator|->
name|ti_flag
operator|&=
operator|~
name|TIF_QUEUED
expr_stmt|;
comment|/* 		 * Call timeout handler (with network interrupts locked out) 		 */
name|func
operator|=
name|tip
operator|->
name|ti_func
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
call|(
modifier|*
name|func
call|)
argument_list|(
name|tip
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* 		 * Drain any deferred calls 		 */
name|STACK_DRAIN
argument_list|()
expr_stmt|;
block|}
name|restart
label|:
comment|/* 	 * Restart the timer 	 */
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|timeout
argument_list|(
name|atm_timexp
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
name|hz
operator|/
name|ATM_HZ
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Schedule a control block timeout  *   * Place the supplied timer control block on the timer queue.  The  * function (func) will be called in 't' timer ticks with the  * control block address as its only argument.  There are ATM_HZ  * timer ticks per second.  The ticks value stored in each block is  * a delta of the number of ticks from the previous block in the queue.  * Thus, for each tick interval, only the first block in the queue   * needs to have its tick value decremented.  *  * Arguments:  *	tip	pointer to timer control block  *	t	number of timer ticks until expiration  *	func	pointer to function to call at expiration   *  * Returns:  *	none  *  */
end_comment

begin_function_decl
name|void
name|atm_timeout
parameter_list|(
name|tip
parameter_list|,
name|t
parameter_list|,
name|func
parameter_list|)
name|struct
name|atm_time
modifier|*
name|tip
decl_stmt|;
name|int
name|t
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*func
end_function_decl

begin_expr_stmt
unit|)
name|__P
argument_list|(
operator|(
expr|struct
name|atm_time
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|atm_time
modifier|*
name|tip1
decl_stmt|,
modifier|*
name|tip2
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* 	 * Check for double queueing error 	 */
if|if
condition|(
name|tip
operator|->
name|ti_flag
operator|&
name|TIF_QUEUED
condition|)
name|panic
argument_list|(
literal|"atm_timeout: double queueing"
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure we delay at least a little bit 	 */
if|if
condition|(
name|t
operator|<=
literal|0
condition|)
name|t
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Find out where we belong on the queue 	 */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
for|for
control|(
name|tip1
operator|=
name|NULL
operator|,
name|tip2
operator|=
name|atm_timeq
init|;
name|tip2
operator|&&
operator|(
name|tip2
operator|->
name|ti_ticks
operator|<=
name|t
operator|)
condition|;
name|tip1
operator|=
name|tip2
operator|,
name|tip2
operator|=
name|tip1
operator|->
name|ti_next
control|)
block|{
name|t
operator|-=
name|tip2
operator|->
name|ti_ticks
expr_stmt|;
block|}
comment|/* 	 * Place ourselves on queue and update timer deltas 	 */
if|if
condition|(
name|tip1
operator|==
name|NULL
condition|)
name|atm_timeq
operator|=
name|tip
expr_stmt|;
else|else
name|tip1
operator|->
name|ti_next
operator|=
name|tip
expr_stmt|;
name|tip
operator|->
name|ti_next
operator|=
name|tip2
expr_stmt|;
if|if
condition|(
name|tip2
condition|)
name|tip2
operator|->
name|ti_ticks
operator|-=
name|t
expr_stmt|;
comment|/* 	 * Setup timer block 	 */
name|tip
operator|->
name|ti_flag
operator||=
name|TIF_QUEUED
expr_stmt|;
name|tip
operator|->
name|ti_ticks
operator|=
name|t
expr_stmt|;
name|tip
operator|->
name|ti_func
operator|=
name|func
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/*  * Cancel a timeout  *   * Remove the supplied timer control block from the timer queue.  *  * Arguments:  *	tip	pointer to timer control block  *  * Returns:  *	0	control block successfully dequeued  * 	1	control block not on timer queue  *  */
end_comment

begin_function
name|int
name|atm_untimeout
parameter_list|(
name|tip
parameter_list|)
name|struct
name|atm_time
modifier|*
name|tip
decl_stmt|;
block|{
name|struct
name|atm_time
modifier|*
name|tip1
decl_stmt|,
modifier|*
name|tip2
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* 	 * Is control block queued? 	 */
if|if
condition|(
operator|(
name|tip
operator|->
name|ti_flag
operator|&
name|TIF_QUEUED
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * Find control block on the queue 	 */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
for|for
control|(
name|tip1
operator|=
name|NULL
operator|,
name|tip2
operator|=
name|atm_timeq
init|;
name|tip2
operator|&&
operator|(
name|tip2
operator|!=
name|tip
operator|)
condition|;
name|tip1
operator|=
name|tip2
operator|,
name|tip2
operator|=
name|tip1
operator|->
name|ti_next
control|)
block|{ 	}
if|if
condition|(
name|tip2
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Remove block from queue and update timer deltas 	 */
name|tip2
operator|=
name|tip
operator|->
name|ti_next
expr_stmt|;
if|if
condition|(
name|tip1
operator|==
name|NULL
condition|)
name|atm_timeq
operator|=
name|tip2
expr_stmt|;
else|else
name|tip1
operator|->
name|ti_next
operator|=
name|tip2
expr_stmt|;
if|if
condition|(
name|tip2
condition|)
name|tip2
operator|->
name|ti_ticks
operator|+=
name|tip
operator|->
name|ti_ticks
expr_stmt|;
comment|/* 	 * Reset timer block 	 */
name|tip
operator|->
name|ti_flag
operator|&=
operator|~
name|TIF_QUEUED
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Queue a Stack Call   *   * Queues a stack call which must be deferred to the global stack queue.  * The call parameters are stored in entries which are allocated from the  * stack queue storage pool.  *  * Arguments:  *	cmd	stack command  *	func	destination function  *	token	destination layer's token  *	cvp	pointer to  connection vcc  *	arg1	command argument  *	arg2	command argument  *  * Returns:  *	0 	call queued  *	errno	call not queued - reason indicated  *  */
end_comment

begin_function_decl
name|int
name|atm_stack_enq
parameter_list|(
name|cmd
parameter_list|,
name|func
parameter_list|,
name|token
parameter_list|,
name|cvp
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|int
name|cmd
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*func
end_function_decl

begin_expr_stmt
unit|)
name|__P
argument_list|(
operator|(
name|int
operator|,
name|void
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|void
modifier|*
name|token
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Atm_connvc
modifier|*
name|cvp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|arg1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|arg2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|stackq_entry
modifier|*
name|sqp
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
comment|/* 	 * Get a new queue entry for this call 	 */
name|sqp
operator|=
operator|(
expr|struct
name|stackq_entry
operator|*
operator|)
name|atm_allocate
argument_list|(
operator|&
name|atm_stackq_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|sqp
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* 	 * Fill in new entry 	 */
name|sqp
operator|->
name|sq_next
operator|=
name|NULL
expr_stmt|;
name|sqp
operator|->
name|sq_cmd
operator|=
name|cmd
expr_stmt|;
name|sqp
operator|->
name|sq_func
operator|=
name|func
expr_stmt|;
name|sqp
operator|->
name|sq_token
operator|=
name|token
expr_stmt|;
name|sqp
operator|->
name|sq_arg1
operator|=
name|arg1
expr_stmt|;
name|sqp
operator|->
name|sq_arg2
operator|=
name|arg2
expr_stmt|;
name|sqp
operator|->
name|sq_connvc
operator|=
name|cvp
expr_stmt|;
comment|/* 	 * Put new entry at end of queue 	 */
if|if
condition|(
name|atm_stackq_head
operator|==
name|NULL
condition|)
name|atm_stackq_head
operator|=
name|sqp
expr_stmt|;
else|else
name|atm_stackq_tail
operator|->
name|sq_next
operator|=
name|sqp
expr_stmt|;
name|atm_stackq_tail
operator|=
name|sqp
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Drain the Stack Queue  *   * Dequeues and processes entries from the global stack queue.    *  * Arguments:  *	none  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|atm_stack_drain
parameter_list|()
block|{
name|struct
name|stackq_entry
modifier|*
name|sqp
decl_stmt|,
modifier|*
name|qprev
decl_stmt|,
modifier|*
name|qnext
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
name|int
name|cnt
decl_stmt|;
comment|/* 	 * Loop thru entire queue until queue is empty 	 *	(but panic rather loop forever) 	 */
do|do
block|{
name|cnt
operator|=
literal|0
expr_stmt|;
name|qprev
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|sqp
operator|=
name|atm_stackq_head
init|;
name|sqp
condition|;
control|)
block|{
comment|/* 			 * Got an eligible entry, do STACK_CALL stuff 			 */
if|if
condition|(
name|sqp
operator|->
name|sq_cmd
operator|&
name|STKCMD_UP
condition|)
block|{
if|if
condition|(
name|sqp
operator|->
name|sq_connvc
operator|->
name|cvc_downcnt
condition|)
block|{
comment|/* 					 * Cant process now, skip it 					 */
name|qprev
operator|=
name|sqp
expr_stmt|;
name|sqp
operator|=
name|sqp
operator|->
name|sq_next
expr_stmt|;
continue|continue;
block|}
comment|/* 				 * OK, dispatch the call 				 */
name|sqp
operator|->
name|sq_connvc
operator|->
name|cvc_upcnt
operator|++
expr_stmt|;
call|(
modifier|*
name|sqp
operator|->
name|sq_func
call|)
argument_list|(
name|sqp
operator|->
name|sq_cmd
argument_list|,
name|sqp
operator|->
name|sq_token
argument_list|,
name|sqp
operator|->
name|sq_arg1
argument_list|,
name|sqp
operator|->
name|sq_arg2
argument_list|)
expr_stmt|;
name|sqp
operator|->
name|sq_connvc
operator|->
name|cvc_upcnt
operator|--
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sqp
operator|->
name|sq_connvc
operator|->
name|cvc_upcnt
condition|)
block|{
comment|/* 					 * Cant process now, skip it 					 */
name|qprev
operator|=
name|sqp
expr_stmt|;
name|sqp
operator|=
name|sqp
operator|->
name|sq_next
expr_stmt|;
continue|continue;
block|}
comment|/* 				 * OK, dispatch the call 				 */
name|sqp
operator|->
name|sq_connvc
operator|->
name|cvc_downcnt
operator|++
expr_stmt|;
call|(
modifier|*
name|sqp
operator|->
name|sq_func
call|)
argument_list|(
name|sqp
operator|->
name|sq_cmd
argument_list|,
name|sqp
operator|->
name|sq_token
argument_list|,
name|sqp
operator|->
name|sq_arg1
argument_list|,
name|sqp
operator|->
name|sq_arg2
argument_list|)
expr_stmt|;
name|sqp
operator|->
name|sq_connvc
operator|->
name|cvc_downcnt
operator|--
expr_stmt|;
block|}
comment|/* 			 * Dequeue processed entry and free it 			 */
name|cnt
operator|++
expr_stmt|;
name|qnext
operator|=
name|sqp
operator|->
name|sq_next
expr_stmt|;
if|if
condition|(
name|qprev
condition|)
name|qprev
operator|->
name|sq_next
operator|=
name|qnext
expr_stmt|;
else|else
name|atm_stackq_head
operator|=
name|qnext
expr_stmt|;
if|if
condition|(
name|qnext
operator|==
name|NULL
condition|)
name|atm_stackq_tail
operator|=
name|qprev
expr_stmt|;
name|atm_free
argument_list|(
operator|(
name|caddr_t
operator|)
name|sqp
argument_list|)
expr_stmt|;
name|sqp
operator|=
name|qnext
expr_stmt|;
block|}
block|}
do|while
condition|(
name|cnt
operator|>
literal|0
condition|)
do|;
comment|/* 	 * Make sure entire queue was drained 	 */
if|if
condition|(
name|atm_stackq_head
operator|!=
name|NULL
condition|)
name|panic
argument_list|(
literal|"atm_stack_drain: Queue not emptied"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process Interrupt Queue  *   * Processes entries on the ATM interrupt queue.  This queue is used by  * device interface drivers in order to schedule events from the driver's   * lower (interrupt) half to the driver's stack services.  *  * The interrupt routines must store the stack processing function to call  * and a token (typically a driver/stack control block) at the front of the  * queued buffer.  We assume that the function pointer and token values are   * both contained (and properly aligned) in the first buffer of the chain.  *  * Arguments:  *	none  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|atm_intr
parameter_list|()
block|{
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|caddr_t
name|cp
decl_stmt|;
name|atm_intr_func_t
name|func
decl_stmt|;
name|void
modifier|*
name|token
decl_stmt|;
name|int
name|s
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Get next buffer from queue 		 */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|atm_intrq
argument_list|,
name|m
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
comment|/* 		 * Get function to call and token value 		 */
name|KB_DATASTART
argument_list|(
name|m
argument_list|,
name|cp
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|func
operator|=
operator|*
operator|(
name|atm_intr_func_t
operator|*
operator|)
name|cp
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|func
argument_list|)
expr_stmt|;
name|token
operator|=
operator|*
operator|(
name|void
operator|*
operator|*
operator|)
name|cp
expr_stmt|;
name|KB_HEADADJ
argument_list|(
name|m
argument_list|,
operator|-
operator|(
sizeof|sizeof
argument_list|(
name|func
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|token
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|KB_LEN
argument_list|(
name|m
argument_list|)
operator|==
literal|0
condition|)
block|{
name|KBuffer
modifier|*
name|m1
decl_stmt|;
name|KB_UNLINKHEAD
argument_list|(
name|m
argument_list|,
name|m1
argument_list|)
expr_stmt|;
name|m
operator|=
name|m1
expr_stmt|;
block|}
comment|/* 		 * Call processing function 		 */
call|(
modifier|*
name|func
call|)
argument_list|(
name|token
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* 		 * Drain any deferred calls 		 */
name|STACK_DRAIN
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Print a pdu buffer chain  *   * Arguments:  *	m	pointer to pdu buffer chain  *	msg	pointer to message header string  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|atm_pdu_print
parameter_list|(
name|m
parameter_list|,
name|msg
parameter_list|)
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
block|{
name|caddr_t
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|c
init|=
literal|' '
decl_stmt|;
name|printf
argument_list|(
literal|"%s:"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
name|KB_DATASTART
argument_list|(
name|m
argument_list|,
name|cp
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%cbfr=%p data=%p len=%d: "
argument_list|,
name|c
argument_list|,
name|m
argument_list|,
name|cp
argument_list|,
name|KB_LEN
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'\t'
expr_stmt|;
if|if
condition|(
name|atm_print_data
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|KB_LEN
argument_list|(
name|m
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%2x "
argument_list|,
operator|(
name|u_char
operator|)
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"<end_bfr>\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|m
operator|=
name|KB_NEXT
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

