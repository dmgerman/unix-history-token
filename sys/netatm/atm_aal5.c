begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * ===================================  * HARP  |  Host ATM Research Platform  * ===================================  *  *  * This Host ATM Research Platform ("HARP") file (the "Software") is  * made available by Network Computing Services, Inc. ("NetworkCS")  * "AS IS".  NetworkCS does not provide maintenance, improvements or  * support of any kind.  *  * NETWORKCS MAKES NO WARRANTIES OR REPRESENTATIONS, EXPRESS OR IMPLIED,  * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE, AS TO ANY ELEMENT OF THE  * SOFTWARE OR ANY SUPPORT PROVIDED IN CONNECTION WITH THIS SOFTWARE.  * In no event shall NetworkCS be responsible for any damages, including  * but not limited to consequential damages, arising from or relating to  * any use of the Software or related support.  *  * Copyright 1994-1998 Network Computing Services, Inc.  *  * Copies of this Software may be made, however, the above copyright  * notice must be reproduced on all copies.  *  *	@(#) $FreeBSD$  *  */
end_comment

begin_comment
comment|/*  * Core ATM Services  * -----------------  *  * ATM AAL5 socket protocol processing  *  */
end_comment

begin_include
include|#
directive|include
file|<netatm/kern_include.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"@(#) $FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Global variables  */
end_comment

begin_decl_stmt
name|u_long
name|atm_aal5_sendspace
init|=
literal|64
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX */
end_comment

begin_decl_stmt
name|u_long
name|atm_aal5_recvspace
init|=
literal|64
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX */
end_comment

begin_comment
comment|/*  * Local functions  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|atm_aal5_attach
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
name|int
operator|,
expr|struct
name|proc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|atm_aal5_detach
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|atm_aal5_bind
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
expr|struct
name|sockaddr
operator|*
operator|,
expr|struct
name|proc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|atm_aal5_listen
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
expr|struct
name|proc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|atm_aal5_connect
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
expr|struct
name|sockaddr
operator|*
operator|,
expr|struct
name|proc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|atm_aal5_accept
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
expr|struct
name|sockaddr
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|atm_aal5_disconnect
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|atm_aal5_shutdown
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|atm_aal5_send
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
name|int
operator|,
name|KBuffer
operator|*
operator|,
expr|struct
name|sockaddr
operator|*
operator|,
name|KBuffer
operator|*
operator|,
expr|struct
name|proc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|atm_aal5_abort
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|atm_aal5_control
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
name|u_long
operator|,
name|caddr_t
operator|,
expr|struct
name|ifnet
operator|*
operator|,
expr|struct
name|proc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|atm_aal5_sense
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
expr|struct
name|stat
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|atm_aal5_sockaddr
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
expr|struct
name|sockaddr
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|atm_aal5_peeraddr
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
expr|struct
name|sockaddr
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|atm_aal5_incoming
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|Atm_connection
operator|*
operator|,
name|Atm_attributes
operator|*
operator|,
name|void
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|atm_aal5_cpcs_data
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|KBuffer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|caddr_t
name|atm_aal5_getname
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
operator|(
name|BSD
operator|>=
literal|199506
operator|)
operator|)
end_if

begin_comment
comment|/*  * New-style socket request routines  */
end_comment

begin_decl_stmt
name|struct
name|pr_usrreqs
name|atm_aal5_usrreqs
init|=
block|{
name|atm_aal5_abort
block|,
comment|/* pru_abort */
name|atm_aal5_accept
block|,
comment|/* pru_accept */
name|atm_aal5_attach
block|,
comment|/* pru_attach */
name|atm_aal5_bind
block|,
comment|/* pru_bind */
name|atm_aal5_connect
block|,
comment|/* pru_connect */
name|pru_connect2_notsupp
block|,
comment|/* pru_connect2 */
name|atm_aal5_control
block|,
comment|/* pru_control */
name|atm_aal5_detach
block|,
comment|/* pru_detach */
name|atm_aal5_disconnect
block|,
comment|/* pru_disconnect */
name|atm_aal5_listen
block|,
comment|/* pru_listen */
name|atm_aal5_peeraddr
block|,
comment|/* pru_peeraddr */
name|pru_rcvd_notsupp
block|,
comment|/* pru_rcvd */
name|pru_rcvoob_notsupp
block|,
comment|/* pru_rcvoob */
name|atm_aal5_send
block|,
comment|/* pru_send */
name|atm_aal5_sense
block|,
comment|/* pru_sense */
name|atm_aal5_shutdown
block|,
comment|/* pru_shutdown */
name|atm_aal5_sockaddr
block|,
comment|/* pru_sockaddr */
name|sosend
block|,
comment|/* pru_sosend */
name|soreceive
block|,
comment|/* pru_soreceive */
name|sopoll
comment|/* pru_sopoll */
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Local variables  */
end_comment

begin_decl_stmt
specifier|static
name|Atm_endpoint
name|atm_aal5_endpt
init|=
block|{
name|NULL
block|,
name|ENDPT_SOCK_AAL5
block|,
name|NULL
block|,
name|atm_aal5_getname
block|,
name|atm_sock_connected
block|,
name|atm_sock_cleared
block|,
name|atm_aal5_incoming
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|atm_aal5_cpcs_data
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Atm_attributes
name|atm_aal5_defattr
init|=
block|{
name|NULL
block|,
comment|/* nif */
name|CMAPI_CPCS
block|,
comment|/* api */
literal|0
block|,
comment|/* api_init */
literal|0
block|,
comment|/* headin */
literal|0
block|,
comment|/* headout */
block|{
comment|/* aal */
name|T_ATM_PRESENT
block|,
name|ATM_AAL5
block|}
block|,
block|{
comment|/* traffic */
name|T_ATM_ABSENT
block|, 	}
block|,
block|{
comment|/* bearer */
name|T_ATM_ABSENT
block|, 	}
block|,
block|{
comment|/* bhli */
name|T_ATM_ABSENT
block|}
block|,
block|{
comment|/* blli */
name|T_ATM_ABSENT
block|,
name|T_ATM_ABSENT
block|, 	}
block|,
block|{
comment|/* llc */
name|T_ATM_ABSENT
block|, 	}
block|,
block|{
comment|/* called */
name|T_ATM_ABSENT
block|,
block|{
name|T_ATM_ABSENT
block|,
literal|0
block|}
block|,
block|{
name|T_ATM_ABSENT
block|,
literal|0
block|}
block|}
block|,
block|{
comment|/* calling */
name|T_ATM_ABSENT
block|}
block|,
block|{
comment|/* qos */
name|T_ATM_ABSENT
block|, 	}
block|,
block|{
comment|/* transit */
name|T_ATM_ABSENT
block|}
block|,
block|{
comment|/* cause */
name|T_ATM_ABSENT
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Handy common code macros  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DIAGNOSTIC
end_ifdef

begin_define
define|#
directive|define
name|ATM_INTRO
parameter_list|(
name|f
parameter_list|)
define|\
value|int		s, err = 0;				\ 	s = splnet();						\ 	ATM_DEBUG2("aal5 socket %s (%p)\n", f, so);		\
comment|/*							\ 	 * Stack queue should have been drained			\ 	 */
value|\ 	if (atm_stackq_head != NULL)				\ 		panic("atm_aal5: stack queue not empty");	\ 	;
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !DIAGNOSTIC */
end_comment

begin_define
define|#
directive|define
name|ATM_INTRO
parameter_list|(
name|f
parameter_list|)
define|\
value|int		s, err = 0;				\ 	s = splnet();						\ 	;
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DIAGNOSTIC */
end_comment

begin_define
define|#
directive|define
name|ATM_OUTRO
parameter_list|()
define|\
comment|/*							\ 	 * Drain any deferred calls				\ 	 */
define|\
value|STACK_DRAIN();						\ 	(void) splx(s);						\ 	return (err);						\ 	;
end_define

begin_define
define|#
directive|define
name|ATM_RETERR
parameter_list|(
name|errno
parameter_list|)
value|{					\ 	err = errno;						\ 	goto out;						\ }
end_define

begin_comment
comment|/*  * Attach protocol to socket  *  * Arguments:  *	so	pointer to socket  *	proto	protocol identifier  *	p	pointer to process  *  * Returns:  *	0	request processed  *	errno	error processing request - reason indicated  *  */
end_comment

begin_function
specifier|static
name|int
name|atm_aal5_attach
parameter_list|(
name|so
parameter_list|,
name|proto
parameter_list|,
name|p
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|int
name|proto
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|Atm_pcb
modifier|*
name|atp
decl_stmt|;
name|ATM_INTRO
argument_list|(
literal|"attach"
argument_list|)
expr_stmt|;
comment|/* 	 * Do general attach stuff 	 */
name|err
operator|=
name|atm_sock_attach
argument_list|(
name|so
argument_list|,
name|atm_aal5_sendspace
argument_list|,
name|atm_aal5_recvspace
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|ATM_RETERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* 	 * Finish up any protocol specific stuff 	 */
name|atp
operator|=
name|sotoatmpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|atp
operator|->
name|atp_type
operator|=
name|ATPT_AAL5
expr_stmt|;
comment|/* 	 * Set default connection attributes 	 */
name|atp
operator|->
name|atp_attr
operator|=
name|atm_aal5_defattr
expr_stmt|;
name|strncpy
argument_list|(
name|atp
operator|->
name|atp_name
argument_list|,
literal|"(AAL5)"
argument_list|,
name|T_ATM_APP_NAME_LEN
argument_list|)
expr_stmt|;
name|out
label|:
name|ATM_OUTRO
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Detach protocol from socket  *  * Arguments:  *	so	pointer to socket  *  * Returns:  *	0	request processed  *	errno	error processing request - reason indicated  *  */
end_comment

begin_function
specifier|static
name|int
name|atm_aal5_detach
parameter_list|(
name|so
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
block|{
name|ATM_INTRO
argument_list|(
literal|"detach"
argument_list|)
expr_stmt|;
name|err
operator|=
name|atm_sock_detach
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|ATM_OUTRO
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Bind address to socket  *  * Arguments:  *	so	pointer to socket  *	addr	pointer to protocol address  *	p	pointer to process  *  * Returns:  *	0	request processed  *	errno	error processing request - reason indicated  *  */
end_comment

begin_function
specifier|static
name|int
name|atm_aal5_bind
parameter_list|(
name|so
parameter_list|,
name|addr
parameter_list|,
name|p
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|addr
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|ATM_INTRO
argument_list|(
literal|"bind"
argument_list|)
expr_stmt|;
name|err
operator|=
name|atm_sock_bind
argument_list|(
name|so
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|ATM_OUTRO
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Listen for incoming connections  *  * Arguments:  *	so	pointer to socket  *	p	pointer to process  *  * Returns:  *	0	request processed  *	errno	error processing request - reason indicated  *  */
end_comment

begin_function
specifier|static
name|int
name|atm_aal5_listen
parameter_list|(
name|so
parameter_list|,
name|p
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|ATM_INTRO
argument_list|(
literal|"listen"
argument_list|)
expr_stmt|;
name|err
operator|=
name|atm_sock_listen
argument_list|(
name|so
argument_list|,
operator|&
name|atm_aal5_endpt
argument_list|)
expr_stmt|;
name|ATM_OUTRO
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Connect socket to peer  *  * Arguments:  *	so	pointer to socket  *	addr	pointer to protocol address  *	p	pointer to process  *  * Returns:  *	0	request processed  *	errno	error processing request - reason indicated  *  */
end_comment

begin_function
specifier|static
name|int
name|atm_aal5_connect
parameter_list|(
name|so
parameter_list|,
name|addr
parameter_list|,
name|p
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|addr
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|Atm_pcb
modifier|*
name|atp
decl_stmt|;
name|ATM_INTRO
argument_list|(
literal|"connect"
argument_list|)
expr_stmt|;
name|atp
operator|=
name|sotoatmpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
comment|/* 	 * Resize send socket buffer to maximum sdu size 	 */
if|if
condition|(
name|atp
operator|->
name|atp_attr
operator|.
name|aal
operator|.
name|tag
operator|==
name|T_ATM_PRESENT
condition|)
block|{
name|long
name|size
decl_stmt|;
name|size
operator|=
name|atp
operator|->
name|atp_attr
operator|.
name|aal
operator|.
name|v
operator|.
name|aal5
operator|.
name|forward_max_SDU_size
expr_stmt|;
if|if
condition|(
name|size
operator|!=
name|T_ATM_ABSENT
condition|)
if|if
condition|(
operator|!
name|sbreserve
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|,
name|size
argument_list|,
name|so
argument_list|,
name|p
argument_list|)
condition|)
block|{
name|err
operator|=
name|ENOBUFS
expr_stmt|;
name|ATM_OUTRO
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* 	 * Now get the socket connected 	 */
name|err
operator|=
name|atm_sock_connect
argument_list|(
name|so
argument_list|,
name|addr
argument_list|,
operator|&
name|atm_aal5_endpt
argument_list|)
expr_stmt|;
name|ATM_OUTRO
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Accept pending connection  *  * Arguments:  *	so	pointer to socket  *	addr	pointer to pointer to contain protocol address  *  * Returns:  *	0	request processed  *	errno	error processing request - reason indicated  *  */
end_comment

begin_function
specifier|static
name|int
name|atm_aal5_accept
parameter_list|(
name|so
parameter_list|,
name|addr
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|sockaddr
modifier|*
modifier|*
name|addr
decl_stmt|;
block|{
name|ATM_INTRO
argument_list|(
literal|"accept"
argument_list|)
expr_stmt|;
comment|/* 	 * Everything is pretty much done already, we just need to 	 * return the caller's address to the user. 	 */
name|err
operator|=
name|atm_sock_peeraddr
argument_list|(
name|so
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|ATM_OUTRO
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Disconnect connected socket  *  * Arguments:  *	so	pointer to socket  *  * Returns:  *	0	request processed  *	errno	error processing request - reason indicated  *  */
end_comment

begin_function
specifier|static
name|int
name|atm_aal5_disconnect
parameter_list|(
name|so
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
block|{
name|ATM_INTRO
argument_list|(
literal|"disconnect"
argument_list|)
expr_stmt|;
name|err
operator|=
name|atm_sock_disconnect
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|ATM_OUTRO
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Shut down socket data transmission  *  * Arguments:  *	so	pointer to socket  *  * Returns:  *	0	request processed  *	errno	error processing request - reason indicated  *  */
end_comment

begin_function
specifier|static
name|int
name|atm_aal5_shutdown
parameter_list|(
name|so
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
block|{
name|ATM_INTRO
argument_list|(
literal|"shutdown"
argument_list|)
expr_stmt|;
name|socantsendmore
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|ATM_OUTRO
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send user data  *  * Arguments:  *	so	pointer to socket  *	flags	send data flags  *	m	pointer to buffer containing user data  *	addr	pointer to protocol address  *	control	pointer to buffer containing protocol control data  *	p	pointer to process  *  * Returns:  *	0	request processed  *	errno	error processing request - reason indicated  *  */
end_comment

begin_function
specifier|static
name|int
name|atm_aal5_send
parameter_list|(
name|so
parameter_list|,
name|flags
parameter_list|,
name|m
parameter_list|,
name|addr
parameter_list|,
name|control
parameter_list|,
name|p
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|addr
decl_stmt|;
name|KBuffer
modifier|*
name|control
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|Atm_pcb
modifier|*
name|atp
decl_stmt|;
name|ATM_INTRO
argument_list|(
literal|"send"
argument_list|)
expr_stmt|;
comment|/* 	 * We don't support any control functions 	 */
if|if
condition|(
name|control
condition|)
block|{
name|int
name|clen
decl_stmt|;
name|clen
operator|=
name|KB_LEN
argument_list|(
name|control
argument_list|)
expr_stmt|;
name|KB_FREEALL
argument_list|(
name|control
argument_list|)
expr_stmt|;
if|if
condition|(
name|clen
condition|)
block|{
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ATM_RETERR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * We also don't support any flags or send-level addressing 	 */
if|if
condition|(
name|flags
operator|||
name|addr
condition|)
block|{
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ATM_RETERR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * All we've got left is the data, so push it out 	 */
name|atp
operator|=
name|sotoatmpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|err
operator|=
name|atm_cm_cpcs_data
argument_list|(
name|atp
operator|->
name|atp_conn
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* 		 * Output problem, drop packet 		 */
name|atm_sock_stat
operator|.
name|as_outdrop
index|[
name|atp
operator|->
name|atp_type
index|]
operator|++
expr_stmt|;
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|ATM_OUTRO
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Abnormally terminate service  *  * Arguments:  *	so	pointer to socket  *  * Returns:  *	0	request processed  *	errno	error processing request - reason indicated  *  */
end_comment

begin_function
specifier|static
name|int
name|atm_aal5_abort
parameter_list|(
name|so
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
block|{
name|ATM_INTRO
argument_list|(
literal|"abort"
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_error
operator|=
name|ECONNABORTED
expr_stmt|;
name|err
operator|=
name|atm_sock_detach
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|ATM_OUTRO
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Do control operation - ioctl system call  *  * Arguments:  *	so	pointer to socket  *	cmd	ioctl code  *	data	pointer to code specific parameter data area  *	ifp	pointer to ifnet structure if it's an interface ioctl  *	p	pointer to process  *  * Returns:  *	0 	request processed  *	errno	error processing request - reason indicated  *  */
end_comment

begin_function
specifier|static
name|int
name|atm_aal5_control
parameter_list|(
name|so
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|,
name|ifp
parameter_list|,
name|p
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|u_long
name|cmd
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|ATM_INTRO
argument_list|(
literal|"control"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
default|default:
name|err
operator|=
name|EOPNOTSUPP
expr_stmt|;
block|}
name|ATM_OUTRO
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Sense socket status - fstat system call  *  * Arguments:  *	so	pointer to socket  *	st	pointer to file status structure  *  * Returns:  *	0	request processed  *	errno	error processing request - reason indicated  *  */
end_comment

begin_function
specifier|static
name|int
name|atm_aal5_sense
parameter_list|(
name|so
parameter_list|,
name|st
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|stat
modifier|*
name|st
decl_stmt|;
block|{
name|ATM_INTRO
argument_list|(
literal|"sense"
argument_list|)
expr_stmt|;
comment|/* 	 * Just return the max sdu size for the connection 	 */
name|st
operator|->
name|st_blksize
operator|=
name|so
operator|->
name|so_snd
operator|.
name|sb_hiwat
expr_stmt|;
name|ATM_OUTRO
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Retrieve local socket address  *  * Arguments:  *	so	pointer to socket  *	addr	pointer to pointer to contain protocol address  *  * Returns:  *	0	request processed  *	errno	error processing request - reason indicated  *  */
end_comment

begin_function
specifier|static
name|int
name|atm_aal5_sockaddr
parameter_list|(
name|so
parameter_list|,
name|addr
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|sockaddr
modifier|*
modifier|*
name|addr
decl_stmt|;
block|{
name|ATM_INTRO
argument_list|(
literal|"sockaddr"
argument_list|)
expr_stmt|;
name|err
operator|=
name|atm_sock_sockaddr
argument_list|(
name|so
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|ATM_OUTRO
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Retrieve peer socket address  *  * Arguments:  *	so	pointer to socket  *	addr	pointer to pointer to contain protocol address  *  * Returns:  *	0	request processed  *	errno	error processing request - reason indicated  *  */
end_comment

begin_function
specifier|static
name|int
name|atm_aal5_peeraddr
parameter_list|(
name|so
parameter_list|,
name|addr
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|sockaddr
modifier|*
modifier|*
name|addr
decl_stmt|;
block|{
name|ATM_INTRO
argument_list|(
literal|"peeraddr"
argument_list|)
expr_stmt|;
name|err
operator|=
name|atm_sock_peeraddr
argument_list|(
name|so
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|ATM_OUTRO
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process Incoming Calls  *  * This function will receive control when an incoming call has been matched  * to one of our registered listen parameter blocks.  Assuming the call passes  * acceptance criteria and all required resources are available, we will  * create a new protocol control block and socket association.  We must  * then await notification of the final SVC setup results.  If any  * problems are encountered, we will just tell the connection manager to  * reject the call.  *  * Called at splnet.  *  * Arguments:  *	tok	owner's matched listening token  *	cop	pointer to incoming call's connection block  *	ap	pointer to incoming call's attributes  *	tokp	pointer to location to store our connection token  *  * Returns:  *	0	call is accepted  *	errno	call rejected - reason indicated  *  */
end_comment

begin_function
specifier|static
name|int
name|atm_aal5_incoming
parameter_list|(
name|tok
parameter_list|,
name|cop
parameter_list|,
name|ap
parameter_list|,
name|tokp
parameter_list|)
name|void
modifier|*
name|tok
decl_stmt|;
name|Atm_connection
modifier|*
name|cop
decl_stmt|;
name|Atm_attributes
modifier|*
name|ap
decl_stmt|;
name|void
modifier|*
modifier|*
name|tokp
decl_stmt|;
block|{
name|Atm_pcb
modifier|*
name|atp0
init|=
name|tok
decl_stmt|,
modifier|*
name|atp
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
comment|/* 	 * Allocate a new socket and pcb for this connection. 	 * 	 * Note that our attach function will be called via sonewconn 	 * and it will allocate and setup most of the pcb. 	 */
name|atm_sock_stat
operator|.
name|as_inconn
index|[
name|atp0
operator|->
name|atp_type
index|]
operator|++
expr_stmt|;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|BSD
argument_list|)
operator|&&
operator|(
name|BSD
operator|>=
literal|199103
operator|)
operator|)
name|so
operator|=
name|sonewconn
argument_list|(
name|atp0
operator|->
name|atp_socket
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|so
operator|=
name|sonewconn
argument_list|(
name|atp0
operator|->
name|atp_socket
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|so
condition|)
block|{
comment|/* 		 * Finish pcb setup and pass pcb back to CM 		 */
name|atp
operator|=
name|sotoatmpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|atp
operator|->
name|atp_conn
operator|=
name|cop
expr_stmt|;
name|atp
operator|->
name|atp_attr
operator|=
operator|*
name|atp0
operator|->
name|atp_conn
operator|->
name|co_lattr
expr_stmt|;
name|strncpy
argument_list|(
name|atp
operator|->
name|atp_name
argument_list|,
name|atp0
operator|->
name|atp_name
argument_list|,
name|T_ATM_APP_NAME_LEN
argument_list|)
expr_stmt|;
operator|*
name|tokp
operator|=
name|atp
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|ECONNABORTED
expr_stmt|;
name|atm_sock_stat
operator|.
name|as_connfail
index|[
name|atp0
operator|->
name|atp_type
index|]
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process Socket VCC Input Data  *  * Arguments:  *	tok	owner's connection token (atm_pcb)  *	m	pointer to input packet buffer chain  *  * Returns:  *	none  *  */
end_comment

begin_function
specifier|static
name|void
name|atm_aal5_cpcs_data
parameter_list|(
name|tok
parameter_list|,
name|m
parameter_list|)
name|void
modifier|*
name|tok
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
block|{
name|Atm_pcb
modifier|*
name|atp
init|=
name|tok
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|int
name|len
decl_stmt|;
name|so
operator|=
name|atp
operator|->
name|atp_socket
expr_stmt|;
name|KB_PLENGET
argument_list|(
name|m
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* 	 * Ensure that the socket is able to receive data and 	 * that there's room in the socket buffer 	 */
if|if
condition|(
operator|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTED
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_CANTRCVMORE
operator|)
operator|||
operator|(
name|len
operator|>
name|sbspace
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
operator|)
condition|)
block|{
name|atm_sock_stat
operator|.
name|as_indrop
index|[
name|atp
operator|->
name|atp_type
index|]
operator|++
expr_stmt|;
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Queue the data and notify the user 	 */
name|sbappendrecord
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|sorwakeup
argument_list|(
name|so
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Process getsockopt/setsockopt system calls  *  * Arguments:  *	so	pointer to socket  *	sopt	pointer to socket option info  *  * Returns:  *	0 	request processed  *	errno	error processing request - reason indicated  *  */
end_comment

begin_function
name|int
name|atm_aal5_ctloutput
parameter_list|(
name|so
parameter_list|,
name|sopt
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|sockopt
modifier|*
name|sopt
decl_stmt|;
block|{
name|Atm_pcb
modifier|*
name|atp
decl_stmt|;
name|ATM_INTRO
argument_list|(
literal|"ctloutput"
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure this is for us 	 */
if|if
condition|(
name|sopt
operator|->
name|sopt_level
operator|!=
name|T_ATM_SIGNALING
condition|)
block|{
name|ATM_RETERR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
block|}
name|atp
operator|=
name|sotoatmpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|atp
operator|==
name|NULL
condition|)
block|{
name|ATM_RETERR
argument_list|(
name|ENOTCONN
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|sopt
operator|->
name|sopt_dir
condition|)
block|{
case|case
name|SOPT_SET
case|:
comment|/* 		 * setsockopt() 		 */
comment|/* 		 * Validate socket state 		 */
switch|switch
condition|(
name|sopt
operator|->
name|sopt_name
condition|)
block|{
case|case
name|T_ATM_ADD_LEAF
case|:
case|case
name|T_ATM_DROP_LEAF
case|:
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTED
operator|)
operator|==
literal|0
condition|)
block|{
name|ATM_RETERR
argument_list|(
name|ENOTCONN
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|T_ATM_CAUSE
case|:
case|case
name|T_ATM_APP_NAME
case|:
break|break;
default|default:
if|if
condition|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTED
condition|)
block|{
name|ATM_RETERR
argument_list|(
name|EISCONN
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* 		 * Validate and save user-supplied option data 		 */
name|err
operator|=
name|atm_sock_setopt
argument_list|(
name|so
argument_list|,
name|sopt
argument_list|,
name|atp
argument_list|)
expr_stmt|;
break|break;
case|case
name|SOPT_GET
case|:
comment|/* 		 * getsockopt() 		 */
comment|/* 		 * Return option data 		 */
name|err
operator|=
name|atm_sock_getopt
argument_list|(
name|so
argument_list|,
name|sopt
argument_list|,
name|atp
argument_list|)
expr_stmt|;
break|break;
block|}
name|out
label|:
name|ATM_OUTRO
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize AAL5 Sockets  *  * Arguments:  *	none  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|atm_aal5_init
parameter_list|()
block|{
comment|/* 	 * Register our endpoint 	 */
if|if
condition|(
name|atm_endpoint_register
argument_list|(
operator|&
name|atm_aal5_endpt
argument_list|)
condition|)
name|panic
argument_list|(
literal|"atm_aal5_init: register"
argument_list|)
expr_stmt|;
comment|/* 	 * Set default connection attributes 	 */
name|atm_aal5_defattr
operator|.
name|aal
operator|.
name|v
operator|.
name|aal5
operator|.
name|forward_max_SDU_size
operator|=
name|T_ATM_ABSENT
expr_stmt|;
name|atm_aal5_defattr
operator|.
name|aal
operator|.
name|v
operator|.
name|aal5
operator|.
name|backward_max_SDU_size
operator|=
name|T_ATM_ABSENT
expr_stmt|;
name|atm_aal5_defattr
operator|.
name|aal
operator|.
name|v
operator|.
name|aal5
operator|.
name|SSCS_type
operator|=
name|T_ATM_NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get Connection's Application/Owner Name  *  * Arguments:  *	tok	owner's connection token (atm_pcb)  *  * Returns:  *	addr	pointer to string containing our name  *  */
end_comment

begin_function
specifier|static
name|caddr_t
name|atm_aal5_getname
parameter_list|(
name|tok
parameter_list|)
name|void
modifier|*
name|tok
decl_stmt|;
block|{
name|Atm_pcb
modifier|*
name|atp
init|=
name|tok
decl_stmt|;
return|return
operator|(
name|atp
operator|->
name|atp_name
operator|)
return|;
block|}
end_function

end_unit

