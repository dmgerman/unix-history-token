begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ===================================  * HARP  |  Host ATM Research Platform  * ===================================  *  *  * This Host ATM Research Platform ("HARP") file (the "Software") is  * made available by Network Computing Services, Inc. ("NetworkCS")  * "AS IS".  NetworkCS does not provide maintenance, improvements or  * support of any kind.  *  * NETWORKCS MAKES NO WARRANTIES OR REPRESENTATIONS, EXPRESS OR IMPLIED,  * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE, AS TO ANY ELEMENT OF THE  * SOFTWARE OR ANY SUPPORT PROVIDED IN CONNECTION WITH THIS SOFTWARE.  * In no event shall NetworkCS be responsible for any damages, including  * but not limited to consequential damages, arising from or relating to  * any use of the Software or related support.  *  * Copyright 1994-1998 Network Computing Services, Inc.  *  * Copies of this Software may be made, however, the above copyright  * notice must be reproduced on all copies.  */
end_comment

begin_comment
comment|/*  * SPANS Signalling Manager  * ---------------------------  *  * SPANS Connectionless Datagram Service (CLS) module  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<netatm/port.h>
end_include

begin_include
include|#
directive|include
file|<netatm/queue.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sys.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sap.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_cm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_if.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_vc.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sigmgr.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_stack.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_var.h>
end_include

begin_include
include|#
directive|include
file|<netatm/ipatm/ipatm_var.h>
end_include

begin_include
include|#
directive|include
file|<netatm/ipatm/ipatm_serv.h>
end_include

begin_include
include|#
directive|include
file|"spans_xdr.h"
end_include

begin_include
include|#
directive|include
file|<netatm/spans/spans_var.h>
end_include

begin_include
include|#
directive|include
file|<netatm/spans/spans_cls.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_comment
comment|/*  * Global variables  */
end_comment

begin_decl_stmt
name|int
name|spanscls_print
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_harp_spans
argument_list|,
name|OID_AUTO
argument_list|,
name|spanscls_print
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|spanscls_print
argument_list|,
literal|0
argument_list|,
literal|"dump SPANS packets"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|spanscls
modifier|*
name|spanscls_head
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|spans_addr
name|spans_bcastaddr
init|=
block|{
block|{
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|spanscls_hdr
name|spanscls_hdr
init|=
block|{
block|{
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|}
block|,
comment|/* dst */
block|{
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|}
block|,
comment|/* src */
literal|0x00
block|,
literal|0x00
block|,
literal|0
block|,
literal|0xaa
block|,
literal|0xaa
block|,
literal|0x03
block|,
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|,
literal|0
comment|/* LLC SNAP */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Local functions  */
end_comment

begin_function_decl
specifier|static
name|int
name|spanscls_ipact
parameter_list|(
name|struct
name|ip_nif
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|spanscls_ipdact
parameter_list|(
name|struct
name|ip_nif
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|spanscls_bcast_output
parameter_list|(
name|struct
name|ip_nif
modifier|*
parameter_list|,
name|KBuffer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|spanscls_cpcs_data
parameter_list|(
name|void
modifier|*
parameter_list|,
name|KBuffer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|spanscls_connected
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|spanscls_cleared
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|t_atm_cause
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|caddr_t
name|spanscls_getname
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|spanscls_pdu_print
parameter_list|(
specifier|const
name|struct
name|spanscls
modifier|*
parameter_list|,
specifier|const
name|KBuffer
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Local variables  */
end_comment

begin_decl_stmt
specifier|static
name|uma_zone_t
name|spanscls_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ip_serv
name|spanscls_ipserv
init|=
block|{
name|spanscls_ipact
block|,
name|spanscls_ipdact
block|,
name|spansarp_ioctl
block|,
name|NULL
block|,
name|spansarp_svcout
block|,
name|spansarp_svcin
block|,
name|spansarp_svcactive
block|,
name|spansarp_vcclose
block|,
name|spanscls_bcast_output
block|,
block|{
block|{
name|ATM_AAL5
block|,
name|ATM_ENC_NULL
block|}
block|,
block|{
name|ATM_AAL3_4
block|,
name|ATM_ENC_NULL
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|spanscls_bridged
index|[]
init|=
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0xaa
block|,
literal|0xaa
block|,
literal|0x03
block|,
literal|0x00
block|,
literal|0x80
block|,
literal|0xc2
comment|/* LLC SNAP */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Atm_endpoint
name|spanscls_endpt
init|=
block|{
name|NULL
block|,
name|ENDPT_SPANS_CLS
block|,
name|NULL
block|,
name|spanscls_getname
block|,
name|spanscls_connected
block|,
name|spanscls_cleared
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|spanscls_cpcs_data
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Atm_attributes
name|spanscls_attr
init|=
block|{
name|NULL
block|,
comment|/* nif */
name|CMAPI_CPCS
block|,
comment|/* api */
literal|0
block|,
comment|/* api_init */
literal|0
block|,
comment|/* headin */
literal|0
block|,
comment|/* headout */
block|{
comment|/* aal */
name|T_ATM_PRESENT
block|,
name|ATM_AAL3_4
block|}
block|,
block|{
comment|/* traffic */
name|T_ATM_PRESENT
block|,
block|{
block|{
name|T_ATM_ABSENT
block|,
literal|0
block|,
name|T_ATM_ABSENT
block|,
name|T_ATM_ABSENT
block|,
name|T_ATM_ABSENT
block|,
name|T_ATM_ABSENT
block|,
name|T_NO
block|}
block|,
block|{
name|T_ATM_ABSENT
block|,
literal|0
block|,
name|T_ATM_ABSENT
block|,
name|T_ATM_ABSENT
block|,
name|T_ATM_ABSENT
block|,
name|T_ATM_ABSENT
block|,
name|T_NO
block|}
block|,
name|T_YES
block|}
block|, 	}
block|,
block|{
comment|/* bearer */
name|T_ATM_PRESENT
block|,
block|{
name|T_ATM_CLASS_X
block|,
name|T_ATM_NULL
block|,
name|T_ATM_NULL
block|,
name|T_NO
block|,
name|T_ATM_1_TO_1
block|}
block|}
block|,
block|{
comment|/* bhli */
name|T_ATM_ABSENT
block|}
block|,
block|{
comment|/* blli */
name|T_ATM_ABSENT
block|,
name|T_ATM_ABSENT
block|}
block|,
block|{
comment|/* llc */
name|T_ATM_ABSENT
block|}
block|,
block|{
comment|/* called */
name|T_ATM_PRESENT
block|, 	}
block|,
block|{
comment|/* calling */
name|T_ATM_ABSENT
block|}
block|,
block|{
comment|/* qos */
name|T_ATM_PRESENT
block|,
block|{
name|T_ATM_NETWORK_CODING
block|,
block|{
name|T_ATM_QOS_CLASS_0
block|, 			}
block|,
block|{
name|T_ATM_QOS_CLASS_0
block|}
block|}
block|}
block|,
block|{
comment|/* transit */
name|T_ATM_ABSENT
block|}
block|,
block|{
comment|/* cause */
name|T_ATM_ABSENT
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|t_atm_cause
name|spanscls_cause
init|=
block|{
name|T_ATM_ITU_CODING
block|,
name|T_ATM_LOC_USER
block|,
name|T_ATM_CAUSE_UNSPECIFIED_NORMAL
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Process module loading  *   * Called whenever the spans module is initializing.    *  * Arguments:  *	none  *  * Returns:  *	0	initialization successful  *	errno	initialization failed - reason indicated  *  */
end_comment

begin_function
name|int
name|spanscls_start
parameter_list|()
block|{
name|int
name|err
decl_stmt|;
name|spanscls_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"spanscls"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|spanscls
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|spanscls_zone
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"spanscls_zone"
argument_list|)
expr_stmt|;
comment|/* 	 * Fill in union fields 	 */
name|spanscls_attr
operator|.
name|aal
operator|.
name|v
operator|.
name|aal4
operator|.
name|forward_max_SDU_size
operator|=
name|ATM_NIF_MTU
expr_stmt|;
name|spanscls_attr
operator|.
name|aal
operator|.
name|v
operator|.
name|aal4
operator|.
name|backward_max_SDU_size
operator|=
name|ATM_NIF_MTU
expr_stmt|;
name|spanscls_attr
operator|.
name|aal
operator|.
name|v
operator|.
name|aal4
operator|.
name|SSCS_type
operator|=
name|T_ATM_NULL
expr_stmt|;
name|spanscls_attr
operator|.
name|aal
operator|.
name|v
operator|.
name|aal4
operator|.
name|mid_low
operator|=
literal|0
expr_stmt|;
name|spanscls_attr
operator|.
name|aal
operator|.
name|v
operator|.
name|aal4
operator|.
name|mid_high
operator|=
literal|1023
expr_stmt|;
comment|/* 	 * Register our endpoint 	 */
name|err
operator|=
name|atm_endpoint_register
argument_list|(
operator|&
name|spanscls_endpt
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process module unloading notification  *   * Called whenever the spans module is about to be unloaded.  All signalling  * instances will have been previously detached.  All spanscls resources  * must be freed now.  *  * Arguments:  *	none  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|spanscls_stop
parameter_list|()
block|{
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
comment|/* 	 * Tell ARP to stop 	 */
name|spansarp_stop
argument_list|()
expr_stmt|;
comment|/* 	 * Nothing should be left here... 	 */
if|if
condition|(
name|spanscls_head
condition|)
block|{
name|panic
argument_list|(
literal|"spanscls_stop: bad state"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * De-register ourselves 	 */
operator|(
name|void
operator|)
name|atm_endpoint_deregister
argument_list|(
operator|&
name|spanscls_endpt
argument_list|)
expr_stmt|;
comment|/* 	 * Free our storage pools 	 */
name|uma_zdestroy
argument_list|(
name|spanscls_zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process signalling interface attach  *   * This function is called whenever a physical interface has been attached  * to spans.  We will open the CLS PVC and await further events.  *  * Called at splnet.  *  * Arguments:  *	spp	pointer to spans signalling protocol instance  *  * Returns:  *	0	attach successful  *	errno	attach failed - reason indicated  *  */
end_comment

begin_function
name|int
name|spanscls_attach
parameter_list|(
name|spp
parameter_list|)
name|struct
name|spans
modifier|*
name|spp
decl_stmt|;
block|{
name|struct
name|spanscls
modifier|*
name|clp
decl_stmt|;
name|Atm_addr_pvc
modifier|*
name|pvcp
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* 	 * Get a new cls control block 	 */
name|clp
operator|=
name|uma_zalloc
argument_list|(
name|spanscls_zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|clp
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* 	 * Initialize some stuff 	 */
name|clp
operator|->
name|cls_state
operator|=
name|CLS_CLOSED
expr_stmt|;
name|clp
operator|->
name|cls_spans
operator|=
name|spp
expr_stmt|;
name|spp
operator|->
name|sp_ipserv
operator|=
operator|&
name|spanscls_ipserv
expr_stmt|;
comment|/* 	 * Fill out connection attributes 	 */
name|spanscls_attr
operator|.
name|nif
operator|=
name|spp
operator|->
name|sp_pif
operator|->
name|pif_nif
expr_stmt|;
name|spanscls_attr
operator|.
name|traffic
operator|.
name|v
operator|.
name|forward
operator|.
name|PCR_all_traffic
operator|=
name|spp
operator|->
name|sp_pif
operator|->
name|pif_pcr
expr_stmt|;
name|spanscls_attr
operator|.
name|traffic
operator|.
name|v
operator|.
name|backward
operator|.
name|PCR_all_traffic
operator|=
name|spp
operator|->
name|sp_pif
operator|->
name|pif_pcr
expr_stmt|;
name|spanscls_attr
operator|.
name|called
operator|.
name|addr
operator|.
name|address_format
operator|=
name|T_ATM_PVC_ADDR
expr_stmt|;
name|spanscls_attr
operator|.
name|called
operator|.
name|addr
operator|.
name|address_length
operator|=
sizeof|sizeof
argument_list|(
name|Atm_addr_pvc
argument_list|)
expr_stmt|;
name|pvcp
operator|=
operator|(
name|Atm_addr_pvc
operator|*
operator|)
name|spanscls_attr
operator|.
name|called
operator|.
name|addr
operator|.
name|address
expr_stmt|;
name|ATM_PVC_SET_VPI
argument_list|(
name|pvcp
argument_list|,
name|SPANS_CLS_VPI
argument_list|)
expr_stmt|;
name|ATM_PVC_SET_VCI
argument_list|(
name|pvcp
argument_list|,
name|SPANS_CLS_VCI
argument_list|)
expr_stmt|;
name|spanscls_attr
operator|.
name|called
operator|.
name|subaddr
operator|.
name|address_format
operator|=
name|T_ATM_ABSENT
expr_stmt|;
name|spanscls_attr
operator|.
name|called
operator|.
name|subaddr
operator|.
name|address_length
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Create SPANS Connectionless Service (CLS) PVC 	 */
name|err
operator|=
name|atm_cm_connect
argument_list|(
operator|&
name|spanscls_endpt
argument_list|,
name|clp
argument_list|,
operator|&
name|spanscls_attr
argument_list|,
operator|&
name|clp
operator|->
name|cls_conn
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|uma_zfree
argument_list|(
name|spanscls_zone
argument_list|,
name|clp
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/* 	 * Set new state and link instance 	 */
name|clp
operator|->
name|cls_state
operator|=
name|CLS_OPEN
expr_stmt|;
name|LINK2TAIL
argument_list|(
name|clp
argument_list|,
expr|struct
name|spanscls
argument_list|,
name|spanscls_head
argument_list|,
name|cls_next
argument_list|)
expr_stmt|;
name|spp
operator|->
name|sp_cls
operator|=
name|clp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process signalling interface detach  *   * This function is called whenever a physical interface has been detached  * from spans.  We will close the CLS PVC and clean up everything.  *  * Called at splnet.  *  * Arguments:  *	spp	pointer to spans signalling protocol instance  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|spanscls_detach
parameter_list|(
name|spp
parameter_list|)
name|struct
name|spans
modifier|*
name|spp
decl_stmt|;
block|{
name|struct
name|spanscls
modifier|*
name|clp
decl_stmt|;
comment|/* 	 * Get our control block 	 */
name|clp
operator|=
name|spp
operator|->
name|sp_cls
expr_stmt|;
if|if
condition|(
name|clp
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * Just checking up on things... 	 */
if|if
condition|(
name|clp
operator|->
name|cls_ipnif
condition|)
name|panic
argument_list|(
literal|"spanscls_detach: IP interface still active"
argument_list|)
expr_stmt|;
comment|/* 	 * Close CLS PVC 	 */
name|spanscls_closevc
argument_list|(
name|clp
argument_list|,
operator|&
name|spanscls_cause
argument_list|)
expr_stmt|;
comment|/* 	 * Sever links and free server block, if possible 	 */
name|clp
operator|->
name|cls_spans
operator|=
name|NULL
expr_stmt|;
name|spp
operator|->
name|sp_cls
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|clp
operator|->
name|cls_state
operator|==
name|CLS_CLOSED
condition|)
block|{
name|UNLINK
argument_list|(
name|clp
argument_list|,
expr|struct
name|spanscls
argument_list|,
name|spanscls_head
argument_list|,
name|cls_next
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|spanscls_zone
argument_list|,
name|clp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Process IP Network Interface Activation  *   * Called whenever an IP network interface becomes active.  *  * Called at splnet.  *  * Arguments:  *	inp	pointer to IP network interface  *  * Returns:  *	0 	command successful  *	errno	command failed - reason indicated  *  */
end_comment

begin_function
specifier|static
name|int
name|spanscls_ipact
parameter_list|(
name|inp
parameter_list|)
name|struct
name|ip_nif
modifier|*
name|inp
decl_stmt|;
block|{
name|struct
name|spans
modifier|*
name|spp
decl_stmt|;
name|struct
name|spanscls
modifier|*
name|clp
decl_stmt|;
comment|/* 	 * Get corresponding cls instance 	 */
name|spp
operator|=
operator|(
expr|struct
name|spans
operator|*
operator|)
name|inp
operator|->
name|inf_nif
operator|->
name|nif_pif
operator|->
name|pif_siginst
expr_stmt|;
if|if
condition|(
operator|(
name|spp
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|clp
operator|=
name|spp
operator|->
name|sp_cls
operator|)
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* 	 * Make sure it's not already activated 	 */
if|if
condition|(
name|clp
operator|->
name|cls_ipnif
condition|)
return|return
operator|(
name|EEXIST
operator|)
return|;
comment|/* 	 * Set two-way links with IP world 	 */
name|clp
operator|->
name|cls_ipnif
operator|=
name|inp
expr_stmt|;
name|inp
operator|->
name|inf_isintf
operator|=
operator|(
name|caddr_t
operator|)
name|clp
expr_stmt|;
comment|/* 	 * Tell arp about new interface 	 */
name|spansarp_ipact
argument_list|(
name|clp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process IP Network Interface Deactivation  *   * Called whenever an IP network interface becomes inactive.  *  * Called at splnet.  *  * Arguments:  *	inp	pointer to IP network interface  *  * Returns:  *	0 	command successful  *	errno	command failed - reason indicated  *  */
end_comment

begin_function
specifier|static
name|int
name|spanscls_ipdact
parameter_list|(
name|inp
parameter_list|)
name|struct
name|ip_nif
modifier|*
name|inp
decl_stmt|;
block|{
name|struct
name|spanscls
modifier|*
name|clp
decl_stmt|;
comment|/* 	 * Get cls instance and make sure it's been activated 	 */
name|clp
operator|=
operator|(
expr|struct
name|spanscls
operator|*
operator|)
name|inp
operator|->
name|inf_isintf
expr_stmt|;
if|if
condition|(
operator|(
name|clp
operator|==
name|NULL
operator|)
operator|||
operator|(
name|clp
operator|->
name|cls_ipnif
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* 	 * Let arp know about this 	 */
name|spansarp_ipdact
argument_list|(
name|clp
argument_list|)
expr_stmt|;
comment|/* 	 * Clear IP interface pointer 	 */
name|clp
operator|->
name|cls_ipnif
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Output IP Broadcast Packet  *   * Called whenever an IP broadcast packet is sent to this interface.  *  * Arguments:  *	inp	pointer to IP network interface  *	m	pointer to packet buffer chain  *  * Returns:  *	0 	packet sent successfully  *	errno	send failed - reason indicated  *  */
end_comment

begin_function
specifier|static
name|int
name|spanscls_bcast_output
parameter_list|(
name|inp
parameter_list|,
name|m
parameter_list|)
name|struct
name|ip_nif
modifier|*
name|inp
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
block|{
name|struct
name|spans
modifier|*
name|spp
decl_stmt|;
name|struct
name|spanscls
modifier|*
name|clp
decl_stmt|;
name|struct
name|spanscls_hdr
modifier|*
name|chp
decl_stmt|;
name|int
name|err
decl_stmt|,
name|space
decl_stmt|;
comment|/* 	 * Get cls instance and make sure it's been activated 	 */
name|clp
operator|=
operator|(
expr|struct
name|spanscls
operator|*
operator|)
name|inp
operator|->
name|inf_isintf
expr_stmt|;
if|if
condition|(
operator|(
name|clp
operator|==
name|NULL
operator|)
operator|||
operator|(
name|clp
operator|->
name|cls_ipnif
operator|==
name|NULL
operator|)
condition|)
block|{
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENETDOWN
operator|)
return|;
block|}
comment|/* 	 * Make sure that we know our addresses 	 */
name|spp
operator|=
name|clp
operator|->
name|cls_spans
expr_stmt|;
if|if
condition|(
name|spp
operator|->
name|sp_addr
operator|.
name|address_format
operator|!=
name|T_ATM_SPANS_ADDR
condition|)
block|{
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENETDOWN
operator|)
return|;
block|}
comment|/* 	 * See if there's room to add CLS header to front of packet. 	 */
name|KB_HEADROOM
argument_list|(
name|m
argument_list|,
name|space
argument_list|)
expr_stmt|;
if|if
condition|(
name|space
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|spanscls_hdr
argument_list|)
condition|)
block|{
name|KBuffer
modifier|*
name|n
decl_stmt|;
comment|/* 		 * We have to allocate another buffer and tack it 		 * onto the front of the packet 		 */
name|KB_ALLOCPKT
argument_list|(
name|n
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|spanscls_hdr
argument_list|)
argument_list|,
name|KB_F_NOWAIT
argument_list|,
name|KB_T_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|KB_TAILALIGN
argument_list|(
name|n
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|spanscls_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|KB_LINKHEAD
argument_list|(
name|n
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|n
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Header fits, just adjust buffer controls 		 */
name|KB_HEADADJ
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|spanscls_hdr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now, build the CLS header 	 */
name|KB_DATASTART
argument_list|(
name|m
argument_list|,
name|chp
argument_list|,
expr|struct
name|spanscls_hdr
operator|*
argument_list|)
expr_stmt|;
name|spans_addr_copy
argument_list|(
operator|&
name|spans_bcastaddr
argument_list|,
operator|&
name|chp
operator|->
name|ch_dst
argument_list|)
expr_stmt|;
name|spans_addr_copy
argument_list|(
name|spp
operator|->
name|sp_addr
operator|.
name|address
argument_list|,
operator|&
name|chp
operator|->
name|ch_src
argument_list|)
expr_stmt|;
operator|*
operator|(
name|u_int
operator|*
operator|)
operator|&
name|chp
operator|->
name|ch_proto
operator|=
operator|*
operator|(
name|u_int
operator|*
operator|)
operator|&
name|spanscls_hdr
operator|.
name|ch_proto
expr_stmt|;
operator|*
operator|(
name|u_int
operator|*
operator|)
operator|&
name|chp
operator|->
name|ch_dsap
operator|=
operator|*
operator|(
name|u_int
operator|*
operator|)
operator|&
name|spanscls_hdr
operator|.
name|ch_dsap
expr_stmt|;
operator|*
operator|(
name|u_short
operator|*
operator|)
operator|&
name|chp
operator|->
name|ch_oui
index|[
literal|1
index|]
operator|=
operator|*
operator|(
name|u_short
operator|*
operator|)
operator|&
name|spanscls_hdr
operator|.
name|ch_oui
index|[
literal|1
index|]
expr_stmt|;
name|chp
operator|->
name|ch_pid
operator|=
name|htons
argument_list|(
name|ETHERTYPE_IP
argument_list|)
expr_stmt|;
if|if
condition|(
name|spanscls_print
condition|)
name|spanscls_pdu_print
argument_list|(
name|clp
argument_list|,
name|m
argument_list|,
literal|"output"
argument_list|)
expr_stmt|;
comment|/* 	 * Finally, send the pdu via the CLS service 	 */
name|err
operator|=
name|atm_cm_cpcs_data
argument_list|(
name|clp
operator|->
name|cls_conn
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process VCC Input Data  *   * All input packets received from CLS VCC lower layers are processed here.  *  * Arguments:  *	tok	connection token (pointer to CLS VCC control block)  *	m	pointer to input packet buffer chain  *  * Returns:  *	none  *  */
end_comment

begin_function
specifier|static
name|void
name|spanscls_cpcs_data
parameter_list|(
name|tok
parameter_list|,
name|m
parameter_list|)
name|void
modifier|*
name|tok
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
block|{
name|struct
name|spanscls
modifier|*
name|clp
init|=
name|tok
decl_stmt|;
name|struct
name|spans
modifier|*
name|spp
init|=
name|clp
operator|->
name|cls_spans
decl_stmt|;
name|struct
name|spanscls_hdr
modifier|*
name|chp
decl_stmt|;
name|struct
name|ip_nif
modifier|*
name|inp
decl_stmt|;
comment|/* 	 * Make sure we're ready 	 */
if|if
condition|(
operator|(
name|clp
operator|->
name|cls_state
operator|!=
name|CLS_OPEN
operator|)
operator|||
operator|(
name|spp
operator|->
name|sp_state
operator|!=
name|SPANS_ACTIVE
operator|)
condition|)
block|{
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|spanscls_print
condition|)
name|spanscls_pdu_print
argument_list|(
name|clp
argument_list|,
name|m
argument_list|,
literal|"input"
argument_list|)
expr_stmt|;
comment|/* 	 * Get CLS header into buffer 	 */
if|if
condition|(
name|KB_LEN
argument_list|(
name|m
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|spanscls_hdr
argument_list|)
condition|)
block|{
name|KB_PULLUP
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|spanscls_hdr
argument_list|)
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return;
block|}
name|KB_DATASTART
argument_list|(
name|m
argument_list|,
name|chp
argument_list|,
expr|struct
name|spanscls_hdr
operator|*
argument_list|)
expr_stmt|;
comment|/* 	 * Verify packet information 	 */
if|if
condition|(
operator|(
operator|*
operator|(
name|u_int
operator|*
operator|)
operator|&
name|chp
operator|->
name|ch_proto
operator|!=
operator|*
operator|(
name|u_int
operator|*
operator|)
operator|&
name|spanscls_hdr
operator|.
name|ch_proto
operator|)
operator|||
operator|(
operator|*
operator|(
name|u_int
operator|*
operator|)
operator|&
name|chp
operator|->
name|ch_dsap
operator|!=
operator|*
operator|(
name|u_int
operator|*
operator|)
operator|&
name|spanscls_hdr
operator|.
name|ch_dsap
operator|)
operator|||
operator|(
operator|*
operator|(
name|u_short
operator|*
operator|)
operator|&
name|chp
operator|->
name|ch_oui
index|[
literal|1
index|]
operator|!=
operator|*
operator|(
name|u_short
operator|*
operator|)
operator|&
name|spanscls_hdr
operator|.
name|ch_oui
index|[
literal|1
index|]
operator|)
condition|)
block|{
comment|/* 		 * Check for bridged PDU 		 */
if|if
condition|(
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|chp
operator|->
name|ch_proto
argument_list|,
operator|(
name|char
operator|*
operator|)
name|spanscls_bridged
argument_list|,
sizeof|sizeof
argument_list|(
name|spanscls_bridged
argument_list|)
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"spanscls_input: bad format\n"
argument_list|)
expr_stmt|;
name|spanscls_pdu_print
argument_list|(
name|clp
argument_list|,
name|m
argument_list|,
literal|"input error"
argument_list|)
expr_stmt|;
block|}
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Make sure packet is for us 	 */
if|if
condition|(
name|spans_addr_cmp
argument_list|(
operator|&
name|chp
operator|->
name|ch_dst
argument_list|,
name|spp
operator|->
name|sp_addr
operator|.
name|address
argument_list|)
operator|&&
name|spans_addr_cmp
argument_list|(
operator|&
name|chp
operator|->
name|ch_dst
argument_list|,
operator|&
name|spans_bcastaddr
argument_list|)
condition|)
block|{
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Do protocol processing 	 */
switch|switch
condition|(
name|ntohs
argument_list|(
name|chp
operator|->
name|ch_pid
argument_list|)
condition|)
block|{
case|case
name|ETHERTYPE_IP
case|:
comment|/* 		 * Drop CLS header 		 */
name|KB_HEADADJ
argument_list|(
name|m
argument_list|,
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|spanscls_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|KB_PLENADJ
argument_list|(
name|m
argument_list|,
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|spanscls_hdr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Packet is ready for input to IP 		 */
if|if
condition|(
operator|(
name|inp
operator|=
name|clp
operator|->
name|cls_ipnif
operator|)
operator|!=
name|NULL
condition|)
call|(
name|void
call|)
argument_list|(
operator|*
name|inp
operator|->
name|inf_ipinput
argument_list|)
argument_list|(
name|inp
argument_list|,
name|m
argument_list|)
expr_stmt|;
else|else
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
break|break;
case|case
name|ETHERTYPE_ARP
case|:
name|spansarp_input
argument_list|(
name|clp
argument_list|,
name|m
argument_list|)
expr_stmt|;
break|break;
default|default:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"spanscls_input: unknown protocol 0x%x\n"
argument_list|,
name|chp
operator|->
name|ch_pid
argument_list|)
expr_stmt|;
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/*  * Close a SPANS CLS VCC  *   * This function will close a SPANS CLS VCC.  *  * Arguments:  *	clp	pointer to CLS instance  *	cause	pointer to cause code  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|spanscls_closevc
parameter_list|(
name|clp
parameter_list|,
name|cause
parameter_list|)
name|struct
name|spanscls
modifier|*
name|clp
decl_stmt|;
name|struct
name|t_atm_cause
modifier|*
name|cause
decl_stmt|;
block|{
name|int
name|err
decl_stmt|;
comment|/* 	 * Close VCC 	 */
if|if
condition|(
name|clp
operator|->
name|cls_conn
condition|)
block|{
name|err
operator|=
name|atm_cm_release
argument_list|(
name|clp
operator|->
name|cls_conn
argument_list|,
name|cause
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"spanscls_closevc: release err=%d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
name|clp
operator|->
name|cls_conn
operator|=
name|NULL
expr_stmt|;
block|}
name|clp
operator|->
name|cls_state
operator|=
name|CLS_CLOSED
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process CLS VCC Connected Notification  *   * Arguments:  *	toku	user's connection token (spanscls protocol block)  *  * Returns:  *	none  *  */
end_comment

begin_function
specifier|static
name|void
name|spanscls_connected
parameter_list|(
name|toku
parameter_list|)
name|void
modifier|*
name|toku
decl_stmt|;
block|{
comment|/* 	 * We should never get one of these 	 */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"spanscls: unexpected connected event\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process CLS VCC Cleared Notification  *   * Arguments:  *	toku	user's connection token (spanscls protocol block)  *	cause	pointer to cause code  *  * Returns:  *	none  *  */
end_comment

begin_function
specifier|static
name|void
name|spanscls_cleared
parameter_list|(
name|toku
parameter_list|,
name|cause
parameter_list|)
name|void
modifier|*
name|toku
decl_stmt|;
name|struct
name|t_atm_cause
modifier|*
name|cause
decl_stmt|;
block|{
name|struct
name|spanscls
modifier|*
name|clp
init|=
operator|(
expr|struct
name|spanscls
operator|*
operator|)
name|toku
decl_stmt|;
comment|/* 	 * CLS VCC has been closed, so clean up our side 	 */
name|clp
operator|->
name|cls_conn
operator|=
name|NULL
expr_stmt|;
name|spanscls_closevc
argument_list|(
name|clp
argument_list|,
name|cause
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get Connection's Application/Owner Name  *   * Arguments:  *	tok	spanscls connection token  *  * Returns:  *	addr	pointer to string containing our name  *  */
end_comment

begin_function
specifier|static
name|caddr_t
name|spanscls_getname
parameter_list|(
name|tok
parameter_list|)
name|void
modifier|*
name|tok
decl_stmt|;
block|{
return|return
operator|(
literal|"SPANSCLS"
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Print a SPANS CLS PDU  *   * Arguments:  *	clp	pointer to cls instance  *	m	pointer to pdu buffer chain  *	msg	pointer to message string  *  * Returns:  *	none  *  */
end_comment

begin_function
specifier|static
name|void
name|spanscls_pdu_print
parameter_list|(
specifier|const
name|struct
name|spanscls
modifier|*
name|clp
parameter_list|,
specifier|const
name|KBuffer
modifier|*
name|m
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"spanscls %s:\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|atm_pdu_print
argument_list|(
name|m
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

