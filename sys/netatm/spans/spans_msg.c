begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ===================================  * HARP  |  Host ATM Research Platform  * ===================================  *  *  * This Host ATM Research Platform ("HARP") file (the "Software") is  * made available by Network Computing Services, Inc. ("NetworkCS")  * "AS IS".  NetworkCS does not provide maintenance, improvements or  * support of any kind.  *  * NETWORKCS MAKES NO WARRANTIES OR REPRESENTATIONS, EXPRESS OR IMPLIED,  * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE, AS TO ANY ELEMENT OF THE  * SOFTWARE OR ANY SUPPORT PROVIDED IN CONNECTION WITH THIS SOFTWARE.  * In no event shall NetworkCS be responsible for any damages, including  * but not limited to consequential damages, arising from or relating to  * any use of the Software or related support.  *  * Copyright 1994-1998 Network Computing Services, Inc.  *  * Copies of this Software may be made, however, the above copyright  * notice must be reproduced on all copies.  */
end_comment

begin_comment
comment|/*  * SPANS Signalling Manager  * ---------------------------  *  * SPANS signalling message processing.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netatm/port.h>
end_include

begin_include
include|#
directive|include
file|<netatm/queue.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sys.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sap.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_cm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_if.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_vc.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sigmgr.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_stack.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_var.h>
end_include

begin_include
include|#
directive|include
file|"spans_xdr.h"
end_include

begin_include
include|#
directive|include
file|<netatm/spans/spans_var.h>
end_include

begin_comment
comment|/*  * External functions  */
end_comment

begin_function_decl
name|void
name|xdrmbuf_init
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|KBuffer
modifier|*
parameter_list|,
name|enum
name|xdr_op
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Local functions  */
end_comment

begin_function_decl
specifier|static
name|void
name|spans_host_link
parameter_list|(
name|struct
name|spans
modifier|*
parameter_list|,
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|spans_status_ind
parameter_list|(
name|struct
name|spans
modifier|*
parameter_list|,
name|spans_msg
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|spans_status_rsp
parameter_list|(
name|struct
name|spans
modifier|*
parameter_list|,
name|spans_msg
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|spans_open_req
parameter_list|(
name|struct
name|spans
modifier|*
parameter_list|,
name|spans_msg
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|spans_open_rsp
parameter_list|(
name|struct
name|spans
modifier|*
parameter_list|,
name|spans_msg
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|spans_close_req
parameter_list|(
name|struct
name|spans
modifier|*
parameter_list|,
name|spans_msg
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|spans_close_rsp
parameter_list|(
name|struct
name|spans
modifier|*
parameter_list|,
name|spans_msg
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|spans_multi_req
parameter_list|(
name|struct
name|spans
modifier|*
parameter_list|,
name|spans_msg
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|spans_add_req
parameter_list|(
name|struct
name|spans
modifier|*
parameter_list|,
name|spans_msg
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|spans_join_req
parameter_list|(
name|struct
name|spans
modifier|*
parameter_list|,
name|spans_msg
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|spans_leave_req
parameter_list|(
name|struct
name|spans
modifier|*
parameter_list|,
name|spans_msg
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|spans_vcir_ind
parameter_list|(
name|struct
name|spans
modifier|*
parameter_list|,
name|spans_msg
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|spans_query_req
parameter_list|(
name|struct
name|spans
modifier|*
parameter_list|,
name|spans_msg
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Called to set status when a status message comes in from a host  * connected back-to-back with us.  Check the epoch and, if it has  * changed, set the appropriate state and save updated state  * information.  *  * Arguments:  *	spp		pointer to SPANS protocol instance block  *	host_epoch	epoch of host at far end of link  *  * Returns:  *	0	message sent OK  *	errno	error encountered  *  */
end_comment

begin_function
specifier|static
name|void
name|spans_host_link
parameter_list|(
name|spp
parameter_list|,
name|host_epoch
parameter_list|)
name|struct
name|spans
modifier|*
name|spp
decl_stmt|;
name|long
name|host_epoch
decl_stmt|;
block|{
name|struct
name|atm_pif
modifier|*
name|pip
init|=
name|spp
operator|->
name|sp_pif
decl_stmt|;
comment|/* 	 * There's a host at the other end of the link.  If its 	 * epoch has changed, clean up our state and save the 	 * new information. 	 */
if|if
condition|(
name|spp
operator|->
name|sp_s_epoch
operator|!=
name|host_epoch
condition|)
block|{
name|spp
operator|->
name|sp_s_epoch
operator|=
name|host_epoch
expr_stmt|;
name|spans_switch_reset
argument_list|(
name|spp
argument_list|,
name|SPANS_UNI_UP
argument_list|)
expr_stmt|;
name|spp
operator|->
name|sp_addr
operator|.
name|address_format
operator|=
name|T_ATM_SPANS_ADDR
expr_stmt|;
name|spp
operator|->
name|sp_addr
operator|.
name|address_length
operator|=
sizeof|sizeof
argument_list|(
name|spans_addr
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|pip
operator|->
name|pif_macaddr
operator|.
name|ma_data
index|[
literal|2
index|]
argument_list|,
operator|&
name|spp
operator|->
name|sp_addr
operator|.
name|address
index|[
literal|4
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"spans: using SPANS address of %s on interface %s%d\n"
argument_list|,
name|spans_addr_print
argument_list|(
operator|(
name|spans_addr
operator|*
operator|)
name|spp
operator|->
name|sp_addr
operator|.
name|address
argument_list|)
argument_list|,
name|pip
operator|->
name|pif_name
argument_list|,
name|pip
operator|->
name|pif_unit
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Send a SPANS signalling message  *  * Called to send a SPANS message.  This routine gets a buffer, performs  * XDR processing, and hands the message to the AAL for transmission.  *  * Arguments:  *	spp	pointer to SPANS protocol instance block  *	msg	pointer to status message  *  * Returns:  *	0	message sent OK  *	errno	error encountered  *  */
end_comment

begin_function
name|int
name|spans_send_msg
parameter_list|(
name|spp
parameter_list|,
name|msg
parameter_list|)
name|struct
name|spans
modifier|*
name|spp
decl_stmt|;
name|spans_msg
modifier|*
name|msg
decl_stmt|;
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|XDR
name|xdrs
decl_stmt|;
ifdef|#
directive|ifdef
name|NOTDEF
name|ATM_DEBUG2
argument_list|(
literal|"spans_send_msg: msg=%p, type=%d\n"
argument_list|,
name|msg
argument_list|,
name|msg
operator|->
name|sm_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|sm_type
operator|!=
name|SPANS_STAT_REQ
operator|&&
name|msg
operator|->
name|sm_type
operator|!=
name|SPANS_STAT_IND
operator|&&
name|msg
operator|->
name|sm_type
operator|!=
name|SPANS_STAT_RSP
condition|)
block|{
name|printf
argument_list|(
literal|"spans_send_msg: sending "
argument_list|)
expr_stmt|;
name|spans_print_msg
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * If the signalling channel has been closed, don't do anything 	 */
if|if
condition|(
operator|!
name|spp
operator|->
name|sp_conn
condition|)
return|return
operator|(
name|ECONNABORTED
operator|)
return|;
comment|/* 	 * Get a buffer 	 */
name|KB_ALLOCPKT
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
name|spans_msg
argument_list|)
argument_list|,
name|KB_F_NOWAIT
argument_list|,
name|KB_T_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* No buffer available */
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
comment|/* 	 * Convert message to network order 	 */
name|KB_LEN
argument_list|(
name|m
argument_list|)
operator|=
name|KB_BFRLEN
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|xdrmbuf_init
argument_list|(
operator|&
name|xdrs
argument_list|,
name|m
argument_list|,
name|XDR_ENCODE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xdr_spans_msg
argument_list|(
operator|&
name|xdrs
argument_list|,
name|msg
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"spans_send_msg: XDR encode failed\n"
argument_list|)
expr_stmt|;
name|KB_LEN
argument_list|(
name|m
argument_list|)
operator|=
name|XDR_GETPOS
argument_list|(
operator|&
name|xdrs
argument_list|)
expr_stmt|;
name|spans_dump_buffer
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|KB_LEN
argument_list|(
name|m
argument_list|)
operator|=
name|XDR_GETPOS
argument_list|(
operator|&
name|xdrs
argument_list|)
expr_stmt|;
comment|/* 	 * Send the message 	 */
name|err
operator|=
name|atm_cm_cpcs_data
argument_list|(
name|spp
operator|->
name|sp_conn
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send an open request  *  * Build and send an open request.  *  * Arguments:  *	spp	pointer to SPANS protocol instance block  *	svp	pointer to VCCB for which the request is being sent  *  * Returns:  *	none  *  */
end_comment

begin_function
name|int
name|spans_send_open_req
parameter_list|(
name|spp
parameter_list|,
name|svp
parameter_list|)
name|struct
name|spans
modifier|*
name|spp
decl_stmt|;
name|struct
name|spans_vccb
modifier|*
name|svp
decl_stmt|;
block|{
name|spans_msg
modifier|*
name|req
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|ATM_DEBUG1
argument_list|(
literal|"spans_send_open_req: svp=%p\n"
argument_list|,
name|svp
argument_list|)
expr_stmt|;
comment|/* 	 * Get memory for a request message 	 */
name|req
operator|=
name|uma_zalloc
argument_list|(
name|spans_msg_zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Fill in the request 	 */
name|req
operator|->
name|sm_vers
operator|=
name|SPANS_VERS_1_0
expr_stmt|;
name|req
operator|->
name|sm_type
operator|=
name|SPANS_OPEN_REQ
expr_stmt|;
name|req
operator|->
name|sm_open_req
operator|.
name|opreq_conn
operator|=
name|svp
operator|->
name|sv_conn
expr_stmt|;
name|req
operator|->
name|sm_open_req
operator|.
name|opreq_aal
operator|=
name|svp
operator|->
name|sv_spans_aal
expr_stmt|;
name|req
operator|->
name|sm_open_req
operator|.
name|opreq_desrsrc
operator|=
name|svp
operator|->
name|sv_spans_qos
expr_stmt|;
name|req
operator|->
name|sm_open_req
operator|.
name|opreq_minrsrc
operator|.
name|rsc_peak
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|sm_open_req
operator|.
name|opreq_minrsrc
operator|.
name|rsc_mean
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|sm_open_req
operator|.
name|opreq_minrsrc
operator|.
name|rsc_burst
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|sm_open_req
operator|.
name|opreq_vpvc
operator|.
name|vpf_valid
operator|=
name|FALSE
expr_stmt|;
comment|/* 	 * Send the request 	 */
name|err
operator|=
name|spans_send_msg
argument_list|(
name|spp
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|spans_msg_zone
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|done
label|:
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send an open response  *  * Build and send a response to an open request or open indication.  *  * Arguments:  *	spp	pointer to SPANS protocol instance block  *	svp	pointer to VCCB for which the response is being sent  *	result	result code to include in the response  *  * Returns:  *	none  *  */
end_comment

begin_function
name|int
name|spans_send_open_rsp
parameter_list|(
name|spp
parameter_list|,
name|svp
parameter_list|,
name|result
parameter_list|)
name|struct
name|spans
modifier|*
name|spp
decl_stmt|;
name|struct
name|spans_vccb
modifier|*
name|svp
decl_stmt|;
name|spans_result
name|result
decl_stmt|;
block|{
name|spans_msg
modifier|*
name|rsp
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|ATM_DEBUG2
argument_list|(
literal|"spans_send_open_rsp: svp=%p, result=%d\n"
argument_list|,
name|svp
argument_list|,
name|result
argument_list|)
expr_stmt|;
comment|/* 	 * Get memory for a response message 	 */
name|rsp
operator|=
name|uma_zalloc
argument_list|(
name|spans_msg_zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsp
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
comment|/* 	 * Fill in the response 	 */
name|rsp
operator|->
name|sm_vers
operator|=
name|SPANS_VERS_1_0
expr_stmt|;
name|rsp
operator|->
name|sm_type
operator|=
name|SPANS_OPEN_RSP
expr_stmt|;
name|rsp
operator|->
name|sm_open_rsp
operator|.
name|oprsp_conn
operator|=
name|svp
operator|->
name|sv_conn
expr_stmt|;
name|rsp
operator|->
name|sm_open_rsp
operator|.
name|oprsp_result
operator|=
name|result
expr_stmt|;
name|rsp
operator|->
name|sm_open_rsp
operator|.
name|oprsp_rsrc
operator|=
name|svp
operator|->
name|sv_spans_qos
expr_stmt|;
name|rsp
operator|->
name|sm_open_rsp
operator|.
name|oprsp_vpvc
operator|=
name|SPANS_PACK_VPIVCI
argument_list|(
name|svp
operator|->
name|sv_vpi
argument_list|,
name|svp
operator|->
name|sv_vci
argument_list|)
expr_stmt|;
comment|/* 	 * Send the response 	 */
name|rc
operator|=
name|spans_send_msg
argument_list|(
name|spp
argument_list|,
name|rsp
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|spans_msg_zone
argument_list|,
name|rsp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send a close request  *  * Called to send a close request.  *  * Arguments:  *	spp	pointer to SPANS protocol instance block  *	svp	pointer to VCCB for which the close is being sent  *  * Returns:  *	none  *  */
end_comment

begin_function
name|int
name|spans_send_close_req
parameter_list|(
name|spp
parameter_list|,
name|svp
parameter_list|)
name|struct
name|spans
modifier|*
name|spp
decl_stmt|;
name|struct
name|spans_vccb
modifier|*
name|svp
decl_stmt|;
block|{
name|spans_msg
modifier|*
name|req
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|ATM_DEBUG1
argument_list|(
literal|"spans_send_close_req: svp=%p\n"
argument_list|,
name|svp
argument_list|)
expr_stmt|;
comment|/* 	 * Get memory for a close request 	 */
name|req
operator|=
name|uma_zalloc
argument_list|(
name|spans_msg_zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Fill in the request 	 */
name|req
operator|->
name|sm_vers
operator|=
name|SPANS_VERS_1_0
expr_stmt|;
if|if
condition|(
name|svp
operator|->
name|sv_type
operator|&
name|VCC_OUT
condition|)
block|{
name|req
operator|->
name|sm_type
operator|=
name|SPANS_CLOSE_REQ
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|svp
operator|->
name|sv_type
operator|&
name|VCC_IN
condition|)
block|{
name|req
operator|->
name|sm_type
operator|=
name|SPANS_RCLOSE_REQ
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
name|ATM_DEBUG1
argument_list|(
literal|"spans_send_close_req: invalid VCCB type 0x%x\n"
argument_list|,
name|svp
operator|->
name|sv_type
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|req
operator|->
name|sm_close_req
operator|.
name|clreq_conn
operator|=
name|svp
operator|->
name|sv_conn
expr_stmt|;
comment|/* 	 * Send the close request 	 */
name|err
operator|=
name|spans_send_msg
argument_list|(
name|spp
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|req
condition|)
name|uma_zfree
argument_list|(
name|spans_msg_zone
argument_list|,
name|req
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process a status indication or status request  *  * Called when a status indication or status request is received.  * Processing will be based on the current SPANS state.  *  * Arguments:  *	spp	pointer to SPANS protocol instance block  *	msg	pointer to the status message  *  * Returns:  *	none  *  */
end_comment

begin_function
specifier|static
name|void
name|spans_status_ind
parameter_list|(
name|spp
parameter_list|,
name|msg
parameter_list|)
name|struct
name|spans
modifier|*
name|spp
decl_stmt|;
name|spans_msg
modifier|*
name|msg
decl_stmt|;
block|{
name|spans_msg
modifier|*
name|rsp_msg
decl_stmt|;
name|struct
name|atm_pif
modifier|*
name|pip
init|=
name|spp
operator|->
name|sp_pif
decl_stmt|;
comment|/* 	 * Reset the probe count. 	 */
name|spp
operator|->
name|sp_probe_ct
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|spp
operator|->
name|sp_state
condition|)
block|{
case|case
name|SPANS_PROBE
case|:
comment|/* 		 * Interface just came up, update signalling state 		 */
name|spp
operator|->
name|sp_state
operator|=
name|SPANS_ACTIVE
expr_stmt|;
break|break;
case|case
name|SPANS_ACTIVE
case|:
break|break;
default|default:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"spans: received status msg in state %d\n"
argument_list|,
name|spp
operator|->
name|sp_state
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Process the message 	 */
switch|switch
condition|(
name|msg
operator|->
name|sm_type
condition|)
block|{
case|case
name|SPANS_STAT_REQ
case|:
comment|/* 		 * Handle a request from a host at the other end of 		 * the link. 		 */
name|spans_host_link
argument_list|(
name|spp
argument_list|,
name|msg
operator|->
name|sm_stat_req
operator|.
name|streq_es_epoch
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPANS_STAT_IND
case|:
comment|/* 		 * There's a switch at the other end of the link.  If 		 * its epoch has changed, reset the SPANS state and save 		 * the new information. 		 */
if|if
condition|(
name|spp
operator|->
name|sp_s_epoch
operator|!=
name|msg
operator|->
name|sm_stat_ind
operator|.
name|stind_sw_epoch
condition|)
block|{
name|spans_switch_reset
argument_list|(
name|spp
argument_list|,
name|SPANS_UNI_UP
argument_list|)
expr_stmt|;
name|spp
operator|->
name|sp_s_epoch
operator|=
name|msg
operator|->
name|sm_stat_ind
operator|.
name|stind_sw_epoch
expr_stmt|;
name|spp
operator|->
name|sp_addr
operator|.
name|address_format
operator|=
name|T_ATM_SPANS_ADDR
expr_stmt|;
name|spp
operator|->
name|sp_addr
operator|.
name|address_length
operator|=
sizeof|sizeof
argument_list|(
name|spans_addr
argument_list|)
expr_stmt|;
name|spans_addr_copy
argument_list|(
operator|&
name|msg
operator|->
name|sm_stat_ind
operator|.
name|stind_es_addr
argument_list|,
name|spp
operator|->
name|sp_addr
operator|.
name|address
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"spans: received SPANS address %s from switch for interface %s%d\n"
argument_list|,
name|spans_addr_print
argument_list|(
operator|(
name|spans_addr
operator|*
operator|)
name|spp
operator|->
name|sp_addr
operator|.
name|address
argument_list|)
argument_list|,
name|pip
operator|->
name|pif_name
argument_list|,
name|pip
operator|->
name|pif_unit
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|ATM_DEBUG1
argument_list|(
literal|"spans_status_ind: Invalid message type %d\n"
argument_list|,
name|msg
operator|->
name|sm_type
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Respond to the status request or indication with a 	 * status response 	 */
name|rsp_msg
operator|=
name|uma_zalloc
argument_list|(
name|spans_msg_zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsp_msg
operator|==
name|NULL
condition|)
return|return;
name|rsp_msg
operator|->
name|sm_vers
operator|=
name|SPANS_VERS_1_0
expr_stmt|;
name|rsp_msg
operator|->
name|sm_type
operator|=
name|SPANS_STAT_RSP
expr_stmt|;
name|rsp_msg
operator|->
name|sm_stat_rsp
operator|.
name|strsp_es_epoch
operator|=
name|spp
operator|->
name|sp_h_epoch
expr_stmt|;
name|spans_addr_copy
argument_list|(
name|spp
operator|->
name|sp_addr
operator|.
name|address
argument_list|,
operator|&
name|rsp_msg
operator|->
name|sm_stat_rsp
operator|.
name|strsp_es_addr
argument_list|)
expr_stmt|;
name|spans_send_msg
argument_list|(
name|spp
argument_list|,
name|rsp_msg
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|spans_msg_zone
argument_list|,
name|rsp_msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process a status response  *  * Called when a status response is received.  * Processing will be based on the current SPANS state.  *  * Arguments:  *	spp	pointer to SPANS protocol instance block  *	msg	pointer to the status response message  *  * Returns:  *	none  *  */
end_comment

begin_function
specifier|static
name|void
name|spans_status_rsp
parameter_list|(
name|spp
parameter_list|,
name|msg
parameter_list|)
name|struct
name|spans
modifier|*
name|spp
decl_stmt|;
name|spans_msg
modifier|*
name|msg
decl_stmt|;
block|{
comment|/* 	 * Reset the probe count. 	 */
name|spp
operator|->
name|sp_probe_ct
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|spp
operator|->
name|sp_state
condition|)
block|{
case|case
name|SPANS_PROBE
case|:
comment|/* 		 * Interface just came up, update signalling state 		 */
name|spp
operator|->
name|sp_state
operator|=
name|SPANS_ACTIVE
expr_stmt|;
break|break;
case|case
name|SPANS_ACTIVE
case|:
break|break;
default|default:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"spans: received status msg in state %d\n"
argument_list|,
name|spp
operator|->
name|sp_state
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Process the message 	 */
name|spans_host_link
argument_list|(
name|spp
argument_list|,
name|msg
operator|->
name|sm_stat_req
operator|.
name|streq_es_epoch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process an open indication or open request  *  * Called when an open indication or open request is received.  * Processing will be based on the state of the requested connection.  *  * Arguments:  *	spp	pointer to SPANS protocol instance block  *	msg	pointer to the open message  *  * Returns:  *	none  *  */
end_comment

begin_function
specifier|static
name|void
name|spans_open_req
parameter_list|(
name|spp
parameter_list|,
name|msg
parameter_list|)
name|struct
name|spans
modifier|*
name|spp
decl_stmt|;
name|spans_msg
modifier|*
name|msg
decl_stmt|;
block|{
name|spans_result
name|result
init|=
name|SPANS_OK
decl_stmt|;
name|spans_msg
modifier|*
name|rsp_msg
decl_stmt|;
name|struct
name|spans_vccb
modifier|*
name|svp
init|=
name|NULL
decl_stmt|;
name|struct
name|atm_pif
modifier|*
name|pip
decl_stmt|;
name|spans_vpvc
name|vpvc
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|,
name|vpi
decl_stmt|,
name|vci
decl_stmt|;
name|Aal_t
name|aal
decl_stmt|;
name|Atm_attributes
name|call_attrs
decl_stmt|;
name|ATM_DEBUG2
argument_list|(
literal|"spans_open_req: spp=%p, msg=%p\n"
argument_list|,
name|spp
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|/* 	 * See if the connection is new 	 */
if|if
condition|(
operator|(
name|svp
operator|=
name|spans_find_conn
argument_list|(
name|spp
argument_list|,
operator|&
name|msg
operator|->
name|sm_open_req
operator|.
name|opreq_conn
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * We already have a VCCB that matches the connection in 		 * the request 		 */
name|vpi
operator|=
name|SPANS_EXTRACT_VPI
argument_list|(
name|msg
operator|->
name|sm_open_req
operator|.
name|opreq_vpvc
operator|.
name|vpf_vpvc
argument_list|)
expr_stmt|;
name|vci
operator|=
name|SPANS_EXTRACT_VCI
argument_list|(
name|msg
operator|->
name|sm_open_req
operator|.
name|opreq_vpvc
operator|.
name|vpf_vpvc
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|sm_open_req
operator|.
name|opreq_aal
operator|==
name|svp
operator|->
name|sv_spans_aal
operator|&&
operator|(
operator|!
name|msg
operator|->
name|sm_open_req
operator|.
name|opreq_vpvc
operator|.
name|vpf_valid
operator|||
operator|(
name|vpi
operator|==
name|svp
operator|->
name|sv_vpi
operator|&&
name|vci
operator|==
name|svp
operator|->
name|sv_vci
operator|)
operator|)
condition|)
block|{
comment|/* 			 * VCCB already exists, process depending on 			 * state 			 */
switch|switch
condition|(
name|svp
operator|->
name|sv_sstate
condition|)
block|{
case|case
name|SPANS_VC_R_POPEN
case|:
comment|/* I'm still thinking about it */
return|return;
case|case
name|SPANS_VC_OPEN
case|:
comment|/* Retransmit the open_rsp */
break|break;
case|case
name|SPANS_VC_POPEN
case|:
case|case
name|SPANS_VC_CLOSE
case|:
case|case
name|SPANS_VC_ABORT
case|:
name|ATM_DEBUG0
argument_list|(
literal|"spans_open_req: bad VCCB state\n"
argument_list|)
expr_stmt|;
name|result
operator|=
name|SPANS_FAIL
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* 			 * VCCB is for same connection, but other 			 * parameters don't match 			 */
name|ATM_DEBUG0
argument_list|(
literal|"spans_open_req: VCCB confusion\n"
argument_list|)
expr_stmt|;
name|result
operator|=
name|SPANS_FAIL
expr_stmt|;
block|}
name|svp
operator|=
name|NULL
expr_stmt|;
goto|goto
name|response
goto|;
block|}
comment|/* 	 * Verify that the request is for our ATM addres 	 */
if|if
condition|(
name|spans_addr_cmp
argument_list|(
name|spp
operator|->
name|sp_addr
operator|.
name|address
argument_list|,
operator|&
name|msg
operator|->
name|sm_open_req
operator|.
name|opreq_conn
operator|.
name|con_dst
argument_list|)
condition|)
block|{
name|ATM_DEBUG0
argument_list|(
literal|"spans_open_req: bad destination\n"
argument_list|)
expr_stmt|;
name|result
operator|=
name|SPANS_BADDEST
expr_stmt|;
goto|goto
name|response
goto|;
block|}
comment|/* 	 * See if we recognize the specified AAL 	 */
if|if
condition|(
operator|!
name|spans_get_local_aal
argument_list|(
name|msg
operator|->
name|sm_open_req
operator|.
name|opreq_aal
argument_list|,
operator|&
name|aal
argument_list|)
condition|)
block|{
name|ATM_DEBUG0
argument_list|(
literal|"spans_open_req: bad AAL\n"
argument_list|)
expr_stmt|;
name|result
operator|=
name|SPANS_FAIL
expr_stmt|;
goto|goto
name|response
goto|;
block|}
comment|/* 	 * Should verify that we can handle requested connection QOS 	 */
comment|/* 	 * Select a VPI/VCI for the new connection 	 */
if|if
condition|(
name|msg
operator|->
name|sm_open_req
operator|.
name|opreq_vpvc
operator|.
name|vpf_valid
condition|)
block|{
comment|/* 		 * Requestor asked for a certain VPI/VCI.  Make sure we 		 * aren't already using the pair that was asked for. 		 */
name|vpi
operator|=
name|SPANS_EXTRACT_VPI
argument_list|(
name|msg
operator|->
name|sm_open_req
operator|.
name|opreq_vpvc
operator|.
name|vpf_vpvc
argument_list|)
expr_stmt|;
name|vci
operator|=
name|SPANS_EXTRACT_VCI
argument_list|(
name|msg
operator|->
name|sm_open_req
operator|.
name|opreq_vpvc
operator|.
name|vpf_vpvc
argument_list|)
expr_stmt|;
if|if
condition|(
name|spans_find_vpvc
argument_list|(
name|spp
argument_list|,
name|vci
argument_list|,
name|vpi
argument_list|,
name|VCC_IN
argument_list|)
condition|)
block|{
name|ATM_DEBUG0
argument_list|(
literal|"spans_open_req: VPI, VCI busy\n"
argument_list|)
expr_stmt|;
name|result
operator|=
name|SPANS_NOVPVC
expr_stmt|;
goto|goto
name|response
goto|;
block|}
name|vpvc
operator|=
name|msg
operator|->
name|sm_open_req
operator|.
name|opreq_vpvc
operator|.
name|vpf_vpvc
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Allocate a VPI/VCI for this end of the VCC 		 */
name|vpvc
operator|=
name|spans_alloc_vpvc
argument_list|(
name|spp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vpvc
operator|==
literal|0
condition|)
block|{
name|ATM_DEBUG0
argument_list|(
literal|"spans_open_req: no VPI, VCI available\n"
argument_list|)
expr_stmt|;
name|result
operator|=
name|SPANS_NOVPVC
expr_stmt|;
goto|goto
name|response
goto|;
block|}
block|}
comment|/* 	 * Get a new VCCB for the connection 	 */
name|svp
operator|=
name|uma_zalloc
argument_list|(
name|spans_vc_zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|svp
operator|==
name|NULL
condition|)
block|{
name|ATM_DEBUG0
argument_list|(
literal|"spans_open_req: VCCB pool empty\n"
argument_list|)
expr_stmt|;
name|result
operator|=
name|SPANS_NORSC
expr_stmt|;
goto|goto
name|response
goto|;
block|}
comment|/* 	 * Find the physical interface structure 	 */
name|pip
operator|=
name|spp
operator|->
name|sp_pif
expr_stmt|;
comment|/* 	 * Fill in the VCCB fields that we can at this point 	 */
name|svp
operator|->
name|sv_type
operator|=
name|VCC_SVC
operator||
name|VCC_IN
expr_stmt|;
name|svp
operator|->
name|sv_proto
operator|=
name|ATM_SIG_SPANS
expr_stmt|;
name|svp
operator|->
name|sv_sstate
operator|=
name|SPANS_VC_R_POPEN
expr_stmt|;
name|svp
operator|->
name|sv_ustate
operator|=
name|VCCU_POPEN
expr_stmt|;
name|svp
operator|->
name|sv_pif
operator|=
name|pip
expr_stmt|;
name|svp
operator|->
name|sv_nif
operator|=
name|pip
operator|->
name|pif_nif
expr_stmt|;
name|svp
operator|->
name|sv_conn
operator|=
name|msg
operator|->
name|sm_open_req
operator|.
name|opreq_conn
expr_stmt|;
name|svp
operator|->
name|sv_spans_qos
operator|=
name|msg
operator|->
name|sm_open_req
operator|.
name|opreq_desrsrc
expr_stmt|;
name|svp
operator|->
name|sv_spans_aal
operator|=
name|msg
operator|->
name|sm_open_req
operator|.
name|opreq_aal
expr_stmt|;
name|svp
operator|->
name|sv_tstamp
operator|=
name|time_second
expr_stmt|;
name|svp
operator|->
name|sv_vpi
operator|=
name|SPANS_EXTRACT_VPI
argument_list|(
name|vpvc
argument_list|)
expr_stmt|;
name|svp
operator|->
name|sv_vci
operator|=
name|SPANS_EXTRACT_VCI
argument_list|(
name|vpvc
argument_list|)
expr_stmt|;
comment|/* 	 * Put the VCCB on the SPANS queue 	 */
name|ENQUEUE
argument_list|(
name|svp
argument_list|,
expr|struct
name|spans_vccb
argument_list|,
name|sv_sigelem
argument_list|,
name|spp
operator|->
name|sp_vccq
argument_list|)
expr_stmt|;
comment|/* 	 * Set up the ATM attributes block 	 */
name|bzero
argument_list|(
operator|&
name|call_attrs
argument_list|,
sizeof|sizeof
argument_list|(
name|call_attrs
argument_list|)
argument_list|)
expr_stmt|;
name|call_attrs
operator|.
name|nif
operator|=
name|svp
operator|->
name|sv_nif
expr_stmt|;
name|call_attrs
operator|.
name|api
operator|=
name|CMAPI_CPCS
expr_stmt|;
name|call_attrs
operator|.
name|aal
operator|.
name|tag
operator|=
name|T_ATM_PRESENT
expr_stmt|;
name|call_attrs
operator|.
name|aal
operator|.
name|type
operator|=
name|aal
expr_stmt|;
switch|switch
condition|(
name|aal
condition|)
block|{
case|case
name|ATM_AAL3_4
case|:
name|call_attrs
operator|.
name|aal
operator|.
name|v
operator|.
name|aal4
operator|.
name|forward_max_SDU_size
operator|=
name|ATM_NIF_MTU
expr_stmt|;
name|call_attrs
operator|.
name|aal
operator|.
name|v
operator|.
name|aal4
operator|.
name|backward_max_SDU_size
operator|=
name|ATM_NIF_MTU
expr_stmt|;
name|call_attrs
operator|.
name|aal
operator|.
name|v
operator|.
name|aal4
operator|.
name|SSCS_type
operator|=
name|T_ATM_NULL
expr_stmt|;
name|call_attrs
operator|.
name|aal
operator|.
name|v
operator|.
name|aal4
operator|.
name|mid_low
operator|=
literal|0
expr_stmt|;
name|call_attrs
operator|.
name|aal
operator|.
name|v
operator|.
name|aal4
operator|.
name|mid_high
operator|=
literal|1023
expr_stmt|;
break|break;
case|case
name|ATM_AAL5
case|:
name|call_attrs
operator|.
name|aal
operator|.
name|v
operator|.
name|aal5
operator|.
name|forward_max_SDU_size
operator|=
name|ATM_NIF_MTU
expr_stmt|;
name|call_attrs
operator|.
name|aal
operator|.
name|v
operator|.
name|aal5
operator|.
name|backward_max_SDU_size
operator|=
name|ATM_NIF_MTU
expr_stmt|;
name|call_attrs
operator|.
name|aal
operator|.
name|v
operator|.
name|aal5
operator|.
name|SSCS_type
operator|=
name|T_ATM_NULL
expr_stmt|;
break|break;
block|}
name|call_attrs
operator|.
name|traffic
operator|.
name|tag
operator|=
name|T_ATM_PRESENT
expr_stmt|;
name|call_attrs
operator|.
name|traffic
operator|.
name|v
operator|.
name|forward
operator|.
name|PCR_high_priority
operator|=
name|T_ATM_ABSENT
expr_stmt|;
name|call_attrs
operator|.
name|traffic
operator|.
name|v
operator|.
name|forward
operator|.
name|PCR_all_traffic
operator|=
name|msg
operator|->
name|sm_open_req
operator|.
name|opreq_desrsrc
operator|.
name|rsc_peak
operator|*
literal|1000
operator|/
literal|53
expr_stmt|;
name|call_attrs
operator|.
name|traffic
operator|.
name|v
operator|.
name|forward
operator|.
name|SCR_high_priority
operator|=
name|T_ATM_ABSENT
expr_stmt|;
name|call_attrs
operator|.
name|traffic
operator|.
name|v
operator|.
name|forward
operator|.
name|SCR_all_traffic
operator|=
name|T_ATM_ABSENT
expr_stmt|;
name|call_attrs
operator|.
name|traffic
operator|.
name|v
operator|.
name|forward
operator|.
name|MBS_high_priority
operator|=
name|T_ATM_ABSENT
expr_stmt|;
name|call_attrs
operator|.
name|traffic
operator|.
name|v
operator|.
name|forward
operator|.
name|MBS_all_traffic
operator|=
name|T_ATM_ABSENT
expr_stmt|;
name|call_attrs
operator|.
name|traffic
operator|.
name|v
operator|.
name|forward
operator|.
name|tagging
operator|=
name|T_NO
expr_stmt|;
name|call_attrs
operator|.
name|traffic
operator|.
name|v
operator|.
name|backward
operator|.
name|PCR_high_priority
operator|=
name|T_ATM_ABSENT
expr_stmt|;
name|call_attrs
operator|.
name|traffic
operator|.
name|v
operator|.
name|backward
operator|.
name|PCR_all_traffic
operator|=
name|call_attrs
operator|.
name|traffic
operator|.
name|v
operator|.
name|forward
operator|.
name|PCR_all_traffic
expr_stmt|;
name|call_attrs
operator|.
name|traffic
operator|.
name|v
operator|.
name|backward
operator|.
name|SCR_high_priority
operator|=
name|T_ATM_ABSENT
expr_stmt|;
name|call_attrs
operator|.
name|traffic
operator|.
name|v
operator|.
name|backward
operator|.
name|SCR_all_traffic
operator|=
name|T_ATM_ABSENT
expr_stmt|;
name|call_attrs
operator|.
name|traffic
operator|.
name|v
operator|.
name|backward
operator|.
name|MBS_high_priority
operator|=
name|T_ATM_ABSENT
expr_stmt|;
name|call_attrs
operator|.
name|traffic
operator|.
name|v
operator|.
name|backward
operator|.
name|MBS_all_traffic
operator|=
name|T_ATM_ABSENT
expr_stmt|;
name|call_attrs
operator|.
name|traffic
operator|.
name|v
operator|.
name|backward
operator|.
name|tagging
operator|=
name|T_NO
expr_stmt|;
name|call_attrs
operator|.
name|traffic
operator|.
name|v
operator|.
name|best_effort
operator|=
name|T_YES
expr_stmt|;
name|call_attrs
operator|.
name|bearer
operator|.
name|tag
operator|=
name|T_ATM_PRESENT
expr_stmt|;
name|call_attrs
operator|.
name|bearer
operator|.
name|v
operator|.
name|bearer_class
operator|=
name|T_ATM_CLASS_X
expr_stmt|;
name|call_attrs
operator|.
name|bearer
operator|.
name|v
operator|.
name|traffic_type
operator|=
name|T_ATM_NULL
expr_stmt|;
name|call_attrs
operator|.
name|bearer
operator|.
name|v
operator|.
name|timing_requirements
operator|=
name|T_ATM_NULL
expr_stmt|;
name|call_attrs
operator|.
name|bearer
operator|.
name|v
operator|.
name|clipping_susceptibility
operator|=
name|T_NO
expr_stmt|;
name|call_attrs
operator|.
name|bearer
operator|.
name|v
operator|.
name|connection_configuration
operator|=
name|T_ATM_1_TO_1
expr_stmt|;
name|call_attrs
operator|.
name|bhli
operator|.
name|tag
operator|=
name|T_ATM_ABSENT
expr_stmt|;
name|call_attrs
operator|.
name|blli
operator|.
name|tag_l2
operator|=
name|T_ATM_ABSENT
expr_stmt|;
name|call_attrs
operator|.
name|blli
operator|.
name|tag_l3
operator|=
name|T_ATM_ABSENT
expr_stmt|;
name|call_attrs
operator|.
name|llc
operator|.
name|tag
operator|=
name|T_ATM_ABSENT
expr_stmt|;
name|call_attrs
operator|.
name|called
operator|.
name|tag
operator|=
name|T_ATM_PRESENT
expr_stmt|;
name|spans_addr_copy
argument_list|(
operator|&
name|msg
operator|->
name|sm_open_req
operator|.
name|opreq_conn
operator|.
name|con_dst
argument_list|,
name|call_attrs
operator|.
name|called
operator|.
name|addr
operator|.
name|address
argument_list|)
expr_stmt|;
name|call_attrs
operator|.
name|called
operator|.
name|addr
operator|.
name|address_format
operator|=
name|T_ATM_SPANS_ADDR
expr_stmt|;
name|call_attrs
operator|.
name|called
operator|.
name|addr
operator|.
name|address_length
operator|=
sizeof|sizeof
argument_list|(
name|spans_addr
argument_list|)
expr_stmt|;
name|call_attrs
operator|.
name|called
operator|.
name|subaddr
operator|.
name|address_format
operator|=
name|T_ATM_ABSENT
expr_stmt|;
name|call_attrs
operator|.
name|called
operator|.
name|subaddr
operator|.
name|address_length
operator|=
literal|0
expr_stmt|;
name|call_attrs
operator|.
name|calling
operator|.
name|tag
operator|=
name|T_ATM_PRESENT
expr_stmt|;
name|spans_addr_copy
argument_list|(
operator|&
name|msg
operator|->
name|sm_open_req
operator|.
name|opreq_conn
operator|.
name|con_src
argument_list|,
name|call_attrs
operator|.
name|calling
operator|.
name|addr
operator|.
name|address
argument_list|)
expr_stmt|;
name|call_attrs
operator|.
name|calling
operator|.
name|addr
operator|.
name|address_format
operator|=
name|T_ATM_SPANS_ADDR
expr_stmt|;
name|call_attrs
operator|.
name|calling
operator|.
name|addr
operator|.
name|address_length
operator|=
sizeof|sizeof
argument_list|(
name|spans_addr
argument_list|)
expr_stmt|;
name|call_attrs
operator|.
name|calling
operator|.
name|subaddr
operator|.
name|address_format
operator|=
name|T_ATM_ABSENT
expr_stmt|;
name|call_attrs
operator|.
name|calling
operator|.
name|subaddr
operator|.
name|address_length
operator|=
literal|0
expr_stmt|;
name|call_attrs
operator|.
name|qos
operator|.
name|tag
operator|=
name|T_ATM_PRESENT
expr_stmt|;
name|call_attrs
operator|.
name|qos
operator|.
name|v
operator|.
name|coding_standard
operator|=
name|T_ATM_NETWORK_CODING
expr_stmt|;
name|call_attrs
operator|.
name|qos
operator|.
name|v
operator|.
name|forward
operator|.
name|qos_class
operator|=
name|T_ATM_QOS_CLASS_0
expr_stmt|;
name|call_attrs
operator|.
name|qos
operator|.
name|v
operator|.
name|backward
operator|.
name|qos_class
operator|=
name|T_ATM_QOS_CLASS_0
expr_stmt|;
name|call_attrs
operator|.
name|transit
operator|.
name|tag
operator|=
name|T_ATM_ABSENT
expr_stmt|;
name|call_attrs
operator|.
name|cause
operator|.
name|tag
operator|=
name|T_ATM_ABSENT
expr_stmt|;
comment|/* 	 * Notify the connection manager that it has a new channel 	 */
name|err
operator|=
name|atm_cm_incoming
argument_list|(
operator|(
expr|struct
name|vccb
operator|*
operator|)
name|svp
argument_list|,
operator|&
name|call_attrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|ATM_DEBUG0
argument_list|(
literal|"spans_open_req: atm_cm_incoming returned error\n"
argument_list|)
expr_stmt|;
name|result
operator|=
name|SPANS_FAIL
expr_stmt|;
goto|goto
name|response
goto|;
block|}
comment|/* 	 * Wait for the connection recipient to issue an accept 	 */
return|return;
name|response
label|:
comment|/* 	 * Clean up the VCCB and the atm_conn block if we got them 	 */
if|if
condition|(
name|svp
condition|)
block|{
name|DEQUEUE
argument_list|(
name|svp
argument_list|,
expr|struct
name|spans_vccb
argument_list|,
name|sv_sigelem
argument_list|,
name|spp
operator|->
name|sp_vccq
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|spans_vc_zone
argument_list|,
name|svp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Some problem was detected with the request.  Send a SPANS 	 * message rejecting the connection. 	 */
name|rsp_msg
operator|=
name|uma_zalloc
argument_list|(
name|spans_msg_zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsp_msg
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * Fill out the response 	 */
name|rsp_msg
operator|->
name|sm_vers
operator|=
name|SPANS_VERS_1_0
expr_stmt|;
name|rsp_msg
operator|->
name|sm_type
operator|=
name|SPANS_OPEN_RSP
expr_stmt|;
name|rsp_msg
operator|->
name|sm_open_rsp
operator|.
name|oprsp_conn
operator|=
name|msg
operator|->
name|sm_open_req
operator|.
name|opreq_conn
expr_stmt|;
name|rsp_msg
operator|->
name|sm_open_rsp
operator|.
name|oprsp_result
operator|=
name|result
expr_stmt|;
name|rsp_msg
operator|->
name|sm_open_rsp
operator|.
name|oprsp_vpvc
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Send the Open Response 	 */
name|spans_send_msg
argument_list|(
name|spp
argument_list|,
name|rsp_msg
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|spans_msg_zone
argument_list|,
name|rsp_msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process an open response or open confirmation  *  * Called when an open response or open confirmation is received.  * Processing will be based on the state of the requested connection and  * the status returned.  *  * Arguments:  *	spp	pointer to SPANS protocol instance block  *	msg	pointer to the open response or confirmation message  *  * Returns:  *	none  *  */
end_comment

begin_function
specifier|static
name|void
name|spans_open_rsp
parameter_list|(
name|spp
parameter_list|,
name|msg
parameter_list|)
name|struct
name|spans
modifier|*
name|spp
decl_stmt|;
name|spans_msg
modifier|*
name|msg
decl_stmt|;
block|{
name|struct
name|spans_vccb
modifier|*
name|svp
decl_stmt|;
name|ATM_DEBUG2
argument_list|(
literal|"spans_open_rsp: spp=%p, msg=%p\n"
argument_list|,
name|spp
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|/* 	 * Locate the VCCB for the connection 	 */
name|svp
operator|=
name|spans_find_conn
argument_list|(
name|spp
argument_list|,
operator|&
name|msg
operator|->
name|sm_open_rsp
operator|.
name|oprsp_conn
argument_list|)
expr_stmt|;
if|if
condition|(
name|svp
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * Check the connection state 	 */
if|if
condition|(
operator|(
name|svp
operator|->
name|sv_sstate
operator|!=
name|SPANS_VC_POPEN
operator|&&
name|svp
operator|->
name|sv_sstate
operator|!=
name|SPANS_VC_R_POPEN
operator|)
operator|||
name|svp
operator|->
name|sv_ustate
operator|!=
name|VCCU_POPEN
condition|)
block|{
name|ATM_DEBUG2
argument_list|(
literal|"spans_open_rsp: invalid VCCB state, sstate=%d, ustate=%d\n"
argument_list|,
name|svp
operator|->
name|sv_sstate
argument_list|,
name|svp
operator|->
name|sv_ustate
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Cancel the retransmission timer 	 */
name|SPANS_VC_CANCEL
argument_list|(
operator|(
expr|struct
name|vccb
operator|*
operator|)
name|svp
argument_list|)
expr_stmt|;
comment|/* 	 * Check the result 	 */
switch|switch
condition|(
name|msg
operator|->
name|sm_open_rsp
operator|.
name|oprsp_result
condition|)
block|{
case|case
name|SPANS_OK
case|:
comment|/* 		 * Save the assigned VPI and VCI 		 */
name|svp
operator|->
name|sv_vpi
operator|=
name|SPANS_EXTRACT_VPI
argument_list|(
name|msg
operator|->
name|sm_open_rsp
operator|.
name|oprsp_vpvc
argument_list|)
expr_stmt|;
name|svp
operator|->
name|sv_vci
operator|=
name|SPANS_EXTRACT_VCI
argument_list|(
name|msg
operator|->
name|sm_open_rsp
operator|.
name|oprsp_vpvc
argument_list|)
expr_stmt|;
comment|/* 		 * Update the VCC state and notify the VCC owner 		 */
name|svp
operator|->
name|sv_sstate
operator|=
name|SPANS_VC_OPEN
expr_stmt|;
name|svp
operator|->
name|sv_ustate
operator|=
name|VCCU_OPEN
expr_stmt|;
name|svp
operator|->
name|sv_tstamp
operator|=
name|time_second
expr_stmt|;
name|atm_cm_connected
argument_list|(
name|svp
operator|->
name|sv_connvc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPANS_FAIL
case|:
case|case
name|SPANS_NOVPVC
case|:
case|case
name|SPANS_NORSC
case|:
case|case
name|SPANS_BADDEST
case|:
comment|/* 		 * Close out the VCCB and notify the user 		 */
name|svp
operator|->
name|sv_sstate
operator|=
name|SPANS_VC_FREE
expr_stmt|;
name|svp
operator|->
name|sv_ustate
operator|=
name|VCCU_CLOSED
expr_stmt|;
name|svp
operator|->
name|sv_connvc
operator|->
name|cvc_attr
operator|.
name|cause
operator|.
name|tag
operator|=
name|T_ATM_PRESENT
expr_stmt|;
name|svp
operator|->
name|sv_connvc
operator|->
name|cvc_attr
operator|.
name|cause
operator|.
name|v
operator|.
name|coding_standard
operator|=
name|T_ATM_ITU_CODING
expr_stmt|;
name|svp
operator|->
name|sv_connvc
operator|->
name|cvc_attr
operator|.
name|cause
operator|.
name|v
operator|.
name|location
operator|=
name|T_ATM_LOC_USER
expr_stmt|;
name|svp
operator|->
name|sv_connvc
operator|->
name|cvc_attr
operator|.
name|cause
operator|.
name|v
operator|.
name|cause_value
operator|=
name|T_ATM_CAUSE_CALL_REJECTED
expr_stmt|;
name|bzero
argument_list|(
name|svp
operator|->
name|sv_connvc
operator|->
name|cvc_attr
operator|.
name|cause
operator|.
name|v
operator|.
name|diagnostics
argument_list|,
sizeof|sizeof
argument_list|(
name|svp
operator|->
name|sv_connvc
operator|->
name|cvc_attr
operator|.
name|cause
operator|.
name|v
operator|.
name|diagnostics
argument_list|)
argument_list|)
expr_stmt|;
name|atm_cm_cleared
argument_list|(
name|svp
operator|->
name|sv_connvc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"spans: unknown result %d in open rsp\n"
argument_list|,
name|msg
operator|->
name|sm_open_rsp
operator|.
name|oprsp_result
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Process a close request from the network  *  * Called when a close request, close indication, rclose request, or  * rclose indication is received.  Processing will be based on the  * state of the connection.  *  * Arguments:  *	spp	pointer to SPANS protocol instance block  *	msg	pointer to the close request message  *  * Returns:  *	none  *  */
end_comment

begin_function
specifier|static
name|void
name|spans_close_req
parameter_list|(
name|spp
parameter_list|,
name|msg
parameter_list|)
name|struct
name|spans
modifier|*
name|spp
decl_stmt|;
name|spans_msg
modifier|*
name|msg
decl_stmt|;
block|{
name|struct
name|spans_vccb
modifier|*
name|svp
decl_stmt|;
name|spans_result
name|result
decl_stmt|;
name|spans_msg
modifier|*
name|rsp_msg
decl_stmt|;
name|u_char
name|outstate
decl_stmt|;
name|Atm_connvc
modifier|*
name|cvp
decl_stmt|;
name|ATM_DEBUG2
argument_list|(
literal|"spans_close_req: spp=%p, msg=%p\n"
argument_list|,
name|spp
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|/* 	 * Locate the VCCB for the connection 	 */
name|svp
operator|=
name|spans_find_conn
argument_list|(
name|spp
argument_list|,
operator|&
name|msg
operator|->
name|sm_close_req
operator|.
name|clreq_conn
argument_list|)
expr_stmt|;
if|if
condition|(
name|svp
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|SPANS_BADDEST
expr_stmt|;
goto|goto
name|response
goto|;
block|}
comment|/* 	 * Check the connection type 	 */
if|if
condition|(
operator|!
operator|(
name|svp
operator|->
name|sv_type
operator|&
name|VCC_SVC
operator|)
condition|)
block|{
name|result
operator|=
name|SPANS_FAIL
expr_stmt|;
goto|goto
name|response
goto|;
block|}
comment|/* 	 * Check the connection state 	 */
switch|switch
condition|(
name|svp
operator|->
name|sv_sstate
condition|)
block|{
case|case
name|SPANS_VC_OPEN
case|:
case|case
name|SPANS_VC_R_POPEN
case|:
case|case
name|SPANS_VC_POPEN
case|:
comment|/* 		 * VCC is open or opening--continue 		 */
break|break;
case|case
name|SPANS_VC_CLOSE
case|:
case|case
name|SPANS_VC_FREE
case|:
case|case
name|SPANS_VC_ABORT
case|:
comment|/* 		 * We're already closing--give a response, since this 		 * is probably a retransmission 		 */
name|result
operator|=
name|SPANS_OK
expr_stmt|;
goto|goto
name|response
goto|;
case|case
name|SPANS_VC_NULL
case|:
name|result
operator|=
name|SPANS_FAIL
expr_stmt|;
goto|goto
name|response
goto|;
block|}
comment|/* 	 * Cancel the retransmission timer 	 */
name|SPANS_VC_CANCEL
argument_list|(
operator|(
expr|struct
name|vccb
operator|*
operator|)
name|svp
argument_list|)
expr_stmt|;
comment|/* 	 * Close out the VCCB and notify the user 	 */
name|outstate
operator|=
name|svp
operator|->
name|sv_sstate
expr_stmt|;
name|svp
operator|->
name|sv_ustate
operator|=
name|VCCU_CLOSED
expr_stmt|;
name|svp
operator|->
name|sv_sstate
operator|=
name|SPANS_VC_FREE
expr_stmt|;
name|cvp
operator|=
name|svp
operator|->
name|sv_connvc
expr_stmt|;
switch|switch
condition|(
name|outstate
condition|)
block|{
case|case
name|SPANS_VC_R_POPEN
case|:
name|spans_free
argument_list|(
operator|(
expr|struct
name|vccb
operator|*
operator|)
name|svp
argument_list|)
expr_stmt|;
comment|/* FALLTHRU */
case|case
name|SPANS_VC_POPEN
case|:
case|case
name|SPANS_VC_OPEN
case|:
name|cvp
operator|->
name|cvc_attr
operator|.
name|cause
operator|.
name|tag
operator|=
name|T_ATM_PRESENT
expr_stmt|;
name|cvp
operator|->
name|cvc_attr
operator|.
name|cause
operator|.
name|v
operator|.
name|coding_standard
operator|=
name|T_ATM_ITU_CODING
expr_stmt|;
name|cvp
operator|->
name|cvc_attr
operator|.
name|cause
operator|.
name|v
operator|.
name|location
operator|=
name|T_ATM_LOC_USER
expr_stmt|;
name|cvp
operator|->
name|cvc_attr
operator|.
name|cause
operator|.
name|v
operator|.
name|cause_value
operator|=
name|T_ATM_CAUSE_NORMAL_CALL_CLEARING
expr_stmt|;
name|bzero
argument_list|(
name|cvp
operator|->
name|cvc_attr
operator|.
name|cause
operator|.
name|v
operator|.
name|diagnostics
argument_list|,
sizeof|sizeof
argument_list|(
name|cvp
operator|->
name|cvc_attr
operator|.
name|cause
operator|.
name|v
operator|.
name|diagnostics
argument_list|)
argument_list|)
expr_stmt|;
name|atm_cm_cleared
argument_list|(
name|svp
operator|->
name|sv_connvc
argument_list|)
expr_stmt|;
break|break;
block|}
name|result
operator|=
name|SPANS_OK
expr_stmt|;
name|response
label|:
comment|/* 	 * Respond to the SPANS_CLOSE_IND with a SPANS_CLOSE_RSP 	 */
name|rsp_msg
operator|=
name|uma_zalloc
argument_list|(
name|spans_msg_zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsp_msg
operator|==
name|NULL
condition|)
return|return;
name|rsp_msg
operator|->
name|sm_vers
operator|=
name|SPANS_VERS_1_0
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|sm_type
operator|==
name|SPANS_RCLOSE_REQ
operator|||
name|msg
operator|->
name|sm_type
operator|==
name|SPANS_RCLOSE_IND
condition|)
block|{
name|rsp_msg
operator|->
name|sm_type
operator|=
name|SPANS_RCLOSE_RSP
expr_stmt|;
block|}
else|else
block|{
name|rsp_msg
operator|->
name|sm_type
operator|=
name|SPANS_CLOSE_RSP
expr_stmt|;
block|}
name|rsp_msg
operator|->
name|sm_close_rsp
operator|.
name|clrsp_conn
operator|=
name|msg
operator|->
name|sm_close_req
operator|.
name|clreq_conn
expr_stmt|;
name|rsp_msg
operator|->
name|sm_close_rsp
operator|.
name|clrsp_result
operator|=
name|result
expr_stmt|;
name|spans_send_msg
argument_list|(
name|spp
argument_list|,
name|rsp_msg
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|spans_msg_zone
argument_list|,
name|rsp_msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process a close response or close confirmation  *  * Called when a close response or close confirmation is received.  * Processing will be based on the state of the requested connection and  * the returned status.  *  * Arguments:  *	spp	pointer to SPANS protocol instance block  *	msg	pointer to the close response or confirmation message  *  * Returns:  *	none  *  */
end_comment

begin_function
specifier|static
name|void
name|spans_close_rsp
parameter_list|(
name|spp
parameter_list|,
name|msg
parameter_list|)
name|struct
name|spans
modifier|*
name|spp
decl_stmt|;
name|spans_msg
modifier|*
name|msg
decl_stmt|;
block|{
name|struct
name|spans_vccb
modifier|*
name|svp
decl_stmt|;
name|ATM_DEBUG2
argument_list|(
literal|"spans_close_rsp: spp=%p, msg=%p\n"
argument_list|,
name|spp
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|/* 	 * Locate the VCCB for the connection 	 */
name|svp
operator|=
name|spans_find_conn
argument_list|(
name|spp
argument_list|,
operator|&
name|msg
operator|->
name|sm_close_rsp
operator|.
name|clrsp_conn
argument_list|)
expr_stmt|;
if|if
condition|(
name|svp
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
comment|/* 	 * Check the VCCB state 	 */
if|if
condition|(
name|svp
operator|->
name|sv_sstate
operator|!=
name|SPANS_VC_CLOSE
condition|)
block|{
return|return;
block|}
comment|/* 	 * Cancel the retransmission timer 	 */
name|SPANS_VC_CANCEL
argument_list|(
operator|(
expr|struct
name|vccb
operator|*
operator|)
name|svp
argument_list|)
expr_stmt|;
comment|/* 	 * Check the response from the remote end 	 */
switch|switch
condition|(
name|msg
operator|->
name|sm_close_rsp
operator|.
name|clrsp_result
condition|)
block|{
case|case
name|SPANS_OK
case|:
comment|/* 		 * Mark the VCCB as closed and notify the owner 		 */
name|svp
operator|->
name|sv_sstate
operator|=
name|SPANS_VC_FREE
expr_stmt|;
name|svp
operator|->
name|sv_connvc
operator|->
name|cvc_attr
operator|.
name|cause
operator|.
name|tag
operator|=
name|T_ATM_PRESENT
expr_stmt|;
name|svp
operator|->
name|sv_connvc
operator|->
name|cvc_attr
operator|.
name|cause
operator|.
name|v
operator|.
name|coding_standard
operator|=
name|T_ATM_ITU_CODING
expr_stmt|;
name|svp
operator|->
name|sv_connvc
operator|->
name|cvc_attr
operator|.
name|cause
operator|.
name|v
operator|.
name|location
operator|=
name|T_ATM_LOC_USER
expr_stmt|;
name|svp
operator|->
name|sv_connvc
operator|->
name|cvc_attr
operator|.
name|cause
operator|.
name|v
operator|.
name|cause_value
operator|=
name|T_ATM_CAUSE_NORMAL_CALL_CLEARING
expr_stmt|;
name|bzero
argument_list|(
name|svp
operator|->
name|sv_connvc
operator|->
name|cvc_attr
operator|.
name|cause
operator|.
name|v
operator|.
name|diagnostics
argument_list|,
sizeof|sizeof
argument_list|(
name|svp
operator|->
name|sv_connvc
operator|->
name|cvc_attr
operator|.
name|cause
operator|.
name|v
operator|.
name|diagnostics
argument_list|)
argument_list|)
expr_stmt|;
name|atm_cm_cleared
argument_list|(
name|svp
operator|->
name|sv_connvc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPANS_NOVPVC
case|:
case|case
name|SPANS_BADDEST
case|:
case|case
name|SPANS_FAIL
case|:
case|case
name|SPANS_NORSC
case|:
comment|/* 		 * Mark the VCCB as closed and notify the owner 		 */
name|svp
operator|->
name|sv_sstate
operator|=
name|SPANS_VC_FREE
expr_stmt|;
name|svp
operator|->
name|sv_connvc
operator|->
name|cvc_attr
operator|.
name|cause
operator|.
name|tag
operator|=
name|T_ATM_PRESENT
expr_stmt|;
name|svp
operator|->
name|sv_connvc
operator|->
name|cvc_attr
operator|.
name|cause
operator|.
name|v
operator|.
name|coding_standard
operator|=
name|T_ATM_ITU_CODING
expr_stmt|;
name|svp
operator|->
name|sv_connvc
operator|->
name|cvc_attr
operator|.
name|cause
operator|.
name|v
operator|.
name|location
operator|=
name|T_ATM_LOC_USER
expr_stmt|;
name|svp
operator|->
name|sv_connvc
operator|->
name|cvc_attr
operator|.
name|cause
operator|.
name|v
operator|.
name|cause_value
operator|=
name|T_ATM_CAUSE_UNSPECIFIED_NORMAL
expr_stmt|;
name|bzero
argument_list|(
name|svp
operator|->
name|sv_connvc
operator|->
name|cvc_attr
operator|.
name|cause
operator|.
name|v
operator|.
name|diagnostics
argument_list|,
sizeof|sizeof
argument_list|(
name|svp
operator|->
name|sv_connvc
operator|->
name|cvc_attr
operator|.
name|cause
operator|.
name|v
operator|.
name|diagnostics
argument_list|)
argument_list|)
expr_stmt|;
name|atm_cm_cleared
argument_list|(
name|svp
operator|->
name|sv_connvc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"spans: unknown result %d in close rsp\n"
argument_list|,
name|msg
operator|->
name|sm_close_rsp
operator|.
name|clrsp_result
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Process a multi request or multi indication  *  * Called when a multi response or multi confirmation is received.  We  * don't support multicast channels, so we just reject the request.  *  * Arguments:  *	spp	pointer to SPANS protocol instance block  *	msg	pointer to the multi request or indication message  *  * Returns:  *	none  *  */
end_comment

begin_function
specifier|static
name|void
name|spans_multi_req
parameter_list|(
name|spp
parameter_list|,
name|msg
parameter_list|)
name|struct
name|spans
modifier|*
name|spp
decl_stmt|;
name|spans_msg
modifier|*
name|msg
decl_stmt|;
block|{
name|spans_msg
modifier|*
name|rsp_msg
decl_stmt|;
comment|/* 	 * Get memory for a SPANS_MULTI_RSP message. 	 */
name|rsp_msg
operator|=
name|uma_zalloc
argument_list|(
name|spans_msg_zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsp_msg
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * Fill out the response. 	 */
name|rsp_msg
operator|->
name|sm_vers
operator|=
name|SPANS_VERS_1_0
expr_stmt|;
name|rsp_msg
operator|->
name|sm_type
operator|=
name|SPANS_MULTI_RSP
expr_stmt|;
name|rsp_msg
operator|->
name|sm_multi_rsp
operator|.
name|mursp_conn
operator|=
name|msg
operator|->
name|sm_multi_req
operator|.
name|mureq_conn
expr_stmt|;
name|rsp_msg
operator|->
name|sm_multi_rsp
operator|.
name|mursp_result
operator|=
name|SPANS_FAIL
expr_stmt|;
name|rsp_msg
operator|->
name|sm_multi_rsp
operator|.
name|mursp_rsrc
operator|=
name|msg
operator|->
name|sm_multi_req
operator|.
name|mureq_desrsrc
expr_stmt|;
name|rsp_msg
operator|->
name|sm_multi_rsp
operator|.
name|mursp_vpvc
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Send the response and free the message. 	 */
operator|(
name|void
operator|)
name|spans_send_msg
argument_list|(
name|spp
argument_list|,
name|rsp_msg
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|spans_msg_zone
argument_list|,
name|rsp_msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process an add request or add indication  *  * Called when an add response or add confirmation is received.  We  * don't support multicast channels, so we just reject the request.  *  * Arguments:  *	spp	pointer to SPANS protocol instance block  *	msg	pointer to the add request or indication message  *  * Returns:  *	none  *  */
end_comment

begin_function
specifier|static
name|void
name|spans_add_req
parameter_list|(
name|spp
parameter_list|,
name|msg
parameter_list|)
name|struct
name|spans
modifier|*
name|spp
decl_stmt|;
name|spans_msg
modifier|*
name|msg
decl_stmt|;
block|{
name|spans_msg
modifier|*
name|rsp_msg
decl_stmt|;
comment|/* 	 * Get memory for a SPANS_ADD_RSP message. 	 */
name|rsp_msg
operator|=
name|uma_zalloc
argument_list|(
name|spans_msg_zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsp_msg
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * Fill out the response. 	 */
name|rsp_msg
operator|->
name|sm_vers
operator|=
name|SPANS_VERS_1_0
expr_stmt|;
name|rsp_msg
operator|->
name|sm_type
operator|=
name|SPANS_ADD_RSP
expr_stmt|;
name|rsp_msg
operator|->
name|sm_add_rsp
operator|.
name|adrsp_conn
operator|=
name|msg
operator|->
name|sm_add_req
operator|.
name|adreq_desconn
expr_stmt|;
name|rsp_msg
operator|->
name|sm_add_rsp
operator|.
name|adrsp_result
operator|=
name|SPANS_FAIL
expr_stmt|;
name|rsp_msg
operator|->
name|sm_add_rsp
operator|.
name|adrsp_rsrc
operator|.
name|rsc_peak
operator|=
literal|0
expr_stmt|;
name|rsp_msg
operator|->
name|sm_add_rsp
operator|.
name|adrsp_rsrc
operator|.
name|rsc_mean
operator|=
literal|0
expr_stmt|;
name|rsp_msg
operator|->
name|sm_add_rsp
operator|.
name|adrsp_rsrc
operator|.
name|rsc_burst
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Send the response and free the message. 	 */
operator|(
name|void
operator|)
name|spans_send_msg
argument_list|(
name|spp
argument_list|,
name|rsp_msg
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|spans_msg_zone
argument_list|,
name|rsp_msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process a join request  *  * Called when a join request is received.  We don't support group  * addresses, so we just reject the request.  *  * Arguments:  *	spp	pointer to SPANS protocol instance block  *	msg	pointer to the join request message  *  * Returns:  *	none  *  */
end_comment

begin_function
specifier|static
name|void
name|spans_join_req
parameter_list|(
name|spp
parameter_list|,
name|msg
parameter_list|)
name|struct
name|spans
modifier|*
name|spp
decl_stmt|;
name|spans_msg
modifier|*
name|msg
decl_stmt|;
block|{
name|spans_msg
modifier|*
name|rsp_msg
decl_stmt|;
comment|/* 	 * Get memory for a SPANS_JOIN_CNF message. 	 */
name|rsp_msg
operator|=
name|uma_zalloc
argument_list|(
name|spans_msg_zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsp_msg
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * Fill out the response. 	 */
name|rsp_msg
operator|->
name|sm_vers
operator|=
name|SPANS_VERS_1_0
expr_stmt|;
name|rsp_msg
operator|->
name|sm_type
operator|=
name|SPANS_JOIN_CNF
expr_stmt|;
name|spans_addr_copy
argument_list|(
operator|&
name|msg
operator|->
name|sm_join_req
operator|.
name|jnreq_addr
argument_list|,
operator|&
name|rsp_msg
operator|->
name|sm_join_cnf
operator|.
name|jncnf_addr
argument_list|)
expr_stmt|;
name|rsp_msg
operator|->
name|sm_join_cnf
operator|.
name|jncnf_result
operator|=
name|SPANS_FAIL
expr_stmt|;
comment|/* 	 * Send the response and free the message. 	 */
operator|(
name|void
operator|)
name|spans_send_msg
argument_list|(
name|spp
argument_list|,
name|rsp_msg
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|spans_msg_zone
argument_list|,
name|rsp_msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process a leave request  *  * Called when a leave request is received.  We don't support group  * addresses, so we just reject the request.  *  * Arguments:  *	spp	pointer to SPANS protocol instance block  *	msg	pointer to the leave request message  *  * Returns:  *	none  *  */
end_comment

begin_function
specifier|static
name|void
name|spans_leave_req
parameter_list|(
name|spp
parameter_list|,
name|msg
parameter_list|)
name|struct
name|spans
modifier|*
name|spp
decl_stmt|;
name|spans_msg
modifier|*
name|msg
decl_stmt|;
block|{
name|spans_msg
modifier|*
name|rsp_msg
decl_stmt|;
comment|/* 	 * Get memory for a SPANS_LEAVE_CNF message. 	 */
name|rsp_msg
operator|=
name|uma_zalloc
argument_list|(
name|spans_msg_zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsp_msg
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * Fill out the response. 	 */
name|rsp_msg
operator|->
name|sm_vers
operator|=
name|SPANS_VERS_1_0
expr_stmt|;
name|rsp_msg
operator|->
name|sm_type
operator|=
name|SPANS_LEAVE_CNF
expr_stmt|;
name|spans_addr_copy
argument_list|(
operator|&
name|msg
operator|->
name|sm_leave_req
operator|.
name|lvreq_addr
argument_list|,
operator|&
name|rsp_msg
operator|->
name|sm_leave_cnf
operator|.
name|lvcnf_addr
argument_list|)
expr_stmt|;
name|rsp_msg
operator|->
name|sm_leave_cnf
operator|.
name|lvcnf_result
operator|=
name|SPANS_FAIL
expr_stmt|;
comment|/* 	 * Send the response and free the message. 	 */
operator|(
name|void
operator|)
name|spans_send_msg
argument_list|(
name|spp
argument_list|,
name|rsp_msg
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|spans_msg_zone
argument_list|,
name|rsp_msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process a VCI range indication  *  * Called when a VCI range indication is received.  Adjust the VCI  * bounds if they have changed.  *  * Arguments:  *	spp	pointer to SPANS protocol instance block  *	msg	pointer to the VCI range indication message  *  * Returns:  *	none  *  */
end_comment

begin_function
specifier|static
name|void
name|spans_vcir_ind
parameter_list|(
name|spp
parameter_list|,
name|msg
parameter_list|)
name|struct
name|spans
modifier|*
name|spp
decl_stmt|;
name|spans_msg
modifier|*
name|msg
decl_stmt|;
block|{
comment|/* 	 * Adjust the limits if they have changed 	 */
if|if
condition|(
name|msg
operator|->
name|sm_vcir_ind
operator|.
name|vrind_min
operator|!=
name|spp
operator|->
name|sp_min_vci
condition|)
block|{
name|spp
operator|->
name|sp_min_vci
operator|=
operator|(
name|msg
operator|->
name|sm_vcir_ind
operator|.
name|vrind_min
operator|<
name|SPANS_MIN_VCI
condition|?
name|SPANS_MIN_VCI
else|:
name|msg
operator|->
name|sm_vcir_ind
operator|.
name|vrind_min
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|msg
operator|->
name|sm_vcir_ind
operator|.
name|vrind_max
operator|!=
name|spp
operator|->
name|sp_max_vci
condition|)
block|{
name|spp
operator|->
name|sp_max_vci
operator|=
operator|(
name|msg
operator|->
name|sm_vcir_ind
operator|.
name|vrind_max
operator|>
name|SPANS_MAX_VCI
condition|?
name|SPANS_MAX_VCI
else|:
name|msg
operator|->
name|sm_vcir_ind
operator|.
name|vrind_max
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Process a query request  *  * Called when a query request is received.  Respond with the  * appropriate query response.  *  * Arguments:  *	spp	pointer to SPANS protocol instance block  *	msg	pointer to the VCI range indication message  *  * Returns:  *	none  *  */
end_comment

begin_function
specifier|static
name|void
name|spans_query_req
parameter_list|(
name|spp
parameter_list|,
name|msg
parameter_list|)
name|struct
name|spans
modifier|*
name|spp
decl_stmt|;
name|spans_msg
modifier|*
name|msg
decl_stmt|;
block|{
name|struct
name|spans_vccb
modifier|*
name|svp
init|=
name|NULL
decl_stmt|;
name|spans_msg
modifier|*
name|rsp_msg
decl_stmt|;
name|ATM_DEBUG1
argument_list|(
literal|"spans_query_req: msg=%p\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|/* 	 * Ignore an end-to-end query 	 */
if|if
condition|(
name|msg
operator|->
name|sm_query_req
operator|.
name|qyreq_type
operator|==
name|SPANS_QUERY_END_TO_END
condition|)
block|{
return|return;
block|}
comment|/* 	 * Get memory for a SPANS_QUERY_RSP message. 	 */
name|rsp_msg
operator|=
name|uma_zalloc
argument_list|(
name|spans_msg_zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsp_msg
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * Fill out the response. 	 */
name|rsp_msg
operator|->
name|sm_vers
operator|=
name|SPANS_VERS_1_0
expr_stmt|;
name|rsp_msg
operator|->
name|sm_type
operator|=
name|SPANS_QUERY_RSP
expr_stmt|;
name|rsp_msg
operator|->
name|sm_query_rsp
operator|.
name|qyrsp_conn
operator|=
name|msg
operator|->
name|sm_query_req
operator|.
name|qyreq_conn
expr_stmt|;
name|rsp_msg
operator|->
name|sm_query_rsp
operator|.
name|qyrsp_type
operator|=
name|msg
operator|->
name|sm_query_req
operator|.
name|qyreq_type
expr_stmt|;
name|rsp_msg
operator|->
name|sm_query_rsp
operator|.
name|qyrsp_data
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Get the state of the requested connection 	 */
name|svp
operator|=
name|spans_find_conn
argument_list|(
name|spp
argument_list|,
operator|&
name|msg
operator|->
name|sm_query_req
operator|.
name|qyreq_conn
argument_list|)
expr_stmt|;
if|if
condition|(
name|svp
condition|)
block|{
switch|switch
condition|(
name|svp
operator|->
name|sv_sstate
condition|)
block|{
case|case
name|SPANS_VC_NULL
case|:
case|case
name|SPANS_VC_FREE
case|:
name|rsp_msg
operator|->
name|sm_query_rsp
operator|.
name|qyrsp_state
operator|=
name|SPANS_CONN_CLOSED
expr_stmt|;
break|break;
case|case
name|SPANS_VC_OPEN
case|:
name|rsp_msg
operator|->
name|sm_query_rsp
operator|.
name|qyrsp_state
operator|=
name|SPANS_CONN_OPEN
expr_stmt|;
break|break;
case|case
name|SPANS_VC_POPEN
case|:
case|case
name|SPANS_VC_R_POPEN
case|:
name|rsp_msg
operator|->
name|sm_query_rsp
operator|.
name|qyrsp_state
operator|=
name|SPANS_CONN_OPEN_PEND
expr_stmt|;
break|break;
case|case
name|SPANS_VC_CLOSE
case|:
case|case
name|SPANS_VC_ABORT
case|:
name|rsp_msg
operator|->
name|sm_query_rsp
operator|.
name|qyrsp_state
operator|=
name|SPANS_CONN_CLOSE_PEND
expr_stmt|;
break|break;
case|case
name|SPANS_VC_ACTIVE
case|:
case|case
name|SPANS_VC_ACT_DOWN
case|:
comment|/* 			 * VCCB is for a PVC (shouldn't happen) 			 */
name|uma_zfree
argument_list|(
name|spans_msg_zone
argument_list|,
name|rsp_msg
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|/* 		 * No VCCB found--connection doesn't exist 		 */
name|rsp_msg
operator|->
name|sm_query_rsp
operator|.
name|qyrsp_state
operator|=
name|SPANS_CONN_CLOSED
expr_stmt|;
block|}
comment|/* 	 * Send the response and free the message. 	 */
operator|(
name|void
operator|)
name|spans_send_msg
argument_list|(
name|spp
argument_list|,
name|rsp_msg
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|spans_msg_zone
argument_list|,
name|rsp_msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process a SPANS signalling message  *  * Called when a SPANS message is received.  The message is converted  * into internal format with XDR and decoded by calling the appropriate  * mesage handling routine.  Unrecognized and unexpected messages are  * logged.  *  * Arguments:  *	spp	pointer to SPANS protocol instance block  *	m	pointer to a buffer chain containing the SPANS message  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|spans_rcv_msg
parameter_list|(
name|spp
parameter_list|,
name|m
parameter_list|)
name|struct
name|spans
modifier|*
name|spp
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
block|{
name|XDR
name|xdrs
decl_stmt|;
name|spans_msg
modifier|*
name|msg
decl_stmt|;
comment|/* 	 * Get storage for the message 	 */
name|msg
operator|=
name|uma_zalloc
argument_list|(
name|spans_msg_zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * Convert the message from network order to internal format 	 */
name|xdrmbuf_init
argument_list|(
operator|&
name|xdrs
argument_list|,
name|m
argument_list|,
name|XDR_DECODE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xdr_spans_msg
argument_list|(
operator|&
name|xdrs
argument_list|,
name|msg
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"spans_rcv_msg: XDR decode failed\n"
argument_list|)
expr_stmt|;
name|spans_dump_buffer
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
ifdef|#
directive|ifdef
name|NOTDEF
comment|/* 	 * Debug--print some information about the message 	 */
if|if
condition|(
name|msg
operator|->
name|sm_type
operator|!=
name|SPANS_STAT_REQ
operator|&&
name|msg
operator|->
name|sm_type
operator|!=
name|SPANS_STAT_IND
operator|&&
name|msg
operator|->
name|sm_type
operator|!=
name|SPANS_STAT_RSP
condition|)
block|{
name|printf
argument_list|(
literal|"spans_rcv_msg: got "
argument_list|)
expr_stmt|;
name|spans_print_msg
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Verify the message sm_vers 	 */
if|if
condition|(
name|msg
operator|->
name|sm_vers
operator|!=
name|SPANS_VERS_1_0
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"spans: invalid message version 0x%x\n"
argument_list|,
name|msg
operator|->
name|sm_vers
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Ignore the message if SPANS isn't up yet 	 */
if|if
condition|(
name|spp
operator|->
name|sp_state
operator|!=
name|SPANS_ACTIVE
operator|&&
operator|(
name|spp
operator|->
name|sp_state
operator|!=
name|SPANS_PROBE
operator|||
operator|(
name|msg
operator|->
name|sm_type
operator|!=
name|SPANS_STAT_REQ
operator|&&
name|msg
operator|->
name|sm_type
operator|!=
name|SPANS_STAT_RSP
operator|&&
name|msg
operator|->
name|sm_type
operator|!=
name|SPANS_STAT_IND
operator|)
operator|)
condition|)
block|{
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Process the message based on its type 	 */
switch|switch
condition|(
name|msg
operator|->
name|sm_type
condition|)
block|{
case|case
name|SPANS_STAT_REQ
case|:
name|spans_status_ind
argument_list|(
name|spp
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPANS_STAT_IND
case|:
name|spans_status_ind
argument_list|(
name|spp
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPANS_STAT_RSP
case|:
name|spans_status_rsp
argument_list|(
name|spp
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPANS_OPEN_REQ
case|:
name|spans_open_req
argument_list|(
name|spp
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPANS_OPEN_IND
case|:
name|spans_open_req
argument_list|(
name|spp
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPANS_OPEN_RSP
case|:
name|spans_open_rsp
argument_list|(
name|spp
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPANS_OPEN_CNF
case|:
name|spans_open_rsp
argument_list|(
name|spp
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPANS_CLOSE_REQ
case|:
name|spans_close_req
argument_list|(
name|spp
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPANS_CLOSE_IND
case|:
name|spans_close_req
argument_list|(
name|spp
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPANS_CLOSE_RSP
case|:
name|spans_close_rsp
argument_list|(
name|spp
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPANS_CLOSE_CNF
case|:
name|spans_close_rsp
argument_list|(
name|spp
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPANS_RCLOSE_REQ
case|:
name|spans_close_req
argument_list|(
name|spp
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPANS_RCLOSE_IND
case|:
name|spans_close_req
argument_list|(
name|spp
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPANS_RCLOSE_RSP
case|:
name|spans_close_rsp
argument_list|(
name|spp
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPANS_RCLOSE_CNF
case|:
name|spans_close_rsp
argument_list|(
name|spp
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPANS_MULTI_REQ
case|:
name|spans_multi_req
argument_list|(
name|spp
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPANS_MULTI_IND
case|:
name|spans_multi_req
argument_list|(
name|spp
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPANS_MULTI_RSP
case|:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"spans: unexpected message (multi_rsp)\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPANS_MULTI_CNF
case|:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"spans: unexpected message (multi_conf)\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPANS_ADD_REQ
case|:
name|spans_add_req
argument_list|(
name|spp
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPANS_ADD_IND
case|:
name|spans_add_req
argument_list|(
name|spp
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPANS_ADD_RSP
case|:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"spans: unexpected message (add_rsp)\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPANS_ADD_CNF
case|:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"spans: unexpected message (add_conf)\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPANS_JOIN_REQ
case|:
name|spans_join_req
argument_list|(
name|spp
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPANS_JOIN_CNF
case|:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"spans: unexpected message (join_conf)\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPANS_LEAVE_REQ
case|:
name|spans_leave_req
argument_list|(
name|spp
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPANS_LEAVE_CNF
case|:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"spans: unexpected message (leave_conf)\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPANS_VCIR_IND
case|:
name|spans_vcir_ind
argument_list|(
name|spp
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPANS_QUERY_REQ
case|:
name|spans_query_req
argument_list|(
name|spp
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPANS_QUERY_RSP
case|:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"spans: unexpected message (query_rsp)\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"spans: unknown SPANS message type %d\n"
argument_list|,
name|msg
operator|->
name|sm_type
argument_list|)
expr_stmt|;
block|}
name|done
label|:
comment|/* 	 * Free the incoming message (both buffer and internal format) if 	 * necessary. 	 */
if|if
condition|(
name|msg
condition|)
name|uma_zfree
argument_list|(
name|spans_msg_zone
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

