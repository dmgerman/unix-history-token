begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * ===================================  * HARP  |  Host ATM Research Platform  * ===================================  *  *  * This Host ATM Research Platform ("HARP") file (the "Software") is  * made available by Network Computing Services, Inc. ("NetworkCS")  * "AS IS".  NetworkCS does not provide maintenance, improvements or  * support of any kind.  *  * NETWORKCS MAKES NO WARRANTIES OR REPRESENTATIONS, EXPRESS OR IMPLIED,  * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE, AS TO ANY ELEMENT OF THE  * SOFTWARE OR ANY SUPPORT PROVIDED IN CONNECTION WITH THIS SOFTWARE.  * In no event shall NetworkCS be responsible for any damages, including  * but not limited to consequential damages, arising from or relating to  * any use of the Software or related support.  *  * Copyright 1994-1998 Network Computing Services, Inc.  *  * Copies of this Software may be made, however, the above copyright  * notice must be reproduced on all copies.  *  *	@(#) $FreeBSD$  *  */
end_comment

begin_comment
comment|/*  * SPANS Signalling Manager  * ---------------------------  *  * SPANS-related utility routines.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netatm/port.h>
end_include

begin_include
include|#
directive|include
file|<netatm/queue.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sys.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sap.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_cm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_vc.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sigmgr.h>
end_include

begin_include
include|#
directive|include
file|"spans_xdr.h"
end_include

begin_include
include|#
directive|include
file|<netatm/spans/spans_var.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"@(#) $FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NOTDEF
end_ifdef

begin_comment
comment|/* XXX -- Remove all SAP checks? */
end_comment

begin_define
define|#
directive|define
name|MAX_SAP_ENT
value|1
end_define

begin_struct
specifier|static
struct|struct
block|{
name|spans_sap
name|spans_sap
decl_stmt|;
name|Sap_t
name|local_sap
decl_stmt|;
block|}
name|sap_table
index|[
name|MAX_SAP_ENT
index|]
init|=
block|{
block|{
name|SPANS_SAP_IP
block|,
name|SAP_IP
block|}
block|, }
struct|;
end_struct

begin_comment
comment|/*  * Translate an internal SAP to a SPANS SAP  *  * Search the SAP table for the given SAP.  Put the corresponding SPANS  * SAP into the indicated variable.  *  * Arguments:  *	lsap	the value of the internal SAP  *	ssap	a pointer to the variable to receive the SPANS SAP value  *  * Returns:  *	TRUE	the SAP was found; *ssap is valid  *	FALSE	the SAP was not found; *ssap is not valid  *  */
end_comment

begin_function
name|int
name|spans_get_spans_sap
parameter_list|(
name|lsap
parameter_list|,
name|ssap
parameter_list|)
name|Sap_t
name|lsap
decl_stmt|;
name|spans_sap
modifier|*
name|ssap
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* 	 * Search the SAP table for the given local SAP 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_SAP_ENT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sap_table
index|[
name|i
index|]
operator|.
name|local_sap
operator|==
name|lsap
condition|)
block|{
operator|*
name|ssap
operator|=
name|sap_table
index|[
name|i
index|]
operator|.
name|spans_sap
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Translate a SPANS SAP to internal format  *  * Search the SAP table for the given SAP.  Put the corresponding  * internal SAP into the indicated variable.  *  * Arguments:  *	ssap	the value of the SPANS SAP  *	lsap	a pointer to the variable to receive the internal  *		SAP value  *  * Returns:  *	TRUE	the SAP was found; *lsap is valid  *	FALSE	the SAP was not found; *lsap is not valid  *  */
end_comment

begin_function
name|int
name|spans_get_local_sap
parameter_list|(
name|ssap
parameter_list|,
name|lsap
parameter_list|)
name|spans_sap
name|ssap
decl_stmt|;
name|Sap_t
modifier|*
name|lsap
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* 	 * Search the SAP table for the given SPANS SAP 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_SAP_ENT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sap_table
index|[
name|i
index|]
operator|.
name|spans_sap
operator|==
name|ssap
condition|)
block|{
operator|*
name|lsap
operator|=
name|sap_table
index|[
name|i
index|]
operator|.
name|local_sap
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Allocate an ephemeral SPANS SAP  *  * Arguments:  *	spp	pointer to SPANS protocol instance  *  * Returns:  *	a SPANS ephemeral SAP number  *  */
end_comment

begin_function
name|int
name|spans_ephemeral_sap
parameter_list|(
name|spp
parameter_list|)
name|struct
name|spans
modifier|*
name|spp
decl_stmt|;
block|{
return|return
operator|(
name|SPANS_SAP_EPHEMERAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Translate an internal AAL designator to a SPANS AAL type  *  * Arguments:  *	laal	internal AAL designation  *	saal	a pointer to the variable to receive the SPANS AAL type  *  * Returns:  *	TRUE	the AAL was found; *saal is valid  *	FALSE	the AAL was not found; *saal is not valid  *  */
end_comment

begin_function
name|int
name|spans_get_spans_aal
parameter_list|(
name|laal
parameter_list|,
name|saal
parameter_list|)
name|Aal_t
name|laal
decl_stmt|;
name|spans_aal
modifier|*
name|saal
decl_stmt|;
block|{
comment|/* 	 * 	 */
switch|switch
condition|(
name|laal
condition|)
block|{
case|case
name|ATM_AAL0
case|:
operator|*
name|saal
operator|=
name|SPANS_AAL0
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
case|case
name|ATM_AAL1
case|:
operator|*
name|saal
operator|=
name|SPANS_AAL1
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
case|case
name|ATM_AAL2
case|:
operator|*
name|saal
operator|=
name|SPANS_AAL2
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
case|case
name|ATM_AAL3_4
case|:
operator|*
name|saal
operator|=
name|SPANS_AAL4
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
case|case
name|ATM_AAL5
case|:
operator|*
name|saal
operator|=
name|SPANS_AAL5
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
default|default:
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Translate a SPANS AAL type to an internal AAL designator  *  * Arguments:  *	saal	the SPANS AAL type  *	laal	a pointer to the variable to receive the internal  *		AAL designation  *  * Returns:  *	TRUE	the AAL was found; *laal is valid  *	FALSE	the AAL was not found; *laal is not valid  *  */
end_comment

begin_function
name|int
name|spans_get_local_aal
parameter_list|(
name|saal
parameter_list|,
name|laal
parameter_list|)
name|spans_aal
name|saal
decl_stmt|;
name|Aal_t
modifier|*
name|laal
decl_stmt|;
block|{
comment|/* 	 * 	 */
switch|switch
condition|(
name|saal
condition|)
block|{
case|case
name|SPANS_AAL0
case|:
operator|*
name|laal
operator|=
name|ATM_AAL0
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
case|case
name|SPANS_AAL1
case|:
operator|*
name|laal
operator|=
name|ATM_AAL1
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
case|case
name|SPANS_AAL2
case|:
operator|*
name|laal
operator|=
name|ATM_AAL2
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
case|case
name|SPANS_AAL3
case|:
case|case
name|SPANS_AAL4
case|:
operator|*
name|laal
operator|=
name|ATM_AAL3_4
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
case|case
name|SPANS_AAL5
case|:
operator|*
name|laal
operator|=
name|ATM_AAL5
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
default|default:
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Verify a VCCB  *  * Search SPANS's VCCB queue to verify that a VCCB belongs to SPANS.  *  * Arguments:  *	spp	pointer to SPANS protocol instance  *	svp	pointer to a VCCB  *  * Returns:  *	TRUE	the VCCB belongs to SPANS  *	FALSE	the VCCB doesn't belong to SPANS  *  */
end_comment

begin_function
name|int
name|spans_verify_vccb
parameter_list|(
name|spp
parameter_list|,
name|svp
parameter_list|)
name|struct
name|spans
modifier|*
name|spp
decl_stmt|;
name|struct
name|spans_vccb
modifier|*
name|svp
decl_stmt|;
block|{
name|struct
name|spans_vccb
modifier|*
name|vcp
decl_stmt|,
modifier|*
name|vcnext
decl_stmt|;
for|for
control|(
name|vcp
operator|=
name|Q_HEAD
argument_list|(
name|spp
operator|->
name|sp_vccq
argument_list|,
expr|struct
name|spans_vccb
argument_list|)
init|;
name|vcp
condition|;
name|vcp
operator|=
name|vcnext
control|)
block|{
name|vcnext
operator|=
name|Q_NEXT
argument_list|(
name|vcp
argument_list|,
expr|struct
name|spans_vccb
argument_list|,
name|sv_sigelem
argument_list|)
expr_stmt|;
if|if
condition|(
name|svp
operator|==
name|vcp
condition|)
block|{
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find a VCCB  *  * Find a VCCB given the VPI and VCI.  *  * Arguments:  *	spp	pointer to SPANS protocol instance  *	vpi	the VPI to search for  *	vci	the VCI to search for  *	dir	the direction of the VCC (VCC_IN, VCC_OUT, or both).  *		If dir is set to zero, return the address of any VCCB  *		with the given VPI/VCI, regardless of direction.  *  * Returns:  *	0	there is no such VCCB  *	address	the address of the VCCB  *  */
end_comment

begin_function
name|struct
name|spans_vccb
modifier|*
name|spans_find_vpvc
parameter_list|(
name|spp
parameter_list|,
name|vpi
parameter_list|,
name|vci
parameter_list|,
name|dir
parameter_list|)
name|struct
name|spans
modifier|*
name|spp
decl_stmt|;
name|int
name|vpi
decl_stmt|,
name|vci
decl_stmt|;
name|u_char
name|dir
decl_stmt|;
block|{
name|struct
name|spans_vccb
modifier|*
name|svp
decl_stmt|,
modifier|*
name|svnext
decl_stmt|;
for|for
control|(
name|svp
operator|=
name|Q_HEAD
argument_list|(
name|spp
operator|->
name|sp_vccq
argument_list|,
expr|struct
name|spans_vccb
argument_list|)
init|;
name|svp
condition|;
name|svp
operator|=
name|svnext
control|)
block|{
name|svnext
operator|=
name|Q_NEXT
argument_list|(
name|svp
argument_list|,
expr|struct
name|spans_vccb
argument_list|,
name|sv_sigelem
argument_list|)
expr_stmt|;
if|if
condition|(
name|svp
operator|->
name|sv_vpi
operator|==
name|vpi
operator|&&
name|svp
operator|->
name|sv_vci
operator|==
name|vci
operator|&&
operator|(
name|svp
operator|->
name|sv_type
operator|&
name|dir
operator|)
operator|==
name|dir
condition|)
break|break;
block|}
return|return
operator|(
name|svp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find a connection  *  * Find a VCCB given the connection structure.  *  * Arguments:  *	spp	pointer to SPANS protocol instance  *	p	pointer to an spans_atm_conn structure  *  * Returns:  *	0	there is no such VCCB  *	address	the address of the VCCB  *  */
end_comment

begin_function
name|struct
name|spans_vccb
modifier|*
name|spans_find_conn
parameter_list|(
name|spp
parameter_list|,
name|p
parameter_list|)
name|struct
name|spans
modifier|*
name|spp
decl_stmt|;
name|struct
name|spans_atm_conn
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|spans_vccb
modifier|*
name|svp
decl_stmt|,
modifier|*
name|svnext
decl_stmt|;
for|for
control|(
name|svp
operator|=
name|Q_HEAD
argument_list|(
name|spp
operator|->
name|sp_vccq
argument_list|,
expr|struct
name|spans_vccb
argument_list|)
init|;
name|svp
condition|;
name|svp
operator|=
name|svnext
control|)
block|{
name|svnext
operator|=
name|Q_NEXT
argument_list|(
name|svp
argument_list|,
expr|struct
name|spans_vccb
argument_list|,
name|sv_sigelem
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bcmp
argument_list|(
name|p
argument_list|,
operator|&
name|svp
operator|->
name|sv_conn
argument_list|,
sizeof|sizeof
argument_list|(
name|spans_atm_conn
argument_list|)
argument_list|)
condition|)
break|break;
block|}
return|return
operator|(
name|svp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a VPI/VCI pair  *  * When we get an open request or indication from the network, we have  * allocate a VPI and VCI for the conection.  This routine will allocate  * a VPI/VCI based on the next available VCI in the SPANS protocol block.  * The VPI/VCI chose must be within the range allowed by the interface and  * must not already be in use.  *  * Currently the Fore ATM interface only supports VPI 0, so this code only  * allocates a VCI.  *  * There's probably a more elegant way to do this.  *  * Arguments:  *	spp	pointer to connection's SPANS protocol instance  *  * Returns:  *	0	no VPI/VCI available  *	vpvc	the VPI/VCI for the connection  *  */
end_comment

begin_function
name|spans_vpvc
name|spans_alloc_vpvc
parameter_list|(
name|spp
parameter_list|)
name|struct
name|spans
modifier|*
name|spp
decl_stmt|;
block|{
name|int
name|vpi
decl_stmt|,
name|vci
decl_stmt|;
comment|/* 	 * Loop through the allowable VCIs, starting with the curent one, 	 * to find one that's not in use. 	 */
while|while
condition|(
name|spp
operator|->
name|sp_alloc_vci
operator|<=
name|spp
operator|->
name|sp_max_vci
condition|)
block|{
name|vpi
operator|=
name|spp
operator|->
name|sp_alloc_vpi
expr_stmt|;
name|vci
operator|=
name|spp
operator|->
name|sp_alloc_vci
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|spans_find_vpvc
argument_list|(
name|spp
argument_list|,
name|vpi
argument_list|,
name|vci
argument_list|,
literal|0
argument_list|)
condition|)
block|{
return|return
operator|(
name|SPANS_PACK_VPIVCI
argument_list|(
name|vpi
argument_list|,
name|vci
argument_list|)
operator|)
return|;
block|}
block|}
comment|/* 	 * Reset the VCI to the minimum 	 */
name|spp
operator|->
name|sp_alloc_vci
operator|=
name|spp
operator|->
name|sp_min_vci
expr_stmt|;
comment|/* 	 * Try looping through again 	 */
while|while
condition|(
name|spp
operator|->
name|sp_alloc_vci
operator|<=
name|spp
operator|->
name|sp_max_vci
condition|)
block|{
name|vpi
operator|=
name|spp
operator|->
name|sp_alloc_vpi
expr_stmt|;
name|vci
operator|=
name|spp
operator|->
name|sp_alloc_vci
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|spans_find_vpvc
argument_list|(
name|spp
argument_list|,
name|vpi
argument_list|,
name|vci
argument_list|,
literal|0
argument_list|)
condition|)
block|{
return|return
operator|(
name|SPANS_PACK_VPIVCI
argument_list|(
name|vpi
argument_list|,
name|vci
argument_list|)
operator|)
return|;
block|}
block|}
comment|/* 	 * All allowable VCIs are in use 	 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Print a SPANS address  *  * Convert a SPANS address into an ASCII string suitable for printing.  *  * Arguments:  *	p	pointer to a struct spans_addr  *  * Returns:  *	the address of a string with the ASCII representation of the  *	address.  *  */
end_comment

begin_function
name|char
modifier|*
name|spans_addr_print
parameter_list|(
name|p
parameter_list|)
name|struct
name|spans_addr
modifier|*
name|p
decl_stmt|;
block|{
specifier|static
name|char
name|strbuff
index|[
literal|80
index|]
decl_stmt|;
union|union
block|{
name|int
name|w
decl_stmt|;
name|char
name|c
index|[
literal|4
index|]
decl_stmt|;
block|}
name|u1
union|,
name|u2
union|;
comment|/* 	 * Clear the returned string 	 */
name|KM_ZERO
argument_list|(
name|strbuff
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuff
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Get address into integers 	 */
name|u1
operator|.
name|c
index|[
literal|0
index|]
operator|=
name|p
operator|->
name|addr
index|[
literal|0
index|]
expr_stmt|;
name|u1
operator|.
name|c
index|[
literal|1
index|]
operator|=
name|p
operator|->
name|addr
index|[
literal|1
index|]
expr_stmt|;
name|u1
operator|.
name|c
index|[
literal|2
index|]
operator|=
name|p
operator|->
name|addr
index|[
literal|2
index|]
expr_stmt|;
name|u1
operator|.
name|c
index|[
literal|3
index|]
operator|=
name|p
operator|->
name|addr
index|[
literal|3
index|]
expr_stmt|;
name|u2
operator|.
name|c
index|[
literal|0
index|]
operator|=
name|p
operator|->
name|addr
index|[
literal|4
index|]
expr_stmt|;
name|u2
operator|.
name|c
index|[
literal|1
index|]
operator|=
name|p
operator|->
name|addr
index|[
literal|5
index|]
expr_stmt|;
name|u2
operator|.
name|c
index|[
literal|2
index|]
operator|=
name|p
operator|->
name|addr
index|[
literal|6
index|]
expr_stmt|;
name|u2
operator|.
name|c
index|[
literal|3
index|]
operator|=
name|p
operator|->
name|addr
index|[
literal|7
index|]
expr_stmt|;
comment|/* 	 * Print and return the string 	 */
name|sprintf
argument_list|(
name|strbuff
argument_list|,
literal|"%lx.%lx"
argument_list|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|u1
operator|.
name|w
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|u2
operator|.
name|w
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|strbuff
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Print a buffer chain  *  * Arguments:  *	m	pointer to a buffer chain  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|spans_dump_buffer
parameter_list|(
name|m
parameter_list|)
name|KBuffer
modifier|*
name|m
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|caddr_t
name|cp
decl_stmt|;
name|printf
argument_list|(
literal|"spans_dump_buffer:\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
name|KB_DATASTART
argument_list|(
name|m
argument_list|,
name|cp
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|KB_LEN
argument_list|(
name|m
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"   bfr=%p: "
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%x "
argument_list|,
operator|(
name|u_char
operator|)
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"<end_bfr>\n"
argument_list|)
expr_stmt|;
name|m
operator|=
name|KB_NEXT
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

