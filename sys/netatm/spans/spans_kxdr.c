begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * ===================================  * HARP  |  Host ATM Research Platform  * ===================================  *  *  * This Host ATM Research Platform ("HARP") file (the "Software") is  * made available by Network Computing Services, Inc. ("NetworkCS")  * "AS IS".  NetworkCS does not provide maintenance, improvements or  * support of any kind.  *  * NETWORKCS MAKES NO WARRANTIES OR REPRESENTATIONS, EXPRESS OR IMPLIED,  * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE, AS TO ANY ELEMENT OF THE  * SOFTWARE OR ANY SUPPORT PROVIDED IN CONNECTION WITH THIS SOFTWARE.  * In no event shall NetworkCS be responsible for any damages, including  * but not limited to consequential damages, arising from or relating to  * any use of the Software or related support.  *  * Copyright 1994-1998 Network Computing Services, Inc.  *  * Copies of this Software may be made, however, the above copyright  * notice must be reproduced on all copies.  *  *	@(#) $FreeBSD$  *  */
end_comment

begin_comment
comment|/*  * SPANS Signalling Manager  * ---------------------------  *  * Kernel XDR (External Data Representation) routines  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<netatm/port.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"@(#) $FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * This file contains code that has been copied and/or modified from  * the following FreeBSD files:  *  *	/usr/src/lib/libc/xdr/xdr.c  *	/usr/src/lib/libc/xdr/xdr_mem.c  *  * which are covered by the copyright notice below.  */
end_comment

begin_comment
comment|/*  * Sun RPC is a product of Sun Microsystems, Inc. and is provided for  * unrestricted use provided that this legend is included on all tape  * media and as a part of the software program in whole or part.  Users  * may copy or modify Sun RPC without charge, but are not authorized  * to license or distribute it to anyone else except as part of a product or  * program developed by the user.  *  * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE  * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR  * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.  *  * Sun RPC is provided with no support and without any obligation on the  * part of Sun Microsystems, Inc. to assist in its use, correction,  * modification or enhancement.  *  * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE  * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC  * OR ANY PART THEREOF.  *  * In no event will Sun Microsystems, Inc. be liable for any lost revenue  * or profits or other special, indirect and consequential damages, even if  * Sun has been advised of the possibility of such damages.  *  * Sun Microsystems, Inc.  * 2550 Garcia Avenue  * Mountain View, California  94043  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LIBC_SCCS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_comment
comment|/*static char *sccsid = "from: @(#)xdr.c 1.35 87/08/12";*/
end_comment

begin_comment
comment|/*static char *sccsid = "from: @(#)xdr.c	2.1 88/07/29 4.0 RPCSRC";*/
end_comment

begin_comment
comment|/*static char *rcsid = "Id: xdr.c,v 1.2.4.2 1996/06/05 02:52:02 jkh Exp";*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * xdr.c, Generic XDR routines implementation.  *  * Copyright (C) 1986, Sun Microsystems, Inc.  *  * These are the "generic" xdr routines used to serialize and de-serialize  * most common data items.  See xdr.h for more info on the interface to  * xdr.  */
end_comment

begin_include
include|#
directive|include
file|<rpc/types.h>
end_include

begin_include
include|#
directive|include
file|<rpc/xdr.h>
end_include

begin_comment
comment|/*  * constants specific to the xdr "protocol"  */
end_comment

begin_define
define|#
directive|define
name|XDR_FALSE
value|((long) 0)
end_define

begin_define
define|#
directive|define
name|XDR_TRUE
value|((long) 1)
end_define

begin_define
define|#
directive|define
name|LASTUNSIGNED
value|((u_int) 0-1)
end_define

begin_comment
comment|/*  * for unit alignment  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|xdr_zero
index|[
name|BYTES_PER_XDR_UNIT
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * XDR integers  */
end_comment

begin_function
name|bool_t
name|xdr_int
parameter_list|(
name|xdrs
parameter_list|,
name|ip
parameter_list|)
name|XDR
modifier|*
name|xdrs
decl_stmt|;
name|int
modifier|*
name|ip
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|lint
call|(
name|void
call|)
argument_list|(
name|xdr_short
argument_list|(
name|xdrs
argument_list|,
operator|(
name|short
operator|*
operator|)
name|ip
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|xdr_long
argument_list|(
name|xdrs
argument_list|,
operator|(
name|long
operator|*
operator|)
name|ip
argument_list|)
operator|)
return|;
else|#
directive|else
if|if
condition|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|)
block|{
return|return
operator|(
name|xdr_long
argument_list|(
name|xdrs
argument_list|,
operator|(
name|long
operator|*
operator|)
name|ip
argument_list|)
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|xdr_short
argument_list|(
name|xdrs
argument_list|,
operator|(
name|short
operator|*
operator|)
name|ip
argument_list|)
operator|)
return|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * XDR unsigned integers  */
end_comment

begin_function
name|bool_t
name|xdr_u_int
parameter_list|(
name|xdrs
parameter_list|,
name|up
parameter_list|)
name|XDR
modifier|*
name|xdrs
decl_stmt|;
name|u_int
modifier|*
name|up
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|lint
call|(
name|void
call|)
argument_list|(
name|xdr_short
argument_list|(
name|xdrs
argument_list|,
operator|(
name|short
operator|*
operator|)
name|up
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|xdr_u_long
argument_list|(
name|xdrs
argument_list|,
operator|(
name|u_long
operator|*
operator|)
name|up
argument_list|)
operator|)
return|;
else|#
directive|else
if|if
condition|(
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
condition|)
block|{
return|return
operator|(
name|xdr_u_long
argument_list|(
name|xdrs
argument_list|,
operator|(
name|u_long
operator|*
operator|)
name|up
argument_list|)
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|xdr_short
argument_list|(
name|xdrs
argument_list|,
operator|(
name|short
operator|*
operator|)
name|up
argument_list|)
operator|)
return|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * XDR long integers  * same as xdr_u_long - open coded to save a proc call!  */
end_comment

begin_function
name|bool_t
name|xdr_long
parameter_list|(
name|xdrs
parameter_list|,
name|lp
parameter_list|)
specifier|register
name|XDR
modifier|*
name|xdrs
decl_stmt|;
name|long
modifier|*
name|lp
decl_stmt|;
block|{
if|if
condition|(
name|xdrs
operator|->
name|x_op
operator|==
name|XDR_ENCODE
condition|)
return|return
operator|(
name|XDR_PUTLONG
argument_list|(
name|xdrs
argument_list|,
name|lp
argument_list|)
operator|)
return|;
if|if
condition|(
name|xdrs
operator|->
name|x_op
operator|==
name|XDR_DECODE
condition|)
return|return
operator|(
name|XDR_GETLONG
argument_list|(
name|xdrs
argument_list|,
name|lp
argument_list|)
operator|)
return|;
if|if
condition|(
name|xdrs
operator|->
name|x_op
operator|==
name|XDR_FREE
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * XDR unsigned long integers  * same as xdr_long - open coded to save a proc call!  */
end_comment

begin_function
name|bool_t
name|xdr_u_long
parameter_list|(
name|xdrs
parameter_list|,
name|ulp
parameter_list|)
specifier|register
name|XDR
modifier|*
name|xdrs
decl_stmt|;
name|u_long
modifier|*
name|ulp
decl_stmt|;
block|{
if|if
condition|(
name|xdrs
operator|->
name|x_op
operator|==
name|XDR_DECODE
condition|)
return|return
operator|(
name|XDR_GETLONG
argument_list|(
name|xdrs
argument_list|,
operator|(
name|long
operator|*
operator|)
name|ulp
argument_list|)
operator|)
return|;
if|if
condition|(
name|xdrs
operator|->
name|x_op
operator|==
name|XDR_ENCODE
condition|)
return|return
operator|(
name|XDR_PUTLONG
argument_list|(
name|xdrs
argument_list|,
operator|(
name|long
operator|*
operator|)
name|ulp
argument_list|)
operator|)
return|;
if|if
condition|(
name|xdrs
operator|->
name|x_op
operator|==
name|XDR_FREE
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * XDR short integers  */
end_comment

begin_function
name|bool_t
name|xdr_short
parameter_list|(
name|xdrs
parameter_list|,
name|sp
parameter_list|)
specifier|register
name|XDR
modifier|*
name|xdrs
decl_stmt|;
name|short
modifier|*
name|sp
decl_stmt|;
block|{
name|long
name|l
decl_stmt|;
switch|switch
condition|(
name|xdrs
operator|->
name|x_op
condition|)
block|{
case|case
name|XDR_ENCODE
case|:
name|l
operator|=
operator|(
name|long
operator|)
operator|*
name|sp
expr_stmt|;
return|return
operator|(
name|XDR_PUTLONG
argument_list|(
name|xdrs
argument_list|,
operator|&
name|l
argument_list|)
operator|)
return|;
case|case
name|XDR_DECODE
case|:
if|if
condition|(
operator|!
name|XDR_GETLONG
argument_list|(
name|xdrs
argument_list|,
operator|&
name|l
argument_list|)
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
operator|*
name|sp
operator|=
operator|(
name|short
operator|)
name|l
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
case|case
name|XDR_FREE
case|:
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * XDR unsigned short integers  */
end_comment

begin_function
name|bool_t
name|xdr_u_short
parameter_list|(
name|xdrs
parameter_list|,
name|usp
parameter_list|)
specifier|register
name|XDR
modifier|*
name|xdrs
decl_stmt|;
name|u_short
modifier|*
name|usp
decl_stmt|;
block|{
name|u_long
name|l
decl_stmt|;
switch|switch
condition|(
name|xdrs
operator|->
name|x_op
condition|)
block|{
case|case
name|XDR_ENCODE
case|:
name|l
operator|=
operator|(
name|u_long
operator|)
operator|*
name|usp
expr_stmt|;
return|return
operator|(
name|XDR_PUTLONG
argument_list|(
name|xdrs
argument_list|,
operator|&
name|l
argument_list|)
operator|)
return|;
case|case
name|XDR_DECODE
case|:
if|if
condition|(
operator|!
name|XDR_GETLONG
argument_list|(
name|xdrs
argument_list|,
operator|&
name|l
argument_list|)
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
operator|*
name|usp
operator|=
operator|(
name|u_short
operator|)
name|l
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
case|case
name|XDR_FREE
case|:
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * XDR a char  */
end_comment

begin_function
name|bool_t
name|xdr_char
parameter_list|(
name|xdrs
parameter_list|,
name|cp
parameter_list|)
name|XDR
modifier|*
name|xdrs
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
operator|(
operator|*
name|cp
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|xdr_int
argument_list|(
name|xdrs
argument_list|,
operator|&
name|i
argument_list|)
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
operator|*
name|cp
operator|=
name|i
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * XDR an unsigned char  */
end_comment

begin_function
name|bool_t
name|xdr_u_char
parameter_list|(
name|xdrs
parameter_list|,
name|cp
parameter_list|)
name|XDR
modifier|*
name|xdrs
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|;
block|{
name|u_int
name|u
decl_stmt|;
name|u
operator|=
operator|(
operator|*
name|cp
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|xdr_u_int
argument_list|(
name|xdrs
argument_list|,
operator|&
name|u
argument_list|)
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
operator|*
name|cp
operator|=
name|u
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * XDR booleans  */
end_comment

begin_function
name|bool_t
name|xdr_bool
parameter_list|(
name|xdrs
parameter_list|,
name|bp
parameter_list|)
specifier|register
name|XDR
modifier|*
name|xdrs
decl_stmt|;
name|bool_t
modifier|*
name|bp
decl_stmt|;
block|{
name|long
name|lb
decl_stmt|;
switch|switch
condition|(
name|xdrs
operator|->
name|x_op
condition|)
block|{
case|case
name|XDR_ENCODE
case|:
name|lb
operator|=
operator|*
name|bp
condition|?
name|XDR_TRUE
else|:
name|XDR_FALSE
expr_stmt|;
return|return
operator|(
name|XDR_PUTLONG
argument_list|(
name|xdrs
argument_list|,
operator|&
name|lb
argument_list|)
operator|)
return|;
case|case
name|XDR_DECODE
case|:
if|if
condition|(
operator|!
name|XDR_GETLONG
argument_list|(
name|xdrs
argument_list|,
operator|&
name|lb
argument_list|)
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
operator|*
name|bp
operator|=
operator|(
name|lb
operator|==
name|XDR_FALSE
operator|)
condition|?
name|FALSE
else|:
name|TRUE
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
case|case
name|XDR_FREE
case|:
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * XDR enumerations  */
end_comment

begin_function
name|bool_t
name|xdr_enum
parameter_list|(
name|xdrs
parameter_list|,
name|ep
parameter_list|)
name|XDR
modifier|*
name|xdrs
decl_stmt|;
name|enum_t
modifier|*
name|ep
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|lint
enum|enum
name|sizecheck
block|{
name|SIZEVAL
block|}
enum|;
comment|/* used to find the size of an enum */
comment|/* 	 * enums are treated as ints 	 */
if|if
condition|(
sizeof|sizeof
argument_list|(
expr|enum
name|sizecheck
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|)
block|{
return|return
operator|(
name|xdr_long
argument_list|(
name|xdrs
argument_list|,
operator|(
name|long
operator|*
operator|)
name|ep
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
sizeof|sizeof
argument_list|(
expr|enum
name|sizecheck
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|short
argument_list|)
condition|)
block|{
return|return
operator|(
name|xdr_short
argument_list|(
name|xdrs
argument_list|,
operator|(
name|short
operator|*
operator|)
name|ep
argument_list|)
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
else|#
directive|else
call|(
name|void
call|)
argument_list|(
name|xdr_short
argument_list|(
name|xdrs
argument_list|,
operator|(
name|short
operator|*
operator|)
name|ep
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|xdr_long
argument_list|(
name|xdrs
argument_list|,
operator|(
name|long
operator|*
operator|)
name|ep
argument_list|)
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * XDR opaque data  * Allows the specification of a fixed size sequence of opaque bytes.  * cp points to the opaque object and cnt gives the byte length.  */
end_comment

begin_function
name|bool_t
name|xdr_opaque
parameter_list|(
name|xdrs
parameter_list|,
name|cp
parameter_list|,
name|cnt
parameter_list|)
specifier|register
name|XDR
modifier|*
name|xdrs
decl_stmt|;
name|caddr_t
name|cp
decl_stmt|;
specifier|register
name|u_int
name|cnt
decl_stmt|;
block|{
specifier|register
name|u_int
name|rndup
decl_stmt|;
specifier|static
name|char
name|crud
index|[
name|BYTES_PER_XDR_UNIT
index|]
decl_stmt|;
comment|/* 	 * if no data we are done 	 */
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
comment|/* 	 * round byte count to full xdr units 	 */
name|rndup
operator|=
name|cnt
operator|%
name|BYTES_PER_XDR_UNIT
expr_stmt|;
if|if
condition|(
name|rndup
operator|>
literal|0
condition|)
name|rndup
operator|=
name|BYTES_PER_XDR_UNIT
operator|-
name|rndup
expr_stmt|;
if|if
condition|(
name|xdrs
operator|->
name|x_op
operator|==
name|XDR_DECODE
condition|)
block|{
if|if
condition|(
operator|!
name|XDR_GETBYTES
argument_list|(
name|xdrs
argument_list|,
name|cp
argument_list|,
name|cnt
argument_list|)
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|rndup
operator|==
literal|0
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
return|return
operator|(
name|XDR_GETBYTES
argument_list|(
name|xdrs
argument_list|,
name|crud
argument_list|,
name|rndup
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|xdrs
operator|->
name|x_op
operator|==
name|XDR_ENCODE
condition|)
block|{
if|if
condition|(
operator|!
name|XDR_PUTBYTES
argument_list|(
name|xdrs
argument_list|,
name|cp
argument_list|,
name|cnt
argument_list|)
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|rndup
operator|==
literal|0
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
return|return
operator|(
name|XDR_PUTBYTES
argument_list|(
name|xdrs
argument_list|,
name|xdr_zero
argument_list|,
name|rndup
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|xdrs
operator|->
name|x_op
operator|==
name|XDR_FREE
condition|)
block|{
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * XDR implementation using kernel buffers  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LIBC_SCCS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_comment
comment|/*static char *sccsid = "from: @(#)xdr_mem.c 1.19 87/08/11 Copyr 1984 Sun Micro";*/
end_comment

begin_comment
comment|/*static char *sccsid = "from: @(#)xdr_mem.c	2.1 88/07/29 4.0 RPCSRC";*/
end_comment

begin_comment
comment|/*static char *rcsid = "Id: xdr_mem.c,v 1.2.4.2 1996/06/05 02:52:04 jkh Exp";*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * xdr_mem.h, XDR implementation using memory buffers.  *  * Copyright (C) 1984, Sun Microsystems, Inc.  *  * If you have some data to be interpreted as external data representation  * or to be converted to external data representation in a memory buffer,  * then this is the package for you.  *  */
end_comment

begin_function_decl
name|void
name|xdrmbuf_init
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|KBuffer
modifier|*
parameter_list|,
name|enum
name|xdr_op
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool_t
name|xdrmbuf_getlong
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|long
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool_t
name|xdrmbuf_putlong
parameter_list|(
name|XDR
modifier|*
parameter_list|,
specifier|const
name|long
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool_t
name|xdrmbuf_getbytes
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool_t
name|xdrmbuf_putbytes
parameter_list|(
name|XDR
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|xdrmbuf_getpos
parameter_list|(
name|XDR
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|xdr_ops
name|xdrmbuf_ops
init|=
block|{
name|xdrmbuf_getlong
block|,
name|xdrmbuf_putlong
block|,
name|xdrmbuf_getbytes
block|,
name|xdrmbuf_putbytes
block|,
name|xdrmbuf_getpos
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The procedure xdrmbuf_init initializes a stream descriptor for a  * kernel buffer.  */
end_comment

begin_function
name|void
name|xdrmbuf_init
parameter_list|(
name|xdrs
parameter_list|,
name|m
parameter_list|,
name|op
parameter_list|)
specifier|register
name|XDR
modifier|*
name|xdrs
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|enum
name|xdr_op
name|op
decl_stmt|;
block|{
name|xdrs
operator|->
name|x_op
operator|=
name|op
expr_stmt|;
name|xdrs
operator|->
name|x_ops
operator|=
operator|&
name|xdrmbuf_ops
expr_stmt|;
name|xdrs
operator|->
name|x_base
operator|=
operator|(
name|caddr_t
operator|)
name|m
expr_stmt|;
name|KB_DATASTART
argument_list|(
name|m
argument_list|,
name|xdrs
operator|->
name|x_private
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|xdrs
operator|->
name|x_handy
operator|=
name|KB_LEN
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool_t
name|xdrmbuf_getlong
parameter_list|(
name|xdrs
parameter_list|,
name|lp
parameter_list|)
specifier|register
name|XDR
modifier|*
name|xdrs
decl_stmt|;
name|long
modifier|*
name|lp
decl_stmt|;
block|{
comment|/* 	 * See if long is contained in this buffer 	 */
if|if
condition|(
operator|(
name|xdrs
operator|->
name|x_handy
operator|-=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
specifier|register
name|KBuffer
modifier|*
name|m
decl_stmt|;
comment|/* 		 * We (currently) don't allow a long to span a buffer 		 */
if|if
condition|(
name|xdrs
operator|->
name|x_handy
operator|!=
operator|-
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"xdrmbuf_getlong: data spans buffers\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* 		 * Try to move to a chained buffer 		 */
if|if
condition|(
operator|(
name|m
operator|=
operator|(
name|KBuffer
operator|*
operator|)
operator|(
name|xdrs
operator|->
name|x_base
operator|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|m
operator|=
name|KB_NEXT
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|xdrs
operator|->
name|x_base
operator|=
operator|(
name|caddr_t
operator|)
name|m
expr_stmt|;
block|}
if|if
condition|(
name|m
condition|)
block|{
comment|/* 			 * Setup new buffer's info 			 */
name|KB_DATASTART
argument_list|(
name|m
argument_list|,
name|xdrs
operator|->
name|x_private
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|xdrs
operator|->
name|x_handy
operator|=
name|KB_LEN
argument_list|(
name|m
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"xdrmbuf_getlong: short buffer\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* 			 * No more buffers 			 */
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
comment|/* 	 * Return the long value 	 */
operator|*
name|lp
operator|=
operator|(
name|long
operator|)
name|ntohl
argument_list|(
call|(
name|u_long
call|)
argument_list|(
operator|*
operator|(
operator|(
name|long
operator|*
operator|)
operator|(
name|xdrs
operator|->
name|x_private
operator|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Advance the data stream 	 */
operator|(
operator|(
name|long
operator|*
operator|)
name|xdrs
operator|->
name|x_private
operator|)
operator|++
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool_t
name|xdrmbuf_putlong
parameter_list|(
name|xdrs
parameter_list|,
name|lp
parameter_list|)
specifier|register
name|XDR
modifier|*
name|xdrs
decl_stmt|;
specifier|const
name|long
modifier|*
name|lp
decl_stmt|;
block|{
comment|/* 	 * See if long will fit in this buffer 	 */
if|if
condition|(
operator|(
name|xdrs
operator|->
name|x_handy
operator|-=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
specifier|register
name|KBuffer
modifier|*
name|m
decl_stmt|;
comment|/* 		 * We (currently) don't allow a long to span a buffer 		 */
if|if
condition|(
name|xdrs
operator|->
name|x_handy
operator|!=
operator|-
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"xdrmbuf_putlong: data spans buffers\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* 		 * Try to move to a chained buffer 		 */
if|if
condition|(
operator|(
name|m
operator|=
operator|(
name|KBuffer
operator|*
operator|)
operator|(
name|xdrs
operator|->
name|x_base
operator|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|m
operator|=
name|KB_NEXT
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|xdrs
operator|->
name|x_base
operator|=
operator|(
name|caddr_t
operator|)
name|m
expr_stmt|;
block|}
if|if
condition|(
name|m
condition|)
block|{
comment|/* 			 * Setup new buffer's info 			 */
name|KB_DATASTART
argument_list|(
name|m
argument_list|,
name|xdrs
operator|->
name|x_private
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|xdrs
operator|->
name|x_handy
operator|=
name|KB_LEN
argument_list|(
name|m
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"xdrmbuf_putlong: short buffer\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* 			 * No more buffers 			 */
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
comment|/* 	 * Store the long value into our buffer 	 */
operator|*
operator|(
name|long
operator|*
operator|)
name|xdrs
operator|->
name|x_private
operator|=
operator|(
name|long
operator|)
name|htonl
argument_list|(
call|(
name|u_long
call|)
argument_list|(
operator|*
name|lp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Advance the data stream 	 */
operator|(
operator|(
name|long
operator|*
operator|)
name|xdrs
operator|->
name|x_private
operator|)
operator|++
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool_t
name|xdrmbuf_getbytes
parameter_list|(
name|xdrs
parameter_list|,
name|addr
parameter_list|,
name|len
parameter_list|)
specifier|register
name|XDR
modifier|*
name|xdrs
decl_stmt|;
name|caddr_t
name|addr
decl_stmt|;
specifier|register
name|u_int
name|len
decl_stmt|;
block|{
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|u_int
name|copy
decl_stmt|;
if|if
condition|(
name|xdrs
operator|->
name|x_handy
operator|<=
literal|0
condition|)
block|{
specifier|register
name|KBuffer
modifier|*
name|m
decl_stmt|;
comment|/* 			 * No data in current buffer, move to a chained buffer 			 */
if|if
condition|(
operator|(
name|m
operator|=
operator|(
name|KBuffer
operator|*
operator|)
operator|(
name|xdrs
operator|->
name|x_base
operator|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|m
operator|=
name|KB_NEXT
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|xdrs
operator|->
name|x_base
operator|=
operator|(
name|caddr_t
operator|)
name|m
expr_stmt|;
block|}
if|if
condition|(
name|m
condition|)
block|{
comment|/* 				 * Setup new buffer's info 				 */
name|KB_DATASTART
argument_list|(
name|m
argument_list|,
name|xdrs
operator|->
name|x_private
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|xdrs
operator|->
name|x_handy
operator|=
name|KB_LEN
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * No more buffers 				 */
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
comment|/* 		 * Copy from buffer to user's space 		 */
name|copy
operator|=
name|MIN
argument_list|(
name|len
argument_list|,
name|xdrs
operator|->
name|x_handy
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|xdrs
operator|->
name|x_private
argument_list|,
name|addr
argument_list|,
name|copy
argument_list|)
expr_stmt|;
comment|/* 		 * Update data stream controls 		 */
operator|(
operator|(
name|char
operator|*
operator|)
name|xdrs
operator|->
name|x_private
operator|)
operator|+=
name|copy
expr_stmt|;
name|xdrs
operator|->
name|x_handy
operator|-=
name|copy
expr_stmt|;
name|addr
operator|+=
name|copy
expr_stmt|;
name|len
operator|-=
name|copy
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool_t
name|xdrmbuf_putbytes
parameter_list|(
name|xdrs
parameter_list|,
name|addr
parameter_list|,
name|len
parameter_list|)
specifier|register
name|XDR
modifier|*
name|xdrs
decl_stmt|;
specifier|const
name|char
modifier|*
name|addr
decl_stmt|;
specifier|register
name|u_int
name|len
decl_stmt|;
block|{
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|u_int
name|copy
decl_stmt|;
if|if
condition|(
name|xdrs
operator|->
name|x_handy
operator|<=
literal|0
condition|)
block|{
specifier|register
name|KBuffer
modifier|*
name|m
decl_stmt|;
comment|/* 			 * No data in current buffer, move to a chained buffer 			 */
if|if
condition|(
operator|(
name|m
operator|=
operator|(
name|KBuffer
operator|*
operator|)
operator|(
name|xdrs
operator|->
name|x_base
operator|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|m
operator|=
name|KB_NEXT
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|xdrs
operator|->
name|x_base
operator|=
operator|(
name|caddr_t
operator|)
name|m
expr_stmt|;
block|}
if|if
condition|(
name|m
condition|)
block|{
comment|/* 				 * Setup new buffer's info 				 */
name|KB_DATASTART
argument_list|(
name|m
argument_list|,
name|xdrs
operator|->
name|x_private
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|xdrs
operator|->
name|x_handy
operator|=
name|KB_LEN
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * No more buffers 				 */
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
comment|/* 		 * Copy from user's space into buffer 		 */
name|copy
operator|=
name|MIN
argument_list|(
name|len
argument_list|,
name|xdrs
operator|->
name|x_handy
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|addr
argument_list|,
name|xdrs
operator|->
name|x_private
argument_list|,
name|copy
argument_list|)
expr_stmt|;
comment|/* 		 * Update data stream controls 		 */
operator|(
operator|(
name|char
operator|*
operator|)
name|xdrs
operator|->
name|x_private
operator|)
operator|++
expr_stmt|;
name|xdrs
operator|->
name|x_handy
operator|-=
name|copy
expr_stmt|;
name|addr
operator|+=
name|copy
expr_stmt|;
name|len
operator|-=
name|copy
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|xdrmbuf_getpos
parameter_list|(
name|xdrs
parameter_list|)
specifier|register
name|XDR
modifier|*
name|xdrs
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|u_int
operator|)
name|xdrs
operator|->
name|x_private
operator|-
operator|(
name|u_int
operator|)
name|xdrs
operator|->
name|x_base
operator|)
return|;
block|}
end_function

end_unit

