begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * ===================================  * HARP  |  Host ATM Research Platform  * ===================================  *  *  * This Host ATM Research Platform ("HARP") file (the "Software") is  * made available by Network Computing Services, Inc. ("NetworkCS")  * "AS IS".  NetworkCS does not provide maintenance, improvements or  * support of any kind.  *  * NETWORKCS MAKES NO WARRANTIES OR REPRESENTATIONS, EXPRESS OR IMPLIED,  * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE, AS TO ANY ELEMENT OF THE  * SOFTWARE OR ANY SUPPORT PROVIDED IN CONNECTION WITH THIS SOFTWARE.  * In no event shall NetworkCS be responsible for any damages, including  * but not limited to consequential damages, arising from or relating to  * any use of the Software or related support.  *  * Copyright 1994-1998 Network Computing Services, Inc.  *  * Copies of this Software may be made, however, the above copyright  * notice must be reproduced on all copies.  *  *	@(#) $FreeBSD$  *  */
end_comment

begin_comment
comment|/*  * SPANS Signalling Manager  * ---------------------------  *  * SPANS CLS - ARP support  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<netatm/port.h>
end_include

begin_include
include|#
directive|include
file|<netatm/queue.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sys.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sap.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_cm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_if.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_vc.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sigmgr.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_stack.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_var.h>
end_include

begin_include
include|#
directive|include
file|<netatm/ipatm/ipatm_var.h>
end_include

begin_include
include|#
directive|include
file|<netatm/ipatm/ipatm_serv.h>
end_include

begin_include
include|#
directive|include
file|"spans_xdr.h"
end_include

begin_include
include|#
directive|include
file|<netatm/spans/spans_var.h>
end_include

begin_include
include|#
directive|include
file|<netatm/spans/spans_cls.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"@(#) $FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Global variables  */
end_comment

begin_decl_stmt
name|struct
name|spansarp
modifier|*
name|spansarp_arptab
index|[
name|SPANSARP_HASHSIZ
index|]
init|=
block|{
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Local functions  */
end_comment

begin_function_decl
specifier|static
name|int
name|spansarp_request
parameter_list|(
name|struct
name|spansarp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|spansarp_aging
parameter_list|(
name|struct
name|atm_time
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|spansarp_retry
parameter_list|(
name|struct
name|atm_time
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Local variables  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|atm_time
name|spansarp_timer
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Aging timer */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|atm_time
name|spansarp_rtimer
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Retry timer */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|spansarp
modifier|*
name|spansarp_retry_head
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Retry chain */
end_comment

begin_decl_stmt
specifier|static
name|uma_zone_t
name|spansarp_zone
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Process a new outgoing SVC requiring SPANS ARP support  *   * This function is called by an endpoint wishing to resolve a destination   * IP address to an ATM address in order to open an SVC to that destination.  * If a valid mapping is already in our cache, then we just tell the caller  * about it and that's that.  Otherwise, we have to allocate a new arp entry  * and issue a query for the mapping.  *  * Arguments:  *	ivp	pointer to SVC's IPVCC control block  *	dst	pointer to destination IP address  *  * Returns:  *	MAP_VALID	- Got the answer, returned via iv_arpent field.  *	MAP_PROCEEDING	- OK so far, querying for peer's mapping  *	MAP_FAILED	- error, unable to allocate resources  *  */
end_comment

begin_function
name|int
name|spansarp_svcout
parameter_list|(
name|ivp
parameter_list|,
name|dst
parameter_list|)
name|struct
name|ipvcc
modifier|*
name|ivp
decl_stmt|;
name|struct
name|in_addr
modifier|*
name|dst
decl_stmt|;
block|{
name|struct
name|spanscls
modifier|*
name|clp
decl_stmt|;
name|struct
name|spansarp
modifier|*
name|sap
decl_stmt|;
name|int
name|s
decl_stmt|;
name|ivp
operator|->
name|iv_arpent
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Lookup destination address 	 */
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|SPANSARP_LOOKUP
argument_list|(
name|dst
operator|->
name|s_addr
argument_list|,
name|sap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sap
condition|)
block|{
comment|/* 		 * Link this vcc to entry queue 		 */
name|LINK2TAIL
argument_list|(
name|ivp
argument_list|,
expr|struct
name|ipvcc
argument_list|,
name|sap
operator|->
name|sa_ivp
argument_list|,
name|iv_arpnext
argument_list|)
expr_stmt|;
comment|/* 		 * If entry is valid, we're done 		 */
if|if
condition|(
name|sap
operator|->
name|sa_flags
operator|&
name|SAF_VALID
condition|)
block|{
name|ivp
operator|->
name|iv_arpent
operator|=
operator|(
expr|struct
name|arpmap
operator|*
operator|)
name|sap
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|MAP_VALID
operator|)
return|;
block|}
comment|/* 		 * We're already looking for this address 		 */
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|MAP_PROCEEDING
operator|)
return|;
block|}
comment|/* 	 * Need a new arp entry - first, find the cls instance 	 * corresponding to the requestor's IP interface. 	 */
for|for
control|(
name|clp
operator|=
name|spanscls_head
init|;
name|clp
condition|;
name|clp
operator|=
name|clp
operator|->
name|cls_next
control|)
block|{
if|if
condition|(
name|clp
operator|->
name|cls_ipnif
operator|==
name|ivp
operator|->
name|iv_ipnif
condition|)
break|break;
block|}
if|if
condition|(
name|clp
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|MAP_FAILED
operator|)
return|;
block|}
comment|/* 	 * Now get the new arp entry 	 */
name|sap
operator|=
name|uma_zalloc
argument_list|(
name|spansarp_zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|sap
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|MAP_FAILED
operator|)
return|;
block|}
comment|/* 	 * Get entry set up 	 */
name|sap
operator|->
name|sa_dstip
operator|.
name|s_addr
operator|=
name|dst
operator|->
name|s_addr
expr_stmt|;
name|sap
operator|->
name|sa_dstatm
operator|.
name|address_format
operator|=
name|T_ATM_ABSENT
expr_stmt|;
name|sap
operator|->
name|sa_dstatm
operator|.
name|address_length
operator|=
literal|0
expr_stmt|;
name|sap
operator|->
name|sa_dstatmsub
operator|.
name|address_format
operator|=
name|T_ATM_ABSENT
expr_stmt|;
name|sap
operator|->
name|sa_dstatmsub
operator|.
name|address_length
operator|=
literal|0
expr_stmt|;
name|sap
operator|->
name|sa_cls
operator|=
name|clp
expr_stmt|;
name|sap
operator|->
name|sa_origin
operator|=
name|SAO_LOOKUP
expr_stmt|;
comment|/* 	 * Link ipvcc to arp entry for later notification 	 */
name|LINK2TAIL
argument_list|(
name|ivp
argument_list|,
expr|struct
name|ipvcc
argument_list|,
name|sap
operator|->
name|sa_ivp
argument_list|,
name|iv_arpnext
argument_list|)
expr_stmt|;
comment|/* 	 * Add arp entry to table 	 */
name|SPANSARP_ADD
argument_list|(
name|sap
argument_list|)
expr_stmt|;
comment|/* 	 * Add arp entry to retry list and start retry timer if needed 	 */
name|LINK2TAIL
argument_list|(
name|sap
argument_list|,
expr|struct
name|spansarp
argument_list|,
name|spansarp_retry_head
argument_list|,
name|sa_rnext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|spansarp_rtimer
operator|.
name|ti_flag
operator|&
name|TIF_QUEUED
operator|)
operator|==
literal|0
condition|)
name|atm_timeout
argument_list|(
operator|&
name|spansarp_rtimer
argument_list|,
name|SPANSARP_RETRY
argument_list|,
name|spansarp_retry
argument_list|)
expr_stmt|;
comment|/* 	 * Issue arp request for this address 	 */
operator|(
name|void
operator|)
name|spansarp_request
argument_list|(
name|sap
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|MAP_PROCEEDING
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process a new incoming SVC requiring SPANS ARP support  *   * This function is called by an endpoint wishing to resolve a destination   * ATM address to its IP address for an incoming call in order to allow a  * bi-directional flow of IP packets on the SVC.  *  * SPANS ARP does not provide reverse mapping facilities and only supports  * uni-directional SVCs.  Thus, we lie a little to IP and always return a  * MAP_PROCEEDING indication, but we will never later notify IP of a   * MAP_VALID condition.  *  * Arguments:  *	ivp	pointer to SVC's IPVCC control block  *	dst	pointer to destination ATM address  *	dstsub	pointer to destination ATM subaddress  *  * Returns:  *	MAP_VALID	- Got the answer, returned via iv_arpent field.  *	MAP_PROCEEDING	- OK so far, querying for peer's mapping  *	MAP_FAILED	- error, unable to allocate resources  *  */
end_comment

begin_function
name|int
name|spansarp_svcin
parameter_list|(
name|ivp
parameter_list|,
name|dst
parameter_list|,
name|dstsub
parameter_list|)
name|struct
name|ipvcc
modifier|*
name|ivp
decl_stmt|;
name|Atm_addr
modifier|*
name|dst
decl_stmt|;
name|Atm_addr
modifier|*
name|dstsub
decl_stmt|;
block|{
comment|/* 	 * Clear ARP entry field 	 */
name|ivp
operator|->
name|iv_arpent
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|MAP_PROCEEDING
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * SPANS ARP SVC activation notification  *   * This function is called when a previously opened SVC has successfully  * been connected.  *  * Arguments:  *	ivp	pointer to SVC's IPVCC control block  *  * Returns:  *	0	activation processing successful  *	errno	activation failed - reason indicated  *  */
end_comment

begin_function
name|int
name|spansarp_svcactive
parameter_list|(
name|ivp
parameter_list|)
name|struct
name|ipvcc
modifier|*
name|ivp
decl_stmt|;
block|{
name|struct
name|spansarp
modifier|*
name|sap
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
comment|/*  	 * Find an entry for the destination address 	 */
name|SPANSARP_LOOKUP
argument_list|(
name|ivp
operator|->
name|iv_dst
operator|.
name|s_addr
argument_list|,
name|sap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sap
condition|)
block|{
comment|/* 		 * IP is finished with entry, so remove IP VCC from chain 		 */
name|UNLINK
argument_list|(
name|ivp
argument_list|,
expr|struct
name|ipvcc
argument_list|,
name|sap
operator|->
name|sa_ivp
argument_list|,
name|iv_arpnext
argument_list|)
expr_stmt|;
name|ivp
operator|->
name|iv_arpent
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * This seems like a reasonable reason to refresh the entry 		 */
name|sap
operator|->
name|sa_reftime
operator|=
literal|0
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * SPANS ARP supported VCC is closing  *   * This function is called just prior to a user closing a VCC which   * supports SPANS ARP.  We'll sever our links to the VCC and then  * figure out how much more cleanup we need to do for now.  *  * Arguments:  *	ivp	pointer to VCC's IPVCC control block  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|spansarp_vcclose
parameter_list|(
name|ivp
parameter_list|)
name|struct
name|ipvcc
modifier|*
name|ivp
decl_stmt|;
block|{
name|struct
name|spansarp
modifier|*
name|sap
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
comment|/* 	 * Get spansarp entry 	 */
name|SPANSARP_LOOKUP
argument_list|(
name|ivp
operator|->
name|iv_dst
operator|.
name|s_addr
argument_list|,
name|sap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sap
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Remove IP VCC from chain 	 */
name|UNLINK
argument_list|(
name|ivp
argument_list|,
expr|struct
name|ipvcc
argument_list|,
name|sap
operator|->
name|sa_ivp
argument_list|,
name|iv_arpnext
argument_list|)
expr_stmt|;
name|ivp
operator|->
name|iv_arpent
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * If entry is currently valid or in use, not much else for us to do 	 */
if|if
condition|(
operator|(
name|sap
operator|->
name|sa_flags
operator|&
operator|(
name|SAF_VALID
operator||
name|SAF_LOCKED
operator|)
operator|)
operator|||
operator|(
name|sap
operator|->
name|sa_origin
operator|>=
name|SAO_PERM
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If there are still other VCCs waiting, exit 	 */
if|if
condition|(
name|sap
operator|->
name|sa_ivp
condition|)
block|{
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Noone else waiting, so remove entry from the retry chain 	 */
name|UNLINK
argument_list|(
name|sap
argument_list|,
expr|struct
name|spansarp
argument_list|,
name|spansarp_retry_head
argument_list|,
name|sa_rnext
argument_list|)
expr_stmt|;
comment|/* 	 * Free entry 	 */
name|SPANSARP_DELETE
argument_list|(
name|sap
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|spansarp_zone
argument_list|,
name|sap
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called when the spans module is loaded.  */
end_comment

begin_function
name|void
name|spansarp_start
parameter_list|()
block|{
name|spansarp_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"spansarp"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|spansarp
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|uma_zone_set_max
argument_list|(
name|spansarp_zone
argument_list|,
literal|100
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process module unloading notification  *   * Called whenever the spans module is about to be unloaded.  All signalling  * instances will have been previously detached.  All spansarp resources   * must be freed now.  *  * Arguments:  *	none  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|spansarp_stop
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
comment|/*  	 * Make sure the arp table is empty 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SPANSARP_HASHSIZ
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|spansarp_arptab
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|panic
argument_list|(
literal|"spansarp_stop: arp table not empty"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Cancel timers 	 */
operator|(
name|void
operator|)
name|atm_untimeout
argument_list|(
operator|&
name|spansarp_timer
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|atm_untimeout
argument_list|(
operator|&
name|spansarp_rtimer
argument_list|)
expr_stmt|;
comment|/* 	 * Free our storage pools 	 */
name|uma_zdestroy
argument_list|(
name|spansarp_zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process IP Network Interface Activation  *   * Called whenever an IP network interface becomes active.  *  * Called at splnet.  *  * Arguments:  *      clp     pointer to CLS interface  *  * Returns:  *      none  *  */
end_comment

begin_function
name|void
name|spansarp_ipact
parameter_list|(
name|clp
parameter_list|)
name|struct
name|spanscls
modifier|*
name|clp
decl_stmt|;
block|{
comment|/* 	 * Make sure aging timer is running 	 */
if|if
condition|(
operator|(
name|spansarp_timer
operator|.
name|ti_flag
operator|&
name|TIF_QUEUED
operator|)
operator|==
literal|0
condition|)
name|atm_timeout
argument_list|(
operator|&
name|spansarp_timer
argument_list|,
name|SPANSARP_AGING
argument_list|,
name|spansarp_aging
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process IP Network Interface Deactivation  *   * Called whenever an IP network interface becomes inactive.  *  * Called at splnet.  *  * Arguments:  *      clp     pointer to CLS interface  *  * Returns:  *      none  *  */
end_comment

begin_function
name|void
name|spansarp_ipdact
parameter_list|(
name|clp
parameter_list|)
name|struct
name|spanscls
modifier|*
name|clp
decl_stmt|;
block|{
name|struct
name|spanscls
modifier|*
name|clp2
decl_stmt|;
name|struct
name|spansarp
modifier|*
name|sap
decl_stmt|,
modifier|*
name|snext
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/*  	 * Delete all interface entries 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SPANSARP_HASHSIZ
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|sap
operator|=
name|spansarp_arptab
index|[
name|i
index|]
init|;
name|sap
condition|;
name|sap
operator|=
name|snext
control|)
block|{
name|snext
operator|=
name|sap
operator|->
name|sa_next
expr_stmt|;
comment|/* 			 * Clean up entries for this interface 			 */
if|if
condition|(
name|sap
operator|->
name|sa_cls
operator|!=
name|clp
condition|)
continue|continue;
comment|/* 			 * All VCCs better be gone by now 			 */
if|if
condition|(
name|sap
operator|->
name|sa_ivp
condition|)
name|panic
argument_list|(
literal|"spansarp_ipdact: entry not empty"
argument_list|)
expr_stmt|;
comment|/* 			 * Remove entry from the retry chain 			 */
name|UNLINK
argument_list|(
name|sap
argument_list|,
expr|struct
name|spansarp
argument_list|,
name|spansarp_retry_head
argument_list|,
name|sa_rnext
argument_list|)
expr_stmt|;
comment|/* 			 * Delete entry from arp table 			 */
name|SPANSARP_DELETE
argument_list|(
name|sap
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|spansarp_zone
argument_list|,
name|sap
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Stop aging timer if this is the last active interface 	 */
for|for
control|(
name|clp2
operator|=
name|spanscls_head
init|;
name|clp2
condition|;
name|clp2
operator|=
name|clp2
operator|->
name|cls_next
control|)
block|{
if|if
condition|(
operator|(
name|clp
operator|!=
name|clp2
operator|)
operator|&&
operator|(
name|clp2
operator|->
name|cls_ipnif
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|clp2
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|atm_untimeout
argument_list|(
operator|&
name|spansarp_timer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Issue a SPANS ARP request packet  *   * Arguments:  *	sap	pointer to arp table entry  *  * Returns:  *	0	packet was successfully sent  *	else	unable to send packet  *  */
end_comment

begin_function
specifier|static
name|int
name|spansarp_request
parameter_list|(
name|sap
parameter_list|)
name|struct
name|spansarp
modifier|*
name|sap
decl_stmt|;
block|{
name|struct
name|spanscls
modifier|*
name|clp
decl_stmt|;
name|struct
name|spans
modifier|*
name|spp
decl_stmt|;
name|struct
name|spanscls_hdr
modifier|*
name|chp
decl_stmt|;
name|struct
name|spansarp_hdr
modifier|*
name|ahp
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|struct
name|ip_nif
modifier|*
name|inp
decl_stmt|;
name|int
name|err
decl_stmt|;
name|clp
operator|=
name|sap
operator|->
name|sa_cls
expr_stmt|;
name|spp
operator|=
name|clp
operator|->
name|cls_spans
expr_stmt|;
name|inp
operator|=
name|clp
operator|->
name|cls_ipnif
expr_stmt|;
comment|/* 	 * Make sure CLS VCC is open and that we know our addresses 	 */
if|if
condition|(
name|clp
operator|->
name|cls_state
operator|!=
name|CLS_OPEN
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|spp
operator|->
name|sp_addr
operator|.
name|address_format
operator|!=
name|T_ATM_SPANS_ADDR
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * Get a buffer for pdu 	 */
name|KB_ALLOCPKT
argument_list|(
name|m
argument_list|,
name|ARP_PACKET_LEN
argument_list|,
name|KB_F_NOWAIT
argument_list|,
name|KB_T_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * Place pdu at end of buffer 	 */
name|KB_PLENSET
argument_list|(
name|m
argument_list|,
name|ARP_PACKET_LEN
argument_list|)
expr_stmt|;
name|KB_TAILALIGN
argument_list|(
name|m
argument_list|,
name|ARP_PACKET_LEN
argument_list|)
expr_stmt|;
name|KB_DATASTART
argument_list|(
name|m
argument_list|,
name|chp
argument_list|,
expr|struct
name|spanscls_hdr
operator|*
argument_list|)
expr_stmt|;
name|ahp
operator|=
operator|(
expr|struct
name|spansarp_hdr
operator|*
operator|)
operator|(
name|chp
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* 	 * Build headers 	 */
name|spans_addr_copy
argument_list|(
operator|&
name|spans_bcastaddr
argument_list|,
operator|&
name|chp
operator|->
name|ch_dst
argument_list|)
expr_stmt|;
name|spans_addr_copy
argument_list|(
name|spp
operator|->
name|sp_addr
operator|.
name|address
argument_list|,
operator|&
name|chp
operator|->
name|ch_src
argument_list|)
expr_stmt|;
operator|*
operator|(
name|u_int
operator|*
operator|)
operator|&
name|chp
operator|->
name|ch_proto
operator|=
operator|*
operator|(
name|u_int
operator|*
operator|)
operator|&
name|spanscls_hdr
operator|.
name|ch_proto
expr_stmt|;
operator|*
operator|(
name|u_int
operator|*
operator|)
operator|&
name|chp
operator|->
name|ch_dsap
operator|=
operator|*
operator|(
name|u_int
operator|*
operator|)
operator|&
name|spanscls_hdr
operator|.
name|ch_dsap
expr_stmt|;
operator|*
operator|(
name|u_short
operator|*
operator|)
operator|&
name|chp
operator|->
name|ch_oui
index|[
literal|1
index|]
operator|=
operator|*
operator|(
name|u_short
operator|*
operator|)
operator|&
name|spanscls_hdr
operator|.
name|ch_oui
index|[
literal|1
index|]
expr_stmt|;
name|chp
operator|->
name|ch_pid
operator|=
name|htons
argument_list|(
name|ETHERTYPE_ARP
argument_list|)
expr_stmt|;
comment|/* 	 * Build ARP packet 	 */
name|ahp
operator|->
name|ah_hrd
operator|=
name|htons
argument_list|(
name|ARP_SPANS
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_pro
operator|=
name|htons
argument_list|(
name|ETHERTYPE_IP
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_hln
operator|=
sizeof|sizeof
argument_list|(
name|spans_addr
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_pln
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_op
operator|=
name|htons
argument_list|(
name|ARP_REQUEST
argument_list|)
expr_stmt|;
name|spans_addr_copy
argument_list|(
name|spp
operator|->
name|sp_addr
operator|.
name|address
argument_list|,
operator|&
name|ahp
operator|->
name|ah_sha
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
operator|(
name|IA_SIN
argument_list|(
name|inp
operator|->
name|inf_addr
argument_list|)
operator|->
name|sin_addr
operator|)
argument_list|,
name|ahp
operator|->
name|ah_spa
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|sap
operator|->
name|sa_dstip
argument_list|,
name|ahp
operator|->
name|ah_tpa
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Now, send the pdu via the CLS service 	 */
name|err
operator|=
name|atm_cm_cpcs_data
argument_list|(
name|clp
operator|->
name|cls_conn
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process a SPANS ARP input packet  *   * Arguments:  *	clp	pointer to interface CLS control block  *	m	pointer to input packet buffer chain  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|spansarp_input
parameter_list|(
name|clp
parameter_list|,
name|m
parameter_list|)
name|struct
name|spanscls
modifier|*
name|clp
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
block|{
name|struct
name|spans
modifier|*
name|spp
init|=
name|clp
operator|->
name|cls_spans
decl_stmt|;
name|struct
name|spanscls_hdr
modifier|*
name|chp
decl_stmt|;
name|struct
name|spansarp_hdr
modifier|*
name|ahp
decl_stmt|;
name|struct
name|spansarp
modifier|*
name|sap
decl_stmt|;
name|struct
name|ip_nif
modifier|*
name|inp
init|=
name|clp
operator|->
name|cls_ipnif
decl_stmt|;
name|struct
name|in_addr
name|in_me
decl_stmt|,
name|in_src
decl_stmt|,
name|in_targ
decl_stmt|;
name|int
name|s
decl_stmt|,
name|err
decl_stmt|;
comment|/* 	 * Make sure IP interface has been activated 	 */
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
goto|goto
name|free
goto|;
comment|/* 	 * Get the packet together 	 */
if|if
condition|(
name|KB_LEN
argument_list|(
name|m
argument_list|)
operator|<
name|ARP_PACKET_LEN
condition|)
block|{
name|KB_PULLUP
argument_list|(
name|m
argument_list|,
name|ARP_PACKET_LEN
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return;
block|}
name|KB_DATASTART
argument_list|(
name|m
argument_list|,
name|chp
argument_list|,
expr|struct
name|spanscls_hdr
operator|*
argument_list|)
expr_stmt|;
name|ahp
operator|=
operator|(
expr|struct
name|spansarp_hdr
operator|*
operator|)
operator|(
name|chp
operator|+
literal|1
operator|)
expr_stmt|;
name|bcopy
argument_list|(
name|ahp
operator|->
name|ah_spa
argument_list|,
operator|&
name|in_src
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|ahp
operator|->
name|ah_tpa
argument_list|,
operator|&
name|in_targ
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
operator|(
name|IA_SIN
argument_list|(
name|inp
operator|->
name|inf_addr
argument_list|)
operator|->
name|sin_addr
operator|)
argument_list|,
operator|&
name|in_me
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Initial packet verification 	 */
if|if
condition|(
operator|(
name|ahp
operator|->
name|ah_hrd
operator|!=
name|htons
argument_list|(
name|ARP_SPANS
argument_list|)
operator|)
operator|||
operator|(
name|ahp
operator|->
name|ah_pro
operator|!=
name|htons
argument_list|(
name|ETHERTYPE_IP
argument_list|)
operator|)
condition|)
goto|goto
name|free
goto|;
comment|/* 	 * Validate source addresses 	 * 	can't be from hardware broadcast 	 *	can't be from me 	 */
if|if
condition|(
operator|!
name|spans_addr_cmp
argument_list|(
operator|&
name|ahp
operator|->
name|ah_sha
argument_list|,
operator|&
name|spans_bcastaddr
argument_list|)
condition|)
goto|goto
name|free
goto|;
if|if
condition|(
operator|!
name|spans_addr_cmp
argument_list|(
operator|&
name|ahp
operator|->
name|ah_sha
argument_list|,
name|spp
operator|->
name|sp_addr
operator|.
name|address
argument_list|)
condition|)
goto|goto
name|free
goto|;
if|if
condition|(
name|in_src
operator|.
name|s_addr
operator|==
name|in_me
operator|.
name|s_addr
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"duplicate IP address sent from spans address %s\n"
argument_list|,
name|spans_addr_print
argument_list|(
operator|&
name|ahp
operator|->
name|ah_sha
argument_list|)
argument_list|)
expr_stmt|;
name|in_targ
operator|=
name|in_me
expr_stmt|;
goto|goto
name|chkop
goto|;
block|}
comment|/* 	 * If source IP address is from unspecified or broadcast addresses, 	 * don't bother updating arp table, but answer possible requests 	 */
if|if
condition|(
name|in_broadcast
argument_list|(
name|in_src
argument_list|,
operator|&
name|inp
operator|->
name|inf_nif
operator|->
name|nif_if
argument_list|)
condition|)
goto|goto
name|chkop
goto|;
comment|/* 	 * Update arp table with source address info 	 */
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|SPANSARP_LOOKUP
argument_list|(
name|in_src
operator|.
name|s_addr
argument_list|,
name|sap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sap
condition|)
block|{
comment|/* 		 * Found an entry for the source, but don't 		 * update permanent entries 		 */
if|if
condition|(
name|sap
operator|->
name|sa_origin
operator|!=
name|SAO_PERM
condition|)
block|{
comment|/* 			 * Update the entry 			 */
name|sap
operator|->
name|sa_dstatm
operator|.
name|address_format
operator|=
name|T_ATM_SPANS_ADDR
expr_stmt|;
name|sap
operator|->
name|sa_dstatm
operator|.
name|address_length
operator|=
sizeof|sizeof
argument_list|(
name|spans_addr
argument_list|)
expr_stmt|;
name|spans_addr_copy
argument_list|(
operator|&
name|ahp
operator|->
name|ah_sha
argument_list|,
name|sap
operator|->
name|sa_dstatm
operator|.
name|address
argument_list|)
expr_stmt|;
name|sap
operator|->
name|sa_cls
operator|=
name|clp
expr_stmt|;
name|sap
operator|->
name|sa_reftime
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|sap
operator|->
name|sa_flags
operator|&
name|SAF_VALID
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Newly valid entry, notify waiting users 				 */
name|struct
name|ipvcc
modifier|*
name|ivp
decl_stmt|,
modifier|*
name|inext
decl_stmt|;
name|sap
operator|->
name|sa_flags
operator||=
name|SAF_VALID
expr_stmt|;
for|for
control|(
name|ivp
operator|=
name|sap
operator|->
name|sa_ivp
init|;
name|ivp
condition|;
name|ivp
operator|=
name|inext
control|)
block|{
name|inext
operator|=
name|ivp
operator|->
name|iv_arpnext
expr_stmt|;
name|ivp
operator|->
name|iv_arpent
operator|=
operator|(
expr|struct
name|arpmap
operator|*
operator|)
name|sap
expr_stmt|;
call|(
modifier|*
name|inp
operator|->
name|inf_arpnotify
call|)
argument_list|(
name|ivp
argument_list|,
name|MAP_VALID
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * Remove ourselves from the retry chain 				 */
name|UNLINK
argument_list|(
name|sap
argument_list|,
expr|struct
name|spansarp
argument_list|,
name|spansarp_retry_head
argument_list|,
name|sa_rnext
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|in_targ
operator|.
name|s_addr
operator|==
name|in_me
operator|.
name|s_addr
condition|)
block|{
comment|/* 		 * Source unknown and we're the target - add new entry 		 */
name|sap
operator|=
name|uma_zalloc
argument_list|(
name|spansarp_zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|sap
condition|)
block|{
name|sap
operator|->
name|sa_dstip
operator|.
name|s_addr
operator|=
name|in_src
operator|.
name|s_addr
expr_stmt|;
name|sap
operator|->
name|sa_dstatm
operator|.
name|address_format
operator|=
name|T_ATM_SPANS_ADDR
expr_stmt|;
name|sap
operator|->
name|sa_dstatm
operator|.
name|address_length
operator|=
sizeof|sizeof
argument_list|(
name|spans_addr
argument_list|)
expr_stmt|;
name|spans_addr_copy
argument_list|(
operator|&
name|ahp
operator|->
name|ah_sha
argument_list|,
name|sap
operator|->
name|sa_dstatm
operator|.
name|address
argument_list|)
expr_stmt|;
name|sap
operator|->
name|sa_dstatmsub
operator|.
name|address_format
operator|=
name|T_ATM_ABSENT
expr_stmt|;
name|sap
operator|->
name|sa_dstatmsub
operator|.
name|address_length
operator|=
literal|0
expr_stmt|;
name|sap
operator|->
name|sa_cls
operator|=
name|clp
expr_stmt|;
name|sap
operator|->
name|sa_flags
operator|=
name|SAF_VALID
expr_stmt|;
name|sap
operator|->
name|sa_origin
operator|=
name|SAO_LOOKUP
expr_stmt|;
name|SPANSARP_ADD
argument_list|(
name|sap
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|chkop
label|:
comment|/* 	 * If this is a request for our address, send a reply  	 */
if|if
condition|(
name|ntohs
argument_list|(
name|ahp
operator|->
name|ah_op
argument_list|)
operator|!=
name|ARP_REQUEST
condition|)
goto|goto
name|free
goto|;
if|if
condition|(
name|in_targ
operator|.
name|s_addr
operator|!=
name|in_me
operator|.
name|s_addr
condition|)
goto|goto
name|free
goto|;
name|spans_addr_copy
argument_list|(
operator|&
name|chp
operator|->
name|ch_src
argument_list|,
operator|&
name|chp
operator|->
name|ch_dst
argument_list|)
expr_stmt|;
name|spans_addr_copy
argument_list|(
name|spp
operator|->
name|sp_addr
operator|.
name|address
argument_list|,
operator|&
name|chp
operator|->
name|ch_src
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_op
operator|=
name|htons
argument_list|(
name|ARP_REPLY
argument_list|)
expr_stmt|;
name|spans_addr_copy
argument_list|(
operator|&
name|ahp
operator|->
name|ah_sha
argument_list|,
operator|&
name|ahp
operator|->
name|ah_tha
argument_list|)
expr_stmt|;
name|spans_addr_copy
argument_list|(
name|spp
operator|->
name|sp_addr
operator|.
name|address
argument_list|,
operator|&
name|ahp
operator|->
name|ah_sha
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|ahp
operator|->
name|ah_spa
argument_list|,
name|ahp
operator|->
name|ah_tpa
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|in_me
argument_list|,
name|ahp
operator|->
name|ah_spa
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|atm_cm_cpcs_data
argument_list|(
name|clp
operator|->
name|cls_conn
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|free
goto|;
return|return;
name|free
label|:
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process a SPANS ARP aging timer tick  *   * This function is called every SPANSARP_AGING seconds, in order to age  * all the arp table entries.  *  * Called at splnet.  *  * Arguments:  *	tip	pointer to spansarp aging timer control block  *  * Returns:  *	none  *  */
end_comment

begin_function
specifier|static
name|void
name|spansarp_aging
parameter_list|(
name|tip
parameter_list|)
name|struct
name|atm_time
modifier|*
name|tip
decl_stmt|;
block|{
name|struct
name|spansarp
modifier|*
name|sap
decl_stmt|,
modifier|*
name|snext
decl_stmt|;
name|struct
name|ipvcc
modifier|*
name|ivp
decl_stmt|,
modifier|*
name|inext
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Schedule next timeout 	 */
name|atm_timeout
argument_list|(
operator|&
name|spansarp_timer
argument_list|,
name|SPANSARP_AGING
argument_list|,
name|spansarp_aging
argument_list|)
expr_stmt|;
comment|/* 	 * Run through arp table bumping each entry's aging timer. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SPANSARP_HASHSIZ
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|sap
operator|=
name|spansarp_arptab
index|[
name|i
index|]
init|;
name|sap
condition|;
name|sap
operator|=
name|snext
control|)
block|{
name|snext
operator|=
name|sap
operator|->
name|sa_next
expr_stmt|;
comment|/* 			 * Permanent (manually installed) entries aren't aged 			 */
if|if
condition|(
name|sap
operator|->
name|sa_origin
operator|==
name|SAO_PERM
condition|)
continue|continue;
comment|/* 			 * See if entry is valid and over-aged 			 */
if|if
condition|(
operator|(
name|sap
operator|->
name|sa_flags
operator|&
name|SAF_VALID
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|++
name|sap
operator|->
name|sa_reftime
operator|<
name|SPANSARP_MAXAGE
condition|)
continue|continue;
comment|/* 			 * Entry is now invalid, tell IP/ATM about it 			 */
name|sap
operator|->
name|sa_flags
operator||=
name|SAF_LOCKED
expr_stmt|;
for|for
control|(
name|ivp
operator|=
name|sap
operator|->
name|sa_ivp
init|;
name|ivp
condition|;
name|ivp
operator|=
name|inext
control|)
block|{
name|inext
operator|=
name|ivp
operator|->
name|iv_arpnext
expr_stmt|;
call|(
modifier|*
name|ivp
operator|->
name|iv_ipnif
operator|->
name|inf_arpnotify
call|)
argument_list|(
name|ivp
argument_list|,
name|MAP_INVALID
argument_list|)
expr_stmt|;
block|}
name|sap
operator|->
name|sa_flags
operator|&=
operator|~
operator|(
name|SAF_LOCKED
operator||
name|SAF_VALID
operator|)
expr_stmt|;
if|if
condition|(
name|sap
operator|->
name|sa_ivp
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * Somebody still cares, so add the arp 				 * entry to the retry list. 				 */
name|LINK2TAIL
argument_list|(
name|sap
argument_list|,
expr|struct
name|spansarp
argument_list|,
name|spansarp_retry_head
argument_list|,
name|sa_rnext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|spansarp_rtimer
operator|.
name|ti_flag
operator|&
name|TIF_QUEUED
operator|)
operator|==
literal|0
condition|)
name|atm_timeout
argument_list|(
operator|&
name|spansarp_rtimer
argument_list|,
name|SPANSARP_RETRY
argument_list|,
name|spansarp_retry
argument_list|)
expr_stmt|;
comment|/* 				 * Issue arp request for this address 				 */
operator|(
name|void
operator|)
name|spansarp_request
argument_list|(
name|sap
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Delete unused entry 				 */
name|SPANSARP_DELETE
argument_list|(
name|sap
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|spansarp_zone
argument_list|,
name|sap
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Process a SPANS ARP retry timer tick  *   * This function is called every SPANSARP_RETRY seconds, in order to retry  * awaiting arp resolution requests.  We will retry requests indefinitely,  * assuming that IP will set a timeout to close the VCC(s) requesting the  * failing address resolution.  *  * Called at splnet.  *  * Arguments:  *	tip	pointer to spansarp retry timer control block  *  * Returns:  *	none  *  */
end_comment

begin_function
specifier|static
name|void
name|spansarp_retry
parameter_list|(
name|tip
parameter_list|)
name|struct
name|atm_time
modifier|*
name|tip
decl_stmt|;
block|{
name|struct
name|spansarp
modifier|*
name|sap
decl_stmt|;
comment|/* 	 * See if there's work to do 	 */
if|if
condition|(
name|spansarp_retry_head
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
comment|/* 	 * Schedule next timeout 	 */
name|atm_timeout
argument_list|(
operator|&
name|spansarp_rtimer
argument_list|,
name|SPANSARP_RETRY
argument_list|,
name|spansarp_retry
argument_list|)
expr_stmt|;
comment|/* 	 * Run through retry chain, (re)issuing arp requests. 	 */
for|for
control|(
name|sap
operator|=
name|spansarp_retry_head
init|;
name|sap
condition|;
name|sap
operator|=
name|sap
operator|->
name|sa_next
control|)
block|{
comment|/* 		 * Send another arp request 		 */
operator|(
name|void
operator|)
name|spansarp_request
argument_list|(
name|sap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * SPANS ARP IOCTL support  *  * Function will be called at splnet.  *  * Arguments:  *	code	PF_ATM sub-operation code  *      data    pointer to code specific parameter data area  *      arg1    pointer to code specific argument  *  * Returns:  *	0	request procesed  *	errno	error processing request - reason indicated  *  */
end_comment

begin_function
name|int
name|spansarp_ioctl
parameter_list|(
name|code
parameter_list|,
name|data
parameter_list|,
name|arg1
parameter_list|)
name|int
name|code
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
name|caddr_t
name|arg1
decl_stmt|;
block|{
name|struct
name|atmaddreq
modifier|*
name|aap
decl_stmt|;
name|struct
name|atmdelreq
modifier|*
name|adp
decl_stmt|;
name|struct
name|atminfreq
modifier|*
name|aip
decl_stmt|;
name|struct
name|spans
modifier|*
name|spp
decl_stmt|;
name|struct
name|spanscls
modifier|*
name|clp
decl_stmt|;
name|struct
name|spansarp
modifier|*
name|sap
decl_stmt|;
name|struct
name|air_arp_rsp
name|aar
decl_stmt|;
name|struct
name|ip_nif
modifier|*
name|inp
decl_stmt|;
name|struct
name|ipvcc
modifier|*
name|ivp
decl_stmt|,
modifier|*
name|inext
decl_stmt|;
name|struct
name|in_addr
name|ip
decl_stmt|;
name|u_long
name|dst
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|buf_len
decl_stmt|;
name|caddr_t
name|buf_addr
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|AIOCS_ADD_ARP
case|:
comment|/* 		 * Add a permanent ARP mapping 		 */
name|aap
operator|=
operator|(
expr|struct
name|atmaddreq
operator|*
operator|)
name|data
expr_stmt|;
name|clp
operator|=
operator|(
expr|struct
name|spanscls
operator|*
operator|)
name|arg1
expr_stmt|;
name|inp
operator|=
name|clp
operator|->
name|cls_ipnif
expr_stmt|;
if|if
condition|(
operator|(
name|aap
operator|->
name|aar_arp_addr
operator|.
name|address_format
operator|!=
name|T_ATM_SPANS_ADDR
operator|)
operator|||
operator|(
name|aap
operator|->
name|aar_arp_origin
operator|!=
name|ARP_ORIG_PERM
operator|)
condition|)
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|ip
operator|=
name|SATOSIN
argument_list|(
operator|&
name|aap
operator|->
name|aar_arp_dst
argument_list|)
operator|->
name|sin_addr
expr_stmt|;
comment|/* 		 * See if we already have an entry for this IP address 		 */
name|SPANSARP_LOOKUP
argument_list|(
name|ip
operator|.
name|s_addr
argument_list|,
name|sap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sap
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * No, get a new arp entry 			 */
name|sap
operator|=
name|uma_zalloc
argument_list|(
name|spansarp_zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|sap
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
comment|/* 			 * Get entry set up 			 */
name|sap
operator|->
name|sa_dstip
operator|=
name|ip
expr_stmt|;
name|ATM_ADDR_COPY
argument_list|(
operator|&
name|aap
operator|->
name|aar_arp_addr
argument_list|,
operator|&
name|sap
operator|->
name|sa_dstatm
argument_list|)
expr_stmt|;
name|sap
operator|->
name|sa_dstatmsub
operator|.
name|address_format
operator|=
name|T_ATM_ABSENT
expr_stmt|;
name|sap
operator|->
name|sa_dstatmsub
operator|.
name|address_length
operator|=
literal|0
expr_stmt|;
name|sap
operator|->
name|sa_cls
operator|=
name|clp
expr_stmt|;
name|sap
operator|->
name|sa_flags
operator||=
name|SAF_VALID
expr_stmt|;
name|sap
operator|->
name|sa_origin
operator|=
name|SAO_PERM
expr_stmt|;
comment|/* 			 * Add entry to table 			 */
name|SPANSARP_ADD
argument_list|(
name|sap
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * See if we're attempting to change the ATM address for 		 * this cached entry 		 */
if|if
condition|(
operator|(
name|sap
operator|->
name|sa_dstatm
operator|.
name|address_format
operator|!=
name|T_ATM_ABSENT
operator|)
operator|&&
operator|(
operator|!
name|ATM_ADDR_EQUAL
argument_list|(
operator|&
name|aap
operator|->
name|aar_arp_addr
argument_list|,
operator|&
name|sap
operator|->
name|sa_dstatm
argument_list|)
operator|||
operator|(
name|clp
operator|!=
name|sap
operator|->
name|sa_cls
operator|)
operator|)
condition|)
block|{
comment|/* 			 * Yes, notify IP/ATM that a mapping change has 			 * occurred.  IP/ATM will close any VCC's which 			 * aren't waiting for this map. 			 */
name|sap
operator|->
name|sa_flags
operator||=
name|SAF_LOCKED
expr_stmt|;
for|for
control|(
name|ivp
operator|=
name|sap
operator|->
name|sa_ivp
init|;
name|ivp
condition|;
name|ivp
operator|=
name|inext
control|)
block|{
name|inext
operator|=
name|ivp
operator|->
name|iv_arpnext
expr_stmt|;
call|(
modifier|*
name|inp
operator|->
name|inf_arpnotify
call|)
argument_list|(
name|ivp
argument_list|,
name|MAP_CHANGED
argument_list|)
expr_stmt|;
block|}
name|sap
operator|->
name|sa_flags
operator|&=
operator|~
name|SAF_LOCKED
expr_stmt|;
block|}
comment|/* 		 * Update the cached entry with the new data 		 */
name|ATM_ADDR_COPY
argument_list|(
operator|&
name|aap
operator|->
name|aar_arp_addr
argument_list|,
operator|&
name|sap
operator|->
name|sa_dstatm
argument_list|)
expr_stmt|;
name|sap
operator|->
name|sa_cls
operator|=
name|clp
expr_stmt|;
comment|/* 		 * If this entry isn't valid, notify anyone who might 		 * be interested 		 */
if|if
condition|(
operator|(
name|sap
operator|->
name|sa_flags
operator|&
name|SAF_VALID
operator|)
operator|==
literal|0
condition|)
block|{
name|sap
operator|->
name|sa_flags
operator||=
name|SAF_LOCKED
expr_stmt|;
for|for
control|(
name|ivp
operator|=
name|sap
operator|->
name|sa_ivp
init|;
name|ivp
condition|;
name|ivp
operator|=
name|inext
control|)
block|{
name|inext
operator|=
name|ivp
operator|->
name|iv_arpnext
expr_stmt|;
call|(
modifier|*
name|inp
operator|->
name|inf_arpnotify
call|)
argument_list|(
name|ivp
argument_list|,
name|MAP_VALID
argument_list|)
expr_stmt|;
block|}
name|sap
operator|->
name|sa_flags
operator|&=
operator|~
name|SAF_LOCKED
expr_stmt|;
block|}
comment|/* 		 * Remove this entry from the retry chain 		 */
name|UNLINK
argument_list|(
name|sap
argument_list|,
expr|struct
name|spansarp
argument_list|,
name|spansarp_retry_head
argument_list|,
name|sa_rnext
argument_list|)
expr_stmt|;
comment|/* 		 * Mark the entry as permanent 		 */
name|sap
operator|->
name|sa_flags
operator||=
name|SAF_VALID
expr_stmt|;
name|sap
operator|->
name|sa_origin
operator|=
name|SAO_PERM
expr_stmt|;
break|break;
case|case
name|AIOCS_DEL_ARP
case|:
comment|/* 		 * Delete an ARP mapping 		 */
name|adp
operator|=
operator|(
expr|struct
name|atmdelreq
operator|*
operator|)
name|data
expr_stmt|;
name|clp
operator|=
operator|(
expr|struct
name|spanscls
operator|*
operator|)
name|arg1
expr_stmt|;
name|ip
operator|=
name|SATOSIN
argument_list|(
operator|&
name|adp
operator|->
name|adr_arp_dst
argument_list|)
operator|->
name|sin_addr
expr_stmt|;
comment|/* 		 * Now find the entry to be deleted 		 */
name|SPANSARP_LOOKUP
argument_list|(
name|ip
operator|.
name|s_addr
argument_list|,
name|sap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sap
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
comment|/* 		 * Notify all VCCs using this entry that they must finish 		 * up now.   		 */
name|sap
operator|->
name|sa_flags
operator||=
name|SAF_LOCKED
expr_stmt|;
for|for
control|(
name|ivp
operator|=
name|sap
operator|->
name|sa_ivp
init|;
name|ivp
condition|;
name|ivp
operator|=
name|inext
control|)
block|{
name|inext
operator|=
name|ivp
operator|->
name|iv_arpnext
expr_stmt|;
call|(
modifier|*
name|ivp
operator|->
name|iv_ipnif
operator|->
name|inf_arpnotify
call|)
argument_list|(
name|ivp
argument_list|,
name|MAP_FAILED
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Now free up the entry 		 */
name|UNLINK
argument_list|(
name|sap
argument_list|,
expr|struct
name|spansarp
argument_list|,
name|spansarp_retry_head
argument_list|,
name|sa_rnext
argument_list|)
expr_stmt|;
name|SPANSARP_DELETE
argument_list|(
name|sap
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|spansarp_zone
argument_list|,
name|sap
argument_list|)
expr_stmt|;
break|break;
case|case
name|AIOCS_INF_ARP
case|:
comment|/* 		 * Get ARP table information 		 */
name|aip
operator|=
operator|(
expr|struct
name|atminfreq
operator|*
operator|)
name|data
expr_stmt|;
name|spp
operator|=
operator|(
expr|struct
name|spans
operator|*
operator|)
name|arg1
expr_stmt|;
if|if
condition|(
name|aip
operator|->
name|air_arp_addr
operator|.
name|sa_family
operator|!=
name|AF_INET
condition|)
break|break;
name|dst
operator|=
name|SATOSIN
argument_list|(
operator|&
name|aip
operator|->
name|air_arp_addr
argument_list|)
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|buf_addr
operator|=
name|aip
operator|->
name|air_buf_addr
expr_stmt|;
name|buf_len
operator|=
name|aip
operator|->
name|air_buf_len
expr_stmt|;
if|if
condition|(
operator|(
name|clp
operator|=
name|spp
operator|->
name|sp_cls
operator|)
operator|==
name|NULL
condition|)
break|break;
comment|/* 		 * Run through entire arp table 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SPANSARP_HASHSIZ
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|sap
operator|=
name|spansarp_arptab
index|[
name|i
index|]
init|;
name|sap
condition|;
name|sap
operator|=
name|sap
operator|->
name|sa_next
control|)
block|{
comment|/* 				 * We only want entries learned 				 * from the supplied interface. 				 */
if|if
condition|(
name|sap
operator|->
name|sa_cls
operator|!=
name|clp
condition|)
continue|continue;
if|if
condition|(
operator|(
name|dst
operator|!=
name|INADDR_ANY
operator|)
operator|&&
operator|(
name|dst
operator|!=
name|sap
operator|->
name|sa_dstip
operator|.
name|s_addr
operator|)
condition|)
continue|continue;
comment|/* 				 * Make sure there's room in the user's buffer 				 */
if|if
condition|(
name|buf_len
operator|<
sizeof|sizeof
argument_list|(
name|aar
argument_list|)
condition|)
block|{
name|err
operator|=
name|ENOSPC
expr_stmt|;
break|break;
block|}
comment|/* 				 * Fill in info to be returned 				 */
name|SATOSIN
argument_list|(
operator|&
name|aar
operator|.
name|aap_arp_addr
argument_list|)
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|SATOSIN
argument_list|(
operator|&
name|aar
operator|.
name|aap_arp_addr
argument_list|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|sap
operator|->
name|sa_dstip
operator|.
name|s_addr
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|aar
operator|.
name|aap_intf
argument_list|,
sizeof|sizeof
argument_list|(
name|aar
operator|.
name|aap_intf
argument_list|)
argument_list|,
literal|"%s%d"
argument_list|,
name|clp
operator|->
name|cls_ipnif
operator|->
name|inf_nif
operator|->
name|nif_if
operator|.
name|if_name
argument_list|,
name|clp
operator|->
name|cls_ipnif
operator|->
name|inf_nif
operator|->
name|nif_if
operator|.
name|if_unit
argument_list|)
expr_stmt|;
name|aar
operator|.
name|aap_flags
operator|=
name|sap
operator|->
name|sa_flags
expr_stmt|;
name|aar
operator|.
name|aap_origin
operator|=
name|sap
operator|->
name|sa_origin
expr_stmt|;
if|if
condition|(
name|sap
operator|->
name|sa_flags
operator|&
name|SAF_VALID
condition|)
name|aar
operator|.
name|aap_age
operator|=
name|SPANSARP_MAXAGE
operator|-
name|sap
operator|->
name|sa_reftime
expr_stmt|;
else|else
name|aar
operator|.
name|aap_age
operator|=
literal|0
expr_stmt|;
name|ATM_ADDR_COPY
argument_list|(
operator|&
name|sap
operator|->
name|sa_dstatm
argument_list|,
operator|&
name|aar
operator|.
name|aap_addr
argument_list|)
expr_stmt|;
name|ATM_ADDR_COPY
argument_list|(
operator|&
name|sap
operator|->
name|sa_dstatmsub
argument_list|,
operator|&
name|aar
operator|.
name|aap_subaddr
argument_list|)
expr_stmt|;
comment|/* 				 * Copy the response into the user's buffer 				 */
if|if
condition|(
operator|(
name|err
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|aar
argument_list|,
name|buf_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|aar
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|buf_addr
operator|+=
sizeof|sizeof
argument_list|(
name|aar
argument_list|)
expr_stmt|;
name|buf_len
operator|-=
sizeof|sizeof
argument_list|(
name|aar
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
break|break;
block|}
comment|/* 		 * Update the buffer pointer and length 		 */
name|aip
operator|->
name|air_buf_addr
operator|=
name|buf_addr
expr_stmt|;
name|aip
operator|->
name|air_buf_len
operator|=
name|buf_len
expr_stmt|;
break|break;
case|case
name|AIOCS_INF_ASV
case|:
comment|/* 		 * Get ARP server information 		 */
comment|/* SPANS doesn't have an ARP server */
break|break;
default|default:
name|err
operator|=
name|EOPNOTSUPP
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

end_unit

