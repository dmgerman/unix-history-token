begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * ===================================  * HARP  |  Host ATM Research Platform  * ===================================  *  *  * This Host ATM Research Platform ("HARP") file (the "Software") is  * made available by Network Computing Services, Inc. ("NetworkCS")  * "AS IS".  NetworkCS does not provide maintenance, improvements or  * support of any kind.  *  * NETWORKCS MAKES NO WARRANTIES OR REPRESENTATIONS, EXPRESS OR IMPLIED,  * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE, AS TO ANY ELEMENT OF THE  * SOFTWARE OR ANY SUPPORT PROVIDED IN CONNECTION WITH THIS SOFTWARE.  * In no event shall NetworkCS be responsible for any damages, including  * but not limited to consequential damages, arising from or relating to  * any use of the Software or related support.  *  * Copyright 1994-1998 Network Computing Services, Inc.  *  * Copies of this Software may be made, however, the above copyright  * notice must be reproduced on all copies.  *  *	@(#) $Id: spans_subr.c,v 1.1 1998/09/15 08:23:04 phk Exp $  *  */
end_comment

begin_comment
comment|/*  * SPANS Signalling Manager  * ---------------------------  *  * SPANS-related subroutines.  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|RCSid
init|=
literal|"@(#) $Id: spans_subr.c,v 1.1 1998/09/15 08:23:04 phk Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netatm/kern_include.h>
end_include

begin_include
include|#
directive|include
file|"spans_xdr.h"
end_include

begin_include
include|#
directive|include
file|<netatm/spans/spans_var.h>
end_include

begin_comment
comment|/*  * Open a SPANS VCC  *  * Called when a user wants to open a VC.  This function will construct  * a VCCB, create the stack requested by the user, and, if we are  * opening an SVC, start the SPANS signalling message exchange.  The  * user will have to wait for a notify event to be sure the SVC is fully  * open.  *  * Must be called at splnet.  *  * Arguments:  *	spp	pointer to SPANS protocol instance  *	acp	pointer to PVC's connection parameters  *  * Returns:  *	0	VCC creation successful  *	errno	VCC setup failed - reason indicated  *  */
end_comment

begin_function
name|int
name|spans_open_vcc
parameter_list|(
name|spp
parameter_list|,
name|cvp
parameter_list|)
name|struct
name|spans
modifier|*
name|spp
decl_stmt|;
name|Atm_connvc
modifier|*
name|cvp
decl_stmt|;
block|{
name|struct
name|atm_pif
modifier|*
name|pip
init|=
name|spp
operator|->
name|sp_pif
decl_stmt|;
name|struct
name|spans_vccb
modifier|*
name|svp
decl_stmt|;
name|Atm_addr_pvc
modifier|*
name|pvp
decl_stmt|;
name|spans_aal
name|aal
decl_stmt|;
name|int
name|err
decl_stmt|,
name|pvc
decl_stmt|,
name|vpi
decl_stmt|,
name|vci
decl_stmt|;
name|ATM_DEBUG2
argument_list|(
literal|"spans_open_vcc: spp=%p, cvp=%p\n"
argument_list|,
name|spp
argument_list|,
name|cvp
argument_list|)
expr_stmt|;
comment|/* 	 * Validate user parameters. AAL and encapsulation are 	 * checked by the connection manager. 	 */
comment|/* 	 * Check called party address(es) 	 */
if|if
condition|(
name|cvp
operator|->
name|cvc_attr
operator|.
name|called
operator|.
name|tag
operator|!=
name|T_ATM_PRESENT
operator|||
name|cvp
operator|->
name|cvc_attr
operator|.
name|called
operator|.
name|addr
operator|.
name|address_format
operator|==
name|T_ATM_ABSENT
operator|||
name|cvp
operator|->
name|cvc_attr
operator|.
name|called
operator|.
name|subaddr
operator|.
name|address_format
operator|!=
name|T_ATM_ABSENT
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
switch|switch
condition|(
name|cvp
operator|->
name|cvc_attr
operator|.
name|called
operator|.
name|addr
operator|.
name|address_format
condition|)
block|{
case|case
name|T_ATM_PVC_ADDR
case|:
comment|/* 		 * Make sure VPI/VCI is valid 		 */
name|pvc
operator|=
literal|1
expr_stmt|;
name|pvp
operator|=
operator|(
name|Atm_addr_pvc
operator|*
operator|)
name|cvp
operator|->
name|cvc_attr
operator|.
name|called
operator|.
name|addr
operator|.
name|address
expr_stmt|;
name|vpi
operator|=
name|ATM_PVC_GET_VPI
argument_list|(
name|pvp
argument_list|)
expr_stmt|;
name|vci
operator|=
name|ATM_PVC_GET_VCI
argument_list|(
name|pvp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vpi
operator|>
name|pip
operator|->
name|pif_maxvpi
operator|)
operator|||
operator|(
name|vci
operator|==
literal|0
operator|)
operator|||
operator|(
name|vci
operator|>
name|pip
operator|->
name|pif_maxvci
operator|)
condition|)
block|{
return|return
operator|(
name|ERANGE
operator|)
return|;
block|}
comment|/* 		 * Make sure VPI/VCI is not already in use 		 */
if|if
condition|(
name|spans_find_vpvc
argument_list|(
name|spp
argument_list|,
name|vpi
argument_list|,
name|vci
argument_list|,
literal|0
argument_list|)
condition|)
block|{
return|return
operator|(
name|EADDRINUSE
operator|)
return|;
block|}
name|ATM_DEBUG2
argument_list|(
literal|"spans_open_vcc: VPI.VCI=%d.%d\n"
argument_list|,
name|vpi
argument_list|,
name|vci
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_ATM_SPANS_ADDR
case|:
name|pvc
operator|=
literal|0
expr_stmt|;
name|vpi
operator|=
name|vci
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Check signalling state 		 */
if|if
condition|(
name|spp
operator|->
name|sp_state
operator|!=
name|SPANS_ACTIVE
condition|)
block|{
return|return
operator|(
name|ENETDOWN
operator|)
return|;
block|}
comment|/* 		 *Check destination address length 		 */
if|if
condition|(
name|cvp
operator|->
name|cvc_attr
operator|.
name|called
operator|.
name|addr
operator|.
name|address_length
operator|!=
sizeof|sizeof
argument_list|(
name|spans_addr
argument_list|)
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * Check that this is for the same interface SPANS uses          */
if|if
condition|(
operator|!
name|cvp
operator|->
name|cvc_attr
operator|.
name|nif
operator|||
name|cvp
operator|->
name|cvc_attr
operator|.
name|nif
operator|->
name|nif_pif
operator|!=
name|spp
operator|->
name|sp_pif
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * Check AAL 	 */
if|if
condition|(
operator|!
name|spans_get_spans_aal
argument_list|(
name|cvp
operator|->
name|cvc_attr
operator|.
name|aal
operator|.
name|type
argument_list|,
operator|&
name|aal
argument_list|)
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|NOTDEF
comment|/* 	 * Check encapsulation 	 */
comment|/* XXX -- How do we check encapsulation? */
if|if
condition|(
name|cvp
operator|->
name|ac_encaps
operator|!=
name|ATM_ENC_NULL
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* 	 * Allocate control block for VCC 	 */
name|svp
operator|=
operator|(
expr|struct
name|spans_vccb
operator|*
operator|)
name|atm_allocate
argument_list|(
operator|&
name|spans_vcpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|svp
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* 	 * Fill in VCCB 	 */
if|if
condition|(
name|pvc
condition|)
block|{
name|svp
operator|->
name|sv_type
operator|=
name|VCC_PVC
operator||
name|VCC_IN
operator||
name|VCC_OUT
expr_stmt|;
name|svp
operator|->
name|sv_vpi
operator|=
name|vpi
expr_stmt|;
name|svp
operator|->
name|sv_vci
operator|=
name|vci
expr_stmt|;
name|svp
operator|->
name|sv_sstate
operator|=
operator|(
name|spp
operator|->
name|sp_state
operator|==
name|SPANS_ACTIVE
condition|?
name|SPANS_VC_ACTIVE
else|:
name|SPANS_VC_ACT_DOWN
operator|)
expr_stmt|;
name|svp
operator|->
name|sv_ustate
operator|=
name|VCCU_OPEN
expr_stmt|;
block|}
else|else
block|{
name|svp
operator|->
name|sv_type
operator|=
name|VCC_SVC
operator||
name|VCC_OUT
expr_stmt|;
name|spans_addr_copy
argument_list|(
name|cvp
operator|->
name|cvc_attr
operator|.
name|called
operator|.
name|addr
operator|.
name|address
argument_list|,
operator|&
name|svp
operator|->
name|sv_conn
operator|.
name|con_dst
argument_list|)
expr_stmt|;
name|spans_addr_copy
argument_list|(
name|spp
operator|->
name|sp_addr
operator|.
name|address
argument_list|,
operator|&
name|svp
operator|->
name|sv_conn
operator|.
name|con_src
argument_list|)
expr_stmt|;
name|svp
operator|->
name|sv_conn
operator|.
name|con_dsap
operator|=
name|SPANS_SAP_IP
expr_stmt|;
name|svp
operator|->
name|sv_conn
operator|.
name|con_ssap
operator|=
name|spans_ephemeral_sap
argument_list|(
name|spp
argument_list|)
expr_stmt|;
name|svp
operator|->
name|sv_sstate
operator|=
name|SPANS_VC_POPEN
expr_stmt|;
name|svp
operator|->
name|sv_ustate
operator|=
name|VCCU_POPEN
expr_stmt|;
block|}
name|svp
operator|->
name|sv_proto
operator|=
name|ATM_SIG_SPANS
expr_stmt|;
name|svp
operator|->
name|sv_pif
operator|=
name|spp
operator|->
name|sp_pif
expr_stmt|;
name|svp
operator|->
name|sv_nif
operator|=
name|cvp
operator|->
name|cvc_attr
operator|.
name|nif
expr_stmt|;
name|svp
operator|->
name|sv_connvc
operator|=
name|cvp
expr_stmt|;
name|svp
operator|->
name|sv_spans_aal
operator|=
name|aal
expr_stmt|;
name|svp
operator|->
name|sv_tstamp
operator|=
name|time_second
expr_stmt|;
comment|/* 	 * Put VCCB on SPANS queue 	 */
name|ENQUEUE
argument_list|(
name|svp
argument_list|,
expr|struct
name|spans_vccb
argument_list|,
name|sv_sigelem
argument_list|,
name|spp
operator|->
name|sp_vccq
argument_list|)
expr_stmt|;
comment|/* 	 * Link VCCB to VCC connection block 	 */
name|cvp
operator|->
name|cvc_vcc
operator|=
operator|(
expr|struct
name|vccb
operator|*
operator|)
name|svp
expr_stmt|;
comment|/* 	 * Start the SPANS message exchange if this is an SVC 	 */
if|if
condition|(
operator|!
name|pvc
condition|)
block|{
name|svp
operator|->
name|sv_retry
operator|=
literal|0
expr_stmt|;
name|svp
operator|->
name|sv_spans_qos
operator|.
name|rsc_peak
operator|=
literal|1
expr_stmt|;
name|svp
operator|->
name|sv_spans_qos
operator|.
name|rsc_mean
operator|=
literal|1
expr_stmt|;
name|svp
operator|->
name|sv_spans_qos
operator|.
name|rsc_burst
operator|=
literal|1
expr_stmt|;
name|err
operator|=
name|spans_send_open_req
argument_list|(
name|spp
argument_list|,
name|svp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* 			 * On error, delete the VCCB 			 */
name|DEQUEUE
argument_list|(
name|svp
argument_list|,
expr|struct
name|spans_vccb
argument_list|,
name|sv_sigelem
argument_list|,
name|spp
operator|->
name|sp_vccq
argument_list|)
expr_stmt|;
name|cvp
operator|->
name|cvc_vcc
operator|=
operator|(
expr|struct
name|vccb
operator|*
operator|)
literal|0
expr_stmt|;
name|atm_free
argument_list|(
operator|(
name|caddr_t
operator|)
name|svp
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
else|else
block|{
comment|/* 			 * VCCB is opening--set the retransmit timer 			 */
name|SPANS_VC_TIMER
argument_list|(
operator|(
expr|struct
name|vccb
operator|*
operator|)
name|svp
argument_list|,
name|SV_TIMEOUT
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close a SPANS VCC  *  * Called when a user wants to close a VCC.  This function will clean  * up the VCCB and, for an SVC, send a close request.  *  * Must be called at splnet.  *  * Arguments:  *	spp	pointer to SPANS protocol instance  *	svp	pointer to VCCB for the VCC to be closed  *  * Returns:  *	0	VCC is now closed  *	errno	error encountered  */
end_comment

begin_function
name|int
name|spans_close_vcc
parameter_list|(
name|spp
parameter_list|,
name|svp
parameter_list|,
name|force
parameter_list|)
name|struct
name|spans
modifier|*
name|spp
decl_stmt|;
name|struct
name|spans_vccb
modifier|*
name|svp
decl_stmt|;
name|int
name|force
decl_stmt|;
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|ATM_DEBUG2
argument_list|(
literal|"spans_close_vcc: svp=%p, state=%d\n"
argument_list|,
name|svp
argument_list|,
name|svp
operator|->
name|sv_sstate
argument_list|)
expr_stmt|;
comment|/* 	 * Check that this is for the same interface SPANS uses          */
if|if
condition|(
name|svp
operator|->
name|sv_pif
operator|!=
name|spp
operator|->
name|sp_pif
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * Kill any possible timer 	 */
name|SPANS_VC_CANCEL
argument_list|(
operator|(
expr|struct
name|vccb
operator|*
operator|)
name|svp
argument_list|)
expr_stmt|;
comment|/* 	 * Mark the close time. 	 */
name|svp
operator|->
name|sv_tstamp
operator|=
name|time_second
expr_stmt|;
comment|/* 	 * Process based on the connection type 	 */
if|if
condition|(
name|svp
operator|->
name|sv_type
operator|&
name|VCC_PVC
condition|)
block|{
name|svp
operator|->
name|sv_sstate
operator|=
name|SPANS_VC_FREE
expr_stmt|;
name|svp
operator|->
name|sv_ustate
operator|=
name|VCCU_CLOSED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|svp
operator|->
name|sv_type
operator|&
name|VCC_SVC
condition|)
block|{
comment|/* 		 * Update VCCB states 		 */
name|svp
operator|->
name|sv_ustate
operator|=
name|VCCU_CLOSED
expr_stmt|;
comment|/* 		 * Send the appropriate SPANS close message 		 */
switch|switch
condition|(
name|svp
operator|->
name|sv_sstate
condition|)
block|{
case|case
name|SPANS_VC_R_POPEN
case|:
name|err
operator|=
name|spans_send_open_rsp
argument_list|(
name|spp
argument_list|,
name|svp
argument_list|,
name|SPANS_FAIL
argument_list|)
expr_stmt|;
name|svp
operator|->
name|sv_sstate
operator|=
name|SPANS_VC_FREE
expr_stmt|;
break|break;
case|case
name|SPANS_VC_OPEN
case|:
case|case
name|SPANS_VC_POPEN
case|:
case|case
name|SPANS_VC_ABORT
case|:
name|svp
operator|->
name|sv_retry
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|spans_send_close_req
argument_list|(
name|spp
argument_list|,
name|svp
argument_list|)
expr_stmt|;
if|if
condition|(
name|force
condition|)
block|{
name|svp
operator|->
name|sv_sstate
operator|=
name|SPANS_VC_FREE
expr_stmt|;
block|}
else|else
block|{
name|svp
operator|->
name|sv_sstate
operator|=
name|SPANS_VC_CLOSE
expr_stmt|;
name|SPANS_VC_TIMER
argument_list|(
operator|(
expr|struct
name|vccb
operator|*
operator|)
name|svp
argument_list|,
name|SV_TIMEOUT
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SPANS_VC_CLOSE
case|:
if|if
condition|(
name|force
condition|)
block|{
name|svp
operator|->
name|sv_sstate
operator|=
name|SPANS_VC_FREE
expr_stmt|;
block|}
break|break;
block|}
block|}
comment|/* 	 * Wait for user to free resources 	 */
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Clear a SPANS VCC  *  * Called when the signalling manager wants to close a VCC immediately.  * This function will clean up the VCCB and notify the owner.  *  * Must be called at splnet.  *  * Arguments:  *	spp	pointer to SPANS protocol instance  *	svp	pointer to VCCB for the VCC to be closed  *  * Returns:  *	0	VCC is now closed  *	errno	error encountered  */
end_comment

begin_function
name|int
name|spans_clear_vcc
parameter_list|(
name|spp
parameter_list|,
name|svp
parameter_list|)
name|struct
name|spans
modifier|*
name|spp
decl_stmt|;
name|struct
name|spans_vccb
modifier|*
name|svp
decl_stmt|;
block|{
name|u_char
name|outstate
decl_stmt|;
name|ATM_DEBUG2
argument_list|(
literal|"spans_clear_vcc: svp=%p, state=%d\n"
argument_list|,
name|svp
argument_list|,
name|svp
operator|->
name|sv_sstate
argument_list|)
expr_stmt|;
comment|/* 	 * Check that this is for the same interface SPANS uses          */
if|if
condition|(
name|svp
operator|->
name|sv_pif
operator|!=
name|spp
operator|->
name|sp_pif
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * Kill any possible timer 	 */
name|SPANS_VC_CANCEL
argument_list|(
operator|(
expr|struct
name|vccb
operator|*
operator|)
name|svp
argument_list|)
expr_stmt|;
comment|/* 	 * Mark the close time 	 */
name|svp
operator|->
name|sv_tstamp
operator|=
name|time_second
expr_stmt|;
comment|/* 	 * Mark the VCCB closed 	 */
name|outstate
operator|=
name|svp
operator|->
name|sv_sstate
expr_stmt|;
name|svp
operator|->
name|sv_sstate
operator|=
name|SPANS_VC_FREE
expr_stmt|;
name|svp
operator|->
name|sv_ustate
operator|=
name|VCCU_CLOSED
expr_stmt|;
comment|/* 	 * Notify the user if old state indicates. 	 */
switch|switch
condition|(
name|outstate
condition|)
block|{
case|case
name|SPANS_VC_ACTIVE
case|:
case|case
name|SPANS_VC_ACT_DOWN
case|:
case|case
name|SPANS_VC_POPEN
case|:
case|case
name|SPANS_VC_OPEN
case|:
case|case
name|SPANS_VC_CLOSE
case|:
case|case
name|SPANS_VC_ABORT
case|:
comment|/* XXX -- set cause */
name|atm_cm_cleared
argument_list|(
name|svp
operator|->
name|sv_connvc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPANS_VC_NULL
case|:
case|case
name|SPANS_VC_R_POPEN
case|:
case|case
name|SPANS_VC_FREE
case|:
break|break;
block|}
comment|/* 	 * Wait for user to free resources 	 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reset the switch state  *  * Called when the switch or host at the far end of the ATM link has  * gone away.  This can be deteched either by a number of SPANS_STAT_REQ  * messages going unanswered or by the host epoch changing in a SPANS  * SPANS_STAT_IND or SPANS_STAT_REQ message.  *  * Arguments:  *	spp	pointer to SPANS protocol instance  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|spans_switch_reset
parameter_list|(
name|spp
parameter_list|,
name|cause
parameter_list|)
name|struct
name|spans
modifier|*
name|spp
decl_stmt|;
name|int
name|cause
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
name|struct
name|vccb
modifier|*
name|vcp
decl_stmt|,
modifier|*
name|vnext
decl_stmt|;
name|ATM_DEBUG2
argument_list|(
literal|"spans_switch_reset: spp=%p, cause=%d\n"
argument_list|,
name|spp
argument_list|,
name|cause
argument_list|)
expr_stmt|;
comment|/* 	 * Log the event 	 */
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"spans: signalling %s on interface %s%d\n"
argument_list|,
operator|(
name|cause
operator|==
name|SPANS_UNI_DOWN
condition|?
literal|"down"
else|:
literal|"up"
operator|)
argument_list|,
name|spp
operator|->
name|sp_pif
operator|->
name|pif_name
argument_list|,
name|spp
operator|->
name|sp_pif
operator|->
name|pif_unit
argument_list|)
expr_stmt|;
comment|/* 	 * Terminate all of our VCCs 	 */
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
for|for
control|(
name|vcp
operator|=
name|Q_HEAD
argument_list|(
name|spp
operator|->
name|sp_vccq
argument_list|,
expr|struct
name|vccb
argument_list|)
init|;
name|vcp
condition|;
name|vcp
operator|=
name|vnext
control|)
block|{
name|u_char
name|outstate
decl_stmt|;
name|vnext
operator|=
name|Q_NEXT
argument_list|(
name|vcp
argument_list|,
expr|struct
name|vccb
argument_list|,
name|vc_sigelem
argument_list|)
expr_stmt|;
if|if
condition|(
name|vcp
operator|->
name|vc_type
operator|&
name|VCC_SVC
condition|)
block|{
comment|/* 			 * Close the SVC and notify the owner 			 */
name|outstate
operator|=
name|vcp
operator|->
name|vc_sstate
expr_stmt|;
name|SPANS_VC_CANCEL
argument_list|(
operator|(
expr|struct
name|vccb
operator|*
operator|)
name|vcp
argument_list|)
expr_stmt|;
name|vcp
operator|->
name|vc_ustate
operator|=
name|VCCU_CLOSED
expr_stmt|;
name|vcp
operator|->
name|vc_sstate
operator|=
name|SPANS_VC_FREE
expr_stmt|;
if|if
condition|(
name|outstate
operator|==
name|SPANS_VC_OPEN
operator|||
name|outstate
operator|==
name|SPANS_VC_POPEN
condition|)
block|{
comment|/* XXX -- set cause */
name|atm_cm_cleared
argument_list|(
name|vcp
operator|->
name|vc_connvc
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|vcp
operator|->
name|vc_type
operator|&
name|VCC_PVC
condition|)
block|{
comment|/* 			 * Note new state 			 */
switch|switch
condition|(
name|cause
condition|)
block|{
case|case
name|SPANS_UNI_DOWN
case|:
name|vcp
operator|->
name|vc_sstate
operator|=
name|SPANS_VC_ACT_DOWN
expr_stmt|;
break|break;
case|case
name|SPANS_UNI_UP
case|:
name|vcp
operator|->
name|vc_sstate
operator|=
name|SPANS_VC_ACTIVE
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"spans: invalid VCC type: vccb=%p, type=%d\n"
argument_list|,
name|vcp
argument_list|,
name|vcp
operator|->
name|vc_type
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

