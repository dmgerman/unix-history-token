begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * ===================================  * HARP  |  Host ATM Research Platform  * ===================================  *  *  * This Host ATM Research Platform ("HARP") file (the "Software") is  * made available by Network Computing Services, Inc. ("NetworkCS")  * "AS IS".  NetworkCS does not provide maintenance, improvements or  * support of any kind.  *  * NETWORKCS MAKES NO WARRANTIES OR REPRESENTATIONS, EXPRESS OR IMPLIED,  * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE, AS TO ANY ELEMENT OF THE  * SOFTWARE OR ANY SUPPORT PROVIDED IN CONNECTION WITH THIS SOFTWARE.  * In no event shall NetworkCS be responsible for any damages, including  * but not limited to consequential damages, arising from or relating to  * any use of the Software or related support.  *  * Copyright 1994-1998 Network Computing Services, Inc.  *  * Copies of this Software may be made, however, the above copyright  * notice must be reproduced on all copies.  *  *	@(#) $FreeBSD$  *  */
end_comment

begin_comment
comment|/*  * IP Over ATM Support  * -------------------  *  * Virtual Channel Manager  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netatm/port.h>
end_include

begin_include
include|#
directive|include
file|<netatm/queue.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sys.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sap.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_cm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_if.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_stack.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_var.h>
end_include

begin_include
include|#
directive|include
file|<netatm/ipatm/ipatm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/ipatm/ipatm_var.h>
end_include

begin_include
include|#
directive|include
file|<netatm/ipatm/ipatm_serv.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"@(#) $FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|Atm_attributes
name|ipatm_aal5llc
init|=
block|{
name|NULL
block|,
comment|/* nif */
name|CMAPI_CPCS
block|,
comment|/* api */
literal|0
block|,
comment|/* api_init */
literal|0
block|,
comment|/* headin */
literal|0
block|,
comment|/* headout */
block|{
comment|/* aal */
name|T_ATM_PRESENT
block|,
name|ATM_AAL5
block|}
block|,
block|{
comment|/* traffic */
name|T_ATM_PRESENT
block|,
block|{
block|{
name|T_ATM_ABSENT
block|,
literal|0
block|,
name|T_ATM_ABSENT
block|,
name|T_ATM_ABSENT
block|,
name|T_ATM_ABSENT
block|,
name|T_ATM_ABSENT
block|,
name|T_NO
block|}
block|,
block|{
name|T_ATM_ABSENT
block|,
literal|0
block|,
name|T_ATM_ABSENT
block|,
name|T_ATM_ABSENT
block|,
name|T_ATM_ABSENT
block|,
name|T_ATM_ABSENT
block|,
name|T_NO
block|}
block|,
name|T_YES
block|}
block|, 	}
block|,
block|{
comment|/* bearer */
name|T_ATM_PRESENT
block|,
block|{
name|T_ATM_CLASS_X
block|,
name|T_ATM_NULL
block|,
name|T_ATM_NULL
block|,
name|T_NO
block|,
name|T_ATM_1_TO_1
block|}
block|}
block|,
block|{
comment|/* bhli */
name|T_ATM_ABSENT
block|}
block|,
block|{
comment|/* blli */
name|T_ATM_PRESENT
block|,
name|T_ATM_ABSENT
block|,
block|{
block|{
name|T_ATM_SIMPLE_ID
block|, 			}
block|,
block|{
name|T_ATM_ABSENT
block|}
block|}
block|}
block|,
block|{
comment|/* llc */
name|T_ATM_PRESENT
block|,
block|{
name|T_ATM_LLC_SHARING
block|,
name|IPATM_LLC_LEN
block|,
name|IPATM_LLC_HDR
block|}
block|}
block|,
block|{
comment|/* called */
name|T_ATM_PRESENT
block|, 	}
block|,
block|{
comment|/* calling */
name|T_ATM_ABSENT
block|}
block|,
block|{
comment|/* qos */
name|T_ATM_PRESENT
block|,
block|{
name|T_ATM_NETWORK_CODING
block|,
block|{
name|T_ATM_QOS_CLASS_0
block|, 			}
block|,
block|{
name|T_ATM_QOS_CLASS_0
block|}
block|}
block|}
block|,
block|{
comment|/* transit */
name|T_ATM_ABSENT
block|}
block|,
block|{
comment|/* cause */
name|T_ATM_ABSENT
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Atm_attributes
name|ipatm_aal5null
init|=
block|{
name|NULL
block|,
comment|/* nif */
name|CMAPI_CPCS
block|,
comment|/* api */
literal|0
block|,
comment|/* api_init */
sizeof|sizeof
argument_list|(
expr|struct
name|ifnet
operator|*
argument_list|)
block|,
comment|/* headin */
literal|0
block|,
comment|/* headout */
block|{
comment|/* aal */
name|T_ATM_PRESENT
block|,
name|ATM_AAL5
block|}
block|,
block|{
comment|/* traffic */
name|T_ATM_PRESENT
block|,
block|{
block|{
name|T_ATM_ABSENT
block|,
literal|0
block|,
name|T_ATM_ABSENT
block|,
name|T_ATM_ABSENT
block|,
name|T_ATM_ABSENT
block|,
name|T_ATM_ABSENT
block|,
name|T_NO
block|}
block|,
block|{
name|T_ATM_ABSENT
block|,
literal|0
block|,
name|T_ATM_ABSENT
block|,
name|T_ATM_ABSENT
block|,
name|T_ATM_ABSENT
block|,
name|T_ATM_ABSENT
block|,
name|T_NO
block|}
block|,
name|T_YES
block|}
block|, 	}
block|,
block|{
comment|/* bearer */
name|T_ATM_PRESENT
block|,
block|{
name|T_ATM_CLASS_X
block|,
name|T_ATM_NULL
block|,
name|T_ATM_NULL
block|,
name|T_NO
block|,
name|T_ATM_1_TO_1
block|}
block|}
block|,
block|{
comment|/* bhli */
name|T_ATM_ABSENT
block|}
block|,
block|{
comment|/* blli */
name|T_ATM_ABSENT
block|,
name|T_ATM_ABSENT
block|}
block|,
block|{
comment|/* llc */
name|T_ATM_ABSENT
block|}
block|,
block|{
comment|/* called */
name|T_ATM_PRESENT
block|, 	}
block|,
block|{
comment|/* calling */
name|T_ATM_ABSENT
block|}
block|,
block|{
comment|/* qos */
name|T_ATM_PRESENT
block|,
block|{
name|T_ATM_NETWORK_CODING
block|,
block|{
name|T_ATM_QOS_CLASS_0
block|, 			}
block|,
block|{
name|T_ATM_QOS_CLASS_0
block|}
block|}
block|}
block|,
block|{
comment|/* transit */
name|T_ATM_ABSENT
block|}
block|,
block|{
comment|/* cause */
name|T_ATM_ABSENT
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Atm_attributes
name|ipatm_aal4null
init|=
block|{
name|NULL
block|,
comment|/* nif */
name|CMAPI_CPCS
block|,
comment|/* api */
literal|0
block|,
comment|/* api_init */
sizeof|sizeof
argument_list|(
expr|struct
name|ifnet
operator|*
argument_list|)
block|,
comment|/* headin */
literal|0
block|,
comment|/* headout */
block|{
comment|/* aal */
name|T_ATM_PRESENT
block|,
name|ATM_AAL3_4
block|}
block|,
block|{
comment|/* traffic */
name|T_ATM_PRESENT
block|,
block|{
block|{
name|T_ATM_ABSENT
block|,
literal|0
block|,
name|T_ATM_ABSENT
block|,
name|T_ATM_ABSENT
block|,
name|T_ATM_ABSENT
block|,
name|T_ATM_ABSENT
block|,
name|T_NO
block|}
block|,
block|{
name|T_ATM_ABSENT
block|,
literal|0
block|,
name|T_ATM_ABSENT
block|,
name|T_ATM_ABSENT
block|,
name|T_ATM_ABSENT
block|,
name|T_ATM_ABSENT
block|,
name|T_NO
block|}
block|,
name|T_YES
block|}
block|, 	}
block|,
block|{
comment|/* bearer */
name|T_ATM_PRESENT
block|,
block|{
name|T_ATM_CLASS_X
block|,
name|T_ATM_NULL
block|,
name|T_ATM_NULL
block|,
name|T_NO
block|,
name|T_ATM_1_TO_1
block|}
block|}
block|,
block|{
comment|/* bhli */
name|T_ATM_ABSENT
block|}
block|,
block|{
comment|/* blli */
name|T_ATM_ABSENT
block|,
name|T_ATM_ABSENT
block|}
block|,
block|{
comment|/* llc */
name|T_ATM_ABSENT
block|}
block|,
block|{
comment|/* called */
name|T_ATM_PRESENT
block|, 	}
block|,
block|{
comment|/* calling */
name|T_ATM_ABSENT
block|}
block|,
block|{
comment|/* qos */
name|T_ATM_PRESENT
block|,
block|{
name|T_ATM_NETWORK_CODING
block|,
block|{
name|T_ATM_QOS_CLASS_0
block|, 			}
block|,
block|{
name|T_ATM_QOS_CLASS_0
block|}
block|}
block|}
block|,
block|{
comment|/* transit */
name|T_ATM_ABSENT
block|}
block|,
block|{
comment|/* cause */
name|T_ATM_ABSENT
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|t_atm_cause
name|ipatm_cause
init|=
block|{
name|T_ATM_ITU_CODING
block|,
name|T_ATM_LOC_USER
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Open an IP PVC  *   * This function will perform all actions necessary to activate a  * PVC for IP usage.  In particular, it will allocate control blocks,   * open the PVC, initialize PVC stack, and initiate whatever ARP  * procedures are required.  *  * Arguments:  *	pvp	pointer to PVC parameter structure  *	sivp	address to return pointer to IP PVC control block  *  * Returns:  *	0 	PVC was successfully opened  *	errno	open failed - reason indicated  *  */
end_comment

begin_function
name|int
name|ipatm_openpvc
parameter_list|(
name|pvp
parameter_list|,
name|sivp
parameter_list|)
name|struct
name|ipatmpvc
modifier|*
name|pvp
decl_stmt|;
name|struct
name|ipvcc
modifier|*
modifier|*
name|sivp
decl_stmt|;
block|{
name|struct
name|ipvcc
modifier|*
name|ivp
decl_stmt|;
name|Atm_attributes
modifier|*
name|ap
decl_stmt|;
name|Atm_addr_pvc
modifier|*
name|pvcp
decl_stmt|;
name|struct
name|atm_nif
modifier|*
name|nip
decl_stmt|;
name|struct
name|ip_nif
modifier|*
name|inp
decl_stmt|;
name|int
name|s
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
name|inp
operator|=
name|pvp
operator|->
name|ipp_ipnif
expr_stmt|;
name|nip
operator|=
name|inp
operator|->
name|inf_nif
expr_stmt|;
comment|/* 	 * Make sure interface is ready to go 	 */
if|if
condition|(
name|inp
operator|->
name|inf_state
operator|!=
name|IPNIF_ACTIVE
condition|)
block|{
name|err
operator|=
name|ENETDOWN
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Validate fixed destination IP address 	 */
if|if
condition|(
name|pvp
operator|->
name|ipp_dst
operator|.
name|sin_addr
operator|.
name|s_addr
operator|!=
name|INADDR_ANY
condition|)
block|{
if|#
directive|if
operator|(
name|defined
argument_list|(
name|BSD
argument_list|)
operator|&&
operator|(
name|BSD
operator|>=
literal|199306
operator|)
operator|)
if|if
condition|(
name|in_broadcast
argument_list|(
name|pvp
operator|->
name|ipp_dst
operator|.
name|sin_addr
argument_list|,
operator|&
name|nip
operator|->
name|nif_if
argument_list|)
operator|||
else|#
directive|else
if|if
condition|(
name|in_broadcast
argument_list|(
name|pvp
operator|->
name|ipp_dst
operator|.
name|sin_addr
argument_list|)
operator|||
endif|#
directive|endif
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|pvp
operator|->
name|ipp_dst
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|)
operator|||
name|ipatm_chknif
argument_list|(
name|pvp
operator|->
name|ipp_dst
operator|.
name|sin_addr
argument_list|,
name|inp
argument_list|)
condition|)
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
comment|/* 	 * Allocate IP VCC block 	 */
name|ivp
operator|=
operator|(
expr|struct
name|ipvcc
operator|*
operator|)
name|atm_allocate
argument_list|(
operator|&
name|ipatm_vcpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|ivp
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Initialize the PVC 	 */
name|ivp
operator|->
name|iv_flags
operator|=
name|IVF_PVC
expr_stmt|;
if|if
condition|(
name|pvp
operator|->
name|ipp_encaps
operator|==
name|ATM_ENC_LLC
condition|)
name|ivp
operator|->
name|iv_flags
operator||=
name|IVF_LLC
expr_stmt|;
comment|/* 	 * Fill out connection attributes 	 */
if|if
condition|(
name|pvp
operator|->
name|ipp_aal
operator|==
name|ATM_AAL5
condition|)
block|{
if|if
condition|(
name|pvp
operator|->
name|ipp_encaps
operator|==
name|ATM_ENC_LLC
condition|)
name|ap
operator|=
operator|&
name|ipatm_aal5llc
expr_stmt|;
else|else
name|ap
operator|=
operator|&
name|ipatm_aal5null
expr_stmt|;
block|}
else|else
block|{
name|ap
operator|=
operator|&
name|ipatm_aal4null
expr_stmt|;
block|}
name|ap
operator|->
name|nif
operator|=
name|nip
expr_stmt|;
name|ap
operator|->
name|traffic
operator|.
name|v
operator|.
name|forward
operator|.
name|PCR_all_traffic
operator|=
name|nip
operator|->
name|nif_pif
operator|->
name|pif_pcr
expr_stmt|;
name|ap
operator|->
name|traffic
operator|.
name|v
operator|.
name|backward
operator|.
name|PCR_all_traffic
operator|=
name|nip
operator|->
name|nif_pif
operator|->
name|pif_pcr
expr_stmt|;
name|ap
operator|->
name|called
operator|.
name|addr
operator|.
name|address_format
operator|=
name|T_ATM_PVC_ADDR
expr_stmt|;
name|ap
operator|->
name|called
operator|.
name|addr
operator|.
name|address_length
operator|=
sizeof|sizeof
argument_list|(
name|Atm_addr_pvc
argument_list|)
expr_stmt|;
name|pvcp
operator|=
operator|(
name|Atm_addr_pvc
operator|*
operator|)
name|ap
operator|->
name|called
operator|.
name|addr
operator|.
name|address
expr_stmt|;
name|ATM_PVC_SET_VPI
argument_list|(
name|pvcp
argument_list|,
name|pvp
operator|->
name|ipp_vpi
argument_list|)
expr_stmt|;
name|ATM_PVC_SET_VCI
argument_list|(
name|pvcp
argument_list|,
name|pvp
operator|->
name|ipp_vci
argument_list|)
expr_stmt|;
name|ap
operator|->
name|called
operator|.
name|subaddr
operator|.
name|address_format
operator|=
name|T_ATM_ABSENT
expr_stmt|;
name|ap
operator|->
name|called
operator|.
name|subaddr
operator|.
name|address_length
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Create PVC 	 */
name|err
operator|=
name|atm_cm_connect
argument_list|(
operator|&
name|ipatm_endpt
argument_list|,
name|ivp
argument_list|,
name|ap
argument_list|,
operator|&
name|ivp
operator|->
name|iv_conn
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|atm_free
argument_list|(
operator|(
name|caddr_t
operator|)
name|ivp
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Save PVC information and link in VCC 	 */
comment|/* ivp->iv_ = ap->headout; */
comment|/* 	 * Queue VCC onto its network interface 	 */
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|ipatm_vccnt
operator|++
expr_stmt|;
name|ENQUEUE
argument_list|(
name|ivp
argument_list|,
expr|struct
name|ipvcc
argument_list|,
name|iv_elem
argument_list|,
name|inp
operator|->
name|inf_vcq
argument_list|)
expr_stmt|;
name|ivp
operator|->
name|iv_ipnif
operator|=
name|inp
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Set destination IP address and IPVCC state 	 */
if|if
condition|(
name|pvp
operator|->
name|ipp_dst
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
block|{
comment|/* 		 * Initiate ARP processing 		 */
switch|switch
condition|(
call|(
modifier|*
name|inp
operator|->
name|inf_serv
operator|->
name|is_arp_pvcopen
call|)
argument_list|(
name|ivp
argument_list|)
condition|)
block|{
case|case
name|MAP_PROCEEDING
case|:
comment|/* 			 * Wait for answer 			 */
name|ivp
operator|->
name|iv_state
operator|=
name|IPVCC_ACTIVE
expr_stmt|;
break|break;
case|case
name|MAP_VALID
case|:
comment|/* 			 * We've got our answer already 			 */
name|ivp
operator|->
name|iv_state
operator|=
name|IPVCC_ACTIVE
expr_stmt|;
name|ivp
operator|->
name|iv_flags
operator||=
name|IVF_MAPOK
expr_stmt|;
name|ivp
operator|->
name|iv_dst
operator|.
name|s_addr
operator|=
name|ivp
operator|->
name|iv_arpent
operator|->
name|am_dstip
operator|.
name|s_addr
expr_stmt|;
break|break;
case|case
name|MAP_FAILED
case|:
comment|/* 			 * Try again later 			 */
name|ivp
operator|->
name|iv_state
operator|=
name|IPVCC_ACTPENT
expr_stmt|;
name|IPVCC_TIMER
argument_list|(
name|ivp
argument_list|,
literal|1
operator|*
name|ATM_HZ
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"ipatm_openpvc: invalid arp_pvcopen return"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Use configured IP destination 		 */
name|ivp
operator|->
name|iv_dst
operator|.
name|s_addr
operator|=
name|pvp
operator|->
name|ipp_dst
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|ivp
operator|->
name|iv_state
operator|=
name|IPVCC_ACTIVE
expr_stmt|;
name|ivp
operator|->
name|iv_flags
operator||=
name|IVF_MAPOK
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
name|err
condition|)
operator|*
name|sivp
operator|=
name|NULL
expr_stmt|;
else|else
operator|*
name|sivp
operator|=
name|ivp
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create an IP SVC  *   * This function will initiate the creation of an IP SVC.  The IP VCC  * control block will be initialized and, if required, we will initiate  * ARP processing in order to resolve the destination's ATM address.  Once  * the destination ATM address is known, ipatm_opensvc() will be called.  *  * Arguments:  *	ifp	pointer to destination ifnet structure  *	daf	destination address family type  *	dst	pointer to destination address  *	sivp	address to return pointer to IP SVC control block  *  * Returns:  *	0 	SVC creation was successfully initiated  *	errno	creation failed - reason indicated  *  */
end_comment

begin_function
name|int
name|ipatm_createsvc
parameter_list|(
name|ifp
parameter_list|,
name|daf
parameter_list|,
name|dst
parameter_list|,
name|sivp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_short
name|daf
decl_stmt|;
name|caddr_t
name|dst
decl_stmt|;
name|struct
name|ipvcc
modifier|*
modifier|*
name|sivp
decl_stmt|;
block|{
name|struct
name|atm_nif
modifier|*
name|nip
init|=
operator|(
expr|struct
name|atm_nif
operator|*
operator|)
name|ifp
decl_stmt|;
name|struct
name|ip_nif
modifier|*
name|inp
decl_stmt|;
name|struct
name|ipvcc
modifier|*
name|ivp
decl_stmt|;
name|struct
name|in_addr
modifier|*
name|ip
decl_stmt|;
name|Atm_addr
modifier|*
name|atm
decl_stmt|;
name|int
name|s
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
comment|/* 	 * Get IP interface and make sure its ready 	 */
for|for
control|(
name|inp
operator|=
name|ipatm_nif_head
init|;
name|inp
condition|;
name|inp
operator|=
name|inp
operator|->
name|inf_next
control|)
block|{
if|if
condition|(
name|inp
operator|->
name|inf_nif
operator|==
name|nip
condition|)
break|break;
block|}
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|inp
operator|->
name|inf_state
operator|!=
name|IPNIF_ACTIVE
condition|)
block|{
name|err
operator|=
name|ENETDOWN
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Validate destination address 	 */
if|if
condition|(
name|daf
operator|==
name|AF_INET
condition|)
block|{
comment|/* 		 * Destination is IP address 		 */
name|ip
operator|=
operator|(
expr|struct
name|in_addr
operator|*
operator|)
name|dst
expr_stmt|;
name|atm
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|s_addr
operator|==
name|INADDR_ANY
condition|)
block|{
name|err
operator|=
name|EADDRNOTAVAIL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|daf
operator|==
name|AF_ATM
condition|)
block|{
comment|/* 		 * Destination is ATM address 		 */
name|atm
operator|=
operator|(
name|Atm_addr
operator|*
operator|)
name|dst
expr_stmt|;
name|ip
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|atm
operator|->
name|address_format
operator|==
name|T_ATM_ABSENT
condition|)
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
else|else
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Make sure we have services provider and ARP support 	 */
if|if
condition|(
operator|(
name|inp
operator|->
name|inf_serv
operator|==
name|NULL
operator|)
operator|||
operator|(
name|inp
operator|->
name|inf_serv
operator|->
name|is_arp_svcout
operator|==
name|NULL
operator|)
condition|)
block|{
name|err
operator|=
name|ENETDOWN
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Allocate IP VCC 	 */
name|ivp
operator|=
operator|(
expr|struct
name|ipvcc
operator|*
operator|)
name|atm_allocate
argument_list|(
operator|&
name|ipatm_vcpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|ivp
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Initialize SVC 	 */
name|ivp
operator|->
name|iv_flags
operator|=
name|IVF_SVC
expr_stmt|;
name|ivp
operator|->
name|iv_ipnif
operator|=
name|inp
expr_stmt|;
comment|/* 	 * Get destination ATM address 	 */
if|if
condition|(
name|daf
operator|==
name|AF_INET
condition|)
block|{
comment|/* 		 * ARP is the way... 		 */
name|ivp
operator|->
name|iv_dst
operator|.
name|s_addr
operator|=
name|ip
operator|->
name|s_addr
expr_stmt|;
switch|switch
condition|(
call|(
modifier|*
name|inp
operator|->
name|inf_serv
operator|->
name|is_arp_svcout
call|)
argument_list|(
name|ivp
argument_list|,
name|ip
argument_list|)
condition|)
block|{
case|case
name|MAP_PROCEEDING
case|:
comment|/* 			 * Wait for answer 			 */
name|ivp
operator|->
name|iv_state
operator|=
name|IPVCC_PMAP
expr_stmt|;
name|IPVCC_TIMER
argument_list|(
name|ivp
argument_list|,
name|IPATM_ARP_TIME
argument_list|)
expr_stmt|;
break|break;
case|case
name|MAP_VALID
case|:
comment|/* 			 * We've got our answer already, so open SVC 			 */
name|ivp
operator|->
name|iv_flags
operator||=
name|IVF_MAPOK
expr_stmt|;
name|err
operator|=
name|ipatm_opensvc
argument_list|(
name|ivp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
call|(
modifier|*
name|inp
operator|->
name|inf_serv
operator|->
name|is_arp_close
call|)
argument_list|(
name|ivp
argument_list|)
expr_stmt|;
name|atm_free
argument_list|(
operator|(
name|caddr_t
operator|)
name|ivp
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
break|break;
case|case
name|MAP_FAILED
case|:
comment|/* 			 * So sorry...come again 			 */
name|atm_free
argument_list|(
operator|(
name|caddr_t
operator|)
name|ivp
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENETDOWN
expr_stmt|;
goto|goto
name|done
goto|;
default|default:
name|panic
argument_list|(
literal|"ipatm_createsvc: invalid arp_svcout return"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * We were given the ATM address, so open the SVC 		 * 		 * Create temporary arp map entry so that opensvc() works. 		 * Caller must set up a permanent entry immediately! (yuk) 		 */
name|struct
name|arpmap
name|map
decl_stmt|;
name|ATM_ADDR_COPY
argument_list|(
name|atm
argument_list|,
operator|&
name|map
operator|.
name|am_dstatm
argument_list|)
expr_stmt|;
name|map
operator|.
name|am_dstatmsub
operator|.
name|address_format
operator|=
name|T_ATM_ABSENT
expr_stmt|;
name|map
operator|.
name|am_dstatmsub
operator|.
name|address_length
operator|=
literal|0
expr_stmt|;
name|ivp
operator|->
name|iv_arpent
operator|=
operator|&
name|map
expr_stmt|;
name|err
operator|=
name|ipatm_opensvc
argument_list|(
name|ivp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|atm_free
argument_list|(
operator|(
name|caddr_t
operator|)
name|ivp
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|ivp
operator|->
name|iv_arpent
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Queue VCC onto its network interface 	 */
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|ipatm_vccnt
operator|++
expr_stmt|;
name|ENQUEUE
argument_list|(
name|ivp
argument_list|,
expr|struct
name|ipvcc
argument_list|,
name|iv_elem
argument_list|,
name|inp
operator|->
name|inf_vcq
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|err
condition|)
operator|*
name|sivp
operator|=
name|NULL
expr_stmt|;
else|else
operator|*
name|sivp
operator|=
name|ivp
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Open an IP SVC  *   * This function will continue the IP SVC creation process.  Here, we  * will issue an SVC open to the signalling manager and then wait for  * the final SVC setup results.  *  * Arguments:  *	ivp	pointer to IP SVC to open  *  * Returns:  *	0 	SVC open was successfully initiated  *	errno	open failed - reason indicated  *  */
end_comment

begin_function
name|int
name|ipatm_opensvc
parameter_list|(
name|ivp
parameter_list|)
name|struct
name|ipvcc
modifier|*
name|ivp
decl_stmt|;
block|{
name|struct
name|ip_nif
modifier|*
name|inp
init|=
name|ivp
operator|->
name|iv_ipnif
decl_stmt|;
name|Atm_attributes
modifier|*
name|ap
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
comment|/* 	 * Cancel possible arp timeout 	 */
name|IPVCC_CANCEL
argument_list|(
name|ivp
argument_list|)
expr_stmt|;
comment|/* 	 * Fill out connection attributes 	 */
name|i
operator|=
name|ivp
operator|->
name|iv_parmx
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|inf_serv
operator|->
name|is_vccparm
index|[
name|i
index|]
operator|.
name|ivc_aal
operator|==
name|ATM_AAL5
condition|)
block|{
if|if
condition|(
name|inp
operator|->
name|inf_serv
operator|->
name|is_vccparm
index|[
name|i
index|]
operator|.
name|ivc_encaps
operator|==
name|ATM_ENC_LLC
condition|)
block|{
name|ap
operator|=
operator|&
name|ipatm_aal5llc
expr_stmt|;
name|ivp
operator|->
name|iv_flags
operator||=
name|IVF_LLC
expr_stmt|;
block|}
else|else
block|{
name|ap
operator|=
operator|&
name|ipatm_aal5null
expr_stmt|;
name|ivp
operator|->
name|iv_flags
operator|&=
operator|~
name|IVF_LLC
expr_stmt|;
block|}
block|}
else|else
block|{
name|ap
operator|=
operator|&
name|ipatm_aal4null
expr_stmt|;
name|ivp
operator|->
name|iv_flags
operator|&=
operator|~
name|IVF_LLC
expr_stmt|;
block|}
name|ap
operator|->
name|nif
operator|=
name|inp
operator|->
name|inf_nif
expr_stmt|;
name|ap
operator|->
name|traffic
operator|.
name|v
operator|.
name|forward
operator|.
name|PCR_all_traffic
operator|=
name|inp
operator|->
name|inf_nif
operator|->
name|nif_pif
operator|->
name|pif_pcr
expr_stmt|;
name|ap
operator|->
name|traffic
operator|.
name|v
operator|.
name|backward
operator|.
name|PCR_all_traffic
operator|=
name|inp
operator|->
name|inf_nif
operator|->
name|nif_pif
operator|->
name|pif_pcr
expr_stmt|;
name|ATM_ADDR_COPY
argument_list|(
operator|&
name|ivp
operator|->
name|iv_arpent
operator|->
name|am_dstatm
argument_list|,
operator|&
name|ap
operator|->
name|called
operator|.
name|addr
argument_list|)
expr_stmt|;
name|ATM_ADDR_COPY
argument_list|(
operator|&
name|ivp
operator|->
name|iv_arpent
operator|->
name|am_dstatmsub
argument_list|,
operator|&
name|ap
operator|->
name|called
operator|.
name|subaddr
argument_list|)
expr_stmt|;
comment|/* 	 * Initiate SVC open 	 */
name|err
operator|=
name|atm_cm_connect
argument_list|(
operator|&
name|ipatm_endpt
argument_list|,
name|ivp
argument_list|,
name|ap
argument_list|,
operator|&
name|ivp
operator|->
name|iv_conn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|err
condition|)
block|{
case|case
name|EINPROGRESS
case|:
comment|/* 		 * Call is progressing 		 */
comment|/* ivp->iv_ = ap->headout; */
comment|/* 		 * Now we just wait for a CALL_CONNECTED event 		 */
name|ivp
operator|->
name|iv_state
operator|=
name|IPVCC_POPEN
expr_stmt|;
name|IPVCC_TIMER
argument_list|(
name|ivp
argument_list|,
name|IPATM_SVC_TIME
argument_list|)
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* 		 * We've been hooked up with a shared VCC 		 */
comment|/* ivp->iv_ = ap->headout; */
name|ipatm_activate
argument_list|(
name|ivp
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Retry an IP SVC Open  *   * This function will attempt to retry a failed SVC open request.  The IP  * interface service provider specifies a list of possible VCC parameters  * for IP to use.  We will try each set of parameters in turn until either  * an open succeeds or we reach the end of the list.  *   * Arguments:  *	ivp	pointer to IP SVC  *  * Returns:  *	0 	SVC (re)open was successfully initiated  *	else	retry failed  *  */
end_comment

begin_function
name|int
name|ipatm_retrysvc
parameter_list|(
name|ivp
parameter_list|)
name|struct
name|ipvcc
modifier|*
name|ivp
decl_stmt|;
block|{
name|struct
name|ip_nif
modifier|*
name|inp
init|=
name|ivp
operator|->
name|iv_ipnif
decl_stmt|;
comment|/* 	 * If there isn't another set of vcc parameters to try, return 	 */
if|if
condition|(
operator|(
operator|++
name|ivp
operator|->
name|iv_parmx
operator|>=
name|IPATM_VCCPARMS
operator|)
operator|||
operator|(
name|inp
operator|->
name|inf_serv
operator|->
name|is_vccparm
index|[
name|ivp
operator|->
name|iv_parmx
index|]
operator|.
name|ivc_aal
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * Okay, now initiate open with a new set of parameters 	 */
return|return
operator|(
name|ipatm_opensvc
argument_list|(
name|ivp
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Finish IP SVC Activation  *   * Arguments:  *	ivp	pointer to IP SVC  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|ipatm_activate
parameter_list|(
name|ivp
parameter_list|)
name|struct
name|ipvcc
modifier|*
name|ivp
decl_stmt|;
block|{
comment|/* 	 * Connection is now active 	 */
name|ivp
operator|->
name|iv_state
operator|=
name|IPVCC_ACTIVE
expr_stmt|;
name|IPVCC_CANCEL
argument_list|(
name|ivp
argument_list|)
expr_stmt|;
comment|/* 	 * Tell ARP module that connection is active 	 */
if|if
condition|(
call|(
modifier|*
name|ivp
operator|->
name|iv_ipnif
operator|->
name|inf_serv
operator|->
name|is_arp_svcact
call|)
argument_list|(
name|ivp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|ipatm_closevc
argument_list|(
name|ivp
argument_list|,
name|T_ATM_CAUSE_TEMPORARY_FAILURE
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Send any queued packet 	 */
if|if
condition|(
operator|(
name|ivp
operator|->
name|iv_flags
operator|&
name|IVF_MAPOK
operator|)
operator|&&
name|ivp
operator|->
name|iv_queue
condition|)
block|{
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|ivp
operator|->
name|iv_dst
operator|.
name|s_addr
expr_stmt|;
name|ifp
operator|=
operator|(
expr|struct
name|ifnet
operator|*
operator|)
name|ivp
operator|->
name|iv_ipnif
operator|->
name|inf_nif
expr_stmt|;
operator|(
name|void
operator|)
name|ipatm_ifoutput
argument_list|(
name|ifp
argument_list|,
name|ivp
operator|->
name|iv_queue
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|)
expr_stmt|;
name|ivp
operator|->
name|iv_queue
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Process Incoming Calls  *   * This function will receive control when an incoming call has been matched  * to one of our registered listen parameter blocks.  Assuming the call passes  * acceptance criteria and all required resources are available, we will  * create an IP SVC and notify the connection manager of our decision.  We  * will then await notification of the final SVC setup results.  If any  * problems are encountered, we will just tell the connection manager to  * reject the call.  *  * Called at splnet.  *  * Arguments:  *	tok	owner's matched listening token  *	cop	pointer to incoming call's connection block  *	ap	pointer to incoming call's attributes  *	tokp	pointer to location to store our connection token  *  * Returns:  *	0	call is accepted  *	errno	call rejected - reason indicated  *  */
end_comment

begin_function
name|int
name|ipatm_incoming
parameter_list|(
name|tok
parameter_list|,
name|cop
parameter_list|,
name|ap
parameter_list|,
name|tokp
parameter_list|)
name|void
modifier|*
name|tok
decl_stmt|;
name|Atm_connection
modifier|*
name|cop
decl_stmt|;
name|Atm_attributes
modifier|*
name|ap
decl_stmt|;
name|void
modifier|*
modifier|*
name|tokp
decl_stmt|;
block|{
name|struct
name|atm_nif
modifier|*
name|nip
init|=
name|ap
operator|->
name|nif
decl_stmt|;
name|struct
name|ip_nif
modifier|*
name|inp
decl_stmt|;
name|struct
name|ipvcc
modifier|*
name|ivp
init|=
name|NULL
decl_stmt|;
name|int
name|err
decl_stmt|,
name|cause
decl_stmt|;
name|int
name|usellc
init|=
literal|0
decl_stmt|,
name|mtu
init|=
name|ATM_NIF_MTU
decl_stmt|;
comment|/* 	 * Get IP interface and make sure its ready 	 */
for|for
control|(
name|inp
operator|=
name|ipatm_nif_head
init|;
name|inp
condition|;
name|inp
operator|=
name|inp
operator|->
name|inf_next
control|)
block|{
if|if
condition|(
name|inp
operator|->
name|inf_nif
operator|==
name|nip
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|inp
operator|==
name|NULL
operator|)
operator|||
operator|(
name|inp
operator|->
name|inf_state
operator|!=
name|IPNIF_ACTIVE
operator|)
condition|)
block|{
name|err
operator|=
name|ENETUNREACH
expr_stmt|;
name|cause
operator|=
name|T_ATM_CAUSE_SERVICE_OR_OPTION_UNAVAILABLE
expr_stmt|;
goto|goto
name|reject
goto|;
block|}
comment|/* 	 * Make sure we have services provider and ARP support 	 */
if|if
condition|(
operator|(
name|inp
operator|->
name|inf_serv
operator|==
name|NULL
operator|)
operator|||
operator|(
name|inp
operator|->
name|inf_serv
operator|->
name|is_arp_svcin
operator|==
name|NULL
operator|)
condition|)
block|{
name|err
operator|=
name|ENETUNREACH
expr_stmt|;
name|cause
operator|=
name|T_ATM_CAUSE_SERVICE_OR_OPTION_UNAVAILABLE
expr_stmt|;
goto|goto
name|reject
goto|;
block|}
comment|/* 	 * Check for LLC encapsulation 	 */
if|if
condition|(
operator|(
name|ap
operator|->
name|blli
operator|.
name|tag_l2
operator|==
name|T_ATM_PRESENT
operator|)
operator|&&
operator|(
name|ap
operator|->
name|blli
operator|.
name|v
operator|.
name|layer_2_protocol
operator|.
name|ID_type
operator|==
name|T_ATM_SIMPLE_ID
operator|)
operator|&&
operator|(
name|ap
operator|->
name|blli
operator|.
name|v
operator|.
name|layer_2_protocol
operator|.
name|ID
operator|.
name|simple_ID
operator|==
name|T_ATM_BLLI2_I8802
operator|)
condition|)
block|{
name|usellc
operator|=
literal|1
expr_stmt|;
name|mtu
operator|+=
name|IPATM_LLC_LEN
expr_stmt|;
block|}
comment|/* 	 * Verify requested MTU 	 */
if|if
condition|(
name|ap
operator|->
name|aal
operator|.
name|type
operator|==
name|ATM_AAL5
condition|)
block|{
if|if
condition|(
operator|(
name|ap
operator|->
name|aal
operator|.
name|v
operator|.
name|aal5
operator|.
name|forward_max_SDU_size
operator|>
name|mtu
operator|)
operator|||
operator|(
name|ap
operator|->
name|aal
operator|.
name|v
operator|.
name|aal5
operator|.
name|backward_max_SDU_size
operator|<
name|mtu
operator|)
condition|)
block|{
name|err
operator|=
name|ENETUNREACH
expr_stmt|;
name|cause
operator|=
name|T_ATM_CAUSE_AAL_PARAMETERS_NOT_SUPPORTED
expr_stmt|;
goto|goto
name|reject
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ap
operator|->
name|aal
operator|.
name|v
operator|.
name|aal4
operator|.
name|forward_max_SDU_size
operator|>
name|mtu
operator|)
operator|||
operator|(
name|ap
operator|->
name|aal
operator|.
name|v
operator|.
name|aal4
operator|.
name|backward_max_SDU_size
operator|<
name|mtu
operator|)
condition|)
block|{
name|err
operator|=
name|ENETUNREACH
expr_stmt|;
name|cause
operator|=
name|T_ATM_CAUSE_AAL_PARAMETERS_NOT_SUPPORTED
expr_stmt|;
goto|goto
name|reject
goto|;
block|}
block|}
comment|/* 	 * Allocate IP VCC 	 */
name|ivp
operator|=
operator|(
expr|struct
name|ipvcc
operator|*
operator|)
name|atm_allocate
argument_list|(
operator|&
name|ipatm_vcpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|ivp
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|ENOMEM
expr_stmt|;
name|cause
operator|=
name|T_ATM_CAUSE_UNSPECIFIED_RESOURCE_UNAVAILABLE
expr_stmt|;
goto|goto
name|reject
goto|;
block|}
comment|/* 	 * Initialize SVC 	 */
name|ivp
operator|->
name|iv_flags
operator|=
name|IVF_SVC
expr_stmt|;
name|ivp
operator|->
name|iv_ipnif
operator|=
name|inp
expr_stmt|;
if|if
condition|(
name|usellc
condition|)
name|ivp
operator|->
name|iv_flags
operator||=
name|IVF_LLC
expr_stmt|;
comment|/* 	 * Lookup ARP entry for destination 	 */
switch|switch
condition|(
call|(
modifier|*
name|inp
operator|->
name|inf_serv
operator|->
name|is_arp_svcin
call|)
argument_list|(
name|ivp
argument_list|,
operator|&
name|ap
operator|->
name|calling
operator|.
name|addr
argument_list|,
operator|&
name|ap
operator|->
name|calling
operator|.
name|subaddr
argument_list|)
condition|)
block|{
case|case
name|MAP_PROCEEDING
case|:
comment|/* 		 * We'll be (hopefully) notified later 		 */
break|break;
case|case
name|MAP_VALID
case|:
comment|/* 		 * We've got our answer already 		 */
name|ivp
operator|->
name|iv_flags
operator||=
name|IVF_MAPOK
expr_stmt|;
name|ivp
operator|->
name|iv_dst
operator|.
name|s_addr
operator|=
name|ivp
operator|->
name|iv_arpent
operator|->
name|am_dstip
operator|.
name|s_addr
expr_stmt|;
break|break;
case|case
name|MAP_FAILED
case|:
comment|/* 		 * So sorry...come again 		 */
name|err
operator|=
name|ENETUNREACH
expr_stmt|;
name|cause
operator|=
name|T_ATM_CAUSE_SERVICE_OR_OPTION_UNAVAILABLE
expr_stmt|;
goto|goto
name|reject
goto|;
default|default:
name|panic
argument_list|(
literal|"ipatm_incoming: invalid arp_svcin return"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Accept SVC connection 	 */
name|ivp
operator|->
name|iv_state
operator|=
name|IPVCC_PACCEPT
expr_stmt|;
comment|/* 	 * Save VCC information 	 */
name|ivp
operator|->
name|iv_conn
operator|=
name|cop
expr_stmt|;
operator|*
name|tokp
operator|=
name|ivp
expr_stmt|;
comment|/* ivp->iv_ = ap->headout; */
comment|/* 	 * Queue VCC onto its network interface 	 */
name|ipatm_vccnt
operator|++
expr_stmt|;
name|ENQUEUE
argument_list|(
name|ivp
argument_list|,
expr|struct
name|ipvcc
argument_list|,
name|iv_elem
argument_list|,
name|inp
operator|->
name|inf_vcq
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for a CALL_CONNECTED event 	 */
name|IPVCC_TIMER
argument_list|(
name|ivp
argument_list|,
name|IPATM_SVC_TIME
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|reject
label|:
comment|/* 	 * Clean up after call failure 	 */
if|if
condition|(
name|ivp
condition|)
block|{
call|(
modifier|*
name|inp
operator|->
name|inf_serv
operator|->
name|is_arp_close
call|)
argument_list|(
name|ivp
argument_list|)
expr_stmt|;
name|atm_free
argument_list|(
operator|(
name|caddr_t
operator|)
name|ivp
argument_list|)
expr_stmt|;
block|}
name|ap
operator|->
name|cause
operator|.
name|tag
operator|=
name|T_ATM_PRESENT
expr_stmt|;
name|ap
operator|->
name|cause
operator|.
name|v
operator|=
name|ipatm_cause
expr_stmt|;
name|ap
operator|->
name|cause
operator|.
name|v
operator|.
name|cause_value
operator|=
name|cause
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close an IP VCC  *   * This function will close an IP VCC (PVC or SVC), including notifying   * the signalling and ARP subsystems of the VCC's demise and cleaning   * up memory after ourselves.  *  * Arguments:  *	ivp	pointer to VCC  *	code	cause code  *  * Returns:  *	0 	VCC successfully closed  *	errno	close failed - reason indicated  *  */
end_comment

begin_function
name|int
name|ipatm_closevc
parameter_list|(
name|ivp
parameter_list|,
name|code
parameter_list|)
name|struct
name|ipvcc
modifier|*
name|ivp
decl_stmt|;
name|int
name|code
decl_stmt|;
block|{
name|struct
name|ip_nif
modifier|*
name|inp
init|=
name|ivp
operator|->
name|iv_ipnif
decl_stmt|;
name|int
name|s
decl_stmt|,
name|err
decl_stmt|;
comment|/* 	 * Make sure VCC hasn't been through here already 	 */
switch|switch
condition|(
name|ivp
operator|->
name|iv_state
condition|)
block|{
case|case
name|IPVCC_FREE
case|:
return|return
operator|(
name|EALREADY
operator|)
return|;
block|}
comment|/* 	 * Reset lookup cache 	 */
if|if
condition|(
name|last_map_ipvcc
operator|==
name|ivp
condition|)
block|{
name|last_map_ipvcc
operator|=
name|NULL
expr_stmt|;
name|last_map_ipdst
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Tell ARP about SVCs and dynamic PVCs 	 */
if|if
condition|(
name|inp
operator|->
name|inf_serv
operator|&&
operator|(
operator|(
name|ivp
operator|->
name|iv_flags
operator|&
name|IVF_SVC
operator|)
operator|||
name|inp
operator|->
name|inf_serv
operator|->
name|is_arp_pvcopen
operator|)
condition|)
block|{
call|(
modifier|*
name|inp
operator|->
name|inf_serv
operator|->
name|is_arp_close
call|)
argument_list|(
name|ivp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Free queued packets 	 */
if|if
condition|(
name|ivp
operator|->
name|iv_queue
condition|)
name|KB_FREEALL
argument_list|(
name|ivp
operator|->
name|iv_queue
argument_list|)
expr_stmt|;
comment|/* 	 * Cancel any timers 	 */
name|IPVCC_CANCEL
argument_list|(
name|ivp
argument_list|)
expr_stmt|;
comment|/* 	 * Close VCC 	 */
switch|switch
condition|(
name|ivp
operator|->
name|iv_state
condition|)
block|{
case|case
name|IPVCC_PMAP
case|:
break|break;
case|case
name|IPVCC_POPEN
case|:
case|case
name|IPVCC_PACCEPT
case|:
case|case
name|IPVCC_ACTPENT
case|:
case|case
name|IPVCC_ACTIVE
case|:
name|ipatm_cause
operator|.
name|cause_value
operator|=
name|code
expr_stmt|;
name|err
operator|=
name|atm_cm_release
argument_list|(
name|ivp
operator|->
name|iv_conn
argument_list|,
operator|&
name|ipatm_cause
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ipatm_closevc: release fail: err=%d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IPVCC_CLOSED
case|:
break|break;
default|default:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ipatm_closevc: unknown state: ivp=%p, state=%d\n"
argument_list|,
name|ivp
argument_list|,
name|ivp
operator|->
name|iv_state
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Remove VCC from network i/f 	 */
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|DEQUEUE
argument_list|(
name|ivp
argument_list|,
expr|struct
name|ipvcc
argument_list|,
name|iv_elem
argument_list|,
name|inp
operator|->
name|inf_vcq
argument_list|)
expr_stmt|;
comment|/* 	 * Reset state just to be sure 	 */
name|ivp
operator|->
name|iv_state
operator|=
name|IPVCC_FREE
expr_stmt|;
comment|/* 	 * If ARP module is done with VCC too, then free it 	 */
if|if
condition|(
name|ivp
operator|->
name|iv_arpconn
operator|==
name|NULL
condition|)
name|atm_free
argument_list|(
operator|(
name|caddr_t
operator|)
name|ivp
argument_list|)
expr_stmt|;
name|ipatm_vccnt
operator|--
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check if IP address is valid on a Network Interface  *   * Checks whether the supplied IP address is allowed to be assigned to  * the supplied IP network interface.  *  * Arguments:  *	in	IP address  *	inp	pointer to IP network interface  *  * Returns:  *	0 - OK to assign  *	1 - not valid to assign  *  */
end_comment

begin_function
name|int
name|ipatm_chknif
parameter_list|(
name|in
parameter_list|,
name|inp
parameter_list|)
name|struct
name|in_addr
name|in
decl_stmt|;
name|struct
name|ip_nif
modifier|*
name|inp
decl_stmt|;
block|{
name|struct
name|in_ifaddr
modifier|*
name|ia
decl_stmt|;
name|u_long
name|i
decl_stmt|;
comment|/* 	 * Make sure there's an interface requested 	 */
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * Make sure we have an IP address 	 */
name|i
operator|=
name|ntohl
argument_list|(
name|in
operator|.
name|s_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * Make sure an interface address is set  	 */
name|ia
operator|=
name|inp
operator|->
name|inf_addr
expr_stmt|;
if|if
condition|(
name|ia
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * Make sure we're on the right subnet 	 */
if|if
condition|(
operator|(
name|i
operator|&
name|ia
operator|->
name|ia_subnetmask
operator|)
operator|!=
name|ia
operator|->
name|ia_subnet
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Map an IP Address to an IP VCC  *   * Given a destination IP address, this function will return a pointer  * to the appropriate output IP VCC to which to send the packet.  * This is currently implemented using a one-behind cache containing the   * last successful mapping result.  If the cache lookup fails, then a  * simple linear search of all IP VCCs on the destination network interface   * is performed.  This is obviously an area to look at for performance   * improvements.  *  * Arguments:  *	dst	pointer to destination IP address  *	nip	pointer to destination network interface  *  * Returns:  *	addr 	pointer to located IP VCC  *	0	no such mapping exists  *  */
end_comment

begin_function
name|struct
name|ipvcc
modifier|*
name|ipatm_iptovc
parameter_list|(
name|dst
parameter_list|,
name|nip
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|dst
decl_stmt|;
name|struct
name|atm_nif
modifier|*
name|nip
decl_stmt|;
block|{
name|struct
name|ip_nif
modifier|*
name|inp
decl_stmt|;
name|struct
name|ipvcc
modifier|*
name|ivp
decl_stmt|;
name|u_long
name|dstip
init|=
name|dst
operator|->
name|sin_addr
operator|.
name|s_addr
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* 	 * Look in cache first 	 */
if|if
condition|(
name|last_map_ipdst
operator|==
name|dstip
condition|)
return|return
operator|(
name|last_map_ipvcc
operator|)
return|;
comment|/* 	 * Oh well, we've got to search for it...first find the interface 	 */
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
for|for
control|(
name|inp
operator|=
name|ipatm_nif_head
init|;
name|inp
condition|;
name|inp
operator|=
name|inp
operator|->
name|inf_next
control|)
block|{
if|if
condition|(
name|inp
operator|->
name|inf_nif
operator|==
name|nip
condition|)
break|break;
block|}
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Now home in on the VCC 	 */
for|for
control|(
name|ivp
operator|=
name|Q_HEAD
argument_list|(
name|inp
operator|->
name|inf_vcq
argument_list|,
expr|struct
name|ipvcc
argument_list|)
init|;
name|ivp
condition|;
name|ivp
operator|=
name|Q_NEXT
argument_list|(
name|ivp
argument_list|,
expr|struct
name|ipvcc
argument_list|,
name|iv_elem
argument_list|)
control|)
block|{
if|if
condition|(
name|ivp
operator|->
name|iv_dst
operator|.
name|s_addr
operator|==
name|dstip
condition|)
break|break;
block|}
comment|/* 	 * Update lookup cache 	 */
if|if
condition|(
name|ivp
condition|)
block|{
name|last_map_ipdst
operator|=
name|dstip
expr_stmt|;
name|last_map_ipvcc
operator|=
name|ivp
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ivp
operator|)
return|;
block|}
end_function

end_unit

