begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * ===================================  * HARP  |  Host ATM Research Platform  * ===================================  *  *  * This Host ATM Research Platform ("HARP") file (the "Software") is  * made available by Network Computing Services, Inc. ("NetworkCS")  * "AS IS".  NetworkCS does not provide maintenance, improvements or  * support of any kind.  *  * NETWORKCS MAKES NO WARRANTIES OR REPRESENTATIONS, EXPRESS OR IMPLIED,  * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE, AS TO ANY ELEMENT OF THE  * SOFTWARE OR ANY SUPPORT PROVIDED IN CONNECTION WITH THIS SOFTWARE.  * In no event shall NetworkCS be responsible for any damages, including  * but not limited to consequential damages, arising from or relating to  * any use of the Software or related support.  *  * Copyright 1994-1998 Network Computing Services, Inc.  *  * Copies of this Software may be made, however, the above copyright  * notice must be reproduced on all copies.  *  *	@(#) $FreeBSD$  *  */
end_comment

begin_comment
comment|/*  * IP Over ATM Support  * -------------------  *  * Interface Manager  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netatm/port.h>
end_include

begin_include
include|#
directive|include
file|<netatm/queue.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sys.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sap.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_cm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_if.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sigmgr.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_stack.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_var.h>
end_include

begin_include
include|#
directive|include
file|<netatm/ipatm/ipatm_var.h>
end_include

begin_include
include|#
directive|include
file|<netatm/ipatm/ipatm_serv.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"@(#) $FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Local functions  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|ipatm_closenif
name|__P
argument_list|(
operator|(
expr|struct
name|ip_nif
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Process Network Interface status change  *   * Called whenever a network interface status change is requested.  *  * Called at splnet.  *  * Arguments:  *	cmd	command code  *	nip	pointer to atm network interface control block  *	arg	command specific parameter  *  * Returns:  *	0 	command successful  *	errno	command failed - reason indicated  *  */
end_comment

begin_function
name|int
name|ipatm_nifstat
parameter_list|(
name|cmd
parameter_list|,
name|nip
parameter_list|,
name|arg
parameter_list|)
name|int
name|cmd
decl_stmt|;
name|struct
name|atm_nif
modifier|*
name|nip
decl_stmt|;
name|int
name|arg
decl_stmt|;
block|{
name|struct
name|in_ifaddr
modifier|*
name|ia
decl_stmt|;
name|struct
name|siginst
modifier|*
name|sip
decl_stmt|;
name|struct
name|ip_nif
modifier|*
name|inp
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
comment|/* 	 * Look for corresponding IP interface 	 */
for|for
control|(
name|inp
operator|=
name|ipatm_nif_head
init|;
name|inp
condition|;
name|inp
operator|=
name|inp
operator|->
name|inf_next
control|)
block|{
if|if
condition|(
name|inp
operator|->
name|inf_nif
operator|==
name|nip
condition|)
break|break;
block|}
comment|/* 	 * Process command 	 */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|NCM_ATTACH
case|:
comment|/* 		 * Make sure i/f isn't already attached 		 */
if|if
condition|(
name|inp
operator|!=
name|NULL
condition|)
block|{
name|err
operator|=
name|EEXIST
expr_stmt|;
break|break;
block|}
comment|/* 		 * Get a new interface block 		 */
name|inp
operator|=
operator|(
expr|struct
name|ip_nif
operator|*
operator|)
name|atm_allocate
argument_list|(
operator|&
name|ipatm_nifpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|inp
operator|->
name|inf_nif
operator|=
name|nip
expr_stmt|;
name|inp
operator|->
name|inf_state
operator|=
name|IPNIF_ADDR
expr_stmt|;
name|inp
operator|->
name|inf_arpnotify
operator|=
name|ipatm_arpnotify
expr_stmt|;
name|inp
operator|->
name|inf_ipinput
operator|=
name|ipatm_ipinput
expr_stmt|;
name|inp
operator|->
name|inf_createsvc
operator|=
name|ipatm_createsvc
expr_stmt|;
name|LINK2TAIL
argument_list|(
name|inp
argument_list|,
expr|struct
name|ip_nif
argument_list|,
name|ipatm_nif_head
argument_list|,
name|inf_next
argument_list|)
expr_stmt|;
break|break;
case|case
name|NCM_DETACH
case|:
comment|/* 		 * Make sure i/f is attached 		 */
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
comment|/* 		 * Validate interface stuff 		 */
if|if
condition|(
name|Q_HEAD
argument_list|(
name|inp
operator|->
name|inf_vcq
argument_list|,
expr|struct
name|ipvcc
argument_list|)
condition|)
name|panic
argument_list|(
literal|"ipatm_nifstat: ipvcc queue not empty"
argument_list|)
expr_stmt|;
comment|/* 		 * If we're active, close all our VCCs and tell the 		 * interface service about the deactivation 		 */
if|if
condition|(
name|inp
operator|->
name|inf_state
operator|==
name|IPNIF_ACTIVE
condition|)
block|{
name|ipatm_closenif
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|inf_serv
condition|)
call|(
name|void
call|)
argument_list|(
operator|*
name|inp
operator|->
name|inf_serv
operator|->
name|is_ifdact
argument_list|)
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Clean up and free block 		 */
name|UNLINK
argument_list|(
name|inp
argument_list|,
expr|struct
name|ip_nif
argument_list|,
name|ipatm_nif_head
argument_list|,
name|inf_next
argument_list|)
expr_stmt|;
name|atm_free
argument_list|(
operator|(
name|caddr_t
operator|)
name|inp
argument_list|)
expr_stmt|;
break|break;
case|case
name|NCM_SETADDR
case|:
comment|/* 		 * We only care about IP addresses 		 */
if|#
directive|if
operator|(
name|defined
argument_list|(
name|BSD
argument_list|)
operator|&&
operator|(
name|BSD
operator|>=
literal|199103
operator|)
operator|)
if|if
condition|(
operator|(
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|arg
operator|)
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_INET
condition|)
else|#
directive|else
if|if
condition|(
operator|(
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|arg
operator|)
operator|->
name|ifa_addr
operator|.
name|sa_family
operator|!=
name|AF_INET
condition|)
endif|#
directive|endif
break|break;
comment|/* 		 * Make sure i/f is there 		 */
name|ia
operator|=
operator|(
expr|struct
name|in_ifaddr
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"ipatm_nifstat: setaddr missing ip_nif"
argument_list|)
expr_stmt|;
comment|/* 		 * Process new address 		 */
switch|switch
condition|(
name|inp
operator|->
name|inf_state
condition|)
block|{
case|case
name|IPNIF_SIGMGR
case|:
case|case
name|IPNIF_ADDR
case|:
name|inp
operator|->
name|inf_addr
operator|=
name|ia
expr_stmt|;
comment|/* 			 * If signalling manager is not set, wait for it 			 */
name|sip
operator|=
name|nip
operator|->
name|nif_pif
operator|->
name|pif_siginst
expr_stmt|;
if|if
condition|(
name|sip
operator|==
name|NULL
condition|)
block|{
name|inp
operator|->
name|inf_state
operator|=
name|IPNIF_SIGMGR
expr_stmt|;
break|break;
block|}
comment|/* 			 * Otherwise, everything's set 			 */
name|inp
operator|->
name|inf_state
operator|=
name|IPNIF_ACTIVE
expr_stmt|;
comment|/* 			 * Tell interface service we're around 			 */
if|if
condition|(
name|sip
operator|->
name|si_ipserv
condition|)
block|{
name|inp
operator|->
name|inf_serv
operator|=
name|sip
operator|->
name|si_ipserv
expr_stmt|;
name|err
operator|=
call|(
modifier|*
name|inp
operator|->
name|inf_serv
operator|->
name|is_ifact
call|)
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Reset state if there's been a problem 			 */
if|if
condition|(
name|err
condition|)
block|{
name|inp
operator|->
name|inf_serv
operator|=
name|NULL
expr_stmt|;
name|inp
operator|->
name|inf_addr
operator|=
name|NULL
expr_stmt|;
name|inp
operator|->
name|inf_state
operator|=
name|IPNIF_ADDR
expr_stmt|;
block|}
break|break;
case|case
name|IPNIF_ACTIVE
case|:
comment|/* 			 * We dont support an address change 			 */
name|err
operator|=
name|EEXIST
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|NCM_SIGATTACH
case|:
comment|/* 		 * Make sure i/f is attached 		 */
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
comment|/* 		 * Are we waiting for the sigmgr attach?? 		 */
if|if
condition|(
name|inp
operator|->
name|inf_state
operator|!=
name|IPNIF_SIGMGR
condition|)
block|{
comment|/* 			 * No, nothing else to do 			 */
break|break;
block|}
comment|/* 		 * OK, everything's set 		 */
name|inp
operator|->
name|inf_state
operator|=
name|IPNIF_ACTIVE
expr_stmt|;
comment|/* 		 * Tell interface service we're around 		 */
name|sip
operator|=
name|nip
operator|->
name|nif_pif
operator|->
name|pif_siginst
expr_stmt|;
if|if
condition|(
name|sip
operator|->
name|si_ipserv
condition|)
block|{
name|inp
operator|->
name|inf_serv
operator|=
name|sip
operator|->
name|si_ipserv
expr_stmt|;
name|err
operator|=
call|(
modifier|*
name|inp
operator|->
name|inf_serv
operator|->
name|is_ifact
call|)
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Just report any problems, since a NCM_SIGDETACH will 		 * be coming down immediately 		 */
break|break;
case|case
name|NCM_SIGDETACH
case|:
comment|/* 		 * Make sure i/f is attached 		 */
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
comment|/* 		 * Are we currently active?? 		 */
if|if
condition|(
name|inp
operator|->
name|inf_state
operator|!=
name|IPNIF_ACTIVE
condition|)
block|{
comment|/* 			 * No, nothing else to do 			 */
break|break;
block|}
comment|/* 		 * Close all the IP VCCs for this interface 		 */
name|ipatm_closenif
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* 		 * Tell interface service that i/f has gone down 		 */
if|if
condition|(
name|inp
operator|->
name|inf_serv
condition|)
call|(
name|void
call|)
argument_list|(
operator|*
name|inp
operator|->
name|inf_serv
operator|->
name|is_ifdact
argument_list|)
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* 		 * Just have to wait for another sigattach 		 */
name|inp
operator|->
name|inf_serv
operator|=
name|NULL
expr_stmt|;
name|inp
operator|->
name|inf_state
operator|=
name|IPNIF_SIGMGR
expr_stmt|;
break|break;
default|default:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ipatm_nifstat: unknown command %d\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close all VCCs on a Network Interface  *   * Called at splnet.  *  * Arguments:  *	inp	pointer to IP network interface  *  * Returns:  *	none  *  */
end_comment

begin_function
specifier|static
name|void
name|ipatm_closenif
parameter_list|(
name|inp
parameter_list|)
name|struct
name|ip_nif
modifier|*
name|inp
decl_stmt|;
block|{
name|struct
name|ipvcc
modifier|*
name|ivp
decl_stmt|,
modifier|*
name|inext
decl_stmt|;
comment|/* 	 * Close each IP VCC on this interface 	 */
for|for
control|(
name|ivp
operator|=
name|Q_HEAD
argument_list|(
name|inp
operator|->
name|inf_vcq
argument_list|,
expr|struct
name|ipvcc
argument_list|)
init|;
name|ivp
condition|;
name|ivp
operator|=
name|inext
control|)
block|{
name|inext
operator|=
name|Q_NEXT
argument_list|(
name|ivp
argument_list|,
expr|struct
name|ipvcc
argument_list|,
name|iv_elem
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ipatm_closevc
argument_list|(
name|ivp
argument_list|,
name|T_ATM_CAUSE_UNSPECIFIED_NORMAL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

