begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * ===================================  * HARP  |  Host ATM Research Platform  * ===================================  *  *  * This Host ATM Research Platform ("HARP") file (the "Software") is  * made available by Network Computing Services, Inc. ("NetworkCS")  * "AS IS".  NetworkCS does not provide maintenance, improvements or  * support of any kind.  *  * NETWORKCS MAKES NO WARRANTIES OR REPRESENTATIONS, EXPRESS OR IMPLIED,  * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE, AS TO ANY ELEMENT OF THE  * SOFTWARE OR ANY SUPPORT PROVIDED IN CONNECTION WITH THIS SOFTWARE.  * In no event shall NetworkCS be responsible for any damages, including  * but not limited to consequential damages, arising from or relating to  * any use of the Software or related support.  *  * Copyright 1994-1998 Network Computing Services, Inc.  *  * Copies of this Software may be made, however, the above copyright  * notice must be reproduced on all copies.  *  *	@(#) $FreeBSD$  *  */
end_comment

begin_comment
comment|/*  * IP Over ATM Support  * -------------------  *  * Process user requests  *  */
end_comment

begin_include
include|#
directive|include
file|<netatm/kern_include.h>
end_include

begin_include
include|#
directive|include
file|<netatm/ipatm/ipatm_var.h>
end_include

begin_include
include|#
directive|include
file|<netatm/ipatm/ipatm_serv.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"@(#) $FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Process IP PF_ATM ioctls  *   * Called at splnet.  *  * Arguments:  *	code	PF_ATM sub-operation code  *	data	pointer to code specific parameter data area  *	arg1	pointer to code specific argument  *  * Returns:  *	0 	request procesed  *	errno	error processing request - reason indicated  *  */
end_comment

begin_function
name|int
name|ipatm_ioctl
parameter_list|(
name|code
parameter_list|,
name|data
parameter_list|,
name|arg1
parameter_list|)
name|int
name|code
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
name|caddr_t
name|arg1
decl_stmt|;
block|{
name|struct
name|atmaddreq
modifier|*
name|aap
decl_stmt|;
name|struct
name|atmdelreq
modifier|*
name|adp
decl_stmt|;
name|struct
name|atminfreq
modifier|*
name|aip
decl_stmt|;
name|struct
name|air_ip_vcc_rsp
name|aivr
decl_stmt|;
name|struct
name|atm_nif
modifier|*
name|nip
decl_stmt|;
name|struct
name|ip_nif
modifier|*
name|inp
decl_stmt|;
name|struct
name|ipvcc
modifier|*
name|ivp
decl_stmt|;
name|struct
name|vccb
modifier|*
name|vcp
decl_stmt|;
name|struct
name|ipatmpvc
name|pv
decl_stmt|;
name|caddr_t
name|cp
decl_stmt|;
name|struct
name|in_addr
name|ip
decl_stmt|;
name|int
name|space
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|AIOCS_ADD_PVC
case|:
comment|/* 		 * Add an IP PVC 		 */
name|aap
operator|=
operator|(
expr|struct
name|atmaddreq
operator|*
operator|)
name|data
expr_stmt|;
comment|/* 		 * Find the IP network interface 		 */
if|if
condition|(
operator|(
name|nip
operator|=
name|atm_nifname
argument_list|(
name|aap
operator|->
name|aar_pvc_intf
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
for|for
control|(
name|inp
operator|=
name|ipatm_nif_head
init|;
name|inp
condition|;
name|inp
operator|=
name|inp
operator|->
name|inf_next
control|)
block|{
if|if
condition|(
name|inp
operator|->
name|inf_nif
operator|==
name|nip
condition|)
break|break;
block|}
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
comment|/* 		 * Validate PVC params 		 */
if|if
condition|(
name|aap
operator|->
name|aar_pvc_aal
operator|==
name|ATM_AAL5
condition|)
block|{
if|if
condition|(
operator|(
name|aap
operator|->
name|aar_pvc_encaps
operator|!=
name|ATM_ENC_LLC
operator|)
operator|&&
operator|(
name|aap
operator|->
name|aar_pvc_encaps
operator|!=
name|ATM_ENC_NULL
operator|)
condition|)
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|aap
operator|->
name|aar_pvc_aal
operator|==
name|ATM_AAL3_4
condition|)
block|{
if|if
condition|(
name|aap
operator|->
name|aar_pvc_encaps
operator|!=
name|ATM_ENC_NULL
condition|)
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|aap
operator|->
name|aar_pvc_flags
operator|&
name|PVC_DYN
condition|)
block|{
comment|/* 			 * For dynamic PVC destination addressing, the 			 * network interface must have support for this 			 */
if|if
condition|(
operator|(
name|inp
operator|->
name|inf_serv
operator|==
name|NULL
operator|)
operator|||
operator|(
name|inp
operator|->
name|inf_serv
operator|->
name|is_arp_pvcopen
operator|==
name|NULL
operator|)
condition|)
block|{
name|err
operator|=
name|EDESTADDRREQ
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|u_long
name|dst
init|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|aap
operator|->
name|aar_pvc_dst
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
decl_stmt|;
if|if
condition|(
name|dst
operator|==
name|INADDR_ANY
condition|)
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
comment|/* 		 * Build connection request 		 */
name|pv
operator|.
name|ipp_ipnif
operator|=
name|inp
expr_stmt|;
name|pv
operator|.
name|ipp_vpi
operator|=
name|aap
operator|->
name|aar_pvc_vpi
expr_stmt|;
name|pv
operator|.
name|ipp_vci
operator|=
name|aap
operator|->
name|aar_pvc_vci
expr_stmt|;
name|pv
operator|.
name|ipp_encaps
operator|=
name|aap
operator|->
name|aar_pvc_encaps
expr_stmt|;
name|pv
operator|.
name|ipp_aal
operator|=
name|aap
operator|->
name|aar_pvc_aal
expr_stmt|;
if|if
condition|(
name|aap
operator|->
name|aar_pvc_flags
operator|&
name|PVC_DYN
condition|)
block|{
name|pv
operator|.
name|ipp_dst
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
block|}
else|else
name|pv
operator|.
name|ipp_dst
operator|=
operator|*
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|aap
operator|->
name|aar_pvc_dst
expr_stmt|;
comment|/* 		 * Open a new VCC 		 */
name|err
operator|=
name|ipatm_openpvc
argument_list|(
operator|&
name|pv
argument_list|,
operator|&
name|ivp
argument_list|)
expr_stmt|;
break|break;
case|case
name|AIOCS_ADD_ARP
case|:
comment|/* 		 * Add an ARP mapping 		 */
name|aap
operator|=
operator|(
expr|struct
name|atmaddreq
operator|*
operator|)
name|data
expr_stmt|;
comment|/* 		 * Validate IP address 		 */
if|if
condition|(
name|aap
operator|->
name|aar_arp_dst
operator|.
name|sa_family
operator|!=
name|AF_INET
condition|)
block|{
name|err
operator|=
name|EAFNOSUPPORT
expr_stmt|;
break|break;
block|}
name|ip
operator|=
name|SATOSIN
argument_list|(
operator|&
name|aap
operator|->
name|aar_arp_dst
argument_list|)
operator|->
name|sin_addr
expr_stmt|;
if|if
condition|(
name|aap
operator|->
name|aar_arp_intf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* 			 * Find the IP network interface associated with 			 * the supplied IP address 			 */
for|for
control|(
name|inp
operator|=
name|ipatm_nif_head
init|;
name|inp
condition|;
name|inp
operator|=
name|inp
operator|->
name|inf_next
control|)
block|{
if|if
condition|(
name|ipatm_chknif
argument_list|(
name|ip
argument_list|,
name|inp
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|EADDRNOTAVAIL
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* 			 * Find the specified IP network interface 			 */
if|if
condition|(
operator|(
name|nip
operator|=
name|atm_nifname
argument_list|(
name|aap
operator|->
name|aar_arp_intf
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
for|for
control|(
name|inp
operator|=
name|ipatm_nif_head
init|;
name|inp
condition|;
name|inp
operator|=
name|inp
operator|->
name|inf_next
control|)
block|{
if|if
condition|(
name|inp
operator|->
name|inf_nif
operator|==
name|nip
condition|)
break|break;
block|}
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|ip
operator|.
name|s_addr
operator|==
name|INADDR_ANY
operator|)
operator|||
if|#
directive|if
operator|(
name|defined
argument_list|(
name|BSD
argument_list|)
operator|&&
operator|(
name|BSD
operator|>=
literal|199306
operator|)
operator|)
name|in_broadcast
argument_list|(
name|ip
argument_list|,
operator|&
name|inp
operator|->
name|inf_nif
operator|->
name|nif_if
argument_list|)
operator|||
else|#
directive|else
name|in_broadcast
argument_list|(
name|ip
argument_list|)
operator|||
endif|#
directive|endif
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|ip
operator|.
name|s_addr
argument_list|)
argument_list|)
condition|)
block|{
name|err
operator|=
name|EADDRNOTAVAIL
expr_stmt|;
break|break;
block|}
comment|/* 		 * Notify the responsible ARP service 		 */
name|err
operator|=
call|(
modifier|*
name|inp
operator|->
name|inf_serv
operator|->
name|is_ioctl
call|)
argument_list|(
name|code
argument_list|,
name|data
argument_list|,
name|inp
operator|->
name|inf_isintf
argument_list|)
expr_stmt|;
break|break;
case|case
name|AIOCS_DEL_ARP
case|:
comment|/* 		 * Delete an ARP mapping 		 */
name|adp
operator|=
operator|(
expr|struct
name|atmdelreq
operator|*
operator|)
name|data
expr_stmt|;
comment|/* 		 * Validate IP address 		 */
if|if
condition|(
name|adp
operator|->
name|adr_arp_dst
operator|.
name|sa_family
operator|!=
name|AF_INET
condition|)
block|{
name|err
operator|=
name|EAFNOSUPPORT
expr_stmt|;
break|break;
block|}
name|ip
operator|=
name|SATOSIN
argument_list|(
operator|&
name|adp
operator|->
name|adr_arp_dst
argument_list|)
operator|->
name|sin_addr
expr_stmt|;
if|if
condition|(
name|adp
operator|->
name|adr_arp_intf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* 			 * Find the IP network interface associated with 			 * the supplied IP address 			 */
for|for
control|(
name|inp
operator|=
name|ipatm_nif_head
init|;
name|inp
condition|;
name|inp
operator|=
name|inp
operator|->
name|inf_next
control|)
block|{
if|if
condition|(
name|ipatm_chknif
argument_list|(
name|ip
argument_list|,
name|inp
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|EADDRNOTAVAIL
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* 			 * Find the specified IP network interface 			 */
if|if
condition|(
operator|(
name|nip
operator|=
name|atm_nifname
argument_list|(
name|adp
operator|->
name|adr_arp_intf
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
for|for
control|(
name|inp
operator|=
name|ipatm_nif_head
init|;
name|inp
condition|;
name|inp
operator|=
name|inp
operator|->
name|inf_next
control|)
block|{
if|if
condition|(
name|inp
operator|->
name|inf_nif
operator|==
name|nip
condition|)
break|break;
block|}
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|ip
operator|.
name|s_addr
operator|==
name|INADDR_ANY
operator|)
operator|||
if|#
directive|if
operator|(
name|defined
argument_list|(
name|BSD
argument_list|)
operator|&&
operator|(
name|BSD
operator|>=
literal|199306
operator|)
operator|)
name|in_broadcast
argument_list|(
name|ip
argument_list|,
operator|&
name|inp
operator|->
name|inf_nif
operator|->
name|nif_if
argument_list|)
operator|||
else|#
directive|else
name|in_broadcast
argument_list|(
name|ip
argument_list|)
operator|||
endif|#
directive|endif
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|ip
operator|.
name|s_addr
argument_list|)
argument_list|)
condition|)
block|{
name|err
operator|=
name|EADDRNOTAVAIL
expr_stmt|;
break|break;
block|}
comment|/* 		 * Notify the responsible ARP service 		 */
name|err
operator|=
call|(
modifier|*
name|inp
operator|->
name|inf_serv
operator|->
name|is_ioctl
call|)
argument_list|(
name|code
argument_list|,
name|data
argument_list|,
name|inp
operator|->
name|inf_isintf
argument_list|)
expr_stmt|;
break|break;
case|case
name|AIOCS_INF_IPM
case|:
comment|/* 		 * Get IP VCC information 		 */
name|aip
operator|=
operator|(
expr|struct
name|atminfreq
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|aip
operator|->
name|air_ip_addr
operator|.
name|sa_family
operator|!=
name|AF_INET
condition|)
break|break;
name|ip
operator|=
name|SATOSIN
argument_list|(
operator|&
name|aip
operator|->
name|air_ip_addr
argument_list|)
operator|->
name|sin_addr
expr_stmt|;
name|cp
operator|=
name|aip
operator|->
name|air_buf_addr
expr_stmt|;
name|space
operator|=
name|aip
operator|->
name|air_buf_len
expr_stmt|;
comment|/* 		 * Loop through all our interfaces 		 */
for|for
control|(
name|inp
operator|=
name|ipatm_nif_head
init|;
name|inp
condition|;
name|inp
operator|=
name|inp
operator|->
name|inf_next
control|)
block|{
comment|/* 			 * Check out each VCC 			 */
for|for
control|(
name|ivp
operator|=
name|Q_HEAD
argument_list|(
name|inp
operator|->
name|inf_vcq
argument_list|,
expr|struct
name|ipvcc
argument_list|)
init|;
name|ivp
condition|;
name|ivp
operator|=
name|Q_NEXT
argument_list|(
name|ivp
argument_list|,
expr|struct
name|ipvcc
argument_list|,
name|iv_elem
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|ip
operator|.
name|s_addr
operator|!=
name|INADDR_ANY
operator|)
operator|&&
operator|(
name|ip
operator|.
name|s_addr
operator|!=
name|ivp
operator|->
name|iv_dst
operator|.
name|s_addr
operator|)
condition|)
continue|continue;
comment|/* 				 * Make sure there's room in user buffer 				 */
if|if
condition|(
name|space
operator|<
sizeof|sizeof
argument_list|(
name|aivr
argument_list|)
condition|)
block|{
name|err
operator|=
name|ENOSPC
expr_stmt|;
break|break;
block|}
comment|/* 				 * Fill in info to be returned 				 */
name|KM_ZERO
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|aivr
argument_list|,
sizeof|sizeof
argument_list|(
name|aivr
argument_list|)
argument_list|)
expr_stmt|;
name|SATOSIN
argument_list|(
operator|&
name|aivr
operator|.
name|aip_dst_addr
argument_list|)
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|SATOSIN
argument_list|(
operator|&
name|aivr
operator|.
name|aip_dst_addr
argument_list|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|ivp
operator|->
name|iv_dst
operator|.
name|s_addr
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|aivr
operator|.
name|aip_intf
argument_list|,
sizeof|sizeof
argument_list|(
name|aivr
operator|.
name|aip_intf
argument_list|)
argument_list|,
literal|"%s%d"
argument_list|,
name|inp
operator|->
name|inf_nif
operator|->
name|nif_if
operator|.
name|if_name
argument_list|,
name|inp
operator|->
name|inf_nif
operator|->
name|nif_if
operator|.
name|if_unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ivp
operator|->
name|iv_conn
operator|)
operator|&&
operator|(
name|ivp
operator|->
name|iv_conn
operator|->
name|co_connvc
operator|)
operator|&&
operator|(
name|vcp
operator|=
name|ivp
operator|->
name|iv_conn
operator|->
name|co_connvc
operator|->
name|cvc_vcc
operator|)
condition|)
block|{
name|aivr
operator|.
name|aip_vpi
operator|=
name|vcp
operator|->
name|vc_vpi
expr_stmt|;
name|aivr
operator|.
name|aip_vci
operator|=
name|vcp
operator|->
name|vc_vci
expr_stmt|;
name|aivr
operator|.
name|aip_sig_proto
operator|=
name|vcp
operator|->
name|vc_proto
expr_stmt|;
block|}
name|aivr
operator|.
name|aip_flags
operator|=
name|ivp
operator|->
name|iv_flags
expr_stmt|;
name|aivr
operator|.
name|aip_state
operator|=
name|ivp
operator|->
name|iv_state
expr_stmt|;
comment|/* 				 * Copy data to user buffer and  				 * update buffer controls 				 */
name|err
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|aivr
argument_list|,
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|aivr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|aivr
argument_list|)
expr_stmt|;
name|space
operator|-=
sizeof|sizeof
argument_list|(
name|aivr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
break|break;
block|}
comment|/* 		 * Update buffer pointer/count 		 */
name|aip
operator|->
name|air_buf_addr
operator|=
name|cp
expr_stmt|;
name|aip
operator|->
name|air_buf_len
operator|=
name|space
expr_stmt|;
break|break;
default|default:
name|err
operator|=
name|EOPNOTSUPP
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get Connection's Application/Owner Name  *   * Arguments:  *	tok	ipatm connection token (pointer to ipvcc)  *  * Returns:  *	addr	pointer to string containing our name  *  */
end_comment

begin_function
name|caddr_t
name|ipatm_getname
parameter_list|(
name|tok
parameter_list|)
name|void
modifier|*
name|tok
decl_stmt|;
block|{
return|return
operator|(
literal|"IP"
operator|)
return|;
block|}
end_function

end_unit

