begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * ===================================  * HARP  |  Host ATM Research Platform  * ===================================  *  *  * This Host ATM Research Platform ("HARP") file (the "Software") is  * made available by Network Computing Services, Inc. ("NetworkCS")  * "AS IS".  NetworkCS does not provide maintenance, improvements or  * support of any kind.  *  * NETWORKCS MAKES NO WARRANTIES OR REPRESENTATIONS, EXPRESS OR IMPLIED,  * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE, AS TO ANY ELEMENT OF THE  * SOFTWARE OR ANY SUPPORT PROVIDED IN CONNECTION WITH THIS SOFTWARE.  * In no event shall NetworkCS be responsible for any damages, including  * but not limited to consequential damages, arising from or relating to  * any use of the Software or related support.  *  * Copyright 1994-1998 Network Computing Services, Inc.  *  * Copies of this Software may be made, however, the above copyright  * notice must be reproduced on all copies.  *  *	@(#) $Id: uniarp_cache.c,v 1.8 1998/08/26 23:29:20 mks Exp $  *  */
end_comment

begin_comment
comment|/*  * ATM Forum UNI Support  * ---------------------  *  * UNI ATMARP support (RFC1577) - ARP cache processing  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|RCSid
init|=
literal|"@(#) $Id: uniarp_cache.c,v 1.8 1998/08/26 23:29:20 mks Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netatm/kern_include.h>
end_include

begin_include
include|#
directive|include
file|<netatm/ipatm/ipatm_var.h>
end_include

begin_include
include|#
directive|include
file|<netatm/ipatm/ipatm_serv.h>
end_include

begin_include
include|#
directive|include
file|<netatm/uni/unisig_var.h>
end_include

begin_include
include|#
directive|include
file|<netatm/uni/uniip_var.h>
end_include

begin_comment
comment|/*  * Add data to the arp table cache  *   * Called at splnet.  *  * Arguments:  *	uip	pointer to UNI IP interface  *	ip	pointer to IP address structure  *	atm	pointer to ATM address structure  *	atmsub	pointer to ATM subaddress structure  *	origin	source of arp information  *  * Returns:  *	0	cache successfully updated  *	else	updated failed - reason indicated  *  */
end_comment

begin_function
name|int
name|uniarp_cache_svc
parameter_list|(
name|uip
parameter_list|,
name|ip
parameter_list|,
name|atm
parameter_list|,
name|atmsub
parameter_list|,
name|origin
parameter_list|)
name|struct
name|uniip
modifier|*
name|uip
decl_stmt|;
name|struct
name|in_addr
modifier|*
name|ip
decl_stmt|;
name|Atm_addr
modifier|*
name|atm
decl_stmt|;
name|Atm_addr
modifier|*
name|atmsub
decl_stmt|;
name|u_int
name|origin
decl_stmt|;
block|{
name|struct
name|ip_nif
modifier|*
name|inp
decl_stmt|;
name|struct
name|ipvcc
modifier|*
name|ivp
decl_stmt|,
modifier|*
name|inext
decl_stmt|,
modifier|*
name|itail
decl_stmt|;
name|struct
name|uniarp
modifier|*
name|nouap
decl_stmt|,
modifier|*
name|ipuap
decl_stmt|;
name|char
name|abuf
index|[
literal|64
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|strncpy
argument_list|(
name|abuf
argument_list|,
name|unisig_addr_print
argument_list|(
name|atmsub
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|abuf
argument_list|)
argument_list|)
expr_stmt|;
name|ATM_DEBUG4
argument_list|(
literal|"cache_svc: ip=%s, atm=(%s,%s), origin=%d\n"
argument_list|,
name|inet_ntoa
argument_list|(
operator|*
name|ip
argument_list|)
argument_list|,
name|unisig_addr_print
argument_list|(
name|atm
argument_list|)
argument_list|,
name|abuf
argument_list|,
name|origin
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Get interface info 	 */
name|inp
operator|=
name|uip
operator|->
name|uip_ipnif
expr_stmt|;
comment|/* 	 * Find both cached entry and 'nomap' entries for this data. 	 */
name|UNIARP_LOOKUP
argument_list|(
name|ip
operator|->
name|s_addr
argument_list|,
name|ipuap
argument_list|)
expr_stmt|;
for|for
control|(
name|nouap
operator|=
name|uniarp_nomaptab
init|;
name|nouap
condition|;
name|nouap
operator|=
name|nouap
operator|->
name|ua_next
control|)
block|{
if|if
condition|(
name|ATM_ADDR_EQUAL
argument_list|(
name|atm
argument_list|,
operator|&
name|nouap
operator|->
name|ua_dstatm
argument_list|)
operator|&&
name|ATM_ADDR_EQUAL
argument_list|(
name|atmsub
argument_list|,
operator|&
name|nouap
operator|->
name|ua_dstatmsub
argument_list|)
operator|&&
operator|(
name|nouap
operator|->
name|ua_intf
operator|==
name|uip
operator|)
condition|)
break|break;
block|}
comment|/* 	 * If there aren't any entries yet, create one 	 */
if|if
condition|(
operator|(
name|ipuap
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|nouap
operator|==
name|NULL
operator|)
condition|)
block|{
name|ipuap
operator|=
operator|(
expr|struct
name|uniarp
operator|*
operator|)
name|atm_allocate
argument_list|(
operator|&
name|uniarp_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipuap
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|ipuap
operator|->
name|ua_dstip
operator|.
name|s_addr
operator|=
name|ip
operator|->
name|s_addr
expr_stmt|;
name|ipuap
operator|->
name|ua_dstatm
operator|.
name|address_format
operator|=
name|T_ATM_ABSENT
expr_stmt|;
name|ipuap
operator|->
name|ua_dstatmsub
operator|.
name|address_format
operator|=
name|T_ATM_ABSENT
expr_stmt|;
name|ipuap
operator|->
name|ua_intf
operator|=
name|uip
expr_stmt|;
name|UNIARP_ADD
argument_list|(
name|ipuap
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If there's no cached mapping, then make the 'nomap' entry 	 * the new cached entry. 	 */
if|if
condition|(
name|ipuap
operator|==
name|NULL
condition|)
block|{
name|UNLINK
argument_list|(
name|nouap
argument_list|,
expr|struct
name|uniarp
argument_list|,
name|uniarp_nomaptab
argument_list|,
name|ua_next
argument_list|)
expr_stmt|;
name|nouap
operator|->
name|ua_dstip
operator|.
name|s_addr
operator|=
name|ip
operator|->
name|s_addr
expr_stmt|;
name|ipuap
operator|=
name|nouap
expr_stmt|;
name|nouap
operator|=
name|NULL
expr_stmt|;
name|UNIARP_ADD
argument_list|(
name|ipuap
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We need to check the consistency of the new data with any  	 * cached data.  So taking the easy case first, if there isn't 	 * an ATM address in the cache then we can skip all these checks. 	 */
if|if
condition|(
name|ipuap
operator|->
name|ua_dstatm
operator|.
name|address_format
operator|!=
name|T_ATM_ABSENT
condition|)
block|{
comment|/* 		 * See if the new data conflicts with what's in the cache 		 */
if|if
condition|(
name|ATM_ADDR_EQUAL
argument_list|(
name|atm
argument_list|,
operator|&
name|ipuap
operator|->
name|ua_dstatm
argument_list|)
operator|&&
name|ATM_ADDR_EQUAL
argument_list|(
name|atmsub
argument_list|,
operator|&
name|ipuap
operator|->
name|ua_dstatmsub
argument_list|)
operator|&&
operator|(
name|uip
operator|==
name|ipuap
operator|->
name|ua_intf
operator|)
condition|)
block|{
comment|/* 			 * No conflicts here 			 */
goto|goto
name|dataok
goto|;
block|}
comment|/* 		 * Data conflict...how we deal with this depends on 		 * the origins of the conflicting data 		 */
if|if
condition|(
name|origin
operator|==
name|ipuap
operator|->
name|ua_origin
condition|)
block|{
comment|/* 			 * The new data has equal precedence - if there are 			 * any VCCs using this entry, then we reject this 			 * "duplicate IP address" update. 			 */
if|if
condition|(
name|ipuap
operator|->
name|ua_ivp
operator|!=
name|NULL
condition|)
block|{
name|strncpy
argument_list|(
name|abuf
argument_list|,
name|unisig_addr_print
argument_list|(
name|atmsub
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|abuf
argument_list|)
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"uniarp: duplicate IP address %s from %s,%s\n"
argument_list|,
name|inet_ntoa
argument_list|(
operator|*
name|ip
argument_list|)
argument_list|,
name|unisig_addr_print
argument_list|(
name|atm
argument_list|)
argument_list|,
name|abuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|EACCES
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|origin
operator|>
name|ipuap
operator|->
name|ua_origin
condition|)
block|{
comment|/* 			 * New data's origin has higher precedence, 			 * so accept the new mapping and notify IP/ATM 			 * that a mapping change has occurred.  IP/ATM will 			 * close any VCC's which aren't waiting for this map. 			 */
name|ipuap
operator|->
name|ua_flags
operator||=
name|UAF_LOCKED
expr_stmt|;
for|for
control|(
name|ivp
operator|=
name|ipuap
operator|->
name|ua_ivp
init|;
name|ivp
condition|;
name|ivp
operator|=
name|inext
control|)
block|{
name|inext
operator|=
name|ivp
operator|->
name|iv_arpnext
expr_stmt|;
call|(
modifier|*
name|inp
operator|->
name|inf_arpnotify
call|)
argument_list|(
name|ivp
argument_list|,
name|MAP_CHANGED
argument_list|)
expr_stmt|;
block|}
name|ipuap
operator|->
name|ua_flags
operator|&=
operator|~
name|UAF_LOCKED
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * New data is of lesser origin precedence, 			 * so we just reject the update attempt. 			 */
return|return
operator|(
name|EACCES
operator|)
return|;
block|}
name|strncpy
argument_list|(
name|abuf
argument_list|,
name|unisig_addr_print
argument_list|(
name|atmsub
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|abuf
argument_list|)
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"uniarp: ATM address for %s changed to %s,%s\n"
argument_list|,
name|inet_ntoa
argument_list|(
operator|*
name|ip
argument_list|)
argument_list|,
name|unisig_addr_print
argument_list|(
name|atm
argument_list|)
argument_list|,
name|abuf
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Update the cache entry with the new data 	 */
name|ATM_ADDR_COPY
argument_list|(
name|atm
argument_list|,
operator|&
name|ipuap
operator|->
name|ua_dstatm
argument_list|)
expr_stmt|;
name|ATM_ADDR_COPY
argument_list|(
name|atmsub
argument_list|,
operator|&
name|ipuap
operator|->
name|ua_dstatmsub
argument_list|)
expr_stmt|;
name|ipuap
operator|->
name|ua_intf
operator|=
name|uip
expr_stmt|;
name|dataok
label|:
comment|/* 	 * Update cache data origin 	 */
name|ipuap
operator|->
name|ua_origin
operator|=
name|MAX
argument_list|(
name|ipuap
operator|->
name|ua_origin
argument_list|,
name|origin
argument_list|)
expr_stmt|;
comment|/* 	 * Ok, now act on this new/updated cache data 	 */
name|ipuap
operator|->
name|ua_flags
operator||=
name|UAF_LOCKED
expr_stmt|;
comment|/* 	 * Save pointer to last VCC currently on cached entry chain that 	 * will need to be notified of the map becoming valid 	 */
name|itail
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|ipuap
operator|->
name|ua_flags
operator|&
name|UAF_VALID
operator|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|itail
operator|=
name|ipuap
operator|->
name|ua_ivp
init|;
name|itail
operator|&&
name|itail
operator|->
name|iv_arpnext
condition|;
name|itail
operator|=
name|itail
operator|->
name|iv_arpnext
control|)
block|{ 		}
block|}
comment|/* 	 * If there was a 'nomap' entry for this mapping, then we need to 	 * announce the new mapping to them first. 	 */
if|if
condition|(
name|nouap
condition|)
block|{
comment|/* 		 * Move the VCCs from this entry to the cache entry and 		 * let them know there's a valid mapping now 		 */
for|for
control|(
name|ivp
operator|=
name|nouap
operator|->
name|ua_ivp
init|;
name|ivp
condition|;
name|ivp
operator|=
name|inext
control|)
block|{
name|inext
operator|=
name|ivp
operator|->
name|iv_arpnext
expr_stmt|;
name|UNLINK
argument_list|(
name|ivp
argument_list|,
expr|struct
name|ipvcc
argument_list|,
name|nouap
operator|->
name|ua_ivp
argument_list|,
name|iv_arpnext
argument_list|)
expr_stmt|;
name|LINK2TAIL
argument_list|(
name|ivp
argument_list|,
expr|struct
name|ipvcc
argument_list|,
name|ipuap
operator|->
name|ua_ivp
argument_list|,
name|iv_arpnext
argument_list|)
expr_stmt|;
name|ivp
operator|->
name|iv_arpent
operator|=
operator|(
expr|struct
name|arpmap
operator|*
operator|)
name|ipuap
expr_stmt|;
call|(
modifier|*
name|inp
operator|->
name|inf_arpnotify
call|)
argument_list|(
name|ivp
argument_list|,
name|MAP_VALID
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Unlink and free the 'nomap' entry 		 */
name|UNLINK
argument_list|(
name|nouap
argument_list|,
expr|struct
name|uniarp
argument_list|,
name|uniarp_nomaptab
argument_list|,
name|ua_next
argument_list|)
expr_stmt|;
name|UNIARP_CANCEL
argument_list|(
name|nouap
argument_list|)
expr_stmt|;
name|atm_free
argument_list|(
operator|(
name|caddr_t
operator|)
name|nouap
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now, if this entry wasn't valid, notify the remaining VCCs 	 */
if|if
condition|(
name|itail
condition|)
block|{
for|for
control|(
name|ivp
operator|=
name|ipuap
operator|->
name|ua_ivp
init|;
name|ivp
condition|;
name|ivp
operator|=
name|inext
control|)
block|{
name|inext
operator|=
name|ivp
operator|->
name|iv_arpnext
expr_stmt|;
call|(
modifier|*
name|inp
operator|->
name|inf_arpnotify
call|)
argument_list|(
name|ivp
argument_list|,
name|MAP_VALID
argument_list|)
expr_stmt|;
if|if
condition|(
name|ivp
operator|==
name|itail
condition|)
break|break;
block|}
block|}
name|ipuap
operator|->
name|ua_flags
operator|&=
operator|~
name|UAF_LOCKED
expr_stmt|;
comment|/* 	 * We now have a valid cache entry, so cancel any retry timer 	 * and reset the aging timeout 	 */
name|UNIARP_CANCEL
argument_list|(
name|ipuap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ipuap
operator|->
name|ua_origin
operator|==
name|UAO_REGISTER
operator|)
operator|&&
operator|(
name|origin
operator|!=
name|UAO_REGISTER
operator|)
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|ipuap
operator|->
name|ua_flags
operator|&
name|UAF_VALID
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|ipuap
operator|->
name|ua_aging
operator|<=
name|UNIARP_SERVER_AGE
operator|-
name|UNIARP_MIN_REFRESH
operator|)
condition|)
block|{
name|ipuap
operator|->
name|ua_flags
operator||=
name|UAF_REFRESH
expr_stmt|;
name|ipuap
operator|->
name|ua_aging
operator|=
name|UNIARP_SERVER_AGE
expr_stmt|;
name|ipuap
operator|->
name|ua_retry
operator|=
name|UNIARP_SERVER_RETRY
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|uip
operator|->
name|uip_arpstate
operator|==
name|UIAS_SERVER_ACTIVE
condition|)
block|{
name|ipuap
operator|->
name|ua_aging
operator|=
name|UNIARP_SERVER_AGE
expr_stmt|;
name|ipuap
operator|->
name|ua_retry
operator|=
name|UNIARP_SERVER_RETRY
expr_stmt|;
block|}
else|else
block|{
name|ipuap
operator|->
name|ua_aging
operator|=
name|UNIARP_CLIENT_AGE
expr_stmt|;
name|ipuap
operator|->
name|ua_retry
operator|=
name|UNIARP_CLIENT_RETRY
expr_stmt|;
block|}
name|ipuap
operator|->
name|ua_flags
operator||=
name|UAF_REFRESH
expr_stmt|;
block|}
name|ipuap
operator|->
name|ua_flags
operator||=
name|UAF_VALID
expr_stmt|;
name|ipuap
operator|->
name|ua_flags
operator|&=
operator|~
name|UAF_USED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process ARP data from a PVC  *   * The arp table cache is never updated with PVC information.  *   * Called at splnet.  *  * Arguments:  *	ivp	pointer to input PVC's IPVCC control block  *	ip	pointer to IP address structure  *	atm	pointer to ATM address structure  *	atmsub	pointer to ATM subaddress structure  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|uniarp_cache_pvc
parameter_list|(
name|ivp
parameter_list|,
name|ip
parameter_list|,
name|atm
parameter_list|,
name|atmsub
parameter_list|)
name|struct
name|ipvcc
modifier|*
name|ivp
decl_stmt|;
name|struct
name|in_addr
modifier|*
name|ip
decl_stmt|;
name|Atm_addr
modifier|*
name|atm
decl_stmt|;
name|Atm_addr
modifier|*
name|atmsub
decl_stmt|;
block|{
name|struct
name|ip_nif
modifier|*
name|inp
decl_stmt|;
name|struct
name|uniarp
modifier|*
name|uap
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|int
name|vpi
init|=
literal|0
decl_stmt|,
name|vci
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|ivp
operator|->
name|iv_conn
operator|)
operator|&&
operator|(
name|ivp
operator|->
name|iv_conn
operator|->
name|co_connvc
operator|)
condition|)
block|{
name|vpi
operator|=
name|ivp
operator|->
name|iv_conn
operator|->
name|co_connvc
operator|->
name|cvc_vcc
operator|->
name|vc_vpi
expr_stmt|;
name|vci
operator|=
name|ivp
operator|->
name|iv_conn
operator|->
name|co_connvc
operator|->
name|cvc_vcc
operator|->
name|vc_vci
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|buf
argument_list|,
name|unisig_addr_print
argument_list|(
name|atmsub
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|ATM_DEBUG5
argument_list|(
literal|"cache_pvc: vcc=(%d,%d), ip=%s, atm=(%s,%s)\n"
argument_list|,
name|vpi
argument_list|,
name|vci
argument_list|,
name|inet_ntoa
argument_list|(
operator|*
name|ip
argument_list|)
argument_list|,
name|unisig_addr_print
argument_list|(
name|atm
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Get PVC info 	 */
name|inp
operator|=
name|ivp
operator|->
name|iv_ipnif
expr_stmt|;
name|uap
operator|=
operator|(
expr|struct
name|uniarp
operator|*
operator|)
name|ivp
operator|->
name|iv_arpent
expr_stmt|;
comment|/* 	 * See if IP address for PVC has changed 	 */
if|if
condition|(
name|uap
operator|->
name|ua_dstip
operator|.
name|s_addr
operator|!=
name|ip
operator|->
name|s_addr
condition|)
block|{
if|if
condition|(
name|uap
operator|->
name|ua_dstip
operator|.
name|s_addr
operator|!=
literal|0
condition|)
call|(
modifier|*
name|inp
operator|->
name|inf_arpnotify
call|)
argument_list|(
name|ivp
argument_list|,
name|MAP_CHANGED
argument_list|)
expr_stmt|;
name|uap
operator|->
name|ua_dstip
operator|.
name|s_addr
operator|=
name|ip
operator|->
name|s_addr
expr_stmt|;
block|}
comment|/* 	 * Let IP/ATM know if address has become valid 	 */
if|if
condition|(
operator|(
name|uap
operator|->
name|ua_flags
operator|&
name|UAF_VALID
operator|)
operator|==
literal|0
condition|)
call|(
modifier|*
name|inp
operator|->
name|inf_arpnotify
call|)
argument_list|(
name|ivp
argument_list|,
name|MAP_VALID
argument_list|)
expr_stmt|;
name|uap
operator|->
name|ua_flags
operator||=
name|UAF_VALID
expr_stmt|;
name|uap
operator|->
name|ua_aging
operator|=
name|UNIARP_CLIENT_AGE
expr_stmt|;
name|uap
operator|->
name|ua_retry
operator|=
name|UNIARP_CLIENT_RETRY
expr_stmt|;
comment|/* 	 * Save ATM addresses just for debugging 	 */
name|ATM_ADDR_COPY
argument_list|(
name|atm
argument_list|,
operator|&
name|uap
operator|->
name|ua_dstatm
argument_list|)
expr_stmt|;
name|ATM_ADDR_COPY
argument_list|(
name|atmsub
argument_list|,
operator|&
name|uap
operator|->
name|ua_dstatmsub
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Validate IP address  *   * Arguments:  *	uip	pointer to UNI IP interface  *	ip	pointer to IP address structure  *	origin	source of arp information  *  * Returns:  *	0	IP address is acceptable  *	else	invalid IP address  *  */
end_comment

begin_function
name|int
name|uniarp_validate_ip
parameter_list|(
name|uip
parameter_list|,
name|ip
parameter_list|,
name|origin
parameter_list|)
name|struct
name|uniip
modifier|*
name|uip
decl_stmt|;
name|struct
name|in_addr
modifier|*
name|ip
decl_stmt|;
name|u_int
name|origin
decl_stmt|;
block|{
name|struct
name|uniarp_prf
modifier|*
name|upp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Can't be multicast or broadcast address 	 */
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|ip
operator|->
name|s_addr
argument_list|)
argument_list|)
operator|||
if|#
directive|if
operator|(
name|defined
argument_list|(
name|BSD
argument_list|)
operator|&&
operator|(
name|BSD
operator|>=
literal|199306
operator|)
operator|)
name|in_broadcast
argument_list|(
operator|*
name|ip
argument_list|,
operator|&
name|uip
operator|->
name|uip_ipnif
operator|->
name|inf_nif
operator|->
name|nif_if
argument_list|)
condition|)
else|#
directive|else
name|in_broadcast
argument_list|(
operator|*
name|ip
argument_list|)
block|)
endif|#
directive|endif
function|return
parameter_list|(
function|1
end_function

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* 	 * For ATMARP registration information (including SCSP data), 	 * the address must be allowed by the interface's prefix list. 	 */
end_comment

begin_if
if|if
condition|(
operator|(
name|origin
operator|==
name|UAO_REGISTER
operator|)
operator|||
operator|(
name|origin
operator|==
name|UAO_SCSP
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
name|uip
operator|->
name|uip_nprefix
operator|,
name|upp
operator|=
name|uip
operator|->
name|uip_prefix
init|;
name|i
condition|;
name|i
operator|--
operator|,
name|upp
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ip
operator|->
name|s_addr
operator|&
name|upp
operator|->
name|upf_mask
operator|.
name|s_addr
operator|)
operator|==
name|upp
operator|->
name|upf_addr
operator|.
name|s_addr
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_if

begin_return
return|return
operator|(
literal|0
operator|)
return|;
end_return

unit|}
end_unit

