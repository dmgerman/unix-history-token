begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * ===================================  * HARP  |  Host ATM Research Platform  * ===================================  *  *  * This Host ATM Research Platform ("HARP") file (the "Software") is  * made available by Network Computing Services, Inc. ("NetworkCS")  * "AS IS".  NetworkCS does not provide maintenance, improvements or  * support of any kind.  *  * NETWORKCS MAKES NO WARRANTIES OR REPRESENTATIONS, EXPRESS OR IMPLIED,  * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE, AS TO ANY ELEMENT OF THE  * SOFTWARE OR ANY SUPPORT PROVIDED IN CONNECTION WITH THIS SOFTWARE.  * In no event shall NetworkCS be responsible for any damages, including  * but not limited to consequential damages, arising from or relating to  * any use of the Software or related support.  *  * Copyright 1994-1998 Network Computing Services, Inc.  *  * Copies of this Software may be made, however, the above copyright  * notice must be reproduced on all copies.  *  *	@(#) $Id: unisig_proto.c,v 1.9 1998/08/26 23:29:23 mks Exp $  *  */
end_comment

begin_comment
comment|/*  * ATM Forum UNI 3.0/3.1 Signalling Manager  * ----------------------------------------  *  * Protocol processing module.  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|RCSid
init|=
literal|"@(#) $Id: unisig_proto.c,v 1.9 1998/08/26 23:29:23 mks Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netatm/kern_include.h>
end_include

begin_include
include|#
directive|include
file|<netatm/uni/unisig.h>
end_include

begin_include
include|#
directive|include
file|<netatm/uni/unisig_var.h>
end_include

begin_include
include|#
directive|include
file|<netatm/uni/unisig_msg.h>
end_include

begin_include
include|#
directive|include
file|<netatm/uni/unisig_mbuf.h>
end_include

begin_comment
comment|/*  * Process a UNISIG timeout  *  * Called when a previously scheduled protocol instance control block  * timer expires.  This routine passes a timeout event to the UNISIG  * signalling manager state machine.  *  * Called at splnet.  *  * Arguments:  *	tip	pointer to UNISIG timer control block  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|unisig_timer
parameter_list|(
name|tip
parameter_list|)
name|struct
name|atm_time
modifier|*
name|tip
decl_stmt|;
block|{
name|struct
name|unisig
modifier|*
name|usp
decl_stmt|;
comment|/* 	 * Back-off to UNISIG control block 	 */
name|usp
operator|=
operator|(
expr|struct
name|unisig
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|tip
operator|-
call|(
name|int
call|)
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|unisig
operator|*
operator|)
literal|0
operator|)
operator|->
name|us_time
argument_list|)
operator|)
expr_stmt|;
name|ATM_DEBUG2
argument_list|(
literal|"unisig_timer: usp=0x%x,state=%d\n"
argument_list|,
operator|(
name|int
operator|)
name|usp
argument_list|,
name|usp
operator|->
name|us_state
argument_list|)
expr_stmt|;
comment|/* 	 * Pass the timeout to the signalling manager state machine 	 */
operator|(
name|void
operator|)
name|unisig_sigmgr_state
argument_list|(
name|usp
argument_list|,
name|UNISIG_SIGMGR_TIMEOUT
argument_list|,
operator|(
name|KBuffer
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process a UNISIG VCC timeout  *  * Called when a previously scheduled UNISIG VCCB timer expires.  * Processing will based on the current VCC state.  *  * Called at splnet.  *  * Arguments:  *	tip	pointer to vccb timer control block  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|unisig_vctimer
parameter_list|(
name|tip
parameter_list|)
name|struct
name|atm_time
modifier|*
name|tip
decl_stmt|;
block|{
name|struct
name|unisig
modifier|*
name|usp
decl_stmt|;
name|struct
name|unisig_vccb
modifier|*
name|uvp
decl_stmt|;
comment|/* 	 * Get VCCB and UNISIG control block addresses 	 */
name|uvp
operator|=
operator|(
expr|struct
name|unisig_vccb
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|tip
operator|-
call|(
name|int
call|)
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|vccb
operator|*
operator|)
literal|0
operator|)
operator|->
name|vc_time
argument_list|)
operator|)
expr_stmt|;
name|usp
operator|=
operator|(
expr|struct
name|unisig
operator|*
operator|)
name|uvp
operator|->
name|uv_pif
operator|->
name|pif_siginst
expr_stmt|;
name|ATM_DEBUG3
argument_list|(
literal|"unisig_vctimer: uvp=0x%x, sstate=%d, ustate=%d\n"
argument_list|,
operator|(
name|int
operator|)
name|uvp
argument_list|,
name|uvp
operator|->
name|uv_sstate
argument_list|,
name|uvp
operator|->
name|uv_ustate
argument_list|)
expr_stmt|;
comment|/* 	 * Hand the timeout to the VC finite state machine 	 */
if|if
condition|(
name|uvp
operator|->
name|uv_ustate
operator|==
name|VCCU_ABORT
condition|)
block|{
comment|/* 		 * If we're aborting, this is an ABORT call 		 */
operator|(
name|void
operator|)
name|unisig_vc_state
argument_list|(
name|usp
argument_list|,
name|uvp
argument_list|,
name|UNI_VC_ABORT_CALL
argument_list|,
operator|(
expr|struct
name|unisig_msg
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * If we're not aborting, it's a timeout 		 */
operator|(
name|void
operator|)
name|unisig_vc_state
argument_list|(
name|usp
argument_list|,
name|uvp
argument_list|,
name|UNI_VC_TIMEOUT
argument_list|,
operator|(
expr|struct
name|unisig_msg
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * UNISIG SAAL Control Handler  *  * This is the module which receives data on the UNISIG signalling  * channel.  Processing is based on the indication received from the  * SSCF and the protocol state.  *  * Arguments:  *	cmd	command code  *	tok	session token (pointer to UNISIG protocol control block)  *	a1	argument 1  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|unisig_saal_ctl
parameter_list|(
name|cmd
parameter_list|,
name|tok
parameter_list|,
name|a1
parameter_list|)
name|int
name|cmd
decl_stmt|;
name|void
modifier|*
name|tok
decl_stmt|;
name|void
modifier|*
name|a1
decl_stmt|;
block|{
name|struct
name|unisig
modifier|*
name|usp
init|=
name|tok
decl_stmt|;
name|ATM_DEBUG4
argument_list|(
literal|"unisig_upper: usp=0x%x,state=%d,cmd=%d,a1=0x%x,\n"
argument_list|,
operator|(
name|u_long
operator|)
name|usp
argument_list|,
name|usp
operator|->
name|us_state
argument_list|,
name|cmd
argument_list|,
operator|(
name|u_long
operator|)
name|a1
argument_list|)
expr_stmt|;
comment|/* 	 * Process command 	 */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SSCF_UNI_ESTABLISH_IND
case|:
operator|(
name|void
operator|)
name|unisig_sigmgr_state
argument_list|(
name|usp
argument_list|,
name|UNISIG_SIGMGR_SSCF_EST_IND
argument_list|,
operator|(
name|KBuffer
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|SSCF_UNI_ESTABLISH_CNF
case|:
operator|(
name|void
operator|)
name|unisig_sigmgr_state
argument_list|(
name|usp
argument_list|,
name|UNISIG_SIGMGR_SSCF_EST_CNF
argument_list|,
operator|(
name|KBuffer
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|SSCF_UNI_RELEASE_IND
case|:
operator|(
name|void
operator|)
name|unisig_sigmgr_state
argument_list|(
name|usp
argument_list|,
name|UNISIG_SIGMGR_SSCF_RLS_IND
argument_list|,
operator|(
name|KBuffer
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|SSCF_UNI_RELEASE_CNF
case|:
operator|(
name|void
operator|)
name|unisig_sigmgr_state
argument_list|(
name|usp
argument_list|,
name|UNISIG_SIGMGR_SSCF_RLS_CNF
argument_list|,
operator|(
name|KBuffer
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unisig: unknown SAAL cmd: usp=0x%x, state=%d, cmd=%d\n"
argument_list|,
operator|(
name|int
operator|)
name|usp
argument_list|,
name|usp
operator|->
name|us_state
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * UNISIG SAAL Data Handler  *  * This is the module which receives data on the UNISIG signalling  * channel.  Processing is based on the protocol state.  *  * Arguments:  *	tok	session token (pointer to UNISIG protocol control block)  *	m	pointer to data  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|unisig_saal_data
parameter_list|(
name|tok
parameter_list|,
name|m
parameter_list|)
name|void
modifier|*
name|tok
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
block|{
name|struct
name|unisig
modifier|*
name|usp
init|=
name|tok
decl_stmt|;
name|ATM_DEBUG3
argument_list|(
literal|"unisig_saal_data: usp=0x%x,state=%d,m=0x%x,\n"
argument_list|,
operator|(
name|int
operator|)
name|usp
argument_list|,
name|usp
operator|->
name|us_state
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* 	 * Pass data to signalling manager state machine 	 */
operator|(
name|void
operator|)
name|unisig_sigmgr_state
argument_list|(
name|usp
argument_list|,
name|UNISIG_SIGMGR_SSCF_DATA_IND
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get Connection's Application/Owner Name  *  * Arguments:  *      tok     UNI signalling connection token (pointer to protocol instance)  *  * Returns:  *      addr    pointer to string containing our name  *  */
end_comment

begin_function
name|caddr_t
name|unisig_getname
parameter_list|(
name|tok
parameter_list|)
name|void
modifier|*
name|tok
decl_stmt|;
block|{
name|struct
name|unisig
modifier|*
name|usp
init|=
name|tok
decl_stmt|;
if|if
condition|(
name|usp
operator|->
name|us_proto
operator|==
name|ATM_SIG_UNI30
condition|)
return|return
operator|(
literal|"UNI3.0"
operator|)
return|;
elseif|else
if|if
condition|(
name|usp
operator|->
name|us_proto
operator|==
name|ATM_SIG_UNI31
condition|)
return|return
operator|(
literal|"UNI3.1"
operator|)
return|;
elseif|else
if|if
condition|(
name|usp
operator|->
name|us_proto
operator|==
name|ATM_SIG_UNI40
condition|)
return|return
operator|(
literal|"UNI4.0"
operator|)
return|;
else|else
return|return
operator|(
literal|"UNI"
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process a VCC connection notification  *  * Should never be called.  *  * Arguments:  *	tok	user's connection token (unisig protocol block)  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|unisig_connected
parameter_list|(
name|tok
parameter_list|)
name|void
modifier|*
name|tok
decl_stmt|;
block|{
name|struct
name|unisig
modifier|*
name|usp
init|=
name|tok
decl_stmt|;
name|ATM_DEBUG2
argument_list|(
literal|"unisig_connected: usp=0x%x,state=%d\n"
argument_list|,
operator|(
name|u_long
operator|)
name|usp
argument_list|,
name|usp
operator|->
name|us_state
argument_list|)
expr_stmt|;
comment|/* 	 * Connected routine shouldn't ever get called for a PVC 	 */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unisig: connected notification, usp=0x%x\n"
argument_list|,
operator|(
name|u_long
operator|)
name|usp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process a VCC closed notification  *  * Called when UNISIG signalling channel is closed.  *  * Arguments:  *	tok	user's connection token (unisig protocol block)  *	cp	pointer to cause structure  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|unisig_cleared
parameter_list|(
name|tok
parameter_list|,
name|cp
parameter_list|)
name|void
modifier|*
name|tok
decl_stmt|;
name|struct
name|t_atm_cause
modifier|*
name|cp
decl_stmt|;
block|{
name|struct
name|unisig
modifier|*
name|usp
init|=
name|tok
decl_stmt|;
name|ATM_DEBUG3
argument_list|(
literal|"unisig_cleared: usp=0x%x, state=%d, cause=%d\n"
argument_list|,
operator|(
name|u_long
operator|)
name|usp
argument_list|,
name|usp
operator|->
name|us_state
argument_list|,
name|cp
operator|->
name|cause_value
argument_list|)
expr_stmt|;
comment|/* 	 * VCC has been closed.  Notify the signalling 	 * manager state machine. 	 */
operator|(
name|void
operator|)
name|unisig_sigmgr_state
argument_list|(
name|usp
argument_list|,
name|UNISIG_SIGMGR_CALL_CLEARED
argument_list|,
operator|(
name|KBuffer
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

