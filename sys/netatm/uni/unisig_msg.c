begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ===================================  * HARP  |  Host ATM Research Platform  * ===================================  *  *  * This Host ATM Research Platform ("HARP") file (the "Software") is  * made available by Network Computing Services, Inc. ("NetworkCS")  * "AS IS".  NetworkCS does not provide maintenance, improvements or  * support of any kind.  *  * NETWORKCS MAKES NO WARRANTIES OR REPRESENTATIONS, EXPRESS OR IMPLIED,  * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE, AS TO ANY ELEMENT OF THE  * SOFTWARE OR ANY SUPPORT PROVIDED IN CONNECTION WITH THIS SOFTWARE.  * In no event shall NetworkCS be responsible for any damages, including  * but not limited to consequential damages, arising from or relating to  * any use of the Software or related support.  *  * Copyright 1994-1998 Network Computing Services, Inc.  *  * Copies of this Software may be made, however, the above copyright  * notice must be reproduced on all copies.  */
end_comment

begin_comment
comment|/*  * ATM Forum UNI 3.0/3.1 Signalling Manager  * ----------------------------------------  *  * Message handling module  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netatm/port.h>
end_include

begin_include
include|#
directive|include
file|<netatm/queue.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sys.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sap.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_cm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_if.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_vc.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sigmgr.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_stack.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_var.h>
end_include

begin_include
include|#
directive|include
file|<netatm/uni/unisig_var.h>
end_include

begin_include
include|#
directive|include
file|<netatm/uni/unisig_msg.h>
end_include

begin_include
include|#
directive|include
file|<netatm/uni/unisig_mbuf.h>
end_include

begin_include
include|#
directive|include
file|<netatm/uni/unisig_print.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_comment
comment|/*  * Local functions  */
end_comment

begin_function_decl
specifier|static
name|void
name|unisig_rcv_restart
parameter_list|(
name|struct
name|unisig
modifier|*
parameter_list|,
name|struct
name|unisig_msg
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unisig_rcv_setup
parameter_list|(
name|struct
name|unisig
modifier|*
parameter_list|,
name|struct
name|unisig_msg
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * net.harp.uni.unisig_print_msg  *  * 0 - disable  * 1 - dump UNI message  * 2 - dump UNI message + print decoded form  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|unisig_print_msg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_harp_uni
argument_list|,
name|OID_AUTO
argument_list|,
name|unisig_print_msg
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|unisig_print_msg
argument_list|,
literal|0
argument_list|,
literal|"dump UNI messages"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Set a Cause IE based on information in an ATM attribute block  *  * Arguments:  *	iep	pointer to a cause IE  *	aap	pointer to attribute block  *  * Returns:  *	0	message sent OK  *	errno	error encountered  *  */
end_comment

begin_function
name|void
name|unisig_cause_from_attr
parameter_list|(
name|iep
parameter_list|,
name|aap
parameter_list|)
name|struct
name|ie_generic
modifier|*
name|iep
decl_stmt|;
name|Atm_attributes
modifier|*
name|aap
decl_stmt|;
block|{
comment|/* 	 * Copy cause info from attribute block to IE 	 */
name|iep
operator|->
name|ie_ident
operator|=
name|UNI_IE_CAUS
expr_stmt|;
name|iep
operator|->
name|ie_coding
operator|=
name|aap
operator|->
name|cause
operator|.
name|v
operator|.
name|coding_standard
expr_stmt|;
name|iep
operator|->
name|ie_caus_loc
operator|=
name|aap
operator|->
name|cause
operator|.
name|v
operator|.
name|location
expr_stmt|;
name|iep
operator|->
name|ie_caus_cause
operator|=
name|aap
operator|->
name|cause
operator|.
name|v
operator|.
name|cause_value
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set a Cause IE based on information in a UNI signalling message  *  * Arguments:  *	iep	pointer to a cause IE  *	msg	pointer to message  *	cause	cause code for the error  *  * Returns:  *	0	message sent OK  *	errno	error encountered  *  */
end_comment

begin_function
name|void
name|unisig_cause_from_msg
parameter_list|(
name|iep
parameter_list|,
name|msg
parameter_list|,
name|cause
parameter_list|)
name|struct
name|ie_generic
modifier|*
name|iep
decl_stmt|;
name|struct
name|unisig_msg
modifier|*
name|msg
decl_stmt|;
name|int
name|cause
decl_stmt|;
block|{
name|struct
name|ie_generic
modifier|*
name|ie1
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Fill out the cause IE fixed fields 	 */
name|iep
operator|->
name|ie_ident
operator|=
name|UNI_IE_CAUS
expr_stmt|;
name|iep
operator|->
name|ie_caus_loc
operator|=
name|UNI_IE_CAUS_LOC_USER
expr_stmt|;
name|iep
operator|->
name|ie_caus_cause
operator|=
name|cause
expr_stmt|;
comment|/* 	 * Set diagnostics if indicated 	 */
switch|switch
condition|(
name|cause
condition|)
block|{
case|case
name|UNI_IE_CAUS_IECONTENT
case|:
name|iep
operator|->
name|ie_caus_diag_len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ie1
operator|=
name|msg
operator|->
name|msg_ie_err
init|;
name|ie1
operator|&&
name|i
operator|<
name|UNI_IE_CAUS_MAX_ID
condition|;
name|ie1
operator|=
name|ie1
operator|->
name|ie_next
control|)
block|{
if|if
condition|(
name|ie1
operator|->
name|ie_err_cause
operator|==
name|UNI_IE_CAUS_IECONTENT
condition|)
block|{
name|iep
operator|->
name|ie_caus_diagnostic
index|[
name|i
index|]
operator|=
name|ie1
operator|->
name|ie_ident
expr_stmt|;
name|iep
operator|->
name|ie_caus_diag_len
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
break|break;
case|case
name|UNI_IE_CAUS_REJECT
case|:
name|iep
operator|->
name|ie_caus_diag_len
operator|=
literal|2
expr_stmt|;
name|iep
operator|->
name|ie_caus_diagnostic
index|[
literal|0
index|]
operator|=
name|UNI_IE_EXT_BIT
operator|+
operator|(
name|UNI_IE_CAUS_RR_USER
operator|<<
name|UNI_IE_CAUS_RR_SHIFT
operator|)
operator|+
name|UNI_IE_CAUS_RC_TRANS
expr_stmt|;
name|iep
operator|->
name|ie_caus_diagnostic
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|UNI_IE_CAUS_MISSING
case|:
name|iep
operator|->
name|ie_caus_diag_len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ie1
operator|=
name|msg
operator|->
name|msg_ie_err
init|;
name|ie1
operator|&&
name|i
operator|<
name|UNI_IE_CAUS_MAX_ID
condition|;
name|ie1
operator|=
name|ie1
operator|->
name|ie_next
control|)
block|{
if|if
condition|(
name|ie1
operator|->
name|ie_err_cause
operator|==
name|UNI_IE_CAUS_MISSING
condition|)
block|{
name|iep
operator|->
name|ie_caus_diagnostic
index|[
name|i
index|]
operator|=
name|ie1
operator|->
name|ie_ident
expr_stmt|;
name|iep
operator|->
name|ie_caus_diag_len
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Send a UNISIG signalling message  *  * Called to send a Q.2931 message.  This routine encodes the message  * and hands it to SSCF for transmission.  *  * Arguments:  *	usp	pointer to UNISIG protocol instance block  *	msg	pointer to message  *  * Returns:  *	0	message sent OK  *	errno	error encountered  *  */
end_comment

begin_function
name|int
name|unisig_send_msg
parameter_list|(
name|usp
parameter_list|,
name|msg
parameter_list|)
name|struct
name|unisig
modifier|*
name|usp
decl_stmt|;
name|struct
name|unisig_msg
modifier|*
name|msg
decl_stmt|;
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|struct
name|usfmt
name|usf
decl_stmt|;
name|ATM_DEBUG2
argument_list|(
literal|"unisig_send_msg: msg=%p, type=%d\n"
argument_list|,
name|msg
argument_list|,
name|msg
operator|->
name|msg_type
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure the network is up 	 */
if|if
condition|(
name|usp
operator|->
name|us_state
operator|!=
name|UNISIG_ACTIVE
condition|)
return|return
operator|(
name|ENETDOWN
operator|)
return|;
comment|/* 	 * Print the message we're sending. 	 */
if|if
condition|(
name|unisig_print_msg
condition|)
name|usp_print_msg
argument_list|(
name|msg
argument_list|,
name|UNISIG_MSG_OUT
argument_list|)
expr_stmt|;
comment|/* 	 * Convert message to network order 	 */
name|err
operator|=
name|usf_init
argument_list|(
operator|&
name|usf
argument_list|,
name|usp
argument_list|,
operator|(
name|KBuffer
operator|*
operator|)
literal|0
argument_list|,
name|USF_ENCODE
argument_list|,
name|usp
operator|->
name|us_headout
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|err
operator|=
name|usf_enc_msg
argument_list|(
operator|&
name|usf
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|ATM_DEBUG1
argument_list|(
literal|"unisig_send_msg: encode failed with %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|KB_FREEALL
argument_list|(
name|usf
operator|.
name|usf_m_base
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* 	 * Print the converted message 	 */
if|if
condition|(
name|unisig_print_msg
operator|>
literal|1
condition|)
name|unisig_print_mbuf
argument_list|(
name|usf
operator|.
name|usf_m_base
argument_list|)
expr_stmt|;
comment|/* 	 * Send the message 	 */
name|err
operator|=
name|atm_cm_saal_data
argument_list|(
name|usp
operator|->
name|us_conn
argument_list|,
name|usf
operator|.
name|usf_m_base
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|KB_FREEALL
argument_list|(
name|usf
operator|.
name|usf_m_base
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send a SETUP request  *  * Build and send a Q.2931 SETUP message.  *  * Arguments:  *	usp	pointer to UNISIG protocol instance block  *	uvp	pointer to VCCB for which the request is being sent  *  * Returns:  *	none  *  */
end_comment

begin_function
name|int
name|unisig_send_setup
parameter_list|(
name|usp
parameter_list|,
name|uvp
parameter_list|)
name|struct
name|unisig
modifier|*
name|usp
decl_stmt|;
name|struct
name|unisig_vccb
modifier|*
name|uvp
decl_stmt|;
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|struct
name|unisig_msg
modifier|*
name|setup
decl_stmt|;
name|Atm_attributes
modifier|*
name|ap
init|=
operator|&
name|uvp
operator|->
name|uv_connvc
operator|->
name|cvc_attr
decl_stmt|;
name|ATM_DEBUG1
argument_list|(
literal|"unisig_send_setup: uvp=%p\n"
argument_list|,
name|uvp
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure required connection attriutes are set 	 */
if|if
condition|(
name|ap
operator|->
name|aal
operator|.
name|tag
operator|!=
name|T_ATM_PRESENT
operator|||
name|ap
operator|->
name|traffic
operator|.
name|tag
operator|!=
name|T_ATM_PRESENT
operator|||
name|ap
operator|->
name|bearer
operator|.
name|tag
operator|!=
name|T_ATM_PRESENT
operator|||
name|ap
operator|->
name|called
operator|.
name|tag
operator|!=
name|T_ATM_PRESENT
operator|||
name|ap
operator|->
name|qos
operator|.
name|tag
operator|!=
name|T_ATM_PRESENT
condition|)
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
name|setup
operator|=
name|NULL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Get memory for a SETUP message 	 */
name|setup
operator|=
name|uma_zalloc
argument_list|(
name|unisig_msg_zone
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|setup
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Fill in the SETUP message 	 */
if|if
condition|(
operator|!
name|uvp
operator|->
name|uv_call_ref
condition|)
name|uvp
operator|->
name|uv_call_ref
operator|=
name|unisig_alloc_call_ref
argument_list|(
name|usp
argument_list|)
expr_stmt|;
name|setup
operator|->
name|msg_call_ref
operator|=
name|uvp
operator|->
name|uv_call_ref
expr_stmt|;
name|setup
operator|->
name|msg_type
operator|=
name|UNI_MSG_SETU
expr_stmt|;
comment|/* 	 * Set IEs from connection attributes 	 */
name|err
operator|=
name|unisig_set_attrs
argument_list|(
name|usp
argument_list|,
name|setup
argument_list|,
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|done
goto|;
comment|/* 	 * Attach a Calling Party Number IE if the user didn't 	 * specify one in the attribute block 	 */
if|if
condition|(
name|ap
operator|->
name|calling
operator|.
name|tag
operator|!=
name|T_ATM_PRESENT
condition|)
block|{
name|setup
operator|->
name|msg_ie_cgad
operator|=
name|uma_zalloc
argument_list|(
name|unisig_ie_zone
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|setup
operator|->
name|msg_ie_cgad
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|setup
operator|->
name|msg_ie_cgad
operator|->
name|ie_ident
operator|=
name|UNI_IE_CGAD
expr_stmt|;
name|ATM_ADDR_COPY
argument_list|(
operator|&
name|usp
operator|->
name|us_addr
argument_list|,
operator|&
name|setup
operator|->
name|msg_ie_cgad
operator|->
name|ie_cgad_addr
argument_list|)
expr_stmt|;
name|ATM_ADDR_SEL_COPY
argument_list|(
operator|&
name|usp
operator|->
name|us_addr
argument_list|,
name|uvp
operator|->
name|uv_nif
condition|?
name|uvp
operator|->
name|uv_nif
operator|->
name|nif_sel
else|:
literal|0
argument_list|,
operator|&
name|setup
operator|->
name|msg_ie_cgad
operator|->
name|ie_cgad_addr
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Send the SETUP message 	 */
name|err
operator|=
name|unisig_send_msg
argument_list|(
name|usp
argument_list|,
name|setup
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|setup
condition|)
name|unisig_free_msg
argument_list|(
name|setup
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send a RELEASE message  *  * Arguments:  *	usp	pointer to UNISIG protocol instance block  *	uvp	pointer to VCCB for which the RELEASE is being sent  *	msg	pointer to UNI signalling message that the RELEASE  *		responds to (may be NULL)  *	cause	the reason for the RELEASE; a value of  *		T_ATM_ABSENT indicates that the cause code is  *		in the VCC's ATM attributes block  *  * Returns:  *	none  *  */
end_comment

begin_function
name|int
name|unisig_send_release
parameter_list|(
name|usp
parameter_list|,
name|uvp
parameter_list|,
name|msg
parameter_list|,
name|cause
parameter_list|)
name|struct
name|unisig
modifier|*
name|usp
decl_stmt|;
name|struct
name|unisig_vccb
modifier|*
name|uvp
decl_stmt|;
name|struct
name|unisig_msg
modifier|*
name|msg
decl_stmt|;
name|int
name|cause
decl_stmt|;
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|struct
name|unisig_msg
modifier|*
name|rls_msg
decl_stmt|;
name|struct
name|ie_generic
modifier|*
name|cause_ie
decl_stmt|;
name|ATM_DEBUG2
argument_list|(
literal|"unisig_send_release: usp=%p, uvp=%p\n"
argument_list|,
name|usp
argument_list|,
name|uvp
argument_list|)
expr_stmt|;
comment|/* 	 * Get memory for a RELEASE message 	 */
name|rls_msg
operator|=
name|uma_zalloc
argument_list|(
name|unisig_msg_zone
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rls_msg
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|cause_ie
operator|=
name|uma_zalloc
argument_list|(
name|unisig_ie_zone
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause_ie
operator|==
name|NULL
condition|)
block|{
name|uma_zfree
argument_list|(
name|unisig_msg_zone
argument_list|,
name|rls_msg
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* 	 * Fill in the RELEASE message 	 */
name|rls_msg
operator|->
name|msg_call_ref
operator|=
name|uvp
operator|->
name|uv_call_ref
expr_stmt|;
name|rls_msg
operator|->
name|msg_type
operator|=
name|UNI_MSG_RLSE
expr_stmt|;
name|rls_msg
operator|->
name|msg_type_flag
operator|=
literal|0
expr_stmt|;
name|rls_msg
operator|->
name|msg_type_action
operator|=
literal|0
expr_stmt|;
name|rls_msg
operator|->
name|msg_ie_caus
operator|=
name|cause_ie
expr_stmt|;
comment|/* 	 * Fill out the cause IE 	 */
name|cause_ie
operator|->
name|ie_ident
operator|=
name|UNI_IE_CAUS
expr_stmt|;
if|if
condition|(
name|cause
operator|==
name|T_ATM_ABSENT
condition|)
block|{
name|unisig_cause_from_attr
argument_list|(
name|cause_ie
argument_list|,
operator|&
name|uvp
operator|->
name|uv_connvc
operator|->
name|cvc_attr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cause_ie
operator|->
name|ie_caus_loc
operator|=
name|UNI_IE_CAUS_LOC_USER
expr_stmt|;
name|unisig_cause_from_msg
argument_list|(
name|cause_ie
argument_list|,
name|msg
argument_list|,
name|cause
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Send the RELEASE 	 */
name|err
operator|=
name|unisig_send_msg
argument_list|(
name|usp
argument_list|,
name|rls_msg
argument_list|)
expr_stmt|;
name|unisig_free_msg
argument_list|(
name|rls_msg
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send a RELEASE COMPLETE message  *  * Arguments:  *	usp	pointer to UNISIG protocol instance block  *	uvp	pointer to VCCB for which the RELEASE is being sent.  *		NULL indicates that a VCCB wasn't found for a call  *		reference value.  *	msg	pointer to the message which triggered the send  *	cause	the cause code for the message; a value of  *		T_ATM_ABSENT indicates that the cause code is  *		in the VCC's ATM attributes block  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
name|int
name|unisig_send_release_complete
parameter_list|(
name|usp
parameter_list|,
name|uvp
parameter_list|,
name|msg
parameter_list|,
name|cause
parameter_list|)
name|struct
name|unisig
modifier|*
name|usp
decl_stmt|;
name|struct
name|unisig_vccb
modifier|*
name|uvp
decl_stmt|;
name|struct
name|unisig_msg
modifier|*
name|msg
decl_stmt|;
name|int
name|cause
decl_stmt|;
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|struct
name|unisig_msg
modifier|*
name|rls_cmp
decl_stmt|;
name|struct
name|ie_generic
modifier|*
name|cause_ie
decl_stmt|;
name|ATM_DEBUG4
argument_list|(
literal|"unisig_send_release_complete usp=%p, uvp=%p, msg=%p, cause=%d\n"
argument_list|,
name|usp
argument_list|,
name|uvp
argument_list|,
name|msg
argument_list|,
name|cause
argument_list|)
expr_stmt|;
comment|/* 	 * Get memory for a RELEASE COMPLETE message 	 */
name|rls_cmp
operator|=
name|uma_zalloc
argument_list|(
name|unisig_msg_zone
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rls_cmp
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|cause_ie
operator|=
name|uma_zalloc
argument_list|(
name|unisig_ie_zone
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause_ie
operator|==
name|NULL
condition|)
block|{
name|uma_zfree
argument_list|(
name|unisig_msg_zone
argument_list|,
name|rls_cmp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* 	 * Fill in the RELEASE COMPLETE message 	 */
if|if
condition|(
name|uvp
condition|)
block|{
name|rls_cmp
operator|->
name|msg_call_ref
operator|=
name|uvp
operator|->
name|uv_call_ref
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|msg
condition|)
block|{
name|rls_cmp
operator|->
name|msg_call_ref
operator|=
name|EXTRACT_CREF
argument_list|(
name|msg
operator|->
name|msg_call_ref
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rls_cmp
operator|->
name|msg_call_ref
operator|=
name|UNI_MSG_CALL_REF_GLOBAL
expr_stmt|;
block|}
name|rls_cmp
operator|->
name|msg_type
operator|=
name|UNI_MSG_RLSC
expr_stmt|;
name|rls_cmp
operator|->
name|msg_type_flag
operator|=
literal|0
expr_stmt|;
name|rls_cmp
operator|->
name|msg_type_action
operator|=
literal|0
expr_stmt|;
name|rls_cmp
operator|->
name|msg_ie_caus
operator|=
name|cause_ie
expr_stmt|;
comment|/* 	 * Fill out the cause IE 	 */
name|cause_ie
operator|->
name|ie_ident
operator|=
name|UNI_IE_CAUS
expr_stmt|;
if|if
condition|(
name|cause
operator|==
name|T_ATM_ABSENT
condition|)
block|{
name|unisig_cause_from_attr
argument_list|(
name|cause_ie
argument_list|,
operator|&
name|uvp
operator|->
name|uv_connvc
operator|->
name|cvc_attr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cause_ie
operator|->
name|ie_caus_loc
operator|=
name|UNI_IE_CAUS_LOC_USER
expr_stmt|;
name|unisig_cause_from_msg
argument_list|(
name|cause_ie
argument_list|,
name|msg
argument_list|,
name|cause
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Send the RELEASE COMPLETE 	 */
name|err
operator|=
name|unisig_send_msg
argument_list|(
name|usp
argument_list|,
name|rls_cmp
argument_list|)
expr_stmt|;
name|unisig_free_msg
argument_list|(
name|rls_cmp
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send a STATUS message  *  * Arguments:  *	usp	pointer to UNISIG protocol instance block  *	uvp	pointer to VCCB for which the STATUS is being sent.  *		NULL indicates that a VCCB wasn't found for a call  *		reference value.  *	msg	pointer to the message which triggered the send  *	cause	the cause code to include in the message  *  * Returns:  *	none  *  */
end_comment

begin_function
name|int
name|unisig_send_status
parameter_list|(
name|usp
parameter_list|,
name|uvp
parameter_list|,
name|msg
parameter_list|,
name|cause
parameter_list|)
name|struct
name|unisig
modifier|*
name|usp
decl_stmt|;
name|struct
name|unisig_vccb
modifier|*
name|uvp
decl_stmt|;
name|struct
name|unisig_msg
modifier|*
name|msg
decl_stmt|;
name|int
name|cause
decl_stmt|;
block|{
name|int
name|err
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|unisig_msg
modifier|*
name|stat_msg
decl_stmt|;
name|struct
name|ie_generic
modifier|*
name|cause_ie
decl_stmt|,
modifier|*
name|clst_ie
decl_stmt|,
modifier|*
name|iep
decl_stmt|;
name|ATM_DEBUG4
argument_list|(
literal|"unisig_send_status: usp=%p, uvp=%p, msg=%p, cause=%d\n"
argument_list|,
name|usp
argument_list|,
name|uvp
argument_list|,
name|msg
argument_list|,
name|cause
argument_list|)
expr_stmt|;
comment|/* 	 * Get memory for a STATUS message 	 */
name|stat_msg
operator|=
name|uma_zalloc
argument_list|(
name|unisig_msg_zone
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat_msg
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|cause_ie
operator|=
name|uma_zalloc
argument_list|(
name|unisig_ie_zone
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause_ie
operator|==
name|NULL
condition|)
block|{
name|uma_zfree
argument_list|(
name|unisig_msg_zone
argument_list|,
name|stat_msg
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|clst_ie
operator|=
name|uma_zalloc
argument_list|(
name|unisig_ie_zone
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|clst_ie
operator|==
name|NULL
condition|)
block|{
name|uma_zfree
argument_list|(
name|unisig_msg_zone
argument_list|,
name|stat_msg
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|unisig_ie_zone
argument_list|,
name|cause_ie
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* 	 * Fill in the STATUS message 	 */
if|if
condition|(
name|uvp
condition|)
block|{
name|stat_msg
operator|->
name|msg_call_ref
operator|=
name|uvp
operator|->
name|uv_call_ref
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|msg
condition|)
block|{
name|stat_msg
operator|->
name|msg_call_ref
operator|=
name|EXTRACT_CREF
argument_list|(
name|msg
operator|->
name|msg_call_ref
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stat_msg
operator|->
name|msg_call_ref
operator|=
name|UNI_MSG_CALL_REF_GLOBAL
expr_stmt|;
block|}
name|stat_msg
operator|->
name|msg_type
operator|=
name|UNI_MSG_STAT
expr_stmt|;
name|stat_msg
operator|->
name|msg_type_flag
operator|=
literal|0
expr_stmt|;
name|stat_msg
operator|->
name|msg_type_action
operator|=
literal|0
expr_stmt|;
name|stat_msg
operator|->
name|msg_ie_clst
operator|=
name|clst_ie
expr_stmt|;
name|stat_msg
operator|->
name|msg_ie_caus
operator|=
name|cause_ie
expr_stmt|;
comment|/* 	 * Fill out the call state IE 	 */
name|clst_ie
operator|->
name|ie_ident
operator|=
name|UNI_IE_CLST
expr_stmt|;
name|clst_ie
operator|->
name|ie_coding
operator|=
literal|0
expr_stmt|;
name|clst_ie
operator|->
name|ie_flag
operator|=
literal|0
expr_stmt|;
name|clst_ie
operator|->
name|ie_action
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|uvp
condition|)
block|{
name|clst_ie
operator|->
name|ie_clst_state
operator|=
name|uvp
operator|->
name|uv_sstate
expr_stmt|;
block|}
else|else
block|{
name|clst_ie
operator|->
name|ie_clst_state
operator|=
name|UNI_NULL
expr_stmt|;
block|}
comment|/* 	 * Fill out the cause IE 	 */
name|cause_ie
operator|->
name|ie_ident
operator|=
name|UNI_IE_CAUS
expr_stmt|;
name|cause_ie
operator|->
name|ie_coding
operator|=
literal|0
expr_stmt|;
name|cause_ie
operator|->
name|ie_flag
operator|=
literal|0
expr_stmt|;
name|cause_ie
operator|->
name|ie_action
operator|=
literal|0
expr_stmt|;
name|cause_ie
operator|->
name|ie_caus_loc
operator|=
name|UNI_IE_CAUS_LOC_USER
expr_stmt|;
name|cause_ie
operator|->
name|ie_caus_cause
operator|=
name|cause
expr_stmt|;
switch|switch
condition|(
name|cause
condition|)
block|{
case|case
name|UNI_IE_CAUS_MTEXIST
case|:
case|case
name|UNI_IE_CAUS_STATE
case|:
if|if
condition|(
name|msg
condition|)
block|{
name|cause_ie
operator|->
name|ie_caus_diagnostic
index|[
literal|0
index|]
operator|=
name|msg
operator|->
name|msg_type
expr_stmt|;
block|}
break|break;
case|case
name|UNI_IE_CAUS_MISSING
case|:
case|case
name|UNI_IE_CAUS_IECONTENT
case|:
case|case
name|UNI_IE_CAUS_IEEXIST
case|:
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|iep
operator|=
name|msg
operator|->
name|msg_ie_err
init|;
name|iep
operator|&&
name|i
operator|<
name|UNI_MSG_IE_CNT
condition|;
name|i
operator|++
operator|,
name|iep
operator|=
name|iep
operator|->
name|ie_next
control|)
block|{
if|if
condition|(
name|iep
operator|->
name|ie_err_cause
operator|==
name|cause
condition|)
block|{
name|cause_ie
operator|->
name|ie_caus_diagnostic
index|[
name|i
index|]
operator|=
name|iep
operator|->
name|ie_ident
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Send the STATUS message 	 */
name|err
operator|=
name|unisig_send_msg
argument_list|(
name|usp
argument_list|,
name|stat_msg
argument_list|)
expr_stmt|;
name|unisig_free_msg
argument_list|(
name|stat_msg
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process a RESTART message  *  * Arguments:  *	usp	pointer to UNISIG protocol instance block  *	msg	pointer to the RESTART message  *  * Returns:  *	none  *  */
end_comment

begin_function
specifier|static
name|void
name|unisig_rcv_restart
parameter_list|(
name|usp
parameter_list|,
name|msg
parameter_list|)
name|struct
name|unisig
modifier|*
name|usp
decl_stmt|;
name|struct
name|unisig_msg
modifier|*
name|msg
decl_stmt|;
block|{
name|struct
name|unisig_vccb
modifier|*
name|uvp
decl_stmt|,
modifier|*
name|uvnext
decl_stmt|;
name|struct
name|unisig_msg
modifier|*
name|rsta_msg
decl_stmt|;
name|int
name|s
decl_stmt|;
name|ATM_DEBUG2
argument_list|(
literal|"unisig_rcv_restart: usp=%p, msg=%p\n"
argument_list|,
name|usp
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|/* 	 * Check what class of VCCs we're supposed to restart 	 */
if|if
condition|(
name|msg
operator|->
name|msg_ie_rsti
operator|->
name|ie_rsti_class
operator|==
name|UNI_IE_RSTI_IND_VC
condition|)
block|{
comment|/* 		 * Just restart the indicated VCC 		 */
if|if
condition|(
name|msg
operator|->
name|msg_ie_cnid
condition|)
block|{
name|uvp
operator|=
name|unisig_find_vpvc
argument_list|(
name|usp
argument_list|,
name|msg
operator|->
name|msg_ie_cnid
operator|->
name|ie_cnid_vpci
argument_list|,
name|msg
operator|->
name|msg_ie_cnid
operator|->
name|ie_cnid_vci
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|uvp
operator|&&
name|uvp
operator|->
name|uv_type
operator|&
name|VCC_SVC
condition|)
block|{
operator|(
name|void
operator|)
name|unisig_clear_vcc
argument_list|(
name|usp
argument_list|,
name|uvp
argument_list|,
name|T_ATM_CAUSE_NORMAL_CALL_CLEARING
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* 		 * Restart all VCCs 		 */
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
for|for
control|(
name|uvp
operator|=
name|Q_HEAD
argument_list|(
name|usp
operator|->
name|us_vccq
argument_list|,
expr|struct
name|unisig_vccb
argument_list|)
init|;
name|uvp
condition|;
name|uvp
operator|=
name|uvnext
control|)
block|{
name|uvnext
operator|=
name|Q_NEXT
argument_list|(
name|uvp
argument_list|,
expr|struct
name|unisig_vccb
argument_list|,
name|uv_sigelem
argument_list|)
expr_stmt|;
if|if
condition|(
name|uvp
operator|->
name|uv_type
operator|&
name|VCC_SVC
condition|)
block|{
operator|(
name|void
operator|)
name|unisig_clear_vcc
argument_list|(
name|usp
argument_list|,
name|uvp
argument_list|,
name|T_ATM_CAUSE_NORMAL_CALL_CLEARING
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Get memory for a RESTART ACKNOWLEDGE message 	 */
name|rsta_msg
operator|=
name|uma_zalloc
argument_list|(
name|unisig_msg_zone
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsta_msg
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
comment|/* 	 * Fill out the message 	 */
name|rsta_msg
operator|->
name|msg_call_ref
operator|=
name|EXTRACT_CREF
argument_list|(
name|msg
operator|->
name|msg_call_ref
argument_list|)
expr_stmt|;
name|rsta_msg
operator|->
name|msg_type
operator|=
name|UNI_MSG_RSTA
expr_stmt|;
name|rsta_msg
operator|->
name|msg_type_flag
operator|=
literal|0
expr_stmt|;
name|rsta_msg
operator|->
name|msg_type_action
operator|=
literal|0
expr_stmt|;
name|rsta_msg
operator|->
name|msg_ie_rsti
operator|=
name|msg
operator|->
name|msg_ie_rsti
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|msg_ie_cnid
condition|)
block|{
name|rsta_msg
operator|->
name|msg_ie_cnid
operator|=
name|msg
operator|->
name|msg_ie_cnid
expr_stmt|;
block|}
comment|/* 	 * Send the message 	 */
operator|(
name|void
operator|)
name|unisig_send_msg
argument_list|(
name|usp
argument_list|,
name|rsta_msg
argument_list|)
expr_stmt|;
name|rsta_msg
operator|->
name|msg_ie_rsti
operator|=
name|NULL
expr_stmt|;
name|rsta_msg
operator|->
name|msg_ie_cnid
operator|=
name|NULL
expr_stmt|;
name|unisig_free_msg
argument_list|(
name|rsta_msg
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Process a SETUP message  *  * Arguments:  *	usp	pointer to UNISIG protocol instance block  *	msg	pointer to the SETUP message  *  * Returns:  *	none  *  */
end_comment

begin_function
specifier|static
name|void
name|unisig_rcv_setup
parameter_list|(
name|usp
parameter_list|,
name|msg
parameter_list|)
name|struct
name|unisig
modifier|*
name|usp
decl_stmt|;
name|struct
name|unisig_msg
modifier|*
name|msg
decl_stmt|;
block|{
name|struct
name|unisig_vccb
modifier|*
name|uvp
init|=
name|NULL
decl_stmt|;
name|struct
name|ie_generic
modifier|*
name|iep
decl_stmt|;
name|ATM_DEBUG2
argument_list|(
literal|"unisig_rcv_setup: usp=%p, msg=%p\n"
argument_list|,
name|usp
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|/* 	 * If we already have a VCC with the call reference, 	 * ignore the SETUP message 	 */
name|uvp
operator|=
name|unisig_find_conn
argument_list|(
name|usp
argument_list|,
name|EXTRACT_CREF
argument_list|(
name|msg
operator|->
name|msg_call_ref
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|uvp
condition|)
return|return;
comment|/* 	 * If the call reference flag is incorrectly set,  	 * ignore the SETUP message 	 */
if|if
condition|(
name|msg
operator|->
name|msg_call_ref
operator|&
name|UNI_MSG_CALL_REF_RMT
condition|)
return|return;
comment|/* 	 * If there are missing mandatory IEs, send a 	 * RELEASE COMPLETE message and ignore the SETUP 	 */
for|for
control|(
name|iep
operator|=
name|msg
operator|->
name|msg_ie_err
init|;
name|iep
condition|;
name|iep
operator|=
name|iep
operator|->
name|ie_next
control|)
block|{
if|if
condition|(
name|iep
operator|->
name|ie_err_cause
operator|==
name|UNI_IE_CAUS_MISSING
condition|)
block|{
operator|(
name|void
operator|)
name|unisig_send_release_complete
argument_list|(
name|usp
argument_list|,
name|uvp
argument_list|,
name|msg
argument_list|,
name|UNI_IE_CAUS_MISSING
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * If there are mandatory IEs with invalid content, send a 	 * RELEASE COMPLETE message and ignore the SETUP 	 */
for|for
control|(
name|iep
operator|=
name|msg
operator|->
name|msg_ie_err
init|;
name|iep
condition|;
name|iep
operator|=
name|iep
operator|->
name|ie_next
control|)
block|{
if|if
condition|(
name|iep
operator|->
name|ie_err_cause
operator|==
name|UNI_IE_CAUS_IECONTENT
condition|)
block|{
operator|(
name|void
operator|)
name|unisig_send_release_complete
argument_list|(
name|usp
argument_list|,
name|uvp
argument_list|,
name|msg
argument_list|,
name|UNI_IE_CAUS_IECONTENT
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * Get a new VCCB for the connection 	 */
name|uvp
operator|=
name|uma_zalloc
argument_list|(
name|unisig_vc_zone
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|uvp
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
comment|/* 	 * Put the VCCB on the UNISIG queue 	 */
name|ENQUEUE
argument_list|(
name|uvp
argument_list|,
expr|struct
name|unisig_vccb
argument_list|,
name|uv_sigelem
argument_list|,
name|usp
operator|->
name|us_vccq
argument_list|)
expr_stmt|;
comment|/* 	 * Set the state and call reference value 	 */
name|uvp
operator|->
name|uv_sstate
operator|=
name|UNI_NULL
expr_stmt|;
name|uvp
operator|->
name|uv_call_ref
operator|=
name|EXTRACT_CREF
argument_list|(
name|msg
operator|->
name|msg_call_ref
argument_list|)
expr_stmt|;
comment|/* 	 * Pass the VCCB and message to the VC state machine 	 */
operator|(
name|void
operator|)
name|unisig_vc_state
argument_list|(
name|usp
argument_list|,
name|uvp
argument_list|,
name|UNI_VC_SETUP_MSG
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|/* 	 * If the VCCB state is NULL, the open failed and the 	 * VCCB should be released 	 */
if|if
condition|(
name|uvp
operator|->
name|uv_sstate
operator|==
name|UNI_NULL
condition|)
block|{
name|DEQUEUE
argument_list|(
name|uvp
argument_list|,
expr|struct
name|unisig_vccb
argument_list|,
name|uv_sigelem
argument_list|,
name|usp
operator|->
name|us_vccq
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|unisig_vc_zone
argument_list|,
name|uvp
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * Process a UNISIG signalling message  *  * Called when a UNISIG message is received.  The message is decoded  * and passed to the UNISIG state machine.  Unrecognized and  * unexpected messages are logged.  *  * Arguments:  *	usp	pointer to UNISIG protocol instance block  *	m	pointer to a buffer chain containing the UNISIG message  *  * Returns:  *	none  *  */
end_comment

begin_function
name|int
name|unisig_rcv_msg
parameter_list|(
name|usp
parameter_list|,
name|m
parameter_list|)
name|struct
name|unisig
modifier|*
name|usp
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
block|{
name|int
name|err
decl_stmt|;
name|u_int
name|cref
decl_stmt|;
name|struct
name|usfmt
name|usf
decl_stmt|;
name|struct
name|unisig_msg
modifier|*
name|msg
init|=
literal|0
decl_stmt|;
name|struct
name|unisig_vccb
modifier|*
name|uvp
init|=
literal|0
decl_stmt|;
name|struct
name|ie_generic
modifier|*
name|iep
decl_stmt|;
name|ATM_DEBUG2
argument_list|(
literal|"unisig_rcv_msg: bfr=%p, len=%d\n"
argument_list|,
name|m
argument_list|,
name|KB_LEN
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NOTDEF
name|unisig_print_mbuf
argument_list|(
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Get storage for the message 	 */
name|msg
operator|=
name|uma_zalloc
argument_list|(
name|unisig_msg_zone
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Convert the message from network order to internal format 	 */
name|err
operator|=
name|usf_init
argument_list|(
operator|&
name|usf
argument_list|,
name|usp
argument_list|,
name|m
argument_list|,
name|USF_DECODE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|==
name|EINVAL
condition|)
name|panic
argument_list|(
literal|"unisig_rcv_msg: invalid parameter\n"
argument_list|)
expr_stmt|;
name|ATM_DEBUG1
argument_list|(
literal|"unisig_rcv_msg: decode init failed with %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|err
operator|=
name|usf_dec_msg
argument_list|(
operator|&
name|usf
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|ATM_DEBUG1
argument_list|(
literal|"unisig_rcv_msg: decode failed with %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Debug--print some information about the message 	 */
if|if
condition|(
name|unisig_print_msg
condition|)
name|usp_print_msg
argument_list|(
name|msg
argument_list|,
name|UNISIG_MSG_IN
argument_list|)
expr_stmt|;
comment|/* 	 * Get the call reference value 	 */
name|cref
operator|=
name|EXTRACT_CREF
argument_list|(
name|msg
operator|->
name|msg_call_ref
argument_list|)
expr_stmt|;
comment|/* 	 * Any message with the global call reference value except 	 * RESTART, RESTART ACK, or STATUS is in error 	 */
if|if
condition|(
name|GLOBAL_CREF
argument_list|(
name|cref
argument_list|)
operator|&&
name|msg
operator|->
name|msg_type
operator|!=
name|UNI_MSG_RSTR
operator|&&
name|msg
operator|->
name|msg_type
operator|!=
name|UNI_MSG_RSTA
operator|&&
name|msg
operator|->
name|msg_type
operator|!=
name|UNI_MSG_STAT
condition|)
block|{
comment|/* 		 * Send STATUS message indicating the error 		 */
name|err
operator|=
name|unisig_send_status
argument_list|(
name|usp
argument_list|,
operator|(
expr|struct
name|unisig_vccb
operator|*
operator|)
literal|0
argument_list|,
name|msg
argument_list|,
name|UNI_IE_CAUS_CREF
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Check for missing mandatory IEs.  Checks for SETUP, 	 * RELEASE, and RELEASE COMPLETE are handled elsewhere. 	 */
if|if
condition|(
name|msg
operator|->
name|msg_type
operator|!=
name|UNI_MSG_SETU
operator|&&
name|msg
operator|->
name|msg_type
operator|!=
name|UNI_MSG_RLSE
operator|&&
name|msg
operator|->
name|msg_type
operator|!=
name|UNI_MSG_RLSC
condition|)
block|{
for|for
control|(
name|iep
operator|=
name|msg
operator|->
name|msg_ie_err
init|;
name|iep
condition|;
name|iep
operator|=
name|iep
operator|->
name|ie_next
control|)
block|{
if|if
condition|(
name|iep
operator|->
name|ie_err_cause
operator|==
name|UNI_IE_CAUS_MISSING
condition|)
block|{
name|err
operator|=
name|unisig_send_status
argument_list|(
name|usp
argument_list|,
name|uvp
argument_list|,
name|msg
argument_list|,
name|UNI_IE_CAUS_MISSING
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
block|}
comment|/* 	 * Find the VCCB associated with the message 	 */
name|uvp
operator|=
name|unisig_find_conn
argument_list|(
name|usp
argument_list|,
name|cref
argument_list|)
expr_stmt|;
comment|/* 	 * Process the message based on its type 	 */
switch|switch
condition|(
name|msg
operator|->
name|msg_type
condition|)
block|{
case|case
name|UNI_MSG_CALP
case|:
operator|(
name|void
operator|)
name|unisig_vc_state
argument_list|(
name|usp
argument_list|,
name|uvp
argument_list|,
name|UNI_VC_CALLP_MSG
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNI_MSG_CONN
case|:
operator|(
name|void
operator|)
name|unisig_vc_state
argument_list|(
name|usp
argument_list|,
name|uvp
argument_list|,
name|UNI_VC_CONNECT_MSG
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNI_MSG_CACK
case|:
operator|(
name|void
operator|)
name|unisig_vc_state
argument_list|(
name|usp
argument_list|,
name|uvp
argument_list|,
name|UNI_VC_CNCTACK_MSG
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNI_MSG_SETU
case|:
name|unisig_rcv_setup
argument_list|(
name|usp
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNI_MSG_RLSE
case|:
operator|(
name|void
operator|)
name|unisig_vc_state
argument_list|(
name|usp
argument_list|,
name|uvp
argument_list|,
name|UNI_VC_RELEASE_MSG
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNI_MSG_RLSC
case|:
comment|/* 		 * Ignore a RELEASE COMPLETE with an unrecognized 		 * call reference value 		 */
if|if
condition|(
name|uvp
condition|)
block|{
operator|(
name|void
operator|)
name|unisig_vc_state
argument_list|(
name|usp
argument_list|,
name|uvp
argument_list|,
name|UNI_VC_RLSCMP_MSG
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|UNI_MSG_RSTR
case|:
name|unisig_rcv_restart
argument_list|(
name|usp
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNI_MSG_RSTA
case|:
break|break;
case|case
name|UNI_MSG_STAT
case|:
operator|(
name|void
operator|)
name|unisig_vc_state
argument_list|(
name|usp
argument_list|,
name|uvp
argument_list|,
name|UNI_VC_STATUS_MSG
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNI_MSG_SENQ
case|:
operator|(
name|void
operator|)
name|unisig_vc_state
argument_list|(
name|usp
argument_list|,
name|uvp
argument_list|,
name|UNI_VC_STATUSENQ_MSG
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNI_MSG_ADDP
case|:
operator|(
name|void
operator|)
name|unisig_vc_state
argument_list|(
name|usp
argument_list|,
name|uvp
argument_list|,
name|UNI_VC_ADDP_MSG
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNI_MSG_ADPA
case|:
operator|(
name|void
operator|)
name|unisig_vc_state
argument_list|(
name|usp
argument_list|,
name|uvp
argument_list|,
name|UNI_VC_ADDPACK_MSG
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNI_MSG_ADPR
case|:
operator|(
name|void
operator|)
name|unisig_vc_state
argument_list|(
name|usp
argument_list|,
name|uvp
argument_list|,
name|UNI_VC_ADDPREJ_MSG
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNI_MSG_DRPP
case|:
operator|(
name|void
operator|)
name|unisig_vc_state
argument_list|(
name|usp
argument_list|,
name|uvp
argument_list|,
name|UNI_VC_DROP_MSG
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNI_MSG_DRPA
case|:
operator|(
name|void
operator|)
name|unisig_vc_state
argument_list|(
name|usp
argument_list|,
name|uvp
argument_list|,
name|UNI_VC_DROPACK_MSG
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* 		 * Message size didn't match size received 		 */
name|err
operator|=
name|unisig_send_status
argument_list|(
name|usp
argument_list|,
name|uvp
argument_list|,
name|msg
argument_list|,
name|UNI_IE_CAUS_MTEXIST
argument_list|)
expr_stmt|;
block|}
name|done
label|:
comment|/* 	 * Handle message errors that require a response 	 */
switch|switch
condition|(
name|err
condition|)
block|{
case|case
name|EMSGSIZE
case|:
comment|/* 		 * Message size didn't match size received 		 */
name|err
operator|=
name|unisig_send_status
argument_list|(
name|usp
argument_list|,
name|uvp
argument_list|,
name|msg
argument_list|,
name|UNI_IE_CAUS_LEN
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	 * Free the incoming message (both buffer and internal format) 	 * if necessary. 	 */
if|if
condition|(
name|msg
condition|)
name|unisig_free_msg
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

end_unit

