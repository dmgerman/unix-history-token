begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * ===================================  * HARP  |  Host ATM Research Platform  * ===================================  *  *  * This Host ATM Research Platform ("HARP") file (the "Software") is  * made available by Network Computing Services, Inc. ("NetworkCS")  * "AS IS".  NetworkCS does not provide maintenance, improvements or  * support of any kind.  *  * NETWORKCS MAKES NO WARRANTIES OR REPRESENTATIONS, EXPRESS OR IMPLIED,  * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE, AS TO ANY ELEMENT OF THE  * SOFTWARE OR ANY SUPPORT PROVIDED IN CONNECTION WITH THIS SOFTWARE.  * In no event shall NetworkCS be responsible for any damages, including  * but not limited to consequential damages, arising from or relating to  * any use of the Software or related support.  *  * Copyright 1994-1998 Network Computing Services, Inc.  *  * Copies of this Software may be made, however, the above copyright  * notice must be reproduced on all copies.  *  *	@(#) $FreeBSD$  *  */
end_comment

begin_comment
comment|/*  * ATM Forum UNI Support  * ---------------------  *  * SSCF UNI - SSCF_UNI SAP interface processing  *  */
end_comment

begin_include
include|#
directive|include
file|<netatm/kern_include.h>
end_include

begin_include
include|#
directive|include
file|<netatm/uni/uni.h>
end_include

begin_include
include|#
directive|include
file|<netatm/uni/sscop.h>
end_include

begin_include
include|#
directive|include
file|<netatm/uni/sscf_uni.h>
end_include

begin_include
include|#
directive|include
file|<netatm/uni/sscf_uni_var.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"@(#) $FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Local variables  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sscop_parms
name|sscf_uni_sscop_parms
init|=
block|{
literal|4096
block|,
comment|/* sp_maxinfo */
literal|4096
block|,
comment|/* sp_maxuu */
literal|4
block|,
comment|/* sp_maxcc */
literal|25
block|,
comment|/* sp_maxpd */
literal|1
operator|*
name|ATM_HZ
block|,
comment|/* sp_timecc */
literal|2
operator|*
name|ATM_HZ
block|,
comment|/* sp_timekeep */
literal|7
operator|*
name|ATM_HZ
block|,
comment|/* sp_timeresp */
literal|1
operator|*
name|ATM_HZ
block|,
comment|/* sp_timepoll */
literal|15
operator|*
name|ATM_HZ
block|,
comment|/* sp_timeidle */
literal|80
comment|/* sp_rcvwin */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * SSCF_UNI Lower Stack Command Handler  *   * This function will receive all of the stack commands issued from the   * layer above SSCF UNI (ie. Q.2931).  *  * Arguments:  *	cmd	stack command code  *	tok	session token  *	arg1	command specific argument  *	arg2	command specific argument  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|sscf_uni_lower
parameter_list|(
name|cmd
parameter_list|,
name|tok
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|int
name|cmd
decl_stmt|;
name|void
modifier|*
name|tok
decl_stmt|;
name|int
name|arg1
decl_stmt|;
name|int
name|arg2
decl_stmt|;
block|{
name|struct
name|univcc
modifier|*
name|uvp
init|=
operator|(
expr|struct
name|univcc
operator|*
operator|)
name|tok
decl_stmt|;
name|Atm_connvc
modifier|*
name|cvp
init|=
name|uvp
operator|->
name|uv_connvc
decl_stmt|;
name|enum
name|sscop_vers
name|vers
decl_stmt|;
name|int
name|err
decl_stmt|;
name|ATM_DEBUG5
argument_list|(
literal|"sscf_uni_lower: cmd=0x%x, uvp=%p, ustate=%d, arg1=0x%x, arg2=0x%x\n"
argument_list|,
name|cmd
argument_list|,
name|uvp
argument_list|,
name|uvp
operator|->
name|uv_ustate
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SSCF_UNI_INIT
case|:
comment|/* 		 * Validate state 		 */
if|if
condition|(
name|uvp
operator|->
name|uv_ustate
operator|!=
name|UVU_INST
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sscf_uni_lower: SSCF_INIT in ustate=%d\n"
argument_list|,
name|uvp
operator|->
name|uv_ustate
argument_list|)
expr_stmt|;
name|sscf_uni_abort
argument_list|(
name|uvp
argument_list|,
literal|"sscf_uni: sequence err\n"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * Validate UNI version 		 */
if|if
condition|(
operator|(
expr|enum
name|uni_vers
operator|)
name|arg1
operator|==
name|UNI_VERS_3_0
condition|)
name|vers
operator|=
name|SSCOP_VERS_QSAAL
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
expr|enum
name|uni_vers
operator|)
name|arg1
operator|==
name|UNI_VERS_3_1
condition|)
name|vers
operator|=
name|SSCOP_VERS_Q2110
expr_stmt|;
else|else
block|{
name|sscf_uni_abort
argument_list|(
name|uvp
argument_list|,
literal|"sscf_uni: bad version\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|uvp
operator|->
name|uv_vers
operator|=
operator|(
expr|enum
name|uni_vers
operator|)
name|arg1
expr_stmt|;
comment|/* 		 * Make ourselves ready and pass on the INIT 		 */
name|uvp
operator|->
name|uv_ustate
operator|=
name|UVU_RELEASED
expr_stmt|;
name|uvp
operator|->
name|uv_lstate
operator|=
name|UVL_IDLE
expr_stmt|;
name|STACK_CALL
argument_list|(
name|SSCOP_INIT
argument_list|,
name|uvp
operator|->
name|uv_lower
argument_list|,
name|uvp
operator|->
name|uv_tokl
argument_list|,
name|cvp
argument_list|,
operator|(
name|int
operator|)
name|vers
argument_list|,
operator|(
name|int
operator|)
operator|&
name|sscf_uni_sscop_parms
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* 			 * Should never happen 			 */
name|sscf_uni_abort
argument_list|(
name|uvp
argument_list|,
literal|"sscf_uni: INIT failure\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SSCF_UNI_TERM
case|:
comment|/* 		 * Set termination states 		 */
name|uvp
operator|->
name|uv_ustate
operator|=
name|UVU_TERM
expr_stmt|;
name|uvp
operator|->
name|uv_lstate
operator|=
name|UVL_TERM
expr_stmt|;
comment|/* 		 * Pass the TERM down the stack 		 */
name|STACK_CALL
argument_list|(
name|SSCOP_TERM
argument_list|,
name|uvp
operator|->
name|uv_lower
argument_list|,
name|uvp
operator|->
name|uv_tokl
argument_list|,
name|cvp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* 			 * Should never happen 			 */
name|sscf_uni_abort
argument_list|(
name|uvp
argument_list|,
literal|"sscf_uni: TERM failure\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|atm_free
argument_list|(
operator|(
name|caddr_t
operator|)
name|uvp
argument_list|)
expr_stmt|;
name|sscf_uni_vccnt
operator|--
expr_stmt|;
break|break;
case|case
name|SSCF_UNI_ESTABLISH_REQ
case|:
comment|/* 		 * Validation based on user state 		 */
switch|switch
condition|(
name|uvp
operator|->
name|uv_ustate
condition|)
block|{
case|case
name|UVU_RELEASED
case|:
case|case
name|UVU_PRELEASE
case|:
comment|/* 			 * Establishing a new connection 			 */
name|uvp
operator|->
name|uv_ustate
operator|=
name|UVU_PACTIVE
expr_stmt|;
name|uvp
operator|->
name|uv_lstate
operator|=
name|UVL_OUTCONN
expr_stmt|;
name|STACK_CALL
argument_list|(
name|SSCOP_ESTABLISH_REQ
argument_list|,
name|uvp
operator|->
name|uv_lower
argument_list|,
name|uvp
operator|->
name|uv_tokl
argument_list|,
name|cvp
argument_list|,
name|SSCOP_UU_NULL
argument_list|,
name|SSCOP_BR_YES
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|sscf_uni_abort
argument_list|(
name|uvp
argument_list|,
literal|"sscf_uni: stack memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|UVU_ACTIVE
case|:
comment|/* 			 * Resynchronizing a connection 			 */
name|uvp
operator|->
name|uv_ustate
operator|=
name|UVU_PACTIVE
expr_stmt|;
if|if
condition|(
name|uvp
operator|->
name|uv_vers
operator|==
name|UNI_VERS_3_0
condition|)
block|{
name|uvp
operator|->
name|uv_lstate
operator|=
name|UVL_OUTCONN
expr_stmt|;
name|STACK_CALL
argument_list|(
name|SSCOP_ESTABLISH_REQ
argument_list|,
name|uvp
operator|->
name|uv_lower
argument_list|,
name|uvp
operator|->
name|uv_tokl
argument_list|,
name|cvp
argument_list|,
name|SSCOP_UU_NULL
argument_list|,
name|SSCOP_BR_YES
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uvp
operator|->
name|uv_lstate
operator|=
name|UVL_OUTRESYN
expr_stmt|;
name|STACK_CALL
argument_list|(
name|SSCOP_RESYNC_REQ
argument_list|,
name|uvp
operator|->
name|uv_lower
argument_list|,
name|uvp
operator|->
name|uv_tokl
argument_list|,
name|cvp
argument_list|,
name|SSCOP_UU_NULL
argument_list|,
literal|0
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
block|{
name|sscf_uni_abort
argument_list|(
name|uvp
argument_list|,
literal|"sscf_uni: stack memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|UVU_TERM
case|:
comment|/* Ignore */
break|break;
case|case
name|UVU_INST
case|:
case|case
name|UVU_PACTIVE
case|:
default|default:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sscf_uni_lower: cmd=0x%x, ustate=%d\n"
argument_list|,
name|cmd
argument_list|,
name|uvp
operator|->
name|uv_ustate
argument_list|)
expr_stmt|;
name|sscf_uni_abort
argument_list|(
name|uvp
argument_list|,
literal|"sscf_uni: sequence err\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SSCF_UNI_RELEASE_REQ
case|:
comment|/* 		 * Validate re-establishment parameter 		 */
switch|switch
condition|(
name|arg1
condition|)
block|{
case|case
name|SSCF_UNI_ESTIND_YES
case|:
name|uvp
operator|->
name|uv_flags
operator|&=
operator|~
name|UVF_NOESTIND
expr_stmt|;
break|break;
case|case
name|SSCF_UNI_ESTIND_NO
case|:
name|uvp
operator|->
name|uv_flags
operator||=
name|UVF_NOESTIND
expr_stmt|;
break|break;
default|default:
name|sscf_uni_abort
argument_list|(
name|uvp
argument_list|,
literal|"sscf_uni: bad estind value\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * Validation based on user state 		 */
switch|switch
condition|(
name|uvp
operator|->
name|uv_ustate
condition|)
block|{
case|case
name|UVU_RELEASED
case|:
comment|/* 			 * Releasing a non-existant connection 			 */
name|STACK_CALL
argument_list|(
name|SSCF_UNI_RELEASE_CNF
argument_list|,
name|uvp
operator|->
name|uv_upper
argument_list|,
name|uvp
operator|->
name|uv_toku
argument_list|,
name|cvp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|sscf_uni_abort
argument_list|(
name|uvp
argument_list|,
literal|"sscf_uni: stack memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|UVU_PACTIVE
case|:
case|case
name|UVU_ACTIVE
case|:
comment|/* 			 * Releasing a connection 			 */
name|uvp
operator|->
name|uv_ustate
operator|=
name|UVU_PRELEASE
expr_stmt|;
name|uvp
operator|->
name|uv_lstate
operator|=
name|UVL_OUTDISC
expr_stmt|;
name|STACK_CALL
argument_list|(
name|SSCOP_RELEASE_REQ
argument_list|,
name|uvp
operator|->
name|uv_lower
argument_list|,
name|uvp
operator|->
name|uv_tokl
argument_list|,
name|cvp
argument_list|,
name|SSCOP_UU_NULL
argument_list|,
literal|0
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|sscf_uni_abort
argument_list|(
name|uvp
argument_list|,
literal|"sscf_uni: stack memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|UVU_TERM
case|:
comment|/* Ignore */
break|break;
case|case
name|UVU_INST
case|:
case|case
name|UVU_PRELEASE
case|:
default|default:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sscf_uni_lower: cmd=0x%x, ustate=%d\n"
argument_list|,
name|cmd
argument_list|,
name|uvp
operator|->
name|uv_ustate
argument_list|)
expr_stmt|;
name|sscf_uni_abort
argument_list|(
name|uvp
argument_list|,
literal|"sscf_uni: sequence err\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SSCF_UNI_DATA_REQ
case|:
ifdef|#
directive|ifdef
name|notdef
name|sscf_uni_pdu_print
argument_list|(
name|uvp
argument_list|,
operator|(
name|KBuffer
operator|*
operator|)
name|arg1
argument_list|,
literal|"DATA_REQ"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * Validation based on user state 		 */
switch|switch
condition|(
name|uvp
operator|->
name|uv_ustate
condition|)
block|{
case|case
name|UVU_ACTIVE
case|:
comment|/* 			 * Send assured data on connection 			 */
name|STACK_CALL
argument_list|(
name|SSCOP_DATA_REQ
argument_list|,
name|uvp
operator|->
name|uv_lower
argument_list|,
name|uvp
operator|->
name|uv_tokl
argument_list|,
name|cvp
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|KB_FREEALL
argument_list|(
operator|(
name|KBuffer
operator|*
operator|)
name|arg1
argument_list|)
expr_stmt|;
name|sscf_uni_abort
argument_list|(
name|uvp
argument_list|,
literal|"sscf_uni: stack memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|UVU_RELEASED
case|:
case|case
name|UVU_TERM
case|:
comment|/* 			 * Release supplied buffers and ignore 			 */
name|KB_FREEALL
argument_list|(
operator|(
name|KBuffer
operator|*
operator|)
name|arg1
argument_list|)
expr_stmt|;
break|break;
case|case
name|UVU_INST
case|:
case|case
name|UVU_PACTIVE
case|:
case|case
name|UVU_PRELEASE
case|:
default|default:
name|KB_FREEALL
argument_list|(
operator|(
name|KBuffer
operator|*
operator|)
name|arg1
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sscf_uni_lower: cmd=0x%x, ustate=%d\n"
argument_list|,
name|cmd
argument_list|,
name|uvp
operator|->
name|uv_ustate
argument_list|)
expr_stmt|;
name|sscf_uni_abort
argument_list|(
name|uvp
argument_list|,
literal|"sscf_uni: sequence err\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SSCF_UNI_UNITDATA_REQ
case|:
ifdef|#
directive|ifdef
name|notdef
name|sscf_uni_pdu_print
argument_list|(
name|uvp
argument_list|,
operator|(
name|KBuffer
operator|*
operator|)
name|arg1
argument_list|,
literal|"UNITDATA_REQ"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * Validation based on user state 		 */
switch|switch
condition|(
name|uvp
operator|->
name|uv_ustate
condition|)
block|{
case|case
name|UVU_RELEASED
case|:
case|case
name|UVU_PACTIVE
case|:
case|case
name|UVU_PRELEASE
case|:
case|case
name|UVU_ACTIVE
case|:
comment|/* 			 * Send unassured data on connection 			 */
name|STACK_CALL
argument_list|(
name|SSCOP_UNITDATA_REQ
argument_list|,
name|uvp
operator|->
name|uv_lower
argument_list|,
name|uvp
operator|->
name|uv_tokl
argument_list|,
name|cvp
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|KB_FREEALL
argument_list|(
operator|(
name|KBuffer
operator|*
operator|)
name|arg1
argument_list|)
expr_stmt|;
name|sscf_uni_abort
argument_list|(
name|uvp
argument_list|,
literal|"sscf_uni: stack memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|UVU_TERM
case|:
comment|/* 			 * Release supplied buffers and ignore 			 */
name|KB_FREEALL
argument_list|(
operator|(
name|KBuffer
operator|*
operator|)
name|arg1
argument_list|)
expr_stmt|;
break|break;
case|case
name|UVU_INST
case|:
default|default:
name|KB_FREEALL
argument_list|(
operator|(
name|KBuffer
operator|*
operator|)
name|arg1
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sscf_uni_lower: cmd=0x%x, ustate=%d\n"
argument_list|,
name|cmd
argument_list|,
name|uvp
operator|->
name|uv_ustate
argument_list|)
expr_stmt|;
name|sscf_uni_abort
argument_list|(
name|uvp
argument_list|,
literal|"sscf_uni: sequence err\n"
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sscf_uni_lower: unknown cmd 0x%x, uvp=%p\n"
argument_list|,
name|cmd
argument_list|,
name|uvp
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

end_unit

