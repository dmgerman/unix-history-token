begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * ===================================  * HARP  |  Host ATM Research Platform  * ===================================  *  *  * This Host ATM Research Platform ("HARP") file (the "Software") is  * made available by Network Computing Services, Inc. ("NetworkCS")  * "AS IS".  NetworkCS does not provide maintenance, improvements or  * support of any kind.  *  * NETWORKCS MAKES NO WARRANTIES OR REPRESENTATIONS, EXPRESS OR IMPLIED,  * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE, AS TO ANY ELEMENT OF THE  * SOFTWARE OR ANY SUPPORT PROVIDED IN CONNECTION WITH THIS SOFTWARE.  * In no event shall NetworkCS be responsible for any damages, including  * but not limited to consequential damages, arising from or relating to  * any use of the Software or related support.  *  * Copyright 1994-1998 Network Computing Services, Inc.  *  * Copies of this Software may be made, however, the above copyright  * notice must be reproduced on all copies.  *  *	@(#) $FreeBSD$  *  */
end_comment

begin_comment
comment|/*  * ATM Forum UNI Support  * ---------------------  *  * SSCOP - Subroutines  *  */
end_comment

begin_include
include|#
directive|include
file|<netatm/kern_include.h>
end_include

begin_include
include|#
directive|include
file|<netatm/uni/sscop.h>
end_include

begin_include
include|#
directive|include
file|<netatm/uni/sscop_misc.h>
end_include

begin_include
include|#
directive|include
file|<netatm/uni/sscop_pdu.h>
end_include

begin_include
include|#
directive|include
file|<netatm/uni/sscop_var.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"@(#) $FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Local functions  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sscop_proc_xmit
name|__P
argument_list|(
operator|(
expr|struct
name|sscop
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Get Next Element from STAT PDU  *  * Arguments:  *	m	pointer to current buffer in STAT PDU  *	pelem	pointer to location to store element value  *  * Returns:  *	addr	pointer to updated current buffer in STAT PDU  *  */
end_comment

begin_function
name|KBuffer
modifier|*
name|sscop_stat_getelem
parameter_list|(
name|m
parameter_list|,
name|pelem
parameter_list|)
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|sscop_seq
modifier|*
name|pelem
decl_stmt|;
block|{
name|caddr_t
name|cp
decl_stmt|;
comment|/* 	 * Get to start of element 	 * 	 * Note that we always ensure that the current buffer has 	 * at least one byte of the next element. 	 */
name|KB_DATASTART
argument_list|(
name|m
argument_list|,
name|cp
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
comment|/* 	 * See how much of element is in this buffer 	 */
if|if
condition|(
name|KB_LEN
argument_list|(
name|m
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|sscop_seq
argument_list|)
condition|)
block|{
comment|/* 		 * Get element from this buffer 		 */
if|if
condition|(
operator|(
name|int
operator|)
name|cp
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|sscop_seq
argument_list|)
operator|-
literal|1
operator|)
condition|)
name|KM_COPY
argument_list|(
name|cp
argument_list|,
operator|(
name|caddr_t
operator|)
name|pelem
argument_list|,
sizeof|sizeof
argument_list|(
name|sscop_seq
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|*
name|pelem
operator|=
operator|*
operator|(
name|sscop_seq
operator|*
operator|)
name|cp
expr_stmt|;
comment|/* 		 * Update buffer controls 		 */
name|KB_HEADADJ
argument_list|(
name|m
argument_list|,
operator|-
sizeof|sizeof
argument_list|(
name|sscop_seq
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Get element split between two buffers 		 */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* 		 * Copy what's in this buffer 		 */
name|i
operator|=
name|KB_LEN
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|KM_COPY
argument_list|(
name|cp
argument_list|,
operator|(
name|caddr_t
operator|)
name|pelem
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|KB_LEN
argument_list|(
name|m
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Now get to next buffer 		 */
while|while
condition|(
name|m
operator|&&
operator|(
name|KB_LEN
argument_list|(
name|m
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|m
operator|=
name|KB_NEXT
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* 		 * And copy remainder of element 		 */
name|j
operator|=
sizeof|sizeof
argument_list|(
name|sscop_seq
argument_list|)
operator|-
name|i
expr_stmt|;
name|KB_DATASTART
argument_list|(
name|m
argument_list|,
name|cp
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|KM_COPY
argument_list|(
name|cp
argument_list|,
operator|(
name|caddr_t
operator|)
name|pelem
operator|+
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
comment|/* 		 * Update buffer controls 		 */
name|KB_HEADADJ
argument_list|(
name|m
argument_list|,
operator|-
name|j
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Put element (sequence number) into host order 	 */
name|NTOHL
argument_list|(
operator|*
name|pelem
argument_list|)
expr_stmt|;
comment|/* 	 * Get pointers set for next call 	 */
while|while
condition|(
name|m
operator|&&
operator|(
name|KB_LEN
argument_list|(
name|m
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|m
operator|=
name|KB_NEXT
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Locate SD PDU on Pending Ack Queue  *  * Arguments:  *	sop	pointer to sscop connection block  *	seq	sequence number of PDU to locate  *  * Returns:  *	addr	pointer to located PDU header  *	0	SD PDU sequence number not found  *  */
end_comment

begin_function
name|struct
name|pdu_hdr
modifier|*
name|sscop_pack_locate
parameter_list|(
name|sop
parameter_list|,
name|seq
parameter_list|)
name|struct
name|sscop
modifier|*
name|sop
decl_stmt|;
name|sscop_seq
name|seq
decl_stmt|;
block|{
name|struct
name|pdu_hdr
modifier|*
name|php
decl_stmt|;
comment|/* 	 * Loop thru queue until we either find the PDU or the queue's 	 * sequence numbers are greater than the PDU's sequence number, 	 * indicating that the PDU is not on the queue. 	 */
for|for
control|(
name|php
operator|=
name|sop
operator|->
name|so_pack_hd
init|;
name|php
condition|;
name|php
operator|=
name|php
operator|->
name|ph_pack_lk
control|)
block|{
if|if
condition|(
name|php
operator|->
name|ph_ns
operator|==
name|seq
condition|)
break|break;
if|if
condition|(
name|SEQ_GT
argument_list|(
name|php
operator|->
name|ph_ns
argument_list|,
name|seq
argument_list|,
name|sop
operator|->
name|so_ack
argument_list|)
condition|)
block|{
name|php
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|php
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free Acknowledged SD PDU  *  * Arguments:  *	sop	pointer to sscop connection block  *	seq	sequence number of PDU to free  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|sscop_pack_free
parameter_list|(
name|sop
parameter_list|,
name|seq
parameter_list|)
name|struct
name|sscop
modifier|*
name|sop
decl_stmt|;
name|sscop_seq
name|seq
decl_stmt|;
block|{
name|struct
name|pdu_hdr
modifier|*
name|php
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
comment|/* 	 * Unlink PDU from pending ack queue 	 * 	 * First, check for an empty queue 	 */
name|php
operator|=
name|sop
operator|->
name|so_pack_hd
expr_stmt|;
if|if
condition|(
name|php
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * Now check for PDU at head of queue 	 */
if|if
condition|(
name|php
operator|->
name|ph_ns
operator|==
name|seq
condition|)
block|{
if|if
condition|(
operator|(
name|sop
operator|->
name|so_pack_hd
operator|=
name|php
operator|->
name|ph_pack_lk
operator|)
operator|==
name|NULL
condition|)
name|sop
operator|->
name|so_pack_tl
operator|=
name|NULL
expr_stmt|;
goto|goto
name|found
goto|;
block|}
comment|/* 	 * Otherwise, loop thru queue until we either find the PDU or 	 * the queue's sequence numbers are greater than the PDU's 	 * sequence number, indicating that the PDU is not on the queue. 	 */
name|prev
operator|=
name|php
expr_stmt|;
name|php
operator|=
name|php
operator|->
name|ph_pack_lk
expr_stmt|;
while|while
condition|(
name|php
condition|)
block|{
if|if
condition|(
name|php
operator|->
name|ph_ns
operator|==
name|seq
condition|)
block|{
if|if
condition|(
operator|(
name|prev
operator|->
name|ph_pack_lk
operator|=
name|php
operator|->
name|ph_pack_lk
operator|)
operator|==
name|NULL
condition|)
name|sop
operator|->
name|so_pack_tl
operator|=
name|prev
expr_stmt|;
goto|goto
name|found
goto|;
block|}
if|if
condition|(
name|SEQ_GT
argument_list|(
name|php
operator|->
name|ph_ns
argument_list|,
name|seq
argument_list|,
name|sop
operator|->
name|so_ack
argument_list|)
condition|)
return|return;
name|prev
operator|=
name|php
expr_stmt|;
name|php
operator|=
name|php
operator|->
name|ph_pack_lk
expr_stmt|;
block|}
return|return;
name|found
label|:
comment|/* 	 * We've got the ack'ed PDU - unlink it from retransmit queue 	 */
name|sscop_rexmit_unlink
argument_list|(
name|sop
argument_list|,
name|php
argument_list|)
expr_stmt|;
comment|/* 	 * Free PDU buffers 	 */
name|KB_FREEALL
argument_list|(
name|php
operator|->
name|ph_buf
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Insert SD PDU into Retransmit Queue  *  * Arguments:  *	sop	pointer to sscop connection block  *	php	pointer to SD PDU header  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|sscop_rexmit_insert
parameter_list|(
name|sop
parameter_list|,
name|php
parameter_list|)
name|struct
name|sscop
modifier|*
name|sop
decl_stmt|;
name|struct
name|pdu_hdr
modifier|*
name|php
decl_stmt|;
block|{
name|struct
name|pdu_hdr
modifier|*
name|curr
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|sscop_seq
name|seq
init|=
name|php
operator|->
name|ph_ns
decl_stmt|;
comment|/* 	 * Check for an empty queue 	 */
if|if
condition|(
operator|(
name|curr
operator|=
name|sop
operator|->
name|so_rexmit_hd
operator|)
operator|==
name|NULL
condition|)
block|{
name|php
operator|->
name|ph_rexmit_lk
operator|=
name|NULL
expr_stmt|;
name|sop
operator|->
name|so_rexmit_hd
operator|=
name|php
expr_stmt|;
name|sop
operator|->
name|so_rexmit_tl
operator|=
name|php
expr_stmt|;
return|return;
block|}
comment|/* 	 * Now see if PDU belongs at head of queue 	 */
if|if
condition|(
name|SEQ_LT
argument_list|(
name|seq
argument_list|,
name|curr
operator|->
name|ph_ns
argument_list|,
name|sop
operator|->
name|so_ack
argument_list|)
condition|)
block|{
name|php
operator|->
name|ph_rexmit_lk
operator|=
name|curr
expr_stmt|;
name|sop
operator|->
name|so_rexmit_hd
operator|=
name|php
expr_stmt|;
return|return;
block|}
comment|/* 	 * Otherwise, loop thru the queue until we find the 	 * proper insertion point for the PDU 	 */
while|while
condition|(
operator|(
name|next
operator|=
name|curr
operator|->
name|ph_rexmit_lk
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|SEQ_LT
argument_list|(
name|seq
argument_list|,
name|next
operator|->
name|ph_ns
argument_list|,
name|sop
operator|->
name|so_ack
argument_list|)
condition|)
block|{
name|php
operator|->
name|ph_rexmit_lk
operator|=
name|next
expr_stmt|;
name|curr
operator|->
name|ph_rexmit_lk
operator|=
name|php
expr_stmt|;
return|return;
block|}
name|curr
operator|=
name|next
expr_stmt|;
block|}
comment|/* 	 * Insert PDU at end of queue 	 */
name|php
operator|->
name|ph_rexmit_lk
operator|=
name|NULL
expr_stmt|;
name|curr
operator|->
name|ph_rexmit_lk
operator|=
name|php
expr_stmt|;
name|sop
operator|->
name|so_rexmit_tl
operator|=
name|php
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Unlink SD PDU from Retransmit Queue  *  * Arguments:  *	sop	pointer to sscop connection block  *	php	pointer to PDU header to unlink  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|sscop_rexmit_unlink
parameter_list|(
name|sop
parameter_list|,
name|php
parameter_list|)
name|struct
name|sscop
modifier|*
name|sop
decl_stmt|;
name|struct
name|pdu_hdr
modifier|*
name|php
decl_stmt|;
block|{
name|struct
name|pdu_hdr
modifier|*
name|curr
decl_stmt|;
comment|/* 	 * See if PDU is on retransmit queue 	 */
if|if
condition|(
operator|(
name|php
operator|->
name|ph_rexmit_lk
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|sop
operator|->
name|so_rexmit_tl
operator|!=
name|php
operator|)
condition|)
return|return;
comment|/* 	 * It's here somewhere, so first check for the PDU at the 	 * head of the queue 	 */
if|if
condition|(
name|php
operator|==
name|sop
operator|->
name|so_rexmit_hd
condition|)
block|{
if|if
condition|(
operator|(
name|sop
operator|->
name|so_rexmit_hd
operator|=
name|php
operator|->
name|ph_rexmit_lk
operator|)
operator|==
name|NULL
condition|)
name|sop
operator|->
name|so_rexmit_tl
operator|=
name|NULL
expr_stmt|;
name|php
operator|->
name|ph_rexmit_lk
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
comment|/* 	 * Otherwise, loop thru the queue until we find the PDU 	 */
for|for
control|(
name|curr
operator|=
name|sop
operator|->
name|so_rexmit_hd
init|;
name|curr
condition|;
name|curr
operator|=
name|curr
operator|->
name|ph_rexmit_lk
control|)
block|{
if|if
condition|(
name|curr
operator|->
name|ph_rexmit_lk
operator|==
name|php
condition|)
break|break;
block|}
if|if
condition|(
name|curr
condition|)
block|{
if|if
condition|(
operator|(
name|curr
operator|->
name|ph_rexmit_lk
operator|=
name|php
operator|->
name|ph_rexmit_lk
operator|)
operator|==
name|NULL
condition|)
name|sop
operator|->
name|so_rexmit_tl
operator|=
name|curr
expr_stmt|;
block|}
else|else
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sscop_rexmit_unlink: Not found - sop=%p, php=%p\n"
argument_list|,
name|sop
argument_list|,
name|php
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|panic
argument_list|(
literal|"sscop_rexmit_unlink: Not found"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|php
operator|->
name|ph_rexmit_lk
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Drain Transmission Queues  *  * Arguments:  *	sop	pointer to sscop connection block  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|sscop_xmit_drain
parameter_list|(
name|sop
parameter_list|)
name|struct
name|sscop
modifier|*
name|sop
decl_stmt|;
block|{
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|struct
name|pdu_hdr
modifier|*
name|php
decl_stmt|;
comment|/* 	 * Free transmission queue buffers 	 */
while|while
condition|(
operator|(
name|m
operator|=
name|sop
operator|->
name|so_xmit_hd
operator|)
operator|!=
name|NULL
condition|)
block|{
name|sop
operator|->
name|so_xmit_hd
operator|=
name|KB_QNEXT
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|sop
operator|->
name|so_xmit_tl
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Free retransmission queue 	 * 	 * All retranmission buffers are also on the pending ack 	 * queue (but not the converse), so we just clear the queue 	 * pointers here and do all the real work below. 	 */
name|sop
operator|->
name|so_rexmit_hd
operator|=
name|NULL
expr_stmt|;
name|sop
operator|->
name|so_rexmit_tl
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Free pending ack queue buffers 	 */
while|while
condition|(
operator|(
name|php
operator|=
name|sop
operator|->
name|so_pack_hd
operator|)
operator|!=
name|NULL
condition|)
block|{
name|sop
operator|->
name|so_pack_hd
operator|=
name|php
operator|->
name|ph_pack_lk
expr_stmt|;
name|KB_FREEALL
argument_list|(
name|php
operator|->
name|ph_buf
argument_list|)
expr_stmt|;
block|}
name|sop
operator|->
name|so_pack_tl
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Clear service required flag 	 */
name|sop
operator|->
name|so_flags
operator|&=
operator|~
name|SOF_XMITSRVC
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Insert SD PDU into Receive Queue  *  * Arguments:  *	sop	pointer to sscop connection block  *	php	pointer to SD PDU header  *  * Returns:  *	0	PDU successfully inserted into queue  *	1	duplicate sequence number PDU on queue, PDU not inserted  *  */
end_comment

begin_function
name|int
name|sscop_recv_insert
parameter_list|(
name|sop
parameter_list|,
name|php
parameter_list|)
name|struct
name|sscop
modifier|*
name|sop
decl_stmt|;
name|struct
name|pdu_hdr
modifier|*
name|php
decl_stmt|;
block|{
name|struct
name|pdu_hdr
modifier|*
name|curr
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|sscop_seq
name|seq
init|=
name|php
operator|->
name|ph_ns
decl_stmt|;
comment|/* 	 * Check for an empty queue 	 */
if|if
condition|(
operator|(
name|curr
operator|=
name|sop
operator|->
name|so_recv_hd
operator|)
operator|==
name|NULL
condition|)
block|{
name|php
operator|->
name|ph_recv_lk
operator|=
name|NULL
expr_stmt|;
name|sop
operator|->
name|so_recv_hd
operator|=
name|php
expr_stmt|;
name|sop
operator|->
name|so_recv_tl
operator|=
name|php
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Now see if PDU belongs at head of queue 	 */
if|if
condition|(
name|SEQ_LT
argument_list|(
name|seq
argument_list|,
name|curr
operator|->
name|ph_ns
argument_list|,
name|sop
operator|->
name|so_rcvnext
argument_list|)
condition|)
block|{
name|php
operator|->
name|ph_recv_lk
operator|=
name|curr
expr_stmt|;
name|sop
operator|->
name|so_recv_hd
operator|=
name|php
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Otherwise, loop thru the queue until we find the 	 * proper insertion point for the PDU.  We also check 	 * to make sure there isn't a PDU already on the queue 	 * with a matching sequence number. 	 */
while|while
condition|(
operator|(
name|next
operator|=
name|curr
operator|->
name|ph_recv_lk
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|SEQ_LT
argument_list|(
name|seq
argument_list|,
name|next
operator|->
name|ph_ns
argument_list|,
name|sop
operator|->
name|so_rcvnext
argument_list|)
condition|)
block|{
if|if
condition|(
name|seq
operator|==
name|curr
operator|->
name|ph_ns
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|php
operator|->
name|ph_recv_lk
operator|=
name|next
expr_stmt|;
name|curr
operator|->
name|ph_recv_lk
operator|=
name|php
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|curr
operator|=
name|next
expr_stmt|;
block|}
comment|/* 	 * Insert PDU at end of queue 	 */
if|if
condition|(
name|seq
operator|==
name|curr
operator|->
name|ph_ns
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|php
operator|->
name|ph_recv_lk
operator|=
name|NULL
expr_stmt|;
name|curr
operator|->
name|ph_recv_lk
operator|=
name|php
expr_stmt|;
name|sop
operator|->
name|so_recv_tl
operator|=
name|php
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Drain Receiver Queues  *  * Arguments:  *	sop	pointer to sscop connection block  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|sscop_rcvr_drain
parameter_list|(
name|sop
parameter_list|)
name|struct
name|sscop
modifier|*
name|sop
decl_stmt|;
block|{
name|struct
name|pdu_hdr
modifier|*
name|php
decl_stmt|;
comment|/* 	 * Free receive queue buffers 	 */
while|while
condition|(
operator|(
name|php
operator|=
name|sop
operator|->
name|so_recv_hd
operator|)
operator|!=
name|NULL
condition|)
block|{
name|sop
operator|->
name|so_recv_hd
operator|=
name|php
operator|->
name|ph_recv_lk
expr_stmt|;
name|KB_FREEALL
argument_list|(
name|php
operator|->
name|ph_buf
argument_list|)
expr_stmt|;
block|}
name|sop
operator|->
name|so_recv_tl
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Service connection's transmit queues  *  * Arguments:  *	sop	pointer to sscop connection block  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|sscop_service_xmit
parameter_list|(
name|sop
parameter_list|)
name|struct
name|sscop
modifier|*
name|sop
decl_stmt|;
block|{
name|KBuffer
modifier|*
name|m
decl_stmt|,
modifier|*
name|n
decl_stmt|;
name|struct
name|pdu_hdr
modifier|*
name|php
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|,
name|pollsent
init|=
literal|0
decl_stmt|;
comment|/* 	 * Initially assume we need service 	 */
name|sop
operator|->
name|so_flags
operator||=
name|SOF_XMITSRVC
expr_stmt|;
comment|/* 	 * Loop until done with queues 	 * 	 * (Congestion control will be added later) 	 */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|php
operator|=
name|sop
operator|->
name|so_rexmit_hd
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * Send SD PDU from retransmit queue 			 * 			 * First, get a copy of the PDU to send 			 */
name|m
operator|=
name|php
operator|->
name|ph_buf
expr_stmt|;
if|if
condition|(
name|KB_LEN
argument_list|(
name|m
argument_list|)
operator|==
literal|0
condition|)
name|m
operator|=
name|KB_NEXT
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|KB_COPY
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|KB_COPYALL
argument_list|,
name|n
argument_list|,
name|KB_F_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* 			 * Now pass it down the stack 			 */
name|STACK_CALL
argument_list|(
name|CPCS_UNITDATA_INV
argument_list|,
name|sop
operator|->
name|so_lower
argument_list|,
name|sop
operator|->
name|so_tokl
argument_list|,
name|sop
operator|->
name|so_connvc
argument_list|,
operator|(
name|int
operator|)
name|n
argument_list|,
literal|0
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|KB_FREEALL
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 			 * PDU is on its way, so remove it from 			 * the retransmit queue 			 */
if|if
condition|(
name|sop
operator|->
name|so_rexmit_tl
operator|==
name|php
condition|)
block|{
name|sop
operator|->
name|so_rexmit_hd
operator|=
name|NULL
expr_stmt|;
name|sop
operator|->
name|so_rexmit_tl
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|sop
operator|->
name|so_rexmit_hd
operator|=
name|php
operator|->
name|ph_rexmit_lk
expr_stmt|;
block|}
name|php
operator|->
name|ph_rexmit_lk
operator|=
name|NULL
expr_stmt|;
comment|/* 			 * Update PDU's poll sequence 			 */
name|php
operator|->
name|ph_nps
operator|=
name|sop
operator|->
name|so_pollsend
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sop
operator|->
name|so_xmit_hd
condition|)
block|{
comment|/* 			 * Newly arrived data waiting to be sent. 			 * See if transmit window allows us to send it. 			 */
if|if
condition|(
name|SEQ_LT
argument_list|(
name|sop
operator|->
name|so_send
argument_list|,
name|sop
operator|->
name|so_sendmax
argument_list|,
name|sop
operator|->
name|so_ack
argument_list|)
condition|)
block|{
comment|/* 				 * OK, send SD PDU from transmission queue 				 */
name|err
operator|=
name|sscop_proc_xmit
argument_list|(
name|sop
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
block|}
else|else
block|{
comment|/* 				 * Can't send now, so leave idle phase. 				 */
if|if
condition|(
name|sop
operator|->
name|so_timer
index|[
name|SSCOP_T_IDLE
index|]
operator|!=
literal|0
condition|)
block|{
name|sop
operator|->
name|so_timer
index|[
name|SSCOP_T_IDLE
index|]
operator|=
literal|0
expr_stmt|;
name|sop
operator|->
name|so_timer
index|[
name|SSCOP_T_NORESP
index|]
operator|=
name|sop
operator|->
name|so_parm
operator|.
name|sp_timeresp
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
break|break;
block|}
block|}
else|else
block|{
comment|/* 			 * We're finished, so clear service required flag 			 */
name|sop
operator|->
name|so_flags
operator|&=
operator|~
name|SOF_XMITSRVC
expr_stmt|;
break|break;
block|}
comment|/* 		 * We've sent another SD PDU 		 */
name|sop
operator|->
name|so_polldata
operator|++
expr_stmt|;
comment|/* 		 * Transition into active (polling) phase 		 */
if|if
condition|(
name|sop
operator|->
name|so_timer
index|[
name|SSCOP_T_POLL
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|sop
operator|->
name|so_flags
operator|&
name|SOF_KEEPALIVE
condition|)
block|{
comment|/* 				 * Leaving transient phase 				 */
name|sop
operator|->
name|so_flags
operator|&=
operator|~
name|SOF_KEEPALIVE
expr_stmt|;
name|sop
operator|->
name|so_timer
index|[
name|SSCOP_T_POLL
index|]
operator|=
name|sop
operator|->
name|so_parm
operator|.
name|sp_timepoll
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * Leaving idle phase 			 */
name|sop
operator|->
name|so_timer
index|[
name|SSCOP_T_IDLE
index|]
operator|=
literal|0
expr_stmt|;
name|sop
operator|->
name|so_timer
index|[
name|SSCOP_T_NORESP
index|]
operator|=
name|sop
operator|->
name|so_parm
operator|.
name|sp_timeresp
expr_stmt|;
name|sop
operator|->
name|so_timer
index|[
name|SSCOP_T_POLL
index|]
operator|=
name|sop
operator|->
name|so_parm
operator|.
name|sp_timepoll
expr_stmt|;
block|}
comment|/* 		 * Let's see if we need to send a POLL yet 		 */
if|if
condition|(
name|sop
operator|->
name|so_polldata
operator|<
name|sop
operator|->
name|so_parm
operator|.
name|sp_maxpd
condition|)
continue|continue;
comment|/* 		 * Yup, send another poll out 		 */
name|SEQ_INCR
argument_list|(
name|sop
operator|->
name|so_pollsend
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sscop_send_poll
argument_list|(
name|sop
argument_list|)
expr_stmt|;
name|pollsent
operator|++
expr_stmt|;
comment|/* 		 * Reset data counter for this poll cycle 		 */
name|sop
operator|->
name|so_polldata
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Restart polling timer in active phase 		 */
name|sop
operator|->
name|so_timer
index|[
name|SSCOP_T_POLL
index|]
operator|=
name|sop
operator|->
name|so_parm
operator|.
name|sp_timepoll
expr_stmt|;
block|}
comment|/* 	 * If we need/want to send a poll, but haven't sent any yet 	 * on this servicing, send one now 	 */
if|if
condition|(
name|err
operator|&&
operator|(
name|pollsent
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * Send poll 		 */
name|SEQ_INCR
argument_list|(
name|sop
operator|->
name|so_pollsend
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sscop_send_poll
argument_list|(
name|sop
argument_list|)
expr_stmt|;
comment|/* 		 * Reset data counter for this poll cycle 		 */
name|sop
operator|->
name|so_polldata
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Restart polling timer in active phase 		 */
name|sop
operator|->
name|so_timer
index|[
name|SSCOP_T_POLL
index|]
operator|=
name|sop
operator|->
name|so_parm
operator|.
name|sp_timepoll
expr_stmt|;
name|sop
operator|->
name|so_flags
operator|&=
operator|~
name|SOF_KEEPALIVE
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * Process Transmission Queue PDU  *  * For the first entry on the transmission queue: add a PDU header and  * trailer, send a copy of the PDU down the stack and move the PDU from  * the transmission queue to the pending ack queue.  *  * Arguments:  *	sop	pointer to sscop connection block  *  * Returns:  *	0	head of transmission queue successfully processed  *	else	processing error, tranmission queue unchanged  *  */
end_comment

begin_function
specifier|static
name|int
name|sscop_proc_xmit
parameter_list|(
name|sop
parameter_list|)
name|struct
name|sscop
modifier|*
name|sop
decl_stmt|;
block|{
name|KBuffer
modifier|*
name|m
decl_stmt|,
modifier|*
name|ml
decl_stmt|,
modifier|*
name|n
decl_stmt|;
name|struct
name|pdu_hdr
modifier|*
name|php
decl_stmt|;
name|sscop_seq
name|seq
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|,
name|err
decl_stmt|;
name|int
name|pad
decl_stmt|,
name|trlen
decl_stmt|,
name|space
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|;
comment|/* 	 * Get first buffer chain on queue 	 */
if|if
condition|(
operator|(
name|m
operator|=
name|sop
operator|->
name|so_xmit_hd
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Count data and get to last buffer in chain 	 */
for|for
control|(
name|ml
operator|=
name|m
init|;
condition|;
name|ml
operator|=
name|KB_NEXT
argument_list|(
name|ml
argument_list|)
control|)
block|{
name|len
operator|+=
name|KB_LEN
argument_list|(
name|ml
argument_list|)
expr_stmt|;
if|if
condition|(
name|KB_NEXT
argument_list|(
name|ml
argument_list|)
operator|==
name|NULL
condition|)
break|break;
block|}
comment|/* 	 * Verify data length 	 */
if|if
condition|(
name|len
operator|>
name|sop
operator|->
name|so_parm
operator|.
name|sp_maxinfo
condition|)
block|{
name|sscop_abort
argument_list|(
name|sop
argument_list|,
literal|"sscop: maximum data size exceeded\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Get space for PDU header 	 */
name|KB_HEADROOM
argument_list|(
name|m
argument_list|,
name|space
argument_list|)
expr_stmt|;
if|if
condition|(
name|space
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|pdu_hdr
argument_list|)
condition|)
block|{
comment|/* 		 * Allocate& link buffer for header 		 */
name|KB_ALLOC
argument_list|(
name|n
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pdu_hdr
argument_list|)
argument_list|,
name|KB_F_NOWAIT
argument_list|,
name|KB_T_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|KB_LEN
argument_list|(
name|n
argument_list|)
operator|=
literal|0
expr_stmt|;
name|KB_HEADSET
argument_list|(
name|n
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pdu_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|KB_LINKHEAD
argument_list|(
name|n
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|KB_QNEXT
argument_list|(
name|n
argument_list|)
operator|=
name|KB_QNEXT
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|KB_QNEXT
argument_list|(
name|m
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|sop
operator|->
name|so_xmit_hd
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|sop
operator|->
name|so_xmit_tl
operator|==
name|m
condition|)
name|sop
operator|->
name|so_xmit_tl
operator|=
name|n
expr_stmt|;
name|m
operator|=
name|n
expr_stmt|;
block|}
comment|/* 	 * Figure out how much padding we'll need 	 */
name|pad
operator|=
operator|(
operator|(
name|len
operator|+
operator|(
name|PDU_PAD_ALIGN
operator|-
literal|1
operator|)
operator|)
operator|&
operator|~
operator|(
name|PDU_PAD_ALIGN
operator|-
literal|1
operator|)
operator|)
operator|-
name|len
expr_stmt|;
name|trlen
operator|=
name|pad
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sd_pdu
argument_list|)
expr_stmt|;
comment|/* 	 * Now get space for PDU trailer and padding 	 */
name|KB_TAILROOM
argument_list|(
name|ml
argument_list|,
name|space
argument_list|)
expr_stmt|;
if|if
condition|(
name|space
operator|<
name|trlen
condition|)
block|{
comment|/* 		 * Allocate& link buffer for pad and trailer 		 */
name|KB_ALLOC
argument_list|(
name|n
argument_list|,
name|trlen
argument_list|,
name|KB_F_NOWAIT
argument_list|,
name|KB_T_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|KB_LEN
argument_list|(
name|n
argument_list|)
operator|=
literal|0
expr_stmt|;
name|KB_LINK
argument_list|(
name|n
argument_list|,
name|ml
argument_list|)
expr_stmt|;
name|ml
operator|=
name|n
expr_stmt|;
block|}
comment|/* 	 * Build the PDU trailer 	 * 	 * Since we can't be sure of alignment in the buffers, we 	 * have to move this a byte at a time and we have to be 	 * careful with host byte order issues. 	 */
name|KB_DATASTART
argument_list|(
name|ml
argument_list|,
name|cp
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|KB_LEN
argument_list|(
name|ml
argument_list|)
operator|+
name|pad
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
operator|(
name|pad
operator|<<
name|PT_PAD_SHIFT
operator|)
operator||
name|PT_SD
expr_stmt|;
name|seq
operator|=
name|sop
operator|->
name|so_send
expr_stmt|;
operator|*
operator|(
name|cp
operator|+
literal|2
operator|)
operator|=
call|(
name|u_char
call|)
argument_list|(
name|seq
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|seq
operator|>>=
literal|8
expr_stmt|;
operator|*
operator|(
name|cp
operator|+
literal|1
operator|)
operator|=
call|(
name|u_char
call|)
argument_list|(
name|seq
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|seq
operator|>>=
literal|8
expr_stmt|;
operator|*
operator|(
name|cp
operator|)
operator|=
call|(
name|u_char
call|)
argument_list|(
name|seq
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|KB_LEN
argument_list|(
name|ml
argument_list|)
operator|+=
name|trlen
expr_stmt|;
comment|/* 	 * Get a copy of the SD PDU to send 	 */
if|if
condition|(
name|KB_LEN
argument_list|(
name|m
argument_list|)
operator|==
literal|0
condition|)
name|n
operator|=
name|KB_NEXT
argument_list|(
name|m
argument_list|)
expr_stmt|;
else|else
name|n
operator|=
name|m
expr_stmt|;
name|KB_COPY
argument_list|(
name|n
argument_list|,
literal|0
argument_list|,
name|KB_COPYALL
argument_list|,
name|n
argument_list|,
name|KB_F_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|KB_LEN
argument_list|(
name|ml
argument_list|)
operator|-=
name|trlen
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Now pass copy down the stack 	 */
name|STACK_CALL
argument_list|(
name|CPCS_UNITDATA_INV
argument_list|,
name|sop
operator|->
name|so_lower
argument_list|,
name|sop
operator|->
name|so_tokl
argument_list|,
name|sop
operator|->
name|so_connvc
argument_list|,
operator|(
name|int
operator|)
name|n
argument_list|,
literal|0
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|KB_FREEALL
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|KB_LEN
argument_list|(
name|ml
argument_list|)
operator|-=
name|trlen
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * PDU is on its way, so remove buffer from 	 * the transmission queue 	 */
if|if
condition|(
name|sop
operator|->
name|so_xmit_tl
operator|==
name|m
condition|)
block|{
name|sop
operator|->
name|so_xmit_hd
operator|=
name|NULL
expr_stmt|;
name|sop
operator|->
name|so_xmit_tl
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|sop
operator|->
name|so_xmit_hd
operator|=
name|KB_QNEXT
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|KB_QNEXT
argument_list|(
name|m
argument_list|)
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Build PDU header 	 * 	 * We can at least assume/require that the start of 	 * the user data is aligned.  Also note that we don't 	 * include this header in the buffer len/offset fields. 	 */
name|KB_DATASTART
argument_list|(
name|m
argument_list|,
name|php
argument_list|,
expr|struct
name|pdu_hdr
operator|*
argument_list|)
expr_stmt|;
name|php
operator|--
expr_stmt|;
name|php
operator|->
name|ph_ns
operator|=
name|sop
operator|->
name|so_send
expr_stmt|;
name|php
operator|->
name|ph_nps
operator|=
name|sop
operator|->
name|so_pollsend
expr_stmt|;
name|php
operator|->
name|ph_buf
operator|=
name|m
expr_stmt|;
name|php
operator|->
name|ph_rexmit_lk
operator|=
name|NULL
expr_stmt|;
name|php
operator|->
name|ph_pack_lk
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Put PDU onto the pending ack queue 	 */
if|if
condition|(
name|sop
operator|->
name|so_pack_hd
operator|==
name|NULL
condition|)
name|sop
operator|->
name|so_pack_hd
operator|=
name|php
expr_stmt|;
else|else
name|sop
operator|->
name|so_pack_tl
operator|->
name|ph_pack_lk
operator|=
name|php
expr_stmt|;
name|sop
operator|->
name|so_pack_tl
operator|=
name|php
expr_stmt|;
comment|/* 	 * Finally, bump send sequence number 	 */
name|SEQ_INCR
argument_list|(
name|sop
operator|->
name|so_send
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Detect Retransmitted PDUs  *  * Arguments:  *	sop	pointer to sscop connection block  *	nsq	connection sequence value (N(SQ)) from received PDU  *  * Returns:  *	0	received PDU was NOT retransmitted  *	1	received PDU was retransmitted  *  */
end_comment

begin_function
name|int
name|sscop_is_rexmit
parameter_list|(
name|sop
parameter_list|,
name|nsq
parameter_list|)
name|struct
name|sscop
modifier|*
name|sop
decl_stmt|;
name|u_char
name|nsq
decl_stmt|;
block|{
comment|/* 	 * For Q.SAAL1, N(SQ) doesn't exist 	 */
if|if
condition|(
name|sop
operator|->
name|so_vers
operator|==
name|SSCOP_VERS_QSAAL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * If we've already received the N(SQ) value, 	 * then this PDU has been retransmitted 	 */
if|if
condition|(
name|nsq
operator|==
name|sop
operator|->
name|so_rcvconn
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * New PDU, save its N(SQ) 	 */
name|sop
operator|->
name|so_rcvconn
operator|=
name|nsq
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Start connection poll timer  *  * Arguments:  *	sop	pointer to sscop connection block  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|sscop_set_poll
parameter_list|(
name|sop
parameter_list|)
name|struct
name|sscop
modifier|*
name|sop
decl_stmt|;
block|{
comment|/* 	 * Decide which polling timer value to set 	 */
if|if
condition|(
operator|(
name|sop
operator|->
name|so_xmit_hd
operator|!=
name|NULL
operator|)
operator|||
name|SEQ_NEQ
argument_list|(
name|sop
operator|->
name|so_send
argument_list|,
name|sop
operator|->
name|so_ack
argument_list|)
condition|)
block|{
comment|/* 		 * Data outstanding, poll frequently 		 */
name|sop
operator|->
name|so_timer
index|[
name|SSCOP_T_POLL
index|]
operator|=
name|sop
operator|->
name|so_parm
operator|.
name|sp_timepoll
expr_stmt|;
name|sop
operator|->
name|so_flags
operator|&=
operator|~
name|SOF_KEEPALIVE
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * No data outstanding, just poll occassionally 		 */
name|sop
operator|->
name|so_timer
index|[
name|SSCOP_T_POLL
index|]
operator|=
name|sop
operator|->
name|so_parm
operator|.
name|sp_timekeep
expr_stmt|;
name|sop
operator|->
name|so_flags
operator||=
name|SOF_KEEPALIVE
expr_stmt|;
block|}
return|return;
block|}
end_function

end_unit

