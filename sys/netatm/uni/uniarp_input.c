begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ===================================  * HARP  |  Host ATM Research Platform  * ===================================  *  *  * This Host ATM Research Platform ("HARP") file (the "Software") is  * made available by Network Computing Services, Inc. ("NetworkCS")  * "AS IS".  NetworkCS does not provide maintenance, improvements or  * support of any kind.  *  * NETWORKCS MAKES NO WARRANTIES OR REPRESENTATIONS, EXPRESS OR IMPLIED,  * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE, AS TO ANY ELEMENT OF THE  * SOFTWARE OR ANY SUPPORT PROVIDED IN CONNECTION WITH THIS SOFTWARE.  * In no event shall NetworkCS be responsible for any damages, including  * but not limited to consequential damages, arising from or relating to  * any use of the Software or related support.  *  * Copyright 1994-1998 Network Computing Services, Inc.  *  * Copies of this Software may be made, however, the above copyright  * notice must be reproduced on all copies.  */
end_comment

begin_comment
comment|/*  * ATM Forum UNI Support  * ---------------------  *  * UNI ATMARP support (RFC1577) - Input packet processing  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<netatm/port.h>
end_include

begin_include
include|#
directive|include
file|<netatm/queue.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sys.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sap.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_cm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_if.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_vc.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sigmgr.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_stack.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_var.h>
end_include

begin_include
include|#
directive|include
file|<netatm/ipatm/ipatm_var.h>
end_include

begin_include
include|#
directive|include
file|<netatm/ipatm/ipatm_serv.h>
end_include

begin_include
include|#
directive|include
file|<netatm/uni/uniip_var.h>
end_include

begin_comment
comment|/*  * Local functions  */
end_comment

begin_function_decl
specifier|static
name|void
name|proc_arp_req
parameter_list|(
name|struct
name|ipvcc
modifier|*
parameter_list|,
name|KBuffer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|proc_arp_rsp
parameter_list|(
name|struct
name|ipvcc
modifier|*
parameter_list|,
name|KBuffer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|proc_arp_nak
parameter_list|(
name|struct
name|ipvcc
modifier|*
parameter_list|,
name|KBuffer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|proc_inarp_req
parameter_list|(
name|struct
name|ipvcc
modifier|*
parameter_list|,
name|KBuffer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|proc_inarp_rsp
parameter_list|(
name|struct
name|ipvcc
modifier|*
parameter_list|,
name|KBuffer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Local variables  */
end_comment

begin_decl_stmt
specifier|static
name|Atm_addr
name|satm
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Atm_addr
name|satmsub
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Atm_addr
name|tatm
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Atm_addr
name|tatmsub
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|in_addr
name|sip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|in_addr
name|tip
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Process ATMARP Input Data  *   * Arguments:  *	tok	uniarp connection token (pointer to ipvcc)  *	m	pointer to input packet buffer chain  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|uniarp_cpcs_data
parameter_list|(
name|tok
parameter_list|,
name|m
parameter_list|)
name|void
modifier|*
name|tok
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
block|{
name|struct
name|ipvcc
modifier|*
name|ivp
init|=
name|tok
decl_stmt|;
name|struct
name|atmarp_hdr
modifier|*
name|ahp
decl_stmt|;
name|KBuffer
modifier|*
name|n
decl_stmt|;
name|int
name|len
decl_stmt|,
name|plen
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|atmarp_hdr
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|uniarp_print
condition|)
name|uniarp_pdu_print
argument_list|(
name|ivp
argument_list|,
name|m
argument_list|,
literal|"receive"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Verify IP's VCC state 	 */
if|if
condition|(
name|ivp
operator|->
name|iv_state
operator|!=
name|IPVCC_ACTIVE
condition|)
block|{
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Get the fixed fields together 	 */
if|if
condition|(
name|KB_LEN
argument_list|(
name|m
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|atmarp_hdr
argument_list|)
condition|)
block|{
name|KB_PULLUP
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|atmarp_hdr
argument_list|)
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
block|}
name|KB_DATASTART
argument_list|(
name|m
argument_list|,
name|ahp
argument_list|,
expr|struct
name|atmarp_hdr
operator|*
argument_list|)
expr_stmt|;
comment|/* 	 * Initial packet verification 	 */
if|if
condition|(
operator|(
name|ahp
operator|->
name|ah_hrd
operator|!=
name|htons
argument_list|(
name|ARP_ATMFORUM
argument_list|)
operator|)
operator|||
operator|(
name|ahp
operator|->
name|ah_pro
operator|!=
name|htons
argument_list|(
name|ETHERTYPE_IP
argument_list|)
operator|)
condition|)
goto|goto
name|bad
goto|;
comment|/* 	 * Verify/gather source address fields 	 */
if|if
condition|(
operator|(
name|len
operator|=
operator|(
name|ahp
operator|->
name|ah_shtl
operator|&
name|ARP_TL_LMASK
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ahp
operator|->
name|ah_shtl
operator|&
name|ARP_TL_E164
condition|)
block|{
if|if
condition|(
name|len
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|atm_addr_e164
argument_list|)
condition|)
goto|goto
name|bad
goto|;
name|satm
operator|.
name|address_format
operator|=
name|T_ATM_E164_ADDR
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|atm_addr_nsap
argument_list|)
condition|)
goto|goto
name|bad
goto|;
name|satm
operator|.
name|address_format
operator|=
name|T_ATM_ENDSYS_ADDR
expr_stmt|;
block|}
name|satm
operator|.
name|address_length
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|KB_COPYDATA
argument_list|(
name|m
argument_list|,
name|plen
argument_list|,
name|len
argument_list|,
operator|(
name|caddr_t
operator|)
name|satm
operator|.
name|address
argument_list|)
condition|)
goto|goto
name|bad
goto|;
name|plen
operator|+=
name|len
expr_stmt|;
block|}
else|else
block|{
name|satm
operator|.
name|address_format
operator|=
name|T_ATM_ABSENT
expr_stmt|;
name|satm
operator|.
name|address_length
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|len
operator|=
operator|(
name|ahp
operator|->
name|ah_sstl
operator|&
name|ARP_TL_LMASK
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|ahp
operator|->
name|ah_sstl
operator|&
name|ARP_TL_TMASK
operator|)
operator|!=
name|ARP_TL_NSAPA
operator|)
operator|||
operator|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|atm_addr_nsap
argument_list|)
operator|)
condition|)
goto|goto
name|bad
goto|;
name|satmsub
operator|.
name|address_format
operator|=
name|T_ATM_ENDSYS_ADDR
expr_stmt|;
name|satmsub
operator|.
name|address_length
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|KB_COPYDATA
argument_list|(
name|m
argument_list|,
name|plen
argument_list|,
name|len
argument_list|,
operator|(
name|caddr_t
operator|)
name|satmsub
operator|.
name|address
argument_list|)
condition|)
goto|goto
name|bad
goto|;
name|plen
operator|+=
name|len
expr_stmt|;
block|}
else|else
block|{
name|satmsub
operator|.
name|address_format
operator|=
name|T_ATM_ABSENT
expr_stmt|;
name|satmsub
operator|.
name|address_length
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|len
operator|=
name|ahp
operator|->
name|ah_spln
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|KB_COPYDATA
argument_list|(
name|m
argument_list|,
name|plen
argument_list|,
name|len
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sip
argument_list|)
condition|)
goto|goto
name|bad
goto|;
name|plen
operator|+=
name|len
expr_stmt|;
block|}
else|else
block|{
name|sip
operator|.
name|s_addr
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Verify/gather target address fields 	 */
if|if
condition|(
operator|(
name|len
operator|=
operator|(
name|ahp
operator|->
name|ah_thtl
operator|&
name|ARP_TL_LMASK
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ahp
operator|->
name|ah_thtl
operator|&
name|ARP_TL_E164
condition|)
block|{
if|if
condition|(
name|len
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|atm_addr_e164
argument_list|)
condition|)
goto|goto
name|bad
goto|;
name|tatm
operator|.
name|address_format
operator|=
name|T_ATM_E164_ADDR
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|atm_addr_nsap
argument_list|)
condition|)
goto|goto
name|bad
goto|;
name|tatm
operator|.
name|address_format
operator|=
name|T_ATM_ENDSYS_ADDR
expr_stmt|;
block|}
name|tatm
operator|.
name|address_length
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|KB_COPYDATA
argument_list|(
name|m
argument_list|,
name|plen
argument_list|,
name|len
argument_list|,
operator|(
name|caddr_t
operator|)
name|tatm
operator|.
name|address
argument_list|)
condition|)
goto|goto
name|bad
goto|;
name|plen
operator|+=
name|len
expr_stmt|;
block|}
else|else
block|{
name|tatm
operator|.
name|address_format
operator|=
name|T_ATM_ABSENT
expr_stmt|;
name|tatm
operator|.
name|address_length
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|len
operator|=
operator|(
name|ahp
operator|->
name|ah_tstl
operator|&
name|ARP_TL_LMASK
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|ahp
operator|->
name|ah_tstl
operator|&
name|ARP_TL_TMASK
operator|)
operator|!=
name|ARP_TL_NSAPA
operator|)
operator|||
operator|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|atm_addr_nsap
argument_list|)
operator|)
condition|)
goto|goto
name|bad
goto|;
name|tatmsub
operator|.
name|address_format
operator|=
name|T_ATM_ENDSYS_ADDR
expr_stmt|;
name|tatmsub
operator|.
name|address_length
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|KB_COPYDATA
argument_list|(
name|m
argument_list|,
name|plen
argument_list|,
name|len
argument_list|,
operator|(
name|caddr_t
operator|)
name|tatmsub
operator|.
name|address
argument_list|)
condition|)
goto|goto
name|bad
goto|;
name|plen
operator|+=
name|len
expr_stmt|;
block|}
else|else
block|{
name|tatmsub
operator|.
name|address_format
operator|=
name|T_ATM_ABSENT
expr_stmt|;
name|tatmsub
operator|.
name|address_length
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|len
operator|=
name|ahp
operator|->
name|ah_tpln
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|KB_COPYDATA
argument_list|(
name|m
argument_list|,
name|plen
argument_list|,
name|len
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|tip
argument_list|)
condition|)
goto|goto
name|bad
goto|;
name|plen
operator|+=
name|len
expr_stmt|;
block|}
else|else
block|{
name|tip
operator|.
name|s_addr
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Verify packet length 	 */
for|for
control|(
name|len
operator|=
literal|0
operator|,
name|n
operator|=
name|m
init|;
name|n
condition|;
name|n
operator|=
name|KB_NEXT
argument_list|(
name|n
argument_list|)
control|)
name|len
operator|+=
name|KB_LEN
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|plen
condition|)
goto|goto
name|bad
goto|;
comment|/* 	 * Now finish with packet-specific processing 	 */
switch|switch
condition|(
name|ntohs
argument_list|(
name|ahp
operator|->
name|ah_op
argument_list|)
condition|)
block|{
case|case
name|ARP_REQUEST
case|:
name|proc_arp_req
argument_list|(
name|ivp
argument_list|,
name|m
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARP_REPLY
case|:
name|proc_arp_rsp
argument_list|(
name|ivp
argument_list|,
name|m
argument_list|)
expr_stmt|;
break|break;
case|case
name|INARP_REQUEST
case|:
name|proc_inarp_req
argument_list|(
name|ivp
argument_list|,
name|m
argument_list|)
expr_stmt|;
break|break;
case|case
name|INARP_REPLY
case|:
name|proc_inarp_rsp
argument_list|(
name|ivp
argument_list|,
name|m
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARP_NAK
case|:
name|proc_arp_nak
argument_list|(
name|ivp
argument_list|,
name|m
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|bad
goto|;
block|}
return|return;
name|bad
label|:
name|uniarp_stat
operator|.
name|uas_rcvdrop
operator|++
expr_stmt|;
if|if
condition|(
name|m
condition|)
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process an ATMARP request packet  *   * Arguments:  *	ivp	pointer to input VCC's IPVCC control block  *	m	pointer to input packet buffer chain  *  * Returns:  *	none  *  */
end_comment

begin_function
specifier|static
name|void
name|proc_arp_req
parameter_list|(
name|ivp
parameter_list|,
name|m
parameter_list|)
name|struct
name|ipvcc
modifier|*
name|ivp
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
block|{
name|struct
name|ip_nif
modifier|*
name|inp
decl_stmt|;
name|struct
name|atm_nif
modifier|*
name|nip
decl_stmt|;
name|struct
name|siginst
modifier|*
name|sgp
decl_stmt|;
name|struct
name|uniip
modifier|*
name|uip
decl_stmt|;
name|struct
name|uniarp
modifier|*
name|uap
decl_stmt|;
name|struct
name|in_addr
name|myip
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
comment|/* 	 * Only an arp server should receive these 	 */
name|inp
operator|=
name|ivp
operator|->
name|iv_ipnif
expr_stmt|;
name|nip
operator|=
name|inp
operator|->
name|inf_nif
expr_stmt|;
name|uip
operator|=
operator|(
expr|struct
name|uniip
operator|*
operator|)
name|inp
operator|->
name|inf_isintf
expr_stmt|;
if|if
condition|(
operator|(
name|uip
operator|==
name|NULL
operator|)
operator|||
operator|(
name|uip
operator|->
name|uip_arpstate
operator|!=
name|UIAS_SERVER_ACTIVE
operator|)
condition|)
goto|goto
name|drop
goto|;
comment|/* 	 * These should be sent only on SVCs 	 */
if|if
condition|(
operator|(
name|ivp
operator|->
name|iv_flags
operator|&
name|IVF_SVC
operator|)
operator|==
literal|0
condition|)
goto|goto
name|drop
goto|;
comment|/* 	 * Locate our addresses 	 */
name|sgp
operator|=
name|nip
operator|->
name|nif_pif
operator|->
name|pif_siginst
expr_stmt|;
name|myip
operator|.
name|s_addr
operator|=
name|IA_SIN
argument_list|(
name|inp
operator|->
name|inf_addr
argument_list|)
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
comment|/* 	 * Target IP address must be present 	 */
if|if
condition|(
name|tip
operator|.
name|s_addr
operator|==
literal|0
condition|)
goto|goto
name|drop
goto|;
comment|/* 	 * Drop packet if both Source addresses aren't present 	 */
if|if
condition|(
operator|(
name|sip
operator|.
name|s_addr
operator|==
literal|0
operator|)
operator|||
operator|(
name|satm
operator|.
name|address_format
operator|==
name|T_ATM_ABSENT
operator|)
condition|)
goto|goto
name|drop
goto|;
comment|/* 	 * Source addresses can't be ours 	 */
if|if
condition|(
name|ATM_ADDR_SEL_EQUAL
argument_list|(
operator|&
name|sgp
operator|->
name|si_addr
argument_list|,
name|nip
operator|->
name|nif_sel
argument_list|,
operator|&
name|satm
argument_list|)
operator|&&
name|ATM_ADDR_SEL_EQUAL
argument_list|(
operator|&
name|sgp
operator|->
name|si_subaddr
argument_list|,
name|nip
operator|->
name|nif_sel
argument_list|,
operator|&
name|satmsub
argument_list|)
condition|)
block|{
name|struct
name|vccb
modifier|*
name|vcp
init|=
name|ivp
operator|->
name|iv_conn
operator|->
name|co_connvc
operator|->
name|cvc_vcc
decl_stmt|;
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"uniarp: vcc=(%d,%d) reports our ATM address\n"
argument_list|,
name|vcp
operator|->
name|vc_vpi
argument_list|,
name|vcp
operator|->
name|vc_vci
argument_list|)
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
if|if
condition|(
name|sip
operator|.
name|s_addr
operator|==
name|myip
operator|.
name|s_addr
condition|)
block|{
name|struct
name|vccb
modifier|*
name|vcp
init|=
name|ivp
operator|->
name|iv_conn
operator|->
name|co_connvc
operator|->
name|cvc_vcc
decl_stmt|;
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"uniarp: vcc=(%d,%d) reports our IP address\n"
argument_list|,
name|vcp
operator|->
name|vc_vpi
argument_list|,
name|vcp
operator|->
name|vc_vci
argument_list|)
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
comment|/* 	 * Validate Source IP address 	 */
if|if
condition|(
name|uniarp_validate_ip
argument_list|(
name|uip
argument_list|,
operator|&
name|sip
argument_list|,
name|UAO_REGISTER
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|drop
goto|;
comment|/* 	 * If the source and target IP addresses are the same, then this 	 * must be a client registration request (RFC-2225).  Otherwise,  	 * try to accomodate old clients (per RFC-2225 8.4.4). 	 */
if|if
condition|(
name|sip
operator|.
name|s_addr
operator|==
name|tip
operator|.
name|s_addr
condition|)
operator|(
name|void
operator|)
name|uniarp_cache_svc
argument_list|(
name|uip
argument_list|,
operator|&
name|sip
argument_list|,
operator|&
name|satm
argument_list|,
operator|&
name|satmsub
argument_list|,
name|UAO_REGISTER
argument_list|)
expr_stmt|;
else|else
block|{
name|uap
operator|=
operator|(
expr|struct
name|uniarp
operator|*
operator|)
name|ivp
operator|->
name|iv_arpent
expr_stmt|;
if|if
condition|(
operator|(
name|uap
operator|==
name|NULL
operator|)
operator|||
operator|(
name|uap
operator|->
name|ua_origin
operator|<
name|UAO_REGISTER
operator|)
condition|)
operator|(
name|void
operator|)
name|uniarp_cache_svc
argument_list|(
name|uip
argument_list|,
operator|&
name|sip
argument_list|,
operator|&
name|satm
argument_list|,
operator|&
name|satmsub
argument_list|,
name|UAO_REGISTER
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Lookup the target IP address in the cache (and also check if 	 * the query is for our address). 	 */
name|UNIARP_LOOKUP
argument_list|(
name|tip
operator|.
name|s_addr
argument_list|,
name|uap
argument_list|)
expr_stmt|;
if|if
condition|(
name|uap
operator|&&
operator|(
name|uap
operator|->
name|ua_flags
operator|&
name|UAF_VALID
operator|)
condition|)
block|{
comment|/* 		 * We've found a valid mapping 		 */
operator|(
name|void
operator|)
name|uniarp_arp_rsp
argument_list|(
name|uip
argument_list|,
operator|&
name|uap
operator|->
name|ua_arpmap
argument_list|,
operator|&
name|sip
argument_list|,
operator|&
name|satm
argument_list|,
operator|&
name|satmsub
argument_list|,
name|ivp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tip
operator|.
name|s_addr
operator|==
name|myip
operator|.
name|s_addr
condition|)
block|{
comment|/* 		 * We're the target, so respond accordingly 		 */
operator|(
name|void
operator|)
name|uniarp_arp_rsp
argument_list|(
name|uip
argument_list|,
operator|&
name|uip
operator|->
name|uip_arpsvrmap
argument_list|,
operator|&
name|sip
argument_list|,
operator|&
name|satm
argument_list|,
operator|&
name|satmsub
argument_list|,
name|ivp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * We don't know who the target is, so NAK the query 		 */
operator|(
name|void
operator|)
name|uniarp_arp_nak
argument_list|(
name|uip
argument_list|,
name|m
argument_list|,
name|ivp
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
block|}
name|drop
label|:
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Process an ATMARP reply packet  *   * Arguments:  *	ivp	pointer to input VCC's IPVCC control block  *	m	pointer to input packet buffer chain  *  * Returns:  *	none  *  */
end_comment

begin_function
specifier|static
name|void
name|proc_arp_rsp
parameter_list|(
name|ivp
parameter_list|,
name|m
parameter_list|)
name|struct
name|ipvcc
modifier|*
name|ivp
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
block|{
name|struct
name|ip_nif
modifier|*
name|inp
decl_stmt|;
name|struct
name|atm_nif
modifier|*
name|nip
decl_stmt|;
name|struct
name|siginst
modifier|*
name|sgp
decl_stmt|;
name|struct
name|uniip
modifier|*
name|uip
decl_stmt|;
name|struct
name|uniarp
modifier|*
name|uap
decl_stmt|;
name|struct
name|in_addr
name|myip
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
comment|/* 	 * Only the arp server should send these 	 */
name|inp
operator|=
name|ivp
operator|->
name|iv_ipnif
expr_stmt|;
name|nip
operator|=
name|inp
operator|->
name|inf_nif
expr_stmt|;
name|uip
operator|=
operator|(
expr|struct
name|uniip
operator|*
operator|)
name|inp
operator|->
name|inf_isintf
expr_stmt|;
if|if
condition|(
operator|(
name|uip
operator|==
name|NULL
operator|)
operator|||
operator|(
name|uip
operator|->
name|uip_arpsvrvcc
operator|!=
name|ivp
operator|)
condition|)
goto|goto
name|drop
goto|;
comment|/* 	 * Locate our addresses 	 */
name|sgp
operator|=
name|nip
operator|->
name|nif_pif
operator|->
name|pif_siginst
expr_stmt|;
name|myip
operator|.
name|s_addr
operator|=
name|IA_SIN
argument_list|(
name|inp
operator|->
name|inf_addr
argument_list|)
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
comment|/* 	 * Target addresses must be ours 	 */
if|if
condition|(
operator|(
name|tip
operator|.
name|s_addr
operator|!=
name|myip
operator|.
name|s_addr
operator|)
operator|||
operator|!
name|ATM_ADDR_SEL_EQUAL
argument_list|(
operator|&
name|sgp
operator|->
name|si_addr
argument_list|,
name|nip
operator|->
name|nif_sel
argument_list|,
operator|&
name|tatm
argument_list|)
operator|||
operator|!
name|ATM_ADDR_SEL_EQUAL
argument_list|(
operator|&
name|sgp
operator|->
name|si_subaddr
argument_list|,
name|nip
operator|->
name|nif_sel
argument_list|,
operator|&
name|tatmsub
argument_list|)
condition|)
goto|goto
name|drop
goto|;
comment|/* 	 * Drop packet if both Source addresses aren't present 	 */
if|if
condition|(
operator|(
name|sip
operator|.
name|s_addr
operator|==
literal|0
operator|)
operator|||
operator|(
name|satm
operator|.
name|address_format
operator|==
name|T_ATM_ABSENT
operator|)
condition|)
goto|goto
name|drop
goto|;
comment|/* 	 * If the Source addresses are ours, this is an arp server 	 * registration response 	 */
if|if
condition|(
name|ATM_ADDR_SEL_EQUAL
argument_list|(
operator|&
name|sgp
operator|->
name|si_addr
argument_list|,
name|nip
operator|->
name|nif_sel
argument_list|,
operator|&
name|satm
argument_list|)
operator|&&
name|ATM_ADDR_SEL_EQUAL
argument_list|(
operator|&
name|sgp
operator|->
name|si_subaddr
argument_list|,
name|nip
operator|->
name|nif_sel
argument_list|,
operator|&
name|satmsub
argument_list|)
condition|)
block|{
if|if
condition|(
name|sip
operator|.
name|s_addr
operator|==
name|myip
operator|.
name|s_addr
condition|)
block|{
comment|/* 			 * Registration response - update our state and 			 * set a registration refresh timer 			 */
if|if
condition|(
name|uip
operator|->
name|uip_arpstate
operator|==
name|UIAS_CLIENT_REGISTER
condition|)
name|uip
operator|->
name|uip_arpstate
operator|=
name|UIAS_CLIENT_ACTIVE
expr_stmt|;
if|if
condition|(
name|uip
operator|->
name|uip_arpstate
operator|==
name|UIAS_CLIENT_ACTIVE
condition|)
block|{
name|UNIIP_ARP_CANCEL
argument_list|(
name|uip
argument_list|)
expr_stmt|;
name|UNIIP_ARP_TIMER
argument_list|(
name|uip
argument_list|,
name|UNIARP_REGIS_REFRESH
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * If the cache entry for the server VCC isn't valid 			 * yet, then send an Inverse ATMARP request to solicit 			 * the server's IP address 			 */
name|uap
operator|=
operator|(
expr|struct
name|uniarp
operator|*
operator|)
name|ivp
operator|->
name|iv_arpent
expr_stmt|;
if|if
condition|(
operator|(
name|uap
operator|->
name|ua_flags
operator|&
name|UAF_VALID
operator|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|uniarp_inarp_req
argument_list|(
name|uip
argument_list|,
operator|&
name|uap
operator|->
name|ua_dstatm
argument_list|,
operator|&
name|uap
operator|->
name|ua_dstatmsub
argument_list|,
name|ivp
argument_list|)
expr_stmt|;
block|}
goto|goto
name|drop
goto|;
block|}
else|else
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"uniarp: arpserver has our IP address wrong\n"
argument_list|)
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|sip
operator|.
name|s_addr
operator|==
name|myip
operator|.
name|s_addr
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"uniarp: arpserver has our ATM address wrong\n"
argument_list|)
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
comment|/* 	 * Validate the Source IP address 	 */
if|if
condition|(
name|uniarp_validate_ip
argument_list|(
name|uip
argument_list|,
operator|&
name|sip
argument_list|,
name|UAO_LOOKUP
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|drop
goto|;
comment|/* 	 * Now we believe this packet contains an authoritative mapping, 	 * which we probably need to setup an outgoing SVC connection 	 */
operator|(
name|void
operator|)
name|uniarp_cache_svc
argument_list|(
name|uip
argument_list|,
operator|&
name|sip
argument_list|,
operator|&
name|satm
argument_list|,
operator|&
name|satmsub
argument_list|,
name|UAO_LOOKUP
argument_list|)
expr_stmt|;
name|drop
label|:
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Process an ATMARP negative ack packet  *   * Arguments:  *	ivp	pointer to input VCC's IPVCC control block  *	m	pointer to input packet buffer chain  *  * Returns:  *	none  *  */
end_comment

begin_function
specifier|static
name|void
name|proc_arp_nak
parameter_list|(
name|ivp
parameter_list|,
name|m
parameter_list|)
name|struct
name|ipvcc
modifier|*
name|ivp
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
block|{
name|struct
name|ip_nif
modifier|*
name|inp
decl_stmt|;
name|struct
name|atm_nif
modifier|*
name|nip
decl_stmt|;
name|struct
name|siginst
modifier|*
name|sgp
decl_stmt|;
name|struct
name|uniip
modifier|*
name|uip
decl_stmt|;
name|struct
name|uniarp
modifier|*
name|uap
decl_stmt|;
name|struct
name|in_addr
name|myip
decl_stmt|;
name|struct
name|ipvcc
modifier|*
name|inext
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
comment|/* 	 * Only the arp server should send these 	 */
name|inp
operator|=
name|ivp
operator|->
name|iv_ipnif
expr_stmt|;
name|nip
operator|=
name|inp
operator|->
name|inf_nif
expr_stmt|;
name|uip
operator|=
operator|(
expr|struct
name|uniip
operator|*
operator|)
name|inp
operator|->
name|inf_isintf
expr_stmt|;
if|if
condition|(
operator|(
name|uip
operator|==
name|NULL
operator|)
operator|||
operator|(
name|uip
operator|->
name|uip_arpsvrvcc
operator|!=
name|ivp
operator|)
condition|)
goto|goto
name|drop
goto|;
comment|/* 	 * Locate our addresses 	 */
name|sgp
operator|=
name|nip
operator|->
name|nif_pif
operator|->
name|pif_siginst
expr_stmt|;
name|myip
operator|.
name|s_addr
operator|=
name|IA_SIN
argument_list|(
name|inp
operator|->
name|inf_addr
argument_list|)
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
comment|/* 	 * Source addresses must be ours 	 */
if|if
condition|(
operator|(
name|sip
operator|.
name|s_addr
operator|!=
name|myip
operator|.
name|s_addr
operator|)
operator|||
operator|!
name|ATM_ADDR_SEL_EQUAL
argument_list|(
operator|&
name|sgp
operator|->
name|si_addr
argument_list|,
name|nip
operator|->
name|nif_sel
argument_list|,
operator|&
name|satm
argument_list|)
operator|||
operator|!
name|ATM_ADDR_SEL_EQUAL
argument_list|(
operator|&
name|sgp
operator|->
name|si_subaddr
argument_list|,
name|nip
operator|->
name|nif_sel
argument_list|,
operator|&
name|satmsub
argument_list|)
condition|)
goto|goto
name|drop
goto|;
comment|/* 	 * Drop packet if the Target IP address isn't there or if this 	 * is a registration response, indicating an old or flakey server 	 */
if|if
condition|(
operator|(
name|tip
operator|.
name|s_addr
operator|==
literal|0
operator|)
operator|||
operator|(
name|tip
operator|.
name|s_addr
operator|==
name|myip
operator|.
name|s_addr
operator|)
condition|)
goto|goto
name|drop
goto|;
comment|/* 	 * Otherwise, see who we were looking for 	 */
name|UNIARP_LOOKUP
argument_list|(
name|tip
operator|.
name|s_addr
argument_list|,
name|uap
argument_list|)
expr_stmt|;
if|if
condition|(
name|uap
operator|==
name|NULL
condition|)
goto|goto
name|drop
goto|;
comment|/* 	 * This entry isn't valid any longer, so notify all VCCs using this 	 * entry that they must finish up.  The last notify should cause 	 * this entry to be freed by the vcclose() function. 	 */
name|uap
operator|->
name|ua_flags
operator|&=
operator|~
name|UAF_VALID
expr_stmt|;
for|for
control|(
name|ivp
operator|=
name|uap
operator|->
name|ua_ivp
init|;
name|ivp
condition|;
name|ivp
operator|=
name|inext
control|)
block|{
name|inext
operator|=
name|ivp
operator|->
name|iv_arpnext
expr_stmt|;
call|(
modifier|*
name|inp
operator|->
name|inf_arpnotify
call|)
argument_list|(
name|ivp
argument_list|,
name|MAP_FAILED
argument_list|)
expr_stmt|;
block|}
name|drop
label|:
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Process an InATMARP request packet  *   * Arguments:  *	ivp	pointer to input VCC's IPVCC control block  *	m	pointer to input packet buffer chain  *  * Returns:  *	none  *  */
end_comment

begin_function
specifier|static
name|void
name|proc_inarp_req
parameter_list|(
name|ivp
parameter_list|,
name|m
parameter_list|)
name|struct
name|ipvcc
modifier|*
name|ivp
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
block|{
name|struct
name|ip_nif
modifier|*
name|inp
decl_stmt|;
name|struct
name|atm_nif
modifier|*
name|nip
decl_stmt|;
name|struct
name|siginst
modifier|*
name|sgp
decl_stmt|;
name|struct
name|uniip
modifier|*
name|uip
decl_stmt|;
name|struct
name|in_addr
name|myip
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
comment|/* 	 * Get interface pointers 	 */
name|inp
operator|=
name|ivp
operator|->
name|iv_ipnif
expr_stmt|;
name|nip
operator|=
name|inp
operator|->
name|inf_nif
expr_stmt|;
name|uip
operator|=
operator|(
expr|struct
name|uniip
operator|*
operator|)
name|inp
operator|->
name|inf_isintf
expr_stmt|;
if|if
condition|(
name|uip
operator|==
name|NULL
condition|)
goto|goto
name|drop
goto|;
comment|/* 	 * Locate our addresses 	 */
name|sgp
operator|=
name|nip
operator|->
name|nif_pif
operator|->
name|pif_siginst
expr_stmt|;
name|myip
operator|.
name|s_addr
operator|=
name|IA_SIN
argument_list|(
name|inp
operator|->
name|inf_addr
argument_list|)
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
comment|/* 	 * Packet must have a Source IP address and, if it was received 	 * over an SVC, a Source ATM address too. 	 */
if|if
condition|(
operator|(
name|sip
operator|.
name|s_addr
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|ivp
operator|->
name|iv_flags
operator|&
name|IVF_SVC
operator|)
operator|&&
operator|(
name|satm
operator|.
name|address_format
operator|==
name|T_ATM_ABSENT
operator|)
operator|)
condition|)
goto|goto
name|drop
goto|;
comment|/* 	 * Validate Source ATM address 	 *      - can't be me 	 */
if|if
condition|(
name|satm
operator|.
name|address_format
operator|!=
name|T_ATM_ABSENT
condition|)
block|{
if|if
condition|(
name|ATM_ADDR_SEL_EQUAL
argument_list|(
operator|&
name|sgp
operator|->
name|si_addr
argument_list|,
name|nip
operator|->
name|nif_sel
argument_list|,
operator|&
name|satm
argument_list|)
operator|&&
name|ATM_ADDR_SEL_EQUAL
argument_list|(
operator|&
name|sgp
operator|->
name|si_subaddr
argument_list|,
name|nip
operator|->
name|nif_sel
argument_list|,
operator|&
name|satmsub
argument_list|)
condition|)
goto|goto
name|drop
goto|;
block|}
comment|/* 	 * Validate Source IP address 	 */
if|if
condition|(
operator|(
name|sip
operator|.
name|s_addr
operator|==
name|myip
operator|.
name|s_addr
operator|)
operator|||
operator|(
name|uniarp_validate_ip
argument_list|(
name|uip
argument_list|,
operator|&
name|sip
argument_list|,
name|UAO_PEER_REQ
argument_list|)
operator|!=
literal|0
operator|)
condition|)
goto|goto
name|drop
goto|;
comment|/* 	 * The Target ATM address is required for a packet received over 	 * an SVC, optional for a PVC.  If one is present, it must be our 	 * address. 	 */
if|if
condition|(
operator|(
name|ivp
operator|->
name|iv_flags
operator|&
name|IVF_SVC
operator|)
operator|&&
operator|(
name|tatm
operator|.
name|address_format
operator|==
name|T_ATM_ABSENT
operator|)
condition|)
goto|goto
name|drop
goto|;
if|if
condition|(
operator|(
name|tatm
operator|.
name|address_format
operator|!=
name|T_ATM_ABSENT
operator|)
operator|&&
operator|(
operator|!
name|ATM_ADDR_SEL_EQUAL
argument_list|(
operator|&
name|sgp
operator|->
name|si_addr
argument_list|,
name|nip
operator|->
name|nif_sel
argument_list|,
operator|&
name|tatm
argument_list|)
operator|||
operator|!
name|ATM_ADDR_SEL_EQUAL
argument_list|(
operator|&
name|sgp
operator|->
name|si_subaddr
argument_list|,
name|nip
operator|->
name|nif_sel
argument_list|,
operator|&
name|tatmsub
argument_list|)
operator|)
condition|)
goto|goto
name|drop
goto|;
comment|/* 	 * See where this packet is from 	 */
if|if
condition|(
name|ivp
operator|->
name|iv_flags
operator|&
name|IVF_PVC
condition|)
block|{
comment|/* 		 * Process the PVC arp data, although we don't really  		 * update the arp cache with this information 		 */
name|uniarp_cache_pvc
argument_list|(
name|ivp
argument_list|,
operator|&
name|sip
argument_list|,
operator|&
name|satm
argument_list|,
operator|&
name|satmsub
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|uip
operator|->
name|uip_arpsvrvcc
operator|==
name|ivp
condition|)
block|{
comment|/* 		 * Packet is from the arp server, so we've received a 		 * registration/refresh request (1577 version). 		 * 		 * Therefore, update cache with authoritative data. 		 */
operator|(
name|void
operator|)
name|uniarp_cache_svc
argument_list|(
name|uip
argument_list|,
operator|&
name|sip
argument_list|,
operator|&
name|satm
argument_list|,
operator|&
name|satmsub
argument_list|,
name|UAO_LOOKUP
argument_list|)
expr_stmt|;
comment|/* 		 * Make sure the cache update didn't kill the server VCC 		 */
if|if
condition|(
name|uip
operator|->
name|uip_arpsvrvcc
operator|!=
name|ivp
condition|)
goto|goto
name|drop
goto|;
comment|/* 		 * Update the server state and set the 		 * registration refresh timer 		 */
name|uip
operator|->
name|uip_arpstate
operator|=
name|UIAS_CLIENT_ACTIVE
expr_stmt|;
name|UNIIP_ARP_CANCEL
argument_list|(
name|uip
argument_list|)
expr_stmt|;
name|UNIIP_ARP_TIMER
argument_list|(
name|uip
argument_list|,
name|UNIARP_REGIS_REFRESH
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Otherwise, we consider this source mapping data as 		 * non-authoritative and update the cache appropriately 		 */
if|if
condition|(
name|uniarp_cache_svc
argument_list|(
name|uip
argument_list|,
operator|&
name|sip
argument_list|,
operator|&
name|satm
argument_list|,
operator|&
name|satmsub
argument_list|,
name|UAO_PEER_REQ
argument_list|)
condition|)
goto|goto
name|drop
goto|;
block|}
comment|/* 	 * Send an InATMARP response back to originator 	 */
operator|(
name|void
operator|)
name|uniarp_inarp_rsp
argument_list|(
name|uip
argument_list|,
operator|&
name|sip
argument_list|,
operator|&
name|satm
argument_list|,
operator|&
name|satmsub
argument_list|,
name|ivp
argument_list|)
expr_stmt|;
name|drop
label|:
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Process an InATMARP response packet  *   * Arguments:  *	ivp	pointer to input VCC's IPVCC control block  *	m	pointer to input packet buffer chain  *  * Returns:  *	none  *  */
end_comment

begin_function
specifier|static
name|void
name|proc_inarp_rsp
parameter_list|(
name|ivp
parameter_list|,
name|m
parameter_list|)
name|struct
name|ipvcc
modifier|*
name|ivp
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
block|{
name|struct
name|ip_nif
modifier|*
name|inp
decl_stmt|;
name|struct
name|atm_nif
modifier|*
name|nip
decl_stmt|;
name|struct
name|siginst
modifier|*
name|sgp
decl_stmt|;
name|struct
name|uniip
modifier|*
name|uip
decl_stmt|;
name|struct
name|in_addr
name|myip
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
comment|/* 	 * Get interface pointers 	 */
name|inp
operator|=
name|ivp
operator|->
name|iv_ipnif
expr_stmt|;
name|nip
operator|=
name|inp
operator|->
name|inf_nif
expr_stmt|;
name|uip
operator|=
operator|(
expr|struct
name|uniip
operator|*
operator|)
name|inp
operator|->
name|inf_isintf
expr_stmt|;
if|if
condition|(
name|uip
operator|==
name|NULL
condition|)
goto|goto
name|drop
goto|;
comment|/* 	 * Locate our addresses 	 */
name|sgp
operator|=
name|nip
operator|->
name|nif_pif
operator|->
name|pif_siginst
expr_stmt|;
name|myip
operator|.
name|s_addr
operator|=
name|IA_SIN
argument_list|(
name|inp
operator|->
name|inf_addr
argument_list|)
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
comment|/* 	 * Packet must have a Source IP address and, if it was received 	 * over an SVC, a Source ATM address too. 	 */
if|if
condition|(
operator|(
name|sip
operator|.
name|s_addr
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|ivp
operator|->
name|iv_flags
operator|&
name|IVF_SVC
operator|)
operator|&&
operator|(
name|satm
operator|.
name|address_format
operator|==
name|T_ATM_ABSENT
operator|)
operator|)
condition|)
goto|goto
name|drop
goto|;
comment|/* 	 * Validate Source ATM address 	 *      - can't be me 	 */
if|if
condition|(
name|satm
operator|.
name|address_format
operator|!=
name|T_ATM_ABSENT
condition|)
block|{
if|if
condition|(
name|ATM_ADDR_SEL_EQUAL
argument_list|(
operator|&
name|sgp
operator|->
name|si_addr
argument_list|,
name|nip
operator|->
name|nif_sel
argument_list|,
operator|&
name|satm
argument_list|)
operator|&&
name|ATM_ADDR_SEL_EQUAL
argument_list|(
operator|&
name|sgp
operator|->
name|si_subaddr
argument_list|,
name|nip
operator|->
name|nif_sel
argument_list|,
operator|&
name|satmsub
argument_list|)
condition|)
goto|goto
name|drop
goto|;
block|}
comment|/* 	 * Validate Source IP address 	 *      - must be in our LIS 	 *      - can't be me 	 *      - can't be broadcast 	 *      - can't be multicast 	 */
if|if
condition|(
operator|(
name|sip
operator|.
name|s_addr
operator|==
name|myip
operator|.
name|s_addr
operator|)
operator|||
operator|(
name|uniarp_validate_ip
argument_list|(
name|uip
argument_list|,
operator|&
name|sip
argument_list|,
name|UAO_PEER_RSP
argument_list|)
operator|!=
literal|0
operator|)
condition|)
goto|goto
name|drop
goto|;
comment|/* 	 * The Target ATM address is required for a packet received over 	 * an SVC, optional for a PVC.  If one is present, it must be our 	 * address. 	 */
if|if
condition|(
operator|(
name|ivp
operator|->
name|iv_flags
operator|&
name|IVF_SVC
operator|)
operator|&&
operator|(
name|tatm
operator|.
name|address_format
operator|==
name|T_ATM_ABSENT
operator|)
condition|)
goto|goto
name|drop
goto|;
if|if
condition|(
operator|(
name|tatm
operator|.
name|address_format
operator|!=
name|T_ATM_ABSENT
operator|)
operator|&&
operator|(
operator|!
name|ATM_ADDR_SEL_EQUAL
argument_list|(
operator|&
name|sgp
operator|->
name|si_addr
argument_list|,
name|nip
operator|->
name|nif_sel
argument_list|,
operator|&
name|tatm
argument_list|)
operator|||
operator|!
name|ATM_ADDR_SEL_EQUAL
argument_list|(
operator|&
name|sgp
operator|->
name|si_subaddr
argument_list|,
name|nip
operator|->
name|nif_sel
argument_list|,
operator|&
name|tatmsub
argument_list|)
operator|)
condition|)
goto|goto
name|drop
goto|;
comment|/* 	 * See where this packet is from 	 */
if|if
condition|(
name|ivp
operator|->
name|iv_flags
operator|&
name|IVF_PVC
condition|)
block|{
comment|/* 		 * Process the PVC arp data, although we don't really  		 * update the arp cache with this information 		 */
name|uniarp_cache_pvc
argument_list|(
name|ivp
argument_list|,
operator|&
name|sip
argument_list|,
operator|&
name|satm
argument_list|,
operator|&
name|satmsub
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Can't tell the difference between an RFC-1577 registration 		 * and a data connection from a client of another arpserver  		 * on our LIS (using SCSP) - so we'll update the cache now 		 * with what we've got.  Our clients will get "registered" 		 * when (if) they query us with an arp request. 		 */
operator|(
name|void
operator|)
name|uniarp_cache_svc
argument_list|(
name|uip
argument_list|,
operator|&
name|sip
argument_list|,
operator|&
name|satm
argument_list|,
operator|&
name|satmsub
argument_list|,
name|UAO_PEER_RSP
argument_list|)
expr_stmt|;
block|}
name|drop
label|:
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Print an ATMARP PDU  *   * Arguments:  *	ivp	pointer to input VCC control block  *	m	pointer to pdu buffer chain  *	msg	pointer to message string  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|uniarp_pdu_print
parameter_list|(
specifier|const
name|struct
name|ipvcc
modifier|*
name|ivp
parameter_list|,
specifier|const
name|KBuffer
modifier|*
name|m
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|struct
name|vccb
modifier|*
name|vcp
decl_stmt|;
name|vcp
operator|=
name|ivp
operator|->
name|iv_conn
operator|->
name|co_connvc
operator|->
name|cvc_vcc
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"uniarp %s: vcc=(%d,%d)\n"
argument_list|,
name|msg
argument_list|,
name|vcp
operator|->
name|vc_vpi
argument_list|,
name|vcp
operator|->
name|vc_vci
argument_list|)
expr_stmt|;
name|atm_pdu_print
argument_list|(
name|m
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

