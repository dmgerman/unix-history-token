begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * ===================================  * HARP  |  Host ATM Research Platform  * ===================================  *  *  * This Host ATM Research Platform ("HARP") file (the "Software") is  * made available by Network Computing Services, Inc. ("NetworkCS")  * "AS IS".  NetworkCS does not provide maintenance, improvements or  * support of any kind.  *  * NETWORKCS MAKES NO WARRANTIES OR REPRESENTATIONS, EXPRESS OR IMPLIED,  * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE, AS TO ANY ELEMENT OF THE  * SOFTWARE OR ANY SUPPORT PROVIDED IN CONNECTION WITH THIS SOFTWARE.  * In no event shall NetworkCS be responsible for any damages, including  * but not limited to consequential damages, arising from or relating to  * any use of the Software or related support.  *  * Copyright 1994-1998 Network Computing Services, Inc.  *  * Copies of this Software may be made, however, the above copyright  * notice must be reproduced on all copies.  *  *	@(#) $FreeBSD$  *  */
end_comment

begin_comment
comment|/*  * ATM Forum UNI Support  * ---------------------  *  * SSCF UNI - SSCOP SAP interface processing  *  */
end_comment

begin_include
include|#
directive|include
file|<netatm/kern_include.h>
end_include

begin_include
include|#
directive|include
file|<netatm/uni/uni.h>
end_include

begin_include
include|#
directive|include
file|<netatm/uni/sscop.h>
end_include

begin_include
include|#
directive|include
file|<netatm/uni/sscf_uni_var.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"@(#) $FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * SSCF_UNI Upper Stack Command Handler  *   * This function will receive all of the stack commands issued from the   * layer below SSCF UNI (ie. SSCOP).  *  * Arguments:  *	cmd	stack command code  *	tok	session token  *	arg1	command specific argument  *	arg2	command specific argument  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|sscf_uni_upper
parameter_list|(
name|cmd
parameter_list|,
name|tok
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|int
name|cmd
decl_stmt|;
name|void
modifier|*
name|tok
decl_stmt|;
name|int
name|arg1
decl_stmt|;
name|int
name|arg2
decl_stmt|;
block|{
name|struct
name|univcc
modifier|*
name|uvp
init|=
operator|(
expr|struct
name|univcc
operator|*
operator|)
name|tok
decl_stmt|;
name|Atm_connvc
modifier|*
name|cvp
init|=
name|uvp
operator|->
name|uv_connvc
decl_stmt|;
name|int
name|err
decl_stmt|;
name|ATM_DEBUG5
argument_list|(
literal|"sscf_uni_upper: cmd=0x%x, uvp=%p, lstate=%d, arg1=0x%x, arg2=0x%x\n"
argument_list|,
name|cmd
argument_list|,
name|uvp
argument_list|,
name|uvp
operator|->
name|uv_lstate
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SSCOP_ESTABLISH_IND
case|:
comment|/* 		 * We don't support SSCOP User-to-User data, so just 		 * get rid of any supplied to us 		 */
if|if
condition|(
name|arg1
operator|!=
name|SSCOP_UU_NULL
condition|)
name|KB_FREEALL
argument_list|(
operator|(
name|KBuffer
operator|*
operator|)
name|arg1
argument_list|)
expr_stmt|;
comment|/* 		 * Validation based on sscop state 		 */
switch|switch
condition|(
name|uvp
operator|->
name|uv_lstate
condition|)
block|{
case|case
name|UVL_READY
case|:
if|if
condition|(
name|uvp
operator|->
name|uv_vers
operator|!=
name|UNI_VERS_3_0
condition|)
block|{
goto|goto
name|seqerr
goto|;
block|}
goto|goto
name|doestind
goto|;
case|case
name|UVL_IDLE
case|:
comment|/* 			 * Incoming connection establishment request 			 */
comment|/* 			 * If user doesn't want any more incoming sessions 			 * accepted, then refuse request 			 */
if|if
condition|(
name|uvp
operator|->
name|uv_flags
operator|&
name|UVF_NOESTIND
condition|)
block|{
name|STACK_CALL
argument_list|(
name|SSCOP_RELEASE_REQ
argument_list|,
name|uvp
operator|->
name|uv_lower
argument_list|,
name|uvp
operator|->
name|uv_tokl
argument_list|,
name|cvp
argument_list|,
name|SSCOP_UU_NULL
argument_list|,
literal|0
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|sscf_uni_abort
argument_list|(
name|uvp
argument_list|,
literal|"sscf_uni: stack memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
block|}
name|doestind
label|:
comment|/* 			 * Tell sscop we've accepted the new connection 			 */
name|uvp
operator|->
name|uv_lstate
operator|=
name|UVL_READY
expr_stmt|;
name|STACK_CALL
argument_list|(
name|SSCOP_ESTABLISH_RSP
argument_list|,
name|uvp
operator|->
name|uv_lower
argument_list|,
name|uvp
operator|->
name|uv_tokl
argument_list|,
name|cvp
argument_list|,
name|SSCOP_UU_NULL
argument_list|,
name|SSCOP_BR_YES
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|sscf_uni_abort
argument_list|(
name|uvp
argument_list|,
literal|"sscf_uni: stack memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 			 * Now notify the user of the new connection 			 */
name|uvp
operator|->
name|uv_ustate
operator|=
name|UVU_ACTIVE
expr_stmt|;
name|STACK_CALL
argument_list|(
name|SSCF_UNI_ESTABLISH_IND
argument_list|,
name|uvp
operator|->
name|uv_upper
argument_list|,
name|uvp
operator|->
name|uv_toku
argument_list|,
name|cvp
argument_list|,
name|SSCOP_UU_NULL
argument_list|,
literal|0
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|sscf_uni_abort
argument_list|(
name|uvp
argument_list|,
literal|"sscf_uni: stack memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|UVL_TERM
case|:
comment|/* 			 * Ignoring everything 			 */
break|break;
case|case
name|UVL_INST
case|:
case|case
name|UVL_OUTCONN
case|:
case|case
name|UVL_INCONN
case|:
case|case
name|UVL_OUTDISC
case|:
case|case
name|UVL_OUTRESYN
case|:
case|case
name|UVL_INRESYN
case|:
case|case
name|UVL_RECOVERY
case|:
default|default:
name|seqerr
label|:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sscf_uni_upper: cmd=0x%x, lstate=%d\n"
argument_list|,
name|cmd
argument_list|,
name|uvp
operator|->
name|uv_lstate
argument_list|)
expr_stmt|;
name|sscf_uni_abort
argument_list|(
name|uvp
argument_list|,
literal|"sscf_uni: sequence err\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SSCOP_ESTABLISH_CNF
case|:
comment|/* 		 * We don't support SSCOP User-to-User data, so just 		 * get rid of any supplied to us 		 */
if|if
condition|(
name|arg1
operator|!=
name|SSCOP_UU_NULL
condition|)
name|KB_FREEALL
argument_list|(
operator|(
name|KBuffer
operator|*
operator|)
name|arg1
argument_list|)
expr_stmt|;
comment|/* 		 * Validation based on sscop state 		 */
switch|switch
condition|(
name|uvp
operator|->
name|uv_lstate
condition|)
block|{
case|case
name|UVL_OUTCONN
case|:
comment|/* 			 * Outgoing connection establishment completed 			 */
comment|/* 			 * Tell the user that the connection is established 			 */
name|uvp
operator|->
name|uv_ustate
operator|=
name|UVU_ACTIVE
expr_stmt|;
name|uvp
operator|->
name|uv_lstate
operator|=
name|UVL_READY
expr_stmt|;
name|STACK_CALL
argument_list|(
name|SSCF_UNI_ESTABLISH_CNF
argument_list|,
name|uvp
operator|->
name|uv_upper
argument_list|,
name|uvp
operator|->
name|uv_toku
argument_list|,
name|cvp
argument_list|,
name|SSCOP_UU_NULL
argument_list|,
literal|0
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|sscf_uni_abort
argument_list|(
name|uvp
argument_list|,
literal|"sscf_uni: stack memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|UVL_TERM
case|:
comment|/* 			 * Ignoring everything 			 */
break|break;
case|case
name|UVL_INST
case|:
case|case
name|UVL_IDLE
case|:
case|case
name|UVL_INCONN
case|:
case|case
name|UVL_OUTDISC
case|:
case|case
name|UVL_OUTRESYN
case|:
case|case
name|UVL_INRESYN
case|:
case|case
name|UVL_RECOVERY
case|:
case|case
name|UVL_READY
case|:
default|default:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sscf_uni_upper: cmd=0x%x, lstate=%d\n"
argument_list|,
name|cmd
argument_list|,
name|uvp
operator|->
name|uv_lstate
argument_list|)
expr_stmt|;
name|sscf_uni_abort
argument_list|(
name|uvp
argument_list|,
literal|"sscf_uni: sequence err\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SSCOP_RELEASE_IND
case|:
comment|/* 		 * We don't support SSCOP User-to-User data, so just 		 * get rid of any supplied to us 		 */
if|if
condition|(
name|arg1
operator|!=
name|SSCOP_UU_NULL
condition|)
name|KB_FREEALL
argument_list|(
operator|(
name|KBuffer
operator|*
operator|)
name|arg1
argument_list|)
expr_stmt|;
comment|/* 		 * Validation based on sscop state 		 */
switch|switch
condition|(
name|uvp
operator|->
name|uv_lstate
condition|)
block|{
case|case
name|UVL_OUTCONN
case|:
case|case
name|UVL_OUTRESYN
case|:
case|case
name|UVL_READY
case|:
comment|/* 			 * Peer requesting connection termination 			 */
comment|/* 			 * Notify the user that the connection  			 * has been terminated 			 */
name|uvp
operator|->
name|uv_ustate
operator|=
name|UVU_RELEASED
expr_stmt|;
name|uvp
operator|->
name|uv_lstate
operator|=
name|UVL_IDLE
expr_stmt|;
name|STACK_CALL
argument_list|(
name|SSCF_UNI_RELEASE_IND
argument_list|,
name|uvp
operator|->
name|uv_upper
argument_list|,
name|uvp
operator|->
name|uv_toku
argument_list|,
name|cvp
argument_list|,
name|SSCOP_UU_NULL
argument_list|,
literal|0
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|sscf_uni_abort
argument_list|(
name|uvp
argument_list|,
literal|"sscf_uni: stack memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|UVL_TERM
case|:
comment|/* 			 * Ignoring everything 			 */
break|break;
case|case
name|UVL_INST
case|:
case|case
name|UVL_IDLE
case|:
case|case
name|UVL_INCONN
case|:
case|case
name|UVL_OUTDISC
case|:
case|case
name|UVL_INRESYN
case|:
case|case
name|UVL_RECOVERY
case|:
default|default:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sscf_uni_upper: cmd=0x%x, lstate=%d\n"
argument_list|,
name|cmd
argument_list|,
name|uvp
operator|->
name|uv_lstate
argument_list|)
expr_stmt|;
name|sscf_uni_abort
argument_list|(
name|uvp
argument_list|,
literal|"sscf_uni: sequence err\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SSCOP_RELEASE_CNF
case|:
comment|/* 		 * Validation based on sscop state 		 */
switch|switch
condition|(
name|uvp
operator|->
name|uv_lstate
condition|)
block|{
case|case
name|UVL_OUTDISC
case|:
comment|/* 			 * Peer acknowledging connection termination 			 */
comment|/* 			 * Notify the user that the connection  			 * termination is completed 			 */
name|uvp
operator|->
name|uv_ustate
operator|=
name|UVU_RELEASED
expr_stmt|;
name|uvp
operator|->
name|uv_lstate
operator|=
name|UVL_IDLE
expr_stmt|;
name|STACK_CALL
argument_list|(
name|SSCF_UNI_RELEASE_CNF
argument_list|,
name|uvp
operator|->
name|uv_upper
argument_list|,
name|uvp
operator|->
name|uv_toku
argument_list|,
name|cvp
argument_list|,
name|SSCOP_UU_NULL
argument_list|,
literal|0
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|sscf_uni_abort
argument_list|(
name|uvp
argument_list|,
literal|"sscf_uni: stack memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|UVL_TERM
case|:
comment|/* 			 * Ignoring everything 			 */
break|break;
case|case
name|UVL_INST
case|:
case|case
name|UVL_IDLE
case|:
case|case
name|UVL_OUTCONN
case|:
case|case
name|UVL_INCONN
case|:
case|case
name|UVL_OUTRESYN
case|:
case|case
name|UVL_INRESYN
case|:
case|case
name|UVL_RECOVERY
case|:
case|case
name|UVL_READY
case|:
default|default:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sscf_uni_upper: cmd=0x%x, lstate=%d\n"
argument_list|,
name|cmd
argument_list|,
name|uvp
operator|->
name|uv_lstate
argument_list|)
expr_stmt|;
name|sscf_uni_abort
argument_list|(
name|uvp
argument_list|,
literal|"sscf_uni: sequence err\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SSCOP_DATA_IND
case|:
ifdef|#
directive|ifdef
name|notdef
name|sscf_uni_pdu_print
argument_list|(
name|uvp
argument_list|,
operator|(
name|KBuffer
operator|*
operator|)
name|arg1
argument_list|,
literal|"DATA_IND"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * Validation based on sscop state 		 */
switch|switch
condition|(
name|uvp
operator|->
name|uv_lstate
condition|)
block|{
case|case
name|UVL_READY
case|:
comment|/* 			 * Incoming assured data from peer 			 */
comment|/* 			 * Pass the data up to the user 			 */
name|STACK_CALL
argument_list|(
name|SSCF_UNI_DATA_IND
argument_list|,
name|uvp
operator|->
name|uv_upper
argument_list|,
name|uvp
operator|->
name|uv_toku
argument_list|,
name|cvp
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|KB_FREEALL
argument_list|(
operator|(
name|KBuffer
operator|*
operator|)
name|arg1
argument_list|)
expr_stmt|;
name|sscf_uni_abort
argument_list|(
name|uvp
argument_list|,
literal|"sscf_uni: stack memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|UVL_TERM
case|:
comment|/* 			 * Ignoring everything 			 */
name|KB_FREEALL
argument_list|(
operator|(
name|KBuffer
operator|*
operator|)
name|arg1
argument_list|)
expr_stmt|;
break|break;
case|case
name|UVL_INST
case|:
case|case
name|UVL_IDLE
case|:
case|case
name|UVL_OUTCONN
case|:
case|case
name|UVL_INCONN
case|:
case|case
name|UVL_OUTDISC
case|:
case|case
name|UVL_OUTRESYN
case|:
case|case
name|UVL_INRESYN
case|:
case|case
name|UVL_RECOVERY
case|:
default|default:
name|KB_FREEALL
argument_list|(
operator|(
name|KBuffer
operator|*
operator|)
name|arg1
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sscf_uni_upper: cmd=0x%x, lstate=%d\n"
argument_list|,
name|cmd
argument_list|,
name|uvp
operator|->
name|uv_lstate
argument_list|)
expr_stmt|;
name|sscf_uni_abort
argument_list|(
name|uvp
argument_list|,
literal|"sscf_uni: sequence err\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SSCOP_RESYNC_IND
case|:
comment|/* 		 * We don't support SSCOP User-to-User data, so just 		 * get rid of any supplied to us 		 */
if|if
condition|(
name|arg1
operator|!=
name|SSCOP_UU_NULL
condition|)
name|KB_FREEALL
argument_list|(
operator|(
name|KBuffer
operator|*
operator|)
name|arg1
argument_list|)
expr_stmt|;
comment|/* 		 * Validation based on sscop state 		 */
switch|switch
condition|(
name|uvp
operator|->
name|uv_lstate
condition|)
block|{
case|case
name|UVL_READY
case|:
comment|/* 			 * Incoming connection resynchronization request 			 */
comment|/* 			 * Send resynch acknowledgement to sscop 			 */
name|STACK_CALL
argument_list|(
name|SSCOP_RESYNC_RSP
argument_list|,
name|uvp
operator|->
name|uv_lower
argument_list|,
name|uvp
operator|->
name|uv_tokl
argument_list|,
name|cvp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|sscf_uni_abort
argument_list|(
name|uvp
argument_list|,
literal|"sscf_uni: stack memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|uvp
operator|->
name|uv_vers
operator|!=
name|UNI_VERS_3_0
condition|)
block|{
comment|/* 				 * Notify the user that the connection  				 * has been resynced 				 */
name|STACK_CALL
argument_list|(
name|SSCF_UNI_ESTABLISH_IND
argument_list|,
name|uvp
operator|->
name|uv_upper
argument_list|,
name|uvp
operator|->
name|uv_toku
argument_list|,
name|cvp
argument_list|,
name|SSCOP_UU_NULL
argument_list|,
literal|0
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|sscf_uni_abort
argument_list|(
name|uvp
argument_list|,
literal|"sscf_uni: stack memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
break|break;
case|case
name|UVL_TERM
case|:
comment|/* 			 * Ignoring everything 			 */
break|break;
case|case
name|UVL_INST
case|:
case|case
name|UVL_IDLE
case|:
case|case
name|UVL_OUTCONN
case|:
case|case
name|UVL_INCONN
case|:
case|case
name|UVL_OUTDISC
case|:
case|case
name|UVL_OUTRESYN
case|:
case|case
name|UVL_INRESYN
case|:
case|case
name|UVL_RECOVERY
case|:
default|default:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sscf_uni_upper: cmd=0x%x, lstate=%d\n"
argument_list|,
name|cmd
argument_list|,
name|uvp
operator|->
name|uv_lstate
argument_list|)
expr_stmt|;
name|sscf_uni_abort
argument_list|(
name|uvp
argument_list|,
literal|"sscf_uni: sequence err\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SSCOP_RESYNC_CNF
case|:
comment|/* 		 * Not supported in version 3.0 		 */
if|if
condition|(
name|uvp
operator|->
name|uv_vers
operator|==
name|UNI_VERS_3_0
condition|)
block|{
name|sscf_uni_abort
argument_list|(
name|uvp
argument_list|,
literal|"sscf_uni: SSCOP_RESYNC_CNF in 3.0\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * Validation based on sscop state 		 */
switch|switch
condition|(
name|uvp
operator|->
name|uv_lstate
condition|)
block|{
case|case
name|UVL_OUTRESYN
case|:
comment|/* 			 * Peer acknowledging connection resynchronization 			 */
comment|/* 			 * Now notify the user that the connection  			 * has been resynced 			 */
name|uvp
operator|->
name|uv_ustate
operator|=
name|UVU_ACTIVE
expr_stmt|;
name|uvp
operator|->
name|uv_lstate
operator|=
name|UVL_READY
expr_stmt|;
name|STACK_CALL
argument_list|(
name|SSCF_UNI_ESTABLISH_CNF
argument_list|,
name|uvp
operator|->
name|uv_upper
argument_list|,
name|uvp
operator|->
name|uv_toku
argument_list|,
name|cvp
argument_list|,
name|SSCOP_UU_NULL
argument_list|,
literal|0
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|sscf_uni_abort
argument_list|(
name|uvp
argument_list|,
literal|"sscf_uni: stack memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|UVL_TERM
case|:
comment|/* 			 * Ignoring everything 			 */
break|break;
case|case
name|UVL_INST
case|:
case|case
name|UVL_IDLE
case|:
case|case
name|UVL_OUTCONN
case|:
case|case
name|UVL_INCONN
case|:
case|case
name|UVL_OUTDISC
case|:
case|case
name|UVL_INRESYN
case|:
case|case
name|UVL_RECOVERY
case|:
case|case
name|UVL_READY
case|:
default|default:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sscf_uni_upper: cmd=0x%x, lstate=%d\n"
argument_list|,
name|cmd
argument_list|,
name|uvp
operator|->
name|uv_lstate
argument_list|)
expr_stmt|;
name|sscf_uni_abort
argument_list|(
name|uvp
argument_list|,
literal|"sscf_uni: sequence err\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SSCOP_RECOVER_IND
case|:
comment|/* 		 * Not supported in version 3.0 		 */
if|if
condition|(
name|uvp
operator|->
name|uv_vers
operator|==
name|UNI_VERS_3_0
condition|)
block|{
name|sscf_uni_abort
argument_list|(
name|uvp
argument_list|,
literal|"sscf_uni: SSCOP_RECOVER_IND in 3.0\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * Validation based on sscop state 		 */
switch|switch
condition|(
name|uvp
operator|->
name|uv_lstate
condition|)
block|{
case|case
name|UVL_READY
case|:
comment|/* 			 * Recover connection due to internal problems 			 */
comment|/* 			 * Send recovery acknowledgement to sscop 			 */
name|STACK_CALL
argument_list|(
name|SSCOP_RECOVER_RSP
argument_list|,
name|uvp
operator|->
name|uv_lower
argument_list|,
name|uvp
operator|->
name|uv_tokl
argument_list|,
name|cvp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|sscf_uni_abort
argument_list|(
name|uvp
argument_list|,
literal|"sscf_uni: stack memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 			 * Now notify the user that the connection  			 * has been recovered 			 */
name|STACK_CALL
argument_list|(
name|SSCF_UNI_ESTABLISH_IND
argument_list|,
name|uvp
operator|->
name|uv_upper
argument_list|,
name|uvp
operator|->
name|uv_toku
argument_list|,
name|cvp
argument_list|,
name|SSCOP_UU_NULL
argument_list|,
literal|0
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|sscf_uni_abort
argument_list|(
name|uvp
argument_list|,
literal|"sscf_uni: stack memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|UVL_TERM
case|:
comment|/* 			 * Ignoring everything 			 */
break|break;
case|case
name|UVL_INST
case|:
case|case
name|UVL_IDLE
case|:
case|case
name|UVL_OUTCONN
case|:
case|case
name|UVL_INCONN
case|:
case|case
name|UVL_OUTDISC
case|:
case|case
name|UVL_OUTRESYN
case|:
case|case
name|UVL_INRESYN
case|:
case|case
name|UVL_RECOVERY
case|:
default|default:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sscf_uni_upper: cmd=0x%x, lstate=%d\n"
argument_list|,
name|cmd
argument_list|,
name|uvp
operator|->
name|uv_lstate
argument_list|)
expr_stmt|;
name|sscf_uni_abort
argument_list|(
name|uvp
argument_list|,
literal|"sscf_uni: sequence err\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SSCOP_UNITDATA_IND
case|:
ifdef|#
directive|ifdef
name|notdef
name|sscf_uni_pdu_print
argument_list|(
name|uvp
argument_list|,
operator|(
name|KBuffer
operator|*
operator|)
name|arg1
argument_list|,
literal|"UNITDATA_IND"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * Validation based on sscop state 		 */
switch|switch
condition|(
name|uvp
operator|->
name|uv_lstate
condition|)
block|{
case|case
name|UVL_IDLE
case|:
case|case
name|UVL_OUTCONN
case|:
case|case
name|UVL_INCONN
case|:
case|case
name|UVL_OUTDISC
case|:
case|case
name|UVL_OUTRESYN
case|:
case|case
name|UVL_INRESYN
case|:
case|case
name|UVL_RECOVERY
case|:
case|case
name|UVL_READY
case|:
comment|/* 			 * Incoming unassured data from peer 			 */
comment|/* 			 * Pass the data up to the user 			 */
name|STACK_CALL
argument_list|(
name|SSCF_UNI_UNITDATA_IND
argument_list|,
name|uvp
operator|->
name|uv_upper
argument_list|,
name|uvp
operator|->
name|uv_toku
argument_list|,
name|cvp
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|KB_FREEALL
argument_list|(
operator|(
name|KBuffer
operator|*
operator|)
name|arg1
argument_list|)
expr_stmt|;
name|sscf_uni_abort
argument_list|(
name|uvp
argument_list|,
literal|"sscf_uni: stack memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|UVL_TERM
case|:
comment|/* 			 * Ignoring everything 			 */
name|KB_FREEALL
argument_list|(
operator|(
name|KBuffer
operator|*
operator|)
name|arg1
argument_list|)
expr_stmt|;
break|break;
case|case
name|UVL_INST
case|:
default|default:
name|KB_FREEALL
argument_list|(
operator|(
name|KBuffer
operator|*
operator|)
name|arg1
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sscf_uni_upper: cmd=0x%x, lstate=%d\n"
argument_list|,
name|cmd
argument_list|,
name|uvp
operator|->
name|uv_lstate
argument_list|)
expr_stmt|;
name|sscf_uni_abort
argument_list|(
name|uvp
argument_list|,
literal|"sscf_uni: sequence err\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SSCOP_RETRIEVE_IND
case|:
case|case
name|SSCOP_RETRIEVECMP_IND
case|:
comment|/* 		 * Not supported 		 */
default|default:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sscf_uni_upper: unknown cmd 0x%x, uvp=%p\n"
argument_list|,
name|cmd
argument_list|,
name|uvp
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

end_unit

