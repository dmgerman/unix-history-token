begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * ===================================  * HARP  |  Host ATM Research Platform  * ===================================  *  *  * This Host ATM Research Platform ("HARP") file (the "Software") is  * made available by Network Computing Services, Inc. ("NetworkCS")  * "AS IS".  NetworkCS does not provide maintenance, improvements or  * support of any kind.  *  * NETWORKCS MAKES NO WARRANTIES OR REPRESENTATIONS, EXPRESS OR IMPLIED,  * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE, AS TO ANY ELEMENT OF THE  * SOFTWARE OR ANY SUPPORT PROVIDED IN CONNECTION WITH THIS SOFTWARE.  * In no event shall NetworkCS be responsible for any damages, including  * but not limited to consequential damages, arising from or relating to  * any use of the Software or related support.  *  * Copyright 1994-1998 Network Computing Services, Inc.  *  * Copies of this Software may be made, however, the above copyright  * notice must be reproduced on all copies.  *  *	@(#) $FreeBSD$  *  */
end_comment

begin_comment
comment|/*  * ATM Forum UNI 3.0/3.1 Signalling Manager  * ----------------------------------------  *  * Message buffer handling routines  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netatm/port.h>
end_include

begin_include
include|#
directive|include
file|<netatm/queue.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sys.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sap.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_cm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_if.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_vc.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sigmgr.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_stack.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_var.h>
end_include

begin_include
include|#
directive|include
file|<netatm/uni/unisig_var.h>
end_include

begin_include
include|#
directive|include
file|<netatm/uni/unisig_mbuf.h>
end_include

begin_include
include|#
directive|include
file|<netatm/uni/unisig_msg.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"@(#) $FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Initialize a unisig formatting structure  *  * Arguments:  *	usf	pointer to a unisig formatting structure  *	usp	pointer to a unisig protocol instance  *	buf	pointer to a buffer chain (decode only)  *	op	operation code (encode or decode)  *	headroom headroom to leave in first buffer  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
name|int
name|usf_init
parameter_list|(
name|usf
parameter_list|,
name|usp
parameter_list|,
name|buf
parameter_list|,
name|op
parameter_list|,
name|headroom
parameter_list|)
name|struct
name|usfmt
modifier|*
name|usf
decl_stmt|;
name|struct
name|unisig
modifier|*
name|usp
decl_stmt|;
name|KBuffer
modifier|*
name|buf
decl_stmt|;
name|int
name|op
decl_stmt|;
name|int
name|headroom
decl_stmt|;
block|{
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|ATM_DEBUG3
argument_list|(
literal|"usf_init: usf=%p, buf=%p, op=%d\n"
argument_list|,
name|usf
argument_list|,
name|buf
argument_list|,
name|op
argument_list|)
expr_stmt|;
comment|/* 	 * Check parameters 	 */
if|if
condition|(
operator|!
name|usf
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|USF_ENCODE
case|:
comment|/* 		 * Get a buffer 		 */
name|KB_ALLOCPKT
argument_list|(
name|m
argument_list|,
name|USF_MIN_ALLOC
argument_list|,
name|KB_F_NOWAIT
argument_list|,
name|KB_T_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|KB_LEN
argument_list|(
name|m
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|headroom
operator|<
name|KB_BFRLEN
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|KB_HEADSET
argument_list|(
name|m
argument_list|,
name|headroom
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|USF_DECODE
case|:
comment|/* 		 * Verify buffer address 		 */
if|if
condition|(
operator|!
name|buf
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|m
operator|=
name|buf
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * Save parameters in formatting structure 	 */
name|usf
operator|->
name|usf_m_addr
operator|=
name|m
expr_stmt|;
name|usf
operator|->
name|usf_m_base
operator|=
name|m
expr_stmt|;
name|usf
operator|->
name|usf_loc
operator|=
literal|0
expr_stmt|;
name|usf
operator|->
name|usf_op
operator|=
name|op
expr_stmt|;
name|usf
operator|->
name|usf_sig
operator|=
name|usp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get or put the next byte of a signalling message  *  * Arguments:  *	usf	pointer to a unisig formatting structure  *	c	pointer to the byte to send from or receive into  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
name|int
name|usf_byte
parameter_list|(
name|usf
parameter_list|,
name|c
parameter_list|)
name|struct
name|usfmt
modifier|*
name|usf
decl_stmt|;
name|u_char
modifier|*
name|c
decl_stmt|;
block|{
name|u_char
modifier|*
name|mp
decl_stmt|;
name|KBuffer
modifier|*
name|m
init|=
name|usf
operator|->
name|usf_m_addr
decl_stmt|,
modifier|*
name|m1
decl_stmt|;
name|int
name|space
decl_stmt|;
switch|switch
condition|(
name|usf
operator|->
name|usf_op
condition|)
block|{
case|case
name|USF_DECODE
case|:
comment|/* 		 * Make sure we're not past the end of the buffer 		 * (allowing for zero-length buffers) 		 */
while|while
condition|(
name|usf
operator|->
name|usf_loc
operator|>=
name|KB_LEN
argument_list|(
name|m
argument_list|)
condition|)
block|{
if|if
condition|(
name|KB_NEXT
argument_list|(
name|usf
operator|->
name|usf_m_addr
argument_list|)
condition|)
block|{
name|usf
operator|->
name|usf_m_addr
operator|=
name|m
operator|=
name|KB_NEXT
argument_list|(
name|usf
operator|->
name|usf_m_addr
argument_list|)
expr_stmt|;
name|usf
operator|->
name|usf_loc
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|EMSGSIZE
operator|)
return|;
block|}
block|}
comment|/* 		 * Get the data from the buffer 		 */
name|KB_DATASTART
argument_list|(
name|m
argument_list|,
name|mp
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
operator|*
name|c
operator|=
name|mp
index|[
name|usf
operator|->
name|usf_loc
index|]
expr_stmt|;
name|usf
operator|->
name|usf_loc
operator|++
expr_stmt|;
break|break;
case|case
name|USF_ENCODE
case|:
comment|/* 		 * If the current buffer is full, get another 		 */
name|KB_TAILROOM
argument_list|(
name|m
argument_list|,
name|space
argument_list|)
expr_stmt|;
if|if
condition|(
name|space
operator|==
literal|0
condition|)
block|{
name|KB_ALLOC
argument_list|(
name|m1
argument_list|,
name|USF_MIN_ALLOC
argument_list|,
name|KB_F_NOWAIT
argument_list|,
name|KB_T_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m1
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|KB_LEN
argument_list|(
name|m1
argument_list|)
operator|=
literal|0
expr_stmt|;
name|KB_LINK
argument_list|(
name|m1
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|usf
operator|->
name|usf_m_addr
operator|=
name|m
operator|=
name|m1
expr_stmt|;
name|usf
operator|->
name|usf_loc
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * Put the data into the buffer 		 */
name|KB_DATASTART
argument_list|(
name|m
argument_list|,
name|mp
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
name|mp
index|[
name|usf
operator|->
name|usf_loc
index|]
operator|=
operator|*
name|c
expr_stmt|;
name|KB_TAILADJ
argument_list|(
name|m
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|usf
operator|->
name|usf_loc
operator|++
expr_stmt|;
break|break;
default|default:
comment|/* 		 * Invalid operation code 		 */
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get or put a short integer  *  * Arguments:  *	usf	pointer to a unisig formatting structure  *	s	pointer to a short to send from or receive into  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
name|int
name|usf_short
parameter_list|(
name|usf
parameter_list|,
name|s
parameter_list|)
name|struct
name|usfmt
modifier|*
name|usf
decl_stmt|;
name|u_short
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|rc
decl_stmt|;
union|union
block|{
name|u_short
name|value
decl_stmt|;
name|u_char
name|b
index|[
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
index|]
decl_stmt|;
block|}
name|tval
union|;
name|tval
operator|.
name|value
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|usf
operator|->
name|usf_op
operator|==
name|USF_ENCODE
condition|)
name|tval
operator|.
name|value
operator|=
name|htons
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|tval
operator|.
name|b
index|[
literal|0
index|]
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
operator|(
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|tval
operator|.
name|b
index|[
literal|1
index|]
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
name|usf
operator|->
name|usf_op
operator|==
name|USF_DECODE
condition|)
operator|*
name|s
operator|=
name|ntohs
argument_list|(
name|tval
operator|.
name|value
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get or put a 3-byte integer  *  * Arguments:  *	usf	pointer to a unisig formatting structure  *	i	pointer to an integer to send from or receive into  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
name|int
name|usf_int3
parameter_list|(
name|usf
parameter_list|,
name|i
parameter_list|)
name|struct
name|usfmt
modifier|*
name|usf
decl_stmt|;
name|u_int
modifier|*
name|i
decl_stmt|;
block|{
name|int
name|j
decl_stmt|,
name|rc
decl_stmt|;
union|union
block|{
name|u_int
name|value
decl_stmt|;
name|u_char
name|b
index|[
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
index|]
decl_stmt|;
block|}
name|tval
union|;
name|tval
operator|.
name|value
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|usf
operator|->
name|usf_op
operator|==
name|USF_ENCODE
condition|)
name|tval
operator|.
name|value
operator|=
name|htonl
argument_list|(
operator|*
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|3
condition|;
name|j
operator|++
control|)
block|{
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|tval
operator|.
name|b
index|[
name|j
operator|+
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
operator|-
literal|3
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
block|}
if|if
condition|(
name|usf
operator|->
name|usf_op
operator|==
name|USF_DECODE
condition|)
operator|*
name|i
operator|=
name|ntohl
argument_list|(
name|tval
operator|.
name|value
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get or put an integer  *  * Arguments:  *	usf	pointer to a unisig formatting structure  *	i	pointer to an integer to send from or receive into  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
name|int
name|usf_int
parameter_list|(
name|usf
parameter_list|,
name|i
parameter_list|)
name|struct
name|usfmt
modifier|*
name|usf
decl_stmt|;
name|u_int
modifier|*
name|i
decl_stmt|;
block|{
name|int
name|j
decl_stmt|,
name|rc
decl_stmt|;
union|union
block|{
name|u_int
name|value
decl_stmt|;
name|u_char
name|b
index|[
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
index|]
decl_stmt|;
block|}
name|tval
union|;
if|if
condition|(
name|usf
operator|->
name|usf_op
operator|==
name|USF_ENCODE
condition|)
name|tval
operator|.
name|value
operator|=
name|htonl
argument_list|(
operator|*
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
block|{
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|tval
operator|.
name|b
index|[
name|j
operator|+
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
operator|-
literal|4
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
block|}
if|if
condition|(
name|usf
operator|->
name|usf_op
operator|==
name|USF_DECODE
condition|)
operator|*
name|i
operator|=
name|ntohl
argument_list|(
name|tval
operator|.
name|value
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get or put an extented field  *  * An extented field consists of a string of bytes.  All but the last  * byte of the field has the high-order bit set to zero.  When decoding,  * this routine will read bytes until either the input is exhausted or  * a byte with a high-order one is found.  Whe encoding, it will take an  * unsigned integer and write until the highest-order one bit has been  * written.  *  * Arguments:  *	usf	pointer to a unisig formatting structure  *	i	pointer to an integer to send from or receive into  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
name|int
name|usf_ext
parameter_list|(
name|usf
parameter_list|,
name|i
parameter_list|)
name|struct
name|usfmt
modifier|*
name|usf
decl_stmt|;
name|u_int
modifier|*
name|i
decl_stmt|;
block|{
name|int
name|j
decl_stmt|,
name|rc
decl_stmt|;
name|u_char
name|c
decl_stmt|,
name|buff
index|[
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
operator|+
literal|1
index|]
decl_stmt|;
name|u_int
name|val
decl_stmt|;
union|union
block|{
name|u_int
name|value
decl_stmt|;
name|u_char
name|b
index|[
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
index|]
decl_stmt|;
block|}
name|tval
union|;
switch|switch
condition|(
name|usf
operator|->
name|usf_op
condition|)
block|{
case|case
name|USF_ENCODE
case|:
name|val
operator|=
operator|*
name|i
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|val
condition|)
block|{
name|tval
operator|.
name|value
operator|=
name|htonl
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|buff
index|[
name|j
index|]
operator|=
name|tval
operator|.
name|b
index|[
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
operator|-
literal|1
index|]
operator|&
name|UNI_IE_EXT_MASK
expr_stmt|;
name|val
operator|>>=
literal|7
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
name|j
operator|--
expr_stmt|;
name|buff
index|[
literal|0
index|]
operator||=
name|UNI_IE_EXT_BIT
expr_stmt|;
for|for
control|(
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|buff
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
block|}
break|break;
case|case
name|USF_DECODE
case|:
name|c
operator|=
literal|0
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|c
operator|&
name|UNI_IE_EXT_BIT
operator|)
condition|)
block|{
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|val
operator|=
operator|(
name|val
operator|<<
literal|7
operator|)
operator|+
operator|(
name|c
operator|&
name|UNI_IE_EXT_MASK
operator|)
expr_stmt|;
block|}
operator|*
name|i
operator|=
name|val
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Count the bytes remaining to be decoded  *  * Arguments:  *	usf	pointer to a unisig formatting structure  *  * Returns:  *	int	the number of bytes in the buffer chain remaining to  *		be decoded  *  */
end_comment

begin_function
name|int
name|usf_count
parameter_list|(
name|usf
parameter_list|)
name|struct
name|usfmt
modifier|*
name|usf
decl_stmt|;
block|{
name|int
name|count
decl_stmt|;
name|KBuffer
modifier|*
name|m
init|=
name|usf
operator|->
name|usf_m_addr
decl_stmt|;
comment|/* 	 * Return zero if we're not decoding 	 */
if|if
condition|(
name|usf
operator|->
name|usf_op
operator|!=
name|USF_DECODE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Calculate the length of data remaining in the current buffer 	 */
name|count
operator|=
name|KB_LEN
argument_list|(
name|m
argument_list|)
operator|-
name|usf
operator|->
name|usf_loc
expr_stmt|;
comment|/* 	 * Loop through any remaining buffers, adding in their lengths 	 */
while|while
condition|(
name|KB_NEXT
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|m
operator|=
name|KB_NEXT
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|count
operator|+=
name|KB_LEN
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get or put the next byte of a signalling message and return  * the byte's buffer address   *  * Arguments:  *	usf	pointer to a unisig formatting structure  *	c	pointer to the byte to send from or receive into  *	bp	address to store the byte's buffer address  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
name|int
name|usf_byte_mark
parameter_list|(
name|usf
parameter_list|,
name|c
parameter_list|,
name|bp
parameter_list|)
name|struct
name|usfmt
modifier|*
name|usf
decl_stmt|;
name|u_char
modifier|*
name|c
decl_stmt|;
name|u_char
modifier|*
modifier|*
name|bp
decl_stmt|;
block|{
name|u_char
modifier|*
name|mp
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/* 	 * First, get/put the data byte 	 */
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
comment|/* 		 * Error encountered 		 */
operator|*
name|bp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
comment|/* 	 * Now return the buffer address of that byte 	 */
name|KB_DATASTART
argument_list|(
name|usf
operator|->
name|usf_m_addr
argument_list|,
name|mp
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
operator|*
name|bp
operator|=
operator|&
name|mp
index|[
name|usf
operator|->
name|usf_loc
operator|-
literal|1
index|]
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

