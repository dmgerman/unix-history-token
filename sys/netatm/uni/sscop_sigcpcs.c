begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * ===================================  * HARP  |  Host ATM Research Platform  * ===================================  *  *  * This Host ATM Research Platform ("HARP") file (the "Software") is  * made available by Network Computing Services, Inc. ("NetworkCS")  * "AS IS".  NetworkCS does not provide maintenance, improvements or  * support of any kind.  *  * NETWORKCS MAKES NO WARRANTIES OR REPRESENTATIONS, EXPRESS OR IMPLIED,  * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE, AS TO ANY ELEMENT OF THE  * SOFTWARE OR ANY SUPPORT PROVIDED IN CONNECTION WITH THIS SOFTWARE.  * In no event shall NetworkCS be responsible for any damages, including  * but not limited to consequential damages, arising from or relating to  * any use of the Software or related support.  *  * Copyright 1994-1998 Network Computing Services, Inc.  *  * Copies of this Software may be made, however, the above copyright  * notice must be reproduced on all copies.  *  *	@(#) $FreeBSD$  *  */
end_comment

begin_comment
comment|/*  * ATM Forum UNI Support  * ---------------------  *  * SSCOP Common - Process CPCS-signals (SSCOP PDUs)  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netatm/port.h>
end_include

begin_include
include|#
directive|include
file|<netatm/queue.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sys.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sap.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_cm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_if.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_stack.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_var.h>
end_include

begin_include
include|#
directive|include
file|<netatm/uni/sscop.h>
end_include

begin_include
include|#
directive|include
file|<netatm/uni/sscop_misc.h>
end_include

begin_include
include|#
directive|include
file|<netatm/uni/sscop_pdu.h>
end_include

begin_include
include|#
directive|include
file|<netatm/uni/sscop_var.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"@(#) $FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * No-op Processor  *  * Arguments:  *	sop	pointer to sscop connection block  *	m	pointer to PDU buffer (without trailer)  *	trlr	pointer to PDU trailer  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|sscop_noop
parameter_list|(
name|sop
parameter_list|,
name|m
parameter_list|,
name|trlr
parameter_list|)
name|struct
name|sscop
modifier|*
name|sop
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|caddr_t
name|trlr
decl_stmt|;
block|{
comment|/* 	 * Just free PDU 	 */
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * BGN PDU / SOS_IDLE Processor  *  * Arguments:  *	sop	pointer to sscop connection block  *	m	pointer to PDU buffer (without trailer)  *	trlr	pointer to PDU trailer  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|sscop_bgn_idle
parameter_list|(
name|sop
parameter_list|,
name|m
parameter_list|,
name|trlr
parameter_list|)
name|struct
name|sscop
modifier|*
name|sop
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|caddr_t
name|trlr
decl_stmt|;
block|{
name|struct
name|bgn_pdu
modifier|*
name|bp
init|=
operator|(
expr|struct
name|bgn_pdu
operator|*
operator|)
name|trlr
decl_stmt|;
name|int
name|err
decl_stmt|,
name|source
decl_stmt|;
if|if
condition|(
name|sop
operator|->
name|so_vers
operator|==
name|SSCOP_VERS_Q2110
condition|)
block|{
comment|/* 		 * "Power-up Robustness" option 		 * 		 * Accept BGN regardless of BGN.N(SQ) 		 */
name|sop
operator|->
name|so_rcvconn
operator|=
name|bp
operator|->
name|bgn_nsq
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * If retransmitted BGN, reject it 		 */
if|if
condition|(
name|sscop_is_rexmit
argument_list|(
name|sop
argument_list|,
name|bp
operator|->
name|bgn_nsq
argument_list|)
condition|)
block|{
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sscop_send_bgrej
argument_list|(
name|sop
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|sop
operator|->
name|so_vers
operator|==
name|SSCOP_VERS_QSAAL
condition|)
block|{
comment|/* 		 * Get Source value 		 */
if|if
condition|(
name|bp
operator|->
name|bgn_type
operator|&
name|PT_SOURCE_SSCOP
condition|)
name|source
operator|=
name|SSCOP_SOURCE_SSCOP
expr_stmt|;
else|else
name|source
operator|=
name|SSCOP_SOURCE_USER
expr_stmt|;
comment|/* 		 * Reset receiver state variables 		 */
name|qsaal1_reset_rcvr
argument_list|(
name|sop
argument_list|)
expr_stmt|;
block|}
else|else
name|source
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Set initial transmit window 	 */
name|SEQ_SET
argument_list|(
name|sop
operator|->
name|so_sendmax
argument_list|,
name|ntohl
argument_list|(
name|bp
operator|->
name|bgn_nmr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Pass connection request up to user 	 */
name|STACK_CALL
argument_list|(
name|SSCOP_ESTABLISH_IND
argument_list|,
name|sop
operator|->
name|so_upper
argument_list|,
name|sop
operator|->
name|so_toku
argument_list|,
name|sop
operator|->
name|so_connvc
argument_list|,
operator|(
name|intptr_t
operator|)
name|m
argument_list|,
name|source
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|sscop_abort
argument_list|(
name|sop
argument_list|,
literal|"stack memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Wait for user's response 	 */
name|sop
operator|->
name|so_state
operator|=
name|SOS_INCONN
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * BGN PDU / SOS_OUTDISC Processor  *  * Arguments:  *	sop	pointer to sscop connection block  *	m	pointer to PDU buffer (without trailer)  *	trlr	pointer to PDU trailer  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|sscop_bgn_outdisc
parameter_list|(
name|sop
parameter_list|,
name|m
parameter_list|,
name|trlr
parameter_list|)
name|struct
name|sscop
modifier|*
name|sop
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|caddr_t
name|trlr
decl_stmt|;
block|{
name|struct
name|bgn_pdu
modifier|*
name|bp
init|=
operator|(
expr|struct
name|bgn_pdu
operator|*
operator|)
name|trlr
decl_stmt|;
name|int
name|err
decl_stmt|,
name|source
decl_stmt|;
comment|/* 	 * If retransmitted BGN, ACK it and send new END 	 */
if|if
condition|(
name|sscop_is_rexmit
argument_list|(
name|sop
argument_list|,
name|bp
operator|->
name|bgn_nsq
argument_list|)
condition|)
block|{
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sscop_send_bgak
argument_list|(
name|sop
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sscop_send_end
argument_list|(
name|sop
argument_list|,
name|SSCOP_SOURCE_LAST
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Stop retransmit timer 	 */
name|sop
operator|->
name|so_timer
index|[
name|SSCOP_T_CC
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Initialize transmit window 	 */
name|SEQ_SET
argument_list|(
name|sop
operator|->
name|so_sendmax
argument_list|,
name|ntohl
argument_list|(
name|bp
operator|->
name|bgn_nmr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Notify user of connection termination 	 */
name|STACK_CALL
argument_list|(
name|SSCOP_RELEASE_CNF
argument_list|,
name|sop
operator|->
name|so_upper
argument_list|,
name|sop
operator|->
name|so_toku
argument_list|,
name|sop
operator|->
name|so_connvc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|sscop_abort
argument_list|(
name|sop
argument_list|,
literal|"stack memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sop
operator|->
name|so_vers
operator|==
name|SSCOP_VERS_QSAAL
condition|)
block|{
comment|/* 		 * Get Source value 		 */
if|if
condition|(
name|bp
operator|->
name|bgn_type
operator|&
name|PT_SOURCE_SSCOP
condition|)
name|source
operator|=
name|SSCOP_SOURCE_SSCOP
expr_stmt|;
else|else
name|source
operator|=
name|SSCOP_SOURCE_USER
expr_stmt|;
comment|/* 		 * Reset receiver variables 		 */
name|qsaal1_reset_rcvr
argument_list|(
name|sop
argument_list|)
expr_stmt|;
block|}
else|else
name|source
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Tell user about incoming connection 	 */
name|STACK_CALL
argument_list|(
name|SSCOP_ESTABLISH_IND
argument_list|,
name|sop
operator|->
name|so_upper
argument_list|,
name|sop
operator|->
name|so_toku
argument_list|,
name|sop
operator|->
name|so_connvc
argument_list|,
operator|(
name|intptr_t
operator|)
name|m
argument_list|,
name|source
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|sscop_abort
argument_list|(
name|sop
argument_list|,
literal|"stack memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Wait for user's response 	 */
name|sop
operator|->
name|so_state
operator|=
name|SOS_INCONN
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * BGN PDU / SOS_OUTRESYN Processor  *  * Arguments:  *	sop	pointer to sscop connection block  *	m	pointer to PDU buffer (without trailer)  *	trlr	pointer to PDU trailer  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|sscop_bgn_outresyn
parameter_list|(
name|sop
parameter_list|,
name|m
parameter_list|,
name|trlr
parameter_list|)
name|struct
name|sscop
modifier|*
name|sop
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|caddr_t
name|trlr
decl_stmt|;
block|{
name|struct
name|bgn_pdu
modifier|*
name|bp
init|=
operator|(
expr|struct
name|bgn_pdu
operator|*
operator|)
name|trlr
decl_stmt|;
name|int
name|err
decl_stmt|,
name|source
decl_stmt|;
comment|/* 	 * If retransmitted BGN, ACK it and send new RS 	 */
if|if
condition|(
name|sscop_is_rexmit
argument_list|(
name|sop
argument_list|,
name|bp
operator|->
name|bgn_nsq
argument_list|)
condition|)
block|{
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sscop_send_bgak
argument_list|(
name|sop
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sscop_send_rs
argument_list|(
name|sop
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Stop retransmit timer 	 */
name|sop
operator|->
name|so_timer
index|[
name|SSCOP_T_CC
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Initialize transmit window 	 */
name|SEQ_SET
argument_list|(
name|sop
operator|->
name|so_sendmax
argument_list|,
name|ntohl
argument_list|(
name|bp
operator|->
name|bgn_nmr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sop
operator|->
name|so_vers
operator|==
name|SSCOP_VERS_QSAAL
condition|)
block|{
comment|/* 		 * Get (possible) Source value 		 */
if|if
condition|(
name|bp
operator|->
name|bgn_type
operator|&
name|PT_SOURCE_SSCOP
condition|)
name|source
operator|=
name|SSCOP_SOURCE_SSCOP
expr_stmt|;
else|else
name|source
operator|=
name|SSCOP_SOURCE_USER
expr_stmt|;
comment|/* 		 * Reset receiver variables 		 */
name|qsaal1_reset_rcvr
argument_list|(
name|sop
argument_list|)
expr_stmt|;
block|}
else|else
name|source
operator|=
name|SSCOP_SOURCE_USER
expr_stmt|;
comment|/* 	 * Notify user of connection termination 	 */
name|STACK_CALL
argument_list|(
name|SSCOP_RELEASE_IND
argument_list|,
name|sop
operator|->
name|so_upper
argument_list|,
name|sop
operator|->
name|so_toku
argument_list|,
name|sop
operator|->
name|so_connvc
argument_list|,
name|SSCOP_UU_NULL
argument_list|,
name|source
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|sscop_abort
argument_list|(
name|sop
argument_list|,
literal|"stack memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Now tell user of a "new" incoming connection 	 */
name|STACK_CALL
argument_list|(
name|SSCOP_ESTABLISH_IND
argument_list|,
name|sop
operator|->
name|so_upper
argument_list|,
name|sop
operator|->
name|so_toku
argument_list|,
name|sop
operator|->
name|so_connvc
argument_list|,
operator|(
name|intptr_t
operator|)
name|m
argument_list|,
name|source
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|sscop_abort
argument_list|(
name|sop
argument_list|,
literal|"stack memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Wait for user's response 	 */
name|sop
operator|->
name|so_state
operator|=
name|SOS_INCONN
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * BGN PDU / SOS_INRESYN Processor  *  * Arguments:  *	sop	pointer to sscop connection block  *	m	pointer to PDU buffer (without trailer)  *	trlr	pointer to PDU trailer  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|sscop_bgn_inresyn
parameter_list|(
name|sop
parameter_list|,
name|m
parameter_list|,
name|trlr
parameter_list|)
name|struct
name|sscop
modifier|*
name|sop
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|caddr_t
name|trlr
decl_stmt|;
block|{
name|struct
name|bgn_pdu
modifier|*
name|bp
init|=
operator|(
expr|struct
name|bgn_pdu
operator|*
operator|)
name|trlr
decl_stmt|;
name|int
name|err
decl_stmt|,
name|source
decl_stmt|;
comment|/* 	 * If retransmitted BGN, oops 	 */
if|if
condition|(
name|sscop_is_rexmit
argument_list|(
name|sop
argument_list|,
name|bp
operator|->
name|bgn_nsq
argument_list|)
condition|)
block|{
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|sscop_maa_error
argument_list|(
name|sop
argument_list|,
literal|'B'
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Stop data transfer timers 	 */
name|sop
operator|->
name|so_timer
index|[
name|SSCOP_T_POLL
index|]
operator|=
literal|0
expr_stmt|;
name|sop
operator|->
name|so_timer
index|[
name|SSCOP_T_NORESP
index|]
operator|=
literal|0
expr_stmt|;
name|sop
operator|->
name|so_timer
index|[
name|SSCOP_T_IDLE
index|]
operator|=
literal|0
expr_stmt|;
name|sop
operator|->
name|so_flags
operator|&=
operator|~
name|SOF_KEEPALIVE
expr_stmt|;
comment|/* 	 * Initialize transmit window 	 */
name|SEQ_SET
argument_list|(
name|sop
operator|->
name|so_sendmax
argument_list|,
name|ntohl
argument_list|(
name|bp
operator|->
name|bgn_nmr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sop
operator|->
name|so_vers
operator|==
name|SSCOP_VERS_QSAAL
condition|)
block|{
comment|/* 		 * Get (possible) Source value 		 */
if|if
condition|(
name|bp
operator|->
name|bgn_type
operator|&
name|PT_SOURCE_SSCOP
condition|)
name|source
operator|=
name|SSCOP_SOURCE_SSCOP
expr_stmt|;
else|else
name|source
operator|=
name|SSCOP_SOURCE_USER
expr_stmt|;
comment|/* 		 * Reset receiver variables 		 */
name|qsaal1_reset_rcvr
argument_list|(
name|sop
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Stop possible retransmit timer 		 */
name|sop
operator|->
name|so_timer
index|[
name|SSCOP_T_CC
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Drain receiver queues 		 */
name|sscop_rcvr_drain
argument_list|(
name|sop
argument_list|)
expr_stmt|;
comment|/* 		 * Tell user current connection has been released 		 */
name|STACK_CALL
argument_list|(
name|SSCOP_RELEASE_IND
argument_list|,
name|sop
operator|->
name|so_upper
argument_list|,
name|sop
operator|->
name|so_toku
argument_list|,
name|sop
operator|->
name|so_connvc
argument_list|,
name|SSCOP_UU_NULL
argument_list|,
name|SSCOP_SOURCE_USER
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|sscop_abort
argument_list|(
name|sop
argument_list|,
literal|"stack memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|source
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Tell user of incoming connection 	 */
name|STACK_CALL
argument_list|(
name|SSCOP_ESTABLISH_IND
argument_list|,
name|sop
operator|->
name|so_upper
argument_list|,
name|sop
operator|->
name|so_toku
argument_list|,
name|sop
operator|->
name|so_connvc
argument_list|,
operator|(
name|intptr_t
operator|)
name|m
argument_list|,
name|source
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|sscop_abort
argument_list|(
name|sop
argument_list|,
literal|"stack memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Wait for user's response 	 */
name|sop
operator|->
name|so_state
operator|=
name|SOS_INCONN
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * BGAK PDU / Protocol Error  *  * Arguments:  *	sop	pointer to sscop connection block  *	m	pointer to PDU buffer (without trailer)  *	trlr	pointer to PDU trailer  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|sscop_bgak_error
parameter_list|(
name|sop
parameter_list|,
name|m
parameter_list|,
name|trlr
parameter_list|)
name|struct
name|sscop
modifier|*
name|sop
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|caddr_t
name|trlr
decl_stmt|;
block|{
comment|/* 	 * Record error condition 	 */
name|sscop_maa_error
argument_list|(
name|sop
argument_list|,
literal|'C'
argument_list|)
expr_stmt|;
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * BGAK PDU / SOS_IDLE Processor  *  * Arguments:  *	sop	pointer to sscop connection block  *	m	pointer to PDU buffer (without trailer)  *	trlr	pointer to PDU trailer  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|sscop_bgak_idle
parameter_list|(
name|sop
parameter_list|,
name|m
parameter_list|,
name|trlr
parameter_list|)
name|struct
name|sscop
modifier|*
name|sop
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|caddr_t
name|trlr
decl_stmt|;
block|{
comment|/* 	 * Record error condition 	 */
name|sscop_bgak_error
argument_list|(
name|sop
argument_list|,
name|m
argument_list|,
name|trlr
argument_list|)
expr_stmt|;
comment|/* 	 * Return an END to peer 	 */
operator|(
name|void
operator|)
name|sscop_send_end
argument_list|(
name|sop
argument_list|,
name|SSCOP_SOURCE_SSCOP
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * BGAK PDU / SOS_OUTCONN Processor  *  * Arguments:  *	sop	pointer to sscop connection block  *	m	pointer to PDU buffer (without trailer)  *	trlr	pointer to PDU trailer  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|sscop_bgak_outconn
parameter_list|(
name|sop
parameter_list|,
name|m
parameter_list|,
name|trlr
parameter_list|)
name|struct
name|sscop
modifier|*
name|sop
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|caddr_t
name|trlr
decl_stmt|;
block|{
name|struct
name|bgak_pdu
modifier|*
name|bp
init|=
operator|(
expr|struct
name|bgak_pdu
operator|*
operator|)
name|trlr
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* 	 * Stop retransmit timer 	 */
name|sop
operator|->
name|so_timer
index|[
name|SSCOP_T_CC
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Initialize transmit window 	 */
name|SEQ_SET
argument_list|(
name|sop
operator|->
name|so_sendmax
argument_list|,
name|ntohl
argument_list|(
name|bp
operator|->
name|bgak_nmr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Notify user of connection establishment 	 */
if|if
condition|(
name|sop
operator|->
name|so_flags
operator|&
name|SOF_REESTAB
condition|)
block|{
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|STACK_CALL
argument_list|(
name|SSCOP_ESTABLISH_IND
argument_list|,
name|sop
operator|->
name|so_upper
argument_list|,
name|sop
operator|->
name|so_toku
argument_list|,
name|sop
operator|->
name|so_connvc
argument_list|,
name|SSCOP_UU_NULL
argument_list|,
name|SSCOP_SOURCE_SSCOP
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|sscop_abort
argument_list|(
name|sop
argument_list|,
literal|"stack memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|sop
operator|->
name|so_flags
operator|&=
operator|~
name|SOF_REESTAB
expr_stmt|;
block|}
else|else
block|{
name|STACK_CALL
argument_list|(
name|SSCOP_ESTABLISH_CNF
argument_list|,
name|sop
operator|->
name|so_upper
argument_list|,
name|sop
operator|->
name|so_toku
argument_list|,
name|sop
operator|->
name|so_connvc
argument_list|,
operator|(
name|intptr_t
operator|)
name|m
argument_list|,
literal|0
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|sscop_abort
argument_list|(
name|sop
argument_list|,
literal|"stack memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|sop
operator|->
name|so_vers
operator|==
name|SSCOP_VERS_QSAAL
condition|)
block|{
comment|/* 		 * Reset receiver variables 		 */
name|qsaal1_reset_rcvr
argument_list|(
name|sop
argument_list|)
expr_stmt|;
comment|/* 		 * Start polling timer 		 */
name|sscop_set_poll
argument_list|(
name|sop
argument_list|)
expr_stmt|;
comment|/* 		 * Start lost poll/stat timer 		 */
name|sop
operator|->
name|so_timer
index|[
name|SSCOP_T_NORESP
index|]
operator|=
name|sop
operator|->
name|so_parm
operator|.
name|sp_timeresp
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Initialize state variables 		 */
name|q2110_init_state
argument_list|(
name|sop
argument_list|)
expr_stmt|;
comment|/* 		 * Start data transfer timers 		 */
name|sop
operator|->
name|so_timer
index|[
name|SSCOP_T_POLL
index|]
operator|=
name|sop
operator|->
name|so_parm
operator|.
name|sp_timepoll
expr_stmt|;
name|sop
operator|->
name|so_timer
index|[
name|SSCOP_T_NORESP
index|]
operator|=
name|sop
operator|->
name|so_parm
operator|.
name|sp_timeresp
expr_stmt|;
block|}
comment|/* 	 * OK, we're ready for data 	 */
name|sop
operator|->
name|so_state
operator|=
name|SOS_READY
expr_stmt|;
comment|/* 	 * See if transmit queues need servicing 	 */
if|if
condition|(
name|sop
operator|->
name|so_flags
operator|&
name|SOF_XMITSRVC
condition|)
name|sscop_service_xmit
argument_list|(
name|sop
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * BGREJ PDU / Protocol Error  *  * Arguments:  *	sop	pointer to sscop connection block  *	m	pointer to PDU buffer (without trailer)  *	trlr	pointer to PDU trailer  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|sscop_bgrej_error
parameter_list|(
name|sop
parameter_list|,
name|m
parameter_list|,
name|trlr
parameter_list|)
name|struct
name|sscop
modifier|*
name|sop
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|caddr_t
name|trlr
decl_stmt|;
block|{
comment|/* 	 * Record error condition 	 */
name|sscop_maa_error
argument_list|(
name|sop
argument_list|,
literal|'D'
argument_list|)
expr_stmt|;
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * BGREJ PDU / SOS_OUTCONN Processor  *  * Arguments:  *	sop	pointer to sscop connection block  *	m	pointer to PDU buffer (without trailer)  *	trlr	pointer to PDU trailer  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|sscop_bgrej_outconn
parameter_list|(
name|sop
parameter_list|,
name|m
parameter_list|,
name|trlr
parameter_list|)
name|struct
name|sscop
modifier|*
name|sop
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|caddr_t
name|trlr
decl_stmt|;
block|{
name|int
name|source
decl_stmt|,
name|err
decl_stmt|;
name|intptr_t
name|uu
decl_stmt|;
comment|/* 	 * Stop retransmit timer 	 */
name|sop
operator|->
name|so_timer
index|[
name|SSCOP_T_CC
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sop
operator|->
name|so_vers
operator|==
name|SSCOP_VERS_QSAAL
condition|)
block|{
comment|/* 		 * Clear reestablishment flag 		 */
name|sop
operator|->
name|so_flags
operator|&=
operator|~
name|SOF_REESTAB
expr_stmt|;
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
name|uu
operator|=
name|SSCOP_UU_NULL
expr_stmt|;
name|source
operator|=
name|SSCOP_SOURCE_SSCOP
expr_stmt|;
block|}
else|else
block|{
name|uu
operator|=
operator|(
name|intptr_t
operator|)
name|m
expr_stmt|;
name|source
operator|=
name|SSCOP_SOURCE_USER
expr_stmt|;
block|}
comment|/* 	 * Notify user of connection failure 	 */
name|STACK_CALL
argument_list|(
name|SSCOP_RELEASE_IND
argument_list|,
name|sop
operator|->
name|so_upper
argument_list|,
name|sop
operator|->
name|so_toku
argument_list|,
name|sop
operator|->
name|so_connvc
argument_list|,
name|uu
argument_list|,
name|source
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|sscop_abort
argument_list|(
name|sop
argument_list|,
literal|"stack memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Back to idle state 	 */
name|sop
operator|->
name|so_state
operator|=
name|SOS_IDLE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * BGREJ PDU / SOS_INCONN Processor  *  * Arguments:  *	sop	pointer to sscop connection block  *	m	pointer to PDU buffer (without trailer)  *	trlr	pointer to PDU trailer  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|sscop_bgrej_inconn
parameter_list|(
name|sop
parameter_list|,
name|m
parameter_list|,
name|trlr
parameter_list|)
name|struct
name|sscop
modifier|*
name|sop
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|caddr_t
name|trlr
decl_stmt|;
block|{
name|int
name|err
decl_stmt|;
comment|/* 	 * Report protocol error 	 */
name|sscop_bgrej_error
argument_list|(
name|sop
argument_list|,
name|m
argument_list|,
name|trlr
argument_list|)
expr_stmt|;
comment|/* 	 * Notify user of connection failure 	 */
name|STACK_CALL
argument_list|(
name|SSCOP_RELEASE_IND
argument_list|,
name|sop
operator|->
name|so_upper
argument_list|,
name|sop
operator|->
name|so_toku
argument_list|,
name|sop
operator|->
name|so_connvc
argument_list|,
name|SSCOP_UU_NULL
argument_list|,
name|SSCOP_SOURCE_SSCOP
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|sscop_abort
argument_list|(
name|sop
argument_list|,
literal|"stack memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Back to idle state 	 */
name|sop
operator|->
name|so_state
operator|=
name|SOS_IDLE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * BGREJ PDU / SOS_OUTRESYN Processor  *  * Arguments:  *	sop	pointer to sscop connection block  *	m	pointer to PDU buffer (without trailer)  *	trlr	pointer to PDU trailer  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|sscop_bgrej_outresyn
parameter_list|(
name|sop
parameter_list|,
name|m
parameter_list|,
name|trlr
parameter_list|)
name|struct
name|sscop
modifier|*
name|sop
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|caddr_t
name|trlr
decl_stmt|;
block|{
name|int
name|err
decl_stmt|;
comment|/* 	 * Stop retransmit timer 	 */
name|sop
operator|->
name|so_timer
index|[
name|SSCOP_T_CC
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Report protocol error 	 */
name|sscop_bgrej_error
argument_list|(
name|sop
argument_list|,
name|m
argument_list|,
name|trlr
argument_list|)
expr_stmt|;
comment|/* 	 * Notify user of connection failure 	 */
name|STACK_CALL
argument_list|(
name|SSCOP_RELEASE_IND
argument_list|,
name|sop
operator|->
name|so_upper
argument_list|,
name|sop
operator|->
name|so_toku
argument_list|,
name|sop
operator|->
name|so_connvc
argument_list|,
name|SSCOP_UU_NULL
argument_list|,
name|SSCOP_SOURCE_SSCOP
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|sscop_abort
argument_list|(
name|sop
argument_list|,
literal|"stack memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sop
operator|->
name|so_vers
operator|==
name|SSCOP_VERS_QSAAL
condition|)
block|{
comment|/* 		 * Clear connection data 		 */
name|qsaal1_clear_connection
argument_list|(
name|sop
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Back to idle state 	 */
name|sop
operator|->
name|so_state
operator|=
name|SOS_IDLE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * BGREJ PDU / SOS_READY Processor  *  * Arguments:  *	sop	pointer to sscop connection block  *	m	pointer to PDU buffer (without trailer)  *	trlr	pointer to PDU trailer  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|sscop_bgrej_ready
parameter_list|(
name|sop
parameter_list|,
name|m
parameter_list|,
name|trlr
parameter_list|)
name|struct
name|sscop
modifier|*
name|sop
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|caddr_t
name|trlr
decl_stmt|;
block|{
name|int
name|err
decl_stmt|;
comment|/* 	 * Stop data transfer timers 	 */
name|sop
operator|->
name|so_timer
index|[
name|SSCOP_T_POLL
index|]
operator|=
literal|0
expr_stmt|;
name|sop
operator|->
name|so_timer
index|[
name|SSCOP_T_NORESP
index|]
operator|=
literal|0
expr_stmt|;
name|sop
operator|->
name|so_timer
index|[
name|SSCOP_T_IDLE
index|]
operator|=
literal|0
expr_stmt|;
name|sop
operator|->
name|so_flags
operator|&=
operator|~
name|SOF_KEEPALIVE
expr_stmt|;
comment|/* 	 * Report protocol error 	 */
name|sscop_bgrej_error
argument_list|(
name|sop
argument_list|,
name|m
argument_list|,
name|trlr
argument_list|)
expr_stmt|;
comment|/* 	 * Notify user of connection failure 	 */
name|STACK_CALL
argument_list|(
name|SSCOP_RELEASE_IND
argument_list|,
name|sop
operator|->
name|so_upper
argument_list|,
name|sop
operator|->
name|so_toku
argument_list|,
name|sop
operator|->
name|so_connvc
argument_list|,
name|SSCOP_UU_NULL
argument_list|,
name|SSCOP_SOURCE_SSCOP
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|sscop_abort
argument_list|(
name|sop
argument_list|,
literal|"stack memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sop
operator|->
name|so_vers
operator|==
name|SSCOP_VERS_QSAAL
condition|)
block|{
comment|/* 		 * Clear connection data 		 */
name|qsaal1_clear_connection
argument_list|(
name|sop
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Clear out appropriate queues 		 */
name|q2110_prep_retrieve
argument_list|(
name|sop
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Back to idle state 	 */
name|sop
operator|->
name|so_state
operator|=
name|SOS_IDLE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * END PDU / SOS_IDLE Processor  *  * Arguments:  *	sop	pointer to sscop connection block  *	m	pointer to PDU buffer (without trailer)  *	trlr	pointer to PDU trailer  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|sscop_end_idle
parameter_list|(
name|sop
parameter_list|,
name|m
parameter_list|,
name|trlr
parameter_list|)
name|struct
name|sscop
modifier|*
name|sop
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|caddr_t
name|trlr
decl_stmt|;
block|{
comment|/* 	 * Free buffers 	 */
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* 	 * Return an ENDAK to peer 	 */
operator|(
name|void
operator|)
name|sscop_send_endak
argument_list|(
name|sop
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * END PDU / SOS_INCONN Processor  *  * Arguments:  *	sop	pointer to sscop connection block  *	m	pointer to PDU buffer (without trailer)  *	trlr	pointer to PDU trailer  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|sscop_end_inconn
parameter_list|(
name|sop
parameter_list|,
name|m
parameter_list|,
name|trlr
parameter_list|)
name|struct
name|sscop
modifier|*
name|sop
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|caddr_t
name|trlr
decl_stmt|;
block|{
name|struct
name|end_pdu
modifier|*
name|ep
init|=
operator|(
expr|struct
name|end_pdu
operator|*
operator|)
name|trlr
decl_stmt|;
name|int
name|err
decl_stmt|,
name|source
decl_stmt|;
comment|/* 	 * Stop retransmit timer 	 */
name|sop
operator|->
name|so_timer
index|[
name|SSCOP_T_CC
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Acknowledge END 	 */
operator|(
name|void
operator|)
name|sscop_send_endak
argument_list|(
name|sop
argument_list|)
expr_stmt|;
comment|/* 	 * Get Source value 	 */
if|if
condition|(
name|ep
operator|->
name|end_type
operator|&
name|PT_SOURCE_SSCOP
condition|)
name|source
operator|=
name|SSCOP_SOURCE_SSCOP
expr_stmt|;
else|else
name|source
operator|=
name|SSCOP_SOURCE_USER
expr_stmt|;
comment|/* 	 * Notify user of connection termination 	 */
name|STACK_CALL
argument_list|(
name|SSCOP_RELEASE_IND
argument_list|,
name|sop
operator|->
name|so_upper
argument_list|,
name|sop
operator|->
name|so_toku
argument_list|,
name|sop
operator|->
name|so_connvc
argument_list|,
operator|(
name|intptr_t
operator|)
name|m
argument_list|,
name|source
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|sscop_abort
argument_list|(
name|sop
argument_list|,
literal|"stack memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Back to idle state 	 */
name|sop
operator|->
name|so_state
operator|=
name|SOS_IDLE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * END PDU / SOS_OUTDISC Processor  *  * Arguments:  *	sop	pointer to sscop connection block  *	m	pointer to PDU buffer (without trailer)  *	trlr	pointer to PDU trailer  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|sscop_end_outdisc
parameter_list|(
name|sop
parameter_list|,
name|m
parameter_list|,
name|trlr
parameter_list|)
name|struct
name|sscop
modifier|*
name|sop
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|caddr_t
name|trlr
decl_stmt|;
block|{
name|int
name|err
decl_stmt|;
comment|/* 	 * Stop retransmit timer 	 */
name|sop
operator|->
name|so_timer
index|[
name|SSCOP_T_CC
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Release buffers 	 */
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* 	 * Acknowledge END 	 */
operator|(
name|void
operator|)
name|sscop_send_endak
argument_list|(
name|sop
argument_list|)
expr_stmt|;
comment|/* 	 * Notify user of connection termination 	 */
name|STACK_CALL
argument_list|(
name|SSCOP_RELEASE_CNF
argument_list|,
name|sop
operator|->
name|so_upper
argument_list|,
name|sop
operator|->
name|so_toku
argument_list|,
name|sop
operator|->
name|so_connvc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|sscop_abort
argument_list|(
name|sop
argument_list|,
literal|"stack memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Back to idle state 	 */
name|sop
operator|->
name|so_state
operator|=
name|SOS_IDLE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * ENDAK PDU / Protocol Error  *  * Arguments:  *	sop	pointer to sscop connection block  *	m	pointer to PDU buffer (without trailer)  *	trlr	pointer to PDU trailer  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|sscop_endak_error
parameter_list|(
name|sop
parameter_list|,
name|m
parameter_list|,
name|trlr
parameter_list|)
name|struct
name|sscop
modifier|*
name|sop
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|caddr_t
name|trlr
decl_stmt|;
block|{
comment|/* 	 * Record error condition 	 */
name|sscop_maa_error
argument_list|(
name|sop
argument_list|,
literal|'F'
argument_list|)
expr_stmt|;
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * ENDAK PDU / SOS_INCONN Processor  *  * Arguments:  *	sop	pointer to sscop connection block  *	m	pointer to PDU buffer (without trailer)  *	trlr	pointer to PDU trailer  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|sscop_endak_inconn
parameter_list|(
name|sop
parameter_list|,
name|m
parameter_list|,
name|trlr
parameter_list|)
name|struct
name|sscop
modifier|*
name|sop
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|caddr_t
name|trlr
decl_stmt|;
block|{
name|int
name|err
decl_stmt|;
comment|/* 	 * Stop retransmit timer 	 */
name|sop
operator|->
name|so_timer
index|[
name|SSCOP_T_CC
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Report protocol error 	 */
name|sscop_endak_error
argument_list|(
name|sop
argument_list|,
name|m
argument_list|,
name|trlr
argument_list|)
expr_stmt|;
comment|/* 	 * Notify user of connection termination 	 */
name|STACK_CALL
argument_list|(
name|SSCOP_RELEASE_IND
argument_list|,
name|sop
operator|->
name|so_upper
argument_list|,
name|sop
operator|->
name|so_toku
argument_list|,
name|sop
operator|->
name|so_connvc
argument_list|,
name|SSCOP_UU_NULL
argument_list|,
name|SSCOP_SOURCE_SSCOP
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|sscop_abort
argument_list|(
name|sop
argument_list|,
literal|"stack memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Back to idle state 	 */
name|sop
operator|->
name|so_state
operator|=
name|SOS_IDLE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * ENDAK PDU / SOS_OUTDISC Processor  *  * Arguments:  *	sop	pointer to sscop connection block  *	m	pointer to PDU buffer (without trailer)  *	trlr	pointer to PDU trailer  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|sscop_endak_outdisc
parameter_list|(
name|sop
parameter_list|,
name|m
parameter_list|,
name|trlr
parameter_list|)
name|struct
name|sscop
modifier|*
name|sop
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|caddr_t
name|trlr
decl_stmt|;
block|{
name|int
name|err
decl_stmt|;
comment|/* 	 * Stop retransmit timer 	 */
name|sop
operator|->
name|so_timer
index|[
name|SSCOP_T_CC
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Release buffers 	 */
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* 	 * Notify user of connection termination 	 */
name|STACK_CALL
argument_list|(
name|SSCOP_RELEASE_CNF
argument_list|,
name|sop
operator|->
name|so_upper
argument_list|,
name|sop
operator|->
name|so_toku
argument_list|,
name|sop
operator|->
name|so_connvc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|sscop_abort
argument_list|(
name|sop
argument_list|,
literal|"stack memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Back to idle state 	 */
name|sop
operator|->
name|so_state
operator|=
name|SOS_IDLE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * ENDAK PDU / SOS_READY Processor  *  * Arguments:  *	sop	pointer to sscop connection block  *	m	pointer to PDU buffer (without trailer)  *	trlr	pointer to PDU trailer  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|sscop_endak_ready
parameter_list|(
name|sop
parameter_list|,
name|m
parameter_list|,
name|trlr
parameter_list|)
name|struct
name|sscop
modifier|*
name|sop
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|caddr_t
name|trlr
decl_stmt|;
block|{
name|int
name|err
decl_stmt|;
comment|/* 	 * Stop data transfer timers 	 */
name|sop
operator|->
name|so_timer
index|[
name|SSCOP_T_POLL
index|]
operator|=
literal|0
expr_stmt|;
name|sop
operator|->
name|so_timer
index|[
name|SSCOP_T_NORESP
index|]
operator|=
literal|0
expr_stmt|;
name|sop
operator|->
name|so_timer
index|[
name|SSCOP_T_IDLE
index|]
operator|=
literal|0
expr_stmt|;
name|sop
operator|->
name|so_flags
operator|&=
operator|~
name|SOF_KEEPALIVE
expr_stmt|;
comment|/* 	 * Report protocol error 	 */
name|sscop_endak_error
argument_list|(
name|sop
argument_list|,
name|m
argument_list|,
name|trlr
argument_list|)
expr_stmt|;
comment|/* 	 * Notify user of connection failure 	 */
name|STACK_CALL
argument_list|(
name|SSCOP_RELEASE_IND
argument_list|,
name|sop
operator|->
name|so_upper
argument_list|,
name|sop
operator|->
name|so_toku
argument_list|,
name|sop
operator|->
name|so_connvc
argument_list|,
name|SSCOP_UU_NULL
argument_list|,
name|SSCOP_SOURCE_SSCOP
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|sscop_abort
argument_list|(
name|sop
argument_list|,
literal|"stack memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sop
operator|->
name|so_vers
operator|==
name|SSCOP_VERS_QSAAL
condition|)
block|{
comment|/* 		 * Clear connection data 		 */
name|qsaal1_clear_connection
argument_list|(
name|sop
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Clear out appropriate queues 		 */
name|q2110_prep_retrieve
argument_list|(
name|sop
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Back to idle state 	 */
name|sop
operator|->
name|so_state
operator|=
name|SOS_IDLE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * RS PDU / Protocol Error  *  * Arguments:  *	sop	pointer to sscop connection block  *	m	pointer to PDU buffer (without trailer)  *	trlr	pointer to PDU trailer  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|sscop_rs_error
parameter_list|(
name|sop
parameter_list|,
name|m
parameter_list|,
name|trlr
parameter_list|)
name|struct
name|sscop
modifier|*
name|sop
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|caddr_t
name|trlr
decl_stmt|;
block|{
comment|/* 	 * Record error condition 	 */
name|sscop_maa_error
argument_list|(
name|sop
argument_list|,
literal|'J'
argument_list|)
expr_stmt|;
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * RS PDU / SOS_IDLE Processor  *  * Arguments:  *	sop	pointer to sscop connection block  *	m	pointer to PDU buffer (without trailer)  *	trlr	pointer to PDU trailer  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|sscop_rs_idle
parameter_list|(
name|sop
parameter_list|,
name|m
parameter_list|,
name|trlr
parameter_list|)
name|struct
name|sscop
modifier|*
name|sop
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|caddr_t
name|trlr
decl_stmt|;
block|{
comment|/* 	 * Report error condition 	 */
name|sscop_rs_error
argument_list|(
name|sop
argument_list|,
name|m
argument_list|,
name|trlr
argument_list|)
expr_stmt|;
comment|/* 	 * Return an END to peer 	 */
operator|(
name|void
operator|)
name|sscop_send_end
argument_list|(
name|sop
argument_list|,
name|SSCOP_SOURCE_SSCOP
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * RSAK PDU / Protocol Error  *  * Arguments:  *	sop	pointer to sscop connection block  *	m	pointer to PDU buffer (without trailer)  *	trlr	pointer to PDU trailer  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|sscop_rsak_error
parameter_list|(
name|sop
parameter_list|,
name|m
parameter_list|,
name|trlr
parameter_list|)
name|struct
name|sscop
modifier|*
name|sop
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|caddr_t
name|trlr
decl_stmt|;
block|{
comment|/* 	 * Record error condition 	 */
name|sscop_maa_error
argument_list|(
name|sop
argument_list|,
literal|'K'
argument_list|)
expr_stmt|;
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * RSAK PDU / SOS_IDLE Processor  *  * Arguments:  *	sop	pointer to sscop connection block  *	m	pointer to PDU buffer (without trailer)  *	trlr	pointer to PDU trailer  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|sscop_rsak_idle
parameter_list|(
name|sop
parameter_list|,
name|m
parameter_list|,
name|trlr
parameter_list|)
name|struct
name|sscop
modifier|*
name|sop
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|caddr_t
name|trlr
decl_stmt|;
block|{
comment|/* 	 * Report error condition 	 */
name|sscop_rsak_error
argument_list|(
name|sop
argument_list|,
name|m
argument_list|,
name|trlr
argument_list|)
expr_stmt|;
comment|/* 	 * Return an END to peer 	 */
operator|(
name|void
operator|)
name|sscop_send_end
argument_list|(
name|sop
argument_list|,
name|SSCOP_SOURCE_SSCOP
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * RSAK PDU / SOS_OUTRESYN Processor  *  * Arguments:  *	sop	pointer to sscop connection block  *	m	pointer to PDU buffer (without trailer)  *	trlr	pointer to PDU trailer  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|sscop_rsak_outresyn
parameter_list|(
name|sop
parameter_list|,
name|m
parameter_list|,
name|trlr
parameter_list|)
name|struct
name|sscop
modifier|*
name|sop
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|caddr_t
name|trlr
decl_stmt|;
block|{
name|struct
name|rsak_q2110_pdu
modifier|*
name|rp
init|=
operator|(
expr|struct
name|rsak_q2110_pdu
operator|*
operator|)
name|trlr
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* 	 * Stop retransmit timer 	 */
name|sop
operator|->
name|so_timer
index|[
name|SSCOP_T_CC
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Notify user of resynchronization completion 	 */
name|STACK_CALL
argument_list|(
name|SSCOP_RESYNC_CNF
argument_list|,
name|sop
operator|->
name|so_upper
argument_list|,
name|sop
operator|->
name|so_toku
argument_list|,
name|sop
operator|->
name|so_connvc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|sscop_abort
argument_list|(
name|sop
argument_list|,
literal|"stack memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sop
operator|->
name|so_vers
operator|==
name|SSCOP_VERS_QSAAL
condition|)
block|{
comment|/* 		 * Start the polling timer 		 */
name|sscop_set_poll
argument_list|(
name|sop
argument_list|)
expr_stmt|;
comment|/* 		 * Start lost poll/stat timer 		 */
name|sop
operator|->
name|so_timer
index|[
name|SSCOP_T_NORESP
index|]
operator|=
name|sop
operator|->
name|so_parm
operator|.
name|sp_timeresp
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Initialize state variables 		 */
name|SEQ_SET
argument_list|(
name|sop
operator|->
name|so_sendmax
argument_list|,
name|ntohl
argument_list|(
name|rp
operator|->
name|rsak_nmr
argument_list|)
argument_list|)
expr_stmt|;
name|q2110_init_state
argument_list|(
name|sop
argument_list|)
expr_stmt|;
comment|/* 		 * Start data transfer timers 		 */
name|sop
operator|->
name|so_timer
index|[
name|SSCOP_T_POLL
index|]
operator|=
name|sop
operator|->
name|so_parm
operator|.
name|sp_timepoll
expr_stmt|;
name|sop
operator|->
name|so_timer
index|[
name|SSCOP_T_NORESP
index|]
operator|=
name|sop
operator|->
name|so_parm
operator|.
name|sp_timeresp
expr_stmt|;
block|}
comment|/* 	 * Free buffers 	 */
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* 	 * Now go back to data transfer state 	 */
name|sop
operator|->
name|so_state
operator|=
name|SOS_READY
expr_stmt|;
comment|/* 	 * See if transmit queues need servicing 	 */
if|if
condition|(
name|sop
operator|->
name|so_flags
operator|&
name|SOF_XMITSRVC
condition|)
name|sscop_service_xmit
argument_list|(
name|sop
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * SD PDU / Protocol Error  *  * Arguments:  *	sop	pointer to sscop connection block  *	m	pointer to PDU buffer (without trailer)  *	trlr	pointer to PDU trailer  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|sscop_sd_error
parameter_list|(
name|sop
parameter_list|,
name|m
parameter_list|,
name|trlr
parameter_list|)
name|struct
name|sscop
modifier|*
name|sop
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|caddr_t
name|trlr
decl_stmt|;
block|{
comment|/* 	 * Record error condition 	 */
name|sscop_maa_error
argument_list|(
name|sop
argument_list|,
literal|'A'
argument_list|)
expr_stmt|;
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * SD PDU / SOS_IDLE Processor  *  * Arguments:  *	sop	pointer to sscop connection block  *	m	pointer to PDU buffer (without trailer)  *	trlr	pointer to PDU trailer  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|sscop_sd_idle
parameter_list|(
name|sop
parameter_list|,
name|m
parameter_list|,
name|trlr
parameter_list|)
name|struct
name|sscop
modifier|*
name|sop
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|caddr_t
name|trlr
decl_stmt|;
block|{
comment|/* 	 * Record error condition 	 */
name|sscop_sd_error
argument_list|(
name|sop
argument_list|,
name|m
argument_list|,
name|trlr
argument_list|)
expr_stmt|;
comment|/* 	 * Return an END to peer 	 */
operator|(
name|void
operator|)
name|sscop_send_end
argument_list|(
name|sop
argument_list|,
name|SSCOP_SOURCE_SSCOP
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * SD PDU / SOS_INCONN Processor  *  * Arguments:  *	sop	pointer to sscop connection block  *	m	pointer to PDU buffer (without trailer)  *	trlr	pointer to PDU trailer  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|sscop_sd_inconn
parameter_list|(
name|sop
parameter_list|,
name|m
parameter_list|,
name|trlr
parameter_list|)
name|struct
name|sscop
modifier|*
name|sop
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|caddr_t
name|trlr
decl_stmt|;
block|{
name|int
name|err
decl_stmt|;
comment|/* 	 * Record error condition 	 */
name|sscop_sd_error
argument_list|(
name|sop
argument_list|,
name|m
argument_list|,
name|trlr
argument_list|)
expr_stmt|;
comment|/* 	 * Return an END to peer 	 */
operator|(
name|void
operator|)
name|sscop_send_end
argument_list|(
name|sop
argument_list|,
name|SSCOP_SOURCE_SSCOP
argument_list|)
expr_stmt|;
comment|/* 	 * Notify user of connection failure 	 */
name|STACK_CALL
argument_list|(
name|SSCOP_RELEASE_IND
argument_list|,
name|sop
operator|->
name|so_upper
argument_list|,
name|sop
operator|->
name|so_toku
argument_list|,
name|sop
operator|->
name|so_connvc
argument_list|,
name|SSCOP_UU_NULL
argument_list|,
name|SSCOP_SOURCE_SSCOP
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|sscop_abort
argument_list|(
name|sop
argument_list|,
literal|"stack memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Go back to idle state 	 */
name|sop
operator|->
name|so_state
operator|=
name|SOS_IDLE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * POLL PDU / Protocol Error  *  * Arguments:  *	sop	pointer to sscop connection block  *	m	pointer to PDU buffer (without trailer)  *	trlr	pointer to PDU trailer  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|sscop_poll_error
parameter_list|(
name|sop
parameter_list|,
name|m
parameter_list|,
name|trlr
parameter_list|)
name|struct
name|sscop
modifier|*
name|sop
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|caddr_t
name|trlr
decl_stmt|;
block|{
comment|/* 	 * Record error condition 	 */
name|sscop_maa_error
argument_list|(
name|sop
argument_list|,
literal|'G'
argument_list|)
expr_stmt|;
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * POLL PDU / SOS_IDLE Processor  *  * Arguments:  *	sop	pointer to sscop connection block  *	m	pointer to PDU buffer (without trailer)  *	trlr	pointer to PDU trailer  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|sscop_poll_idle
parameter_list|(
name|sop
parameter_list|,
name|m
parameter_list|,
name|trlr
parameter_list|)
name|struct
name|sscop
modifier|*
name|sop
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|caddr_t
name|trlr
decl_stmt|;
block|{
comment|/* 	 * Report error condition 	 */
name|sscop_poll_error
argument_list|(
name|sop
argument_list|,
name|m
argument_list|,
name|trlr
argument_list|)
expr_stmt|;
comment|/* 	 * Return an END to peer 	 */
operator|(
name|void
operator|)
name|sscop_send_end
argument_list|(
name|sop
argument_list|,
name|SSCOP_SOURCE_SSCOP
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * POLL PDU / SOS_INCONN Processor  *  * Arguments:  *	sop	pointer to sscop connection block  *	m	pointer to PDU buffer (without trailer)  *	trlr	pointer to PDU trailer  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|sscop_poll_inconn
parameter_list|(
name|sop
parameter_list|,
name|m
parameter_list|,
name|trlr
parameter_list|)
name|struct
name|sscop
modifier|*
name|sop
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|caddr_t
name|trlr
decl_stmt|;
block|{
name|int
name|err
decl_stmt|;
comment|/* 	 * Record error condition 	 */
name|sscop_poll_error
argument_list|(
name|sop
argument_list|,
name|m
argument_list|,
name|trlr
argument_list|)
expr_stmt|;
comment|/* 	 * Return an END to peer 	 */
operator|(
name|void
operator|)
name|sscop_send_end
argument_list|(
name|sop
argument_list|,
name|SSCOP_SOURCE_SSCOP
argument_list|)
expr_stmt|;
comment|/* 	 * Notify user of connection failure 	 */
name|STACK_CALL
argument_list|(
name|SSCOP_RELEASE_IND
argument_list|,
name|sop
operator|->
name|so_upper
argument_list|,
name|sop
operator|->
name|so_toku
argument_list|,
name|sop
operator|->
name|so_connvc
argument_list|,
name|SSCOP_UU_NULL
argument_list|,
name|SSCOP_SOURCE_SSCOP
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|sscop_abort
argument_list|(
name|sop
argument_list|,
literal|"stack memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Go back to idle state 	 */
name|sop
operator|->
name|so_state
operator|=
name|SOS_IDLE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * STAT PDU / Protocol Error  *  * Arguments:  *	sop	pointer to sscop connection block  *	m	pointer to PDU buffer (without trailer)  *	trlr	pointer to PDU trailer  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|sscop_stat_error
parameter_list|(
name|sop
parameter_list|,
name|m
parameter_list|,
name|trlr
parameter_list|)
name|struct
name|sscop
modifier|*
name|sop
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|caddr_t
name|trlr
decl_stmt|;
block|{
comment|/* 	 * Record error condition 	 */
name|sscop_maa_error
argument_list|(
name|sop
argument_list|,
literal|'H'
argument_list|)
expr_stmt|;
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * STAT PDU / SOS_IDLE Processor  *  * Arguments:  *	sop	pointer to sscop connection block  *	m	pointer to PDU buffer (without trailer)  *	trlr	pointer to PDU trailer  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|sscop_stat_idle
parameter_list|(
name|sop
parameter_list|,
name|m
parameter_list|,
name|trlr
parameter_list|)
name|struct
name|sscop
modifier|*
name|sop
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|caddr_t
name|trlr
decl_stmt|;
block|{
comment|/* 	 * Report error condition 	 */
name|sscop_stat_error
argument_list|(
name|sop
argument_list|,
name|m
argument_list|,
name|trlr
argument_list|)
expr_stmt|;
comment|/* 	 * Return an END to peer 	 */
operator|(
name|void
operator|)
name|sscop_send_end
argument_list|(
name|sop
argument_list|,
name|SSCOP_SOURCE_SSCOP
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * STAT PDU / SOS_INCONN Processor  *  * Arguments:  *	sop	pointer to sscop connection block  *	m	pointer to PDU buffer (without trailer)  *	trlr	pointer to PDU trailer  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|sscop_stat_inconn
parameter_list|(
name|sop
parameter_list|,
name|m
parameter_list|,
name|trlr
parameter_list|)
name|struct
name|sscop
modifier|*
name|sop
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|caddr_t
name|trlr
decl_stmt|;
block|{
name|int
name|err
decl_stmt|;
comment|/* 	 * Record error condition 	 */
name|sscop_stat_error
argument_list|(
name|sop
argument_list|,
name|m
argument_list|,
name|trlr
argument_list|)
expr_stmt|;
comment|/* 	 * Return an END to peer 	 */
operator|(
name|void
operator|)
name|sscop_send_end
argument_list|(
name|sop
argument_list|,
name|SSCOP_SOURCE_SSCOP
argument_list|)
expr_stmt|;
comment|/* 	 * Notify user of connection failure 	 */
name|STACK_CALL
argument_list|(
name|SSCOP_RELEASE_IND
argument_list|,
name|sop
operator|->
name|so_upper
argument_list|,
name|sop
operator|->
name|so_toku
argument_list|,
name|sop
operator|->
name|so_connvc
argument_list|,
name|SSCOP_UU_NULL
argument_list|,
name|SSCOP_SOURCE_SSCOP
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|sscop_abort
argument_list|(
name|sop
argument_list|,
literal|"stack memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Go back to idle state 	 */
name|sop
operator|->
name|so_state
operator|=
name|SOS_IDLE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * STAT PDU / SOS_READY Processor  *  * Arguments:  *	sop	pointer to sscop connection block  *	m	pointer to PDU buffer (without trailer)  *	trlr	pointer to PDU trailer  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|sscop_stat_ready
parameter_list|(
name|sop
parameter_list|,
name|m
parameter_list|,
name|trlr
parameter_list|)
name|struct
name|sscop
modifier|*
name|sop
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|caddr_t
name|trlr
decl_stmt|;
block|{
name|struct
name|stat_pdu
modifier|*
name|sp
init|=
operator|(
expr|struct
name|stat_pdu
operator|*
operator|)
name|trlr
decl_stmt|;
name|struct
name|pdu_hdr
modifier|*
name|php
decl_stmt|;
name|KBuffer
modifier|*
name|m0
init|=
name|m
decl_stmt|;
name|sscop_seq
name|seq1
decl_stmt|,
name|seq2
decl_stmt|,
name|opa
decl_stmt|;
name|int
name|cnt
init|=
literal|0
decl_stmt|;
name|NTOHL
argument_list|(
name|sp
operator|->
name|stat_nps
argument_list|)
expr_stmt|;
name|NTOHL
argument_list|(
name|sp
operator|->
name|stat_nmr
argument_list|)
expr_stmt|;
name|NTOHL
argument_list|(
name|sp
operator|->
name|stat_nr
argument_list|)
expr_stmt|;
comment|/* 	 * Validate peer's received poll sequence number 	 */
if|if
condition|(
name|SEQ_GT
argument_list|(
name|sop
operator|->
name|so_pollack
argument_list|,
name|sp
operator|->
name|stat_nps
argument_list|,
name|sop
operator|->
name|so_pollack
argument_list|)
operator|||
name|SEQ_GT
argument_list|(
name|sp
operator|->
name|stat_nps
argument_list|,
name|sop
operator|->
name|so_pollsend
argument_list|,
name|sop
operator|->
name|so_pollack
argument_list|)
condition|)
block|{
comment|/* 		 * Bad poll sequence number 		 */
name|sscop_maa_error
argument_list|(
name|sop
argument_list|,
literal|'R'
argument_list|)
expr_stmt|;
goto|goto
name|goterr
goto|;
block|}
comment|/* 	 * Validate peer's current receive data sequence number 	 */
if|if
condition|(
name|SEQ_GT
argument_list|(
name|sop
operator|->
name|so_ack
argument_list|,
name|sp
operator|->
name|stat_nr
argument_list|,
name|sop
operator|->
name|so_ack
argument_list|)
operator|||
name|SEQ_GT
argument_list|(
name|sp
operator|->
name|stat_nr
argument_list|,
name|sop
operator|->
name|so_send
argument_list|,
name|sop
operator|->
name|so_ack
argument_list|)
condition|)
block|{
comment|/* 		 * Bad data sequence number 		 */
name|sscop_maa_error
argument_list|(
name|sop
argument_list|,
literal|'S'
argument_list|)
expr_stmt|;
goto|goto
name|goterr
goto|;
block|}
comment|/* 	 * Free acknowledged PDUs 	 */
for|for
control|(
name|seq1
operator|=
name|sop
operator|->
name|so_ack
operator|,
name|SEQ_SET
argument_list|(
name|seq2
argument_list|,
name|sp
operator|->
name|stat_nr
argument_list|)
init|;
name|SEQ_LT
argument_list|(
name|seq1
argument_list|,
name|seq2
argument_list|,
name|sop
operator|->
name|so_ack
argument_list|)
condition|;
name|SEQ_INCR
argument_list|(
name|seq1
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|sscop_pack_free
argument_list|(
name|sop
argument_list|,
name|seq1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Update transmit state variables 	 */
name|opa
operator|=
name|sop
operator|->
name|so_pollack
expr_stmt|;
name|sop
operator|->
name|so_ack
operator|=
name|seq2
expr_stmt|;
name|SEQ_SET
argument_list|(
name|sop
operator|->
name|so_pollack
argument_list|,
name|sp
operator|->
name|stat_nps
argument_list|)
expr_stmt|;
name|SEQ_SET
argument_list|(
name|sop
operator|->
name|so_sendmax
argument_list|,
name|sp
operator|->
name|stat_nmr
argument_list|)
expr_stmt|;
comment|/* 	 * Get first element in STAT list 	 */
while|while
condition|(
name|m
operator|&&
operator|(
name|KB_LEN
argument_list|(
name|m
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|m
operator|=
name|KB_NEXT
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
name|m
operator|=
name|sscop_stat_getelem
argument_list|(
name|m
argument_list|,
operator|&
name|seq1
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure there's a second element too 	 */
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
comment|/* 	 * Validate first element (start of missing pdus) 	 */
if|if
condition|(
name|SEQ_GT
argument_list|(
name|sop
operator|->
name|so_ack
argument_list|,
name|seq1
argument_list|,
name|sop
operator|->
name|so_ack
argument_list|)
operator|||
name|SEQ_GEQ
argument_list|(
name|seq1
argument_list|,
name|sop
operator|->
name|so_send
argument_list|,
name|sop
operator|->
name|so_ack
argument_list|)
condition|)
block|{
comment|/* 		 * Bad element sequence number 		 */
name|sscop_maa_error
argument_list|(
name|sop
argument_list|,
literal|'S'
argument_list|)
expr_stmt|;
goto|goto
name|goterr
goto|;
block|}
comment|/* 	 * Loop thru all STAT elements in list 	 */
while|while
condition|(
name|m
condition|)
block|{
comment|/* 		 * Get next even element (start of received pdus) 		 */
name|m
operator|=
name|sscop_stat_getelem
argument_list|(
name|m
argument_list|,
operator|&
name|seq2
argument_list|)
expr_stmt|;
comment|/* 		 * Validate seqence number 		 */
if|if
condition|(
name|SEQ_GEQ
argument_list|(
name|seq1
argument_list|,
name|seq2
argument_list|,
name|sop
operator|->
name|so_ack
argument_list|)
operator|||
name|SEQ_GT
argument_list|(
name|seq2
argument_list|,
name|sop
operator|->
name|so_send
argument_list|,
name|sop
operator|->
name|so_ack
argument_list|)
condition|)
block|{
comment|/* 			 * Bad element sequence number 			 */
name|sscop_maa_error
argument_list|(
name|sop
argument_list|,
literal|'S'
argument_list|)
expr_stmt|;
goto|goto
name|goterr
goto|;
block|}
comment|/* 		 * Process each missing sequence number in this gap 		 */
while|while
condition|(
name|SEQ_LT
argument_list|(
name|seq1
argument_list|,
name|seq2
argument_list|,
name|sop
operator|->
name|so_ack
argument_list|)
condition|)
block|{
comment|/* 			 * Find corresponding SD PDU on pending ack queue 			 */
name|php
operator|=
name|sscop_pack_locate
argument_list|(
name|sop
argument_list|,
name|seq1
argument_list|)
expr_stmt|;
if|if
condition|(
name|php
operator|==
name|NULL
condition|)
block|{
name|sscop_maa_error
argument_list|(
name|sop
argument_list|,
literal|'S'
argument_list|)
expr_stmt|;
goto|goto
name|goterr
goto|;
block|}
comment|/* 			 * Retransmit this SD PDU only if it was last sent 			 * during an earlier poll sequence and it's not 			 * already scheduled for retranmission. 			 */
if|if
condition|(
name|SEQ_LT
argument_list|(
name|php
operator|->
name|ph_nps
argument_list|,
name|sp
operator|->
name|stat_nps
argument_list|,
name|opa
argument_list|)
operator|&&
operator|(
name|php
operator|->
name|ph_rexmit_lk
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|sop
operator|->
name|so_rexmit_tl
operator|!=
name|php
operator|)
condition|)
block|{
comment|/* 				 * Put PDU on retransmit queue and schedule 				 * transmit servicing 				 */
name|sscop_rexmit_insert
argument_list|(
name|sop
argument_list|,
name|php
argument_list|)
expr_stmt|;
name|sop
operator|->
name|so_flags
operator||=
name|SOF_XMITSRVC
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
block|}
comment|/* 			 * Bump to next sequence number 			 */
name|SEQ_INCR
argument_list|(
name|seq1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Now process series of acknowledged PDUs 		 * 		 * Get next odd element (start of missing pdus), 		 * but make sure there is one and that it's valid 		 */
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
name|m
operator|=
name|sscop_stat_getelem
argument_list|(
name|m
argument_list|,
operator|&
name|seq2
argument_list|)
expr_stmt|;
if|if
condition|(
name|SEQ_GEQ
argument_list|(
name|seq1
argument_list|,
name|seq2
argument_list|,
name|sop
operator|->
name|so_ack
argument_list|)
operator|||
name|SEQ_GT
argument_list|(
name|seq2
argument_list|,
name|sop
operator|->
name|so_send
argument_list|,
name|sop
operator|->
name|so_ack
argument_list|)
condition|)
block|{
comment|/* 			 * Bad element sequence number 			 */
name|sscop_maa_error
argument_list|(
name|sop
argument_list|,
literal|'S'
argument_list|)
expr_stmt|;
goto|goto
name|goterr
goto|;
block|}
comment|/* 		 * Process each acked sequence number 		 */
while|while
condition|(
name|SEQ_LT
argument_list|(
name|seq1
argument_list|,
name|seq2
argument_list|,
name|sop
operator|->
name|so_ack
argument_list|)
condition|)
block|{
comment|/* 			 * Can we clear transmit buffers ?? 			 */
if|if
condition|(
operator|(
name|sop
operator|->
name|so_flags
operator|&
name|SOF_NOCLRBUF
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Yes, free acked buffers 				 */
name|sscop_pack_free
argument_list|(
name|sop
argument_list|,
name|seq1
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Bump to next sequence number 			 */
name|SEQ_INCR
argument_list|(
name|seq1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|done
label|:
comment|/* 	 * Free PDU buffer chain 	 */
name|KB_FREEALL
argument_list|(
name|m0
argument_list|)
expr_stmt|;
comment|/* 	 * Report retransmitted PDUs 	 */
if|if
condition|(
name|cnt
condition|)
name|sscop_maa_error
argument_list|(
name|sop
argument_list|,
literal|'V'
argument_list|)
expr_stmt|;
comment|/* 	 * Record transmit window closed transitions 	 */
if|if
condition|(
name|SEQ_LT
argument_list|(
name|sop
operator|->
name|so_send
argument_list|,
name|sop
operator|->
name|so_sendmax
argument_list|,
name|sop
operator|->
name|so_ack
argument_list|)
condition|)
block|{
if|if
condition|(
name|sop
operator|->
name|so_flags
operator|&
name|SOF_NOCREDIT
condition|)
block|{
name|sop
operator|->
name|so_flags
operator|&=
operator|~
name|SOF_NOCREDIT
expr_stmt|;
name|sscop_maa_error
argument_list|(
name|sop
argument_list|,
literal|'X'
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|sop
operator|->
name|so_flags
operator|&
name|SOF_NOCREDIT
operator|)
operator|==
literal|0
condition|)
block|{
name|sop
operator|->
name|so_flags
operator||=
name|SOF_NOCREDIT
expr_stmt|;
name|sscop_maa_error
argument_list|(
name|sop
argument_list|,
literal|'W'
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sop
operator|->
name|so_vers
operator|==
name|SSCOP_VERS_QSAAL
condition|)
comment|/* 		 * Restart lost poll/stat timer 		 */
name|sop
operator|->
name|so_timer
index|[
name|SSCOP_T_NORESP
index|]
operator|=
name|sop
operator|->
name|so_parm
operator|.
name|sp_timeresp
expr_stmt|;
else|else
block|{
comment|/* 		 * Determine new polling phase 		 */
if|if
condition|(
operator|(
name|sop
operator|->
name|so_timer
index|[
name|SSCOP_T_POLL
index|]
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|sop
operator|->
name|so_flags
operator|&
name|SOF_KEEPALIVE
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 			 * Remain in active phase - reset NO-RESPONSE timer 			 */
name|sop
operator|->
name|so_timer
index|[
name|SSCOP_T_NORESP
index|]
operator|=
name|sop
operator|->
name|so_parm
operator|.
name|sp_timeresp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sop
operator|->
name|so_timer
index|[
name|SSCOP_T_IDLE
index|]
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Go from transient to idle phase 			 */
name|sop
operator|->
name|so_timer
index|[
name|SSCOP_T_POLL
index|]
operator|=
literal|0
expr_stmt|;
name|sop
operator|->
name|so_flags
operator|&=
operator|~
name|SOF_KEEPALIVE
expr_stmt|;
name|sop
operator|->
name|so_timer
index|[
name|SSCOP_T_NORESP
index|]
operator|=
literal|0
expr_stmt|;
name|sop
operator|->
name|so_timer
index|[
name|SSCOP_T_IDLE
index|]
operator|=
name|sop
operator|->
name|so_parm
operator|.
name|sp_timeidle
expr_stmt|;
block|}
block|}
comment|/* 	 * See if transmit queues need servicing 	 */
if|if
condition|(
name|sop
operator|->
name|so_flags
operator|&
name|SOF_XMITSRVC
condition|)
name|sscop_service_xmit
argument_list|(
name|sop
argument_list|)
expr_stmt|;
return|return;
name|goterr
label|:
comment|/* 	 * Protocol/parameter error encountered 	 */
comment|/* 	 * Free PDU buffer chain 	 */
name|KB_FREEALL
argument_list|(
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sop
operator|->
name|so_vers
operator|==
name|SSCOP_VERS_QSAAL
condition|)
comment|/* 		 * Reestablish a new connection 		 */
name|qsaal1_reestablish
argument_list|(
name|sop
argument_list|)
expr_stmt|;
else|else
comment|/* 		 * Initiate error recovery 		 */
name|q2110_error_recovery
argument_list|(
name|sop
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * USTAT PDU / Protocol Error  *  * Arguments:  *	sop	pointer to sscop connection block  *	m	pointer to PDU buffer (without trailer)  *	trlr	pointer to PDU trailer  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|sscop_ustat_error
parameter_list|(
name|sop
parameter_list|,
name|m
parameter_list|,
name|trlr
parameter_list|)
name|struct
name|sscop
modifier|*
name|sop
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|caddr_t
name|trlr
decl_stmt|;
block|{
comment|/* 	 * Record error condition 	 */
name|sscop_maa_error
argument_list|(
name|sop
argument_list|,
literal|'I'
argument_list|)
expr_stmt|;
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * USTAT PDU / SOS_IDLE Processor  *  * Arguments:  *	sop	pointer to sscop connection block  *	m	pointer to PDU buffer (without trailer)  *	trlr	pointer to PDU trailer  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|sscop_ustat_idle
parameter_list|(
name|sop
parameter_list|,
name|m
parameter_list|,
name|trlr
parameter_list|)
name|struct
name|sscop
modifier|*
name|sop
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|caddr_t
name|trlr
decl_stmt|;
block|{
comment|/* 	 * Report error condition 	 */
name|sscop_ustat_error
argument_list|(
name|sop
argument_list|,
name|m
argument_list|,
name|trlr
argument_list|)
expr_stmt|;
comment|/* 	 * Return an END to peer 	 */
operator|(
name|void
operator|)
name|sscop_send_end
argument_list|(
name|sop
argument_list|,
name|SSCOP_SOURCE_SSCOP
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * USTAT PDU / SOS_INCONN Processor  *  * Arguments:  *	sop	pointer to sscop connection block  *	m	pointer to PDU buffer (without trailer)  *	trlr	pointer to PDU trailer  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|sscop_ustat_inconn
parameter_list|(
name|sop
parameter_list|,
name|m
parameter_list|,
name|trlr
parameter_list|)
name|struct
name|sscop
modifier|*
name|sop
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|caddr_t
name|trlr
decl_stmt|;
block|{
name|int
name|err
decl_stmt|;
comment|/* 	 * Record error condition 	 */
name|sscop_ustat_error
argument_list|(
name|sop
argument_list|,
name|m
argument_list|,
name|trlr
argument_list|)
expr_stmt|;
comment|/* 	 * Return an END to peer 	 */
operator|(
name|void
operator|)
name|sscop_send_end
argument_list|(
name|sop
argument_list|,
name|SSCOP_SOURCE_SSCOP
argument_list|)
expr_stmt|;
comment|/* 	 * Notify user of connection failure 	 */
name|STACK_CALL
argument_list|(
name|SSCOP_RELEASE_IND
argument_list|,
name|sop
operator|->
name|so_upper
argument_list|,
name|sop
operator|->
name|so_toku
argument_list|,
name|sop
operator|->
name|so_connvc
argument_list|,
name|SSCOP_UU_NULL
argument_list|,
name|SSCOP_SOURCE_SSCOP
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|sscop_abort
argument_list|(
name|sop
argument_list|,
literal|"stack memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Go back to idle state 	 */
name|sop
operator|->
name|so_state
operator|=
name|SOS_IDLE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * USTAT PDU / SOS_READY Processor  *  * Arguments:  *	sop	pointer to sscop connection block  *	m	pointer to PDU buffer (without trailer)  *	trlr	pointer to PDU trailer  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|sscop_ustat_ready
parameter_list|(
name|sop
parameter_list|,
name|m
parameter_list|,
name|trlr
parameter_list|)
name|struct
name|sscop
modifier|*
name|sop
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|caddr_t
name|trlr
decl_stmt|;
block|{
name|struct
name|ustat_pdu
modifier|*
name|up
init|=
operator|(
expr|struct
name|ustat_pdu
operator|*
operator|)
name|trlr
decl_stmt|;
name|struct
name|pdu_hdr
modifier|*
name|php
decl_stmt|;
name|sscop_seq
name|seq1
decl_stmt|,
name|seq2
decl_stmt|;
name|NTOHL
argument_list|(
name|up
operator|->
name|ustat_nmr
argument_list|)
expr_stmt|;
name|NTOHL
argument_list|(
name|up
operator|->
name|ustat_nr
argument_list|)
expr_stmt|;
comment|/* 	 * Validate peer's current receive data sequence number 	 */
if|if
condition|(
name|SEQ_GT
argument_list|(
name|sop
operator|->
name|so_ack
argument_list|,
name|up
operator|->
name|ustat_nr
argument_list|,
name|sop
operator|->
name|so_ack
argument_list|)
operator|||
name|SEQ_GEQ
argument_list|(
name|up
operator|->
name|ustat_nr
argument_list|,
name|sop
operator|->
name|so_send
argument_list|,
name|sop
operator|->
name|so_ack
argument_list|)
condition|)
block|{
comment|/* 		 * Bad data sequence number 		 */
goto|goto
name|goterr
goto|;
block|}
comment|/* 	 * Free acknowledged PDUs 	 */
for|for
control|(
name|seq1
operator|=
name|sop
operator|->
name|so_ack
operator|,
name|SEQ_SET
argument_list|(
name|seq2
argument_list|,
name|up
operator|->
name|ustat_nr
argument_list|)
init|;
name|SEQ_LT
argument_list|(
name|seq1
argument_list|,
name|seq2
argument_list|,
name|sop
operator|->
name|so_ack
argument_list|)
condition|;
name|SEQ_INCR
argument_list|(
name|seq1
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|sscop_pack_free
argument_list|(
name|sop
argument_list|,
name|seq1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Update transmit state variables 	 */
name|sop
operator|->
name|so_ack
operator|=
name|seq2
expr_stmt|;
name|SEQ_SET
argument_list|(
name|sop
operator|->
name|so_sendmax
argument_list|,
name|up
operator|->
name|ustat_nmr
argument_list|)
expr_stmt|;
comment|/* 	 * Get USTAT list elements 	 */
name|SEQ_SET
argument_list|(
name|seq1
argument_list|,
name|ntohl
argument_list|(
name|up
operator|->
name|ustat_le1
argument_list|)
argument_list|)
expr_stmt|;
name|SEQ_SET
argument_list|(
name|seq2
argument_list|,
name|ntohl
argument_list|(
name|up
operator|->
name|ustat_le2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Validate elements 	 */
if|if
condition|(
name|SEQ_GT
argument_list|(
name|sop
operator|->
name|so_ack
argument_list|,
name|seq1
argument_list|,
name|sop
operator|->
name|so_ack
argument_list|)
operator|||
name|SEQ_GEQ
argument_list|(
name|seq1
argument_list|,
name|seq2
argument_list|,
name|sop
operator|->
name|so_ack
argument_list|)
operator|||
name|SEQ_GEQ
argument_list|(
name|seq2
argument_list|,
name|sop
operator|->
name|so_send
argument_list|,
name|sop
operator|->
name|so_ack
argument_list|)
condition|)
block|{
comment|/* 		 * Bad element sequence number 		 */
goto|goto
name|goterr
goto|;
block|}
comment|/* 	 * Process each missing sequence number in this gap 	 */
while|while
condition|(
name|SEQ_LT
argument_list|(
name|seq1
argument_list|,
name|seq2
argument_list|,
name|sop
operator|->
name|so_ack
argument_list|)
condition|)
block|{
comment|/* 		 * Find corresponding SD PDU on pending ack queue 		 */
name|php
operator|=
name|sscop_pack_locate
argument_list|(
name|sop
argument_list|,
name|seq1
argument_list|)
expr_stmt|;
if|if
condition|(
name|php
operator|==
name|NULL
condition|)
block|{
goto|goto
name|goterr
goto|;
block|}
comment|/* 		 * Retransmit this SD PDU if it's not 		 * already scheduled for retranmission. 		 */
if|if
condition|(
operator|(
name|php
operator|->
name|ph_rexmit_lk
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|sop
operator|->
name|so_rexmit_tl
operator|!=
name|php
operator|)
condition|)
block|{
comment|/* 			 * Put PDU on retransmit queue and schedule 			 * transmit servicing 			 */
name|sscop_rexmit_insert
argument_list|(
name|sop
argument_list|,
name|php
argument_list|)
expr_stmt|;
name|sop
operator|->
name|so_flags
operator||=
name|SOF_XMITSRVC
expr_stmt|;
block|}
comment|/* 		 * Bump to next sequence number 		 */
name|SEQ_INCR
argument_list|(
name|seq1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Report retransmitted PDUs 	 */
name|sscop_maa_error
argument_list|(
name|sop
argument_list|,
literal|'V'
argument_list|)
expr_stmt|;
comment|/* 	 * Free PDU buffer chain 	 */
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* 	 * See if transmit queues need servicing 	 */
if|if
condition|(
name|sop
operator|->
name|so_flags
operator|&
name|SOF_XMITSRVC
condition|)
name|sscop_service_xmit
argument_list|(
name|sop
argument_list|)
expr_stmt|;
return|return;
name|goterr
label|:
comment|/* 	 * Protocol/parameter error encountered 	 */
name|sscop_maa_error
argument_list|(
name|sop
argument_list|,
literal|'T'
argument_list|)
expr_stmt|;
comment|/* 	 * Free PDU buffer chain 	 */
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|sop
operator|->
name|so_vers
operator|==
name|SSCOP_VERS_QSAAL
condition|)
comment|/* 		 * Reestablish a new connection 		 */
name|qsaal1_reestablish
argument_list|(
name|sop
argument_list|)
expr_stmt|;
else|else
comment|/* 		 * Initiate error recovery 		 */
name|q2110_error_recovery
argument_list|(
name|sop
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * UD PDU / SOS_* Processor  *  * Arguments:  *	sop	pointer to sscop connection block  *	m	pointer to PDU buffer (without trailer)  *	trlr	pointer to PDU trailer  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|sscop_ud_all
parameter_list|(
name|sop
parameter_list|,
name|m
parameter_list|,
name|trlr
parameter_list|)
name|struct
name|sscop
modifier|*
name|sop
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|caddr_t
name|trlr
decl_stmt|;
block|{
name|int
name|err
decl_stmt|;
comment|/* 	 * Pass data up to user 	 */
name|STACK_CALL
argument_list|(
name|SSCOP_UNITDATA_IND
argument_list|,
name|sop
operator|->
name|so_upper
argument_list|,
name|sop
operator|->
name|so_toku
argument_list|,
name|sop
operator|->
name|so_connvc
argument_list|,
operator|(
name|intptr_t
operator|)
name|m
argument_list|,
literal|0
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * MD PDU / SOS_* Processor  *  * Arguments:  *	sop	pointer to sscop connection block  *	m	pointer to PDU buffer (without trailer)  *	trlr	pointer to PDU trailer  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|sscop_md_all
parameter_list|(
name|sop
parameter_list|,
name|m
parameter_list|,
name|trlr
parameter_list|)
name|struct
name|sscop
modifier|*
name|sop
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|caddr_t
name|trlr
decl_stmt|;
block|{
comment|/* 	 * We don't support MD PDUs 	 */
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

end_unit

