begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * ===================================  * HARP  |  Host ATM Research Platform  * ===================================  *  *  * This Host ATM Research Platform ("HARP") file (the "Software") is  * made available by Network Computing Services, Inc. ("NetworkCS")  * "AS IS".  NetworkCS does not provide maintenance, improvements or  * support of any kind.  *  * NETWORKCS MAKES NO WARRANTIES OR REPRESENTATIONS, EXPRESS OR IMPLIED,  * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE, AS TO ANY ELEMENT OF THE  * SOFTWARE OR ANY SUPPORT PROVIDED IN CONNECTION WITH THIS SOFTWARE.  * In no event shall NetworkCS be responsible for any damages, including  * but not limited to consequential damages, arising from or relating to  * any use of the Software or related support.  *  * Copyright 1994-1998 Network Computing Services, Inc.  *  * Copies of this Software may be made, however, the above copyright  * notice must be reproduced on all copies.  *  *	@(#) $FreeBSD$  *  */
end_comment

begin_comment
comment|/*  * ATM Forum UNI 3.0/3.1 Signalling Manager  * ----------------------------------------  *  * Message formatting module  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netatm/port.h>
end_include

begin_include
include|#
directive|include
file|<netatm/queue.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sys.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sap.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_cm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_if.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_vc.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sigmgr.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_stack.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_var.h>
end_include

begin_include
include|#
directive|include
file|<netatm/uni/unisig_var.h>
end_include

begin_include
include|#
directive|include
file|<netatm/uni/unisig_msg.h>
end_include

begin_include
include|#
directive|include
file|<netatm/uni/unisig_mbuf.h>
end_include

begin_include
include|#
directive|include
file|<netatm/uni/unisig_decode.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"@(#) $FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Local functions  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|usf_enc_ie
name|__P
argument_list|(
operator|(
expr|struct
name|usfmt
operator|*
operator|,
expr|struct
name|ie_generic
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|usf_enc_ie_aalp
name|__P
argument_list|(
operator|(
expr|struct
name|usfmt
operator|*
operator|,
expr|struct
name|ie_generic
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|usf_enc_ie_clrt
name|__P
argument_list|(
operator|(
expr|struct
name|usfmt
operator|*
operator|,
expr|struct
name|ie_generic
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|usf_enc_ie_bbcp
name|__P
argument_list|(
operator|(
expr|struct
name|usfmt
operator|*
operator|,
expr|struct
name|ie_generic
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|usf_enc_ie_bhli
name|__P
argument_list|(
operator|(
expr|struct
name|usfmt
operator|*
operator|,
expr|struct
name|ie_generic
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|usf_enc_ie_blli
name|__P
argument_list|(
operator|(
expr|struct
name|usfmt
operator|*
operator|,
expr|struct
name|ie_generic
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|usf_enc_ie_clst
name|__P
argument_list|(
operator|(
expr|struct
name|usfmt
operator|*
operator|,
expr|struct
name|ie_generic
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|usf_enc_ie_cdad
name|__P
argument_list|(
operator|(
expr|struct
name|usfmt
operator|*
operator|,
expr|struct
name|ie_generic
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|usf_enc_ie_cdsa
name|__P
argument_list|(
operator|(
expr|struct
name|usfmt
operator|*
operator|,
expr|struct
name|ie_generic
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|usf_enc_ie_cgad
name|__P
argument_list|(
operator|(
expr|struct
name|usfmt
operator|*
operator|,
expr|struct
name|ie_generic
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|usf_enc_ie_cgsa
name|__P
argument_list|(
operator|(
expr|struct
name|usfmt
operator|*
operator|,
expr|struct
name|ie_generic
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|usf_enc_ie_caus
name|__P
argument_list|(
operator|(
expr|struct
name|usfmt
operator|*
operator|,
expr|struct
name|ie_generic
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|usf_enc_ie_cnid
name|__P
argument_list|(
operator|(
expr|struct
name|usfmt
operator|*
operator|,
expr|struct
name|ie_generic
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|usf_enc_ie_qosp
name|__P
argument_list|(
operator|(
expr|struct
name|usfmt
operator|*
operator|,
expr|struct
name|ie_generic
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|usf_enc_ie_brpi
name|__P
argument_list|(
operator|(
expr|struct
name|usfmt
operator|*
operator|,
expr|struct
name|ie_generic
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|usf_enc_ie_rsti
name|__P
argument_list|(
operator|(
expr|struct
name|usfmt
operator|*
operator|,
expr|struct
name|ie_generic
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|usf_enc_ie_bsdc
name|__P
argument_list|(
operator|(
expr|struct
name|usfmt
operator|*
operator|,
expr|struct
name|ie_generic
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|usf_enc_ie_trnt
name|__P
argument_list|(
operator|(
expr|struct
name|usfmt
operator|*
operator|,
expr|struct
name|ie_generic
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|usf_enc_ie_uimp
name|__P
argument_list|(
operator|(
expr|struct
name|usfmt
operator|*
operator|,
expr|struct
name|ie_generic
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|usf_enc_ie_ident
name|__P
argument_list|(
operator|(
expr|struct
name|usfmt
operator|*
operator|,
expr|struct
name|ie_generic
operator|*
operator|,
expr|struct
name|ie_decode_tbl
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|usf_enc_atm_addr
name|__P
argument_list|(
operator|(
expr|struct
name|usfmt
operator|*
operator|,
name|Atm_addr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Local variables  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|u_char
name|ident
decl_stmt|;
comment|/* IE identifier */
name|int
argument_list|(
argument|*encode
argument_list|)
name|__P
argument_list|(
operator|(
expr|struct
name|usfmt
operator|*
operator|,
expr|struct
name|ie_generic
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* Encoding function */
block|}
name|ie_table
index|[]
init|=
block|{
block|{
name|UNI_IE_AALP
block|,
name|usf_enc_ie_aalp
block|}
block|,
block|{
name|UNI_IE_CLRT
block|,
name|usf_enc_ie_clrt
block|}
block|,
block|{
name|UNI_IE_BBCP
block|,
name|usf_enc_ie_bbcp
block|}
block|,
block|{
name|UNI_IE_BHLI
block|,
name|usf_enc_ie_bhli
block|}
block|,
block|{
name|UNI_IE_BLLI
block|,
name|usf_enc_ie_blli
block|}
block|,
block|{
name|UNI_IE_CLST
block|,
name|usf_enc_ie_clst
block|}
block|,
block|{
name|UNI_IE_CDAD
block|,
name|usf_enc_ie_cdad
block|}
block|,
block|{
name|UNI_IE_CDSA
block|,
name|usf_enc_ie_cdsa
block|}
block|,
block|{
name|UNI_IE_CGAD
block|,
name|usf_enc_ie_cgad
block|}
block|,
block|{
name|UNI_IE_CGSA
block|,
name|usf_enc_ie_cgsa
block|}
block|,
block|{
name|UNI_IE_CAUS
block|,
name|usf_enc_ie_caus
block|}
block|,
block|{
name|UNI_IE_CNID
block|,
name|usf_enc_ie_cnid
block|}
block|,
block|{
name|UNI_IE_QOSP
block|,
name|usf_enc_ie_qosp
block|}
block|,
block|{
name|UNI_IE_BRPI
block|,
name|usf_enc_ie_brpi
block|}
block|,
block|{
name|UNI_IE_RSTI
block|,
name|usf_enc_ie_rsti
block|}
block|,
block|{
name|UNI_IE_BLSH
block|,
name|usf_enc_ie_uimp
block|}
block|,
block|{
name|UNI_IE_BNSH
block|,
name|usf_enc_ie_uimp
block|}
block|,
block|{
name|UNI_IE_BSDC
block|,
name|usf_enc_ie_bsdc
block|}
block|,
block|{
name|UNI_IE_TRNT
block|,
name|usf_enc_ie_trnt
block|}
block|,
block|{
name|UNI_IE_EPRF
block|,
name|usf_enc_ie_uimp
block|}
block|,
block|{
name|UNI_IE_EPST
block|,
name|usf_enc_ie_uimp
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|struct
name|ie_decode_tbl
name|ie_aal1_tbl
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|ie_decode_tbl
name|ie_aal4_tbl_30
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|ie_decode_tbl
name|ie_aal4_tbl_31
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|ie_decode_tbl
name|ie_aal5_tbl_30
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|ie_decode_tbl
name|ie_aal5_tbl_31
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|ie_decode_tbl
name|ie_clrt_tbl
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Encode a UNI signalling message  *  * Arguments:  *	usf	pointer to a unisig formatting structure  *	msg	pointer to a signalling message structure  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
name|int
name|usf_enc_msg
parameter_list|(
name|usf
parameter_list|,
name|msg
parameter_list|)
name|struct
name|usfmt
modifier|*
name|usf
decl_stmt|;
name|struct
name|unisig_msg
modifier|*
name|msg
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|len
decl_stmt|,
name|rc
decl_stmt|;
name|u_char
name|c
decl_stmt|;
name|u_char
modifier|*
name|lp0
decl_stmt|,
modifier|*
name|lp1
decl_stmt|;
name|struct
name|ie_generic
modifier|*
name|ie
decl_stmt|;
union|union
block|{
name|short
name|s
decl_stmt|;
name|u_char
name|sb
index|[
sizeof|sizeof
argument_list|(
name|short
argument_list|)
index|]
decl_stmt|;
block|}
name|su
union|;
name|ATM_DEBUG2
argument_list|(
literal|"usf_enc_msg: usf=%p, msg=%p\n"
argument_list|,
name|usf
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|/* 	 * Encode the protocol discriminator 	 */
name|c
operator|=
name|UNI_MSG_DISC_Q93B
expr_stmt|;
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
comment|/* 	 * Encode the call reference length 	 */
name|c
operator|=
literal|3
expr_stmt|;
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
comment|/* 	 * Encode the call reference 	 */
name|rc
operator|=
name|usf_int3
argument_list|(
name|usf
argument_list|,
operator|&
name|msg
operator|->
name|msg_call_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
comment|/* 	 * Encode the message type 	 */
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|msg
operator|->
name|msg_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
comment|/* 	 * Encode the message type extension 	 */
name|c
operator|=
operator|(
operator|(
name|msg
operator|->
name|msg_type_flag
operator|&
name|UNI_MSG_TYPE_FLAG_MASK
operator|)
operator|<<
name|UNI_MSG_TYPE_FLAG_SHIFT
operator|)
operator|+
operator|(
name|msg
operator|->
name|msg_type_action
operator|&
name|UNI_MSG_TYPE_ACT_MASK
operator|)
operator|+
name|UNI_IE_EXT_BIT
expr_stmt|;
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
comment|/* 	 * Save the location of the message length and encode a length 	 * of zero for now.  We'll fix the length up at the end. 	 */
name|su
operator|.
name|s
operator|=
literal|0
expr_stmt|;
name|rc
operator|=
name|usf_byte_mark
argument_list|(
name|usf
argument_list|,
operator|&
name|su
operator|.
name|sb
index|[
sizeof|sizeof
argument_list|(
name|short
argument_list|)
operator|-
literal|2
index|]
argument_list|,
operator|&
name|lp0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|rc
operator|=
name|usf_byte_mark
argument_list|(
name|usf
argument_list|,
operator|&
name|su
operator|.
name|sb
index|[
sizeof|sizeof
argument_list|(
name|short
argument_list|)
operator|-
literal|1
index|]
argument_list|,
operator|&
name|lp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
comment|/* 	 * Process information elements 	 */
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UNI_MSG_IE_CNT
condition|;
name|i
operator|++
control|)
block|{
name|ie
operator|=
name|msg
operator|->
name|msg_ie_vec
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|ie
condition|)
block|{
name|rc
operator|=
name|usf_enc_ie
argument_list|(
name|usf
argument_list|,
name|ie
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|len
operator|+=
operator|(
name|ie
operator|->
name|ie_length
operator|+
name|UNI_IE_HDR_LEN
operator|)
expr_stmt|;
name|ie
operator|=
name|ie
operator|->
name|ie_next
expr_stmt|;
block|}
block|}
comment|/* 	 * Fix the message length in the encoded message 	 */
name|su
operator|.
name|s
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|len
argument_list|)
expr_stmt|;
operator|*
name|lp0
operator|=
name|su
operator|.
name|sb
index|[
sizeof|sizeof
argument_list|(
name|short
argument_list|)
operator|-
literal|2
index|]
expr_stmt|;
operator|*
name|lp1
operator|=
name|su
operator|.
name|sb
index|[
sizeof|sizeof
argument_list|(
name|short
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Encode an information element  *  * Arguments:  *	usf	pointer to a UNISIG formatting structure  *	msg	pointer to a UNISIG message structure  *	ie	pointer to a generic IE structure  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
specifier|static
name|int
name|usf_enc_ie
parameter_list|(
name|usf
parameter_list|,
name|ie
parameter_list|)
name|struct
name|usfmt
modifier|*
name|usf
decl_stmt|;
name|struct
name|ie_generic
modifier|*
name|ie
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
name|u_char
name|c
decl_stmt|;
name|u_char
modifier|*
name|lp0
decl_stmt|,
modifier|*
name|lp1
decl_stmt|;
union|union
block|{
name|short
name|s
decl_stmt|;
name|u_char
name|sb
index|[
sizeof|sizeof
argument_list|(
name|short
argument_list|)
index|]
decl_stmt|;
block|}
name|su
union|;
name|ATM_DEBUG2
argument_list|(
literal|"usf_enc_ie: usf=%p, ie=%p\n"
argument_list|,
name|usf
argument_list|,
name|ie
argument_list|)
expr_stmt|;
comment|/* 	 * Encode the IE identifier 	 */
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|ie
operator|->
name|ie_ident
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
comment|/* 	 * Encode the extended type 	 */
name|c
operator|=
operator|(
operator|(
name|ie
operator|->
name|ie_coding
operator|&
name|UNI_IE_CODE_MASK
operator|)
operator|<<
name|UNI_IE_CODE_SHIFT
operator|)
operator|+
operator|(
operator|(
name|ie
operator|->
name|ie_flag
operator|&
name|UNI_IE_FLAG_MASK
operator|)
operator|<<
name|UNI_IE_FLAG_SHIFT
operator|)
operator|+
operator|(
name|ie
operator|->
name|ie_action
operator|&
name|UNI_IE_ACT_MASK
operator|)
operator|+
name|UNI_IE_EXT_BIT
expr_stmt|;
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
comment|/* 	 * Mark the current location in the output stream.  Encode a 	 * length of zero for now;  we'll come back and fix it up at 	 * the end. 	 */
name|su
operator|.
name|s
operator|=
literal|0
expr_stmt|;
name|rc
operator|=
name|usf_byte_mark
argument_list|(
name|usf
argument_list|,
operator|&
name|su
operator|.
name|sb
index|[
sizeof|sizeof
argument_list|(
name|short
argument_list|)
operator|-
literal|2
index|]
argument_list|,
operator|&
name|lp0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|rc
operator|=
name|usf_byte_mark
argument_list|(
name|usf
argument_list|,
operator|&
name|su
operator|.
name|sb
index|[
sizeof|sizeof
argument_list|(
name|short
argument_list|)
operator|-
literal|1
index|]
argument_list|,
operator|&
name|lp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
comment|/* 	 * Look up the information element in the table 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|ie
operator|->
name|ie_ident
operator|!=
name|ie_table
index|[
name|i
index|]
operator|.
name|ident
operator|)
operator|&&
operator|(
name|ie_table
index|[
name|i
index|]
operator|.
name|encode
operator|!=
name|NULL
operator|)
condition|;
name|i
operator|++
control|)
block|{ 	}
if|if
condition|(
name|ie_table
index|[
name|i
index|]
operator|.
name|encode
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Unrecognized IE 		 */
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * Process the IE by calling the function indicated 	 * in the IE table 	 */
name|rc
operator|=
name|ie_table
index|[
name|i
index|]
operator|.
name|encode
argument_list|(
name|usf
argument_list|,
name|ie
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
comment|/* 	 * Set the length in the output stream 	 */
name|su
operator|.
name|s
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|ie
operator|->
name|ie_length
argument_list|)
expr_stmt|;
operator|*
name|lp0
operator|=
name|su
operator|.
name|sb
index|[
sizeof|sizeof
argument_list|(
name|short
argument_list|)
operator|-
literal|2
index|]
expr_stmt|;
operator|*
name|lp1
operator|=
name|su
operator|.
name|sb
index|[
sizeof|sizeof
argument_list|(
name|short
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Encode an AAL parameters information element  *  * Arguments:  *	usf	pointer to a unisig formatting structure  *	ie	pointer to an AAL parms IE structure  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
specifier|static
name|int
name|usf_enc_ie_aalp
parameter_list|(
name|usf
parameter_list|,
name|ie
parameter_list|)
name|struct
name|usfmt
modifier|*
name|usf
decl_stmt|;
name|struct
name|ie_generic
modifier|*
name|ie
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|rc
init|=
literal|0
decl_stmt|;
name|ATM_DEBUG2
argument_list|(
literal|"usf_enc_ie_aalp: usf=%p, ie=%p\n"
argument_list|,
name|usf
argument_list|,
name|ie
argument_list|)
expr_stmt|;
name|ie
operator|->
name|ie_length
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Encode the AAL type 	 */
if|if
condition|(
name|ie
operator|->
name|ie_aalp_aal_type
operator|==
name|T_ATM_ABSENT
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|ie
operator|->
name|ie_aalp_aal_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
comment|/* 	 * Process based on AAL type 	 */
switch|switch
condition|(
name|ie
operator|->
name|ie_aalp_aal_type
condition|)
block|{
case|case
name|UNI_IE_AALP_AT_AAL1
case|:
name|rc
operator|=
name|usf_enc_ie_ident
argument_list|(
name|usf
argument_list|,
name|ie
argument_list|,
name|ie_aal1_tbl
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNI_IE_AALP_AT_AAL3
case|:
if|if
condition|(
name|usf
operator|->
name|usf_sig
operator|->
name|us_proto
operator|==
name|ATM_SIG_UNI30
condition|)
name|rc
operator|=
name|usf_enc_ie_ident
argument_list|(
name|usf
argument_list|,
name|ie
argument_list|,
name|ie_aal4_tbl_30
argument_list|)
expr_stmt|;
else|else
name|rc
operator|=
name|usf_enc_ie_ident
argument_list|(
name|usf
argument_list|,
name|ie
argument_list|,
name|ie_aal4_tbl_31
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNI_IE_AALP_AT_AAL5
case|:
if|if
condition|(
name|usf
operator|->
name|usf_sig
operator|->
name|us_proto
operator|==
name|ATM_SIG_UNI30
condition|)
name|rc
operator|=
name|usf_enc_ie_ident
argument_list|(
name|usf
argument_list|,
name|ie
argument_list|,
name|ie_aal5_tbl_30
argument_list|)
expr_stmt|;
else|else
name|rc
operator|=
name|usf_enc_ie_ident
argument_list|(
name|usf
argument_list|,
name|ie
argument_list|,
name|ie_aal5_tbl_31
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNI_IE_AALP_AT_AALU
case|:
comment|/* 			 * Encode the user data 			 */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
sizeof|sizeof
argument_list|(
name|ie
operator|->
name|ie_aalp_user_info
argument_list|)
condition|)
block|{
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|ie
operator|->
name|ie_aalp_user_info
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
break|break;
name|i
operator|++
expr_stmt|;
name|ie
operator|->
name|ie_length
operator|++
expr_stmt|;
block|}
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|ie
operator|->
name|ie_length
operator|++
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Encode a user cell rate information element  *  * This routine just encodes the parameters required for best  * effort service.  *  * Arguments:  *	usf	pointer to a unisig formatting structure  *	ie	pointer to a cell rate IE structure  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
specifier|static
name|int
name|usf_enc_ie_clrt
parameter_list|(
name|usf
parameter_list|,
name|ie
parameter_list|)
name|struct
name|usfmt
modifier|*
name|usf
decl_stmt|;
name|struct
name|ie_generic
modifier|*
name|ie
decl_stmt|;
block|{
name|int
name|rc
decl_stmt|;
name|ATM_DEBUG2
argument_list|(
literal|"usf_enc_ie_clrt: usf=%p, ie=%p\n"
argument_list|,
name|usf
argument_list|,
name|ie
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NOTDEF
comment|/* 	 * Encode Peak Cell Rate Forward CLP = 0 + 1 	 */
name|c
operator|=
name|UNI_IE_CLRT_FWD_PEAK_01_ID
expr_stmt|;
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|rc
operator|=
name|usf_int3
argument_list|(
name|usf
argument_list|,
operator|&
name|ie
operator|->
name|ie_clrt_fwd_peak_01
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
comment|/* 	 * Encode Peak Cell Rate Backward CLP = 0 + 1 	 */
name|c
operator|=
name|UNI_IE_CLRT_BKWD_PEAK_01_ID
expr_stmt|;
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|rc
operator|=
name|usf_int3
argument_list|(
name|usf
argument_list|,
operator|&
name|ie
operator|->
name|ie_clrt_bkwd_peak_01
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
comment|/* 	 * Encode Best Effort Flag 	 */
name|c
operator|=
name|UNI_IE_CLRT_BEST_EFFORT_ID
expr_stmt|;
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
comment|/* 	 * Set IE length 	 */
name|ie
operator|->
name|ie_length
operator|=
literal|9
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Encode the user cell rate IE using the table 	 */
name|ie
operator|->
name|ie_length
operator|=
literal|0
expr_stmt|;
name|rc
operator|=
name|usf_enc_ie_ident
argument_list|(
name|usf
argument_list|,
name|ie
argument_list|,
name|ie_clrt_tbl
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Encode a broadband bearer capability information element  *  * Arguments:  *	usf	pointer to a unisig formatting structure  *	ie	pointer to a cell rate IE structure  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
specifier|static
name|int
name|usf_enc_ie_bbcp
parameter_list|(
name|usf
parameter_list|,
name|ie
parameter_list|)
name|struct
name|usfmt
modifier|*
name|usf
decl_stmt|;
name|struct
name|ie_generic
modifier|*
name|ie
decl_stmt|;
block|{
name|int
name|rc
decl_stmt|;
name|u_char
name|c
decl_stmt|;
name|ATM_DEBUG2
argument_list|(
literal|"usf_enc_ie_bbcp: usf=%p, ie=%p\n"
argument_list|,
name|usf
argument_list|,
name|ie
argument_list|)
expr_stmt|;
name|ie
operator|->
name|ie_length
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Encode the broadband bearer class 	 */
if|if
condition|(
name|ie
operator|->
name|ie_bbcp_bearer_class
operator|==
name|T_ATM_ABSENT
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|c
operator|=
name|ie
operator|->
name|ie_bbcp_bearer_class
operator|&
name|UNI_IE_BBCP_BC_MASK
expr_stmt|;
if|if
condition|(
name|ie
operator|->
name|ie_bbcp_bearer_class
operator|!=
name|UNI_IE_BBCP_BC_BCOB_X
condition|)
name|c
operator||=
name|UNI_IE_EXT_BIT
expr_stmt|;
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|ie
operator|->
name|ie_length
operator|++
expr_stmt|;
comment|/* 	 * If the broadband bearer class was X, the next 	 * byte has the traffic type and timing requirements 	 */
if|if
condition|(
name|ie
operator|->
name|ie_bbcp_bearer_class
operator|==
name|UNI_IE_BBCP_BC_BCOB_X
condition|)
block|{
name|c
operator|=
operator|(
operator|(
name|ie
operator|->
name|ie_bbcp_traffic_type
operator|&
name|UNI_IE_BBCP_TT_MASK
operator|)
operator|<<
name|UNI_IE_BBCP_TT_SHIFT
operator|)
operator|+
operator|(
name|ie
operator|->
name|ie_bbcp_timing_req
operator|&
name|UNI_IE_BBCP_TR_MASK
operator|)
operator|+
name|UNI_IE_EXT_BIT
expr_stmt|;
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|ie
operator|->
name|ie_length
operator|++
expr_stmt|;
block|}
comment|/* 	 * Encode the clipping and user plane connection configuration 	 */
name|c
operator|=
operator|(
operator|(
name|ie
operator|->
name|ie_bbcp_clipping
operator|&
name|UNI_IE_BBCP_SC_MASK
operator|)
operator|<<
name|UNI_IE_BBCP_SC_SHIFT
operator|)
operator|+
operator|(
name|ie
operator|->
name|ie_bbcp_conn_config
operator|&
name|UNI_IE_BBCP_CC_MASK
operator|)
operator|+
name|UNI_IE_EXT_BIT
expr_stmt|;
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|ie
operator|->
name|ie_length
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Encode a broadband high layer information element  *  * Arguments:  *	usf	pointer to a unisig formatting structure  *	ie	pointer to a cell rate IE structure  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
specifier|static
name|int
name|usf_enc_ie_bhli
parameter_list|(
name|usf
parameter_list|,
name|ie
parameter_list|)
name|struct
name|usfmt
modifier|*
name|usf
decl_stmt|;
name|struct
name|ie_generic
modifier|*
name|ie
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
name|u_int
name|type
decl_stmt|;
name|ATM_DEBUG2
argument_list|(
literal|"usf_enc_ie_bhli: usf=%p, ie=%p\n"
argument_list|,
name|usf
argument_list|,
name|ie
argument_list|)
expr_stmt|;
name|ie
operator|->
name|ie_length
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Encode the high layer information type 	 */
if|if
condition|(
name|ie
operator|->
name|ie_bhli_type
operator|==
name|T_ATM_ABSENT
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|type
operator|=
name|ie
operator|->
name|ie_bhli_type
operator||
name|UNI_IE_EXT_BIT
expr_stmt|;
name|rc
operator|=
name|usf_ext
argument_list|(
name|usf
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|ie
operator|->
name|ie_length
operator|++
expr_stmt|;
comment|/* 	 * What comes next depends on the type 	 */
switch|switch
condition|(
name|ie
operator|->
name|ie_bhli_type
condition|)
block|{
case|case
name|UNI_IE_BHLI_TYPE_ISO
case|:
case|case
name|UNI_IE_BHLI_TYPE_USER
case|:
comment|/* 		 * ISO or user-specified parameters -- take the 		 * length of information from the IE length 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ie
operator|->
name|ie_length
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|ie
operator|->
name|ie_bhli_info
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|ie
operator|->
name|ie_length
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|UNI_IE_BHLI_TYPE_HLP
case|:
comment|/* 		 * Make sure the IE is long enough for the high 		 * layer profile information, then get it 		 */
if|if
condition|(
name|usf
operator|->
name|usf_sig
operator|->
name|us_proto
operator|!=
name|ATM_SIG_UNI30
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UNI_IE_BHLI_HLP_LEN
condition|;
name|i
operator|++
control|)
block|{
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|ie
operator|->
name|ie_bhli_info
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|ie
operator|->
name|ie_length
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|UNI_IE_BHLI_TYPE_VSA
case|:
comment|/* 		 * Make sure the IE is long enough for the vendor- 		 * specific application information, then get it 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UNI_IE_BHLI_VSA_LEN
condition|;
name|i
operator|++
control|)
block|{
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|ie
operator|->
name|ie_bhli_info
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|ie
operator|->
name|ie_length
operator|++
expr_stmt|;
block|}
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Encode a broadband low layer information element  *  * Arguments:  *	usf	pointer to a unisig formatting structure  *	ie	pointer to a cell rate IE structure  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
specifier|static
name|int
name|usf_enc_ie_blli
parameter_list|(
name|usf
parameter_list|,
name|ie
parameter_list|)
name|struct
name|usfmt
modifier|*
name|usf
decl_stmt|;
name|struct
name|ie_generic
modifier|*
name|ie
decl_stmt|;
block|{
name|u_char
name|c
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|u_int
name|ipi
decl_stmt|;
name|ATM_DEBUG2
argument_list|(
literal|"usf_enc_ie_blli: usf=%p, ie=%p\n"
argument_list|,
name|usf
argument_list|,
name|ie
argument_list|)
expr_stmt|;
name|ie
operator|->
name|ie_length
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Encode paramteters for whichever protocol layers the 	 * user specified 	 */
comment|/* 	 * Layer 1 information 	 */
if|if
condition|(
name|ie
operator|->
name|ie_blli_l1_id
operator|&&
name|ie
operator|->
name|ie_blli_l1_id
operator|!=
name|T_ATM_ABSENT
condition|)
block|{
name|c
operator|=
operator|(
name|UNI_IE_BLLI_L1_ID
operator|<<
name|UNI_IE_BLLI_LID_SHIFT
operator|)
operator|+
operator|(
name|ie
operator|->
name|ie_blli_l1_id
operator|&
name|UNI_IE_BLLI_LP_MASK
operator|)
operator|+
name|UNI_IE_EXT_BIT
expr_stmt|;
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|ie
operator|->
name|ie_length
operator|++
expr_stmt|;
block|}
comment|/* 	 * Layer 2 information 	 */
if|if
condition|(
name|ie
operator|->
name|ie_blli_l2_id
operator|&&
name|ie
operator|->
name|ie_blli_l2_id
operator|!=
name|T_ATM_ABSENT
condition|)
block|{
name|c
operator|=
operator|(
name|UNI_IE_BLLI_L2_ID
operator|<<
name|UNI_IE_BLLI_LID_SHIFT
operator|)
operator|+
operator|(
name|ie
operator|->
name|ie_blli_l2_id
operator|&
name|UNI_IE_BLLI_LP_MASK
operator|)
expr_stmt|;
switch|switch
condition|(
name|ie
operator|->
name|ie_blli_l2_id
condition|)
block|{
case|case
name|UNI_IE_BLLI_L2P_X25L
case|:
case|case
name|UNI_IE_BLLI_L2P_X25M
case|:
case|case
name|UNI_IE_BLLI_L2P_HDLC1
case|:
case|case
name|UNI_IE_BLLI_L2P_HDLC2
case|:
case|case
name|UNI_IE_BLLI_L2P_HDLC3
case|:
case|case
name|UNI_IE_BLLI_L2P_Q922
case|:
case|case
name|UNI_IE_BLLI_L2P_ISO7776
case|:
comment|/* 			 * Write the Layer 2 type 			 */
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|ie
operator|->
name|ie_length
operator|++
expr_stmt|;
comment|/* 			 * Encode the Layer 2 mode 			 */
if|if
condition|(
name|ie
operator|->
name|ie_blli_l2_mode
condition|)
block|{
name|c
operator|=
operator|(
name|ie
operator|->
name|ie_blli_l2_mode
operator|&
name|UNI_IE_BLLI_L2MODE_MASK
operator|)
operator|<<
name|UNI_IE_BLLI_L2MODE_SHIFT
expr_stmt|;
if|if
condition|(
operator|!
name|ie
operator|->
name|ie_blli_l2_window
condition|)
name|c
operator||=
name|UNI_IE_EXT_BIT
expr_stmt|;
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|ie
operator|->
name|ie_length
operator|++
expr_stmt|;
block|}
comment|/* 			 * Encode the Layer 2 window size 			 */
if|if
condition|(
name|ie
operator|->
name|ie_blli_l2_window
condition|)
block|{
name|c
operator|=
operator|(
name|ie
operator|->
name|ie_blli_l2_window
operator|&
name|UNI_IE_EXT_MASK
operator|)
operator|+
name|UNI_IE_EXT_BIT
expr_stmt|;
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|ie
operator|->
name|ie_length
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|UNI_IE_BLLI_L2P_USER
case|:
comment|/* 			 * Write the Layer 2 type 			 */
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|ie
operator|->
name|ie_length
operator|++
expr_stmt|;
comment|/* 			 * Encode the user-specified layer 2 info 			 */
name|c
operator|=
operator|(
name|ie
operator|->
name|ie_blli_l2_user_proto
operator|&
name|UNI_IE_EXT_MASK
operator|)
operator|+
name|UNI_IE_EXT_BIT
expr_stmt|;
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|ie
operator|->
name|ie_length
operator|++
expr_stmt|;
break|break;
default|default:
comment|/* 			 * Write the Layer 2 type 			 */
name|c
operator||=
name|UNI_IE_EXT_BIT
expr_stmt|;
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|ie
operator|->
name|ie_length
operator|++
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * Layer 3 information 	 */
if|if
condition|(
name|ie
operator|->
name|ie_blli_l3_id
operator|&&
name|ie
operator|->
name|ie_blli_l3_id
operator|!=
name|T_ATM_ABSENT
condition|)
block|{
comment|/* 		 * Encode the layer 3 protocol ID 		 */
name|c
operator|=
operator|(
name|UNI_IE_BLLI_L3_ID
operator|<<
name|UNI_IE_BLLI_LID_SHIFT
operator|)
operator|+
operator|(
name|ie
operator|->
name|ie_blli_l3_id
operator|&
name|UNI_IE_BLLI_LP_MASK
operator|)
expr_stmt|;
comment|/* 		 * Process other fields based on protocol ID 		 */
switch|switch
condition|(
name|ie
operator|->
name|ie_blli_l3_id
condition|)
block|{
case|case
name|UNI_IE_BLLI_L3P_X25
case|:
case|case
name|UNI_IE_BLLI_L3P_ISO8208
case|:
case|case
name|UNI_IE_BLLI_L3P_ISO8878
case|:
comment|/* 			 * Write the protocol ID 			 */
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|ie
operator|->
name|ie_length
operator|++
expr_stmt|;
if|if
condition|(
name|ie
operator|->
name|ie_blli_l3_mode
operator|||
name|ie
operator|->
name|ie_blli_l3_packet_size
operator|||
name|ie
operator|->
name|ie_blli_l3_window
condition|)
block|{
name|c
operator|=
operator|(
name|ie
operator|->
name|ie_blli_l3_mode
operator|&
name|UNI_IE_BLLI_L3MODE_MASK
operator|)
operator|<<
name|UNI_IE_BLLI_L3MODE_SHIFT
expr_stmt|;
if|if
condition|(
operator|!
name|ie
operator|->
name|ie_blli_l3_packet_size
operator|&&
operator|!
name|ie
operator|->
name|ie_blli_l3_window
condition|)
name|c
operator||=
name|UNI_IE_EXT_BIT
expr_stmt|;
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|ie
operator|->
name|ie_length
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ie
operator|->
name|ie_blli_l3_packet_size
operator|||
name|ie
operator|->
name|ie_blli_l3_window
condition|)
block|{
name|c
operator|=
name|ie
operator|->
name|ie_blli_l3_packet_size
operator|&
name|UNI_IE_BLLI_L3PS_MASK
expr_stmt|;
if|if
condition|(
operator|!
name|ie
operator|->
name|ie_blli_l3_window
condition|)
name|c
operator||=
name|UNI_IE_EXT_BIT
expr_stmt|;
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|ie
operator|->
name|ie_length
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ie
operator|->
name|ie_blli_l3_window
condition|)
block|{
name|c
operator|=
operator|(
name|ie
operator|->
name|ie_blli_l3_window
operator|&
name|UNI_IE_EXT_MASK
operator|)
operator|+
name|UNI_IE_EXT_BIT
expr_stmt|;
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|ie
operator|->
name|ie_length
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|UNI_IE_BLLI_L3P_USER
case|:
comment|/* 			 * Write the protocol ID 			 */
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|ie
operator|->
name|ie_length
operator|++
expr_stmt|;
comment|/* 			 * Encode the user-specified protocol info 			 */
name|c
operator|=
operator|(
name|ie
operator|->
name|ie_blli_l3_user_proto
operator|&
name|UNI_IE_EXT_MASK
operator|)
operator|+
name|UNI_IE_EXT_BIT
expr_stmt|;
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|ie
operator|->
name|ie_length
operator|++
expr_stmt|;
break|break;
case|case
name|UNI_IE_BLLI_L3P_ISO9577
case|:
comment|/* 			 * Write the protocol ID 			 */
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|ie
operator|->
name|ie_length
operator|++
expr_stmt|;
comment|/* 			 * Encode the IPI 			 */
name|ipi
operator|=
name|ie
operator|->
name|ie_blli_l3_ipi
operator|<<
name|UNI_IE_BLLI_L3IPI_SHIFT
expr_stmt|;
name|rc
operator|=
name|usf_ext
argument_list|(
name|usf
argument_list|,
operator|&
name|ipi
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|ie
operator|->
name|ie_length
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|ie
operator|->
name|ie_blli_l3_ipi
operator|==
name|UNI_IE_BLLI_L3IPI_SNAP
condition|)
block|{
name|c
operator|=
name|UNI_IE_EXT_BIT
expr_stmt|;
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|ie
operator|->
name|ie_blli_l3_oui
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|ie
operator|->
name|ie_blli_l3_oui
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|ie
operator|->
name|ie_blli_l3_oui
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|ie
operator|->
name|ie_blli_l3_pid
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|ie
operator|->
name|ie_blli_l3_pid
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|ie
operator|->
name|ie_length
operator|+=
literal|6
expr_stmt|;
block|}
break|break;
default|default:
comment|/* 			 * Write the layer 3 protocol ID 			 */
name|c
operator||=
name|UNI_IE_EXT_BIT
expr_stmt|;
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|ie
operator|->
name|ie_length
operator|++
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Encode a call state information element  *  * Arguments:  *	usf	pointer to a unisig formatting structure  *	ie	pointer to a cell rate IE structure  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
specifier|static
name|int
name|usf_enc_ie_clst
parameter_list|(
name|usf
parameter_list|,
name|ie
parameter_list|)
name|struct
name|usfmt
modifier|*
name|usf
decl_stmt|;
name|struct
name|ie_generic
modifier|*
name|ie
decl_stmt|;
block|{
name|int
name|rc
decl_stmt|;
name|u_char
name|c
decl_stmt|;
name|ATM_DEBUG2
argument_list|(
literal|"usf_enc_ie_clst: usf=%p, ie=%p\n"
argument_list|,
name|usf
argument_list|,
name|ie
argument_list|)
expr_stmt|;
name|c
operator|=
name|ie
operator|->
name|ie_clst_state
operator|&
name|UNI_IE_CLST_STATE_MASK
expr_stmt|;
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|ie
operator|->
name|ie_length
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Encode a called party number information element  *  * Arguments:  *	usf	pointer to a unisig formatting structure  *	ie	pointer to a cell rate IE structure  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
specifier|static
name|int
name|usf_enc_ie_cdad
parameter_list|(
name|usf
parameter_list|,
name|ie
parameter_list|)
name|struct
name|usfmt
modifier|*
name|usf
decl_stmt|;
name|struct
name|ie_generic
modifier|*
name|ie
decl_stmt|;
block|{
name|u_char
name|c
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|ATM_DEBUG2
argument_list|(
literal|"usf_enc_ie_cdad: usf=%p, ie=%p\n"
argument_list|,
name|usf
argument_list|,
name|ie
argument_list|)
expr_stmt|;
comment|/* 	 * Encode the numbering plan 	 */
switch|switch
condition|(
name|ie
operator|->
name|ie_cdad_addr
operator|.
name|address_format
condition|)
block|{
case|case
name|T_ATM_E164_ADDR
case|:
name|c
operator|=
name|UNI_IE_CDAD_PLAN_E164
operator|+
operator|(
name|UNI_IE_CDAD_TYPE_INTL
operator|<<
name|UNI_IE_CDAD_TYPE_SHIFT
operator|)
expr_stmt|;
name|ie
operator|->
name|ie_length
operator|=
sizeof|sizeof
argument_list|(
name|Atm_addr_e164
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|T_ATM_ENDSYS_ADDR
case|:
name|c
operator|=
name|UNI_IE_CDAD_PLAN_NSAP
operator|+
operator|(
name|UNI_IE_CDAD_TYPE_UNK
operator|<<
name|UNI_IE_CDAD_TYPE_SHIFT
operator|)
expr_stmt|;
name|ie
operator|->
name|ie_length
operator|=
sizeof|sizeof
argument_list|(
name|Atm_addr_nsap
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|c
operator||=
name|UNI_IE_EXT_BIT
expr_stmt|;
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
comment|/* 	 * Encode the ATM address 	 */
name|rc
operator|=
name|usf_enc_atm_addr
argument_list|(
name|usf
argument_list|,
operator|&
name|ie
operator|->
name|ie_cdad_addr
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Encode a called party subaddress information element  *  * Arguments:  *	usf	pointer to a unisig formatting structure  *	ie	pointer to a cell rate IE structure  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
specifier|static
name|int
name|usf_enc_ie_cdsa
parameter_list|(
name|usf
parameter_list|,
name|ie
parameter_list|)
name|struct
name|usfmt
modifier|*
name|usf
decl_stmt|;
name|struct
name|ie_generic
modifier|*
name|ie
decl_stmt|;
block|{
name|u_char
name|c
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/* 	 * Encode the subaddress type 	 */
switch|switch
condition|(
name|ie
operator|->
name|ie_cdsa_addr
operator|.
name|address_format
condition|)
block|{
case|case
name|T_ATM_ENDSYS_ADDR
case|:
name|c
operator|=
name|UNI_IE_CDSA_TYPE_AESA
operator|<<
name|UNI_IE_CDSA_TYPE_SHIFT
expr_stmt|;
name|ie
operator|->
name|ie_length
operator|=
sizeof|sizeof
argument_list|(
name|Atm_addr_nsap
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|c
operator||=
name|UNI_IE_EXT_BIT
expr_stmt|;
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
comment|/* 	 * Encode the ATM address 	 */
name|rc
operator|=
name|usf_enc_atm_addr
argument_list|(
name|usf
argument_list|,
operator|&
name|ie
operator|->
name|ie_cdsa_addr
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Encode a calling party number information element  *  * Arguments:  *	usf	pointer to a unisig formatting structure  *	ie	pointer to a cell rate IE structure  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
specifier|static
name|int
name|usf_enc_ie_cgad
parameter_list|(
name|usf
parameter_list|,
name|ie
parameter_list|)
name|struct
name|usfmt
modifier|*
name|usf
decl_stmt|;
name|struct
name|ie_generic
modifier|*
name|ie
decl_stmt|;
block|{
name|u_char
name|c
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|ATM_DEBUG2
argument_list|(
literal|"usf_enc_ie_cgad: usf=%p, ie=%p\n"
argument_list|,
name|usf
argument_list|,
name|ie
argument_list|)
expr_stmt|;
comment|/* 	 * Encode the numbering plan 	 */
switch|switch
condition|(
name|ie
operator|->
name|ie_cgad_addr
operator|.
name|address_format
condition|)
block|{
case|case
name|T_ATM_E164_ADDR
case|:
name|c
operator|=
name|UNI_IE_CGAD_PLAN_E164
operator|+
operator|(
name|UNI_IE_CGAD_TYPE_INTL
operator|<<
name|UNI_IE_CGAD_TYPE_SHIFT
operator|)
operator|+
name|UNI_IE_EXT_BIT
expr_stmt|;
name|ie
operator|->
name|ie_length
operator|=
sizeof|sizeof
argument_list|(
name|Atm_addr_e164
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|T_ATM_ENDSYS_ADDR
case|:
name|c
operator|=
name|UNI_IE_CGAD_PLAN_NSAP
operator|+
operator|(
name|UNI_IE_CGAD_TYPE_UNK
operator|<<
name|UNI_IE_CGAD_TYPE_SHIFT
operator|)
operator|+
name|UNI_IE_EXT_BIT
expr_stmt|;
name|ie
operator|->
name|ie_length
operator|=
sizeof|sizeof
argument_list|(
name|Atm_addr_nsap
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
comment|/* 	 * Encode the presentation and screening indicators 	 */
ifdef|#
directive|ifdef
name|NOTDEF
name|c
operator|=
operator|(
operator|(
name|ie
operator|->
name|ie_cgad_pres_ind
operator|&
name|UNI_IE_CGAD_PRES_MASK
operator|)
operator|<<
name|UNI_IE_CGAD_PRES_SHIFT
operator|)
operator|+
operator|(
name|ie
operator|->
name|ie_cgad_screen_ind
operator|&
name|UNI_IE_CGAD_SCR_MASK
operator|)
operator|+
name|UNI_IE_EXT_BIT
expr_stmt|;
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
endif|#
directive|endif
comment|/* 	 * Encode the ATM address 	 */
name|rc
operator|=
name|usf_enc_atm_addr
argument_list|(
name|usf
argument_list|,
operator|&
name|ie
operator|->
name|ie_cgad_addr
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Encode a calling party subaddress information element  *  * Arguments:  *	usf	pointer to a unisig formatting structure  *	ie	pointer to a cell rate IE structure  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
specifier|static
name|int
name|usf_enc_ie_cgsa
parameter_list|(
name|usf
parameter_list|,
name|ie
parameter_list|)
name|struct
name|usfmt
modifier|*
name|usf
decl_stmt|;
name|struct
name|ie_generic
modifier|*
name|ie
decl_stmt|;
block|{
name|u_char
name|c
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/* 	 * Encode the subaddress type 	 */
switch|switch
condition|(
name|ie
operator|->
name|ie_cgsa_addr
operator|.
name|address_format
condition|)
block|{
case|case
name|T_ATM_ENDSYS_ADDR
case|:
name|c
operator|=
name|UNI_IE_CGSA_TYPE_AESA
operator|<<
name|UNI_IE_CGSA_TYPE_SHIFT
expr_stmt|;
name|ie
operator|->
name|ie_length
operator|=
sizeof|sizeof
argument_list|(
name|Atm_addr_nsap
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|c
operator||=
name|UNI_IE_EXT_BIT
expr_stmt|;
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
comment|/* 	 * Encode the ATM address 	 */
name|rc
operator|=
name|usf_enc_atm_addr
argument_list|(
name|usf
argument_list|,
operator|&
name|ie
operator|->
name|ie_cgsa_addr
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Encode a cause information element  *  * Arguments:  *	usf	pointer to a unisig formatting structure  *	ie	pointer to a cell rate IE structure  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
specifier|static
name|int
name|usf_enc_ie_caus
parameter_list|(
name|usf
parameter_list|,
name|ie
parameter_list|)
name|struct
name|usfmt
modifier|*
name|usf
decl_stmt|;
name|struct
name|ie_generic
modifier|*
name|ie
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
name|u_char
name|c
decl_stmt|;
name|ATM_DEBUG2
argument_list|(
literal|"usf_enc_ie_caus: usf=%p, ie=%p\n"
argument_list|,
name|usf
argument_list|,
name|ie
argument_list|)
expr_stmt|;
name|ie
operator|->
name|ie_length
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Encode the cause location 	 */
name|c
operator|=
operator|(
name|ie
operator|->
name|ie_caus_loc
operator|&
name|UNI_IE_CAUS_LOC_MASK
operator|)
operator||
name|UNI_IE_EXT_BIT
expr_stmt|;
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|ie
operator|->
name|ie_length
operator|++
expr_stmt|;
comment|/* 	 * Encode the cause value 	 */
name|c
operator|=
name|ie
operator|->
name|ie_caus_cause
operator||
name|UNI_IE_EXT_BIT
expr_stmt|;
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|ie
operator|->
name|ie_length
operator|++
expr_stmt|;
comment|/* 	 * Encode any included diagnostics 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ie
operator|->
name|ie_caus_diag_len
operator|&&
name|i
operator|<
sizeof|sizeof
argument_list|(
name|ie
operator|->
name|ie_caus_diagnostic
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|ie
operator|->
name|ie_caus_diagnostic
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|ie
operator|->
name|ie_length
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Encode a conection identifier information element  *  * Arguments:  *	usf	pointer to a unisig formatting structure  *	ie	pointer to a cell rate IE structure  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
specifier|static
name|int
name|usf_enc_ie_cnid
parameter_list|(
name|usf
parameter_list|,
name|ie
parameter_list|)
name|struct
name|usfmt
modifier|*
name|usf
decl_stmt|;
name|struct
name|ie_generic
modifier|*
name|ie
decl_stmt|;
block|{
name|int
name|rc
decl_stmt|;
name|u_char
name|c
decl_stmt|;
name|ATM_DEBUG2
argument_list|(
literal|"usf_enc_ie_cnid: usf=%p, ie=%p\n"
argument_list|,
name|usf
argument_list|,
name|ie
argument_list|)
expr_stmt|;
name|c
operator|=
operator|(
operator|(
name|ie
operator|->
name|ie_cnid_vp_sig
operator|&
name|UNI_IE_CNID_VPSIG_MASK
operator|)
operator|<<
name|UNI_IE_CNID_VPSIG_SHIFT
operator|)
operator|+
operator|(
name|ie
operator|->
name|ie_cnid_pref_excl
operator|&
name|UNI_IE_CNID_PREX_MASK
operator|)
operator|+
name|UNI_IE_EXT_BIT
expr_stmt|;
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|rc
operator|=
name|usf_short
argument_list|(
name|usf
argument_list|,
operator|&
name|ie
operator|->
name|ie_cnid_vpci
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|rc
operator|=
name|usf_short
argument_list|(
name|usf
argument_list|,
operator|&
name|ie
operator|->
name|ie_cnid_vci
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|ie
operator|->
name|ie_length
operator|=
literal|5
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Encode a quality of service parameters information element  *  * Arguments:  *	usf	pointer to a unisig formatting structure  *	ie	pointer to a cell rate IE structure  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
specifier|static
name|int
name|usf_enc_ie_qosp
parameter_list|(
name|usf
parameter_list|,
name|ie
parameter_list|)
name|struct
name|usfmt
modifier|*
name|usf
decl_stmt|;
name|struct
name|ie_generic
modifier|*
name|ie
decl_stmt|;
block|{
name|int
name|rc
decl_stmt|;
name|ATM_DEBUG2
argument_list|(
literal|"usf_enc_ie_qosp: usf=%p, ie=%p\n"
argument_list|,
name|usf
argument_list|,
name|ie
argument_list|)
expr_stmt|;
comment|/*          * Encode forward QoS class          */
if|if
condition|(
name|ie
operator|->
name|ie_qosp_fwd_class
operator|==
name|T_ATM_ABSENT
operator|||
name|ie
operator|->
name|ie_qosp_bkwd_class
operator|==
name|T_ATM_ABSENT
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|ie
operator|->
name|ie_qosp_fwd_class
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
comment|/*          * Encode backward QoS class          */
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|ie
operator|->
name|ie_qosp_bkwd_class
argument_list|)
expr_stmt|;
name|ie
operator|->
name|ie_length
operator|=
literal|2
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Encode a broadband repeat indicator information element  *  * Arguments:  *	usf	pointer to a unisig formatting structure  *	ie	pointer to a cell rate IE structure  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
specifier|static
name|int
name|usf_enc_ie_brpi
parameter_list|(
name|usf
parameter_list|,
name|ie
parameter_list|)
name|struct
name|usfmt
modifier|*
name|usf
decl_stmt|;
name|struct
name|ie_generic
modifier|*
name|ie
decl_stmt|;
block|{
name|int
name|rc
decl_stmt|;
name|u_char
name|c
decl_stmt|;
name|ATM_DEBUG2
argument_list|(
literal|"usf_enc_ie_brpi: usf=%p, ie=%p\n"
argument_list|,
name|usf
argument_list|,
name|ie
argument_list|)
expr_stmt|;
comment|/* 	 * Encode the repeat indicator 	 */
name|c
operator|=
name|ie
operator|->
name|ie_brpi_ind
operator|+
name|UNI_IE_EXT_BIT
expr_stmt|;
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Encode a restart indicator information element  *  * Arguments:  *	usf	pointer to a unisig formatting structure  *	ie	pointer to a cell rate IE structure  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
specifier|static
name|int
name|usf_enc_ie_rsti
parameter_list|(
name|usf
parameter_list|,
name|ie
parameter_list|)
name|struct
name|usfmt
modifier|*
name|usf
decl_stmt|;
name|struct
name|ie_generic
modifier|*
name|ie
decl_stmt|;
block|{
name|int
name|rc
decl_stmt|;
name|u_char
name|c
decl_stmt|;
name|ATM_DEBUG2
argument_list|(
literal|"usf_enc_ie_rsti: usf=%p, ie=%p\n"
argument_list|,
name|usf
argument_list|,
name|ie
argument_list|)
expr_stmt|;
comment|/* 	 * Encode the restart class 	 */
name|c
operator|=
operator|(
name|ie
operator|->
name|ie_rsti_class
operator|&
name|UNI_IE_RSTI_CLASS_MASK
operator|)
operator||
name|UNI_IE_EXT_BIT
expr_stmt|;
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
name|ie
operator|->
name|ie_length
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Encode a broadband sending complete information element  *  * Arguments:  *	usf	pointer to a unisig formatting structure  *	ie	pointer to a broadband sending complete IE structure  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
specifier|static
name|int
name|usf_enc_ie_bsdc
parameter_list|(
name|usf
parameter_list|,
name|ie
parameter_list|)
name|struct
name|usfmt
modifier|*
name|usf
decl_stmt|;
name|struct
name|ie_generic
modifier|*
name|ie
decl_stmt|;
block|{
name|int
name|rc
decl_stmt|;
name|u_char
name|c
decl_stmt|;
name|ATM_DEBUG2
argument_list|(
literal|"usf_enc_ie_bsdc: usf=%p, ie=%p\n"
argument_list|,
name|usf
argument_list|,
name|ie
argument_list|)
expr_stmt|;
comment|/* 	 * Encode the sending complete indicator 	 */
name|c
operator|=
name|UNI_IE_BSDC_IND
operator||
name|UNI_IE_EXT_BIT
expr_stmt|;
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
name|ie
operator|->
name|ie_length
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Encode a transit network selection information element  *  * Arguments:  *	usf	pointer to a unisig formatting structure  *	ie	pointer to a transit network selection rate IE structure  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
specifier|static
name|int
name|usf_enc_ie_trnt
parameter_list|(
name|usf
parameter_list|,
name|ie
parameter_list|)
name|struct
name|usfmt
modifier|*
name|usf
decl_stmt|;
name|struct
name|ie_generic
modifier|*
name|ie
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
name|u_char
name|c
decl_stmt|;
name|ATM_DEBUG2
argument_list|(
literal|"usf_enc_ie_trnt: usf=%p, ie=%p\n"
argument_list|,
name|usf
argument_list|,
name|ie
argument_list|)
expr_stmt|;
comment|/* 	 * Encode the sending complete indicator 	 */
name|c
operator|=
operator|(
operator|(
name|ie
operator|->
name|ie_trnt_id_type
operator|&
name|UNI_IE_TRNT_IDT_MASK
operator|)
operator|<<
name|UNI_IE_TRNT_IDT_SHIFT
operator|)
operator|+
operator|(
name|ie
operator|->
name|ie_trnt_id_plan
operator|&
name|UNI_IE_TRNT_IDP_MASK
operator|)
operator|+
name|UNI_IE_EXT_BIT
expr_stmt|;
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|ie
operator|->
name|ie_length
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Encode the network identification 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ie
operator|->
name|ie_trnt_id_len
condition|;
name|i
operator|++
control|)
block|{
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|ie
operator|->
name|ie_trnt_id
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|ie
operator|->
name|ie_length
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Encode an unsupported IE type  *  * Arguments:  *	usf	pointer to a unisig formatting structure  *	ie	pointer to an IE structure  *  * Returns:  *	0	success  *  */
end_comment

begin_function
specifier|static
name|int
name|usf_enc_ie_uimp
parameter_list|(
name|usf
parameter_list|,
name|ie
parameter_list|)
name|struct
name|usfmt
modifier|*
name|usf
decl_stmt|;
name|struct
name|ie_generic
modifier|*
name|ie
decl_stmt|;
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Encode an information element using field identifiers  *  * The AAL parameters and ATM user cell rate IEs are formatted  * with a one-byte identifier preceding each field.  The routine  * encodes these IEs by using a table which relates the field  * identifiers with the fields in the appropriate IE structure.  *  * Arguments:  *	usf	pointer to a unisig formatting structure  *	ie	pointer to a cell rate IE structure  *	tbl	pointer to an IE decoding table  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
specifier|static
name|int
name|usf_enc_ie_ident
parameter_list|(
name|usf
parameter_list|,
name|ie
parameter_list|,
name|tbl
parameter_list|)
name|struct
name|usfmt
modifier|*
name|usf
decl_stmt|;
name|struct
name|ie_generic
modifier|*
name|ie
decl_stmt|;
name|struct
name|ie_decode_tbl
modifier|*
name|tbl
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|len
decl_stmt|,
name|rc
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|u_int8_t
name|cv
decl_stmt|;
name|u_int16_t
name|sv
decl_stmt|;
name|u_int32_t
name|iv
decl_stmt|;
name|ATM_DEBUG3
argument_list|(
literal|"usf_enc_ie_ident: usf=%p, ie=%p, tbl=%p\n"
argument_list|,
name|usf
argument_list|,
name|ie
argument_list|,
name|tbl
argument_list|)
expr_stmt|;
comment|/* 	 * Scan through the IE table 	 */
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tbl
index|[
name|i
index|]
operator|.
name|ident
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * Check whether to send the field 		 */
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
name|int
operator|)
name|ie
operator|+
name|tbl
index|[
name|i
index|]
operator|.
name|f_offs
operator|)
expr_stmt|;
if|if
condition|(
name|tbl
index|[
name|i
index|]
operator|.
name|len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|cp
operator|==
name|T_NO
operator|||
operator|*
name|cp
operator|==
name|T_ATM_ABSENT
operator|)
condition|)
continue|continue;
block|}
else|else
block|{
switch|switch
condition|(
name|tbl
index|[
name|i
index|]
operator|.
name|f_size
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
operator|*
operator|(
name|int8_t
operator|*
operator|)
name|cp
operator|==
name|T_ATM_ABSENT
condition|)
continue|continue;
break|break;
case|case
literal|2
case|:
if|if
condition|(
operator|*
operator|(
name|int16_t
operator|*
operator|)
name|cp
operator|==
name|T_ATM_ABSENT
condition|)
continue|continue;
break|break;
case|case
literal|4
case|:
if|if
condition|(
operator|*
operator|(
name|int32_t
operator|*
operator|)
name|cp
operator|==
name|T_ATM_ABSENT
condition|)
continue|continue;
break|break;
default|default:
name|badtbl
label|:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"uni encode: id=%d,len=%d,off=%d,size=%d\n"
argument_list|,
name|tbl
index|[
name|i
index|]
operator|.
name|ident
argument_list|,
name|tbl
index|[
name|i
index|]
operator|.
name|len
argument_list|,
name|tbl
index|[
name|i
index|]
operator|.
name|f_offs
argument_list|,
name|tbl
index|[
name|i
index|]
operator|.
name|f_size
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
block|}
comment|/* 		 * Encode the field identifier 		 */
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|tbl
index|[
name|i
index|]
operator|.
name|ident
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|len
operator|++
expr_stmt|;
comment|/* 		 * Encode the field value 		 */
switch|switch
condition|(
name|tbl
index|[
name|i
index|]
operator|.
name|len
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
switch|switch
condition|(
name|tbl
index|[
name|i
index|]
operator|.
name|f_size
condition|)
block|{
case|case
literal|1
case|:
name|cv
operator|=
operator|*
operator|(
name|u_int8_t
operator|*
operator|)
name|cp
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|cv
operator|=
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
name|cp
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|cv
operator|=
operator|*
operator|(
name|u_int32_t
operator|*
operator|)
name|cp
expr_stmt|;
break|break;
default|default:
goto|goto
name|badtbl
goto|;
block|}
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
operator|&
name|cv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
switch|switch
condition|(
name|tbl
index|[
name|i
index|]
operator|.
name|f_size
condition|)
block|{
case|case
literal|2
case|:
name|sv
operator|=
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
name|cp
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|sv
operator|=
operator|*
operator|(
name|u_int32_t
operator|*
operator|)
name|cp
expr_stmt|;
break|break;
default|default:
goto|goto
name|badtbl
goto|;
block|}
name|rc
operator|=
name|usf_short
argument_list|(
name|usf
argument_list|,
operator|&
name|sv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
switch|switch
condition|(
name|tbl
index|[
name|i
index|]
operator|.
name|f_size
condition|)
block|{
case|case
literal|4
case|:
name|iv
operator|=
operator|*
operator|(
name|u_int32_t
operator|*
operator|)
name|cp
expr_stmt|;
break|break;
default|default:
goto|goto
name|badtbl
goto|;
block|}
name|rc
operator|=
name|usf_int3
argument_list|(
name|usf
argument_list|,
operator|&
name|iv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
switch|switch
condition|(
name|tbl
index|[
name|i
index|]
operator|.
name|f_size
condition|)
block|{
case|case
literal|4
case|:
name|iv
operator|=
operator|*
operator|(
name|u_int32_t
operator|*
operator|)
name|cp
expr_stmt|;
break|break;
default|default:
goto|goto
name|badtbl
goto|;
block|}
name|rc
operator|=
name|usf_int
argument_list|(
name|usf
argument_list|,
operator|&
name|iv
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|badtbl
goto|;
block|}
name|len
operator|+=
name|tbl
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|ie
operator|->
name|ie_length
operator|=
name|len
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Encode an ATM address  *  * Arguments:  *	usf	pointer to a unisig formatting structure  *	addr	pointer to an ATM address structure.  The address  *		type must already be set correctly.  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
specifier|static
name|int
name|usf_enc_atm_addr
parameter_list|(
name|usf
parameter_list|,
name|addr
parameter_list|)
name|struct
name|usfmt
modifier|*
name|usf
decl_stmt|;
name|Atm_addr
modifier|*
name|addr
decl_stmt|;
block|{
name|int
name|len
decl_stmt|,
name|rc
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|;
comment|/* 	 * Check the address type 	 */
switch|switch
condition|(
name|addr
operator|->
name|address_format
condition|)
block|{
case|case
name|T_ATM_E164_ADDR
case|:
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|addr
operator|->
name|address
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|Atm_addr_e164
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_ATM_ENDSYS_ADDR
case|:
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|addr
operator|->
name|address
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|Atm_addr_nsap
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * Get the address bytes 	 */
while|while
condition|(
name|len
condition|)
block|{
name|rc
operator|=
name|usf_byte
argument_list|(
name|usf
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|len
operator|--
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

