begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * ===================================  * HARP  |  Host ATM Research Platform  * ===================================  *  *  * This Host ATM Research Platform ("HARP") file (the "Software") is  * made available by Network Computing Services, Inc. ("NetworkCS")  * "AS IS".  NetworkCS does not provide maintenance, improvements or  * support of any kind.  *  * NETWORKCS MAKES NO WARRANTIES OR REPRESENTATIONS, EXPRESS OR IMPLIED,  * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE, AS TO ANY ELEMENT OF THE  * SOFTWARE OR ANY SUPPORT PROVIDED IN CONNECTION WITH THIS SOFTWARE.  * In no event shall NetworkCS be responsible for any damages, including  * but not limited to consequential damages, arising from or relating to  * any use of the Software or related support.  *  * Copyright 1994-1998 Network Computing Services, Inc.  *  * Copies of this Software may be made, however, the above copyright  * notice must be reproduced on all copies.  *  *	@(#) $Id: sigpvc_subr.c,v 1.7 1998/06/29 21:52:25 mks Exp $  *  */
end_comment

begin_comment
comment|/*  * PVC-only Signalling Manager  * ---------------------------  *  * Subroutines  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|RCSid
init|=
literal|"@(#) $Id: sigpvc_subr.c,v 1.7 1998/06/29 21:52:25 mks Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netatm/kern_include.h>
end_include

begin_include
include|#
directive|include
file|<netatm/sigpvc/sigpvc.h>
end_include

begin_include
include|#
directive|include
file|<netatm/sigpvc/sigpvc_var.h>
end_include

begin_decl_stmt
specifier|extern
name|struct
name|sp_info
name|sigpvc_vcpool
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Create a SigPVC Permanent Virtual Channel  *   * This function will construct a vccb for a "sigpvc-controlled" PVC  * and create the service stack requested by the user.  *  * Must be called at splnet.  *  * Arguments:  *	pvp	pointer to sigpvc protocol instance  *	cvp	pointer to CM's connection VCC  *	errp	location to store an error code if CALL_FAILED is returned  *  * Returns:  *	CALL_FAILED	- pvc creation failed  *	CALL_CONNECTED	- pvc has been successfully created  *  */
end_comment

begin_function
name|int
name|sigpvc_create_pvc
parameter_list|(
name|pvp
parameter_list|,
name|cvp
parameter_list|,
name|errp
parameter_list|)
name|struct
name|sigpvc
modifier|*
name|pvp
decl_stmt|;
name|Atm_connvc
modifier|*
name|cvp
decl_stmt|;
name|int
modifier|*
name|errp
decl_stmt|;
block|{
name|Atm_addr_pvc
modifier|*
name|pp
decl_stmt|;
name|struct
name|vccb
modifier|*
name|vcp
decl_stmt|;
name|u_int
name|vpi
decl_stmt|,
name|vci
decl_stmt|;
name|pp
operator|=
operator|(
name|Atm_addr_pvc
operator|*
operator|)
name|cvp
operator|->
name|cvc_attr
operator|.
name|called
operator|.
name|addr
operator|.
name|address
expr_stmt|;
name|vpi
operator|=
name|ATM_PVC_GET_VPI
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|vci
operator|=
name|ATM_PVC_GET_VCI
argument_list|(
name|pp
argument_list|)
expr_stmt|;
comment|/* 	 * Verify requested VPI,VCI 	 */
if|if
condition|(
operator|(
name|vpi
operator|>
name|pvp
operator|->
name|pv_pif
operator|->
name|pif_maxvpi
operator|)
operator|||
operator|(
name|vci
operator|==
literal|0
operator|)
operator|||
operator|(
name|vci
operator|>
name|pvp
operator|->
name|pv_pif
operator|->
name|pif_maxvci
operator|)
condition|)
block|{
operator|*
name|errp
operator|=
name|ERANGE
expr_stmt|;
return|return
operator|(
name|CALL_FAILED
operator|)
return|;
block|}
for|for
control|(
name|vcp
operator|=
name|Q_HEAD
argument_list|(
name|pvp
operator|->
name|pv_vccq
argument_list|,
expr|struct
name|vccb
argument_list|)
init|;
name|vcp
condition|;
name|vcp
operator|=
name|Q_NEXT
argument_list|(
name|vcp
argument_list|,
expr|struct
name|vccb
argument_list|,
name|vc_sigelem
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|vcp
operator|->
name|vc_vpi
operator|==
name|vpi
operator|)
operator|&&
operator|(
name|vcp
operator|->
name|vc_vci
operator|==
name|vci
operator|)
condition|)
block|{
operator|*
name|errp
operator|=
name|EADDRINUSE
expr_stmt|;
return|return
operator|(
name|CALL_FAILED
operator|)
return|;
block|}
block|}
comment|/* 	 * Verify network interface 	 */
if|if
condition|(
name|cvp
operator|->
name|cvc_attr
operator|.
name|nif
condition|)
block|{
if|if
condition|(
name|cvp
operator|->
name|cvc_attr
operator|.
name|nif
operator|->
name|nif_pif
operator|!=
name|pvp
operator|->
name|pv_pif
condition|)
block|{
operator|*
name|errp
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|CALL_FAILED
operator|)
return|;
block|}
block|}
comment|/* 	 * Allocate control block for PVC 	 */
name|vcp
operator|=
operator|(
expr|struct
name|vccb
operator|*
operator|)
name|atm_allocate
argument_list|(
operator|&
name|sigpvc_vcpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|vcp
operator|==
name|NULL
condition|)
block|{
operator|*
name|errp
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
name|CALL_FAILED
operator|)
return|;
block|}
comment|/* 	 * Fill in VCCB 	 */
name|vcp
operator|->
name|vc_type
operator|=
name|VCC_PVC
operator||
name|VCC_IN
operator||
name|VCC_OUT
expr_stmt|;
name|vcp
operator|->
name|vc_proto
operator|=
name|ATM_SIG_PVC
expr_stmt|;
name|vcp
operator|->
name|vc_sstate
operator|=
name|VCCS_ACTIVE
expr_stmt|;
name|vcp
operator|->
name|vc_ustate
operator|=
name|VCCU_OPEN
expr_stmt|;
name|vcp
operator|->
name|vc_pif
operator|=
name|pvp
operator|->
name|pv_pif
expr_stmt|;
name|vcp
operator|->
name|vc_nif
operator|=
name|cvp
operator|->
name|cvc_attr
operator|.
name|nif
expr_stmt|;
name|vcp
operator|->
name|vc_vpi
operator|=
name|vpi
expr_stmt|;
name|vcp
operator|->
name|vc_vci
operator|=
name|vci
expr_stmt|;
name|vcp
operator|->
name|vc_connvc
operator|=
name|cvp
expr_stmt|;
comment|/* 	 * Put VCCB on sigpvc queue 	 */
name|ENQUEUE
argument_list|(
name|vcp
argument_list|,
expr|struct
name|vccb
argument_list|,
name|vc_sigelem
argument_list|,
name|pvp
operator|->
name|pv_vccq
argument_list|)
expr_stmt|;
comment|/* 	 * Pass back VCCB to connection manager 	 */
name|cvp
operator|->
name|cvc_vcc
operator|=
name|vcp
expr_stmt|;
comment|/* 	 * PVC is ready to go! 	 */
return|return
operator|(
name|CALL_CONNECTED
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close a SigPVC VCC   *   * Clean up vccb, note that it's closing and wait for its freeing.  *  * Arguments:  *	vcp	pointer to connection's VCC control block  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|sigpvc_close_vcc
parameter_list|(
name|vcp
parameter_list|)
name|struct
name|vccb
modifier|*
name|vcp
decl_stmt|;
block|{
comment|/* 	 * Sanity check (actually design-flaw check) 	 */
if|if
condition|(
name|vcp
operator|->
name|vc_connvc
operator|->
name|cvc_upcnt
operator|||
name|vcp
operator|->
name|vc_connvc
operator|->
name|cvc_downcnt
condition|)
name|panic
argument_list|(
literal|"sigpvc_close_vcc: stack call"
argument_list|)
expr_stmt|;
comment|/* 	 * Set state variables 	 */
name|vcp
operator|->
name|vc_ustate
operator|=
name|VCCU_CLOSED
expr_stmt|;
name|vcp
operator|->
name|vc_sstate
operator|=
name|VCCS_FREE
expr_stmt|;
comment|/* 	 * Wait for user to free resources 	 */
block|}
end_function

end_unit

