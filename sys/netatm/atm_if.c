begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * ===================================  * HARP  |  Host ATM Research Platform  * ===================================  *  *  * This Host ATM Research Platform ("HARP") file (the "Software") is  * made available by Network Computing Services, Inc. ("NetworkCS")  * "AS IS".  NetworkCS does not provide maintenance, improvements or  * support of any kind.  *  * NETWORKCS MAKES NO WARRANTIES OR REPRESENTATIONS, EXPRESS OR IMPLIED,  * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE, AS TO ANY ELEMENT OF THE  * SOFTWARE OR ANY SUPPORT PROVIDED IN CONNECTION WITH THIS SOFTWARE.  * In no event shall NetworkCS be responsible for any damages, including  * but not limited to consequential damages, arising from or relating to  * any use of the Software or related support.  *  * Copyright 1994-1998 Network Computing Services, Inc.  *  * Copies of this Software may be made, however, the above copyright  * notice must be reproduced on all copies.  */
end_comment

begin_comment
comment|/*  * Core ATM Services  * -----------------  *  * ATM interface management  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netatm/port.h>
end_include

begin_include
include|#
directive|include
file|<netatm/queue.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sys.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sap.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_cm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_if.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sigmgr.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_stack.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_var.h>
end_include

begin_comment
comment|/*  * Local functions  */
end_comment

begin_function_decl
specifier|static
name|int
name|atm_physif_ioctl
parameter_list|(
name|int
parameter_list|,
name|caddr_t
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|atm_if_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|atm_ifparse
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Local variables  */
end_comment

begin_function_decl
specifier|static
name|int
function_decl|(
modifier|*
name|atm_ifouttbl
index|[
name|AF_MAX
operator|+
literal|1
index|]
function_decl|)
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|KBuffer
modifier|*
parameter_list|,
name|struct
name|sockaddr
modifier|*
parameter_list|)
init|=
block|{
name|NULL
block|}
function_decl|;
end_function_decl

begin_comment
comment|/*  * Register an ATM physical interface  *   * Each ATM device interface must register itself here upon completing  * its internal initialization.  This applies to both linked and loaded  * device drivers.  The interface must be registered before a signalling  * manager can be attached.  *  * Arguments:  *	cup	pointer to interface's common unit structure  *	name	pointer to device name string  *	sdp	pointer to interface's stack services  *  * Returns:  *	0	registration successful  *	errno	registration failed - reason indicated  *  */
end_comment

begin_function
name|int
name|atm_physif_register
parameter_list|(
name|cup
parameter_list|,
name|name
parameter_list|,
name|sdp
parameter_list|)
name|Cmn_unit
modifier|*
name|cup
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|stack_defn
modifier|*
name|sdp
decl_stmt|;
block|{
name|struct
name|atm_pif
modifier|*
name|pip
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* 	 * See if we need to be initialized 	 */
if|if
condition|(
operator|!
name|atm_init
condition|)
name|atm_initialize
argument_list|()
expr_stmt|;
comment|/* 	 * Make sure we're not already registered 	 */
if|if
condition|(
name|cup
operator|->
name|cu_flags
operator|&
name|CUF_REGISTER
condition|)
block|{
return|return
operator|(
name|EALREADY
operator|)
return|;
block|}
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
comment|/* 	 * Make sure an interface is only registered once 	 */
for|for
control|(
name|pip
operator|=
name|atm_interface_head
init|;
name|pip
operator|!=
name|NULL
condition|;
name|pip
operator|=
name|pip
operator|->
name|pif_next
control|)
block|{
if|if
condition|(
operator|(
name|cup
operator|->
name|cu_unit
operator|==
name|pip
operator|->
name|pif_unit
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|pip
operator|->
name|pif_name
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
block|}
comment|/* 	 * Fill in physical interface parameters 	 */
name|pip
operator|=
operator|&
name|cup
operator|->
name|cu_pif
expr_stmt|;
name|pip
operator|->
name|pif_name
operator|=
name|name
expr_stmt|;
name|pip
operator|->
name|pif_unit
operator|=
name|cup
operator|->
name|cu_unit
expr_stmt|;
name|pip
operator|->
name|pif_flags
operator|=
name|PIF_UP
expr_stmt|;
name|pip
operator|->
name|pif_services
operator|=
name|sdp
expr_stmt|;
name|pip
operator|->
name|pif_ioctl
operator|=
name|atm_physif_ioctl
expr_stmt|;
comment|/* 	 * Link in the interface and mark us registered 	 */
name|LINK2TAIL
argument_list|(
name|pip
argument_list|,
expr|struct
name|atm_pif
argument_list|,
name|atm_interface_head
argument_list|,
name|pif_next
argument_list|)
expr_stmt|;
name|cup
operator|->
name|cu_flags
operator||=
name|CUF_REGISTER
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * De-register an ATM physical interface  *   * Each ATM interface must de-register itself before downing the interface.    * The interface's signalling manager will be detached and any network  * interface and VCC control blocks will be freed.    *  * Arguments:  *	cup	pointer to interface's common unit structure  *  * Returns:  *	0	de-registration successful  *	errno	de-registration failed - reason indicated  *  */
end_comment

begin_function
name|int
name|atm_physif_deregister
parameter_list|(
name|cup
parameter_list|)
name|Cmn_unit
modifier|*
name|cup
decl_stmt|;
block|{
name|struct
name|atm_pif
modifier|*
name|pip
init|=
operator|(
expr|struct
name|atm_pif
operator|*
operator|)
operator|&
name|cup
operator|->
name|cu_pif
decl_stmt|;
name|Cmn_vcc
modifier|*
name|cvp
decl_stmt|,
modifier|*
name|cvp_next
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
comment|/* 	 * Detach and deregister, if needed 	 */
if|if
condition|(
operator|(
name|cup
operator|->
name|cu_flags
operator|&
name|CUF_REGISTER
operator|)
condition|)
block|{
comment|/* 		 * Detach from signalling manager 		 */
if|if
condition|(
name|pip
operator|->
name|pif_sigmgr
operator|!=
name|NULL
condition|)
block|{
name|err
operator|=
name|atm_sigmgr_detach
argument_list|(
name|pip
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
operator|(
name|err
operator|!=
name|ENOENT
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
block|}
comment|/* 		 * Make sure signalling manager is detached 		 */
if|if
condition|(
name|pip
operator|->
name|pif_sigmgr
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
comment|/* 		 * Unlink interface 		 */
name|UNLINK
argument_list|(
name|pip
argument_list|,
expr|struct
name|atm_pif
argument_list|,
name|atm_interface_head
argument_list|,
name|pif_next
argument_list|)
expr_stmt|;
name|cup
operator|->
name|cu_flags
operator|&=
operator|~
name|CUF_REGISTER
expr_stmt|;
block|}
comment|/* 	 * Free all of our network interfaces 	 */
name|atm_physif_freenifs
argument_list|(
name|pip
argument_list|,
name|cup
operator|->
name|cu_nif_zone
argument_list|)
expr_stmt|;
comment|/* 	 * Free unit's vcc information 	 */
name|cvp
operator|=
name|cup
operator|->
name|cu_vcc
expr_stmt|;
while|while
condition|(
name|cvp
condition|)
block|{
name|cvp_next
operator|=
name|cvp
operator|->
name|cv_next
expr_stmt|;
name|uma_zfree
argument_list|(
name|cup
operator|->
name|cu_vcc_zone
argument_list|,
name|cvp
argument_list|)
expr_stmt|;
name|cvp
operator|=
name|cvp_next
expr_stmt|;
block|}
name|cup
operator|->
name|cu_vcc
operator|=
operator|(
name|Cmn_vcc
operator|*
operator|)
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free all network interfaces on a physical interface  *  * Arguments  *	pip		pointer to physical interface structure  *  * Returns  *	none  *  */
end_comment

begin_function
name|void
name|atm_physif_freenifs
parameter_list|(
name|pip
parameter_list|,
name|zone
parameter_list|)
name|struct
name|atm_pif
modifier|*
name|pip
decl_stmt|;
name|uma_zone_t
name|zone
decl_stmt|;
block|{
name|struct
name|atm_nif
modifier|*
name|nip
init|=
name|pip
operator|->
name|pif_nif
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
while|while
condition|(
name|nip
condition|)
block|{
comment|/* 		 * atm_nif_detach zeros pointers - save so we can 		 * walk the chain. 		 */
name|struct
name|atm_nif
modifier|*
name|nipp
init|=
name|nip
operator|->
name|nif_pnext
decl_stmt|;
comment|/* 		 * Clean up network i/f trails 		 */
name|atm_nif_detach
argument_list|(
name|nip
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|zone
argument_list|,
name|nip
argument_list|)
expr_stmt|;
name|nip
operator|=
name|nipp
expr_stmt|;
block|}
name|pip
operator|->
name|pif_nif
operator|=
operator|(
expr|struct
name|atm_nif
operator|*
operator|)
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Handle physical interface ioctl's  *  * See<netatm/atm_ioctl.h> for definitions.  *  * Called at splnet.  *  * Arguments:  *	code			Ioctl function (sub)code  *	data			Data block. On input contains command,  *					on output, contains results  *	arg			Optional code specific arguments  *  * Returns:  *	0			Request processed successfully  *	errno			Request failed - reason code  *  */
end_comment

begin_function
specifier|static
name|int
name|atm_physif_ioctl
parameter_list|(
name|code
parameter_list|,
name|data
parameter_list|,
name|arg
parameter_list|)
name|int
name|code
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
name|caddr_t
name|arg
decl_stmt|;
block|{
name|struct
name|atminfreq
modifier|*
name|aip
init|=
operator|(
expr|struct
name|atminfreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|atmsetreq
modifier|*
name|asr
init|=
operator|(
expr|struct
name|atmsetreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|atm_pif
modifier|*
name|pip
decl_stmt|;
name|struct
name|atm_nif
modifier|*
name|nip
decl_stmt|;
name|struct
name|sigmgr
modifier|*
name|smp
decl_stmt|;
name|struct
name|siginst
modifier|*
name|sip
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|Cmn_unit
modifier|*
name|cup
decl_stmt|;
name|Atm_config
modifier|*
name|acp
decl_stmt|;
name|caddr_t
name|buf
init|=
name|aip
operator|->
name|air_buf_addr
decl_stmt|;
name|struct
name|air_phy_stat_rsp
modifier|*
name|apsp
decl_stmt|;
name|struct
name|air_int_rsp
name|apr
decl_stmt|;
name|struct
name|air_netif_rsp
name|anr
decl_stmt|;
name|struct
name|air_cfg_rsp
name|acr
decl_stmt|;
name|u_int
name|count
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|size_t
name|buf_len
init|=
name|aip
operator|->
name|air_buf_len
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|char
name|ifname
index|[
literal|2
operator|*
name|IFNAMSIZ
index|]
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|struct
name|in_ifaddr
modifier|*
name|ia
decl_stmt|;
name|struct
name|sockaddr_dl
modifier|*
name|sdl
decl_stmt|;
switch|switch
condition|(
name|aip
operator|->
name|air_opcode
condition|)
block|{
case|case
name|AIOCS_INF_INT
case|:
comment|/* 		 * Get physical interface information 		 */
name|aip
operator|=
operator|(
expr|struct
name|atminfreq
operator|*
operator|)
name|data
expr_stmt|;
name|pip
operator|=
operator|(
expr|struct
name|atm_pif
operator|*
operator|)
name|arg
expr_stmt|;
comment|/* 		 * Make sure there's room in user buffer 		 */
if|if
condition|(
name|aip
operator|->
name|air_buf_len
operator|<
sizeof|sizeof
argument_list|(
name|apr
argument_list|)
condition|)
block|{
name|err
operator|=
name|ENOSPC
expr_stmt|;
break|break;
block|}
comment|/* 		 * Fill in info to be returned 		 */
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|apr
argument_list|,
sizeof|sizeof
argument_list|(
name|apr
argument_list|)
argument_list|)
expr_stmt|;
name|smp
operator|=
name|pip
operator|->
name|pif_sigmgr
expr_stmt|;
name|sip
operator|=
name|pip
operator|->
name|pif_siginst
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|apr
operator|.
name|anp_intf
argument_list|,
sizeof|sizeof
argument_list|(
name|apr
operator|.
name|anp_intf
argument_list|)
argument_list|,
literal|"%s%d"
argument_list|,
name|pip
operator|->
name|pif_name
argument_list|,
name|pip
operator|->
name|pif_unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|pip
operator|->
name|pif_nif
condition|)
block|{
name|strcpy
argument_list|(
name|apr
operator|.
name|anp_nif_pref
argument_list|,
name|pip
operator|->
name|pif_nif
operator|->
name|nif_ifp
operator|->
name|if_dname
argument_list|)
expr_stmt|;
name|nip
operator|=
name|pip
operator|->
name|pif_nif
expr_stmt|;
while|while
condition|(
name|nip
condition|)
block|{
name|apr
operator|.
name|anp_nif_cnt
operator|++
expr_stmt|;
name|nip
operator|=
name|nip
operator|->
name|nif_pnext
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sip
condition|)
block|{
name|ATM_ADDR_COPY
argument_list|(
operator|&
name|sip
operator|->
name|si_addr
argument_list|,
operator|&
name|apr
operator|.
name|anp_addr
argument_list|)
expr_stmt|;
name|ATM_ADDR_COPY
argument_list|(
operator|&
name|sip
operator|->
name|si_subaddr
argument_list|,
operator|&
name|apr
operator|.
name|anp_subaddr
argument_list|)
expr_stmt|;
name|apr
operator|.
name|anp_sig_proto
operator|=
name|smp
operator|->
name|sm_proto
expr_stmt|;
name|apr
operator|.
name|anp_sig_state
operator|=
name|sip
operator|->
name|si_state
expr_stmt|;
block|}
comment|/* 		 * Copy data to user buffer 		 */
name|err
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|apr
argument_list|,
name|aip
operator|->
name|air_buf_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|apr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
comment|/* 		 * Update buffer pointer/count 		 */
name|aip
operator|->
name|air_buf_addr
operator|+=
sizeof|sizeof
argument_list|(
name|apr
argument_list|)
expr_stmt|;
name|aip
operator|->
name|air_buf_len
operator|-=
sizeof|sizeof
argument_list|(
name|apr
argument_list|)
expr_stmt|;
break|break;
case|case
name|AIOCS_INF_NIF
case|:
comment|/* 		 * Get network interface information 		 */
name|aip
operator|=
operator|(
expr|struct
name|atminfreq
operator|*
operator|)
name|data
expr_stmt|;
name|nip
operator|=
operator|(
expr|struct
name|atm_nif
operator|*
operator|)
name|arg
expr_stmt|;
name|ifp
operator|=
name|nip
operator|->
name|nif_ifp
expr_stmt|;
name|pip
operator|=
name|nip
operator|->
name|nif_pif
expr_stmt|;
comment|/* 		 * Make sure there's room in user buffer 		 */
if|if
condition|(
name|aip
operator|->
name|air_buf_len
operator|<
sizeof|sizeof
argument_list|(
name|anr
argument_list|)
condition|)
block|{
name|err
operator|=
name|ENOSPC
expr_stmt|;
break|break;
block|}
comment|/* 		 * Fill in info to be returned 		 */
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|anr
argument_list|,
sizeof|sizeof
argument_list|(
name|anr
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|anr
operator|.
name|anp_intf
argument_list|,
sizeof|sizeof
argument_list|(
name|anr
operator|.
name|anp_intf
argument_list|)
argument_list|,
literal|"%s%d"
argument_list|,
name|ifp
operator|->
name|if_dname
argument_list|,
name|ifp
operator|->
name|if_dunit
argument_list|)
expr_stmt|;
name|IFP_TO_IA
argument_list|(
name|ifp
argument_list|,
name|ia
argument_list|)
expr_stmt|;
if|if
condition|(
name|ia
condition|)
block|{
name|anr
operator|.
name|anp_proto_addr
operator|=
operator|*
name|ia
operator|->
name|ia_ifa
operator|.
name|ifa_addr
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|anr
operator|.
name|anp_phy_intf
argument_list|,
sizeof|sizeof
argument_list|(
name|anr
operator|.
name|anp_phy_intf
argument_list|)
argument_list|,
literal|"%s%d"
argument_list|,
name|pip
operator|->
name|pif_name
argument_list|,
name|pip
operator|->
name|pif_unit
argument_list|)
expr_stmt|;
comment|/* 		 * Copy data to user buffer 		 */
name|err
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|anr
argument_list|,
name|aip
operator|->
name|air_buf_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|anr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
comment|/* 		 * Update buffer pointer/count 		 */
name|aip
operator|->
name|air_buf_addr
operator|+=
sizeof|sizeof
argument_list|(
name|anr
argument_list|)
expr_stmt|;
name|aip
operator|->
name|air_buf_len
operator|-=
sizeof|sizeof
argument_list|(
name|anr
argument_list|)
expr_stmt|;
break|break;
case|case
name|AIOCS_INF_PIS
case|:
comment|/* 		 * Get per interface statistics 		 */
name|pip
operator|=
operator|(
expr|struct
name|atm_pif
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|pip
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|snprintf
argument_list|(
name|ifname
argument_list|,
sizeof|sizeof
argument_list|(
name|ifname
argument_list|)
argument_list|,
literal|"%s%d"
argument_list|,
name|pip
operator|->
name|pif_name
argument_list|,
name|pip
operator|->
name|pif_unit
argument_list|)
expr_stmt|;
comment|/* 		 * Cast response into users buffer 		 */
name|apsp
operator|=
operator|(
expr|struct
name|air_phy_stat_rsp
operator|*
operator|)
name|buf
expr_stmt|;
comment|/* 		 * Sanity check 		 */
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|air_phy_stat_rsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf_len
operator|<
name|len
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
comment|/* 		 * Copy interface name into response 		 */
if|if
condition|(
operator|(
name|err
operator|=
name|copyout
argument_list|(
name|ifname
argument_list|,
name|apsp
operator|->
name|app_intf
argument_list|,
name|IFNAMSIZ
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
comment|/* 		 * Copy counters 		 */
if|if
condition|(
operator|(
name|err
operator|=
name|copyout
argument_list|(
operator|&
name|pip
operator|->
name|pif_ipdus
argument_list|,
operator|&
name|apsp
operator|->
name|app_ipdus
argument_list|,
name|len
operator|-
sizeof|sizeof
argument_list|(
name|apsp
operator|->
name|app_intf
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
comment|/* 		 * Adjust buffer elements 		 */
name|buf
operator|+=
name|len
expr_stmt|;
name|buf_len
operator|-=
name|len
expr_stmt|;
name|aip
operator|->
name|air_buf_addr
operator|=
name|buf
expr_stmt|;
name|aip
operator|->
name|air_buf_len
operator|=
name|buf_len
expr_stmt|;
break|break;
case|case
name|AIOCS_SET_NIF
case|:
comment|/* 		 * Set NIF - allow user to configure 1 or more logical 		 *	interfaces per physical interface. 		 */
comment|/* 		 * Get pointer to physical interface structure from 		 * ioctl argument. 		 */
name|pip
operator|=
operator|(
expr|struct
name|atm_pif
operator|*
operator|)
name|arg
expr_stmt|;
name|cup
operator|=
operator|(
name|Cmn_unit
operator|*
operator|)
name|pip
expr_stmt|;
comment|/* 		 * Sanity check - are we already connected to something? 		 */
if|if
condition|(
name|pip
operator|->
name|pif_sigmgr
condition|)
block|{
name|err
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
comment|/* 		 * Free any previously allocated NIFs 		 */
name|atm_physif_freenifs
argument_list|(
name|pip
argument_list|,
name|cup
operator|->
name|cu_nif_zone
argument_list|)
expr_stmt|;
comment|/* 		 * Add list of interfaces 		 */
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|asr
operator|->
name|asr_nif_cnt
condition|;
name|count
operator|++
control|)
block|{
name|nip
operator|=
name|uma_zalloc
argument_list|(
name|cup
operator|->
name|cu_nif_zone
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|nip
operator|==
name|NULL
condition|)
block|{
comment|/* 				 * Destroy any successful nifs 				 */
name|atm_physif_freenifs
argument_list|(
name|pip
argument_list|,
name|cup
operator|->
name|cu_nif_zone
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|nip
operator|->
name|nif_pif
operator|=
name|pip
expr_stmt|;
name|ifp
operator|=
name|nip
operator|->
name|nif_ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_IPOVERATM
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|uma_zfree
argument_list|(
name|cup
operator|->
name|cu_nif_zone
argument_list|,
name|nip
argument_list|)
expr_stmt|;
comment|/* 				 * Destroy any successful nifs 				 */
name|atm_physif_freenifs
argument_list|(
name|pip
argument_list|,
name|cup
operator|->
name|cu_nif_zone
argument_list|)
expr_stmt|;
break|break;
block|}
name|strcpy
argument_list|(
name|nip
operator|->
name|nif_name
argument_list|,
name|asr
operator|->
name|asr_nif_pref
argument_list|)
expr_stmt|;
name|nip
operator|->
name|nif_sel
operator|=
name|count
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|nip
operator|->
name|nif_name
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ATM_NIF_MTU
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_UP
operator||
name|IFF_BROADCAST
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|atm_ifoutput
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|atm_if_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|ifqmaxlen
expr_stmt|;
switch|switch
condition|(
name|cup
operator|->
name|cu_config
operator|.
name|ac_media
condition|)
block|{
case|case
name|MEDIA_TAXI_100
case|:
name|ifp
operator|->
name|if_baudrate
operator|=
literal|100000000
expr_stmt|;
break|break;
case|case
name|MEDIA_TAXI_140
case|:
name|ifp
operator|->
name|if_baudrate
operator|=
literal|140000000
expr_stmt|;
break|break;
case|case
name|MEDIA_OC3C
case|:
case|case
name|MEDIA_OC12C
case|:
case|case
name|MEDIA_UTP155
case|:
name|ifp
operator|->
name|if_baudrate
operator|=
literal|155000000
expr_stmt|;
break|break;
case|case
name|MEDIA_UTP25
case|:
name|ifp
operator|->
name|if_baudrate
operator|=
literal|25600000
expr_stmt|;
break|break;
case|case
name|MEDIA_VIRTUAL
case|:
name|ifp
operator|->
name|if_baudrate
operator|=
literal|100000000
expr_stmt|;
comment|/* XXX */
break|break;
case|case
name|MEDIA_DSL
case|:
name|ifp
operator|->
name|if_baudrate
operator|=
literal|2500000
expr_stmt|;
comment|/* XXX */
break|break;
case|case
name|MEDIA_UNKNOWN
case|:
name|ifp
operator|->
name|if_baudrate
operator|=
literal|9600
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|atm_nif_attach
argument_list|(
name|nip
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|if_free
argument_list|(
name|nip
operator|->
name|nif_ifp
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|cup
operator|->
name|cu_nif_zone
argument_list|,
name|nip
argument_list|)
expr_stmt|;
comment|/* 				 * Destroy any successful nifs 				 */
name|atm_physif_freenifs
argument_list|(
name|pip
argument_list|,
name|cup
operator|->
name|cu_nif_zone
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 			 * Set macaddr in<Link> address 			 */
name|ifp
operator|->
name|if_addrlen
operator|=
literal|6
expr_stmt|;
name|ifa
operator|=
name|ifp
operator|->
name|if_addr
expr_stmt|;
if|if
condition|(
name|ifa
condition|)
block|{
name|sdl
operator|=
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifa
operator|->
name|ifa_addr
expr_stmt|;
name|sdl
operator|->
name|sdl_type
operator|=
name|IFT_ETHER
expr_stmt|;
name|sdl
operator|->
name|sdl_alen
operator|=
name|ifp
operator|->
name|if_addrlen
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|cup
operator|->
name|cu_config
operator|.
name|ac_macaddr
argument_list|,
name|LLADDR
argument_list|(
name|sdl
argument_list|)
argument_list|,
name|ifp
operator|->
name|if_addrlen
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|AIOCS_INF_CFG
case|:
comment|/* 		 * Get adapter configuration information 		 */
name|aip
operator|=
operator|(
expr|struct
name|atminfreq
operator|*
operator|)
name|data
expr_stmt|;
name|pip
operator|=
operator|(
expr|struct
name|atm_pif
operator|*
operator|)
name|arg
expr_stmt|;
name|cup
operator|=
operator|(
name|Cmn_unit
operator|*
operator|)
name|pip
expr_stmt|;
name|acp
operator|=
operator|&
name|cup
operator|->
name|cu_config
expr_stmt|;
comment|/* 		 * Make sure there's room in user buffer 		 */
if|if
condition|(
name|aip
operator|->
name|air_buf_len
operator|<
sizeof|sizeof
argument_list|(
name|acr
argument_list|)
condition|)
block|{
name|err
operator|=
name|ENOSPC
expr_stmt|;
break|break;
block|}
comment|/* 		 * Fill in info to be returned 		 */
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|acr
argument_list|,
sizeof|sizeof
argument_list|(
name|acr
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|acr
operator|.
name|acp_intf
argument_list|,
sizeof|sizeof
argument_list|(
name|acr
operator|.
name|acp_intf
argument_list|)
argument_list|,
literal|"%s%d"
argument_list|,
name|pip
operator|->
name|pif_name
argument_list|,
name|pip
operator|->
name|pif_unit
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|acp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|acr
operator|.
name|acp_cfg
argument_list|,
sizeof|sizeof
argument_list|(
name|Atm_config
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Copy data to user buffer 		 */
name|err
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|acr
argument_list|,
name|aip
operator|->
name|air_buf_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|acr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
comment|/* 		 * Update buffer pointer/count 		 */
name|aip
operator|->
name|air_buf_addr
operator|+=
sizeof|sizeof
argument_list|(
name|acr
argument_list|)
expr_stmt|;
name|aip
operator|->
name|air_buf_len
operator|-=
sizeof|sizeof
argument_list|(
name|acr
argument_list|)
expr_stmt|;
break|break;
case|case
name|AIOCS_INF_VST
case|:
comment|/* 		 * Pass off to device-specific handler 		 */
name|cup
operator|=
operator|(
name|Cmn_unit
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|cup
operator|==
name|NULL
condition|)
name|err
operator|=
name|ENXIO
expr_stmt|;
else|else
name|err
operator|=
call|(
modifier|*
name|cup
operator|->
name|cu_ioctl
call|)
argument_list|(
name|code
argument_list|,
name|data
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|err
operator|=
name|ENOSYS
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Register a Network Convergence Module  *   * Each ATM network convergence module must register itself here before  * it will receive network interface status notifications.   *  * Arguments:  *	ncp	pointer to network convergence definition structure  *  * Returns:  *	0	registration successful  *	errno	registration failed - reason indicated  *  */
end_comment

begin_function
name|int
name|atm_netconv_register
parameter_list|(
name|ncp
parameter_list|)
name|struct
name|atm_ncm
modifier|*
name|ncp
decl_stmt|;
block|{
name|struct
name|atm_ncm
modifier|*
name|tdp
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
comment|/* 	 * See if we need to be initialized 	 */
if|if
condition|(
operator|!
name|atm_init
condition|)
name|atm_initialize
argument_list|()
expr_stmt|;
comment|/* 	 * Validate protocol family 	 */
if|if
condition|(
name|ncp
operator|->
name|ncm_family
operator|>
name|AF_MAX
condition|)
block|{
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * Ensure no duplicates 	 */
for|for
control|(
name|tdp
operator|=
name|atm_netconv_head
init|;
name|tdp
operator|!=
name|NULL
condition|;
name|tdp
operator|=
name|tdp
operator|->
name|ncm_next
control|)
block|{
if|if
condition|(
name|tdp
operator|->
name|ncm_family
operator|==
name|ncp
operator|->
name|ncm_family
condition|)
block|{
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
block|}
comment|/* 	 * Add module to list 	 */
name|LINK2TAIL
argument_list|(
name|ncp
argument_list|,
expr|struct
name|atm_ncm
argument_list|,
name|atm_netconv_head
argument_list|,
name|ncm_next
argument_list|)
expr_stmt|;
comment|/* 	 * Add new interface output function 	 */
name|atm_ifouttbl
index|[
name|ncp
operator|->
name|ncm_family
index|]
operator|=
name|ncp
operator|->
name|ncm_ifoutput
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * De-register an ATM Network Convergence Module  *   * Each ATM network convergence provider must de-register its registered   * service(s) before terminating.  Specifically, loaded kernel modules  * must de-register their services before unloading themselves.  *  * Arguments:  *	ncp	pointer to network convergence definition structure  *  * Returns:  *	0	de-registration successful   *	errno	de-registration failed - reason indicated  *  */
end_comment

begin_function
name|int
name|atm_netconv_deregister
parameter_list|(
name|ncp
parameter_list|)
name|struct
name|atm_ncm
modifier|*
name|ncp
decl_stmt|;
block|{
name|int
name|found
decl_stmt|,
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
comment|/* 	 * Remove module from list 	 */
name|UNLINKF
argument_list|(
name|ncp
argument_list|,
expr|struct
name|atm_ncm
argument_list|,
name|atm_netconv_head
argument_list|,
name|ncm_next
argument_list|,
name|found
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
block|{
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
comment|/* 	 * Remove module's interface output function 	 */
name|atm_ifouttbl
index|[
name|ncp
operator|->
name|ncm_family
index|]
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attach an ATM Network Interface  *   * Before an ATM network interface can be used by the system, the owning  * device interface must attach the network interface using this function.  * The physical interface for this network interface must have been previously  * registered (using atm_interface_register).  The network interface will be  * added to the kernel's interface list and to the physical interface's list.  * The caller is responsible for initializing the control block fields.  *  * Arguments:  *	nip	pointer to atm network interface control block  *  * Returns:  *	0	attach successful  *	errno	attach failed - reason indicated  *  */
end_comment

begin_function
name|int
name|atm_nif_attach
parameter_list|(
name|nip
parameter_list|)
name|struct
name|atm_nif
modifier|*
name|nip
decl_stmt|;
block|{
name|struct
name|atm_pif
modifier|*
name|pip
decl_stmt|,
modifier|*
name|pip2
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|atm_ncm
modifier|*
name|ncp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|ifp
operator|=
name|nip
operator|->
name|nif_ifp
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
name|pip
operator|=
name|nip
operator|->
name|nif_pif
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* 	 * Verify physical interface is registered 	 */
for|for
control|(
name|pip2
operator|=
name|atm_interface_head
init|;
name|pip2
operator|!=
name|NULL
condition|;
name|pip2
operator|=
name|pip2
operator|->
name|pif_next
control|)
block|{
if|if
condition|(
name|pip
operator|==
name|pip2
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|pip
operator|==
name|NULL
operator|)
operator|||
operator|(
name|pip2
operator|==
name|NULL
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
comment|/* 	 * Add to system interface list  	 */
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* 	 * Add to BPF interface list 	 * DLT_ATM_RFC_1483 cannot be used because both NULL and LLC/SNAP could 	 * be provisioned 	 */
name|bpfattach
argument_list|(
name|ifp
argument_list|,
name|DLT_ATM_CLIP
argument_list|,
name|T_ATM_LLC_MAX_LEN
argument_list|)
expr_stmt|;
comment|/* 	 * Add to physical interface list 	 */
name|LINK2TAIL
argument_list|(
name|nip
argument_list|,
expr|struct
name|atm_nif
argument_list|,
name|pip
operator|->
name|pif_nif
argument_list|,
name|nif_pnext
argument_list|)
expr_stmt|;
comment|/* 	 * Notify network convergence modules of new network i/f 	 */
for|for
control|(
name|ncp
operator|=
name|atm_netconv_head
init|;
name|ncp
condition|;
name|ncp
operator|=
name|ncp
operator|->
name|ncm_next
control|)
block|{
name|int
name|err
decl_stmt|;
name|err
operator|=
call|(
modifier|*
name|ncp
operator|->
name|ncm_stat
call|)
argument_list|(
name|NCM_ATTACH
argument_list|,
name|nip
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|atm_nif_detach
argument_list|(
name|nip
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Detach an ATM Network Interface  *   * Before an ATM network interface control block can be freed, all kernel  * references to/from this block must be released.  This function will delete  * all routing references to the interface and free all interface addresses  * for the interface.  The network interface will then be removed from the  * kernel's interface list and from the owning physical interface's list.  * The caller is responsible for free'ing the control block.  *  * Arguments:  *	nip	pointer to atm network interface control block  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|atm_nif_detach
parameter_list|(
name|nip
parameter_list|)
name|struct
name|atm_nif
modifier|*
name|nip
decl_stmt|;
block|{
name|struct
name|atm_ncm
modifier|*
name|ncp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|nip
operator|->
name|nif_ifp
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* 	 * Notify convergence modules of network i/f demise 	 */
for|for
control|(
name|ncp
operator|=
name|atm_netconv_head
init|;
name|ncp
condition|;
name|ncp
operator|=
name|ncp
operator|->
name|ncm_next
control|)
block|{
call|(
name|void
call|)
argument_list|(
operator|*
name|ncp
operator|->
name|ncm_stat
argument_list|)
argument_list|(
name|NCM_DETACH
argument_list|,
name|nip
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Remove from BPF interface list 	 */
name|bpfdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* 	 * Free all interface routes and addresses, 	 * delete all remaining routes using this interface, 	 * then remove from the system interface list 	 */
name|if_detach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* 	 * Remove from physical interface list 	 */
name|UNLINK
argument_list|(
name|nip
argument_list|,
expr|struct
name|atm_nif
argument_list|,
name|nip
operator|->
name|nif_pif
operator|->
name|pif_nif
argument_list|,
name|nif_pnext
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set an ATM Network Interface address  *   * This is called from a device interface when processing an SIOCSIFADDR  * ioctl request.  We just notify all convergence modules of the new address  * and hope everyone has non-overlapping interests, since if someone reports  * an error we don't go back and tell everyone to undo the change.  *  * Arguments:  *	nip	pointer to atm network interface control block  *	ifa	pointer to new interface address  *  * Returns:  *	0	set successful  *	errno	set failed - reason indicated  *  */
end_comment

begin_function
name|int
name|atm_nif_setaddr
parameter_list|(
name|nip
parameter_list|,
name|ifa
parameter_list|)
name|struct
name|atm_nif
modifier|*
name|nip
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
block|{
name|struct
name|atm_ncm
modifier|*
name|ncp
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|,
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
comment|/* 	 * Notify convergence modules of network i/f change 	 */
for|for
control|(
name|ncp
operator|=
name|atm_netconv_head
init|;
name|ncp
condition|;
name|ncp
operator|=
name|ncp
operator|->
name|ncm_next
control|)
block|{
name|err
operator|=
call|(
modifier|*
name|ncp
operator|->
name|ncm_stat
call|)
argument_list|(
name|NCM_SETADDR
argument_list|,
name|nip
argument_list|,
operator|(
name|intptr_t
operator|)
name|ifa
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ATM Interface Packet Output  *   * All ATM network interfaces must have their ifnet if_output address set to  * this function.  Since no existing network layer code is to be modified   * for ATM support, this function serves as the hook to allow network output  * packets to be assigned to their proper outbound VCC.  Each network address  * family which is to be supported over ATM must be assigned an output  * packet processing function via atm_netconv_register().  *  * Arguments:  *	ifp	pointer to ifnet structure  *	m	pointer to packet buffer chain to be output  *	dst	pointer to packet's network destination address  *  * Returns:  *	0	packet queued to interface  *	errno	output failed - reason indicated  *  */
end_comment

begin_function
name|int
name|atm_ifoutput
parameter_list|(
name|ifp
parameter_list|,
name|m
parameter_list|,
name|dst
parameter_list|,
name|rt
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|dst
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
block|{
name|u_short
name|fam
init|=
name|dst
operator|->
name|sa_family
decl_stmt|;
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|KBuffer
modifier|*
parameter_list|,
name|struct
name|sockaddr
modifier|*
parameter_list|)
function_decl|;
comment|/* 	 * Validate address family 	 */
if|if
condition|(
name|fam
operator|>
name|AF_MAX
condition|)
block|{
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAFNOSUPPORT
operator|)
return|;
block|}
comment|/* 	 * Hand packet off for dst-to-VCC mapping 	 */
name|func
operator|=
name|atm_ifouttbl
index|[
name|fam
index|]
expr_stmt|;
if|if
condition|(
name|func
operator|==
name|NULL
condition|)
block|{
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAFNOSUPPORT
operator|)
return|;
block|}
return|return
operator|(
call|(
modifier|*
name|func
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|,
name|dst
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle interface ioctl requests.   *  * Arguments:  *	ifp		pointer to network interface structure  *	cmd		IOCTL cmd  *	data		arguments to/from ioctl  *  * Returns:  *	error		errno value  */
end_comment

begin_function
specifier|static
name|int
name|atm_if_ioctl
parameter_list|(
name|ifp
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_long
name|cmd
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
specifier|register
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|atm_nif
modifier|*
name|nip
init|=
name|IFP2ANIF
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCGIFADDR
case|:
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
operator|(
name|nip
operator|->
name|nif_pif
operator|->
name|pif_macaddr
operator|)
argument_list|,
operator|(
name|caddr_t
operator|)
name|ifr
operator|->
name|ifr_addr
operator|.
name|sa_data
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mac_addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFADDR
case|:
name|error
operator|=
name|atm_nif_setaddr
argument_list|(
name|nip
argument_list|,
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
operator||
name|IFF_BROADCAST
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
break|break;
case|case
name|SIOCGIFFLAGS
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse interface name  *   * Parses an interface name string into a name and a unit component.  *  * Arguments:  *	name	pointer to interface name string  *	namep	address to store interface name  *	size	size available at namep  *	unitp	address to store interface unit number  *  * Returns:  *	0 	name parsed  *	else	parse error  *  */
end_comment

begin_function
specifier|static
name|int
name|atm_ifparse
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|namep
parameter_list|,
name|size_t
name|size
parameter_list|,
name|int
modifier|*
name|unitp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|np
decl_stmt|;
name|size_t
name|len
init|=
literal|0
decl_stmt|;
name|int
name|unit
init|=
literal|0
decl_stmt|;
comment|/* 	 * Separate supplied string into name and unit parts. 	 */
name|cp
operator|=
name|name
expr_stmt|;
name|np
operator|=
name|namep
expr_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|>=
literal|'0'
operator|&&
operator|*
name|cp
operator|<=
literal|'9'
condition|)
break|break;
if|if
condition|(
operator|++
name|len
operator|>=
name|size
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|np
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
block|}
operator|*
name|np
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|&&
operator|*
name|cp
operator|>=
literal|'0'
operator|&&
operator|*
name|cp
operator|<=
literal|'9'
condition|)
name|unit
operator|=
literal|10
operator|*
name|unit
operator|+
operator|*
name|cp
operator|++
operator|-
literal|'0'
expr_stmt|;
operator|*
name|unitp
operator|=
name|unit
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Locate ATM physical interface via name  *   * Uses the supplied interface name string to locate a registered  * ATM physical interface.  *  * Arguments:  *	name	pointer to interface name string  *  * Returns:  *	0 	interface not found  *	else	pointer to atm physical interface structure  *  */
end_comment

begin_function
name|struct
name|atm_pif
modifier|*
name|atm_pifname
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|atm_pif
modifier|*
name|pip
decl_stmt|;
name|char
name|n
index|[
name|IFNAMSIZ
index|]
decl_stmt|;
name|int
name|unit
decl_stmt|;
comment|/* 	 * Break down name 	 */
if|if
condition|(
name|atm_ifparse
argument_list|(
name|name
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|n
argument_list|)
argument_list|,
operator|&
name|unit
argument_list|)
condition|)
return|return
operator|(
operator|(
expr|struct
name|atm_pif
operator|*
operator|)
literal|0
operator|)
return|;
comment|/* 	 * Look for the physical interface 	 */
for|for
control|(
name|pip
operator|=
name|atm_interface_head
init|;
name|pip
condition|;
name|pip
operator|=
name|pip
operator|->
name|pif_next
control|)
block|{
if|if
condition|(
operator|(
name|pip
operator|->
name|pif_unit
operator|==
name|unit
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|pip
operator|->
name|pif_name
argument_list|,
name|n
argument_list|)
operator|==
literal|0
operator|)
condition|)
break|break;
block|}
return|return
operator|(
name|pip
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Locate ATM network interface via name  *   * Uses the supplied interface name string to locate an ATM network interface.  *  * Arguments:  *	name	pointer to interface name string  *  * Returns:  *	0 	interface not found  *	else	pointer to atm network interface structure  *  */
end_comment

begin_function
name|struct
name|atm_nif
modifier|*
name|atm_nifname
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|atm_pif
modifier|*
name|pip
decl_stmt|;
name|struct
name|atm_nif
modifier|*
name|nip
decl_stmt|;
name|char
name|n
index|[
name|IFNAMSIZ
index|]
decl_stmt|;
name|int
name|unit
decl_stmt|;
comment|/* 	 * Break down name 	 */
if|if
condition|(
name|atm_ifparse
argument_list|(
name|name
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|n
argument_list|)
argument_list|,
operator|&
name|unit
argument_list|)
condition|)
return|return
operator|(
operator|(
expr|struct
name|atm_nif
operator|*
operator|)
literal|0
operator|)
return|;
comment|/* 	 * Search thru each physical interface 	 */
for|for
control|(
name|pip
operator|=
name|atm_interface_head
init|;
name|pip
condition|;
name|pip
operator|=
name|pip
operator|->
name|pif_next
control|)
block|{
comment|/* 		 * Looking for network interface 		 */
for|for
control|(
name|nip
operator|=
name|pip
operator|->
name|pif_nif
init|;
name|nip
condition|;
name|nip
operator|=
name|nip
operator|->
name|nif_pnext
control|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|(
expr|struct
name|ifnet
operator|*
operator|)
name|nip
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_dunit
operator|==
name|unit
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|ifp
operator|->
name|if_dname
argument_list|,
name|n
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|nip
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

end_unit

