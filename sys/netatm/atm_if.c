begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * ===================================  * HARP  |  Host ATM Research Platform  * ===================================  *  *  * This Host ATM Research Platform ("HARP") file (the "Software") is  * made available by Network Computing Services, Inc. ("NetworkCS")  * "AS IS".  NetworkCS does not provide maintenance, improvements or  * support of any kind.  *  * NETWORKCS MAKES NO WARRANTIES OR REPRESENTATIONS, EXPRESS OR IMPLIED,  * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE, AS TO ANY ELEMENT OF THE  * SOFTWARE OR ANY SUPPORT PROVIDED IN CONNECTION WITH THIS SOFTWARE.  * In no event shall NetworkCS be responsible for any damages, including  * but not limited to consequential damages, arising from or relating to  * any use of the Software or related support.  *  * Copyright 1994-1998 Network Computing Services, Inc.  *  * Copies of this Software may be made, however, the above copyright  * notice must be reproduced on all copies.  *  *	@(#) $FreeBSD$  *  */
end_comment

begin_comment
comment|/*  * Core ATM Services  * -----------------  *  * ATM interface management  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netatm/port.h>
end_include

begin_include
include|#
directive|include
file|<netatm/queue.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sys.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sap.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_cm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_if.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sigmgr.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_stack.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_var.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"@(#) $FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|BSD
argument_list|)
operator|&&
operator|(
name|BSD
operator|<
literal|199506
operator|)
operator|)
end_if

begin_decl_stmt
specifier|extern
name|int
name|ifqmaxlen
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Local functions  */
end_comment

begin_function_decl
specifier|static
name|int
name|atm_physif_ioctl
parameter_list|(
name|int
parameter_list|,
name|caddr_t
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|BSD
argument_list|)
operator|&&
operator|(
name|BSD
operator|>=
literal|199306
operator|)
operator|)
end_if

begin_function_decl
specifier|static
name|int
name|atm_netif_rtdel
parameter_list|(
name|struct
name|radix_node
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|atm_if_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|atm_ifparse
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Local variables  */
end_comment

begin_function_decl
specifier|static
name|int
function_decl|(
modifier|*
name|atm_ifouttbl
index|[
name|AF_MAX
operator|+
literal|1
index|]
function_decl|)
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|KBuffer
modifier|*
parameter_list|,
name|struct
name|sockaddr
modifier|*
parameter_list|)
init|=
block|{
name|NULL
block|}
function_decl|;
end_function_decl

begin_comment
comment|/*  * Register an ATM physical interface  *   * Each ATM device interface must register itself here upon completing  * its internal initialization.  This applies to both linked and loaded  * device drivers.  The interface must be registered before a signalling  * manager can be attached.  *  * Arguments:  *	cup	pointer to interface's common unit structure  *	name	pointer to device name string  *	sdp	pointer to interface's stack services  *  * Returns:  *	0	registration successful  *	errno	registration failed - reason indicated  *  */
end_comment

begin_function
name|int
name|atm_physif_register
parameter_list|(
name|cup
parameter_list|,
name|name
parameter_list|,
name|sdp
parameter_list|)
name|Cmn_unit
modifier|*
name|cup
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|stack_defn
modifier|*
name|sdp
decl_stmt|;
block|{
name|struct
name|atm_pif
modifier|*
name|pip
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* 	 * See if we need to be initialized 	 */
if|if
condition|(
operator|!
name|atm_init
condition|)
name|atm_initialize
argument_list|()
expr_stmt|;
comment|/* 	 * Make sure we're not already registered 	 */
if|if
condition|(
name|cup
operator|->
name|cu_flags
operator|&
name|CUF_REGISTER
condition|)
block|{
return|return
operator|(
name|EALREADY
operator|)
return|;
block|}
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
comment|/* 	 * Make sure an interface is only registered once 	 */
for|for
control|(
name|pip
operator|=
name|atm_interface_head
init|;
name|pip
operator|!=
name|NULL
condition|;
name|pip
operator|=
name|pip
operator|->
name|pif_next
control|)
block|{
if|if
condition|(
operator|(
name|cup
operator|->
name|cu_unit
operator|==
name|pip
operator|->
name|pif_unit
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|pip
operator|->
name|pif_name
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
block|}
comment|/* 	 * Fill in physical interface parameters 	 */
name|pip
operator|=
operator|&
name|cup
operator|->
name|cu_pif
expr_stmt|;
name|pip
operator|->
name|pif_name
operator|=
name|name
expr_stmt|;
name|pip
operator|->
name|pif_unit
operator|=
name|cup
operator|->
name|cu_unit
expr_stmt|;
name|pip
operator|->
name|pif_flags
operator|=
name|PIF_UP
expr_stmt|;
name|pip
operator|->
name|pif_services
operator|=
name|sdp
expr_stmt|;
name|pip
operator|->
name|pif_ioctl
operator|=
name|atm_physif_ioctl
expr_stmt|;
comment|/* 	 * Link in the interface and mark us registered 	 */
name|LINK2TAIL
argument_list|(
name|pip
argument_list|,
expr|struct
name|atm_pif
argument_list|,
name|atm_interface_head
argument_list|,
name|pif_next
argument_list|)
expr_stmt|;
name|cup
operator|->
name|cu_flags
operator||=
name|CUF_REGISTER
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * De-register an ATM physical interface  *   * Each ATM interface must de-register itself before downing the interface.    * The interface's signalling manager will be detached and any network  * interface and VCC control blocks will be freed.    *  * Arguments:  *	cup	pointer to interface's common unit structure  *  * Returns:  *	0	de-registration successful  *	errno	de-registration failed - reason indicated  *  */
end_comment

begin_function
name|int
name|atm_physif_deregister
parameter_list|(
name|cup
parameter_list|)
name|Cmn_unit
modifier|*
name|cup
decl_stmt|;
block|{
name|struct
name|atm_pif
modifier|*
name|pip
init|=
operator|(
expr|struct
name|atm_pif
operator|*
operator|)
operator|&
name|cup
operator|->
name|cu_pif
decl_stmt|;
name|Cmn_vcc
modifier|*
name|cvp
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
comment|/* 	 * Detach and deregister, if needed 	 */
if|if
condition|(
operator|(
name|cup
operator|->
name|cu_flags
operator|&
name|CUF_REGISTER
operator|)
condition|)
block|{
comment|/* 		 * Detach from signalling manager 		 */
if|if
condition|(
name|pip
operator|->
name|pif_sigmgr
operator|!=
name|NULL
condition|)
block|{
name|err
operator|=
name|atm_sigmgr_detach
argument_list|(
name|pip
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
operator|(
name|err
operator|!=
name|ENOENT
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
block|}
comment|/* 		 * Make sure signalling manager is detached 		 */
if|if
condition|(
name|pip
operator|->
name|pif_sigmgr
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
comment|/* 		 * Unlink interface 		 */
name|UNLINK
argument_list|(
name|pip
argument_list|,
expr|struct
name|atm_pif
argument_list|,
name|atm_interface_head
argument_list|,
name|pif_next
argument_list|)
expr_stmt|;
name|cup
operator|->
name|cu_flags
operator|&=
operator|~
name|CUF_REGISTER
expr_stmt|;
block|}
comment|/* 	 * Free all of our network interfaces 	 */
name|atm_physif_freenifs
argument_list|(
name|pip
argument_list|)
expr_stmt|;
comment|/* 	 * Free unit's vcc information 	 */
name|cvp
operator|=
name|cup
operator|->
name|cu_vcc
expr_stmt|;
while|while
condition|(
name|cvp
condition|)
block|{
name|atm_free
argument_list|(
name|cvp
argument_list|)
expr_stmt|;
name|cvp
operator|=
name|cvp
operator|->
name|cv_next
expr_stmt|;
block|}
name|cup
operator|->
name|cu_vcc
operator|=
operator|(
name|Cmn_vcc
operator|*
operator|)
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free all network interfaces on a physical interface  *  * Arguments  *	pip		pointer to physical interface structure  *  * Returns  *	none  *  */
end_comment

begin_function
name|void
name|atm_physif_freenifs
parameter_list|(
name|pip
parameter_list|)
name|struct
name|atm_pif
modifier|*
name|pip
decl_stmt|;
block|{
name|struct
name|atm_nif
modifier|*
name|nip
init|=
name|pip
operator|->
name|pif_nif
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
while|while
condition|(
name|nip
condition|)
block|{
comment|/* 		 * atm_nif_detach zeros pointers - save so we can 		 * walk the chain. 		 */
name|struct
name|atm_nif
modifier|*
name|nipp
init|=
name|nip
operator|->
name|nif_pnext
decl_stmt|;
comment|/* 		 * Clean up network i/f trails 		 */
name|atm_nif_detach
argument_list|(
name|nip
argument_list|)
expr_stmt|;
name|atm_free
argument_list|(
operator|(
name|caddr_t
operator|)
name|nip
argument_list|)
expr_stmt|;
name|nip
operator|=
name|nipp
expr_stmt|;
block|}
name|pip
operator|->
name|pif_nif
operator|=
operator|(
expr|struct
name|atm_nif
operator|*
operator|)
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Handle physical interface ioctl's  *  * See<netatm/atm_ioctl.h> for definitions.  *  * Called at splnet.  *  * Arguments:  *	code			Ioctl function (sub)code  *	data			Data block. On input contains command,  *					on output, contains results  *	arg			Optional code specific arguments  *  * Returns:  *	0			Request processed successfully  *	errno			Request failed - reason code  *  */
end_comment

begin_function
specifier|static
name|int
name|atm_physif_ioctl
parameter_list|(
name|code
parameter_list|,
name|data
parameter_list|,
name|arg
parameter_list|)
name|int
name|code
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
name|caddr_t
name|arg
decl_stmt|;
block|{
name|struct
name|atminfreq
modifier|*
name|aip
init|=
operator|(
expr|struct
name|atminfreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|atmsetreq
modifier|*
name|asr
init|=
operator|(
expr|struct
name|atmsetreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|atm_pif
modifier|*
name|pip
decl_stmt|;
name|struct
name|atm_nif
modifier|*
name|nip
decl_stmt|;
name|struct
name|sigmgr
modifier|*
name|smp
decl_stmt|;
name|struct
name|siginst
modifier|*
name|sip
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|Cmn_unit
modifier|*
name|cup
decl_stmt|;
name|Atm_config
modifier|*
name|acp
decl_stmt|;
name|caddr_t
name|buf
init|=
name|aip
operator|->
name|air_buf_addr
decl_stmt|;
name|struct
name|air_phy_stat_rsp
modifier|*
name|apsp
decl_stmt|;
name|struct
name|air_int_rsp
name|apr
decl_stmt|;
name|struct
name|air_netif_rsp
name|anr
decl_stmt|;
name|struct
name|air_cfg_rsp
name|acr
decl_stmt|;
name|int
name|count
decl_stmt|,
name|len
decl_stmt|,
name|buf_len
init|=
name|aip
operator|->
name|air_buf_len
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|char
name|ifname
index|[
literal|2
operator|*
name|IFNAMSIZ
index|]
decl_stmt|;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|BSD
argument_list|)
operator|&&
operator|(
name|BSD
operator|>=
literal|199103
operator|)
operator|)
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|struct
name|in_ifaddr
modifier|*
name|ia
decl_stmt|;
name|struct
name|sockaddr_dl
modifier|*
name|sdl
decl_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|aip
operator|->
name|air_opcode
condition|)
block|{
case|case
name|AIOCS_INF_INT
case|:
comment|/* 		 * Get physical interface information 		 */
name|aip
operator|=
operator|(
expr|struct
name|atminfreq
operator|*
operator|)
name|data
expr_stmt|;
name|pip
operator|=
operator|(
expr|struct
name|atm_pif
operator|*
operator|)
name|arg
expr_stmt|;
comment|/* 		 * Make sure there's room in user buffer 		 */
if|if
condition|(
name|aip
operator|->
name|air_buf_len
operator|<
sizeof|sizeof
argument_list|(
name|apr
argument_list|)
condition|)
block|{
name|err
operator|=
name|ENOSPC
expr_stmt|;
break|break;
block|}
comment|/* 		 * Fill in info to be returned 		 */
name|KM_ZERO
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|apr
argument_list|,
sizeof|sizeof
argument_list|(
name|apr
argument_list|)
argument_list|)
expr_stmt|;
name|smp
operator|=
name|pip
operator|->
name|pif_sigmgr
expr_stmt|;
name|sip
operator|=
name|pip
operator|->
name|pif_siginst
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|apr
operator|.
name|anp_intf
argument_list|,
sizeof|sizeof
argument_list|(
name|apr
operator|.
name|anp_intf
argument_list|)
argument_list|,
literal|"%s%d"
argument_list|,
name|pip
operator|->
name|pif_name
argument_list|,
name|pip
operator|->
name|pif_unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|pip
operator|->
name|pif_nif
condition|)
block|{
name|strcpy
argument_list|(
name|apr
operator|.
name|anp_nif_pref
argument_list|,
name|pip
operator|->
name|pif_nif
operator|->
name|nif_if
operator|.
name|if_name
argument_list|)
expr_stmt|;
name|nip
operator|=
name|pip
operator|->
name|pif_nif
expr_stmt|;
while|while
condition|(
name|nip
condition|)
block|{
name|apr
operator|.
name|anp_nif_cnt
operator|++
expr_stmt|;
name|nip
operator|=
name|nip
operator|->
name|nif_pnext
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sip
condition|)
block|{
name|ATM_ADDR_COPY
argument_list|(
operator|&
name|sip
operator|->
name|si_addr
argument_list|,
operator|&
name|apr
operator|.
name|anp_addr
argument_list|)
expr_stmt|;
name|ATM_ADDR_COPY
argument_list|(
operator|&
name|sip
operator|->
name|si_subaddr
argument_list|,
operator|&
name|apr
operator|.
name|anp_subaddr
argument_list|)
expr_stmt|;
name|apr
operator|.
name|anp_sig_proto
operator|=
name|smp
operator|->
name|sm_proto
expr_stmt|;
name|apr
operator|.
name|anp_sig_state
operator|=
name|sip
operator|->
name|si_state
expr_stmt|;
block|}
comment|/* 		 * Copy data to user buffer 		 */
name|err
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|apr
argument_list|,
name|aip
operator|->
name|air_buf_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|apr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
comment|/* 		 * Update buffer pointer/count 		 */
name|aip
operator|->
name|air_buf_addr
operator|+=
sizeof|sizeof
argument_list|(
name|apr
argument_list|)
expr_stmt|;
name|aip
operator|->
name|air_buf_len
operator|-=
sizeof|sizeof
argument_list|(
name|apr
argument_list|)
expr_stmt|;
break|break;
case|case
name|AIOCS_INF_NIF
case|:
comment|/* 		 * Get network interface information 		 */
name|aip
operator|=
operator|(
expr|struct
name|atminfreq
operator|*
operator|)
name|data
expr_stmt|;
name|nip
operator|=
operator|(
expr|struct
name|atm_nif
operator|*
operator|)
name|arg
expr_stmt|;
name|ifp
operator|=
operator|&
name|nip
operator|->
name|nif_if
expr_stmt|;
name|pip
operator|=
name|nip
operator|->
name|nif_pif
expr_stmt|;
comment|/* 		 * Make sure there's room in user buffer 		 */
if|if
condition|(
name|aip
operator|->
name|air_buf_len
operator|<
sizeof|sizeof
argument_list|(
name|anr
argument_list|)
condition|)
block|{
name|err
operator|=
name|ENOSPC
expr_stmt|;
break|break;
block|}
comment|/* 		 * Fill in info to be returned 		 */
name|KM_ZERO
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|anr
argument_list|,
sizeof|sizeof
argument_list|(
name|anr
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|anr
operator|.
name|anp_intf
argument_list|,
sizeof|sizeof
argument_list|(
name|anr
operator|.
name|anp_intf
argument_list|)
argument_list|,
literal|"%s%d"
argument_list|,
name|ifp
operator|->
name|if_name
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
name|IFP_TO_IA
argument_list|(
name|ifp
argument_list|,
name|ia
argument_list|)
expr_stmt|;
if|if
condition|(
name|ia
condition|)
block|{
name|anr
operator|.
name|anp_proto_addr
operator|=
operator|*
name|ia
operator|->
name|ia_ifa
operator|.
name|ifa_addr
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|anr
operator|.
name|anp_phy_intf
argument_list|,
sizeof|sizeof
argument_list|(
name|anr
operator|.
name|anp_phy_intf
argument_list|)
argument_list|,
literal|"%s%d"
argument_list|,
name|pip
operator|->
name|pif_name
argument_list|,
name|pip
operator|->
name|pif_unit
argument_list|)
expr_stmt|;
comment|/* 		 * Copy data to user buffer 		 */
name|err
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|anr
argument_list|,
name|aip
operator|->
name|air_buf_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|anr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
comment|/* 		 * Update buffer pointer/count 		 */
name|aip
operator|->
name|air_buf_addr
operator|+=
sizeof|sizeof
argument_list|(
name|anr
argument_list|)
expr_stmt|;
name|aip
operator|->
name|air_buf_len
operator|-=
sizeof|sizeof
argument_list|(
name|anr
argument_list|)
expr_stmt|;
break|break;
case|case
name|AIOCS_INF_PIS
case|:
comment|/* 		 * Get per interface statistics 		 */
name|pip
operator|=
operator|(
expr|struct
name|atm_pif
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|pip
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|snprintf
argument_list|(
name|ifname
argument_list|,
sizeof|sizeof
argument_list|(
name|ifname
argument_list|)
argument_list|,
literal|"%s%d"
argument_list|,
name|pip
operator|->
name|pif_name
argument_list|,
name|pip
operator|->
name|pif_unit
argument_list|)
expr_stmt|;
comment|/* 		 * Cast response into users buffer 		 */
name|apsp
operator|=
operator|(
expr|struct
name|air_phy_stat_rsp
operator|*
operator|)
name|buf
expr_stmt|;
comment|/* 		 * Sanity check 		 */
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|air_phy_stat_rsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf_len
operator|<
name|len
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
comment|/* 		 * Copy interface name into response 		 */
if|if
condition|(
operator|(
name|err
operator|=
name|copyout
argument_list|(
name|ifname
argument_list|,
name|apsp
operator|->
name|app_intf
argument_list|,
name|IFNAMSIZ
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
comment|/* 		 * Copy counters 		 */
if|if
condition|(
operator|(
name|err
operator|=
name|copyout
argument_list|(
operator|&
name|pip
operator|->
name|pif_ipdus
argument_list|,
operator|&
name|apsp
operator|->
name|app_ipdus
argument_list|,
name|len
operator|-
sizeof|sizeof
argument_list|(
name|apsp
operator|->
name|app_intf
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
comment|/* 		 * Adjust buffer elements 		 */
name|buf
operator|+=
name|len
expr_stmt|;
name|buf_len
operator|-=
name|len
expr_stmt|;
name|aip
operator|->
name|air_buf_addr
operator|=
name|buf
expr_stmt|;
name|aip
operator|->
name|air_buf_len
operator|=
name|buf_len
expr_stmt|;
break|break;
case|case
name|AIOCS_SET_NIF
case|:
comment|/* 		 * Set NIF - allow user to configure 1 or more logical 		 *	interfaces per physical interface. 		 */
comment|/* 		 * Get pointer to physical interface structure from 		 * ioctl argument. 		 */
name|pip
operator|=
operator|(
expr|struct
name|atm_pif
operator|*
operator|)
name|arg
expr_stmt|;
name|cup
operator|=
operator|(
name|Cmn_unit
operator|*
operator|)
name|pip
expr_stmt|;
comment|/* 		 * Sanity check - are we already connected to something? 		 */
if|if
condition|(
name|pip
operator|->
name|pif_sigmgr
condition|)
block|{
name|err
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
comment|/* 		 * Free any previously allocated NIFs 		 */
name|atm_physif_freenifs
argument_list|(
name|pip
argument_list|)
expr_stmt|;
comment|/* 		 * Add list of interfaces 		 */
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|asr
operator|->
name|asr_nif_cnt
condition|;
name|count
operator|++
control|)
block|{
name|nip
operator|=
operator|(
expr|struct
name|atm_nif
operator|*
operator|)
name|atm_allocate
argument_list|(
name|cup
operator|->
name|cu_nif_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|nip
operator|==
name|NULL
condition|)
block|{
comment|/* 				 * Destroy any successful nifs 				 */
name|atm_physif_freenifs
argument_list|(
name|pip
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|nip
operator|->
name|nif_pif
operator|=
name|pip
expr_stmt|;
name|ifp
operator|=
operator|&
name|nip
operator|->
name|nif_if
expr_stmt|;
name|strcpy
argument_list|(
name|nip
operator|->
name|nif_name
argument_list|,
name|asr
operator|->
name|asr_nif_pref
argument_list|)
expr_stmt|;
name|nip
operator|->
name|nif_sel
operator|=
name|count
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
name|nip
operator|->
name|nif_name
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|count
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ATM_NIF_MTU
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_UP
operator||
name|IFF_BROADCAST
operator||
name|IFF_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|atm_ifoutput
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|atm_if_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|ifqmaxlen
expr_stmt|;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|BSD
argument_list|)
operator|&&
operator|(
name|BSD
operator|>=
literal|199103
operator|)
operator|)
comment|/* 			 * Set if_type and if_baudrate 			 */
name|ifp
operator|->
name|if_type
operator|=
name|IFT_ATM
expr_stmt|;
switch|switch
condition|(
name|cup
operator|->
name|cu_config
operator|.
name|ac_media
condition|)
block|{
case|case
name|MEDIA_TAXI_100
case|:
name|ifp
operator|->
name|if_baudrate
operator|=
literal|100000000
expr_stmt|;
break|break;
case|case
name|MEDIA_TAXI_140
case|:
name|ifp
operator|->
name|if_baudrate
operator|=
literal|140000000
expr_stmt|;
break|break;
case|case
name|MEDIA_OC3C
case|:
case|case
name|MEDIA_OC12C
case|:
case|case
name|MEDIA_UTP155
case|:
name|ifp
operator|->
name|if_baudrate
operator|=
literal|155000000
expr_stmt|;
break|break;
case|case
name|MEDIA_UNKNOWN
case|:
name|ifp
operator|->
name|if_baudrate
operator|=
literal|9600
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|err
operator|=
name|atm_nif_attach
argument_list|(
name|nip
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|atm_free
argument_list|(
operator|(
name|caddr_t
operator|)
name|nip
argument_list|)
expr_stmt|;
comment|/* 				 * Destroy any successful nifs 				 */
name|atm_physif_freenifs
argument_list|(
name|pip
argument_list|)
expr_stmt|;
break|break;
block|}
if|#
directive|if
operator|(
name|defined
argument_list|(
name|BSD
argument_list|)
operator|&&
operator|(
name|BSD
operator|>=
literal|199103
operator|)
operator|)
comment|/* 			 * Set macaddr in<Link> address 			 */
name|ifp
operator|->
name|if_addrlen
operator|=
literal|6
expr_stmt|;
name|ifa
operator|=
name|ifaddr_byindex
argument_list|(
name|ifp
operator|->
name|if_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifa
condition|)
block|{
name|sdl
operator|=
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifa
operator|->
name|ifa_addr
expr_stmt|;
name|sdl
operator|->
name|sdl_type
operator|=
name|IFT_ETHER
expr_stmt|;
name|sdl
operator|->
name|sdl_alen
operator|=
name|ifp
operator|->
name|if_addrlen
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|cup
operator|->
name|cu_config
operator|.
name|ac_macaddr
argument_list|,
name|LLADDR
argument_list|(
name|sdl
argument_list|)
argument_list|,
name|ifp
operator|->
name|if_addrlen
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
break|break;
case|case
name|AIOCS_INF_CFG
case|:
comment|/* 		 * Get adapter configuration information 		 */
name|aip
operator|=
operator|(
expr|struct
name|atminfreq
operator|*
operator|)
name|data
expr_stmt|;
name|pip
operator|=
operator|(
expr|struct
name|atm_pif
operator|*
operator|)
name|arg
expr_stmt|;
name|cup
operator|=
operator|(
name|Cmn_unit
operator|*
operator|)
name|pip
expr_stmt|;
name|acp
operator|=
operator|&
name|cup
operator|->
name|cu_config
expr_stmt|;
comment|/* 		 * Make sure there's room in user buffer 		 */
if|if
condition|(
name|aip
operator|->
name|air_buf_len
operator|<
sizeof|sizeof
argument_list|(
name|acr
argument_list|)
condition|)
block|{
name|err
operator|=
name|ENOSPC
expr_stmt|;
break|break;
block|}
comment|/* 		 * Fill in info to be returned 		 */
name|KM_ZERO
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|acr
argument_list|,
sizeof|sizeof
argument_list|(
name|acr
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|acr
operator|.
name|acp_intf
argument_list|,
sizeof|sizeof
argument_list|(
name|acr
operator|.
name|acp_intf
argument_list|)
argument_list|,
literal|"%s%d"
argument_list|,
name|pip
operator|->
name|pif_name
argument_list|,
name|pip
operator|->
name|pif_unit
argument_list|)
expr_stmt|;
name|KM_COPY
argument_list|(
operator|(
name|caddr_t
operator|)
name|acp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|acr
operator|.
name|acp_cfg
argument_list|,
sizeof|sizeof
argument_list|(
name|Atm_config
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Copy data to user buffer 		 */
name|err
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|acr
argument_list|,
name|aip
operator|->
name|air_buf_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|acr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
comment|/* 		 * Update buffer pointer/count 		 */
name|aip
operator|->
name|air_buf_addr
operator|+=
sizeof|sizeof
argument_list|(
name|acr
argument_list|)
expr_stmt|;
name|aip
operator|->
name|air_buf_len
operator|-=
sizeof|sizeof
argument_list|(
name|acr
argument_list|)
expr_stmt|;
break|break;
case|case
name|AIOCS_INF_VST
case|:
comment|/* 		 * Pass off to device-specific handler 		 */
name|cup
operator|=
operator|(
name|Cmn_unit
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|cup
operator|==
name|NULL
condition|)
name|err
operator|=
name|ENXIO
expr_stmt|;
else|else
name|err
operator|=
call|(
modifier|*
name|cup
operator|->
name|cu_ioctl
call|)
argument_list|(
name|code
argument_list|,
name|data
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|err
operator|=
name|ENOSYS
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Register a Network Convergence Module  *   * Each ATM network convergence module must register itself here before  * it will receive network interface status notifications.   *  * Arguments:  *	ncp	pointer to network convergence definition structure  *  * Returns:  *	0	registration successful  *	errno	registration failed - reason indicated  *  */
end_comment

begin_function
name|int
name|atm_netconv_register
parameter_list|(
name|ncp
parameter_list|)
name|struct
name|atm_ncm
modifier|*
name|ncp
decl_stmt|;
block|{
name|struct
name|atm_ncm
modifier|*
name|tdp
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
comment|/* 	 * See if we need to be initialized 	 */
if|if
condition|(
operator|!
name|atm_init
condition|)
name|atm_initialize
argument_list|()
expr_stmt|;
comment|/* 	 * Validate protocol family 	 */
if|if
condition|(
name|ncp
operator|->
name|ncm_family
operator|>
name|AF_MAX
condition|)
block|{
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * Ensure no duplicates 	 */
for|for
control|(
name|tdp
operator|=
name|atm_netconv_head
init|;
name|tdp
operator|!=
name|NULL
condition|;
name|tdp
operator|=
name|tdp
operator|->
name|ncm_next
control|)
block|{
if|if
condition|(
name|tdp
operator|->
name|ncm_family
operator|==
name|ncp
operator|->
name|ncm_family
condition|)
block|{
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
block|}
comment|/* 	 * Add module to list 	 */
name|LINK2TAIL
argument_list|(
name|ncp
argument_list|,
expr|struct
name|atm_ncm
argument_list|,
name|atm_netconv_head
argument_list|,
name|ncm_next
argument_list|)
expr_stmt|;
comment|/* 	 * Add new interface output function 	 */
name|atm_ifouttbl
index|[
name|ncp
operator|->
name|ncm_family
index|]
operator|=
name|ncp
operator|->
name|ncm_ifoutput
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * De-register an ATM Network Convergence Module  *   * Each ATM network convergence provider must de-register its registered   * service(s) before terminating.  Specifically, loaded kernel modules  * must de-register their services before unloading themselves.  *  * Arguments:  *	ncp	pointer to network convergence definition structure  *  * Returns:  *	0	de-registration successful   *	errno	de-registration failed - reason indicated  *  */
end_comment

begin_function
name|int
name|atm_netconv_deregister
parameter_list|(
name|ncp
parameter_list|)
name|struct
name|atm_ncm
modifier|*
name|ncp
decl_stmt|;
block|{
name|int
name|found
decl_stmt|,
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
comment|/* 	 * Remove module from list 	 */
name|UNLINKF
argument_list|(
name|ncp
argument_list|,
expr|struct
name|atm_ncm
argument_list|,
name|atm_netconv_head
argument_list|,
name|ncm_next
argument_list|,
name|found
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
block|{
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
comment|/* 	 * Remove module's interface output function 	 */
name|atm_ifouttbl
index|[
name|ncp
operator|->
name|ncm_family
index|]
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attach an ATM Network Interface  *   * Before an ATM network interface can be used by the system, the owning  * device interface must attach the network interface using this function.  * The physical interface for this network interface must have been previously  * registered (using atm_interface_register).  The network interface will be  * added to the kernel's interface list and to the physical interface's list.  * The caller is responsible for initializing the control block fields.  *  * Arguments:  *	nip	pointer to atm network interface control block  *  * Returns:  *	0	attach successful  *	errno	attach failed - reason indicated  *  */
end_comment

begin_function
name|int
name|atm_nif_attach
parameter_list|(
name|nip
parameter_list|)
name|struct
name|atm_nif
modifier|*
name|nip
decl_stmt|;
block|{
name|struct
name|atm_pif
modifier|*
name|pip
decl_stmt|,
modifier|*
name|pip2
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|atm_ncm
modifier|*
name|ncp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|ifp
operator|=
operator|&
name|nip
operator|->
name|nif_if
expr_stmt|;
name|pip
operator|=
name|nip
operator|->
name|nif_pif
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* 	 * Verify physical interface is registered 	 */
for|for
control|(
name|pip2
operator|=
name|atm_interface_head
init|;
name|pip2
operator|!=
name|NULL
condition|;
name|pip2
operator|=
name|pip2
operator|->
name|pif_next
control|)
block|{
if|if
condition|(
name|pip
operator|==
name|pip2
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|pip
operator|==
name|NULL
operator|)
operator|||
operator|(
name|pip2
operator|==
name|NULL
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
comment|/* 	 * Add to system interface list  	 */
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* 	 * Add to physical interface list 	 */
name|LINK2TAIL
argument_list|(
name|nip
argument_list|,
expr|struct
name|atm_nif
argument_list|,
name|pip
operator|->
name|pif_nif
argument_list|,
name|nif_pnext
argument_list|)
expr_stmt|;
comment|/* 	 * Notify network convergence modules of new network i/f 	 */
for|for
control|(
name|ncp
operator|=
name|atm_netconv_head
init|;
name|ncp
condition|;
name|ncp
operator|=
name|ncp
operator|->
name|ncm_next
control|)
block|{
name|int
name|err
decl_stmt|;
name|err
operator|=
call|(
modifier|*
name|ncp
operator|->
name|ncm_stat
call|)
argument_list|(
name|NCM_ATTACH
argument_list|,
name|nip
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|atm_nif_detach
argument_list|(
name|nip
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Detach an ATM Network Interface  *   * Before an ATM network interface control block can be freed, all kernel  * references to/from this block must be released.  This function will delete  * all routing references to the interface and free all interface addresses  * for the interface.  The network interface will then be removed from the  * kernel's interface list and from the owning physical interface's list.  * The caller is responsible for free'ing the control block.  *  * Arguments:  *	nip	pointer to atm network interface control block  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|atm_nif_detach
parameter_list|(
name|nip
parameter_list|)
name|struct
name|atm_nif
modifier|*
name|nip
decl_stmt|;
block|{
name|struct
name|atm_ncm
modifier|*
name|ncp
decl_stmt|;
name|int
name|s
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|nip
operator|->
name|nif_if
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|struct
name|in_ifaddr
modifier|*
name|ia
decl_stmt|;
name|struct
name|radix_node_head
modifier|*
name|rnh
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* 	 * Notify convergence modules of network i/f demise 	 */
for|for
control|(
name|ncp
operator|=
name|atm_netconv_head
init|;
name|ncp
condition|;
name|ncp
operator|=
name|ncp
operator|->
name|ncm_next
control|)
block|{
call|(
name|void
call|)
argument_list|(
operator|*
name|ncp
operator|->
name|ncm_stat
argument_list|)
argument_list|(
name|NCM_DETACH
argument_list|,
name|nip
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Mark interface down 	 */
name|if_down
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* 	 * Free all interface routes and addresses 	 */
while|while
condition|(
literal|1
condition|)
block|{
name|IFP_TO_IA
argument_list|(
name|ifp
argument_list|,
name|ia
argument_list|)
expr_stmt|;
if|if
condition|(
name|ia
operator|==
name|NULL
condition|)
break|break;
comment|/* Delete interface route */
name|in_ifscrub
argument_list|(
name|ifp
argument_list|,
name|ia
argument_list|)
expr_stmt|;
comment|/* Remove interface address from queues */
name|ifa
operator|=
operator|&
name|ia
operator|->
name|ia_ifa
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ifp
operator|->
name|if_addrhead
argument_list|,
name|ifa
argument_list|,
name|ifa_link
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|in_ifaddrhead
argument_list|,
name|ia
argument_list|,
name|ia_link
argument_list|)
expr_stmt|;
comment|/* Free interface address */
name|IFAFREE
argument_list|(
name|ifa
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Delete all remaining routes using this interface 	 * Unfortuneatly the only way to do this is to slog through 	 * the entire routing table looking for routes which point 	 * to this interface...oh well... 	 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|AF_MAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|rnh
operator|=
name|rt_tables
index|[
name|i
index|]
operator|)
operator|==
name|NULL
condition|)
continue|continue;
operator|(
name|void
operator|)
name|rnh
operator|->
name|rnh_walktree
argument_list|(
name|rnh
argument_list|,
name|atm_netif_rtdel
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Remove from system interface list (ie. if_detach()) 	 */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ifnet
argument_list|,
name|ifp
argument_list|,
name|if_link
argument_list|)
expr_stmt|;
comment|/* 	 * Remove from physical interface list 	 */
name|UNLINK
argument_list|(
name|nip
argument_list|,
expr|struct
name|atm_nif
argument_list|,
name|nip
operator|->
name|nif_pif
operator|->
name|pif_nif
argument_list|,
name|nif_pnext
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Delete Routes for a Network Interface  *   * Called for each routing entry via the rnh->rnh_walktree() call above  * to delete all route entries referencing a detaching network interface.  *  * Arguments:  *	rn	pointer to node in the routing table  *	arg	argument passed to rnh->rnh_walktree() - detaching interface  *  * Returns:  *	0	successful  *	errno	failed - reason indicated  *  */
end_comment

begin_function
specifier|static
name|int
name|atm_netif_rtdel
parameter_list|(
name|rn
parameter_list|,
name|arg
parameter_list|)
name|struct
name|radix_node
modifier|*
name|rn
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|rtentry
modifier|*
name|rt
init|=
operator|(
expr|struct
name|rtentry
operator|*
operator|)
name|rn
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|arg
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|rt
operator|->
name|rt_ifp
operator|==
name|ifp
condition|)
block|{
comment|/* 		 * Protect (sorta) against walktree recursion problems 		 * with cloned routes 		 */
if|if
condition|(
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_UP
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|err
operator|=
name|rtrequest
argument_list|(
name|RTM_DELETE
argument_list|,
name|rt_key
argument_list|(
name|rt
argument_list|)
argument_list|,
name|rt
operator|->
name|rt_gateway
argument_list|,
name|rt_mask
argument_list|(
name|rt
argument_list|)
argument_list|,
name|rt
operator|->
name|rt_flags
argument_list|,
operator|(
expr|struct
name|rtentry
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"atm_netif_rtdel: error %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set an ATM Network Interface address  *   * This is called from a device interface when processing an SIOCSIFADDR  * ioctl request.  We just notify all convergence modules of the new address  * and hope everyone has non-overlapping interests, since if someone reports  * an error we don't go back and tell everyone to undo the change.  *  * Arguments:  *	nip	pointer to atm network interface control block  *	ifa	pointer to new interface address  *  * Returns:  *	0	set successful  *	errno	set failed - reason indicated  *  */
end_comment

begin_function
name|int
name|atm_nif_setaddr
parameter_list|(
name|nip
parameter_list|,
name|ifa
parameter_list|)
name|struct
name|atm_nif
modifier|*
name|nip
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
block|{
name|struct
name|atm_ncm
modifier|*
name|ncp
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|,
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
comment|/* 	 * Notify convergence modules of network i/f change 	 */
for|for
control|(
name|ncp
operator|=
name|atm_netconv_head
init|;
name|ncp
condition|;
name|ncp
operator|=
name|ncp
operator|->
name|ncm_next
control|)
block|{
name|err
operator|=
call|(
modifier|*
name|ncp
operator|->
name|ncm_stat
call|)
argument_list|(
name|NCM_SETADDR
argument_list|,
name|nip
argument_list|,
operator|(
name|int
operator|)
name|ifa
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ATM Interface Packet Output  *   * All ATM network interfaces must have their ifnet if_output address set to  * this function.  Since no existing network layer code is to be modified   * for ATM support, this function serves as the hook to allow network output  * packets to be assigned to their proper outbound VCC.  Each network address  * family which is to be supported over ATM must be assigned an output  * packet processing function via atm_netconv_register().  *  * Arguments:  *	ifp	pointer to ifnet structure  *	m	pointer to packet buffer chain to be output  *	dst	pointer to packet's network destination address  *  * Returns:  *	0	packet queued to interface  *	errno	output failed - reason indicated  *  */
end_comment

begin_function
name|int
if|#
directive|if
operator|(
name|defined
argument_list|(
name|BSD
argument_list|)
operator|&&
operator|(
name|BSD
operator|>=
literal|199103
operator|)
operator|)
name|atm_ifoutput
parameter_list|(
name|ifp
parameter_list|,
name|m
parameter_list|,
name|dst
parameter_list|,
name|rt
parameter_list|)
else|#
directive|else
function|atm_ifoutput
parameter_list|(
name|ifp
parameter_list|,
name|m
parameter_list|,
name|dst
parameter_list|)
endif|#
directive|endif
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|dst
decl_stmt|;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|BSD
argument_list|)
operator|&&
operator|(
name|BSD
operator|>=
literal|199103
operator|)
operator|)
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
endif|#
directive|endif
block|{
name|u_short
name|fam
init|=
name|dst
operator|->
name|sa_family
decl_stmt|;
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|KBuffer
modifier|*
parameter_list|,
name|struct
name|sockaddr
modifier|*
parameter_list|)
function_decl|;
comment|/* 	 * Validate address family 	 */
if|if
condition|(
name|fam
operator|>
name|AF_MAX
condition|)
block|{
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAFNOSUPPORT
operator|)
return|;
block|}
comment|/* 	 * Hand packet off for dst-to-VCC mapping 	 */
name|func
operator|=
name|atm_ifouttbl
index|[
name|fam
index|]
expr_stmt|;
if|if
condition|(
name|func
operator|==
name|NULL
condition|)
block|{
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAFNOSUPPORT
operator|)
return|;
block|}
return|return
operator|(
call|(
modifier|*
name|func
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|,
name|dst
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle interface ioctl requests.   *  * Arguments:  *	ifp		pointer to network interface structure  *	cmd		IOCTL cmd  *	data		arguments to/from ioctl  *  * Returns:  *	error		errno value  */
end_comment

begin_function
specifier|static
name|int
name|atm_if_ioctl
parameter_list|(
name|ifp
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_long
name|cmd
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
specifier|register
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|atm_nif
modifier|*
name|nip
init|=
operator|(
expr|struct
name|atm_nif
operator|*
operator|)
name|ifp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCGIFADDR
case|:
name|KM_COPY
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
operator|(
name|nip
operator|->
name|nif_pif
operator|->
name|pif_macaddr
operator|)
argument_list|,
operator|(
name|caddr_t
operator|)
name|ifr
operator|->
name|ifr_addr
operator|.
name|sa_data
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mac_addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFADDR
case|:
name|error
operator|=
name|atm_nif_setaddr
argument_list|(
name|nip
argument_list|,
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
operator||
name|IFF_RUNNING
operator||
name|IFF_BROADCAST
expr_stmt|;
break|break;
case|case
name|SIOCGIFFLAGS
case|:
operator|*
operator|(
name|short
operator|*
operator|)
name|data
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse interface name  *   * Parses an interface name string into a name and a unit component.  *  * Arguments:  *	name	pointer to interface name string  *	namep	address to store interface name  *	size	size available at namep  *	unitp	address to store interface unit number  *  * Returns:  *	0 	name parsed  *	else	parse error  *  */
end_comment

begin_function
specifier|static
name|int
name|atm_ifparse
parameter_list|(
name|name
parameter_list|,
name|namep
parameter_list|,
name|size
parameter_list|,
name|unitp
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|namep
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
modifier|*
name|unitp
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|,
name|unit
init|=
literal|0
decl_stmt|;
comment|/* 	 * Separate supplied string into name and unit parts. 	 */
name|cp
operator|=
name|name
expr_stmt|;
name|np
operator|=
name|namep
expr_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|>=
literal|'0'
operator|&&
operator|*
name|cp
operator|<=
literal|'9'
condition|)
break|break;
if|if
condition|(
operator|++
name|len
operator|>=
name|size
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|np
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
block|}
operator|*
name|np
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|&&
operator|*
name|cp
operator|>=
literal|'0'
operator|&&
operator|*
name|cp
operator|<=
literal|'9'
condition|)
name|unit
operator|=
literal|10
operator|*
name|unit
operator|+
operator|*
name|cp
operator|++
operator|-
literal|'0'
expr_stmt|;
operator|*
name|unitp
operator|=
name|unit
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Locate ATM physical interface via name  *   * Uses the supplied interface name string to locate a registered  * ATM physical interface.  *  * Arguments:  *	name	pointer to interface name string  *  * Returns:  *	0 	interface not found  *	else	pointer to atm physical interface structure  *  */
end_comment

begin_function
name|struct
name|atm_pif
modifier|*
name|atm_pifname
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|atm_pif
modifier|*
name|pip
decl_stmt|;
name|char
name|n
index|[
name|IFNAMSIZ
index|]
decl_stmt|;
name|int
name|unit
decl_stmt|;
comment|/* 	 * Break down name 	 */
if|if
condition|(
name|atm_ifparse
argument_list|(
name|name
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|n
argument_list|)
argument_list|,
operator|&
name|unit
argument_list|)
condition|)
return|return
operator|(
operator|(
expr|struct
name|atm_pif
operator|*
operator|)
literal|0
operator|)
return|;
comment|/* 	 * Look for the physical interface 	 */
for|for
control|(
name|pip
operator|=
name|atm_interface_head
init|;
name|pip
condition|;
name|pip
operator|=
name|pip
operator|->
name|pif_next
control|)
block|{
if|if
condition|(
operator|(
name|pip
operator|->
name|pif_unit
operator|==
name|unit
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|pip
operator|->
name|pif_name
argument_list|,
name|n
argument_list|)
operator|==
literal|0
operator|)
condition|)
break|break;
block|}
return|return
operator|(
name|pip
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Locate ATM network interface via name  *   * Uses the supplied interface name string to locate an ATM network interface.  *  * Arguments:  *	name	pointer to interface name string  *  * Returns:  *	0 	interface not found  *	else	pointer to atm network interface structure  *  */
end_comment

begin_function
name|struct
name|atm_nif
modifier|*
name|atm_nifname
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|atm_pif
modifier|*
name|pip
decl_stmt|;
name|struct
name|atm_nif
modifier|*
name|nip
decl_stmt|;
name|char
name|n
index|[
name|IFNAMSIZ
index|]
decl_stmt|;
name|int
name|unit
decl_stmt|;
comment|/* 	 * Break down name 	 */
if|if
condition|(
name|atm_ifparse
argument_list|(
name|name
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|n
argument_list|)
argument_list|,
operator|&
name|unit
argument_list|)
condition|)
return|return
operator|(
operator|(
expr|struct
name|atm_nif
operator|*
operator|)
literal|0
operator|)
return|;
comment|/* 	 * Search thru each physical interface 	 */
for|for
control|(
name|pip
operator|=
name|atm_interface_head
init|;
name|pip
condition|;
name|pip
operator|=
name|pip
operator|->
name|pif_next
control|)
block|{
comment|/* 		 * Looking for network interface 		 */
for|for
control|(
name|nip
operator|=
name|pip
operator|->
name|pif_nif
init|;
name|nip
condition|;
name|nip
operator|=
name|nip
operator|->
name|nif_pnext
control|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|(
expr|struct
name|ifnet
operator|*
operator|)
name|nip
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_unit
operator|==
name|unit
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|ifp
operator|->
name|if_name
argument_list|,
name|n
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|nip
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

end_unit

