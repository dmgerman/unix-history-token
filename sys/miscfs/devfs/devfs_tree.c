begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 1997,1998 Julian Elischer.  All rights reserved.  * julian@freebsd.org  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  1. Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  2. Redistributions in binary form must reproduce the above copyright notice,  *     this list of conditions and the following disclaimer in the documentation  *     and/or other materials provided with the distribution.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER ``AS IS'' AND ANY EXPRESS  * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE HOLDER OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *   *	$Id: devfs_tree.c,v 1.60 1999/08/24 20:30:15 julian Exp $  */
end_comment

begin_comment
comment|/* SPLIT_DEVS means each devfs uses a different vnode for the same device */
end_comment

begin_comment
comment|/* Otherwise the same device always ends up at the same vnode even if  */
end_comment

begin_comment
comment|/* reached througgh a different devfs instance. The practical difference */
end_comment

begin_comment
comment|/* is that with the same vnode, chmods and chowns show up on all instances of */
end_comment

begin_comment
comment|/* a device. (etc) */
end_comment

begin_define
define|#
directive|define
name|SPLIT_DEVS
value|1
end_define

begin_comment
comment|/* maybe make this an option */
end_comment

begin_comment
comment|/*#define SPLIT_DEVS 1*/
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/devfsext.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_include
include|#
directive|include
file|<miscfs/devfs/devfsdefs.h>
end_include

begin_escape
end_escape

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_DEVFSNODE
argument_list|,
literal|"DEVFS node"
argument_list|,
literal|"DEVFS node"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_DEVFSNAME
argument_list|,
literal|"DEVFS name"
argument_list|,
literal|"DEVFS name"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|devfs_add_to_tree
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|uid_t
name|uid
parameter_list|,
name|gid_t
name|gid
parameter_list|,
name|int
name|perms
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|devnm_p
name|dev_root
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* root of the backing tree */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mount
modifier|*
name|devfs_hidden_mount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|devfs_up_and_going
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Set up the root directory node in the backing plane  * This is happenning before the vfs system has been  * set up yet, so be careful about what we reference..  * Notice that the ops are by indirection.. as they haven't  * been set up yet!  * DEVFS has a hidden mountpoint that is used as the anchor point  * for the internal 'blueprint' version of the dev filesystem tree.  */
end_comment

begin_comment
comment|/*proto*/
end_comment

begin_function
name|void
name|devfs_sinit
parameter_list|(
name|void
modifier|*
name|junk
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
comment|/* we will discard this */
comment|/* 	 * call the right routine at the right time with the right args.... 	 */
name|retval
operator|=
name|dev_add_entry
argument_list|(
literal|"root"
argument_list|,
name|NULL
argument_list|,
name|DEV_DIR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|dev_root
argument_list|)
expr_stmt|;
name|devfs_create_hook
operator|=
name|devfs_add_to_tree
expr_stmt|;
ifdef|#
directive|ifdef
name|PARANOID
if|if
condition|(
name|retval
condition|)
name|panic
argument_list|(
literal|"devfs_sinit: dev_add_entry failed "
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|devfs_hidden_mount
operator|=
operator|(
expr|struct
name|mount
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mount
argument_list|)
argument_list|,
name|M_MOUNT
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PARANOID
if|if
condition|(
operator|!
name|devfs_hidden_mount
condition|)
name|panic
argument_list|(
literal|"devfs_sinit: malloc failed"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bzero
argument_list|(
name|devfs_hidden_mount
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mount
argument_list|)
argument_list|)
expr_stmt|;
name|devfs_mount
argument_list|(
name|devfs_hidden_mount
argument_list|,
literal|"dummy"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dev_root
operator|->
name|dnp
operator|->
name|dvm
operator|=
operator|(
expr|struct
name|devfsmount
operator|*
operator|)
name|devfs_hidden_mount
operator|->
name|mnt_data
expr_stmt|;
name|devfs_up_and_going
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"DEVFS: ready for devices\n"
argument_list|)
expr_stmt|;
comment|/* part 2 of this is done later */
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|devfs
argument_list|,
argument|SI_SUB_DEVFS
argument_list|,
argument|SI_ORDER_FIRST
argument_list|,
argument|devfs_sinit
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_escape
end_escape

begin_comment
comment|/***********************************************************************\ ************************************************************************* *	Routines used to find our way to a point in the tree		* ************************************************************************* \***********************************************************************/
end_comment

begin_comment
comment|/***************************************************************\ * Search down the linked list off a dir to find "name"		* * return the dn_p for that node. \***************************************************************/
end_comment

begin_comment
comment|/*proto*/
end_comment

begin_function
name|devnm_p
name|dev_findname
parameter_list|(
name|dn_p
name|dir
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|devnm_p
name|newfp
decl_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"	dev_findname(%s)\n"
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|->
name|type
operator|!=
name|DEV_DIR
condition|)
return|return
literal|0
return|;
comment|/*XXX*/
comment|/* printf?*/
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|0
condition|)
block|{
return|return
name|dir
operator|->
name|by
operator|.
name|Dir
operator|.
name|myname
return|;
block|}
if|if
condition|(
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'.'
operator|)
operator|&&
operator|(
name|name
index|[
literal|2
index|]
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* for root, .. == . */
return|return
name|dir
operator|->
name|by
operator|.
name|Dir
operator|.
name|parent
operator|->
name|by
operator|.
name|Dir
operator|.
name|myname
return|;
block|}
block|}
name|newfp
operator|=
name|dir
operator|->
name|by
operator|.
name|Dir
operator|.
name|dirlist
expr_stmt|;
while|while
condition|(
name|newfp
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|newfp
operator|->
name|name
argument_list|)
operator|)
condition|)
return|return
name|newfp
return|;
name|newfp
operator|=
name|newfp
operator|->
name|next
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/***********************************************************************\ * Given a starting node (0 for root) and a pathname, return the node	* * for the end item on the path. It MUST BE A DIRECTORY. If the 'CREATE'	* * option is true, then create any missing nodes in the path and create	* * and return the final node as well.					* * This is used to set up a directory, before making nodes in it..	* *									* * Warning: This function is RECURSIVE.					* *	char	*orig_path,	 find this dir (err if not dir)		* *	dn_p	dirnode,	 starting point  (0 = root)	 	* *	int	create,		 create path if not found 		* *	dn_p	*dn_pp)		 where to return the node of the dir	* \***********************************************************************/
end_comment

begin_comment
comment|/*proto*/
end_comment

begin_function
name|int
name|dev_finddir
parameter_list|(
name|char
modifier|*
name|orig_path
parameter_list|,
name|dn_p
name|dirnode
parameter_list|,
name|int
name|create
parameter_list|,
name|dn_p
modifier|*
name|dn_pp
parameter_list|)
block|{
name|devnm_p
name|devnmp
decl_stmt|;
name|dn_p
name|dnp
decl_stmt|;
name|char
name|pathbuf
index|[
name|DEVMAXPATHSIZE
index|]
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"dev_finddir\n"
operator|)
argument_list|)
expr_stmt|;
comment|/***************************************\ 	* If no parent directory is given	* 	* then start at the root of the tree	* 	\***************************************/
if|if
condition|(
operator|!
name|dirnode
condition|)
name|dirnode
operator|=
name|dev_root
operator|->
name|dnp
expr_stmt|;
comment|/***************************************\ 	* Sanity Checks				* 	\***************************************/
if|if
condition|(
name|dirnode
operator|->
name|type
operator|!=
name|DEV_DIR
condition|)
return|return
name|ENOTDIR
return|;
if|if
condition|(
name|strlen
argument_list|(
name|orig_path
argument_list|)
operator|>
operator|(
name|DEVMAXPATHSIZE
operator|-
literal|1
operator|)
condition|)
return|return
name|ENAMETOOLONG
return|;
name|path
operator|=
name|pathbuf
expr_stmt|;
name|strcpy
argument_list|(
name|path
argument_list|,
name|orig_path
argument_list|)
expr_stmt|;
comment|/***************************************\ 	* always absolute, skip leading / 	* 	*  get rid of / or // or /// etc.	* 	\***************************************/
while|while
condition|(
operator|*
name|path
operator|==
literal|'/'
condition|)
name|path
operator|++
expr_stmt|;
comment|/***************************************\ 	* If nothing left, then parent was it..	* 	\***************************************/
if|if
condition|(
operator|*
name|path
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|dn_pp
operator|=
name|dirnode
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/***************************************\ 	* find the next segment of the name	* 	\***************************************/
name|cp
operator|=
name|name
operator|=
name|path
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|cp
operator|!=
literal|'/'
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|!=
literal|0
operator|)
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
comment|/***********************************************\ 	* Check to see if it's the last component	* 	\***********************************************/
if|if
condition|(
operator|*
name|cp
condition|)
block|{
name|path
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
comment|/* path refers to the rest */
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
comment|/* name is now a separate string */
if|if
condition|(
operator|!
operator|(
operator|*
name|path
operator|)
condition|)
block|{
name|path
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* was trailing slash */
block|}
block|}
else|else
block|{
name|path
operator|=
name|NULL
expr_stmt|;
comment|/* no more to do */
block|}
comment|/***************************************\ 	* Start scanning along the linked list	* 	\***************************************/
name|devnmp
operator|=
name|dev_findname
argument_list|(
name|dirnode
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|devnmp
condition|)
block|{
comment|/* check it's a directory */
name|dnp
operator|=
name|devnmp
operator|->
name|dnp
expr_stmt|;
if|if
condition|(
name|dnp
operator|->
name|type
operator|!=
name|DEV_DIR
condition|)
return|return
name|ENOTDIR
return|;
block|}
else|else
block|{
comment|/***************************************\ 		* The required element does not exist	* 		* So we will add it if asked to.	* 		\***************************************/
if|if
condition|(
operator|!
name|create
condition|)
return|return
name|ENOENT
return|;
if|if
condition|(
operator|(
name|retval
operator|=
name|dev_add_entry
argument_list|(
name|name
argument_list|,
name|dirnode
argument_list|,
name|DEV_DIR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|devnmp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
name|retval
return|;
block|}
name|dnp
operator|=
name|devnmp
operator|->
name|dnp
expr_stmt|;
name|devfs_propogate
argument_list|(
name|dirnode
operator|->
name|by
operator|.
name|Dir
operator|.
name|myname
argument_list|,
name|devnmp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|path
operator|!=
name|NULL
condition|)
block|{
comment|/* decide whether to recurse more or return */
return|return
operator|(
name|dev_finddir
argument_list|(
name|path
argument_list|,
name|dnp
argument_list|,
name|create
argument_list|,
name|dn_pp
argument_list|)
operator|)
return|;
block|}
else|else
block|{
operator|*
name|dn_pp
operator|=
name|dnp
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/***********************************************************************\ * Add a new NAME element to the devfs					* * If we're creating a root node, then dirname is NULL			* * Basically this creates a new namespace entry for the device node	* *									* * Creates a name node, and links it to the supplied node		* \***********************************************************************/
end_comment

begin_comment
comment|/*proto*/
end_comment

begin_function
name|int
name|dev_add_name
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|dn_p
name|dirnode
parameter_list|,
name|devnm_p
name|back
parameter_list|,
name|dn_p
name|dnp
parameter_list|,
name|devnm_p
modifier|*
name|devnm_pp
parameter_list|)
block|{
name|devnm_p
name|devnmp
decl_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"dev_add_name\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirnode
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dirnode
operator|->
name|type
operator|!=
name|DEV_DIR
condition|)
return|return
operator|(
name|ENOTDIR
operator|)
return|;
if|if
condition|(
name|dev_findname
argument_list|(
name|dirnode
argument_list|,
name|name
argument_list|)
condition|)
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
comment|/* 	 * make sure the name is legal 	 * slightly misleading in the case of NULL 	 */
if|if
condition|(
operator|!
name|name
operator|||
operator|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|>
operator|(
name|DEVMAXNAMESIZE
operator|-
literal|1
operator|)
operator|)
condition|)
return|return
operator|(
name|ENAMETOOLONG
operator|)
return|;
comment|/* 	 * Allocate and fill out a new directory entry  	 */
if|if
condition|(
operator|!
operator|(
name|devnmp
operator|=
operator|(
name|devnm_p
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|devnm_t
argument_list|)
argument_list|,
name|M_DEVFSNAME
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
condition|)
block|{
return|return
name|ENOMEM
return|;
block|}
name|bzero
argument_list|(
name|devnmp
argument_list|,
sizeof|sizeof
argument_list|(
name|devnm_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* inherrit our parent's mount info */
comment|/*XXX*/
comment|/* a kludge but.... */
if|if
condition|(
name|dirnode
operator|&&
operator|(
name|dnp
operator|->
name|dvm
operator|==
name|NULL
operator|)
condition|)
block|{
name|dnp
operator|->
name|dvm
operator|=
name|dirnode
operator|->
name|dvm
expr_stmt|;
if|if
condition|(
operator|!
name|dnp
operator|->
name|dvm
condition|)
name|printf
argument_list|(
literal|"parent had null dvm "
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Link the two together 	 * include the implicit link in the count of links to the devnode.. 	 * this stops it from being accidentally freed later. 	 */
name|devnmp
operator|->
name|dnp
operator|=
name|dnp
expr_stmt|;
name|dnp
operator|->
name|links
operator|++
expr_stmt|;
comment|/* implicit from our own name-node */
comment|/*  	 * Make sure that we can find all the links that reference a node 	 * so that we can get them all if we need to zap the node. 	 */
if|if
condition|(
name|dnp
operator|->
name|linklist
condition|)
block|{
name|devnmp
operator|->
name|nextlink
operator|=
name|dnp
operator|->
name|linklist
expr_stmt|;
name|devnmp
operator|->
name|prevlinkp
operator|=
name|devnmp
operator|->
name|nextlink
operator|->
name|prevlinkp
expr_stmt|;
name|devnmp
operator|->
name|nextlink
operator|->
name|prevlinkp
operator|=
operator|&
operator|(
name|devnmp
operator|->
name|nextlink
operator|)
expr_stmt|;
operator|*
name|devnmp
operator|->
name|prevlinkp
operator|=
name|devnmp
expr_stmt|;
name|dnp
operator|->
name|linklist
operator|=
name|devnmp
expr_stmt|;
block|}
else|else
block|{
name|devnmp
operator|->
name|nextlink
operator|=
name|devnmp
expr_stmt|;
name|devnmp
operator|->
name|prevlinkp
operator|=
operator|&
operator|(
name|devnmp
operator|->
name|nextlink
operator|)
expr_stmt|;
name|dnp
operator|->
name|linklist
operator|=
name|devnmp
expr_stmt|;
block|}
comment|/* 	 * If the node is a directory, then we need to handle the  	 * creation of the .. link. 	 * A NULL dirnode indicates a root node, so point to ourself. 	 */
if|if
condition|(
name|dnp
operator|->
name|type
operator|==
name|DEV_DIR
condition|)
block|{
name|dnp
operator|->
name|by
operator|.
name|Dir
operator|.
name|myname
operator|=
name|devnmp
expr_stmt|;
comment|/* 		 * If we are unlinking from an old dir, decrement its links 		 * as we point our '..' elsewhere 		 * Note: it's up to the calling code to remove the  		 * us from the original directory's list 		 */
if|if
condition|(
name|dnp
operator|->
name|by
operator|.
name|Dir
operator|.
name|parent
condition|)
block|{
name|dnp
operator|->
name|by
operator|.
name|Dir
operator|.
name|parent
operator|->
name|links
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|dirnode
condition|)
block|{
name|dnp
operator|->
name|by
operator|.
name|Dir
operator|.
name|parent
operator|=
name|dirnode
expr_stmt|;
block|}
else|else
block|{
name|dnp
operator|->
name|by
operator|.
name|Dir
operator|.
name|parent
operator|=
name|dnp
expr_stmt|;
block|}
name|dnp
operator|->
name|by
operator|.
name|Dir
operator|.
name|parent
operator|->
name|links
operator|++
expr_stmt|;
comment|/* account for the new '..' */
block|}
comment|/* 	 * put the name into the directory entry. 	 */
name|strcpy
argument_list|(
name|devnmp
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* 	 * Check if we are not making a root node.. 	 * (i.e. have parent) 	 */
if|if
condition|(
name|dirnode
condition|)
block|{
comment|/* 	 	 * Put it on the END of the linked list of directory entries 	 	 */
name|devnmp
operator|->
name|parent
operator|=
name|dirnode
expr_stmt|;
comment|/* null for root */
name|devnmp
operator|->
name|prevp
operator|=
name|dirnode
operator|->
name|by
operator|.
name|Dir
operator|.
name|dirlast
expr_stmt|;
name|devnmp
operator|->
name|next
operator|=
operator|*
operator|(
name|devnmp
operator|->
name|prevp
operator|)
expr_stmt|;
comment|/* should be NULL */
comment|/*right?*/
operator|*
operator|(
name|devnmp
operator|->
name|prevp
operator|)
operator|=
name|devnmp
expr_stmt|;
name|dirnode
operator|->
name|by
operator|.
name|Dir
operator|.
name|dirlast
operator|=
operator|&
operator|(
name|devnmp
operator|->
name|next
operator|)
expr_stmt|;
name|dirnode
operator|->
name|by
operator|.
name|Dir
operator|.
name|entrycount
operator|++
expr_stmt|;
name|dirnode
operator|->
name|len
operator|+=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|8
expr_stmt|;
comment|/*ok, ok?*/
block|}
operator|*
name|devnm_pp
operator|=
name|devnmp
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/***********************************************************************\ * Add a new element to the devfs plane. 				* *									* * Creates a new dev_node to go with it if the prototype should not be	* * reused. (Is a DIR, or we select SPLIT_DEVS at compile time)		* * 'by' gives us info to make our node if we don't have a prototype.	* * If 'by is null and proto exists, then the 'by' field of		* * the proto is used intead in the CREATE case.				* * note the 'links' count is 0 (except if a dir)				* * but it is only cleared on a transition				* * so this is ok till we link it to something				* * Even in SPLIT_DEVS mode,						* * if the node already exists on the wanted plane, just return it	* \***********************************************************************/
end_comment

begin_comment
comment|/*proto*/
end_comment

begin_function
name|int
name|dev_add_node
parameter_list|(
name|int
name|entrytype
parameter_list|,
name|union
name|typeinfo
modifier|*
name|by
parameter_list|,
name|dn_p
name|proto
parameter_list|,
name|dn_p
modifier|*
name|dn_pp
parameter_list|,
name|struct
name|devfsmount
modifier|*
name|dvm
parameter_list|)
block|{
name|dn_p
name|dnp
decl_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"dev_add_node\n"
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|SPLIT_DEVS
comment|/* 	 * If we have a prototype, then check if there is already a sibling 	 * on the mount plane we are looking at, if so, just return it. 	 */
if|if
condition|(
name|proto
condition|)
block|{
name|dnp
operator|=
name|proto
operator|->
name|nextsibling
expr_stmt|;
while|while
condition|(
name|dnp
operator|!=
name|proto
condition|)
block|{
if|if
condition|(
name|dnp
operator|->
name|dvm
operator|==
name|dvm
condition|)
block|{
operator|*
name|dn_pp
operator|=
name|dnp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|dnp
operator|=
name|dnp
operator|->
name|nextsibling
expr_stmt|;
block|}
if|if
condition|(
name|by
operator|==
name|NULL
condition|)
name|by
operator|=
operator|&
operator|(
name|proto
operator|->
name|by
operator|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* SPLIT_DEVS */
if|if
condition|(
name|proto
condition|)
block|{
switch|switch
condition|(
name|proto
operator|->
name|type
condition|)
block|{
case|case
name|DEV_BDEV
case|:
case|case
name|DEV_CDEV
case|:
case|case
name|DEV_DDEV
case|:
operator|*
name|dn_pp
operator|=
name|proto
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
endif|#
directive|endif
comment|/* SPLIT_DEVS */
if|if
condition|(
operator|!
operator|(
name|dnp
operator|=
operator|(
name|dn_p
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|devnode_t
argument_list|)
argument_list|,
name|M_DEVFSNODE
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
condition|)
block|{
return|return
name|ENOMEM
return|;
block|}
comment|/* 	 * If we have a proto, that means that we are duplicating some 	 * other device, which can only happen if we are not at the back plane 	 */
if|if
condition|(
name|proto
condition|)
block|{
name|bcopy
argument_list|(
name|proto
argument_list|,
name|dnp
argument_list|,
sizeof|sizeof
argument_list|(
name|devnode_t
argument_list|)
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|links
operator|=
literal|0
expr_stmt|;
name|dnp
operator|->
name|linklist
operator|=
name|NULL
expr_stmt|;
name|dnp
operator|->
name|vn
operator|=
name|NULL
expr_stmt|;
name|dnp
operator|->
name|len
operator|=
literal|0
expr_stmt|;
comment|/* add to END of siblings list */
name|dnp
operator|->
name|prevsiblingp
operator|=
name|proto
operator|->
name|prevsiblingp
expr_stmt|;
operator|*
operator|(
name|dnp
operator|->
name|prevsiblingp
operator|)
operator|=
name|dnp
expr_stmt|;
name|dnp
operator|->
name|nextsibling
operator|=
name|proto
expr_stmt|;
name|proto
operator|->
name|prevsiblingp
operator|=
operator|&
operator|(
name|dnp
operator|->
name|nextsibling
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/*  		 * We have no prototype, so start off with a clean slate 		 */
name|bzero
argument_list|(
name|dnp
argument_list|,
sizeof|sizeof
argument_list|(
name|devnode_t
argument_list|)
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|type
operator|=
name|entrytype
expr_stmt|;
name|getnanotime
argument_list|(
operator|&
operator|(
name|dnp
operator|->
name|ctime
operator|)
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|mtime
operator|=
name|dnp
operator|->
name|ctime
expr_stmt|;
name|dnp
operator|->
name|atime
operator|=
name|dnp
operator|->
name|ctime
expr_stmt|;
name|dnp
operator|->
name|nextsibling
operator|=
name|dnp
expr_stmt|;
name|dnp
operator|->
name|prevsiblingp
operator|=
operator|&
operator|(
name|dnp
operator|->
name|nextsibling
operator|)
expr_stmt|;
block|}
name|dnp
operator|->
name|dvm
operator|=
name|dvm
expr_stmt|;
comment|/* 	 * fill out the dev node according to type 	 */
switch|switch
condition|(
name|entrytype
condition|)
block|{
case|case
name|DEV_DIR
case|:
comment|/* 		 * As it's a directory, make sure 		 * it has a null entries list 		 */
name|dnp
operator|->
name|by
operator|.
name|Dir
operator|.
name|dirlast
operator|=
operator|&
operator|(
name|dnp
operator|->
name|by
operator|.
name|Dir
operator|.
name|dirlist
operator|)
expr_stmt|;
name|dnp
operator|->
name|by
operator|.
name|Dir
operator|.
name|dirlist
operator|=
operator|(
name|devnm_p
operator|)
literal|0
expr_stmt|;
name|dnp
operator|->
name|by
operator|.
name|Dir
operator|.
name|entrycount
operator|=
literal|0
expr_stmt|;
comment|/*  until we know better, it has a null parent pointer*/
name|dnp
operator|->
name|by
operator|.
name|Dir
operator|.
name|parent
operator|=
name|NULL
expr_stmt|;
name|dnp
operator|->
name|links
operator|++
expr_stmt|;
comment|/* for .*/
name|dnp
operator|->
name|by
operator|.
name|Dir
operator|.
name|myname
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * make sure that the ops associated with it are the ops 		 * that we use (by default) for directories 		 */
name|dnp
operator|->
name|ops
operator|=
operator|&
name|devfs_vnodeop_p
expr_stmt|;
name|dnp
operator|->
name|mode
operator||=
literal|0555
expr_stmt|;
comment|/* default perms */
break|break;
case|case
name|DEV_SLNK
case|:
comment|/* 		 * As it's a symlink allocate and store the link info 		 * Symlinks should only ever be created by the user, 		 * so they are not on the back plane and should not be  		 * propogated forward.. a bit like directories in that way.. 		 * A symlink only exists on one plane and has its own 		 * node.. therefore we might be on any random plane. 		 */
name|dnp
operator|->
name|by
operator|.
name|Slnk
operator|.
name|name
operator|=
name|malloc
argument_list|(
name|by
operator|->
name|Slnk
operator|.
name|namelen
operator|+
literal|1
argument_list|,
name|M_DEVFSNODE
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dnp
operator|->
name|by
operator|.
name|Slnk
operator|.
name|name
condition|)
block|{
name|free
argument_list|(
name|dnp
argument_list|,
name|M_DEVFSNODE
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|strncpy
argument_list|(
name|dnp
operator|->
name|by
operator|.
name|Slnk
operator|.
name|name
argument_list|,
name|by
operator|->
name|Slnk
operator|.
name|name
argument_list|,
name|by
operator|->
name|Slnk
operator|.
name|namelen
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|by
operator|.
name|Slnk
operator|.
name|namelen
operator|=
name|by
operator|->
name|Slnk
operator|.
name|namelen
expr_stmt|;
name|dnp
operator|->
name|ops
operator|=
operator|&
name|devfs_vnodeop_p
expr_stmt|;
name|dnp
operator|->
name|mode
operator||=
literal|0555
expr_stmt|;
comment|/* default perms */
break|break;
case|case
name|DEV_BDEV
case|:
comment|/* 		 * Make sure it has DEVICE type ops 		 * and device specific fields are correct 		 */
name|dnp
operator|->
name|ops
operator|=
operator|&
name|devfs_spec_vnodeop_p
expr_stmt|;
name|dnp
operator|->
name|by
operator|.
name|dev
operator|.
name|dev
operator|=
name|by
operator|->
name|dev
operator|.
name|dev
expr_stmt|;
break|break;
case|case
name|DEV_CDEV
case|:
comment|/* 		 * Make sure it has DEVICE type ops 		 * and device specific fields are correct 		 */
name|dnp
operator|->
name|ops
operator|=
operator|&
name|devfs_spec_vnodeop_p
expr_stmt|;
name|dnp
operator|->
name|by
operator|.
name|dev
operator|.
name|dev
operator|=
name|by
operator|->
name|dev
operator|.
name|dev
expr_stmt|;
break|break;
case|case
name|DEV_DDEV
case|:
comment|/* 		 * store the address of (the address of) the ops 		 * and the magic cookie to use with them 		 */
name|dnp
operator|->
name|by
operator|.
name|Ddev
operator|.
name|arg
operator|=
name|by
operator|->
name|Ddev
operator|.
name|arg
expr_stmt|;
name|dnp
operator|->
name|by
operator|.
name|Ddev
operator|.
name|ops
operator|=
name|by
operator|->
name|Ddev
operator|.
name|ops
expr_stmt|;
name|dnp
operator|->
name|ops
operator|=
name|by
operator|->
name|Ddev
operator|.
name|ops
expr_stmt|;
break|break;
default|default:
return|return
name|EINVAL
return|;
block|}
operator|*
name|dn_pp
operator|=
name|dnp
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*proto*/
end_comment

begin_function
name|int
name|dev_touch
parameter_list|(
name|devnm_p
name|key
parameter_list|)
comment|/* update the node for this dev */
block|{
name|DBPRINT
argument_list|(
operator|(
literal|"dev_touch\n"
operator|)
argument_list|)
expr_stmt|;
name|getnanotime
argument_list|(
operator|&
operator|(
name|key
operator|->
name|dnp
operator|->
name|mtime
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/*XXX*/
block|}
end_function

begin_comment
comment|/*proto*/
end_comment

begin_function
name|void
name|devfs_dn_free
parameter_list|(
name|dn_p
name|dnp
parameter_list|)
block|{
if|if
condition|(
operator|--
name|dnp
operator|->
name|links
operator|<=
literal|0
condition|)
comment|/* can be -1 for initial free, on error */
block|{
comment|/*probably need to do other cleanups XXX */
if|if
condition|(
name|dnp
operator|->
name|nextsibling
operator|!=
name|dnp
condition|)
block|{
name|dn_p
modifier|*
name|prevp
init|=
name|dnp
operator|->
name|prevsiblingp
decl_stmt|;
operator|*
name|prevp
operator|=
name|dnp
operator|->
name|nextsibling
expr_stmt|;
name|dnp
operator|->
name|nextsibling
operator|->
name|prevsiblingp
operator|=
name|prevp
expr_stmt|;
block|}
if|if
condition|(
name|dnp
operator|->
name|type
operator|==
name|DEV_SLNK
condition|)
block|{
name|free
argument_list|(
name|dnp
operator|->
name|by
operator|.
name|Slnk
operator|.
name|name
argument_list|,
name|M_DEVFSNODE
argument_list|)
expr_stmt|;
block|}
name|devfs_dropvnode
argument_list|(
name|dnp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dnp
argument_list|,
name|M_DEVFSNODE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/***********************************************************************\ *	Front Node Operations						*  *	Add or delete a chain of front nodes				* \***********************************************************************/
end_comment

begin_comment
comment|/***********************************************************************\ * Given a directory backing node, and a child backing node, add the	* * appropriate front nodes to the front nodes of the directory to	* * represent the child node to the user					* *									* * on failure, front nodes will either be correct or not exist for each	* * front dir, however dirs completed will not be stripped of completed	* * frontnodes on failure of a later frontnode				* *									* * This allows a new node to be propogated through all mounted planes	* *									* \***********************************************************************/
end_comment

begin_comment
comment|/*proto*/
end_comment

begin_function
name|int
name|devfs_propogate
parameter_list|(
name|devnm_p
name|parent
parameter_list|,
name|devnm_p
name|child
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|devnm_p
name|newnmp
decl_stmt|;
name|dn_p
name|dnp
init|=
name|child
operator|->
name|dnp
decl_stmt|;
name|dn_p
name|pdnp
init|=
name|parent
operator|->
name|dnp
decl_stmt|;
name|dn_p
name|adnp
init|=
name|parent
operator|->
name|dnp
decl_stmt|;
name|int
name|type
init|=
name|child
operator|->
name|dnp
operator|->
name|type
decl_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"	devfs_propogate\n"
operator|)
argument_list|)
expr_stmt|;
comment|/***********************************************\ 	* Find the other instances of the parent node	* 	\***********************************************/
for|for
control|(
name|adnp
operator|=
name|pdnp
operator|->
name|nextsibling
init|;
name|adnp
operator|!=
name|pdnp
condition|;
name|adnp
operator|=
name|adnp
operator|->
name|nextsibling
control|)
block|{
comment|/* 		 * Make the node, using the original as a prototype) 		 * if the node already exists on that plane it won't be 		 * re-made.. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|dev_add_entry
argument_list|(
name|child
operator|->
name|name
argument_list|,
name|adnp
argument_list|,
name|type
argument_list|,
name|NULL
argument_list|,
name|dnp
argument_list|,
name|adnp
operator|->
name|dvm
argument_list|,
operator|&
name|newnmp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"duplicating %s failed\n"
argument_list|,
name|child
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
comment|/* for now always succeed */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/***********************************************************************  * remove all instances of this devicename [for backing nodes..]  * note.. if there is another link to the node (non dir nodes only)  * then the devfs_node will still exist as the ref count will be non-0  * removing a directory node will remove all sup-nodes on all planes (ZAP)  *  * Used by device drivers to remove nodes that are no longer relevant  * The argument is the 'cookie' they were given when they created the node  * this function is exported.. see sys/devfsext.h  ***********************************************************************/
end_comment

begin_function
name|void
name|devfs_remove_dev
parameter_list|(
name|void
modifier|*
name|devnmp
parameter_list|)
block|{
name|dn_p
name|dnp
init|=
operator|(
operator|(
name|devnm_p
operator|)
name|devnmp
operator|)
operator|->
name|dnp
decl_stmt|;
name|dn_p
name|dnp2
decl_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"devfs_remove_dev\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* keep removing the next sibling till only we exist. */
while|while
condition|(
operator|(
name|dnp2
operator|=
name|dnp
operator|->
name|nextsibling
operator|)
operator|!=
name|dnp
condition|)
block|{
comment|/* 		 * Keep removing the next front node till no more exist 		 */
name|dnp
operator|->
name|nextsibling
operator|=
name|dnp2
operator|->
name|nextsibling
expr_stmt|;
name|dnp
operator|->
name|nextsibling
operator|->
name|prevsiblingp
operator|=
operator|&
operator|(
name|dnp
operator|->
name|nextsibling
operator|)
expr_stmt|;
name|dnp2
operator|->
name|nextsibling
operator|=
name|dnp2
expr_stmt|;
name|dnp2
operator|->
name|prevsiblingp
operator|=
operator|&
operator|(
name|dnp2
operator|->
name|nextsibling
operator|)
expr_stmt|;
while|while
condition|(
name|dnp2
operator|->
name|linklist
condition|)
block|{
name|dev_free_name
argument_list|(
name|dnp2
operator|->
name|linklist
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * then free the main node 	 * If we are not running in SPLIT_DEVS mode, then 	 * THIS is what gets rid of the propogated nodes. 	 */
while|while
condition|(
name|dnp
operator|->
name|linklist
condition|)
block|{
name|dev_free_name
argument_list|(
name|dnp
operator|->
name|linklist
argument_list|)
expr_stmt|;
block|}
return|return ;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/***************************************************************  * duplicate the backing tree into a tree of nodes hung off the  * mount point given as the argument. Do this by  * calling dev_dup_entry which recurses all the way  * up the tree..  * If we are the first plane, just return the base root   **************************************************************/
end_comment

begin_comment
comment|/*proto*/
end_comment

begin_function
name|int
name|dev_dup_plane
parameter_list|(
name|struct
name|devfsmount
modifier|*
name|devfs_mp_p
parameter_list|)
block|{
name|devnm_p
name|new
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"	dev_dup_plane\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|devfs_up_and_going
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|dev_dup_entry
argument_list|(
name|NULL
argument_list|,
name|dev_root
argument_list|,
operator|&
name|new
argument_list|,
name|devfs_mp_p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
else|else
block|{
comment|/* we are doing the dummy mount during initialisation.. */
name|new
operator|=
name|dev_root
expr_stmt|;
block|}
name|devfs_mp_p
operator|->
name|plane_root
operator|=
name|new
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/***************************************************************\ * Free a whole plane \***************************************************************/
end_comment

begin_comment
comment|/*proto*/
end_comment

begin_function
name|void
name|devfs_free_plane
parameter_list|(
name|struct
name|devfsmount
modifier|*
name|devfs_mp_p
parameter_list|)
block|{
name|devnm_p
name|devnmp
decl_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"	devfs_free_plane\n"
operator|)
argument_list|)
expr_stmt|;
name|devnmp
operator|=
name|devfs_mp_p
operator|->
name|plane_root
expr_stmt|;
if|if
condition|(
name|devnmp
condition|)
block|{
name|dev_free_hier
argument_list|(
name|devnmp
argument_list|)
expr_stmt|;
name|dev_free_name
argument_list|(
name|devnmp
argument_list|)
expr_stmt|;
block|}
name|devfs_mp_p
operator|->
name|plane_root
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/***************************************************************\ * Create and link in a new front element.. 			* * Parent can be 0 for a root node				* * Not presently usable to make a symlink XXX			* * (Ok, symlinks don't propogate) * recursively will create subnodes corresponding to equivalent	* * child nodes in the base level					* \***************************************************************/
end_comment

begin_comment
comment|/*proto*/
end_comment

begin_function
name|int
name|dev_dup_entry
parameter_list|(
name|dn_p
name|parent
parameter_list|,
name|devnm_p
name|back
parameter_list|,
name|devnm_p
modifier|*
name|dnm_pp
parameter_list|,
name|struct
name|devfsmount
modifier|*
name|dvm
parameter_list|)
block|{
name|devnm_p
name|newnmp
decl_stmt|;
name|devnm_p
name|newback
decl_stmt|;
name|devnm_p
name|newfront
decl_stmt|;
name|int
name|error
decl_stmt|;
name|dn_p
name|dnp
init|=
name|back
operator|->
name|dnp
decl_stmt|;
name|int
name|type
init|=
name|dnp
operator|->
name|type
decl_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"	dev_dup_entry\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * go get the node made (if we need to) 	 * use the back one as a prototype 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|dev_add_entry
argument_list|(
name|back
operator|->
name|name
argument_list|,
name|parent
argument_list|,
name|type
argument_list|,
name|NULL
argument_list|,
name|dnp
argument_list|,
name|parent
condition|?
name|parent
operator|->
name|dvm
else|:
name|dvm
argument_list|,
operator|&
name|newnmp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"duplicating %s failed\n"
argument_list|,
name|back
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we have just made the root, then insert the pointer to the 	 * mount information 	 */
if|if
condition|(
name|dvm
condition|)
block|{
name|newnmp
operator|->
name|dnp
operator|->
name|dvm
operator|=
name|dvm
expr_stmt|;
block|}
comment|/* 	 * If it is a directory, then recurse down all the other 	 * subnodes in it.... 	 * note that this time we don't pass on the mount info.. 	 */
if|if
condition|(
name|type
operator|==
name|DEV_DIR
condition|)
block|{
for|for
control|(
name|newback
operator|=
name|back
operator|->
name|dnp
operator|->
name|by
operator|.
name|Dir
operator|.
name|dirlist
init|;
name|newback
condition|;
name|newback
operator|=
name|newback
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|dev_dup_entry
argument_list|(
name|newnmp
operator|->
name|dnp
argument_list|,
name|newback
argument_list|,
operator|&
name|newfront
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
break|break;
comment|/* back out with an error */
block|}
block|}
block|}
operator|*
name|dnm_pp
operator|=
name|newnmp
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/***************************************************************\ * Free a name node						* * remember that if there are other names pointing to the	* * dev_node then it may not get freed yet			* * can handle if there is no dnp 				* \***************************************************************/
end_comment

begin_comment
comment|/*proto*/
end_comment

begin_function
name|int
name|dev_free_name
parameter_list|(
name|devnm_p
name|devnmp
parameter_list|)
block|{
name|dn_p
name|parent
init|=
name|devnmp
operator|->
name|parent
decl_stmt|;
name|dn_p
name|dnp
init|=
name|devnmp
operator|->
name|dnp
decl_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"	dev_free_name\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnp
condition|)
block|{
if|if
condition|(
name|dnp
operator|->
name|type
operator|==
name|DEV_DIR
condition|)
block|{
if|if
condition|(
name|dnp
operator|->
name|by
operator|.
name|Dir
operator|.
name|dirlist
condition|)
return|return
operator|(
name|ENOTEMPTY
operator|)
return|;
name|devfs_dn_free
argument_list|(
name|dnp
argument_list|)
expr_stmt|;
comment|/* account for '.' */
name|devfs_dn_free
argument_list|(
name|dnp
operator|->
name|by
operator|.
name|Dir
operator|.
name|parent
argument_list|)
expr_stmt|;
comment|/* '..' */
block|}
comment|/* 		 * unlink us from the list of links for this node 		 * If we are the only link, it's easy! 		 * if we are a DIR of course there should not be any 		 * other links. 	 	 */
if|if
condition|(
name|devnmp
operator|->
name|nextlink
operator|==
name|devnmp
condition|)
block|{
name|dnp
operator|->
name|linklist
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dnp
operator|->
name|linklist
operator|==
name|devnmp
condition|)
block|{
name|dnp
operator|->
name|linklist
operator|=
name|devnmp
operator|->
name|nextlink
expr_stmt|;
block|}
name|devnmp
operator|->
name|nextlink
operator|->
name|prevlinkp
operator|=
name|devnmp
operator|->
name|prevlinkp
expr_stmt|;
operator|*
name|devnmp
operator|->
name|prevlinkp
operator|=
name|devnmp
operator|->
name|nextlink
expr_stmt|;
block|}
name|devfs_dn_free
argument_list|(
name|dnp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * unlink ourselves from the directory on this plane 	 */
if|if
condition|(
name|parent
condition|)
comment|/* if not fs root */
block|{
if|if
condition|(
operator|(
operator|*
name|devnmp
operator|->
name|prevp
operator|=
name|devnmp
operator|->
name|next
operator|)
condition|)
comment|/* yes, assign */
block|{
name|devnmp
operator|->
name|next
operator|->
name|prevp
operator|=
name|devnmp
operator|->
name|prevp
expr_stmt|;
block|}
else|else
block|{
name|parent
operator|->
name|by
operator|.
name|Dir
operator|.
name|dirlast
operator|=
name|devnmp
operator|->
name|prevp
expr_stmt|;
block|}
name|parent
operator|->
name|by
operator|.
name|Dir
operator|.
name|entrycount
operator|--
expr_stmt|;
name|parent
operator|->
name|len
operator|-=
name|strlen
argument_list|(
name|devnmp
operator|->
name|name
argument_list|)
operator|+
literal|8
expr_stmt|;
block|}
comment|/***************************************************************\ 	* If the front node has its own devnode structure,		* 	* then free it.							* 	\***************************************************************/
name|free
argument_list|(
name|devnmp
argument_list|,
name|M_DEVFSNAME
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/***************************************************************\ * Free a hierarchy starting at a directory node name 			* * remember that if there are other names pointing to the	* * dev_node then it may not get freed yet			* * can handle if there is no dnp 				* * leave the node itself allocated.				* \***************************************************************/
end_comment

begin_comment
comment|/*proto*/
end_comment

begin_function
name|void
name|dev_free_hier
parameter_list|(
name|devnm_p
name|devnmp
parameter_list|)
block|{
name|dn_p
name|dnp
init|=
name|devnmp
operator|->
name|dnp
decl_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"	dev_free_hier\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnp
condition|)
block|{
if|if
condition|(
name|dnp
operator|->
name|type
operator|==
name|DEV_DIR
condition|)
block|{
while|while
condition|(
name|dnp
operator|->
name|by
operator|.
name|Dir
operator|.
name|dirlist
condition|)
block|{
name|dev_free_hier
argument_list|(
name|dnp
operator|->
name|by
operator|.
name|Dir
operator|.
name|dirlist
argument_list|)
expr_stmt|;
name|dev_free_name
argument_list|(
name|dnp
operator|->
name|by
operator|.
name|Dir
operator|.
name|dirlist
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*******************************************************\ ********************************************************* * ROUTINES to control the connection between devfs	* * nodes and the system's vnodes				* ********************************************************* \*******************************************************/
end_comment

begin_comment
comment|/*******************************************************\ * Theoretically this could be called for any kind of 	* * vnode, however in practice it must be a DEVFS vnode	* \*******************************************************/
end_comment

begin_comment
comment|/*proto*/
end_comment

begin_function
name|int
name|devfs_vntodn
parameter_list|(
name|struct
name|vnode
modifier|*
name|vn_p
parameter_list|,
name|dn_p
modifier|*
name|dn_pp
parameter_list|)
block|{
name|DBPRINT
argument_list|(
operator|(
literal|"	vntodn "
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vn_p
operator|->
name|v_tag
operator|!=
name|VT_DEVFS
condition|)
block|{
name|printf
argument_list|(
literal|"bad-tag2 "
argument_list|)
expr_stmt|;
name|Debugger
argument_list|(
literal|"bad-tag "
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|#
directive|if
literal|0
comment|/* 	 * XXX: This is actually a "normal" case when vclean calls us without 	 * XXX: incrementing the reference count first. 	 */
block|if(vn_p->v_usecount == 0) 	{ 		printf("No references! "); 	}
endif|#
directive|endif
switch|switch
condition|(
name|vn_p
operator|->
name|v_type
condition|)
block|{
case|case
name|VBAD
case|:
name|printf
argument_list|(
literal|"bad-type2 (VBAD)"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
if|#
directive|if
literal|0
block|case VNON: 		printf("bad-type2 (VNON)"); 		return(EINVAL);
endif|#
directive|endif
default|default:
break|break;
block|}
operator|*
name|dn_pp
operator|=
operator|(
name|dn_p
operator|)
name|vn_p
operator|->
name|v_data
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/***************************************************************\ * given a dev_node, find the appropriate vnode if one is already* * associated, or get a new one an associate it with the dev_node* * need to check about vnode references.. should we increment it?* \***************************************************************/
end_comment

begin_comment
comment|/*proto*/
end_comment

begin_function
name|int
name|devfs_dntovn
parameter_list|(
name|dn_p
name|dnp
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vn_pp
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vn_p
decl_stmt|,
modifier|*
name|nvp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
comment|/* XXX */
name|vn_p
operator|=
name|dnp
operator|->
name|vn
expr_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"dntovn "
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vn_p
condition|)
block|{
if|if
condition|(
name|vn_p
operator|->
name|v_id
operator|!=
name|dnp
operator|->
name|vn_id
condition|)
block|{
if|#
directive|if
literal|0
comment|/* XXX: This is `normal'... */
block|printf("bad-id ");
endif|#
directive|endif
goto|goto
name|skip
goto|;
block|}
if|if
condition|(
name|vn_p
operator|->
name|v_tag
operator|!=
name|VT_DEVFS
condition|)
block|{
if|#
directive|if
literal|0
comment|/* XXX: This is `normal'... */
block|printf("bad-tag ");
endif|#
directive|endif
goto|goto
name|skip
goto|;
block|}
if|if
condition|(
name|vn_p
operator|->
name|v_op
operator|!=
operator|*
operator|(
name|dnp
operator|->
name|ops
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"bad-ops "
argument_list|)
expr_stmt|;
goto|goto
name|skip
goto|;
block|}
if|if
condition|(
call|(
name|dn_p
call|)
argument_list|(
name|vn_p
operator|->
name|v_data
argument_list|)
operator|!=
name|dnp
condition|)
block|{
name|printf
argument_list|(
literal|"bad-rev_link "
argument_list|)
expr_stmt|;
goto|goto
name|skip
goto|;
block|}
if|if
condition|(
name|vn_p
operator|->
name|v_type
operator|!=
name|VNON
condition|)
block|{
name|vget
argument_list|(
name|vn_p
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|p
argument_list|)
expr_stmt|;
operator|*
name|vn_pp
operator|=
name|vn_p
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"bad-type"
argument_list|)
expr_stmt|;
block|}
name|skip
label|:
name|vn_p
operator|=
operator|(
expr|struct
name|vnode
operator|*
operator|)
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|error
operator|=
name|getnewvnode
argument_list|(
name|VT_DEVFS
argument_list|,
name|dnp
operator|->
name|dvm
operator|->
name|mount
argument_list|,
operator|*
operator|(
name|dnp
operator|->
name|ops
operator|)
argument_list|,
operator|&
name|vn_p
argument_list|)
operator|)
condition|)
block|{
name|dnp
operator|->
name|vn
operator|=
name|vn_p
expr_stmt|;
name|dnp
operator|->
name|vn_id
operator|=
name|vn_p
operator|->
name|v_id
expr_stmt|;
operator|*
name|vn_pp
operator|=
name|vn_p
expr_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"(New vnode)"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dnp
operator|->
name|type
condition|)
block|{
case|case
name|DEV_SLNK
case|:
name|vn_p
operator|->
name|v_type
operator|=
name|VLNK
expr_stmt|;
break|break;
case|case
name|DEV_DIR
case|:
if|if
condition|(
name|dnp
operator|->
name|by
operator|.
name|Dir
operator|.
name|parent
operator|==
name|dnp
condition|)
block|{
name|vn_p
operator|->
name|v_flag
operator||=
name|VROOT
expr_stmt|;
block|}
name|vn_p
operator|->
name|v_type
operator|=
name|VDIR
expr_stmt|;
break|break;
case|case
name|DEV_BDEV
case|:
name|vn_p
operator|->
name|v_type
operator|=
name|VBLK
expr_stmt|;
if|if
condition|(
operator|(
name|nvp
operator|=
name|checkalias2
argument_list|(
name|vn_p
argument_list|,
name|dnp
operator|->
name|by
operator|.
name|dev
operator|.
name|dev
argument_list|,
operator|(
expr|struct
name|mount
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|vput
argument_list|(
name|vn_p
argument_list|)
expr_stmt|;
name|vn_p
operator|=
name|nvp
expr_stmt|;
block|}
break|break;
case|case
name|DEV_CDEV
case|:
name|vn_p
operator|->
name|v_type
operator|=
name|VCHR
expr_stmt|;
if|if
condition|(
operator|(
name|nvp
operator|=
name|checkalias2
argument_list|(
name|vn_p
argument_list|,
name|dnp
operator|->
name|by
operator|.
name|dev
operator|.
name|dev
argument_list|,
operator|(
expr|struct
name|mount
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|vput
argument_list|(
name|vn_p
argument_list|)
expr_stmt|;
name|vn_p
operator|=
name|nvp
expr_stmt|;
block|}
break|break;
case|case
name|DEV_DDEV
case|:
break|break;
block|}
if|if
condition|(
name|vn_p
condition|)
block|{
name|vn_p
operator|->
name|v_mount
operator|=
name|dnp
operator|->
name|dvm
operator|->
name|mount
expr_stmt|;
comment|/* XXX Duplicated */
operator|*
name|vn_pp
operator|=
name|vn_p
expr_stmt|;
name|vn_p
operator|->
name|v_data
operator|=
operator|(
name|void
operator|*
operator|)
name|dnp
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|vn_lock
argument_list|(
name|vn_p
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/***********************************************************************\ * add a whole device, with no prototype.. make name element and node	* * Used for adding the original device entries 				* \***********************************************************************/
end_comment

begin_comment
comment|/*proto*/
end_comment

begin_function
name|int
name|dev_add_entry
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|dn_p
name|parent
parameter_list|,
name|int
name|type
parameter_list|,
name|union
name|typeinfo
modifier|*
name|by
parameter_list|,
name|dn_p
name|proto
parameter_list|,
name|struct
name|devfsmount
modifier|*
name|dvm
parameter_list|,
name|devnm_p
modifier|*
name|nm_pp
parameter_list|)
block|{
name|dn_p
name|dnp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"	devfs_add_entry\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|dev_add_node
argument_list|(
name|type
argument_list|,
name|by
argument_list|,
name|proto
argument_list|,
operator|&
name|dnp
argument_list|,
operator|(
name|parent
condition|?
name|parent
operator|->
name|dvm
else|:
name|dvm
operator|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Device %s: base node allocation failed (Errno=%d)\n"
argument_list|,
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|dev_add_name
argument_list|(
name|name
argument_list|,
name|parent
argument_list|,
name|NULL
argument_list|,
name|dnp
argument_list|,
name|nm_pp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|devfs_dn_free
argument_list|(
name|dnp
argument_list|)
expr_stmt|;
comment|/* 1->0 for dir, 0->(-1) for other */
name|printf
argument_list|(
literal|"Device %s: name slot allocation failed (Errno=%d)\n"
argument_list|,
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|devfs_add_to_tree
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|uid_t
name|uid
parameter_list|,
name|gid_t
name|gid
parameter_list|,
name|int
name|perms
parameter_list|)
block|{
name|struct
name|cdevsw
modifier|*
name|devsw
init|=
name|dev
operator|->
name|si_devsw
decl_stmt|;
name|dev
operator|->
name|si_devfs
operator|=
name|devfs_add_devswf
argument_list|(
name|dev
operator|->
name|si_devsw
argument_list|,
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|,
name|DV_CHR
argument_list|,
name|uid
argument_list|,
name|gid
argument_list|,
name|perms
argument_list|,
literal|"%s"
argument_list|,
name|dev
operator|->
name|si_name
argument_list|)
expr_stmt|;
comment|/* XXX HACK .. name may not start in 'r' */
comment|/* Also Hack.. no place to store Block cookie */
if|if
condition|(
operator|(
name|devsw
operator|->
name|d_bmaj
operator|!=
operator|-
literal|1
operator|)
operator|&&
operator|(
name|dev
operator|->
name|si_name
index|[
literal|0
index|]
operator|==
literal|'r'
operator|)
operator|&&
operator|(
operator|(
name|devsw
operator|->
name|d_flags
operator|&
name|D_TYPEMASK
operator|)
operator|==
name|D_DISK
operator|)
condition|)
block|{
comment|/* dev->si_devfs =*/
name|devfs_add_devswf
argument_list|(
name|devsw
argument_list|,
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|,
name|DV_BLK
argument_list|,
name|uid
argument_list|,
name|gid
argument_list|,
name|perms
argument_list|,
name|dev
operator|->
name|si_name
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/***********************************************************************\ * Add the named device entry into the given directory, and make it 	* * The appropriate type... (called (sometimes indirectly) by drivers..)	* * this function is exported.. see sys/devfsext.h			* * Has the capacity to take  printf type arguments to format the device 	* * names									* \***********************************************************************/
end_comment

begin_function
name|void
modifier|*
name|devfs_add_devswf
parameter_list|(
name|void
modifier|*
name|devsw
parameter_list|,
name|int
name|minor
parameter_list|,
name|int
name|chrblk
parameter_list|,
name|uid_t
name|uid
parameter_list|,
name|gid_t
name|gid
parameter_list|,
name|int
name|perms
parameter_list|,
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|int
name|major
decl_stmt|;
name|devnm_p
name|new_dev
decl_stmt|;
name|dn_p
name|dnp
decl_stmt|;
comment|/* devnode for parent directory */
name|int
name|retval
decl_stmt|;
name|union
name|typeinfo
name|by
decl_stmt|;
name|struct
name|cdevsw
modifier|*
name|cd
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|path
decl_stmt|,
name|buf
index|[
literal|256
index|]
decl_stmt|;
comment|/* XXX */
name|int
name|i
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|i
operator|=
name|kvprintf
argument_list|(
name|fmt
argument_list|,
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|)
name|buf
argument_list|,
literal|32
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|buf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|name
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
literal|'/'
condition|)
block|{
name|name
operator|=
operator|&
name|buf
index|[
name|i
index|]
expr_stmt|;
name|buf
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|name
condition|)
block|{
operator|*
name|name
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|path
operator|=
name|buf
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
name|buf
expr_stmt|;
name|path
operator|=
literal|"/"
expr_stmt|;
block|}
name|DBPRINT
argument_list|(
operator|(
literal|"dev_add\n"
operator|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|dev_finddir
argument_list|(
name|path
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
operator|&
name|dnp
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|chrblk
condition|)
block|{
case|case
name|DV_CHR
case|:
name|cd
operator|=
name|devsw
expr_stmt|;
name|major
operator|=
name|cd
operator|->
name|d_maj
expr_stmt|;
if|if
condition|(
name|major
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
name|by
operator|.
name|dev
operator|.
name|dev
operator|=
name|makedev
argument_list|(
name|major
argument_list|,
name|minor
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_add_entry
argument_list|(
name|name
argument_list|,
name|dnp
argument_list|,
name|DEV_CDEV
argument_list|,
operator|&
name|by
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|new_dev
argument_list|)
condition|)
return|return
name|NULL
return|;
break|break;
case|case
name|DV_BLK
case|:
name|cd
operator|=
name|devsw
expr_stmt|;
name|major
operator|=
name|cd
operator|->
name|d_bmaj
expr_stmt|;
if|if
condition|(
name|major
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
name|by
operator|.
name|dev
operator|.
name|dev
operator|=
name|makebdev
argument_list|(
name|major
argument_list|,
name|minor
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_add_entry
argument_list|(
name|name
argument_list|,
name|dnp
argument_list|,
name|DEV_BDEV
argument_list|,
operator|&
name|by
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|new_dev
argument_list|)
condition|)
return|return
name|NULL
return|;
break|break;
default|default:
return|return
name|NULL
return|;
block|}
name|new_dev
operator|->
name|dnp
operator|->
name|gid
operator|=
name|gid
expr_stmt|;
name|new_dev
operator|->
name|dnp
operator|->
name|uid
operator|=
name|uid
expr_stmt|;
name|new_dev
operator|->
name|dnp
operator|->
name|mode
operator||=
name|perms
expr_stmt|;
name|devfs_propogate
argument_list|(
name|dnp
operator|->
name|by
operator|.
name|Dir
operator|.
name|myname
argument_list|,
name|new_dev
argument_list|)
expr_stmt|;
return|return
name|new_dev
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/***********************************************************************\ * Add the named device entry into the given directory, and make it 	* *  a link to the already created device given as an arg..		* * this function is exported.. see sys/devfsext.h			* \***********************************************************************/
end_comment

begin_function
name|void
modifier|*
name|devfs_makelink
parameter_list|(
name|void
modifier|*
name|original
parameter_list|,
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|devnm_p
name|new_dev
decl_stmt|;
name|devnm_p
name|orig
init|=
operator|(
name|devnm_p
operator|)
name|original
decl_stmt|;
name|dn_p
name|dirnode
decl_stmt|;
comment|/* devnode for parent directory */
name|int
name|retval
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
name|buf
index|[
literal|256
index|]
decl_stmt|;
comment|/* XXX */
name|int
name|i
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|i
operator|=
name|kvprintf
argument_list|(
name|fmt
argument_list|,
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|)
name|buf
argument_list|,
literal|32
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|buf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
literal|'/'
condition|)
block|{
name|p
operator|=
operator|&
name|buf
index|[
name|i
index|]
expr_stmt|;
name|buf
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|DBPRINT
argument_list|(
operator|(
literal|"dev_add\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 *  The DEV_CDEV below is not used other than it must NOT be DEV_DIR 	 * the correctness of original should be checked.. 	 */
if|if
condition|(
name|p
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|retval
operator|=
name|dev_finddir
argument_list|(
name|buf
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
operator|&
name|dirnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|dev_add_name
argument_list|(
name|p
argument_list|,
name|dirnode
argument_list|,
name|NULL
argument_list|,
name|orig
operator|->
name|dnp
argument_list|,
operator|&
name|new_dev
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
else|else
block|{
name|retval
operator|=
name|dev_finddir
argument_list|(
literal|"/"
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
operator|&
name|dirnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|dev_add_name
argument_list|(
name|buf
argument_list|,
name|dirnode
argument_list|,
name|NULL
argument_list|,
name|orig
operator|->
name|dnp
argument_list|,
operator|&
name|new_dev
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
name|devfs_propogate
argument_list|(
name|dirnode
operator|->
name|by
operator|.
name|Dir
operator|.
name|myname
argument_list|,
name|new_dev
argument_list|)
expr_stmt|;
return|return
name|new_dev
return|;
block|}
end_function

begin_comment
comment|/*  * internal kernel call to open a device. Return either 0 or an open vnode.  */
end_comment

begin_function
name|struct
name|vnode
modifier|*
name|devfs_open_device
parameter_list|(
name|char
modifier|*
name|path
parameter_list|,
name|int
name|type
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|lastslash
decl_stmt|;
name|char
modifier|*
name|nextpart
decl_stmt|;
name|devnm_p
name|nm_p
decl_stmt|;
name|dn_p
name|dirnode
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vn
decl_stmt|;
comment|/* 	 * If the caller didn't supply a full path, ignore and be 	 * noisy about it. 	 */
if|if
condition|(
operator|*
name|path
operator|!=
literal|'/'
condition|)
block|{
name|printf
argument_list|(
name|__FUNCTION__
literal|": caller supplied bad path\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * find the last '/'. Unfortunatly rindex() while being in 	 * libkern source, is not being compiled.. do it by hand. 	 * lastslash = strrchr(path,(int)'c'); 	 * There will be at LEAST one '/'. 	 */
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|path
decl_stmt|;
comment|/* don't destroy path */
for|for
control|(
name|lastslash
operator|=
name|NULL
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
name|lastslash
operator|=
name|p
expr_stmt|;
block|}
block|}
name|dirnode
operator|=
name|dev_root
operator|->
name|dnp
expr_stmt|;
if|if
condition|(
name|lastslash
operator|!=
name|path
condition|)
block|{
comment|/* find the directory we need */
operator|*
name|lastslash
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|dev_finddir
argument_list|(
name|path
argument_list|,
name|dirnode
argument_list|,
name|NULL
argument_list|,
operator|&
name|dirnode
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|lastslash
operator|=
literal|'/'
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* ok we found the directory, put the slash back */
operator|*
name|lastslash
operator|=
literal|'/'
expr_stmt|;
block|}
name|nextpart
operator|=
operator|++
name|lastslash
expr_stmt|;
if|if
condition|(
operator|*
name|nextpart
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/*  	 * Now only return true if it exists and is the right type. 	 */
if|if
condition|(
operator|(
name|nm_p
operator|=
name|dev_findname
argument_list|(
name|dirnode
argument_list|,
name|nextpart
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DV_BLK
case|:
if|if
condition|(
name|nm_p
operator|->
name|dnp
operator|->
name|type
operator|!=
name|DEV_BDEV
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
break|break;
case|case
name|DV_CHR
case|:
if|if
condition|(
name|nm_p
operator|->
name|dnp
operator|->
name|type
operator|!=
name|DEV_CDEV
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
break|break;
block|}
if|if
condition|(
name|devfs_dntovn
argument_list|(
name|nm_p
operator|->
name|dnp
argument_list|,
operator|&
name|vn
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|#
directive|if
literal|0
block|if ( VOP_OPEN(vn, FREAD, proc0.p_cred->pc_ucred,&proc0)) { 	 	vput(vn); 		return (NULL); 	}
endif|#
directive|endif
return|return
operator|(
name|vn
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * internal kernel call to close a devfs device.  * It should have been openned by th ecall above.  * try not mix it with user-openned vnodes.  * Frees the vnode.  */
end_comment

begin_function
name|void
name|devfs_close_device
parameter_list|(
name|struct
name|vnode
modifier|*
name|vn
parameter_list|)
block|{
if|#
directive|if
literal|0
block|VOP_CLOSE(vn, 0, proc0.p_cred->pc_ucred,&proc0) ;
endif|#
directive|endif
name|vput
argument_list|(
name|vn
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * Little utility routine for compatibilty.  * Returns the dev_t that a devfs vnode represents.  * should go away after dev_t go away :).  */
end_comment

begin_endif
unit|dev_t  devfs_vntodev(struct vnode *vn) { 	register dn_p  dnp;  	dnp = (dn_p)vn->v_data; 	switch (dnp->type) { 	case	DEV_BDEV: 		return (dnp->by.dev.dev); 		break; 	case	DEV_CDEV: 		return (dnp->by.dev.dev); 		break; 	} 	panic ("bad devfs DEVICE vnode"); }
endif|#
directive|endif
end_endif

end_unit

