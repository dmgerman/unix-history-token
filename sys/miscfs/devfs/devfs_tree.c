begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  Written by Julian Elischer (julian@DIALix.oz.au)  *  *	$Header: /home/ncvs/src/sys/miscfs/devfs/devfs_tree.c,v 1.2 1995/09/06 09:29:16 julian Exp $  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"types.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_comment
comment|/* define FWRITE ... */
end_comment

begin_include
include|#
directive|include
file|"conf.h"
end_include

begin_include
include|#
directive|include
file|"stat.h"
end_include

begin_include
include|#
directive|include
file|"mount.h"
end_include

begin_include
include|#
directive|include
file|"vnode.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_comment
comment|/* defines dirent structure		*/
end_comment

begin_include
include|#
directive|include
file|"devfsdefs.h"
end_include

begin_include
include|#
directive|include
file|"sys/devfsext.h"
end_include

begin_macro
name|SYSINIT
argument_list|(
argument|devfs
argument_list|,
argument|SI_SUB_DEVFS
argument_list|,
argument|SI_ORDER_FIRST
argument_list|,
argument|devfs_sinit
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_escape
end_escape

begin_decl_stmt
name|devnm_p
name|dev_root
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* root of the backing tree */
end_comment

begin_decl_stmt
name|struct
name|mount
modifier|*
name|devfs_hidden_mount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|devfs_up_and_going
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Set up the root directory node in the backing plane  * This is happenning before the vfs system has been  * set up yet, so be careful about what we reference..  * Notice that the ops are by indirection.. as they haven't  * been set up yet!  */
end_comment

begin_function
name|void
name|devfs_sinit
parameter_list|(
name|caddr_t
name|junk
parameter_list|)
comment|/*proto*/
block|{
name|int
name|retval
decl_stmt|;
comment|/* we will discard this */
name|devnm_p
name|new
decl_stmt|;
comment|/* 	 * call the right routine at the right time with the right args.... 	 */
name|retval
operator|=
name|dev_add_node
argument_list|(
literal|"root"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|DEV_DIR
argument_list|,
name|NULL
argument_list|,
operator|&
name|dev_root
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PARANOID
if|if
condition|(
name|retval
condition|)
name|panic
argument_list|(
literal|"devfs_sinit: dev_add_node failed "
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|devfs_hidden_mount
operator|=
operator|(
expr|struct
name|mount
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mount
argument_list|)
argument_list|,
name|M_MOUNT
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PARANOID
if|if
condition|(
operator|!
name|devfs_hidden_mount
condition|)
name|panic
argument_list|(
literal|"devfs_sinit: malloc failed"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bzero
argument_list|(
name|devfs_hidden_mount
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mount
argument_list|)
argument_list|)
expr_stmt|;
name|devfs_mount
argument_list|(
name|devfs_hidden_mount
argument_list|,
literal|"dummy"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dev_root
operator|->
name|dnp
operator|->
name|dvm
operator|=
operator|(
expr|struct
name|devfsmount
operator|*
operator|)
name|devfs_hidden_mount
operator|->
name|mnt_data
expr_stmt|;
name|devfs_up_and_going
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"DEVFS: ready for devices\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/***********************************************************************\ *	Routines used to add and remove nodes from the base tree	* \***********************************************************************/
end_comment

begin_comment
comment|/***********************************************************************\ * Given a starting node (0 for root) and a pathname, return the node	* * for the end item on the path. It MUST BE A DIRECTORY. If the 'CREATE'	* * option is true, then create any missing nodes in the path and create	* * and return the final node as well.					* * This is used to set up a directory, before making nodes in it..	* *									* * Warning: This function is RECURSIVE.					* *	char	*path,		 find this dir (err if not dir)		* *	dn_p	dirnode,	 starting point  (0 = root)	 	* *	int	create,		 create path if not found 		* *	dn_p	*dn_pp)		 where to return the node of the dir	* \***********************************************************************/
end_comment

begin_function
name|int
name|dev_finddir
parameter_list|(
name|char
modifier|*
name|orig_path
parameter_list|,
name|dn_p
name|dirnode
parameter_list|,
name|int
name|create
parameter_list|,
name|dn_p
modifier|*
name|dn_pp
parameter_list|)
comment|/*proto*/
block|{
name|devnm_p
name|devnmp
decl_stmt|;
name|dn_p
name|dnp
decl_stmt|;
name|char
name|pathbuf
index|[
name|DEVMAXPATHSIZE
index|]
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"dev_finddir\n"
operator|)
argument_list|)
expr_stmt|;
comment|/***************************************\ 	* If no parent directory is given	* 	* then start at the root of the tree	* 	\***************************************/
if|if
condition|(
operator|!
name|dirnode
condition|)
name|dirnode
operator|=
name|dev_root
operator|->
name|dnp
expr_stmt|;
comment|/***************************************\ 	* Sanity Checks				* 	\***************************************/
if|if
condition|(
name|dirnode
operator|->
name|type
operator|!=
name|DEV_DIR
condition|)
return|return
name|ENOTDIR
return|;
if|if
condition|(
name|strlen
argument_list|(
name|orig_path
argument_list|)
operator|>
operator|(
name|DEVMAXPATHSIZE
operator|-
literal|1
operator|)
condition|)
return|return
name|ENAMETOOLONG
return|;
name|path
operator|=
name|pathbuf
expr_stmt|;
name|strcpy
argument_list|(
name|path
argument_list|,
name|orig_path
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|path
operator|==
literal|'/'
condition|)
name|path
operator|++
expr_stmt|;
comment|/* always absolute, skip leading / */
comment|/***************************************\ 	* find the next segment of the name	* 	\***************************************/
name|cp
operator|=
name|name
operator|=
name|path
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|cp
operator|!=
literal|'/'
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|!=
literal|0
operator|)
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
comment|/***********************************************\ 	* Check to see if it's the last component	* 	\***********************************************/
if|if
condition|(
operator|*
name|cp
condition|)
block|{
name|path
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
comment|/* path refers to the rest */
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
comment|/* name is now a separate string */
if|if
condition|(
operator|!
operator|(
operator|*
name|path
operator|)
condition|)
block|{
name|path
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* was trailing slash */
block|}
block|}
else|else
block|{
name|path
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* no more to do */
block|}
comment|/***************************************\ 	* Start scanning along the linked list	* 	\***************************************/
name|dnp
operator|=
name|dev_findname
argument_list|(
name|dirnode
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnp
condition|)
block|{
comment|/* check it's a directory */
if|if
condition|(
name|dnp
operator|->
name|type
operator|!=
name|DEV_DIR
condition|)
return|return
name|ENOTDIR
return|;
block|}
else|else
block|{
comment|/***************************************\ 		* The required element does not exist	* 		* So we will add it if asked to.	* 		\***************************************/
if|if
condition|(
operator|!
name|create
condition|)
return|return
name|ENOENT
return|;
if|if
condition|(
name|retval
operator|=
name|dev_add_node
argument_list|(
name|name
argument_list|,
name|dirnode
argument_list|,
name|NULL
argument_list|,
name|DEV_DIR
argument_list|,
name|NULL
argument_list|,
operator|&
name|devnmp
argument_list|)
condition|)
block|{
return|return
name|retval
return|;
block|}
name|dnp
operator|=
name|devnmp
operator|->
name|dnp
expr_stmt|;
block|}
if|if
condition|(
name|path
condition|)
comment|/* decide whether to recurse more or return */
block|{
return|return
operator|(
name|dev_finddir
argument_list|(
name|path
argument_list|,
name|dnp
argument_list|,
name|create
argument_list|,
name|dn_pp
argument_list|)
operator|)
return|;
block|}
else|else
block|{
operator|*
name|dn_pp
operator|=
name|dnp
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/***********************************************************************\ * Add a new element to the devfs backing structure. 			* * If we're creating a root node, then dirname is NULL			* * If devnode is non zero, then we just want to create a link to it	* * This implies that we are not at base level and it's a not a DIR	* \***********************************************************************/
end_comment

begin_function
name|int
name|dev_add_node
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|dn_p
name|dirnode
parameter_list|,
name|devnm_p
name|back
parameter_list|,
name|int
name|entrytype
parameter_list|,
name|union
name|typeinfo
modifier|*
name|by
parameter_list|,
name|devnm_p
modifier|*
name|devnm_pp
parameter_list|)
comment|/*proto*/
block|{
name|devnm_p
name|devnmp
decl_stmt|;
name|devnm_p
name|realthing
decl_stmt|;
comment|/* needed to create an alias */
name|dn_p
name|dnp
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"dev_add_node\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirnode
condition|)
block|{
if|if
condition|(
name|dirnode
operator|->
name|type
operator|!=
name|DEV_DIR
condition|)
return|return
operator|(
name|ENOTDIR
operator|)
return|;
name|dnp
operator|=
name|dev_findname
argument_list|(
name|dirnode
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnp
condition|)
comment|/* if we actually found it.. */
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
comment|/* 	 * make sure the name is legal 	 * slightly misleading in the case of NULL 	 */
if|if
condition|(
operator|!
name|name
operator|||
operator|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|>
operator|(
name|DEVMAXNAMESIZE
operator|-
literal|1
operator|)
operator|)
condition|)
return|return
operator|(
name|ENAMETOOLONG
operator|)
return|;
comment|/* 	 * Allocate and fill out a new directory entry  	 */
if|if
condition|(
operator|!
operator|(
name|devnmp
operator|=
operator|(
name|devnm_p
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|devnm_t
argument_list|)
argument_list|,
name|M_DEVFSNAME
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
condition|)
block|{
return|return
name|ENOMEM
return|;
block|}
name|bzero
argument_list|(
name|devnmp
argument_list|,
sizeof|sizeof
argument_list|(
name|devnm_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If we don't already have one, 	 * Allocate a devfs node.. 	 * If we already have one, create a new link to it. 	 * DIR types ALWAYS get a new node.. 	 */
if|if
condition|(
operator|(
name|entrytype
operator|==
name|DEV_DIR
operator|)
operator|||
operator|(
operator|!
name|back
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|dnp
operator|=
operator|(
name|dn_p
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|devnode_t
argument_list|)
argument_list|,
name|M_DEVFSNODE
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|devnmp
argument_list|,
name|M_DEVFSNAME
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|bzero
argument_list|(
name|dnp
argument_list|,
sizeof|sizeof
argument_list|(
name|devnode_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * note the node type we are adding 		 * and set the creation times to NOW 		 * put in it's name 		 */
name|dnp
operator|->
name|type
operator|=
name|entrytype
expr_stmt|;
name|TIMEVAL_TO_TIMESPEC
argument_list|(
argument|&time
argument_list|,
argument|&(dnp->ctime)
argument_list|)
name|dnp
operator|->
name|mtime
operator|=
name|dnp
operator|->
name|ctime
expr_stmt|;
name|dnp
operator|->
name|atime
operator|=
name|dnp
operator|->
name|ctime
expr_stmt|;
comment|/* 		 * fill out the dev node according to type 		 */
switch|switch
condition|(
name|entrytype
condition|)
block|{
case|case
name|DEV_DIR
case|:
comment|/* 			 * As it's a directory, make sure 			 * it has a null entries list 			 */
name|dnp
operator|->
name|by
operator|.
name|Dir
operator|.
name|dirlast
operator|=
operator|&
operator|(
name|dnp
operator|->
name|by
operator|.
name|Dir
operator|.
name|dirlist
operator|)
expr_stmt|;
name|dnp
operator|->
name|by
operator|.
name|Dir
operator|.
name|dirlist
operator|=
operator|(
name|devnm_p
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|dirnode
condition|)
block|{
name|dnp
operator|->
name|by
operator|.
name|Dir
operator|.
name|parent
operator|=
operator|(
name|dn_p
operator|)
name|dirnode
expr_stmt|;
block|}
else|else
block|{
comment|/* root loops to self */
name|dnp
operator|->
name|by
operator|.
name|Dir
operator|.
name|parent
operator|=
name|dnp
expr_stmt|;
block|}
name|dnp
operator|->
name|by
operator|.
name|Dir
operator|.
name|parent
operator|->
name|links
operator|++
expr_stmt|;
comment|/* account for .. */
name|dnp
operator|->
name|links
operator|++
expr_stmt|;
comment|/* for .*/
name|dnp
operator|->
name|by
operator|.
name|Dir
operator|.
name|myname
operator|=
name|devnmp
expr_stmt|;
comment|/* 			 * make sure that the ops associated with it are the ops 			 * that we use (by default) for directories 			 */
name|dnp
operator|->
name|ops
operator|=
operator|&
name|devfs_vnodeop_p
expr_stmt|;
name|dnp
operator|->
name|mode
operator||=
literal|0555
expr_stmt|;
comment|/* default perms */
break|break;
comment|/*******************************************************\ 		* The rest of these can't happen except in the back plane* 		\*******************************************************/
case|case
name|DEV_BDEV
case|:
comment|/* 			 * Make sure it has DEVICE type ops 			 * and device specific fields are correct 			 */
name|dnp
operator|->
name|ops
operator|=
operator|&
name|dev_spec_vnodeop_p
expr_stmt|;
name|dnp
operator|->
name|by
operator|.
name|Bdev
operator|.
name|bdevsw
operator|=
name|by
operator|->
name|Bdev
operator|.
name|bdevsw
expr_stmt|;
name|dnp
operator|->
name|by
operator|.
name|Bdev
operator|.
name|dev
operator|=
name|by
operator|->
name|Bdev
operator|.
name|dev
expr_stmt|;
break|break;
case|case
name|DEV_CDEV
case|:
comment|/* 			 * Make sure it has DEVICE type ops 			 * and device specific fields are correct 			 */
name|dnp
operator|->
name|ops
operator|=
operator|&
name|dev_spec_vnodeop_p
expr_stmt|;
name|dnp
operator|->
name|by
operator|.
name|Cdev
operator|.
name|cdevsw
operator|=
name|by
operator|->
name|Cdev
operator|.
name|cdevsw
expr_stmt|;
name|dnp
operator|->
name|by
operator|.
name|Cdev
operator|.
name|dev
operator|=
name|by
operator|->
name|Cdev
operator|.
name|dev
expr_stmt|;
break|break;
case|case
name|DEV_DDEV
case|:
comment|/* 			 * store the address of (the address of) the ops 			 * and the magic cookie to use with them 			 */
name|dnp
operator|->
name|by
operator|.
name|Ddev
operator|.
name|arg
operator|=
name|by
operator|->
name|Ddev
operator|.
name|arg
expr_stmt|;
name|dnp
operator|->
name|ops
operator|=
name|by
operator|->
name|Ddev
operator|.
name|ops
expr_stmt|;
break|break;
case|case
name|DEV_ALIAS
case|:
comment|/* 			 * point to the node we want to shadow 			 * Also store the fact we exist so that aliases 			 * can be deleted accuratly when the original node 			 * is deleted.. (i.e. when device is removed) 			 */
name|realthing
operator|=
name|by
operator|->
name|Alias
operator|.
name|realthing
expr_stmt|;
name|dnp
operator|->
name|by
operator|.
name|Alias
operator|.
name|realthing
operator|=
name|realthing
expr_stmt|;
name|dnp
operator|->
name|by
operator|.
name|Alias
operator|.
name|next
operator|=
name|realthing
operator|->
name|as
operator|.
name|back
operator|.
name|aliases
expr_stmt|;
name|realthing
operator|->
name|as
operator|.
name|back
operator|.
name|aliases
operator|=
name|devnmp
expr_stmt|;
break|break;
block|}
comment|/* inherrit our parent's mount info */
if|if
condition|(
name|dirnode
condition|)
block|{
name|dnp
operator|->
name|dvm
operator|=
name|dirnode
operator|->
name|dvm
expr_stmt|;
if|if
condition|(
operator|!
name|dnp
operator|->
name|dvm
condition|)
name|printf
argument_list|(
literal|"parent had null dvm "
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|dnp
operator|=
name|back
operator|->
name|dnp
expr_stmt|;
if|if
condition|(
operator|!
name|dnp
operator|->
name|dvm
condition|)
name|printf
argument_list|(
literal|"node has null dvm "
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Link the two together 	 * include the implicit link in the count of links to the devnode.. 	 * this stops it from being accidentally freed later. 	 */
name|devnmp
operator|->
name|dnp
operator|=
name|dnp
expr_stmt|;
name|dnp
operator|->
name|links
operator|++
expr_stmt|;
comment|/* implicit from our own name-node */
comment|/* 	 * put in it's name 	 */
name|strcpy
argument_list|(
name|devnmp
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* 	 * And set up the 'clones' list (empty if new node) 	 */
if|if
condition|(
name|back
condition|)
block|{
comment|/*******************************************************\ 		* Put it in the appropriate back/front list too.	* 		\*******************************************************/
name|devnmp
operator|->
name|next_front
operator|=
operator|*
name|back
operator|->
name|prev_frontp
expr_stmt|;
name|devnmp
operator|->
name|prev_frontp
operator|=
name|back
operator|->
name|prev_frontp
expr_stmt|;
operator|*
name|back
operator|->
name|prev_frontp
operator|=
name|devnmp
expr_stmt|;
name|back
operator|->
name|prev_frontp
operator|=
operator|&
operator|(
name|devnmp
operator|->
name|next_front
operator|)
expr_stmt|;
name|devnmp
operator|->
name|as
operator|.
name|front
operator|.
name|realthing
operator|=
name|back
expr_stmt|;
block|}
else|else
block|{
name|devnmp
operator|->
name|prev_frontp
operator|=
operator|&
operator|(
name|devnmp
operator|->
name|next_front
operator|)
expr_stmt|;
name|devnmp
operator|->
name|next_front
operator|=
name|NULL
expr_stmt|;
block|}
comment|/******************************************* 	 * Check if we are not making a root node.. 	 * (i.e. have parent) 	 */
if|if
condition|(
name|dirnode
condition|)
block|{
comment|/* 	 	 * Put it on the END of the linked list of directory entries 	 	 */
name|devnmp
operator|->
name|parent
operator|=
name|dirnode
expr_stmt|;
comment|/* null for root */
name|devnmp
operator|->
name|prevp
operator|=
name|dirnode
operator|->
name|by
operator|.
name|Dir
operator|.
name|dirlast
expr_stmt|;
name|devnmp
operator|->
name|next
operator|=
operator|*
operator|(
name|devnmp
operator|->
name|prevp
operator|)
expr_stmt|;
comment|/* should be NULL */
comment|/*right?*/
operator|*
operator|(
name|devnmp
operator|->
name|prevp
operator|)
operator|=
name|devnmp
expr_stmt|;
name|dirnode
operator|->
name|by
operator|.
name|Dir
operator|.
name|dirlast
operator|=
operator|&
operator|(
name|devnmp
operator|->
name|next
operator|)
expr_stmt|;
name|dirnode
operator|->
name|by
operator|.
name|Dir
operator|.
name|entrycount
operator|++
expr_stmt|;
name|dirnode
operator|->
name|len
operator|+=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|8
expr_stmt|;
comment|/*ok, ok?*/
block|}
comment|/* 	 * If we have a parent, then maybe we should duplicate 	 * ourselves onto any plane that the parent is on... 	 * Though this may be better handled elsewhere as 	 * it stops this routine from being used for front nodes 	 */
if|if
condition|(
name|dirnode
operator|&&
operator|!
name|back
condition|)
block|{
if|if
condition|(
name|retval
operator|=
name|devfs_add_fronts
argument_list|(
name|dirnode
operator|->
name|by
operator|.
name|Dir
operator|.
name|myname
argument_list|,
name|devnmp
argument_list|)
condition|)
block|{
comment|/*XXX*/
comment|/* no idea what to do if it fails... */
return|return
name|retval
return|;
block|}
block|}
operator|*
name|devnm_pp
operator|=
name|devnmp
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/***********************************************************************  * remove all fronts to this dev and also it's aliases,  * Then remove this node.  * For now only allow DEVICE nodes to go.. XXX  * directory nodes are more complicated and may need more work..  ***********************************************************************/
end_comment

begin_function
name|int
name|dev_remove
parameter_list|(
name|devnm_p
name|devnmp
parameter_list|)
comment|/*proto*/
block|{
name|devnm_p
name|alias
decl_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"dev_remove\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Check the type of the node.. for now don't allow dirs 	 */
switch|switch
condition|(
name|devnmp
operator|->
name|dnp
operator|->
name|type
condition|)
block|{
case|case
name|DEV_BDEV
case|:
case|case
name|DEV_CDEV
case|:
case|case
name|DEV_DDEV
case|:
case|case
name|DEV_ALIAS
case|:
case|case
name|DEV_SLNK
case|:
break|break;
case|case
name|DEV_DIR
case|:
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * Free each alias 	 * Remember, aliases can't have front nodes 	 */
while|while
condition|(
name|alias
operator|=
name|devnmp
operator|->
name|as
operator|.
name|back
operator|.
name|aliases
condition|)
block|{
name|devnmp
operator|->
name|as
operator|.
name|back
operator|.
name|aliases
operator|=
name|alias
operator|->
name|dnp
operator|->
name|by
operator|.
name|Alias
operator|.
name|next
expr_stmt|;
name|devfs_dn_free
argument_list|(
name|alias
operator|->
name|dnp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|alias
argument_list|,
name|M_DEVFSNAME
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now remove front items of the Main node itself 	 */
name|devfs_remove_fronts
argument_list|(
name|devnmp
argument_list|)
expr_stmt|;
comment|/* 	 * now we should free the main node 	 */
name|devfs_dn_free
argument_list|(
name|devnmp
operator|->
name|dnp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|devnmp
argument_list|,
name|M_DEVFSNAME
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|dev_touch
parameter_list|(
name|devnm_p
name|key
parameter_list|)
comment|/* update the node for this dev */
comment|/*proto*/
block|{
name|DBPRINT
argument_list|(
operator|(
literal|"dev_touch\n"
operator|)
argument_list|)
expr_stmt|;
name|TIMEVAL_TO_TIMESPEC
argument_list|(
argument|&time
argument_list|,
argument|&(key->dnp->mtime)
argument_list|)
return|return
literal|0
return|;
comment|/*XXX*/
block|}
end_function

begin_function
name|void
name|devfs_dn_free
parameter_list|(
name|dn_p
name|dnp
parameter_list|)
comment|/*proto*/
block|{
if|if
condition|(
name|dnp
operator|->
name|links
operator|<=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"devfs node reference count bogus\n"
argument_list|)
expr_stmt|;
name|Debugger
argument_list|(
literal|"devfs_dn_free"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|--
name|dnp
operator|->
name|links
operator|==
literal|0
condition|)
block|{
name|devfs_dropvnode
argument_list|(
name|dnp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dnp
argument_list|,
name|M_DEVFSNODE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/***********************************************************************\ * UTILITY routine:							* * Return the major number for the cdevsw entry containing the given	* * address.								* \***********************************************************************/
end_comment

begin_function
name|int
name|get_cdev_major_num
parameter_list|(
name|caddr_t
name|addr
parameter_list|)
comment|/*proto*/
block|{
name|int
name|index
init|=
literal|0
decl_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"get_cdev_major_num\n"
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|index
operator|<
name|nchrdev
condition|)
block|{
if|if
condition|(
operator|(
call|(
name|caddr_t
call|)
argument_list|(
name|cdevsw
index|[
name|index
index|]
operator|.
name|d_open
argument_list|)
operator|==
name|addr
operator|)
operator|||
operator|(
call|(
name|caddr_t
call|)
argument_list|(
name|cdevsw
index|[
name|index
index|]
operator|.
name|d_read
argument_list|)
operator|==
name|addr
operator|)
operator|||
operator|(
call|(
name|caddr_t
call|)
argument_list|(
name|cdevsw
index|[
name|index
index|]
operator|.
name|d_ioctl
argument_list|)
operator|==
name|addr
operator|)
condition|)
block|{
return|return
name|index
return|;
block|}
name|index
operator|++
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|get_bdev_major_num
parameter_list|(
name|caddr_t
name|addr
parameter_list|)
comment|/*proto*/
block|{
name|int
name|index
init|=
literal|0
decl_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"get_bdev_major_num\n"
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|index
operator|<
name|nblkdev
condition|)
block|{
if|if
condition|(
operator|(
call|(
name|caddr_t
call|)
argument_list|(
name|bdevsw
index|[
name|index
index|]
operator|.
name|d_open
argument_list|)
operator|==
name|addr
operator|)
operator|||
operator|(
call|(
name|caddr_t
call|)
argument_list|(
name|bdevsw
index|[
name|index
index|]
operator|.
name|d_strategy
argument_list|)
operator|==
name|addr
operator|)
operator|||
operator|(
call|(
name|caddr_t
call|)
argument_list|(
name|bdevsw
index|[
name|index
index|]
operator|.
name|d_ioctl
argument_list|)
operator|==
name|addr
operator|)
condition|)
block|{
return|return
name|index
return|;
block|}
name|index
operator|++
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/***********************************************************************\ * Add the named device entry into the given directory, and make it 	* * The appropriate type... (called (sometimes indirectly) by drivers..)	* \***********************************************************************/
end_comment

begin_function
name|void
modifier|*
name|dev_add
parameter_list|(
name|char
modifier|*
name|path
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|funct
parameter_list|,
name|int
name|minor
parameter_list|,
name|int
name|chrblk
parameter_list|,
name|uid_t
name|uid
parameter_list|,
name|gid_t
name|gid
parameter_list|,
name|int
name|perms
parameter_list|)
block|{
name|devnm_p
name|new_dev
decl_stmt|;
name|dn_p
name|dnp
decl_stmt|;
comment|/* devnode for parent directory */
name|int
name|retval
decl_stmt|;
name|int
name|major
decl_stmt|;
name|union
name|typeinfo
name|by
decl_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"dev_add\n"
operator|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|dev_finddir
argument_list|(
name|path
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
operator|&
name|dnp
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|chrblk
condition|)
block|{
case|case
name|DV_CHR
case|:
name|major
operator|=
name|get_cdev_major_num
argument_list|(
name|funct
argument_list|)
expr_stmt|;
name|by
operator|.
name|Cdev
operator|.
name|cdevsw
operator|=
name|cdevsw
operator|+
name|major
expr_stmt|;
name|by
operator|.
name|Cdev
operator|.
name|dev
operator|=
name|makedev
argument_list|(
name|major
argument_list|,
name|minor
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_add_node
argument_list|(
name|name
argument_list|,
name|dnp
argument_list|,
name|NULL
argument_list|,
name|DEV_CDEV
argument_list|,
operator|&
name|by
argument_list|,
operator|&
name|new_dev
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|DV_BLK
case|:
name|major
operator|=
name|get_bdev_major_num
argument_list|(
name|funct
argument_list|)
expr_stmt|;
name|by
operator|.
name|Bdev
operator|.
name|bdevsw
operator|=
name|bdevsw
operator|+
name|major
expr_stmt|;
name|by
operator|.
name|Bdev
operator|.
name|dev
operator|=
name|makedev
argument_list|(
name|major
argument_list|,
name|minor
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_add_node
argument_list|(
name|name
argument_list|,
name|dnp
argument_list|,
name|NULL
argument_list|,
name|DEV_BDEV
argument_list|,
operator|&
name|by
argument_list|,
operator|&
name|new_dev
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|new_dev
operator|->
name|dnp
operator|->
name|gid
operator|=
name|gid
expr_stmt|;
name|new_dev
operator|->
name|dnp
operator|->
name|uid
operator|=
name|uid
expr_stmt|;
name|new_dev
operator|->
name|dnp
operator|->
name|mode
operator||=
name|perms
expr_stmt|;
return|return
name|new_dev
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/***********************************************************************\ *	Front Node Operations						*  \***********************************************************************/
end_comment

begin_comment
comment|/***********************************************************************\ * Given a directory backing node, and a child backing node, add the	* * appropriate front nodes to the front nodes of the directory to	* * represent the child node to the user					* *									* * on failure, front nodes will either be correct or not exist for each	* * front dir, however dirs completed will not be stripped of completed	* * frontnodes on failure of a later frontnode				* *									* \***********************************************************************/
end_comment

begin_function
name|int
name|devfs_add_fronts
parameter_list|(
name|devnm_p
name|parent
parameter_list|,
name|devnm_p
name|child
parameter_list|)
comment|/*proto*/
block|{
name|devnm_p
name|newnmp
decl_stmt|;
name|devnm_p
name|falias
decl_stmt|;
name|int
name|type
init|=
name|child
operator|->
name|dnp
operator|->
name|type
decl_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"	devfs_add_fronts\n"
operator|)
argument_list|)
expr_stmt|;
comment|/***********************************************\ 	* Find the frontnodes of the parent node	* 	\***********************************************/
for|for
control|(
name|falias
operator|=
name|parent
operator|->
name|next_front
init|;
name|falias
condition|;
name|falias
operator|=
name|falias
operator|->
name|next_front
control|)
block|{
if|if
condition|(
name|dev_findname
argument_list|(
name|falias
operator|->
name|dnp
argument_list|,
name|child
operator|->
name|name
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Device %s not created, already exists\n"
argument_list|,
name|child
operator|->
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|dev_add_node
argument_list|(
name|child
operator|->
name|name
argument_list|,
name|parent
operator|->
name|dnp
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|NULL
argument_list|,
operator|&
name|newnmp
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Device %s: allocation failed\n"
argument_list|,
name|child
operator|->
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* for now always succeed */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/***************************************************************\ * Search down the linked list off a dir to find "name"		* * return the dn_p for that node. \***************************************************************/
end_comment

begin_function
name|dn_p
name|dev_findname
parameter_list|(
name|dn_p
name|dir
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
comment|/*proto*/
block|{
name|devnm_p
name|newfp
decl_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"	dev_findname(%s)\n"
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|->
name|type
operator|!=
name|DEV_DIR
condition|)
return|return
literal|0
return|;
comment|/*XXX*/
comment|/* printf?*/
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|0
condition|)
block|{
return|return
name|dir
return|;
block|}
if|if
condition|(
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'.'
operator|)
operator|&&
operator|(
name|name
index|[
literal|2
index|]
operator|==
literal|0
operator|)
condition|)
block|{
return|return
name|dir
operator|->
name|by
operator|.
name|Dir
operator|.
name|parent
return|;
comment|/* for root, .. == . */
block|}
block|}
name|newfp
operator|=
name|dir
operator|->
name|by
operator|.
name|Dir
operator|.
name|dirlist
expr_stmt|;
while|while
condition|(
name|newfp
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|newfp
operator|->
name|name
argument_list|)
operator|)
condition|)
return|return
name|newfp
operator|->
name|dnp
return|;
name|newfp
operator|=
name|newfp
operator|->
name|next
expr_stmt|;
block|}
return|return
operator|(
name|dn_p
operator|)
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/***************************************************************\ * Create and link in a new front element.. 			* * Parent can be 0 for a root node				* * Not presently usable to make a symlink XXX			* * Must teach this to handle where there is no back node		* * maybe split into two bits?					* \***************************************************************/
end_comment

begin_function
name|int
name|dev_mk_front
parameter_list|(
name|dn_p
name|parent
parameter_list|,
name|devnm_p
name|back
parameter_list|,
name|devnm_p
modifier|*
name|dnm_pp
parameter_list|,
name|struct
name|devfsmount
modifier|*
name|dvm
parameter_list|)
comment|/*proto*/
block|{
name|devnm_p
name|newnmp
decl_stmt|;
name|struct
name|devfsmount
modifier|*
name|dmt
decl_stmt|;
name|devnm_p
name|newback
decl_stmt|;
name|devnm_p
name|newfront
decl_stmt|;
name|int
name|error
decl_stmt|;
name|dn_p
name|dnp
init|=
name|back
operator|->
name|dnp
decl_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"	dev_mk_front\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * go get the node made 	 */
name|error
operator|=
name|dev_add_node
argument_list|(
name|back
operator|->
name|name
argument_list|,
name|parent
argument_list|,
name|back
argument_list|,
name|dnp
operator|->
name|type
argument_list|,
name|NULL
argument_list|,
operator|&
name|newnmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
comment|/* 	 * If we have just made the root, then insert the pointer to the 	 * mount information 	 */
if|if
condition|(
name|dvm
condition|)
block|{
name|newnmp
operator|->
name|dnp
operator|->
name|dvm
operator|=
name|dvm
expr_stmt|;
block|}
comment|/* 	 * If it is a directory, then recurse down all the other 	 * subnodes in it.... 	 * note that this time we don't pass on the mount info.. 	 */
if|if
condition|(
name|newnmp
operator|->
name|dnp
operator|->
name|type
operator|==
name|DEV_DIR
condition|)
block|{
for|for
control|(
name|newback
operator|=
name|back
operator|->
name|dnp
operator|->
name|by
operator|.
name|Dir
operator|.
name|dirlist
init|;
name|newback
condition|;
name|newback
operator|=
name|newback
operator|->
name|next
control|)
block|{
if|if
condition|(
name|error
operator|=
name|dev_mk_front
argument_list|(
name|newnmp
operator|->
name|dnp
argument_list|,
name|newback
argument_list|,
operator|&
name|newfront
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
break|break;
comment|/* back out with an error */
block|}
block|}
block|}
operator|*
name|dnm_pp
operator|=
name|newnmp
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * duplicate the backing tree into a tree of nodes hung off the  * mount point given as the argument. Do this by  * calling dev_mk_front() which recurses all the way  * up the tree..  */
end_comment

begin_function
name|int
name|devfs_make_plane
parameter_list|(
name|struct
name|devfsmount
modifier|*
name|devfs_mp_p
parameter_list|)
comment|/*proto*/
block|{
name|devnm_p
name|new
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"	devfs_make_plane\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|devfs_up_and_going
condition|)
block|{
if|if
condition|(
name|error
operator|=
name|dev_mk_front
argument_list|(
name|NULL
argument_list|,
name|dev_root
argument_list|,
operator|&
name|new
argument_list|,
name|devfs_mp_p
argument_list|)
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
else|else
block|{
comment|/* we are doing the dummy mount during initialisation.. */
name|new
operator|=
name|dev_root
expr_stmt|;
block|}
name|devfs_mp_p
operator|->
name|plane_root
operator|=
name|new
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|void
name|devfs_free_plane
parameter_list|(
name|struct
name|devfsmount
modifier|*
name|devfs_mp_p
parameter_list|)
comment|/*proto*/
block|{
name|devnm_p
name|devnmp
decl_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"	devfs_free_plane\n"
operator|)
argument_list|)
expr_stmt|;
name|devnmp
operator|=
name|devfs_mp_p
operator|->
name|plane_root
expr_stmt|;
if|if
condition|(
name|devnmp
condition|)
name|dev_free_name
argument_list|(
name|devnmp
argument_list|)
expr_stmt|;
name|devfs_mp_p
operator|->
name|plane_root
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove all the front nodes associated with a backing node  */
end_comment

begin_function
name|void
name|devfs_remove_fronts
parameter_list|(
name|devnm_p
name|devnmp
parameter_list|)
comment|/*proto*/
block|{
while|while
condition|(
name|devnmp
operator|->
name|next_front
condition|)
block|{
name|dev_free_name
argument_list|(
name|devnmp
operator|->
name|next_front
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/***************************************************************\ * Free a front node (and any below it of it's a directory node)	* \***************************************************************/
end_comment

begin_function
name|void
name|dev_free_name
parameter_list|(
name|devnm_p
name|devnmp
parameter_list|)
comment|/*proto*/
block|{
name|dn_p
name|parent
init|=
name|devnmp
operator|->
name|parent
decl_stmt|;
name|devnm_p
name|back
decl_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"	dev_free_name\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|devnmp
operator|->
name|dnp
operator|->
name|type
operator|==
name|DEV_DIR
condition|)
block|{
while|while
condition|(
name|devnmp
operator|->
name|dnp
operator|->
name|by
operator|.
name|Dir
operator|.
name|dirlist
condition|)
block|{
name|dev_free_name
argument_list|(
name|devnmp
operator|->
name|dnp
operator|->
name|by
operator|.
name|Dir
operator|.
name|dirlist
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * drop the reference counts on our and our parent's 		 * nodes for "." and ".." (root has ".." -> "." ) 		 */
name|devfs_dn_free
argument_list|(
name|devnmp
operator|->
name|dnp
argument_list|)
expr_stmt|;
comment|/* account for '.' */
name|devfs_dn_free
argument_list|(
name|devnmp
operator|->
name|dnp
operator|->
name|by
operator|.
name|Dir
operator|.
name|parent
argument_list|)
expr_stmt|;
comment|/* and '..' */
comment|/* should only have one reference left (from name element) */
block|}
comment|/* 	 * unlink ourselves from the directory on this plane 	 */
if|if
condition|(
name|parent
condition|)
comment|/* if not fs root */
block|{
if|if
condition|(
operator|*
name|devnmp
operator|->
name|prevp
operator|=
name|devnmp
operator|->
name|next
condition|)
comment|/* yes, assign */
block|{
name|devnmp
operator|->
name|next
operator|->
name|prevp
operator|=
name|devnmp
operator|->
name|prevp
expr_stmt|;
block|}
else|else
block|{
name|parent
operator|->
name|by
operator|.
name|Dir
operator|.
name|dirlast
operator|=
name|devnmp
operator|->
name|prevp
expr_stmt|;
block|}
name|parent
operator|->
name|by
operator|.
name|Dir
operator|.
name|entrycount
operator|--
expr_stmt|;
name|parent
operator|->
name|len
operator|-=
name|strlen
argument_list|(
name|devnmp
operator|->
name|name
argument_list|)
operator|+
literal|8
expr_stmt|;
block|}
comment|/* 	 * If the node has a backing pointer we need to free ourselves 	 * from that.. 	 * Remember that we may not HAVE a backing node. 	 */
if|if
condition|(
name|back
operator|=
name|devnmp
operator|->
name|as
operator|.
name|front
operator|.
name|realthing
condition|)
comment|/* yes an assign */
block|{
if|if
condition|(
operator|*
name|devnmp
operator|->
name|prev_frontp
operator|=
name|devnmp
operator|->
name|next_front
condition|)
comment|/* yes, assign */
block|{
name|devnmp
operator|->
name|next_front
operator|->
name|prev_frontp
operator|=
name|devnmp
operator|->
name|prev_frontp
expr_stmt|;
block|}
else|else
block|{
name|back
operator|->
name|prev_frontp
operator|=
name|devnmp
operator|->
name|prev_frontp
expr_stmt|;
block|}
block|}
comment|/***************************************************************\ 	* If the front node has it's own devnode structure,		* 	* then free it.							* 	\***************************************************************/
name|devfs_dn_free
argument_list|(
name|devnmp
operator|->
name|dnp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|devnmp
argument_list|,
name|M_DEVFSNAME
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*******************************************************\ * Theoretically this could be called for any kind of 	* * vnode, however in practice it must be a DEVFS vnode	* \*******************************************************/
end_comment

begin_function
name|int
name|devfs_vntodn
parameter_list|(
name|struct
name|vnode
modifier|*
name|vn_p
parameter_list|,
name|dn_p
modifier|*
name|dn_pp
parameter_list|)
comment|/*proto*/
block|{
name|DBPRINT
argument_list|(
operator|(
literal|"	vntodn "
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vn_p
operator|->
name|v_tag
operator|!=
name|VT_DEVFS
condition|)
block|{
name|printf
argument_list|(
literal|"bad-tag "
argument_list|)
expr_stmt|;
name|Debugger
argument_list|(
literal|"bad-tag "
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|vn_p
operator|->
name|v_usecount
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"not locked! "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|vn_p
operator|->
name|v_type
operator|==
name|VBAD
operator|)
operator|||
operator|(
name|vn_p
operator|->
name|v_type
operator|==
name|VNON
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"bad-type "
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
operator|*
name|dn_pp
operator|=
operator|(
name|dn_p
operator|)
name|vn_p
operator|->
name|v_data
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/***************************************************************\ * given a dev_node, find the appropriate vnode if one is already* * associated, or get a new one an associate it with the dev_node* * need to check about vnode references.. should we increment it?* \***************************************************************/
end_comment

begin_function
name|int
name|devfs_dntovn
parameter_list|(
name|dn_p
name|dnp
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vn_pp
parameter_list|)
comment|/*proto*/
block|{
name|struct
name|vnode
modifier|*
name|vn_p
decl_stmt|,
modifier|*
name|nvp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|vn_p
operator|=
name|dnp
operator|->
name|vn
expr_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"dntovn "
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vn_p
condition|)
block|{
if|if
condition|(
name|vn_p
operator|->
name|v_id
operator|!=
name|dnp
operator|->
name|vn_id
condition|)
block|{
name|printf
argument_list|(
literal|"bad-id "
argument_list|)
expr_stmt|;
goto|goto
name|skip
goto|;
block|}
if|if
condition|(
name|vn_p
operator|->
name|v_tag
operator|!=
name|VT_DEVFS
condition|)
block|{
name|printf
argument_list|(
literal|"bad-tag "
argument_list|)
expr_stmt|;
goto|goto
name|skip
goto|;
block|}
if|if
condition|(
name|vn_p
operator|->
name|v_op
operator|!=
operator|*
operator|(
name|dnp
operator|->
name|ops
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"bad-ops "
argument_list|)
expr_stmt|;
goto|goto
name|skip
goto|;
block|}
if|if
condition|(
call|(
name|dn_p
call|)
argument_list|(
name|vn_p
operator|->
name|v_data
argument_list|)
operator|!=
name|dnp
condition|)
block|{
name|printf
argument_list|(
literal|"bad-rev_link "
argument_list|)
expr_stmt|;
goto|goto
name|skip
goto|;
block|}
if|if
condition|(
name|vn_p
operator|->
name|v_type
operator|!=
name|VNON
condition|)
block|{
name|vget
argument_list|(
name|vn_p
argument_list|,
literal|0
comment|/*lockflag ?*/
argument_list|)
expr_stmt|;
comment|/*XXX*/
operator|*
name|vn_pp
operator|=
name|vn_p
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"bad-type"
argument_list|)
expr_stmt|;
block|}
name|skip
label|:
name|vn_p
operator|=
operator|(
expr|struct
name|vnode
operator|*
operator|)
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|error
operator|=
name|getnewvnode
argument_list|(
name|VT_DEVFS
argument_list|,
name|dnp
operator|->
name|dvm
operator|->
name|mount
argument_list|,
operator|*
operator|(
name|dnp
operator|->
name|ops
operator|)
argument_list|,
operator|&
name|vn_p
argument_list|)
operator|)
condition|)
block|{
name|dnp
operator|->
name|vn
operator|=
name|vn_p
expr_stmt|;
name|dnp
operator|->
name|vn_id
operator|=
name|vn_p
operator|->
name|v_id
expr_stmt|;
operator|*
name|vn_pp
operator|=
name|vn_p
expr_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"(New vnode)"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dnp
operator|->
name|type
condition|)
block|{
case|case
name|DEV_SLNK
case|:
break|break;
case|case
name|DEV_DIR
case|:
if|if
condition|(
name|dnp
operator|->
name|by
operator|.
name|Dir
operator|.
name|parent
operator|==
name|dnp
condition|)
block|{
name|vn_p
operator|->
name|v_flag
operator||=
name|VROOT
expr_stmt|;
block|}
name|vn_p
operator|->
name|v_type
operator|=
name|VDIR
expr_stmt|;
break|break;
case|case
name|DEV_BDEV
case|:
name|vn_p
operator|->
name|v_type
operator|=
name|VBLK
expr_stmt|;
if|if
condition|(
name|nvp
operator|=
name|checkalias
argument_list|(
name|vn_p
argument_list|,
name|dnp
operator|->
name|by
operator|.
name|Bdev
operator|.
name|dev
argument_list|,
operator|(
expr|struct
name|mount
operator|*
operator|)
literal|0
argument_list|)
condition|)
block|{
name|vput
argument_list|(
name|vn_p
argument_list|)
expr_stmt|;
name|vn_p
operator|=
name|nvp
expr_stmt|;
block|}
break|break;
case|case
name|DEV_CDEV
case|:
name|vn_p
operator|->
name|v_type
operator|=
name|VCHR
expr_stmt|;
if|if
condition|(
name|nvp
operator|=
name|checkalias
argument_list|(
name|vn_p
argument_list|,
name|dnp
operator|->
name|by
operator|.
name|Cdev
operator|.
name|dev
argument_list|,
operator|(
expr|struct
name|mount
operator|*
operator|)
literal|0
argument_list|)
condition|)
block|{
name|vput
argument_list|(
name|vn_p
argument_list|)
expr_stmt|;
name|vn_p
operator|=
name|nvp
expr_stmt|;
block|}
break|break;
case|case
name|DEV_DDEV
case|:
break|break;
block|}
if|if
condition|(
name|vn_p
condition|)
block|{
name|vn_p
operator|->
name|v_mount
operator|=
name|dnp
operator|->
name|dvm
operator|->
name|mount
expr_stmt|;
comment|/* XXX Duplicated */
operator|*
name|vn_pp
operator|=
name|vn_p
expr_stmt|;
name|vn_p
operator|->
name|v_data
operator|=
operator|(
name|void
operator|*
operator|)
name|dnp
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
return|return
name|error
return|;
block|}
end_function

end_unit

