begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  Written by Julian Elischer (julian@DIALix.oz.au)  *  *	$Header: /home/ncvs/src/sys/miscfs/devfs/devfs_vnops.c,v 1.43 1997/10/15 13:23:01 phk Exp $  *  * symlinks can wait 'til later.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<miscfs/specfs/specdev.h>
end_include

begin_comment
comment|/* definitions of spec functions we use */
end_comment

begin_include
include|#
directive|include
file|<sys/dirent.h>
end_include

begin_include
include|#
directive|include
file|<miscfs/devfs/devfsdefs.h>
end_include

begin_comment
comment|/*  * Insert description here  */
end_comment

begin_comment
comment|/*  * Convert a component of a pathname into a pointer to a locked node.  * This is a very central and rather complicated routine.  * If the file system is not maintained in a strict tree hierarchy,  * this can result in a deadlock situation (see comments in code below).  *  * The flag argument is LOOKUP, CREATE, RENAME, or DELETE depending on  * whether the name is to be looked up, created, renamed, or deleted.  * When CREATE, RENAME, or DELETE is specified, information usable in  * creating, renaming, or deleting a directory entry may be calculated.  * If flag has LOCKPARENT or'ed into it and the target of the pathname  * exists, lookup returns both the target and its parent directory locked.  * When creating or renaming and LOCKPARENT is specified, the target may  * not be ".".  When deleting and LOCKPARENT is specified, the target may  * be "."., but the caller must check to ensure it does an vrele and DNUNLOCK  * instead of two DNUNLOCKs.  *  * Overall outline of devfs_lookup:  *  *	check accessibility of directory  *	null terminate the component (lookup leaves the whole string alone)  *	look for name in cache, if found, then if at end of path  *	  and deleting or creating, drop it, else return name  *	search for name in directory, to found or notfound  * notfound:  *	if creating, return locked directory,  *	else return error  * found:  *	if at end of path and deleting, return information to allow delete  *	if at end of path and rewriting (RENAME and LOCKPARENT), lock target  *	  node and return info to allow rewrite  *	if not at end, add name to cache; if at end and neither creating  *	  nor deleting, add name to cache  * On return to lookup, remove the null termination we put in at the start.  *  * NOTE: (LOOKUP | LOCKPARENT) currently returns the parent node unlocked.  */
end_comment

begin_function
specifier|static
name|int
name|devfs_lookup
parameter_list|(
name|struct
name|vop_lookup_args
modifier|*
name|ap
parameter_list|)
comment|/*struct vop_lookup_args {                 struct vnode * a_dvp; directory vnode ptr                 struct vnode ** a_vpp; where to put the result                 struct componentname * a_cnp; the name we want         };*/
block|{
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dir_vnode
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
name|struct
name|vnode
modifier|*
modifier|*
name|result_vnode
init|=
name|ap
operator|->
name|a_vpp
decl_stmt|;
name|dn_p
name|dir_node
decl_stmt|;
comment|/* the directory we are searching */
name|dn_p
name|new_node
decl_stmt|;
comment|/* the node we are searching for */
name|devnm_p
name|new_nodename
decl_stmt|;
name|int
name|flags
init|=
name|cnp
operator|->
name|cn_flags
decl_stmt|;
name|int
name|op
init|=
name|cnp
operator|->
name|cn_nameiop
decl_stmt|;
comment|/* LOOKUP, CREATE, RENAME, or DELETE */
name|int
name|lockparent
init|=
name|flags
operator|&
name|LOCKPARENT
decl_stmt|;
name|int
name|wantparent
init|=
name|flags
operator|&
operator|(
name|LOCKPARENT
operator||
name|WANTPARENT
operator|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|cnp
operator|->
name|cn_proc
decl_stmt|;
name|char
name|heldchar
decl_stmt|;
comment|/* the char at the end of the name componet */
operator|*
name|result_vnode
operator|=
name|NULL
expr_stmt|;
comment|/* safe not sorry */
comment|/*XXX*/
name|DBPRINT
argument_list|(
operator|(
literal|"lookup\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir_vnode
operator|->
name|v_usecount
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"dir had no refs "
argument_list|)
expr_stmt|;
if|if
condition|(
name|devfs_vntodn
argument_list|(
name|dir_vnode
argument_list|,
operator|&
name|dir_node
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"vnode has changed?\n"
argument_list|)
expr_stmt|;
name|vprint
argument_list|(
literal|"="
argument_list|,
name|dir_vnode
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * Check accessiblity of directory. 	 */
if|if
condition|(
name|dir_node
operator|->
name|type
operator|!=
name|DEV_DIR
condition|)
comment|/* XXX or symlink? */
block|{
return|return
operator|(
name|ENOTDIR
operator|)
return|;
block|}
if|if
condition|(
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|dir_vnode
argument_list|,
name|VEXEC
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|p
argument_list|)
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * We now have a segment name to search for, and a directory to search. 	 * 	 */
comment|/***********************************************************************\ * SEARCH FOR NAME							* * while making sure the component is null terminated for the strcmp 	* \***********************************************************************/
name|heldchar
operator|=
name|cnp
operator|->
name|cn_nameptr
index|[
name|cnp
operator|->
name|cn_namelen
index|]
expr_stmt|;
name|cnp
operator|->
name|cn_nameptr
index|[
name|cnp
operator|->
name|cn_namelen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|new_nodename
operator|=
name|dev_findname
argument_list|(
name|dir_node
argument_list|,
name|cnp
operator|->
name|cn_nameptr
argument_list|)
expr_stmt|;
name|cnp
operator|->
name|cn_nameptr
index|[
name|cnp
operator|->
name|cn_namelen
index|]
operator|=
name|heldchar
expr_stmt|;
if|if
condition|(
operator|!
name|new_nodename
condition|)
block|{
comment|/*******************************************************\ 		* Failed to find it.. (That may be good)		* 		\*******************************************************/
name|new_node
operator|=
name|NULL
expr_stmt|;
comment|/* to be safe */
comment|/* 		 * If creating, and at end of pathname 		 * then can consider 		 * allowing file to be created. 		 */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|ISLASTCN
operator|)
operator|||
operator|!
operator|(
name|op
operator|==
name|CREATE
operator|||
name|op
operator|==
name|RENAME
operator|)
condition|)
block|{
return|return
name|ENOENT
return|;
block|}
comment|/* 		 * Access for write is interpreted as allowing 		 * creation of files in the directory. 		 */
if|if
condition|(
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|dir_vnode
argument_list|,
name|VWRITE
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|p
argument_list|)
condition|)
block|{
name|DBPRINT
argument_list|(
operator|(
literal|"MKACCESS "
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 		 * We return with the directory locked, so that 		 * the parameters we set up above will still be 		 * valid if we actually decide to add a new entry. 		 * We return ni_vp == NULL to indicate that the entry 		 * does not currently exist; we leave a pointer to 		 * the (locked) directory vnode in namei_data->ni_dvp. 		 * The pathname buffer is saved so that the name 		 * can be obtained later. 		 * 		 * NB - if the directory is unlocked, then this 		 * information cannot be used. 		 */
name|cnp
operator|->
name|cn_flags
operator||=
name|SAVENAME
expr_stmt|;
comment|/*XXX why? */
if|if
condition|(
operator|!
name|lockparent
condition|)
name|VOP_UNLOCK
argument_list|(
name|dir_vnode
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|EJUSTRETURN
operator|)
return|;
block|}
comment|/***************************************************************\ 	* Found it.. this is not always a good thing..			* 	\***************************************************************/
name|new_node
operator|=
name|new_nodename
operator|->
name|dnp
expr_stmt|;
name|new_node
operator|->
name|last_lookup
operator|=
name|new_nodename
expr_stmt|;
comment|/* for unlink */
comment|/* 	 * If deleting, and at end of pathname, return 	 * parameters which can be used to remove file. 	 * If the wantparent flag isn't set, we return only 	 * the directory (in namei_data->ni_dvp), otherwise we go 	 * on and lock the node, being careful with ".". 	 */
if|if
condition|(
name|op
operator|==
name|DELETE
operator|&&
operator|(
name|flags
operator|&
name|ISLASTCN
operator|)
condition|)
block|{
comment|/* 		 * Write access to directory required to delete files. 		 */
if|if
condition|(
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|dir_vnode
argument_list|,
name|VWRITE
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|p
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 		 * we are trying to delete '.'.  What does this mean? XXX 		 */
if|if
condition|(
name|dir_node
operator|==
name|new_node
condition|)
block|{
name|VREF
argument_list|(
name|dir_vnode
argument_list|)
expr_stmt|;
operator|*
name|result_vnode
operator|=
name|dir_vnode
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 		 * If directory is "sticky", then user must own 		 * the directory, or the file in it, else she 		 * may not delete it (unless she's root). This 		 * implements append-only directories. 		 */
name|devfs_dntovn
argument_list|(
name|new_node
argument_list|,
name|result_vnode
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NOTYET
if|if
condition|(
operator|(
name|dir_node
operator|->
name|mode
operator|&
name|ISVTX
operator|)
operator|&&
name|cnp
operator|->
name|cn_cred
operator|->
name|cr_uid
operator|!=
literal|0
operator|&&
name|cnp
operator|->
name|cn_cred
operator|->
name|cr_uid
operator|!=
name|dir_node
operator|->
name|uid
operator|&&
name|cnp
operator|->
name|cn_cred
operator|->
name|cr_uid
operator|!=
name|new_node
operator|->
name|uid
condition|)
block|{
name|VOP_UNLOCK
argument_list|(
operator|*
name|result_vnode
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|lockparent
condition|)
name|VOP_UNLOCK
argument_list|(
name|dir_vnode
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If rewriting (RENAME), return the vnode and the 	 * information required to rewrite the present directory 	 * Must get node of directory entry to verify it's a 	 * regular file, or empty directory. 	 */
if|if
condition|(
name|op
operator|==
name|RENAME
operator|&&
name|wantparent
operator|&&
operator|(
name|flags
operator|&
name|ISLASTCN
operator|)
condition|)
block|{
comment|/* 		 * Are we allowed to change the holding directory? 		 */
if|if
condition|(
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|dir_vnode
argument_list|,
name|VWRITE
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|p
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 		 * Careful about locking second node. 		 * This can only occur if the target is ".". 		 */
if|if
condition|(
name|dir_node
operator|==
name|new_node
condition|)
return|return
operator|(
name|EISDIR
operator|)
return|;
name|devfs_dntovn
argument_list|(
name|new_node
argument_list|,
name|result_vnode
argument_list|)
expr_stmt|;
comment|/* hmm save the 'from' name (we need to delete it) */
name|cnp
operator|->
name|cn_flags
operator||=
name|SAVENAME
expr_stmt|;
if|if
condition|(
operator|!
name|lockparent
condition|)
name|VOP_UNLOCK
argument_list|(
name|dir_vnode
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Step through the translation in the name.  We do not unlock the 	 * directory because we may need it again if a symbolic link 	 * is relative to the current directory.  Instead we save it 	 * unlocked as "saved_dir_node" XXX.  We must get the target 	 * node before unlocking 	 * the directory to insure that the node will not be removed 	 * before we get it.  We prevent deadlock by always fetching 	 * nodes from the root, moving down the directory tree. Thus 	 * when following backward pointers ".." we must unlock the 	 * parent directory before getting the requested directory. 	 * There is a potential race condition here if both the current 	 * and parent directories are removed before the lock for the 	 * node associated with ".." returns.  We hope that this occurs 	 * infrequently since we cannot avoid this race condition without 	 * implementing a sophisticated deadlock detection algorithm. 	 * Note also that this simple deadlock detection scheme will not 	 * work if the file system has any hard links other than ".." 	 * that point backwards in the directory structure. 	 */
if|if
condition|(
name|flags
operator|&
name|ISDOTDOT
condition|)
block|{
name|VOP_UNLOCK
argument_list|(
name|dir_vnode
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* race to get the node */
name|devfs_dntovn
argument_list|(
name|new_node
argument_list|,
name|result_vnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|lockparent
operator|&&
operator|(
name|flags
operator|&
name|ISLASTCN
operator|)
condition|)
name|vn_lock
argument_list|(
name|dir_vnode
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dir_node
operator|==
name|new_node
condition|)
block|{
name|VREF
argument_list|(
name|dir_vnode
argument_list|)
expr_stmt|;
comment|/* we want ourself, ie "." */
operator|*
name|result_vnode
operator|=
name|dir_vnode
expr_stmt|;
block|}
else|else
block|{
name|devfs_dntovn
argument_list|(
name|new_node
argument_list|,
name|result_vnode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lockparent
operator|||
operator|(
name|flags
operator|&
name|ISLASTCN
operator|)
condition|)
name|VOP_UNLOCK
argument_list|(
name|dir_vnode
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|DBPRINT
argument_list|(
operator|(
literal|"GOT\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Create a regular file.  *  We must also free the pathname buffer pointed at  *  by ndp->ni_pnbuf, always on error, or only if the  *  SAVESTART bit in ni_nameiop is clear on success.  *<still true in 4.4?>  *  *  Always  error... no such thing in this FS  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_function
specifier|static
name|int
name|devfs_create
parameter_list|(
name|struct
name|vop_mknod_args
modifier|*
name|ap
parameter_list|)
comment|/*struct vop_mknod_args  {                 struct vnode *a_dvp;                 struct vnode **a_vpp;                 struct componentname *a_cnp;                 struct vattr *a_vap;         } */
block|{
name|DBPRINT
argument_list|(
operator|(
literal|"create\n"
operator|)
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|devfs_mknod
parameter_list|(
name|struct
name|vop_mknod_args
modifier|*
name|ap
parameter_list|)
comment|/*struct vop_mknod_args  {                 struct vnode *a_dvp;                 struct vnode **a_vpp;                 struct componentname *a_cnp;                 struct vattr *a_vap;         } */
block|{
name|int
name|error
decl_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"mknod\n"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ap
operator|->
name|a_vap
operator|->
name|va_type
condition|)
block|{
case|case
name|VDIR
case|:
ifdef|#
directive|ifdef
name|VNSLEAZE
return|return
name|devfs_mkdir
argument_list|(
name|ap
argument_list|)
return|;
comment|/*XXX check for WILLRELE settings (different)*/
else|#
directive|else
name|error
operator|=
name|VOP_MKDIR
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|,
name|ap
operator|->
name|a_vpp
argument_list|,
name|ap
operator|->
name|a_cnp
argument_list|,
name|ap
operator|->
name|a_vap
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
comment|/*  *  devfs_create() sets ndp->ni_vp.  */
case|case
name|VREG
case|:
ifdef|#
directive|ifdef
name|VNSLEAZE
return|return
name|devfs_create
argument_list|(
name|ap
argument_list|)
return|;
comment|/*XXX check for WILLRELE settings (different)*/
else|#
directive|else
name|error
operator|=
name|VOP_CREATE
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|,
name|ap
operator|->
name|a_vpp
argument_list|,
name|ap
operator|->
name|a_cnp
argument_list|,
name|ap
operator|->
name|a_vap
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
return|return
name|EINVAL
return|;
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* notyet */
end_comment

begin_function
specifier|static
name|int
name|devfs_open
parameter_list|(
name|struct
name|vop_open_args
modifier|*
name|ap
parameter_list|)
comment|/*struct vop_open_args  {                 struct vnode *a_vp;                 int  a_mode;                 struct ucred *a_cred;                 struct proc *a_p;         } */
block|{
name|DBPRINT
argument_list|(
operator|(
literal|"open\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_function
specifier|static
name|int
name|devfs_close
parameter_list|(
name|struct
name|vop_close_args
modifier|*
name|ap
parameter_list|)
comment|/*struct vop_close_args  {                 struct vnode *a_vp;                 int  a_fflag;                 struct ucred *a_cred;                 struct proc *a_p;         } */
block|{
name|DBPRINT
argument_list|(
operator|(
literal|"close\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* notyet */
end_comment

begin_function
specifier|static
name|int
name|devfs_access
parameter_list|(
name|struct
name|vop_access_args
modifier|*
name|ap
parameter_list|)
comment|/*struct vop_access_args  {                 struct vnode *a_vp;                 int  a_mode;                 struct ucred *a_cred;                 struct proc *a_p;         } */
block|{
comment|/*  	 *  mode is filled with a combination of VREAD, VWRITE,  	 *  and/or VEXEC bits turned on.  In an octal number these  	 *  are the Y in 0Y00.  	 */
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|int
name|mode
init|=
name|ap
operator|->
name|a_mode
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|ap
operator|->
name|a_cred
decl_stmt|;
name|dn_p
name|file_node
decl_stmt|;
name|int
name|error
decl_stmt|;
name|gid_t
modifier|*
name|gp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"access\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|devfs_vntodn
argument_list|(
name|vp
argument_list|,
operator|&
name|file_node
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"devfs_vntodn returned %d "
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/*  	 * if we are not running as a process, we are in the  	 * kernel and we DO have permission 	 */
if|if
condition|(
name|ap
operator|->
name|a_p
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* 	 * Access check is based on only one of owner, group, public. 	 * If not owner, then check group. If not a member of the 	 * group, then check public access. 	 */
if|if
condition|(
name|cred
operator|->
name|cr_uid
operator|!=
name|file_node
operator|->
name|uid
condition|)
block|{
comment|/* failing that.. try groups */
name|mode
operator|>>=
literal|3
expr_stmt|;
name|gp
operator|=
name|cred
operator|->
name|cr_groups
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cred
operator|->
name|cr_ngroups
condition|;
name|i
operator|++
operator|,
name|gp
operator|++
control|)
block|{
if|if
condition|(
name|file_node
operator|->
name|gid
operator|==
operator|*
name|gp
condition|)
block|{
goto|goto
name|found
goto|;
block|}
block|}
comment|/* failing that.. try general access */
name|mode
operator|>>=
literal|3
expr_stmt|;
name|found
label|:
empty_stmt|;
block|}
if|if
condition|(
operator|(
name|file_node
operator|->
name|mode
operator|&
name|mode
operator|)
operator|==
name|mode
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 *  Root gets to do anything. 	 * but only use suser prives as a last resort 	 * (Use of super powers is recorded in ap->a_p->p_acflag) 	 */
if|if
condition|(
name|suser
argument_list|(
name|cred
argument_list|,
operator|&
name|ap
operator|->
name|a_p
operator|->
name|p_acflag
argument_list|)
operator|==
literal|0
condition|)
comment|/* XXX what if no proc? */
return|return
literal|0
return|;
return|return
operator|(
name|EACCES
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|devfs_getattr
parameter_list|(
name|struct
name|vop_getattr_args
modifier|*
name|ap
parameter_list|)
comment|/*struct vop_getattr_args {                 struct vnode *a_vp;                 struct vattr *a_vap;                 struct ucred *a_cred;                 struct proc *a_p;         } */
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|vattr
modifier|*
name|vap
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|dn_p
name|file_node
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"getattr\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|devfs_vntodn
argument_list|(
name|vp
argument_list|,
operator|&
name|file_node
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"devfs_vntodn returned %d "
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|vap
operator|->
name|va_rdev
operator|=
literal|0
expr_stmt|;
comment|/* default value only */
name|vap
operator|->
name|va_mode
operator|=
name|file_node
operator|->
name|mode
expr_stmt|;
switch|switch
condition|(
name|file_node
operator|->
name|type
condition|)
block|{
case|case
name|DEV_DIR
case|:
name|vap
operator|->
name|va_rdev
operator|=
operator|(
name|dev_t
operator|)
name|file_node
operator|->
name|dvm
expr_stmt|;
name|vap
operator|->
name|va_mode
operator||=
operator|(
name|S_IFDIR
operator|)
expr_stmt|;
break|break;
case|case
name|DEV_CDEV
case|:
name|vap
operator|->
name|va_rdev
operator|=
name|file_node
operator|->
name|by
operator|.
name|Cdev
operator|.
name|dev
expr_stmt|;
name|vap
operator|->
name|va_mode
operator||=
operator|(
name|S_IFCHR
operator|)
expr_stmt|;
break|break;
case|case
name|DEV_BDEV
case|:
name|vap
operator|->
name|va_rdev
operator|=
name|file_node
operator|->
name|by
operator|.
name|Bdev
operator|.
name|dev
expr_stmt|;
name|vap
operator|->
name|va_mode
operator||=
operator|(
name|S_IFBLK
operator|)
expr_stmt|;
break|break;
case|case
name|DEV_SLNK
case|:
break|break;
block|}
name|vap
operator|->
name|va_type
operator|=
name|vp
operator|->
name|v_type
expr_stmt|;
name|vap
operator|->
name|va_nlink
operator|=
name|file_node
operator|->
name|links
expr_stmt|;
name|vap
operator|->
name|va_uid
operator|=
name|file_node
operator|->
name|uid
expr_stmt|;
name|vap
operator|->
name|va_gid
operator|=
name|file_node
operator|->
name|gid
expr_stmt|;
name|vap
operator|->
name|va_fsid
operator|=
operator|(
name|long
operator|)
name|file_node
operator|->
name|dvm
expr_stmt|;
name|vap
operator|->
name|va_fileid
operator|=
operator|(
name|long
operator|)
name|file_node
expr_stmt|;
name|vap
operator|->
name|va_size
operator|=
name|file_node
operator|->
name|len
expr_stmt|;
comment|/* now a u_quad_t */
name|vap
operator|->
name|va_blocksize
operator|=
literal|512
expr_stmt|;
if|if
condition|(
name|file_node
operator|->
name|ctime
operator|.
name|tv_sec
condition|)
block|{
name|vap
operator|->
name|va_ctime
operator|=
name|file_node
operator|->
name|ctime
expr_stmt|;
block|}
else|else
block|{
name|TIMEVAL_TO_TIMESPEC
argument_list|(
operator|&
name|boottime
argument_list|,
operator|&
operator|(
name|vap
operator|->
name|va_ctime
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|file_node
operator|->
name|mtime
operator|.
name|tv_sec
condition|)
block|{
name|vap
operator|->
name|va_mtime
operator|=
name|file_node
operator|->
name|mtime
expr_stmt|;
block|}
else|else
block|{
name|TIMEVAL_TO_TIMESPEC
argument_list|(
operator|&
name|boottime
argument_list|,
operator|&
operator|(
name|vap
operator|->
name|va_mtime
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|file_node
operator|->
name|atime
operator|.
name|tv_sec
condition|)
block|{
name|vap
operator|->
name|va_atime
operator|=
name|file_node
operator|->
name|atime
expr_stmt|;
block|}
else|else
block|{
name|TIMEVAL_TO_TIMESPEC
argument_list|(
operator|&
name|boottime
argument_list|,
operator|&
operator|(
name|vap
operator|->
name|va_atime
operator|)
argument_list|)
expr_stmt|;
block|}
name|vap
operator|->
name|va_gen
operator|=
literal|0
expr_stmt|;
name|vap
operator|->
name|va_flags
operator|=
literal|0
expr_stmt|;
name|vap
operator|->
name|va_bytes
operator|=
name|file_node
operator|->
name|len
expr_stmt|;
comment|/* u_quad_t */
name|vap
operator|->
name|va_filerev
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
comment|/* u_quad_t */
name|vap
operator|->
name|va_vaflags
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|devfs_setattr
parameter_list|(
name|struct
name|vop_setattr_args
modifier|*
name|ap
parameter_list|)
comment|/*struct vop_setattr_args  {                 struct vnode *a_vp;                 struct vattr *a_vap;                 struct ucred *a_cred;                 struct proc *a_p;         } */
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|vattr
modifier|*
name|vap
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|ap
operator|->
name|a_cred
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|ap
operator|->
name|a_p
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|gid_t
modifier|*
name|gp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|dn_p
name|file_node
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
if|if
condition|(
name|error
operator|=
name|devfs_vntodn
argument_list|(
name|vp
argument_list|,
operator|&
name|file_node
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"devfs_vntodn returned %d "
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|DBPRINT
argument_list|(
operator|(
literal|"setattr\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vap
operator|->
name|va_type
operator|!=
name|VNON
operator|)
operator|||
operator|(
name|vap
operator|->
name|va_nlink
operator|!=
name|VNOVAL
operator|)
operator|||
operator|(
name|vap
operator|->
name|va_fsid
operator|!=
name|VNOVAL
operator|)
operator|||
operator|(
name|vap
operator|->
name|va_fileid
operator|!=
name|VNOVAL
operator|)
operator|||
operator|(
name|vap
operator|->
name|va_blocksize
operator|!=
name|VNOVAL
operator|)
operator|||
operator|(
name|vap
operator|->
name|va_rdev
operator|!=
name|VNOVAL
operator|)
operator|||
operator|(
name|vap
operator|->
name|va_bytes
operator|!=
name|VNOVAL
operator|)
operator|||
operator|(
name|vap
operator|->
name|va_gen
operator|!=
name|VNOVAL
operator|)
condition|)
block|{
return|return
name|EINVAL
return|;
block|}
comment|/*  	 * Anyone can touch the files in such a way that the times are set 	 * to NOW (e.g. run 'touch') if they have write permissions 	 * however only the owner or root can set "un-natural times. 	 * They also don't need write permissions. 	 */
if|if
condition|(
name|vap
operator|->
name|va_atime
operator|.
name|tv_sec
operator|!=
name|VNOVAL
operator|||
name|vap
operator|->
name|va_mtime
operator|.
name|tv_sec
operator|!=
name|VNOVAL
condition|)
block|{
if|#
directive|if
literal|0
comment|/* 		 * This next test is pointless under devfs for now.. 		 * as there is only one devfs hiding under potentially many 		 * mountpoints and actual device node are really 'mounted' under 		 * a FAKE mountpoint inside the kernel only, no matter where it 		 * APPEARS they are mounted to the outside world.. 		 * A readonly devfs doesn't exist anyway. 		 */
block|if (vp->v_mount->mnt_flag& MNT_RDONLY) 			return (EROFS);
endif|#
directive|endif
if|if
condition|(
operator|(
operator|(
name|vap
operator|->
name|va_vaflags
operator|&
name|VA_UTIMES_NULL
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|cred
operator|->
name|cr_uid
operator|!=
name|file_node
operator|->
name|uid
operator|)
operator|&&
name|suser
argument_list|(
name|cred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
if|if
condition|(
name|VOP_ACCESS
argument_list|(
name|vp
argument_list|,
name|VWRITE
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
condition|)
return|return
operator|(
name|EACCES
operator|)
return|;
name|file_node
operator|->
name|atime
operator|=
name|vap
operator|->
name|va_atime
expr_stmt|;
name|file_node
operator|->
name|mtime
operator|=
name|vap
operator|->
name|va_mtime
expr_stmt|;
name|microtime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|TIMEVAL_TO_TIMESPEC
argument_list|(
operator|&
name|tv
argument_list|,
operator|&
name|file_node
operator|->
name|ctime
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Change the permissions.. must be root or owner to do this. 	 */
if|if
condition|(
name|vap
operator|->
name|va_mode
operator|!=
operator|(
name|u_short
operator|)
name|VNOVAL
condition|)
block|{
if|if
condition|(
operator|(
name|cred
operator|->
name|cr_uid
operator|!=
name|file_node
operator|->
name|uid
operator|)
operator|&&
name|suser
argument_list|(
name|cred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
comment|/* set drwxwxrwx stuff */
name|file_node
operator|->
name|mode
operator|&=
operator|~
literal|07777
expr_stmt|;
name|file_node
operator|->
name|mode
operator||=
name|vap
operator|->
name|va_mode
operator|&
literal|07777
expr_stmt|;
block|}
comment|/* 	 * Change the owner.. must be root to do this. 	 */
if|if
condition|(
name|vap
operator|->
name|va_uid
operator|!=
operator|(
name|uid_t
operator|)
name|VNOVAL
condition|)
block|{
if|if
condition|(
name|suser
argument_list|(
name|cred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|file_node
operator|->
name|uid
operator|=
name|vap
operator|->
name|va_uid
expr_stmt|;
block|}
comment|/* 	 * Change the group.. must be root or owner to do this. 	 * If we are the owner, we must be in the target group too. 	 * don't use suser() unless you have to as it reports 	 * whether you needed suser powers or not. 	 */
if|if
condition|(
name|vap
operator|->
name|va_gid
operator|!=
operator|(
name|gid_t
operator|)
name|VNOVAL
condition|)
block|{
if|if
condition|(
name|cred
operator|->
name|cr_uid
operator|==
name|file_node
operator|->
name|uid
condition|)
block|{
name|gp
operator|=
name|cred
operator|->
name|cr_groups
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cred
operator|->
name|cr_ngroups
condition|;
name|i
operator|++
operator|,
name|gp
operator|++
control|)
block|{
if|if
condition|(
name|vap
operator|->
name|va_gid
operator|==
operator|*
name|gp
condition|)
goto|goto
name|cando
goto|;
block|}
block|}
comment|/* 		 * we can't do it with normal privs, 		 * do we have an ace up our sleeve? 		 */
if|if
condition|(
name|suser
argument_list|(
name|cred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|cando
label|:
name|file_node
operator|->
name|gid
operator|=
name|vap
operator|->
name|va_gid
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/*  	 * Copied from somewhere else 	 * but only kept as a marker and reminder of the fact that 	 * flags should be handled some day 	 */
block|if (vap->va_flags != VNOVAL) { 		if (error = suser(cred,&p->p_acflag)) 			return error; 		if (cred->cr_uid == 0) 		; 		else { 		} 	}
endif|#
directive|endif
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|devfs_read
parameter_list|(
name|struct
name|vop_read_args
modifier|*
name|ap
parameter_list|)
comment|/*struct vop_read_args {                 struct vnode *a_vp;                 struct uio *a_uio;                 int  a_ioflag;                 struct ucred *a_cred;         } */
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|dn_p
name|file_node
decl_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"read\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|devfs_vntodn
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
operator|&
name|file_node
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"devfs_vntodn returned %d "
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
switch|switch
condition|(
name|ap
operator|->
name|a_vp
operator|->
name|v_type
condition|)
block|{
case|case
name|VREG
case|:
return|return
operator|(
name|EINVAL
operator|)
return|;
case|case
name|VDIR
case|:
return|return
name|VOP_READDIR
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|ap
operator|->
name|a_uio
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
case|case
name|VCHR
case|:
case|case
name|VBLK
case|:
name|error
operator|=
name|VOCALL
argument_list|(
name|spec_vnodeop_p
argument_list|,
name|VOFFSET
argument_list|(
name|vop_read
argument_list|)
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|TIMEVAL_TO_TIMESPEC
argument_list|(
argument|&time
argument_list|,
argument|&(file_node->atime)
argument_list|)
return|return
operator|(
name|error
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"devfs_read(): bad file type"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  *  Write data to a file or directory.  */
end_comment

begin_function
specifier|static
name|int
name|devfs_write
parameter_list|(
name|struct
name|vop_write_args
modifier|*
name|ap
parameter_list|)
comment|/*struct vop_write_args  {                 struct vnode *a_vp;                 struct uio *a_uio;                 int  a_ioflag;                 struct ucred *a_cred;         } */
block|{
name|dn_p
name|file_node
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"write\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|devfs_vntodn
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
operator|&
name|file_node
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"devfs_vntodn returned %d "
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
switch|switch
condition|(
name|ap
operator|->
name|a_vp
operator|->
name|v_type
condition|)
block|{
case|case
name|VREG
case|:
return|return
operator|(
name|EINVAL
operator|)
return|;
case|case
name|VDIR
case|:
return|return
operator|(
name|EISDIR
operator|)
return|;
case|case
name|VCHR
case|:
case|case
name|VBLK
case|:
name|error
operator|=
name|VOCALL
argument_list|(
name|spec_vnodeop_p
argument_list|,
name|VOFFSET
argument_list|(
name|vop_write
argument_list|)
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|TIMEVAL_TO_TIMESPEC
argument_list|(
argument|&time
argument_list|,
argument|&(file_node->mtime)
argument_list|)
return|return
operator|(
name|error
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"devfs_write(): bad file type"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* presently not called from devices anyhow */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_function
specifier|static
name|int
name|devfs_ioctl
parameter_list|(
name|struct
name|vop_ioctl_args
modifier|*
name|ap
parameter_list|)
comment|/*struct vop_ioctl_args  {                 struct vnode *a_vp;                 int  a_command;                 caddr_t  a_data;                 int  a_fflag;                 struct ucred *a_cred;                 struct proc *a_p;         } */
block|{
name|DBPRINT
argument_list|(
operator|(
literal|"ioctl\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ENOTTY
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|devfs_select
parameter_list|(
name|struct
name|vop_select_args
modifier|*
name|ap
parameter_list|)
comment|/*struct vop_select_args {                 struct vnode *a_vp;                 int  a_which;                 int  a_fflags;                 struct ucred *a_cred;                 struct proc *a_p;         } */
block|{
name|DBPRINT
argument_list|(
operator|(
literal|"select\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* filesystems never block? */
block|}
end_function

begin_function
specifier|static
name|int
name|devfs_mmap
parameter_list|(
name|struct
name|vop_mmap_args
modifier|*
name|ap
parameter_list|)
comment|/*struct vop_mmap_args  {                 struct vnode *a_vp;                 int  a_fflags;                 struct ucred *a_cred;                 struct proc *a_p;         } */
block|{
name|DBPRINT
argument_list|(
operator|(
literal|"mmap\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
end_function

begin_comment
comment|/*  *  Flush the blocks of a file to disk.  */
end_comment

begin_function
specifier|static
name|int
name|devfs_fsync
parameter_list|(
name|struct
name|vop_fsync_args
modifier|*
name|ap
parameter_list|)
comment|/*struct vop_fsync_args {                 struct vnode *a_vp;                 struct ucred *a_cred;                 int  a_waitfor;                 struct proc *a_p;         } */
block|{
name|DBPRINT
argument_list|(
operator|(
literal|"fsync\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|devfs_seek
parameter_list|(
name|struct
name|vop_seek_args
modifier|*
name|ap
parameter_list|)
comment|/*struct vop_seek_args  {                 struct vnode *a_vp;                 off_t  a_oldoff;                 off_t  a_newoff;                 struct ucred *a_cred;         } */
block|{
name|DBPRINT
argument_list|(
operator|(
literal|"seek\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* notyet */
end_comment

begin_function
specifier|static
name|int
name|devfs_remove
parameter_list|(
name|struct
name|vop_remove_args
modifier|*
name|ap
parameter_list|)
comment|/*struct vop_remove_args  {                 struct vnode *a_dvp;                 struct vnode *a_vp;                 struct componentname *a_cnp;         } */
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|dn_p
name|tp
decl_stmt|,
name|tdp
decl_stmt|;
name|devnm_p
name|tnp
decl_stmt|;
name|int
name|doingdirectory
init|=
literal|0
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|uid_t
name|ouruid
init|=
name|cnp
operator|->
name|cn_cred
operator|->
name|cr_uid
decl_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"remove\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Lock our directories and get our name pointers 	 * assume that the names are null terminated as they 	 * are the end of the path. Get pointers to all our 	 * devfs structures. 	 */
if|if
condition|(
name|error
operator|=
name|devfs_vntodn
argument_list|(
name|dvp
argument_list|,
operator|&
name|tdp
argument_list|)
condition|)
block|{
name|abortit
label|:
name|VOP_ABORTOP
argument_list|(
name|dvp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dvp
operator|==
name|vp
condition|)
comment|/* eh? */
name|vrele
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
else|else
name|vput
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
condition|)
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|error
operator|=
name|devfs_vntodn
argument_list|(
name|vp
argument_list|,
operator|&
name|tp
argument_list|)
condition|)
goto|goto
name|abortit
goto|;
comment|/* 	 * Assuming we are atomic, dev_lookup left this for us 	 */
name|tnp
operator|=
name|tp
operator|->
name|last_lookup
expr_stmt|;
comment|/* 	 * Check we are doing legal things WRT the new flags 	 */
if|if
condition|(
operator|(
name|tp
operator|->
name|flags
operator|&
operator|(
name|IMMUTABLE
operator||
name|APPEND
operator|)
operator|)
operator|||
operator|(
name|tdp
operator|->
name|flags
operator|&
name|APPEND
operator|)
comment|/*XXX eh?*/
condition|)
block|{
name|error
operator|=
name|EPERM
expr_stmt|;
goto|goto
name|abortit
goto|;
block|}
comment|/* 	 * Make sure that we don't try do something stupid 	 */
if|if
condition|(
operator|(
name|tp
operator|->
name|type
operator|)
operator|==
name|DEV_DIR
condition|)
block|{
comment|/* 		 * Avoid ".", "..", and aliases of "." for obvious reasons. 		 */
if|if
condition|(
operator|(
name|cnp
operator|->
name|cn_namelen
operator|==
literal|1
operator|&&
name|cnp
operator|->
name|cn_nameptr
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
operator|||
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|ISDOTDOT
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|abortit
goto|;
block|}
name|doingdirectory
operator|++
expr_stmt|;
block|}
comment|/*********************************** 	 * Start actually doing things.... * 	 ***********************************/
name|TIMEVAL_TO_TIMESPEC
argument_list|(
operator|&
name|time
argument_list|,
operator|&
operator|(
name|tdp
operator|->
name|mtime
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * own the parent directory, or the destination of the rename, 	 * otherwise the destination may not be changed (except by 	 * root). This implements append-only directories. 	 * XXX shoudn't this be in generic code?  	 */
if|if
condition|(
operator|(
name|tdp
operator|->
name|mode
operator|&
name|S_ISTXT
operator|)
operator|&&
name|ouruid
operator|!=
literal|0
operator|&&
name|ouruid
operator|!=
name|tdp
operator|->
name|uid
operator|&&
name|ouruid
operator|!=
name|tp
operator|->
name|uid
condition|)
block|{
name|error
operator|=
name|EPERM
expr_stmt|;
goto|goto
name|abortit
goto|;
block|}
comment|/* 	 * Target must be empty if a directory and have no links 	 * to it. Also, ensure source and target are compatible 	 * (both directories, or both not directories). 	 */
if|if
condition|(
operator|(
name|doingdirectory
operator|)
operator|&&
operator|(
name|tp
operator|->
name|links
operator|>
literal|2
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"nlink = %d\n"
argument_list|,
name|tp
operator|->
name|links
argument_list|)
expr_stmt|;
comment|/*XXX*/
name|error
operator|=
name|ENOTEMPTY
expr_stmt|;
goto|goto
name|abortit
goto|;
block|}
name|dev_free_name
argument_list|(
name|tnp
argument_list|)
expr_stmt|;
name|tp
operator|=
name|NULL
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  */
end_comment

begin_function
specifier|static
name|int
name|devfs_link
parameter_list|(
name|struct
name|vop_link_args
modifier|*
name|ap
parameter_list|)
comment|/*struct vop_link_args  {                 struct vnode *a_tdvp;                 struct vnode *a_vp;                 struct componentname *a_cnp;         } */
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|tdvp
init|=
name|ap
operator|->
name|a_tdvp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|dn_p
name|fp
decl_stmt|,
name|tdp
decl_stmt|;
name|devnm_p
name|tnp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"link\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * First catch an arbitrary restriction for this FS 	 */
if|if
condition|(
name|cnp
operator|->
name|cn_namelen
operator|>
name|DEVMAXNAMESIZE
condition|)
block|{
name|error
operator|=
name|ENAMETOOLONG
expr_stmt|;
goto|goto
name|abortit
goto|;
block|}
comment|/* 	 * Lock our directories and get our name pointers 	 * assume that the names are null terminated as they 	 * are the end of the path. Get pointers to all our 	 * devfs structures. 	 */
if|if
condition|(
name|error
operator|=
name|devfs_vntodn
argument_list|(
name|tdvp
argument_list|,
operator|&
name|tdp
argument_list|)
condition|)
goto|goto
name|abortit
goto|;
if|if
condition|(
name|error
operator|=
name|devfs_vntodn
argument_list|(
name|vp
argument_list|,
operator|&
name|fp
argument_list|)
condition|)
goto|goto
name|abortit
goto|;
comment|/* 	 * trying to move it out of devfs? (v_tag == VT_DEVFS) 	 */
if|if
condition|(
operator|(
name|vp
operator|->
name|v_tag
operator|!=
name|VT_DEVFS
operator|)
operator|||
operator|(
name|vp
operator|->
name|v_tag
operator|!=
name|tdvp
operator|->
name|v_tag
operator|)
condition|)
block|{
name|error
operator|=
name|EXDEV
expr_stmt|;
name|abortit
label|:
name|VOP_ABORTOP
argument_list|(
name|tdvp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Check we are doing legal things WRT the new flags 	 */
if|if
condition|(
name|fp
operator|->
name|flags
operator|&
operator|(
name|IMMUTABLE
operator||
name|APPEND
operator|)
condition|)
block|{
name|error
operator|=
name|EPERM
expr_stmt|;
goto|goto
name|abortit
goto|;
block|}
comment|/*********************************** 	 * Start actually doing things.... * 	 ***********************************/
name|TIMEVAL_TO_TIMESPEC
argument_list|(
operator|&
name|time
argument_list|,
operator|&
operator|(
name|tdp
operator|->
name|atime
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|dev_add_name
argument_list|(
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|tdp
argument_list|,
name|NULL
argument_list|,
name|fp
argument_list|,
operator|&
name|tnp
argument_list|)
expr_stmt|;
name|out
label|:
name|vput
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Rename system call. Seems overly complicated to me...  * 	rename("foo", "bar");  * is essentially  *	unlink("bar");  *	link("foo", "bar");  *	unlink("foo");  * but ``atomically''.  *  * When the target exists, both the directory  * and target vnodes are locked.  * the source and source-parent vnodes are referenced  *  *  * Basic algorithm is:  *  * 1) Bump link count on source while we're linking it to the  *    target.  This also ensure the inode won't be deleted out  *    from underneath us while we work (it may be truncated by  *    a concurrent `trunc' or `open' for creation).  * 2) Link source to destination.  If destination already exists,  *    delete it first.  * 3) Unlink source reference to node if still around. If a  *    directory was moved and the parent of the destination  *    is different from the source, patch the ".." entry in the  *    directory.  */
end_comment

begin_function
specifier|static
name|int
name|devfs_rename
parameter_list|(
name|struct
name|vop_rename_args
modifier|*
name|ap
parameter_list|)
comment|/*struct vop_rename_args  {                 struct vnode *a_fdvp;                 struct vnode *a_fvp;                 struct componentname *a_fcnp;                 struct vnode *a_tdvp;                 struct vnode *a_tvp;                 struct componentname *a_tcnp;         } */
block|{
name|struct
name|vnode
modifier|*
name|tvp
init|=
name|ap
operator|->
name|a_tvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|tdvp
init|=
name|ap
operator|->
name|a_tdvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|fvp
init|=
name|ap
operator|->
name|a_fvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|fdvp
init|=
name|ap
operator|->
name|a_fdvp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|tcnp
init|=
name|ap
operator|->
name|a_tcnp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|fcnp
init|=
name|ap
operator|->
name|a_fcnp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|fcnp
operator|->
name|cn_proc
decl_stmt|;
name|dn_p
name|fp
decl_stmt|,
name|fdp
decl_stmt|,
name|tp
decl_stmt|,
name|tdp
decl_stmt|;
name|devnm_p
name|fnp
decl_stmt|,
name|tnp
decl_stmt|;
name|int
name|doingdirectory
init|=
literal|0
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* 	 * First catch an arbitrary restriction for this FS 	 */
if|if
condition|(
name|tcnp
operator|->
name|cn_namelen
operator|>
name|DEVMAXNAMESIZE
condition|)
block|{
name|error
operator|=
name|ENAMETOOLONG
expr_stmt|;
goto|goto
name|abortit
goto|;
block|}
comment|/* 	 * Lock our directories and get our name pointers 	 * assume that the names are null terminated as they 	 * are the end of the path. Get pointers to all our 	 * devfs structures. 	 */
if|if
condition|(
name|error
operator|=
name|devfs_vntodn
argument_list|(
name|tdvp
argument_list|,
operator|&
name|tdp
argument_list|)
condition|)
goto|goto
name|abortit
goto|;
if|if
condition|(
name|error
operator|=
name|devfs_vntodn
argument_list|(
name|fdvp
argument_list|,
operator|&
name|fdp
argument_list|)
condition|)
goto|goto
name|abortit
goto|;
if|if
condition|(
name|error
operator|=
name|devfs_vntodn
argument_list|(
name|fvp
argument_list|,
operator|&
name|fp
argument_list|)
condition|)
goto|goto
name|abortit
goto|;
name|fnp
operator|=
name|fp
operator|->
name|last_lookup
expr_stmt|;
if|if
condition|(
name|tvp
condition|)
block|{
if|if
condition|(
name|error
operator|=
name|devfs_vntodn
argument_list|(
name|tvp
argument_list|,
operator|&
name|tp
argument_list|)
condition|)
goto|goto
name|abortit
goto|;
name|tnp
operator|=
name|tp
operator|->
name|last_lookup
expr_stmt|;
block|}
else|else
block|{
name|tp
operator|=
name|NULL
expr_stmt|;
name|tnp
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * trying to move it out of devfs? (v_tag == VT_DEVFS)          * if we move a dir across mnt points. we need to fix all 	 * the mountpoint pointers! XXX 	 * so for now keep dirs within the same mount 	 */
if|if
condition|(
operator|(
name|fvp
operator|->
name|v_tag
operator|!=
name|VT_DEVFS
operator|)
operator|||
operator|(
name|fvp
operator|->
name|v_tag
operator|!=
name|tdvp
operator|->
name|v_tag
operator|)
operator|||
operator|(
name|tvp
operator|&&
operator|(
name|fvp
operator|->
name|v_tag
operator|!=
name|tvp
operator|->
name|v_tag
operator|)
operator|)
operator|||
operator|(
operator|(
name|fp
operator|->
name|type
operator|==
name|DEV_DIR
operator|)
operator|&&
operator|(
name|fp
operator|->
name|dvm
operator|!=
name|tdp
operator|->
name|dvm
operator|)
operator|)
condition|)
block|{
name|error
operator|=
name|EXDEV
expr_stmt|;
name|abortit
label|:
name|VOP_ABORTOP
argument_list|(
name|tdvp
argument_list|,
name|tcnp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdvp
operator|==
name|tvp
condition|)
comment|/* eh? */
name|vrele
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
else|else
name|vput
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tvp
condition|)
name|vput
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
name|VOP_ABORTOP
argument_list|(
name|fdvp
argument_list|,
name|fcnp
argument_list|)
expr_stmt|;
comment|/* XXX, why not in NFS? */
name|vrele
argument_list|(
name|fdvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|fvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Check we are doing legal things WRT the new flags 	 */
if|if
condition|(
operator|(
name|tp
operator|&&
operator|(
name|tp
operator|->
name|flags
operator|&
operator|(
name|IMMUTABLE
operator||
name|APPEND
operator|)
operator|)
operator|)
operator|||
operator|(
name|fp
operator|->
name|flags
operator|&
operator|(
name|IMMUTABLE
operator||
name|APPEND
operator|)
operator|)
operator|||
operator|(
name|fdp
operator|->
name|flags
operator|&
name|APPEND
operator|)
condition|)
block|{
name|error
operator|=
name|EPERM
expr_stmt|;
goto|goto
name|abortit
goto|;
block|}
comment|/* 	 * Make sure that we don't try do something stupid 	 */
if|if
condition|(
operator|(
name|fp
operator|->
name|type
operator|)
operator|==
name|DEV_DIR
condition|)
block|{
comment|/* 		 * Avoid ".", "..", and aliases of "." for obvious reasons. 		 */
if|if
condition|(
operator|(
name|fcnp
operator|->
name|cn_namelen
operator|==
literal|1
operator|&&
name|fcnp
operator|->
name|cn_nameptr
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
operator|||
operator|(
name|fcnp
operator|->
name|cn_flags
operator|&
name|ISDOTDOT
operator|)
operator|||
operator|(
name|tcnp
operator|->
name|cn_namelen
operator|==
literal|1
operator|&&
name|tcnp
operator|->
name|cn_nameptr
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
operator|||
operator|(
name|tcnp
operator|->
name|cn_flags
operator|&
name|ISDOTDOT
operator|)
operator|||
operator|(
name|tdp
operator|==
name|fp
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|abortit
goto|;
block|}
name|doingdirectory
operator|++
expr_stmt|;
block|}
comment|/* 	 * If ".." must be changed (ie the directory gets a new 	 * parent) then the source directory must not be in the 	 * directory heirarchy above the target, as this would 	 * orphan everything below the source directory. Also 	 * the user must have write permission in the source so 	 * as to be able to change "..".  	 */
if|if
condition|(
name|doingdirectory
operator|&&
operator|(
name|tdp
operator|!=
name|fdp
operator|)
condition|)
block|{
name|dn_p
name|tmp
decl_stmt|,
name|ntmp
decl_stmt|;
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|fvp
argument_list|,
name|VWRITE
argument_list|,
name|tcnp
operator|->
name|cn_cred
argument_list|,
name|tcnp
operator|->
name|cn_proc
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|tdp
expr_stmt|;
do|do
block|{
if|if
condition|(
name|tmp
operator|==
name|fp
condition|)
block|{
comment|/* XXX unlock stuff here probably */
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ntmp
operator|=
name|tmp
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|tmp
operator|=
name|tmp
operator|->
name|by
operator|.
name|Dir
operator|.
name|parent
operator|)
operator|!=
name|ntmp
condition|)
do|;
block|}
comment|/*********************************** 	 * Start actually doing things.... * 	 ***********************************/
name|TIMEVAL_TO_TIMESPEC
argument_list|(
operator|&
name|time
argument_list|,
operator|&
operator|(
name|fp
operator|->
name|atime
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Check if just deleting a link name. 	 */
if|if
condition|(
name|fvp
operator|==
name|tvp
condition|)
block|{
if|if
condition|(
name|fvp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|abortit
goto|;
block|}
comment|/* Release destination completely. */
name|VOP_ABORTOP
argument_list|(
name|tdvp
argument_list|,
name|tcnp
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
comment|/* Delete source. */
name|VOP_ABORTOP
argument_list|(
name|fdvp
argument_list|,
name|fcnp
argument_list|)
expr_stmt|;
comment|/*XXX*/
name|vrele
argument_list|(
name|fdvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|fvp
argument_list|)
expr_stmt|;
name|dev_free_name
argument_list|(
name|fnp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * 1) Bump link count while we're moving stuff 	 *    around.  If we crash somewhere before 	 *    completing our work,  too bad :) 	 */
name|fp
operator|->
name|links
operator|++
expr_stmt|;
comment|/* 	 * If the target exists zap it (unless it's a non-empty directory) 	 * We could do that as well but won't  	 */
if|if
condition|(
name|tp
condition|)
block|{
name|int
name|ouruid
init|=
name|tcnp
operator|->
name|cn_cred
operator|->
name|cr_uid
decl_stmt|;
comment|/* 		 * If the parent directory is "sticky", then the user must 		 * own the parent directory, or the destination of the rename, 		 * otherwise the destination may not be changed (except by 		 * root). This implements append-only directories. 		 * XXX shoudn't this be in generic code?  		 */
if|if
condition|(
operator|(
name|tdp
operator|->
name|mode
operator|&
name|S_ISTXT
operator|)
operator|&&
name|ouruid
operator|!=
literal|0
operator|&&
name|ouruid
operator|!=
name|tdp
operator|->
name|uid
operator|&&
name|ouruid
operator|!=
name|tp
operator|->
name|uid
condition|)
block|{
name|error
operator|=
name|EPERM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 		 * Target must be empty if a directory and have no links 		 * to it. Also, ensure source and target are compatible 		 * (both directories, or both not directories). 		 */
if|if
condition|(
operator|(
name|doingdirectory
operator|)
operator|&&
operator|(
name|tp
operator|->
name|links
operator|>
literal|2
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"nlink = %d\n"
argument_list|,
name|tp
operator|->
name|links
argument_list|)
expr_stmt|;
comment|/*XXX*/
name|error
operator|=
name|ENOTEMPTY
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|dev_free_name
argument_list|(
name|tnp
argument_list|)
expr_stmt|;
name|tp
operator|=
name|NULL
expr_stmt|;
block|}
name|dev_add_name
argument_list|(
name|tcnp
operator|->
name|cn_nameptr
argument_list|,
name|tdp
argument_list|,
name|fnp
operator|->
name|as
operator|.
name|front
operator|.
name|realthing
argument_list|,
name|fp
argument_list|,
operator|&
name|tnp
argument_list|)
expr_stmt|;
name|fnp
operator|->
name|dnp
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|links
operator|--
expr_stmt|;
comment|/* one less link to it.. */
name|dev_free_name
argument_list|(
name|fnp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|links
operator|--
expr_stmt|;
comment|/* we added one earlier*/
if|if
condition|(
name|tdp
condition|)
name|vput
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
condition|)
name|vput
argument_list|(
name|fvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|ap
operator|->
name|a_fvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
name|bad
label|:
if|if
condition|(
name|tp
condition|)
name|vput
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|vn_lock
argument_list|(
name|fvp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|p
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fp
operator|->
name|links
operator|--
expr_stmt|;
comment|/* we added one earlier*/
name|vput
argument_list|(
name|fvp
argument_list|)
expr_stmt|;
block|}
else|else
name|vrele
argument_list|(
name|fvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_function
specifier|static
name|int
name|devfs_mkdir
parameter_list|(
name|struct
name|vop_mkdir_args
modifier|*
name|ap
parameter_list|)
comment|/*struct vop_mkdir_args {                 struct vnode *a_dvp;                 struct vnode **a_vpp;                 struct componentname *a_cnp;                 struct vattr *a_vap;         } */
block|{
name|DBPRINT
argument_list|(
operator|(
literal|"mkdir\n"
operator|)
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|devfs_rmdir
parameter_list|(
name|struct
name|vop_rmdir_args
modifier|*
name|ap
parameter_list|)
comment|/*struct vop_rmdir_args {                 struct vnode *a_dvp;                 struct vnode *a_vp;                 struct componentname *a_cnp;         } */
block|{
name|DBPRINT
argument_list|(
operator|(
literal|"rmdir\n"
operator|)
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|devfs_symlink
parameter_list|(
name|struct
name|vop_symlink_args
modifier|*
name|ap
parameter_list|)
comment|/*struct vop_symlink_args {                 struct vnode *a_dvp;                 struct vnode **a_vpp;                 struct componentname *a_cnp;                 struct vattr *a_vap;                 char *a_target;         } */
block|{
name|int
name|err
decl_stmt|;
name|dn_p
name|dnp
decl_stmt|;
name|union
name|typeinfo
name|by
decl_stmt|;
name|devnm_p
name|nm_p
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"symlink\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|=
name|devfs_vntodn
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|,
operator|&
name|dnp
argument_list|)
condition|)
block|{
return|return
name|err
return|;
block|}
name|by
operator|.
name|Slnk
operator|.
name|name
operator|=
name|ap
operator|->
name|a_target
expr_stmt|;
name|by
operator|.
name|Slnk
operator|.
name|namelen
operator|=
name|strlen
argument_list|(
name|ap
operator|->
name|a_target
argument_list|)
expr_stmt|;
name|dev_add_entry
argument_list|(
name|ap
operator|->
name|a_cnp
operator|->
name|cn_nameptr
argument_list|,
name|dnp
argument_list|,
name|DEV_SLNK
argument_list|,
operator|&
name|by
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|nm_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|=
name|devfs_dntovn
argument_list|(
name|nm_p
operator|->
name|dnp
argument_list|,
operator|&
name|vp
argument_list|)
condition|)
block|{
name|vput
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|VOP_SETATTR
argument_list|(
name|vp
argument_list|,
name|ap
operator|->
name|a_vap
argument_list|,
name|ap
operator|->
name|a_cnp
operator|->
name|cn_cred
argument_list|,
name|ap
operator|->
name|a_cnp
operator|->
name|cn_proc
argument_list|)
expr_stmt|;
operator|*
name|ap
operator|->
name|a_vpp
operator|=
name|NULL
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Vnode op for readdir  */
end_comment

begin_function
specifier|static
name|int
name|devfs_readdir
parameter_list|(
name|struct
name|vop_readdir_args
modifier|*
name|ap
parameter_list|)
comment|/*struct vop_readdir_args {                 struct vnode *a_vp;                 struct uio *a_uio;                 struct ucred *a_cred;         	int *eofflag;         	int *ncookies;         	u_int **cookies;         } */
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
init|=
name|ap
operator|->
name|a_uio
decl_stmt|;
name|struct
name|dirent
name|dirent
decl_stmt|;
name|dn_p
name|dir_node
decl_stmt|;
name|devnm_p
name|name_node
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|reclen
decl_stmt|;
name|int
name|nodenumber
decl_stmt|;
name|int
name|startpos
decl_stmt|,
name|pos
decl_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"readdir\n"
operator|)
argument_list|)
expr_stmt|;
comment|/*  set up refs to dir */
if|if
condition|(
name|error
operator|=
name|devfs_vntodn
argument_list|(
name|vp
argument_list|,
operator|&
name|dir_node
argument_list|)
condition|)
return|return
name|error
return|;
if|if
condition|(
name|dir_node
operator|->
name|type
operator|!=
name|DEV_DIR
condition|)
return|return
operator|(
name|ENOTDIR
operator|)
return|;
name|pos
operator|=
literal|0
expr_stmt|;
name|startpos
operator|=
name|uio
operator|->
name|uio_offset
expr_stmt|;
name|name_node
operator|=
name|dir_node
operator|->
name|by
operator|.
name|Dir
operator|.
name|dirlist
expr_stmt|;
name|nodenumber
operator|=
literal|0
expr_stmt|;
name|TIMEVAL_TO_TIMESPEC
argument_list|(
argument|&time
argument_list|,
argument|&(dir_node->atime)
argument_list|)
while|while
condition|(
operator|(
name|name_node
operator|||
operator|(
name|nodenumber
operator|<
literal|2
operator|)
operator|)
operator|&&
operator|(
name|uio
operator|->
name|uio_resid
operator|>
literal|0
operator|)
condition|)
block|{
switch|switch
condition|(
name|nodenumber
condition|)
block|{
case|case
literal|0
case|:
name|dirent
operator|.
name|d_fileno
operator|=
operator|(
name|unsigned
name|long
name|int
operator|)
name|dir_node
expr_stmt|;
name|name
operator|=
literal|"."
expr_stmt|;
name|dirent
operator|.
name|d_namlen
operator|=
literal|1
expr_stmt|;
name|dirent
operator|.
name|d_type
operator|=
name|DT_DIR
expr_stmt|;
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|dir_node
operator|->
name|by
operator|.
name|Dir
operator|.
name|parent
condition|)
name|dirent
operator|.
name|d_fileno
operator|=
operator|(
name|unsigned
name|long
name|int
operator|)
name|dir_node
operator|->
name|by
operator|.
name|Dir
operator|.
name|parent
expr_stmt|;
else|else
name|dirent
operator|.
name|d_fileno
operator|=
operator|(
name|unsigned
name|long
name|int
operator|)
name|dir_node
expr_stmt|;
name|name
operator|=
literal|".."
expr_stmt|;
name|dirent
operator|.
name|d_namlen
operator|=
literal|2
expr_stmt|;
name|dirent
operator|.
name|d_type
operator|=
name|DT_DIR
expr_stmt|;
break|break;
default|default:
name|dirent
operator|.
name|d_fileno
operator|=
operator|(
name|unsigned
name|long
name|int
operator|)
name|name_node
operator|->
name|dnp
expr_stmt|;
name|dirent
operator|.
name|d_namlen
operator|=
name|strlen
argument_list|(
name|name_node
operator|->
name|name
argument_list|)
expr_stmt|;
name|name
operator|=
name|name_node
operator|->
name|name
expr_stmt|;
switch|switch
condition|(
name|name_node
operator|->
name|dnp
operator|->
name|type
condition|)
block|{
case|case
name|DEV_BDEV
case|:
name|dirent
operator|.
name|d_type
operator|=
name|DT_BLK
expr_stmt|;
break|break;
case|case
name|DEV_CDEV
case|:
name|dirent
operator|.
name|d_type
operator|=
name|DT_CHR
expr_stmt|;
break|break;
case|case
name|DEV_DDEV
case|:
name|dirent
operator|.
name|d_type
operator|=
name|DT_SOCK
expr_stmt|;
comment|/*XXX*/
break|break;
case|case
name|DEV_DIR
case|:
name|dirent
operator|.
name|d_type
operator|=
name|DT_DIR
expr_stmt|;
break|break;
case|case
name|DEV_SLNK
case|:
name|dirent
operator|.
name|d_type
operator|=
name|DT_LNK
expr_stmt|;
break|break;
default|default:
name|dirent
operator|.
name|d_type
operator|=
name|DT_UNKNOWN
expr_stmt|;
block|}
block|}
name|reclen
operator|=
name|dirent
operator|.
name|d_reclen
operator|=
name|GENERIC_DIRSIZ
argument_list|(
operator|&
name|dirent
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|>=
name|startpos
condition|)
comment|/* made it to the offset yet? */
block|{
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|<
name|reclen
condition|)
comment|/* will it fit? */
break|break;
name|strcpy
argument_list|(
name|dirent
operator|.
name|d_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|uiomove
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|dirent
argument_list|,
name|dirent
operator|.
name|d_reclen
argument_list|,
name|uio
argument_list|)
condition|)
break|break;
block|}
name|pos
operator|+=
name|reclen
expr_stmt|;
if|if
condition|(
operator|(
name|nodenumber
operator|>
literal|1
operator|)
operator|&&
name|name_node
condition|)
name|name_node
operator|=
name|name_node
operator|->
name|next
expr_stmt|;
name|nodenumber
operator|++
expr_stmt|;
block|}
name|uio
operator|->
name|uio_offset
operator|=
name|pos
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  */
end_comment

begin_function
specifier|static
name|int
name|devfs_readlink
parameter_list|(
name|struct
name|vop_readlink_args
modifier|*
name|ap
parameter_list|)
comment|/*struct vop_readlink_args {                 struct vnode *a_vp;                 struct uio *a_uio;                 struct ucred *a_cred;         } */
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
init|=
name|ap
operator|->
name|a_uio
decl_stmt|;
name|dn_p
name|lnk_node
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"readlink\n"
operator|)
argument_list|)
expr_stmt|;
comment|/*  set up refs to dir */
if|if
condition|(
name|error
operator|=
name|devfs_vntodn
argument_list|(
name|vp
argument_list|,
operator|&
name|lnk_node
argument_list|)
condition|)
return|return
name|error
return|;
if|if
condition|(
name|lnk_node
operator|->
name|type
operator|!=
name|DEV_SLNK
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|vp
argument_list|,
name|VREAD
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
comment|/* XXX */
return|return
name|error
return|;
block|}
name|error
operator|=
name|uiomove
argument_list|(
name|lnk_node
operator|->
name|by
operator|.
name|Slnk
operator|.
name|name
argument_list|,
name|lnk_node
operator|->
name|by
operator|.
name|Slnk
operator|.
name|namelen
argument_list|,
name|uio
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_function
specifier|static
name|int
name|devfs_abortop
parameter_list|(
name|struct
name|vop_abortop_args
modifier|*
name|ap
parameter_list|)
comment|/*struct vop_abortop_args {                 struct vnode *a_dvp;                 struct componentname *a_cnp;         } */
block|{
name|DBPRINT
argument_list|(
operator|(
literal|"abortop\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ap
operator|->
name|a_cnp
operator|->
name|cn_flags
operator|&
operator|(
name|HASBUF
operator||
name|SAVESTART
operator|)
operator|)
operator|==
name|HASBUF
condition|)
name|zfree
argument_list|(
name|namei_zone
argument_list|,
name|ap
operator|->
name|a_cnp
operator|->
name|cn_pnbuf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* notyet */
end_comment

begin_function
specifier|static
name|int
name|devfs_inactive
parameter_list|(
name|struct
name|vop_inactive_args
modifier|*
name|ap
parameter_list|)
comment|/*struct vop_inactive_args {                 struct vnode *a_vp;         } */
block|{
name|DBPRINT
argument_list|(
operator|(
literal|"inactive\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_function
specifier|static
name|int
name|devfs_lock
parameter_list|(
name|struct
name|vop_lock_args
modifier|*
name|ap
parameter_list|)
block|{
name|DBPRINT
argument_list|(
operator|(
literal|"lock\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|devfs_unlock
parameter_list|(
name|struct
name|vop_unlock_args
modifier|*
name|ap
parameter_list|)
block|{
name|DBPRINT
argument_list|(
operator|(
literal|"unlock\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|devfs_islocked
parameter_list|(
name|struct
name|vop_islocked_args
modifier|*
name|ap
parameter_list|)
comment|/*struct vop_islocked_args {                 struct vnode *a_vp;         } */
block|{
name|DBPRINT
argument_list|(
operator|(
literal|"islocked\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|devfs_bmap
parameter_list|(
name|struct
name|vop_bmap_args
modifier|*
name|ap
parameter_list|)
comment|/*struct vop_bmap_args {                 struct vnode *a_vp;                 daddr_t  a_bn;                 struct vnode **a_vpp;                 daddr_t *a_bnp;                 int *a_runp;                 int *a_runb;         } */
block|{
name|DBPRINT
argument_list|(
operator|(
literal|"bmap\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|devfs_advlock
parameter_list|(
name|struct
name|vop_advlock_args
modifier|*
name|ap
parameter_list|)
comment|/*struct vop_advlock_args {                 struct vnode *a_vp;                 caddr_t  a_id;                 int  a_op;                 struct flock *a_fl;                 int  a_flags;         } */
block|{
name|DBPRINT
argument_list|(
operator|(
literal|"advlock\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
comment|/* we don't do locking yet		*/
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* notyet */
end_comment

begin_function
specifier|static
name|int
name|devfs_reclaim
parameter_list|(
name|struct
name|vop_reclaim_args
modifier|*
name|ap
parameter_list|)
comment|/*struct vop_reclaim_args { 		struct vnode *a_vp;         } */
block|{
name|dn_p
name|file_node
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"reclaim\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|devfs_vntodn
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
operator|&
name|file_node
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"devfs_vntodn returned %d "
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|ap
operator|->
name|a_vp
operator|->
name|v_data
operator|=
name|NULL
expr_stmt|;
name|file_node
operator|->
name|vn
operator|=
literal|0
expr_stmt|;
name|file_node
operator|->
name|vn_id
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return POSIX pathconf information applicable to special devices.  */
end_comment

begin_function
specifier|static
name|int
name|devfs_pathconf
parameter_list|(
name|struct
name|vop_pathconf_args
modifier|*
name|ap
parameter_list|)
comment|/*struct vop_pathconf_args {                 struct vnode *a_vp;                 int a_name;                 int *a_retval;         } */
block|{
switch|switch
condition|(
name|ap
operator|->
name|a_name
condition|)
block|{
case|case
name|_PC_LINK_MAX
case|:
operator|*
name|ap
operator|->
name|a_retval
operator|=
name|LINK_MAX
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|_PC_MAX_CANON
case|:
operator|*
name|ap
operator|->
name|a_retval
operator|=
name|MAX_CANON
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|_PC_MAX_INPUT
case|:
operator|*
name|ap
operator|->
name|a_retval
operator|=
name|MAX_INPUT
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|_PC_PIPE_BUF
case|:
operator|*
name|ap
operator|->
name|a_retval
operator|=
name|PIPE_BUF
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|_PC_CHOWN_RESTRICTED
case|:
operator|*
name|ap
operator|->
name|a_retval
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|_PC_VDISABLE
case|:
operator|*
name|ap
operator|->
name|a_retval
operator|=
name|_POSIX_VDISABLE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * Print out the contents of a /devfs vnode.  */
end_comment

begin_function
specifier|static
name|int
name|devfs_print
parameter_list|(
name|struct
name|vop_print_args
modifier|*
name|ap
parameter_list|)
comment|/*struct vop_print_args { 		struct vnode *a_vp; 	} */
block|{
name|printf
argument_list|(
literal|"tag VT_DEVFS, devfs vnode\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************\ * pseudo ops * \**************************************************************************/
end_comment

begin_comment
comment|/*  * /devfs vnode unsupported operation  */
end_comment

begin_function
specifier|static
name|int
name|devfs_enotsupp
parameter_list|(
name|void
modifier|*
name|junk
parameter_list|)
block|{
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * /devfs "should never get here" operation  */
end_comment

begin_function
specifier|static
name|int
name|devfs_badop
parameter_list|(
name|void
modifier|*
name|junk
parameter_list|)
block|{
name|panic
argument_list|(
literal|"devfs: bad op"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*proto*/
end_comment

begin_function
name|void
name|devfs_dropvnode
parameter_list|(
name|dn_p
name|dnp
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vn_p
decl_stmt|;
ifdef|#
directive|ifdef
name|PARANOID
if|if
condition|(
operator|!
name|dnp
condition|)
block|{
name|printf
argument_list|(
literal|"devfs: dn count dropped too early\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|vn_p
operator|=
name|dnp
operator|->
name|vn
expr_stmt|;
comment|/* 	 * check if we have a vnode....... 	 */
if|if
condition|(
operator|(
name|vn_p
operator|)
operator|&&
operator|(
name|dnp
operator|->
name|vn_id
operator|==
name|vn_p
operator|->
name|v_id
operator|)
operator|&&
operator|(
name|dnp
operator|==
operator|(
name|dn_p
operator|)
name|vn_p
operator|->
name|v_data
operator|)
condition|)
block|{
name|VOP_REVOKE
argument_list|(
name|vn_p
argument_list|,
name|REVOKEALL
argument_list|)
expr_stmt|;
block|}
name|dnp
operator|->
name|vn
operator|=
name|NULL
expr_stmt|;
comment|/* be pedantic about this */
block|}
end_function

begin_comment
comment|/* These are the operations used by directories etc in a devfs */
end_comment

begin_decl_stmt
name|vop_t
modifier|*
modifier|*
name|devfs_vnodeop_p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vnodeopv_entry_desc
name|devfs_vnodeop_entries
index|[]
init|=
block|{
block|{
operator|&
name|vop_default_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|vn_default_error
block|}
block|,
block|{
operator|&
name|vop_abortop_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nullop
block|}
block|,
block|{
operator|&
name|vop_access_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|devfs_access
block|}
block|,
block|{
operator|&
name|vop_bmap_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|devfs_badop
block|}
block|,
block|{
operator|&
name|vop_close_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nullop
block|}
block|,
block|{
operator|&
name|vop_fsync_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nullop
block|}
block|,
block|{
operator|&
name|vop_getattr_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|devfs_getattr
block|}
block|,
block|{
operator|&
name|vop_inactive_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|devfs_inactive
block|}
block|,
block|{
operator|&
name|vop_islocked_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|vop_noislocked
block|}
block|,
block|{
operator|&
name|vop_link_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|devfs_link
block|}
block|,
block|{
operator|&
name|vop_lock_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|vop_nolock
block|}
block|,
block|{
operator|&
name|vop_lookup_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|devfs_lookup
block|}
block|,
block|{
operator|&
name|vop_open_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|devfs_open
block|}
block|,
block|{
operator|&
name|vop_pathconf_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|devfs_pathconf
block|}
block|,
block|{
operator|&
name|vop_print_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|devfs_print
block|}
block|,
block|{
operator|&
name|vop_read_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|devfs_read
block|}
block|,
block|{
operator|&
name|vop_readdir_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|devfs_readdir
block|}
block|,
block|{
operator|&
name|vop_readlink_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|devfs_readlink
block|}
block|,
block|{
operator|&
name|vop_reclaim_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|devfs_reclaim
block|}
block|,
block|{
operator|&
name|vop_remove_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|devfs_remove
block|}
block|,
block|{
operator|&
name|vop_rename_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|devfs_rename
block|}
block|,
block|{
operator|&
name|vop_seek_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nullop
block|}
block|,
block|{
operator|&
name|vop_setattr_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|devfs_setattr
block|}
block|,
block|{
operator|&
name|vop_symlink_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|devfs_symlink
block|}
block|,
block|{
operator|&
name|vop_unlock_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|vop_nounlock
block|}
block|,
block|{
operator|&
name|vop_write_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|devfs_write
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vnodeopv_desc
name|devfs_vnodeop_opv_desc
init|=
block|{
operator|&
name|devfs_vnodeop_p
block|,
name|devfs_vnodeop_entries
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|VNODEOP_SET
argument_list|(
name|devfs_vnodeop_opv_desc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*copied in from specfs/spec_vnops.c.. (spot the changes )*/
end_comment

begin_comment
comment|/* These are the operations used by special devices in a devfs */
end_comment

begin_comment
comment|/*  * Copyright (c) 1989, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)spec_vnops.c	8.6 (Berkeley) 4/9/94  * spec_vnops.c,v 1.9 1994/11/14 13:22:52 bde Exp  */
end_comment

begin_decl_stmt
name|vop_t
modifier|*
modifier|*
name|dev_spec_vnodeop_p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vnodeopv_entry_desc
name|dev_spec_vnodeop_entries
index|[]
init|=
block|{
block|{
operator|&
name|vop_default_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|spec_vnoperate
block|}
block|,
block|{
operator|&
name|vop_access_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|devfs_access
block|}
block|,
block|{
operator|&
name|vop_getattr_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|devfs_getattr
block|}
block|,
block|{
operator|&
name|vop_read_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|devfs_read
block|}
block|,
block|{
operator|&
name|vop_reclaim_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|devfs_reclaim
block|}
block|,
block|{
operator|&
name|vop_setattr_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|devfs_setattr
block|}
block|,
block|{
operator|&
name|vop_symlink_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|devfs_symlink
block|}
block|,
block|{
operator|&
name|vop_write_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|devfs_write
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vnodeopv_desc
name|dev_spec_vnodeop_opv_desc
init|=
block|{
operator|&
name|dev_spec_vnodeop_p
block|,
name|dev_spec_vnodeop_entries
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|VNODEOP_SET
argument_list|(
name|dev_spec_vnodeop_opv_desc
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

