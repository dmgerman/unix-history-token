begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Written by Julian Elischer (julian@DIALix.oz.au)  *  *	$Header: /sys/miscfs/devfs/RCS/devfs_front.c,v 1.3 1995/01/07 04:20:25 root Exp root $  *  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_comment
comment|/* define FWRITE ... */
end_comment

begin_include
include|#
directive|include
file|"conf.h"
end_include

begin_include
include|#
directive|include
file|"stat.h"
end_include

begin_include
include|#
directive|include
file|"mount.h"
end_include

begin_include
include|#
directive|include
file|"vnode.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_comment
comment|/* defines dirent structure		*/
end_comment

begin_include
include|#
directive|include
file|"devfsdefs.h"
end_include

begin_comment
comment|/***********************************************************************\ * Given a directory backing node, and a child backing node, add the	* * appropriate front nodes to the front nodes of the directory to	* * represent the child node to the user					* *									* * on failure, front nodes will either be correct or not exist for each	* * front dir, however dirs completed will not be stripped of completed	* * frontnodes on failure of a later parent frontnode			* *									* \***********************************************************************/
end_comment

begin_function
name|int
name|devfs_add_fronts
parameter_list|(
name|devb_p
name|parent
parameter_list|,
name|devb_p
name|child
parameter_list|)
comment|/*proto*/
block|{
name|devf_p
name|newfp
decl_stmt|;
name|devf_p
name|falias
decl_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"	devfs_add_fronts\n"
operator|)
argument_list|)
expr_stmt|;
comment|/***********************************************\ 	* Find the frontnodes of the parent node	* 	\***********************************************/
for|for
control|(
name|falias
operator|=
name|parent
operator|->
name|fronts
init|;
name|falias
condition|;
name|falias
operator|=
name|falias
operator|->
name|next_front
control|)
block|{
if|if
condition|(
name|dev_findfront
argument_list|(
name|falias
operator|->
name|dnp
argument_list|,
name|child
operator|->
name|name
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Device %s not created, already exists\n"
argument_list|,
name|child
operator|->
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|dev_mk_front
argument_list|(
name|falias
operator|->
name|dnp
argument_list|,
name|child
argument_list|,
operator|&
name|newfp
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Device %s: allocation failed\n"
argument_list|,
name|child
operator|->
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* for now always succeed */
block|}
end_function

begin_comment
comment|/***************************************************************\ * Search down the linked list off a front dir to find "name"	* * return the dn_p for that node. \***************************************************************/
end_comment

begin_function
name|dn_p
name|dev_findfront
parameter_list|(
name|dn_p
name|dir
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
comment|/*proto*/
block|{
name|devf_p
name|newfp
decl_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"	dev_findfront(%s)\n"
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|->
name|type
operator|!=
name|DEV_DIR
condition|)
return|return
literal|0
return|;
comment|/*XXX*/
comment|/* printf?*/
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|0
condition|)
block|{
return|return
name|dir
return|;
block|}
if|if
condition|(
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'.'
operator|)
operator|&&
operator|(
name|name
index|[
literal|2
index|]
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|dir
operator|->
name|by
operator|.
name|Dir
operator|.
name|parent
operator|==
name|dir
condition|)
comment|/* root? */
return|return
name|dir
return|;
else|else
return|return
name|dir
operator|->
name|by
operator|.
name|Dir
operator|.
name|parent
return|;
block|}
block|}
name|newfp
operator|=
name|dir
operator|->
name|by
operator|.
name|Dir
operator|.
name|dirlist
expr_stmt|;
while|while
condition|(
name|newfp
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|newfp
operator|->
name|name
argument_list|)
operator|)
condition|)
break|break;
name|newfp
operator|=
name|newfp
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|newfp
condition|)
return|return
name|newfp
operator|->
name|dnp
return|;
else|else
return|return
operator|(
name|dn_p
operator|)
literal|0
return|;
block|}
end_function

begin_comment
comment|/***************************************************************\ * Create and link in a new front element.. 			* * Parent can be 0 for a root node				* * Not presently usable to make a symlink XXX			* * Must teach this to handle where there is no back node		* * maybe split into two bits?					* \***************************************************************/
end_comment

begin_function
name|int
name|dev_mk_front
parameter_list|(
name|dn_p
name|parent
parameter_list|,
name|devb_p
name|back
parameter_list|,
name|devf_p
modifier|*
name|devf_pp
parameter_list|,
name|struct
name|devfsmount
modifier|*
name|dvm
parameter_list|)
comment|/*proto*/
block|{
name|devf_p
name|newfp
decl_stmt|;
name|struct
name|devfsmount
modifier|*
name|dmt
decl_stmt|;
name|devb_p
name|newback
decl_stmt|;
name|devf_p
name|newfront
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"	dev_mk_front\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|&&
operator|(
name|parent
operator|->
name|type
operator|!=
name|DEV_DIR
operator|)
condition|)
return|return
name|EINVAL
return|;
comment|/*XXX*/
comment|/* printf?*/
if|if
condition|(
operator|!
operator|(
name|newfp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|newfp
argument_list|)
argument_list|,
name|M_DEVFSFRONT
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|newfp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|newfp
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|newfp
operator|->
name|name
argument_list|,
name|back
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/*******************************************************\ 	* If we are creating an alias, Then we need to find the * 	* real object's file_node. (It must pre-exist)		*  	* this means that aliases have no front nodes...	* 	* In effect ALIAS back nodes are just place markers	* 	* Check the removal code for this! XXX			* 	\*******************************************************/
if|if
condition|(
name|back
operator|->
name|dnp
operator|->
name|type
operator|==
name|DEV_ALIAS
condition|)
block|{
name|back
operator|=
name|back
operator|->
name|dnp
operator|->
name|by
operator|.
name|Alias
operator|.
name|realthing
expr_stmt|;
block|}
comment|/* 	 * either use the existing devnode or make our own, 	 * depending on if we are a dev or a dir. 	 */
switch|switch
condition|(
name|back
operator|->
name|dnp
operator|->
name|type
condition|)
block|{
case|case
name|DEV_BDEV
case|:
case|case
name|DEV_CDEV
case|:
case|case
name|DEV_DDEV
case|:
name|newfp
operator|->
name|dnp
operator|=
name|back
operator|->
name|dnp
expr_stmt|;
name|newfp
operator|->
name|dnp
operator|->
name|links
operator|++
expr_stmt|;
comment|/* wherever it is.....*/
break|break;
case|case
name|DEV_DIR
case|:
name|newfp
operator|->
name|dnp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|devnode_t
argument_list|)
argument_list|,
name|M_DEVFSNODE
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|newfp
operator|->
name|dnp
operator|)
condition|)
block|{
name|free
argument_list|(
name|newfp
argument_list|,
name|M_DEVFSFRONT
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
comment|/* 		 * we have two options.. bcopy and reset some items, 		 * or bzero and reset or copy some items... 		 */
name|bcopy
argument_list|(
name|back
operator|->
name|dnp
argument_list|,
name|newfp
operator|->
name|dnp
argument_list|,
sizeof|sizeof
argument_list|(
name|devnode_t
argument_list|)
argument_list|)
expr_stmt|;
name|newfp
operator|->
name|dnp
operator|->
name|links
operator|=
literal|1
expr_stmt|;
comment|/*  EXTRA from '.' */
name|newfp
operator|->
name|dnp
operator|->
name|links
operator|++
expr_stmt|;
comment|/* wherever it is.....*/
name|newfp
operator|->
name|dnp
operator|->
name|by
operator|.
name|Dir
operator|.
name|dirlast
operator|=
operator|&
name|newfp
operator|->
name|dnp
operator|->
name|by
operator|.
name|Dir
operator|.
name|dirlist
expr_stmt|;
name|newfp
operator|->
name|dnp
operator|->
name|by
operator|.
name|Dir
operator|.
name|dirlist
operator|=
name|NULL
expr_stmt|;
name|newfp
operator|->
name|dnp
operator|->
name|by
operator|.
name|Dir
operator|.
name|entrycount
operator|=
literal|0
expr_stmt|;
name|newfp
operator|->
name|dnp
operator|->
name|vn
operator|=
name|NULL
expr_stmt|;
name|newfp
operator|->
name|dnp
operator|->
name|vn_id
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DEV_SLNK
case|:
comment|/* should never happen */
default|default:
name|printf
argument_list|(
literal|"unknown DEV type\n"
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/*******************************************************\ 	* Put it in the parent's directory list (at the end).	* 	\*******************************************************/
if|if
condition|(
name|parent
condition|)
block|{
name|newfp
operator|->
name|next
operator|=
operator|*
name|parent
operator|->
name|by
operator|.
name|Dir
operator|.
name|dirlast
expr_stmt|;
name|newfp
operator|->
name|prevp
operator|=
name|parent
operator|->
name|by
operator|.
name|Dir
operator|.
name|dirlast
expr_stmt|;
operator|*
name|parent
operator|->
name|by
operator|.
name|Dir
operator|.
name|dirlast
operator|=
name|newfp
expr_stmt|;
name|parent
operator|->
name|by
operator|.
name|Dir
operator|.
name|dirlast
operator|=
operator|&
name|newfp
operator|->
name|next
expr_stmt|;
name|parent
operator|->
name|by
operator|.
name|Dir
operator|.
name|entrycount
operator|++
expr_stmt|;
name|newfp
operator|->
name|dnp
operator|->
name|dvm
operator|=
name|parent
operator|->
name|dvm
expr_stmt|;
comment|/* XXX bad for devs */
if|if
condition|(
name|back
operator|->
name|dnp
operator|->
name|type
operator|==
name|DEV_DIR
condition|)
block|{
name|newfp
operator|->
name|dnp
operator|->
name|by
operator|.
name|Dir
operator|.
name|parent
operator|=
name|parent
expr_stmt|;
name|parent
operator|->
name|links
operator|++
expr_stmt|;
comment|/* only dirs have '..'*/
block|}
name|parent
operator|->
name|len
operator|+=
name|strlen
argument_list|(
name|newfp
operator|->
name|name
argument_list|)
operator|+
literal|8
expr_stmt|;
comment|/*ok, ok?*/
block|}
else|else
block|{
comment|/* 		 * it's the root node, put in the dvm 		 * and link it to itself... 		 */
name|newfp
operator|->
name|dnp
operator|->
name|by
operator|.
name|Dir
operator|.
name|parent
operator|=
name|newfp
operator|->
name|dnp
expr_stmt|;
name|newfp
operator|->
name|dnp
operator|->
name|links
operator|++
expr_stmt|;
comment|/* extra for '..'*/
name|newfp
operator|->
name|dnp
operator|->
name|dvm
operator|=
name|dvm
expr_stmt|;
block|}
comment|/* 	 * not accounted for in the link counts.. 	 * only used to get from the front name entries 	 * to the total length of the names  	 * which is stored in the parent's devnode 	 */
name|newfp
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
comment|/* is NULL for root */
comment|/*******************************************************\ 	* Put it in the appropriate back/front list too.	* 	\*******************************************************/
name|newfp
operator|->
name|next_front
operator|=
operator|*
name|back
operator|->
name|lastfront
expr_stmt|;
name|newfp
operator|->
name|prev_frontp
operator|=
name|back
operator|->
name|lastfront
expr_stmt|;
operator|*
name|back
operator|->
name|lastfront
operator|=
name|newfp
expr_stmt|;
name|back
operator|->
name|lastfront
operator|=
operator|&
operator|(
name|newfp
operator|->
name|next_front
operator|)
expr_stmt|;
name|back
operator|->
name|frontcount
operator|++
expr_stmt|;
name|newfp
operator|->
name|realthing
operator|=
name|back
expr_stmt|;
comment|/* 	 * If it is a directory, then recurse down all the other 	 * subnodes in it.... 	 */
if|if
condition|(
name|newfp
operator|->
name|dnp
operator|->
name|type
operator|==
name|DEV_DIR
condition|)
block|{
for|for
control|(
name|newback
operator|=
name|back
operator|->
name|dnp
operator|->
name|by
operator|.
name|BackDir
operator|.
name|dirlist
init|;
name|newback
condition|;
name|newback
operator|=
name|newback
operator|->
name|next
control|)
block|{
if|if
condition|(
name|error
operator|=
name|dev_mk_front
argument_list|(
name|newfp
operator|->
name|dnp
argument_list|,
name|newback
argument_list|,
operator|&
name|newfront
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
block|}
operator|*
name|devf_pp
operator|=
name|newfp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * duplicate the backing tree into a tree of nodes hung off the  * mount point given as the argument. Do this by   * calling dev_mk_front() which recurses all the way  * up the tree..  */
end_comment

begin_function
name|int
name|devfs_make_plane
parameter_list|(
name|struct
name|devfsmount
modifier|*
name|devfs_mp_p
parameter_list|)
comment|/*proto*/
block|{
name|devf_p
name|parent
decl_stmt|;
name|devf_p
name|new
decl_stmt|;
name|devb_p
name|realthing
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"	devfs_make_plane\n"
operator|)
argument_list|)
expr_stmt|;
name|realthing
operator|=
name|dev_root
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|dev_mk_front
argument_list|(
literal|0
argument_list|,
name|realthing
argument_list|,
operator|&
name|new
argument_list|,
name|devfs_mp_p
argument_list|)
condition|)
block|{
return|return
name|error
return|;
block|}
name|devfs_mp_p
operator|->
name|plane_root
operator|=
name|new
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|void
name|devfs_free_plane
parameter_list|(
name|struct
name|devfsmount
modifier|*
name|devfs_mp_p
parameter_list|)
comment|/*proto*/
block|{
name|devf_p
name|devfp
decl_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"	devfs_free_plane\n"
operator|)
argument_list|)
expr_stmt|;
name|devfp
operator|=
name|devfs_mp_p
operator|->
name|plane_root
expr_stmt|;
if|if
condition|(
name|devfp
condition|)
name|dev_free_front
argument_list|(
name|devfp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove all the front nodes associated with a backing node  */
end_comment

begin_function
name|void
name|devfs_remove_fronts
parameter_list|(
name|devb_p
name|devbp
parameter_list|)
comment|/*proto*/
block|{
while|while
condition|(
name|devbp
operator|->
name|fronts
condition|)
block|{
name|dev_free_front
argument_list|(
name|devbp
operator|->
name|fronts
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/***************************************************************\ * Free a front node (and any below it of it's a directory node)	* \***************************************************************/
end_comment

begin_function
name|void
name|dev_free_front
parameter_list|(
name|devf_p
name|devfp
parameter_list|)
comment|/*proto*/
block|{
name|dn_p
name|parent
init|=
name|devfp
operator|->
name|parent
decl_stmt|;
name|devb_p
name|back
decl_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"	dev_free_front\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|devfp
operator|->
name|dnp
operator|->
name|type
operator|==
name|DEV_DIR
condition|)
block|{
while|while
condition|(
name|devfp
operator|->
name|dnp
operator|->
name|by
operator|.
name|Dir
operator|.
name|dirlist
condition|)
block|{
name|dev_free_front
argument_list|(
name|devfp
operator|->
name|dnp
operator|->
name|by
operator|.
name|Dir
operator|.
name|dirlist
argument_list|)
expr_stmt|;
block|}
comment|/*  		 * drop the reference counts on our and our parent's 		 * nodes for "." and ".." (root has ".." -> "." ) 		 */
name|devfs_dn_free
argument_list|(
name|devfp
operator|->
name|dnp
argument_list|)
expr_stmt|;
comment|/* account for '.' */
name|devfs_dn_free
argument_list|(
name|devfp
operator|->
name|dnp
operator|->
name|by
operator|.
name|Dir
operator|.
name|parent
argument_list|)
expr_stmt|;
comment|/* and '..' */
block|}
comment|/* 	 * unlink ourselves from the directory on this plane 	 */
if|if
condition|(
name|parent
condition|)
comment|/* if not fs root */
block|{
if|if
condition|(
operator|*
name|devfp
operator|->
name|prevp
operator|=
name|devfp
operator|->
name|next
condition|)
comment|/* yes, assign */
block|{
name|devfp
operator|->
name|next
operator|->
name|prevp
operator|=
name|devfp
operator|->
name|prevp
expr_stmt|;
block|}
else|else
block|{
name|parent
operator|->
name|by
operator|.
name|Dir
operator|.
name|dirlast
operator|=
name|devfp
operator|->
name|prevp
expr_stmt|;
block|}
name|parent
operator|->
name|by
operator|.
name|Dir
operator|.
name|entrycount
operator|--
expr_stmt|;
name|parent
operator|->
name|len
operator|-=
name|strlen
argument_list|(
name|devfp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the node has a backing pointer we need to free ourselves 	 * from that..  	 * Remember that we may not HAVE a backing node. 	 */
if|if
condition|(
name|back
operator|=
name|devfp
operator|->
name|realthing
condition|)
comment|/* yes an assign */
block|{
if|if
condition|(
operator|*
name|devfp
operator|->
name|prev_frontp
operator|=
name|devfp
operator|->
name|next_front
condition|)
comment|/* yes, assign */
block|{
name|devfp
operator|->
name|next_front
operator|->
name|prev_frontp
operator|=
name|devfp
operator|->
name|prev_frontp
expr_stmt|;
block|}
else|else
block|{
name|back
operator|->
name|lastfront
operator|=
name|devfp
operator|->
name|prev_frontp
expr_stmt|;
block|}
name|back
operator|->
name|frontcount
operator|--
expr_stmt|;
block|}
comment|/***************************************************************\ 	* If the front node has it's own devnode structure,		* 	* then free it.							* 	\***************************************************************/
name|devfs_dn_free
argument_list|(
name|devfp
operator|->
name|dnp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|devfp
argument_list|,
name|M_DEVFSFRONT
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*******************************************************\ * Theoretically this could be called for any kind of 	* * vnode, however in practice it must be a DEVFS vnode	* \*******************************************************/
end_comment

begin_function
name|int
name|devfs_vntodn
parameter_list|(
name|struct
name|vnode
modifier|*
name|vn_p
parameter_list|,
name|dn_p
modifier|*
name|dn_pp
parameter_list|)
comment|/*proto*/
block|{
name|DBPRINT
argument_list|(
operator|(
literal|"	vntodn "
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vn_p
operator|->
name|v_tag
operator|!=
name|VT_DEVFS
condition|)
block|{
name|printf
argument_list|(
literal|"bad-tag "
argument_list|)
expr_stmt|;
name|Debugger
argument_list|(
literal|"bad-tag "
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|vn_p
operator|->
name|v_usecount
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"not locked! "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|vn_p
operator|->
name|v_type
operator|==
name|VBAD
operator|)
operator|||
operator|(
name|vn_p
operator|->
name|v_type
operator|==
name|VNON
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"bad-type "
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
operator|*
name|dn_pp
operator|=
operator|(
name|dn_p
operator|)
name|vn_p
operator|->
name|v_data
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/***************************************************************\ *     Think about this: 					* * Though this routine uses a front node, it also uses a backing	* * node indirectly, via the 'realthing' link. This may prove bad	* * in the case of a user-added slink, where there migh not be a	* * backing node. (e.g. if a slink points out of the fs it CAN'T	* * have a backing node, unlike a hardlink which does..)		* * we are going to have to think very carefully about slinks..	* \***************************************************************/
end_comment

begin_function
name|int
name|devfs_dntovn
parameter_list|(
name|dn_p
name|front
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vn_pp
parameter_list|)
comment|/*proto*/
block|{
name|struct
name|vnode
modifier|*
name|vn_p
decl_stmt|,
modifier|*
name|nvp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|vn_p
operator|=
name|front
operator|->
name|vn
expr_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"dntovn "
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vn_p
condition|)
block|{
if|if
condition|(
name|vn_p
operator|->
name|v_id
operator|!=
name|front
operator|->
name|vn_id
condition|)
block|{
name|printf
argument_list|(
literal|"bad-id "
argument_list|)
expr_stmt|;
goto|goto
name|skip
goto|;
block|}
if|if
condition|(
name|vn_p
operator|->
name|v_tag
operator|!=
name|VT_DEVFS
condition|)
block|{
name|printf
argument_list|(
literal|"bad-tag "
argument_list|)
expr_stmt|;
goto|goto
name|skip
goto|;
block|}
if|if
condition|(
name|vn_p
operator|->
name|v_op
operator|!=
operator|*
operator|(
name|front
operator|->
name|ops
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"bad-ops "
argument_list|)
expr_stmt|;
goto|goto
name|skip
goto|;
block|}
if|if
condition|(
call|(
name|dn_p
call|)
argument_list|(
name|vn_p
operator|->
name|v_data
argument_list|)
operator|!=
name|front
condition|)
block|{
name|printf
argument_list|(
literal|"bad-rev_link "
argument_list|)
expr_stmt|;
goto|goto
name|skip
goto|;
block|}
if|if
condition|(
name|vn_p
operator|->
name|v_type
operator|!=
name|VNON
condition|)
block|{
name|vget
argument_list|(
name|vn_p
argument_list|,
literal|0
comment|/*lockflag ?*/
argument_list|)
expr_stmt|;
comment|/*XXX*/
operator|*
name|vn_pp
operator|=
name|vn_p
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"bad-type"
argument_list|)
expr_stmt|;
block|}
name|skip
label|:
name|vn_p
operator|=
operator|(
expr|struct
name|vnode
operator|*
operator|)
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|error
operator|=
name|getnewvnode
argument_list|(
name|VT_DEVFS
argument_list|,
name|front
operator|->
name|dvm
operator|->
name|mount
argument_list|,
operator|*
operator|(
name|front
operator|->
name|ops
operator|)
argument_list|,
operator|&
name|vn_p
argument_list|)
operator|)
condition|)
block|{
name|front
operator|->
name|vn
operator|=
name|vn_p
expr_stmt|;
name|front
operator|->
name|vn_id
operator|=
name|vn_p
operator|->
name|v_id
expr_stmt|;
operator|*
name|vn_pp
operator|=
name|vn_p
expr_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"(New vnode)"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|front
operator|->
name|type
condition|)
block|{
case|case
name|DEV_SLNK
case|:
break|break;
case|case
name|DEV_DIR
case|:
if|if
condition|(
name|front
operator|->
name|by
operator|.
name|Dir
operator|.
name|parent
operator|==
name|front
condition|)
block|{
name|vn_p
operator|->
name|v_flag
operator||=
name|VROOT
expr_stmt|;
block|}
name|vn_p
operator|->
name|v_type
operator|=
name|VDIR
expr_stmt|;
break|break;
case|case
name|DEV_BDEV
case|:
name|vn_p
operator|->
name|v_type
operator|=
name|VBLK
expr_stmt|;
if|if
condition|(
name|nvp
operator|=
name|checkalias
argument_list|(
name|vn_p
argument_list|,
name|front
operator|->
name|by
operator|.
name|Bdev
operator|.
name|dev
argument_list|,
operator|(
expr|struct
name|mount
operator|*
operator|)
literal|0
argument_list|)
condition|)
block|{
name|vput
argument_list|(
name|vn_p
argument_list|)
expr_stmt|;
name|vn_p
operator|=
name|nvp
expr_stmt|;
block|}
break|break;
case|case
name|DEV_CDEV
case|:
name|vn_p
operator|->
name|v_type
operator|=
name|VCHR
expr_stmt|;
if|if
condition|(
name|nvp
operator|=
name|checkalias
argument_list|(
name|vn_p
argument_list|,
name|front
operator|->
name|by
operator|.
name|Cdev
operator|.
name|dev
argument_list|,
operator|(
expr|struct
name|mount
operator|*
operator|)
literal|0
argument_list|)
condition|)
block|{
name|vput
argument_list|(
name|vn_p
argument_list|)
expr_stmt|;
name|vn_p
operator|=
name|nvp
expr_stmt|;
block|}
break|break;
case|case
name|DEV_DDEV
case|:
break|break;
block|}
if|if
condition|(
name|vn_p
condition|)
block|{
name|vn_p
operator|->
name|v_mount
operator|=
name|front
operator|->
name|dvm
operator|->
name|mount
expr_stmt|;
comment|/* Duplicated */
operator|*
name|vn_pp
operator|=
name|vn_p
expr_stmt|;
name|vn_p
operator|->
name|v_data
operator|=
operator|(
name|void
operator|*
operator|)
name|front
expr_stmt|;
comment|/*XXX*/
comment|/* maybe not.. I mean what if it's a dev... (vnode at back)*/
block|}
else|else
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

