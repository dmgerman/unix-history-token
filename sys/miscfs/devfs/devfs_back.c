begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  Written by Julian Elischer (julian@DIALix.oz.au)  *  *	$Header: /pub/FreeBSD/FreeBSD-CVS/src/sys/miscfs/devfs/Attic/devfs_back.c,v 1.3 1995/05/30 08:06:49 rgrimes Exp $  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"types.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_comment
comment|/* define FWRITE ... */
end_comment

begin_include
include|#
directive|include
file|"conf.h"
end_include

begin_include
include|#
directive|include
file|"stat.h"
end_include

begin_include
include|#
directive|include
file|"mount.h"
end_include

begin_include
include|#
directive|include
file|"vnode.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_comment
comment|/* defines dirent structure		*/
end_comment

begin_include
include|#
directive|include
file|"devfsdefs.h"
end_include

begin_decl_stmt
name|devnm_p
name|dev_root
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* root of the backing tree */
end_comment

begin_decl_stmt
name|int
name|devfs_set_up
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* note tha we HAVE set up the backing tree */
end_comment

begin_comment
comment|/*  * Set up the root directory node in the backing plane  * This is happenning before the vfs system has been  * set up yet, so be careful about what we reference..  * Notice that the ops are by indirection.. as they haven't  * been set up yet!  */
end_comment

begin_function
name|void
name|devfs_back_init
parameter_list|()
comment|/*proto*/
block|{
name|devnm_p
name|devbp
decl_stmt|;
name|dn_p
name|dnp
decl_stmt|;
comment|/* 	 * This may be called several times.. only do it if it needs 	 * to be done. 	 */
if|if
condition|(
operator|!
name|devfs_set_up
condition|)
block|{
comment|/* 	 	 * Allocate and fill out a new backing node 	 	 */
if|if
condition|(
operator|!
operator|(
name|devbp
operator|=
operator|(
name|devnm_p
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|devnm_t
argument_list|)
argument_list|,
name|M_DEVFSBACK
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
condition|)
block|{
return|return ;
block|}
name|bzero
argument_list|(
name|devbp
argument_list|,
sizeof|sizeof
argument_list|(
name|devnm_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * And the devnode associated with it 		 */
if|if
condition|(
operator|!
operator|(
name|dnp
operator|=
operator|(
name|dn_p
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|devnode_t
argument_list|)
argument_list|,
name|M_DEVFSNODE
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|devbp
argument_list|,
name|M_DEVFSBACK
argument_list|)
expr_stmt|;
return|return ;
block|}
name|bzero
argument_list|(
name|dnp
argument_list|,
sizeof|sizeof
argument_list|(
name|devnode_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Link the two together 		 */
name|devbp
operator|->
name|dnp
operator|=
name|dnp
expr_stmt|;
name|dnp
operator|->
name|links
operator|=
literal|1
expr_stmt|;
comment|/* 		 * set up the directory node for the root 		 * and put in all the usual entries for a directory node 		 */
name|dnp
operator|->
name|type
operator|=
name|DEV_DIR
expr_stmt|;
name|dnp
operator|->
name|links
operator|++
expr_stmt|;
comment|/* for .*/
comment|/* root loops to self */
name|dnp
operator|->
name|by
operator|.
name|Dir
operator|.
name|parent
operator|=
name|dnp
expr_stmt|;
name|dnp
operator|->
name|links
operator|++
expr_stmt|;
comment|/* for ..*/
comment|/* 		 * set up the list of children (none so far) 		 */
name|dnp
operator|->
name|by
operator|.
name|Dir
operator|.
name|dirlist
operator|=
operator|(
name|devnm_p
operator|)
literal|0
expr_stmt|;
name|dnp
operator|->
name|by
operator|.
name|Dir
operator|.
name|dirlast
operator|=
operator|&
name|dnp
operator|->
name|by
operator|.
name|Dir
operator|.
name|dirlist
expr_stmt|;
name|dnp
operator|->
name|by
operator|.
name|Dir
operator|.
name|myname
operator|=
name|devbp
expr_stmt|;
comment|/* 		 * set up a pointer to directory type ops 		 */
name|dnp
operator|->
name|ops
operator|=
operator|&
name|devfs_vnodeop_p
expr_stmt|;
name|dnp
operator|->
name|mode
operator||=
literal|0555
expr_stmt|;
comment|/* default perms */
comment|/* 		 * note creation times etc, as now (boot time) 		 */
name|TIMEVAL_TO_TIMESPEC
argument_list|(
argument|&time
argument_list|,
argument|&(dnp->ctime)
argument_list|)
name|dnp
operator|->
name|mtime
operator|=
name|dnp
operator|->
name|ctime
expr_stmt|;
name|dnp
operator|->
name|atime
operator|=
name|dnp
operator|->
name|ctime
expr_stmt|;
comment|/* 		 * and the list of layers 		 */
name|devbp
operator|->
name|next_front
operator|=
name|NULL
expr_stmt|;
name|devbp
operator|->
name|prev_frontp
operator|=
operator|&
operator|(
name|devbp
operator|->
name|next_front
operator|)
expr_stmt|;
comment|/* 		 * next time, we don't need to do all this 		 */
name|dev_root
operator|=
name|devbp
expr_stmt|;
name|devfs_set_up
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/***********************************************************************\ * Given a starting node (0 for root) and a pathname, return the node	* * for the end item on the path. It MUST BE A DIRECTORY. If the 'CREATE'	* * option is true, then create any missing nodes in the path and create	* * and return the final node as well.					* * Generally, this MUST be the first function called by any module	* * as it also calls the initial setup code, in case it has never been	* * done yet.								* * This is used to set up a directory, before making nodes in it..	* *									* * Warning: This function is RECURSIVE.					* *	char	*path,		 find this dir (err if not dir)		* *	dn_p	dirnode,	 starting point  (0 = root)	 	* *	int	create,		 create path if not found 		* *	dn_p	*dn_pp)		 where to return the node of the dir	* \***********************************************************************/
end_comment

begin_function
name|int
name|dev_finddir
parameter_list|(
name|char
modifier|*
name|orig_path
parameter_list|,
name|dn_p
name|dirnode
parameter_list|,
name|int
name|create
parameter_list|,
name|dn_p
modifier|*
name|dn_pp
parameter_list|)
comment|/*proto*/
block|{
name|devnm_p
name|devbp
decl_stmt|;
name|char
name|pathbuf
index|[
name|DEVMAXPATHSIZE
index|]
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"dev_finddir\n"
operator|)
argument_list|)
expr_stmt|;
name|devfs_back_init
argument_list|()
expr_stmt|;
comment|/* in case we are the first */
if|if
condition|(
operator|!
name|dirnode
condition|)
name|dirnode
operator|=
name|dev_root
operator|->
name|dnp
expr_stmt|;
if|if
condition|(
name|dirnode
operator|->
name|type
operator|!=
name|DEV_DIR
condition|)
return|return
name|ENOTDIR
return|;
if|if
condition|(
name|strlen
argument_list|(
name|orig_path
argument_list|)
operator|>
operator|(
name|DEVMAXPATHSIZE
operator|-
literal|1
operator|)
condition|)
return|return
name|ENAMETOOLONG
return|;
name|path
operator|=
name|pathbuf
expr_stmt|;
name|strcpy
argument_list|(
name|path
argument_list|,
name|orig_path
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|path
operator|==
literal|'/'
condition|)
name|path
operator|++
expr_stmt|;
comment|/* always absolute, skip leading / */
comment|/***************************************\ 	* find the next segment of the name	* 	\***************************************/
name|cp
operator|=
name|name
operator|=
name|path
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|cp
operator|!=
literal|'/'
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|!=
literal|0
operator|)
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
comment|/***********************************************\ 	* Check to see if it's the last component	* 	\***********************************************/
if|if
condition|(
operator|*
name|cp
condition|)
block|{
name|path
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
comment|/* path refers to the rest */
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
comment|/* name is now a separate string */
if|if
condition|(
operator|!
operator|(
operator|*
name|path
operator|)
condition|)
block|{
name|path
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* was trailing slash */
block|}
block|}
else|else
block|{
name|path
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* no more to do */
block|}
comment|/***************************************\ 	* Start scanning along the linked list	* 	\***************************************/
name|devbp
operator|=
name|dirnode
operator|->
name|by
operator|.
name|Dir
operator|.
name|dirlist
expr_stmt|;
while|while
condition|(
name|devbp
operator|&&
name|strcmp
argument_list|(
name|devbp
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|devbp
operator|=
name|devbp
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|devbp
condition|)
block|{
comment|/* check it's a directory */
if|if
condition|(
name|devbp
operator|->
name|dnp
operator|->
name|type
operator|!=
name|DEV_DIR
condition|)
return|return
name|ENOTDIR
return|;
block|}
else|else
block|{
comment|/***************************************\ 		* The required element does not exist	* 		* So we will add it if asked to.	* 		\***************************************/
if|if
condition|(
operator|!
name|create
condition|)
return|return
name|ENOENT
return|;
if|if
condition|(
name|retval
operator|=
name|dev_add_node
argument_list|(
name|name
argument_list|,
name|dirnode
argument_list|,
name|DEV_DIR
argument_list|,
name|NULL
argument_list|,
operator|&
name|devbp
argument_list|)
condition|)
block|{
return|return
name|retval
return|;
block|}
block|}
if|if
condition|(
name|path
condition|)
comment|/* decide whether to recurse more or return */
block|{
return|return
operator|(
name|dev_finddir
argument_list|(
name|path
argument_list|,
name|devbp
operator|->
name|dnp
argument_list|,
name|create
argument_list|,
name|dn_pp
argument_list|)
operator|)
return|;
block|}
else|else
block|{
operator|*
name|dn_pp
operator|=
name|devbp
operator|->
name|dnp
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/***********************************************************************\ * Add a new element to the devfs backing structure. 			* \***********************************************************************/
end_comment

begin_function
name|int
name|dev_add_node
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|dn_p
name|dirnode
parameter_list|,
name|int
name|entrytype
parameter_list|,
name|union
name|typeinfo
modifier|*
name|by
parameter_list|,
name|devnm_p
modifier|*
name|devnm_pp
parameter_list|)
comment|/*proto*/
block|{
name|devnm_p
name|devbp
decl_stmt|;
name|devnm_p
name|realthing
decl_stmt|;
comment|/* needed to create an alias */
name|dn_p
name|dnp
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"dev_add_node\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirnode
operator|->
name|type
operator|!=
name|DEV_DIR
condition|)
return|return
operator|(
name|ENOTDIR
operator|)
return|;
if|if
condition|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|>
operator|(
name|DEVMAXNAMESIZE
operator|-
literal|1
operator|)
condition|)
return|return
operator|(
name|ENAMETOOLONG
operator|)
return|;
name|retval
operator|=
name|dev_finddir
argument_list|(
name|name
argument_list|,
name|dirnode
argument_list|,
literal|0
argument_list|,
operator|&
name|dnp
argument_list|)
expr_stmt|;
comment|/*don't create!*/
name|dnp
operator|=
name|NULL
expr_stmt|;
comment|/*just want the return code..*/
if|if
condition|(
name|retval
operator|!=
name|ENOENT
condition|)
comment|/* only acceptable answer */
return|return
operator|(
name|EEXIST
operator|)
return|;
comment|/* 	 * Allocate and fill out a new backing node 	 */
if|if
condition|(
operator|!
operator|(
name|devbp
operator|=
operator|(
name|devnm_p
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|devnm_t
argument_list|)
argument_list|,
name|M_DEVFSBACK
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
condition|)
block|{
return|return
name|ENOMEM
return|;
block|}
name|bzero
argument_list|(
name|devbp
argument_list|,
sizeof|sizeof
argument_list|(
name|devnm_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|dnp
operator|=
operator|(
name|dn_p
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|devnode_t
argument_list|)
argument_list|,
name|M_DEVFSNODE
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|devbp
argument_list|,
name|M_DEVFSBACK
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|bzero
argument_list|(
name|dnp
argument_list|,
sizeof|sizeof
argument_list|(
name|devnode_t
argument_list|)
argument_list|)
expr_stmt|;
name|devbp
operator|->
name|dnp
operator|=
name|dnp
expr_stmt|;
name|dnp
operator|->
name|links
operator|=
literal|1
expr_stmt|;
comment|/* implicit from our own name-node */
comment|/* 	 * note the node type we are adding 	 * and set the creation times to NOW 	 * put in it's name 	 * include the implicit link in the count of links to the devnode.. 	 * this stops it from being accidentally freed later. 	 */
name|strcpy
argument_list|(
name|devbp
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|type
operator|=
name|entrytype
expr_stmt|;
name|TIMEVAL_TO_TIMESPEC
argument_list|(
argument|&time
argument_list|,
argument|&(dnp->ctime)
argument_list|)
name|dnp
operator|->
name|mtime
operator|=
name|dnp
operator|->
name|ctime
expr_stmt|;
name|dnp
operator|->
name|atime
operator|=
name|dnp
operator|->
name|ctime
expr_stmt|;
comment|/* 	 * And set up a new 'clones' list (empty) 	 */
name|devbp
operator|->
name|prev_frontp
operator|=
operator|&
operator|(
name|devbp
operator|->
name|next_front
operator|)
expr_stmt|;
comment|/* 	 * Put it on the END of the linked list of directory entries 	 */
name|devbp
operator|->
name|parent
operator|=
name|dirnode
expr_stmt|;
name|devbp
operator|->
name|prevp
operator|=
name|dirnode
operator|->
name|by
operator|.
name|Dir
operator|.
name|dirlast
expr_stmt|;
name|devbp
operator|->
name|next
operator|=
operator|*
operator|(
name|devbp
operator|->
name|prevp
operator|)
expr_stmt|;
comment|/* should be NULL */
comment|/*right?*/
operator|*
operator|(
name|devbp
operator|->
name|prevp
operator|)
operator|=
name|devbp
expr_stmt|;
name|dirnode
operator|->
name|by
operator|.
name|Dir
operator|.
name|dirlast
operator|=
operator|&
operator|(
name|devbp
operator|->
name|next
operator|)
expr_stmt|;
name|dirnode
operator|->
name|by
operator|.
name|Dir
operator|.
name|entrycount
operator|++
expr_stmt|;
comment|/* 	 * return the answer 	 */
switch|switch
condition|(
name|entrytype
condition|)
block|{
case|case
name|DEV_DIR
case|:
comment|/* 		 * As it's a directory, make sure it has a null entries list 		 */
name|dnp
operator|->
name|by
operator|.
name|Dir
operator|.
name|dirlast
operator|=
operator|&
operator|(
name|dnp
operator|->
name|by
operator|.
name|Dir
operator|.
name|dirlist
operator|)
expr_stmt|;
name|dnp
operator|->
name|by
operator|.
name|Dir
operator|.
name|dirlist
operator|=
operator|(
name|devnm_p
operator|)
literal|0
expr_stmt|;
name|dnp
operator|->
name|by
operator|.
name|Dir
operator|.
name|parent
operator|=
operator|(
name|dn_p
operator|)
name|dirnode
expr_stmt|;
name|dnp
operator|->
name|by
operator|.
name|Dir
operator|.
name|myname
operator|=
name|devbp
expr_stmt|;
comment|/* 		 * make sure that the ops associated with it are the ops 		 * that we use (by default) for directories 		 */
name|dnp
operator|->
name|ops
operator|=
operator|&
name|devfs_vnodeop_p
expr_stmt|;
name|dnp
operator|->
name|mode
operator||=
literal|0555
expr_stmt|;
comment|/* default perms */
break|break;
case|case
name|DEV_BDEV
case|:
comment|/* 		 * Make sure it has DEVICE type ops 		 * and device specific fields are correct 		 */
name|dnp
operator|->
name|ops
operator|=
operator|&
name|dev_spec_vnodeop_p
expr_stmt|;
name|dnp
operator|->
name|by
operator|.
name|Bdev
operator|.
name|bdevsw
operator|=
name|by
operator|->
name|Bdev
operator|.
name|bdevsw
expr_stmt|;
name|dnp
operator|->
name|by
operator|.
name|Bdev
operator|.
name|dev
operator|=
name|by
operator|->
name|Bdev
operator|.
name|dev
expr_stmt|;
break|break;
case|case
name|DEV_CDEV
case|:
comment|/* 		 * Make sure it has DEVICE type ops 		 * and device specific fields are correct 		 */
name|dnp
operator|->
name|ops
operator|=
operator|&
name|dev_spec_vnodeop_p
expr_stmt|;
name|dnp
operator|->
name|by
operator|.
name|Cdev
operator|.
name|cdevsw
operator|=
name|by
operator|->
name|Cdev
operator|.
name|cdevsw
expr_stmt|;
name|dnp
operator|->
name|by
operator|.
name|Cdev
operator|.
name|dev
operator|=
name|by
operator|->
name|Cdev
operator|.
name|dev
expr_stmt|;
break|break;
case|case
name|DEV_DDEV
case|:
comment|/* 		 * store the address of (the address of) the ops 		 * and the magic cookie to use with them 		 */
name|dnp
operator|->
name|by
operator|.
name|Ddev
operator|.
name|arg
operator|=
name|by
operator|->
name|Ddev
operator|.
name|arg
expr_stmt|;
name|dnp
operator|->
name|ops
operator|=
name|by
operator|->
name|Ddev
operator|.
name|ops
expr_stmt|;
break|break;
case|case
name|DEV_ALIAS
case|:
comment|/* 		 * point to the node we want to shadow 		 * Also store the fact we exist so that aliases 		 * can be deleted accuratly when the original node 		 * is deleted.. (i.e. when device is removed) 		 */
name|realthing
operator|=
name|by
operator|->
name|Alias
operator|.
name|realthing
expr_stmt|;
name|dnp
operator|->
name|by
operator|.
name|Alias
operator|.
name|realthing
operator|=
name|realthing
expr_stmt|;
name|dnp
operator|->
name|by
operator|.
name|Alias
operator|.
name|next
operator|=
name|realthing
operator|->
name|as
operator|.
name|back
operator|.
name|aliases
expr_stmt|;
name|realthing
operator|->
name|as
operator|.
name|back
operator|.
name|aliases
operator|=
name|devbp
expr_stmt|;
name|realthing
operator|->
name|as
operator|.
name|back
operator|.
name|alias_count
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|retval
operator|=
name|devfs_add_fronts
argument_list|(
name|dirnode
operator|->
name|by
operator|.
name|Dir
operator|.
name|myname
comment|/*XXX*/
argument_list|,
name|devbp
argument_list|)
condition|)
block|{
comment|/*XXX*/
comment|/* no idea what to do if it fails... */
return|return
name|retval
return|;
block|}
operator|*
name|devnm_pp
operator|=
name|devbp
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/***********************************************************************  * remove all fronts to this dev and also it's aliases,  * Then remove this node.  * For now only allow DEVICE nodes to go.. XXX  * directory nodes are more complicated and may need more work..  */
end_comment

begin_function
name|int
name|dev_remove
parameter_list|(
name|devnm_p
name|devbp
parameter_list|)
comment|/*proto*/
block|{
name|devnm_p
name|alias
decl_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"dev_remove\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Check the type of the node.. for now don't allow dirs 	 */
switch|switch
condition|(
name|devbp
operator|->
name|dnp
operator|->
name|type
condition|)
block|{
case|case
name|DEV_BDEV
case|:
case|case
name|DEV_CDEV
case|:
case|case
name|DEV_DDEV
case|:
case|case
name|DEV_ALIAS
case|:
case|case
name|DEV_SLNK
case|:
break|break;
case|case
name|DEV_DIR
case|:
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * Free each alias 	 */
while|while
condition|(
name|devbp
operator|->
name|as
operator|.
name|back
operator|.
name|alias_count
condition|)
block|{
name|alias
operator|=
name|devbp
operator|->
name|as
operator|.
name|back
operator|.
name|aliases
expr_stmt|;
name|devbp
operator|->
name|as
operator|.
name|back
operator|.
name|aliases
operator|=
name|alias
operator|->
name|dnp
operator|->
name|by
operator|.
name|Alias
operator|.
name|next
expr_stmt|;
name|devbp
operator|->
name|as
operator|.
name|back
operator|.
name|alias_count
operator|--
expr_stmt|;
name|devfs_dn_free
argument_list|(
name|alias
operator|->
name|dnp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|alias
argument_list|,
name|M_DEVFSBACK
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now remove front items of the Main node itself 	 */
name|devfs_remove_fronts
argument_list|(
name|devbp
argument_list|)
expr_stmt|;
comment|/* 	 * now we should free the main node 	 */
name|devfs_dn_free
argument_list|(
name|devbp
operator|->
name|dnp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|devbp
argument_list|,
name|M_DEVFSBACK
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|dev_touch
parameter_list|(
name|devnm_p
name|key
parameter_list|)
comment|/* update the node for this dev */
comment|/*proto*/
block|{
name|DBPRINT
argument_list|(
operator|(
literal|"dev_touch\n"
operator|)
argument_list|)
expr_stmt|;
name|TIMEVAL_TO_TIMESPEC
argument_list|(
argument|&time
argument_list|,
argument|&(key->dnp->mtime)
argument_list|)
return|return
literal|0
return|;
comment|/*XXX*/
block|}
end_function

begin_function
name|void
name|devfs_dn_free
parameter_list|(
name|dn_p
name|dnp
parameter_list|)
comment|/*proto*/
block|{
if|if
condition|(
name|dnp
operator|->
name|links
operator|<=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"devfs node reference count bogus\n"
argument_list|)
expr_stmt|;
name|Debugger
argument_list|(
literal|"devfs_dn_free"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|--
name|dnp
operator|->
name|links
operator|==
literal|0
condition|)
block|{
name|devfs_dropvnode
argument_list|(
name|dnp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dnp
argument_list|,
name|M_DEVFSNODE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/***********************************************************************\ * UTILITY routine:							* * Return the major number for the cdevsw entry containing the given	* * address.								* \***********************************************************************/
end_comment

begin_function
name|int
name|get_cdev_major_num
parameter_list|(
name|caddr_t
name|addr
parameter_list|)
comment|/*proto*/
block|{
name|int
name|index
init|=
literal|0
decl_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"get_cdev_major_num\n"
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|index
operator|<
name|nchrdev
condition|)
block|{
if|if
condition|(
operator|(
call|(
name|caddr_t
call|)
argument_list|(
name|cdevsw
index|[
name|index
index|]
operator|.
name|d_open
argument_list|)
operator|==
name|addr
operator|)
operator|||
operator|(
call|(
name|caddr_t
call|)
argument_list|(
name|cdevsw
index|[
name|index
index|]
operator|.
name|d_read
argument_list|)
operator|==
name|addr
operator|)
operator|||
operator|(
call|(
name|caddr_t
call|)
argument_list|(
name|cdevsw
index|[
name|index
index|]
operator|.
name|d_ioctl
argument_list|)
operator|==
name|addr
operator|)
condition|)
block|{
return|return
name|index
return|;
block|}
name|index
operator|++
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|get_bdev_major_num
parameter_list|(
name|caddr_t
name|addr
parameter_list|)
comment|/*proto*/
block|{
name|int
name|index
init|=
literal|0
decl_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"get_bdev_major_num\n"
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|index
operator|<
name|nblkdev
condition|)
block|{
if|if
condition|(
operator|(
call|(
name|caddr_t
call|)
argument_list|(
name|bdevsw
index|[
name|index
index|]
operator|.
name|d_open
argument_list|)
operator|==
name|addr
operator|)
operator|||
operator|(
call|(
name|caddr_t
call|)
argument_list|(
name|bdevsw
index|[
name|index
index|]
operator|.
name|d_strategy
argument_list|)
operator|==
name|addr
operator|)
operator|||
operator|(
call|(
name|caddr_t
call|)
argument_list|(
name|bdevsw
index|[
name|index
index|]
operator|.
name|d_ioctl
argument_list|)
operator|==
name|addr
operator|)
condition|)
block|{
return|return
name|index
return|;
block|}
name|index
operator|++
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/***********************************************************************\ * Add the named device entry into the given directory, and make it 	* * The appropriate type... (called (sometimes indirectly) by drivers..)	* \***********************************************************************/
end_comment

begin_function
name|devnm_p
name|dev_add
parameter_list|(
name|char
modifier|*
name|path
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|caddr_t
name|funct
parameter_list|,
name|int
name|minor
parameter_list|,
name|int
name|chrblk
parameter_list|,
name|uid_t
name|uid
parameter_list|,
name|gid_t
name|gid
parameter_list|,
name|int
name|perms
parameter_list|)
comment|/*proto*/
block|{
name|devnm_p
name|new_dev
decl_stmt|;
name|dn_p
name|dnp
decl_stmt|;
comment|/* devnode for parent directory */
name|int
name|retval
decl_stmt|;
name|int
name|major
decl_stmt|;
name|union
name|typeinfo
name|by
decl_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"dev_add\n"
operator|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|dev_finddir
argument_list|(
name|path
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
operator|&
name|dnp
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|chrblk
condition|)
block|{
case|case
literal|0
case|:
name|major
operator|=
name|get_cdev_major_num
argument_list|(
name|funct
argument_list|)
expr_stmt|;
name|by
operator|.
name|Cdev
operator|.
name|cdevsw
operator|=
name|cdevsw
operator|+
name|major
expr_stmt|;
name|by
operator|.
name|Cdev
operator|.
name|dev
operator|=
name|makedev
argument_list|(
name|major
argument_list|,
name|minor
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_add_node
argument_list|(
name|name
argument_list|,
name|dnp
argument_list|,
name|DEV_CDEV
argument_list|,
operator|&
name|by
argument_list|,
operator|&
name|new_dev
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|1
case|:
name|major
operator|=
name|get_bdev_major_num
argument_list|(
name|funct
argument_list|)
expr_stmt|;
name|by
operator|.
name|Bdev
operator|.
name|bdevsw
operator|=
name|bdevsw
operator|+
name|major
expr_stmt|;
name|by
operator|.
name|Bdev
operator|.
name|dev
operator|=
name|makedev
argument_list|(
name|major
argument_list|,
name|minor
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_add_node
argument_list|(
name|name
argument_list|,
name|dnp
argument_list|,
name|DEV_BDEV
argument_list|,
operator|&
name|by
argument_list|,
operator|&
name|new_dev
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|new_dev
operator|->
name|dnp
operator|->
name|gid
operator|=
name|gid
expr_stmt|;
name|new_dev
operator|->
name|dnp
operator|->
name|uid
operator|=
name|uid
expr_stmt|;
name|new_dev
operator|->
name|dnp
operator|->
name|mode
operator||=
name|perms
expr_stmt|;
return|return
name|new_dev
return|;
block|}
end_function

end_unit

