begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  *  Written by Julian Elischer (julian@DIALix.oz.au)  *  *	$Header: /home/ncvs/src/sys/miscfs/devfs/devfs_vfsops.c,v 1.23 1997/10/16 06:29:27 julian Exp $  *  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<miscfs/devfs/devfsdefs.h>
end_include

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_DEVFSMNT
argument_list|,
literal|"DEVFS mount"
argument_list|,
literal|"DEVFS mount structure"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|devfs_statfs
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|statfs
modifier|*
name|sbp
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*-  * Called from the generic VFS startups.  * This is the second stage of DEVFS initialisation.  * The probed devices have already been loaded and the   * basic structure of the DEVFS created.  * We take the oportunity to mount the hidden DEVFS layer, so that  * devices from devfs get sync'd.  */
end_comment

begin_function
specifier|static
name|int
name|devfs_init
parameter_list|(
name|struct
name|vfsconf
modifier|*
name|vfsp
parameter_list|)
block|{
name|struct
name|mount
modifier|*
name|mp
init|=
name|dev_root
operator|->
name|dnp
operator|->
name|dvm
operator|->
name|mount
decl_stmt|;
comment|/*- 	 * fill in the missing members on the "hidden" mount 	 * we could almost use vfs_rootmountalloc() to do this. 	 */
name|lockinit
argument_list|(
operator|&
name|mp
operator|->
name|mnt_lock
argument_list|,
name|PVFS
argument_list|,
literal|"vfslock"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_op
operator|=
name|vfsp
operator|->
name|vfc_vfsops
expr_stmt|;
name|mp
operator|->
name|mnt_vfc
operator|=
name|vfsp
expr_stmt|;
name|mp
operator|->
name|mnt_stat
operator|.
name|f_type
operator|=
name|vfsp
operator|->
name|vfc_typenum
expr_stmt|;
name|mp
operator|->
name|mnt_flag
operator||=
name|vfsp
operator|->
name|vfc_flags
operator|&
name|MNT_VISFLAGMASK
expr_stmt|;
name|strncpy
argument_list|(
name|mp
operator|->
name|mnt_stat
operator|.
name|f_fstypename
argument_list|,
name|vfsp
operator|->
name|vfc_name
argument_list|,
name|MFSNAMELEN
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_vnodecovered
operator|=
name|NULLVP
expr_stmt|;
comment|/* Mark a reference for the "invisible" blueprint mount */
name|mp
operator|->
name|mnt_vfc
operator|->
name|vfc_refcount
operator|++
expr_stmt|;
name|CIRCLEQ_INSERT_TAIL
argument_list|(
operator|&
name|mountlist
argument_list|,
name|mp
argument_list|,
name|mnt_list
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"DEVFS: ready to run\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/*XXX*/
block|}
end_function

begin_comment
comment|/*-  *  mp	 - pointer to 'mount' structure  *  path - addr in user space of mount point (ie /usr or whatever)  *  data - addr in user space of mount params including the  *         name of the block special file to treat as a filesystem.  *  ndp  - namei data pointer  *  p    - proc pointer  * devfs is special in that it doesn't require any device to be mounted..  * It makes up it's data as it goes along.  * it must be mounted during single user.. until it is, only std{in/out/err}  * and the root filesystem are available.  */
end_comment

begin_comment
comment|/*proto*/
end_comment

begin_function
name|int
name|devfs_mount
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|struct
name|nameidata
modifier|*
name|ndp
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|devfsmount
modifier|*
name|devfs_mp_p
decl_stmt|;
comment|/* devfs specific mount info */
name|int
name|error
decl_stmt|;
name|u_int
name|size
decl_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"mount "
operator|)
argument_list|)
expr_stmt|;
comment|/*- 	 *  If they just want to update, we don't need to do anything. 	 */
if|if
condition|(
name|mp
operator|->
name|mnt_flag
operator|&
name|MNT_UPDATE
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/*- 	 *  Well, it's not an update, it's a real mount request. 	 *  Time to get dirty. 	 * HERE we should check to see if we are already mounted here. 	 */
name|devfs_mp_p
operator|=
operator|(
expr|struct
name|devfsmount
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|devfs_mp_p
argument_list|,
name|M_DEVFSMNT
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|devfs_mp_p
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|bzero
argument_list|(
name|devfs_mp_p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|devfs_mp_p
argument_list|)
argument_list|)
expr_stmt|;
name|devfs_mp_p
operator|->
name|mount
operator|=
name|mp
expr_stmt|;
name|mp
operator|->
name|mnt_data
operator|=
operator|(
name|void
operator|*
operator|)
name|devfs_mp_p
expr_stmt|;
comment|/*- 	 *  Fill out some fields 	 */
name|mp
operator|->
name|mnt_data
operator|=
operator|(
name|qaddr_t
operator|)
name|devfs_mp_p
expr_stmt|;
name|mp
operator|->
name|mnt_stat
operator|.
name|f_type
operator|=
name|MOUNT_DEVFS
expr_stmt|;
name|mp
operator|->
name|mnt_stat
operator|.
name|f_fsid
operator|.
name|val
index|[
literal|0
index|]
operator|=
operator|(
name|long
operator|)
name|devfs_mp_p
expr_stmt|;
name|mp
operator|->
name|mnt_stat
operator|.
name|f_fsid
operator|.
name|val
index|[
literal|1
index|]
operator|=
name|MOUNT_DEVFS
expr_stmt|;
name|mp
operator|->
name|mnt_flag
operator||=
name|MNT_LOCAL
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|dev_dup_plane
argument_list|(
name|devfs_mp_p
argument_list|)
condition|)
block|{
name|mp
operator|->
name|mnt_data
operator|=
operator|(
name|qaddr_t
operator|)
literal|0
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|devfs_mp_p
argument_list|,
name|M_DEVFSMNT
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/*- 	 *  Copy in the name of the directory the filesystem 	 *  is to be mounted on. 	 *  And we clear the remainder of the character strings 	 *  to be tidy. 	 *  Then, we try to fill in the filesystem stats structure 	 *  as best we can with whatever we can think of at the time 	 */
if|if
condition|(
name|devfs_up_and_going
condition|)
block|{
name|copyinstr
argument_list|(
name|path
argument_list|,
operator|(
name|caddr_t
operator|)
name|mp
operator|->
name|mnt_stat
operator|.
name|f_mntonname
argument_list|,
sizeof|sizeof
argument_list|(
name|mp
operator|->
name|mnt_stat
operator|.
name|f_mntonname
argument_list|)
operator|-
literal|1
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|mp
operator|->
name|mnt_stat
operator|.
name|f_mntonname
operator|+
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|mp
operator|->
name|mnt_stat
operator|.
name|f_mntonname
argument_list|)
operator|-
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
literal|"dummy_mount"
argument_list|,
operator|(
name|caddr_t
operator|)
name|mp
operator|->
name|mnt_stat
operator|.
name|f_mntonname
argument_list|,
literal|12
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
name|mp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|,
name|MNAMELEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
literal|"devfs"
argument_list|,
name|mp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|,
literal|5
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|devfs_statfs
argument_list|(
name|mp
argument_list|,
operator|&
name|mp
operator|->
name|mnt_stat
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|devfs_start
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|DBPRINT
argument_list|(
operator|(
literal|"start "
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*-  *  Unmount the filesystem described by mp.  */
end_comment

begin_function
specifier|static
name|int
name|devfs_unmount
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|int
name|mntflags
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|devfsmount
modifier|*
name|devfs_mp_p
init|=
operator|(
expr|struct
name|devfsmount
operator|*
operator|)
name|mp
operator|->
name|mnt_data
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|;
name|printf
argument_list|(
literal|"-devfs_unmount-"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mntflags
operator|&
name|MNT_FORCE
condition|)
block|{
name|flags
operator||=
name|FORCECLOSE
expr_stmt|;
block|}
name|error
operator|=
name|vflush
argument_list|(
name|mp
argument_list|,
name|NULLVP
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|DBPRINT
argument_list|(
operator|(
literal|"unmount "
operator|)
argument_list|)
expr_stmt|;
name|devfs_free_plane
argument_list|(
name|devfs_mp_p
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|devfs_mp_p
argument_list|,
name|M_DEVFSMNT
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_data
operator|=
operator|(
name|qaddr_t
operator|)
literal|0
expr_stmt|;
name|mp
operator|->
name|mnt_flag
operator|&=
operator|~
name|MNT_LOCAL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* return the address of the root vnode  in *vpp */
end_comment

begin_function
specifier|static
name|int
name|devfs_root
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|)
block|{
name|struct
name|devfsmount
modifier|*
name|devfs_mp_p
init|=
operator|(
expr|struct
name|devfsmount
operator|*
operator|)
operator|(
name|mp
operator|->
name|mnt_data
operator|)
decl_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"root "
operator|)
argument_list|)
expr_stmt|;
name|devfs_dntovn
argument_list|(
name|devfs_mp_p
operator|->
name|plane_root
operator|->
name|dnp
argument_list|,
name|vpp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|devfs_quotactl
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|int
name|cmds
parameter_list|,
name|uid_t
name|uid
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|DBPRINT
argument_list|(
operator|(
literal|"quotactl "
operator|)
argument_list|)
expr_stmt|;
return|return
name|EOPNOTSUPP
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|devfs_statfs
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|statfs
modifier|*
name|sbp
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|devfsmount
modifier|*
name|devfs_mp_p
init|=
operator|(
expr|struct
name|devfsmount
operator|*
operator|)
name|mp
operator|->
name|mnt_data
decl_stmt|;
comment|/*-  *  Fill in the stat block.  */
name|DBPRINT
argument_list|(
operator|(
literal|"statfs "
operator|)
argument_list|)
expr_stmt|;
name|sbp
operator|->
name|f_type
operator|=
name|MOUNT_DEVFS
expr_stmt|;
name|sbp
operator|->
name|f_flags
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
name|sbp
operator|->
name|f_bsize
operator|=
literal|128
expr_stmt|;
name|sbp
operator|->
name|f_iosize
operator|=
literal|1024
expr_stmt|;
comment|/* XXX*/
name|sbp
operator|->
name|f_blocks
operator|=
literal|128
expr_stmt|;
name|sbp
operator|->
name|f_bfree
operator|=
literal|0
expr_stmt|;
name|sbp
operator|->
name|f_bavail
operator|=
literal|0
expr_stmt|;
name|sbp
operator|->
name|f_files
operator|=
literal|128
expr_stmt|;
name|sbp
operator|->
name|f_ffree
operator|=
literal|0
expr_stmt|;
comment|/* what to put in here? */
name|sbp
operator|->
name|f_fsid
operator|.
name|val
index|[
literal|0
index|]
operator|=
operator|(
name|long
operator|)
name|devfs_mp_p
expr_stmt|;
name|sbp
operator|->
name|f_fsid
operator|.
name|val
index|[
literal|1
index|]
operator|=
name|MOUNT_DEVFS
expr_stmt|;
comment|/*-  *  Copy the mounted on and mounted from names into  *  the passed in stat block, if it is not the one  *  in the mount structure.  */
if|if
condition|(
name|sbp
operator|!=
operator|&
name|mp
operator|->
name|mnt_stat
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|mp
operator|->
name|mnt_stat
operator|.
name|f_mntonname
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sbp
operator|->
name|f_mntonname
index|[
literal|0
index|]
argument_list|,
name|MNAMELEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|mp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sbp
operator|->
name|f_mntfromname
index|[
literal|0
index|]
argument_list|,
name|MNAMELEN
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*-  * Go through the disk queues to initiate sandbagged IO;  * go through the inodes to write those that have been modified;  * initiate the writing of the super block if it has been modified.  *  * Note: we are always called with the filesystem marked `MPBUSY'.  */
end_comment

begin_function
specifier|static
name|int
name|devfs_sync
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|int
name|waitfor
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
specifier|register
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|,
modifier|*
name|nvp
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|int
name|error
decl_stmt|,
name|allerror
init|=
literal|0
decl_stmt|;
name|DBPRINT
argument_list|(
operator|(
literal|"sync "
operator|)
argument_list|)
expr_stmt|;
comment|/*- 	 * Write back modified superblock. 	 * Consistency check that the superblock 	 * is still in the buffer cache. 	 */
comment|/*- 	 * Write back each (modified) inode. 	 */
name|loop
label|:
for|for
control|(
name|vp
operator|=
name|mp
operator|->
name|mnt_vnodelist
operator|.
name|lh_first
init|;
name|vp
operator|!=
name|NULL
condition|;
name|vp
operator|=
name|nvp
control|)
block|{
comment|/*- 		 * If the vnode that we are about to sync is no longer 		 * associated with this mount point, start over. 		 */
if|if
condition|(
name|vp
operator|->
name|v_mount
operator|!=
name|mp
condition|)
goto|goto
name|loop
goto|;
name|nvp
operator|=
name|vp
operator|->
name|v_mntvnodes
operator|.
name|le_next
expr_stmt|;
if|if
condition|(
name|VOP_ISLOCKED
argument_list|(
name|vp
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|vp
operator|->
name|v_dirtyblkhd
operator|.
name|lh_first
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VBLK
condition|)
block|{
if|if
condition|(
name|vget
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|loop
goto|;
name|error
operator|=
name|VOP_FSYNC
argument_list|(
name|vp
argument_list|,
name|cred
argument_list|,
name|waitfor
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|allerror
operator|=
name|error
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|NOTYET
else|else
block|{
name|tv
operator|=
name|time
expr_stmt|;
comment|/* VOP_UPDATE(vp,&tv,&tv, waitfor == MNT_WAIT); */
name|VOP_UPDATE
argument_list|(
name|vp
argument_list|,
operator|&
name|tv
argument_list|,
operator|&
name|tv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/*- 	 * Force stale file system control information to be flushed. 	 *( except that htat makes no sense with devfs 	 */
return|return
operator|(
name|allerror
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|devfs_vget
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|ino_t
name|ino
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|)
block|{
name|DBPRINT
argument_list|(
operator|(
literal|"vget "
operator|)
argument_list|)
expr_stmt|;
return|return
name|EOPNOTSUPP
return|;
block|}
end_function

begin_comment
comment|/*************************************************************  * The concept of exporting a kernel generated devfs is stupid  * So don't handle filehandles  */
end_comment

begin_function
specifier|static
name|int
name|devfs_fhtovp
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|fid
modifier|*
name|fhp
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|,
name|int
modifier|*
name|exflagsp
parameter_list|,
name|struct
name|ucred
modifier|*
modifier|*
name|credanonp
parameter_list|)
block|{
name|DBPRINT
argument_list|(
operator|(
literal|"fhtovp "
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|devfs_vptofh
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|fid
modifier|*
name|fhp
parameter_list|)
block|{
name|DBPRINT
argument_list|(
operator|(
literal|"vptofh "
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|vfsops
name|devfs_vfsops
init|=
block|{
name|devfs_mount
block|,
name|devfs_start
block|,
name|devfs_unmount
block|,
name|devfs_root
block|,
name|devfs_quotactl
block|,
name|devfs_statfs
block|,
name|devfs_sync
block|,
name|devfs_vget
block|,
name|devfs_fhtovp
block|,
name|devfs_vptofh
block|,
name|devfs_init
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|VFS_SET
argument_list|(
name|devfs_vfsops
argument_list|,
name|devfs
argument_list|,
name|MOUNT_DEVFS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

