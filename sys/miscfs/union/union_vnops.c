begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, 1993, 1994, 1995 Jan-Simon Pendry.  * Copyright (c) 1992, 1993, 1994, 1995  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Jan-Simon Pendry.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)union_vnops.c	8.32 (Berkeley) 6/23/95  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<miscfs/union/union.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vnode_pager.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_decl_stmt
name|int
name|uniondebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|UDEBUG_ENABLED
end_if

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs
argument_list|,
name|OID_AUTO
argument_list|,
name|uniondebug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|uniondebug
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs
argument_list|,
name|OID_AUTO
argument_list|,
name|uniondebug
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|uniondebug
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|union_access
name|__P
argument_list|(
operator|(
expr|struct
name|vop_access_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_advlock
name|__P
argument_list|(
operator|(
expr|struct
name|vop_advlock_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_bmap
name|__P
argument_list|(
operator|(
expr|struct
name|vop_bmap_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_close
name|__P
argument_list|(
operator|(
expr|struct
name|vop_close_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_create
name|__P
argument_list|(
operator|(
expr|struct
name|vop_create_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_fsync
name|__P
argument_list|(
operator|(
expr|struct
name|vop_fsync_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_getattr
name|__P
argument_list|(
operator|(
expr|struct
name|vop_getattr_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_inactive
name|__P
argument_list|(
operator|(
expr|struct
name|vop_inactive_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_ioctl
name|__P
argument_list|(
operator|(
expr|struct
name|vop_ioctl_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_lease
name|__P
argument_list|(
operator|(
expr|struct
name|vop_lease_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_link
name|__P
argument_list|(
operator|(
expr|struct
name|vop_link_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_lock
name|__P
argument_list|(
operator|(
expr|struct
name|vop_lock_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_lookup
name|__P
argument_list|(
operator|(
expr|struct
name|vop_lookup_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_lookup1
name|__P
argument_list|(
operator|(
expr|struct
name|vnode
operator|*
name|udvp
operator|,
expr|struct
name|vnode
operator|*
operator|*
name|dvp
operator|,
expr|struct
name|vnode
operator|*
operator|*
name|vpp
operator|,
expr|struct
name|componentname
operator|*
name|cnp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_mkdir
name|__P
argument_list|(
operator|(
expr|struct
name|vop_mkdir_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_mknod
name|__P
argument_list|(
operator|(
expr|struct
name|vop_mknod_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_mmap
name|__P
argument_list|(
operator|(
expr|struct
name|vop_mmap_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_open
name|__P
argument_list|(
operator|(
expr|struct
name|vop_open_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_pathconf
name|__P
argument_list|(
operator|(
expr|struct
name|vop_pathconf_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_print
name|__P
argument_list|(
operator|(
expr|struct
name|vop_print_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_read
name|__P
argument_list|(
operator|(
expr|struct
name|vop_read_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_readdir
name|__P
argument_list|(
operator|(
expr|struct
name|vop_readdir_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_readlink
name|__P
argument_list|(
operator|(
expr|struct
name|vop_readlink_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_getwritemount
name|__P
argument_list|(
operator|(
expr|struct
name|vop_getwritemount_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_reclaim
name|__P
argument_list|(
operator|(
expr|struct
name|vop_reclaim_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_remove
name|__P
argument_list|(
operator|(
expr|struct
name|vop_remove_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_rename
name|__P
argument_list|(
operator|(
expr|struct
name|vop_rename_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_revoke
name|__P
argument_list|(
operator|(
expr|struct
name|vop_revoke_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_rmdir
name|__P
argument_list|(
operator|(
expr|struct
name|vop_rmdir_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_poll
name|__P
argument_list|(
operator|(
expr|struct
name|vop_poll_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_setattr
name|__P
argument_list|(
operator|(
expr|struct
name|vop_setattr_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_strategy
name|__P
argument_list|(
operator|(
expr|struct
name|vop_strategy_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_getpages
name|__P
argument_list|(
operator|(
expr|struct
name|vop_getpages_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_putpages
name|__P
argument_list|(
operator|(
expr|struct
name|vop_putpages_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_symlink
name|__P
argument_list|(
operator|(
expr|struct
name|vop_symlink_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_unlock
name|__P
argument_list|(
operator|(
expr|struct
name|vop_unlock_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_whiteout
name|__P
argument_list|(
operator|(
expr|struct
name|vop_whiteout_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_write
name|__P
argument_list|(
operator|(
expr|struct
name|vop_read_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|vnode
operator|*
name|union_lock_upper
argument_list|(
argument|struct union_node *un
argument_list|,
argument|struct proc *p
argument_list|)
block|{ 	struct
name|vnode
operator|*
name|uppervp
block|;
if|if
condition|(
operator|(
name|uppervp
operator|=
name|un
operator|->
name|un_uppervp
operator|)
operator|!=
name|NULL
condition|)
block|{
name|VREF
argument_list|(
name|uppervp
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|uppervp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_CANRECURSE
operator||
name|LK_RETRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|KASSERT
argument_list|(
operator|(
name|uppervp
operator|==
name|NULL
operator|||
name|uppervp
operator|->
name|v_usecount
operator|>
literal|0
operator|)
argument_list|,
operator|(
literal|"uppervp usecount is 0"
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|uppervp
operator|)
return|;
end_return

begin_function
unit|}  static
name|__inline
name|void
name|union_unlock_upper
parameter_list|(
name|struct
name|vnode
modifier|*
name|uppervp
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|vput
argument_list|(
name|uppervp
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|vnode
operator|*
name|union_lock_other
argument_list|(
argument|struct union_node *un
argument_list|,
argument|struct proc *p
argument_list|)
block|{ 	struct
name|vnode
operator|*
name|vp
block|;
if|if
condition|(
name|un
operator|->
name|un_uppervp
operator|!=
name|NULL
condition|)
block|{
name|vp
operator|=
name|union_lock_upper
argument_list|(
name|un
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_elseif
elseif|else
if|if
condition|(
operator|(
name|vp
operator|=
name|un
operator|->
name|un_lowervp
operator|)
operator|!=
name|NULL
condition|)
block|{
name|VREF
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_CANRECURSE
operator||
name|LK_RETRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_elseif

begin_return
return|return
operator|(
name|vp
operator|)
return|;
end_return

begin_function
unit|}  static
name|__inline
name|void
name|union_unlock_other
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	union_lookup:  *  *	udvp	must be exclusively locked on call and will remain   *		exclusively locked on return.  This is the mount point   *		for out filesystem.  *  *	dvp	Our base directory, locked and referenced.  *		The passed dvp will be dereferenced and unlocked on return  *		and a new dvp will be returned which is locked and   *		referenced in the same variable.  *  *	vpp	is filled in with the result if no error occured,  *		locked and ref'd.  *  *		If an error is returned, *vpp is set to NULLVP.  If no  *		error occurs, *vpp is returned with a reference and an  *		exclusive lock.  */
end_comment

begin_function
specifier|static
name|int
name|union_lookup1
parameter_list|(
name|udvp
parameter_list|,
name|pdvp
parameter_list|,
name|vpp
parameter_list|,
name|cnp
parameter_list|)
name|struct
name|vnode
modifier|*
name|udvp
decl_stmt|;
name|struct
name|vnode
modifier|*
modifier|*
name|pdvp
decl_stmt|;
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|cnp
operator|->
name|cn_proc
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
init|=
operator|*
name|pdvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|tdvp
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
comment|/* 	 * If stepping up the directory tree, check for going 	 * back across the mount point, in which case do what 	 * lookup would do by stepping back down the mount 	 * hierarchy. 	 */
if|if
condition|(
name|cnp
operator|->
name|cn_flags
operator|&
name|ISDOTDOT
condition|)
block|{
while|while
condition|(
operator|(
name|dvp
operator|!=
name|udvp
operator|)
operator|&&
operator|(
name|dvp
operator|->
name|v_flag
operator|&
name|VROOT
operator|)
condition|)
block|{
comment|/* 			 * Don't do the NOCROSSMOUNT check 			 * at this level.  By definition, 			 * union fs deals with namespaces, not 			 * filesystems. 			 */
name|tdvp
operator|=
name|dvp
expr_stmt|;
name|dvp
operator|=
name|dvp
operator|->
name|v_mount
operator|->
name|mnt_vnodecovered
expr_stmt|;
name|VREF
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|dvp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Set return dvp to be the upperdvp 'parent directory. 	 */
operator|*
name|pdvp
operator|=
name|dvp
expr_stmt|;
comment|/* 	 * If the VOP_LOOKUP call generates an error, tdvp is invalid and no 	 * changes will have been made to dvp, so we are set to return. 	 */
name|error
operator|=
name|VOP_LOOKUP
argument_list|(
name|dvp
argument_list|,
operator|&
name|tdvp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|UDEBUG
argument_list|(
operator|(
literal|"dvp %p error %d flags %lx\n"
operator|,
name|dvp
operator|,
name|error
operator|,
name|cnp
operator|->
name|cn_flags
operator|)
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * The parent directory will have been unlocked, unless lookup 	 * found the last component or if dvp == tdvp (tdvp must be locked). 	 * 	 * We want our dvp to remain locked and ref'd.  We also want tdvp 	 * to remain locked and ref'd. 	 */
name|UDEBUG
argument_list|(
operator|(
literal|"parentdir %p result %p flag %lx\n"
operator|,
name|dvp
operator|,
name|tdvp
operator|,
name|cnp
operator|->
name|cn_flags
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dvp
operator|!=
name|tdvp
operator|&&
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|ISLASTCN
operator|)
operator|==
literal|0
condition|)
name|vn_lock
argument_list|(
name|dvp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* 	 * Lastly check if the current node is a mount point in 	 * which case walk up the mount hierarchy making sure not to 	 * bump into the root of the mount tree (ie. dvp != udvp). 	 * 	 * We use dvp as a temporary variable here, it is no longer related 	 * to the dvp above.  However, we have to ensure that both *pdvp and 	 * tdvp are locked on return. 	 */
name|dvp
operator|=
name|tdvp
expr_stmt|;
while|while
condition|(
name|dvp
operator|!=
name|udvp
operator|&&
operator|(
name|dvp
operator|->
name|v_type
operator|==
name|VDIR
operator|)
operator|&&
operator|(
name|mp
operator|=
name|dvp
operator|->
name|v_mountedhere
operator|)
condition|)
block|{
name|int
name|relock_pdvp
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|vfs_busy
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|dvp
operator|==
operator|*
name|pdvp
condition|)
name|relock_pdvp
operator|=
literal|1
expr_stmt|;
name|vput
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|dvp
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|VFS_ROOT
argument_list|(
name|mp
argument_list|,
operator|&
name|dvp
argument_list|)
expr_stmt|;
name|vfs_unbusy
argument_list|(
name|mp
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|relock_pdvp
condition|)
name|vn_lock
argument_list|(
operator|*
name|pdvp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
operator|*
name|vpp
operator|=
name|dvp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_lookup
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_lookup_args
comment|/* { 		struct vnodeop_desc *a_desc; 		struct vnode *a_dvp; 		struct vnode **a_vpp; 		struct componentname *a_cnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|int
name|uerror
decl_stmt|,
name|lerror
decl_stmt|;
name|struct
name|vnode
modifier|*
name|uppervp
decl_stmt|,
modifier|*
name|lowervp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|upperdvp
decl_stmt|,
modifier|*
name|lowerdvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
comment|/* starting dir */
name|struct
name|union_node
modifier|*
name|dun
init|=
name|VTOUNION
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
comment|/* associated union node */
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|cnp
operator|->
name|cn_proc
decl_stmt|;
name|int
name|lockparent
init|=
name|cnp
operator|->
name|cn_flags
operator|&
name|LOCKPARENT
decl_stmt|;
name|struct
name|union_mount
modifier|*
name|um
init|=
name|MOUNTTOUNIONMOUNT
argument_list|(
name|dvp
operator|->
name|v_mount
argument_list|)
decl_stmt|;
name|struct
name|ucred
modifier|*
name|saved_cred
init|=
name|NULL
decl_stmt|;
name|int
name|iswhiteout
decl_stmt|;
name|struct
name|vattr
name|va
decl_stmt|;
operator|*
name|ap
operator|->
name|a_vpp
operator|=
name|NULLVP
expr_stmt|;
comment|/* 	 * Disallow write attemps to the filesystem mounted read-only. 	 */
if|if
condition|(
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|ISLASTCN
operator|)
operator|&&
operator|(
name|dvp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
operator|&&
operator|(
name|cnp
operator|->
name|cn_nameiop
operator|==
name|DELETE
operator|||
name|cnp
operator|->
name|cn_nameiop
operator|==
name|RENAME
operator|)
condition|)
block|{
return|return
operator|(
name|EROFS
operator|)
return|;
block|}
comment|/* 	 * For any lookup's we do, always return with the parent locked 	 */
name|cnp
operator|->
name|cn_flags
operator||=
name|LOCKPARENT
expr_stmt|;
name|lowerdvp
operator|=
name|dun
operator|->
name|un_lowervp
expr_stmt|;
name|uppervp
operator|=
name|NULLVP
expr_stmt|;
name|lowervp
operator|=
name|NULLVP
expr_stmt|;
name|iswhiteout
operator|=
literal|0
expr_stmt|;
name|uerror
operator|=
name|ENOENT
expr_stmt|;
name|lerror
operator|=
name|ENOENT
expr_stmt|;
comment|/* 	 * Get a private lock on uppervp and a reference, effectively  	 * taking it out of the union_node's control. 	 * 	 * We must lock upperdvp while holding our lock on dvp 	 * to avoid a deadlock. 	 */
name|upperdvp
operator|=
name|union_lock_upper
argument_list|(
name|dun
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* 	 * do the lookup in the upper level. 	 * if that level comsumes additional pathnames, 	 * then assume that something special is going 	 * on and just return that vnode. 	 */
if|if
condition|(
name|upperdvp
operator|!=
name|NULLVP
condition|)
block|{
comment|/* 		 * We do not have to worry about the DOTDOT case, we've 		 * already unlocked dvp. 		 */
name|UDEBUG
argument_list|(
operator|(
literal|"A %p\n"
operator|,
name|upperdvp
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Do the lookup.   We must supply a locked and referenced 		 * upperdvp to the function and will get a new locked and 		 * referenced upperdvp back with the old having been  		 * dereferenced. 		 * 		 * If an error is returned, uppervp will be NULLVP.  If no 		 * error occurs, uppervp will be the locked and referenced 		 * return vnode or possibly NULL, depending on what is being 		 * requested.  It is possible that the returned uppervp 		 * will be the same as upperdvp. 		 */
name|uerror
operator|=
name|union_lookup1
argument_list|(
name|um
operator|->
name|um_uppervp
argument_list|,
operator|&
name|upperdvp
argument_list|,
operator|&
name|uppervp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
name|UDEBUG
argument_list|(
operator|(
literal|"uerror %d upperdvp %p %d/%d, uppervp %p ref=%d/lck=%d\n"
operator|,
name|uerror
operator|,
name|upperdvp
operator|,
name|upperdvp
operator|->
name|v_usecount
operator|,
name|VOP_ISLOCKED
argument_list|(
name|upperdvp
argument_list|,
name|NULL
argument_list|)
operator|,
name|uppervp
operator|,
operator|(
name|uppervp
condition|?
name|uppervp
operator|->
name|v_usecount
else|:
operator|-
literal|99
operator|)
operator|,
operator|(
name|uppervp
condition|?
name|VOP_ISLOCKED
argument_list|(
name|uppervp
argument_list|,
name|NULL
argument_list|)
else|:
operator|-
literal|99
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Disallow write attemps to the filesystem mounted read-only. 		 */
if|if
condition|(
name|uerror
operator|==
name|EJUSTRETURN
operator|&&
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|ISLASTCN
operator|)
operator|&&
operator|(
name|dvp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
operator|&&
operator|(
name|cnp
operator|->
name|cn_nameiop
operator|==
name|CREATE
operator|||
name|cnp
operator|->
name|cn_nameiop
operator|==
name|RENAME
operator|)
condition|)
block|{
name|error
operator|=
name|EROFS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 		 * Special case.  If cn_consume != 0 skip out.  The result 		 * of the lookup is transfered to our return variable.  If 		 * an error occured we have to throw away the results. 		 */
if|if
condition|(
name|cnp
operator|->
name|cn_consume
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|uerror
operator|)
operator|==
literal|0
condition|)
block|{
operator|*
name|ap
operator|->
name|a_vpp
operator|=
name|uppervp
expr_stmt|;
name|uppervp
operator|=
name|NULL
expr_stmt|;
block|}
goto|goto
name|out
goto|;
block|}
comment|/* 		 * Calculate whiteout, fall through 		 */
if|if
condition|(
name|uerror
operator|==
name|ENOENT
operator|||
name|uerror
operator|==
name|EJUSTRETURN
condition|)
block|{
if|if
condition|(
name|cnp
operator|->
name|cn_flags
operator|&
name|ISWHITEOUT
condition|)
block|{
name|iswhiteout
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lowerdvp
operator|!=
name|NULLVP
condition|)
block|{
name|int
name|terror
decl_stmt|;
name|terror
operator|=
name|VOP_GETATTR
argument_list|(
name|upperdvp
argument_list|,
operator|&
name|va
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|cnp
operator|->
name|cn_proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|terror
operator|==
literal|0
operator|&&
operator|(
name|va
operator|.
name|va_flags
operator|&
name|OPAQUE
operator|)
condition|)
name|iswhiteout
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * in a similar way to the upper layer, do the lookup 	 * in the lower layer.   this time, if there is some 	 * component magic going on, then vput whatever we got 	 * back from the upper layer and return the lower vnode 	 * instead. 	 */
if|if
condition|(
name|lowerdvp
operator|!=
name|NULLVP
operator|&&
operator|!
name|iswhiteout
condition|)
block|{
name|int
name|nameiop
decl_stmt|;
name|UDEBUG
argument_list|(
operator|(
literal|"B %p\n"
operator|,
name|lowerdvp
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Force only LOOKUPs on the lower node, since 		 * we won't be making changes to it anyway. 		 */
name|nameiop
operator|=
name|cnp
operator|->
name|cn_nameiop
expr_stmt|;
name|cnp
operator|->
name|cn_nameiop
operator|=
name|LOOKUP
expr_stmt|;
if|if
condition|(
name|um
operator|->
name|um_op
operator|==
name|UNMNT_BELOW
condition|)
block|{
name|saved_cred
operator|=
name|cnp
operator|->
name|cn_cred
expr_stmt|;
name|cnp
operator|->
name|cn_cred
operator|=
name|um
operator|->
name|um_cred
expr_stmt|;
block|}
comment|/* 		 * We shouldn't have to worry about locking interactions 		 * between the lower layer and our union layer (w.r.t. 		 * `..' processing) because we don't futz with lowervp 		 * locks in the union-node instantiation code path. 		 * 		 * union_lookup1() requires lowervp to be locked on entry, 		 * and it will be unlocked on return.  The ref count will 		 * not change.  On return lowervp doesn't represent anything 		 * to us so we NULL it out. 		 */
name|VREF
argument_list|(
name|lowerdvp
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|lowerdvp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|lerror
operator|=
name|union_lookup1
argument_list|(
name|um
operator|->
name|um_lowervp
argument_list|,
operator|&
name|lowerdvp
argument_list|,
operator|&
name|lowervp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lowerdvp
operator|==
name|lowervp
condition|)
name|vrele
argument_list|(
name|lowerdvp
argument_list|)
expr_stmt|;
else|else
name|vput
argument_list|(
name|lowerdvp
argument_list|)
expr_stmt|;
name|lowerdvp
operator|=
name|NULL
expr_stmt|;
comment|/* lowerdvp invalid after vput */
if|if
condition|(
name|um
operator|->
name|um_op
operator|==
name|UNMNT_BELOW
condition|)
name|cnp
operator|->
name|cn_cred
operator|=
name|saved_cred
expr_stmt|;
name|cnp
operator|->
name|cn_nameiop
operator|=
name|nameiop
expr_stmt|;
if|if
condition|(
name|cnp
operator|->
name|cn_consume
operator|!=
literal|0
operator|||
name|lerror
operator|==
name|EACCES
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|lerror
operator|)
operator|==
literal|0
condition|)
block|{
operator|*
name|ap
operator|->
name|a_vpp
operator|=
name|lowervp
expr_stmt|;
name|lowervp
operator|=
name|NULL
expr_stmt|;
block|}
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
name|UDEBUG
argument_list|(
operator|(
literal|"C %p\n"
operator|,
name|lowerdvp
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|ISDOTDOT
operator|)
operator|&&
name|dun
operator|->
name|un_pvp
operator|!=
name|NULLVP
condition|)
block|{
if|if
condition|(
operator|(
name|lowervp
operator|=
name|LOWERVP
argument_list|(
name|dun
operator|->
name|un_pvp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|VREF
argument_list|(
name|lowervp
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|lowervp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|lerror
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Ok.  Now we have uerror, uppervp, upperdvp, lerror, and lowervp. 	 * 	 * 1. If both layers returned an error, select the upper layer. 	 * 	 * 2. If the upper layer faile and the bottom layer succeeded, 	 *    two subcases occur: 	 * 	 *	a.  The bottom vnode is not a directory, in which case 	 *	    just return a new union vnode referencing an 	 *	    empty top layer and the existing bottom layer. 	 * 	 *	b.  The button vnode is a directory, in which case 	 *	    create a new directory in the top layer and 	 *	    and fall through to case 3. 	 * 	 * 3. If the top layer succeeded then return a new union 	 *    vnode referencing whatever the new top layer and 	 *    whatever the bottom layer returned. 	 */
comment|/* case 1. */
if|if
condition|(
operator|(
name|uerror
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|lerror
operator|!=
literal|0
operator|)
condition|)
block|{
name|error
operator|=
name|uerror
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* case 2. */
if|if
condition|(
name|uerror
operator|!=
literal|0
comment|/*&& (lerror == 0) */
condition|)
block|{
if|if
condition|(
name|lowervp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
block|{
comment|/* case 2b. */
name|KASSERT
argument_list|(
name|uppervp
operator|==
name|NULL
argument_list|,
operator|(
literal|"uppervp unexpectedly non-NULL"
operator|)
argument_list|)
expr_stmt|;
comment|/* 			 * oops, uppervp has a problem, we may have to shadow. 			 */
name|uerror
operator|=
name|union_mkshadow
argument_list|(
name|um
argument_list|,
name|upperdvp
argument_list|,
name|cnp
argument_list|,
operator|&
name|uppervp
argument_list|)
expr_stmt|;
if|if
condition|(
name|uerror
condition|)
block|{
name|error
operator|=
name|uerror
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
block|}
comment|/* 	 * Must call union_allocvp with both the upper and lower vnodes 	 * referenced and the upper vnode locked.   ap->a_vpp is returned  	 * referenced and locked.  lowervp, uppervp, and upperdvp are  	 * absorbed by union_allocvp() whether it succeeds or fails. 	 * 	 * upperdvp is the parent directory of uppervp which may be 	 * different, depending on the path, from dvp->un_uppervp.  That's 	 * why it is a separate argument.  Note that it must be unlocked. 	 * 	 * dvp must be locked on entry to the call and will be locked on 	 * return. 	 */
if|if
condition|(
name|uppervp
operator|&&
name|uppervp
operator|!=
name|upperdvp
condition|)
name|VOP_UNLOCK
argument_list|(
name|uppervp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|lowervp
condition|)
name|VOP_UNLOCK
argument_list|(
name|lowervp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|upperdvp
condition|)
name|VOP_UNLOCK
argument_list|(
name|upperdvp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|error
operator|=
name|union_allocvp
argument_list|(
name|ap
operator|->
name|a_vpp
argument_list|,
name|dvp
operator|->
name|v_mount
argument_list|,
name|dvp
argument_list|,
name|upperdvp
argument_list|,
name|cnp
argument_list|,
name|uppervp
argument_list|,
name|lowervp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|UDEBUG
argument_list|(
operator|(
literal|"Create %p = %p %p refs=%d\n"
operator|,
operator|*
name|ap
operator|->
name|a_vpp
operator|,
name|uppervp
operator|,
name|lowervp
operator|,
operator|(
operator|*
name|ap
operator|->
name|a_vpp
operator|)
condition|?
operator|(
operator|(
operator|*
name|ap
operator|->
name|a_vpp
operator|)
operator|->
name|v_usecount
operator|)
else|:
operator|-
literal|99
operator|)
argument_list|)
expr_stmt|;
name|uppervp
operator|=
name|NULL
expr_stmt|;
name|upperdvp
operator|=
name|NULL
expr_stmt|;
name|lowervp
operator|=
name|NULL
expr_stmt|;
comment|/*  	 *	Termination Code 	 * 	 *	- put away any extra junk laying around.  Note that lowervp 	 *	  (if not NULL) will never be the same as *ap->a_vp and  	 *	  neither will uppervp, because when we set that state we  	 *	  NULL-out lowervp or uppervp.  On the otherhand, upperdvp 	 *	  may match uppervp or *ap->a_vpp. 	 * 	 *	- relock/unlock dvp if appropriate. 	 */
name|out
label|:
if|if
condition|(
name|upperdvp
condition|)
block|{
if|if
condition|(
name|upperdvp
operator|==
name|uppervp
operator|||
name|upperdvp
operator|==
operator|*
name|ap
operator|->
name|a_vpp
condition|)
name|vrele
argument_list|(
name|upperdvp
argument_list|)
expr_stmt|;
else|else
name|vput
argument_list|(
name|upperdvp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|uppervp
condition|)
name|vput
argument_list|(
name|uppervp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lowervp
condition|)
name|vput
argument_list|(
name|lowervp
argument_list|)
expr_stmt|;
comment|/* 	 * Restore LOCKPARENT state 	 */
if|if
condition|(
operator|!
name|lockparent
condition|)
name|cnp
operator|->
name|cn_flags
operator|&=
operator|~
name|LOCKPARENT
expr_stmt|;
name|UDEBUG
argument_list|(
operator|(
literal|"Out %d vpp %p/%d lower %p upper %p\n"
operator|,
name|error
operator|,
operator|*
name|ap
operator|->
name|a_vpp
operator|,
operator|(
operator|(
operator|*
name|ap
operator|->
name|a_vpp
operator|)
condition|?
operator|(
operator|*
name|ap
operator|->
name|a_vpp
operator|)
operator|->
name|v_usecount
else|:
operator|-
literal|99
operator|)
operator|,
name|lowervp
operator|,
name|uppervp
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * dvp lock state, determine whether to relock dvp.  dvp is expected 	 * to be locked on return if: 	 * 	 *	- there was an error (except not EJUSTRETURN), or 	 *	- we hit the last component and lockparent is true 	 * 	 * dvp_is_locked is the current state of the dvp lock, not counting 	 * the possibility that *ap->a_vpp == dvp (in which case it is locked 	 * anyway).  Note that *ap->a_vpp == dvp only if no error occured. 	 */
if|if
condition|(
operator|*
name|ap
operator|->
name|a_vpp
operator|!=
name|dvp
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|==
literal|0
operator|||
name|error
operator|==
name|EJUSTRETURN
operator|)
operator|&&
operator|(
operator|!
name|lockparent
operator|||
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|ISLASTCN
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|VOP_UNLOCK
argument_list|(
name|dvp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Diagnostics 	 */
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|cnp
operator|->
name|cn_namelen
operator|==
literal|1
operator|&&
name|cnp
operator|->
name|cn_nameptr
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
operator|*
name|ap
operator|->
name|a_vpp
operator|!=
name|dvp
condition|)
block|{
name|panic
argument_list|(
literal|"union_lookup returning . (%p) not same as startdir (%p)"
argument_list|,
name|ap
operator|->
name|a_vpp
argument_list|,
name|dvp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * 	union_create:  *  * a_dvp is locked on entry and remains locked on return.  a_vpp is returned  * locked if no error occurs, otherwise it is garbage.  */
end_comment

begin_function
specifier|static
name|int
name|union_create
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_create_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode **a_vpp; 		struct componentname *a_cnp; 		struct vattr *a_vap; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|union_node
modifier|*
name|dun
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|cnp
operator|->
name|cn_proc
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
decl_stmt|;
name|int
name|error
init|=
name|EROFS
decl_stmt|;
if|if
condition|(
operator|(
name|dvp
operator|=
name|union_lock_upper
argument_list|(
name|dun
argument_list|,
name|p
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|error
operator|=
name|VOP_CREATE
argument_list|(
name|dvp
argument_list|,
operator|&
name|vp
argument_list|,
name|cnp
argument_list|,
name|ap
operator|->
name|a_vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|mp
operator|=
name|ap
operator|->
name|a_dvp
operator|->
name|v_mount
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|UDEBUG
argument_list|(
operator|(
literal|"ALLOCVP-1 FROM %p REFS %d\n"
operator|,
name|vp
operator|,
name|vp
operator|->
name|v_usecount
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|union_allocvp
argument_list|(
name|ap
operator|->
name|a_vpp
argument_list|,
name|mp
argument_list|,
name|NULLVP
argument_list|,
name|NULLVP
argument_list|,
name|cnp
argument_list|,
name|vp
argument_list|,
name|NULLVP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|UDEBUG
argument_list|(
operator|(
literal|"ALLOCVP-2B FROM %p REFS %d\n"
operator|,
operator|*
name|ap
operator|->
name|a_vpp
operator|,
name|vp
operator|->
name|v_usecount
operator|)
argument_list|)
expr_stmt|;
block|}
name|union_unlock_upper
argument_list|(
name|dvp
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_whiteout
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_whiteout_args
comment|/* { 		struct vnode *a_dvp; 		struct componentname *a_cnp; 		int a_flags; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|uppervp
decl_stmt|;
name|int
name|error
init|=
name|EOPNOTSUPP
decl_stmt|;
if|if
condition|(
operator|(
name|uppervp
operator|=
name|union_lock_upper
argument_list|(
name|un
argument_list|,
name|cnp
operator|->
name|cn_proc
argument_list|)
operator|)
operator|!=
name|NULLVP
condition|)
block|{
name|error
operator|=
name|VOP_WHITEOUT
argument_list|(
name|un
operator|->
name|un_uppervp
argument_list|,
name|cnp
argument_list|,
name|ap
operator|->
name|a_flags
argument_list|)
expr_stmt|;
name|union_unlock_upper
argument_list|(
name|uppervp
argument_list|,
name|cnp
operator|->
name|cn_proc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * 	union_mknod:  *  *	a_dvp is locked on entry and should remain locked on return.  *	a_vpp is garbagre whether an error occurs or not.  */
end_comment

begin_function
specifier|static
name|int
name|union_mknod
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_mknod_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode **a_vpp; 		struct componentname *a_cnp; 		struct vattr *a_vap; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|union_node
modifier|*
name|dun
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
decl_stmt|;
name|int
name|error
init|=
name|EROFS
decl_stmt|;
if|if
condition|(
operator|(
name|dvp
operator|=
name|union_lock_upper
argument_list|(
name|dun
argument_list|,
name|cnp
operator|->
name|cn_proc
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|VOP_MKNOD
argument_list|(
name|dvp
argument_list|,
name|ap
operator|->
name|a_vpp
argument_list|,
name|cnp
argument_list|,
name|ap
operator|->
name|a_vap
argument_list|)
expr_stmt|;
name|union_unlock_upper
argument_list|(
name|dvp
argument_list|,
name|cnp
operator|->
name|cn_proc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	union_open:  *  *	run open VOP.  When opening the underlying vnode we have to mimic  *	vn_open.  What we *really* need to do to avoid screwups if the  *	open semantics change is to call vn_open().  For example, ufs blows  *	up if you open a file but do not vmio it prior to writing.  */
end_comment

begin_function
specifier|static
name|int
name|union_open
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_open_args
comment|/* { 		struct vnodeop_desc *a_desc; 		struct vnode *a_vp; 		int a_mode; 		struct ucred *a_cred; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|struct
name|vnode
modifier|*
name|tvp
decl_stmt|;
name|int
name|mode
init|=
name|ap
operator|->
name|a_mode
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|ap
operator|->
name|a_cred
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|ap
operator|->
name|a_p
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|tvpisupper
init|=
literal|1
decl_stmt|;
comment|/* 	 * If there is an existing upper vp then simply open that. 	 * The upper vp takes precedence over the lower vp.  When opening 	 * a lower vp for writing copy it to the uppervp and then open the 	 * uppervp. 	 * 	 * At the end of this section tvp will be left locked. 	 */
if|if
condition|(
operator|(
name|tvp
operator|=
name|union_lock_upper
argument_list|(
name|un
argument_list|,
name|p
argument_list|)
operator|)
operator|==
name|NULLVP
condition|)
block|{
comment|/* 		 * If the lower vnode is being opened for writing, then 		 * copy the file contents to the upper vnode and open that, 		 * otherwise can simply open the lower vnode. 		 */
name|tvp
operator|=
name|un
operator|->
name|un_lowervp
expr_stmt|;
if|if
condition|(
operator|(
name|ap
operator|->
name|a_mode
operator|&
name|FWRITE
operator|)
operator|&&
operator|(
name|tvp
operator|->
name|v_type
operator|==
name|VREG
operator|)
condition|)
block|{
name|int
name|docopy
init|=
operator|!
operator|(
name|mode
operator|&
name|O_TRUNC
operator|)
decl_stmt|;
name|error
operator|=
name|union_copyup
argument_list|(
name|un
argument_list|,
name|docopy
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|tvp
operator|=
name|union_lock_upper
argument_list|(
name|un
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|un
operator|->
name|un_openl
operator|++
expr_stmt|;
name|VREF
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|tvp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|tvpisupper
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 	 * We are holding the correct vnode, open it 	 */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|VOP_OPEN
argument_list|(
name|tvp
argument_list|,
name|mode
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* 	 * Absolutely necessary or UFS will blowup 	 */
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|vn_canvmio
argument_list|(
name|tvp
argument_list|)
operator|==
name|TRUE
condition|)
block|{
name|error
operator|=
name|vfs_object_create
argument_list|(
name|tvp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Release any locks held 	 */
if|if
condition|(
name|tvpisupper
condition|)
block|{
if|if
condition|(
name|tvp
condition|)
name|union_unlock_upper
argument_list|(
name|tvp
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vput
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	union_close:  *  *	It is unclear whether a_vp is passed locked or unlocked.  Whatever  *	the case we do not change it.  */
end_comment

begin_function
specifier|static
name|int
name|union_close
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_close_args
comment|/* { 		struct vnode *a_vp; 		int  a_fflag; 		struct ucred *a_cred; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
if|if
condition|(
operator|(
name|vp
operator|=
name|un
operator|->
name|un_uppervp
operator|)
operator|==
name|NULLVP
condition|)
block|{
ifdef|#
directive|ifdef
name|UNION_DIAGNOSTIC
if|if
condition|(
name|un
operator|->
name|un_openl
operator|<=
literal|0
condition|)
name|panic
argument_list|(
literal|"union: un_openl cnt"
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|--
name|un
operator|->
name|un_openl
expr_stmt|;
name|vp
operator|=
name|un
operator|->
name|un_lowervp
expr_stmt|;
block|}
name|ap
operator|->
name|a_vp
operator|=
name|vp
expr_stmt|;
return|return
operator|(
name|VCALL
argument_list|(
name|vp
argument_list|,
name|VOFFSET
argument_list|(
name|vop_close
argument_list|)
argument_list|,
name|ap
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check access permission on the union vnode.  * The access check being enforced is to check  * against both the underlying vnode, and any  * copied vnode.  This ensures that no additional  * file permissions are given away simply because  * the user caused an implicit file copy.  */
end_comment

begin_function
specifier|static
name|int
name|union_access
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_access_args
comment|/* { 		struct vnodeop_desc *a_desc; 		struct vnode *a_vp; 		int a_mode; 		struct ucred *a_cred; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|ap
operator|->
name|a_p
decl_stmt|;
name|int
name|error
init|=
name|EACCES
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
comment|/* 	 * Disallow write attempts on filesystems mounted read-only. 	 */
if|if
condition|(
operator|(
name|ap
operator|->
name|a_mode
operator|&
name|VWRITE
operator|)
operator|&&
operator|(
name|ap
operator|->
name|a_vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
condition|)
block|{
switch|switch
condition|(
name|ap
operator|->
name|a_vp
operator|->
name|v_type
condition|)
block|{
case|case
name|VREG
case|:
case|case
name|VDIR
case|:
case|case
name|VLNK
case|:
return|return
operator|(
name|EROFS
operator|)
return|;
default|default:
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|vp
operator|=
name|union_lock_upper
argument_list|(
name|un
argument_list|,
name|p
argument_list|)
operator|)
operator|!=
name|NULLVP
condition|)
block|{
name|ap
operator|->
name|a_vp
operator|=
name|vp
expr_stmt|;
name|error
operator|=
name|VCALL
argument_list|(
name|vp
argument_list|,
name|VOFFSET
argument_list|(
name|vop_access
argument_list|)
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|union_unlock_upper
argument_list|(
name|vp
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|vp
operator|=
name|un
operator|->
name|un_lowervp
operator|)
operator|!=
name|NULLVP
condition|)
block|{
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|ap
operator|->
name|a_vp
operator|=
name|vp
expr_stmt|;
comment|/* 		 * Remove VWRITE from a_mode if our mount point is RW, because 		 * we want to allow writes and lowervp may be read-only. 		 */
if|if
condition|(
operator|(
name|un
operator|->
name|un_vnode
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
operator|==
literal|0
condition|)
name|ap
operator|->
name|a_mode
operator|&=
operator|~
name|VWRITE
expr_stmt|;
name|error
operator|=
name|VCALL
argument_list|(
name|vp
argument_list|,
name|VOFFSET
argument_list|(
name|vop_access
argument_list|)
argument_list|,
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|struct
name|union_mount
modifier|*
name|um
decl_stmt|;
name|um
operator|=
name|MOUNTTOUNIONMOUNT
argument_list|(
name|un
operator|->
name|un_vnode
operator|->
name|v_mount
argument_list|)
expr_stmt|;
if|if
condition|(
name|um
operator|->
name|um_op
operator|==
name|UNMNT_BELOW
condition|)
block|{
name|ap
operator|->
name|a_cred
operator|=
name|um
operator|->
name|um_cred
expr_stmt|;
name|error
operator|=
name|VCALL
argument_list|(
name|vp
argument_list|,
name|VOFFSET
argument_list|(
name|vop_access
argument_list|)
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
block|}
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We handle getattr only to change the fsid and  * track object sizes  *  * It's not clear whether VOP_GETATTR is to be  * called with the vnode locked or not.  stat() calls  * it with (vp) locked, and fstat calls it with  * (vp) unlocked.   *  * Because of this we cannot use our normal locking functions  * if we do not intend to lock the main a_vp node.  At the moment  * we are running without any specific locking at all, but beware  * to any programmer that care must be taken if locking is added  * to this function.  */
end_comment

begin_function
specifier|static
name|int
name|union_getattr
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_getattr_args
comment|/* { 		struct vnode *a_vp; 		struct vattr *a_vap; 		struct ucred *a_cred; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|vattr
modifier|*
name|vap
decl_stmt|;
name|struct
name|vattr
name|va
decl_stmt|;
comment|/* 	 * Some programs walk the filesystem hierarchy by counting 	 * links to directories to avoid stat'ing all the time. 	 * This means the link count on directories needs to be "correct". 	 * The only way to do that is to call getattr on both layers 	 * and fix up the link count.  The link count will not necessarily 	 * be accurate but will be large enough to defeat the tree walkers. 	 */
name|vap
operator|=
name|ap
operator|->
name|a_vap
expr_stmt|;
if|if
condition|(
operator|(
name|vp
operator|=
name|un
operator|->
name|un_uppervp
operator|)
operator|!=
name|NULLVP
condition|)
block|{
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
name|vap
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* XXX isn't this dangerouso without a lock? */
name|union_newsize
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|vap
operator|->
name|va_size
argument_list|,
name|VNOVAL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vp
operator|==
name|NULLVP
condition|)
block|{
name|vp
operator|=
name|un
operator|->
name|un_lowervp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VDIR
operator|&&
name|un
operator|->
name|un_lowervp
operator|!=
name|NULLVP
condition|)
block|{
name|vp
operator|=
name|un
operator|->
name|un_lowervp
expr_stmt|;
name|vap
operator|=
operator|&
name|va
expr_stmt|;
block|}
else|else
block|{
name|vp
operator|=
name|NULLVP
expr_stmt|;
block|}
if|if
condition|(
name|vp
operator|!=
name|NULLVP
condition|)
block|{
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
name|vap
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* XXX isn't this dangerous without a lock? */
name|union_newsize
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|VNOVAL
argument_list|,
name|vap
operator|->
name|va_size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|vap
operator|!=
name|ap
operator|->
name|a_vap
operator|)
operator|&&
operator|(
name|vap
operator|->
name|va_type
operator|==
name|VDIR
operator|)
condition|)
name|ap
operator|->
name|a_vap
operator|->
name|va_nlink
operator|+=
name|vap
operator|->
name|va_nlink
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_setattr
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_setattr_args
comment|/* { 		struct vnode *a_vp; 		struct vattr *a_vap; 		struct ucred *a_cred; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|ap
operator|->
name|a_p
decl_stmt|;
name|struct
name|vattr
modifier|*
name|vap
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|struct
name|vnode
modifier|*
name|uppervp
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Disallow write attempts on filesystems mounted read-only. 	 */
if|if
condition|(
operator|(
name|ap
operator|->
name|a_vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
operator|&&
operator|(
name|vap
operator|->
name|va_flags
operator|!=
name|VNOVAL
operator|||
name|vap
operator|->
name|va_uid
operator|!=
operator|(
name|uid_t
operator|)
name|VNOVAL
operator|||
name|vap
operator|->
name|va_gid
operator|!=
operator|(
name|gid_t
operator|)
name|VNOVAL
operator|||
name|vap
operator|->
name|va_atime
operator|.
name|tv_sec
operator|!=
name|VNOVAL
operator|||
name|vap
operator|->
name|va_mtime
operator|.
name|tv_sec
operator|!=
name|VNOVAL
operator|||
name|vap
operator|->
name|va_mode
operator|!=
operator|(
name|mode_t
operator|)
name|VNOVAL
operator|)
condition|)
block|{
return|return
operator|(
name|EROFS
operator|)
return|;
block|}
comment|/* 	 * Handle case of truncating lower object to zero size, 	 * by creating a zero length upper object.  This is to 	 * handle the case of open with O_TRUNC and O_CREAT. 	 */
if|if
condition|(
name|un
operator|->
name|un_uppervp
operator|==
name|NULLVP
operator|&&
operator|(
name|un
operator|->
name|un_lowervp
operator|->
name|v_type
operator|==
name|VREG
operator|)
condition|)
block|{
name|error
operator|=
name|union_copyup
argument_list|(
name|un
argument_list|,
operator|(
name|ap
operator|->
name|a_vap
operator|->
name|va_size
operator|!=
literal|0
operator|)
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Try to set attributes in upper layer, 	 * otherwise return read-only filesystem error. 	 */
name|error
operator|=
name|EROFS
expr_stmt|;
if|if
condition|(
operator|(
name|uppervp
operator|=
name|union_lock_upper
argument_list|(
name|un
argument_list|,
name|p
argument_list|)
operator|)
operator|!=
name|NULLVP
condition|)
block|{
name|error
operator|=
name|VOP_SETATTR
argument_list|(
name|un
operator|->
name|un_uppervp
argument_list|,
name|ap
operator|->
name|a_vap
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ap
operator|->
name|a_vap
operator|->
name|va_size
operator|!=
name|VNOVAL
operator|)
condition|)
name|union_newsize
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|ap
operator|->
name|a_vap
operator|->
name|va_size
argument_list|,
name|VNOVAL
argument_list|)
expr_stmt|;
name|union_unlock_upper
argument_list|(
name|uppervp
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	union_getpages:  */
end_comment

begin_function
specifier|static
name|int
name|union_getpages
parameter_list|(
name|struct
name|vop_getpages_args
modifier|*
name|ap
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|r
operator|=
name|vnode_pager_generic_getpages
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|ap
operator|->
name|a_m
argument_list|,
name|ap
operator|->
name|a_count
argument_list|,
name|ap
operator|->
name|a_reqpage
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	union_putpages:  */
end_comment

begin_function
specifier|static
name|int
name|union_putpages
parameter_list|(
name|struct
name|vop_putpages_args
modifier|*
name|ap
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|r
operator|=
name|vnode_pager_generic_putpages
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|ap
operator|->
name|a_m
argument_list|,
name|ap
operator|->
name|a_count
argument_list|,
name|ap
operator|->
name|a_sync
argument_list|,
name|ap
operator|->
name|a_rtvals
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_read
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_read_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		int  a_ioflag; 		struct ucred *a_cred; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|ap
operator|->
name|a_uio
operator|->
name|uio_procp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|uvp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uvp
operator|=
name|union_lock_other
argument_list|(
name|un
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|uvp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"union_read: backing vnode missing!"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_vp
operator|->
name|v_flag
operator|&
name|VOBJBUF
condition|)
name|union_vm_coherency
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|ap
operator|->
name|a_uio
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_READ
argument_list|(
name|uvp
argument_list|,
name|ap
operator|->
name|a_uio
argument_list|,
name|ap
operator|->
name|a_ioflag
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
expr_stmt|;
name|union_unlock_other
argument_list|(
name|uvp
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* 	 * XXX 	 * perhaps the size of the underlying object has changed under 	 * our feet.  take advantage of the offset information present 	 * in the uio structure. 	 */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|off_t
name|cur
init|=
name|ap
operator|->
name|a_uio
operator|->
name|uio_offset
decl_stmt|;
if|if
condition|(
name|uvp
operator|==
name|un
operator|->
name|un_uppervp
condition|)
block|{
if|if
condition|(
name|cur
operator|>
name|un
operator|->
name|un_uppersz
condition|)
name|union_newsize
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|cur
argument_list|,
name|VNOVAL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cur
operator|>
name|un
operator|->
name|un_lowersz
condition|)
name|union_newsize
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|VNOVAL
argument_list|,
name|cur
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_write
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_read_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		int  a_ioflag; 		struct ucred *a_cred; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|ap
operator|->
name|a_uio
operator|->
name|uio_procp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|uppervp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|uppervp
operator|=
name|union_lock_upper
argument_list|(
name|un
argument_list|,
name|p
argument_list|)
operator|)
operator|==
name|NULLVP
condition|)
name|panic
argument_list|(
literal|"union: missing upper layer in write"
argument_list|)
expr_stmt|;
comment|/* 	 * Since our VM pages are associated with our vnode rather then 	 * the real vnode, and since we do not run our reads and writes  	 * through our own VM cache, we have a VM/VFS coherency problem.  	 * We solve them by invalidating or flushing the associated VM 	 * pages prior to allowing a normal read or write to occur. 	 * 	 * VM-backed writes (UIO_NOCOPY) have to be converted to normal 	 * writes because we are not cache-coherent.  Normal writes need 	 * to be made coherent with our VM-backing store, which we do by 	 * first flushing any dirty VM pages associated with the write 	 * range, and then destroying any clean VM pages associated with 	 * the write range. 	 */
if|if
condition|(
name|ap
operator|->
name|a_uio
operator|->
name|uio_segflg
operator|==
name|UIO_NOCOPY
condition|)
block|{
name|ap
operator|->
name|a_uio
operator|->
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ap
operator|->
name|a_vp
operator|->
name|v_flag
operator|&
name|VOBJBUF
condition|)
block|{
name|union_vm_coherency
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|ap
operator|->
name|a_uio
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|VOP_WRITE
argument_list|(
name|uppervp
argument_list|,
name|ap
operator|->
name|a_uio
argument_list|,
name|ap
operator|->
name|a_ioflag
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
expr_stmt|;
comment|/* 	 * the size of the underlying object may be changed by the 	 * write. 	 */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|off_t
name|cur
init|=
name|ap
operator|->
name|a_uio
operator|->
name|uio_offset
decl_stmt|;
if|if
condition|(
name|cur
operator|>
name|un
operator|->
name|un_uppersz
condition|)
name|union_newsize
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|cur
argument_list|,
name|VNOVAL
argument_list|)
expr_stmt|;
block|}
name|union_unlock_upper
argument_list|(
name|uppervp
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_lease
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_lease_args
comment|/* { 		struct vnode *a_vp; 		struct proc *a_p; 		struct ucred *a_cred; 		int a_flag; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|ovp
init|=
name|OTHERVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|ap
operator|->
name|a_vp
operator|=
name|ovp
expr_stmt|;
return|return
operator|(
name|VCALL
argument_list|(
name|ovp
argument_list|,
name|VOFFSET
argument_list|(
name|vop_lease
argument_list|)
argument_list|,
name|ap
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_ioctl
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_ioctl_args
comment|/* { 		struct vnode *a_vp; 		int  a_command; 		caddr_t  a_data; 		int  a_fflag; 		struct ucred *a_cred; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|ovp
init|=
name|OTHERVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|ap
operator|->
name|a_vp
operator|=
name|ovp
expr_stmt|;
return|return
operator|(
name|VCALL
argument_list|(
name|ovp
argument_list|,
name|VOFFSET
argument_list|(
name|vop_ioctl
argument_list|)
argument_list|,
name|ap
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_poll
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_poll_args
comment|/* { 		struct vnode *a_vp; 		int  a_events; 		struct ucred *a_cred; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|ovp
init|=
name|OTHERVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|ap
operator|->
name|a_vp
operator|=
name|ovp
expr_stmt|;
return|return
operator|(
name|VCALL
argument_list|(
name|ovp
argument_list|,
name|VOFFSET
argument_list|(
name|vop_poll
argument_list|)
argument_list|,
name|ap
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_revoke
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_revoke_args
comment|/* { 		struct vnode *a_vp; 		int a_flags; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
if|if
condition|(
name|UPPERVP
argument_list|(
name|vp
argument_list|)
condition|)
name|VOP_REVOKE
argument_list|(
name|UPPERVP
argument_list|(
name|vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOWERVP
argument_list|(
name|vp
argument_list|)
condition|)
name|VOP_REVOKE
argument_list|(
name|LOWERVP
argument_list|(
name|vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_flags
argument_list|)
expr_stmt|;
name|vgone
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_mmap
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_mmap_args
comment|/* { 		struct vnode *a_vp; 		int  a_fflags; 		struct ucred *a_cred; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|ovp
init|=
name|OTHERVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|ap
operator|->
name|a_vp
operator|=
name|ovp
expr_stmt|;
return|return
operator|(
name|VCALL
argument_list|(
name|ovp
argument_list|,
name|VOFFSET
argument_list|(
name|vop_mmap
argument_list|)
argument_list|,
name|ap
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_fsync
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_fsync_args
comment|/* { 		struct vnode *a_vp; 		struct ucred *a_cred; 		int  a_waitfor; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|ap
operator|->
name|a_p
decl_stmt|;
name|struct
name|vnode
modifier|*
name|targetvp
decl_stmt|;
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|targetvp
operator|=
name|union_lock_other
argument_list|(
name|un
argument_list|,
name|p
argument_list|)
operator|)
operator|!=
name|NULLVP
condition|)
block|{
name|error
operator|=
name|VOP_FSYNC
argument_list|(
name|targetvp
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_waitfor
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|union_unlock_other
argument_list|(
name|targetvp
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	union_remove:  *  *	Remove the specified cnp.  The dvp and vp are passed to us locked  *	and must remain locked on return.  */
end_comment

begin_function
specifier|static
name|int
name|union_remove
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_remove_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode *a_vp; 		struct componentname *a_cnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|union_node
modifier|*
name|dun
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
decl_stmt|;
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|cnp
operator|->
name|cn_proc
decl_stmt|;
name|struct
name|vnode
modifier|*
name|uppervp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|upperdvp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|upperdvp
operator|=
name|union_lock_upper
argument_list|(
name|dun
argument_list|,
name|p
argument_list|)
operator|)
operator|==
name|NULLVP
condition|)
name|panic
argument_list|(
literal|"union remove: null upper vnode"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|uppervp
operator|=
name|union_lock_upper
argument_list|(
name|un
argument_list|,
name|p
argument_list|)
operator|)
operator|!=
name|NULLVP
condition|)
block|{
if|if
condition|(
name|union_dowhiteout
argument_list|(
name|un
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|p
argument_list|)
condition|)
name|cnp
operator|->
name|cn_flags
operator||=
name|DOWHITEOUT
expr_stmt|;
name|error
operator|=
name|VOP_REMOVE
argument_list|(
name|upperdvp
argument_list|,
name|uppervp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX */
block|if (!error) 			union_removed_upper(un);
endif|#
directive|endif
name|union_unlock_upper
argument_list|(
name|uppervp
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|union_mkwhiteout
argument_list|(
name|MOUNTTOUNIONMOUNT
argument_list|(
name|ap
operator|->
name|a_dvp
operator|->
name|v_mount
argument_list|)
argument_list|,
name|upperdvp
argument_list|,
name|ap
operator|->
name|a_cnp
argument_list|,
name|un
operator|->
name|un_path
argument_list|)
expr_stmt|;
block|}
name|union_unlock_upper
argument_list|(
name|upperdvp
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	union_link:  *  *	tdvp will be locked on entry, vp will not be locked on entry.  *	tdvp should remain locked on return and vp should remain unlocked  *	on return.  */
end_comment

begin_function
specifier|static
name|int
name|union_link
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_link_args
comment|/* { 		struct vnode *a_tdvp; 		struct vnode *a_vp; 		struct componentname *a_cnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|cnp
operator|->
name|cn_proc
decl_stmt|;
name|struct
name|union_node
modifier|*
name|dun
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_tdvp
argument_list|)
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|tdvp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_tdvp
operator|->
name|v_op
operator|!=
name|ap
operator|->
name|a_vp
operator|->
name|v_op
condition|)
block|{
name|vp
operator|=
name|ap
operator|->
name|a_vp
expr_stmt|;
block|}
else|else
block|{
name|struct
name|union_node
modifier|*
name|tun
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
if|if
condition|(
name|tun
operator|->
name|un_uppervp
operator|==
name|NULLVP
condition|)
block|{
name|vn_lock
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (dun->un_uppervp == tun->un_dirvp) { 				if (dun->un_flags& UN_ULOCK) { 					dun->un_flags&= ~UN_ULOCK; 					VOP_UNLOCK(dun->un_uppervp, 0, p); 				} 			}
endif|#
directive|endif
name|error
operator|=
name|union_copyup
argument_list|(
name|tun
argument_list|,
literal|1
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (dun->un_uppervp == tun->un_dirvp) { 				vn_lock(dun->un_uppervp, 					    LK_EXCLUSIVE | LK_RETRY, p); 				dun->un_flags |= UN_ULOCK; 			}
endif|#
directive|endif
name|VOP_UNLOCK
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|vp
operator|=
name|tun
operator|->
name|un_uppervp
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Make sure upper is locked, then unlock the union directory we were  	 * called with to avoid a deadlock while we are calling VOP_LINK on  	 * the upper (with tdvp locked and vp not locked).  Our ap->a_tdvp 	 * is expected to be locked on return. 	 */
if|if
condition|(
operator|(
name|tdvp
operator|=
name|union_lock_upper
argument_list|(
name|dun
argument_list|,
name|p
argument_list|)
operator|)
operator|==
name|NULLVP
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
name|VOP_UNLOCK
argument_list|(
name|ap
operator|->
name|a_tdvp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* unlock calling node */
name|error
operator|=
name|VOP_LINK
argument_list|(
name|tdvp
argument_list|,
name|vp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
comment|/* call link on upper */
comment|/* 	 * We have to unlock tdvp prior to relocking our calling node in 	 * order to avoid a deadlock. 	 */
name|union_unlock_upper
argument_list|(
name|tdvp
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|ap
operator|->
name|a_tdvp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_rename
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_rename_args
comment|/* { 		struct vnode *a_fdvp; 		struct vnode *a_fvp; 		struct componentname *a_fcnp; 		struct vnode *a_tdvp; 		struct vnode *a_tvp; 		struct componentname *a_tcnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|vnode
modifier|*
name|fdvp
init|=
name|ap
operator|->
name|a_fdvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|fvp
init|=
name|ap
operator|->
name|a_fvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|tdvp
init|=
name|ap
operator|->
name|a_tdvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|tvp
init|=
name|ap
operator|->
name|a_tvp
decl_stmt|;
comment|/* 	 * Figure out what fdvp to pass to our upper or lower vnode.  If we 	 * replace the fdvp, release the original one and ref the new one. 	 */
if|if
condition|(
name|fdvp
operator|->
name|v_op
operator|==
name|union_vnodeop_p
condition|)
block|{
comment|/* always true */
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|fdvp
argument_list|)
decl_stmt|;
if|if
condition|(
name|un
operator|->
name|un_uppervp
operator|==
name|NULLVP
condition|)
block|{
comment|/* 			 * this should never happen in normal 			 * operation but might if there was 			 * a problem creating the top-level shadow 			 * directory. 			 */
name|error
operator|=
name|EXDEV
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|fdvp
operator|=
name|un
operator|->
name|un_uppervp
expr_stmt|;
name|VREF
argument_list|(
name|fdvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|ap
operator|->
name|a_fdvp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Figure out what fvp to pass to our upper or lower vnode.  If we 	 * replace the fvp, release the original one and ref the new one. 	 */
if|if
condition|(
name|fvp
operator|->
name|v_op
operator|==
name|union_vnodeop_p
condition|)
block|{
comment|/* always true */
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|fvp
argument_list|)
decl_stmt|;
if|#
directive|if
literal|0
block|struct union_mount *um = MOUNTTOUNIONMOUNT(fvp->v_mount);
endif|#
directive|endif
if|if
condition|(
name|un
operator|->
name|un_uppervp
operator|==
name|NULLVP
condition|)
block|{
switch|switch
condition|(
name|fvp
operator|->
name|v_type
condition|)
block|{
case|case
name|VREG
case|:
name|vn_lock
argument_list|(
name|un
operator|->
name|un_vnode
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|ap
operator|->
name|a_fcnp
operator|->
name|cn_proc
argument_list|)
expr_stmt|;
name|error
operator|=
name|union_copyup
argument_list|(
name|un
argument_list|,
literal|1
argument_list|,
name|ap
operator|->
name|a_fcnp
operator|->
name|cn_cred
argument_list|,
name|ap
operator|->
name|a_fcnp
operator|->
name|cn_proc
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|un
operator|->
name|un_vnode
argument_list|,
literal|0
argument_list|,
name|ap
operator|->
name|a_fcnp
operator|->
name|cn_proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
break|break;
case|case
name|VDIR
case|:
comment|/* 				 * XXX not yet. 				 * 				 * There is only one way to rename a directory 				 * based in the lowervp, and that is to copy 				 * the entire directory hierarchy.  Otherwise 				 * it would not last across a reboot. 				 */
if|#
directive|if
literal|0
block|vrele(fvp); 				fvp = NULL; 				vn_lock(fdvp, LK_EXCLUSIVE | LK_RETRY, ap->a_fcnp->cn_proc); 				error = union_mkshadow(um, fdvp,  					    ap->a_fcnp,&un->un_uppervp); 				VOP_UNLOCK(fdvp, 0, ap->a_fcnp->cn_proc); 				if (un->un_uppervp) 					VOP_UNLOCK(un->un_uppervp, 0, ap->a_fcnp->cn_proc); 				if (error) 					goto bad; 				break;
endif|#
directive|endif
default|default:
name|error
operator|=
name|EXDEV
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
if|if
condition|(
name|un
operator|->
name|un_lowervp
operator|!=
name|NULLVP
condition|)
name|ap
operator|->
name|a_fcnp
operator|->
name|cn_flags
operator||=
name|DOWHITEOUT
expr_stmt|;
name|fvp
operator|=
name|un
operator|->
name|un_uppervp
expr_stmt|;
name|VREF
argument_list|(
name|fvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|ap
operator|->
name|a_fvp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Figure out what tdvp (destination directory) to pass to the 	 * lower level.  If we replace it with uppervp, we need to vput the  	 * old one.  The exclusive lock is transfered to what we will pass 	 * down in the VOP_RENAME and we replace uppervp with a simple 	 * reference. 	 */
if|if
condition|(
name|tdvp
operator|->
name|v_op
operator|==
name|union_vnodeop_p
condition|)
block|{
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|tdvp
argument_list|)
decl_stmt|;
if|if
condition|(
name|un
operator|->
name|un_uppervp
operator|==
name|NULLVP
condition|)
block|{
comment|/* 			 * this should never happen in normal 			 * operation but might if there was 			 * a problem creating the top-level shadow 			 * directory. 			 */
name|error
operator|=
name|EXDEV
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 		 * new tdvp is a lock and reference on uppervp, put away 		 * the old tdvp. 		 */
name|tdvp
operator|=
name|union_lock_upper
argument_list|(
name|un
argument_list|,
name|ap
operator|->
name|a_tcnp
operator|->
name|cn_proc
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ap
operator|->
name|a_tdvp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Figure out what tvp (destination file) to pass to the 	 * lower level. 	 * 	 * If the uppervp file does not exist put away the (wrong) 	 * file and change tvp to NULL. 	 */
if|if
condition|(
name|tvp
operator|!=
name|NULLVP
operator|&&
name|tvp
operator|->
name|v_op
operator|==
name|union_vnodeop_p
condition|)
block|{
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|tvp
argument_list|)
decl_stmt|;
name|tvp
operator|=
name|union_lock_upper
argument_list|(
name|un
argument_list|,
name|ap
operator|->
name|a_tcnp
operator|->
name|cn_proc
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ap
operator|->
name|a_tvp
argument_list|)
expr_stmt|;
comment|/* note: tvp may be NULL */
block|}
comment|/* 	 * VOP_RENAME releases/vputs prior to returning, so we have no 	 * cleanup to do. 	 */
return|return
operator|(
name|VOP_RENAME
argument_list|(
name|fdvp
argument_list|,
name|fvp
argument_list|,
name|ap
operator|->
name|a_fcnp
argument_list|,
name|tdvp
argument_list|,
name|tvp
argument_list|,
name|ap
operator|->
name|a_tcnp
argument_list|)
operator|)
return|;
comment|/* 	 * Error.  We still have to release / vput the various elements. 	 */
name|bad
label|:
name|vrele
argument_list|(
name|fdvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fvp
condition|)
name|vrele
argument_list|(
name|fvp
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tvp
operator|!=
name|NULLVP
condition|)
block|{
if|if
condition|(
name|tvp
operator|!=
name|tdvp
condition|)
name|vput
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
else|else
name|vrele
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_mkdir
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_mkdir_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode **a_vpp; 		struct componentname *a_cnp; 		struct vattr *a_vap; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|union_node
modifier|*
name|dun
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|cnp
operator|->
name|cn_proc
decl_stmt|;
name|struct
name|vnode
modifier|*
name|upperdvp
decl_stmt|;
name|int
name|error
init|=
name|EROFS
decl_stmt|;
if|if
condition|(
operator|(
name|upperdvp
operator|=
name|union_lock_upper
argument_list|(
name|dun
argument_list|,
name|p
argument_list|)
operator|)
operator|!=
name|NULLVP
condition|)
block|{
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|error
operator|=
name|VOP_MKDIR
argument_list|(
name|upperdvp
argument_list|,
operator|&
name|vp
argument_list|,
name|cnp
argument_list|,
name|ap
operator|->
name|a_vap
argument_list|)
expr_stmt|;
name|union_unlock_upper
argument_list|(
name|upperdvp
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|UDEBUG
argument_list|(
operator|(
literal|"ALLOCVP-2 FROM %p REFS %d\n"
operator|,
name|vp
operator|,
name|vp
operator|->
name|v_usecount
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|union_allocvp
argument_list|(
name|ap
operator|->
name|a_vpp
argument_list|,
name|ap
operator|->
name|a_dvp
operator|->
name|v_mount
argument_list|,
name|ap
operator|->
name|a_dvp
argument_list|,
name|NULLVP
argument_list|,
name|cnp
argument_list|,
name|vp
argument_list|,
name|NULLVP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|UDEBUG
argument_list|(
operator|(
literal|"ALLOCVP-2B FROM %p REFS %d\n"
operator|,
operator|*
name|ap
operator|->
name|a_vpp
operator|,
name|vp
operator|->
name|v_usecount
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_rmdir
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_rmdir_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode *a_vp; 		struct componentname *a_cnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|union_node
modifier|*
name|dun
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
decl_stmt|;
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|cnp
operator|->
name|cn_proc
decl_stmt|;
name|struct
name|vnode
modifier|*
name|upperdvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|uppervp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|upperdvp
operator|=
name|union_lock_upper
argument_list|(
name|dun
argument_list|,
name|p
argument_list|)
operator|)
operator|==
name|NULLVP
condition|)
name|panic
argument_list|(
literal|"union rmdir: null upper vnode"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|uppervp
operator|=
name|union_lock_upper
argument_list|(
name|un
argument_list|,
name|p
argument_list|)
operator|)
operator|!=
name|NULLVP
condition|)
block|{
if|if
condition|(
name|union_dowhiteout
argument_list|(
name|un
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|p
argument_list|)
condition|)
name|cnp
operator|->
name|cn_flags
operator||=
name|DOWHITEOUT
expr_stmt|;
name|error
operator|=
name|VOP_RMDIR
argument_list|(
name|upperdvp
argument_list|,
name|uppervp
argument_list|,
name|ap
operator|->
name|a_cnp
argument_list|)
expr_stmt|;
name|union_unlock_upper
argument_list|(
name|uppervp
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|union_mkwhiteout
argument_list|(
name|MOUNTTOUNIONMOUNT
argument_list|(
name|ap
operator|->
name|a_dvp
operator|->
name|v_mount
argument_list|)
argument_list|,
name|dun
operator|->
name|un_uppervp
argument_list|,
name|ap
operator|->
name|a_cnp
argument_list|,
name|un
operator|->
name|un_path
argument_list|)
expr_stmt|;
block|}
name|union_unlock_upper
argument_list|(
name|upperdvp
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	union_symlink:  *  *	dvp is locked on entry and remains locked on return.  a_vpp is garbage  *	(unused).  */
end_comment

begin_function
specifier|static
name|int
name|union_symlink
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_symlink_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode **a_vpp; 		struct componentname *a_cnp; 		struct vattr *a_vap; 		char *a_target; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|union_node
modifier|*
name|dun
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|cnp
operator|->
name|cn_proc
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
decl_stmt|;
name|int
name|error
init|=
name|EROFS
decl_stmt|;
if|if
condition|(
operator|(
name|dvp
operator|=
name|union_lock_upper
argument_list|(
name|dun
argument_list|,
name|p
argument_list|)
operator|)
operator|!=
name|NULLVP
condition|)
block|{
name|error
operator|=
name|VOP_SYMLINK
argument_list|(
name|dvp
argument_list|,
name|ap
operator|->
name|a_vpp
argument_list|,
name|cnp
argument_list|,
name|ap
operator|->
name|a_vap
argument_list|,
name|ap
operator|->
name|a_target
argument_list|)
expr_stmt|;
name|union_unlock_upper
argument_list|(
name|dvp
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * union_readdir works in concert with getdirentries and  * readdir(3) to provide a list of entries in the unioned  * directories.  getdirentries is responsible for walking  * down the union stack.  readdir(3) is responsible for  * eliminating duplicate names from the returned data stream.  */
end_comment

begin_function
specifier|static
name|int
name|union_readdir
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_readdir_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		struct ucred *a_cred; 		int *a_eofflag; 		u_long *a_cookies; 		int a_ncookies; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|ap
operator|->
name|a_uio
operator|->
name|uio_procp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|uvp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|uvp
operator|=
name|union_lock_upper
argument_list|(
name|un
argument_list|,
name|p
argument_list|)
operator|)
operator|!=
name|NULLVP
condition|)
block|{
name|ap
operator|->
name|a_vp
operator|=
name|uvp
expr_stmt|;
name|error
operator|=
name|VCALL
argument_list|(
name|uvp
argument_list|,
name|VOFFSET
argument_list|(
name|vop_readdir
argument_list|)
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|union_unlock_upper
argument_list|(
name|uvp
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_readlink
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_readlink_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		struct ucred *a_cred; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
init|=
name|ap
operator|->
name|a_uio
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|uio
operator|->
name|uio_procp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|vp
operator|=
name|union_lock_other
argument_list|(
name|un
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|vp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"union_readlink: backing vnode missing!"
operator|)
argument_list|)
expr_stmt|;
name|ap
operator|->
name|a_vp
operator|=
name|vp
expr_stmt|;
name|error
operator|=
name|VCALL
argument_list|(
name|vp
argument_list|,
name|VOFFSET
argument_list|(
name|vop_readlink
argument_list|)
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|union_unlock_other
argument_list|(
name|vp
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_getwritemount
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_getwritemount_args
comment|/* { 		struct vnode *a_vp; 		struct mount **a_mpp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|UPPERVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"union: missing upper layer in getwritemount"
argument_list|)
expr_stmt|;
return|return
operator|(
name|VOP_GETWRITEMOUNT
argument_list|(
name|vp
argument_list|,
name|ap
operator|->
name|a_mpp
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	union_inactive:  *  *	Called with the vnode locked.  We are expected to unlock the vnode.  */
end_comment

begin_function
specifier|static
name|int
name|union_inactive
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_inactive_args
comment|/* { 		struct vnode *a_vp; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|ap
operator|->
name|a_p
decl_stmt|;
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
decl_stmt|;
comment|/* 	 * Do nothing (and _don't_ bypass). 	 * Wait to vrele lowervp until reclaim, 	 * so that until then our union_node is in the 	 * cache and reusable. 	 * 	 * NEEDSWORK: Someday, consider inactive'ing 	 * the lowervp and then trying to reactivate it 	 * with capabilities (v_id) 	 * like they do in the name lookup cache code. 	 * That's too much work for now. 	 */
if|if
condition|(
name|un
operator|->
name|un_dircache
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|vpp
operator|=
name|un
operator|->
name|un_dircache
init|;
operator|*
name|vpp
operator|!=
name|NULLVP
condition|;
name|vpp
operator|++
control|)
name|vrele
argument_list|(
operator|*
name|vpp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|un
operator|->
name|un_dircache
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|un
operator|->
name|un_dircache
operator|=
literal|0
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|if ((un->un_flags& UN_ULOCK)&& un->un_uppervp) { 		un->un_flags&= ~UN_ULOCK; 		VOP_UNLOCK(un->un_uppervp, 0, p); 	}
endif|#
directive|endif
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|un
operator|->
name|un_flags
operator|&
name|UN_CACHED
operator|)
operator|==
literal|0
condition|)
name|vgone
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_reclaim
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_reclaim_args
comment|/* { 		struct vnode *a_vp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|union_freevp
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_lock
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_lock_args
modifier|*
name|ap
decl_stmt|;
block|{
if|#
directive|if
literal|0
block|struct vnode *vp = ap->a_vp; 	struct proc *p = ap->a_p; 	int flags = ap->a_flags; 	struct union_node *un;
endif|#
directive|endif
name|int
name|error
decl_stmt|;
name|error
operator|=
name|vop_stdlock
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|un = VTOUNION(vp);  	if (error == 0) {
comment|/* 		 * Lock the upper if it exists and this is an exclusive lock 		 * request. 		 */
block|if (un->un_uppervp != NULLVP&&  		    (flags& LK_TYPE_MASK) == LK_EXCLUSIVE) { 			if ((un->un_flags& UN_ULOCK) == 0&& vp->v_usecount) { 				error = vn_lock(un->un_uppervp, flags, p); 				if (error) { 					struct vop_unlock_args uap = { 0 }; 					uap.a_vp = ap->a_vp; 					uap.a_flags = ap->a_flags; 					uap.a_p = ap->a_p; 					vop_stdunlock(&uap); 					return (error); 				} 				un->un_flags |= UN_ULOCK; 			} 		} 	}
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	union_unlock:  *  *	Unlock our union node.  This also unlocks uppervp.    */
end_comment

begin_function
specifier|static
name|int
name|union_unlock
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_unlock_args
comment|/* { 		struct vnode *a_vp; 		int a_flags; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|un
operator|->
name|un_uppervp
operator|==
name|NULL
operator|||
name|un
operator|->
name|un_uppervp
operator|->
name|v_usecount
operator|>
literal|0
operator|)
argument_list|,
operator|(
literal|"uppervp usecount is 0"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|vop_stdunlock
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 	 * If no exclusive locks remain and we are holding an uppervp lock, 	 * remove the uppervp lock. 	 */
block|if ((un->un_flags& UN_ULOCK)&&  	    lockstatus(&un->un_lock, NULL) != LK_EXCLUSIVE) { 		un->un_flags&= ~UN_ULOCK; 		VOP_UNLOCK(un->un_uppervp, LK_EXCLUSIVE, p); 	}
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	union_bmap:  *  *	There isn't much we can do.  We cannot push through to the real vnode  *	to get to the underlying device because this will bypass data  *	cached by the real vnode.  *  *	For some reason we cannot return the 'real' vnode either, it seems  *	to blow up memory maps.  */
end_comment

begin_function
specifier|static
name|int
name|union_bmap
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_bmap_args
comment|/* { 		struct vnode *a_vp; 		daddr_t  a_bn; 		struct vnode **a_vpp; 		daddr_t *a_bnp; 		int *a_runp; 		int *a_runb; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_print
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_print_args
comment|/* { 		struct vnode *a_vp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|printf
argument_list|(
literal|"\ttag VT_UNION, vp=%p, uppervp=%p, lowervp=%p\n"
argument_list|,
name|vp
argument_list|,
name|UPPERVP
argument_list|(
name|vp
argument_list|)
argument_list|,
name|LOWERVP
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|UPPERVP
argument_list|(
name|vp
argument_list|)
operator|!=
name|NULLVP
condition|)
name|vprint
argument_list|(
literal|"union: upper"
argument_list|,
name|UPPERVP
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOWERVP
argument_list|(
name|vp
argument_list|)
operator|!=
name|NULLVP
condition|)
name|vprint
argument_list|(
literal|"union: lower"
argument_list|,
name|LOWERVP
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_pathconf
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_pathconf_args
comment|/* { 		struct vnode *a_vp; 		int a_name; 		int *a_retval; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
comment|/* XXX */
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|vp
operator|=
name|union_lock_other
argument_list|(
name|un
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|vp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"union_pathconf: backing vnode missing!"
operator|)
argument_list|)
expr_stmt|;
name|ap
operator|->
name|a_vp
operator|=
name|vp
expr_stmt|;
name|error
operator|=
name|VCALL
argument_list|(
name|vp
argument_list|,
name|VOFFSET
argument_list|(
name|vop_pathconf
argument_list|)
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|union_unlock_other
argument_list|(
name|vp
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_advlock
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_advlock_args
comment|/* { 		struct vnode *a_vp; 		caddr_t  a_id; 		int  a_op; 		struct flock *a_fl; 		int  a_flags; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|struct
name|vnode
modifier|*
name|ovp
init|=
name|OTHERVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|ap
operator|->
name|a_vp
operator|=
name|ovp
expr_stmt|;
return|return
operator|(
name|VCALL
argument_list|(
name|ovp
argument_list|,
name|VOFFSET
argument_list|(
name|vop_advlock
argument_list|)
argument_list|,
name|ap
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * XXX - vop_strategy must be hand coded because it has no  * YYY - and it is not coherent with anything  *  * vnode in its arguments.  * This goes away with a merged VM/buffer cache.  */
end_comment

begin_function
specifier|static
name|int
name|union_strategy
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_strategy_args
comment|/* { 		struct vnode *a_vp; 		struct buf *a_bp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|buf
modifier|*
name|bp
init|=
name|ap
operator|->
name|a_bp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|othervp
init|=
name|OTHERVP
argument_list|(
name|bp
operator|->
name|b_vp
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|othervp
operator|==
name|NULLVP
condition|)
name|panic
argument_list|(
literal|"union_strategy: nil vp"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_iocmd
operator|==
name|BIO_WRITE
operator|)
operator|&&
operator|(
name|othervp
operator|==
name|LOWERVP
argument_list|(
name|bp
operator|->
name|b_vp
argument_list|)
operator|)
condition|)
name|panic
argument_list|(
literal|"union_strategy: writing to lowervp"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|VOP_STRATEGY
argument_list|(
name|othervp
argument_list|,
name|bp
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Global vfs data structures  */
end_comment

begin_decl_stmt
name|vop_t
modifier|*
modifier|*
name|union_vnodeop_p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vnodeopv_entry_desc
name|union_vnodeop_entries
index|[]
init|=
block|{
block|{
operator|&
name|vop_default_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|vop_defaultop
block|}
block|,
block|{
operator|&
name|vop_access_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_access
block|}
block|,
block|{
operator|&
name|vop_advlock_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_advlock
block|}
block|,
block|{
operator|&
name|vop_bmap_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_bmap
block|}
block|,
block|{
operator|&
name|vop_close_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_close
block|}
block|,
block|{
operator|&
name|vop_create_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_create
block|}
block|,
block|{
operator|&
name|vop_fsync_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_fsync
block|}
block|,
block|{
operator|&
name|vop_getpages_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_getpages
block|}
block|,
block|{
operator|&
name|vop_putpages_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_putpages
block|}
block|,
block|{
operator|&
name|vop_getattr_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_getattr
block|}
block|,
block|{
operator|&
name|vop_inactive_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_inactive
block|}
block|,
block|{
operator|&
name|vop_ioctl_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_ioctl
block|}
block|,
block|{
operator|&
name|vop_islocked_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|vop_stdislocked
block|}
block|,
block|{
operator|&
name|vop_lease_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_lease
block|}
block|,
block|{
operator|&
name|vop_link_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_link
block|}
block|,
block|{
operator|&
name|vop_lock_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_lock
block|}
block|,
block|{
operator|&
name|vop_lookup_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_lookup
block|}
block|,
block|{
operator|&
name|vop_mkdir_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_mkdir
block|}
block|,
block|{
operator|&
name|vop_mknod_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_mknod
block|}
block|,
block|{
operator|&
name|vop_mmap_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_mmap
block|}
block|,
block|{
operator|&
name|vop_open_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_open
block|}
block|,
block|{
operator|&
name|vop_pathconf_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_pathconf
block|}
block|,
block|{
operator|&
name|vop_poll_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_poll
block|}
block|,
block|{
operator|&
name|vop_print_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_print
block|}
block|,
block|{
operator|&
name|vop_read_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_read
block|}
block|,
block|{
operator|&
name|vop_readdir_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_readdir
block|}
block|,
block|{
operator|&
name|vop_readlink_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_readlink
block|}
block|,
block|{
operator|&
name|vop_getwritemount_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_getwritemount
block|}
block|,
block|{
operator|&
name|vop_reclaim_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_reclaim
block|}
block|,
block|{
operator|&
name|vop_remove_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_remove
block|}
block|,
block|{
operator|&
name|vop_rename_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_rename
block|}
block|,
block|{
operator|&
name|vop_revoke_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_revoke
block|}
block|,
block|{
operator|&
name|vop_rmdir_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_rmdir
block|}
block|,
block|{
operator|&
name|vop_setattr_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_setattr
block|}
block|,
block|{
operator|&
name|vop_strategy_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_strategy
block|}
block|,
block|{
operator|&
name|vop_symlink_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_symlink
block|}
block|,
block|{
operator|&
name|vop_unlock_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_unlock
block|}
block|,
block|{
operator|&
name|vop_whiteout_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_whiteout
block|}
block|,
block|{
operator|&
name|vop_write_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_write
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vnodeopv_desc
name|union_vnodeop_opv_desc
init|=
block|{
operator|&
name|union_vnodeop_p
block|,
name|union_vnodeop_entries
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|VNODEOP_SET
argument_list|(
name|union_vnodeop_opv_desc
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

