begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, 1993, 1994 The Regents of the University of California.  * Copyright (c) 1992, 1993, 1994 Jan-Simon Pendry.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Jan-Simon Pendry.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)union_vnops.c	8.6 (Berkeley) 2/17/94  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<miscfs/union/union.h>
end_include

begin_comment
comment|/* FIXUP throws the lock on the uppervp vnode if the union_node is already  * locked and the uppervp vnode is not.  Before, this was thrown regardless  * of the state of the union_node which resulted in locked vnodes which  * were never unlocked (since the union would never be unlocked).  */
end_comment

begin_define
define|#
directive|define
name|FIXUP
parameter_list|(
name|un
parameter_list|)
value|{ \ 	if (((un)->un_flags& (UN_LOCKED|UN_ULOCK)) == UN_LOCKED) { \ 		union_fixup(un); \ 	} \ }
end_define

begin_function
specifier|static
name|void
name|union_fixup
parameter_list|(
name|un
parameter_list|)
name|struct
name|union_node
modifier|*
name|un
decl_stmt|;
block|{
name|VOP_LOCK
argument_list|(
name|un
operator|->
name|un_uppervp
argument_list|)
expr_stmt|;
name|un
operator|->
name|un_flags
operator||=
name|UN_ULOCK
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_lookup1
parameter_list|(
name|udvp
parameter_list|,
name|dvp
parameter_list|,
name|vpp
parameter_list|,
name|cnp
parameter_list|)
name|struct
name|vnode
modifier|*
name|udvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
decl_stmt|;
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|vnode
modifier|*
name|tdvp
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
comment|/* 	 * If stepping up the directory tree, check for going 	 * back across the mount point, in which case do what 	 * lookup would do by stepping back down the mount 	 * hierarchy. 	 */
if|if
condition|(
name|cnp
operator|->
name|cn_flags
operator|&
name|ISDOTDOT
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 			 * Don't do the NOCROSSMOUNT check 			 * at this level.  By definition, 			 * union fs deals with namespaces, not 			 * filesystems. 			 */
if|if
condition|(
operator|(
name|dvp
operator|->
name|v_flag
operator|&
name|VROOT
operator|)
operator|==
literal|0
condition|)
break|break;
name|tdvp
operator|=
name|dvp
expr_stmt|;
name|dvp
operator|=
name|dvp
operator|->
name|v_mount
operator|->
name|mnt_vnodecovered
expr_stmt|;
name|vput
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
name|VREF
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|VOP_LOCK
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
block|}
block|}
name|error
operator|=
name|VOP_LOOKUP
argument_list|(
name|dvp
argument_list|,
operator|&
name|tdvp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * The parent directory will have been unlocked, unless lookup 	 * found the last component.  In which case, re-lock the node 	 * here to allow it to be unlocked again (phew) in union_lookup. 	 */
if|if
condition|(
name|dvp
operator|!=
name|tdvp
operator|&&
operator|!
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|ISLASTCN
operator|)
condition|)
name|VOP_LOCK
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|dvp
operator|=
name|tdvp
expr_stmt|;
comment|/* 	 * Lastly check if the current node is a mount point in 	 * which case walk up the mount hierarchy making sure not to 	 * bump into the root of the mount tree (ie. dvp != udvp). 	 */
while|while
condition|(
name|dvp
operator|!=
name|udvp
operator|&&
operator|(
name|dvp
operator|->
name|v_type
operator|==
name|VDIR
operator|)
operator|&&
operator|(
name|mp
operator|=
name|dvp
operator|->
name|v_mountedhere
operator|)
condition|)
block|{
if|if
condition|(
name|mp
operator|->
name|mnt_flag
operator|&
name|MNT_MLOCK
condition|)
block|{
name|mp
operator|->
name|mnt_flag
operator||=
name|MNT_MWAIT
expr_stmt|;
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|mp
argument_list|,
name|PVFS
argument_list|,
literal|"unlkup"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|error
operator|=
name|VFS_ROOT
argument_list|(
name|mp
argument_list|,
operator|&
name|tdvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|vput
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|vput
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|dvp
operator|=
name|tdvp
expr_stmt|;
block|}
operator|*
name|vpp
operator|=
name|dvp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|union_lookup
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_lookup_args
comment|/* { 		struct vnodeop_desc *a_desc; 		struct vnode *a_dvp; 		struct vnode **a_vpp; 		struct componentname *a_cnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|int
name|uerror
decl_stmt|,
name|lerror
decl_stmt|;
name|struct
name|vnode
modifier|*
name|uppervp
decl_stmt|,
modifier|*
name|lowervp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|upperdvp
decl_stmt|,
modifier|*
name|lowerdvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
name|struct
name|union_node
modifier|*
name|dun
init|=
name|VTOUNION
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|int
name|lockparent
init|=
name|cnp
operator|->
name|cn_flags
operator|&
name|LOCKPARENT
decl_stmt|;
name|struct
name|union_mount
modifier|*
name|um
init|=
name|MOUNTTOUNIONMOUNT
argument_list|(
name|dvp
operator|->
name|v_mount
argument_list|)
decl_stmt|;
name|struct
name|ucred
modifier|*
name|saved_cred
init|=
literal|0
decl_stmt|;
name|cnp
operator|->
name|cn_flags
operator||=
name|LOCKPARENT
expr_stmt|;
name|upperdvp
operator|=
name|dun
operator|->
name|un_uppervp
expr_stmt|;
name|lowerdvp
operator|=
name|dun
operator|->
name|un_lowervp
expr_stmt|;
name|uppervp
operator|=
name|NULLVP
expr_stmt|;
name|lowervp
operator|=
name|NULLVP
expr_stmt|;
comment|/* 	 * do the lookup in the upper level. 	 * if that level comsumes additional pathnames, 	 * then assume that something special is going 	 * on and just return that vnode. 	 */
if|if
condition|(
name|upperdvp
condition|)
block|{
name|FIXUP
argument_list|(
name|dun
argument_list|)
expr_stmt|;
name|uerror
operator|=
name|union_lookup1
argument_list|(
name|um
operator|->
name|um_uppervp
argument_list|,
name|upperdvp
argument_list|,
operator|&
name|uppervp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
comment|/*if (uppervp == upperdvp) 			dun->un_flags |= UN_KLOCK;*/
if|if
condition|(
name|cnp
operator|->
name|cn_consume
operator|!=
literal|0
condition|)
block|{
operator|*
name|ap
operator|->
name|a_vpp
operator|=
name|uppervp
expr_stmt|;
if|if
condition|(
operator|!
name|lockparent
condition|)
name|cnp
operator|->
name|cn_flags
operator|&=
operator|~
name|LOCKPARENT
expr_stmt|;
return|return
operator|(
name|uerror
operator|)
return|;
block|}
block|}
else|else
block|{
name|uerror
operator|=
name|ENOENT
expr_stmt|;
block|}
comment|/* 	 * in a similar way to the upper layer, do the lookup 	 * in the lower layer.   this time, if there is some 	 * component magic going on, then vput whatever we got 	 * back from the upper layer and return the lower vnode 	 * instead. 	 */
if|if
condition|(
name|lowerdvp
condition|)
block|{
name|int
name|nameiop
decl_stmt|;
name|VOP_LOCK
argument_list|(
name|lowerdvp
argument_list|)
expr_stmt|;
comment|/* 		 * Only do a LOOKUP on the bottom node, since 		 * we won't be making changes to it anyway. 		 */
name|nameiop
operator|=
name|cnp
operator|->
name|cn_nameiop
expr_stmt|;
name|cnp
operator|->
name|cn_nameiop
operator|=
name|LOOKUP
expr_stmt|;
if|if
condition|(
name|um
operator|->
name|um_op
operator|==
name|UNMNT_BELOW
condition|)
block|{
name|saved_cred
operator|=
name|cnp
operator|->
name|cn_cred
expr_stmt|;
name|cnp
operator|->
name|cn_cred
operator|=
name|um
operator|->
name|um_cred
expr_stmt|;
block|}
name|lerror
operator|=
name|union_lookup1
argument_list|(
name|um
operator|->
name|um_lowervp
argument_list|,
name|lowerdvp
argument_list|,
operator|&
name|lowervp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
if|if
condition|(
name|um
operator|->
name|um_op
operator|==
name|UNMNT_BELOW
condition|)
name|cnp
operator|->
name|cn_cred
operator|=
name|saved_cred
expr_stmt|;
name|cnp
operator|->
name|cn_nameiop
operator|=
name|nameiop
expr_stmt|;
if|if
condition|(
name|lowervp
operator|!=
name|lowerdvp
condition|)
name|VOP_UNLOCK
argument_list|(
name|lowerdvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnp
operator|->
name|cn_consume
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|uppervp
condition|)
block|{
if|if
condition|(
name|uppervp
operator|==
name|upperdvp
condition|)
name|vrele
argument_list|(
name|uppervp
argument_list|)
expr_stmt|;
else|else
name|vput
argument_list|(
name|uppervp
argument_list|)
expr_stmt|;
name|uppervp
operator|=
name|NULLVP
expr_stmt|;
block|}
operator|*
name|ap
operator|->
name|a_vpp
operator|=
name|lowervp
expr_stmt|;
if|if
condition|(
operator|!
name|lockparent
condition|)
name|cnp
operator|->
name|cn_flags
operator|&=
operator|~
name|LOCKPARENT
expr_stmt|;
return|return
operator|(
name|lerror
operator|)
return|;
block|}
block|}
else|else
block|{
name|lerror
operator|=
name|ENOENT
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|lockparent
condition|)
name|cnp
operator|->
name|cn_flags
operator|&=
operator|~
name|LOCKPARENT
expr_stmt|;
comment|/* 	 * at this point, we have uerror and lerror indicating 	 * possible errors with the lookups in the upper and lower 	 * layers.  additionally, uppervp and lowervp are (locked) 	 * references to existing vnodes in the upper and lower layers. 	 * 	 * there are now three cases to consider. 	 * 1. if both layers returned an error, then return whatever 	 *    error the upper layer generated. 	 * 	 * 2. if the top layer failed and the bottom layer succeeded 	 *    then two subcases occur. 	 *    a.  the bottom vnode is not a directory, in which 	 *	  case just return a new union vnode referencing 	 *	  an empty top layer and the existing bottom layer. 	 *    b.  the bottom vnode is a directory, in which case 	 *	  create a new directory in the top-level and 	 *	  continue as in case 3. 	 * 	 * 3. if the top layer succeeded then return a new union 	 *    vnode referencing whatever the new top layer and 	 *    whatever the bottom layer returned. 	 */
operator|*
name|ap
operator|->
name|a_vpp
operator|=
name|NULLVP
expr_stmt|;
comment|/* case 1. */
if|if
condition|(
operator|(
name|uerror
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|lerror
operator|!=
literal|0
operator|)
condition|)
block|{
return|return
operator|(
name|uerror
operator|)
return|;
block|}
comment|/* case 2. */
if|if
condition|(
name|uerror
operator|!=
literal|0
comment|/*&& (lerror == 0) */
condition|)
block|{
if|if
condition|(
name|lowervp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
block|{
comment|/* case 2b. */
name|dun
operator|->
name|un_flags
operator|&=
operator|~
name|UN_ULOCK
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|upperdvp
argument_list|)
expr_stmt|;
name|uerror
operator|=
name|union_mkshadow
argument_list|(
name|um
argument_list|,
name|upperdvp
argument_list|,
name|cnp
argument_list|,
operator|&
name|uppervp
argument_list|)
expr_stmt|;
name|VOP_LOCK
argument_list|(
name|upperdvp
argument_list|)
expr_stmt|;
name|dun
operator|->
name|un_flags
operator||=
name|UN_ULOCK
expr_stmt|;
if|if
condition|(
name|uerror
condition|)
block|{
if|if
condition|(
name|lowervp
condition|)
block|{
name|vput
argument_list|(
name|lowervp
argument_list|)
expr_stmt|;
name|lowervp
operator|=
name|NULLVP
expr_stmt|;
block|}
return|return
operator|(
name|uerror
operator|)
return|;
block|}
block|}
block|}
if|if
condition|(
name|lowervp
condition|)
name|VOP_UNLOCK
argument_list|(
name|lowervp
argument_list|)
expr_stmt|;
name|error
operator|=
name|union_allocvp
argument_list|(
name|ap
operator|->
name|a_vpp
argument_list|,
name|dvp
operator|->
name|v_mount
argument_list|,
name|dvp
argument_list|,
name|upperdvp
argument_list|,
name|cnp
argument_list|,
name|uppervp
argument_list|,
name|lowervp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|uppervp
condition|)
name|vput
argument_list|(
name|uppervp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lowervp
condition|)
name|vrele
argument_list|(
name|lowervp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|ap
operator|->
name|a_vpp
operator|!=
name|dvp
condition|)
if|if
condition|(
operator|!
name|lockparent
operator|||
operator|!
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|ISLASTCN
operator|)
condition|)
name|VOP_UNLOCK
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|union_create
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_create_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode **a_vpp; 		struct componentname *a_cnp; 		struct vattr *a_vap; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|un
operator|->
name|un_uppervp
decl_stmt|;
if|if
condition|(
name|dvp
condition|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|FIXUP
argument_list|(
name|un
argument_list|)
expr_stmt|;
name|VREF
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|un
operator|->
name|un_flags
operator||=
name|UN_KLOCK
expr_stmt|;
name|vput
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_CREATE
argument_list|(
name|dvp
argument_list|,
operator|&
name|vp
argument_list|,
name|ap
operator|->
name|a_cnp
argument_list|,
name|ap
operator|->
name|a_vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|union_allocvp
argument_list|(
name|ap
operator|->
name|a_vpp
argument_list|,
name|ap
operator|->
name|a_dvp
operator|->
name|v_mount
argument_list|,
name|ap
operator|->
name|a_dvp
argument_list|,
name|NULLVP
argument_list|,
name|ap
operator|->
name|a_cnp
argument_list|,
name|vp
argument_list|,
name|NULLVP
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|vput
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EROFS
operator|)
return|;
block|}
end_function

begin_function
name|int
name|union_mknod
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_mknod_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode **a_vpp; 		struct componentname *a_cnp; 		struct vattr *a_vap; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|un
operator|->
name|un_uppervp
decl_stmt|;
if|if
condition|(
name|dvp
condition|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|FIXUP
argument_list|(
name|un
argument_list|)
expr_stmt|;
name|VREF
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|un
operator|->
name|un_flags
operator||=
name|UN_KLOCK
expr_stmt|;
name|vput
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_MKNOD
argument_list|(
name|dvp
argument_list|,
operator|&
name|vp
argument_list|,
name|ap
operator|->
name|a_cnp
argument_list|,
name|ap
operator|->
name|a_vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|vp
condition|)
block|{
name|error
operator|=
name|union_allocvp
argument_list|(
name|ap
operator|->
name|a_vpp
argument_list|,
name|ap
operator|->
name|a_dvp
operator|->
name|v_mount
argument_list|,
name|ap
operator|->
name|a_dvp
argument_list|,
name|NULLVP
argument_list|,
name|ap
operator|->
name|a_cnp
argument_list|,
name|vp
argument_list|,
name|NULLVP
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
name|vput
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EROFS
operator|)
return|;
block|}
end_function

begin_function
name|int
name|union_open
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_open_args
comment|/* { 		struct vnodeop_desc *a_desc; 		struct vnode *a_vp; 		int a_mode; 		struct ucred *a_cred; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|struct
name|vnode
modifier|*
name|tvp
decl_stmt|;
name|int
name|mode
init|=
name|ap
operator|->
name|a_mode
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|ap
operator|->
name|a_cred
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|ap
operator|->
name|a_p
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * If there is an existing upper vp then simply open that. 	 */
name|tvp
operator|=
name|un
operator|->
name|un_uppervp
expr_stmt|;
if|if
condition|(
name|tvp
operator|==
name|NULLVP
condition|)
block|{
comment|/* 		 * If the lower vnode is being opened for writing, then 		 * copy the file contents to the upper vnode and open that, 		 * otherwise can simply open the lower vnode. 		 */
name|tvp
operator|=
name|un
operator|->
name|un_lowervp
expr_stmt|;
if|if
condition|(
operator|(
name|ap
operator|->
name|a_mode
operator|&
name|FWRITE
operator|)
operator|&&
operator|(
name|tvp
operator|->
name|v_type
operator|==
name|VREG
operator|)
condition|)
block|{
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 			 * Open the named file in the upper layer.  Note that 			 * the file may have come into existence *since* the 			 * lookup was done, since the upper layer may really 			 * be a loopback mount of some other filesystem... 			 * so open the file with exclusive create and barf if 			 * it already exists. 			 * XXX - perhaps should re-lookup the node (once more 			 * with feeling) and simply open that.  Who knows. 			 */
name|error
operator|=
name|union_vn_create
argument_list|(
operator|&
name|vp
argument_list|,
name|un
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* at this point, uppervp is locked */
name|union_newupper
argument_list|(
name|un
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|un
operator|->
name|un_flags
operator||=
name|UN_ULOCK
expr_stmt|;
comment|/* 			 * Now, if the file is being opened with truncation, 			 * then the (new) upper vnode is ready to fly, 			 * otherwise the data from the lower vnode must be 			 * copied to the upper layer first.  This only works 			 * for regular files (check is made above). 			 */
if|if
condition|(
operator|(
name|mode
operator|&
name|O_TRUNC
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * XXX - should not ignore errors 				 * from VOP_CLOSE 				 */
name|VOP_LOCK
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_OPEN
argument_list|(
name|tvp
argument_list|,
name|FREAD
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|union_copyfile
argument_list|(
name|p
argument_list|,
name|cred
argument_list|,
name|tvp
argument_list|,
name|un
operator|->
name|un_uppervp
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|VOP_CLOSE
argument_list|(
name|tvp
argument_list|,
name|FREAD
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|VOP_UNLOCK
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|UNION_DIAGNOSTIC
if|if
condition|(
operator|!
name|error
condition|)
name|uprintf
argument_list|(
literal|"union: copied up %s\n"
argument_list|,
name|un
operator|->
name|un_path
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|un
operator|->
name|un_flags
operator|&=
operator|~
name|UN_ULOCK
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|un
operator|->
name|un_uppervp
argument_list|)
expr_stmt|;
name|union_vn_close
argument_list|(
name|un
operator|->
name|un_uppervp
argument_list|,
name|FWRITE
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|VOP_LOCK
argument_list|(
name|un
operator|->
name|un_uppervp
argument_list|)
expr_stmt|;
name|un
operator|->
name|un_flags
operator||=
name|UN_ULOCK
expr_stmt|;
comment|/* 			 * Subsequent IOs will go to the top layer, so 			 * call close on the lower vnode and open on the 			 * upper vnode to ensure that the filesystem keeps 			 * its references counts right.  This doesn't do 			 * the right thing with (cred) and (FREAD) though. 			 * Ignoring error returns is not righ, either. 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|un
operator|->
name|un_openl
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|VOP_CLOSE
argument_list|(
name|tvp
argument_list|,
name|FREAD
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|VOP_OPEN
argument_list|(
name|un
operator|->
name|un_uppervp
argument_list|,
name|FREAD
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|un
operator|->
name|un_openl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|VOP_OPEN
argument_list|(
name|un
operator|->
name|un_uppervp
argument_list|,
name|mode
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 		 * Just open the lower vnode 		 */
name|un
operator|->
name|un_openl
operator|++
expr_stmt|;
name|VOP_LOCK
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_OPEN
argument_list|(
name|tvp
argument_list|,
name|mode
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|FIXUP
argument_list|(
name|un
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_OPEN
argument_list|(
name|tvp
argument_list|,
name|mode
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|union_close
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_close_args
comment|/* { 		struct vnode *a_vp; 		int  a_fflag; 		struct ucred *a_cred; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
if|if
condition|(
name|un
operator|->
name|un_uppervp
condition|)
block|{
name|vp
operator|=
name|un
operator|->
name|un_uppervp
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|UNION_DIAGNOSTIC
if|if
condition|(
name|un
operator|->
name|un_openl
operator|<=
literal|0
condition|)
name|panic
argument_list|(
literal|"union: un_openl cnt"
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|--
name|un
operator|->
name|un_openl
expr_stmt|;
name|vp
operator|=
name|un
operator|->
name|un_lowervp
expr_stmt|;
block|}
return|return
operator|(
name|VOP_CLOSE
argument_list|(
name|vp
argument_list|,
name|ap
operator|->
name|a_fflag
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_p
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check access permission on the union vnode.  * The access check being enforced is to check  * against both the underlying vnode, and any  * copied vnode.  This ensures that no additional  * file permissions are given away simply because  * the user caused an implicit file copy.  */
end_comment

begin_function
name|int
name|union_access
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_access_args
comment|/* { 		struct vnodeop_desc *a_desc; 		struct vnode *a_vp; 		int a_mode; 		struct ucred *a_cred; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|int
name|error
init|=
name|EACCES
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|vp
operator|=
name|un
operator|->
name|un_uppervp
expr_stmt|;
if|if
condition|(
name|vp
condition|)
block|{
name|FIXUP
argument_list|(
name|un
argument_list|)
expr_stmt|;
return|return
operator|(
name|VOP_ACCESS
argument_list|(
name|vp
argument_list|,
name|ap
operator|->
name|a_mode
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_p
argument_list|)
operator|)
return|;
block|}
name|vp
operator|=
name|un
operator|->
name|un_lowervp
expr_stmt|;
if|if
condition|(
name|vp
condition|)
block|{
name|VOP_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|vp
argument_list|,
name|ap
operator|->
name|a_mode
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|struct
name|union_mount
modifier|*
name|um
init|=
name|MOUNTTOUNIONMOUNT
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
decl_stmt|;
if|if
condition|(
name|um
operator|->
name|um_op
operator|==
name|UNMNT_BELOW
condition|)
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|vp
argument_list|,
name|ap
operator|->
name|a_mode
argument_list|,
name|um
operator|->
name|um_cred
argument_list|,
name|ap
operator|->
name|a_p
argument_list|)
expr_stmt|;
block|}
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  We handle getattr only to change the fsid.  */
end_comment

begin_function
name|int
name|union_getattr
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_getattr_args
comment|/* { 		struct vnode *a_vp; 		struct vattr *a_vap; 		struct ucred *a_cred; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|un
operator|->
name|un_uppervp
decl_stmt|;
name|struct
name|vattr
modifier|*
name|vap
decl_stmt|;
name|struct
name|vattr
name|va
decl_stmt|;
comment|/* 	 * Some programs walk the filesystem hierarchy by counting 	 * links to directories to avoid stat'ing all the time. 	 * This means the link count on directories needs to be "correct". 	 * The only way to do that is to call getattr on both layers 	 * and fix up the link count.  The link count will not necessarily 	 * be accurate but will be large enough to defeat the tree walkers. 	 */
name|vap
operator|=
name|ap
operator|->
name|a_vap
expr_stmt|;
name|vp
operator|=
name|un
operator|->
name|un_uppervp
expr_stmt|;
if|if
condition|(
name|vp
operator|!=
name|NULLVP
condition|)
block|{
name|FIXUP
argument_list|(
name|un
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
name|vap
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|vp
operator|==
name|NULLVP
condition|)
block|{
name|vp
operator|=
name|un
operator|->
name|un_lowervp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
block|{
name|vp
operator|=
name|un
operator|->
name|un_lowervp
expr_stmt|;
name|vap
operator|=
operator|&
name|va
expr_stmt|;
block|}
else|else
block|{
name|vp
operator|=
name|NULLVP
expr_stmt|;
block|}
if|if
condition|(
name|vp
operator|!=
name|NULLVP
condition|)
block|{
name|VOP_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
name|vap
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_p
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|vap
operator|!=
name|ap
operator|->
name|a_vap
operator|)
operator|&&
operator|(
name|vap
operator|->
name|va_type
operator|==
name|VDIR
operator|)
condition|)
name|ap
operator|->
name|a_vap
operator|->
name|va_nlink
operator|+=
name|vap
operator|->
name|va_nlink
expr_stmt|;
name|vap
operator|->
name|va_fsid
operator|=
name|ap
operator|->
name|a_vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_fsid
operator|.
name|val
index|[
literal|0
index|]
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|union_setattr
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_setattr_args
comment|/* { 		struct vnode *a_vp; 		struct vattr *a_vap; 		struct ucred *a_cred; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Handle case of truncating lower object to zero size, 	 * by creating a zero length upper object.  This is to 	 * handle the case of open with O_TRUNC and O_CREAT. 	 */
if|if
condition|(
operator|(
name|un
operator|->
name|un_uppervp
operator|==
name|NULLVP
operator|)
operator|&&
comment|/* assert(un->un_lowervp != NULLVP) */
operator|(
name|un
operator|->
name|un_lowervp
operator|->
name|v_type
operator|==
name|VREG
operator|)
operator|&&
operator|(
name|ap
operator|->
name|a_vap
operator|->
name|va_size
operator|==
literal|0
operator|)
condition|)
block|{
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|error
operator|=
name|union_vn_create
argument_list|(
operator|&
name|vp
argument_list|,
name|un
argument_list|,
name|ap
operator|->
name|a_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* at this point, uppervp is locked */
name|union_newupper
argument_list|(
name|un
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|union_vn_close
argument_list|(
name|un
operator|->
name|un_uppervp
argument_list|,
name|FWRITE
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_p
argument_list|)
expr_stmt|;
name|VOP_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|un
operator|->
name|un_flags
operator||=
name|UN_ULOCK
expr_stmt|;
block|}
comment|/* 	 * Try to set attributes in upper layer, 	 * otherwise return read-only filesystem error. 	 */
if|if
condition|(
name|un
operator|->
name|un_uppervp
operator|!=
name|NULLVP
condition|)
block|{
name|FIXUP
argument_list|(
name|un
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_SETATTR
argument_list|(
name|un
operator|->
name|un_uppervp
argument_list|,
name|ap
operator|->
name|a_vap
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|EROFS
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|union_read
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_read_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		int  a_ioflag; 		struct ucred *a_cred; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|OTHERVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|int
name|dolock
init|=
operator|(
name|vp
operator|==
name|LOWERVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|dolock
condition|)
name|VOP_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
else|else
name|FIXUP
argument_list|(
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_READ
argument_list|(
name|vp
argument_list|,
name|ap
operator|->
name|a_uio
argument_list|,
name|ap
operator|->
name|a_ioflag
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|dolock
condition|)
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|union_write
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_read_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		int  a_ioflag; 		struct ucred *a_cred; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|OTHERVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|int
name|dolock
init|=
operator|(
name|vp
operator|==
name|LOWERVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|dolock
condition|)
name|VOP_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
else|else
name|FIXUP
argument_list|(
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_WRITE
argument_list|(
name|vp
argument_list|,
name|ap
operator|->
name|a_uio
argument_list|,
name|ap
operator|->
name|a_ioflag
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|dolock
condition|)
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|union_ioctl
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_ioctl_args
comment|/* { 		struct vnode *a_vp; 		int  a_command; 		caddr_t  a_data; 		int  a_fflag; 		struct ucred *a_cred; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
name|VOP_IOCTL
argument_list|(
name|OTHERVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_command
argument_list|,
name|ap
operator|->
name|a_data
argument_list|,
name|ap
operator|->
name|a_fflag
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_p
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|union_select
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_select_args
comment|/* { 		struct vnode *a_vp; 		int  a_which; 		int  a_fflags; 		struct ucred *a_cred; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
name|VOP_SELECT
argument_list|(
name|OTHERVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_which
argument_list|,
name|ap
operator|->
name|a_fflags
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_p
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|union_mmap
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_mmap_args
comment|/* { 		struct vnode *a_vp; 		int  a_fflags; 		struct ucred *a_cred; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
name|VOP_MMAP
argument_list|(
name|OTHERVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_fflags
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_p
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|union_fsync
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_fsync_args
comment|/* { 		struct vnode *a_vp; 		struct ucred *a_cred; 		int  a_waitfor; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|vnode
modifier|*
name|targetvp
init|=
name|OTHERVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
if|if
condition|(
name|targetvp
condition|)
block|{
name|int
name|dolock
init|=
operator|(
name|targetvp
operator|==
name|LOWERVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|dolock
condition|)
name|VOP_LOCK
argument_list|(
name|targetvp
argument_list|)
expr_stmt|;
else|else
name|FIXUP
argument_list|(
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_FSYNC
argument_list|(
name|targetvp
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_waitfor
argument_list|,
name|ap
operator|->
name|a_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|dolock
condition|)
name|VOP_UNLOCK
argument_list|(
name|targetvp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|union_seek
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_seek_args
comment|/* { 		struct vnode *a_vp; 		off_t  a_oldoff; 		off_t  a_newoff; 		struct ucred *a_cred; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
name|VOP_SEEK
argument_list|(
name|OTHERVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_oldoff
argument_list|,
name|ap
operator|->
name|a_newoff
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|union_remove
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_remove_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode *a_vp; 		struct componentname *a_cnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|union_node
modifier|*
name|dun
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
decl_stmt|;
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
if|if
condition|(
name|dun
operator|->
name|un_uppervp
operator|&&
name|un
operator|->
name|un_uppervp
condition|)
block|{
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|dun
operator|->
name|un_uppervp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|un
operator|->
name|un_uppervp
decl_stmt|;
name|FIXUP
argument_list|(
name|dun
argument_list|)
expr_stmt|;
name|VREF
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|dun
operator|->
name|un_flags
operator||=
name|UN_KLOCK
expr_stmt|;
name|vput
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
name|FIXUP
argument_list|(
name|un
argument_list|)
expr_stmt|;
name|VREF
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|un
operator|->
name|un_flags
operator||=
name|UN_KLOCK
expr_stmt|;
name|vput
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_REMOVE
argument_list|(
name|dvp
argument_list|,
name|vp
argument_list|,
name|ap
operator|->
name|a_cnp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|union_removed_upper
argument_list|(
name|un
argument_list|)
expr_stmt|;
comment|/* 		 * XXX: should create a whiteout here 		 */
block|}
else|else
block|{
comment|/* 		 * XXX: should create a whiteout here 		 */
name|vput
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|error
operator|=
name|EROFS
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|union_link
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_link_args
comment|/* { 		struct vnode *a_vp; 		struct vnode *a_tdvp; 		struct componentname *a_cnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|union_node
modifier|*
name|dun
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_tdvp
argument_list|)
decl_stmt|;
if|if
condition|(
name|dun
operator|->
name|un_uppervp
operator|&&
name|un
operator|->
name|un_uppervp
condition|)
block|{
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|dun
operator|->
name|un_uppervp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|un
operator|->
name|un_uppervp
decl_stmt|;
name|FIXUP
argument_list|(
name|dun
argument_list|)
expr_stmt|;
name|VREF
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|dun
operator|->
name|un_flags
operator||=
name|UN_KLOCK
expr_stmt|;
name|vput
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|FIXUP
argument_list|(
name|un
argument_list|)
expr_stmt|;
name|VREF
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|ap
operator|->
name|a_tdvp
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_LINK
argument_list|(
name|dvp
argument_list|,
name|vp
argument_list|,
name|ap
operator|->
name|a_cnp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * XXX: need to copy to upper layer 		 * and do the link there. 		 */
name|vput
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|ap
operator|->
name|a_tdvp
argument_list|)
expr_stmt|;
name|error
operator|=
name|EROFS
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|union_rename
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_rename_args
comment|/* { 		struct vnode *a_fdvp; 		struct vnode *a_fvp; 		struct componentname *a_fcnp; 		struct vnode *a_tdvp; 		struct vnode *a_tvp; 		struct componentname *a_tcnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|vnode
modifier|*
name|fdvp
init|=
name|ap
operator|->
name|a_fdvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|fvp
init|=
name|ap
operator|->
name|a_fvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|tdvp
init|=
name|ap
operator|->
name|a_tdvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|tvp
init|=
name|ap
operator|->
name|a_tvp
decl_stmt|;
if|if
condition|(
name|fdvp
operator|->
name|v_op
operator|==
name|union_vnodeop_p
condition|)
block|{
comment|/* always true */
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|fdvp
argument_list|)
decl_stmt|;
if|if
condition|(
name|un
operator|->
name|un_uppervp
operator|==
name|NULLVP
condition|)
block|{
name|error
operator|=
name|EROFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|FIXUP
argument_list|(
name|un
argument_list|)
expr_stmt|;
name|fdvp
operator|=
name|un
operator|->
name|un_uppervp
expr_stmt|;
name|VREF
argument_list|(
name|fdvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|ap
operator|->
name|a_fdvp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fvp
operator|->
name|v_op
operator|==
name|union_vnodeop_p
condition|)
block|{
comment|/* always true */
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|fvp
argument_list|)
decl_stmt|;
if|if
condition|(
name|un
operator|->
name|un_uppervp
operator|==
name|NULLVP
condition|)
block|{
name|error
operator|=
name|EROFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|FIXUP
argument_list|(
name|un
argument_list|)
expr_stmt|;
name|fvp
operator|=
name|un
operator|->
name|un_uppervp
expr_stmt|;
name|VREF
argument_list|(
name|fvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|ap
operator|->
name|a_fvp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tdvp
operator|->
name|v_op
operator|==
name|union_vnodeop_p
condition|)
block|{
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|tdvp
argument_list|)
decl_stmt|;
if|if
condition|(
name|un
operator|->
name|un_uppervp
operator|==
name|NULLVP
condition|)
block|{
name|error
operator|=
name|EROFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|tdvp
operator|=
name|un
operator|->
name|un_uppervp
expr_stmt|;
name|VREF
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
name|un
operator|->
name|un_flags
operator||=
name|UN_KLOCK
expr_stmt|;
name|vput
argument_list|(
name|ap
operator|->
name|a_tdvp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tvp
operator|&&
name|tvp
operator|->
name|v_op
operator|==
name|union_vnodeop_p
condition|)
block|{
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|tvp
argument_list|)
decl_stmt|;
if|if
condition|(
name|un
operator|->
name|un_uppervp
operator|==
name|NULLVP
condition|)
block|{
name|error
operator|=
name|EROFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|tvp
operator|=
name|un
operator|->
name|un_uppervp
expr_stmt|;
name|VREF
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
name|un
operator|->
name|un_flags
operator||=
name|UN_KLOCK
expr_stmt|;
name|vput
argument_list|(
name|ap
operator|->
name|a_tvp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|VOP_RENAME
argument_list|(
name|fdvp
argument_list|,
name|fvp
argument_list|,
name|ap
operator|->
name|a_fcnp
argument_list|,
name|tdvp
argument_list|,
name|tvp
argument_list|,
name|ap
operator|->
name|a_tcnp
argument_list|)
operator|)
return|;
name|bad
label|:
name|vrele
argument_list|(
name|fdvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|fvp
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tvp
condition|)
name|vput
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|union_mkdir
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_mkdir_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode **a_vpp; 		struct componentname *a_cnp; 		struct vattr *a_vap; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|un
operator|->
name|un_uppervp
decl_stmt|;
if|if
condition|(
name|dvp
condition|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|FIXUP
argument_list|(
name|un
argument_list|)
expr_stmt|;
name|VREF
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|un
operator|->
name|un_flags
operator||=
name|UN_KLOCK
expr_stmt|;
name|vput
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_MKDIR
argument_list|(
name|dvp
argument_list|,
operator|&
name|vp
argument_list|,
name|ap
operator|->
name|a_cnp
argument_list|,
name|ap
operator|->
name|a_vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|union_allocvp
argument_list|(
name|ap
operator|->
name|a_vpp
argument_list|,
name|ap
operator|->
name|a_dvp
operator|->
name|v_mount
argument_list|,
name|ap
operator|->
name|a_dvp
argument_list|,
name|NULLVP
argument_list|,
name|ap
operator|->
name|a_cnp
argument_list|,
name|vp
argument_list|,
name|NULLVP
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|vput
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EROFS
operator|)
return|;
block|}
end_function

begin_function
name|int
name|union_rmdir
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_rmdir_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode *a_vp; 		struct componentname *a_cnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|union_node
modifier|*
name|dun
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
decl_stmt|;
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
if|if
condition|(
name|dun
operator|->
name|un_uppervp
operator|&&
name|un
operator|->
name|un_uppervp
condition|)
block|{
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|dun
operator|->
name|un_uppervp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|un
operator|->
name|un_uppervp
decl_stmt|;
name|FIXUP
argument_list|(
name|dun
argument_list|)
expr_stmt|;
name|VREF
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|dun
operator|->
name|un_flags
operator||=
name|UN_KLOCK
expr_stmt|;
name|vput
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
name|FIXUP
argument_list|(
name|un
argument_list|)
expr_stmt|;
name|VREF
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|un
operator|->
name|un_flags
operator||=
name|UN_KLOCK
expr_stmt|;
name|vput
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_RMDIR
argument_list|(
name|dvp
argument_list|,
name|vp
argument_list|,
name|ap
operator|->
name|a_cnp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|union_removed_upper
argument_list|(
name|un
argument_list|)
expr_stmt|;
comment|/* 		 * XXX: should create a whiteout here 		 */
block|}
else|else
block|{
comment|/* 		 * XXX: should create a whiteout here 		 */
name|vput
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|error
operator|=
name|EROFS
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|union_symlink
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_symlink_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode **a_vpp; 		struct componentname *a_cnp; 		struct vattr *a_vap; 		char *a_target; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|un
operator|->
name|un_uppervp
decl_stmt|;
if|if
condition|(
name|dvp
condition|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|FIXUP
argument_list|(
name|un
argument_list|)
expr_stmt|;
name|VREF
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|un
operator|->
name|un_flags
operator||=
name|UN_KLOCK
expr_stmt|;
name|vput
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_SYMLINK
argument_list|(
name|dvp
argument_list|,
operator|&
name|vp
argument_list|,
name|ap
operator|->
name|a_cnp
argument_list|,
name|ap
operator|->
name|a_vap
argument_list|,
name|ap
operator|->
name|a_target
argument_list|)
expr_stmt|;
operator|*
name|ap
operator|->
name|a_vpp
operator|=
name|NULLVP
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|vput
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EROFS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * union_readdir works in concert with getdirentries and  * readdir(3) to provide a list of entries in the unioned  * directories.  getdirentries is responsible for walking  * down the union stack.  readdir(3) is responsible for  * eliminating duplicate names from the returned data stream.  */
end_comment

begin_function
name|int
name|union_readdir
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_readdir_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		struct ucred *a_cred; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
if|if
condition|(
name|un
operator|->
name|un_uppervp
condition|)
block|{
name|FIXUP
argument_list|(
name|un
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_READDIR
argument_list|(
name|un
operator|->
name|un_uppervp
argument_list|,
name|ap
operator|->
name|a_uio
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|union_readlink
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_readlink_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		struct ucred *a_cred; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|OTHERVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|int
name|dolock
init|=
operator|(
name|vp
operator|==
name|LOWERVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|dolock
condition|)
name|VOP_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
else|else
name|FIXUP
argument_list|(
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_READLINK
argument_list|(
name|vp
argument_list|,
name|ap
operator|->
name|a_uio
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|dolock
condition|)
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|union_abortop
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_abortop_args
comment|/* { 		struct vnode *a_dvp; 		struct componentname *a_cnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|OTHERVP
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
decl_stmt|;
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
decl_stmt|;
name|int
name|islocked
init|=
name|un
operator|->
name|un_flags
operator|&
name|UN_LOCKED
decl_stmt|;
name|int
name|dolock
init|=
operator|(
name|vp
operator|==
name|LOWERVP
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|islocked
condition|)
block|{
if|if
condition|(
name|dolock
condition|)
name|VOP_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
else|else
name|FIXUP
argument_list|(
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|VOP_ABORTOP
argument_list|(
name|vp
argument_list|,
name|ap
operator|->
name|a_cnp
argument_list|)
expr_stmt|;
if|if
condition|(
name|islocked
operator|&&
name|dolock
condition|)
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|union_inactive
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_inactive_args
comment|/* { 		struct vnode *a_vp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
comment|/* 	 * Do nothing (and _don't_ bypass). 	 * Wait to vrele lowervp until reclaim, 	 * so that until then our union_node is in the 	 * cache and reusable. 	 * 	 * NEEDSWORK: Someday, consider inactive'ing 	 * the lowervp and then trying to reactivate it 	 * with capabilities (v_id) 	 * like they do in the name lookup cache code. 	 * That's too much work for now. 	 */
ifdef|#
directive|ifdef
name|UNION_DIAGNOSTIC
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
if|if
condition|(
name|un
operator|->
name|un_flags
operator|&
name|UN_LOCKED
condition|)
name|panic
argument_list|(
literal|"union: inactivating locked node"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|union_reclaim
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_reclaim_args
comment|/* { 		struct vnode *a_vp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|union_freevp
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|union_lock
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_lock_args
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|union_node
modifier|*
name|un
decl_stmt|;
name|start
label|:
while|while
condition|(
name|vp
operator|->
name|v_flag
operator|&
name|VXLOCK
condition|)
block|{
name|vp
operator|->
name|v_flag
operator||=
name|VXWANT
expr_stmt|;
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|vp
argument_list|,
name|PINOD
argument_list|,
literal|"unnlk1"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|un
operator|=
name|VTOUNION
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|un
operator|->
name|un_uppervp
condition|)
block|{
if|if
condition|(
operator|(
name|un
operator|->
name|un_flags
operator|&
name|UN_ULOCK
operator|)
operator|==
literal|0
condition|)
block|{
name|un
operator|->
name|un_flags
operator||=
name|UN_ULOCK
expr_stmt|;
name|VOP_LOCK
argument_list|(
name|un
operator|->
name|un_uppervp
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|un
operator|->
name|un_flags
operator|&
name|UN_KLOCK
condition|)
name|panic
argument_list|(
literal|"union: dangling upper lock"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|un
operator|->
name|un_flags
operator|&
name|UN_LOCKED
condition|)
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|curproc
operator|&&
name|un
operator|->
name|un_pid
operator|==
name|curproc
operator|->
name|p_pid
operator|&&
name|un
operator|->
name|un_pid
operator|>
operator|-
literal|1
operator|&&
name|curproc
operator|->
name|p_pid
operator|>
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"union: locking against myself"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|un
operator|->
name|un_flags
operator||=
name|UN_WANT
expr_stmt|;
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|un
operator|->
name|un_flags
argument_list|,
name|PINOD
argument_list|,
literal|"unnlk2"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|start
goto|;
block|}
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|curproc
condition|)
name|un
operator|->
name|un_pid
operator|=
name|curproc
operator|->
name|p_pid
expr_stmt|;
else|else
name|un
operator|->
name|un_pid
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
name|un
operator|->
name|un_flags
operator||=
name|UN_LOCKED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|union_unlock
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_lock_args
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|(
name|un
operator|->
name|un_flags
operator|&
name|UN_LOCKED
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"union: unlock unlocked node"
argument_list|)
expr_stmt|;
if|if
condition|(
name|curproc
operator|&&
name|un
operator|->
name|un_pid
operator|!=
name|curproc
operator|->
name|p_pid
operator|&&
name|curproc
operator|->
name|p_pid
operator|>
operator|-
literal|1
operator|&&
name|un
operator|->
name|un_pid
operator|>
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"union: unlocking other process's union node"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|un
operator|->
name|un_flags
operator|&=
operator|~
name|UN_LOCKED
expr_stmt|;
if|if
condition|(
operator|(
name|un
operator|->
name|un_flags
operator|&
operator|(
name|UN_ULOCK
operator||
name|UN_KLOCK
operator|)
operator|)
operator|==
name|UN_ULOCK
condition|)
name|VOP_UNLOCK
argument_list|(
name|un
operator|->
name|un_uppervp
argument_list|)
expr_stmt|;
name|un
operator|->
name|un_flags
operator|&=
operator|~
operator|(
name|UN_ULOCK
operator||
name|UN_KLOCK
operator|)
expr_stmt|;
if|if
condition|(
name|un
operator|->
name|un_flags
operator|&
name|UN_WANT
condition|)
block|{
name|un
operator|->
name|un_flags
operator|&=
operator|~
name|UN_WANT
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|un
operator|->
name|un_flags
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|un
operator|->
name|un_pid
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|union_bmap
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_bmap_args
comment|/* { 		struct vnode *a_vp; 		daddr_t  a_bn; 		struct vnode **a_vpp; 		daddr_t *a_bnp; 		int *a_runp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|OTHERVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|int
name|dolock
init|=
operator|(
name|vp
operator|==
name|LOWERVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|dolock
condition|)
name|VOP_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
else|else
name|FIXUP
argument_list|(
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_BMAP
argument_list|(
name|vp
argument_list|,
name|ap
operator|->
name|a_bn
argument_list|,
name|ap
operator|->
name|a_vpp
argument_list|,
name|ap
operator|->
name|a_bnp
argument_list|,
name|ap
operator|->
name|a_runp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dolock
condition|)
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|union_print
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_print_args
comment|/* { 		struct vnode *a_vp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|printf
argument_list|(
literal|"\ttag VT_UNION, vp=%p, uppervp=%p, lowervp=%p\n"
argument_list|,
name|vp
argument_list|,
name|UPPERVP
argument_list|(
name|vp
argument_list|)
argument_list|,
name|LOWERVP
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|union_islocked
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_islocked_args
comment|/* { 		struct vnode *a_vp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
operator|->
name|un_flags
operator|&
name|UN_LOCKED
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|union_pathconf
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_pathconf_args
comment|/* { 		struct vnode *a_vp; 		int a_name; 		int *a_retval; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|OTHERVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|int
name|dolock
init|=
operator|(
name|vp
operator|==
name|LOWERVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|dolock
condition|)
name|VOP_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
else|else
name|FIXUP
argument_list|(
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_PATHCONF
argument_list|(
name|vp
argument_list|,
name|ap
operator|->
name|a_name
argument_list|,
name|ap
operator|->
name|a_retval
argument_list|)
expr_stmt|;
if|if
condition|(
name|dolock
condition|)
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|union_advlock
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_advlock_args
comment|/* { 		struct vnode *a_vp; 		caddr_t  a_id; 		int  a_op; 		struct flock *a_fl; 		int  a_flags; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
name|VOP_ADVLOCK
argument_list|(
name|OTHERVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_id
argument_list|,
name|ap
operator|->
name|a_op
argument_list|,
name|ap
operator|->
name|a_fl
argument_list|,
name|ap
operator|->
name|a_flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * XXX - vop_strategy must be hand coded because it has no  * vnode in its arguments.  * This goes away with a merged VM/buffer cache.  */
end_comment

begin_function
name|int
name|union_strategy
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_strategy_args
comment|/* { 		struct buf *a_bp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|buf
modifier|*
name|bp
init|=
name|ap
operator|->
name|a_bp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|vnode
modifier|*
name|savedvp
decl_stmt|;
name|savedvp
operator|=
name|bp
operator|->
name|b_vp
expr_stmt|;
name|bp
operator|->
name|b_vp
operator|=
name|OTHERVP
argument_list|(
name|bp
operator|->
name|b_vp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|bp
operator|->
name|b_vp
operator|==
name|NULLVP
condition|)
name|panic
argument_list|(
literal|"union_strategy: nil vp"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|bp
operator|->
name|b_vp
operator|==
name|LOWERVP
argument_list|(
name|savedvp
argument_list|)
operator|)
condition|)
name|panic
argument_list|(
literal|"union_strategy: writing to lowervp"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|VOP_STRATEGY
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_vp
operator|=
name|savedvp
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Global vfs data structures  */
end_comment

begin_function_decl
name|int
function_decl|(
modifier|*
modifier|*
name|union_vnodeop_p
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|vnodeopv_entry_desc
name|union_vnodeop_entries
index|[]
init|=
block|{
block|{
operator|&
name|vop_default_desc
block|,
name|vn_default_error
block|}
block|,
block|{
operator|&
name|vop_lookup_desc
block|,
name|union_lookup
block|}
block|,
comment|/* lookup */
block|{
operator|&
name|vop_create_desc
block|,
name|union_create
block|}
block|,
comment|/* create */
block|{
operator|&
name|vop_mknod_desc
block|,
name|union_mknod
block|}
block|,
comment|/* mknod */
block|{
operator|&
name|vop_open_desc
block|,
name|union_open
block|}
block|,
comment|/* open */
block|{
operator|&
name|vop_close_desc
block|,
name|union_close
block|}
block|,
comment|/* close */
block|{
operator|&
name|vop_access_desc
block|,
name|union_access
block|}
block|,
comment|/* access */
block|{
operator|&
name|vop_getattr_desc
block|,
name|union_getattr
block|}
block|,
comment|/* getattr */
block|{
operator|&
name|vop_setattr_desc
block|,
name|union_setattr
block|}
block|,
comment|/* setattr */
block|{
operator|&
name|vop_read_desc
block|,
name|union_read
block|}
block|,
comment|/* read */
block|{
operator|&
name|vop_write_desc
block|,
name|union_write
block|}
block|,
comment|/* write */
block|{
operator|&
name|vop_ioctl_desc
block|,
name|union_ioctl
block|}
block|,
comment|/* ioctl */
block|{
operator|&
name|vop_select_desc
block|,
name|union_select
block|}
block|,
comment|/* select */
block|{
operator|&
name|vop_mmap_desc
block|,
name|union_mmap
block|}
block|,
comment|/* mmap */
block|{
operator|&
name|vop_fsync_desc
block|,
name|union_fsync
block|}
block|,
comment|/* fsync */
block|{
operator|&
name|vop_seek_desc
block|,
name|union_seek
block|}
block|,
comment|/* seek */
block|{
operator|&
name|vop_remove_desc
block|,
name|union_remove
block|}
block|,
comment|/* remove */
block|{
operator|&
name|vop_link_desc
block|,
name|union_link
block|}
block|,
comment|/* link */
block|{
operator|&
name|vop_rename_desc
block|,
name|union_rename
block|}
block|,
comment|/* rename */
block|{
operator|&
name|vop_mkdir_desc
block|,
name|union_mkdir
block|}
block|,
comment|/* mkdir */
block|{
operator|&
name|vop_rmdir_desc
block|,
name|union_rmdir
block|}
block|,
comment|/* rmdir */
block|{
operator|&
name|vop_symlink_desc
block|,
name|union_symlink
block|}
block|,
comment|/* symlink */
block|{
operator|&
name|vop_readdir_desc
block|,
name|union_readdir
block|}
block|,
comment|/* readdir */
block|{
operator|&
name|vop_readlink_desc
block|,
name|union_readlink
block|}
block|,
comment|/* readlink */
block|{
operator|&
name|vop_abortop_desc
block|,
name|union_abortop
block|}
block|,
comment|/* abortop */
block|{
operator|&
name|vop_inactive_desc
block|,
name|union_inactive
block|}
block|,
comment|/* inactive */
block|{
operator|&
name|vop_reclaim_desc
block|,
name|union_reclaim
block|}
block|,
comment|/* reclaim */
block|{
operator|&
name|vop_lock_desc
block|,
name|union_lock
block|}
block|,
comment|/* lock */
block|{
operator|&
name|vop_unlock_desc
block|,
name|union_unlock
block|}
block|,
comment|/* unlock */
block|{
operator|&
name|vop_bmap_desc
block|,
name|union_bmap
block|}
block|,
comment|/* bmap */
block|{
operator|&
name|vop_strategy_desc
block|,
name|union_strategy
block|}
block|,
comment|/* strategy */
block|{
operator|&
name|vop_print_desc
block|,
name|union_print
block|}
block|,
comment|/* print */
block|{
operator|&
name|vop_islocked_desc
block|,
name|union_islocked
block|}
block|,
comment|/* islocked */
block|{
operator|&
name|vop_pathconf_desc
block|,
name|union_pathconf
block|}
block|,
comment|/* pathconf */
block|{
operator|&
name|vop_advlock_desc
block|,
name|union_advlock
block|}
block|,
comment|/* advlock */
ifdef|#
directive|ifdef
name|notdef
block|{
operator|&
name|vop_blkatoff_desc
block|,
name|union_blkatoff
block|}
block|,
comment|/* blkatoff */
block|{
operator|&
name|vop_valloc_desc
block|,
name|union_valloc
block|}
block|,
comment|/* valloc */
block|{
operator|&
name|vop_vfree_desc
block|,
name|union_vfree
block|}
block|,
comment|/* vfree */
block|{
operator|&
name|vop_truncate_desc
block|,
name|union_truncate
block|}
block|,
comment|/* truncate */
block|{
operator|&
name|vop_update_desc
block|,
name|union_update
block|}
block|,
comment|/* update */
block|{
operator|&
name|vop_bwrite_desc
block|,
name|union_bwrite
block|}
block|,
comment|/* bwrite */
endif|#
directive|endif
block|{
operator|(
expr|struct
name|vnodeop_desc
operator|*
operator|)
name|NULL
block|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vnodeopv_desc
name|union_vnodeop_opv_desc
init|=
block|{
operator|&
name|union_vnodeop_p
block|,
name|union_vnodeop_entries
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|VNODEOP_SET
argument_list|(
name|union_vnodeop_opv_desc
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

