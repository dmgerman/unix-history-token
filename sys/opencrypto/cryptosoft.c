begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$OpenBSD: cryptosoft.c,v 1.35 2002/04/26 08:43:50 deraadt Exp $	*/
end_comment

begin_comment
comment|/*-  * The author of this code is Angelos D. Keromytis (angelos@cis.upenn.edu)  * Copyright (c) 2002-2006 Sam Leffler, Errno Consulting  *  * This code was written by Angelos D. Keromytis in Athens, Greece, in  * February 2000. Network Security Technologies Inc. (NSTI) kindly  * supported the development of this code.  *  * Copyright (c) 2000, 2001 Angelos D. Keromytis  * Copyright (c) 2014 The FreeBSD Foundation  * All rights reserved.  *  * Portions of this software were developed by John-Mark Gurney  * under sponsorship of the FreeBSD Foundation and  * Rubicon Communications, LLC (Netgate).  *  * Permission to use, copy, and modify this software with or without fee  * is hereby granted, provided that this entire notice is included in  * all source code copies of any software which is or includes a copy or  * modification of this software.  *  * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTY. IN PARTICULAR, NONE OF THE AUTHORS MAKES ANY  * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE  * MERCHANTABILITY OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR  * PURPOSE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/random.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<crypto/blowfish/blowfish.h>
end_include

begin_include
include|#
directive|include
file|<crypto/sha1.h>
end_include

begin_include
include|#
directive|include
file|<opencrypto/rmd160.h>
end_include

begin_include
include|#
directive|include
file|<opencrypto/cast.h>
end_include

begin_include
include|#
directive|include
file|<opencrypto/skipjack.h>
end_include

begin_include
include|#
directive|include
file|<sys/md5.h>
end_include

begin_include
include|#
directive|include
file|<opencrypto/cryptodev.h>
end_include

begin_include
include|#
directive|include
file|<opencrypto/cryptosoft.h>
end_include

begin_include
include|#
directive|include
file|<opencrypto/xform.h>
end_include

begin_include
include|#
directive|include
file|<sys/kobj.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|"cryptodev_if.h"
end_include

begin_decl_stmt
specifier|static
name|int32_t
name|swcr_id
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|swcr_data
modifier|*
modifier|*
name|swcr_sessions
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|swcr_sesnum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Protects swcr_sessions pointer, not data. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|rwlock
name|swcr_sessions_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int8_t
name|hmac_ipad_buffer
index|[
name|HMAC_MAX_BLOCK_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int8_t
name|hmac_opad_buffer
index|[
name|HMAC_MAX_BLOCK_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|swcr_encdec
parameter_list|(
name|struct
name|cryptodesc
modifier|*
parameter_list|,
name|struct
name|swcr_data
modifier|*
parameter_list|,
name|caddr_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|swcr_authcompute
parameter_list|(
name|struct
name|cryptodesc
modifier|*
parameter_list|,
name|struct
name|swcr_data
modifier|*
parameter_list|,
name|caddr_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|swcr_authenc
parameter_list|(
name|struct
name|cryptop
modifier|*
name|crp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|swcr_compdec
parameter_list|(
name|struct
name|cryptodesc
modifier|*
parameter_list|,
name|struct
name|swcr_data
modifier|*
parameter_list|,
name|caddr_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|swcr_freesession
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int64_t
name|tid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|swcr_freesession_locked
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int64_t
name|tid
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Apply a symmetric encryption/decryption algorithm.  */
end_comment

begin_function
specifier|static
name|int
name|swcr_encdec
parameter_list|(
name|struct
name|cryptodesc
modifier|*
name|crd
parameter_list|,
name|struct
name|swcr_data
modifier|*
name|sw
parameter_list|,
name|caddr_t
name|buf
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|unsigned
name|char
name|iv
index|[
name|EALG_MAX_BLOCK_LEN
index|]
decl_stmt|,
name|blk
index|[
name|EALG_MAX_BLOCK_LEN
index|]
decl_stmt|,
modifier|*
name|idat
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ivp
decl_stmt|,
modifier|*
name|nivp
decl_stmt|,
name|iv2
index|[
name|EALG_MAX_BLOCK_LEN
index|]
decl_stmt|;
name|struct
name|enc_xform
modifier|*
name|exf
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|blks
decl_stmt|,
name|ind
decl_stmt|,
name|count
decl_stmt|,
name|ivlen
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|,
name|uiolcl
decl_stmt|;
name|struct
name|iovec
name|iovlcl
index|[
literal|4
index|]
decl_stmt|;
name|struct
name|iovec
modifier|*
name|iov
decl_stmt|;
name|int
name|iovcnt
decl_stmt|,
name|iovalloc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|exf
operator|=
name|sw
operator|->
name|sw_exf
expr_stmt|;
name|blks
operator|=
name|exf
operator|->
name|blocksize
expr_stmt|;
name|ivlen
operator|=
name|exf
operator|->
name|ivsize
expr_stmt|;
comment|/* Check for non-padded data */
if|if
condition|(
name|crd
operator|->
name|crd_len
operator|%
name|blks
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|crd
operator|->
name|crd_alg
operator|==
name|CRYPTO_AES_ICM
operator|&&
operator|(
name|crd
operator|->
name|crd_flags
operator|&
name|CRD_F_IV_EXPLICIT
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Initialize the IV */
if|if
condition|(
name|crd
operator|->
name|crd_flags
operator|&
name|CRD_F_ENCRYPT
condition|)
block|{
comment|/* IV explicitly provided ? */
if|if
condition|(
name|crd
operator|->
name|crd_flags
operator|&
name|CRD_F_IV_EXPLICIT
condition|)
name|bcopy
argument_list|(
name|crd
operator|->
name|crd_iv
argument_list|,
name|iv
argument_list|,
name|ivlen
argument_list|)
expr_stmt|;
else|else
name|arc4rand
argument_list|(
name|iv
argument_list|,
name|ivlen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Do we need to write the IV */
if|if
condition|(
operator|!
operator|(
name|crd
operator|->
name|crd_flags
operator|&
name|CRD_F_IV_PRESENT
operator|)
condition|)
name|crypto_copyback
argument_list|(
name|flags
argument_list|,
name|buf
argument_list|,
name|crd
operator|->
name|crd_inject
argument_list|,
name|ivlen
argument_list|,
name|iv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Decryption */
comment|/* IV explicitly provided ? */
if|if
condition|(
name|crd
operator|->
name|crd_flags
operator|&
name|CRD_F_IV_EXPLICIT
condition|)
name|bcopy
argument_list|(
name|crd
operator|->
name|crd_iv
argument_list|,
name|iv
argument_list|,
name|ivlen
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Get IV off buf */
name|crypto_copydata
argument_list|(
name|flags
argument_list|,
name|buf
argument_list|,
name|crd
operator|->
name|crd_inject
argument_list|,
name|ivlen
argument_list|,
name|iv
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|crd
operator|->
name|crd_flags
operator|&
name|CRD_F_KEY_EXPLICIT
condition|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|sw
operator|->
name|sw_kschedule
condition|)
name|exf
operator|->
name|zerokey
argument_list|(
operator|&
operator|(
name|sw
operator|->
name|sw_kschedule
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|exf
operator|->
name|setkey
argument_list|(
operator|&
name|sw
operator|->
name|sw_kschedule
argument_list|,
name|crd
operator|->
name|crd_key
argument_list|,
name|crd
operator|->
name|crd_klen
operator|/
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|iov
operator|=
name|iovlcl
expr_stmt|;
name|iovcnt
operator|=
name|nitems
argument_list|(
name|iovlcl
argument_list|)
expr_stmt|;
name|iovalloc
operator|=
literal|0
expr_stmt|;
name|uio
operator|=
operator|&
name|uiolcl
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|CRYPTO_F_IMBUF
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|crypto_mbuftoiov
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|buf
argument_list|,
operator|&
name|iov
argument_list|,
operator|&
name|iovcnt
argument_list|,
operator|&
name|iovalloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|uio
operator|->
name|uio_iov
operator|=
name|iov
expr_stmt|;
name|uio
operator|->
name|uio_iovcnt
operator|=
name|iovcnt
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|CRYPTO_F_IOV
operator|)
operator|!=
literal|0
condition|)
name|uio
operator|=
operator|(
expr|struct
name|uio
operator|*
operator|)
name|buf
expr_stmt|;
else|else
block|{
name|iov
index|[
literal|0
index|]
operator|.
name|iov_base
operator|=
name|buf
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
name|crd
operator|->
name|crd_skip
operator|+
name|crd
operator|->
name|crd_len
expr_stmt|;
name|uio
operator|->
name|uio_iov
operator|=
name|iov
expr_stmt|;
name|uio
operator|->
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
block|}
name|ivp
operator|=
name|iv
expr_stmt|;
if|if
condition|(
name|exf
operator|->
name|reinit
condition|)
block|{
comment|/* 		 * xforms that provide a reinit method perform all IV 		 * handling themselves. 		 */
name|exf
operator|->
name|reinit
argument_list|(
name|sw
operator|->
name|sw_kschedule
argument_list|,
name|iv
argument_list|)
expr_stmt|;
block|}
name|count
operator|=
name|crd
operator|->
name|crd_skip
expr_stmt|;
name|ind
operator|=
name|cuio_getptr
argument_list|(
name|uio
argument_list|,
name|count
argument_list|,
operator|&
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|ind
operator|==
operator|-
literal|1
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|i
operator|=
name|crd
operator|->
name|crd_len
expr_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
condition|)
block|{
comment|/* 		 * If there's insufficient data at the end of 		 * an iovec, we have to do some copying. 		 */
if|if
condition|(
name|uio
operator|->
name|uio_iov
index|[
name|ind
index|]
operator|.
name|iov_len
operator|<
name|k
operator|+
name|blks
operator|&&
name|uio
operator|->
name|uio_iov
index|[
name|ind
index|]
operator|.
name|iov_len
operator|!=
name|k
condition|)
block|{
name|cuio_copydata
argument_list|(
name|uio
argument_list|,
name|count
argument_list|,
name|blks
argument_list|,
name|blk
argument_list|)
expr_stmt|;
comment|/* Actual encryption/decryption */
if|if
condition|(
name|exf
operator|->
name|reinit
condition|)
block|{
if|if
condition|(
name|crd
operator|->
name|crd_flags
operator|&
name|CRD_F_ENCRYPT
condition|)
block|{
name|exf
operator|->
name|encrypt
argument_list|(
name|sw
operator|->
name|sw_kschedule
argument_list|,
name|blk
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|exf
operator|->
name|decrypt
argument_list|(
name|sw
operator|->
name|sw_kschedule
argument_list|,
name|blk
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|crd
operator|->
name|crd_flags
operator|&
name|CRD_F_ENCRYPT
condition|)
block|{
comment|/* XOR with previous block */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|blks
condition|;
name|j
operator|++
control|)
name|blk
index|[
name|j
index|]
operator|^=
name|ivp
index|[
name|j
index|]
expr_stmt|;
name|exf
operator|->
name|encrypt
argument_list|(
name|sw
operator|->
name|sw_kschedule
argument_list|,
name|blk
argument_list|)
expr_stmt|;
comment|/* 				 * Keep encrypted block for XOR'ing 				 * with next block 				 */
name|bcopy
argument_list|(
name|blk
argument_list|,
name|iv
argument_list|,
name|blks
argument_list|)
expr_stmt|;
name|ivp
operator|=
name|iv
expr_stmt|;
block|}
else|else
block|{
comment|/* decrypt */
comment|/*	 				 * Keep encrypted block for XOR'ing 				 * with next block 				 */
name|nivp
operator|=
operator|(
name|ivp
operator|==
name|iv
operator|)
condition|?
name|iv2
else|:
name|iv
expr_stmt|;
name|bcopy
argument_list|(
name|blk
argument_list|,
name|nivp
argument_list|,
name|blks
argument_list|)
expr_stmt|;
name|exf
operator|->
name|decrypt
argument_list|(
name|sw
operator|->
name|sw_kschedule
argument_list|,
name|blk
argument_list|)
expr_stmt|;
comment|/* XOR with previous block */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|blks
condition|;
name|j
operator|++
control|)
name|blk
index|[
name|j
index|]
operator|^=
name|ivp
index|[
name|j
index|]
expr_stmt|;
name|ivp
operator|=
name|nivp
expr_stmt|;
block|}
comment|/* Copy back decrypted block */
name|cuio_copyback
argument_list|(
name|uio
argument_list|,
name|count
argument_list|,
name|blks
argument_list|,
name|blk
argument_list|)
expr_stmt|;
name|count
operator|+=
name|blks
expr_stmt|;
comment|/* Advance pointer */
name|ind
operator|=
name|cuio_getptr
argument_list|(
name|uio
argument_list|,
name|count
argument_list|,
operator|&
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|ind
operator|==
operator|-
literal|1
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|i
operator|-=
name|blks
expr_stmt|;
comment|/* Could be done... */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* 		 * Warning: idat may point to garbage here, but 		 * we only use it in the while() loop, only if 		 * there are indeed enough data. 		 */
name|idat
operator|=
operator|(
name|char
operator|*
operator|)
name|uio
operator|->
name|uio_iov
index|[
name|ind
index|]
operator|.
name|iov_base
operator|+
name|k
expr_stmt|;
while|while
condition|(
name|uio
operator|->
name|uio_iov
index|[
name|ind
index|]
operator|.
name|iov_len
operator|>=
name|k
operator|+
name|blks
operator|&&
name|i
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|exf
operator|->
name|reinit
condition|)
block|{
if|if
condition|(
name|crd
operator|->
name|crd_flags
operator|&
name|CRD_F_ENCRYPT
condition|)
block|{
name|exf
operator|->
name|encrypt
argument_list|(
name|sw
operator|->
name|sw_kschedule
argument_list|,
name|idat
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|exf
operator|->
name|decrypt
argument_list|(
name|sw
operator|->
name|sw_kschedule
argument_list|,
name|idat
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|crd
operator|->
name|crd_flags
operator|&
name|CRD_F_ENCRYPT
condition|)
block|{
comment|/* XOR with previous block/IV */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|blks
condition|;
name|j
operator|++
control|)
name|idat
index|[
name|j
index|]
operator|^=
name|ivp
index|[
name|j
index|]
expr_stmt|;
name|exf
operator|->
name|encrypt
argument_list|(
name|sw
operator|->
name|sw_kschedule
argument_list|,
name|idat
argument_list|)
expr_stmt|;
name|ivp
operator|=
name|idat
expr_stmt|;
block|}
else|else
block|{
comment|/* decrypt */
comment|/* 				 * Keep encrypted block to be used 				 * in next block's processing. 				 */
name|nivp
operator|=
operator|(
name|ivp
operator|==
name|iv
operator|)
condition|?
name|iv2
else|:
name|iv
expr_stmt|;
name|bcopy
argument_list|(
name|idat
argument_list|,
name|nivp
argument_list|,
name|blks
argument_list|)
expr_stmt|;
name|exf
operator|->
name|decrypt
argument_list|(
name|sw
operator|->
name|sw_kschedule
argument_list|,
name|idat
argument_list|)
expr_stmt|;
comment|/* XOR with previous block/IV */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|blks
condition|;
name|j
operator|++
control|)
name|idat
index|[
name|j
index|]
operator|^=
name|ivp
index|[
name|j
index|]
expr_stmt|;
name|ivp
operator|=
name|nivp
expr_stmt|;
block|}
name|idat
operator|+=
name|blks
expr_stmt|;
name|count
operator|+=
name|blks
expr_stmt|;
name|k
operator|+=
name|blks
expr_stmt|;
name|i
operator|-=
name|blks
expr_stmt|;
block|}
comment|/* 		 * Advance to the next iov if the end of the current iov 		 * is aligned with the end of a cipher block. 		 * Note that the code is equivalent to calling: 		 *      ind = cuio_getptr(uio, count,&k); 		 */
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|k
operator|==
name|uio
operator|->
name|uio_iov
index|[
name|ind
index|]
operator|.
name|iov_len
condition|)
block|{
name|k
operator|=
literal|0
expr_stmt|;
name|ind
operator|++
expr_stmt|;
if|if
condition|(
name|ind
operator|>=
name|uio
operator|->
name|uio_iovcnt
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
block|}
name|out
label|:
if|if
condition|(
name|iovalloc
condition|)
name|free
argument_list|(
name|iov
argument_list|,
name|M_CRYPTO_DATA
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|swcr_authprepare
parameter_list|(
name|struct
name|auth_hash
modifier|*
name|axf
parameter_list|,
name|struct
name|swcr_data
modifier|*
name|sw
parameter_list|,
name|u_char
modifier|*
name|key
parameter_list|,
name|int
name|klen
parameter_list|)
block|{
name|int
name|k
decl_stmt|;
name|klen
operator|/=
literal|8
expr_stmt|;
switch|switch
condition|(
name|axf
operator|->
name|type
condition|)
block|{
case|case
name|CRYPTO_MD5_HMAC
case|:
case|case
name|CRYPTO_SHA1_HMAC
case|:
case|case
name|CRYPTO_SHA2_256_HMAC
case|:
case|case
name|CRYPTO_SHA2_384_HMAC
case|:
case|case
name|CRYPTO_SHA2_512_HMAC
case|:
case|case
name|CRYPTO_NULL_HMAC
case|:
case|case
name|CRYPTO_RIPEMD160_HMAC
case|:
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|klen
condition|;
name|k
operator|++
control|)
name|key
index|[
name|k
index|]
operator|^=
name|HMAC_IPAD_VAL
expr_stmt|;
name|axf
operator|->
name|Init
argument_list|(
name|sw
operator|->
name|sw_ictx
argument_list|)
expr_stmt|;
name|axf
operator|->
name|Update
argument_list|(
name|sw
operator|->
name|sw_ictx
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
expr_stmt|;
name|axf
operator|->
name|Update
argument_list|(
name|sw
operator|->
name|sw_ictx
argument_list|,
name|hmac_ipad_buffer
argument_list|,
name|axf
operator|->
name|blocksize
operator|-
name|klen
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|klen
condition|;
name|k
operator|++
control|)
name|key
index|[
name|k
index|]
operator|^=
operator|(
name|HMAC_IPAD_VAL
operator|^
name|HMAC_OPAD_VAL
operator|)
expr_stmt|;
name|axf
operator|->
name|Init
argument_list|(
name|sw
operator|->
name|sw_octx
argument_list|)
expr_stmt|;
name|axf
operator|->
name|Update
argument_list|(
name|sw
operator|->
name|sw_octx
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
expr_stmt|;
name|axf
operator|->
name|Update
argument_list|(
name|sw
operator|->
name|sw_octx
argument_list|,
name|hmac_opad_buffer
argument_list|,
name|axf
operator|->
name|blocksize
operator|-
name|klen
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|klen
condition|;
name|k
operator|++
control|)
name|key
index|[
name|k
index|]
operator|^=
name|HMAC_OPAD_VAL
expr_stmt|;
break|break;
case|case
name|CRYPTO_MD5_KPDK
case|:
case|case
name|CRYPTO_SHA1_KPDK
case|:
block|{
comment|/*  		 * We need a buffer that can hold an md5 and a sha1 result 		 * just to throw it away. 		 * What we do here is the initial part of: 		 *   ALGO( key, keyfill, .. ) 		 * adding the key to sw_ictx and abusing Final() to get the 		 * "keyfill" padding. 		 * In addition we abuse the sw_octx to save the key to have 		 * it to be able to append it at the end in swcr_authcompute(). 		 */
name|u_char
name|buf
index|[
name|SHA1_RESULTLEN
index|]
decl_stmt|;
name|sw
operator|->
name|sw_klen
operator|=
name|klen
expr_stmt|;
name|bcopy
argument_list|(
name|key
argument_list|,
name|sw
operator|->
name|sw_octx
argument_list|,
name|klen
argument_list|)
expr_stmt|;
name|axf
operator|->
name|Init
argument_list|(
name|sw
operator|->
name|sw_ictx
argument_list|)
expr_stmt|;
name|axf
operator|->
name|Update
argument_list|(
name|sw
operator|->
name|sw_ictx
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
expr_stmt|;
name|axf
operator|->
name|Final
argument_list|(
name|buf
argument_list|,
name|sw
operator|->
name|sw_ictx
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|printf
argument_list|(
literal|"%s: CRD_F_KEY_EXPLICIT flag given, but algorithm %d "
literal|"doesn't use keys.\n"
argument_list|,
name|__func__
argument_list|,
name|axf
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Compute keyed-hash authenticator.  */
end_comment

begin_function
specifier|static
name|int
name|swcr_authcompute
parameter_list|(
name|struct
name|cryptodesc
modifier|*
name|crd
parameter_list|,
name|struct
name|swcr_data
modifier|*
name|sw
parameter_list|,
name|caddr_t
name|buf
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|unsigned
name|char
name|aalg
index|[
name|HASH_MAX_LEN
index|]
decl_stmt|;
name|struct
name|auth_hash
modifier|*
name|axf
decl_stmt|;
name|union
name|authctx
name|ctx
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|sw
operator|->
name|sw_ictx
operator|==
literal|0
condition|)
return|return
name|EINVAL
return|;
name|axf
operator|=
name|sw
operator|->
name|sw_axf
expr_stmt|;
if|if
condition|(
name|crd
operator|->
name|crd_flags
operator|&
name|CRD_F_KEY_EXPLICIT
condition|)
name|swcr_authprepare
argument_list|(
name|axf
argument_list|,
name|sw
argument_list|,
name|crd
operator|->
name|crd_key
argument_list|,
name|crd
operator|->
name|crd_klen
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|sw
operator|->
name|sw_ictx
argument_list|,
operator|&
name|ctx
argument_list|,
name|axf
operator|->
name|ctxsize
argument_list|)
expr_stmt|;
name|err
operator|=
name|crypto_apply
argument_list|(
name|flags
argument_list|,
name|buf
argument_list|,
name|crd
operator|->
name|crd_skip
argument_list|,
name|crd
operator|->
name|crd_len
argument_list|,
operator|(
name|int
argument_list|(
argument|*
argument_list|)
operator|(
name|void
operator|*
operator|,
name|void
operator|*
operator|,
name|unsigned
name|int
operator|)
operator|)
name|axf
operator|->
name|Update
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
switch|switch
condition|(
name|sw
operator|->
name|sw_alg
condition|)
block|{
case|case
name|CRYPTO_MD5_HMAC
case|:
case|case
name|CRYPTO_SHA1_HMAC
case|:
case|case
name|CRYPTO_SHA2_256_HMAC
case|:
case|case
name|CRYPTO_SHA2_384_HMAC
case|:
case|case
name|CRYPTO_SHA2_512_HMAC
case|:
case|case
name|CRYPTO_RIPEMD160_HMAC
case|:
if|if
condition|(
name|sw
operator|->
name|sw_octx
operator|==
name|NULL
condition|)
return|return
name|EINVAL
return|;
name|axf
operator|->
name|Final
argument_list|(
name|aalg
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|sw
operator|->
name|sw_octx
argument_list|,
operator|&
name|ctx
argument_list|,
name|axf
operator|->
name|ctxsize
argument_list|)
expr_stmt|;
name|axf
operator|->
name|Update
argument_list|(
operator|&
name|ctx
argument_list|,
name|aalg
argument_list|,
name|axf
operator|->
name|hashsize
argument_list|)
expr_stmt|;
name|axf
operator|->
name|Final
argument_list|(
name|aalg
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
break|break;
case|case
name|CRYPTO_MD5_KPDK
case|:
case|case
name|CRYPTO_SHA1_KPDK
case|:
comment|/* If we have no key saved, return error. */
if|if
condition|(
name|sw
operator|->
name|sw_octx
operator|==
name|NULL
condition|)
return|return
name|EINVAL
return|;
comment|/* 		 * Add the trailing copy of the key (see comment in 		 * swcr_authprepare()) after the data: 		 *   ALGO( .., key, algofill ) 		 * and let Final() do the proper, natural "algofill" 		 * padding. 		 */
name|axf
operator|->
name|Update
argument_list|(
operator|&
name|ctx
argument_list|,
name|sw
operator|->
name|sw_octx
argument_list|,
name|sw
operator|->
name|sw_klen
argument_list|)
expr_stmt|;
name|axf
operator|->
name|Final
argument_list|(
name|aalg
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
break|break;
case|case
name|CRYPTO_NULL_HMAC
case|:
name|axf
operator|->
name|Final
argument_list|(
name|aalg
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Inject the authentication data */
name|crypto_copyback
argument_list|(
name|flags
argument_list|,
name|buf
argument_list|,
name|crd
operator|->
name|crd_inject
argument_list|,
name|sw
operator|->
name|sw_mlen
operator|==
literal|0
condition|?
name|axf
operator|->
name|hashsize
else|:
name|sw
operator|->
name|sw_mlen
argument_list|,
name|aalg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
name|CTASSERT
argument_list|(
name|INT_MAX
operator|<=
operator|(
literal|1ll
operator|<<
literal|39
operator|)
operator|-
literal|256
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* GCM: plain text< 2^39-256 */
end_comment

begin_expr_stmt
name|CTASSERT
argument_list|(
name|INT_MAX
operator|<=
operator|(
name|uint64_t
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* GCM: associated data<= 2^64-1 */
end_comment

begin_comment
comment|/*  * Apply a combined encryption-authentication transformation  */
end_comment

begin_function
specifier|static
name|int
name|swcr_authenc
parameter_list|(
name|struct
name|cryptop
modifier|*
name|crp
parameter_list|)
block|{
name|uint32_t
name|blkbuf
index|[
name|howmany
argument_list|(
name|EALG_MAX_BLOCK_LEN
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
index|]
decl_stmt|;
name|u_char
modifier|*
name|blk
init|=
operator|(
name|u_char
operator|*
operator|)
name|blkbuf
decl_stmt|;
name|u_char
name|aalg
index|[
name|AALG_MAX_RESULT_LEN
index|]
decl_stmt|;
name|u_char
name|uaalg
index|[
name|AALG_MAX_RESULT_LEN
index|]
decl_stmt|;
name|u_char
name|iv
index|[
name|EALG_MAX_BLOCK_LEN
index|]
decl_stmt|;
name|union
name|authctx
name|ctx
decl_stmt|;
name|struct
name|cryptodesc
modifier|*
name|crd
decl_stmt|,
modifier|*
name|crda
init|=
name|NULL
decl_stmt|,
modifier|*
name|crde
init|=
name|NULL
decl_stmt|;
name|struct
name|swcr_data
modifier|*
name|sw
decl_stmt|,
modifier|*
name|swa
decl_stmt|,
modifier|*
name|swe
init|=
name|NULL
decl_stmt|;
name|struct
name|auth_hash
modifier|*
name|axf
init|=
name|NULL
decl_stmt|;
name|struct
name|enc_xform
modifier|*
name|exf
init|=
name|NULL
decl_stmt|;
name|caddr_t
name|buf
init|=
operator|(
name|caddr_t
operator|)
name|crp
operator|->
name|crp_buf
decl_stmt|;
name|uint32_t
modifier|*
name|blkp
decl_stmt|;
name|int
name|aadlen
decl_stmt|,
name|blksz
decl_stmt|,
name|i
decl_stmt|,
name|ivlen
decl_stmt|,
name|len
decl_stmt|,
name|iskip
decl_stmt|,
name|oskip
decl_stmt|,
name|r
decl_stmt|;
name|ivlen
operator|=
name|blksz
operator|=
name|iskip
operator|=
name|oskip
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|crd
operator|=
name|crp
operator|->
name|crp_desc
init|;
name|crd
condition|;
name|crd
operator|=
name|crd
operator|->
name|crd_next
control|)
block|{
for|for
control|(
name|sw
operator|=
name|swcr_sessions
index|[
name|crp
operator|->
name|crp_sid
operator|&
literal|0xffffffff
index|]
init|;
name|sw
operator|&&
name|sw
operator|->
name|sw_alg
operator|!=
name|crd
operator|->
name|crd_alg
condition|;
name|sw
operator|=
name|sw
operator|->
name|sw_next
control|)
empty_stmt|;
if|if
condition|(
name|sw
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
switch|switch
condition|(
name|sw
operator|->
name|sw_alg
condition|)
block|{
case|case
name|CRYPTO_AES_NIST_GCM_16
case|:
case|case
name|CRYPTO_AES_NIST_GMAC
case|:
name|swe
operator|=
name|sw
expr_stmt|;
name|crde
operator|=
name|crd
expr_stmt|;
name|exf
operator|=
name|swe
operator|->
name|sw_exf
expr_stmt|;
name|ivlen
operator|=
literal|12
expr_stmt|;
break|break;
case|case
name|CRYPTO_AES_128_NIST_GMAC
case|:
case|case
name|CRYPTO_AES_192_NIST_GMAC
case|:
case|case
name|CRYPTO_AES_256_NIST_GMAC
case|:
name|swa
operator|=
name|sw
expr_stmt|;
name|crda
operator|=
name|crd
expr_stmt|;
name|axf
operator|=
name|swa
operator|->
name|sw_axf
expr_stmt|;
if|if
condition|(
name|swa
operator|->
name|sw_ictx
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|bcopy
argument_list|(
name|swa
operator|->
name|sw_ictx
argument_list|,
operator|&
name|ctx
argument_list|,
name|axf
operator|->
name|ctxsize
argument_list|)
expr_stmt|;
name|blksz
operator|=
name|axf
operator|->
name|blocksize
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
if|if
condition|(
name|crde
operator|==
name|NULL
operator|||
name|crda
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|crde
operator|->
name|crd_alg
operator|==
name|CRYPTO_AES_NIST_GCM_16
operator|&&
operator|(
name|crde
operator|->
name|crd_flags
operator|&
name|CRD_F_IV_EXPLICIT
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|crde
operator|->
name|crd_klen
operator|!=
name|crda
operator|->
name|crd_klen
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Initialize the IV */
if|if
condition|(
name|crde
operator|->
name|crd_flags
operator|&
name|CRD_F_ENCRYPT
condition|)
block|{
comment|/* IV explicitly provided ? */
if|if
condition|(
name|crde
operator|->
name|crd_flags
operator|&
name|CRD_F_IV_EXPLICIT
condition|)
name|bcopy
argument_list|(
name|crde
operator|->
name|crd_iv
argument_list|,
name|iv
argument_list|,
name|ivlen
argument_list|)
expr_stmt|;
else|else
name|arc4rand
argument_list|(
name|iv
argument_list|,
name|ivlen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Do we need to write the IV */
if|if
condition|(
operator|!
operator|(
name|crde
operator|->
name|crd_flags
operator|&
name|CRD_F_IV_PRESENT
operator|)
condition|)
name|crypto_copyback
argument_list|(
name|crp
operator|->
name|crp_flags
argument_list|,
name|buf
argument_list|,
name|crde
operator|->
name|crd_inject
argument_list|,
name|ivlen
argument_list|,
name|iv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Decryption */
comment|/* IV explicitly provided ? */
if|if
condition|(
name|crde
operator|->
name|crd_flags
operator|&
name|CRD_F_IV_EXPLICIT
condition|)
name|bcopy
argument_list|(
name|crde
operator|->
name|crd_iv
argument_list|,
name|iv
argument_list|,
name|ivlen
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Get IV off buf */
name|crypto_copydata
argument_list|(
name|crp
operator|->
name|crp_flags
argument_list|,
name|buf
argument_list|,
name|crde
operator|->
name|crd_inject
argument_list|,
name|ivlen
argument_list|,
name|iv
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Supply MAC with IV */
if|if
condition|(
name|axf
operator|->
name|Reinit
condition|)
name|axf
operator|->
name|Reinit
argument_list|(
operator|&
name|ctx
argument_list|,
name|iv
argument_list|,
name|ivlen
argument_list|)
expr_stmt|;
comment|/* Supply MAC with AAD */
name|aadlen
operator|=
name|crda
operator|->
name|crd_len
expr_stmt|;
for|for
control|(
name|i
operator|=
name|iskip
init|;
name|i
operator|<
name|crda
operator|->
name|crd_len
condition|;
name|i
operator|+=
name|blksz
control|)
block|{
name|len
operator|=
name|MIN
argument_list|(
name|crda
operator|->
name|crd_len
operator|-
name|i
argument_list|,
name|blksz
operator|-
name|oskip
argument_list|)
expr_stmt|;
name|crypto_copydata
argument_list|(
name|crp
operator|->
name|crp_flags
argument_list|,
name|buf
argument_list|,
name|crda
operator|->
name|crd_skip
operator|+
name|i
argument_list|,
name|len
argument_list|,
name|blk
operator|+
name|oskip
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|blk
operator|+
name|len
operator|+
name|oskip
argument_list|,
name|blksz
operator|-
name|len
operator|-
name|oskip
argument_list|)
expr_stmt|;
name|axf
operator|->
name|Update
argument_list|(
operator|&
name|ctx
argument_list|,
name|blk
argument_list|,
name|blksz
argument_list|)
expr_stmt|;
name|oskip
operator|=
literal|0
expr_stmt|;
comment|/* reset initial output offset */
block|}
if|if
condition|(
name|exf
operator|->
name|reinit
condition|)
name|exf
operator|->
name|reinit
argument_list|(
name|swe
operator|->
name|sw_kschedule
argument_list|,
name|iv
argument_list|)
expr_stmt|;
comment|/* Do encryption/decryption with MAC */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|crde
operator|->
name|crd_len
condition|;
name|i
operator|+=
name|blksz
control|)
block|{
name|len
operator|=
name|MIN
argument_list|(
name|crde
operator|->
name|crd_len
operator|-
name|i
argument_list|,
name|blksz
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|blksz
condition|)
name|bzero
argument_list|(
name|blk
argument_list|,
name|blksz
argument_list|)
expr_stmt|;
name|crypto_copydata
argument_list|(
name|crp
operator|->
name|crp_flags
argument_list|,
name|buf
argument_list|,
name|crde
operator|->
name|crd_skip
operator|+
name|i
argument_list|,
name|len
argument_list|,
name|blk
argument_list|)
expr_stmt|;
if|if
condition|(
name|crde
operator|->
name|crd_flags
operator|&
name|CRD_F_ENCRYPT
condition|)
block|{
name|exf
operator|->
name|encrypt
argument_list|(
name|swe
operator|->
name|sw_kschedule
argument_list|,
name|blk
argument_list|)
expr_stmt|;
name|axf
operator|->
name|Update
argument_list|(
operator|&
name|ctx
argument_list|,
name|blk
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|crypto_copyback
argument_list|(
name|crp
operator|->
name|crp_flags
argument_list|,
name|buf
argument_list|,
name|crde
operator|->
name|crd_skip
operator|+
name|i
argument_list|,
name|len
argument_list|,
name|blk
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|axf
operator|->
name|Update
argument_list|(
operator|&
name|ctx
argument_list|,
name|blk
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Do any required special finalization */
switch|switch
condition|(
name|crda
operator|->
name|crd_alg
condition|)
block|{
case|case
name|CRYPTO_AES_128_NIST_GMAC
case|:
case|case
name|CRYPTO_AES_192_NIST_GMAC
case|:
case|case
name|CRYPTO_AES_256_NIST_GMAC
case|:
comment|/* length block */
name|bzero
argument_list|(
name|blk
argument_list|,
name|blksz
argument_list|)
expr_stmt|;
name|blkp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|blk
operator|+
literal|1
expr_stmt|;
operator|*
name|blkp
operator|=
name|htobe32
argument_list|(
name|aadlen
operator|*
literal|8
argument_list|)
expr_stmt|;
name|blkp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|blk
operator|+
literal|3
expr_stmt|;
operator|*
name|blkp
operator|=
name|htobe32
argument_list|(
name|crde
operator|->
name|crd_len
operator|*
literal|8
argument_list|)
expr_stmt|;
name|axf
operator|->
name|Update
argument_list|(
operator|&
name|ctx
argument_list|,
name|blk
argument_list|,
name|blksz
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Finalize MAC */
name|axf
operator|->
name|Final
argument_list|(
name|aalg
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
comment|/* Validate tag */
if|if
condition|(
operator|!
operator|(
name|crde
operator|->
name|crd_flags
operator|&
name|CRD_F_ENCRYPT
operator|)
condition|)
block|{
name|crypto_copydata
argument_list|(
name|crp
operator|->
name|crp_flags
argument_list|,
name|buf
argument_list|,
name|crda
operator|->
name|crd_inject
argument_list|,
name|axf
operator|->
name|hashsize
argument_list|,
name|uaalg
argument_list|)
expr_stmt|;
name|r
operator|=
name|timingsafe_bcmp
argument_list|(
name|aalg
argument_list|,
name|uaalg
argument_list|,
name|axf
operator|->
name|hashsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
comment|/* tag matches, decrypt data */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|crde
operator|->
name|crd_len
condition|;
name|i
operator|+=
name|blksz
control|)
block|{
name|len
operator|=
name|MIN
argument_list|(
name|crde
operator|->
name|crd_len
operator|-
name|i
argument_list|,
name|blksz
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|blksz
condition|)
name|bzero
argument_list|(
name|blk
argument_list|,
name|blksz
argument_list|)
expr_stmt|;
name|crypto_copydata
argument_list|(
name|crp
operator|->
name|crp_flags
argument_list|,
name|buf
argument_list|,
name|crde
operator|->
name|crd_skip
operator|+
name|i
argument_list|,
name|len
argument_list|,
name|blk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|crde
operator|->
name|crd_flags
operator|&
name|CRD_F_ENCRYPT
operator|)
condition|)
block|{
name|exf
operator|->
name|decrypt
argument_list|(
name|swe
operator|->
name|sw_kschedule
argument_list|,
name|blk
argument_list|)
expr_stmt|;
block|}
name|crypto_copyback
argument_list|(
name|crp
operator|->
name|crp_flags
argument_list|,
name|buf
argument_list|,
name|crde
operator|->
name|crd_skip
operator|+
name|i
argument_list|,
name|len
argument_list|,
name|blk
argument_list|)
expr_stmt|;
block|}
block|}
else|else
return|return
operator|(
name|EBADMSG
operator|)
return|;
block|}
else|else
block|{
comment|/* Inject the authentication data */
name|crypto_copyback
argument_list|(
name|crp
operator|->
name|crp_flags
argument_list|,
name|buf
argument_list|,
name|crda
operator|->
name|crd_inject
argument_list|,
name|axf
operator|->
name|hashsize
argument_list|,
name|aalg
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Apply a compression/decompression algorithm  */
end_comment

begin_function
specifier|static
name|int
name|swcr_compdec
parameter_list|(
name|struct
name|cryptodesc
modifier|*
name|crd
parameter_list|,
name|struct
name|swcr_data
modifier|*
name|sw
parameter_list|,
name|caddr_t
name|buf
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|u_int8_t
modifier|*
name|data
decl_stmt|,
modifier|*
name|out
decl_stmt|;
name|struct
name|comp_algo
modifier|*
name|cxf
decl_stmt|;
name|int
name|adj
decl_stmt|;
name|u_int32_t
name|result
decl_stmt|;
name|cxf
operator|=
name|sw
operator|->
name|sw_cxf
expr_stmt|;
comment|/* We must handle the whole buffer of data in one time 	 * then if there is not all the data in the mbuf, we must 	 * copy in a buffer. 	 */
name|data
operator|=
name|malloc
argument_list|(
name|crd
operator|->
name|crd_len
argument_list|,
name|M_CRYPTO_DATA
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|crypto_copydata
argument_list|(
name|flags
argument_list|,
name|buf
argument_list|,
name|crd
operator|->
name|crd_skip
argument_list|,
name|crd
operator|->
name|crd_len
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|crd
operator|->
name|crd_flags
operator|&
name|CRD_F_COMP
condition|)
name|result
operator|=
name|cxf
operator|->
name|compress
argument_list|(
name|data
argument_list|,
name|crd
operator|->
name|crd_len
argument_list|,
operator|&
name|out
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|cxf
operator|->
name|decompress
argument_list|(
name|data
argument_list|,
name|crd
operator|->
name|crd_len
argument_list|,
operator|&
name|out
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|,
name|M_CRYPTO_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
return|return
name|EINVAL
return|;
comment|/* Copy back the (de)compressed data. m_copyback is 	 * extending the mbuf as necessary. 	 */
name|sw
operator|->
name|sw_size
operator|=
name|result
expr_stmt|;
comment|/* Check the compressed size when doing compression */
if|if
condition|(
name|crd
operator|->
name|crd_flags
operator|&
name|CRD_F_COMP
condition|)
block|{
if|if
condition|(
name|result
operator|>=
name|crd
operator|->
name|crd_len
condition|)
block|{
comment|/* Compression was useless, we lost time */
name|free
argument_list|(
name|out
argument_list|,
name|M_CRYPTO_DATA
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|crypto_copyback
argument_list|(
name|flags
argument_list|,
name|buf
argument_list|,
name|crd
operator|->
name|crd_skip
argument_list|,
name|result
argument_list|,
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|<
name|crd
operator|->
name|crd_len
condition|)
block|{
name|adj
operator|=
name|result
operator|-
name|crd
operator|->
name|crd_len
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|CRYPTO_F_IMBUF
condition|)
block|{
name|adj
operator|=
name|result
operator|-
name|crd
operator|->
name|crd_len
expr_stmt|;
name|m_adj
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|buf
argument_list|,
name|adj
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|CRYPTO_F_IOV
condition|)
block|{
name|struct
name|uio
modifier|*
name|uio
init|=
operator|(
expr|struct
name|uio
operator|*
operator|)
name|buf
decl_stmt|;
name|int
name|ind
decl_stmt|;
name|adj
operator|=
name|crd
operator|->
name|crd_len
operator|-
name|result
expr_stmt|;
name|ind
operator|=
name|uio
operator|->
name|uio_iovcnt
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|adj
operator|>
literal|0
operator|&&
name|ind
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|adj
operator|<
name|uio
operator|->
name|uio_iov
index|[
name|ind
index|]
operator|.
name|iov_len
condition|)
block|{
name|uio
operator|->
name|uio_iov
index|[
name|ind
index|]
operator|.
name|iov_len
operator|-=
name|adj
expr_stmt|;
break|break;
block|}
name|adj
operator|-=
name|uio
operator|->
name|uio_iov
index|[
name|ind
index|]
operator|.
name|iov_len
expr_stmt|;
name|uio
operator|->
name|uio_iov
index|[
name|ind
index|]
operator|.
name|iov_len
operator|=
literal|0
expr_stmt|;
name|ind
operator|--
expr_stmt|;
name|uio
operator|->
name|uio_iovcnt
operator|--
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
name|out
argument_list|,
name|M_CRYPTO_DATA
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Generate a new software session.  */
end_comment

begin_function
specifier|static
name|int
name|swcr_newsession
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int32_t
modifier|*
name|sid
parameter_list|,
name|struct
name|cryptoini
modifier|*
name|cri
parameter_list|)
block|{
name|struct
name|swcr_data
modifier|*
modifier|*
name|swd
decl_stmt|;
name|struct
name|auth_hash
modifier|*
name|axf
decl_stmt|;
name|struct
name|enc_xform
modifier|*
name|txf
decl_stmt|;
name|struct
name|comp_algo
modifier|*
name|cxf
decl_stmt|;
name|u_int32_t
name|i
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|sid
operator|==
name|NULL
operator|||
name|cri
operator|==
name|NULL
condition|)
return|return
name|EINVAL
return|;
name|rw_wlock
argument_list|(
operator|&
name|swcr_sessions_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|swcr_sessions
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|swcr_sesnum
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|swcr_sessions
index|[
name|i
index|]
operator|==
name|NULL
condition|)
break|break;
block|}
else|else
name|i
operator|=
literal|1
expr_stmt|;
comment|/* NB: to silence compiler warning */
if|if
condition|(
name|swcr_sessions
operator|==
name|NULL
operator|||
name|i
operator|==
name|swcr_sesnum
condition|)
block|{
if|if
condition|(
name|swcr_sessions
operator|==
name|NULL
condition|)
block|{
name|i
operator|=
literal|1
expr_stmt|;
comment|/* We leave swcr_sessions[0] empty */
name|swcr_sesnum
operator|=
name|CRYPTO_SW_SESSIONS
expr_stmt|;
block|}
else|else
name|swcr_sesnum
operator|*=
literal|2
expr_stmt|;
name|swd
operator|=
name|malloc
argument_list|(
name|swcr_sesnum
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|swcr_data
operator|*
argument_list|)
argument_list|,
name|M_CRYPTO_DATA
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|swd
operator|==
name|NULL
condition|)
block|{
comment|/* Reset session number */
if|if
condition|(
name|swcr_sesnum
operator|==
name|CRYPTO_SW_SESSIONS
condition|)
name|swcr_sesnum
operator|=
literal|0
expr_stmt|;
else|else
name|swcr_sesnum
operator|/=
literal|2
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|swcr_sessions_lock
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
comment|/* Copy existing sessions */
if|if
condition|(
name|swcr_sessions
operator|!=
name|NULL
condition|)
block|{
name|bcopy
argument_list|(
name|swcr_sessions
argument_list|,
name|swd
argument_list|,
operator|(
name|swcr_sesnum
operator|/
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|swcr_data
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|swcr_sessions
argument_list|,
name|M_CRYPTO_DATA
argument_list|)
expr_stmt|;
block|}
name|swcr_sessions
operator|=
name|swd
expr_stmt|;
block|}
name|rw_downgrade
argument_list|(
operator|&
name|swcr_sessions_lock
argument_list|)
expr_stmt|;
name|swd
operator|=
operator|&
name|swcr_sessions
index|[
name|i
index|]
expr_stmt|;
operator|*
name|sid
operator|=
name|i
expr_stmt|;
while|while
condition|(
name|cri
condition|)
block|{
operator|*
name|swd
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|swcr_data
argument_list|)
argument_list|,
name|M_CRYPTO_DATA
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|swd
operator|==
name|NULL
condition|)
block|{
name|swcr_freesession_locked
argument_list|(
name|dev
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rw_runlock
argument_list|(
operator|&
name|swcr_sessions_lock
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
switch|switch
condition|(
name|cri
operator|->
name|cri_alg
condition|)
block|{
case|case
name|CRYPTO_DES_CBC
case|:
name|txf
operator|=
operator|&
name|enc_xform_des
expr_stmt|;
goto|goto
name|enccommon
goto|;
case|case
name|CRYPTO_3DES_CBC
case|:
name|txf
operator|=
operator|&
name|enc_xform_3des
expr_stmt|;
goto|goto
name|enccommon
goto|;
case|case
name|CRYPTO_BLF_CBC
case|:
name|txf
operator|=
operator|&
name|enc_xform_blf
expr_stmt|;
goto|goto
name|enccommon
goto|;
case|case
name|CRYPTO_CAST_CBC
case|:
name|txf
operator|=
operator|&
name|enc_xform_cast5
expr_stmt|;
goto|goto
name|enccommon
goto|;
case|case
name|CRYPTO_SKIPJACK_CBC
case|:
name|txf
operator|=
operator|&
name|enc_xform_skipjack
expr_stmt|;
goto|goto
name|enccommon
goto|;
case|case
name|CRYPTO_RIJNDAEL128_CBC
case|:
name|txf
operator|=
operator|&
name|enc_xform_rijndael128
expr_stmt|;
goto|goto
name|enccommon
goto|;
case|case
name|CRYPTO_AES_XTS
case|:
name|txf
operator|=
operator|&
name|enc_xform_aes_xts
expr_stmt|;
goto|goto
name|enccommon
goto|;
case|case
name|CRYPTO_AES_ICM
case|:
name|txf
operator|=
operator|&
name|enc_xform_aes_icm
expr_stmt|;
goto|goto
name|enccommon
goto|;
case|case
name|CRYPTO_AES_NIST_GCM_16
case|:
name|txf
operator|=
operator|&
name|enc_xform_aes_nist_gcm
expr_stmt|;
goto|goto
name|enccommon
goto|;
case|case
name|CRYPTO_AES_NIST_GMAC
case|:
name|txf
operator|=
operator|&
name|enc_xform_aes_nist_gmac
expr_stmt|;
operator|(
operator|*
name|swd
operator|)
operator|->
name|sw_exf
operator|=
name|txf
expr_stmt|;
break|break;
case|case
name|CRYPTO_CAMELLIA_CBC
case|:
name|txf
operator|=
operator|&
name|enc_xform_camellia
expr_stmt|;
goto|goto
name|enccommon
goto|;
case|case
name|CRYPTO_NULL_CBC
case|:
name|txf
operator|=
operator|&
name|enc_xform_null
expr_stmt|;
goto|goto
name|enccommon
goto|;
name|enccommon
label|:
if|if
condition|(
name|cri
operator|->
name|cri_key
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|txf
operator|->
name|setkey
argument_list|(
operator|&
operator|(
operator|(
operator|*
name|swd
operator|)
operator|->
name|sw_kschedule
operator|)
argument_list|,
name|cri
operator|->
name|cri_key
argument_list|,
name|cri
operator|->
name|cri_klen
operator|/
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|swcr_freesession_locked
argument_list|(
name|dev
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rw_runlock
argument_list|(
operator|&
name|swcr_sessions_lock
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
operator|(
operator|*
name|swd
operator|)
operator|->
name|sw_exf
operator|=
name|txf
expr_stmt|;
break|break;
case|case
name|CRYPTO_MD5_HMAC
case|:
name|axf
operator|=
operator|&
name|auth_hash_hmac_md5
expr_stmt|;
goto|goto
name|authcommon
goto|;
case|case
name|CRYPTO_SHA1_HMAC
case|:
name|axf
operator|=
operator|&
name|auth_hash_hmac_sha1
expr_stmt|;
goto|goto
name|authcommon
goto|;
case|case
name|CRYPTO_SHA2_256_HMAC
case|:
name|axf
operator|=
operator|&
name|auth_hash_hmac_sha2_256
expr_stmt|;
goto|goto
name|authcommon
goto|;
case|case
name|CRYPTO_SHA2_384_HMAC
case|:
name|axf
operator|=
operator|&
name|auth_hash_hmac_sha2_384
expr_stmt|;
goto|goto
name|authcommon
goto|;
case|case
name|CRYPTO_SHA2_512_HMAC
case|:
name|axf
operator|=
operator|&
name|auth_hash_hmac_sha2_512
expr_stmt|;
goto|goto
name|authcommon
goto|;
case|case
name|CRYPTO_NULL_HMAC
case|:
name|axf
operator|=
operator|&
name|auth_hash_null
expr_stmt|;
goto|goto
name|authcommon
goto|;
case|case
name|CRYPTO_RIPEMD160_HMAC
case|:
name|axf
operator|=
operator|&
name|auth_hash_hmac_ripemd_160
expr_stmt|;
name|authcommon
label|:
operator|(
operator|*
name|swd
operator|)
operator|->
name|sw_ictx
operator|=
name|malloc
argument_list|(
name|axf
operator|->
name|ctxsize
argument_list|,
name|M_CRYPTO_DATA
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|swd
operator|)
operator|->
name|sw_ictx
operator|==
name|NULL
condition|)
block|{
name|swcr_freesession_locked
argument_list|(
name|dev
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rw_runlock
argument_list|(
operator|&
name|swcr_sessions_lock
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
operator|(
operator|*
name|swd
operator|)
operator|->
name|sw_octx
operator|=
name|malloc
argument_list|(
name|axf
operator|->
name|ctxsize
argument_list|,
name|M_CRYPTO_DATA
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|swd
operator|)
operator|->
name|sw_octx
operator|==
name|NULL
condition|)
block|{
name|swcr_freesession_locked
argument_list|(
name|dev
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rw_runlock
argument_list|(
operator|&
name|swcr_sessions_lock
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
if|if
condition|(
name|cri
operator|->
name|cri_key
operator|!=
name|NULL
condition|)
block|{
name|swcr_authprepare
argument_list|(
name|axf
argument_list|,
operator|*
name|swd
argument_list|,
name|cri
operator|->
name|cri_key
argument_list|,
name|cri
operator|->
name|cri_klen
argument_list|)
expr_stmt|;
block|}
operator|(
operator|*
name|swd
operator|)
operator|->
name|sw_mlen
operator|=
name|cri
operator|->
name|cri_mlen
expr_stmt|;
operator|(
operator|*
name|swd
operator|)
operator|->
name|sw_axf
operator|=
name|axf
expr_stmt|;
break|break;
case|case
name|CRYPTO_MD5_KPDK
case|:
name|axf
operator|=
operator|&
name|auth_hash_key_md5
expr_stmt|;
goto|goto
name|auth2common
goto|;
case|case
name|CRYPTO_SHA1_KPDK
case|:
name|axf
operator|=
operator|&
name|auth_hash_key_sha1
expr_stmt|;
name|auth2common
label|:
operator|(
operator|*
name|swd
operator|)
operator|->
name|sw_ictx
operator|=
name|malloc
argument_list|(
name|axf
operator|->
name|ctxsize
argument_list|,
name|M_CRYPTO_DATA
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|swd
operator|)
operator|->
name|sw_ictx
operator|==
name|NULL
condition|)
block|{
name|swcr_freesession_locked
argument_list|(
name|dev
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rw_runlock
argument_list|(
operator|&
name|swcr_sessions_lock
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
operator|(
operator|*
name|swd
operator|)
operator|->
name|sw_octx
operator|=
name|malloc
argument_list|(
name|cri
operator|->
name|cri_klen
operator|/
literal|8
argument_list|,
name|M_CRYPTO_DATA
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|swd
operator|)
operator|->
name|sw_octx
operator|==
name|NULL
condition|)
block|{
name|swcr_freesession_locked
argument_list|(
name|dev
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rw_runlock
argument_list|(
operator|&
name|swcr_sessions_lock
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
comment|/* Store the key so we can "append" it to the payload */
if|if
condition|(
name|cri
operator|->
name|cri_key
operator|!=
name|NULL
condition|)
block|{
name|swcr_authprepare
argument_list|(
name|axf
argument_list|,
operator|*
name|swd
argument_list|,
name|cri
operator|->
name|cri_key
argument_list|,
name|cri
operator|->
name|cri_klen
argument_list|)
expr_stmt|;
block|}
operator|(
operator|*
name|swd
operator|)
operator|->
name|sw_mlen
operator|=
name|cri
operator|->
name|cri_mlen
expr_stmt|;
operator|(
operator|*
name|swd
operator|)
operator|->
name|sw_axf
operator|=
name|axf
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|notdef
case|case
name|CRYPTO_MD5
case|:
name|axf
operator|=
operator|&
name|auth_hash_md5
expr_stmt|;
goto|goto
name|auth3common
goto|;
case|case
name|CRYPTO_SHA1
case|:
name|axf
operator|=
operator|&
name|auth_hash_sha1
expr_stmt|;
name|auth3common
label|:
operator|(
operator|*
name|swd
operator|)
operator|->
name|sw_ictx
operator|=
name|malloc
argument_list|(
name|axf
operator|->
name|ctxsize
argument_list|,
name|M_CRYPTO_DATA
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|swd
operator|)
operator|->
name|sw_ictx
operator|==
name|NULL
condition|)
block|{
name|swcr_freesession_locked
argument_list|(
name|dev
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rw_runlock
argument_list|(
operator|&
name|swcr_sessions_lock
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|axf
operator|->
name|Init
argument_list|(
operator|(
operator|*
name|swd
operator|)
operator|->
name|sw_ictx
argument_list|)
expr_stmt|;
operator|(
operator|*
name|swd
operator|)
operator|->
name|sw_mlen
operator|=
name|cri
operator|->
name|cri_mlen
expr_stmt|;
operator|(
operator|*
name|swd
operator|)
operator|->
name|sw_axf
operator|=
name|axf
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|CRYPTO_AES_128_NIST_GMAC
case|:
name|axf
operator|=
operator|&
name|auth_hash_nist_gmac_aes_128
expr_stmt|;
goto|goto
name|auth4common
goto|;
case|case
name|CRYPTO_AES_192_NIST_GMAC
case|:
name|axf
operator|=
operator|&
name|auth_hash_nist_gmac_aes_192
expr_stmt|;
goto|goto
name|auth4common
goto|;
case|case
name|CRYPTO_AES_256_NIST_GMAC
case|:
name|axf
operator|=
operator|&
name|auth_hash_nist_gmac_aes_256
expr_stmt|;
name|auth4common
label|:
name|len
operator|=
name|cri
operator|->
name|cri_klen
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|len
operator|!=
literal|16
operator|&&
name|len
operator|!=
literal|24
operator|&&
name|len
operator|!=
literal|32
condition|)
block|{
name|swcr_freesession_locked
argument_list|(
name|dev
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rw_runlock
argument_list|(
operator|&
name|swcr_sessions_lock
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
operator|(
operator|*
name|swd
operator|)
operator|->
name|sw_ictx
operator|=
name|malloc
argument_list|(
name|axf
operator|->
name|ctxsize
argument_list|,
name|M_CRYPTO_DATA
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|swd
operator|)
operator|->
name|sw_ictx
operator|==
name|NULL
condition|)
block|{
name|swcr_freesession_locked
argument_list|(
name|dev
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rw_runlock
argument_list|(
operator|&
name|swcr_sessions_lock
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|axf
operator|->
name|Init
argument_list|(
operator|(
operator|*
name|swd
operator|)
operator|->
name|sw_ictx
argument_list|)
expr_stmt|;
name|axf
operator|->
name|Setkey
argument_list|(
operator|(
operator|*
name|swd
operator|)
operator|->
name|sw_ictx
argument_list|,
name|cri
operator|->
name|cri_key
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
operator|*
name|swd
operator|)
operator|->
name|sw_axf
operator|=
name|axf
expr_stmt|;
break|break;
case|case
name|CRYPTO_DEFLATE_COMP
case|:
name|cxf
operator|=
operator|&
name|comp_algo_deflate
expr_stmt|;
operator|(
operator|*
name|swd
operator|)
operator|->
name|sw_cxf
operator|=
name|cxf
expr_stmt|;
break|break;
default|default:
name|swcr_freesession_locked
argument_list|(
name|dev
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rw_runlock
argument_list|(
operator|&
name|swcr_sessions_lock
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
operator|(
operator|*
name|swd
operator|)
operator|->
name|sw_alg
operator|=
name|cri
operator|->
name|cri_alg
expr_stmt|;
name|cri
operator|=
name|cri
operator|->
name|cri_next
expr_stmt|;
name|swd
operator|=
operator|&
operator|(
operator|(
operator|*
name|swd
operator|)
operator|->
name|sw_next
operator|)
expr_stmt|;
block|}
name|rw_runlock
argument_list|(
operator|&
name|swcr_sessions_lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|swcr_freesession
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int64_t
name|tid
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|rw_rlock
argument_list|(
operator|&
name|swcr_sessions_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|swcr_freesession_locked
argument_list|(
name|dev
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|rw_runlock
argument_list|(
operator|&
name|swcr_sessions_lock
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Free a session.  */
end_comment

begin_function
specifier|static
name|int
name|swcr_freesession_locked
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int64_t
name|tid
parameter_list|)
block|{
name|struct
name|swcr_data
modifier|*
name|swd
decl_stmt|;
name|struct
name|enc_xform
modifier|*
name|txf
decl_stmt|;
name|struct
name|auth_hash
modifier|*
name|axf
decl_stmt|;
name|struct
name|comp_algo
modifier|*
name|cxf
decl_stmt|;
name|u_int32_t
name|sid
init|=
name|CRYPTO_SESID2LID
argument_list|(
name|tid
argument_list|)
decl_stmt|;
if|if
condition|(
name|sid
operator|>
name|swcr_sesnum
operator|||
name|swcr_sessions
operator|==
name|NULL
operator|||
name|swcr_sessions
index|[
name|sid
index|]
operator|==
name|NULL
condition|)
return|return
name|EINVAL
return|;
comment|/* Silently accept and return */
if|if
condition|(
name|sid
operator|==
literal|0
condition|)
return|return
literal|0
return|;
while|while
condition|(
operator|(
name|swd
operator|=
name|swcr_sessions
index|[
name|sid
index|]
operator|)
operator|!=
name|NULL
condition|)
block|{
name|swcr_sessions
index|[
name|sid
index|]
operator|=
name|swd
operator|->
name|sw_next
expr_stmt|;
switch|switch
condition|(
name|swd
operator|->
name|sw_alg
condition|)
block|{
case|case
name|CRYPTO_DES_CBC
case|:
case|case
name|CRYPTO_3DES_CBC
case|:
case|case
name|CRYPTO_BLF_CBC
case|:
case|case
name|CRYPTO_CAST_CBC
case|:
case|case
name|CRYPTO_SKIPJACK_CBC
case|:
case|case
name|CRYPTO_RIJNDAEL128_CBC
case|:
case|case
name|CRYPTO_AES_XTS
case|:
case|case
name|CRYPTO_AES_ICM
case|:
case|case
name|CRYPTO_AES_NIST_GCM_16
case|:
case|case
name|CRYPTO_AES_NIST_GMAC
case|:
case|case
name|CRYPTO_CAMELLIA_CBC
case|:
case|case
name|CRYPTO_NULL_CBC
case|:
name|txf
operator|=
name|swd
operator|->
name|sw_exf
expr_stmt|;
if|if
condition|(
name|swd
operator|->
name|sw_kschedule
condition|)
name|txf
operator|->
name|zerokey
argument_list|(
operator|&
operator|(
name|swd
operator|->
name|sw_kschedule
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CRYPTO_MD5_HMAC
case|:
case|case
name|CRYPTO_SHA1_HMAC
case|:
case|case
name|CRYPTO_SHA2_256_HMAC
case|:
case|case
name|CRYPTO_SHA2_384_HMAC
case|:
case|case
name|CRYPTO_SHA2_512_HMAC
case|:
case|case
name|CRYPTO_RIPEMD160_HMAC
case|:
case|case
name|CRYPTO_NULL_HMAC
case|:
name|axf
operator|=
name|swd
operator|->
name|sw_axf
expr_stmt|;
if|if
condition|(
name|swd
operator|->
name|sw_ictx
condition|)
block|{
name|bzero
argument_list|(
name|swd
operator|->
name|sw_ictx
argument_list|,
name|axf
operator|->
name|ctxsize
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|swd
operator|->
name|sw_ictx
argument_list|,
name|M_CRYPTO_DATA
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|swd
operator|->
name|sw_octx
condition|)
block|{
name|bzero
argument_list|(
name|swd
operator|->
name|sw_octx
argument_list|,
name|axf
operator|->
name|ctxsize
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|swd
operator|->
name|sw_octx
argument_list|,
name|M_CRYPTO_DATA
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CRYPTO_MD5_KPDK
case|:
case|case
name|CRYPTO_SHA1_KPDK
case|:
name|axf
operator|=
name|swd
operator|->
name|sw_axf
expr_stmt|;
if|if
condition|(
name|swd
operator|->
name|sw_ictx
condition|)
block|{
name|bzero
argument_list|(
name|swd
operator|->
name|sw_ictx
argument_list|,
name|axf
operator|->
name|ctxsize
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|swd
operator|->
name|sw_ictx
argument_list|,
name|M_CRYPTO_DATA
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|swd
operator|->
name|sw_octx
condition|)
block|{
name|bzero
argument_list|(
name|swd
operator|->
name|sw_octx
argument_list|,
name|swd
operator|->
name|sw_klen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|swd
operator|->
name|sw_octx
argument_list|,
name|M_CRYPTO_DATA
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CRYPTO_MD5
case|:
case|case
name|CRYPTO_SHA1
case|:
name|axf
operator|=
name|swd
operator|->
name|sw_axf
expr_stmt|;
if|if
condition|(
name|swd
operator|->
name|sw_ictx
condition|)
name|free
argument_list|(
name|swd
operator|->
name|sw_ictx
argument_list|,
name|M_CRYPTO_DATA
argument_list|)
expr_stmt|;
break|break;
case|case
name|CRYPTO_DEFLATE_COMP
case|:
name|cxf
operator|=
name|swd
operator|->
name|sw_cxf
expr_stmt|;
break|break;
block|}
name|free
argument_list|(
name|swd
argument_list|,
name|M_CRYPTO_DATA
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Process a software request.  */
end_comment

begin_function
specifier|static
name|int
name|swcr_process
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|cryptop
modifier|*
name|crp
parameter_list|,
name|int
name|hint
parameter_list|)
block|{
name|struct
name|cryptodesc
modifier|*
name|crd
decl_stmt|;
name|struct
name|swcr_data
modifier|*
name|sw
decl_stmt|;
name|u_int32_t
name|lid
decl_stmt|;
comment|/* Sanity check */
if|if
condition|(
name|crp
operator|==
name|NULL
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|crp
operator|->
name|crp_desc
operator|==
name|NULL
operator|||
name|crp
operator|->
name|crp_buf
operator|==
name|NULL
condition|)
block|{
name|crp
operator|->
name|crp_etype
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|lid
operator|=
name|CRYPTO_SESID2LID
argument_list|(
name|crp
operator|->
name|crp_sid
argument_list|)
expr_stmt|;
name|rw_rlock
argument_list|(
operator|&
name|swcr_sessions_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|swcr_sessions
operator|==
name|NULL
operator|||
name|lid
operator|>=
name|swcr_sesnum
operator|||
name|lid
operator|==
literal|0
operator|||
name|swcr_sessions
index|[
name|lid
index|]
operator|==
name|NULL
condition|)
block|{
name|rw_runlock
argument_list|(
operator|&
name|swcr_sessions_lock
argument_list|)
expr_stmt|;
name|crp
operator|->
name|crp_etype
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|rw_runlock
argument_list|(
operator|&
name|swcr_sessions_lock
argument_list|)
expr_stmt|;
comment|/* Go through crypto descriptors, processing as we go */
for|for
control|(
name|crd
operator|=
name|crp
operator|->
name|crp_desc
init|;
name|crd
condition|;
name|crd
operator|=
name|crd
operator|->
name|crd_next
control|)
block|{
comment|/* 		 * Find the crypto context. 		 * 		 * XXX Note that the logic here prevents us from having 		 * XXX the same algorithm multiple times in a session 		 * XXX (or rather, we can but it won't give us the right 		 * XXX results). To do that, we'd need some way of differentiating 		 * XXX between the various instances of an algorithm (so we can 		 * XXX locate the correct crypto context). 		 */
name|rw_rlock
argument_list|(
operator|&
name|swcr_sessions_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|swcr_sessions
operator|==
name|NULL
condition|)
block|{
name|rw_runlock
argument_list|(
operator|&
name|swcr_sessions_lock
argument_list|)
expr_stmt|;
name|crp
operator|->
name|crp_etype
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
for|for
control|(
name|sw
operator|=
name|swcr_sessions
index|[
name|lid
index|]
init|;
name|sw
operator|&&
name|sw
operator|->
name|sw_alg
operator|!=
name|crd
operator|->
name|crd_alg
condition|;
name|sw
operator|=
name|sw
operator|->
name|sw_next
control|)
empty_stmt|;
name|rw_runlock
argument_list|(
operator|&
name|swcr_sessions_lock
argument_list|)
expr_stmt|;
comment|/* No such context ? */
if|if
condition|(
name|sw
operator|==
name|NULL
condition|)
block|{
name|crp
operator|->
name|crp_etype
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
switch|switch
condition|(
name|sw
operator|->
name|sw_alg
condition|)
block|{
case|case
name|CRYPTO_DES_CBC
case|:
case|case
name|CRYPTO_3DES_CBC
case|:
case|case
name|CRYPTO_BLF_CBC
case|:
case|case
name|CRYPTO_CAST_CBC
case|:
case|case
name|CRYPTO_SKIPJACK_CBC
case|:
case|case
name|CRYPTO_RIJNDAEL128_CBC
case|:
case|case
name|CRYPTO_AES_XTS
case|:
case|case
name|CRYPTO_AES_ICM
case|:
case|case
name|CRYPTO_CAMELLIA_CBC
case|:
if|if
condition|(
operator|(
name|crp
operator|->
name|crp_etype
operator|=
name|swcr_encdec
argument_list|(
name|crd
argument_list|,
name|sw
argument_list|,
name|crp
operator|->
name|crp_buf
argument_list|,
name|crp
operator|->
name|crp_flags
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
break|break;
case|case
name|CRYPTO_NULL_CBC
case|:
name|crp
operator|->
name|crp_etype
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CRYPTO_MD5_HMAC
case|:
case|case
name|CRYPTO_SHA1_HMAC
case|:
case|case
name|CRYPTO_SHA2_256_HMAC
case|:
case|case
name|CRYPTO_SHA2_384_HMAC
case|:
case|case
name|CRYPTO_SHA2_512_HMAC
case|:
case|case
name|CRYPTO_RIPEMD160_HMAC
case|:
case|case
name|CRYPTO_NULL_HMAC
case|:
case|case
name|CRYPTO_MD5_KPDK
case|:
case|case
name|CRYPTO_SHA1_KPDK
case|:
case|case
name|CRYPTO_MD5
case|:
case|case
name|CRYPTO_SHA1
case|:
if|if
condition|(
operator|(
name|crp
operator|->
name|crp_etype
operator|=
name|swcr_authcompute
argument_list|(
name|crd
argument_list|,
name|sw
argument_list|,
name|crp
operator|->
name|crp_buf
argument_list|,
name|crp
operator|->
name|crp_flags
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
break|break;
case|case
name|CRYPTO_AES_NIST_GCM_16
case|:
case|case
name|CRYPTO_AES_NIST_GMAC
case|:
case|case
name|CRYPTO_AES_128_NIST_GMAC
case|:
case|case
name|CRYPTO_AES_192_NIST_GMAC
case|:
case|case
name|CRYPTO_AES_256_NIST_GMAC
case|:
name|crp
operator|->
name|crp_etype
operator|=
name|swcr_authenc
argument_list|(
name|crp
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|CRYPTO_DEFLATE_COMP
case|:
if|if
condition|(
operator|(
name|crp
operator|->
name|crp_etype
operator|=
name|swcr_compdec
argument_list|(
name|crd
argument_list|,
name|sw
argument_list|,
name|crp
operator|->
name|crp_buf
argument_list|,
name|crp
operator|->
name|crp_flags
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
else|else
name|crp
operator|->
name|crp_olen
operator|=
operator|(
name|int
operator|)
name|sw
operator|->
name|sw_size
expr_stmt|;
break|break;
default|default:
comment|/* Unknown/unsupported algorithm */
name|crp
operator|->
name|crp_etype
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|done
label|:
name|crypto_done
argument_list|(
name|crp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|swcr_identify
parameter_list|(
name|driver_t
modifier|*
name|drv
parameter_list|,
name|device_t
name|parent
parameter_list|)
block|{
comment|/* NB: order 10 is so we get attached after h/w devices */
if|if
condition|(
name|device_find_child
argument_list|(
name|parent
argument_list|,
literal|"cryptosoft"
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
name|NULL
operator|&&
name|BUS_ADD_CHILD
argument_list|(
name|parent
argument_list|,
literal|10
argument_list|,
literal|"cryptosoft"
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"cryptosoft: could not attach"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|swcr_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"software crypto"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_NOWILDCARD
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|swcr_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|rw_init
argument_list|(
operator|&
name|swcr_sessions_lock
argument_list|,
literal|"swcr_sessions_lock"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|hmac_ipad_buffer
argument_list|,
name|HMAC_IPAD_VAL
argument_list|,
name|HMAC_MAX_BLOCK_LEN
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|hmac_opad_buffer
argument_list|,
name|HMAC_OPAD_VAL
argument_list|,
name|HMAC_MAX_BLOCK_LEN
argument_list|)
expr_stmt|;
name|swcr_id
operator|=
name|crypto_get_driverid
argument_list|(
name|dev
argument_list|,
name|CRYPTOCAP_F_SOFTWARE
operator||
name|CRYPTOCAP_F_SYNC
argument_list|)
expr_stmt|;
if|if
condition|(
name|swcr_id
operator|<
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot initialize!"
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
define|#
directive|define
name|REGISTER
parameter_list|(
name|alg
parameter_list|)
define|\
value|crypto_register(swcr_id, alg, 0,0)
name|REGISTER
argument_list|(
name|CRYPTO_DES_CBC
argument_list|)
expr_stmt|;
name|REGISTER
argument_list|(
name|CRYPTO_3DES_CBC
argument_list|)
expr_stmt|;
name|REGISTER
argument_list|(
name|CRYPTO_BLF_CBC
argument_list|)
expr_stmt|;
name|REGISTER
argument_list|(
name|CRYPTO_CAST_CBC
argument_list|)
expr_stmt|;
name|REGISTER
argument_list|(
name|CRYPTO_SKIPJACK_CBC
argument_list|)
expr_stmt|;
name|REGISTER
argument_list|(
name|CRYPTO_NULL_CBC
argument_list|)
expr_stmt|;
name|REGISTER
argument_list|(
name|CRYPTO_MD5_HMAC
argument_list|)
expr_stmt|;
name|REGISTER
argument_list|(
name|CRYPTO_SHA1_HMAC
argument_list|)
expr_stmt|;
name|REGISTER
argument_list|(
name|CRYPTO_SHA2_256_HMAC
argument_list|)
expr_stmt|;
name|REGISTER
argument_list|(
name|CRYPTO_SHA2_384_HMAC
argument_list|)
expr_stmt|;
name|REGISTER
argument_list|(
name|CRYPTO_SHA2_512_HMAC
argument_list|)
expr_stmt|;
name|REGISTER
argument_list|(
name|CRYPTO_RIPEMD160_HMAC
argument_list|)
expr_stmt|;
name|REGISTER
argument_list|(
name|CRYPTO_NULL_HMAC
argument_list|)
expr_stmt|;
name|REGISTER
argument_list|(
name|CRYPTO_MD5_KPDK
argument_list|)
expr_stmt|;
name|REGISTER
argument_list|(
name|CRYPTO_SHA1_KPDK
argument_list|)
expr_stmt|;
name|REGISTER
argument_list|(
name|CRYPTO_MD5
argument_list|)
expr_stmt|;
name|REGISTER
argument_list|(
name|CRYPTO_SHA1
argument_list|)
expr_stmt|;
name|REGISTER
argument_list|(
name|CRYPTO_RIJNDAEL128_CBC
argument_list|)
expr_stmt|;
name|REGISTER
argument_list|(
name|CRYPTO_AES_XTS
argument_list|)
expr_stmt|;
name|REGISTER
argument_list|(
name|CRYPTO_AES_ICM
argument_list|)
expr_stmt|;
name|REGISTER
argument_list|(
name|CRYPTO_AES_NIST_GCM_16
argument_list|)
expr_stmt|;
name|REGISTER
argument_list|(
name|CRYPTO_AES_NIST_GMAC
argument_list|)
expr_stmt|;
name|REGISTER
argument_list|(
name|CRYPTO_AES_128_NIST_GMAC
argument_list|)
expr_stmt|;
name|REGISTER
argument_list|(
name|CRYPTO_AES_192_NIST_GMAC
argument_list|)
expr_stmt|;
name|REGISTER
argument_list|(
name|CRYPTO_AES_256_NIST_GMAC
argument_list|)
expr_stmt|;
name|REGISTER
argument_list|(
name|CRYPTO_CAMELLIA_CBC
argument_list|)
expr_stmt|;
name|REGISTER
argument_list|(
name|CRYPTO_DEFLATE_COMP
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|REGISTER
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|swcr_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|crypto_unregister_all
argument_list|(
name|swcr_id
argument_list|)
expr_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|swcr_sessions_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|swcr_sessions
argument_list|,
name|M_CRYPTO_DATA
argument_list|)
expr_stmt|;
name|swcr_sessions
operator|=
name|NULL
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|swcr_sessions_lock
argument_list|)
expr_stmt|;
name|rw_destroy
argument_list|(
operator|&
name|swcr_sessions_lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|swcr_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_identify
argument_list|,
name|swcr_identify
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|swcr_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|swcr_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|swcr_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|cryptodev_newsession
argument_list|,
name|swcr_newsession
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|cryptodev_freesession
argument_list|,
name|swcr_freesession
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|cryptodev_process
argument_list|,
name|swcr_process
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|swcr_driver
init|=
block|{
literal|"cryptosoft"
block|,
name|swcr_methods
block|,
literal|0
block|,
comment|/* NB: no softc */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|swcr_devclass
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * NB: We explicitly reference the crypto module so we  * get the necessary ordering when built as a loadable  * module.  This is required because we bundle the crypto  * module code together with the cryptosoft driver (otherwise  * normal module dependencies would handle things).  */
end_comment

begin_function_decl
specifier|extern
name|int
name|crypto_modevent
parameter_list|(
name|struct
name|module
modifier|*
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* XXX where to attach */
end_comment

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|cryptosoft
argument_list|,
name|nexus
argument_list|,
name|swcr_driver
argument_list|,
name|swcr_devclass
argument_list|,
name|crypto_modevent
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|cryptosoft
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|cryptosoft
argument_list|,
name|crypto
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

