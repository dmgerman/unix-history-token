begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*********************************************************************** ** ** Implementation of the Skein block functions. ** ** Source code author: Doug Whiting, 2008. ** ** This algorithm and source code is released to the public domain. ** ** Compile-time switches: ** **  SKEIN_USE_ASM  -- set bits (256/512/1024) to select which **                    versions use ASM code for block processing **                    [default: use C for all block sizes] ** ************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"skein.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|SKEIN_USE_ASM
end_ifndef

begin_define
define|#
directive|define
name|SKEIN_USE_ASM
value|(0)
end_define

begin_comment
comment|/* default is all C code (no ASM) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SKEIN_LOOP
end_ifndef

begin_define
define|#
directive|define
name|SKEIN_LOOP
value|001
end_define

begin_comment
comment|/* default: unroll 256 and 512, but not 1024 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|BLK_BITS
value|(WCNT*64)
end_define

begin_comment
comment|/* some useful definitions for code here */
end_comment

begin_define
define|#
directive|define
name|KW_TWK_BASE
value|(0)
end_define

begin_define
define|#
directive|define
name|KW_KEY_BASE
value|(3)
end_define

begin_define
define|#
directive|define
name|ks
value|(kw + KW_KEY_BASE)
end_define

begin_define
define|#
directive|define
name|ts
value|(kw + KW_TWK_BASE)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|SKEIN_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|DebugSaveTweak
parameter_list|(
name|ctx
parameter_list|)
value|{ ctx->h.T[0] = ts[0]; ctx->h.T[1] = ts[1]; }
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DebugSaveTweak
parameter_list|(
name|ctx
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*****************************************************************/
end_comment

begin_comment
comment|/* functions to process blkCnt (nonzero) full block(s) of data. */
end_comment

begin_function_decl
name|void
name|Skein_256_Process_Block
parameter_list|(
name|Skein_256_Ctxt_t
modifier|*
name|ctx
parameter_list|,
specifier|const
name|u08b_t
modifier|*
name|blkPtr
parameter_list|,
name|size_t
name|blkCnt
parameter_list|,
name|size_t
name|byteCntAdd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|Skein_512_Process_Block
parameter_list|(
name|Skein_512_Ctxt_t
modifier|*
name|ctx
parameter_list|,
specifier|const
name|u08b_t
modifier|*
name|blkPtr
parameter_list|,
name|size_t
name|blkCnt
parameter_list|,
name|size_t
name|byteCntAdd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|Skein1024_Process_Block
parameter_list|(
name|Skein1024_Ctxt_t
modifier|*
name|ctx
parameter_list|,
specifier|const
name|u08b_t
modifier|*
name|blkPtr
parameter_list|,
name|size_t
name|blkCnt
parameter_list|,
name|size_t
name|byteCntAdd
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*****************************  Skein_256 ******************************/
end_comment

begin_if
if|#
directive|if
operator|!
operator|(
name|SKEIN_USE_ASM
operator|&
literal|256
operator|)
end_if

begin_function
name|void
name|Skein_256_Process_Block
parameter_list|(
name|Skein_256_Ctxt_t
modifier|*
name|ctx
parameter_list|,
specifier|const
name|u08b_t
modifier|*
name|blkPtr
parameter_list|,
name|size_t
name|blkCnt
parameter_list|,
name|size_t
name|byteCntAdd
parameter_list|)
block|{
comment|/* do it in C */
enum|enum
block|{
name|WCNT
init|=
name|SKEIN_256_STATE_WORDS
block|}
enum|;
undef|#
directive|undef
name|RCNT
define|#
directive|define
name|RCNT
value|(SKEIN_256_ROUNDS_TOTAL/8)
ifdef|#
directive|ifdef
name|SKEIN_LOOP
comment|/* configure how much to unroll the loop */
define|#
directive|define
name|SKEIN_UNROLL_256
value|(((SKEIN_LOOP)/100)%10)
else|#
directive|else
define|#
directive|define
name|SKEIN_UNROLL_256
value|(0)
endif|#
directive|endif
if|#
directive|if
name|SKEIN_UNROLL_256
if|#
directive|if
operator|(
name|RCNT
operator|%
name|SKEIN_UNROLL_256
operator|)
error|#
directive|error
literal|"Invalid SKEIN_UNROLL_256"
comment|/* sanity check on unroll count */
endif|#
directive|endif
name|size_t
name|r
decl_stmt|;
name|u64b_t
name|kw
index|[
name|WCNT
operator|+
literal|4
operator|+
name|RCNT
operator|*
literal|2
index|]
decl_stmt|;
comment|/* key schedule words : chaining vars + tweak + "rotation"*/
else|#
directive|else
name|u64b_t
name|kw
index|[
name|WCNT
operator|+
literal|4
index|]
decl_stmt|;
comment|/* key schedule words : chaining vars + tweak */
endif|#
directive|endif
name|u64b_t
name|X0
decl_stmt|,
name|X1
decl_stmt|,
name|X2
decl_stmt|,
name|X3
decl_stmt|;
comment|/* local copy of context vars, for speed */
name|u64b_t
name|w
index|[
name|WCNT
index|]
decl_stmt|;
comment|/* local copy of input block */
ifdef|#
directive|ifdef
name|SKEIN_DEBUG
specifier|const
name|u64b_t
modifier|*
name|Xptr
index|[
literal|4
index|]
decl_stmt|;
comment|/* use for debugging (help compiler put Xn in registers) */
name|Xptr
index|[
literal|0
index|]
operator|=
operator|&
name|X0
expr_stmt|;
name|Xptr
index|[
literal|1
index|]
operator|=
operator|&
name|X1
expr_stmt|;
name|Xptr
index|[
literal|2
index|]
operator|=
operator|&
name|X2
expr_stmt|;
name|Xptr
index|[
literal|3
index|]
operator|=
operator|&
name|X3
expr_stmt|;
endif|#
directive|endif
name|Skein_assert
argument_list|(
name|blkCnt
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* never call with blkCnt == 0! */
name|ts
index|[
literal|0
index|]
operator|=
name|ctx
operator|->
name|h
operator|.
name|T
index|[
literal|0
index|]
expr_stmt|;
name|ts
index|[
literal|1
index|]
operator|=
name|ctx
operator|->
name|h
operator|.
name|T
index|[
literal|1
index|]
expr_stmt|;
do|do
block|{
comment|/* this implementation only supports 2**64 input bytes (no carry out here) */
name|ts
index|[
literal|0
index|]
operator|+=
name|byteCntAdd
expr_stmt|;
comment|/* update processed length */
comment|/* precompute the key schedule for this block */
name|ks
index|[
literal|0
index|]
operator|=
name|ctx
operator|->
name|X
index|[
literal|0
index|]
expr_stmt|;
name|ks
index|[
literal|1
index|]
operator|=
name|ctx
operator|->
name|X
index|[
literal|1
index|]
expr_stmt|;
name|ks
index|[
literal|2
index|]
operator|=
name|ctx
operator|->
name|X
index|[
literal|2
index|]
expr_stmt|;
name|ks
index|[
literal|3
index|]
operator|=
name|ctx
operator|->
name|X
index|[
literal|3
index|]
expr_stmt|;
name|ks
index|[
literal|4
index|]
operator|=
name|ks
index|[
literal|0
index|]
operator|^
name|ks
index|[
literal|1
index|]
operator|^
name|ks
index|[
literal|2
index|]
operator|^
name|ks
index|[
literal|3
index|]
operator|^
name|SKEIN_KS_PARITY
expr_stmt|;
name|ts
index|[
literal|2
index|]
operator|=
name|ts
index|[
literal|0
index|]
operator|^
name|ts
index|[
literal|1
index|]
expr_stmt|;
name|Skein_Get64_LSB_First
argument_list|(
name|w
argument_list|,
name|blkPtr
argument_list|,
name|WCNT
argument_list|)
expr_stmt|;
comment|/* get input block in little-endian format */
name|DebugSaveTweak
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|Skein_Show_Block
argument_list|(
name|BLK_BITS
argument_list|,
operator|&
name|ctx
operator|->
name|h
argument_list|,
name|ctx
operator|->
name|X
argument_list|,
name|blkPtr
argument_list|,
name|w
argument_list|,
name|ks
argument_list|,
name|ts
argument_list|)
expr_stmt|;
name|X0
operator|=
name|w
index|[
literal|0
index|]
operator|+
name|ks
index|[
literal|0
index|]
expr_stmt|;
comment|/* do the first full key injection */
name|X1
operator|=
name|w
index|[
literal|1
index|]
operator|+
name|ks
index|[
literal|1
index|]
operator|+
name|ts
index|[
literal|0
index|]
expr_stmt|;
name|X2
operator|=
name|w
index|[
literal|2
index|]
operator|+
name|ks
index|[
literal|2
index|]
operator|+
name|ts
index|[
literal|1
index|]
expr_stmt|;
name|X3
operator|=
name|w
index|[
literal|3
index|]
operator|+
name|ks
index|[
literal|3
index|]
expr_stmt|;
name|Skein_Show_R_Ptr
argument_list|(
name|BLK_BITS
argument_list|,
operator|&
name|ctx
operator|->
name|h
argument_list|,
name|SKEIN_RND_KEY_INITIAL
argument_list|,
name|Xptr
argument_list|)
expr_stmt|;
comment|/* show starting state values */
name|blkPtr
operator|+=
name|SKEIN_256_BLOCK_BYTES
expr_stmt|;
comment|/* run the rounds */
define|#
directive|define
name|Round256
parameter_list|(
name|p0
parameter_list|,
name|p1
parameter_list|,
name|p2
parameter_list|,
name|p3
parameter_list|,
name|ROT
parameter_list|,
name|rNum
parameter_list|)
define|\
value|X##p0 += X##p1; X##p1 = RotL_64(X##p1,ROT##_0); X##p1 ^= X##p0; \     X##p2 += X##p3; X##p3 = RotL_64(X##p3,ROT##_1); X##p3 ^= X##p2; \  #if SKEIN_UNROLL_256 == 0
define|#
directive|define
name|R256
parameter_list|(
name|p0
parameter_list|,
name|p1
parameter_list|,
name|p2
parameter_list|,
name|p3
parameter_list|,
name|ROT
parameter_list|,
name|rNum
parameter_list|)
comment|/* fully unrolled */
define|\
value|Round256(p0,p1,p2,p3,ROT,rNum)                                  \     Skein_Show_R_Ptr(BLK_BITS,&ctx->h,rNum,Xptr);
define|#
directive|define
name|I256
parameter_list|(
name|R
parameter_list|)
define|\
value|X0   += ks[((R)+1) % 5];
comment|/* inject the key schedule value */
value|\     X1   += ks[((R)+2) % 5] + ts[((R)+1) % 3];                      \     X2   += ks[((R)+3) % 5] + ts[((R)+2) % 3];                      \     X3   += ks[((R)+4) % 5] +     (R)+1;                            \     Skein_Show_R_Ptr(BLK_BITS,&ctx->h,SKEIN_RND_KEY_INJECT,Xptr);
else|#
directive|else
comment|/* looping version */
define|#
directive|define
name|R256
parameter_list|(
name|p0
parameter_list|,
name|p1
parameter_list|,
name|p2
parameter_list|,
name|p3
parameter_list|,
name|ROT
parameter_list|,
name|rNum
parameter_list|)
define|\
value|Round256(p0,p1,p2,p3,ROT,rNum)                                  \     Skein_Show_R_Ptr(BLK_BITS,&ctx->h,4*(r-1)+rNum,Xptr);
define|#
directive|define
name|I256
parameter_list|(
name|R
parameter_list|)
define|\
value|X0   += ks[r+(R)+0];
comment|/* inject the key schedule value */
value|\     X1   += ks[r+(R)+1] + ts[r+(R)+0];                              \     X2   += ks[r+(R)+2] + ts[r+(R)+1];                              \     X3   += ks[r+(R)+3] +    r+(R)   ;                              \     ks[r + (R)+4    ]   = ks[r+(R)-1];
comment|/* rotate key schedule */
value|\     ts[r + (R)+2    ]   = ts[r+(R)-1];                              \     Skein_Show_R_Ptr(BLK_BITS,&ctx->h,SKEIN_RND_KEY_INJECT,Xptr);
for|for
control|(
name|r
operator|=
literal|1
init|;
name|r
operator|<
literal|2
operator|*
name|RCNT
condition|;
name|r
operator|+=
literal|2
operator|*
name|SKEIN_UNROLL_256
control|)
comment|/* loop thru it */
endif|#
directive|endif
block|{
define|#
directive|define
name|R256_8_rounds
parameter_list|(
name|R
parameter_list|)
define|\
value|R256(0,1,2,3,R_256_0,8*(R) + 1);  \         R256(0,3,2,1,R_256_1,8*(R) + 2);  \         R256(0,1,2,3,R_256_2,8*(R) + 3);  \         R256(0,3,2,1,R_256_3,8*(R) + 4);  \         I256(2*(R));                      \         R256(0,1,2,3,R_256_4,8*(R) + 5);  \         R256(0,3,2,1,R_256_5,8*(R) + 6);  \         R256(0,1,2,3,R_256_6,8*(R) + 7);  \         R256(0,3,2,1,R_256_7,8*(R) + 8);  \         I256(2*(R)+1);
name|R256_8_rounds
argument_list|(
literal|0
argument_list|)
expr_stmt|;
define|#
directive|define
name|R256_Unroll_R
parameter_list|(
name|NN
parameter_list|)
value|((SKEIN_UNROLL_256 == 0&& SKEIN_256_ROUNDS_TOTAL/8> (NN)) || (SKEIN_UNROLL_256> (NN)))
if|#
directive|if
name|R256_Unroll_R
argument_list|(
literal|1
argument_list|)
name|R256_8_rounds
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|R256_Unroll_R
argument_list|(
literal|2
argument_list|)
name|R256_8_rounds
argument_list|(
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|R256_Unroll_R
argument_list|(
literal|3
argument_list|)
name|R256_8_rounds
argument_list|(
literal|3
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|R256_Unroll_R
argument_list|(
literal|4
argument_list|)
name|R256_8_rounds
argument_list|(
literal|4
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|R256_Unroll_R
argument_list|(
literal|5
argument_list|)
name|R256_8_rounds
argument_list|(
literal|5
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|R256_Unroll_R
argument_list|(
literal|6
argument_list|)
name|R256_8_rounds
argument_list|(
literal|6
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|R256_Unroll_R
argument_list|(
literal|7
argument_list|)
name|R256_8_rounds
argument_list|(
literal|7
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|R256_Unroll_R
argument_list|(
literal|8
argument_list|)
name|R256_8_rounds
argument_list|(
literal|8
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|R256_Unroll_R
argument_list|(
literal|9
argument_list|)
name|R256_8_rounds
argument_list|(
literal|9
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|R256_Unroll_R
argument_list|(
literal|10
argument_list|)
name|R256_8_rounds
argument_list|(
literal|10
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|R256_Unroll_R
argument_list|(
literal|11
argument_list|)
name|R256_8_rounds
argument_list|(
literal|11
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|R256_Unroll_R
argument_list|(
literal|12
argument_list|)
name|R256_8_rounds
argument_list|(
literal|12
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|R256_Unroll_R
argument_list|(
literal|13
argument_list|)
name|R256_8_rounds
argument_list|(
literal|13
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|R256_Unroll_R
argument_list|(
literal|14
argument_list|)
name|R256_8_rounds
argument_list|(
literal|14
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|SKEIN_UNROLL_256
operator|>
literal|14
operator|)
error|#
directive|error
literal|"need more unrolling in Skein_256_Process_Block"
endif|#
directive|endif
block|}
comment|/* do the final "feedforward" xor, update context chaining vars */
name|ctx
operator|->
name|X
index|[
literal|0
index|]
operator|=
name|X0
operator|^
name|w
index|[
literal|0
index|]
expr_stmt|;
name|ctx
operator|->
name|X
index|[
literal|1
index|]
operator|=
name|X1
operator|^
name|w
index|[
literal|1
index|]
expr_stmt|;
name|ctx
operator|->
name|X
index|[
literal|2
index|]
operator|=
name|X2
operator|^
name|w
index|[
literal|2
index|]
expr_stmt|;
name|ctx
operator|->
name|X
index|[
literal|3
index|]
operator|=
name|X3
operator|^
name|w
index|[
literal|3
index|]
expr_stmt|;
name|Skein_Show_Round
argument_list|(
name|BLK_BITS
argument_list|,
operator|&
name|ctx
operator|->
name|h
argument_list|,
name|SKEIN_RND_FEED_FWD
argument_list|,
name|ctx
operator|->
name|X
argument_list|)
expr_stmt|;
name|ts
index|[
literal|1
index|]
operator|&=
operator|~
name|SKEIN_T1_FLAG_FIRST
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|blkCnt
condition|)
do|;
name|ctx
operator|->
name|h
operator|.
name|T
index|[
literal|0
index|]
operator|=
name|ts
index|[
literal|0
index|]
expr_stmt|;
name|ctx
operator|->
name|h
operator|.
name|T
index|[
literal|1
index|]
operator|=
name|ts
index|[
literal|1
index|]
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SKEIN_CODE_SIZE
argument_list|)
operator|||
name|defined
argument_list|(
name|SKEIN_PERF
argument_list|)
end_if

begin_function
name|size_t
name|Skein_256_Process_Block_CodeSize
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
operator|(
name|u08b_t
operator|*
operator|)
name|Skein_256_Process_Block_CodeSize
operator|)
operator|-
operator|(
operator|(
name|u08b_t
operator|*
operator|)
name|Skein_256_Process_Block
operator|)
return|;
block|}
end_function

begin_function
name|uint_t
name|Skein_256_Unroll_Cnt
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|SKEIN_UNROLL_256
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*****************************  Skein_512 ******************************/
end_comment

begin_if
if|#
directive|if
operator|!
operator|(
name|SKEIN_USE_ASM
operator|&
literal|512
operator|)
end_if

begin_function
name|void
name|Skein_512_Process_Block
parameter_list|(
name|Skein_512_Ctxt_t
modifier|*
name|ctx
parameter_list|,
specifier|const
name|u08b_t
modifier|*
name|blkPtr
parameter_list|,
name|size_t
name|blkCnt
parameter_list|,
name|size_t
name|byteCntAdd
parameter_list|)
block|{
comment|/* do it in C */
enum|enum
block|{
name|WCNT
init|=
name|SKEIN_512_STATE_WORDS
block|}
enum|;
undef|#
directive|undef
name|RCNT
define|#
directive|define
name|RCNT
value|(SKEIN_512_ROUNDS_TOTAL/8)
ifdef|#
directive|ifdef
name|SKEIN_LOOP
comment|/* configure how much to unroll the loop */
define|#
directive|define
name|SKEIN_UNROLL_512
value|(((SKEIN_LOOP)/10)%10)
else|#
directive|else
define|#
directive|define
name|SKEIN_UNROLL_512
value|(0)
endif|#
directive|endif
if|#
directive|if
name|SKEIN_UNROLL_512
if|#
directive|if
operator|(
name|RCNT
operator|%
name|SKEIN_UNROLL_512
operator|)
error|#
directive|error
literal|"Invalid SKEIN_UNROLL_512"
comment|/* sanity check on unroll count */
endif|#
directive|endif
name|size_t
name|r
decl_stmt|;
name|u64b_t
name|kw
index|[
name|WCNT
operator|+
literal|4
operator|+
name|RCNT
operator|*
literal|2
index|]
decl_stmt|;
comment|/* key schedule words : chaining vars + tweak + "rotation"*/
else|#
directive|else
name|u64b_t
name|kw
index|[
name|WCNT
operator|+
literal|4
index|]
decl_stmt|;
comment|/* key schedule words : chaining vars + tweak */
endif|#
directive|endif
name|u64b_t
name|X0
decl_stmt|,
name|X1
decl_stmt|,
name|X2
decl_stmt|,
name|X3
decl_stmt|,
name|X4
decl_stmt|,
name|X5
decl_stmt|,
name|X6
decl_stmt|,
name|X7
decl_stmt|;
comment|/* local copy of vars, for speed */
name|u64b_t
name|w
index|[
name|WCNT
index|]
decl_stmt|;
comment|/* local copy of input block */
ifdef|#
directive|ifdef
name|SKEIN_DEBUG
specifier|const
name|u64b_t
modifier|*
name|Xptr
index|[
literal|8
index|]
decl_stmt|;
comment|/* use for debugging (help compiler put Xn in registers) */
name|Xptr
index|[
literal|0
index|]
operator|=
operator|&
name|X0
expr_stmt|;
name|Xptr
index|[
literal|1
index|]
operator|=
operator|&
name|X1
expr_stmt|;
name|Xptr
index|[
literal|2
index|]
operator|=
operator|&
name|X2
expr_stmt|;
name|Xptr
index|[
literal|3
index|]
operator|=
operator|&
name|X3
expr_stmt|;
name|Xptr
index|[
literal|4
index|]
operator|=
operator|&
name|X4
expr_stmt|;
name|Xptr
index|[
literal|5
index|]
operator|=
operator|&
name|X5
expr_stmt|;
name|Xptr
index|[
literal|6
index|]
operator|=
operator|&
name|X6
expr_stmt|;
name|Xptr
index|[
literal|7
index|]
operator|=
operator|&
name|X7
expr_stmt|;
endif|#
directive|endif
name|Skein_assert
argument_list|(
name|blkCnt
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* never call with blkCnt == 0! */
name|ts
index|[
literal|0
index|]
operator|=
name|ctx
operator|->
name|h
operator|.
name|T
index|[
literal|0
index|]
expr_stmt|;
name|ts
index|[
literal|1
index|]
operator|=
name|ctx
operator|->
name|h
operator|.
name|T
index|[
literal|1
index|]
expr_stmt|;
do|do
block|{
comment|/* this implementation only supports 2**64 input bytes (no carry out here) */
name|ts
index|[
literal|0
index|]
operator|+=
name|byteCntAdd
expr_stmt|;
comment|/* update processed length */
comment|/* precompute the key schedule for this block */
name|ks
index|[
literal|0
index|]
operator|=
name|ctx
operator|->
name|X
index|[
literal|0
index|]
expr_stmt|;
name|ks
index|[
literal|1
index|]
operator|=
name|ctx
operator|->
name|X
index|[
literal|1
index|]
expr_stmt|;
name|ks
index|[
literal|2
index|]
operator|=
name|ctx
operator|->
name|X
index|[
literal|2
index|]
expr_stmt|;
name|ks
index|[
literal|3
index|]
operator|=
name|ctx
operator|->
name|X
index|[
literal|3
index|]
expr_stmt|;
name|ks
index|[
literal|4
index|]
operator|=
name|ctx
operator|->
name|X
index|[
literal|4
index|]
expr_stmt|;
name|ks
index|[
literal|5
index|]
operator|=
name|ctx
operator|->
name|X
index|[
literal|5
index|]
expr_stmt|;
name|ks
index|[
literal|6
index|]
operator|=
name|ctx
operator|->
name|X
index|[
literal|6
index|]
expr_stmt|;
name|ks
index|[
literal|7
index|]
operator|=
name|ctx
operator|->
name|X
index|[
literal|7
index|]
expr_stmt|;
name|ks
index|[
literal|8
index|]
operator|=
name|ks
index|[
literal|0
index|]
operator|^
name|ks
index|[
literal|1
index|]
operator|^
name|ks
index|[
literal|2
index|]
operator|^
name|ks
index|[
literal|3
index|]
operator|^
name|ks
index|[
literal|4
index|]
operator|^
name|ks
index|[
literal|5
index|]
operator|^
name|ks
index|[
literal|6
index|]
operator|^
name|ks
index|[
literal|7
index|]
operator|^
name|SKEIN_KS_PARITY
expr_stmt|;
name|ts
index|[
literal|2
index|]
operator|=
name|ts
index|[
literal|0
index|]
operator|^
name|ts
index|[
literal|1
index|]
expr_stmt|;
name|Skein_Get64_LSB_First
argument_list|(
name|w
argument_list|,
name|blkPtr
argument_list|,
name|WCNT
argument_list|)
expr_stmt|;
comment|/* get input block in little-endian format */
name|DebugSaveTweak
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|Skein_Show_Block
argument_list|(
name|BLK_BITS
argument_list|,
operator|&
name|ctx
operator|->
name|h
argument_list|,
name|ctx
operator|->
name|X
argument_list|,
name|blkPtr
argument_list|,
name|w
argument_list|,
name|ks
argument_list|,
name|ts
argument_list|)
expr_stmt|;
name|X0
operator|=
name|w
index|[
literal|0
index|]
operator|+
name|ks
index|[
literal|0
index|]
expr_stmt|;
comment|/* do the first full key injection */
name|X1
operator|=
name|w
index|[
literal|1
index|]
operator|+
name|ks
index|[
literal|1
index|]
expr_stmt|;
name|X2
operator|=
name|w
index|[
literal|2
index|]
operator|+
name|ks
index|[
literal|2
index|]
expr_stmt|;
name|X3
operator|=
name|w
index|[
literal|3
index|]
operator|+
name|ks
index|[
literal|3
index|]
expr_stmt|;
name|X4
operator|=
name|w
index|[
literal|4
index|]
operator|+
name|ks
index|[
literal|4
index|]
expr_stmt|;
name|X5
operator|=
name|w
index|[
literal|5
index|]
operator|+
name|ks
index|[
literal|5
index|]
operator|+
name|ts
index|[
literal|0
index|]
expr_stmt|;
name|X6
operator|=
name|w
index|[
literal|6
index|]
operator|+
name|ks
index|[
literal|6
index|]
operator|+
name|ts
index|[
literal|1
index|]
expr_stmt|;
name|X7
operator|=
name|w
index|[
literal|7
index|]
operator|+
name|ks
index|[
literal|7
index|]
expr_stmt|;
name|blkPtr
operator|+=
name|SKEIN_512_BLOCK_BYTES
expr_stmt|;
name|Skein_Show_R_Ptr
argument_list|(
name|BLK_BITS
argument_list|,
operator|&
name|ctx
operator|->
name|h
argument_list|,
name|SKEIN_RND_KEY_INITIAL
argument_list|,
name|Xptr
argument_list|)
expr_stmt|;
comment|/* run the rounds */
define|#
directive|define
name|Round512
parameter_list|(
name|p0
parameter_list|,
name|p1
parameter_list|,
name|p2
parameter_list|,
name|p3
parameter_list|,
name|p4
parameter_list|,
name|p5
parameter_list|,
name|p6
parameter_list|,
name|p7
parameter_list|,
name|ROT
parameter_list|,
name|rNum
parameter_list|)
define|\
value|X##p0 += X##p1; X##p1 = RotL_64(X##p1,ROT##_0); X##p1 ^= X##p0; \     X##p2 += X##p3; X##p3 = RotL_64(X##p3,ROT##_1); X##p3 ^= X##p2; \     X##p4 += X##p5; X##p5 = RotL_64(X##p5,ROT##_2); X##p5 ^= X##p4; \     X##p6 += X##p7; X##p7 = RotL_64(X##p7,ROT##_3); X##p7 ^= X##p6; \  #if SKEIN_UNROLL_512 == 0
define|#
directive|define
name|R512
parameter_list|(
name|p0
parameter_list|,
name|p1
parameter_list|,
name|p2
parameter_list|,
name|p3
parameter_list|,
name|p4
parameter_list|,
name|p5
parameter_list|,
name|p6
parameter_list|,
name|p7
parameter_list|,
name|ROT
parameter_list|,
name|rNum
parameter_list|)
comment|/* unrolled */
define|\
value|Round512(p0,p1,p2,p3,p4,p5,p6,p7,ROT,rNum)                      \     Skein_Show_R_Ptr(BLK_BITS,&ctx->h,rNum,Xptr);
define|#
directive|define
name|I512
parameter_list|(
name|R
parameter_list|)
define|\
value|X0   += ks[((R)+1) % 9];
comment|/* inject the key schedule value */
value|\     X1   += ks[((R)+2) % 9];                                        \     X2   += ks[((R)+3) % 9];                                        \     X3   += ks[((R)+4) % 9];                                        \     X4   += ks[((R)+5) % 9];                                        \     X5   += ks[((R)+6) % 9] + ts[((R)+1) % 3];                      \     X6   += ks[((R)+7) % 9] + ts[((R)+2) % 3];                      \     X7   += ks[((R)+8) % 9] +     (R)+1;                            \     Skein_Show_R_Ptr(BLK_BITS,&ctx->h,SKEIN_RND_KEY_INJECT,Xptr);
else|#
directive|else
comment|/* looping version */
define|#
directive|define
name|R512
parameter_list|(
name|p0
parameter_list|,
name|p1
parameter_list|,
name|p2
parameter_list|,
name|p3
parameter_list|,
name|p4
parameter_list|,
name|p5
parameter_list|,
name|p6
parameter_list|,
name|p7
parameter_list|,
name|ROT
parameter_list|,
name|rNum
parameter_list|)
define|\
value|Round512(p0,p1,p2,p3,p4,p5,p6,p7,ROT,rNum)                      \     Skein_Show_R_Ptr(BLK_BITS,&ctx->h,4*(r-1)+rNum,Xptr);
define|#
directive|define
name|I512
parameter_list|(
name|R
parameter_list|)
define|\
value|X0   += ks[r+(R)+0];
comment|/* inject the key schedule value */
value|\     X1   += ks[r+(R)+1];                                            \     X2   += ks[r+(R)+2];                                            \     X3   += ks[r+(R)+3];                                            \     X4   += ks[r+(R)+4];                                            \     X5   += ks[r+(R)+5] + ts[r+(R)+0];                              \     X6   += ks[r+(R)+6] + ts[r+(R)+1];                              \     X7   += ks[r+(R)+7] +    r+(R)   ;                              \     ks[r +       (R)+8] = ks[r+(R)-1];
comment|/* rotate key schedule */
value|\     ts[r +       (R)+2] = ts[r+(R)-1];                              \     Skein_Show_R_Ptr(BLK_BITS,&ctx->h,SKEIN_RND_KEY_INJECT,Xptr);
for|for
control|(
name|r
operator|=
literal|1
init|;
name|r
operator|<
literal|2
operator|*
name|RCNT
condition|;
name|r
operator|+=
literal|2
operator|*
name|SKEIN_UNROLL_512
control|)
comment|/* loop thru it */
endif|#
directive|endif
comment|/* end of looped code definitions */
block|{
define|#
directive|define
name|R512_8_rounds
parameter_list|(
name|R
parameter_list|)
comment|/* do 8 full rounds */
define|\
value|R512(0,1,2,3,4,5,6,7,R_512_0,8*(R)+ 1);   \         R512(2,1,4,7,6,5,0,3,R_512_1,8*(R)+ 2);   \         R512(4,1,6,3,0,5,2,7,R_512_2,8*(R)+ 3);   \         R512(6,1,0,7,2,5,4,3,R_512_3,8*(R)+ 4);   \         I512(2*(R));                              \         R512(0,1,2,3,4,5,6,7,R_512_4,8*(R)+ 5);   \         R512(2,1,4,7,6,5,0,3,R_512_5,8*(R)+ 6);   \         R512(4,1,6,3,0,5,2,7,R_512_6,8*(R)+ 7);   \         R512(6,1,0,7,2,5,4,3,R_512_7,8*(R)+ 8);   \         I512(2*(R)+1);
comment|/* and key injection */
name|R512_8_rounds
argument_list|(
literal|0
argument_list|)
expr_stmt|;
define|#
directive|define
name|R512_Unroll_R
parameter_list|(
name|NN
parameter_list|)
value|((SKEIN_UNROLL_512 == 0&& SKEIN_512_ROUNDS_TOTAL/8> (NN)) || (SKEIN_UNROLL_512> (NN)))
if|#
directive|if
name|R512_Unroll_R
argument_list|(
literal|1
argument_list|)
name|R512_8_rounds
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|R512_Unroll_R
argument_list|(
literal|2
argument_list|)
name|R512_8_rounds
argument_list|(
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|R512_Unroll_R
argument_list|(
literal|3
argument_list|)
name|R512_8_rounds
argument_list|(
literal|3
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|R512_Unroll_R
argument_list|(
literal|4
argument_list|)
name|R512_8_rounds
argument_list|(
literal|4
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|R512_Unroll_R
argument_list|(
literal|5
argument_list|)
name|R512_8_rounds
argument_list|(
literal|5
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|R512_Unroll_R
argument_list|(
literal|6
argument_list|)
name|R512_8_rounds
argument_list|(
literal|6
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|R512_Unroll_R
argument_list|(
literal|7
argument_list|)
name|R512_8_rounds
argument_list|(
literal|7
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|R512_Unroll_R
argument_list|(
literal|8
argument_list|)
name|R512_8_rounds
argument_list|(
literal|8
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|R512_Unroll_R
argument_list|(
literal|9
argument_list|)
name|R512_8_rounds
argument_list|(
literal|9
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|R512_Unroll_R
argument_list|(
literal|10
argument_list|)
name|R512_8_rounds
argument_list|(
literal|10
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|R512_Unroll_R
argument_list|(
literal|11
argument_list|)
name|R512_8_rounds
argument_list|(
literal|11
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|R512_Unroll_R
argument_list|(
literal|12
argument_list|)
name|R512_8_rounds
argument_list|(
literal|12
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|R512_Unroll_R
argument_list|(
literal|13
argument_list|)
name|R512_8_rounds
argument_list|(
literal|13
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|R512_Unroll_R
argument_list|(
literal|14
argument_list|)
name|R512_8_rounds
argument_list|(
literal|14
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|SKEIN_UNROLL_512
operator|>
literal|14
operator|)
error|#
directive|error
literal|"need more unrolling in Skein_512_Process_Block"
endif|#
directive|endif
block|}
comment|/* do the final "feedforward" xor, update context chaining vars */
name|ctx
operator|->
name|X
index|[
literal|0
index|]
operator|=
name|X0
operator|^
name|w
index|[
literal|0
index|]
expr_stmt|;
name|ctx
operator|->
name|X
index|[
literal|1
index|]
operator|=
name|X1
operator|^
name|w
index|[
literal|1
index|]
expr_stmt|;
name|ctx
operator|->
name|X
index|[
literal|2
index|]
operator|=
name|X2
operator|^
name|w
index|[
literal|2
index|]
expr_stmt|;
name|ctx
operator|->
name|X
index|[
literal|3
index|]
operator|=
name|X3
operator|^
name|w
index|[
literal|3
index|]
expr_stmt|;
name|ctx
operator|->
name|X
index|[
literal|4
index|]
operator|=
name|X4
operator|^
name|w
index|[
literal|4
index|]
expr_stmt|;
name|ctx
operator|->
name|X
index|[
literal|5
index|]
operator|=
name|X5
operator|^
name|w
index|[
literal|5
index|]
expr_stmt|;
name|ctx
operator|->
name|X
index|[
literal|6
index|]
operator|=
name|X6
operator|^
name|w
index|[
literal|6
index|]
expr_stmt|;
name|ctx
operator|->
name|X
index|[
literal|7
index|]
operator|=
name|X7
operator|^
name|w
index|[
literal|7
index|]
expr_stmt|;
name|Skein_Show_Round
argument_list|(
name|BLK_BITS
argument_list|,
operator|&
name|ctx
operator|->
name|h
argument_list|,
name|SKEIN_RND_FEED_FWD
argument_list|,
name|ctx
operator|->
name|X
argument_list|)
expr_stmt|;
name|ts
index|[
literal|1
index|]
operator|&=
operator|~
name|SKEIN_T1_FLAG_FIRST
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|blkCnt
condition|)
do|;
name|ctx
operator|->
name|h
operator|.
name|T
index|[
literal|0
index|]
operator|=
name|ts
index|[
literal|0
index|]
expr_stmt|;
name|ctx
operator|->
name|h
operator|.
name|T
index|[
literal|1
index|]
operator|=
name|ts
index|[
literal|1
index|]
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SKEIN_CODE_SIZE
argument_list|)
operator|||
name|defined
argument_list|(
name|SKEIN_PERF
argument_list|)
end_if

begin_function
name|size_t
name|Skein_512_Process_Block_CodeSize
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
operator|(
name|u08b_t
operator|*
operator|)
name|Skein_512_Process_Block_CodeSize
operator|)
operator|-
operator|(
operator|(
name|u08b_t
operator|*
operator|)
name|Skein_512_Process_Block
operator|)
return|;
block|}
end_function

begin_function
name|uint_t
name|Skein_512_Unroll_Cnt
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|SKEIN_UNROLL_512
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*****************************  Skein1024 ******************************/
end_comment

begin_if
if|#
directive|if
operator|!
operator|(
name|SKEIN_USE_ASM
operator|&
literal|1024
operator|)
end_if

begin_function
name|void
name|Skein1024_Process_Block
parameter_list|(
name|Skein1024_Ctxt_t
modifier|*
name|ctx
parameter_list|,
specifier|const
name|u08b_t
modifier|*
name|blkPtr
parameter_list|,
name|size_t
name|blkCnt
parameter_list|,
name|size_t
name|byteCntAdd
parameter_list|)
block|{
comment|/* do it in C, always looping (unrolled is bigger AND slower!) */
enum|enum
block|{
name|WCNT
init|=
name|SKEIN1024_STATE_WORDS
block|}
enum|;
undef|#
directive|undef
name|RCNT
define|#
directive|define
name|RCNT
value|(SKEIN1024_ROUNDS_TOTAL/8)
ifdef|#
directive|ifdef
name|SKEIN_LOOP
comment|/* configure how much to unroll the loop */
define|#
directive|define
name|SKEIN_UNROLL_1024
value|((SKEIN_LOOP)%10)
else|#
directive|else
define|#
directive|define
name|SKEIN_UNROLL_1024
value|(0)
endif|#
directive|endif
if|#
directive|if
operator|(
name|SKEIN_UNROLL_1024
operator|!=
literal|0
operator|)
if|#
directive|if
operator|(
name|RCNT
operator|%
name|SKEIN_UNROLL_1024
operator|)
error|#
directive|error
literal|"Invalid SKEIN_UNROLL_1024"
comment|/* sanity check on unroll count */
endif|#
directive|endif
name|size_t
name|r
decl_stmt|;
name|u64b_t
name|kw
index|[
name|WCNT
operator|+
literal|4
operator|+
name|RCNT
operator|*
literal|2
index|]
decl_stmt|;
comment|/* key schedule words : chaining vars + tweak + "rotation"*/
else|#
directive|else
name|u64b_t
name|kw
index|[
name|WCNT
operator|+
literal|4
index|]
decl_stmt|;
comment|/* key schedule words : chaining vars + tweak */
endif|#
directive|endif
name|u64b_t
name|X00
decl_stmt|,
name|X01
decl_stmt|,
name|X02
decl_stmt|,
name|X03
decl_stmt|,
name|X04
decl_stmt|,
name|X05
decl_stmt|,
name|X06
decl_stmt|,
name|X07
decl_stmt|,
comment|/* local copy of vars, for speed */
name|X08
decl_stmt|,
name|X09
decl_stmt|,
name|X10
decl_stmt|,
name|X11
decl_stmt|,
name|X12
decl_stmt|,
name|X13
decl_stmt|,
name|X14
decl_stmt|,
name|X15
decl_stmt|;
name|u64b_t
name|w
index|[
name|WCNT
index|]
decl_stmt|;
comment|/* local copy of input block */
ifdef|#
directive|ifdef
name|SKEIN_DEBUG
specifier|const
name|u64b_t
modifier|*
name|Xptr
index|[
literal|16
index|]
decl_stmt|;
comment|/* use for debugging (help compiler put Xn in registers) */
name|Xptr
index|[
literal|0
index|]
operator|=
operator|&
name|X00
expr_stmt|;
name|Xptr
index|[
literal|1
index|]
operator|=
operator|&
name|X01
expr_stmt|;
name|Xptr
index|[
literal|2
index|]
operator|=
operator|&
name|X02
expr_stmt|;
name|Xptr
index|[
literal|3
index|]
operator|=
operator|&
name|X03
expr_stmt|;
name|Xptr
index|[
literal|4
index|]
operator|=
operator|&
name|X04
expr_stmt|;
name|Xptr
index|[
literal|5
index|]
operator|=
operator|&
name|X05
expr_stmt|;
name|Xptr
index|[
literal|6
index|]
operator|=
operator|&
name|X06
expr_stmt|;
name|Xptr
index|[
literal|7
index|]
operator|=
operator|&
name|X07
expr_stmt|;
name|Xptr
index|[
literal|8
index|]
operator|=
operator|&
name|X08
expr_stmt|;
name|Xptr
index|[
literal|9
index|]
operator|=
operator|&
name|X09
expr_stmt|;
name|Xptr
index|[
literal|10
index|]
operator|=
operator|&
name|X10
expr_stmt|;
name|Xptr
index|[
literal|11
index|]
operator|=
operator|&
name|X11
expr_stmt|;
name|Xptr
index|[
literal|12
index|]
operator|=
operator|&
name|X12
expr_stmt|;
name|Xptr
index|[
literal|13
index|]
operator|=
operator|&
name|X13
expr_stmt|;
name|Xptr
index|[
literal|14
index|]
operator|=
operator|&
name|X14
expr_stmt|;
name|Xptr
index|[
literal|15
index|]
operator|=
operator|&
name|X15
expr_stmt|;
endif|#
directive|endif
name|Skein_assert
argument_list|(
name|blkCnt
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* never call with blkCnt == 0! */
name|ts
index|[
literal|0
index|]
operator|=
name|ctx
operator|->
name|h
operator|.
name|T
index|[
literal|0
index|]
expr_stmt|;
name|ts
index|[
literal|1
index|]
operator|=
name|ctx
operator|->
name|h
operator|.
name|T
index|[
literal|1
index|]
expr_stmt|;
do|do
block|{
comment|/* this implementation only supports 2**64 input bytes (no carry out here) */
name|ts
index|[
literal|0
index|]
operator|+=
name|byteCntAdd
expr_stmt|;
comment|/* update processed length */
comment|/* precompute the key schedule for this block */
name|ks
index|[
literal|0
index|]
operator|=
name|ctx
operator|->
name|X
index|[
literal|0
index|]
expr_stmt|;
name|ks
index|[
literal|1
index|]
operator|=
name|ctx
operator|->
name|X
index|[
literal|1
index|]
expr_stmt|;
name|ks
index|[
literal|2
index|]
operator|=
name|ctx
operator|->
name|X
index|[
literal|2
index|]
expr_stmt|;
name|ks
index|[
literal|3
index|]
operator|=
name|ctx
operator|->
name|X
index|[
literal|3
index|]
expr_stmt|;
name|ks
index|[
literal|4
index|]
operator|=
name|ctx
operator|->
name|X
index|[
literal|4
index|]
expr_stmt|;
name|ks
index|[
literal|5
index|]
operator|=
name|ctx
operator|->
name|X
index|[
literal|5
index|]
expr_stmt|;
name|ks
index|[
literal|6
index|]
operator|=
name|ctx
operator|->
name|X
index|[
literal|6
index|]
expr_stmt|;
name|ks
index|[
literal|7
index|]
operator|=
name|ctx
operator|->
name|X
index|[
literal|7
index|]
expr_stmt|;
name|ks
index|[
literal|8
index|]
operator|=
name|ctx
operator|->
name|X
index|[
literal|8
index|]
expr_stmt|;
name|ks
index|[
literal|9
index|]
operator|=
name|ctx
operator|->
name|X
index|[
literal|9
index|]
expr_stmt|;
name|ks
index|[
literal|10
index|]
operator|=
name|ctx
operator|->
name|X
index|[
literal|10
index|]
expr_stmt|;
name|ks
index|[
literal|11
index|]
operator|=
name|ctx
operator|->
name|X
index|[
literal|11
index|]
expr_stmt|;
name|ks
index|[
literal|12
index|]
operator|=
name|ctx
operator|->
name|X
index|[
literal|12
index|]
expr_stmt|;
name|ks
index|[
literal|13
index|]
operator|=
name|ctx
operator|->
name|X
index|[
literal|13
index|]
expr_stmt|;
name|ks
index|[
literal|14
index|]
operator|=
name|ctx
operator|->
name|X
index|[
literal|14
index|]
expr_stmt|;
name|ks
index|[
literal|15
index|]
operator|=
name|ctx
operator|->
name|X
index|[
literal|15
index|]
expr_stmt|;
name|ks
index|[
literal|16
index|]
operator|=
name|ks
index|[
literal|0
index|]
operator|^
name|ks
index|[
literal|1
index|]
operator|^
name|ks
index|[
literal|2
index|]
operator|^
name|ks
index|[
literal|3
index|]
operator|^
name|ks
index|[
literal|4
index|]
operator|^
name|ks
index|[
literal|5
index|]
operator|^
name|ks
index|[
literal|6
index|]
operator|^
name|ks
index|[
literal|7
index|]
operator|^
name|ks
index|[
literal|8
index|]
operator|^
name|ks
index|[
literal|9
index|]
operator|^
name|ks
index|[
literal|10
index|]
operator|^
name|ks
index|[
literal|11
index|]
operator|^
name|ks
index|[
literal|12
index|]
operator|^
name|ks
index|[
literal|13
index|]
operator|^
name|ks
index|[
literal|14
index|]
operator|^
name|ks
index|[
literal|15
index|]
operator|^
name|SKEIN_KS_PARITY
expr_stmt|;
name|ts
index|[
literal|2
index|]
operator|=
name|ts
index|[
literal|0
index|]
operator|^
name|ts
index|[
literal|1
index|]
expr_stmt|;
name|Skein_Get64_LSB_First
argument_list|(
name|w
argument_list|,
name|blkPtr
argument_list|,
name|WCNT
argument_list|)
expr_stmt|;
comment|/* get input block in little-endian format */
name|DebugSaveTweak
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|Skein_Show_Block
argument_list|(
name|BLK_BITS
argument_list|,
operator|&
name|ctx
operator|->
name|h
argument_list|,
name|ctx
operator|->
name|X
argument_list|,
name|blkPtr
argument_list|,
name|w
argument_list|,
name|ks
argument_list|,
name|ts
argument_list|)
expr_stmt|;
name|X00
operator|=
name|w
index|[
literal|0
index|]
operator|+
name|ks
index|[
literal|0
index|]
expr_stmt|;
comment|/* do the first full key injection */
name|X01
operator|=
name|w
index|[
literal|1
index|]
operator|+
name|ks
index|[
literal|1
index|]
expr_stmt|;
name|X02
operator|=
name|w
index|[
literal|2
index|]
operator|+
name|ks
index|[
literal|2
index|]
expr_stmt|;
name|X03
operator|=
name|w
index|[
literal|3
index|]
operator|+
name|ks
index|[
literal|3
index|]
expr_stmt|;
name|X04
operator|=
name|w
index|[
literal|4
index|]
operator|+
name|ks
index|[
literal|4
index|]
expr_stmt|;
name|X05
operator|=
name|w
index|[
literal|5
index|]
operator|+
name|ks
index|[
literal|5
index|]
expr_stmt|;
name|X06
operator|=
name|w
index|[
literal|6
index|]
operator|+
name|ks
index|[
literal|6
index|]
expr_stmt|;
name|X07
operator|=
name|w
index|[
literal|7
index|]
operator|+
name|ks
index|[
literal|7
index|]
expr_stmt|;
name|X08
operator|=
name|w
index|[
literal|8
index|]
operator|+
name|ks
index|[
literal|8
index|]
expr_stmt|;
name|X09
operator|=
name|w
index|[
literal|9
index|]
operator|+
name|ks
index|[
literal|9
index|]
expr_stmt|;
name|X10
operator|=
name|w
index|[
literal|10
index|]
operator|+
name|ks
index|[
literal|10
index|]
expr_stmt|;
name|X11
operator|=
name|w
index|[
literal|11
index|]
operator|+
name|ks
index|[
literal|11
index|]
expr_stmt|;
name|X12
operator|=
name|w
index|[
literal|12
index|]
operator|+
name|ks
index|[
literal|12
index|]
expr_stmt|;
name|X13
operator|=
name|w
index|[
literal|13
index|]
operator|+
name|ks
index|[
literal|13
index|]
operator|+
name|ts
index|[
literal|0
index|]
expr_stmt|;
name|X14
operator|=
name|w
index|[
literal|14
index|]
operator|+
name|ks
index|[
literal|14
index|]
operator|+
name|ts
index|[
literal|1
index|]
expr_stmt|;
name|X15
operator|=
name|w
index|[
literal|15
index|]
operator|+
name|ks
index|[
literal|15
index|]
expr_stmt|;
name|Skein_Show_R_Ptr
argument_list|(
name|BLK_BITS
argument_list|,
operator|&
name|ctx
operator|->
name|h
argument_list|,
name|SKEIN_RND_KEY_INITIAL
argument_list|,
name|Xptr
argument_list|)
expr_stmt|;
define|#
directive|define
name|Round1024
parameter_list|(
name|p0
parameter_list|,
name|p1
parameter_list|,
name|p2
parameter_list|,
name|p3
parameter_list|,
name|p4
parameter_list|,
name|p5
parameter_list|,
name|p6
parameter_list|,
name|p7
parameter_list|,
name|p8
parameter_list|,
name|p9
parameter_list|,
name|pA
parameter_list|,
name|pB
parameter_list|,
name|pC
parameter_list|,
name|pD
parameter_list|,
name|pE
parameter_list|,
name|pF
parameter_list|,
name|ROT
parameter_list|,
name|rNum
parameter_list|)
define|\
value|X##p0 += X##p1; X##p1 = RotL_64(X##p1,ROT##_0); X##p1 ^= X##p0;   \     X##p2 += X##p3; X##p3 = RotL_64(X##p3,ROT##_1); X##p3 ^= X##p2;   \     X##p4 += X##p5; X##p5 = RotL_64(X##p5,ROT##_2); X##p5 ^= X##p4;   \     X##p6 += X##p7; X##p7 = RotL_64(X##p7,ROT##_3); X##p7 ^= X##p6;   \     X##p8 += X##p9; X##p9 = RotL_64(X##p9,ROT##_4); X##p9 ^= X##p8;   \     X##pA += X##pB; X##pB = RotL_64(X##pB,ROT##_5); X##pB ^= X##pA;   \     X##pC += X##pD; X##pD = RotL_64(X##pD,ROT##_6); X##pD ^= X##pC;   \     X##pE += X##pF; X##pF = RotL_64(X##pF,ROT##_7); X##pF ^= X##pE;   \  #if SKEIN_UNROLL_1024 == 0
define|#
directive|define
name|R1024
parameter_list|(
name|p0
parameter_list|,
name|p1
parameter_list|,
name|p2
parameter_list|,
name|p3
parameter_list|,
name|p4
parameter_list|,
name|p5
parameter_list|,
name|p6
parameter_list|,
name|p7
parameter_list|,
name|p8
parameter_list|,
name|p9
parameter_list|,
name|pA
parameter_list|,
name|pB
parameter_list|,
name|pC
parameter_list|,
name|pD
parameter_list|,
name|pE
parameter_list|,
name|pF
parameter_list|,
name|ROT
parameter_list|,
name|rn
parameter_list|)
define|\
value|Round1024(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,pA,pB,pC,pD,pE,pF,ROT,rn) \     Skein_Show_R_Ptr(BLK_BITS,&ctx->h,rn,Xptr);
define|#
directive|define
name|I1024
parameter_list|(
name|R
parameter_list|)
define|\
value|X00   += ks[((R)+ 1) % 17];
comment|/* inject the key schedule value */
value|\     X01   += ks[((R)+ 2) % 17];                                       \     X02   += ks[((R)+ 3) % 17];                                       \     X03   += ks[((R)+ 4) % 17];                                       \     X04   += ks[((R)+ 5) % 17];                                       \     X05   += ks[((R)+ 6) % 17];                                       \     X06   += ks[((R)+ 7) % 17];                                       \     X07   += ks[((R)+ 8) % 17];                                       \     X08   += ks[((R)+ 9) % 17];                                       \     X09   += ks[((R)+10) % 17];                                       \     X10   += ks[((R)+11) % 17];                                       \     X11   += ks[((R)+12) % 17];                                       \     X12   += ks[((R)+13) % 17];                                       \     X13   += ks[((R)+14) % 17] + ts[((R)+1) % 3];                     \     X14   += ks[((R)+15) % 17] + ts[((R)+2) % 3];                     \     X15   += ks[((R)+16) % 17] +     (R)+1;                           \     Skein_Show_R_Ptr(BLK_BITS,&ctx->h,SKEIN_RND_KEY_INJECT,Xptr);
else|#
directive|else
comment|/* looping version */
define|#
directive|define
name|R1024
parameter_list|(
name|p0
parameter_list|,
name|p1
parameter_list|,
name|p2
parameter_list|,
name|p3
parameter_list|,
name|p4
parameter_list|,
name|p5
parameter_list|,
name|p6
parameter_list|,
name|p7
parameter_list|,
name|p8
parameter_list|,
name|p9
parameter_list|,
name|pA
parameter_list|,
name|pB
parameter_list|,
name|pC
parameter_list|,
name|pD
parameter_list|,
name|pE
parameter_list|,
name|pF
parameter_list|,
name|ROT
parameter_list|,
name|rn
parameter_list|)
define|\
value|Round1024(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,pA,pB,pC,pD,pE,pF,ROT,rn) \     Skein_Show_R_Ptr(BLK_BITS,&ctx->h,4*(r-1)+rn,Xptr);
define|#
directive|define
name|I1024
parameter_list|(
name|R
parameter_list|)
define|\
value|X00   += ks[r+(R)+ 0];
comment|/* inject the key schedule value */
value|\     X01   += ks[r+(R)+ 1];                                            \     X02   += ks[r+(R)+ 2];                                            \     X03   += ks[r+(R)+ 3];                                            \     X04   += ks[r+(R)+ 4];                                            \     X05   += ks[r+(R)+ 5];                                            \     X06   += ks[r+(R)+ 6];                                            \     X07   += ks[r+(R)+ 7];                                            \     X08   += ks[r+(R)+ 8];                                            \     X09   += ks[r+(R)+ 9];                                            \     X10   += ks[r+(R)+10];                                            \     X11   += ks[r+(R)+11];                                            \     X12   += ks[r+(R)+12];                                            \     X13   += ks[r+(R)+13] + ts[r+(R)+0];                              \     X14   += ks[r+(R)+14] + ts[r+(R)+1];                              \     X15   += ks[r+(R)+15] +    r+(R)   ;                              \     ks[r  +       (R)+16] = ks[r+(R)-1];
comment|/* rotate key schedule */
value|\     ts[r  +       (R)+ 2] = ts[r+(R)-1];                              \     Skein_Show_R_Ptr(BLK_BITS,&ctx->h,SKEIN_RND_KEY_INJECT,Xptr);
for|for
control|(
name|r
operator|=
literal|1
init|;
name|r
operator|<=
literal|2
operator|*
name|RCNT
condition|;
name|r
operator|+=
literal|2
operator|*
name|SKEIN_UNROLL_1024
control|)
comment|/* loop thru it */
endif|#
directive|endif
block|{
define|#
directive|define
name|R1024_8_rounds
parameter_list|(
name|R
parameter_list|)
comment|/* do 8 full rounds */
define|\
value|R1024(00,01,02,03,04,05,06,07,08,09,10,11,12,13,14,15,R1024_0,8*(R) + 1); \         R1024(00,09,02,13,06,11,04,15,10,07,12,03,14,05,08,01,R1024_1,8*(R) + 2); \         R1024(00,07,02,05,04,03,06,01,12,15,14,13,08,11,10,09,R1024_2,8*(R) + 3); \         R1024(00,15,02,11,06,13,04,09,14,01,08,05,10,03,12,07,R1024_3,8*(R) + 4); \         I1024(2*(R));                                                             \         R1024(00,01,02,03,04,05,06,07,08,09,10,11,12,13,14,15,R1024_4,8*(R) + 5); \         R1024(00,09,02,13,06,11,04,15,10,07,12,03,14,05,08,01,R1024_5,8*(R) + 6); \         R1024(00,07,02,05,04,03,06,01,12,15,14,13,08,11,10,09,R1024_6,8*(R) + 7); \         R1024(00,15,02,11,06,13,04,09,14,01,08,05,10,03,12,07,R1024_7,8*(R) + 8); \         I1024(2*(R)+1);
name|R1024_8_rounds
argument_list|(
literal|0
argument_list|)
expr_stmt|;
define|#
directive|define
name|R1024_Unroll_R
parameter_list|(
name|NN
parameter_list|)
value|((SKEIN_UNROLL_1024 == 0&& SKEIN1024_ROUNDS_TOTAL/8> (NN)) || (SKEIN_UNROLL_1024> (NN)))
if|#
directive|if
name|R1024_Unroll_R
argument_list|(
literal|1
argument_list|)
name|R1024_8_rounds
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|R1024_Unroll_R
argument_list|(
literal|2
argument_list|)
name|R1024_8_rounds
argument_list|(
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|R1024_Unroll_R
argument_list|(
literal|3
argument_list|)
name|R1024_8_rounds
argument_list|(
literal|3
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|R1024_Unroll_R
argument_list|(
literal|4
argument_list|)
name|R1024_8_rounds
argument_list|(
literal|4
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|R1024_Unroll_R
argument_list|(
literal|5
argument_list|)
name|R1024_8_rounds
argument_list|(
literal|5
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|R1024_Unroll_R
argument_list|(
literal|6
argument_list|)
name|R1024_8_rounds
argument_list|(
literal|6
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|R1024_Unroll_R
argument_list|(
literal|7
argument_list|)
name|R1024_8_rounds
argument_list|(
literal|7
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|R1024_Unroll_R
argument_list|(
literal|8
argument_list|)
name|R1024_8_rounds
argument_list|(
literal|8
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|R1024_Unroll_R
argument_list|(
literal|9
argument_list|)
name|R1024_8_rounds
argument_list|(
literal|9
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|R1024_Unroll_R
argument_list|(
literal|10
argument_list|)
name|R1024_8_rounds
argument_list|(
literal|10
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|R1024_Unroll_R
argument_list|(
literal|11
argument_list|)
name|R1024_8_rounds
argument_list|(
literal|11
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|R1024_Unroll_R
argument_list|(
literal|12
argument_list|)
name|R1024_8_rounds
argument_list|(
literal|12
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|R1024_Unroll_R
argument_list|(
literal|13
argument_list|)
name|R1024_8_rounds
argument_list|(
literal|13
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|R1024_Unroll_R
argument_list|(
literal|14
argument_list|)
name|R1024_8_rounds
argument_list|(
literal|14
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|SKEIN_UNROLL_1024
operator|>
literal|14
operator|)
error|#
directive|error
literal|"need more unrolling in Skein_1024_Process_Block"
endif|#
directive|endif
block|}
comment|/* do the final "feedforward" xor, update context chaining vars */
name|ctx
operator|->
name|X
index|[
literal|0
index|]
operator|=
name|X00
operator|^
name|w
index|[
literal|0
index|]
expr_stmt|;
name|ctx
operator|->
name|X
index|[
literal|1
index|]
operator|=
name|X01
operator|^
name|w
index|[
literal|1
index|]
expr_stmt|;
name|ctx
operator|->
name|X
index|[
literal|2
index|]
operator|=
name|X02
operator|^
name|w
index|[
literal|2
index|]
expr_stmt|;
name|ctx
operator|->
name|X
index|[
literal|3
index|]
operator|=
name|X03
operator|^
name|w
index|[
literal|3
index|]
expr_stmt|;
name|ctx
operator|->
name|X
index|[
literal|4
index|]
operator|=
name|X04
operator|^
name|w
index|[
literal|4
index|]
expr_stmt|;
name|ctx
operator|->
name|X
index|[
literal|5
index|]
operator|=
name|X05
operator|^
name|w
index|[
literal|5
index|]
expr_stmt|;
name|ctx
operator|->
name|X
index|[
literal|6
index|]
operator|=
name|X06
operator|^
name|w
index|[
literal|6
index|]
expr_stmt|;
name|ctx
operator|->
name|X
index|[
literal|7
index|]
operator|=
name|X07
operator|^
name|w
index|[
literal|7
index|]
expr_stmt|;
name|ctx
operator|->
name|X
index|[
literal|8
index|]
operator|=
name|X08
operator|^
name|w
index|[
literal|8
index|]
expr_stmt|;
name|ctx
operator|->
name|X
index|[
literal|9
index|]
operator|=
name|X09
operator|^
name|w
index|[
literal|9
index|]
expr_stmt|;
name|ctx
operator|->
name|X
index|[
literal|10
index|]
operator|=
name|X10
operator|^
name|w
index|[
literal|10
index|]
expr_stmt|;
name|ctx
operator|->
name|X
index|[
literal|11
index|]
operator|=
name|X11
operator|^
name|w
index|[
literal|11
index|]
expr_stmt|;
name|ctx
operator|->
name|X
index|[
literal|12
index|]
operator|=
name|X12
operator|^
name|w
index|[
literal|12
index|]
expr_stmt|;
name|ctx
operator|->
name|X
index|[
literal|13
index|]
operator|=
name|X13
operator|^
name|w
index|[
literal|13
index|]
expr_stmt|;
name|ctx
operator|->
name|X
index|[
literal|14
index|]
operator|=
name|X14
operator|^
name|w
index|[
literal|14
index|]
expr_stmt|;
name|ctx
operator|->
name|X
index|[
literal|15
index|]
operator|=
name|X15
operator|^
name|w
index|[
literal|15
index|]
expr_stmt|;
name|Skein_Show_Round
argument_list|(
name|BLK_BITS
argument_list|,
operator|&
name|ctx
operator|->
name|h
argument_list|,
name|SKEIN_RND_FEED_FWD
argument_list|,
name|ctx
operator|->
name|X
argument_list|)
expr_stmt|;
name|ts
index|[
literal|1
index|]
operator|&=
operator|~
name|SKEIN_T1_FLAG_FIRST
expr_stmt|;
name|blkPtr
operator|+=
name|SKEIN1024_BLOCK_BYTES
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|blkCnt
condition|)
do|;
name|ctx
operator|->
name|h
operator|.
name|T
index|[
literal|0
index|]
operator|=
name|ts
index|[
literal|0
index|]
expr_stmt|;
name|ctx
operator|->
name|h
operator|.
name|T
index|[
literal|1
index|]
operator|=
name|ts
index|[
literal|1
index|]
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SKEIN_CODE_SIZE
argument_list|)
operator|||
name|defined
argument_list|(
name|SKEIN_PERF
argument_list|)
end_if

begin_function
name|size_t
name|Skein1024_Process_Block_CodeSize
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
operator|(
name|u08b_t
operator|*
operator|)
name|Skein1024_Process_Block_CodeSize
operator|)
operator|-
operator|(
operator|(
name|u08b_t
operator|*
operator|)
name|Skein1024_Process_Block
operator|)
return|;
block|}
end_function

begin_function
name|uint_t
name|Skein1024_Unroll_Cnt
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|SKEIN_UNROLL_1024
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

