begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Common functions for CAM "type" (peripheral) drivers.  *  * Copyright (c) 1997, 1998 Justin T. Gibbs.  * Copyright (c) 1997, 1998, 1999, 2000 Kenneth D. Merry.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker_set.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/devicestat.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_pass.h>
end_include

begin_function_decl
specifier|static
name|u_int
name|camperiphnextunit
parameter_list|(
name|struct
name|periph_driver
modifier|*
name|p_drv
parameter_list|,
name|u_int
name|newunit
parameter_list|,
name|int
name|wired
parameter_list|,
name|path_id_t
name|pathid
parameter_list|,
name|target_id_t
name|target
parameter_list|,
name|lun_id_t
name|lun
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|camperiphunit
parameter_list|(
name|struct
name|periph_driver
modifier|*
name|p_drv
parameter_list|,
name|path_id_t
name|pathid
parameter_list|,
name|target_id_t
name|target
parameter_list|,
name|lun_id_t
name|lun
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|camperiphdone
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|done_ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|camperiphfree
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|camperiphscsistatuserror
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|cam_flags
name|camflags
parameter_list|,
name|u_int32_t
name|sense_flags
parameter_list|,
name|union
name|ccb
modifier|*
name|save_ccb
parameter_list|,
name|int
modifier|*
name|openings
parameter_list|,
name|u_int32_t
modifier|*
name|relsim_flags
parameter_list|,
name|u_int32_t
modifier|*
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|camperiphscsisenseerror
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|cam_flags
name|camflags
parameter_list|,
name|u_int32_t
name|sense_flags
parameter_list|,
name|union
name|ccb
modifier|*
name|save_ccb
parameter_list|,
name|int
modifier|*
name|openings
parameter_list|,
name|u_int32_t
modifier|*
name|relsim_flags
parameter_list|,
name|u_int32_t
modifier|*
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|nperiph_drivers
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|periph_driver
modifier|*
modifier|*
name|periph_drivers
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_CAMPERIPH
argument_list|,
literal|"CAM periph"
argument_list|,
literal|"CAM peripheral buffers"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|periph_selto_delay
init|=
literal|1000
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"kern.cam.periph_selto_delay"
argument_list|,
operator|&
name|periph_selto_delay
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|periph_noresrc_delay
init|=
literal|500
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"kern.cam.periph_noresrc_delay"
argument_list|,
operator|&
name|periph_noresrc_delay
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|periph_busy_delay
init|=
literal|500
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"kern.cam.periph_busy_delay"
argument_list|,
operator|&
name|periph_busy_delay
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|periphdriver_register
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|periph_driver
modifier|*
modifier|*
name|newdrivers
decl_stmt|,
modifier|*
modifier|*
name|old
decl_stmt|;
name|int
name|ndrivers
decl_stmt|;
name|ndrivers
operator|=
name|nperiph_drivers
operator|+
literal|2
expr_stmt|;
name|newdrivers
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|newdrivers
argument_list|)
operator|*
name|ndrivers
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|periph_drivers
condition|)
name|bcopy
argument_list|(
name|periph_drivers
argument_list|,
name|newdrivers
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|newdrivers
argument_list|)
operator|*
name|nperiph_drivers
argument_list|)
expr_stmt|;
name|newdrivers
index|[
name|nperiph_drivers
index|]
operator|=
operator|(
expr|struct
name|periph_driver
operator|*
operator|)
name|data
expr_stmt|;
name|newdrivers
index|[
name|nperiph_drivers
operator|+
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|old
operator|=
name|periph_drivers
expr_stmt|;
name|periph_drivers
operator|=
name|newdrivers
expr_stmt|;
if|if
condition|(
name|old
condition|)
name|free
argument_list|(
name|old
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|nperiph_drivers
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|cam_status
name|cam_periph_alloc
parameter_list|(
name|periph_ctor_t
modifier|*
name|periph_ctor
parameter_list|,
name|periph_oninv_t
modifier|*
name|periph_oninvalidate
parameter_list|,
name|periph_dtor_t
modifier|*
name|periph_dtor
parameter_list|,
name|periph_start_t
modifier|*
name|periph_start
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|cam_periph_type
name|type
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|ac_callback_t
modifier|*
name|ac_callback
parameter_list|,
name|ac_code
name|code
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|periph_driver
modifier|*
modifier|*
name|p_drv
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|cam_periph
modifier|*
name|cur_periph
decl_stmt|;
name|path_id_t
name|path_id
decl_stmt|;
name|target_id_t
name|target_id
decl_stmt|;
name|lun_id_t
name|lun_id
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|u_int
name|init_level
decl_stmt|;
name|int
name|s
decl_stmt|;
name|init_level
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Handle Hot-Plug scenarios.  If there is already a peripheral 	 * of our type assigned to this path, we are likely waiting for 	 * final close on an old, invalidated, peripheral.  If this is 	 * the case, queue up a deferred call to the peripheral's async 	 * handler.  If it looks like a mistaken re-allocation, complain. 	 */
if|if
condition|(
operator|(
name|periph
operator|=
name|cam_periph_find
argument_list|(
name|path
argument_list|,
name|name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|periph
operator|->
name|flags
operator|&
name|CAM_PERIPH_INVALID
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|periph
operator|->
name|flags
operator|&
name|CAM_PERIPH_NEW_DEV_FOUND
operator|)
operator|==
literal|0
condition|)
block|{
name|periph
operator|->
name|flags
operator||=
name|CAM_PERIPH_NEW_DEV_FOUND
expr_stmt|;
name|periph
operator|->
name|deferred_callback
operator|=
name|ac_callback
expr_stmt|;
name|periph
operator|->
name|deferred_ac
operator|=
name|code
expr_stmt|;
return|return
operator|(
name|CAM_REQ_INPROG
operator|)
return|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"cam_periph_alloc: attempt to re-allocate "
literal|"valid device %s%d rejected\n"
argument_list|,
name|periph
operator|->
name|periph_name
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|CAM_REQ_INVALID
operator|)
return|;
block|}
name|periph
operator|=
operator|(
expr|struct
name|cam_periph
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|periph
argument_list|)
argument_list|,
name|M_CAMPERIPH
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
return|return
operator|(
name|CAM_RESRC_UNAVAIL
operator|)
return|;
name|init_level
operator|++
expr_stmt|;
name|xpt_lock_buses
argument_list|()
expr_stmt|;
for|for
control|(
name|p_drv
operator|=
name|periph_drivers
init|;
operator|*
name|p_drv
operator|!=
name|NULL
condition|;
name|p_drv
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|(
operator|*
name|p_drv
operator|)
operator|->
name|driver_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
name|xpt_unlock_buses
argument_list|()
expr_stmt|;
name|sim
operator|=
name|xpt_path_sim
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|path_id
operator|=
name|xpt_path_path_id
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|target_id
operator|=
name|xpt_path_target_id
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|lun_id
operator|=
name|xpt_path_lun_id
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|periph
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|periph
argument_list|)
argument_list|)
expr_stmt|;
name|cam_init_pinfo
argument_list|(
operator|&
name|periph
operator|->
name|pinfo
argument_list|)
expr_stmt|;
name|periph
operator|->
name|periph_start
operator|=
name|periph_start
expr_stmt|;
name|periph
operator|->
name|periph_dtor
operator|=
name|periph_dtor
expr_stmt|;
name|periph
operator|->
name|periph_oninval
operator|=
name|periph_oninvalidate
expr_stmt|;
name|periph
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|periph
operator|->
name|periph_name
operator|=
name|name
expr_stmt|;
name|periph
operator|->
name|unit_number
operator|=
name|camperiphunit
argument_list|(
operator|*
name|p_drv
argument_list|,
name|path_id
argument_list|,
name|target_id
argument_list|,
name|lun_id
argument_list|)
expr_stmt|;
name|periph
operator|->
name|immediate_priority
operator|=
name|CAM_PRIORITY_NONE
expr_stmt|;
name|periph
operator|->
name|refcount
operator|=
literal|0
expr_stmt|;
name|periph
operator|->
name|sim
operator|=
name|sim
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|periph
operator|->
name|ccb_list
argument_list|)
expr_stmt|;
name|status
operator|=
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
name|periph
argument_list|,
name|path_id
argument_list|,
name|target_id
argument_list|,
name|lun_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
goto|goto
name|failure
goto|;
name|periph
operator|->
name|path
operator|=
name|path
expr_stmt|;
name|init_level
operator|++
expr_stmt|;
name|status
operator|=
name|xpt_add_periph
argument_list|(
name|periph
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
goto|goto
name|failure
goto|;
name|s
operator|=
name|splsoftcam
argument_list|()
expr_stmt|;
name|cur_periph
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
operator|(
operator|*
name|p_drv
operator|)
operator|->
name|units
argument_list|)
expr_stmt|;
while|while
condition|(
name|cur_periph
operator|!=
name|NULL
operator|&&
name|cur_periph
operator|->
name|unit_number
operator|<
name|periph
operator|->
name|unit_number
condition|)
name|cur_periph
operator|=
name|TAILQ_NEXT
argument_list|(
name|cur_periph
argument_list|,
name|unit_links
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_periph
operator|!=
name|NULL
condition|)
name|TAILQ_INSERT_BEFORE
argument_list|(
name|cur_periph
argument_list|,
name|periph
argument_list|,
name|unit_links
argument_list|)
expr_stmt|;
else|else
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
operator|(
operator|*
name|p_drv
operator|)
operator|->
name|units
argument_list|,
name|periph
argument_list|,
name|unit_links
argument_list|)
expr_stmt|;
operator|(
operator|*
name|p_drv
operator|)
operator|->
name|generation
operator|++
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|init_level
operator|++
expr_stmt|;
name|status
operator|=
name|periph_ctor
argument_list|(
name|periph
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|CAM_REQ_CMP
condition|)
name|init_level
operator|++
expr_stmt|;
name|failure
label|:
switch|switch
condition|(
name|init_level
condition|)
block|{
case|case
literal|4
case|:
comment|/* Initialized successfully */
break|break;
case|case
literal|3
case|:
name|s
operator|=
name|splsoftcam
argument_list|()
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
operator|(
operator|*
name|p_drv
operator|)
operator|->
name|units
argument_list|,
name|periph
argument_list|,
name|unit_links
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|xpt_remove_periph
argument_list|(
name|periph
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|2
case|:
name|xpt_free_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|1
case|:
name|free
argument_list|(
name|periph
argument_list|,
name|M_CAMPERIPH
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|0
case|:
comment|/* No cleanup to perform. */
break|break;
default|default:
name|panic
argument_list|(
literal|"cam_periph_alloc: Unkown init level"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find a peripheral structure with the specified path, target, lun,   * and (optionally) type.  If the name is NULL, this function will return  * the first peripheral driver that matches the specified path.  */
end_comment

begin_function
name|struct
name|cam_periph
modifier|*
name|cam_periph_find
parameter_list|(
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|periph_driver
modifier|*
modifier|*
name|p_drv
decl_stmt|;
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|int
name|s
decl_stmt|;
for|for
control|(
name|p_drv
operator|=
name|periph_drivers
init|;
operator|*
name|p_drv
operator|!=
name|NULL
condition|;
name|p_drv
operator|++
control|)
block|{
if|if
condition|(
name|name
operator|!=
name|NULL
operator|&&
operator|(
name|strcmp
argument_list|(
operator|(
operator|*
name|p_drv
operator|)
operator|->
name|driver_name
argument_list|,
name|name
argument_list|)
operator|!=
literal|0
operator|)
condition|)
continue|continue;
name|s
operator|=
name|splsoftcam
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|periph
argument_list|,
argument|&(*p_drv)->units
argument_list|,
argument|unit_links
argument_list|)
block|{
if|if
condition|(
name|xpt_path_comp
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|path
argument_list|)
operator|==
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|periph
operator|)
return|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|cam_status
name|cam_periph_acquire
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
name|xpt_lock_buses
argument_list|()
expr_stmt|;
name|periph
operator|->
name|refcount
operator|++
expr_stmt|;
name|xpt_unlock_buses
argument_list|()
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cam_periph_release
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
return|return;
name|xpt_lock_buses
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
operator|--
name|periph
operator|->
name|refcount
operator|==
literal|0
operator|)
operator|&&
operator|(
name|periph
operator|->
name|flags
operator|&
name|CAM_PERIPH_INVALID
operator|)
condition|)
block|{
name|camperiphfree
argument_list|(
name|periph
argument_list|)
expr_stmt|;
block|}
name|xpt_unlock_buses
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|int
name|cam_periph_hold
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|priority
parameter_list|)
block|{
name|struct
name|mtx
modifier|*
name|mtx
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mtx_assert
argument_list|(
name|periph
operator|->
name|sim
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * Increment the reference count on the peripheral 	 * while we wait for our lock attempt to succeed 	 * to ensure the peripheral doesn't disappear out 	 * from user us while we sleep. 	 */
if|if
condition|(
name|cam_periph_acquire
argument_list|(
name|periph
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|mtx
operator|=
name|periph
operator|->
name|sim
operator|->
name|mtx
expr_stmt|;
if|if
condition|(
name|mtx
operator|==
operator|&
name|Giant
condition|)
name|mtx
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|periph
operator|->
name|flags
operator|&
name|CAM_PERIPH_LOCKED
operator|)
operator|!=
literal|0
condition|)
block|{
name|periph
operator|->
name|flags
operator||=
name|CAM_PERIPH_LOCK_WANTED
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|msleep
argument_list|(
name|periph
argument_list|,
name|mtx
argument_list|,
name|priority
argument_list|,
literal|"caplck"
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|cam_periph_release
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|periph
operator|->
name|flags
operator||=
name|CAM_PERIPH_LOCKED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cam_periph_unhold
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|mtx_assert
argument_list|(
name|periph
operator|->
name|sim
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|periph
operator|->
name|flags
operator|&=
operator|~
name|CAM_PERIPH_LOCKED
expr_stmt|;
if|if
condition|(
operator|(
name|periph
operator|->
name|flags
operator|&
name|CAM_PERIPH_LOCK_WANTED
operator|)
operator|!=
literal|0
condition|)
block|{
name|periph
operator|->
name|flags
operator|&=
operator|~
name|CAM_PERIPH_LOCK_WANTED
expr_stmt|;
name|wakeup
argument_list|(
name|periph
argument_list|)
expr_stmt|;
block|}
name|cam_periph_release
argument_list|(
name|periph
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Look for the next unit number that is not currently in use for this  * peripheral type starting at "newunit".  Also exclude unit numbers that  * are reserved by for future "hardwiring" unless we already know that this  * is a potential wired device.  Only assume that the device is "wired" the  * first time through the loop since after that we'll be looking at unit  * numbers that did not match a wiring entry.  */
end_comment

begin_function
specifier|static
name|u_int
name|camperiphnextunit
parameter_list|(
name|struct
name|periph_driver
modifier|*
name|p_drv
parameter_list|,
name|u_int
name|newunit
parameter_list|,
name|int
name|wired
parameter_list|,
name|path_id_t
name|pathid
parameter_list|,
name|target_id_t
name|target
parameter_list|,
name|lun_id_t
name|lun
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|char
modifier|*
name|periph_name
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|i
decl_stmt|,
name|val
decl_stmt|,
name|dunit
decl_stmt|,
name|r
decl_stmt|;
specifier|const
name|char
modifier|*
name|dname
decl_stmt|,
modifier|*
name|strval
decl_stmt|;
name|s
operator|=
name|splsoftcam
argument_list|()
expr_stmt|;
name|periph_name
operator|=
name|p_drv
operator|->
name|driver_name
expr_stmt|;
for|for
control|(
init|;
condition|;
name|newunit
operator|++
control|)
block|{
for|for
control|(
name|periph
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|p_drv
operator|->
name|units
argument_list|)
init|;
name|periph
operator|!=
name|NULL
operator|&&
name|periph
operator|->
name|unit_number
operator|!=
name|newunit
condition|;
name|periph
operator|=
name|TAILQ_NEXT
argument_list|(
name|periph
argument_list|,
name|unit_links
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
name|periph
operator|!=
name|NULL
operator|&&
name|periph
operator|->
name|unit_number
operator|==
name|newunit
condition|)
block|{
if|if
condition|(
name|wired
operator|!=
literal|0
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"Duplicate Wired "
literal|"Device entry!\n"
argument_list|)
expr_stmt|;
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"Second device (%s "
literal|"device at scbus%d target %d lun %d) will "
literal|"not be wired\n"
argument_list|,
name|periph_name
argument_list|,
name|pathid
argument_list|,
name|target
argument_list|,
name|lun
argument_list|)
expr_stmt|;
name|wired
operator|=
literal|0
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|wired
condition|)
break|break;
comment|/* 		 * Don't match entries like "da 4" as a wired down 		 * device, but do match entries like "da 4 target 5" 		 * or even "da 4 scbus 1".  		 */
name|i
operator|=
literal|0
expr_stmt|;
name|dname
operator|=
name|periph_name
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|r
operator|=
name|resource_find_dev
argument_list|(
operator|&
name|i
argument_list|,
name|dname
argument_list|,
operator|&
name|dunit
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
break|break;
comment|/* if no "target" and no specific scbus, skip */
if|if
condition|(
name|resource_int_value
argument_list|(
name|dname
argument_list|,
name|dunit
argument_list|,
literal|"target"
argument_list|,
operator|&
name|val
argument_list|)
operator|&&
operator|(
name|resource_string_value
argument_list|(
name|dname
argument_list|,
name|dunit
argument_list|,
literal|"at"
argument_list|,
operator|&
name|strval
argument_list|)
operator|||
name|strcmp
argument_list|(
name|strval
argument_list|,
literal|"scbus"
argument_list|)
operator|==
literal|0
operator|)
condition|)
continue|continue;
if|if
condition|(
name|newunit
operator|==
name|dunit
condition|)
break|break;
block|}
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|newunit
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|camperiphunit
parameter_list|(
name|struct
name|periph_driver
modifier|*
name|p_drv
parameter_list|,
name|path_id_t
name|pathid
parameter_list|,
name|target_id_t
name|target
parameter_list|,
name|lun_id_t
name|lun
parameter_list|)
block|{
name|u_int
name|unit
decl_stmt|;
name|int
name|wired
decl_stmt|,
name|i
decl_stmt|,
name|val
decl_stmt|,
name|dunit
decl_stmt|;
specifier|const
name|char
modifier|*
name|dname
decl_stmt|,
modifier|*
name|strval
decl_stmt|;
name|char
name|pathbuf
index|[
literal|32
index|]
decl_stmt|,
modifier|*
name|periph_name
decl_stmt|;
name|periph_name
operator|=
name|p_drv
operator|->
name|driver_name
expr_stmt|;
name|snprintf
argument_list|(
name|pathbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|pathbuf
argument_list|)
argument_list|,
literal|"scbus%d"
argument_list|,
name|pathid
argument_list|)
expr_stmt|;
name|unit
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|dname
operator|=
name|periph_name
expr_stmt|;
for|for
control|(
name|wired
operator|=
literal|0
init|;
name|resource_find_dev
argument_list|(
operator|&
name|i
argument_list|,
name|dname
argument_list|,
operator|&
name|dunit
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|;
name|wired
operator|=
literal|0
control|)
block|{
if|if
condition|(
name|resource_string_value
argument_list|(
name|dname
argument_list|,
name|dunit
argument_list|,
literal|"at"
argument_list|,
operator|&
name|strval
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|strval
argument_list|,
name|pathbuf
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|wired
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|resource_int_value
argument_list|(
name|dname
argument_list|,
name|dunit
argument_list|,
literal|"target"
argument_list|,
operator|&
name|val
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|val
operator|!=
name|target
condition|)
continue|continue;
name|wired
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|resource_int_value
argument_list|(
name|dname
argument_list|,
name|dunit
argument_list|,
literal|"lun"
argument_list|,
operator|&
name|val
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|val
operator|!=
name|lun
condition|)
continue|continue;
name|wired
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|wired
operator|!=
literal|0
condition|)
block|{
name|unit
operator|=
name|dunit
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * Either start from 0 looking for the next unit or from 	 * the unit number given in the resource config.  This way, 	 * if we have wildcard matches, we don't return the same 	 * unit number twice. 	 */
name|unit
operator|=
name|camperiphnextunit
argument_list|(
name|p_drv
argument_list|,
name|unit
argument_list|,
name|wired
argument_list|,
name|pathid
argument_list|,
name|target
argument_list|,
name|lun
argument_list|)
expr_stmt|;
return|return
operator|(
name|unit
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cam_periph_invalidate
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
comment|/* 	 * We only call this routine the first time a peripheral is 	 * invalidated.  The oninvalidate() routine is always called at 	 * splsoftcam(). 	 */
if|if
condition|(
operator|(
operator|(
name|periph
operator|->
name|flags
operator|&
name|CAM_PERIPH_INVALID
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|periph
operator|->
name|periph_oninval
operator|!=
name|NULL
operator|)
condition|)
name|periph
operator|->
name|periph_oninval
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|periph
operator|->
name|flags
operator||=
name|CAM_PERIPH_INVALID
expr_stmt|;
name|periph
operator|->
name|flags
operator|&=
operator|~
name|CAM_PERIPH_NEW_DEV_FOUND
expr_stmt|;
name|xpt_lock_buses
argument_list|()
expr_stmt|;
if|if
condition|(
name|periph
operator|->
name|refcount
operator|==
literal|0
condition|)
name|camperiphfree
argument_list|(
name|periph
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|periph
operator|->
name|refcount
operator|<
literal|0
condition|)
name|printf
argument_list|(
literal|"cam_invalidate_periph: refcount< 0!!\n"
argument_list|)
expr_stmt|;
name|xpt_unlock_buses
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|camperiphfree
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|struct
name|periph_driver
modifier|*
modifier|*
name|p_drv
decl_stmt|;
for|for
control|(
name|p_drv
operator|=
name|periph_drivers
init|;
operator|*
name|p_drv
operator|!=
name|NULL
condition|;
name|p_drv
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|(
operator|*
name|p_drv
operator|)
operator|->
name|driver_name
argument_list|,
name|periph
operator|->
name|periph_name
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
operator|*
name|p_drv
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"camperiphfree: attempt to free non-existant periph\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
operator|(
operator|*
name|p_drv
operator|)
operator|->
name|units
argument_list|,
name|periph
argument_list|,
name|unit_links
argument_list|)
expr_stmt|;
operator|(
operator|*
name|p_drv
operator|)
operator|->
name|generation
operator|++
expr_stmt|;
name|xpt_unlock_buses
argument_list|()
expr_stmt|;
if|if
condition|(
name|periph
operator|->
name|periph_dtor
operator|!=
name|NULL
condition|)
name|periph
operator|->
name|periph_dtor
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|xpt_remove_periph
argument_list|(
name|periph
argument_list|)
expr_stmt|;
if|if
condition|(
name|periph
operator|->
name|flags
operator|&
name|CAM_PERIPH_NEW_DEV_FOUND
condition|)
block|{
name|union
name|ccb
name|ccb
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
switch|switch
condition|(
name|periph
operator|->
name|deferred_ac
condition|)
block|{
case|case
name|AC_FOUND_DEVICE
case|:
name|ccb
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_GDEV_TYPE
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|ccb
operator|.
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|xpt_action
argument_list|(
operator|&
name|ccb
argument_list|)
expr_stmt|;
name|arg
operator|=
operator|&
name|ccb
expr_stmt|;
break|break;
case|case
name|AC_PATH_REGISTERED
case|:
name|ccb
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_PATH_INQ
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|ccb
operator|.
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|xpt_action
argument_list|(
operator|&
name|ccb
argument_list|)
expr_stmt|;
name|arg
operator|=
operator|&
name|ccb
expr_stmt|;
break|break;
default|default:
name|arg
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
name|periph
operator|->
name|deferred_callback
argument_list|(
name|NULL
argument_list|,
name|periph
operator|->
name|deferred_ac
argument_list|,
name|periph
operator|->
name|path
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
name|xpt_free_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|periph
argument_list|,
name|M_CAMPERIPH
argument_list|)
expr_stmt|;
name|xpt_lock_buses
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Map user virtual pointers into kernel virtual address space, so we can  * access the memory.  This won't work on physical pointers, for now it's  * up to the caller to check for that.  (XXX KDM -- should we do that here  * instead?)  This also only works for up to MAXPHYS memory.  Since we use  * buffers to map stuff in and out, we're limited to the buffer size.  */
end_comment

begin_function
name|int
name|cam_periph_mapmem
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|struct
name|cam_periph_map_info
modifier|*
name|mapinfo
parameter_list|)
block|{
name|int
name|numbufs
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|flags
index|[
name|CAM_PERIPH_MAXMAPS
index|]
decl_stmt|;
name|u_int8_t
modifier|*
modifier|*
name|data_ptrs
index|[
name|CAM_PERIPH_MAXMAPS
index|]
decl_stmt|;
name|u_int32_t
name|lengths
index|[
name|CAM_PERIPH_MAXMAPS
index|]
decl_stmt|;
name|u_int32_t
name|dirs
index|[
name|CAM_PERIPH_MAXMAPS
index|]
decl_stmt|;
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_DEV_MATCH
case|:
if|if
condition|(
name|ccb
operator|->
name|cdm
operator|.
name|match_buf_len
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"cam_periph_mapmem: invalid match buffer "
literal|"length 0\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|ccb
operator|->
name|cdm
operator|.
name|pattern_buf_len
operator|>
literal|0
condition|)
block|{
name|data_ptrs
index|[
literal|0
index|]
operator|=
operator|(
name|u_int8_t
operator|*
operator|*
operator|)
operator|&
name|ccb
operator|->
name|cdm
operator|.
name|patterns
expr_stmt|;
name|lengths
index|[
literal|0
index|]
operator|=
name|ccb
operator|->
name|cdm
operator|.
name|pattern_buf_len
expr_stmt|;
name|dirs
index|[
literal|0
index|]
operator|=
name|CAM_DIR_OUT
expr_stmt|;
name|data_ptrs
index|[
literal|1
index|]
operator|=
operator|(
name|u_int8_t
operator|*
operator|*
operator|)
operator|&
name|ccb
operator|->
name|cdm
operator|.
name|matches
expr_stmt|;
name|lengths
index|[
literal|1
index|]
operator|=
name|ccb
operator|->
name|cdm
operator|.
name|match_buf_len
expr_stmt|;
name|dirs
index|[
literal|1
index|]
operator|=
name|CAM_DIR_IN
expr_stmt|;
name|numbufs
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|data_ptrs
index|[
literal|0
index|]
operator|=
operator|(
name|u_int8_t
operator|*
operator|*
operator|)
operator|&
name|ccb
operator|->
name|cdm
operator|.
name|matches
expr_stmt|;
name|lengths
index|[
literal|0
index|]
operator|=
name|ccb
operator|->
name|cdm
operator|.
name|match_buf_len
expr_stmt|;
name|dirs
index|[
literal|0
index|]
operator|=
name|CAM_DIR_IN
expr_stmt|;
name|numbufs
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|XPT_SCSI_IO
case|:
case|case
name|XPT_CONT_TARGET_IO
case|:
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_NONE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|data_ptrs
index|[
literal|0
index|]
operator|=
operator|&
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
expr_stmt|;
name|lengths
index|[
literal|0
index|]
operator|=
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
expr_stmt|;
name|dirs
index|[
literal|0
index|]
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
expr_stmt|;
name|numbufs
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
comment|/* NOTREACHED */
block|}
comment|/* 	 * Check the transfer length and permissions first, so we don't 	 * have to unmap any previously mapped buffers. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numbufs
condition|;
name|i
operator|++
control|)
block|{
name|flags
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 		 * The userland data pointer passed in may not be page 		 * aligned.  vmapbuf() truncates the address to a page 		 * boundary, so if the address isn't page aligned, we'll 		 * need enough space for the given transfer length, plus 		 * whatever extra space is necessary to make it to the page 		 * boundary. 		 */
if|if
condition|(
operator|(
name|lengths
index|[
name|i
index|]
operator|+
operator|(
operator|(
call|(
name|vm_offset_t
call|)
argument_list|(
operator|*
name|data_ptrs
index|[
name|i
index|]
argument_list|)
operator|)
operator|&
name|PAGE_MASK
operator|)
operator|)
operator|>
name|DFLTPHYS
condition|)
block|{
name|printf
argument_list|(
literal|"cam_periph_mapmem: attempt to map %lu bytes, "
literal|"which is greater than DFLTPHYS(%d)\n"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|lengths
index|[
name|i
index|]
operator|+
operator|(
operator|(
call|(
name|vm_offset_t
call|)
argument_list|(
operator|*
name|data_ptrs
index|[
name|i
index|]
argument_list|)
operator|)
operator|&
name|PAGE_MASK
operator|)
argument_list|)
argument_list|,
name|DFLTPHYS
argument_list|)
expr_stmt|;
return|return
operator|(
name|E2BIG
operator|)
return|;
block|}
if|if
condition|(
name|dirs
index|[
name|i
index|]
operator|&
name|CAM_DIR_OUT
condition|)
block|{
name|flags
index|[
name|i
index|]
operator|=
name|BIO_WRITE
expr_stmt|;
block|}
if|if
condition|(
name|dirs
index|[
name|i
index|]
operator|&
name|CAM_DIR_IN
condition|)
block|{
name|flags
index|[
name|i
index|]
operator|=
name|BIO_READ
expr_stmt|;
block|}
block|}
comment|/* this keeps the current process from getting swapped */
comment|/* 	 * XXX KDM should I use P_NOSWAP instead? 	 */
name|PHOLD
argument_list|(
name|curproc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numbufs
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * Get the buffer. 		 */
name|mapinfo
operator|->
name|bp
index|[
name|i
index|]
operator|=
name|getpbuf
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* save the buffer's data address */
name|mapinfo
operator|->
name|bp
index|[
name|i
index|]
operator|->
name|b_saveaddr
operator|=
name|mapinfo
operator|->
name|bp
index|[
name|i
index|]
operator|->
name|b_data
expr_stmt|;
comment|/* put our pointer in the data slot */
name|mapinfo
operator|->
name|bp
index|[
name|i
index|]
operator|->
name|b_data
operator|=
operator|*
name|data_ptrs
index|[
name|i
index|]
expr_stmt|;
comment|/* set the transfer length, we know it's< DFLTPHYS */
name|mapinfo
operator|->
name|bp
index|[
name|i
index|]
operator|->
name|b_bufsize
operator|=
name|lengths
index|[
name|i
index|]
expr_stmt|;
comment|/* set the direction */
name|mapinfo
operator|->
name|bp
index|[
name|i
index|]
operator|->
name|b_iocmd
operator|=
name|flags
index|[
name|i
index|]
expr_stmt|;
comment|/* 		 * Map the buffer into kernel memory. 		 * 		 * Note that useracc() alone is not a  sufficient test. 		 * vmapbuf() can still fail due to a smaller file mapped 		 * into a larger area of VM, or if userland races against 		 * vmapbuf() after the useracc() check. 		 */
if|if
condition|(
name|vmapbuf
argument_list|(
name|mapinfo
operator|->
name|bp
index|[
name|i
index|]
argument_list|)
operator|<
literal|0
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
operator|++
name|j
control|)
block|{
operator|*
name|data_ptrs
index|[
name|j
index|]
operator|=
name|mapinfo
operator|->
name|bp
index|[
name|j
index|]
operator|->
name|b_saveaddr
expr_stmt|;
name|vunmapbuf
argument_list|(
name|mapinfo
operator|->
name|bp
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|relpbuf
argument_list|(
name|mapinfo
operator|->
name|bp
index|[
name|j
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|relpbuf
argument_list|(
name|mapinfo
operator|->
name|bp
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|PRELE
argument_list|(
name|curproc
argument_list|)
expr_stmt|;
return|return
operator|(
name|EACCES
operator|)
return|;
block|}
comment|/* set our pointer to the new mapped area */
operator|*
name|data_ptrs
index|[
name|i
index|]
operator|=
name|mapinfo
operator|->
name|bp
index|[
name|i
index|]
operator|->
name|b_data
expr_stmt|;
name|mapinfo
operator|->
name|num_bufs_used
operator|++
expr_stmt|;
block|}
comment|/* 	 * Now that we've gotten this far, change ownership to the kernel 	 * of the buffers so that we don't run afoul of returning to user 	 * space with locks (on the buffer) held. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numbufs
condition|;
name|i
operator|++
control|)
block|{
name|BUF_KERNPROC
argument_list|(
name|mapinfo
operator|->
name|bp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unmap memory segments mapped into kernel virtual address space by  * cam_periph_mapmem().  */
end_comment

begin_function
name|void
name|cam_periph_unmapmem
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|struct
name|cam_periph_map_info
modifier|*
name|mapinfo
parameter_list|)
block|{
name|int
name|numbufs
decl_stmt|,
name|i
decl_stmt|;
name|u_int8_t
modifier|*
modifier|*
name|data_ptrs
index|[
name|CAM_PERIPH_MAXMAPS
index|]
decl_stmt|;
if|if
condition|(
name|mapinfo
operator|->
name|num_bufs_used
operator|<=
literal|0
condition|)
block|{
comment|/* allow ourselves to be swapped once again */
name|PRELE
argument_list|(
name|curproc
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_DEV_MATCH
case|:
name|numbufs
operator|=
name|min
argument_list|(
name|mapinfo
operator|->
name|num_bufs_used
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|numbufs
operator|==
literal|1
condition|)
block|{
name|data_ptrs
index|[
literal|0
index|]
operator|=
operator|(
name|u_int8_t
operator|*
operator|*
operator|)
operator|&
name|ccb
operator|->
name|cdm
operator|.
name|matches
expr_stmt|;
block|}
else|else
block|{
name|data_ptrs
index|[
literal|0
index|]
operator|=
operator|(
name|u_int8_t
operator|*
operator|*
operator|)
operator|&
name|ccb
operator|->
name|cdm
operator|.
name|patterns
expr_stmt|;
name|data_ptrs
index|[
literal|1
index|]
operator|=
operator|(
name|u_int8_t
operator|*
operator|*
operator|)
operator|&
name|ccb
operator|->
name|cdm
operator|.
name|matches
expr_stmt|;
block|}
break|break;
case|case
name|XPT_SCSI_IO
case|:
case|case
name|XPT_CONT_TARGET_IO
case|:
name|data_ptrs
index|[
literal|0
index|]
operator|=
operator|&
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
expr_stmt|;
name|numbufs
operator|=
name|min
argument_list|(
name|mapinfo
operator|->
name|num_bufs_used
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* allow ourselves to be swapped once again */
name|PRELE
argument_list|(
name|curproc
argument_list|)
expr_stmt|;
return|return;
break|break;
comment|/* NOTREACHED */
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numbufs
condition|;
name|i
operator|++
control|)
block|{
comment|/* Set the user's pointer back to the original value */
operator|*
name|data_ptrs
index|[
name|i
index|]
operator|=
name|mapinfo
operator|->
name|bp
index|[
name|i
index|]
operator|->
name|b_saveaddr
expr_stmt|;
comment|/* unmap the buffer */
name|vunmapbuf
argument_list|(
name|mapinfo
operator|->
name|bp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* release the buffer */
name|relpbuf
argument_list|(
name|mapinfo
operator|->
name|bp
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* allow ourselves to be swapped once again */
name|PRELE
argument_list|(
name|curproc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|union
name|ccb
modifier|*
name|cam_periph_getccb
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|u_int32_t
name|priority
parameter_list|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
name|struct
name|mtx
modifier|*
name|mtx
decl_stmt|;
name|mtx_assert
argument_list|(
name|periph
operator|->
name|sim
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"entering cdgetccb\n"
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|SLIST_FIRST
argument_list|(
operator|&
name|periph
operator|->
name|ccb_list
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|periph
operator|->
name|immediate_priority
operator|>
name|priority
condition|)
name|periph
operator|->
name|immediate_priority
operator|=
name|priority
expr_stmt|;
name|xpt_schedule
argument_list|(
name|periph
argument_list|,
name|priority
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|SLIST_FIRST
argument_list|(
operator|&
name|periph
operator|->
name|ccb_list
argument_list|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|SLIST_FIRST
argument_list|(
operator|&
name|periph
operator|->
name|ccb_list
argument_list|)
operator|->
name|pinfo
operator|.
name|priority
operator|==
name|priority
operator|)
condition|)
break|break;
name|mtx_assert
argument_list|(
name|periph
operator|->
name|sim
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|periph
operator|->
name|sim
operator|->
name|mtx
operator|==
operator|&
name|Giant
condition|)
name|mtx
operator|=
name|NULL
expr_stmt|;
else|else
name|mtx
operator|=
name|periph
operator|->
name|sim
operator|->
name|mtx
expr_stmt|;
name|msleep
argument_list|(
operator|&
name|periph
operator|->
name|ccb_list
argument_list|,
name|mtx
argument_list|,
name|PRIBIO
argument_list|,
literal|"cgticb"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ccb_h
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|periph
operator|->
name|ccb_list
argument_list|)
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|periph
operator|->
name|ccb_list
argument_list|,
name|periph_links
operator|.
name|sle
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|ccb_h
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cam_periph_ccbwait
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|mtx
modifier|*
name|mtx
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splsoftcam
argument_list|()
expr_stmt|;
name|sim
operator|=
name|xpt_path_sim
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|sim
operator|->
name|mtx
operator|==
operator|&
name|Giant
condition|)
name|mtx
operator|=
name|NULL
expr_stmt|;
else|else
name|mtx
operator|=
name|sim
operator|->
name|mtx
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|pinfo
operator|.
name|index
operator|!=
name|CAM_UNQUEUED_INDEX
operator|)
operator|||
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_INPROG
operator|)
condition|)
name|msleep
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|.
name|cbfcnp
argument_list|,
name|mtx
argument_list|,
name|PRIBIO
argument_list|,
literal|"cbwait"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|cam_periph_ioctl
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
function_decl|(
modifier|*
name|error_routine
function_decl|)
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|cam_flags
name|camflags
parameter_list|,
name|u_int32_t
name|sense_flags
parameter_list|)
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|found
decl_stmt|;
name|error
operator|=
name|found
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|CAMGETPASSTHRU
case|:
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
comment|/* priority */
literal|1
argument_list|)
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_GDEVLIST
expr_stmt|;
comment|/* 		 * Basically, the point of this is that we go through 		 * getting the list of devices, until we find a passthrough 		 * device.  In the current version of the CAM code, the 		 * only way to determine what type of device we're dealing 		 * with is by its name. 		 */
while|while
condition|(
name|found
operator|==
literal|0
condition|)
block|{
name|ccb
operator|->
name|cgdl
operator|.
name|index
operator|=
literal|0
expr_stmt|;
name|ccb
operator|->
name|cgdl
operator|.
name|status
operator|=
name|CAM_GDEVLIST_MORE_DEVS
expr_stmt|;
while|while
condition|(
name|ccb
operator|->
name|cgdl
operator|.
name|status
operator|==
name|CAM_GDEVLIST_MORE_DEVS
condition|)
block|{
comment|/* we want the next device in the list */
name|xpt_action
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|ccb
operator|->
name|cgdl
operator|.
name|periph_name
argument_list|,
literal|"pass"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|cgdl
operator|.
name|status
operator|==
name|CAM_GDEVLIST_LAST_DEVICE
operator|)
operator|&&
operator|(
name|found
operator|==
literal|0
operator|)
condition|)
block|{
name|ccb
operator|->
name|cgdl
operator|.
name|periph_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ccb
operator|->
name|cgdl
operator|.
name|unit_number
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
comment|/* copy the result back out */
name|bcopy
argument_list|(
name|ccb
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|ccb
argument_list|)
argument_list|)
expr_stmt|;
comment|/* and release the ccb */
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ENOTTY
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cam_periph_runccb
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|int
function_decl|(
modifier|*
name|error_routine
function_decl|)
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|cam_flags
name|camflags
parameter_list|,
name|u_int32_t
name|sense_flags
parameter_list|)
parameter_list|,
name|cam_flags
name|camflags
parameter_list|,
name|u_int32_t
name|sense_flags
parameter_list|,
name|struct
name|devstat
modifier|*
name|ds
parameter_list|)
block|{
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|sim
operator|=
name|xpt_path_sim
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
name|sim
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * If the user has supplied a stats structure, and if we understand 	 * this particular type of ccb, record the transaction start. 	 */
if|if
condition|(
operator|(
name|ds
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_SCSI_IO
operator|)
condition|)
name|devstat_start_transaction
argument_list|(
name|ds
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xpt_action
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
do|do
block|{
name|cam_periph_ccbwait
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_CMP
condition|)
name|error
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|error_routine
operator|!=
name|NULL
condition|)
name|error
operator|=
call|(
modifier|*
name|error_routine
call|)
argument_list|(
name|ccb
argument_list|,
name|camflags
argument_list|,
name|sense_flags
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
name|error
operator|==
name|ERESTART
condition|)
do|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|!=
literal|0
condition|)
name|cam_release_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/* relsim_flags */
literal|0
argument_list|,
comment|/* openings */
literal|0
argument_list|,
comment|/* timeout */
literal|0
argument_list|,
comment|/* getcount_only */
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ds
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_SCSI_IO
operator|)
condition|)
name|devstat_end_transaction
argument_list|(
name|ds
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|tag_action
operator|&
literal|0xf
argument_list|,
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_NONE
operator|)
condition|?
name|DEVSTAT_NO_DATA
else|:
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_OUT
operator|)
condition|?
name|DEVSTAT_WRITE
else|:
name|DEVSTAT_READ
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cam_freeze_devq
parameter_list|(
name|struct
name|cam_path
modifier|*
name|path
parameter_list|)
block|{
name|struct
name|ccb_hdr
name|ccb_h
decl_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|ccb_h
argument_list|,
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_NOOP
expr_stmt|;
name|ccb_h
operator|.
name|flags
operator|=
name|CAM_DEV_QFREEZE
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|ccb_h
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|u_int32_t
name|cam_release_devq
parameter_list|(
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|u_int32_t
name|relsim_flags
parameter_list|,
name|u_int32_t
name|openings
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|,
name|int
name|getcount_only
parameter_list|)
block|{
name|struct
name|ccb_relsim
name|crs
decl_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|crs
operator|.
name|ccb_h
argument_list|,
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|crs
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_REL_SIMQ
expr_stmt|;
name|crs
operator|.
name|ccb_h
operator|.
name|flags
operator|=
name|getcount_only
condition|?
name|CAM_DEV_QFREEZE
else|:
literal|0
expr_stmt|;
name|crs
operator|.
name|release_flags
operator|=
name|relsim_flags
expr_stmt|;
name|crs
operator|.
name|openings
operator|=
name|openings
expr_stmt|;
name|crs
operator|.
name|release_timeout
operator|=
name|timeout
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|crs
argument_list|)
expr_stmt|;
return|return
operator|(
name|crs
operator|.
name|qfrozen_cnt
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|saved_ccb_ptr
value|ppriv_ptr0
end_define

begin_function
specifier|static
name|void
name|camperiphdone
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|done_ccb
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|saved_ccb
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|int
name|frozen
decl_stmt|;
name|int
name|sense
decl_stmt|;
name|struct
name|scsi_start_stop_unit
modifier|*
name|scsi_cmd
decl_stmt|;
name|u_int32_t
name|relsim_flags
decl_stmt|,
name|timeout
decl_stmt|;
name|u_int32_t
name|qfrozen_cnt
decl_stmt|;
name|int
name|xpt_done_ccb
decl_stmt|;
name|xpt_done_ccb
operator|=
name|FALSE
expr_stmt|;
name|status
operator|=
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
expr_stmt|;
name|frozen
operator|=
operator|(
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|!=
literal|0
expr_stmt|;
name|sense
operator|=
operator|(
name|status
operator|&
name|CAM_AUTOSNS_VALID
operator|)
operator|!=
literal|0
expr_stmt|;
name|status
operator|&=
name|CAM_STATUS_MASK
expr_stmt|;
name|timeout
operator|=
literal|0
expr_stmt|;
name|relsim_flags
operator|=
literal|0
expr_stmt|;
name|saved_ccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|done_ccb
operator|->
name|ccb_h
operator|.
name|saved_ccb_ptr
expr_stmt|;
comment|/*  	 * Unfreeze the queue once if it is already frozen.. 	 */
if|if
condition|(
name|frozen
operator|!=
literal|0
condition|)
block|{
name|qfrozen_cnt
operator|=
name|cam_release_devq
argument_list|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*relsim_flags*/
literal|0
argument_list|,
comment|/*openings*/
literal|0
argument_list|,
comment|/*timeout*/
literal|0
argument_list|,
comment|/*getcount_only*/
literal|0
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|CAM_REQ_CMP
case|:
block|{
comment|/* 		 * If we have successfully taken a device from the not 		 * ready to ready state, re-scan the device and re-get 		 * the inquiry information.  Many devices (mostly disks) 		 * don't properly report their inquiry information unless 		 * they are spun up. 		 * 		 * If we manually retrieved sense into a CCB and got 		 * something other than "NO SENSE" send the updated CCB 		 * back to the client via xpt_done() to be processed via 		 * the error recovery code again. 		 */
if|if
condition|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_SCSI_IO
condition|)
block|{
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_start_stop_unit
operator|*
operator|)
operator|&
name|done_ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
if|if
condition|(
name|scsi_cmd
operator|->
name|opcode
operator|==
name|START_STOP_UNIT
condition|)
name|xpt_async
argument_list|(
name|AC_INQ_CHANGED
argument_list|,
name|done_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|scsi_cmd
operator|->
name|opcode
operator|==
name|REQUEST_SENSE
condition|)
block|{
name|u_int
name|sense_key
decl_stmt|;
name|sense_key
operator|=
name|saved_ccb
operator|->
name|csio
operator|.
name|sense_data
operator|.
name|flags
expr_stmt|;
name|sense_key
operator|&=
name|SSD_KEY
expr_stmt|;
if|if
condition|(
name|sense_key
operator|!=
name|SSD_KEY_NO_SENSE
condition|)
block|{
name|saved_ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_AUTOSNS_VALID
expr_stmt|;
if|#
directive|if
literal|0
block|xpt_print(saved_ccb->ccb_h.path, 					    "Recovered Sense\n"); 					scsi_sense_print(&saved_ccb->csio); 					cam_error_print(saved_ccb, CAM_ESF_ALL, 							CAM_EPF_ALL);
endif|#
directive|endif
name|xpt_done_ccb
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
name|bcopy
argument_list|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|saved_ccb_ptr
argument_list|,
name|done_ccb
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|ccb
argument_list|)
argument_list|)
expr_stmt|;
name|periph
operator|->
name|flags
operator|&=
operator|~
name|CAM_PERIPH_RECOVERY_INPROG
expr_stmt|;
if|if
condition|(
name|xpt_done_ccb
operator|==
name|FALSE
condition|)
name|xpt_action
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CAM_SCSI_STATUS_ERROR
case|:
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_start_stop_unit
operator|*
operator|)
operator|&
name|done_ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
if|if
condition|(
name|sense
operator|!=
literal|0
condition|)
block|{
name|struct
name|ccb_getdev
name|cgd
decl_stmt|;
name|struct
name|scsi_sense_data
modifier|*
name|sense
decl_stmt|;
name|int
name|error_code
decl_stmt|,
name|sense_key
decl_stmt|,
name|asc
decl_stmt|,
name|ascq
decl_stmt|;
name|scsi_sense_action
name|err_action
decl_stmt|;
name|sense
operator|=
operator|&
name|done_ccb
operator|->
name|csio
operator|.
name|sense_data
expr_stmt|;
name|scsi_extract_sense
argument_list|(
name|sense
argument_list|,
operator|&
name|error_code
argument_list|,
operator|&
name|sense_key
argument_list|,
operator|&
name|asc
argument_list|,
operator|&
name|ascq
argument_list|)
expr_stmt|;
comment|/* 			 * Grab the inquiry data for this device. 			 */
name|xpt_setup_ccb
argument_list|(
operator|&
name|cgd
operator|.
name|ccb_h
argument_list|,
name|done_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|cgd
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_GDEV_TYPE
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|cgd
argument_list|)
expr_stmt|;
name|err_action
operator|=
name|scsi_error_action
argument_list|(
operator|&
name|done_ccb
operator|->
name|csio
argument_list|,
operator|&
name|cgd
operator|.
name|inq_data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 		 * If the error is "invalid field in CDB",  			 * and the load/eject flag is set, turn the  			 * flag off and try again.  This is just in  			 * case the drive in question barfs on the  			 * load eject flag.  The CAM code should set  			 * the load/eject flag by default for  			 * removable media. 			 */
comment|/* XXX KDM  			 * Should we check to see what the specific 			 * scsi status is??  Or does it not matter 			 * since we already know that there was an 			 * error, and we know what the specific 			 * error code was, and we know what the 			 * opcode is.. 			 */
if|if
condition|(
operator|(
name|scsi_cmd
operator|->
name|opcode
operator|==
name|START_STOP_UNIT
operator|)
operator|&&
operator|(
operator|(
name|scsi_cmd
operator|->
name|how
operator|&
name|SSS_LOEJ
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|asc
operator|==
literal|0x24
operator|)
operator|&&
operator|(
name|ascq
operator|==
literal|0x00
operator|)
operator|&&
operator|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|retry_count
operator|>
literal|0
operator|)
condition|)
block|{
name|scsi_cmd
operator|->
name|how
operator|&=
operator|~
name|SSS_LOEJ
expr_stmt|;
name|xpt_action
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|retry_count
operator|>
literal|1
operator|)
operator|&&
operator|(
operator|(
name|err_action
operator|&
name|SS_MASK
operator|)
operator|!=
name|SS_FAIL
operator|)
condition|)
block|{
comment|/* 				 * In this case, the error recovery 				 * command failed, but we've got  				 * some retries left on it.  Give 				 * it another try unless this is an 				 * unretryable error. 				 */
comment|/* set the timeout to .5 sec */
name|relsim_flags
operator|=
name|RELSIM_RELEASE_AFTER_TIMEOUT
expr_stmt|;
name|timeout
operator|=
literal|500
expr_stmt|;
name|xpt_action
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/*  				 * Perform the final retry with the original 				 * CCB so that final error processing is 				 * performed by the owner of the CCB. 				 */
name|bcopy
argument_list|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|saved_ccb_ptr
argument_list|,
name|done_ccb
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|ccb
argument_list|)
argument_list|)
expr_stmt|;
name|periph
operator|->
name|flags
operator|&=
operator|~
name|CAM_PERIPH_RECOVERY_INPROG
expr_stmt|;
name|xpt_action
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * Eh??  The command failed, but we don't 			 * have any sense.  What's up with that? 			 * Fire the CCB again to return it to the 			 * caller. 			 */
name|bcopy
argument_list|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|saved_ccb_ptr
argument_list|,
name|done_ccb
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|ccb
argument_list|)
argument_list|)
expr_stmt|;
name|periph
operator|->
name|flags
operator|&=
operator|~
name|CAM_PERIPH_RECOVERY_INPROG
expr_stmt|;
name|xpt_action
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|bcopy
argument_list|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|saved_ccb_ptr
argument_list|,
name|done_ccb
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|ccb
argument_list|)
argument_list|)
expr_stmt|;
name|periph
operator|->
name|flags
operator|&=
operator|~
name|CAM_PERIPH_RECOVERY_INPROG
expr_stmt|;
name|xpt_action
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* decrement the retry count */
comment|/* 	 * XXX This isn't appropriate in all cases.  Restructure, 	 *     so that the retry count is only decremented on an 	 *     actual retry.  Remeber that the orignal ccb had its 	 *     retry count dropped before entering recovery, so 	 *     doing it again is a bug. 	 */
if|if
condition|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|retry_count
operator|>
literal|0
condition|)
name|done_ccb
operator|->
name|ccb_h
operator|.
name|retry_count
operator|--
expr_stmt|;
name|qfrozen_cnt
operator|=
name|cam_release_devq
argument_list|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*relsim_flags*/
name|relsim_flags
argument_list|,
comment|/*openings*/
literal|0
argument_list|,
comment|/*timeout*/
name|timeout
argument_list|,
comment|/*getcount_only*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|xpt_done_ccb
operator|==
name|TRUE
condition|)
call|(
modifier|*
name|done_ccb
operator|->
name|ccb_h
operator|.
name|cbfcnp
call|)
argument_list|(
name|periph
argument_list|,
name|done_ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Generic Async Event handler.  Peripheral drivers usually  * filter out the events that require personal attention,  * and leave the rest to this function.  */
end_comment

begin_function
name|void
name|cam_periph_async
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|u_int32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|AC_LOST_DEVICE
case|:
name|cam_periph_invalidate
argument_list|(
name|periph
argument_list|)
expr_stmt|;
break|break;
case|case
name|AC_SENT_BDR
case|:
case|case
name|AC_BUS_RESET
case|:
block|{
name|cam_periph_bus_settle
argument_list|(
name|periph
argument_list|,
name|scsi_delay
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
block|}
end_function

begin_function
name|void
name|cam_periph_bus_settle
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|u_int
name|bus_settle
parameter_list|)
block|{
name|struct
name|ccb_getdevstats
name|cgds
decl_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|cgds
operator|.
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|cgds
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_GDEV_STATS
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|cgds
argument_list|)
expr_stmt|;
name|cam_periph_freeze_after_event
argument_list|(
name|periph
argument_list|,
operator|&
name|cgds
operator|.
name|last_reset
argument_list|,
name|bus_settle
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cam_periph_freeze_after_event
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|timeval
modifier|*
name|event_time
parameter_list|,
name|u_int
name|duration_ms
parameter_list|)
block|{
name|struct
name|timeval
name|delta
decl_stmt|;
name|struct
name|timeval
name|duration_tv
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splclock
argument_list|()
expr_stmt|;
name|microtime
argument_list|(
operator|&
name|delta
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|delta
argument_list|,
name|event_time
argument_list|)
expr_stmt|;
name|duration_tv
operator|.
name|tv_sec
operator|=
name|duration_ms
operator|/
literal|1000
expr_stmt|;
name|duration_tv
operator|.
name|tv_usec
operator|=
operator|(
name|duration_ms
operator|%
literal|1000
operator|)
operator|*
literal|1000
expr_stmt|;
if|if
condition|(
name|timevalcmp
argument_list|(
operator|&
name|delta
argument_list|,
operator|&
name|duration_tv
argument_list|,
operator|<
argument_list|)
condition|)
block|{
name|timevalsub
argument_list|(
operator|&
name|duration_tv
argument_list|,
operator|&
name|delta
argument_list|)
expr_stmt|;
name|duration_ms
operator|=
name|duration_tv
operator|.
name|tv_sec
operator|*
literal|1000
expr_stmt|;
name|duration_ms
operator|+=
name|duration_tv
operator|.
name|tv_usec
operator|/
literal|1000
expr_stmt|;
name|cam_freeze_devq
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|cam_release_devq
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|RELSIM_RELEASE_AFTER_TIMEOUT
argument_list|,
comment|/*reduction*/
literal|0
argument_list|,
comment|/*timeout*/
name|duration_ms
argument_list|,
comment|/*getcount_only*/
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|camperiphscsistatuserror
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|cam_flags
name|camflags
parameter_list|,
name|u_int32_t
name|sense_flags
parameter_list|,
name|union
name|ccb
modifier|*
name|save_ccb
parameter_list|,
name|int
modifier|*
name|openings
parameter_list|,
name|u_int32_t
modifier|*
name|relsim_flags
parameter_list|,
name|u_int32_t
modifier|*
name|timeout
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
switch|switch
condition|(
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
condition|)
block|{
case|case
name|SCSI_STATUS_OK
case|:
case|case
name|SCSI_STATUS_COND_MET
case|:
case|case
name|SCSI_STATUS_INTERMED
case|:
case|case
name|SCSI_STATUS_INTERMED_COND_MET
case|:
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SCSI_STATUS_CMD_TERMINATED
case|:
case|case
name|SCSI_STATUS_CHECK_COND
case|:
name|error
operator|=
name|camperiphscsisenseerror
argument_list|(
name|ccb
argument_list|,
name|camflags
argument_list|,
name|sense_flags
argument_list|,
name|save_ccb
argument_list|,
name|openings
argument_list|,
name|relsim_flags
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCSI_STATUS_QUEUE_FULL
case|:
block|{
comment|/* no decrement */
name|struct
name|ccb_getdevstats
name|cgds
decl_stmt|;
comment|/* 		 * First off, find out what the current 		 * transaction counts are. 		 */
name|xpt_setup_ccb
argument_list|(
operator|&
name|cgds
operator|.
name|ccb_h
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|cgds
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_GDEV_STATS
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|cgds
argument_list|)
expr_stmt|;
comment|/* 		 * If we were the only transaction active, treat 		 * the QUEUE FULL as if it were a BUSY condition. 		 */
if|if
condition|(
name|cgds
operator|.
name|dev_active
operator|!=
literal|0
condition|)
block|{
name|int
name|total_openings
decl_stmt|;
comment|/* 		 	 * Reduce the number of openings to 			 * be 1 less than the amount it took 			 * to get a queue full bounded by the 			 * minimum allowed tag count for this 			 * device. 		 	 */
name|total_openings
operator|=
name|cgds
operator|.
name|dev_active
operator|+
name|cgds
operator|.
name|dev_openings
expr_stmt|;
operator|*
name|openings
operator|=
name|cgds
operator|.
name|dev_active
expr_stmt|;
if|if
condition|(
operator|*
name|openings
operator|<
name|cgds
operator|.
name|mintags
condition|)
operator|*
name|openings
operator|=
name|cgds
operator|.
name|mintags
expr_stmt|;
if|if
condition|(
operator|*
name|openings
operator|<
name|total_openings
condition|)
operator|*
name|relsim_flags
operator|=
name|RELSIM_ADJUST_OPENINGS
expr_stmt|;
else|else
block|{
comment|/* 				 * Some devices report queue full for 				 * temporary resource shortages.  For 				 * this reason, we allow a minimum 				 * tag count to be entered via a 				 * quirk entry to prevent the queue 				 * count on these devices from falling 				 * to a pessimisticly low value.  We 				 * still wait for the next successful 				 * completion, however, before queueing 				 * more transactions to the device. 				 */
operator|*
name|relsim_flags
operator|=
name|RELSIM_RELEASE_AFTER_CMDCMPLT
expr_stmt|;
block|}
operator|*
name|timeout
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|ERESTART
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"Queue Full\n"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* FALLTHROUGH */
block|}
case|case
name|SCSI_STATUS_BUSY
case|:
comment|/* 		 * Restart the queue after either another 		 * command completes or a 1 second timeout. 		 */
if|if
condition|(
name|bootverbose
condition|)
block|{
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"Device Busy\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|retry_count
operator|>
literal|0
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|retry_count
operator|--
expr_stmt|;
name|error
operator|=
name|ERESTART
expr_stmt|;
operator|*
name|relsim_flags
operator|=
name|RELSIM_RELEASE_AFTER_TIMEOUT
operator||
name|RELSIM_RELEASE_AFTER_CMDCMPLT
expr_stmt|;
operator|*
name|timeout
operator|=
literal|1000
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|EIO
expr_stmt|;
block|}
break|break;
case|case
name|SCSI_STATUS_RESERV_CONFLICT
case|:
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"Reservation Conflict\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
break|break;
default|default:
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"SCSI Status 0x%x\n"
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|camperiphscsisenseerror
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|cam_flags
name|camflags
parameter_list|,
name|u_int32_t
name|sense_flags
parameter_list|,
name|union
name|ccb
modifier|*
name|save_ccb
parameter_list|,
name|int
modifier|*
name|openings
parameter_list|,
name|u_int32_t
modifier|*
name|relsim_flags
parameter_list|,
name|u_int32_t
modifier|*
name|timeout
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|int
name|error
decl_stmt|;
name|periph
operator|=
name|xpt_path_periph
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|periph
operator|->
name|flags
operator|&
name|CAM_PERIPH_RECOVERY_INPROG
condition|)
block|{
comment|/* 		 * If error recovery is already in progress, don't attempt 		 * to process this error, but requeue it unconditionally 		 * and attempt to process it once error recovery has 		 * completed.  This failed command is probably related to 		 * the error that caused the currently active error recovery 		 * action so our  current recovery efforts should also 		 * address this command.  Be aware that the error recovery 		 * code assumes that only one recovery action is in progress 		 * on a particular peripheral instance at any given time 		 * (e.g. only one saved CCB for error recovery) so it is 		 * imperitive that we don't violate this assumption. 		 */
name|error
operator|=
name|ERESTART
expr_stmt|;
block|}
else|else
block|{
name|scsi_sense_action
name|err_action
decl_stmt|;
name|struct
name|ccb_getdev
name|cgd
decl_stmt|;
specifier|const
name|char
modifier|*
name|action_string
decl_stmt|;
name|union
name|ccb
modifier|*
name|print_ccb
decl_stmt|;
comment|/* A description of the error recovery action performed */
name|action_string
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * The location of the orignal ccb 		 * for sense printing purposes. 		 */
name|print_ccb
operator|=
name|ccb
expr_stmt|;
comment|/* 		 * Grab the inquiry data for this device. 		 */
name|xpt_setup_ccb
argument_list|(
operator|&
name|cgd
operator|.
name|ccb_h
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|cgd
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_GDEV_TYPE
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|cgd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_AUTOSNS_VALID
operator|)
operator|!=
literal|0
condition|)
name|err_action
operator|=
name|scsi_error_action
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
operator|&
name|cgd
operator|.
name|inq_data
argument_list|,
name|sense_flags
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIS_AUTOSENSE
operator|)
operator|==
literal|0
condition|)
name|err_action
operator|=
name|SS_REQSENSE
expr_stmt|;
else|else
name|err_action
operator|=
name|SS_RETRY
operator||
name|SSQ_DECREMENT_COUNT
operator||
name|EIO
expr_stmt|;
name|error
operator|=
name|err_action
operator|&
name|SS_ERRMASK
expr_stmt|;
comment|/* 		 * If the recovery action will consume a retry, 		 * make sure we actually have retries available. 		 */
if|if
condition|(
operator|(
name|err_action
operator|&
name|SSQ_DECREMENT_COUNT
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|retry_count
operator|>
literal|0
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|retry_count
operator|--
expr_stmt|;
else|else
block|{
name|action_string
operator|=
literal|"Retries Exhausted"
expr_stmt|;
goto|goto
name|sense_error_done
goto|;
block|}
block|}
if|if
condition|(
operator|(
name|err_action
operator|&
name|SS_MASK
operator|)
operator|>=
name|SS_START
condition|)
block|{
comment|/* 			 * Do common portions of commands that 			 * use recovery CCBs. 			 */
if|if
condition|(
name|save_ccb
operator|==
name|NULL
condition|)
block|{
name|action_string
operator|=
literal|"No recovery CCB supplied"
expr_stmt|;
goto|goto
name|sense_error_done
goto|;
block|}
name|bcopy
argument_list|(
name|ccb
argument_list|,
name|save_ccb
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|save_ccb
argument_list|)
argument_list|)
expr_stmt|;
name|print_ccb
operator|=
name|save_ccb
expr_stmt|;
name|periph
operator|->
name|flags
operator||=
name|CAM_PERIPH_RECOVERY_INPROG
expr_stmt|;
block|}
switch|switch
condition|(
name|err_action
operator|&
name|SS_MASK
condition|)
block|{
case|case
name|SS_NOP
case|:
name|action_string
operator|=
literal|"No Recovery Action Needed"
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SS_RETRY
case|:
name|action_string
operator|=
literal|"Retrying Command (per Sense Data)"
expr_stmt|;
name|error
operator|=
name|ERESTART
expr_stmt|;
break|break;
case|case
name|SS_FAIL
case|:
name|action_string
operator|=
literal|"Unretryable error"
expr_stmt|;
break|break;
case|case
name|SS_START
case|:
block|{
name|int
name|le
decl_stmt|;
comment|/* 			 * Send a start unit command to the device, and 			 * then retry the command. 			 */
name|action_string
operator|=
literal|"Attempting to Start Unit"
expr_stmt|;
comment|/* 			 * Check for removable media and set 			 * load/eject flag appropriately. 			 */
if|if
condition|(
name|SID_IS_REMOVABLE
argument_list|(
operator|&
name|cgd
operator|.
name|inq_data
argument_list|)
condition|)
name|le
operator|=
name|TRUE
expr_stmt|;
else|else
name|le
operator|=
name|FALSE
expr_stmt|;
name|scsi_start_stop
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/*retries*/
literal|1
argument_list|,
name|camperiphdone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*start*/
name|TRUE
argument_list|,
comment|/*load/eject*/
name|le
argument_list|,
comment|/*immediate*/
name|FALSE
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
comment|/*timeout*/
literal|50000
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SS_TUR
case|:
block|{
comment|/* 			 * Send a Test Unit Ready to the device. 			 * If the 'many' flag is set, we send 120 			 * test unit ready commands, one every half  			 * second.  Otherwise, we just send one TUR. 			 * We only want to do this if the retry  			 * count has not been exhausted. 			 */
name|int
name|retries
decl_stmt|;
if|if
condition|(
operator|(
name|err_action
operator|&
name|SSQ_MANY
operator|)
operator|!=
literal|0
condition|)
block|{
name|action_string
operator|=
literal|"Polling device for readiness"
expr_stmt|;
name|retries
operator|=
literal|120
expr_stmt|;
block|}
else|else
block|{
name|action_string
operator|=
literal|"Testing device for readiness"
expr_stmt|;
name|retries
operator|=
literal|1
expr_stmt|;
block|}
name|scsi_test_unit_ready
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
name|retries
argument_list|,
name|camperiphdone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
comment|/*timeout*/
literal|5000
argument_list|)
expr_stmt|;
comment|/* 			 * Accomplish our 500ms delay by deferring 			 * the release of our device queue appropriately. 			 */
operator|*
name|relsim_flags
operator|=
name|RELSIM_RELEASE_AFTER_TIMEOUT
expr_stmt|;
operator|*
name|timeout
operator|=
literal|500
expr_stmt|;
break|break;
block|}
case|case
name|SS_REQSENSE
case|:
block|{
comment|/* 			 * Send a Request Sense to the device.  We 			 * assume that we are in a contingent allegiance 			 * condition so we do not tag this request. 			 */
name|scsi_request_sense
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/*retries*/
literal|1
argument_list|,
name|camperiphdone
argument_list|,
operator|&
name|save_ccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|,
sizeof|sizeof
argument_list|(
name|save_ccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|)
argument_list|,
name|CAM_TAG_ACTION_NONE
argument_list|,
comment|/*sense_len*/
name|SSD_FULL_SIZE
argument_list|,
comment|/*timeout*/
literal|5000
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|panic
argument_list|(
literal|"Unhandled error action %x"
argument_list|,
name|err_action
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|err_action
operator|&
name|SS_MASK
operator|)
operator|>=
name|SS_START
condition|)
block|{
comment|/* 			 * Drop the priority to 0 so that the recovery 			 * CCB is the first to execute.  Freeze the queue 			 * after this command is sent so that we can 			 * restore the old csio and have it queued in 			 * the proper order before we release normal  			 * transactions to the device. 			 */
name|ccb
operator|->
name|ccb_h
operator|.
name|pinfo
operator|.
name|priority
operator|=
literal|0
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFREEZE
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|saved_ccb_ptr
operator|=
name|save_ccb
expr_stmt|;
name|error
operator|=
name|ERESTART
expr_stmt|;
block|}
name|sense_error_done
label|:
if|if
condition|(
operator|(
name|err_action
operator|&
name|SSQ_PRINT_SENSE
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_AUTOSNS_VALID
operator|)
operator|!=
literal|0
condition|)
block|{
name|cam_error_print
argument_list|(
name|print_ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|)
expr_stmt|;
name|xpt_print_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|scsi_sense_print
argument_list|(
operator|&
name|print_ccb
operator|->
name|csio
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|action_string
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generic error handler.  Peripheral drivers usually filter  * out the errors that they handle in a unique mannor, then  * call this function.  */
end_comment

begin_function
name|int
name|cam_periph_error
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|cam_flags
name|camflags
parameter_list|,
name|u_int32_t
name|sense_flags
parameter_list|,
name|union
name|ccb
modifier|*
name|save_ccb
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|action_string
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|int
name|frozen
decl_stmt|;
name|int
name|error
decl_stmt|,
name|printed
init|=
literal|0
decl_stmt|;
name|int
name|openings
decl_stmt|;
name|u_int32_t
name|relsim_flags
decl_stmt|;
name|u_int32_t
name|timeout
init|=
literal|0
decl_stmt|;
name|action_string
operator|=
name|NULL
expr_stmt|;
name|status
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|status
expr_stmt|;
name|frozen
operator|=
operator|(
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|!=
literal|0
expr_stmt|;
name|status
operator|&=
name|CAM_STATUS_MASK
expr_stmt|;
name|openings
operator|=
name|relsim_flags
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|CAM_REQ_CMP
case|:
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CAM_SCSI_STATUS_ERROR
case|:
name|error
operator|=
name|camperiphscsistatuserror
argument_list|(
name|ccb
argument_list|,
name|camflags
argument_list|,
name|sense_flags
argument_list|,
name|save_ccb
argument_list|,
operator|&
name|openings
argument_list|,
operator|&
name|relsim_flags
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_AUTOSENSE_FAIL
case|:
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"AutoSense Failed\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
comment|/* we have to kill the command */
break|break;
case|case
name|CAM_REQ_CMP_ERR
case|:
if|if
condition|(
name|bootverbose
operator|&&
name|printed
operator|==
literal|0
condition|)
block|{
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"Request completed with CAM_REQ_CMP_ERR\n"
argument_list|)
expr_stmt|;
name|printed
operator|++
expr_stmt|;
block|}
comment|/* FALLTHROUGH */
case|case
name|CAM_CMD_TIMEOUT
case|:
if|if
condition|(
name|bootverbose
operator|&&
name|printed
operator|==
literal|0
condition|)
block|{
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"Command timed out\n"
argument_list|)
expr_stmt|;
name|printed
operator|++
expr_stmt|;
block|}
comment|/* FALLTHROUGH */
case|case
name|CAM_UNEXP_BUSFREE
case|:
if|if
condition|(
name|bootverbose
operator|&&
name|printed
operator|==
literal|0
condition|)
block|{
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"Unexpected Bus Free\n"
argument_list|)
expr_stmt|;
name|printed
operator|++
expr_stmt|;
block|}
comment|/* FALLTHROUGH */
case|case
name|CAM_UNCOR_PARITY
case|:
if|if
condition|(
name|bootverbose
operator|&&
name|printed
operator|==
literal|0
condition|)
block|{
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"Uncorrected Parity Error\n"
argument_list|)
expr_stmt|;
name|printed
operator|++
expr_stmt|;
block|}
comment|/* FALLTHROUGH */
case|case
name|CAM_DATA_RUN_ERR
case|:
if|if
condition|(
name|bootverbose
operator|&&
name|printed
operator|==
literal|0
condition|)
block|{
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"Data Overrun\n"
argument_list|)
expr_stmt|;
name|printed
operator|++
expr_stmt|;
block|}
name|error
operator|=
name|EIO
expr_stmt|;
comment|/* we have to kill the command */
comment|/* decrement the number of retries */
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|retry_count
operator|>
literal|0
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|retry_count
operator|--
expr_stmt|;
name|error
operator|=
name|ERESTART
expr_stmt|;
block|}
else|else
block|{
name|action_string
operator|=
literal|"Retries Exausted"
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
block|}
break|break;
case|case
name|CAM_UA_ABORT
case|:
case|case
name|CAM_UA_TERMIO
case|:
case|case
name|CAM_MSG_REJECT_REC
case|:
comment|/* XXX Don't know that these are correct */
name|error
operator|=
name|EIO
expr_stmt|;
break|break;
case|case
name|CAM_SEL_TIMEOUT
case|:
block|{
name|struct
name|cam_path
modifier|*
name|newpath
decl_stmt|;
if|if
condition|(
operator|(
name|camflags
operator|&
name|CAM_RETRY_SELTO
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|retry_count
operator|>
literal|0
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|retry_count
operator|--
expr_stmt|;
name|error
operator|=
name|ERESTART
expr_stmt|;
if|if
condition|(
name|bootverbose
operator|&&
name|printed
operator|==
literal|0
condition|)
block|{
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"Selection Timeout\n"
argument_list|)
expr_stmt|;
name|printed
operator|++
expr_stmt|;
block|}
comment|/* 				 * Wait a bit to give the device 				 * time to recover before we try again. 				 */
name|relsim_flags
operator|=
name|RELSIM_RELEASE_AFTER_TIMEOUT
expr_stmt|;
name|timeout
operator|=
name|periph_selto_delay
expr_stmt|;
break|break;
block|}
block|}
name|error
operator|=
name|ENXIO
expr_stmt|;
comment|/* Should we do more if we can't create the path?? */
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|newpath
argument_list|,
name|xpt_path_periph
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
argument_list|,
name|xpt_path_path_id
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
argument_list|,
name|xpt_path_target_id
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
break|break;
comment|/* 		 * Let peripheral drivers know that this device has gone 		 * away. 		 */
name|xpt_async
argument_list|(
name|AC_LOST_DEVICE
argument_list|,
name|newpath
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|newpath
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CAM_REQ_INVALID
case|:
case|case
name|CAM_PATH_INVALID
case|:
case|case
name|CAM_DEV_NOT_THERE
case|:
case|case
name|CAM_NO_HBA
case|:
case|case
name|CAM_PROVIDE_FAIL
case|:
case|case
name|CAM_REQ_TOO_BIG
case|:
case|case
name|CAM_LUN_INVALID
case|:
case|case
name|CAM_TID_INVALID
case|:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|CAM_SCSI_BUS_RESET
case|:
case|case
name|CAM_BDR_SENT
case|:
comment|/* 		 * Commands that repeatedly timeout and cause these 		 * kinds of error recovery actions, should return 		 * CAM_CMD_TIMEOUT, which allows us to safely assume 		 * that this command was an innocent bystander to 		 * these events and should be unconditionally 		 * retried. 		 */
if|if
condition|(
name|bootverbose
operator|&&
name|printed
operator|==
literal|0
condition|)
block|{
name|xpt_print_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|CAM_BDR_SENT
condition|)
name|printf
argument_list|(
literal|"Bus Device Reset sent\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Bus Reset issued\n"
argument_list|)
expr_stmt|;
name|printed
operator|++
expr_stmt|;
block|}
comment|/* FALLTHROUGH */
case|case
name|CAM_REQUEUE_REQ
case|:
comment|/* Unconditional requeue */
name|error
operator|=
name|ERESTART
expr_stmt|;
if|if
condition|(
name|bootverbose
operator|&&
name|printed
operator|==
literal|0
condition|)
block|{
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"Request Requeued\n"
argument_list|)
expr_stmt|;
name|printed
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|CAM_RESRC_UNAVAIL
case|:
comment|/* Wait a bit for the resource shortage to abate. */
name|timeout
operator|=
name|periph_noresrc_delay
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|CAM_BUSY
case|:
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
block|{
comment|/* Wait a bit for the busy condition to abate. */
name|timeout
operator|=
name|periph_busy_delay
expr_stmt|;
block|}
name|relsim_flags
operator|=
name|RELSIM_RELEASE_AFTER_TIMEOUT
expr_stmt|;
comment|/* FALLTHROUGH */
default|default:
comment|/* decrement the number of retries */
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|retry_count
operator|>
literal|0
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|retry_count
operator|--
expr_stmt|;
name|error
operator|=
name|ERESTART
expr_stmt|;
if|if
condition|(
name|bootverbose
operator|&&
name|printed
operator|==
literal|0
condition|)
block|{
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"CAM Status 0x%x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|printed
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|error
operator|=
name|EIO
expr_stmt|;
name|action_string
operator|=
literal|"Retries Exhausted"
expr_stmt|;
block|}
break|break;
block|}
comment|/* Attempt a retry */
if|if
condition|(
name|error
operator|==
name|ERESTART
operator|||
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|frozen
operator|!=
literal|0
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_DEV_QFRZN
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
block|{
name|action_string
operator|=
literal|"Retrying Command"
expr_stmt|;
name|xpt_action
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|frozen
operator|!=
literal|0
condition|)
name|cam_release_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|relsim_flags
argument_list|,
name|openings
argument_list|,
name|timeout
argument_list|,
comment|/*getcount_only*/
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we have and error and are booting verbosely, whine 	 * *unless* this was a non-retryable selection timeout. 	 */
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|bootverbose
operator|&&
operator|!
operator|(
name|status
operator|==
name|CAM_SEL_TIMEOUT
operator|&&
operator|(
name|camflags
operator|&
name|CAM_RETRY_SELTO
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|action_string
operator|==
name|NULL
condition|)
name|action_string
operator|=
literal|"Unretryable Error"
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ERESTART
condition|)
block|{
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"%s\n"
argument_list|,
name|action_string
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

