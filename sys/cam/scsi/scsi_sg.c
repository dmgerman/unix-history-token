begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2007 Scott Long  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * scsi_sg peripheral driver.  This driver is meant to implement the Linux  * SG passthrough interface for SCSI.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/devicestat.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_queue.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_sg.h>
end_include

begin_include
include|#
directive|include
file|<compat/linux/linux_ioctl.h>
end_include

begin_typedef
typedef|typedef
enum|enum
block|{
name|SG_FLAG_OPEN
init|=
literal|0x01
block|,
name|SG_FLAG_LOCKED
init|=
literal|0x02
block|,
name|SG_FLAG_INVALID
init|=
literal|0x04
block|}
name|sg_flags
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|SG_STATE_NORMAL
block|}
name|sg_state
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|SG_RDWR_FREE
block|,
name|SG_RDWR_INPROG
block|,
name|SG_RDWR_DONE
block|}
name|sg_rdwr_state
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|SG_CCB_RDWR_IO
block|,
name|SG_CCB_WAITING
block|}
name|sg_ccb_types
typedef|;
end_typedef

begin_define
define|#
directive|define
name|ccb_type
value|ppriv_field0
end_define

begin_define
define|#
directive|define
name|ccb_rdwr
value|ppriv_ptr1
end_define

begin_struct
struct|struct
name|sg_rdwr
block|{
name|TAILQ_ENTRY
argument_list|(
argument|sg_rdwr
argument_list|)
name|rdwr_link
expr_stmt|;
name|int
name|tag
decl_stmt|;
name|int
name|state
decl_stmt|;
name|int
name|buf_len
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
union|union
block|{
name|struct
name|sg_header
name|hdr
decl_stmt|;
name|struct
name|sg_io_hdr
name|io_hdr
decl_stmt|;
block|}
name|hdr
union|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sg_softc
block|{
name|sg_state
name|state
decl_stmt|;
name|sg_flags
name|flags
decl_stmt|;
name|uint8_t
name|pd_type
decl_stmt|;
name|struct
name|devstat
modifier|*
name|device_stats
decl_stmt|;
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|sg_rdwr
argument_list|)
name|rdwr_done
expr_stmt|;
name|struct
name|cdev
modifier|*
name|dev
decl_stmt|;
name|struct
name|cdev
modifier|*
name|devalias
decl_stmt|;
name|union
name|ccb
name|saved_ccb
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|d_open_t
name|sgopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|sgclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|sgioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|sgwrite
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|sgread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_init_t
name|sginit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_ctor_t
name|sgregister
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_oninv_t
name|sgoninvalidate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_dtor_t
name|sgcleanup
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_start_t
name|sgstart
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|sgasync
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|uint32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sgdone
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|done_ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sgsendccb
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sgsendrdwr
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sgerror
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|uint32_t
name|cam_flags
parameter_list|,
name|uint32_t
name|sense_flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sg_scsiio_status
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_short
modifier|*
name|hoststat
parameter_list|,
name|u_short
modifier|*
name|drvstat
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|scsi_group_len
parameter_list|(
name|u_char
name|cmd
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|periph_driver
name|sgdriver
init|=
block|{
name|sginit
block|,
literal|"sg"
block|,
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|sgdriver
operator|.
name|units
argument_list|)
block|,
comment|/* gen */
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|PERIPHDRIVER_DECLARE
argument_list|(
name|sg
argument_list|,
name|sgdriver
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|sg_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_flags
operator|=
name|D_NEEDGIANT
block|,
operator|.
name|d_open
operator|=
name|sgopen
block|,
operator|.
name|d_close
operator|=
name|sgclose
block|,
operator|.
name|d_ioctl
operator|=
name|sgioctl
block|,
operator|.
name|d_write
operator|=
name|sgwrite
block|,
operator|.
name|d_read
operator|=
name|sgread
block|,
operator|.
name|d_name
operator|=
literal|"sg"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sg_version
init|=
literal|30125
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|sginit
parameter_list|(
name|void
parameter_list|)
block|{
name|cam_status
name|status
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
comment|/* 	 * Install a global async callback.  This callback will receive aync 	 * callbacks like "new device found". 	 */
name|status
operator|=
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|CAM_XPT_PATH_ID
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|CAM_REQ_CMP
condition|)
block|{
name|struct
name|ccb_setasync
name|csa
decl_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|csa
operator|.
name|ccb_h
argument_list|,
name|path
argument_list|,
comment|/*priority*/
literal|5
argument_list|)
expr_stmt|;
name|csa
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SASYNC_CB
expr_stmt|;
name|csa
operator|.
name|event_enable
operator|=
name|AC_FOUND_DEVICE
expr_stmt|;
name|csa
operator|.
name|callback
operator|=
name|sgasync
expr_stmt|;
name|csa
operator|.
name|callback_arg
operator|=
name|NULL
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|csa
argument_list|)
expr_stmt|;
name|status
operator|=
name|csa
operator|.
name|ccb_h
operator|.
name|status
expr_stmt|;
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"sg: Failed to attach master async callbac "
literal|"due to status 0x%x!\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sgoninvalidate
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|struct
name|sg_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ccb_setasync
name|csa
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sg_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
comment|/* 	 * Deregister any async callbacks. 	 */
name|xpt_setup_ccb
argument_list|(
operator|&
name|csa
operator|.
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
comment|/*priority*/
literal|5
argument_list|)
expr_stmt|;
name|csa
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SASYNC_CB
expr_stmt|;
name|csa
operator|.
name|event_enable
operator|=
literal|0
expr_stmt|;
name|csa
operator|.
name|callback
operator|=
name|sgasync
expr_stmt|;
name|csa
operator|.
name|callback_arg
operator|=
name|periph
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|csa
argument_list|)
expr_stmt|;
name|softc
operator|->
name|flags
operator||=
name|SG_FLAG_INVALID
expr_stmt|;
comment|/* 	 * XXX Return all queued I/O with ENXIO. 	 * XXX Handle any transactions queued to the card 	 *     with XPT_ABORT_CCB. 	 */
if|if
condition|(
name|bootverbose
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"lost device\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sgcleanup
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|struct
name|sg_softc
modifier|*
name|softc
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sg_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|devstat_remove_entry
argument_list|(
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
name|destroy_dev
argument_list|(
name|softc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|destroy_dev
argument_list|(
name|softc
operator|->
name|devalias
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"removing device entry\n"
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|softc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sgasync
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|uint32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|periph
operator|=
operator|(
expr|struct
name|cam_periph
operator|*
operator|)
name|callback_arg
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|AC_FOUND_DEVICE
case|:
block|{
name|struct
name|ccb_getdev
modifier|*
name|cgd
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|cgd
operator|=
operator|(
expr|struct
name|ccb_getdev
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|cgd
operator|==
name|NULL
condition|)
break|break;
comment|/* 		 * Allocate a peripheral instance for this device and 		 * start the probe process. 		 */
name|status
operator|=
name|cam_periph_alloc
argument_list|(
name|sgregister
argument_list|,
name|sgoninvalidate
argument_list|,
name|sgcleanup
argument_list|,
name|sgstart
argument_list|,
literal|"sg"
argument_list|,
name|CAM_PERIPH_BIO
argument_list|,
name|cgd
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|sgasync
argument_list|,
name|AC_FOUND_DEVICE
argument_list|,
name|cgd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|!=
name|CAM_REQ_CMP
operator|)
operator|&&
operator|(
name|status
operator|!=
name|CAM_REQ_INPROG
operator|)
condition|)
block|{
specifier|const
name|struct
name|cam_status_entry
modifier|*
name|entry
decl_stmt|;
name|entry
operator|=
name|cam_fetch_status_entry
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sgasync: Unable to attach new device "
literal|"due to status %#x: %s\n"
argument_list|,
name|status
argument_list|,
name|entry
condition|?
name|entry
operator|->
name|status_text
else|:
literal|"Unknown"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
name|cam_periph_async
argument_list|(
name|periph
argument_list|,
name|code
argument_list|,
name|path
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|cam_status
name|sgregister
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sg_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ccb_setasync
name|csa
decl_stmt|;
name|struct
name|ccb_getdev
modifier|*
name|cgd
decl_stmt|;
name|int
name|no_tags
decl_stmt|;
name|cgd
operator|=
operator|(
expr|struct
name|ccb_getdev
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"sgregister: periph was NULL!!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
if|if
condition|(
name|cgd
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"sgregister: no getdev CCB, can't register device\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
name|softc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|softc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"sgregister: Unable to allocate softc\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
name|softc
operator|->
name|state
operator|=
name|SG_STATE_NORMAL
expr_stmt|;
name|softc
operator|->
name|pd_type
operator|=
name|SID_TYPE
argument_list|(
operator|&
name|cgd
operator|->
name|inq_data
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|softc
operator|->
name|rdwr_done
argument_list|)
expr_stmt|;
name|periph
operator|->
name|softc
operator|=
name|softc
expr_stmt|;
comment|/* 	 * We pass in 0 for all blocksize, since we don't know what the 	 * blocksize of the device is, if it even has a blocksize. 	 */
name|no_tags
operator|=
operator|(
name|cgd
operator|->
name|inq_data
operator|.
name|flags
operator|&
name|SID_CmdQue
operator|)
operator|==
literal|0
expr_stmt|;
name|softc
operator|->
name|device_stats
operator|=
name|devstat_new_entry
argument_list|(
literal|"sg"
argument_list|,
name|unit2minor
argument_list|(
name|periph
operator|->
name|unit_number
argument_list|)
argument_list|,
literal|0
argument_list|,
name|DEVSTAT_NO_BLOCKSIZE
operator||
operator|(
name|no_tags
condition|?
name|DEVSTAT_NO_ORDERED_TAGS
else|:
literal|0
operator|)
argument_list|,
name|softc
operator|->
name|pd_type
operator||
name|DEVSTAT_TYPE_IF_SCSI
operator||
name|DEVSTAT_TYPE_PASS
argument_list|,
name|DEVSTAT_PRIORITY_PASS
argument_list|)
expr_stmt|;
comment|/* Register the device */
name|softc
operator|->
name|dev
operator|=
name|make_dev
argument_list|(
operator|&
name|sg_cdevsw
argument_list|,
name|unit2minor
argument_list|(
name|periph
operator|->
name|unit_number
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0600
argument_list|,
literal|"%s%d"
argument_list|,
name|periph
operator|->
name|periph_name
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|)
expr_stmt|;
name|softc
operator|->
name|devalias
operator|=
name|make_dev_alias
argument_list|(
name|softc
operator|->
name|dev
argument_list|,
literal|"sg%c"
argument_list|,
literal|'a'
operator|+
name|periph
operator|->
name|unit_number
argument_list|)
expr_stmt|;
name|softc
operator|->
name|dev
operator|->
name|si_drv1
operator|=
name|periph
expr_stmt|;
comment|/* 	 * Add as async callback so that we get 	 * notified if this device goes away. 	 */
name|xpt_setup_ccb
argument_list|(
operator|&
name|csa
operator|.
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
comment|/*priority*/
literal|5
argument_list|)
expr_stmt|;
name|csa
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SASYNC_CB
expr_stmt|;
name|csa
operator|.
name|event_enable
operator|=
name|AC_LOST_DEVICE
expr_stmt|;
name|csa
operator|.
name|callback
operator|=
name|sgasync
expr_stmt|;
name|csa
operator|.
name|callback_arg
operator|=
name|periph
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|csa
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|xpt_announce_periph
argument_list|(
name|periph
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sgstart
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|start_ccb
parameter_list|)
block|{
name|struct
name|sg_softc
modifier|*
name|softc
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sg_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
switch|switch
condition|(
name|softc
operator|->
name|state
condition|)
block|{
case|case
name|SG_STATE_NORMAL
case|:
name|start_ccb
operator|->
name|ccb_h
operator|.
name|ccb_type
operator|=
name|SG_CCB_WAITING
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|periph
operator|->
name|ccb_list
argument_list|,
operator|&
name|start_ccb
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|sle
argument_list|)
expr_stmt|;
name|periph
operator|->
name|immediate_priority
operator|=
name|CAM_PRIORITY_NONE
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|periph
operator|->
name|ccb_list
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sgdone
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|done_ccb
parameter_list|)
block|{
name|struct
name|sg_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sg_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|csio
operator|=
operator|&
name|done_ccb
operator|->
name|csio
expr_stmt|;
switch|switch
condition|(
name|csio
operator|->
name|ccb_h
operator|.
name|ccb_type
condition|)
block|{
case|case
name|SG_CCB_WAITING
case|:
comment|/* Caller will release the CCB */
name|wakeup
argument_list|(
operator|&
name|done_ccb
operator|->
name|ccb_h
operator|.
name|cbfcnp
argument_list|)
expr_stmt|;
return|return;
case|case
name|SG_CCB_RDWR_IO
case|:
block|{
name|struct
name|sg_rdwr
modifier|*
name|rdwr
decl_stmt|;
name|int
name|state
decl_stmt|;
name|devstat_end_transaction
argument_list|(
name|softc
operator|->
name|device_stats
argument_list|,
name|csio
operator|->
name|dxfer_len
argument_list|,
name|csio
operator|->
name|tag_action
operator|&
literal|0xf
argument_list|,
operator|(
operator|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_NONE
operator|)
condition|?
name|DEVSTAT_NO_DATA
else|:
operator|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_OUT
operator|)
condition|?
name|DEVSTAT_WRITE
else|:
name|DEVSTAT_READ
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rdwr
operator|=
name|done_ccb
operator|->
name|ccb_h
operator|.
name|ccb_rdwr
expr_stmt|;
name|state
operator|=
name|rdwr
operator|->
name|state
expr_stmt|;
name|rdwr
operator|->
name|state
operator|=
name|SG_RDWR_DONE
expr_stmt|;
name|wakeup
argument_list|(
name|rdwr
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|panic
argument_list|(
literal|"unknown sg CCB type"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|sgopen
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|sg_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|periph
operator|=
operator|(
expr|struct
name|cam_periph
operator|*
operator|)
name|dev
operator|->
name|si_drv1
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|softc
operator|=
operator|(
expr|struct
name|sg_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|flags
operator|&
name|SG_FLAG_INVALID
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* 	 * Don't allow access when we're running at a high securelevel. 	 */
name|error
operator|=
name|securelevel_gt
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|cam_periph_lock
argument_list|(
name|periph
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|SG_FLAG_OPEN
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cam_periph_acquire
argument_list|(
name|periph
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|softc
operator|->
name|flags
operator||=
name|SG_FLAG_OPEN
expr_stmt|;
block|}
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sgclose
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|sg_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|periph
operator|=
operator|(
expr|struct
name|cam_periph
operator|*
operator|)
name|dev
operator|->
name|si_drv1
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|softc
operator|=
operator|(
expr|struct
name|sg_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|cam_periph_lock
argument_list|(
name|periph
argument_list|,
name|PRIBIO
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|softc
operator|->
name|flags
operator|&=
operator|~
name|SG_FLAG_OPEN
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|cam_periph_release
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sgioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|sg_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|sg_io_hdr
name|req
decl_stmt|;
name|int
name|dir
decl_stmt|,
name|error
decl_stmt|;
name|periph
operator|=
operator|(
expr|struct
name|cam_periph
operator|*
operator|)
name|dev
operator|->
name|si_drv1
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|softc
operator|=
operator|(
expr|struct
name|sg_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|LINUX_SCSI_GET_BUS_NUMBER
case|:
block|{
name|int
name|busno
decl_stmt|;
name|busno
operator|=
name|xpt_path_path_id
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|busno
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|busno
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|LINUX_SCSI_GET_IDLUN
case|:
block|{
name|struct
name|scsi_idlun
name|idlun
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|idlun
operator|.
name|dev_id
operator|=
name|xpt_path_target_id
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|sim
operator|=
name|xpt_path_sim
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|idlun
operator|.
name|host_unique_id
operator|=
name|sim
operator|->
name|unit_number
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|idlun
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|idlun
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SG_GET_VERSION_NUM
case|:
case|case
name|LINUX_SG_GET_VERSION_NUM
case|:
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|sg_version
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|sg_version
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SG_SET_TIMEOUT
case|:
case|case
name|LINUX_SG_SET_TIMEOUT
case|:
break|break;
case|case
name|SG_GET_TIMEOUT
case|:
case|case
name|LINUX_SG_GET_TIMEOUT
case|:
comment|/* 		 * XXX This ioctl is highly brain damaged because it requires 		 *     that the value be returned in the syscall return value. 		 *     The linuxolator seems to have a hard time with this, 		 *     so just return 0 and hope that apps can cope. 		 */
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|60
operator|*
name|hz
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SG_IO
case|:
case|case
name|LINUX_SG_IO
case|:
name|error
operator|=
name|copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|req
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|req
operator|.
name|cmd_len
operator|>
name|IOCDBLEN
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|req
operator|.
name|iovec_count
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
comment|/*priority*/
literal|5
argument_list|)
expr_stmt|;
name|csio
operator|=
operator|&
name|ccb
operator|->
name|csio
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|req
operator|.
name|cmdp
argument_list|,
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|req
operator|.
name|cmd_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|req
operator|.
name|dxfer_direction
condition|)
block|{
case|case
name|SG_DXFER_TO_DEV
case|:
name|dir
operator|=
name|CAM_DIR_OUT
expr_stmt|;
break|break;
case|case
name|SG_DXFER_FROM_DEV
case|:
name|dir
operator|=
name|CAM_DIR_IN
expr_stmt|;
break|break;
case|case
name|SG_DXFER_TO_FROM_DEV
case|:
name|dir
operator|=
name|CAM_DIR_IN
operator||
name|CAM_DIR_OUT
expr_stmt|;
break|break;
case|case
name|SG_DXFER_NONE
case|:
default|default:
name|dir
operator|=
name|CAM_DIR_NONE
expr_stmt|;
break|break;
block|}
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
comment|/*retries*/
literal|1
argument_list|,
name|sgdone
argument_list|,
name|dir
operator||
name|CAM_DEV_QFRZDIS
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|req
operator|.
name|dxferp
argument_list|,
name|req
operator|.
name|dxfer_len
argument_list|,
name|req
operator|.
name|mx_sb_len
argument_list|,
name|req
operator|.
name|cmd_len
argument_list|,
name|req
operator|.
name|timeout
argument_list|)
expr_stmt|;
name|error
operator|=
name|sgsendccb
argument_list|(
name|periph
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|req
operator|.
name|host_status
operator|=
name|DID_ERROR
expr_stmt|;
name|req
operator|.
name|driver_status
operator|=
name|DRIVER_INVALID
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
name|req
operator|.
name|status
operator|=
name|csio
operator|->
name|scsi_status
expr_stmt|;
name|req
operator|.
name|masked_status
operator|=
operator|(
name|csio
operator|->
name|scsi_status
operator|>>
literal|1
operator|)
operator|&
literal|0x7f
expr_stmt|;
name|sg_scsiio_status
argument_list|(
name|csio
argument_list|,
operator|&
name|req
operator|.
name|host_status
argument_list|,
operator|&
name|req
operator|.
name|driver_status
argument_list|)
expr_stmt|;
name|req
operator|.
name|resid
operator|=
name|csio
operator|->
name|resid
expr_stmt|;
name|req
operator|.
name|duration
operator|=
name|csio
operator|->
name|ccb_h
operator|.
name|timeout
expr_stmt|;
name|req
operator|.
name|info
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|req
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|==
literal|0
operator|)
operator|&&
operator|(
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_AUTOSNS_VALID
operator|)
operator|&&
operator|(
name|req
operator|.
name|sbp
operator|!=
name|NULL
operator|)
condition|)
block|{
name|req
operator|.
name|sb_len_wr
operator|=
name|req
operator|.
name|mx_sb_len
operator|-
name|csio
operator|->
name|sense_resid
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|csio
operator|->
name|sense_data
argument_list|,
name|req
operator|.
name|sbp
argument_list|,
name|req
operator|.
name|sb_len_wr
argument_list|)
expr_stmt|;
block|}
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|SG_GET_RESERVED_SIZE
case|:
case|case
name|LINUX_SG_GET_RESERVED_SIZE
case|:
block|{
name|int
name|size
init|=
literal|32768
decl_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|size
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SG_GET_SCSI_ID
case|:
case|case
name|LINUX_SG_GET_SCSI_ID
case|:
block|{
name|struct
name|sg_scsi_id
name|id
decl_stmt|;
name|id
operator|.
name|host_no
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
name|id
operator|.
name|channel
operator|=
name|xpt_path_path_id
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|id
operator|.
name|scsi_id
operator|=
name|xpt_path_target_id
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|id
operator|.
name|lun
operator|=
name|xpt_path_lun_id
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|id
operator|.
name|scsi_type
operator|=
name|softc
operator|->
name|pd_type
expr_stmt|;
name|id
operator|.
name|h_cmd_per_lun
operator|=
literal|1
expr_stmt|;
name|id
operator|.
name|d_queue_depth
operator|=
literal|1
expr_stmt|;
name|id
operator|.
name|unused
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|id
operator|.
name|unused
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|id
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SG_EMULATED_HOST
case|:
case|case
name|SG_SET_TRANSFORM
case|:
case|case
name|SG_GET_TRANSFORM
case|:
case|case
name|SG_GET_NUM_WAITING
case|:
case|case
name|SG_SCSI_RESET
case|:
case|case
name|SG_GET_REQUEST_TABLE
case|:
case|case
name|SG_SET_KEEP_ORPHAN
case|:
case|case
name|SG_GET_KEEP_ORPHAN
case|:
case|case
name|SG_GET_ACCESS_COUNT
case|:
case|case
name|SG_SET_FORCE_LOW_DMA
case|:
case|case
name|SG_GET_LOW_DMA
case|:
case|case
name|SG_GET_SG_TABLESIZE
case|:
case|case
name|SG_SET_FORCE_PACK_ID
case|:
case|case
name|SG_GET_PACK_ID
case|:
case|case
name|SG_SET_RESERVED_SIZE
case|:
case|case
name|SG_GET_COMMAND_Q
case|:
case|case
name|SG_SET_COMMAND_Q
case|:
case|case
name|SG_SET_DEBUG
case|:
case|case
name|SG_NEXT_CMD_LEN
case|:
case|case
name|LINUX_SG_EMULATED_HOST
case|:
case|case
name|LINUX_SG_SET_TRANSFORM
case|:
case|case
name|LINUX_SG_GET_TRANSFORM
case|:
case|case
name|LINUX_SG_GET_NUM_WAITING
case|:
case|case
name|LINUX_SG_SCSI_RESET
case|:
case|case
name|LINUX_SG_GET_REQUEST_TABLE
case|:
case|case
name|LINUX_SG_SET_KEEP_ORPHAN
case|:
case|case
name|LINUX_SG_GET_KEEP_ORPHAN
case|:
case|case
name|LINUX_SG_GET_ACCESS_COUNT
case|:
case|case
name|LINUX_SG_SET_FORCE_LOW_DMA
case|:
case|case
name|LINUX_SG_GET_LOW_DMA
case|:
case|case
name|LINUX_SG_GET_SG_TABLESIZE
case|:
case|case
name|LINUX_SG_SET_FORCE_PACK_ID
case|:
case|case
name|LINUX_SG_GET_PACK_ID
case|:
case|case
name|LINUX_SG_SET_RESERVED_SIZE
case|:
case|case
name|LINUX_SG_GET_COMMAND_Q
case|:
case|case
name|LINUX_SG_SET_COMMAND_Q
case|:
case|case
name|LINUX_SG_SET_DEBUG
case|:
case|case
name|LINUX_SG_NEXT_CMD_LEN
case|:
default|default:
ifdef|#
directive|ifdef
name|CAMDEBUG
name|printf
argument_list|(
literal|"sgioctl: rejecting cmd 0x%lx\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sgwrite
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|struct
name|sg_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|sg_header
modifier|*
name|hdr
decl_stmt|;
name|struct
name|sg_rdwr
modifier|*
name|rdwr
decl_stmt|;
name|u_char
name|cdb_cmd
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|cdb_len
decl_stmt|,
name|buf_len
decl_stmt|,
name|dir
decl_stmt|;
name|periph
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|sc
operator|=
name|periph
operator|->
name|softc
expr_stmt|;
name|rdwr
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|rdwr
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|hdr
operator|=
operator|&
name|rdwr
operator|->
name|hdr
operator|.
name|hdr
expr_stmt|;
comment|/* Copy in the header block and sanity check it */
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out_hdr
goto|;
block|}
name|error
operator|=
name|uiomove
argument_list|(
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out_hdr
goto|;
name|ccb
operator|=
name|xpt_alloc_ccb
argument_list|()
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out_hdr
goto|;
block|}
name|xpt_setup_ccb
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
comment|/*priority*/
literal|5
argument_list|)
expr_stmt|;
name|csio
operator|=
operator|&
name|ccb
operator|->
name|csio
expr_stmt|;
comment|/* 	 * Copy in the CDB block.  The designers of the interface didn't 	 * bother to provide a size for this in the header, so we have to 	 * figure it out ourselves. 	 */
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|<
literal|1
condition|)
goto|goto
name|out_ccb
goto|;
name|error
operator|=
name|uiomove
argument_list|(
operator|&
name|cdb_cmd
argument_list|,
literal|1
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out_ccb
goto|;
if|if
condition|(
name|hdr
operator|->
name|twelve_byte
condition|)
name|cdb_len
operator|=
literal|12
expr_stmt|;
else|else
name|cdb_len
operator|=
name|scsi_group_len
argument_list|(
name|cdb_cmd
argument_list|)
expr_stmt|;
comment|/* 	 * We've already read the first byte of the CDB and advanced the uio 	 * pointer.  Just read the rest. 	 */
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
operator|=
name|cdb_cmd
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|1
index|]
argument_list|,
name|cdb_len
operator|-
literal|1
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out_ccb
goto|;
comment|/* 	 * Now set up the data block.  Again, the designers didn't bother 	 * to make this reliable. 	 */
name|buf_len
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
if|if
condition|(
name|buf_len
operator|!=
literal|0
condition|)
block|{
name|buf
operator|=
name|malloc
argument_list|(
name|buf_len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
name|buf
argument_list|,
name|buf_len
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out_buf
goto|;
name|dir
operator|=
name|CAM_DIR_OUT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hdr
operator|->
name|reply_len
operator|!=
literal|0
condition|)
block|{
name|buf
operator|=
name|malloc
argument_list|(
name|hdr
operator|->
name|reply_len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|buf_len
operator|=
name|hdr
operator|->
name|reply_len
expr_stmt|;
name|dir
operator|=
name|CAM_DIR_IN
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|=
name|NULL
expr_stmt|;
name|buf_len
operator|=
literal|0
expr_stmt|;
name|dir
operator|=
name|CAM_DIR_NONE
expr_stmt|;
block|}
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
comment|/*retries*/
literal|1
argument_list|,
name|sgdone
argument_list|,
name|dir
operator||
name|CAM_DEV_QFRZDIS
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|buf
argument_list|,
name|buf_len
argument_list|,
name|SG_MAX_SENSE
argument_list|,
name|cdb_len
argument_list|,
literal|60
operator|*
name|hz
argument_list|)
expr_stmt|;
comment|/* 	 * Send off the command and hope that it works. This path does not 	 * go through sgstart because the I/O is supposed to be asynchronous. 	 */
name|rdwr
operator|->
name|buf
operator|=
name|buf
expr_stmt|;
name|rdwr
operator|->
name|buf_len
operator|=
name|buf_len
expr_stmt|;
name|rdwr
operator|->
name|tag
operator|=
name|hdr
operator|->
name|pack_id
expr_stmt|;
name|rdwr
operator|->
name|ccb
operator|=
name|ccb
expr_stmt|;
name|rdwr
operator|->
name|state
operator|=
name|SG_RDWR_INPROG
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_rdwr
operator|=
name|rdwr
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_type
operator|=
name|SG_CCB_RDWR_IO
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|rdwr_done
argument_list|,
name|rdwr
argument_list|,
name|rdwr_link
argument_list|)
expr_stmt|;
return|return
operator|(
name|sgsendrdwr
argument_list|(
name|periph
argument_list|,
name|ccb
argument_list|)
operator|)
return|;
name|out_buf
label|:
name|free
argument_list|(
name|buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|out_ccb
label|:
name|xpt_free_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|out_hdr
label|:
name|free
argument_list|(
name|rdwr
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sgread
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|sg_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|sg_header
modifier|*
name|hdr
decl_stmt|;
name|struct
name|sg_rdwr
modifier|*
name|rdwr
decl_stmt|;
name|u_short
name|hstat
decl_stmt|,
name|dstat
decl_stmt|;
name|int
name|error
decl_stmt|,
name|pack_len
decl_stmt|,
name|reply_len
decl_stmt|,
name|pack_id
decl_stmt|;
name|periph
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|sc
operator|=
name|periph
operator|->
name|softc
expr_stmt|;
comment|/* XXX The pack len field needs to be updated and written out instead 	 * of discarded.  Not sure how to do that. 	 */
name|uio
operator|->
name|uio_rw
operator|=
name|UIO_WRITE
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|uiomove
argument_list|(
operator|&
name|pack_len
argument_list|,
literal|4
argument_list|,
name|uio
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|uiomove
argument_list|(
operator|&
name|reply_len
argument_list|,
literal|4
argument_list|,
name|uio
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|uiomove
argument_list|(
operator|&
name|pack_id
argument_list|,
literal|4
argument_list|,
name|uio
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|uio
operator|->
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|search
label|:
name|TAILQ_FOREACH
argument_list|(
argument|rdwr
argument_list|,
argument|&sc->rdwr_done
argument_list|,
argument|rdwr_link
argument_list|)
block|{
if|if
condition|(
name|rdwr
operator|->
name|tag
operator|==
name|pack_id
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|rdwr
operator|==
name|NULL
operator|)
operator|||
operator|(
name|rdwr
operator|->
name|state
operator|!=
name|SG_RDWR_DONE
operator|)
condition|)
block|{
if|if
condition|(
name|tsleep
argument_list|(
name|rdwr
argument_list|,
name|PCATCH
argument_list|,
literal|"sgread"
argument_list|,
literal|0
argument_list|)
operator|==
name|ERESTART
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
goto|goto
name|search
goto|;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|rdwr_done
argument_list|,
name|rdwr
argument_list|,
name|rdwr_link
argument_list|)
expr_stmt|;
name|hdr
operator|=
operator|&
name|rdwr
operator|->
name|hdr
operator|.
name|hdr
expr_stmt|;
name|csio
operator|=
operator|&
name|rdwr
operator|->
name|ccb
operator|->
name|csio
expr_stmt|;
name|sg_scsiio_status
argument_list|(
name|csio
argument_list|,
operator|&
name|hstat
argument_list|,
operator|&
name|dstat
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|host_status
operator|=
name|hstat
expr_stmt|;
name|hdr
operator|->
name|driver_status
operator|=
name|dstat
expr_stmt|;
name|hdr
operator|->
name|target_status
operator|=
name|csio
operator|->
name|scsi_status
operator|>>
literal|1
expr_stmt|;
switch|switch
condition|(
name|hstat
condition|)
block|{
case|case
name|DID_OK
case|:
case|case
name|DID_PASSTHROUGH
case|:
case|case
name|DID_SOFT_ERROR
case|:
name|hdr
operator|->
name|result
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DID_NO_CONNECT
case|:
case|case
name|DID_BUS_BUSY
case|:
case|case
name|DID_TIME_OUT
case|:
name|hdr
operator|->
name|result
operator|=
name|EBUSY
expr_stmt|;
break|break;
case|case
name|DID_BAD_TARGET
case|:
case|case
name|DID_ABORT
case|:
case|case
name|DID_PARITY
case|:
case|case
name|DID_RESET
case|:
case|case
name|DID_BAD_INTR
case|:
case|case
name|DID_ERROR
case|:
default|default:
name|hdr
operator|->
name|result
operator|=
name|EIO
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dstat
operator|==
name|DRIVER_SENSE
condition|)
block|{
name|bcopy
argument_list|(
operator|&
name|csio
operator|->
name|sense_data
argument_list|,
name|hdr
operator|->
name|sense_buffer
argument_list|,
name|min
argument_list|(
name|csio
operator|->
name|sense_len
argument_list|,
name|SG_MAX_SENSE
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CAMDEBUG
name|scsi_sense_print
argument_list|(
name|csio
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|error
operator|=
name|uiomove
argument_list|(
operator|&
name|hdr
operator|->
name|result
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|-
name|offsetof
argument_list|(
expr|struct
name|sg_header
argument_list|,
name|result
argument_list|)
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|==
literal|0
operator|)
operator|&&
operator|(
name|hdr
operator|->
name|result
operator|==
literal|0
operator|)
condition|)
name|error
operator|=
name|uiomove
argument_list|(
name|rdwr
operator|->
name|buf
argument_list|,
name|rdwr
operator|->
name|buf_len
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|xpt_free_ccb
argument_list|(
name|rdwr
operator|->
name|ccb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rdwr
operator|->
name|buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rdwr
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sgsendccb
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|sg_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|cam_periph_map_info
name|mapinfo
decl_stmt|;
name|int
name|error
decl_stmt|,
name|need_unmap
init|=
literal|0
decl_stmt|;
name|softc
operator|=
name|periph
operator|->
name|softc
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
operator|!=
name|NULL
operator|)
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|mapinfo
argument_list|,
sizeof|sizeof
argument_list|(
name|mapinfo
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|cam_periph_mapmem
argument_list|(
name|ccb
argument_list|,
operator|&
name|mapinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|need_unmap
operator|=
literal|1
expr_stmt|;
block|}
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|sgerror
argument_list|,
name|CAM_RETRY_SELTO
argument_list|,
name|SF_RETRY_UA
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_unmap
condition|)
name|cam_periph_unmapmem
argument_list|(
name|ccb
argument_list|,
operator|&
name|mapinfo
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sgsendrdwr
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|sg_softc
modifier|*
name|softc
decl_stmt|;
name|softc
operator|=
name|periph
operator|->
name|softc
expr_stmt|;
name|devstat_start_transaction
argument_list|(
name|softc
operator|->
name|device_stats
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xpt_action
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sgerror
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|uint32_t
name|cam_flags
parameter_list|,
name|uint32_t
name|sense_flags
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|sg_softc
modifier|*
name|softc
decl_stmt|;
name|periph
operator|=
name|xpt_path_periph
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sg_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
return|return
operator|(
name|cam_periph_error
argument_list|(
name|ccb
argument_list|,
name|cam_flags
argument_list|,
name|sense_flags
argument_list|,
operator|&
name|softc
operator|->
name|saved_ccb
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sg_scsiio_status
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_short
modifier|*
name|hoststat
parameter_list|,
name|u_short
modifier|*
name|drvstat
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|status
operator|=
name|csio
operator|->
name|ccb_h
operator|.
name|status
expr_stmt|;
switch|switch
condition|(
name|status
operator|&
name|CAM_STATUS_MASK
condition|)
block|{
case|case
name|CAM_REQ_CMP
case|:
operator|*
name|hoststat
operator|=
name|DID_OK
expr_stmt|;
operator|*
name|drvstat
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CAM_REQ_CMP_ERR
case|:
operator|*
name|hoststat
operator|=
name|DID_ERROR
expr_stmt|;
operator|*
name|drvstat
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CAM_REQ_ABORTED
case|:
operator|*
name|hoststat
operator|=
name|DID_ABORT
expr_stmt|;
operator|*
name|drvstat
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CAM_REQ_INVALID
case|:
operator|*
name|hoststat
operator|=
name|DID_ERROR
expr_stmt|;
operator|*
name|drvstat
operator|=
name|DRIVER_INVALID
expr_stmt|;
break|break;
case|case
name|CAM_DEV_NOT_THERE
case|:
operator|*
name|hoststat
operator|=
name|DID_BAD_TARGET
expr_stmt|;
operator|*
name|drvstat
operator|=
literal|0
expr_stmt|;
case|case
name|CAM_SEL_TIMEOUT
case|:
operator|*
name|hoststat
operator|=
name|DID_NO_CONNECT
expr_stmt|;
operator|*
name|drvstat
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CAM_CMD_TIMEOUT
case|:
operator|*
name|hoststat
operator|=
name|DID_TIME_OUT
expr_stmt|;
operator|*
name|drvstat
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CAM_SCSI_STATUS_ERROR
case|:
operator|*
name|hoststat
operator|=
name|DID_ERROR
expr_stmt|;
operator|*
name|drvstat
operator|=
literal|0
expr_stmt|;
case|case
name|CAM_SCSI_BUS_RESET
case|:
operator|*
name|hoststat
operator|=
name|DID_RESET
expr_stmt|;
operator|*
name|drvstat
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CAM_UNCOR_PARITY
case|:
operator|*
name|hoststat
operator|=
name|DID_PARITY
expr_stmt|;
operator|*
name|drvstat
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CAM_SCSI_BUSY
case|:
operator|*
name|hoststat
operator|=
name|DID_BUS_BUSY
expr_stmt|;
operator|*
name|drvstat
operator|=
literal|0
expr_stmt|;
default|default:
operator|*
name|hoststat
operator|=
name|DID_ERROR
expr_stmt|;
operator|*
name|drvstat
operator|=
name|DRIVER_ERROR
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|CAM_AUTOSNS_VALID
condition|)
operator|*
name|drvstat
operator|=
name|DRIVER_SENSE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|scsi_group_len
parameter_list|(
name|u_char
name|cmd
parameter_list|)
block|{
name|int
name|len
index|[]
init|=
block|{
literal|6
block|,
literal|10
block|,
literal|10
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|10
block|,
literal|10
block|}
decl_stmt|;
name|int
name|group
decl_stmt|;
name|group
operator|=
operator|(
name|cmd
operator|>>
literal|5
operator|)
operator|&
literal|0x7
expr_stmt|;
return|return
operator|(
name|len
index|[
name|group
index|]
operator|)
return|;
block|}
end_function

end_unit

