begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2000 Matthew Jacob  * Copyright (c) 2010 Spectra Logic Corporation  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file scsi_enc_ses.c  *  * Structures and routines specific&& private to SES only  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_enc.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_enc_internal.h>
end_include

begin_comment
comment|/* SES Native Type Device Support */
end_comment

begin_comment
comment|/* SES Diagnostic Page Codes */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|SesSupportedPages
init|=
literal|0x0
block|,
name|SesConfigPage
init|=
literal|0x1
block|,
name|SesControlPage
init|=
literal|0x2
block|,
name|SesStatusPage
init|=
name|SesControlPage
block|,
name|SesHelpTxt
init|=
literal|0x3
block|,
name|SesStringOut
init|=
literal|0x4
block|,
name|SesStringIn
init|=
name|SesStringOut
block|,
name|SesThresholdOut
init|=
literal|0x5
block|,
name|SesThresholdIn
init|=
name|SesThresholdOut
block|,
name|SesArrayControl
init|=
literal|0x6
block|,
comment|/* Obsolete in SES v2 */
name|SesArrayStatus
init|=
name|SesArrayControl
block|,
name|SesElementDescriptor
init|=
literal|0x7
block|,
name|SesShortStatus
init|=
literal|0x8
block|,
name|SesEnclosureBusy
init|=
literal|0x9
block|,
name|SesAddlElementStatus
init|=
literal|0xa
block|}
name|SesDiagPageCodes
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|ses_type
block|{
specifier|const
name|struct
name|ses_elm_type_desc
modifier|*
name|hdr
decl_stmt|;
specifier|const
name|char
modifier|*
name|text
decl_stmt|;
block|}
name|ses_type_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|ses_comstat
block|{
name|uint8_t
name|comstatus
decl_stmt|;
name|uint8_t
name|comstat
index|[
literal|3
index|]
decl_stmt|;
block|}
name|ses_comstat_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
union|union
name|ses_addl_data
block|{
name|struct
name|ses_elm_sas_device_phy
modifier|*
name|sasdev_phys
decl_stmt|;
name|struct
name|ses_elm_sas_expander_phy
modifier|*
name|sasexp_phys
decl_stmt|;
name|struct
name|ses_elm_sas_port_phy
modifier|*
name|sasport_phys
decl_stmt|;
name|struct
name|ses_fcobj_port
modifier|*
name|fc_ports
decl_stmt|;
block|}
name|ses_add_data_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|ses_addl_status
block|{
name|struct
name|ses_elm_addlstatus_base_hdr
modifier|*
name|hdr
decl_stmt|;
union|union
block|{
name|union
name|ses_fcobj_hdr
modifier|*
name|fc
decl_stmt|;
name|union
name|ses_elm_sas_hdr
modifier|*
name|sas
decl_stmt|;
block|}
name|proto_hdr
union|;
name|union
name|ses_addl_data
name|proto_data
decl_stmt|;
comment|/* array sizes stored in header */
block|}
name|ses_add_status_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|ses_element
block|{
name|uint8_t
name|eip
decl_stmt|;
comment|/* eip bit is set */
name|uint16_t
name|descr_len
decl_stmt|;
comment|/* length of the descriptor */
name|char
modifier|*
name|descr
decl_stmt|;
comment|/* descriptor for this object */
name|struct
name|ses_addl_status
name|addl
decl_stmt|;
comment|/* additional status info */
block|}
name|ses_element_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|ses_control_request
block|{
name|int
name|elm_idx
decl_stmt|;
name|ses_comstat_t
name|elm_stat
decl_stmt|;
name|int
name|result
decl_stmt|;
name|TAILQ_ENTRY
argument_list|(
argument|ses_control_request
argument_list|)
name|links
expr_stmt|;
block|}
name|ses_control_request_t
typedef|;
end_typedef

begin_expr_stmt
name|TAILQ_HEAD
argument_list|(
name|ses_control_reqlist
argument_list|,
name|ses_control_request
argument_list|)
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|struct
name|ses_control_reqlist
name|ses_control_reqlist_t
typedef|;
end_typedef

begin_enum
enum|enum
block|{
name|SES_SETSTATUS_ENC_IDX
init|=
operator|-
literal|1
block|}
enum|;
end_enum

begin_function
specifier|static
name|void
name|ses_terminate_control_requests
parameter_list|(
name|ses_control_reqlist_t
modifier|*
name|reqlist
parameter_list|,
name|int
name|result
parameter_list|)
block|{
name|ses_control_request_t
modifier|*
name|req
decl_stmt|;
while|while
condition|(
operator|(
name|req
operator|=
name|TAILQ_FIRST
argument_list|(
name|reqlist
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
name|reqlist
argument_list|,
name|req
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|req
operator|->
name|result
operator|=
name|result
expr_stmt|;
name|wakeup
argument_list|(
name|req
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_enum
enum|enum
name|ses_iter_index_values
block|{
comment|/** 	 * \brief  Value of an initialized but invalid index 	 *         in a ses_iterator object. 	 * 	 * This value is used for the  individual_element_index of 	 * overal status elements and for all index types when 	 * an iterator is first initialized. 	 */
name|ITERATOR_INDEX_INVALID
init|=
operator|-
literal|1
block|,
comment|/** 	 * \brief  Value of an index in a ses_iterator object 	 *	   when the iterator has traversed past the last 	 *	   valid element.. 	 */
name|ITERATOR_INDEX_END
init|=
name|INT_MAX
block|}
enum|;
end_enum

begin_comment
comment|/**  * \brief Structure encapsulating all data necessary to traverse the  *        elements of a SES configuration.  *  * The ses_iterator object simplifies the task of iterating through all  * elements detected via the SES configuration page by tracking the numerous  * element indexes that, instead of memoizing in the softc, we calculate  * on the fly during the traversal of the element objects.  The various  * indexes are necessary due to the varying needs of matching objects in  * the different SES pages.  Some pages (e.g. Status/Control) contain all  * elements, while others (e.g. Additional Element Status) only contain  * individual elements (no overal status elements) of particular types.  *  * To use an iterator, initialize it with ses_iter_init(), and then  * use ses_iter_next() to traverse the elements (including the first) in  * the configuration.  Once an iterator is initiailized with ses_iter_init(),  * you may also seek to any particular element by either it's global or  * individual element index via the ses_iter_seek_to() function.  You may  * also return an iterator to the position just before the first element  * (i.e. the same state as after an ses_iter_init()), with ses_iter_reset().  */
end_comment

begin_struct
struct|struct
name|ses_iterator
block|{
comment|/** 	 * \brief Backlink to the overal software configuration structure. 	 * 	 * This is included for convenience so the iteration functions 	 * need only take a single, struct ses_iterator *, argument. 	 */
name|enc_softc_t
modifier|*
name|enc
decl_stmt|;
name|enc_cache_t
modifier|*
name|cache
decl_stmt|;
comment|/** 	 * \brief Index of the type of the current element within the 	 *        ses_cache's ses_types array. 	 */
name|int
name|type_index
decl_stmt|;
comment|/** 	 * \brief The position (0 based) of this element relative to all other 	 *        elements of this type. 	 * 	 * This index resets to zero every time the iterator transitions 	 * to elements of a new type in the configuration. 	 */
name|int
name|type_element_index
decl_stmt|;
comment|/** 	 * \brief The position (0 based) of this element relative to all 	 *        other individual status elements in the configuration. 	 * 	 * This index ranges from 0 through the number of individual 	 * elements in the configuration.  When the iterator returns 	 * an overall status element, individual_element_index is 	 * set to ITERATOR_INDEX_INVALID, to indicate that it does 	 * not apply to the current element. 	 */
name|int
name|individual_element_index
decl_stmt|;
comment|/** 	 * \brief The position (0 based) of this element relative to 	 *        all elements in the configration. 	 * 	 * This index is appropriate for indexing into enc->ses_elm_map. 	 */
name|int
name|global_element_index
decl_stmt|;
comment|/** 	 * \brief The last valid individual element index of this 	 *        iterator. 	 * 	 * When an iterator traverses an overal status element, the 	 * individual element index is reset to ITERATOR_INDEX_INVALID 	 * to prevent unintential use of the individual_element_index 	 * field.  The saved_individual_element_index allows the iterator 	 * to restore it's position in the individual elements upon 	 * reaching the next individual element. 	 */
name|int
name|saved_individual_element_index
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
enum|enum
block|{
name|SES_UPDATE_NONE
block|,
name|SES_UPDATE_PAGES
block|,
name|SES_UPDATE_GETCONFIG
block|,
name|SES_UPDATE_GETSTATUS
block|,
name|SES_UPDATE_GETELMDESCS
block|,
name|SES_UPDATE_GETELMADDLSTATUS
block|,
name|SES_PROCESS_CONTROL_REQS
block|,
name|SES_PUBLISH_PHYSPATHS
block|,
name|SES_PUBLISH_CACHE
block|,
name|SES_NUM_UPDATE_STATES
block|}
name|ses_update_action
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|enc_softc_cleanup_t
name|ses_softc_cleanup
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SCSZ
value|0x8000
end_define

begin_decl_stmt
specifier|static
name|fsm_fill_handler_t
name|ses_fill_rcv_diag_io
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fsm_fill_handler_t
name|ses_fill_control_request
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fsm_done_handler_t
name|ses_process_pages
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fsm_done_handler_t
name|ses_process_config
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fsm_done_handler_t
name|ses_process_status
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fsm_done_handler_t
name|ses_process_elm_descs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fsm_done_handler_t
name|ses_process_elm_addlstatus
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fsm_done_handler_t
name|ses_process_control_request
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fsm_done_handler_t
name|ses_publish_physpaths
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fsm_done_handler_t
name|ses_publish_cache
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|enc_fsm_state
name|enc_fsm_states
index|[
name|SES_NUM_UPDATE_STATES
index|]
init|=
block|{
block|{
literal|"SES_UPDATE_NONE"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"SES_UPDATE_PAGES"
block|,
name|SesSupportedPages
block|,
name|SCSZ
block|,
literal|60
operator|*
literal|1000
block|,
name|ses_fill_rcv_diag_io
block|,
name|ses_process_pages
block|,
name|enc_error
block|}
block|,
block|{
literal|"SES_UPDATE_GETCONFIG"
block|,
name|SesConfigPage
block|,
name|SCSZ
block|,
literal|60
operator|*
literal|1000
block|,
name|ses_fill_rcv_diag_io
block|,
name|ses_process_config
block|,
name|enc_error
block|}
block|,
block|{
literal|"SES_UPDATE_GETSTATUS"
block|,
name|SesStatusPage
block|,
name|SCSZ
block|,
literal|60
operator|*
literal|1000
block|,
name|ses_fill_rcv_diag_io
block|,
name|ses_process_status
block|,
name|enc_error
block|}
block|,
block|{
literal|"SES_UPDATE_GETELMDESCS"
block|,
name|SesElementDescriptor
block|,
name|SCSZ
block|,
literal|60
operator|*
literal|1000
block|,
name|ses_fill_rcv_diag_io
block|,
name|ses_process_elm_descs
block|,
name|enc_error
block|}
block|,
block|{
literal|"SES_UPDATE_GETELMADDLSTATUS"
block|,
name|SesAddlElementStatus
block|,
name|SCSZ
block|,
literal|60
operator|*
literal|1000
block|,
name|ses_fill_rcv_diag_io
block|,
name|ses_process_elm_addlstatus
block|,
name|enc_error
block|}
block|,
block|{
literal|"SES_PROCESS_CONTROL_REQS"
block|,
name|SesControlPage
block|,
name|SCSZ
block|,
literal|60
operator|*
literal|1000
block|,
name|ses_fill_control_request
block|,
name|ses_process_control_request
block|,
name|enc_error
block|}
block|,
block|{
literal|"SES_PUBLISH_PHYSPATHS"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|ses_publish_physpaths
block|,
name|NULL
block|}
block|,
block|{
literal|"SES_PUBLISH_CACHE"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|ses_publish_cache
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|ses_cache
block|{
comment|/* Source for all the configuration data pointers */
specifier|const
name|struct
name|ses_cfg_page
modifier|*
name|cfg_page
decl_stmt|;
comment|/* References into the config page. */
name|int
name|ses_nsubencs
decl_stmt|;
specifier|const
name|struct
name|ses_enc_desc
modifier|*
specifier|const
modifier|*
name|subencs
decl_stmt|;
name|int
name|ses_ntypes
decl_stmt|;
specifier|const
name|ses_type_t
modifier|*
name|ses_types
decl_stmt|;
comment|/* Source for all the status pointers */
specifier|const
name|struct
name|ses_status_page
modifier|*
name|status_page
decl_stmt|;
comment|/* Source for all the object descriptor pointers */
specifier|const
name|struct
name|ses_elem_descr_page
modifier|*
name|elm_descs_page
decl_stmt|;
comment|/* Source for all the additional object status pointers */
specifier|const
name|struct
name|ses_addl_elem_status_page
modifier|*
name|elm_addlstatus_page
decl_stmt|;
block|}
name|ses_cache_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|ses_softc
block|{
name|uint32_t
name|ses_flags
decl_stmt|;
define|#
directive|define
name|SES_FLAG_TIMEDCOMP
value|0x01
define|#
directive|define
name|SES_FLAG_ADDLSTATUS
value|0x02
define|#
directive|define
name|SES_FLAG_DESC
value|0x04
name|ses_control_reqlist_t
name|ses_requests
decl_stmt|;
name|ses_control_reqlist_t
name|ses_pending_requests
decl_stmt|;
block|}
name|ses_softc_t
typedef|;
end_typedef

begin_comment
comment|/**  * \brief Reset a SES iterator to just before the first element  *        in the configuration.  *  * \param iter  The iterator object to reset.  *  * The indexes within a reset iterator are invalid and will only  * become valid upon completion of a ses_iter_seek_to() or a  * ses_iter_next().  */
end_comment

begin_function
specifier|static
name|void
name|ses_iter_reset
parameter_list|(
name|struct
name|ses_iterator
modifier|*
name|iter
parameter_list|)
block|{
comment|/* 	 * Set our indexes to just before the first valid element 	 * of the first type (ITERATOR_INDEX_INVALID == -1).  This 	 * simplifies the implementation of ses_iter_next(). 	 */
name|iter
operator|->
name|type_index
operator|=
literal|0
expr_stmt|;
name|iter
operator|->
name|type_element_index
operator|=
name|ITERATOR_INDEX_INVALID
expr_stmt|;
name|iter
operator|->
name|global_element_index
operator|=
name|ITERATOR_INDEX_INVALID
expr_stmt|;
name|iter
operator|->
name|individual_element_index
operator|=
name|ITERATOR_INDEX_INVALID
expr_stmt|;
name|iter
operator|->
name|saved_individual_element_index
operator|=
name|ITERATOR_INDEX_INVALID
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * \brief Initialize the storage of a SES iterator and reset it to  *        the position just before the first element of the  *        configuration.  *  * \param enc	The SES softc for the SES instance whose configuration  *              will be enumerated by this iterator.  * \param iter  The iterator object to initialize.  */
end_comment

begin_function
specifier|static
name|void
name|ses_iter_init
parameter_list|(
name|enc_softc_t
modifier|*
name|enc
parameter_list|,
name|enc_cache_t
modifier|*
name|cache
parameter_list|,
name|struct
name|ses_iterator
modifier|*
name|iter
parameter_list|)
block|{
name|iter
operator|->
name|enc
operator|=
name|enc
expr_stmt|;
name|iter
operator|->
name|cache
operator|=
name|cache
expr_stmt|;
name|ses_iter_reset
argument_list|(
name|iter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * \brief Traverse the provided SES iterator to the next element  *        within the configuraiton.  *  * \param iter  The iterator to move.  *  * \return  If a valid next element exists, a pointer to it's enc_element_t.  *          Otherwise NULL.  */
end_comment

begin_function
specifier|static
name|enc_element_t
modifier|*
name|ses_iter_next
parameter_list|(
name|struct
name|ses_iterator
modifier|*
name|iter
parameter_list|)
block|{
name|ses_cache_t
modifier|*
name|ses_cache
decl_stmt|;
specifier|const
name|ses_type_t
modifier|*
name|element_type
decl_stmt|;
name|ses_cache
operator|=
name|iter
operator|->
name|cache
operator|->
name|private
expr_stmt|;
comment|/* 	 * Note: Treat nelms as signed, so we will hit this case 	 *       and immediately terminate the iteration if the 	 *	 configuration has 0 objects. 	 */
if|if
condition|(
name|iter
operator|->
name|global_element_index
operator|>=
operator|(
name|int
operator|)
name|iter
operator|->
name|cache
operator|->
name|nelms
operator|-
literal|1
condition|)
block|{
comment|/* Elements exhausted. */
name|iter
operator|->
name|type_index
operator|=
name|ITERATOR_INDEX_END
expr_stmt|;
name|iter
operator|->
name|type_element_index
operator|=
name|ITERATOR_INDEX_END
expr_stmt|;
name|iter
operator|->
name|global_element_index
operator|=
name|ITERATOR_INDEX_END
expr_stmt|;
name|iter
operator|->
name|individual_element_index
operator|=
name|ITERATOR_INDEX_END
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|KASSERT
argument_list|(
operator|(
name|iter
operator|->
name|type_index
operator|<
name|ses_cache
operator|->
name|ses_ntypes
operator|)
argument_list|,
operator|(
literal|"Corrupted element iterator. %d not less than %d"
operator|,
name|iter
operator|->
name|type_index
operator|,
name|ses_cache
operator|->
name|ses_ntypes
operator|)
argument_list|)
expr_stmt|;
name|element_type
operator|=
operator|&
name|ses_cache
operator|->
name|ses_types
index|[
name|iter
operator|->
name|type_index
index|]
expr_stmt|;
name|iter
operator|->
name|global_element_index
operator|++
expr_stmt|;
name|iter
operator|->
name|type_element_index
operator|++
expr_stmt|;
comment|/* 	 * There is an object for overal type status in addition 	 * to one for each allowed element, but only if the element 	 * count is non-zero. 	 */
if|if
condition|(
name|iter
operator|->
name|type_element_index
operator|>
name|element_type
operator|->
name|hdr
operator|->
name|etype_maxelt
condition|)
block|{
comment|/* 		 * We've exhausted the elements of this type. 		 * This next element belongs to the next type. 		 */
name|iter
operator|->
name|type_index
operator|++
expr_stmt|;
name|iter
operator|->
name|type_element_index
operator|=
literal|0
expr_stmt|;
name|iter
operator|->
name|saved_individual_element_index
operator|=
name|iter
operator|->
name|individual_element_index
expr_stmt|;
name|iter
operator|->
name|individual_element_index
operator|=
name|ITERATOR_INDEX_INVALID
expr_stmt|;
block|}
if|if
condition|(
name|iter
operator|->
name|type_element_index
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|iter
operator|->
name|type_element_index
operator|==
literal|1
condition|)
block|{
name|iter
operator|->
name|individual_element_index
operator|=
name|iter
operator|->
name|saved_individual_element_index
expr_stmt|;
block|}
name|iter
operator|->
name|individual_element_index
operator|++
expr_stmt|;
block|}
return|return
operator|(
operator|&
name|iter
operator|->
name|cache
operator|->
name|elm_map
index|[
name|iter
operator|->
name|global_element_index
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Element index types tracked by a SES iterator.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
comment|/** 	 * Index relative to all elements (overall and individual) 	 * in the system. 	 */
name|SES_ELEM_INDEX_GLOBAL
block|,
comment|/** 	 * \brief Index relative to all individual elements in the system. 	 * 	 * This index counts only individual elements, skipping overall 	 * status elements.  This is the index space of the additional 	 * element status page (page 0xa). 	 */
name|SES_ELEM_INDEX_INDIVIDUAL
block|}
name|ses_elem_index_type_t
typedef|;
end_typedef

begin_comment
comment|/**  * \brief Move the provided iterator forwards or backwards to the object   *        having the give index.  *  * \param iter           The iterator on which to perform the seek.  * \param element_index  The index of the element to find.  * \param index_type     The type (global or individual) of element_index.  *  * \return  If the element is found, a pointer to it's enc_element_t.  *          Otherwise NULL.  */
end_comment

begin_function
specifier|static
name|enc_element_t
modifier|*
name|ses_iter_seek_to
parameter_list|(
name|struct
name|ses_iterator
modifier|*
name|iter
parameter_list|,
name|int
name|element_index
parameter_list|,
name|ses_elem_index_type_t
name|index_type
parameter_list|)
block|{
name|enc_element_t
modifier|*
name|element
decl_stmt|;
name|int
modifier|*
name|cur_index
decl_stmt|;
if|if
condition|(
name|index_type
operator|==
name|SES_ELEM_INDEX_GLOBAL
condition|)
name|cur_index
operator|=
operator|&
name|iter
operator|->
name|global_element_index
expr_stmt|;
else|else
name|cur_index
operator|=
operator|&
name|iter
operator|->
name|individual_element_index
expr_stmt|;
if|if
condition|(
operator|*
name|cur_index
operator|==
name|element_index
condition|)
block|{
comment|/* Already there. */
return|return
operator|(
operator|&
name|iter
operator|->
name|cache
operator|->
name|elm_map
index|[
name|iter
operator|->
name|global_element_index
index|]
operator|)
return|;
block|}
name|ses_iter_reset
argument_list|(
name|iter
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|element
operator|=
name|ses_iter_next
argument_list|(
name|iter
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|*
name|cur_index
operator|!=
name|element_index
condition|)
empty_stmt|;
if|if
condition|(
operator|*
name|cur_index
operator|!=
name|element_index
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|element
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int ses_encode(enc_softc_t *, uint8_t *, int, int,     struct ses_comstat *);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|ses_set_timed_completion
parameter_list|(
name|enc_softc_t
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int ses_putstatus(enc_softc_t *, int, struct ses_comstat *);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|ses_poll_status
parameter_list|(
name|enc_softc_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ses_print_addl_data
parameter_list|(
name|enc_softc_t
modifier|*
parameter_list|,
name|enc_element_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*=========================== SES cleanup routines ===========================*/
end_comment

begin_function
specifier|static
name|void
name|ses_cache_free_elm_addlstatus
parameter_list|(
name|enc_softc_t
modifier|*
name|enc
parameter_list|,
name|enc_cache_t
modifier|*
name|cache
parameter_list|)
block|{
name|ses_cache_t
modifier|*
name|ses_cache
decl_stmt|;
name|ses_cache_t
modifier|*
name|other_ses_cache
decl_stmt|;
name|enc_element_t
modifier|*
name|cur_elm
decl_stmt|;
name|enc_element_t
modifier|*
name|last_elm
decl_stmt|;
name|ENC_DLOG
argument_list|(
name|enc
argument_list|,
literal|"%s: enter\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ses_cache
operator|=
name|cache
operator|->
name|private
expr_stmt|;
if|if
condition|(
name|ses_cache
operator|->
name|elm_addlstatus_page
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|cur_elm
operator|=
name|cache
operator|->
name|elm_map
operator|,
name|last_elm
operator|=
operator|&
name|cache
operator|->
name|elm_map
index|[
name|cache
operator|->
name|nelms
index|]
init|;
name|cur_elm
operator|!=
name|last_elm
condition|;
name|cur_elm
operator|++
control|)
block|{
name|ses_element_t
modifier|*
name|elmpriv
decl_stmt|;
name|elmpriv
operator|=
name|cur_elm
operator|->
name|elm_private
expr_stmt|;
comment|/* Clear references to the additional status page. */
name|bzero
argument_list|(
operator|&
name|elmpriv
operator|->
name|addl
argument_list|,
sizeof|sizeof
argument_list|(
name|elmpriv
operator|->
name|addl
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|other_ses_cache
operator|=
name|enc_other_cache
argument_list|(
name|enc
argument_list|,
name|cache
argument_list|)
operator|->
name|private
expr_stmt|;
if|if
condition|(
name|other_ses_cache
operator|->
name|elm_addlstatus_page
operator|!=
name|ses_cache
operator|->
name|elm_addlstatus_page
condition|)
name|ENC_FREE
argument_list|(
name|ses_cache
operator|->
name|elm_addlstatus_page
argument_list|)
expr_stmt|;
name|ses_cache
operator|->
name|elm_addlstatus_page
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ses_cache_free_elm_descs
parameter_list|(
name|enc_softc_t
modifier|*
name|enc
parameter_list|,
name|enc_cache_t
modifier|*
name|cache
parameter_list|)
block|{
name|ses_cache_t
modifier|*
name|ses_cache
decl_stmt|;
name|ses_cache_t
modifier|*
name|other_ses_cache
decl_stmt|;
name|enc_element_t
modifier|*
name|cur_elm
decl_stmt|;
name|enc_element_t
modifier|*
name|last_elm
decl_stmt|;
name|ENC_DLOG
argument_list|(
name|enc
argument_list|,
literal|"%s: enter\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ses_cache
operator|=
name|cache
operator|->
name|private
expr_stmt|;
if|if
condition|(
name|ses_cache
operator|->
name|elm_descs_page
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|cur_elm
operator|=
name|cache
operator|->
name|elm_map
operator|,
name|last_elm
operator|=
operator|&
name|cache
operator|->
name|elm_map
index|[
name|cache
operator|->
name|nelms
index|]
init|;
name|cur_elm
operator|!=
name|last_elm
condition|;
name|cur_elm
operator|++
control|)
block|{
name|ses_element_t
modifier|*
name|elmpriv
decl_stmt|;
name|elmpriv
operator|=
name|cur_elm
operator|->
name|elm_private
expr_stmt|;
name|elmpriv
operator|->
name|descr_len
operator|=
literal|0
expr_stmt|;
name|elmpriv
operator|->
name|descr
operator|=
name|NULL
expr_stmt|;
block|}
name|other_ses_cache
operator|=
name|enc_other_cache
argument_list|(
name|enc
argument_list|,
name|cache
argument_list|)
operator|->
name|private
expr_stmt|;
if|if
condition|(
name|other_ses_cache
operator|->
name|elm_descs_page
operator|!=
name|ses_cache
operator|->
name|elm_descs_page
condition|)
name|ENC_FREE
argument_list|(
name|ses_cache
operator|->
name|elm_descs_page
argument_list|)
expr_stmt|;
name|ses_cache
operator|->
name|elm_descs_page
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ses_cache_free_status
parameter_list|(
name|enc_softc_t
modifier|*
name|enc
parameter_list|,
name|enc_cache_t
modifier|*
name|cache
parameter_list|)
block|{
name|ses_cache_t
modifier|*
name|ses_cache
decl_stmt|;
name|ses_cache_t
modifier|*
name|other_ses_cache
decl_stmt|;
name|ENC_DLOG
argument_list|(
name|enc
argument_list|,
literal|"%s: enter\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ses_cache
operator|=
name|cache
operator|->
name|private
expr_stmt|;
if|if
condition|(
name|ses_cache
operator|->
name|status_page
operator|==
name|NULL
condition|)
return|return;
name|other_ses_cache
operator|=
name|enc_other_cache
argument_list|(
name|enc
argument_list|,
name|cache
argument_list|)
operator|->
name|private
expr_stmt|;
if|if
condition|(
name|other_ses_cache
operator|->
name|status_page
operator|!=
name|ses_cache
operator|->
name|status_page
condition|)
name|ENC_FREE
argument_list|(
name|ses_cache
operator|->
name|status_page
argument_list|)
expr_stmt|;
name|ses_cache
operator|->
name|status_page
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ses_cache_free_elm_map
parameter_list|(
name|enc_softc_t
modifier|*
name|enc
parameter_list|,
name|enc_cache_t
modifier|*
name|cache
parameter_list|)
block|{
name|enc_element_t
modifier|*
name|cur_elm
decl_stmt|;
name|enc_element_t
modifier|*
name|last_elm
decl_stmt|;
name|ENC_DLOG
argument_list|(
name|enc
argument_list|,
literal|"%s: enter\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|elm_map
operator|==
name|NULL
condition|)
return|return;
name|ses_cache_free_elm_descs
argument_list|(
name|enc
argument_list|,
name|cache
argument_list|)
expr_stmt|;
name|ses_cache_free_elm_addlstatus
argument_list|(
name|enc
argument_list|,
name|cache
argument_list|)
expr_stmt|;
for|for
control|(
name|cur_elm
operator|=
name|cache
operator|->
name|elm_map
operator|,
name|last_elm
operator|=
operator|&
name|cache
operator|->
name|elm_map
index|[
name|cache
operator|->
name|nelms
index|]
init|;
name|cur_elm
operator|!=
name|last_elm
condition|;
name|cur_elm
operator|++
control|)
block|{
name|ENC_FREE_AND_NULL
argument_list|(
name|cur_elm
operator|->
name|elm_private
argument_list|)
expr_stmt|;
block|}
name|ENC_FREE_AND_NULL
argument_list|(
name|cache
operator|->
name|elm_map
argument_list|)
expr_stmt|;
name|cache
operator|->
name|nelms
operator|=
literal|0
expr_stmt|;
name|ENC_DLOG
argument_list|(
name|enc
argument_list|,
literal|"%s: exit\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ses_cache_free
parameter_list|(
name|enc_softc_t
modifier|*
name|enc
parameter_list|,
name|enc_cache_t
modifier|*
name|cache
parameter_list|)
block|{
name|ses_cache_t
modifier|*
name|other_ses_cache
decl_stmt|;
name|ses_cache_t
modifier|*
name|ses_cache
decl_stmt|;
name|ENC_DLOG
argument_list|(
name|enc
argument_list|,
literal|"%s: enter\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ses_cache_free_elm_addlstatus
argument_list|(
name|enc
argument_list|,
name|cache
argument_list|)
expr_stmt|;
name|ses_cache_free_status
argument_list|(
name|enc
argument_list|,
name|cache
argument_list|)
expr_stmt|;
name|ses_cache_free_elm_map
argument_list|(
name|enc
argument_list|,
name|cache
argument_list|)
expr_stmt|;
name|ses_cache
operator|=
name|cache
operator|->
name|private
expr_stmt|;
name|ses_cache
operator|->
name|ses_ntypes
operator|=
literal|0
expr_stmt|;
name|other_ses_cache
operator|=
name|enc_other_cache
argument_list|(
name|enc
argument_list|,
name|cache
argument_list|)
operator|->
name|private
expr_stmt|;
if|if
condition|(
name|other_ses_cache
operator|->
name|subencs
operator|!=
name|ses_cache
operator|->
name|subencs
condition|)
name|ENC_FREE
argument_list|(
name|ses_cache
operator|->
name|subencs
argument_list|)
expr_stmt|;
name|ses_cache
operator|->
name|subencs
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|other_ses_cache
operator|->
name|ses_types
operator|!=
name|ses_cache
operator|->
name|ses_types
condition|)
name|ENC_FREE
argument_list|(
name|ses_cache
operator|->
name|ses_types
argument_list|)
expr_stmt|;
name|ses_cache
operator|->
name|ses_types
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|other_ses_cache
operator|->
name|cfg_page
operator|!=
name|ses_cache
operator|->
name|cfg_page
condition|)
name|ENC_FREE
argument_list|(
name|ses_cache
operator|->
name|cfg_page
argument_list|)
expr_stmt|;
name|ses_cache
operator|->
name|cfg_page
operator|=
name|NULL
expr_stmt|;
name|ENC_DLOG
argument_list|(
name|enc
argument_list|,
literal|"%s: exit\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ses_cache_clone
parameter_list|(
name|enc_softc_t
modifier|*
name|enc
parameter_list|,
name|enc_cache_t
modifier|*
name|src
parameter_list|,
name|enc_cache_t
modifier|*
name|dst
parameter_list|)
block|{
name|ses_cache_t
modifier|*
name|dst_ses_cache
decl_stmt|;
name|ses_cache_t
modifier|*
name|src_ses_cache
decl_stmt|;
name|enc_element_t
modifier|*
name|src_elm
decl_stmt|;
name|enc_element_t
modifier|*
name|dst_elm
decl_stmt|;
name|enc_element_t
modifier|*
name|last_elm
decl_stmt|;
name|ses_cache_free
argument_list|(
name|enc
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|src_ses_cache
operator|=
name|src
operator|->
name|private
expr_stmt|;
name|dst_ses_cache
operator|=
name|dst
operator|->
name|private
expr_stmt|;
comment|/* 	 * The cloned enclosure cache and ses specific cache are 	 * mostly identical to the source. 	 */
operator|*
name|dst
operator|=
operator|*
name|src
expr_stmt|;
operator|*
name|dst_ses_cache
operator|=
operator|*
name|src_ses_cache
expr_stmt|;
comment|/* 	 * But the ses cache storage is still independent.  Restore 	 * the pointer that was clobbered by the structure copy above. 	 */
name|dst
operator|->
name|private
operator|=
name|dst_ses_cache
expr_stmt|;
comment|/* 	 * The element map is independent even though it starts out 	 * pointing to the same constant page data. 	 */
name|dst
operator|->
name|elm_map
operator|=
name|malloc
argument_list|(
name|dst
operator|->
name|nelms
operator|*
sizeof|sizeof
argument_list|(
name|enc_element_t
argument_list|)
argument_list|,
name|M_SCSIENC
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dst
operator|->
name|elm_map
argument_list|,
name|src
operator|->
name|elm_map
argument_list|,
name|dst
operator|->
name|nelms
operator|*
sizeof|sizeof
argument_list|(
name|enc_element_t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|dst_elm
operator|=
name|dst
operator|->
name|elm_map
operator|,
name|src_elm
operator|=
name|src
operator|->
name|elm_map
operator|,
name|last_elm
operator|=
operator|&
name|src
operator|->
name|elm_map
index|[
name|src
operator|->
name|nelms
index|]
init|;
name|src_elm
operator|!=
name|last_elm
condition|;
name|src_elm
operator|++
operator|,
name|dst_elm
operator|++
control|)
block|{
name|dst_elm
operator|->
name|elm_private
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ses_element_t
argument_list|)
argument_list|,
name|M_SCSIENC
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dst_elm
operator|->
name|elm_private
argument_list|,
name|src_elm
operator|->
name|elm_private
argument_list|,
sizeof|sizeof
argument_list|(
name|ses_element_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Structure accessors.  These are strongly typed to avoid errors. */
end_comment

begin_function
name|int
name|ses_elm_sas_descr_type
parameter_list|(
name|union
name|ses_elm_sas_hdr
modifier|*
name|obj
parameter_list|)
block|{
return|return
operator|(
operator|(
name|obj
operator|)
operator|->
name|base_hdr
operator|.
name|byte1
operator|>>
literal|6
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ses_elm_addlstatus_proto
parameter_list|(
name|struct
name|ses_elm_addlstatus_base_hdr
modifier|*
name|hdr
parameter_list|)
block|{
return|return
operator|(
operator|(
name|hdr
operator|)
operator|->
name|byte0
operator|&
literal|0xf
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ses_elm_addlstatus_eip
parameter_list|(
name|struct
name|ses_elm_addlstatus_base_hdr
modifier|*
name|hdr
parameter_list|)
block|{
return|return
operator|(
operator|(
name|hdr
operator|)
operator|->
name|byte0
operator|>>
literal|4
operator|)
operator|&
literal|0x1
return|;
block|}
end_function

begin_function
name|int
name|ses_elm_addlstatus_invalid
parameter_list|(
name|struct
name|ses_elm_addlstatus_base_hdr
modifier|*
name|hdr
parameter_list|)
block|{
return|return
operator|(
operator|(
name|hdr
operator|)
operator|->
name|byte0
operator|>>
literal|7
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ses_elm_sas_type0_not_all_phys
parameter_list|(
name|union
name|ses_elm_sas_hdr
modifier|*
name|hdr
parameter_list|)
block|{
return|return
operator|(
operator|(
name|hdr
operator|)
operator|->
name|type0_noneip
operator|.
name|byte1
operator|&
literal|0x1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ses_elm_sas_dev_phy_sata_dev
parameter_list|(
name|struct
name|ses_elm_sas_device_phy
modifier|*
name|phy
parameter_list|)
block|{
return|return
operator|(
operator|(
name|phy
operator|)
operator|->
name|target_ports
operator|&
literal|0x1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ses_elm_sas_dev_phy_sata_port
parameter_list|(
name|struct
name|ses_elm_sas_device_phy
modifier|*
name|phy
parameter_list|)
block|{
return|return
operator|(
operator|(
name|phy
operator|)
operator|->
name|target_ports
operator|>>
literal|7
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ses_elm_sas_dev_phy_dev_type
parameter_list|(
name|struct
name|ses_elm_sas_device_phy
modifier|*
name|phy
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|phy
operator|)
operator|->
name|byte0
operator|>>
literal|4
operator|)
operator|&
literal|0x7
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * \brief Verify that the cached configuration data in our softc  *        is valid for processing the page data corresponding to  *        the provided page header.  *  * \param ses_cache The SES cache to validate.  * \param gen_code  The 4 byte generation code from a SES diagnostic  *		    page header.  *  * \return  non-zero if true, 0 if false.  */
end_comment

begin_function
specifier|static
name|int
name|ses_config_cache_valid
parameter_list|(
name|ses_cache_t
modifier|*
name|ses_cache
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|gen_code
parameter_list|)
block|{
name|uint32_t
name|cache_gc
decl_stmt|;
name|uint32_t
name|cur_gc
decl_stmt|;
if|if
condition|(
name|ses_cache
operator|->
name|cfg_page
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|cache_gc
operator|=
name|scsi_4btoul
argument_list|(
name|ses_cache
operator|->
name|cfg_page
operator|->
name|hdr
operator|.
name|gen_code
argument_list|)
expr_stmt|;
name|cur_gc
operator|=
name|scsi_4btoul
argument_list|(
name|gen_code
argument_list|)
expr_stmt|;
return|return
operator|(
name|cache_gc
operator|==
name|cur_gc
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Function signature for consumers of the ses_devids_iter() interface.  */
end_comment

begin_typedef
typedef|typedef
name|void
name|ses_devid_callback_t
parameter_list|(
name|enc_softc_t
modifier|*
parameter_list|,
name|enc_element_t
modifier|*
parameter_list|,
name|struct
name|scsi_vpd_id_descriptor
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/**  * \brief Iterate over and create vpd device id records from the  *        additional element status data for elm, passing that data  *        to the provided callback.  *  * \param enc	        SES instance containing elm  * \param elm	        Element for which to extract device ID data.  * \param callback      The callback function to invoke on each generated  *                      device id descriptor for elm.  * \param callback_arg  Argument passed through to callback on each invocation.  */
end_comment

begin_function
specifier|static
name|void
name|ses_devids_iter
parameter_list|(
name|enc_softc_t
modifier|*
name|enc
parameter_list|,
name|enc_element_t
modifier|*
name|elm
parameter_list|,
name|ses_devid_callback_t
modifier|*
name|callback
parameter_list|,
name|void
modifier|*
name|callback_arg
parameter_list|)
block|{
name|ses_element_t
modifier|*
name|elmpriv
decl_stmt|;
name|struct
name|ses_addl_status
modifier|*
name|addl
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|size_t
name|devid_record_size
decl_stmt|;
name|elmpriv
operator|=
name|elm
operator|->
name|elm_private
expr_stmt|;
name|addl
operator|=
operator|&
operator|(
name|elmpriv
operator|->
name|addl
operator|)
expr_stmt|;
comment|/* 	 * Don't assume this object has additional status information, or 	 * that it is a SAS device, or that it is a device slot device. 	 */
if|if
condition|(
name|addl
operator|->
name|hdr
operator|==
name|NULL
operator|||
name|addl
operator|->
name|proto_hdr
operator|.
name|sas
operator|==
name|NULL
operator|||
name|addl
operator|->
name|proto_data
operator|.
name|sasdev_phys
operator|==
name|NULL
condition|)
return|return;
name|devid_record_size
operator|=
name|SVPD_DEVICE_ID_DESC_HDR_LEN
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_id_naa_ieee_reg
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|addl
operator|->
name|proto_hdr
operator|.
name|sas
operator|->
name|base_hdr
operator|.
name|num_phys
condition|;
name|i
operator|++
control|)
block|{
name|uint8_t
name|devid_buf
index|[
name|devid_record_size
index|]
decl_stmt|;
name|struct
name|scsi_vpd_id_descriptor
modifier|*
name|devid
decl_stmt|;
name|uint8_t
modifier|*
name|phy_addr
decl_stmt|;
name|devid
operator|=
operator|(
expr|struct
name|scsi_vpd_id_descriptor
operator|*
operator|)
name|devid_buf
expr_stmt|;
name|phy_addr
operator|=
name|addl
operator|->
name|proto_data
operator|.
name|sasdev_phys
index|[
name|i
index|]
operator|.
name|phy_addr
expr_stmt|;
name|devid
operator|->
name|proto_codeset
operator|=
operator|(
name|SCSI_PROTO_SAS
operator|<<
name|SVPD_ID_PROTO_SHIFT
operator|)
operator||
name|SVPD_ID_CODESET_BINARY
expr_stmt|;
name|devid
operator|->
name|id_type
operator|=
name|SVPD_ID_PIV
operator||
name|SVPD_ID_ASSOC_PORT
operator||
name|SVPD_ID_TYPE_NAA
expr_stmt|;
name|devid
operator|->
name|reserved
operator|=
literal|0
expr_stmt|;
name|devid
operator|->
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_id_naa_ieee_reg
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|devid
operator|->
name|identifier
argument_list|,
name|phy_addr
argument_list|,
name|devid
operator|->
name|length
argument_list|)
expr_stmt|;
name|callback
argument_list|(
name|enc
argument_list|,
name|elm
argument_list|,
name|devid
argument_list|,
name|callback_arg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Function signature for consumers of the ses_paths_iter() interface.  */
end_comment

begin_typedef
typedef|typedef
name|void
name|ses_path_callback_t
parameter_list|(
name|enc_softc_t
modifier|*
parameter_list|,
name|enc_element_t
modifier|*
parameter_list|,
name|struct
name|cam_path
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/**  * Argument package passed through ses_devids_iter() by  * ses_paths_iter() to ses_path_iter_devid_callback().  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ses_path_iter_args
block|{
name|ses_path_callback_t
modifier|*
name|callback
decl_stmt|;
name|void
modifier|*
name|callback_arg
decl_stmt|;
block|}
name|ses_path_iter_args_t
typedef|;
end_typedef

begin_comment
comment|/**  * ses_devids_iter() callback function used by ses_paths_iter()  * to map device ids to peripheral driver instances.  *  * \param enc	  SES instance containing elm  * \param elm	  Element on which device ID matching is active.  * \param periph  A device ID corresponding to elm.  * \param arg     Argument passed through to callback on each invocation.  */
end_comment

begin_function
specifier|static
name|void
name|ses_path_iter_devid_callback
parameter_list|(
name|enc_softc_t
modifier|*
name|enc
parameter_list|,
name|enc_element_t
modifier|*
name|elem
parameter_list|,
name|struct
name|scsi_vpd_id_descriptor
modifier|*
name|devid
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ccb_dev_match
name|cdm
decl_stmt|;
name|struct
name|dev_match_pattern
name|match_pattern
decl_stmt|;
name|struct
name|dev_match_result
name|match_result
decl_stmt|;
name|struct
name|device_match_result
modifier|*
name|device_match
decl_stmt|;
name|struct
name|device_match_pattern
modifier|*
name|device_pattern
decl_stmt|;
name|ses_path_iter_args_t
modifier|*
name|args
decl_stmt|;
name|args
operator|=
operator|(
name|ses_path_iter_args_t
operator|*
operator|)
name|arg
expr_stmt|;
name|match_pattern
operator|.
name|type
operator|=
name|DEV_MATCH_DEVICE
expr_stmt|;
name|device_pattern
operator|=
operator|&
name|match_pattern
operator|.
name|pattern
operator|.
name|device_pattern
expr_stmt|;
name|device_pattern
operator|->
name|flags
operator|=
name|DEV_MATCH_DEVID
expr_stmt|;
name|device_pattern
operator|->
name|data
operator|.
name|devid_pat
operator|.
name|id_len
operator|=
name|offsetof
argument_list|(
expr|struct
name|scsi_vpd_id_descriptor
argument_list|,
name|identifier
argument_list|)
operator|+
name|devid
operator|->
name|length
expr_stmt|;
name|memcpy
argument_list|(
name|device_pattern
operator|->
name|data
operator|.
name|devid_pat
operator|.
name|id
argument_list|,
name|devid
argument_list|,
name|device_pattern
operator|->
name|data
operator|.
name|devid_pat
operator|.
name|id_len
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cdm
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cdm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|cdm
operator|.
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|CAM_XPT_PATH_ID
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
return|return;
name|cdm
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_DEV_MATCH
expr_stmt|;
name|cdm
operator|.
name|num_patterns
operator|=
literal|1
expr_stmt|;
name|cdm
operator|.
name|patterns
operator|=
operator|&
name|match_pattern
expr_stmt|;
name|cdm
operator|.
name|pattern_buf_len
operator|=
sizeof|sizeof
argument_list|(
name|match_pattern
argument_list|)
expr_stmt|;
name|cdm
operator|.
name|match_buf_len
operator|=
sizeof|sizeof
argument_list|(
name|match_result
argument_list|)
expr_stmt|;
name|cdm
operator|.
name|matches
operator|=
operator|&
name|match_result
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|cdm
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|cdm
operator|.
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cdm
operator|.
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
operator|||
operator|(
name|cdm
operator|.
name|status
operator|!=
name|CAM_DEV_MATCH_LAST
operator|&&
name|cdm
operator|.
name|status
operator|!=
name|CAM_DEV_MATCH_MORE
operator|)
operator|||
name|cdm
operator|.
name|num_matches
operator|==
literal|0
condition|)
return|return;
name|device_match
operator|=
operator|&
name|match_result
operator|.
name|result
operator|.
name|device_result
expr_stmt|;
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|cdm
operator|.
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|device_match
operator|->
name|path_id
argument_list|,
name|device_match
operator|->
name|target_id
argument_list|,
name|device_match
operator|->
name|target_lun
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
return|return;
name|args
operator|->
name|callback
argument_list|(
name|enc
argument_list|,
name|elem
argument_list|,
name|cdm
operator|.
name|ccb_h
operator|.
name|path
argument_list|,
name|args
operator|->
name|callback_arg
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|cdm
operator|.
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * \brief Iterate over and find the matching periph objects for the  *        specified element.  *  * \param enc	        SES instance containing elm  * \param elm	        Element for which to perform periph object matching.  * \param callback      The callback function to invoke with each matching  *                      periph object.  * \param callback_arg  Argument passed through to callback on each invocation.  */
end_comment

begin_function
specifier|static
name|void
name|ses_paths_iter
parameter_list|(
name|enc_softc_t
modifier|*
name|enc
parameter_list|,
name|enc_element_t
modifier|*
name|elm
parameter_list|,
name|ses_path_callback_t
modifier|*
name|callback
parameter_list|,
name|void
modifier|*
name|callback_arg
parameter_list|)
block|{
name|ses_path_iter_args_t
name|args
decl_stmt|;
name|args
operator|.
name|callback
operator|=
name|callback
expr_stmt|;
name|args
operator|.
name|callback_arg
operator|=
name|callback_arg
expr_stmt|;
name|ses_devids_iter
argument_list|(
name|enc
argument_list|,
name|elm
argument_list|,
name|ses_path_iter_devid_callback
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ses_paths_iter() callback function used by ses_get_elmdevname()  * to record periph driver instance strings corresponding to a SES  * element.  *  * \param enc	  SES instance containing elm  * \param elm	  Element on which periph matching is active.  * \param periph  A periph instance that matches elm.  * \param arg     Argument passed through to callback on each invocation.  */
end_comment

begin_function
specifier|static
name|void
name|ses_elmdevname_callback
parameter_list|(
name|enc_softc_t
modifier|*
name|enc
parameter_list|,
name|enc_element_t
modifier|*
name|elem
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|sb
operator|=
operator|(
expr|struct
name|sbuf
operator|*
operator|)
name|arg
expr_stmt|;
name|cam_periph_list
argument_list|(
name|path
argument_list|,
name|sb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Argument package passed through ses_paths_iter() to  * ses_getcampath_callback.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ses_setphyspath_callback_args
block|{
name|struct
name|sbuf
modifier|*
name|physpath
decl_stmt|;
name|int
name|num_set
decl_stmt|;
block|}
name|ses_setphyspath_callback_args_t
typedef|;
end_typedef

begin_comment
comment|/**  * \brief ses_paths_iter() callback to set the physical path on the  *        CAM EDT entries corresponding to a given SES element.  *  * \param enc	  SES instance containing elm  * \param elm	  Element on which periph matching is active.  * \param periph  A periph instance that matches elm.  * \param arg     Argument passed through to callback on each invocation.  */
end_comment

begin_function
specifier|static
name|void
name|ses_setphyspath_callback
parameter_list|(
name|enc_softc_t
modifier|*
name|enc
parameter_list|,
name|enc_element_t
modifier|*
name|elm
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ccb_dev_advinfo
name|cdai
decl_stmt|;
name|ses_setphyspath_callback_args_t
modifier|*
name|args
decl_stmt|;
name|char
modifier|*
name|old_physpath
decl_stmt|;
name|args
operator|=
operator|(
name|ses_setphyspath_callback_args_t
operator|*
operator|)
name|arg
expr_stmt|;
name|old_physpath
operator|=
name|malloc
argument_list|(
name|MAXPATHLEN
argument_list|,
name|M_SCSIENC
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|enc
operator|->
name|periph
argument_list|)
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|cdai
operator|.
name|ccb_h
argument_list|,
name|path
argument_list|,
name|CAM_PRIORITY_NORMAL
argument_list|)
expr_stmt|;
name|cdai
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_DEV_ADVINFO
expr_stmt|;
name|cdai
operator|.
name|buftype
operator|=
name|CDAI_TYPE_PHYS_PATH
expr_stmt|;
name|cdai
operator|.
name|flags
operator|=
name|CDAI_FLAG_NONE
expr_stmt|;
name|cdai
operator|.
name|bufsiz
operator|=
name|MAXPATHLEN
expr_stmt|;
name|cdai
operator|.
name|buf
operator|=
name|old_physpath
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|cdai
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cdai
operator|.
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|!=
literal|0
condition|)
name|cam_release_devq
argument_list|(
name|cdai
operator|.
name|ccb_h
operator|.
name|path
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|old_physpath
argument_list|,
name|sbuf_data
argument_list|(
name|args
operator|->
name|physpath
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|xpt_setup_ccb
argument_list|(
operator|&
name|cdai
operator|.
name|ccb_h
argument_list|,
name|path
argument_list|,
name|CAM_PRIORITY_NORMAL
argument_list|)
expr_stmt|;
name|cdai
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_DEV_ADVINFO
expr_stmt|;
name|cdai
operator|.
name|buftype
operator|=
name|CDAI_TYPE_PHYS_PATH
expr_stmt|;
name|cdai
operator|.
name|flags
operator|=
name|CDAI_FLAG_STORE
expr_stmt|;
name|cdai
operator|.
name|bufsiz
operator|=
name|sbuf_len
argument_list|(
name|args
operator|->
name|physpath
argument_list|)
expr_stmt|;
name|cdai
operator|.
name|buf
operator|=
name|sbuf_data
argument_list|(
name|args
operator|->
name|physpath
argument_list|)
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|cdai
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cdai
operator|.
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|!=
literal|0
condition|)
name|cam_release_devq
argument_list|(
name|cdai
operator|.
name|ccb_h
operator|.
name|path
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdai
operator|.
name|ccb_h
operator|.
name|status
operator|==
name|CAM_REQ_CMP
condition|)
name|args
operator|->
name|num_set
operator|++
expr_stmt|;
block|}
name|cam_periph_unlock
argument_list|(
name|enc
operator|->
name|periph
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|old_physpath
argument_list|,
name|M_SCSIENC
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * \brief Set a device's physical path string in CAM XPT.  *  * \param enc	SES instance containing elm  * \param elm	Element to publish physical path string for  * \param iter	Iterator whose state corresponds to elm  *  * \return	0 on success, errno otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|ses_set_physpath
parameter_list|(
name|enc_softc_t
modifier|*
name|enc
parameter_list|,
name|enc_element_t
modifier|*
name|elm
parameter_list|,
name|struct
name|ses_iterator
modifier|*
name|iter
parameter_list|)
block|{
name|struct
name|ccb_dev_advinfo
name|cdai
decl_stmt|;
name|ses_setphyspath_callback_args_t
name|args
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
name|struct
name|sbuf
name|sb
decl_stmt|;
name|struct
name|scsi_vpd_id_descriptor
modifier|*
name|idd
decl_stmt|;
name|uint8_t
modifier|*
name|devid
decl_stmt|;
name|ses_element_t
modifier|*
name|elmpriv
decl_stmt|;
specifier|const
name|char
modifier|*
name|c
decl_stmt|;
name|ret
operator|=
name|EIO
expr_stmt|;
name|devid
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Assemble the components of the physical path starting with 	 * the device ID of the enclosure itself. 	 */
name|xpt_setup_ccb
argument_list|(
operator|&
name|cdai
operator|.
name|ccb_h
argument_list|,
name|enc
operator|->
name|periph
operator|->
name|path
argument_list|,
name|CAM_PRIORITY_NORMAL
argument_list|)
expr_stmt|;
name|cdai
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_DEV_ADVINFO
expr_stmt|;
name|cdai
operator|.
name|flags
operator|=
name|CDAI_FLAG_NONE
expr_stmt|;
name|cdai
operator|.
name|buftype
operator|=
name|CDAI_TYPE_SCSI_DEVID
expr_stmt|;
name|cdai
operator|.
name|bufsiz
operator|=
name|CAM_SCSI_DEVID_MAXLEN
expr_stmt|;
name|cdai
operator|.
name|buf
operator|=
name|devid
operator|=
name|malloc
argument_list|(
name|cdai
operator|.
name|bufsiz
argument_list|,
name|M_SCSIENC
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|enc
operator|->
name|periph
argument_list|)
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|cdai
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cdai
operator|.
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|!=
literal|0
condition|)
name|cam_release_devq
argument_list|(
name|cdai
operator|.
name|ccb_h
operator|.
name|path
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|enc
operator|->
name|periph
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdai
operator|.
name|ccb_h
operator|.
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
goto|goto
name|out
goto|;
name|idd
operator|=
name|scsi_get_devid
argument_list|(
operator|(
expr|struct
name|scsi_vpd_device_id
operator|*
operator|)
name|cdai
operator|.
name|buf
argument_list|,
name|cdai
operator|.
name|provsiz
argument_list|,
name|scsi_devid_is_naa_ieee_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|idd
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|sbuf_new
argument_list|(
operator|&
name|sb
argument_list|,
name|NULL
argument_list|,
literal|128
argument_list|,
name|SBUF_AUTOEXTEND
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Next, generate the physical path string */
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"id1,enc@n%jx/type@%x/slot@%x"
argument_list|,
name|scsi_8btou64
argument_list|(
name|idd
operator|->
name|identifier
argument_list|)
argument_list|,
name|iter
operator|->
name|type_index
argument_list|,
name|iter
operator|->
name|type_element_index
argument_list|)
expr_stmt|;
comment|/* Append the element descriptor if one exists */
name|elmpriv
operator|=
name|elm
operator|->
name|elm_private
expr_stmt|;
if|if
condition|(
name|elmpriv
operator|->
name|descr
operator|!=
name|NULL
operator|&&
name|elmpriv
operator|->
name|descr_len
operator|>
literal|0
condition|)
block|{
name|sbuf_cat
argument_list|(
operator|&
name|sb
argument_list|,
literal|"/elmdesc@"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|c
operator|=
name|elmpriv
operator|->
name|descr
init|;
name|i
operator|<
name|elmpriv
operator|->
name|descr_len
condition|;
name|i
operator|++
operator|,
name|c
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isprint
argument_list|(
operator|*
name|c
argument_list|)
operator|||
name|isspace
argument_list|(
operator|*
name|c
argument_list|)
operator|||
operator|*
name|c
operator|==
literal|'/'
condition|)
name|sbuf_putc
argument_list|(
operator|&
name|sb
argument_list|,
literal|'_'
argument_list|)
expr_stmt|;
else|else
name|sbuf_putc
argument_list|(
operator|&
name|sb
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
block|}
block|}
name|sbuf_finish
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
comment|/* 	 * Set this physical path on any CAM devices with a device ID 	 * descriptor that matches one created from the SES additional 	 * status data for this element. 	 */
name|args
operator|.
name|physpath
operator|=
operator|&
name|sb
expr_stmt|;
name|args
operator|.
name|num_set
operator|=
literal|0
expr_stmt|;
name|ses_paths_iter
argument_list|(
name|enc
argument_list|,
name|elm
argument_list|,
name|ses_setphyspath_callback
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|ret
operator|=
name|args
operator|.
name|num_set
operator|==
literal|0
condition|?
name|ENOENT
else|:
literal|0
expr_stmt|;
name|out
label|:
if|if
condition|(
name|devid
operator|!=
name|NULL
condition|)
name|ENC_FREE
argument_list|(
name|devid
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * \brief Helper to set the CDB fields appropriately.  *  * \param cdb		Buffer containing the cdb.  * \param pagenum	SES diagnostic page to query for.  * \param dir		Direction of query.  */
end_comment

begin_function
specifier|static
name|void
name|ses_page_cdb
parameter_list|(
name|char
modifier|*
name|cdb
parameter_list|,
name|int
name|bufsiz
parameter_list|,
name|SesDiagPageCodes
name|pagenum
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
comment|/* Ref: SPC-4 r25 Section 6.20 Table 223 */
if|if
condition|(
name|dir
operator|==
name|CAM_DIR_IN
condition|)
block|{
name|cdb
index|[
literal|0
index|]
operator|=
name|RECEIVE_DIAGNOSTIC
expr_stmt|;
name|cdb
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Set page code valid bit */
name|cdb
index|[
literal|2
index|]
operator|=
name|pagenum
expr_stmt|;
block|}
else|else
block|{
name|cdb
index|[
literal|0
index|]
operator|=
name|SEND_DIAGNOSTIC
expr_stmt|;
name|cdb
index|[
literal|1
index|]
operator|=
literal|0x10
expr_stmt|;
name|cdb
index|[
literal|2
index|]
operator|=
name|pagenum
expr_stmt|;
block|}
name|cdb
index|[
literal|3
index|]
operator|=
name|bufsiz
operator|>>
literal|8
expr_stmt|;
comment|/* high bits */
name|cdb
index|[
literal|4
index|]
operator|=
name|bufsiz
operator|&
literal|0xff
expr_stmt|;
comment|/* low bits */
name|cdb
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * \brief Discover whether this instance supports timed completion of a  * 	  RECEIVE DIAGNOSTIC RESULTS command requesting the Enclosure Status  * 	  page, and store the result in the softc, updating if necessary.  *  * \param enc	SES instance to query and update.  * \param tc_en	Value of timed completion to set (see \return).  *  * \return	1 if timed completion enabled, 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|ses_set_timed_completion
parameter_list|(
name|enc_softc_t
modifier|*
name|enc
parameter_list|,
name|uint8_t
name|tc_en
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|ses_mgmt_mode_page
modifier|*
name|mgmt
decl_stmt|;
name|uint8_t
modifier|*
name|mode_buf
decl_stmt|;
name|size_t
name|mode_buf_len
decl_stmt|;
name|ses_softc_t
modifier|*
name|ses
decl_stmt|;
name|periph
operator|=
name|enc
operator|->
name|periph
expr_stmt|;
name|ses
operator|=
name|enc
operator|->
name|enc_private
expr_stmt|;
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
name|CAM_PRIORITY_NORMAL
argument_list|)
expr_stmt|;
name|mode_buf_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ses_mgmt_mode_page
argument_list|)
expr_stmt|;
name|mode_buf
operator|=
name|ENC_MALLOCZ
argument_list|(
name|mode_buf_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode_buf
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
name|scsi_mode_sense
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/*retries*/
literal|4
argument_list|,
name|NULL
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*dbd*/
name|FALSE
argument_list|,
name|SMS_PAGE_CTRL_CURRENT
argument_list|,
name|SES_MGMT_MODE_PAGE_CODE
argument_list|,
name|mode_buf
argument_list|,
name|mode_buf_len
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
comment|/*timeout*/
literal|60
operator|*
literal|1000
argument_list|)
expr_stmt|;
comment|/* 	 * Ignore illegal request errors, as they are quite common and we 	 * will print something out in that case anyway. 	 */
name|err
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|enc_error
argument_list|,
name|ENC_CFLAGS
argument_list|,
name|ENC_FLAGS
operator||
name|SF_QUIET_IR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|ENC_VLOG
argument_list|(
name|enc
argument_list|,
literal|"Timed Completion Unsupported\n"
argument_list|)
expr_stmt|;
goto|goto
name|release
goto|;
block|}
comment|/* Skip the mode select if the desired value is already set */
name|mgmt
operator|=
operator|(
expr|struct
name|ses_mgmt_mode_page
operator|*
operator|)
name|mode_buf
expr_stmt|;
if|if
condition|(
operator|(
name|mgmt
operator|->
name|byte5
operator|&
name|SES_MGMT_TIMED_COMP_EN
operator|)
operator|==
name|tc_en
condition|)
goto|goto
name|done
goto|;
comment|/* Value is not what we wanted, set it */
if|if
condition|(
name|tc_en
condition|)
name|mgmt
operator|->
name|byte5
operator||=
name|SES_MGMT_TIMED_COMP_EN
expr_stmt|;
else|else
name|mgmt
operator|->
name|byte5
operator|&=
operator|~
name|SES_MGMT_TIMED_COMP_EN
expr_stmt|;
comment|/* SES2r20: a completion time of zero means as long as possible */
name|bzero
argument_list|(
operator|&
name|mgmt
operator|->
name|max_comp_time
argument_list|,
sizeof|sizeof
argument_list|(
name|mgmt
operator|->
name|max_comp_time
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_mode_select
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
literal|5
argument_list|,
name|NULL
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*page_fmt*/
name|FALSE
argument_list|,
comment|/*save_pages*/
name|TRUE
argument_list|,
name|mode_buf
argument_list|,
name|mode_buf_len
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
comment|/*timeout*/
literal|60
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|err
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|enc_error
argument_list|,
name|ENC_CFLAGS
argument_list|,
name|ENC_FLAGS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|ENC_VLOG
argument_list|(
name|enc
argument_list|,
literal|"Timed Completion Set Failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|release
goto|;
block|}
name|done
label|:
if|if
condition|(
operator|(
name|mgmt
operator|->
name|byte5
operator|&
name|SES_MGMT_TIMED_COMP_EN
operator|)
operator|!=
literal|0
condition|)
block|{
name|ENC_LOG
argument_list|(
name|enc
argument_list|,
literal|"Timed Completion Enabled\n"
argument_list|)
expr_stmt|;
name|ses
operator|->
name|ses_flags
operator||=
name|SES_FLAG_TIMEDCOMP
expr_stmt|;
block|}
else|else
block|{
name|ENC_LOG
argument_list|(
name|enc
argument_list|,
literal|"Timed Completion Disabled\n"
argument_list|)
expr_stmt|;
name|ses
operator|->
name|ses_flags
operator|&=
operator|~
name|SES_FLAG_TIMEDCOMP
expr_stmt|;
block|}
name|release
label|:
name|ENC_FREE
argument_list|(
name|mode_buf
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|out
label|:
return|return
operator|(
name|ses
operator|->
name|ses_flags
operator|&
name|SES_FLAG_TIMEDCOMP
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * \brief Process the list of supported pages and update flags.  *  * \param enc       SES device to query.  * \param buf       Buffer containing the config page.  * \param xfer_len  Length of the config page in the buffer.  *  * \return  0 on success, errno otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|ses_process_pages
parameter_list|(
name|enc_softc_t
modifier|*
name|enc
parameter_list|,
name|struct
name|enc_fsm_state
modifier|*
name|state
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|bufp
parameter_list|,
name|int
name|error
parameter_list|,
name|int
name|xfer_len
parameter_list|)
block|{
name|ses_softc_t
modifier|*
name|ses
decl_stmt|;
name|struct
name|scsi_diag_page
modifier|*
name|page
decl_stmt|;
name|int
name|err
decl_stmt|,
name|i
decl_stmt|,
name|length
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|enc
operator|->
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"entering %s(%p, %d)\n"
operator|,
name|__func__
operator|,
name|bufp
operator|,
name|xfer_len
operator|)
argument_list|)
expr_stmt|;
name|ses
operator|=
name|enc
operator|->
name|enc_private
expr_stmt|;
name|err
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|error
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|xfer_len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|page
argument_list|)
condition|)
block|{
name|ENC_VLOG
argument_list|(
name|enc
argument_list|,
literal|"Unable to parse Diag Pages List Header\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|EIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|page
operator|=
operator|(
expr|struct
name|scsi_diag_page
operator|*
operator|)
operator|*
name|bufp
expr_stmt|;
name|length
operator|=
name|scsi_2btoul
argument_list|(
name|page
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|+
name|offsetof
argument_list|(
expr|struct
name|scsi_diag_page
argument_list|,
name|params
argument_list|)
operator|>
name|xfer_len
condition|)
block|{
name|ENC_VLOG
argument_list|(
name|enc
argument_list|,
literal|"Diag Pages List Too Long\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ENC_DLOG
argument_list|(
name|enc
argument_list|,
literal|"%s: page length %d, xfer_len %d\n"
argument_list|,
name|__func__
argument_list|,
name|length
argument_list|,
name|xfer_len
argument_list|)
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|page
operator|->
name|params
index|[
name|i
index|]
operator|==
name|SesElementDescriptor
condition|)
name|ses
operator|->
name|ses_flags
operator||=
name|SES_FLAG_DESC
expr_stmt|;
elseif|else
if|if
condition|(
name|page
operator|->
name|params
index|[
name|i
index|]
operator|==
name|SesAddlElementStatus
condition|)
name|ses
operator|->
name|ses_flags
operator||=
name|SES_FLAG_ADDLSTATUS
expr_stmt|;
block|}
name|out
label|:
name|ENC_DLOG
argument_list|(
name|enc
argument_list|,
literal|"%s: exiting with err %d\n"
argument_list|,
name|__func__
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * \brief Process the config page and update associated structures.  *  * \param enc       SES device to query.  * \param buf       Buffer containing the config page.  * \param xfer_len  Length of the config page in the buffer.  *  * \return  0 on success, errno otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|ses_process_config
parameter_list|(
name|enc_softc_t
modifier|*
name|enc
parameter_list|,
name|struct
name|enc_fsm_state
modifier|*
name|state
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|bufp
parameter_list|,
name|int
name|error
parameter_list|,
name|int
name|xfer_len
parameter_list|)
block|{
name|struct
name|ses_iterator
name|iter
decl_stmt|;
name|ses_softc_t
modifier|*
name|ses
decl_stmt|;
name|enc_cache_t
modifier|*
name|enc_cache
decl_stmt|;
name|ses_cache_t
modifier|*
name|ses_cache
decl_stmt|;
name|uint8_t
modifier|*
name|buf
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|nelm
decl_stmt|;
name|int
name|ntype
decl_stmt|;
name|struct
name|ses_cfg_page
modifier|*
name|cfg_page
decl_stmt|;
name|struct
name|ses_enc_desc
modifier|*
name|buf_subenc
decl_stmt|;
specifier|const
name|struct
name|ses_enc_desc
modifier|*
modifier|*
name|subencs
decl_stmt|;
specifier|const
name|struct
name|ses_enc_desc
modifier|*
modifier|*
name|cur_subenc
decl_stmt|;
specifier|const
name|struct
name|ses_enc_desc
modifier|*
modifier|*
name|last_subenc
decl_stmt|;
name|ses_type_t
modifier|*
name|ses_types
decl_stmt|;
name|ses_type_t
modifier|*
name|sestype
decl_stmt|;
specifier|const
name|struct
name|ses_elm_type_desc
modifier|*
name|cur_buf_type
decl_stmt|;
specifier|const
name|struct
name|ses_elm_type_desc
modifier|*
name|last_buf_type
decl_stmt|;
name|uint8_t
modifier|*
name|last_valid_byte
decl_stmt|;
name|enc_element_t
modifier|*
name|element
decl_stmt|;
specifier|const
name|char
modifier|*
name|type_text
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|enc
operator|->
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"entering %s(%p, %d)\n"
operator|,
name|__func__
operator|,
name|bufp
operator|,
name|xfer_len
operator|)
argument_list|)
expr_stmt|;
name|ses
operator|=
name|enc
operator|->
name|enc_private
expr_stmt|;
name|enc_cache
operator|=
operator|&
name|enc
operator|->
name|enc_daemon_cache
expr_stmt|;
name|ses_cache
operator|=
name|enc_cache
operator|->
name|private
expr_stmt|;
name|buf
operator|=
operator|*
name|bufp
expr_stmt|;
name|err
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|error
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|xfer_len
operator|<
sizeof|sizeof
argument_list|(
name|cfg_page
operator|->
name|hdr
argument_list|)
condition|)
block|{
name|ENC_VLOG
argument_list|(
name|enc
argument_list|,
literal|"Unable to parse SES Config Header\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|EIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|cfg_page
operator|=
operator|(
expr|struct
name|ses_cfg_page
operator|*
operator|)
name|buf
expr_stmt|;
name|length
operator|=
name|ses_page_length
argument_list|(
operator|&
name|cfg_page
operator|->
name|hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
name|xfer_len
condition|)
block|{
name|ENC_VLOG
argument_list|(
name|enc
argument_list|,
literal|"Enclosure Config Page Too Long\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|last_valid_byte
operator|=
operator|&
name|buf
index|[
name|length
operator|-
literal|1
index|]
expr_stmt|;
name|ENC_DLOG
argument_list|(
name|enc
argument_list|,
literal|"%s: total page length %d, xfer_len %d\n"
argument_list|,
name|__func__
argument_list|,
name|length
argument_list|,
name|xfer_len
argument_list|)
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ses_config_cache_valid
argument_list|(
name|ses_cache
argument_list|,
name|cfg_page
operator|->
name|hdr
operator|.
name|gen_code
argument_list|)
condition|)
block|{
comment|/* Our cache is still valid.  Proceed to fetching status. */
goto|goto
name|out
goto|;
block|}
comment|/* Cache is no longer valid.  Free old data to make way for new. */
name|ses_cache_free
argument_list|(
name|enc
argument_list|,
name|enc_cache
argument_list|)
expr_stmt|;
name|ENC_VLOG
argument_list|(
name|enc
argument_list|,
literal|"Generation Code 0x%x has %d SubEnclosures\n"
argument_list|,
name|scsi_4btoul
argument_list|(
name|cfg_page
operator|->
name|hdr
operator|.
name|gen_code
argument_list|)
argument_list|,
name|ses_cfg_page_get_num_subenc
argument_list|(
name|cfg_page
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Take ownership of the buffer. */
name|ses_cache
operator|->
name|cfg_page
operator|=
name|cfg_page
expr_stmt|;
operator|*
name|bufp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Now waltz through all the subenclosures summing the number of 	 * types available in each. 	 */
name|subencs
operator|=
name|malloc
argument_list|(
name|ses_cfg_page_get_num_subenc
argument_list|(
name|cfg_page
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|subencs
argument_list|)
argument_list|,
name|M_SCSIENC
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
comment|/* 	 * Sub-enclosure data is const after construction (i.e. when 	 * accessed via our cache object. 	 * 	 * The cast here is not required in C++ but C99 is not so 	 * sophisticated (see C99 6.5.16.1(1)). 	 */
name|ses_cache
operator|->
name|ses_nsubencs
operator|=
name|ses_cfg_page_get_num_subenc
argument_list|(
name|cfg_page
argument_list|)
expr_stmt|;
name|ses_cache
operator|->
name|subencs
operator|=
name|subencs
expr_stmt|;
name|buf_subenc
operator|=
name|cfg_page
operator|->
name|subencs
expr_stmt|;
name|cur_subenc
operator|=
name|subencs
expr_stmt|;
name|last_subenc
operator|=
operator|&
name|subencs
index|[
name|ses_cache
operator|->
name|ses_nsubencs
operator|-
literal|1
index|]
expr_stmt|;
name|ntype
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cur_subenc
operator|<=
name|last_subenc
condition|)
block|{
if|if
condition|(
operator|!
name|ses_enc_desc_is_complete
argument_list|(
name|buf_subenc
argument_list|,
name|last_valid_byte
argument_list|)
condition|)
block|{
name|ENC_VLOG
argument_list|(
name|enc
argument_list|,
literal|"Enclosure %d Beyond End of "
literal|"Descriptors\n"
argument_list|,
name|cur_subenc
operator|-
name|subencs
argument_list|)
expr_stmt|;
name|err
operator|=
name|EIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ENC_VLOG
argument_list|(
name|enc
argument_list|,
literal|" SubEnclosure ID %d, %d Types With this ID, "
literal|"Descriptor Length %d, offset %d\n"
argument_list|,
name|buf_subenc
operator|->
name|subenc_id
argument_list|,
name|buf_subenc
operator|->
name|num_types
argument_list|,
name|buf_subenc
operator|->
name|length
argument_list|,
operator|&
name|buf_subenc
operator|->
name|byte0
operator|-
name|buf
argument_list|)
expr_stmt|;
name|ENC_VLOG
argument_list|(
name|enc
argument_list|,
literal|"WWN: %jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|scsi_8btou64
argument_list|(
name|buf_subenc
operator|->
name|logical_id
argument_list|)
argument_list|)
expr_stmt|;
name|ntype
operator|+=
name|buf_subenc
operator|->
name|num_types
expr_stmt|;
operator|*
name|cur_subenc
operator|=
name|buf_subenc
expr_stmt|;
name|cur_subenc
operator|++
expr_stmt|;
name|buf_subenc
operator|=
name|ses_enc_desc_next
argument_list|(
name|buf_subenc
argument_list|)
expr_stmt|;
block|}
comment|/* Process the type headers. */
name|ses_types
operator|=
name|malloc
argument_list|(
name|ntype
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ses_types
argument_list|)
argument_list|,
name|M_SCSIENC
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
comment|/* 	 * Type data is const after construction (i.e. when accessed via 	 * our cache object. 	 */
name|ses_cache
operator|->
name|ses_ntypes
operator|=
name|ntype
expr_stmt|;
name|ses_cache
operator|->
name|ses_types
operator|=
name|ses_types
expr_stmt|;
name|cur_buf_type
operator|=
operator|(
specifier|const
expr|struct
name|ses_elm_type_desc
operator|*
operator|)
operator|(
operator|&
operator|(
operator|*
name|last_subenc
operator|)
operator|->
name|length
operator|+
operator|(
operator|*
name|last_subenc
operator|)
operator|->
name|length
operator|+
literal|1
operator|)
expr_stmt|;
name|last_buf_type
operator|=
name|cur_buf_type
operator|+
name|ntype
operator|-
literal|1
expr_stmt|;
name|type_text
operator|=
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
operator|(
name|last_buf_type
operator|+
literal|1
operator|)
expr_stmt|;
name|nelm
operator|=
literal|0
expr_stmt|;
name|sestype
operator|=
name|ses_types
expr_stmt|;
while|while
condition|(
name|cur_buf_type
operator|<=
name|last_buf_type
condition|)
block|{
if|if
condition|(
operator|&
name|cur_buf_type
operator|->
name|etype_txt_len
operator|>
name|last_valid_byte
condition|)
block|{
name|ENC_VLOG
argument_list|(
name|enc
argument_list|,
literal|"Runt Enclosure Type Header %d\n"
argument_list|,
name|sestype
operator|-
name|ses_types
argument_list|)
expr_stmt|;
name|err
operator|=
name|EIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|sestype
operator|->
name|hdr
operator|=
name|cur_buf_type
expr_stmt|;
name|sestype
operator|->
name|text
operator|=
name|type_text
expr_stmt|;
name|type_text
operator|+=
name|cur_buf_type
operator|->
name|etype_txt_len
expr_stmt|;
name|ENC_VLOG
argument_list|(
name|enc
argument_list|,
literal|" Type Desc[%d]: Type 0x%x, MaxElt %d, In Subenc "
literal|"%d, Text Length %d: %.*s\n"
argument_list|,
name|sestype
operator|-
name|ses_types
argument_list|,
name|sestype
operator|->
name|hdr
operator|->
name|etype_elm_type
argument_list|,
name|sestype
operator|->
name|hdr
operator|->
name|etype_maxelt
argument_list|,
name|sestype
operator|->
name|hdr
operator|->
name|etype_subenc
argument_list|,
name|sestype
operator|->
name|hdr
operator|->
name|etype_txt_len
argument_list|,
name|sestype
operator|->
name|hdr
operator|->
name|etype_txt_len
argument_list|,
name|sestype
operator|->
name|text
argument_list|)
expr_stmt|;
name|nelm
operator|+=
name|sestype
operator|->
name|hdr
operator|->
name|etype_maxelt
operator|+
comment|/*overall status element*/
literal|1
expr_stmt|;
name|sestype
operator|++
expr_stmt|;
name|cur_buf_type
operator|++
expr_stmt|;
block|}
comment|/* Create the object map. */
name|enc_cache
operator|->
name|elm_map
operator|=
name|malloc
argument_list|(
name|nelm
operator|*
sizeof|sizeof
argument_list|(
name|enc_element_t
argument_list|)
argument_list|,
name|M_SCSIENC
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|enc_cache
operator|->
name|nelms
operator|=
name|nelm
expr_stmt|;
name|ses_iter_init
argument_list|(
name|enc
argument_list|,
name|enc_cache
argument_list|,
operator|&
name|iter
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|element
operator|=
name|ses_iter_next
argument_list|(
operator|&
name|iter
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|struct
name|ses_elm_type_desc
modifier|*
name|thdr
decl_stmt|;
name|ENC_DLOG
argument_list|(
name|enc
argument_list|,
literal|"%s: checking obj %d(%d,%d)\n"
argument_list|,
name|__func__
argument_list|,
name|iter
operator|.
name|global_element_index
argument_list|,
name|iter
operator|.
name|type_index
argument_list|,
name|nelm
argument_list|,
name|iter
operator|.
name|type_element_index
argument_list|)
expr_stmt|;
name|thdr
operator|=
name|ses_cache
operator|->
name|ses_types
index|[
name|iter
operator|.
name|type_index
index|]
operator|.
name|hdr
expr_stmt|;
name|element
operator|->
name|subenclosure
operator|=
name|thdr
operator|->
name|etype_subenc
expr_stmt|;
name|element
operator|->
name|enctype
operator|=
name|thdr
operator|->
name|etype_elm_type
expr_stmt|;
name|element
operator|->
name|overall_status_elem
operator|=
name|iter
operator|.
name|type_element_index
operator|==
literal|0
expr_stmt|;
name|element
operator|->
name|elm_private
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ses_element_t
argument_list|)
argument_list|,
name|M_SCSIENC
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ENC_DLOG
argument_list|(
name|enc
argument_list|,
literal|"%s: creating elmpriv %d(%d,%d) subenc %d "
literal|"type 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|iter
operator|.
name|global_element_index
argument_list|,
name|iter
operator|.
name|type_index
argument_list|,
name|iter
operator|.
name|type_element_index
argument_list|,
name|thdr
operator|->
name|etype_subenc
argument_list|,
name|thdr
operator|->
name|etype_elm_type
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
literal|0
expr_stmt|;
name|out
label|:
if|if
condition|(
name|err
condition|)
name|ses_cache_free
argument_list|(
name|enc
argument_list|,
name|enc_cache
argument_list|)
expr_stmt|;
else|else
block|{
name|ses_poll_status
argument_list|(
name|enc
argument_list|)
expr_stmt|;
name|enc_update_request
argument_list|(
name|enc
argument_list|,
name|SES_PUBLISH_CACHE
argument_list|)
expr_stmt|;
block|}
name|ENC_DLOG
argument_list|(
name|enc
argument_list|,
literal|"%s: exiting with err %d\n"
argument_list|,
name|__func__
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * \brief Update the status page and associated structures.  *   * \param enc   SES softc to update for.  * \param buf   Buffer containing the status page.  * \param bufsz	Amount of data in the buffer.  *  * \return	0 on success, errno otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|ses_process_status
parameter_list|(
name|enc_softc_t
modifier|*
name|enc
parameter_list|,
name|struct
name|enc_fsm_state
modifier|*
name|state
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|bufp
parameter_list|,
name|int
name|error
parameter_list|,
name|int
name|xfer_len
parameter_list|)
block|{
name|struct
name|ses_iterator
name|iter
decl_stmt|;
name|enc_element_t
modifier|*
name|element
decl_stmt|;
name|ses_softc_t
modifier|*
name|ses
decl_stmt|;
name|enc_cache_t
modifier|*
name|enc_cache
decl_stmt|;
name|ses_cache_t
modifier|*
name|ses_cache
decl_stmt|;
name|uint8_t
modifier|*
name|buf
decl_stmt|;
name|int
name|err
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|length
decl_stmt|;
name|struct
name|ses_status_page
modifier|*
name|page
decl_stmt|;
name|union
name|ses_status_element
modifier|*
name|cur_stat
decl_stmt|;
name|union
name|ses_status_element
modifier|*
name|last_stat
decl_stmt|;
name|ses
operator|=
name|enc
operator|->
name|enc_private
expr_stmt|;
name|enc_cache
operator|=
operator|&
name|enc
operator|->
name|enc_daemon_cache
expr_stmt|;
name|ses_cache
operator|=
name|enc_cache
operator|->
name|private
expr_stmt|;
name|buf
operator|=
operator|*
name|bufp
expr_stmt|;
name|ENC_DLOG
argument_list|(
name|enc
argument_list|,
literal|"%s: enter (%p, %p, %d)\n"
argument_list|,
name|__func__
argument_list|,
name|enc
argument_list|,
name|buf
argument_list|,
name|xfer_len
argument_list|)
expr_stmt|;
name|page
operator|=
operator|(
expr|struct
name|ses_status_page
operator|*
operator|)
name|buf
expr_stmt|;
name|length
operator|=
name|ses_page_length
argument_list|(
operator|&
name|page
operator|->
name|hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|error
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Make sure the length fits in the buffer. 	 * 	 * XXX all this means is that the page is larger than the space 	 * we allocated.  Since we use a statically sized buffer, this 	 * could happen... Need to use dynamic discovery of the size. 	 */
if|if
condition|(
name|length
operator|>
name|xfer_len
condition|)
block|{
name|ENC_VLOG
argument_list|(
name|enc
argument_list|,
literal|"Enclosure Status Page Too Long\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Check for simple enclosure reporting short enclosure status. */
if|if
condition|(
name|length
operator|>=
literal|4
operator|&&
name|page
operator|->
name|hdr
operator|.
name|page_code
operator|==
name|SesShortStatus
condition|)
block|{
name|ENC_DLOG
argument_list|(
name|enc
argument_list|,
literal|"Got Short Enclosure Status page\n"
argument_list|)
expr_stmt|;
name|ses
operator|->
name|ses_flags
operator|&=
operator|~
operator|(
name|SES_FLAG_ADDLSTATUS
operator||
name|SES_FLAG_DESC
operator|)
expr_stmt|;
name|ses_cache_free
argument_list|(
name|enc
argument_list|,
name|enc_cache
argument_list|)
expr_stmt|;
name|enc_cache
operator|->
name|enc_status
operator|=
name|page
operator|->
name|hdr
operator|.
name|page_specific_flags
expr_stmt|;
name|enc_update_request
argument_list|(
name|enc
argument_list|,
name|SES_PUBLISH_CACHE
argument_list|)
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Make sure the length contains at least one header and status */
if|if
condition|(
name|length
operator|<
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|page
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|page
operator|->
name|elements
argument_list|)
operator|)
condition|)
block|{
name|ENC_VLOG
argument_list|(
name|enc
argument_list|,
literal|"Enclosure Status Page Too Short\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|!
name|ses_config_cache_valid
argument_list|(
name|ses_cache
argument_list|,
name|page
operator|->
name|hdr
operator|.
name|gen_code
argument_list|)
condition|)
block|{
name|ENC_DLOG
argument_list|(
name|enc
argument_list|,
literal|"%s: Generation count change detected\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|enc_update_request
argument_list|(
name|enc
argument_list|,
name|SES_UPDATE_GETCONFIG
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ses_cache_free_status
argument_list|(
name|enc
argument_list|,
name|enc_cache
argument_list|)
expr_stmt|;
name|ses_cache
operator|->
name|status_page
operator|=
name|page
expr_stmt|;
operator|*
name|bufp
operator|=
name|NULL
expr_stmt|;
name|enc_cache
operator|->
name|enc_status
operator|=
name|page
operator|->
name|hdr
operator|.
name|page_specific_flags
expr_stmt|;
comment|/* 	 * Read in individual element status.  The element order 	 * matches the order reported in the config page (i.e. the 	 * order of an unfiltered iteration of the config objects).. 	 */
name|ses_iter_init
argument_list|(
name|enc
argument_list|,
name|enc_cache
argument_list|,
operator|&
name|iter
argument_list|)
expr_stmt|;
name|cur_stat
operator|=
name|page
operator|->
name|elements
expr_stmt|;
name|last_stat
operator|=
operator|(
expr|union
name|ses_status_element
operator|*
operator|)
operator|&
name|buf
index|[
name|length
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|last_stat
argument_list|)
index|]
expr_stmt|;
name|ENC_DLOG
argument_list|(
name|enc
argument_list|,
literal|"%s: total page length %d, xfer_len %d\n"
argument_list|,
name|__func__
argument_list|,
name|length
argument_list|,
name|xfer_len
argument_list|)
expr_stmt|;
while|while
condition|(
name|cur_stat
operator|<=
name|last_stat
operator|&&
operator|(
name|element
operator|=
name|ses_iter_next
argument_list|(
operator|&
name|iter
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ENC_DLOG
argument_list|(
name|enc
argument_list|,
literal|"%s: obj %d(%d,%d) off=0x%tx status=%jx\n"
argument_list|,
name|__func__
argument_list|,
name|iter
operator|.
name|global_element_index
argument_list|,
name|iter
operator|.
name|type_index
argument_list|,
name|iter
operator|.
name|type_element_index
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|cur_stat
operator|-
name|buf
argument_list|,
name|scsi_4btoul
argument_list|(
name|cur_stat
operator|->
name|bytes
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|element
operator|->
name|encstat
argument_list|,
name|cur_stat
argument_list|,
sizeof|sizeof
argument_list|(
name|element
operator|->
name|encstat
argument_list|)
argument_list|)
expr_stmt|;
name|element
operator|->
name|svalid
operator|=
literal|1
expr_stmt|;
name|cur_stat
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ses_iter_next
argument_list|(
operator|&
name|iter
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|ENC_VLOG
argument_list|(
name|enc
argument_list|,
literal|"Status page, length insufficient for "
literal|"expected number of objects\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cur_stat
operator|<=
name|last_stat
condition|)
name|ENC_VLOG
argument_list|(
name|enc
argument_list|,
literal|"Status page, exhausted objects before "
literal|"exhausing page\n"
argument_list|)
expr_stmt|;
name|enc_update_request
argument_list|(
name|enc
argument_list|,
name|SES_PUBLISH_CACHE
argument_list|)
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
block|}
name|out
label|:
name|ENC_DLOG
argument_list|(
name|enc
argument_list|,
literal|"%s: exiting with error %d\n"
argument_list|,
name|__func__
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
enum|enum
block|{
comment|/** 	 * The enclosure should not provide additional element 	 * status for this element type in page 0x0A. 	 * 	 * \note  This status is returned for any types not 	 *        listed SES3r02.  Further types added in a 	 *        future specification will be incorrectly 	 *        classified. 	 */
name|TYPE_ADDLSTATUS_NONE
block|,
comment|/** 	 * The element type provides additional element status 	 * in page 0x0A. 	 */
name|TYPE_ADDLSTATUS_MANDATORY
block|,
comment|/** 	 * The element type may provide additional element status 	 * in page 0x0A, but i 	 */
name|TYPE_ADDLSTATUS_OPTIONAL
block|}
name|ses_addlstatus_avail_t
typedef|;
end_typedef

begin_comment
comment|/**  * \brief Check to see whether a given type (as obtained via type headers) is  *	  supported by the additional status command.  *  * \param enc     SES softc to check.  * \param typidx  Type index to check for.  *  * \return  An enumeration indicating if additional status is mandatory,  *          optional, or not required for this type.  */
end_comment

begin_function
specifier|static
name|ses_addlstatus_avail_t
name|ses_typehasaddlstatus
parameter_list|(
name|enc_softc_t
modifier|*
name|enc
parameter_list|,
name|uint8_t
name|typidx
parameter_list|)
block|{
name|enc_cache_t
modifier|*
name|enc_cache
decl_stmt|;
name|ses_cache_t
modifier|*
name|ses_cache
decl_stmt|;
name|enc_cache
operator|=
operator|&
name|enc
operator|->
name|enc_daemon_cache
expr_stmt|;
name|ses_cache
operator|=
name|enc_cache
operator|->
name|private
expr_stmt|;
switch|switch
condition|(
name|ses_cache
operator|->
name|ses_types
index|[
name|typidx
index|]
operator|.
name|hdr
operator|->
name|etype_elm_type
condition|)
block|{
case|case
name|ELMTYP_DEVICE
case|:
case|case
name|ELMTYP_ARRAY_DEV
case|:
case|case
name|ELMTYP_SAS_EXP
case|:
return|return
operator|(
name|TYPE_ADDLSTATUS_MANDATORY
operator|)
return|;
case|case
name|ELMTYP_SCSI_INI
case|:
case|case
name|ELMTYP_SCSI_TGT
case|:
case|case
name|ELMTYP_ESCC
case|:
return|return
operator|(
name|TYPE_ADDLSTATUS_OPTIONAL
operator|)
return|;
default|default:
comment|/* No additional status information available. */
break|break;
block|}
return|return
operator|(
name|TYPE_ADDLSTATUS_NONE
operator|)
return|;
block|}
end_function

begin_function_decl
specifier|static
name|int
name|ses_get_elm_addlstatus_fc
parameter_list|(
name|enc_softc_t
modifier|*
parameter_list|,
name|enc_cache_t
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ses_get_elm_addlstatus_sas
parameter_list|(
name|enc_softc_t
modifier|*
parameter_list|,
name|enc_cache_t
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * \brief Parse the additional status element data for each object.  *  * \param enc       The SES softc to update.  * \param buf       The buffer containing the additional status  *                  element response.  * \param xfer_len  Size of the buffer.  *  * \return  0 on success, errno otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|ses_process_elm_addlstatus
parameter_list|(
name|enc_softc_t
modifier|*
name|enc
parameter_list|,
name|struct
name|enc_fsm_state
modifier|*
name|state
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|bufp
parameter_list|,
name|int
name|error
parameter_list|,
name|int
name|xfer_len
parameter_list|)
block|{
name|struct
name|ses_iterator
name|iter
decl_stmt|,
name|titer
decl_stmt|;
name|int
name|eip
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|ignore_index
init|=
literal|0
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|enc_cache_t
modifier|*
name|enc_cache
decl_stmt|;
name|ses_cache_t
modifier|*
name|ses_cache
decl_stmt|;
name|uint8_t
modifier|*
name|buf
decl_stmt|;
name|ses_element_t
modifier|*
name|elmpriv
decl_stmt|;
specifier|const
name|struct
name|ses_page_hdr
modifier|*
name|hdr
decl_stmt|;
name|enc_element_t
modifier|*
name|element
decl_stmt|,
modifier|*
name|telement
decl_stmt|;
name|enc_cache
operator|=
operator|&
name|enc
operator|->
name|enc_daemon_cache
expr_stmt|;
name|ses_cache
operator|=
name|enc_cache
operator|->
name|private
expr_stmt|;
name|buf
operator|=
operator|*
name|bufp
expr_stmt|;
name|err
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|error
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ses_cache_free_elm_addlstatus
argument_list|(
name|enc
argument_list|,
name|enc_cache
argument_list|)
expr_stmt|;
name|ses_cache
operator|->
name|elm_addlstatus_page
operator|=
operator|(
expr|struct
name|ses_addl_elem_status_page
operator|*
operator|)
name|buf
expr_stmt|;
operator|*
name|bufp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * The objects appear in the same order here as in Enclosure Status, 	 * which itself is ordered by the Type Descriptors from the Config 	 * page.  However, it is necessary to skip elements that are not 	 * supported by this page when counting them. 	 */
name|hdr
operator|=
operator|&
name|ses_cache
operator|->
name|elm_addlstatus_page
operator|->
name|hdr
expr_stmt|;
name|length
operator|=
name|ses_page_length
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
name|ENC_DLOG
argument_list|(
name|enc
argument_list|,
literal|"Additional Element Status Page Length 0x%x\n"
argument_list|,
name|length
argument_list|)
expr_stmt|;
comment|/* Make sure the length includes at least one header. */
if|if
condition|(
name|length
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ses_elm_addlstatus_base_hdr
argument_list|)
condition|)
block|{
name|ENC_VLOG
argument_list|(
name|enc
argument_list|,
literal|"Runt Additional Element Status Page\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|length
operator|>
name|xfer_len
condition|)
block|{
name|ENC_VLOG
argument_list|(
name|enc
argument_list|,
literal|"Additional Element Status Page Too Long\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|!
name|ses_config_cache_valid
argument_list|(
name|ses_cache
argument_list|,
name|hdr
operator|->
name|gen_code
argument_list|)
condition|)
block|{
name|ENC_DLOG
argument_list|(
name|enc
argument_list|,
literal|"%s: Generation count change detected\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|enc_update_request
argument_list|(
name|enc
argument_list|,
name|SES_UPDATE_GETCONFIG
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|offset
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ses_page_hdr
argument_list|)
expr_stmt|;
name|ses_iter_init
argument_list|(
name|enc
argument_list|,
name|enc_cache
argument_list|,
operator|&
name|iter
argument_list|)
expr_stmt|;
while|while
condition|(
name|offset
operator|<
name|length
operator|&&
operator|(
name|element
operator|=
name|ses_iter_next
argument_list|(
operator|&
name|iter
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ses_elm_addlstatus_base_hdr
modifier|*
name|elm_hdr
decl_stmt|;
name|int
name|proto_info_len
decl_stmt|;
name|ses_addlstatus_avail_t
name|status_type
decl_stmt|;
comment|/* 		 * Additional element status is only provided for 		 * individual elements (i.e. overal status elements 		 * are excluded) and those of the types specified 		 * in the SES spec. 		 */
name|status_type
operator|=
name|ses_typehasaddlstatus
argument_list|(
name|enc
argument_list|,
name|iter
operator|.
name|type_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|iter
operator|.
name|individual_element_index
operator|==
name|ITERATOR_INDEX_INVALID
operator|||
name|status_type
operator|==
name|TYPE_ADDLSTATUS_NONE
condition|)
continue|continue;
name|elm_hdr
operator|=
operator|(
expr|struct
name|ses_elm_addlstatus_base_hdr
operator|*
operator|)
operator|&
name|buf
index|[
name|offset
index|]
expr_stmt|;
name|eip
operator|=
name|ses_elm_addlstatus_eip
argument_list|(
name|elm_hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|eip
operator|&&
operator|!
name|ignore_index
condition|)
block|{
name|struct
name|ses_elm_addlstatus_eip_hdr
modifier|*
name|eip_hdr
decl_stmt|;
name|int
name|expected_index
decl_stmt|,
name|index
decl_stmt|;
name|ses_elem_index_type_t
name|index_type
decl_stmt|;
name|eip_hdr
operator|=
operator|(
expr|struct
name|ses_elm_addlstatus_eip_hdr
operator|*
operator|)
name|elm_hdr
expr_stmt|;
if|if
condition|(
name|eip_hdr
operator|->
name|byte2
operator|&
name|SES_ADDL_EIP_EIIOE
condition|)
block|{
name|index_type
operator|=
name|SES_ELEM_INDEX_GLOBAL
expr_stmt|;
name|expected_index
operator|=
name|iter
operator|.
name|global_element_index
expr_stmt|;
block|}
else|else
block|{
name|index_type
operator|=
name|SES_ELEM_INDEX_INDIVIDUAL
expr_stmt|;
name|expected_index
operator|=
name|iter
operator|.
name|individual_element_index
expr_stmt|;
block|}
name|titer
operator|=
name|iter
expr_stmt|;
name|telement
operator|=
name|ses_iter_seek_to
argument_list|(
operator|&
name|titer
argument_list|,
name|eip_hdr
operator|->
name|element_index
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|telement
operator|!=
name|NULL
operator|&&
operator|(
name|ses_typehasaddlstatus
argument_list|(
name|enc
argument_list|,
name|titer
operator|.
name|type_index
argument_list|)
operator|!=
name|TYPE_ADDLSTATUS_NONE
operator|||
name|titer
operator|.
name|type_index
operator|>
name|ELMTYP_SAS_CONN
operator|)
condition|)
block|{
name|iter
operator|=
name|titer
expr_stmt|;
name|element
operator|=
name|telement
expr_stmt|;
block|}
else|else
name|ignore_index
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|eip_hdr
operator|->
name|byte2
operator|&
name|SES_ADDL_EIP_EIIOE
condition|)
name|index
operator|=
name|iter
operator|.
name|global_element_index
expr_stmt|;
else|else
name|index
operator|=
name|iter
operator|.
name|individual_element_index
expr_stmt|;
if|if
condition|(
name|index
operator|>
name|expected_index
operator|&&
name|status_type
operator|==
name|TYPE_ADDLSTATUS_MANDATORY
condition|)
block|{
name|ENC_VLOG
argument_list|(
name|enc
argument_list|,
literal|"%s: provided %s element"
literal|"index %d skips mandatory status "
literal|" element at index %d\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|eip_hdr
operator|->
name|byte2
operator|&
name|SES_ADDL_EIP_EIIOE
operator|)
condition|?
literal|"global "
else|:
literal|""
argument_list|,
name|index
argument_list|,
name|expected_index
argument_list|)
expr_stmt|;
block|}
block|}
name|elmpriv
operator|=
name|element
operator|->
name|elm_private
expr_stmt|;
name|elmpriv
operator|->
name|addl
operator|.
name|hdr
operator|=
name|elm_hdr
expr_stmt|;
name|ENC_DLOG
argument_list|(
name|enc
argument_list|,
literal|"%s: global element index=%d, type index=%d "
literal|"type element index=%d, offset=0x%x, "
literal|"byte0=0x%x, length=0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|iter
operator|.
name|global_element_index
argument_list|,
name|iter
operator|.
name|type_index
argument_list|,
name|iter
operator|.
name|type_element_index
argument_list|,
name|offset
argument_list|,
name|elmpriv
operator|->
name|addl
operator|.
name|hdr
operator|->
name|byte0
argument_list|,
name|elmpriv
operator|->
name|addl
operator|.
name|hdr
operator|->
name|length
argument_list|)
expr_stmt|;
comment|/* Skip to after the length field */
name|offset
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ses_elm_addlstatus_base_hdr
argument_list|)
expr_stmt|;
comment|/* Make sure the descriptor is within bounds */
if|if
condition|(
operator|(
name|offset
operator|+
name|elmpriv
operator|->
name|addl
operator|.
name|hdr
operator|->
name|length
operator|)
operator|>
name|length
condition|)
block|{
name|ENC_VLOG
argument_list|(
name|enc
argument_list|,
literal|"Element %d Beyond End "
literal|"of Additional Element Status Descriptors\n"
argument_list|,
name|iter
operator|.
name|global_element_index
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Advance to the protocol data, skipping eip bytes if needed */
name|offset
operator|+=
operator|(
name|eip
operator|*
name|SES_EIP_HDR_EXTRA_LEN
operator|)
expr_stmt|;
name|proto_info_len
operator|=
name|elmpriv
operator|->
name|addl
operator|.
name|hdr
operator|->
name|length
operator|-
operator|(
name|eip
operator|*
name|SES_EIP_HDR_EXTRA_LEN
operator|)
expr_stmt|;
comment|/* Errors in this block are ignored as they are non-fatal */
switch|switch
condition|(
name|ses_elm_addlstatus_proto
argument_list|(
name|elmpriv
operator|->
name|addl
operator|.
name|hdr
argument_list|)
condition|)
block|{
case|case
name|SPSP_PROTO_FC
case|:
if|if
condition|(
name|elmpriv
operator|->
name|addl
operator|.
name|hdr
operator|->
name|length
operator|==
literal|0
condition|)
break|break;
name|ses_get_elm_addlstatus_fc
argument_list|(
name|enc
argument_list|,
name|enc_cache
argument_list|,
operator|&
name|buf
index|[
name|offset
index|]
argument_list|,
name|proto_info_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPSP_PROTO_SAS
case|:
if|if
condition|(
name|elmpriv
operator|->
name|addl
operator|.
name|hdr
operator|->
name|length
operator|<=
literal|2
condition|)
break|break;
name|ses_get_elm_addlstatus_sas
argument_list|(
name|enc
argument_list|,
name|enc_cache
argument_list|,
operator|&
name|buf
index|[
name|offset
index|]
argument_list|,
name|proto_info_len
argument_list|,
name|eip
argument_list|,
name|iter
operator|.
name|type_index
argument_list|,
name|iter
operator|.
name|global_element_index
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ENC_VLOG
argument_list|(
name|enc
argument_list|,
literal|"Element %d: Unknown Additional Element "
literal|"Protocol 0x%x\n"
argument_list|,
name|iter
operator|.
name|global_element_index
argument_list|,
name|ses_elm_addlstatus_proto
argument_list|(
name|elmpriv
operator|->
name|addl
operator|.
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|offset
operator|+=
name|proto_info_len
expr_stmt|;
block|}
name|err
operator|=
literal|0
expr_stmt|;
name|out
label|:
if|if
condition|(
name|err
condition|)
name|ses_cache_free_elm_addlstatus
argument_list|(
name|enc
argument_list|,
name|enc_cache
argument_list|)
expr_stmt|;
name|enc_update_request
argument_list|(
name|enc
argument_list|,
name|SES_PUBLISH_PHYSPATHS
argument_list|)
expr_stmt|;
name|enc_update_request
argument_list|(
name|enc
argument_list|,
name|SES_PUBLISH_CACHE
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ses_process_control_request
parameter_list|(
name|enc_softc_t
modifier|*
name|enc
parameter_list|,
name|struct
name|enc_fsm_state
modifier|*
name|state
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|bufp
parameter_list|,
name|int
name|error
parameter_list|,
name|int
name|xfer_len
parameter_list|)
block|{
name|ses_softc_t
modifier|*
name|ses
decl_stmt|;
name|ses
operator|=
name|enc
operator|->
name|enc_private
expr_stmt|;
comment|/* 	 * Possible errors: 	 *  o Generation count wrong. 	 *  o Some SCSI status error. 	 */
name|ses_terminate_control_requests
argument_list|(
operator|&
name|ses
operator|->
name|ses_pending_requests
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ses_poll_status
argument_list|(
name|enc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ses_publish_physpaths
parameter_list|(
name|enc_softc_t
modifier|*
name|enc
parameter_list|,
name|struct
name|enc_fsm_state
modifier|*
name|state
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|bufp
parameter_list|,
name|int
name|error
parameter_list|,
name|int
name|xfer_len
parameter_list|)
block|{
name|struct
name|ses_iterator
name|iter
decl_stmt|;
name|enc_cache_t
modifier|*
name|enc_cache
decl_stmt|;
name|ses_cache_t
modifier|*
name|ses_cache
decl_stmt|;
name|enc_element_t
modifier|*
name|element
decl_stmt|;
name|enc_cache
operator|=
operator|&
name|enc
operator|->
name|enc_daemon_cache
expr_stmt|;
name|ses_cache
operator|=
name|enc_cache
operator|->
name|private
expr_stmt|;
name|ses_iter_init
argument_list|(
name|enc
argument_list|,
name|enc_cache
argument_list|,
operator|&
name|iter
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|element
operator|=
name|ses_iter_next
argument_list|(
operator|&
name|iter
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * ses_set_physpath() returns success if we changed 		 * the physpath of any element.  This allows us to 		 * only announce devices once regardless of how 		 * many times we process additional element status. 		 */
if|if
condition|(
name|ses_set_physpath
argument_list|(
name|enc
argument_list|,
name|element
argument_list|,
operator|&
name|iter
argument_list|)
operator|==
literal|0
condition|)
name|ses_print_addl_data
argument_list|(
name|enc
argument_list|,
name|element
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ses_publish_cache
parameter_list|(
name|enc_softc_t
modifier|*
name|enc
parameter_list|,
name|struct
name|enc_fsm_state
modifier|*
name|state
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|bufp
parameter_list|,
name|int
name|error
parameter_list|,
name|int
name|xfer_len
parameter_list|)
block|{
name|sx_xlock
argument_list|(
operator|&
name|enc
operator|->
name|enc_cache_lock
argument_list|)
expr_stmt|;
name|ses_cache_clone
argument_list|(
name|enc
argument_list|,
comment|/*src*/
operator|&
name|enc
operator|->
name|enc_daemon_cache
argument_list|,
comment|/*dst*/
operator|&
name|enc
operator|->
name|enc_cache
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|enc
operator|->
name|enc_cache_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * \brief Parse the descriptors for each object.  *  * \param enc       The SES softc to update.  * \param buf       The buffer containing the descriptor list response.  * \param xfer_len  Size of the buffer.  *   * \return	0 on success, errno otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|ses_process_elm_descs
parameter_list|(
name|enc_softc_t
modifier|*
name|enc
parameter_list|,
name|struct
name|enc_fsm_state
modifier|*
name|state
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|bufp
parameter_list|,
name|int
name|error
parameter_list|,
name|int
name|xfer_len
parameter_list|)
block|{
name|ses_softc_t
modifier|*
name|ses
decl_stmt|;
name|struct
name|ses_iterator
name|iter
decl_stmt|;
name|enc_element_t
modifier|*
name|element
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|u_long
name|length
decl_stmt|,
name|plength
decl_stmt|;
name|enc_cache_t
modifier|*
name|enc_cache
decl_stmt|;
name|ses_cache_t
modifier|*
name|ses_cache
decl_stmt|;
name|uint8_t
modifier|*
name|buf
decl_stmt|;
name|ses_element_t
modifier|*
name|elmpriv
decl_stmt|;
specifier|const
name|struct
name|ses_page_hdr
modifier|*
name|phdr
decl_stmt|;
specifier|const
name|struct
name|ses_elm_desc_hdr
modifier|*
name|hdr
decl_stmt|;
name|ses
operator|=
name|enc
operator|->
name|enc_private
expr_stmt|;
name|enc_cache
operator|=
operator|&
name|enc
operator|->
name|enc_daemon_cache
expr_stmt|;
name|ses_cache
operator|=
name|enc_cache
operator|->
name|private
expr_stmt|;
name|buf
operator|=
operator|*
name|bufp
expr_stmt|;
name|err
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|error
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ses_cache_free_elm_descs
argument_list|(
name|enc
argument_list|,
name|enc_cache
argument_list|)
expr_stmt|;
name|ses_cache
operator|->
name|elm_descs_page
operator|=
operator|(
expr|struct
name|ses_elem_descr_page
operator|*
operator|)
name|buf
expr_stmt|;
operator|*
name|bufp
operator|=
name|NULL
expr_stmt|;
name|phdr
operator|=
operator|&
name|ses_cache
operator|->
name|elm_descs_page
operator|->
name|hdr
expr_stmt|;
name|plength
operator|=
name|ses_page_length
argument_list|(
name|phdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ses_page_hdr
argument_list|)
condition|)
block|{
name|ENC_VLOG
argument_list|(
name|enc
argument_list|,
literal|"Runt Element Descriptor Page\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|plength
operator|>
name|xfer_len
condition|)
block|{
name|ENC_VLOG
argument_list|(
name|enc
argument_list|,
literal|"Element Descriptor Page Too Long\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|!
name|ses_config_cache_valid
argument_list|(
name|ses_cache
argument_list|,
name|phdr
operator|->
name|gen_code
argument_list|)
condition|)
block|{
name|ENC_VLOG
argument_list|(
name|enc
argument_list|,
literal|"%s: Generation count change detected\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|enc_update_request
argument_list|(
name|enc
argument_list|,
name|SES_UPDATE_GETCONFIG
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|offset
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ses_page_hdr
argument_list|)
expr_stmt|;
name|ses_iter_init
argument_list|(
name|enc
argument_list|,
name|enc_cache
argument_list|,
operator|&
name|iter
argument_list|)
expr_stmt|;
while|while
condition|(
name|offset
operator|<
name|plength
operator|&&
operator|(
name|element
operator|=
name|ses_iter_next
argument_list|(
operator|&
name|iter
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ses_elm_desc_hdr
argument_list|)
operator|)
operator|>
name|plength
condition|)
block|{
name|ENC_VLOG
argument_list|(
name|enc
argument_list|,
literal|"Element %d Descriptor Header Past "
literal|"End of Buffer\n"
argument_list|,
name|iter
operator|.
name|global_element_index
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|hdr
operator|=
operator|(
expr|struct
name|ses_elm_desc_hdr
operator|*
operator|)
operator|&
name|buf
index|[
name|offset
index|]
expr_stmt|;
name|length
operator|=
name|scsi_2btoul
argument_list|(
name|hdr
operator|->
name|length
argument_list|)
expr_stmt|;
name|ENC_DLOG
argument_list|(
name|enc
argument_list|,
literal|"%s: obj %d(%d,%d) length=%d off=%d\n"
argument_list|,
name|__func__
argument_list|,
name|iter
operator|.
name|global_element_index
argument_list|,
name|iter
operator|.
name|type_index
argument_list|,
name|iter
operator|.
name|type_element_index
argument_list|,
name|length
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|offset
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|+
name|length
operator|)
operator|>
name|plength
condition|)
block|{
name|ENC_VLOG
argument_list|(
name|enc
argument_list|,
literal|"Element%d Descriptor Past "
literal|"End of Buffer\n"
argument_list|,
name|iter
operator|.
name|global_element_index
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|offset
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|elmpriv
operator|=
name|element
operator|->
name|elm_private
expr_stmt|;
name|elmpriv
operator|->
name|descr_len
operator|=
name|length
expr_stmt|;
name|elmpriv
operator|->
name|descr
operator|=
operator|&
name|buf
index|[
name|offset
index|]
expr_stmt|;
block|}
comment|/* skip over the descriptor itself */
name|offset
operator|+=
name|length
expr_stmt|;
block|}
name|err
operator|=
literal|0
expr_stmt|;
name|out
label|:
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ses
operator|->
name|ses_flags
operator|&
name|SES_FLAG_ADDLSTATUS
condition|)
name|enc_update_request
argument_list|(
name|enc
argument_list|,
name|SES_UPDATE_GETELMADDLSTATUS
argument_list|)
expr_stmt|;
block|}
name|enc_update_request
argument_list|(
name|enc
argument_list|,
name|SES_PUBLISH_CACHE
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ses_fill_rcv_diag_io
parameter_list|(
name|enc_softc_t
modifier|*
name|enc
parameter_list|,
name|struct
name|enc_fsm_state
modifier|*
name|state
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|)
block|{
if|if
condition|(
name|enc
operator|->
name|enc_type
operator|==
name|ENC_SEMB_SES
condition|)
block|{
name|semb_receive_diagnostic_results
argument_list|(
operator|&
name|ccb
operator|->
name|ataio
argument_list|,
comment|/*retries*/
literal|5
argument_list|,
name|NULL
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*pcv*/
literal|1
argument_list|,
name|state
operator|->
name|page_code
argument_list|,
name|buf
argument_list|,
name|state
operator|->
name|buf_size
argument_list|,
name|state
operator|->
name|timeout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|scsi_receive_diagnostic_results
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/*retries*/
literal|5
argument_list|,
name|NULL
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*pcv*/
literal|1
argument_list|,
name|state
operator|->
name|page_code
argument_list|,
name|buf
argument_list|,
name|state
operator|->
name|buf_size
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
name|state
operator|->
name|timeout
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * \brief Encode the object status into the response buffer, which is  *	  expected to contain the current enclosure status.  This function  *	  turns off all the 'select' bits for the objects except for the  *	  object specified, then sends it back to the enclosure.  *  * \param enc	SES enclosure the change is being applied to.  * \param buf	Buffer containing the current enclosure status response.  * \param amt	Length of the response in the buffer.  * \param req	The control request to be applied to buf.  *  * \return	0 on success, errno otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|ses_encode
parameter_list|(
name|enc_softc_t
modifier|*
name|enc
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|int
name|amt
parameter_list|,
name|ses_control_request_t
modifier|*
name|req
parameter_list|)
block|{
name|struct
name|ses_iterator
name|iter
decl_stmt|;
name|enc_element_t
modifier|*
name|element
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|struct
name|ses_control_page_hdr
modifier|*
name|hdr
decl_stmt|;
name|ses_iter_init
argument_list|(
name|enc
argument_list|,
operator|&
name|enc
operator|->
name|enc_cache
argument_list|,
operator|&
name|iter
argument_list|)
expr_stmt|;
name|hdr
operator|=
operator|(
expr|struct
name|ses_control_page_hdr
operator|*
operator|)
name|buf
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|elm_idx
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* for enclosure status, at least 2 bytes are needed */
if|if
condition|(
name|amt
operator|<
literal|2
condition|)
return|return
name|EIO
return|;
name|hdr
operator|->
name|control_flags
operator|=
name|req
operator|->
name|elm_stat
operator|.
name|comstatus
operator|&
name|SES_SET_STATUS_MASK
expr_stmt|;
name|ENC_DLOG
argument_list|(
name|enc
argument_list|,
literal|"Set EncStat %x\n"
argument_list|,
name|hdr
operator|->
name|control_flags
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|element
operator|=
name|ses_iter_seek_to
argument_list|(
operator|&
name|iter
argument_list|,
name|req
operator|->
name|elm_idx
argument_list|,
name|SES_ELEM_INDEX_GLOBAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|element
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* 	 * Seek to the type set that corresponds to the requested object. 	 * The +1 is for the overall status element for the type. 	 */
name|offset
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ses_control_page_hdr
argument_list|)
operator|+
operator|(
name|iter
operator|.
name|global_element_index
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ses_comstat
argument_list|)
operator|)
expr_stmt|;
comment|/* Check for buffer overflow. */
if|if
condition|(
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ses_comstat
argument_list|)
operator|>
name|amt
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* Set the status. */
name|memcpy
argument_list|(
operator|&
name|buf
index|[
name|offset
index|]
argument_list|,
operator|&
name|req
operator|->
name|elm_stat
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ses_comstat
argument_list|)
argument_list|)
expr_stmt|;
name|ENC_DLOG
argument_list|(
name|enc
argument_list|,
literal|"Set Type 0x%x Obj 0x%x (offset %d) with %x %x %x %x\n"
argument_list|,
name|iter
operator|.
name|type_index
argument_list|,
name|iter
operator|.
name|global_element_index
argument_list|,
name|offset
argument_list|,
name|req
operator|->
name|elm_stat
operator|.
name|comstatus
argument_list|,
name|req
operator|->
name|elm_stat
operator|.
name|comstat
index|[
literal|0
index|]
argument_list|,
name|req
operator|->
name|elm_stat
operator|.
name|comstat
index|[
literal|1
index|]
argument_list|,
name|req
operator|->
name|elm_stat
operator|.
name|comstat
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ses_fill_control_request
parameter_list|(
name|enc_softc_t
modifier|*
name|enc
parameter_list|,
name|struct
name|enc_fsm_state
modifier|*
name|state
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|)
block|{
name|ses_softc_t
modifier|*
name|ses
decl_stmt|;
name|enc_cache_t
modifier|*
name|enc_cache
decl_stmt|;
name|ses_cache_t
modifier|*
name|ses_cache
decl_stmt|;
name|struct
name|ses_control_page_hdr
modifier|*
name|hdr
decl_stmt|;
name|ses_control_request_t
modifier|*
name|req
decl_stmt|;
name|size_t
name|plength
decl_stmt|;
name|size_t
name|offset
decl_stmt|;
name|ses
operator|=
name|enc
operator|->
name|enc_private
expr_stmt|;
name|enc_cache
operator|=
operator|&
name|enc
operator|->
name|enc_daemon_cache
expr_stmt|;
name|ses_cache
operator|=
name|enc_cache
operator|->
name|private
expr_stmt|;
name|hdr
operator|=
operator|(
expr|struct
name|ses_control_page_hdr
operator|*
operator|)
name|buf
expr_stmt|;
if|if
condition|(
name|ses_cache
operator|->
name|status_page
operator|==
name|NULL
condition|)
block|{
name|ses_terminate_control_requests
argument_list|(
operator|&
name|ses
operator|->
name|ses_requests
argument_list|,
name|EIO
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|plength
operator|=
name|ses_page_length
argument_list|(
operator|&
name|ses_cache
operator|->
name|status_page
operator|->
name|hdr
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|ses_cache
operator|->
name|status_page
argument_list|,
name|plength
argument_list|)
expr_stmt|;
comment|/* Disable the select bits in all status entries.  */
name|offset
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ses_control_page_hdr
argument_list|)
expr_stmt|;
for|for
control|(
name|offset
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ses_control_page_hdr
argument_list|)
init|;
name|offset
operator|<
name|plength
condition|;
name|offset
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ses_comstat
argument_list|)
control|)
block|{
name|buf
index|[
name|offset
index|]
operator|&=
operator|~
name|SESCTL_CSEL
expr_stmt|;
block|}
comment|/* And make sure the INVOP bit is clear.  */
name|hdr
operator|->
name|control_flags
operator|&=
operator|~
name|SES_ENCSTAT_INVOP
expr_stmt|;
comment|/* Apply incoming requests. */
while|while
condition|(
operator|(
name|req
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ses
operator|->
name|ses_requests
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ses
operator|->
name|ses_requests
argument_list|,
name|req
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|req
operator|->
name|result
operator|=
name|ses_encode
argument_list|(
name|enc
argument_list|,
name|buf
argument_list|,
name|plength
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|result
operator|!=
literal|0
condition|)
block|{
name|wakeup
argument_list|(
name|req
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ses
operator|->
name|ses_pending_requests
argument_list|,
name|req
argument_list|,
name|links
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ses
operator|->
name|ses_pending_requests
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
comment|/* Fill out the ccb */
if|if
condition|(
name|enc
operator|->
name|enc_type
operator|==
name|ENC_SEMB_SES
condition|)
block|{
name|semb_send_diagnostic
argument_list|(
operator|&
name|ccb
operator|->
name|ataio
argument_list|,
comment|/*retries*/
literal|5
argument_list|,
name|NULL
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|buf
argument_list|,
name|ses_page_length
argument_list|(
operator|&
name|ses_cache
operator|->
name|status_page
operator|->
name|hdr
argument_list|)
argument_list|,
name|state
operator|->
name|timeout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|scsi_send_diagnostic
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/*retries*/
literal|5
argument_list|,
name|NULL
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*unit_offline*/
literal|0
argument_list|,
comment|/*device_offline*/
literal|0
argument_list|,
comment|/*self_test*/
literal|0
argument_list|,
comment|/*page_format*/
literal|1
argument_list|,
comment|/*self_test_code*/
literal|0
argument_list|,
name|buf
argument_list|,
name|ses_page_length
argument_list|(
operator|&
name|ses_cache
operator|->
name|status_page
operator|->
name|hdr
argument_list|)
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
name|state
operator|->
name|timeout
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ses_get_elm_addlstatus_fc
parameter_list|(
name|enc_softc_t
modifier|*
name|enc
parameter_list|,
name|enc_cache_t
modifier|*
name|enc_cache
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|int
name|bufsiz
parameter_list|)
block|{
name|ENC_VLOG
argument_list|(
name|enc
argument_list|,
literal|"FC Device Support Stubbed in Additional Status Page\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|SES_PRINT_PORTS
parameter_list|(
name|p
parameter_list|,
name|type
parameter_list|)
value|do {					\ 	sbuf_printf(sbp, " %s(", type);					\ 	if (((p)& SES_SASOBJ_DEV_PHY_PROTOMASK) == 0)			\ 		sbuf_printf(sbp, " None");				\ 	else {								\ 		if ((p)& SES_SASOBJ_DEV_PHY_SMP)			\ 			sbuf_printf(sbp, " SMP");			\ 		if ((p)& SES_SASOBJ_DEV_PHY_STP)			\ 			sbuf_printf(sbp, " STP");			\ 		if ((p)& SES_SASOBJ_DEV_PHY_SSP)			\ 			sbuf_printf(sbp, " SSP");			\ 	}								\ 	sbuf_printf(sbp, " )");						\ } while(0)
end_define

begin_comment
comment|/**  * \brief Print the additional element status data for this object, for SAS  * 	  type 0 objects.  See SES2 r20 Section 6.1.13.3.2.  *  * \param sesname	SES device name associated with the object.  * \param sbp		Sbuf to print to.  * \param obj		The object to print the data for.  * \param periph_name	Peripheral string associated with the object.  */
end_comment

begin_function
specifier|static
name|void
name|ses_print_addl_data_sas_type0
parameter_list|(
name|char
modifier|*
name|sesname
parameter_list|,
name|struct
name|sbuf
modifier|*
name|sbp
parameter_list|,
name|enc_element_t
modifier|*
name|obj
parameter_list|,
name|char
modifier|*
name|periph_name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|ses_element_t
modifier|*
name|elmpriv
decl_stmt|;
name|struct
name|ses_addl_status
modifier|*
name|addl
decl_stmt|;
name|struct
name|ses_elm_sas_device_phy
modifier|*
name|phy
decl_stmt|;
name|elmpriv
operator|=
name|obj
operator|->
name|elm_private
expr_stmt|;
name|addl
operator|=
operator|&
operator|(
name|elmpriv
operator|->
name|addl
operator|)
expr_stmt|;
if|if
condition|(
name|addl
operator|->
name|proto_hdr
operator|.
name|sas
operator|==
name|NULL
condition|)
return|return;
name|sbuf_printf
argument_list|(
name|sbp
argument_list|,
literal|"%s: %s: SAS Device Slot Element:"
argument_list|,
name|sesname
argument_list|,
name|periph_name
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sbp
argument_list|,
literal|" %d Phys"
argument_list|,
name|addl
operator|->
name|proto_hdr
operator|.
name|sas
operator|->
name|base_hdr
operator|.
name|num_phys
argument_list|)
expr_stmt|;
if|if
condition|(
name|ses_elm_addlstatus_eip
argument_list|(
name|addl
operator|->
name|hdr
argument_list|)
condition|)
name|sbuf_printf
argument_list|(
name|sbp
argument_list|,
literal|" at Slot %d"
argument_list|,
name|addl
operator|->
name|proto_hdr
operator|.
name|sas
operator|->
name|type0_eip
operator|.
name|dev_slot_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|ses_elm_sas_type0_not_all_phys
argument_list|(
name|addl
operator|->
name|proto_hdr
operator|.
name|sas
argument_list|)
condition|)
name|sbuf_printf
argument_list|(
name|sbp
argument_list|,
literal|", Not All Phys"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sbp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|addl
operator|->
name|proto_data
operator|.
name|sasdev_phys
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|addl
operator|->
name|proto_hdr
operator|.
name|sas
operator|->
name|base_hdr
operator|.
name|num_phys
condition|;
name|i
operator|++
control|)
block|{
name|phy
operator|=
operator|&
name|addl
operator|->
name|proto_data
operator|.
name|sasdev_phys
index|[
name|i
index|]
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sbp
argument_list|,
literal|"%s:  phy %d:"
argument_list|,
name|sesname
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ses_elm_sas_dev_phy_sata_dev
argument_list|(
name|phy
argument_list|)
condition|)
comment|/* Spec says all other fields are specific values */
name|sbuf_printf
argument_list|(
name|sbp
argument_list|,
literal|" SATA device\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|sbuf_printf
argument_list|(
name|sbp
argument_list|,
literal|" SAS device type %d id %d\n"
argument_list|,
name|ses_elm_sas_dev_phy_dev_type
argument_list|(
name|phy
argument_list|)
argument_list|,
name|phy
operator|->
name|phy_id
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sbp
argument_list|,
literal|"%s:  phy %d: protocols:"
argument_list|,
name|sesname
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|SES_PRINT_PORTS
argument_list|(
name|phy
operator|->
name|initiator_ports
argument_list|,
literal|"Initiator"
argument_list|)
expr_stmt|;
name|SES_PRINT_PORTS
argument_list|(
name|phy
operator|->
name|target_ports
argument_list|,
literal|"Target"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sbp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|sbuf_printf
argument_list|(
name|sbp
argument_list|,
literal|"%s:  phy %d: parent %jx addr %jx\n"
argument_list|,
name|sesname
argument_list|,
name|i
argument_list|,
operator|(
name|uintmax_t
operator|)
name|scsi_8btou64
argument_list|(
name|phy
operator|->
name|parent_addr
argument_list|)
argument_list|,
operator|(
name|uintmax_t
operator|)
name|scsi_8btou64
argument_list|(
name|phy
operator|->
name|phy_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_undef
undef|#
directive|undef
name|SES_PRINT_PORTS
end_undef

begin_comment
comment|/**  * \brief Report whether a given enclosure object is an expander.  *  * \param enc	SES softc associated with object.  * \param obj	Enclosure object to report for.  *  * \return	1 if true, 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|ses_obj_is_expander
parameter_list|(
name|enc_softc_t
modifier|*
name|enc
parameter_list|,
name|enc_element_t
modifier|*
name|obj
parameter_list|)
block|{
return|return
operator|(
name|obj
operator|->
name|enctype
operator|==
name|ELMTYP_SAS_EXP
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * \brief Print the additional element status data for this object, for SAS  *	  type 1 objects.  See SES2 r20 Sections 6.1.13.3.3 and 6.1.13.3.4.  *  * \param enc		SES enclosure, needed for type identification.  * \param sesname	SES device name associated with the object.  * \param sbp		Sbuf to print to.  * \param obj		The object to print the data for.  * \param periph_name	Peripheral string associated with the object.  */
end_comment

begin_function
specifier|static
name|void
name|ses_print_addl_data_sas_type1
parameter_list|(
name|enc_softc_t
modifier|*
name|enc
parameter_list|,
name|char
modifier|*
name|sesname
parameter_list|,
name|struct
name|sbuf
modifier|*
name|sbp
parameter_list|,
name|enc_element_t
modifier|*
name|obj
parameter_list|,
name|char
modifier|*
name|periph_name
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|num_phys
decl_stmt|;
name|ses_element_t
modifier|*
name|elmpriv
decl_stmt|;
name|struct
name|ses_addl_status
modifier|*
name|addl
decl_stmt|;
name|struct
name|ses_elm_sas_expander_phy
modifier|*
name|exp_phy
decl_stmt|;
name|struct
name|ses_elm_sas_port_phy
modifier|*
name|port_phy
decl_stmt|;
name|elmpriv
operator|=
name|obj
operator|->
name|elm_private
expr_stmt|;
name|addl
operator|=
operator|&
operator|(
name|elmpriv
operator|->
name|addl
operator|)
expr_stmt|;
if|if
condition|(
name|addl
operator|->
name|proto_hdr
operator|.
name|sas
operator|==
name|NULL
condition|)
return|return;
name|sbuf_printf
argument_list|(
name|sbp
argument_list|,
literal|"%s: %s: SAS "
argument_list|,
name|sesname
argument_list|,
name|periph_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ses_obj_is_expander
argument_list|(
name|enc
argument_list|,
name|obj
argument_list|)
condition|)
block|{
name|num_phys
operator|=
name|addl
operator|->
name|proto_hdr
operator|.
name|sas
operator|->
name|base_hdr
operator|.
name|num_phys
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sbp
argument_list|,
literal|"Expander: %d Phys"
argument_list|,
name|num_phys
argument_list|)
expr_stmt|;
if|if
condition|(
name|addl
operator|->
name|proto_data
operator|.
name|sasexp_phys
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_phys
condition|;
name|i
operator|++
control|)
block|{
name|exp_phy
operator|=
operator|&
name|addl
operator|->
name|proto_data
operator|.
name|sasexp_phys
index|[
name|i
index|]
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sbp
argument_list|,
literal|"%s:  phy %d: connector %d other %d\n"
argument_list|,
name|sesname
argument_list|,
name|i
argument_list|,
name|exp_phy
operator|->
name|connector_index
argument_list|,
name|exp_phy
operator|->
name|other_index
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|num_phys
operator|=
name|addl
operator|->
name|proto_hdr
operator|.
name|sas
operator|->
name|base_hdr
operator|.
name|num_phys
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sbp
argument_list|,
literal|"Port: %d Phys"
argument_list|,
name|num_phys
argument_list|)
expr_stmt|;
if|if
condition|(
name|addl
operator|->
name|proto_data
operator|.
name|sasport_phys
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_phys
condition|;
name|i
operator|++
control|)
block|{
name|port_phy
operator|=
operator|&
name|addl
operator|->
name|proto_data
operator|.
name|sasport_phys
index|[
name|i
index|]
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sbp
argument_list|,
literal|"%s:  phy %d: id %d connector %d other %d\n"
argument_list|,
name|sesname
argument_list|,
name|i
argument_list|,
name|port_phy
operator|->
name|phy_id
argument_list|,
name|port_phy
operator|->
name|connector_index
argument_list|,
name|port_phy
operator|->
name|other_index
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sbp
argument_list|,
literal|"%s:  phy %d: addr %jx\n"
argument_list|,
name|sesname
argument_list|,
name|i
argument_list|,
operator|(
name|uintmax_t
operator|)
name|scsi_8btou64
argument_list|(
name|port_phy
operator|->
name|phy_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * \brief Print the additional element status data for this object.  *  * \param enc		SES softc associated with the object.  * \param obj		The object to print the data for.  */
end_comment

begin_function
specifier|static
name|void
name|ses_print_addl_data
parameter_list|(
name|enc_softc_t
modifier|*
name|enc
parameter_list|,
name|enc_element_t
modifier|*
name|obj
parameter_list|)
block|{
name|ses_element_t
modifier|*
name|elmpriv
decl_stmt|;
name|struct
name|ses_addl_status
modifier|*
name|addl
decl_stmt|;
name|struct
name|sbuf
name|sesname
decl_stmt|,
name|name
decl_stmt|,
name|out
decl_stmt|;
name|elmpriv
operator|=
name|obj
operator|->
name|elm_private
expr_stmt|;
if|if
condition|(
name|elmpriv
operator|==
name|NULL
condition|)
return|return;
name|addl
operator|=
operator|&
operator|(
name|elmpriv
operator|->
name|addl
operator|)
expr_stmt|;
if|if
condition|(
name|addl
operator|->
name|hdr
operator|==
name|NULL
condition|)
return|return;
name|sbuf_new
argument_list|(
operator|&
name|sesname
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|,
name|SBUF_AUTOEXTEND
argument_list|)
expr_stmt|;
name|sbuf_new
argument_list|(
operator|&
name|name
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|,
name|SBUF_AUTOEXTEND
argument_list|)
expr_stmt|;
name|sbuf_new
argument_list|(
operator|&
name|out
argument_list|,
name|NULL
argument_list|,
literal|512
argument_list|,
name|SBUF_AUTOEXTEND
argument_list|)
expr_stmt|;
name|ses_paths_iter
argument_list|(
name|enc
argument_list|,
name|obj
argument_list|,
name|ses_elmdevname_callback
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbuf_len
argument_list|(
operator|&
name|name
argument_list|)
operator|==
literal|0
condition|)
name|sbuf_printf
argument_list|(
operator|&
name|name
argument_list|,
literal|"(none)"
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
operator|&
name|name
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
operator|&
name|sesname
argument_list|,
literal|"%s%d"
argument_list|,
name|enc
operator|->
name|periph
operator|->
name|periph_name
argument_list|,
name|enc
operator|->
name|periph
operator|->
name|unit_number
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
operator|&
name|sesname
argument_list|)
expr_stmt|;
if|if
condition|(
name|elmpriv
operator|->
name|descr
operator|!=
name|NULL
condition|)
name|sbuf_printf
argument_list|(
operator|&
name|out
argument_list|,
literal|"%s: %s: Element descriptor: '%s'\n"
argument_list|,
name|sbuf_data
argument_list|(
operator|&
name|sesname
argument_list|)
argument_list|,
name|sbuf_data
argument_list|(
operator|&
name|name
argument_list|)
argument_list|,
name|elmpriv
operator|->
name|descr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ses_elm_addlstatus_proto
argument_list|(
name|addl
operator|->
name|hdr
argument_list|)
condition|)
block|{
case|case
name|SPSP_PROTO_SAS
case|:
switch|switch
condition|(
name|ses_elm_sas_descr_type
argument_list|(
name|addl
operator|->
name|proto_hdr
operator|.
name|sas
argument_list|)
condition|)
block|{
case|case
name|SES_SASOBJ_TYPE_SLOT
case|:
name|ses_print_addl_data_sas_type0
argument_list|(
name|sbuf_data
argument_list|(
operator|&
name|sesname
argument_list|)
argument_list|,
operator|&
name|out
argument_list|,
name|obj
argument_list|,
name|sbuf_data
argument_list|(
operator|&
name|name
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SES_SASOBJ_TYPE_OTHER
case|:
name|ses_print_addl_data_sas_type1
argument_list|(
name|enc
argument_list|,
name|sbuf_data
argument_list|(
operator|&
name|sesname
argument_list|)
argument_list|,
operator|&
name|out
argument_list|,
name|obj
argument_list|,
name|sbuf_data
argument_list|(
operator|&
name|name
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|SPSP_PROTO_FC
case|:
comment|/* stubbed for now */
break|break;
default|default:
break|break;
block|}
name|sbuf_finish
argument_list|(
operator|&
name|out
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|sbuf_data
argument_list|(
operator|&
name|out
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
operator|&
name|out
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
operator|&
name|name
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
operator|&
name|sesname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * \brief Update the softc with the additional element status data for this  * 	  object, for SAS type 0 objects.  *  * \param enc		SES softc to be updated.  * \param buf		The additional element status response buffer.  * \param bufsiz	Size of the response buffer.  * \param eip		The EIP bit value.  * \param nobj		Number of objects attached to the SES softc.  *   * \return		0 on success, errno otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|ses_get_elm_addlstatus_sas_type0
parameter_list|(
name|enc_softc_t
modifier|*
name|enc
parameter_list|,
name|enc_cache_t
modifier|*
name|enc_cache
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|int
name|bufsiz
parameter_list|,
name|int
name|eip
parameter_list|,
name|int
name|nobj
parameter_list|)
block|{
name|int
name|err
decl_stmt|,
name|offset
decl_stmt|,
name|physz
decl_stmt|;
name|enc_element_t
modifier|*
name|obj
decl_stmt|;
name|ses_element_t
modifier|*
name|elmpriv
decl_stmt|;
name|struct
name|ses_addl_status
modifier|*
name|addl
decl_stmt|;
name|err
operator|=
name|offset
operator|=
literal|0
expr_stmt|;
comment|/* basic object setup */
name|obj
operator|=
operator|&
operator|(
name|enc_cache
operator|->
name|elm_map
index|[
name|nobj
index|]
operator|)
expr_stmt|;
name|elmpriv
operator|=
name|obj
operator|->
name|elm_private
expr_stmt|;
name|addl
operator|=
operator|&
operator|(
name|elmpriv
operator|->
name|addl
operator|)
expr_stmt|;
name|addl
operator|->
name|proto_hdr
operator|.
name|sas
operator|=
operator|(
expr|union
name|ses_elm_sas_hdr
operator|*
operator|)
operator|&
name|buf
index|[
name|offset
index|]
expr_stmt|;
comment|/* Don't assume this object has any phys */
name|bzero
argument_list|(
operator|&
name|addl
operator|->
name|proto_data
argument_list|,
sizeof|sizeof
argument_list|(
name|addl
operator|->
name|proto_data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|addl
operator|->
name|proto_hdr
operator|.
name|sas
operator|->
name|base_hdr
operator|.
name|num_phys
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* Skip forward to the phy list */
if|if
condition|(
name|eip
condition|)
name|offset
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ses_elm_sas_type0_eip_hdr
argument_list|)
expr_stmt|;
else|else
name|offset
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ses_elm_sas_type0_base_hdr
argument_list|)
expr_stmt|;
comment|/* Make sure the phy list fits in the buffer */
name|physz
operator|=
name|addl
operator|->
name|proto_hdr
operator|.
name|sas
operator|->
name|base_hdr
operator|.
name|num_phys
expr_stmt|;
name|physz
operator|*=
sizeof|sizeof
argument_list|(
expr|struct
name|ses_elm_sas_device_phy
argument_list|)
expr_stmt|;
if|if
condition|(
name|physz
operator|>
operator|(
name|bufsiz
operator|-
name|offset
operator|+
literal|4
operator|)
condition|)
block|{
name|ENC_VLOG
argument_list|(
name|enc
argument_list|,
literal|"Element %d Device Phy List Beyond End Of Buffer\n"
argument_list|,
name|nobj
argument_list|)
expr_stmt|;
name|err
operator|=
name|EIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Point to the phy list */
name|addl
operator|->
name|proto_data
operator|.
name|sasdev_phys
operator|=
operator|(
expr|struct
name|ses_elm_sas_device_phy
operator|*
operator|)
operator|&
name|buf
index|[
name|offset
index|]
expr_stmt|;
name|out
label|:
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * \brief Update the softc with the additional element status data for this  * 	  object, for SAS type 1 objects.  *  * \param enc		SES softc to be updated.  * \param buf		The additional element status response buffer.  * \param bufsiz	Size of the response buffer.  * \param eip		The EIP bit value.  * \param nobj		Number of objects attached to the SES softc.  *   * \return		0 on success, errno otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|ses_get_elm_addlstatus_sas_type1
parameter_list|(
name|enc_softc_t
modifier|*
name|enc
parameter_list|,
name|enc_cache_t
modifier|*
name|enc_cache
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|int
name|bufsiz
parameter_list|,
name|int
name|eip
parameter_list|,
name|int
name|nobj
parameter_list|)
block|{
name|int
name|err
decl_stmt|,
name|offset
decl_stmt|,
name|physz
decl_stmt|;
name|enc_element_t
modifier|*
name|obj
decl_stmt|;
name|ses_element_t
modifier|*
name|elmpriv
decl_stmt|;
name|struct
name|ses_addl_status
modifier|*
name|addl
decl_stmt|;
name|err
operator|=
name|offset
operator|=
literal|0
expr_stmt|;
comment|/* basic object setup */
name|obj
operator|=
operator|&
operator|(
name|enc_cache
operator|->
name|elm_map
index|[
name|nobj
index|]
operator|)
expr_stmt|;
name|elmpriv
operator|=
name|obj
operator|->
name|elm_private
expr_stmt|;
name|addl
operator|=
operator|&
operator|(
name|elmpriv
operator|->
name|addl
operator|)
expr_stmt|;
name|addl
operator|->
name|proto_hdr
operator|.
name|sas
operator|=
operator|(
expr|union
name|ses_elm_sas_hdr
operator|*
operator|)
operator|&
name|buf
index|[
name|offset
index|]
expr_stmt|;
comment|/* Don't assume this object has any phys */
name|bzero
argument_list|(
operator|&
name|addl
operator|->
name|proto_data
argument_list|,
sizeof|sizeof
argument_list|(
name|addl
operator|->
name|proto_data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|addl
operator|->
name|proto_hdr
operator|.
name|sas
operator|->
name|base_hdr
operator|.
name|num_phys
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* Process expanders differently from other type1 cases */
if|if
condition|(
name|ses_obj_is_expander
argument_list|(
name|enc
argument_list|,
name|obj
argument_list|)
condition|)
block|{
name|offset
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ses_elm_sas_type1_expander_hdr
argument_list|)
expr_stmt|;
name|physz
operator|=
name|addl
operator|->
name|proto_hdr
operator|.
name|sas
operator|->
name|base_hdr
operator|.
name|num_phys
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ses_elm_sas_expander_phy
argument_list|)
expr_stmt|;
if|if
condition|(
name|physz
operator|>
operator|(
name|bufsiz
operator|-
name|offset
operator|)
condition|)
block|{
name|ENC_VLOG
argument_list|(
name|enc
argument_list|,
literal|"Element %d: Expander Phy List Beyond "
literal|"End Of Buffer\n"
argument_list|,
name|nobj
argument_list|)
expr_stmt|;
name|err
operator|=
name|EIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|addl
operator|->
name|proto_data
operator|.
name|sasexp_phys
operator|=
operator|(
expr|struct
name|ses_elm_sas_expander_phy
operator|*
operator|)
operator|&
name|buf
index|[
name|offset
index|]
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ses_elm_sas_type1_nonexpander_hdr
argument_list|)
expr_stmt|;
name|physz
operator|=
name|addl
operator|->
name|proto_hdr
operator|.
name|sas
operator|->
name|base_hdr
operator|.
name|num_phys
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ses_elm_sas_port_phy
argument_list|)
expr_stmt|;
if|if
condition|(
name|physz
operator|>
operator|(
name|bufsiz
operator|-
name|offset
operator|+
literal|4
operator|)
condition|)
block|{
name|ENC_VLOG
argument_list|(
name|enc
argument_list|,
literal|"Element %d: Port Phy List Beyond End "
literal|"Of Buffer\n"
argument_list|,
name|nobj
argument_list|)
expr_stmt|;
name|err
operator|=
name|EIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|addl
operator|->
name|proto_data
operator|.
name|sasport_phys
operator|=
operator|(
expr|struct
name|ses_elm_sas_port_phy
operator|*
operator|)
operator|&
name|buf
index|[
name|offset
index|]
expr_stmt|;
block|}
name|out
label|:
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * \brief Update the softc with the additional element status data for this  * 	  object, for SAS objects.  *  * \param enc		SES softc to be updated.  * \param buf		The additional element status response buffer.  * \param bufsiz	Size of the response buffer.  * \param eip		The EIP bit value.  * \param tidx		Type index for this object.  * \param nobj		Number of objects attached to the SES softc.  *   * \return		0 on success, errno otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|ses_get_elm_addlstatus_sas
parameter_list|(
name|enc_softc_t
modifier|*
name|enc
parameter_list|,
name|enc_cache_t
modifier|*
name|enc_cache
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|int
name|bufsiz
parameter_list|,
name|int
name|eip
parameter_list|,
name|int
name|tidx
parameter_list|,
name|int
name|nobj
parameter_list|)
block|{
name|int
name|dtype
decl_stmt|,
name|err
decl_stmt|;
name|ses_cache_t
modifier|*
name|ses_cache
decl_stmt|;
name|union
name|ses_elm_sas_hdr
modifier|*
name|hdr
decl_stmt|;
comment|/* Need to be able to read the descriptor type! */
if|if
condition|(
name|bufsiz
operator|<
sizeof|sizeof
argument_list|(
expr|union
name|ses_elm_sas_hdr
argument_list|)
condition|)
block|{
name|err
operator|=
name|EIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ses_cache
operator|=
name|enc_cache
operator|->
name|private
expr_stmt|;
name|hdr
operator|=
operator|(
expr|union
name|ses_elm_sas_hdr
operator|*
operator|)
name|buf
expr_stmt|;
name|dtype
operator|=
name|ses_elm_sas_descr_type
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dtype
condition|)
block|{
case|case
name|SES_SASOBJ_TYPE_SLOT
case|:
switch|switch
condition|(
name|ses_cache
operator|->
name|ses_types
index|[
name|tidx
index|]
operator|.
name|hdr
operator|->
name|etype_elm_type
condition|)
block|{
case|case
name|ELMTYP_DEVICE
case|:
case|case
name|ELMTYP_ARRAY_DEV
case|:
break|break;
default|default:
name|ENC_VLOG
argument_list|(
name|enc
argument_list|,
literal|"Element %d has Additional Status type 0, "
literal|"invalid for SES element type 0x%x\n"
argument_list|,
name|nobj
argument_list|,
name|ses_cache
operator|->
name|ses_types
index|[
name|tidx
index|]
operator|.
name|hdr
operator|->
name|etype_elm_type
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|err
operator|=
name|ses_get_elm_addlstatus_sas_type0
argument_list|(
name|enc
argument_list|,
name|enc_cache
argument_list|,
name|buf
argument_list|,
name|bufsiz
argument_list|,
name|eip
argument_list|,
name|nobj
argument_list|)
expr_stmt|;
break|break;
case|case
name|SES_SASOBJ_TYPE_OTHER
case|:
switch|switch
condition|(
name|ses_cache
operator|->
name|ses_types
index|[
name|tidx
index|]
operator|.
name|hdr
operator|->
name|etype_elm_type
condition|)
block|{
case|case
name|ELMTYP_SAS_EXP
case|:
case|case
name|ELMTYP_SCSI_INI
case|:
case|case
name|ELMTYP_SCSI_TGT
case|:
case|case
name|ELMTYP_ESCC
case|:
break|break;
default|default:
name|ENC_VLOG
argument_list|(
name|enc
argument_list|,
literal|"Element %d has Additional Status type 1, "
literal|"invalid for SES element type 0x%x\n"
argument_list|,
name|nobj
argument_list|,
name|ses_cache
operator|->
name|ses_types
index|[
name|tidx
index|]
operator|.
name|hdr
operator|->
name|etype_elm_type
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|err
operator|=
name|ses_get_elm_addlstatus_sas_type1
argument_list|(
name|enc
argument_list|,
name|enc_cache
argument_list|,
name|buf
argument_list|,
name|bufsiz
argument_list|,
name|eip
argument_list|,
name|nobj
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ENC_VLOG
argument_list|(
name|enc
argument_list|,
literal|"Element %d of type 0x%x has Additional Status "
literal|"of unknown type 0x%x\n"
argument_list|,
name|nobj
argument_list|,
name|ses_cache
operator|->
name|ses_types
index|[
name|tidx
index|]
operator|.
name|hdr
operator|->
name|etype_elm_type
argument_list|,
name|dtype
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|out
label|:
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ses_softc_invalidate
parameter_list|(
name|enc_softc_t
modifier|*
name|enc
parameter_list|)
block|{
name|ses_softc_t
modifier|*
name|ses
decl_stmt|;
name|ses
operator|=
name|enc
operator|->
name|enc_private
expr_stmt|;
name|ses_terminate_control_requests
argument_list|(
operator|&
name|ses
operator|->
name|ses_requests
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ses_softc_cleanup
parameter_list|(
name|enc_softc_t
modifier|*
name|enc
parameter_list|)
block|{
name|ses_cache_free
argument_list|(
name|enc
argument_list|,
operator|&
name|enc
operator|->
name|enc_cache
argument_list|)
expr_stmt|;
name|ses_cache_free
argument_list|(
name|enc
argument_list|,
operator|&
name|enc
operator|->
name|enc_daemon_cache
argument_list|)
expr_stmt|;
name|ENC_FREE_AND_NULL
argument_list|(
name|enc
operator|->
name|enc_private
argument_list|)
expr_stmt|;
name|ENC_FREE_AND_NULL
argument_list|(
name|enc
operator|->
name|enc_cache
operator|.
name|private
argument_list|)
expr_stmt|;
name|ENC_FREE_AND_NULL
argument_list|(
name|enc
operator|->
name|enc_daemon_cache
operator|.
name|private
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ses_init_enc
parameter_list|(
name|enc_softc_t
modifier|*
name|enc
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ses_get_enc_status
parameter_list|(
name|enc_softc_t
modifier|*
name|enc
parameter_list|,
name|int
name|slpflag
parameter_list|)
block|{
comment|/* Automatically updated, caller checks enc_cache->encstat itself */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ses_set_enc_status
parameter_list|(
name|enc_softc_t
modifier|*
name|enc
parameter_list|,
name|uint8_t
name|encstat
parameter_list|,
name|int
name|slpflag
parameter_list|)
block|{
name|ses_control_request_t
name|req
decl_stmt|;
name|ses_softc_t
modifier|*
name|ses
decl_stmt|;
name|ses
operator|=
name|enc
operator|->
name|enc_private
expr_stmt|;
name|req
operator|.
name|elm_idx
operator|=
name|SES_SETSTATUS_ENC_IDX
expr_stmt|;
name|req
operator|.
name|elm_stat
operator|.
name|comstatus
operator|=
name|encstat
operator|&
literal|0xf
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ses
operator|->
name|ses_requests
argument_list|,
operator|&
name|req
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|enc_update_request
argument_list|(
name|enc
argument_list|,
name|SES_PROCESS_CONTROL_REQS
argument_list|)
expr_stmt|;
name|cam_periph_sleep
argument_list|(
name|enc
operator|->
name|periph
argument_list|,
operator|&
name|req
argument_list|,
name|PUSER
argument_list|,
literal|"encstat"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|req
operator|.
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ses_get_elm_status
parameter_list|(
name|enc_softc_t
modifier|*
name|enc
parameter_list|,
name|encioc_elm_status_t
modifier|*
name|elms
parameter_list|,
name|int
name|slpflag
parameter_list|)
block|{
name|unsigned
name|int
name|i
init|=
name|elms
operator|->
name|elm_idx
decl_stmt|;
name|memcpy
argument_list|(
name|elms
operator|->
name|cstat
argument_list|,
operator|&
name|enc
operator|->
name|enc_cache
operator|.
name|elm_map
index|[
name|i
index|]
operator|.
name|encstat
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ses_set_elm_status
parameter_list|(
name|enc_softc_t
modifier|*
name|enc
parameter_list|,
name|encioc_elm_status_t
modifier|*
name|elms
parameter_list|,
name|int
name|slpflag
parameter_list|)
block|{
name|ses_control_request_t
name|req
decl_stmt|;
name|ses_softc_t
modifier|*
name|ses
decl_stmt|;
comment|/* If this is clear, we don't do diddly.  */
if|if
condition|(
operator|(
name|elms
operator|->
name|cstat
index|[
literal|0
index|]
operator|&
name|SESCTL_CSEL
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ses
operator|=
name|enc
operator|->
name|enc_private
expr_stmt|;
name|req
operator|.
name|elm_idx
operator|=
name|elms
operator|->
name|elm_idx
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|req
operator|.
name|elm_stat
argument_list|,
name|elms
operator|->
name|cstat
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|.
name|elm_stat
argument_list|)
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ses
operator|->
name|ses_requests
argument_list|,
operator|&
name|req
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|enc_update_request
argument_list|(
name|enc
argument_list|,
name|SES_PROCESS_CONTROL_REQS
argument_list|)
expr_stmt|;
name|cam_periph_sleep
argument_list|(
name|enc
operator|->
name|periph
argument_list|,
operator|&
name|req
argument_list|,
name|PUSER
argument_list|,
literal|"encstat"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|req
operator|.
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ses_get_elm_desc
parameter_list|(
name|enc_softc_t
modifier|*
name|enc
parameter_list|,
name|encioc_elm_desc_t
modifier|*
name|elmd
parameter_list|)
block|{
name|int
name|i
init|=
operator|(
name|int
operator|)
name|elmd
operator|->
name|elm_idx
decl_stmt|;
name|ses_element_t
modifier|*
name|elmpriv
decl_stmt|;
comment|/* Assume caller has already checked obj_id validity */
name|elmpriv
operator|=
name|enc
operator|->
name|enc_cache
operator|.
name|elm_map
index|[
name|i
index|]
operator|.
name|elm_private
expr_stmt|;
comment|/* object might not have a descriptor */
if|if
condition|(
name|elmpriv
operator|==
name|NULL
operator|||
name|elmpriv
operator|->
name|descr
operator|==
name|NULL
condition|)
block|{
name|elmd
operator|->
name|elm_desc_len
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|elmd
operator|->
name|elm_desc_len
operator|>
name|elmpriv
operator|->
name|descr_len
condition|)
name|elmd
operator|->
name|elm_desc_len
operator|=
name|elmpriv
operator|->
name|descr_len
expr_stmt|;
name|copyout
argument_list|(
name|elmpriv
operator|->
name|descr
argument_list|,
name|elmd
operator|->
name|elm_desc_str
argument_list|,
name|elmd
operator|->
name|elm_desc_len
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * \brief Respond to ENCIOC_GETELMDEVNAME, providing a device name for the  *	  given object id if one is available.  *  * \param enc	SES softc to examine.  * \param objdn	ioctl structure to read/write device name info.  *  * \return	0 on success, errno otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|ses_get_elm_devnames
parameter_list|(
name|enc_softc_t
modifier|*
name|enc
parameter_list|,
name|encioc_elm_devnames_t
modifier|*
name|elmdn
parameter_list|)
block|{
name|struct
name|sbuf
name|sb
decl_stmt|;
name|int
name|len
decl_stmt|;
name|len
operator|=
name|elmdn
operator|->
name|elm_names_size
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|cam_periph_unlock
argument_list|(
name|enc
operator|->
name|periph
argument_list|)
expr_stmt|;
name|sbuf_new
argument_list|(
operator|&
name|sb
argument_list|,
name|NULL
argument_list|,
name|len
argument_list|,
name|SBUF_FIXEDLEN
argument_list|)
expr_stmt|;
name|ses_paths_iter
argument_list|(
name|enc
argument_list|,
operator|&
name|enc
operator|->
name|enc_cache
operator|.
name|elm_map
index|[
name|elmdn
operator|->
name|elm_idx
index|]
argument_list|,
name|ses_elmdevname_callback
argument_list|,
operator|&
name|sb
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|elmdn
operator|->
name|elm_names_len
operator|=
name|sbuf_len
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|copyout
argument_list|(
name|sbuf_data
argument_list|(
operator|&
name|sb
argument_list|)
argument_list|,
name|elmdn
operator|->
name|elm_devnames
argument_list|,
name|elmdn
operator|->
name|elm_names_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|enc
operator|->
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|elmdn
operator|->
name|elm_names_len
operator|>
literal|0
condition|?
literal|0
else|:
name|ENODEV
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * \brief Send a string to the primary subenclosure using the String Out  * 	  SES diagnostic page.  *  * \param enc	SES enclosure to run the command on.  * \param sstr	SES string structure to operate on  * \param ioc	Ioctl being performed  *  * \return	0 on success, errno otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|ses_handle_string
parameter_list|(
name|enc_softc_t
modifier|*
name|enc
parameter_list|,
name|encioc_string_t
modifier|*
name|sstr
parameter_list|,
name|int
name|ioc
parameter_list|)
block|{
name|ses_softc_t
modifier|*
name|ses
decl_stmt|;
name|enc_cache_t
modifier|*
name|enc_cache
decl_stmt|;
name|ses_cache_t
modifier|*
name|ses_cache
decl_stmt|;
specifier|const
name|struct
name|ses_enc_desc
modifier|*
name|enc_desc
decl_stmt|;
name|int
name|amt
decl_stmt|,
name|payload
decl_stmt|,
name|ret
decl_stmt|;
name|char
name|cdb
index|[
literal|6
index|]
decl_stmt|;
name|char
name|str
index|[
literal|32
index|]
decl_stmt|;
name|char
name|vendor
index|[
literal|9
index|]
decl_stmt|;
name|char
name|product
index|[
literal|17
index|]
decl_stmt|;
name|char
name|rev
index|[
literal|5
index|]
decl_stmt|;
name|uint8_t
modifier|*
name|buf
decl_stmt|;
name|size_t
name|size
decl_stmt|,
name|rsize
decl_stmt|;
name|ses
operator|=
name|enc
operator|->
name|enc_private
expr_stmt|;
name|enc_cache
operator|=
operator|&
name|enc
operator|->
name|enc_daemon_cache
expr_stmt|;
name|ses_cache
operator|=
name|enc_cache
operator|->
name|private
expr_stmt|;
comment|/* Implement SES2r20 6.1.6 */
if|if
condition|(
name|sstr
operator|->
name|bufsiz
operator|>
literal|0xffff
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* buffer size too large */
if|if
condition|(
name|ioc
operator|==
name|ENCIOC_SETSTRING
condition|)
block|{
name|payload
operator|=
name|sstr
operator|->
name|bufsiz
operator|+
literal|4
expr_stmt|;
comment|/* header for SEND DIAGNOSTIC */
name|amt
operator|=
literal|0
operator|-
name|payload
expr_stmt|;
name|buf
operator|=
name|ENC_MALLOC
argument_list|(
name|payload
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|ses_page_cdb
argument_list|(
name|cdb
argument_list|,
name|payload
argument_list|,
literal|0
argument_list|,
name|CAM_DIR_OUT
argument_list|)
expr_stmt|;
comment|/* Construct the page request */
name|buf
index|[
literal|0
index|]
operator|=
name|SesStringOut
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|sstr
operator|->
name|bufsiz
operator|>>
literal|8
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|sstr
operator|->
name|bufsiz
operator|&
literal|0xff
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|buf
index|[
literal|4
index|]
argument_list|,
name|sstr
operator|->
name|buf
argument_list|,
name|sstr
operator|->
name|bufsiz
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ioc
operator|==
name|ENCIOC_GETSTRING
condition|)
block|{
name|payload
operator|=
name|sstr
operator|->
name|bufsiz
expr_stmt|;
name|amt
operator|=
name|payload
expr_stmt|;
name|ses_page_cdb
argument_list|(
name|cdb
argument_list|,
name|payload
argument_list|,
name|SesStringIn
argument_list|,
name|CAM_DIR_IN
argument_list|)
expr_stmt|;
name|buf
operator|=
name|sstr
operator|->
name|buf
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ioc
operator|==
name|ENCIOC_GETENCNAME
condition|)
block|{
if|if
condition|(
name|ses_cache
operator|->
name|ses_nsubencs
operator|<
literal|1
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|enc_desc
operator|=
name|ses_cache
operator|->
name|subencs
index|[
literal|0
index|]
expr_stmt|;
name|cam_strvis
argument_list|(
name|vendor
argument_list|,
name|enc_desc
operator|->
name|vendor_id
argument_list|,
sizeof|sizeof
argument_list|(
name|enc_desc
operator|->
name|vendor_id
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|vendor
argument_list|)
argument_list|)
expr_stmt|;
name|cam_strvis
argument_list|(
name|product
argument_list|,
name|enc_desc
operator|->
name|product_id
argument_list|,
sizeof|sizeof
argument_list|(
name|enc_desc
operator|->
name|product_id
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|product
argument_list|)
argument_list|)
expr_stmt|;
name|cam_strvis
argument_list|(
name|rev
argument_list|,
name|enc_desc
operator|->
name|product_rev
argument_list|,
sizeof|sizeof
argument_list|(
name|enc_desc
operator|->
name|product_rev
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|rev
argument_list|)
argument_list|)
expr_stmt|;
name|rsize
operator|=
name|snprintf
argument_list|(
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|,
literal|"%s %s %s"
argument_list|,
name|vendor
argument_list|,
name|product
argument_list|,
name|rev
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|rsize
operator|>
sizeof|sizeof
argument_list|(
name|str
argument_list|)
condition|)
name|rsize
operator|=
sizeof|sizeof
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|copyout
argument_list|(
operator|&
name|rsize
argument_list|,
operator|&
name|sstr
operator|->
name|bufsiz
argument_list|,
sizeof|sizeof
argument_list|(
name|rsize
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|rsize
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|sstr
operator|->
name|bufsiz
condition|)
name|size
operator|=
name|sstr
operator|->
name|bufsiz
expr_stmt|;
name|copyout
argument_list|(
name|str
argument_list|,
name|sstr
operator|->
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|size
operator|==
name|rsize
condition|?
literal|0
else|:
name|ENOMEM
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|ioc
operator|==
name|ENCIOC_GETENCID
condition|)
block|{
if|if
condition|(
name|ses_cache
operator|->
name|ses_nsubencs
operator|<
literal|1
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|enc_desc
operator|=
name|ses_cache
operator|->
name|subencs
index|[
literal|0
index|]
expr_stmt|;
name|rsize
operator|=
name|snprintf
argument_list|(
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|,
literal|"%16jx"
argument_list|,
name|scsi_8btou64
argument_list|(
name|enc_desc
operator|->
name|logical_id
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|rsize
operator|>
sizeof|sizeof
argument_list|(
name|str
argument_list|)
condition|)
name|rsize
operator|=
sizeof|sizeof
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|copyout
argument_list|(
operator|&
name|rsize
argument_list|,
operator|&
name|sstr
operator|->
name|bufsiz
argument_list|,
sizeof|sizeof
argument_list|(
name|rsize
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|rsize
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|sstr
operator|->
name|bufsiz
condition|)
name|size
operator|=
name|sstr
operator|->
name|bufsiz
expr_stmt|;
name|copyout
argument_list|(
name|str
argument_list|,
name|sstr
operator|->
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|size
operator|==
name|rsize
condition|?
literal|0
else|:
name|ENOMEM
operator|)
return|;
block|}
else|else
return|return
name|EINVAL
return|;
name|ret
operator|=
name|enc_runcmd
argument_list|(
name|enc
argument_list|,
name|cdb
argument_list|,
literal|6
argument_list|,
name|buf
argument_list|,
operator|&
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioc
operator|==
name|ENCIOC_SETSTRING
condition|)
name|ENC_FREE
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * \invariant Called with cam_periph mutex held.  */
end_comment

begin_function
specifier|static
name|void
name|ses_poll_status
parameter_list|(
name|enc_softc_t
modifier|*
name|enc
parameter_list|)
block|{
name|ses_softc_t
modifier|*
name|ses
decl_stmt|;
name|ses
operator|=
name|enc
operator|->
name|enc_private
expr_stmt|;
name|enc_update_request
argument_list|(
name|enc
argument_list|,
name|SES_UPDATE_GETSTATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|ses
operator|->
name|ses_flags
operator|&
name|SES_FLAG_DESC
condition|)
name|enc_update_request
argument_list|(
name|enc
argument_list|,
name|SES_UPDATE_GETELMDESCS
argument_list|)
expr_stmt|;
if|if
condition|(
name|ses
operator|->
name|ses_flags
operator|&
name|SES_FLAG_ADDLSTATUS
condition|)
name|enc_update_request
argument_list|(
name|enc
argument_list|,
name|SES_UPDATE_GETELMADDLSTATUS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * \brief Notification received when CAM detects a new device in the  *        SCSI domain in which this SEP resides.  *  * \param enc	SES enclosure instance.  */
end_comment

begin_function
specifier|static
name|void
name|ses_device_found
parameter_list|(
name|enc_softc_t
modifier|*
name|enc
parameter_list|)
block|{
name|ses_poll_status
argument_list|(
name|enc
argument_list|)
expr_stmt|;
name|enc_update_request
argument_list|(
name|enc
argument_list|,
name|SES_PUBLISH_PHYSPATHS
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|enc_vec
name|ses_enc_vec
init|=
block|{
operator|.
name|softc_invalidate
operator|=
name|ses_softc_invalidate
block|,
operator|.
name|softc_cleanup
operator|=
name|ses_softc_cleanup
block|,
operator|.
name|init_enc
operator|=
name|ses_init_enc
block|,
operator|.
name|get_enc_status
operator|=
name|ses_get_enc_status
block|,
operator|.
name|set_enc_status
operator|=
name|ses_set_enc_status
block|,
operator|.
name|get_elm_status
operator|=
name|ses_get_elm_status
block|,
operator|.
name|set_elm_status
operator|=
name|ses_set_elm_status
block|,
operator|.
name|get_elm_desc
operator|=
name|ses_get_elm_desc
block|,
operator|.
name|get_elm_devnames
operator|=
name|ses_get_elm_devnames
block|,
operator|.
name|handle_string
operator|=
name|ses_handle_string
block|,
operator|.
name|device_found
operator|=
name|ses_device_found
block|,
operator|.
name|poll_status
operator|=
name|ses_poll_status
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * \brief Initialize a new SES instance.  *  * \param enc		SES softc structure to set up the instance in.  * \param doinit	Do the initialization (see main driver).  *  * \return		0 on success, errno otherwise.  */
end_comment

begin_function
name|int
name|ses_softc_init
parameter_list|(
name|enc_softc_t
modifier|*
name|enc
parameter_list|)
block|{
name|ses_softc_t
modifier|*
name|ses_softc
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|enc
operator|->
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"entering enc_softc_init(%p)\n"
operator|,
name|enc
operator|)
argument_list|)
expr_stmt|;
name|enc
operator|->
name|enc_vec
operator|=
name|ses_enc_vec
expr_stmt|;
name|enc
operator|->
name|enc_fsm_states
operator|=
name|enc_fsm_states
expr_stmt|;
if|if
condition|(
name|enc
operator|->
name|enc_private
operator|==
name|NULL
condition|)
name|enc
operator|->
name|enc_private
operator|=
name|ENC_MALLOCZ
argument_list|(
sizeof|sizeof
argument_list|(
name|ses_softc_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|enc
operator|->
name|enc_cache
operator|.
name|private
operator|==
name|NULL
condition|)
name|enc
operator|->
name|enc_cache
operator|.
name|private
operator|=
name|ENC_MALLOCZ
argument_list|(
sizeof|sizeof
argument_list|(
name|ses_cache_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|enc
operator|->
name|enc_daemon_cache
operator|.
name|private
operator|==
name|NULL
condition|)
name|enc
operator|->
name|enc_daemon_cache
operator|.
name|private
operator|=
name|ENC_MALLOCZ
argument_list|(
sizeof|sizeof
argument_list|(
name|ses_cache_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|enc
operator|->
name|enc_private
operator|==
name|NULL
operator|||
name|enc
operator|->
name|enc_cache
operator|.
name|private
operator|==
name|NULL
operator|||
name|enc
operator|->
name|enc_daemon_cache
operator|.
name|private
operator|==
name|NULL
condition|)
block|{
name|ENC_FREE_AND_NULL
argument_list|(
name|enc
operator|->
name|enc_private
argument_list|)
expr_stmt|;
name|ENC_FREE_AND_NULL
argument_list|(
name|enc
operator|->
name|enc_cache
operator|.
name|private
argument_list|)
expr_stmt|;
name|ENC_FREE_AND_NULL
argument_list|(
name|enc
operator|->
name|enc_daemon_cache
operator|.
name|private
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|ses_softc
operator|=
name|enc
operator|->
name|enc_private
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|ses_softc
operator|->
name|ses_requests
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|ses_softc
operator|->
name|ses_pending_requests
argument_list|)
expr_stmt|;
name|enc_update_request
argument_list|(
name|enc
argument_list|,
name|SES_UPDATE_PAGES
argument_list|)
expr_stmt|;
comment|// XXX: Move this to the FSM so it doesn't hang init
if|if
condition|(
literal|0
condition|)
operator|(
name|void
operator|)
name|ses_set_timed_completion
argument_list|(
name|enc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

