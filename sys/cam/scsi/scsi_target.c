begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Generic SCSI Target Kernel Mode Driver  *  * Copyright (c) 2002 Nate Lawson.  * Copyright (c) 1998, 1999, 2001, 2002 Justin T. Gibbs.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/devicestat.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_targetio.h>
end_include

begin_comment
comment|/* Transaction information attached to each CCB sent by the user */
end_comment

begin_struct
struct|struct
name|targ_cmd_descr
block|{
name|struct
name|cam_periph_map_info
name|mapinfo
decl_stmt|;
name|TAILQ_ENTRY
argument_list|(
argument|targ_cmd_descr
argument_list|)
name|tqe
expr_stmt|;
name|union
name|ccb
modifier|*
name|user_ccb
decl_stmt|;
name|int
name|priority
decl_stmt|;
name|int
name|func_code
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Offset into the private CCB area for storing our descriptor */
end_comment

begin_define
define|#
directive|define
name|targ_descr
value|periph_priv.entries[1].ptr
end_define

begin_expr_stmt
name|TAILQ_HEAD
argument_list|(
name|descr_queue
argument_list|,
name|targ_cmd_descr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
enum|enum
block|{
name|TARG_STATE_RESV
init|=
literal|0x00
block|,
comment|/* Invalid state */
name|TARG_STATE_OPENED
init|=
literal|0x01
block|,
comment|/* Device opened, softc initialized */
name|TARG_STATE_LUN_ENABLED
init|=
literal|0x02
comment|/* Device enabled for a path */
block|}
name|targ_state
typedef|;
end_typedef

begin_comment
comment|/* Per-instance device software context */
end_comment

begin_struct
struct|struct
name|targ_softc
block|{
comment|/* CCBs (CTIOs, ATIOs, INOTs) pending on the controller */
name|struct
name|ccb_queue
name|pending_ccb_queue
decl_stmt|;
comment|/* Command descriptors awaiting CTIO resources from the XPT */
name|struct
name|descr_queue
name|work_queue
decl_stmt|;
comment|/* Command descriptors that have been aborted back to the user. */
name|struct
name|descr_queue
name|abort_queue
decl_stmt|;
comment|/* 	 * Queue of CCBs that have been copied out to userland, but our 	 * userland daemon has not yet seen. 	 */
name|struct
name|ccb_queue
name|user_ccb_queue
decl_stmt|;
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|targ_state
name|state
decl_stmt|;
name|struct
name|selinfo
name|read_select
decl_stmt|;
name|struct
name|devstat
name|device_stats
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|d_open_t
name|targopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|targclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|targread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|targwrite
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|targioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_poll_t
name|targpoll
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_kqfilter_t
name|targkqfilter
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|targreadfiltdetach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|targreadfilt
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|filterops
name|targread_filtops
init|=
block|{
literal|1
block|,
name|NULL
block|,
name|targreadfiltdetach
block|,
name|targreadfilt
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|targ_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_flags
operator|=
name|D_NEEDGIANT
block|,
operator|.
name|d_open
operator|=
name|targopen
block|,
operator|.
name|d_close
operator|=
name|targclose
block|,
operator|.
name|d_read
operator|=
name|targread
block|,
operator|.
name|d_write
operator|=
name|targwrite
block|,
operator|.
name|d_ioctl
operator|=
name|targioctl
block|,
operator|.
name|d_poll
operator|=
name|targpoll
block|,
operator|.
name|d_name
operator|=
literal|"targ"
block|,
operator|.
name|d_kqfilter
operator|=
name|targkqfilter
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|cam_status
name|targendislun
parameter_list|(
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|int
name|enable
parameter_list|,
name|int
name|grp6_len
parameter_list|,
name|int
name|grp7_len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cam_status
name|targenable
parameter_list|(
name|struct
name|targ_softc
modifier|*
name|softc
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|int
name|grp6_len
parameter_list|,
name|int
name|grp7_len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cam_status
name|targdisable
parameter_list|(
name|struct
name|targ_softc
modifier|*
name|softc
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|periph_ctor_t
name|targctor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_dtor_t
name|targdtor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_start_t
name|targstart
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|targusermerge
parameter_list|(
name|struct
name|targ_softc
modifier|*
name|softc
parameter_list|,
name|struct
name|targ_cmd_descr
modifier|*
name|descr
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|targsendccb
parameter_list|(
name|struct
name|targ_softc
modifier|*
name|softc
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|struct
name|targ_cmd_descr
modifier|*
name|descr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|targdone
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|done_ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|targreturnccb
parameter_list|(
name|struct
name|targ_softc
modifier|*
name|softc
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|union
name|ccb
modifier|*
name|targgetccb
parameter_list|(
name|struct
name|targ_softc
modifier|*
name|softc
parameter_list|,
name|xpt_opcode
name|type
parameter_list|,
name|int
name|priority
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|targfreeccb
parameter_list|(
name|struct
name|targ_softc
modifier|*
name|softc
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|targ_cmd_descr
modifier|*
name|targgetdescr
parameter_list|(
name|struct
name|targ_softc
modifier|*
name|softc
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|periph_init_t
name|targinit
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|targclone
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|struct
name|cdev
modifier|*
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|targasync
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|u_int32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|abort_all_pending
parameter_list|(
name|struct
name|targ_softc
modifier|*
name|softc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|notify_user
parameter_list|(
name|struct
name|targ_softc
modifier|*
name|softc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|targcamstatus
parameter_list|(
name|cam_status
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|size_t
name|targccblen
parameter_list|(
name|xpt_opcode
name|func_code
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|periph_driver
name|targdriver
init|=
block|{
name|targinit
block|,
literal|"targ"
block|,
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|targdriver
operator|.
name|units
argument_list|)
block|,
comment|/* generation */
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|PERIPHDRIVER_DECLARE
argument_list|(
name|targ
argument_list|,
name|targdriver
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_TARG
argument_list|,
literal|"TARG"
argument_list|,
literal|"TARG data"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Create softc and initialize it. Only one proc can open each targ device. */
end_comment

begin_function
specifier|static
name|int
name|targopen
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|targ_softc
modifier|*
name|softc
decl_stmt|;
if|if
condition|(
name|dev
operator|->
name|si_drv1
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
comment|/* Mark device busy before any potentially blocking operations */
name|dev
operator|->
name|si_drv1
operator|=
operator|(
name|void
operator|*
operator|)
operator|~
literal|0
expr_stmt|;
comment|/* Create the targ device, allocate its softc, initialize it */
if|if
condition|(
operator|(
name|dev
operator|->
name|si_flags
operator|&
name|SI_NAMED
operator|)
operator|==
literal|0
condition|)
block|{
name|make_dev
argument_list|(
operator|&
name|targ_cdevsw
argument_list|,
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"targ%d"
argument_list|,
name|dev2unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|MALLOC
argument_list|(
name|softc
argument_list|,
expr|struct
name|targ_softc
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|softc
argument_list|)
argument_list|,
name|M_TARG
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|dev
operator|->
name|si_drv1
operator|=
name|softc
expr_stmt|;
name|softc
operator|->
name|state
operator|=
name|TARG_STATE_OPENED
expr_stmt|;
name|softc
operator|->
name|periph
operator|=
name|NULL
expr_stmt|;
name|softc
operator|->
name|path
operator|=
name|NULL
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|softc
operator|->
name|pending_ccb_queue
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|softc
operator|->
name|work_queue
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|softc
operator|->
name|abort_queue
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|softc
operator|->
name|user_ccb_queue
argument_list|)
expr_stmt|;
name|knlist_init
argument_list|(
operator|&
name|softc
operator|->
name|read_select
operator|.
name|si_note
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Disable LUN if enabled and teardown softc */
end_comment

begin_function
specifier|static
name|int
name|targclose
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|targ_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|targ_softc
operator|*
operator|)
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|error
operator|=
name|targdisable
argument_list|(
name|softc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|CAM_REQ_CMP
condition|)
block|{
name|dev
operator|->
name|si_drv1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|periph
operator|!=
name|NULL
condition|)
block|{
name|cam_periph_invalidate
argument_list|(
name|softc
operator|->
name|periph
argument_list|)
expr_stmt|;
name|softc
operator|->
name|periph
operator|=
name|NULL
expr_stmt|;
block|}
name|destroy_dev
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|softc
argument_list|,
name|M_TARG
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Enable/disable LUNs, set debugging level */
end_comment

begin_function
specifier|static
name|int
name|targioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|targ_softc
modifier|*
name|softc
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|targ_softc
operator|*
operator|)
name|dev
operator|->
name|si_drv1
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|TARGIOCENABLE
case|:
block|{
name|struct
name|ioc_enable_lun
modifier|*
name|new_lun
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|new_lun
operator|=
operator|(
expr|struct
name|ioc_enable_lun
operator|*
operator|)
name|addr
expr_stmt|;
name|status
operator|=
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|new_lun
operator|->
name|path_id
argument_list|,
name|new_lun
operator|->
name|target_id
argument_list|,
name|new_lun
operator|->
name|lun_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"Couldn't create path, status %#x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
break|break;
block|}
name|status
operator|=
name|targenable
argument_list|(
name|softc
argument_list|,
name|path
argument_list|,
name|new_lun
operator|->
name|grp6_len
argument_list|,
name|new_lun
operator|->
name|grp7_len
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TARGIOCDISABLE
case|:
name|status
operator|=
name|targdisable
argument_list|(
name|softc
argument_list|)
expr_stmt|;
break|break;
case|case
name|TARGIOCDEBUG
case|:
block|{
ifdef|#
directive|ifdef
name|CAMDEBUG
name|struct
name|ccb_debug
name|cdbg
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|cdbg
argument_list|,
sizeof|sizeof
name|cdbg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|addr
operator|)
operator|!=
literal|0
condition|)
name|cdbg
operator|.
name|flags
operator|=
name|CAM_DEBUG_PERIPH
expr_stmt|;
else|else
name|cdbg
operator|.
name|flags
operator|=
name|CAM_DEBUG_NONE
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|cdbg
operator|.
name|ccb_h
argument_list|,
name|softc
operator|->
name|path
argument_list|,
comment|/*priority*/
literal|0
argument_list|)
expr_stmt|;
name|cdbg
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_DEBUG
expr_stmt|;
name|cdbg
operator|.
name|ccb_h
operator|.
name|cbfcnp
operator|=
name|targdone
expr_stmt|;
comment|/* If no periph available, disallow debugging changes */
if|if
condition|(
operator|(
name|softc
operator|->
name|state
operator|&
name|TARG_STATE_LUN_ENABLED
operator|)
operator|==
literal|0
condition|)
block|{
name|status
operator|=
name|CAM_DEV_NOT_THERE
expr_stmt|;
break|break;
block|}
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|cdbg
argument_list|)
expr_stmt|;
name|status
operator|=
name|cdbg
operator|.
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
expr_stmt|;
else|#
directive|else
name|status
operator|=
name|CAM_FUNC_NOTAVAIL
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
default|default:
name|status
operator|=
name|CAM_PROVIDE_FAIL
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|targcamstatus
argument_list|(
name|status
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Writes are always ready, reads wait for user_ccb_queue or abort_queue */
end_comment

begin_function
specifier|static
name|int
name|targpoll
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|poll_events
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|targ_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|revents
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|targ_softc
operator|*
operator|)
name|dev
operator|->
name|si_drv1
expr_stmt|;
comment|/* Poll for write() is always ok. */
name|revents
operator|=
name|poll_events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|poll_events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Poll for read() depends on user and abort queues. */
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|softc
operator|->
name|user_ccb_queue
argument_list|)
operator|||
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|softc
operator|->
name|abort_queue
argument_list|)
condition|)
block|{
name|revents
operator||=
name|poll_events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
block|}
comment|/* Only sleep if the user didn't poll for write. */
if|if
condition|(
name|revents
operator|==
literal|0
condition|)
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|softc
operator|->
name|read_select
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|revents
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|targkqfilter
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|targ_softc
modifier|*
name|softc
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|targ_softc
operator|*
operator|)
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|kn
operator|->
name|kn_hook
operator|=
operator|(
name|caddr_t
operator|)
name|softc
expr_stmt|;
name|kn
operator|->
name|kn_fop
operator|=
operator|&
name|targread_filtops
expr_stmt|;
name|knlist_add
argument_list|(
operator|&
name|softc
operator|->
name|read_select
operator|.
name|si_note
argument_list|,
name|kn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|targreadfiltdetach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|targ_softc
modifier|*
name|softc
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|targ_softc
operator|*
operator|)
name|kn
operator|->
name|kn_hook
expr_stmt|;
name|knlist_remove
argument_list|(
operator|&
name|softc
operator|->
name|read_select
operator|.
name|si_note
argument_list|,
name|kn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Notify the user's kqueue when the user queue or abort queue gets a CCB */
end_comment

begin_function
specifier|static
name|int
name|targreadfilt
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
block|{
name|struct
name|targ_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|targ_softc
operator|*
operator|)
name|kn
operator|->
name|kn_hook
expr_stmt|;
name|retval
operator|=
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|softc
operator|->
name|user_ccb_queue
argument_list|)
operator|||
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|softc
operator|->
name|abort_queue
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Send the HBA the enable/disable message */
end_comment

begin_function
specifier|static
name|cam_status
name|targendislun
parameter_list|(
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|int
name|enable
parameter_list|,
name|int
name|grp6_len
parameter_list|,
name|int
name|grp7_len
parameter_list|)
block|{
name|struct
name|ccb_en_lun
name|en_ccb
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
comment|/* Tell the lun to begin answering selects */
name|xpt_setup_ccb
argument_list|(
operator|&
name|en_ccb
operator|.
name|ccb_h
argument_list|,
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|en_ccb
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_EN_LUN
expr_stmt|;
comment|/* Don't need support for any vendor specific commands */
name|en_ccb
operator|.
name|grp6_len
operator|=
name|grp6_len
expr_stmt|;
name|en_ccb
operator|.
name|grp7_len
operator|=
name|grp7_len
expr_stmt|;
name|en_ccb
operator|.
name|enable
operator|=
name|enable
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|en_ccb
argument_list|)
expr_stmt|;
name|status
operator|=
name|en_ccb
operator|.
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_print
argument_list|(
name|path
argument_list|,
literal|"%sable lun CCB rejected, status %#x\n"
argument_list|,
name|enable
condition|?
literal|"en"
else|:
literal|"dis"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Enable target mode on a LUN, given its path */
end_comment

begin_function
specifier|static
name|cam_status
name|targenable
parameter_list|(
name|struct
name|targ_softc
modifier|*
name|softc
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|int
name|grp6_len
parameter_list|,
name|int
name|grp7_len
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|ccb_pathinq
name|cpi
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
if|if
condition|(
operator|(
name|softc
operator|->
name|state
operator|&
name|TARG_STATE_LUN_ENABLED
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|CAM_LUN_ALRDY_ENA
operator|)
return|;
comment|/* Make sure SIM supports target mode */
name|xpt_setup_ccb
argument_list|(
operator|&
name|cpi
operator|.
name|ccb_h
argument_list|,
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|cpi
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_PATH_INQ
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|cpi
argument_list|)
expr_stmt|;
name|status
operator|=
name|cpi
operator|.
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"pathinq failed, status %#x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
goto|goto
name|enable_fail
goto|;
block|}
if|if
condition|(
operator|(
name|cpi
operator|.
name|target_sprt
operator|&
name|PIT_PROCESSOR
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"controller does not support target mode\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|CAM_FUNC_NOTAVAIL
expr_stmt|;
goto|goto
name|enable_fail
goto|;
block|}
comment|/* Destroy any periph on our path if it is disabled */
name|periph
operator|=
name|cam_periph_find
argument_list|(
name|path
argument_list|,
literal|"targ"
argument_list|)
expr_stmt|;
if|if
condition|(
name|periph
operator|!=
name|NULL
condition|)
block|{
name|struct
name|targ_softc
modifier|*
name|del_softc
decl_stmt|;
name|del_softc
operator|=
operator|(
expr|struct
name|targ_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
if|if
condition|(
operator|(
name|del_softc
operator|->
name|state
operator|&
name|TARG_STATE_LUN_ENABLED
operator|)
operator|==
literal|0
condition|)
block|{
name|cam_periph_invalidate
argument_list|(
name|del_softc
operator|->
name|periph
argument_list|)
expr_stmt|;
name|del_softc
operator|->
name|periph
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Requested path still in use by targ%d\n"
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|)
expr_stmt|;
name|status
operator|=
name|CAM_LUN_ALRDY_ENA
expr_stmt|;
goto|goto
name|enable_fail
goto|;
block|}
block|}
comment|/* Create a periph instance attached to this path */
name|status
operator|=
name|cam_periph_alloc
argument_list|(
name|targctor
argument_list|,
name|NULL
argument_list|,
name|targdtor
argument_list|,
name|targstart
argument_list|,
literal|"targ"
argument_list|,
name|CAM_PERIPH_BIO
argument_list|,
name|path
argument_list|,
name|targasync
argument_list|,
literal|0
argument_list|,
name|softc
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"cam_periph_alloc failed, status %#x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
goto|goto
name|enable_fail
goto|;
block|}
comment|/* Ensure that the periph now exists. */
if|if
condition|(
name|cam_periph_find
argument_list|(
name|path
argument_list|,
literal|"targ"
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"targenable: succeeded but no periph?"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
comment|/* Send the enable lun message */
name|status
operator|=
name|targendislun
argument_list|(
name|path
argument_list|,
comment|/*enable*/
literal|1
argument_list|,
name|grp6_len
argument_list|,
name|grp7_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"enable lun failed, status %#x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
goto|goto
name|enable_fail
goto|;
block|}
name|softc
operator|->
name|state
operator||=
name|TARG_STATE_LUN_ENABLED
expr_stmt|;
name|enable_fail
label|:
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Disable this softc's target instance if enabled */
end_comment

begin_function
specifier|static
name|cam_status
name|targdisable
parameter_list|(
name|struct
name|targ_softc
modifier|*
name|softc
parameter_list|)
block|{
name|cam_status
name|status
decl_stmt|;
if|if
condition|(
operator|(
name|softc
operator|->
name|state
operator|&
name|TARG_STATE_LUN_ENABLED
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|CAM_REQ_CMP
operator|)
return|;
name|CAM_DEBUG
argument_list|(
name|softc
operator|->
name|path
argument_list|,
name|CAM_DEBUG_PERIPH
argument_list|,
operator|(
literal|"targdisable\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Abort any ccbs pending on the controller */
name|abort_all_pending
argument_list|(
name|softc
argument_list|)
expr_stmt|;
comment|/* Disable this lun */
name|status
operator|=
name|targendislun
argument_list|(
name|softc
operator|->
name|path
argument_list|,
comment|/*enable*/
literal|0
argument_list|,
comment|/*grp6_len*/
literal|0
argument_list|,
comment|/*grp7_len*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|CAM_REQ_CMP
condition|)
name|softc
operator|->
name|state
operator|&=
operator|~
name|TARG_STATE_LUN_ENABLED
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Disable lun failed, status %#x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Initialize a periph (called from cam_periph_alloc) */
end_comment

begin_function
specifier|static
name|cam_status
name|targctor
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|targ_softc
modifier|*
name|softc
decl_stmt|;
comment|/* Store pointer to softc for periph-driven routines */
name|softc
operator|=
operator|(
expr|struct
name|targ_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|periph
operator|->
name|softc
operator|=
name|softc
expr_stmt|;
name|softc
operator|->
name|periph
operator|=
name|periph
expr_stmt|;
name|softc
operator|->
name|path
operator|=
name|periph
operator|->
name|path
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|targdtor
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|struct
name|targ_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
name|struct
name|targ_cmd_descr
modifier|*
name|descr
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|targ_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
comment|/*  	 * targdisable() aborts CCBs back to the user and leaves them 	 * on user_ccb_queue and abort_queue in case the user is still 	 * interested in them.  We free them now. 	 */
while|while
condition|(
operator|(
name|ccb_h
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|softc
operator|->
name|user_ccb_queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|softc
operator|->
name|user_ccb_queue
argument_list|,
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|targfreeccb
argument_list|(
name|softc
argument_list|,
operator|(
expr|union
name|ccb
operator|*
operator|)
name|ccb_h
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|descr
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|softc
operator|->
name|abort_queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|softc
operator|->
name|abort_queue
argument_list|,
name|descr
argument_list|,
name|tqe
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|descr
argument_list|,
name|M_TARG
argument_list|)
expr_stmt|;
block|}
name|softc
operator|->
name|periph
operator|=
name|NULL
expr_stmt|;
name|softc
operator|->
name|path
operator|=
name|NULL
expr_stmt|;
name|periph
operator|->
name|softc
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Receive CCBs from user mode proc and send them to the HBA */
end_comment

begin_function
specifier|static
name|int
name|targwrite
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|user_ccb
decl_stmt|;
name|struct
name|targ_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|targ_cmd_descr
modifier|*
name|descr
decl_stmt|;
name|int
name|write_len
decl_stmt|,
name|error
decl_stmt|;
name|int
name|func_code
decl_stmt|,
name|priority
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|targ_softc
operator|*
operator|)
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|write_len
operator|=
name|error
operator|=
literal|0
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|softc
operator|->
name|path
argument_list|,
name|CAM_DEBUG_PERIPH
argument_list|,
operator|(
literal|"write - uio_resid %d\n"
operator|,
name|uio
operator|->
name|uio_resid
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|uio
operator|->
name|uio_resid
operator|>=
sizeof|sizeof
argument_list|(
name|user_ccb
argument_list|)
operator|&&
name|error
operator|==
literal|0
condition|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|user_ccb
argument_list|,
sizeof|sizeof
argument_list|(
name|user_ccb
argument_list|)
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|CAM_DEBUG
argument_list|(
name|softc
operator|->
name|path
argument_list|,
name|CAM_DEBUG_PERIPH
argument_list|,
operator|(
literal|"write - uiomove failed (%d)\n"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|priority
operator|=
name|fuword32
argument_list|(
operator|&
name|user_ccb
operator|->
name|ccb_h
operator|.
name|pinfo
operator|.
name|priority
argument_list|)
expr_stmt|;
if|if
condition|(
name|priority
operator|==
operator|-
literal|1
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|func_code
operator|=
name|fuword32
argument_list|(
operator|&
name|user_ccb
operator|->
name|ccb_h
operator|.
name|func_code
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|func_code
condition|)
block|{
case|case
name|XPT_ACCEPT_TARGET_IO
case|:
case|case
name|XPT_IMMED_NOTIFY
case|:
name|ccb
operator|=
name|targgetccb
argument_list|(
name|softc
argument_list|,
name|func_code
argument_list|,
name|priority
argument_list|)
expr_stmt|;
name|descr
operator|=
operator|(
expr|struct
name|targ_cmd_descr
operator|*
operator|)
name|ccb
operator|->
name|ccb_h
operator|.
name|targ_descr
expr_stmt|;
name|descr
operator|->
name|user_ccb
operator|=
name|user_ccb
expr_stmt|;
name|descr
operator|->
name|func_code
operator|=
name|func_code
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|softc
operator|->
name|path
argument_list|,
name|CAM_DEBUG_PERIPH
argument_list|,
operator|(
literal|"Sent ATIO/INOT (%p)\n"
operator|,
name|user_ccb
operator|)
argument_list|)
expr_stmt|;
name|xpt_action
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|softc
operator|->
name|pending_ccb_queue
argument_list|,
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|(
name|func_code
operator|&
name|XPT_FC_QUEUED
operator|)
operator|!=
literal|0
condition|)
block|{
name|CAM_DEBUG
argument_list|(
name|softc
operator|->
name|path
argument_list|,
name|CAM_DEBUG_PERIPH
argument_list|,
operator|(
literal|"Sending queued ccb %#x (%p)\n"
operator|,
name|func_code
operator|,
name|user_ccb
operator|)
argument_list|)
expr_stmt|;
name|descr
operator|=
name|targgetdescr
argument_list|(
name|softc
argument_list|)
expr_stmt|;
name|descr
operator|->
name|user_ccb
operator|=
name|user_ccb
expr_stmt|;
name|descr
operator|->
name|priority
operator|=
name|priority
expr_stmt|;
name|descr
operator|->
name|func_code
operator|=
name|func_code
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|softc
operator|->
name|work_queue
argument_list|,
name|descr
argument_list|,
name|tqe
argument_list|)
expr_stmt|;
name|xpt_schedule
argument_list|(
name|softc
operator|->
name|periph
argument_list|,
name|priority
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CAM_DEBUG
argument_list|(
name|softc
operator|->
name|path
argument_list|,
name|CAM_DEBUG_PERIPH
argument_list|,
operator|(
literal|"Sending inline ccb %#x (%p)\n"
operator|,
name|func_code
operator|,
name|user_ccb
operator|)
argument_list|)
expr_stmt|;
name|ccb
operator|=
name|targgetccb
argument_list|(
name|softc
argument_list|,
name|func_code
argument_list|,
name|priority
argument_list|)
expr_stmt|;
name|descr
operator|=
operator|(
expr|struct
name|targ_cmd_descr
operator|*
operator|)
name|ccb
operator|->
name|ccb_h
operator|.
name|targ_descr
expr_stmt|;
name|descr
operator|->
name|user_ccb
operator|=
name|user_ccb
expr_stmt|;
name|descr
operator|->
name|priority
operator|=
name|priority
expr_stmt|;
name|descr
operator|->
name|func_code
operator|=
name|func_code
expr_stmt|;
if|if
condition|(
name|targusermerge
argument_list|(
name|softc
argument_list|,
name|descr
argument_list|,
name|ccb
argument_list|)
operator|!=
name|EFAULT
condition|)
name|targsendccb
argument_list|(
name|softc
argument_list|,
name|ccb
argument_list|,
name|descr
argument_list|)
expr_stmt|;
name|targreturnccb
argument_list|(
name|softc
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|write_len
operator|+=
sizeof|sizeof
argument_list|(
name|user_ccb
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we've successfully taken in some amount of 	 * data, return success for that data first.  If 	 * an error is persistent, it will be reported 	 * on the next write. 	 */
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|write_len
operator|==
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|write_len
operator|==
literal|0
operator|&&
name|uio
operator|->
name|uio_resid
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Process requests (descrs) via the periph-supplied CCBs */
end_comment

begin_function
specifier|static
name|void
name|targstart
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|start_ccb
parameter_list|)
block|{
name|struct
name|targ_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|targ_cmd_descr
modifier|*
name|descr
decl_stmt|,
modifier|*
name|next_descr
decl_stmt|;
name|int
name|error
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|targ_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|softc
operator|->
name|path
argument_list|,
name|CAM_DEBUG_PERIPH
argument_list|,
operator|(
literal|"targstart %p\n"
operator|,
name|start_ccb
operator|)
argument_list|)
expr_stmt|;
name|descr
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|softc
operator|->
name|work_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|descr
operator|==
name|NULL
condition|)
block|{
name|xpt_release_ccb
argument_list|(
name|start_ccb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|softc
operator|->
name|work_queue
argument_list|,
name|descr
argument_list|,
name|tqe
argument_list|)
expr_stmt|;
name|next_descr
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|softc
operator|->
name|work_queue
argument_list|)
expr_stmt|;
comment|/* Initiate a transaction using the descr and supplied CCB */
name|error
operator|=
name|targusermerge
argument_list|(
name|softc
argument_list|,
name|descr
argument_list|,
name|start_ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|targsendccb
argument_list|(
name|softc
argument_list|,
name|start_ccb
argument_list|,
name|descr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"targsendccb failed, err %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|start_ccb
argument_list|)
expr_stmt|;
name|suword
argument_list|(
operator|&
name|descr
operator|->
name|user_ccb
operator|->
name|ccb_h
operator|.
name|status
argument_list|,
name|CAM_REQ_CMP_ERR
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|softc
operator|->
name|abort_queue
argument_list|,
name|descr
argument_list|,
name|tqe
argument_list|)
expr_stmt|;
name|notify_user
argument_list|(
name|softc
argument_list|)
expr_stmt|;
block|}
comment|/* If we have more work to do, stay scheduled */
if|if
condition|(
name|next_descr
operator|!=
name|NULL
condition|)
name|xpt_schedule
argument_list|(
name|periph
argument_list|,
name|next_descr
operator|->
name|priority
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|targusermerge
parameter_list|(
name|struct
name|targ_softc
modifier|*
name|softc
parameter_list|,
name|struct
name|targ_cmd_descr
modifier|*
name|descr
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|u_ccbh
decl_stmt|,
modifier|*
name|k_ccbh
decl_stmt|;
name|size_t
name|ccb_len
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_ccbh
operator|=
operator|&
name|descr
operator|->
name|user_ccb
operator|->
name|ccb_h
expr_stmt|;
name|k_ccbh
operator|=
operator|&
name|ccb
operator|->
name|ccb_h
expr_stmt|;
comment|/* 	 * There are some fields in the CCB header that need to be 	 * preserved, the rest we get from the user ccb. (See xpt_merge_ccb) 	 */
name|xpt_setup_ccb
argument_list|(
name|k_ccbh
argument_list|,
name|softc
operator|->
name|path
argument_list|,
name|descr
operator|->
name|priority
argument_list|)
expr_stmt|;
name|k_ccbh
operator|->
name|retry_count
operator|=
name|fuword32
argument_list|(
operator|&
name|u_ccbh
operator|->
name|retry_count
argument_list|)
expr_stmt|;
name|k_ccbh
operator|->
name|func_code
operator|=
name|descr
operator|->
name|func_code
expr_stmt|;
name|k_ccbh
operator|->
name|flags
operator|=
name|fuword32
argument_list|(
operator|&
name|u_ccbh
operator|->
name|flags
argument_list|)
expr_stmt|;
name|k_ccbh
operator|->
name|timeout
operator|=
name|fuword32
argument_list|(
operator|&
name|u_ccbh
operator|->
name|timeout
argument_list|)
expr_stmt|;
name|ccb_len
operator|=
name|targccblen
argument_list|(
name|k_ccbh
operator|->
name|func_code
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|u_ccbh
operator|+
literal|1
argument_list|,
name|k_ccbh
operator|+
literal|1
argument_list|,
name|ccb_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|k_ccbh
operator|->
name|status
operator|=
name|CAM_REQ_CMP_ERR
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Translate usermode abort_ccb pointer to its kernel counterpart */
if|if
condition|(
name|k_ccbh
operator|->
name|func_code
operator|==
name|XPT_ABORT
condition|)
block|{
name|struct
name|ccb_abort
modifier|*
name|cab
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
name|cab
operator|=
operator|(
expr|struct
name|ccb_abort
operator|*
operator|)
name|ccb
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ccb_h
argument_list|,
argument|&softc->pending_ccb_queue
argument_list|,
argument|periph_links.tqe
argument_list|)
block|{
name|struct
name|targ_cmd_descr
modifier|*
name|ab_descr
decl_stmt|;
name|ab_descr
operator|=
operator|(
expr|struct
name|targ_cmd_descr
operator|*
operator|)
name|ccb_h
operator|->
name|targ_descr
expr_stmt|;
if|if
condition|(
name|ab_descr
operator|->
name|user_ccb
operator|==
name|cab
operator|->
name|abort_ccb
condition|)
block|{
name|CAM_DEBUG
argument_list|(
name|softc
operator|->
name|path
argument_list|,
name|CAM_DEBUG_PERIPH
argument_list|,
operator|(
literal|"Changing abort for %p to %p\n"
operator|,
name|cab
operator|->
name|abort_ccb
operator|,
name|ccb_h
operator|)
argument_list|)
expr_stmt|;
name|cab
operator|->
name|abort_ccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|ccb_h
expr_stmt|;
break|break;
block|}
block|}
comment|/* CCB not found, set appropriate status */
if|if
condition|(
name|ccb_h
operator|==
name|NULL
condition|)
block|{
name|k_ccbh
operator|->
name|status
operator|=
name|CAM_PATH_INVALID
expr_stmt|;
name|error
operator|=
name|ESRCH
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Build and send a kernel CCB formed from descr->user_ccb */
end_comment

begin_function
specifier|static
name|int
name|targsendccb
parameter_list|(
name|struct
name|targ_softc
modifier|*
name|softc
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|struct
name|targ_cmd_descr
modifier|*
name|descr
parameter_list|)
block|{
name|struct
name|cam_periph_map_info
modifier|*
name|mapinfo
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ccb_h
operator|=
operator|&
name|ccb
operator|->
name|ccb_h
expr_stmt|;
name|mapinfo
operator|=
operator|&
name|descr
operator|->
name|mapinfo
expr_stmt|;
name|mapinfo
operator|->
name|num_bufs_used
operator|=
literal|0
expr_stmt|;
comment|/* 	 * There's no way for the user to have a completion 	 * function, so we put our own completion function in here. 	 * We also stash in a reference to our descriptor so targreturnccb() 	 * can find our mapping info. 	 */
name|ccb_h
operator|->
name|cbfcnp
operator|=
name|targdone
expr_stmt|;
name|ccb_h
operator|->
name|targ_descr
operator|=
name|descr
expr_stmt|;
comment|/* 	 * We only attempt to map the user memory into kernel space 	 * if they haven't passed in a physical memory pointer, 	 * and if there is actually an I/O operation to perform. 	 * Right now cam_periph_mapmem() only supports SCSI and device 	 * match CCBs.  For the SCSI CCBs, we only pass the CCB in if 	 * there's actually data to map.  cam_periph_mapmem() will do the 	 * right thing, even if there isn't data to map, but since CCBs 	 * without data are a reasonably common occurance (e.g. test unit 	 * ready), it will save a few cycles if we check for it here. 	 */
if|if
condition|(
operator|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|(
name|ccb_h
operator|->
name|func_code
operator|==
name|XPT_CONT_TARGET_IO
operator|)
operator|&&
operator|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
operator|)
operator|)
operator|||
operator|(
name|ccb_h
operator|->
name|func_code
operator|==
name|XPT_DEV_MATCH
operator|)
operator|)
condition|)
block|{
name|error
operator|=
name|cam_periph_mapmem
argument_list|(
name|ccb
argument_list|,
name|mapinfo
argument_list|)
expr_stmt|;
comment|/* 		 * cam_periph_mapmem returned an error, we can't continue. 		 * Return the error to the user. 		 */
if|if
condition|(
name|error
condition|)
block|{
name|ccb_h
operator|->
name|status
operator|=
name|CAM_REQ_CMP_ERR
expr_stmt|;
name|mapinfo
operator|->
name|num_bufs_used
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* 	 * Once queued on the pending CCB list, this CCB will be protected 	 * by our error recovery handler. 	 */
name|CAM_DEBUG
argument_list|(
name|softc
operator|->
name|path
argument_list|,
name|CAM_DEBUG_PERIPH
argument_list|,
operator|(
literal|"sendccb %p\n"
operator|,
name|ccb
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|XPT_FC_IS_QUEUED
argument_list|(
name|ccb
argument_list|)
condition|)
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|softc
operator|->
name|pending_ccb_queue
argument_list|,
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
block|}
name|xpt_action
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Completion routine for CCBs (called at splsoftcam) */
end_comment

begin_function
specifier|static
name|void
name|targdone
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|done_ccb
parameter_list|)
block|{
name|struct
name|targ_softc
modifier|*
name|softc
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_PERIPH
argument_list|,
operator|(
literal|"targdone %p\n"
operator|,
name|done_ccb
operator|)
argument_list|)
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|targ_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|softc
operator|->
name|pending_ccb_queue
argument_list|,
operator|&
name|done_ccb
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|status
operator|=
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
expr_stmt|;
comment|/* If we're no longer enabled, throw away CCB */
if|if
condition|(
operator|(
name|softc
operator|->
name|state
operator|&
name|TARG_STATE_LUN_ENABLED
operator|)
operator|==
literal|0
condition|)
block|{
name|targfreeccb
argument_list|(
name|softc
argument_list|,
name|done_ccb
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* abort_all_pending() waits for pending queue to be empty */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|softc
operator|->
name|pending_ccb_queue
argument_list|)
condition|)
name|wakeup
argument_list|(
operator|&
name|softc
operator|->
name|pending_ccb_queue
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
comment|/* All FC_*_QUEUED CCBs go back to userland */
case|case
name|XPT_IMMED_NOTIFY
case|:
case|case
name|XPT_ACCEPT_TARGET_IO
case|:
case|case
name|XPT_CONT_TARGET_IO
case|:
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|softc
operator|->
name|user_ccb_queue
argument_list|,
operator|&
name|done_ccb
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|notify_user
argument_list|(
name|softc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"targdone: impossible xpt opcode %#x"
argument_list|,
name|done_ccb
operator|->
name|ccb_h
operator|.
name|func_code
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
end_function

begin_comment
comment|/* Return CCBs to the user from the user queue and abort queue */
end_comment

begin_function
specifier|static
name|int
name|targread
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|struct
name|descr_queue
modifier|*
name|abort_queue
decl_stmt|;
name|struct
name|targ_cmd_descr
modifier|*
name|user_descr
decl_stmt|;
name|struct
name|targ_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ccb_queue
modifier|*
name|user_queue
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
name|union
name|ccb
modifier|*
name|user_ccb
decl_stmt|;
name|int
name|read_len
decl_stmt|,
name|error
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|read_len
operator|=
literal|0
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|targ_softc
operator|*
operator|)
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|user_queue
operator|=
operator|&
name|softc
operator|->
name|user_ccb_queue
expr_stmt|;
name|abort_queue
operator|=
operator|&
name|softc
operator|->
name|abort_queue
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|softc
operator|->
name|path
argument_list|,
name|CAM_DEBUG_PERIPH
argument_list|,
operator|(
literal|"targread\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* If no data is available, wait or return immediately */
name|ccb_h
operator|=
name|TAILQ_FIRST
argument_list|(
name|user_queue
argument_list|)
expr_stmt|;
name|user_descr
operator|=
name|TAILQ_FIRST
argument_list|(
name|abort_queue
argument_list|)
expr_stmt|;
while|while
condition|(
name|ccb_h
operator|==
name|NULL
operator|&&
name|user_descr
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|ioflag
operator|&
name|IO_NDELAY
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|msleep
argument_list|(
name|user_queue
argument_list|,
name|NULL
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"targrd"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ccb_h
operator|=
name|TAILQ_FIRST
argument_list|(
name|user_queue
argument_list|)
expr_stmt|;
name|user_descr
operator|=
name|TAILQ_FIRST
argument_list|(
name|abort_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
block|{
continue|continue;
block|}
else|else
block|{
goto|goto
name|read_fail
goto|;
block|}
block|}
block|}
else|else
block|{
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
block|}
comment|/* Data is available so fill the user's buffer */
while|while
condition|(
name|ccb_h
operator|!=
name|NULL
condition|)
block|{
name|struct
name|targ_cmd_descr
modifier|*
name|descr
decl_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|<
sizeof|sizeof
argument_list|(
name|user_ccb
argument_list|)
condition|)
break|break;
name|TAILQ_REMOVE
argument_list|(
name|user_queue
argument_list|,
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|descr
operator|=
operator|(
expr|struct
name|targ_cmd_descr
operator|*
operator|)
name|ccb_h
operator|->
name|targ_descr
expr_stmt|;
name|user_ccb
operator|=
name|descr
operator|->
name|user_ccb
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|softc
operator|->
name|path
argument_list|,
name|CAM_DEBUG_PERIPH
argument_list|,
operator|(
literal|"targread ccb %p (%p)\n"
operator|,
name|ccb_h
operator|,
name|user_ccb
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|targreturnccb
argument_list|(
name|softc
argument_list|,
operator|(
expr|union
name|ccb
operator|*
operator|)
name|ccb_h
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|read_fail
goto|;
name|error
operator|=
name|uiomove
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|user_ccb
argument_list|,
sizeof|sizeof
argument_list|(
name|user_ccb
argument_list|)
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|read_fail
goto|;
name|read_len
operator|+=
sizeof|sizeof
argument_list|(
name|user_ccb
argument_list|)
expr_stmt|;
name|ccb_h
operator|=
name|TAILQ_FIRST
argument_list|(
name|user_queue
argument_list|)
expr_stmt|;
block|}
comment|/* Flush out any aborted descriptors */
while|while
condition|(
name|user_descr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|<
sizeof|sizeof
argument_list|(
name|user_ccb
argument_list|)
condition|)
break|break;
name|TAILQ_REMOVE
argument_list|(
name|abort_queue
argument_list|,
name|user_descr
argument_list|,
name|tqe
argument_list|)
expr_stmt|;
name|user_ccb
operator|=
name|user_descr
operator|->
name|user_ccb
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|softc
operator|->
name|path
argument_list|,
name|CAM_DEBUG_PERIPH
argument_list|,
operator|(
literal|"targread aborted descr %p (%p)\n"
operator|,
name|user_descr
operator|,
name|user_ccb
operator|)
argument_list|)
expr_stmt|;
name|suword
argument_list|(
operator|&
name|user_ccb
operator|->
name|ccb_h
operator|.
name|status
argument_list|,
name|CAM_REQ_ABORTED
argument_list|)
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|user_ccb
argument_list|,
sizeof|sizeof
argument_list|(
name|user_ccb
argument_list|)
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|read_fail
goto|;
name|read_len
operator|+=
sizeof|sizeof
argument_list|(
name|user_ccb
argument_list|)
expr_stmt|;
name|user_descr
operator|=
name|TAILQ_FIRST
argument_list|(
name|abort_queue
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we've successfully read some amount of data, don't report an 	 * error.  If the error is persistent, it will be reported on the 	 * next read(). 	 */
if|if
condition|(
name|read_len
operator|==
literal|0
operator|&&
name|uio
operator|->
name|uio_resid
operator|!=
literal|0
condition|)
name|error
operator|=
name|ENOSPC
expr_stmt|;
name|read_fail
label|:
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Copy completed ccb back to the user */
end_comment

begin_function
specifier|static
name|int
name|targreturnccb
parameter_list|(
name|struct
name|targ_softc
modifier|*
name|softc
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|targ_cmd_descr
modifier|*
name|descr
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|u_ccbh
decl_stmt|;
name|size_t
name|ccb_len
decl_stmt|;
name|int
name|error
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|softc
operator|->
name|path
argument_list|,
name|CAM_DEBUG_PERIPH
argument_list|,
operator|(
literal|"targreturnccb %p\n"
operator|,
name|ccb
operator|)
argument_list|)
expr_stmt|;
name|descr
operator|=
operator|(
expr|struct
name|targ_cmd_descr
operator|*
operator|)
name|ccb
operator|->
name|ccb_h
operator|.
name|targ_descr
expr_stmt|;
name|u_ccbh
operator|=
operator|&
name|descr
operator|->
name|user_ccb
operator|->
name|ccb_h
expr_stmt|;
comment|/* Copy out the central portion of the ccb_hdr */
name|copyout
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|.
name|retry_count
argument_list|,
operator|&
name|u_ccbh
operator|->
name|retry_count
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|,
name|periph_priv
argument_list|)
operator|-
name|offsetof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|,
name|retry_count
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy out the rest of the ccb (after the ccb_hdr) */
name|ccb_len
operator|=
name|targccblen
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|descr
operator|->
name|mapinfo
operator|.
name|num_bufs_used
operator|!=
literal|0
condition|)
name|cam_periph_unmapmem
argument_list|(
name|ccb
argument_list|,
operator|&
name|descr
operator|->
name|mapinfo
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|+
literal|1
argument_list|,
name|u_ccbh
operator|+
literal|1
argument_list|,
name|ccb_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|xpt_print
argument_list|(
name|softc
operator|->
name|path
argument_list|,
literal|"targreturnccb - CCB copyout failed (%d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
comment|/* Free CCB or send back to devq. */
name|targfreeccb
argument_list|(
name|softc
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|union
name|ccb
modifier|*
name|targgetccb
parameter_list|(
name|struct
name|targ_softc
modifier|*
name|softc
parameter_list|,
name|xpt_opcode
name|type
parameter_list|,
name|int
name|priority
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|ccb_len
decl_stmt|;
name|ccb_len
operator|=
name|targccblen
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|ccb
argument_list|,
expr|union
name|ccb
operator|*
argument_list|,
name|ccb_len
argument_list|,
name|M_TARG
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|softc
operator|->
name|path
argument_list|,
name|CAM_DEBUG_PERIPH
argument_list|,
operator|(
literal|"getccb %p\n"
operator|,
name|ccb
operator|)
argument_list|)
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|softc
operator|->
name|path
argument_list|,
name|priority
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|type
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|cbfcnp
operator|=
name|targdone
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|targ_descr
operator|=
name|targgetdescr
argument_list|(
name|softc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ccb
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|targfreeccb
parameter_list|(
name|struct
name|targ_softc
modifier|*
name|softc
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|CAM_DEBUG_PRINT
argument_list|(
name|CAM_DEBUG_PERIPH
argument_list|,
operator|(
literal|"targfreeccb descr %p and\n"
operator|,
name|ccb
operator|->
name|ccb_h
operator|.
name|targ_descr
operator|)
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|targ_descr
argument_list|,
name|M_TARG
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_ACCEPT_TARGET_IO
case|:
case|case
name|XPT_IMMED_NOTIFY
case|:
name|CAM_DEBUG_PRINT
argument_list|(
name|CAM_DEBUG_PERIPH
argument_list|,
operator|(
literal|"freeing ccb %p\n"
operator|,
name|ccb
operator|)
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|ccb
argument_list|,
name|M_TARG
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Send back CCB if we got it from the periph */
if|if
condition|(
name|XPT_FC_IS_QUEUED
argument_list|(
name|ccb
argument_list|)
condition|)
block|{
name|CAM_DEBUG_PRINT
argument_list|(
name|CAM_DEBUG_PERIPH
argument_list|,
operator|(
literal|"returning queued ccb %p\n"
operator|,
name|ccb
operator|)
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CAM_DEBUG_PRINT
argument_list|(
name|CAM_DEBUG_PERIPH
argument_list|,
operator|(
literal|"freeing ccb %p\n"
operator|,
name|ccb
operator|)
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|ccb
argument_list|,
name|M_TARG
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|targ_cmd_descr
modifier|*
name|targgetdescr
parameter_list|(
name|struct
name|targ_softc
modifier|*
name|softc
parameter_list|)
block|{
name|struct
name|targ_cmd_descr
modifier|*
name|descr
decl_stmt|;
name|MALLOC
argument_list|(
name|descr
argument_list|,
expr|struct
name|targ_cmd_descr
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|descr
argument_list|)
argument_list|,
name|M_TARG
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|descr
operator|->
name|mapinfo
operator|.
name|num_bufs_used
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|descr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|targinit
parameter_list|(
name|void
parameter_list|)
block|{
name|EVENTHANDLER_REGISTER
argument_list|(
name|dev_clone
argument_list|,
name|targclone
argument_list|,
literal|0
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|targclone
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|struct
name|cdev
modifier|*
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|u
decl_stmt|;
if|if
condition|(
operator|*
name|dev
operator|!=
name|NULL
condition|)
return|return;
if|if
condition|(
name|dev_stdclone
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
literal|"targ"
argument_list|,
operator|&
name|u
argument_list|)
operator|!=
literal|1
condition|)
return|return;
operator|*
name|dev
operator|=
name|make_dev
argument_list|(
operator|&
name|targ_cdevsw
argument_list|,
name|unit2minor
argument_list|(
name|u
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"targ%d"
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|dev_ref
argument_list|(
operator|*
name|dev
argument_list|)
expr_stmt|;
operator|(
operator|*
name|dev
operator|)
operator|->
name|si_flags
operator||=
name|SI_CHEAPCLONE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|targasync
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|u_int32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
comment|/* All events are handled in usermode by INOTs */
name|panic
argument_list|(
literal|"targasync() called, should be an INOT instead"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Cancel all pending requests and CCBs awaiting work. */
end_comment

begin_function
specifier|static
name|void
name|abort_all_pending
parameter_list|(
name|struct
name|targ_softc
modifier|*
name|softc
parameter_list|)
block|{
name|struct
name|targ_cmd_descr
modifier|*
name|descr
decl_stmt|;
name|struct
name|ccb_abort
name|cab
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|softc
operator|->
name|path
argument_list|,
name|CAM_DEBUG_PERIPH
argument_list|,
operator|(
literal|"abort_all_pending\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* First abort the descriptors awaiting resources */
while|while
condition|(
operator|(
name|descr
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|softc
operator|->
name|work_queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|CAM_DEBUG
argument_list|(
name|softc
operator|->
name|path
argument_list|,
name|CAM_DEBUG_PERIPH
argument_list|,
operator|(
literal|"Aborting descr from workq %p\n"
operator|,
name|descr
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|softc
operator|->
name|work_queue
argument_list|,
name|descr
argument_list|,
name|tqe
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|softc
operator|->
name|abort_queue
argument_list|,
name|descr
argument_list|,
name|tqe
argument_list|)
expr_stmt|;
block|}
comment|/*  	 * Then abort all pending CCBs. 	 * targdone() will return the aborted CCB via user_ccb_queue 	 */
name|xpt_setup_ccb
argument_list|(
operator|&
name|cab
operator|.
name|ccb_h
argument_list|,
name|softc
operator|->
name|path
argument_list|,
comment|/*priority*/
literal|0
argument_list|)
expr_stmt|;
name|cab
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_ABORT
expr_stmt|;
name|cab
operator|.
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP_ERR
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ccb_h
argument_list|,
argument|&softc->pending_ccb_queue
argument_list|,
argument|periph_links.tqe
argument_list|)
block|{
name|CAM_DEBUG
argument_list|(
name|softc
operator|->
name|path
argument_list|,
name|CAM_DEBUG_PERIPH
argument_list|,
operator|(
literal|"Aborting pending CCB %p\n"
operator|,
name|ccb_h
operator|)
argument_list|)
expr_stmt|;
name|cab
operator|.
name|abort_ccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|ccb_h
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|cab
argument_list|)
expr_stmt|;
if|if
condition|(
name|cab
operator|.
name|ccb_h
operator|.
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_print
argument_list|(
name|cab
operator|.
name|ccb_h
operator|.
name|path
argument_list|,
literal|"Unable to abort CCB, status %#x\n"
argument_list|,
name|cab
operator|.
name|ccb_h
operator|.
name|status
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we aborted at least one pending CCB ok, wait for it. */
if|if
condition|(
name|cab
operator|.
name|ccb_h
operator|.
name|status
operator|==
name|CAM_REQ_CMP
condition|)
block|{
name|msleep
argument_list|(
operator|&
name|softc
operator|->
name|pending_ccb_queue
argument_list|,
name|NULL
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"tgabrt"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If we aborted anything from the work queue, wakeup user. */
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|softc
operator|->
name|user_ccb_queue
argument_list|)
operator|||
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|softc
operator|->
name|abort_queue
argument_list|)
condition|)
name|notify_user
argument_list|(
name|softc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Notify the user that data is ready */
end_comment

begin_function
specifier|static
name|void
name|notify_user
parameter_list|(
name|struct
name|targ_softc
modifier|*
name|softc
parameter_list|)
block|{
comment|/* 	 * Notify users sleeping via poll(), kqueue(), and 	 * blocking read(). 	 */
name|selwakeuppri
argument_list|(
operator|&
name|softc
operator|->
name|read_select
argument_list|,
name|PRIBIO
argument_list|)
expr_stmt|;
name|KNOTE_UNLOCKED
argument_list|(
operator|&
name|softc
operator|->
name|read_select
operator|.
name|si_note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|softc
operator|->
name|user_ccb_queue
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert CAM status to errno values */
end_comment

begin_function
specifier|static
name|int
name|targcamstatus
parameter_list|(
name|cam_status
name|status
parameter_list|)
block|{
switch|switch
condition|(
name|status
operator|&
name|CAM_STATUS_MASK
condition|)
block|{
case|case
name|CAM_REQ_CMP
case|:
comment|/* CCB request completed without error */
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|CAM_REQ_INPROG
case|:
comment|/* CCB request is in progress */
return|return
operator|(
name|EINPROGRESS
operator|)
return|;
case|case
name|CAM_REQ_CMP_ERR
case|:
comment|/* CCB request completed with an error */
return|return
operator|(
name|EIO
operator|)
return|;
case|case
name|CAM_PROVIDE_FAIL
case|:
comment|/* Unable to provide requested capability */
return|return
operator|(
name|ENOTTY
operator|)
return|;
case|case
name|CAM_FUNC_NOTAVAIL
case|:
comment|/* The requested function is not available */
return|return
operator|(
name|ENOTSUP
operator|)
return|;
case|case
name|CAM_LUN_ALRDY_ENA
case|:
comment|/* LUN is already enabled for target mode */
return|return
operator|(
name|EADDRINUSE
operator|)
return|;
case|case
name|CAM_PATH_INVALID
case|:
comment|/* Supplied Path ID is invalid */
case|case
name|CAM_DEV_NOT_THERE
case|:
comment|/* SCSI Device Not Installed/there */
return|return
operator|(
name|ENOENT
operator|)
return|;
case|case
name|CAM_REQ_ABORTED
case|:
comment|/* CCB request aborted by the host */
return|return
operator|(
name|ECANCELED
operator|)
return|;
case|case
name|CAM_CMD_TIMEOUT
case|:
comment|/* Command timeout */
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
case|case
name|CAM_REQUEUE_REQ
case|:
comment|/* Requeue to preserve transaction ordering */
return|return
operator|(
name|EAGAIN
operator|)
return|;
case|case
name|CAM_REQ_INVALID
case|:
comment|/* CCB request was invalid */
return|return
operator|(
name|EINVAL
operator|)
return|;
case|case
name|CAM_RESRC_UNAVAIL
case|:
comment|/* Resource Unavailable */
return|return
operator|(
name|ENOMEM
operator|)
return|;
case|case
name|CAM_BUSY
case|:
comment|/* CAM subsytem is busy */
case|case
name|CAM_UA_ABORT
case|:
comment|/* Unable to abort CCB request */
return|return
operator|(
name|EBUSY
operator|)
return|;
default|default:
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|size_t
name|targccblen
parameter_list|(
name|xpt_opcode
name|func_code
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
comment|/* Codes we expect to see as a target */
switch|switch
condition|(
name|func_code
condition|)
block|{
case|case
name|XPT_CONT_TARGET_IO
case|:
case|case
name|XPT_SCSI_IO
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_scsiio
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_ACCEPT_TARGET_IO
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_accept_tio
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_IMMED_NOTIFY
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_immed_notify
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_REL_SIMQ
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_relsim
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_PATH_INQ
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_pathinq
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_DEBUG
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_debug
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_ABORT
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_abort
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_EN_LUN
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_en_lun
argument_list|)
expr_stmt|;
break|break;
default|default:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|union
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|len
operator|)
return|;
block|}
end_function

end_unit

