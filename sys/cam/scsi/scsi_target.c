begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Implementation of a simple Target Mode SCSI Proccessor Target driver for CAM.  *  * Copyright (c) 1998 Justin T. Gibbs.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *      $Id$  */
end_comment

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_comment
comment|/* For offsetof */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/devicestat.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_comment
comment|/* For struct selinfo. */
end_comment

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_extend.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_pt.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_targetio.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_typedef
typedef|typedef
enum|enum
block|{
name|TARG_STATE_NORMAL
block|,
name|TARG_STATE_EXCEPTION
block|,
name|TARG_STATE_TEARDOWN
block|}
name|targ_state
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|TARG_FLAG_NONE
init|=
literal|0x00
block|,
name|TARG_FLAG_SEND_EOF
init|=
literal|0x01
block|,
name|TARG_FLAG_RECEIVE_EOF
init|=
literal|0x02
block|}
name|targ_flags
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|TARG_CCB_WORKQ
block|,
name|TARG_CCB_WAITING
block|}
name|targ_ccb_types
typedef|;
end_typedef

begin_define
define|#
directive|define
name|MAX_ACCEPT
value|16
end_define

begin_define
define|#
directive|define
name|MAX_IMMEDIATE
value|16
end_define

begin_define
define|#
directive|define
name|MAX_BUF_SIZE
value|256
end_define

begin_comment
comment|/* Max inquiry/sense/mode page transfer */
end_comment

begin_define
define|#
directive|define
name|MAX_INITIATORS
value|16
end_define

begin_comment
comment|/* XXX More for Fibre-Channel */
end_comment

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a> b) ? b : a)
end_define

begin_comment
comment|/* Offsets into our private CCB area for storing accept information */
end_comment

begin_define
define|#
directive|define
name|ccb_type
value|ppriv_field0
end_define

begin_define
define|#
directive|define
name|ccb_descr
value|ppriv_ptr1
end_define

begin_comment
comment|/* We stick a pointer to the originating accept TIO in each continue I/O CCB */
end_comment

begin_define
define|#
directive|define
name|ccb_atio
value|ppriv_ptr1
end_define

begin_expr_stmt
name|TAILQ_HEAD
argument_list|(
name|ccb_queue
argument_list|,
name|ccb_hdr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|targ_softc
block|{
name|struct
name|ccb_queue
name|pending_queue
decl_stmt|;
name|struct
name|ccb_queue
name|work_queue
decl_stmt|;
name|struct
name|ccb_queue
name|snd_ccb_queue
decl_stmt|;
name|struct
name|ccb_queue
name|rcv_ccb_queue
decl_stmt|;
name|struct
name|ccb_queue
name|unknown_atio_queue
decl_stmt|;
name|struct
name|buf_queue_head
name|snd_buf_queue
decl_stmt|;
name|struct
name|buf_queue_head
name|rcv_buf_queue
decl_stmt|;
name|struct
name|devstat
name|device_stats
decl_stmt|;
name|struct
name|selinfo
name|snd_select
decl_stmt|;
name|struct
name|selinfo
name|rcv_select
decl_stmt|;
name|targ_state
name|state
decl_stmt|;
name|targ_flags
name|flags
decl_stmt|;
name|targ_exception
name|exceptions
decl_stmt|;
name|u_int
name|init_level
decl_stmt|;
name|u_int
name|inq_data_len
decl_stmt|;
name|struct
name|scsi_inquiry_data
modifier|*
name|inq_data
decl_stmt|;
name|struct
name|initiator_state
name|istate
index|[
name|MAX_INITIATORS
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|targ_cmd_desc
block|{
name|SLIST_ENTRY
argument_list|(
argument|targ_cmd_desc
argument_list|)
name|links
expr_stmt|;
name|u_int
name|data_resid
decl_stmt|;
comment|/* How much left to transfer */
name|u_int
name|data_increment
decl_stmt|;
comment|/* Amount to send before next disconnect */
name|void
modifier|*
name|data
decl_stmt|;
comment|/* The data. Can be from backing_store or not */
name|void
modifier|*
name|backing_store
decl_stmt|;
comment|/* Backing store allocated for this descriptor*/
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
comment|/* Buffer for this transfer */
name|u_int
name|max_size
decl_stmt|;
comment|/* Size of backing_store */
name|u_int32_t
name|timeout
decl_stmt|;
name|u_int8_t
name|status
decl_stmt|;
comment|/* Status to return to initiator */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|d_open_t
name|targopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|targclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|targread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|targwrite
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|targioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_poll_t
name|targpoll
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_strategy_t
name|targstrategy
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TARG_CDEV_MAJOR
value|65
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|targ_cdevsw
init|=
block|{
comment|/*d_open*/
name|targopen
block|,
comment|/*d_close*/
name|targclose
block|,
comment|/*d_read*/
name|targread
block|,
comment|/*d_write*/
name|targwrite
block|,
comment|/*d_ioctl*/
name|targioctl
block|,
comment|/*d_stop*/
name|nostop
block|,
comment|/*d_reset*/
name|noreset
block|,
comment|/*d_devtotty*/
name|nodevtotty
block|,
comment|/*d_poll*/
name|targpoll
block|,
comment|/*d_mmap*/
name|nommap
block|,
comment|/*d_strategy*/
name|targstrategy
block|,
comment|/*d_name*/
literal|"targ"
block|,
comment|/*d_spare*/
name|NULL
block|,
comment|/*d_maj*/
operator|-
literal|1
block|,
comment|/*d_dump*/
name|nodump
block|,
comment|/*d_psize*/
name|nopsize
block|,
comment|/*d_flags*/
literal|0
block|,
comment|/*d_maxio*/
literal|0
block|,
comment|/*b_maj*/
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|targsendccb
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|union
name|ccb
modifier|*
name|inccb
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|periph_init_t
name|targinit
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|targasync
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|u_int32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|periph_ctor_t
name|targctor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_dtor_t
name|targdtor
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|targrunqueue
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|targ_softc
modifier|*
name|softc
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|periph_start_t
name|targstart
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|targdone
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|done_ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|targfireexception
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|targ_softc
modifier|*
name|softc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|targerror
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|u_int32_t
name|cam_flags
parameter_list|,
name|u_int32_t
name|sense_flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|targ_cmd_desc
modifier|*
name|allocdescr
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|freedescr
parameter_list|(
name|struct
name|targ_cmd_desc
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fill_sense
parameter_list|(
name|struct
name|scsi_sense_data
modifier|*
name|sense
parameter_list|,
name|u_int
name|error_code
parameter_list|,
name|u_int
name|sense_key
parameter_list|,
name|u_int
name|asc
parameter_list|,
name|u_int
name|ascq
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|periph_driver
name|targdriver
init|=
block|{
name|targinit
block|,
literal|"targ"
block|,
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|targdriver
operator|.
name|units
argument_list|)
block|,
comment|/* generation */
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DATA_SET
argument_list|(
name|periphdriver_set
argument_list|,
name|targdriver
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|extend_array
modifier|*
name|targperiphs
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|targinit
parameter_list|(
name|void
parameter_list|)
block|{
name|cam_status
name|status
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
comment|/* 	 * Create our extend array for storing the devices we attach to. 	 */
name|targperiphs
operator|=
name|cam_extend_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|targperiphs
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"targ: Failed to alloc extend array!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Install a global async callback.  This callback will 	 * receive async callbacks like "new path registered". 	 */
name|status
operator|=
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|CAM_XPT_PATH_ID
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|CAM_REQ_CMP
condition|)
block|{
name|struct
name|ccb_setasync
name|csa
decl_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|csa
operator|.
name|ccb_h
argument_list|,
name|path
argument_list|,
comment|/*priority*/
literal|5
argument_list|)
expr_stmt|;
name|csa
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SASYNC_CB
expr_stmt|;
name|csa
operator|.
name|event_enable
operator|=
name|AC_PATH_REGISTERED
expr_stmt|;
name|csa
operator|.
name|callback
operator|=
name|targasync
expr_stmt|;
name|csa
operator|.
name|callback_arg
operator|=
name|NULL
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|csa
argument_list|)
expr_stmt|;
name|status
operator|=
name|csa
operator|.
name|ccb_h
operator|.
name|status
expr_stmt|;
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"targ: Failed to attach master async callback "
literal|"due to status 0x%x!\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If we were successfull, register our devsw */
name|dev_t
name|dev
decl_stmt|;
name|dev
operator|=
name|makedev
argument_list|(
name|TARG_CDEV_MAJOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cdevsw_add
argument_list|(
operator|&
name|dev
argument_list|,
operator|&
name|targ_cdevsw
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|targasync
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|u_int32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|periph
operator|=
operator|(
expr|struct
name|cam_periph
operator|*
operator|)
name|callback_arg
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|AC_PATH_REGISTERED
case|:
block|{
name|struct
name|ccb_pathinq
modifier|*
name|cpi
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|new_path
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|cpi
operator|=
operator|(
expr|struct
name|ccb_pathinq
operator|*
operator|)
name|arg
expr_stmt|;
comment|/* Only attach to controllers that support target mode */
if|if
condition|(
operator|(
name|cpi
operator|->
name|target_sprt
operator|&
name|PIT_PROCESSOR
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/* 		 * Allocate a peripheral instance for 		 * this target instance. 		 */
name|status
operator|=
name|xpt_create_path
argument_list|(
operator|&
name|new_path
argument_list|,
name|NULL
argument_list|,
name|xpt_path_path_id
argument_list|(
name|path
argument_list|)
argument_list|,
name|cpi
operator|->
name|initiator_id
argument_list|,
comment|/*lun*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"targasync: Unable to create path "
literal|"due to status 0x%x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
break|break;
block|}
name|status
operator|=
name|cam_periph_alloc
argument_list|(
name|targctor
argument_list|,
name|targdtor
argument_list|,
name|targstart
argument_list|,
literal|"targ"
argument_list|,
name|CAM_PERIPH_BIO
argument_list|,
name|new_path
argument_list|,
name|targasync
argument_list|,
name|AC_PATH_REGISTERED
argument_list|,
name|cpi
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|new_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
operator|&&
name|status
operator|!=
name|CAM_REQ_INPROG
condition|)
name|printf
argument_list|(
literal|"targasync: Unable to attach to new device "
literal|"due to status 0x%x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|AC_PATH_DEREGISTERED
case|:
block|{
comment|/* XXX Implement */
break|break;
block|}
case|case
name|AC_BUS_RESET
case|:
block|{
comment|/* Flush transaction queue */
block|}
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|cam_status
name|targctor
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|union
name|ccb
name|immed_ccb
decl_stmt|;
name|struct
name|targ_softc
modifier|*
name|softc
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Allocate our per-instance private storage */
name|softc
operator|=
operator|(
expr|struct
name|targ_softc
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|softc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"targctor: unable to malloc softc\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
name|bzero
argument_list|(
name|softc
argument_list|,
sizeof|sizeof
argument_list|(
name|softc
argument_list|)
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|softc
operator|->
name|pending_queue
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|softc
operator|->
name|work_queue
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|softc
operator|->
name|snd_ccb_queue
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|softc
operator|->
name|rcv_ccb_queue
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|softc
operator|->
name|unknown_atio_queue
argument_list|)
expr_stmt|;
name|bufq_init
argument_list|(
operator|&
name|softc
operator|->
name|snd_buf_queue
argument_list|)
expr_stmt|;
name|bufq_init
argument_list|(
operator|&
name|softc
operator|->
name|rcv_buf_queue
argument_list|)
expr_stmt|;
name|softc
operator|->
name|state
operator|=
name|TARG_STATE_NORMAL
expr_stmt|;
name|periph
operator|->
name|softc
operator|=
name|softc
expr_stmt|;
name|softc
operator|->
name|init_level
operator|++
expr_stmt|;
name|cam_extend_set
argument_list|(
name|targperiphs
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|,
name|periph
argument_list|)
expr_stmt|;
comment|/* 	 * We start out life with a UA to indicate power-on/reset. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_INITIATORS
condition|;
name|i
operator|++
control|)
name|softc
operator|->
name|istate
index|[
name|i
index|]
operator|.
name|pending_ua
operator|=
name|UA_POWER_ON
expr_stmt|;
comment|/* 	 * Allocate an initial inquiry data buffer.  We might allow the 	 * user to override this later via an ioctl. 	 */
name|softc
operator|->
name|inq_data_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|softc
operator|->
name|inq_data
argument_list|)
expr_stmt|;
name|softc
operator|->
name|inq_data
operator|=
name|malloc
argument_list|(
name|softc
operator|->
name|inq_data_len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|inq_data
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"targctor - Unable to malloc inquiry data\n"
argument_list|)
expr_stmt|;
name|targdtor
argument_list|(
name|periph
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
name|softc
operator|->
name|inq_data
argument_list|,
name|softc
operator|->
name|inq_data_len
argument_list|)
expr_stmt|;
name|softc
operator|->
name|inq_data
operator|->
name|device
operator|=
name|T_PROCESSOR
operator||
operator|(
name|SID_QUAL_LU_CONNECTED
operator|<<
literal|5
operator|)
expr_stmt|;
name|softc
operator|->
name|inq_data
operator|->
name|version
operator|=
literal|2
expr_stmt|;
name|softc
operator|->
name|inq_data
operator|->
name|response_format
operator|=
literal|2
expr_stmt|;
comment|/* SCSI2 Inquiry Format */
name|softc
operator|->
name|inq_data
operator|->
name|additional_length
operator|=
name|softc
operator|->
name|inq_data_len
operator|-
literal|4
expr_stmt|;
name|strncpy
argument_list|(
name|softc
operator|->
name|inq_data
operator|->
name|vendor
argument_list|,
literal|"FreeBSD "
argument_list|,
name|SID_VENDOR_SIZE
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|softc
operator|->
name|inq_data
operator|->
name|product
argument_list|,
literal|"TM-PT           "
argument_list|,
name|SID_PRODUCT_SIZE
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|softc
operator|->
name|inq_data
operator|->
name|revision
argument_list|,
literal|"0.0 "
argument_list|,
name|SID_REVISION_SIZE
argument_list|)
expr_stmt|;
name|softc
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* Attempt to enable the lun of interrest */
name|xpt_setup_ccb
argument_list|(
operator|&
name|immed_ccb
operator|.
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|immed_ccb
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_EN_LUN
expr_stmt|;
comment|/* Don't need support for any vendor specific commands */
name|immed_ccb
operator|.
name|cel
operator|.
name|grp6_len
operator|=
literal|0
expr_stmt|;
name|immed_ccb
operator|.
name|cel
operator|.
name|grp7_len
operator|=
literal|0
expr_stmt|;
name|immed_ccb
operator|.
name|cel
operator|.
name|enable
operator|=
literal|1
expr_stmt|;
name|xpt_action
argument_list|(
operator|&
name|immed_ccb
argument_list|)
expr_stmt|;
name|status
operator|=
name|immed_ccb
operator|.
name|ccb_h
operator|.
name|status
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"targctor - Enable Lun Rejected for status 0x%x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|targdtor
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
name|softc
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* 	 * Build up a buffer of accept target I/O 	 * operations for incoming selections. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_ACCEPT
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ccb_accept_tio
modifier|*
name|atio
decl_stmt|;
name|atio
operator|=
operator|(
expr|struct
name|ccb_accept_tio
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|atio
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|atio
operator|==
name|NULL
condition|)
block|{
name|status
operator|=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
break|break;
block|}
name|atio
operator|->
name|ccb_h
operator|.
name|ccb_descr
operator|=
name|allocdescr
argument_list|()
expr_stmt|;
if|if
condition|(
name|atio
operator|->
name|ccb_h
operator|.
name|ccb_descr
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|atio
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|status
operator|=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
break|break;
block|}
name|xpt_setup_ccb
argument_list|(
operator|&
name|atio
operator|->
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_ACCEPT_TARGET_IO
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|cbfcnp
operator|=
name|targdone
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|atio
argument_list|)
expr_stmt|;
name|status
operator|=
name|atio
operator|->
name|ccb_h
operator|.
name|status
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_INPROG
condition|)
block|{
name|free
argument_list|(
name|atio
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"targctor - Could not allocate accept tio CCBs: "
literal|"status = 0x%x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|targdtor
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
comment|/* 	 * Build up a buffer of immediate notify CCBs 	 * so the SIM can tell us of asynchronous target mode events. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_ACCEPT
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ccb_immed_notify
modifier|*
name|inot
decl_stmt|;
name|inot
operator|=
operator|(
expr|struct
name|ccb_immed_notify
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|inot
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|inot
operator|==
name|NULL
condition|)
block|{
name|status
operator|=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
break|break;
block|}
name|xpt_setup_ccb
argument_list|(
operator|&
name|inot
operator|->
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|inot
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_IMMED_NOTIFY
expr_stmt|;
name|inot
operator|->
name|ccb_h
operator|.
name|cbfcnp
operator|=
name|targdone
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|inot
argument_list|)
expr_stmt|;
name|status
operator|=
name|inot
operator|->
name|ccb_h
operator|.
name|status
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_INPROG
condition|)
block|{
name|free
argument_list|(
name|inot
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"targctor - Could not allocate immediate notify CCBs: "
literal|"status = 0x%x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|targdtor
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
return|return
operator|(
name|CAM_REQ_CMP
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|targdtor
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|struct
name|targ_softc
modifier|*
name|softc
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|targ_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|softc
operator|->
name|state
operator|=
name|TARG_STATE_TEARDOWN
expr_stmt|;
switch|switch
condition|(
name|softc
operator|->
name|init_level
condition|)
block|{
default|default:
comment|/* FALLTHROUGH */
case|case
literal|3
case|:
block|{
name|struct
name|ccb_en_lun
name|cel
decl_stmt|;
comment|/* 		 * XXX Spec requires abort of all ACCEPT and 		 * IMMEDIATE CCBS first.  Act accordingly. 		 */
comment|/* 		 * Dissable this lun. 		 */
name|xpt_setup_ccb
argument_list|(
operator|&
name|cel
operator|.
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|cel
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_EN_LUN
expr_stmt|;
name|cel
operator|.
name|enable
operator|=
literal|0
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|cel
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
block|}
case|case
literal|2
case|:
name|free
argument_list|(
name|softc
operator|->
name|inq_data
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|1
case|:
name|free
argument_list|(
name|softc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|panic
argument_list|(
literal|"targdtor - impossible init level"
argument_list|)
expr_stmt|;
empty_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|targopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|targ_softc
modifier|*
name|softc
decl_stmt|;
name|u_int
name|unit
decl_stmt|;
name|int
name|s
decl_stmt|;
name|unit
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|periph
operator|=
name|cam_extend_get
argument_list|(
name|targperiphs
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|softc
operator|=
operator|(
expr|struct
name|targ_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|targclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|targ_softc
modifier|*
name|softc
decl_stmt|;
name|u_int
name|unit
decl_stmt|;
name|int
name|s
decl_stmt|;
name|unit
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|periph
operator|=
name|cam_extend_get
argument_list|(
name|targperiphs
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|softc
operator|=
operator|(
expr|struct
name|targ_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|targioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|targ_softc
modifier|*
name|softc
decl_stmt|;
name|u_int
name|unit
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|s
decl_stmt|;
name|unit
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|periph
operator|=
name|cam_extend_get
argument_list|(
name|targperiphs
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|softc
operator|=
operator|(
expr|struct
name|targ_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|TARGIOCFETCHEXCEPTION
case|:
operator|*
operator|(
operator|(
name|targ_exception
operator|*
operator|)
name|addr
operator|)
operator|=
name|softc
operator|->
name|exceptions
expr_stmt|;
break|break;
case|case
name|TARGIOCCLEAREXCEPTION
case|:
block|{
name|targ_exception
name|clear_mask
decl_stmt|;
name|clear_mask
operator|=
operator|*
operator|(
operator|(
name|targ_exception
operator|*
operator|)
name|addr
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|clear_mask
operator|&
name|TARG_EXCEPT_UNKNOWN_ATIO
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|ccbh
decl_stmt|;
name|ccbh
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|softc
operator|->
name|unknown_atio_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccbh
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|softc
operator|->
name|unknown_atio_queue
argument_list|,
name|ccbh
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|ccbh
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|softc
operator|->
name|unknown_atio_queue
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ccbh
operator|!=
name|NULL
condition|)
name|clear_mask
operator|&=
operator|~
name|TARG_EXCEPT_UNKNOWN_ATIO
expr_stmt|;
block|}
name|softc
operator|->
name|exceptions
operator|&=
operator|~
name|clear_mask
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|exceptions
operator|==
name|TARG_EXCEPT_NONE
operator|&&
name|softc
operator|->
name|state
operator|==
name|TARG_STATE_EXCEPTION
condition|)
block|{
name|softc
operator|->
name|state
operator|=
name|TARG_STATE_NORMAL
expr_stmt|;
name|targrunqueue
argument_list|(
name|periph
argument_list|,
name|softc
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|TARGIOCFETCHATIO
case|:
block|{
name|struct
name|ccb_hdr
modifier|*
name|ccbh
decl_stmt|;
name|ccbh
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|softc
operator|->
name|unknown_atio_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccbh
operator|!=
name|NULL
condition|)
block|{
name|bcopy
argument_list|(
name|ccbh
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_accept_tio
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
block|}
break|break;
block|}
case|case
name|TARGIOCCOMMAND
case|:
block|{
name|union
name|ccb
modifier|*
name|inccb
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
comment|/* 		 * XXX JGibbs 		 * This code is lifted directly from the pass-thru driver. 		 * Perhaps this should be moved to a library???? 		 */
name|inccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|addr
expr_stmt|;
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
name|inccb
operator|->
name|ccb_h
operator|.
name|pinfo
operator|.
name|priority
argument_list|)
expr_stmt|;
name|error
operator|=
name|targsendccb
argument_list|(
name|periph
argument_list|,
name|ccb
argument_list|,
name|inccb
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TARGIOCGETISTATE
case|:
case|case
name|TARGIOCSETISTATE
case|:
block|{
name|struct
name|ioc_initiator_state
modifier|*
name|ioc_istate
decl_stmt|;
name|ioc_istate
operator|=
operator|(
expr|struct
name|ioc_initiator_state
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|ioc_istate
operator|->
name|initiator_id
operator|>
name|MAX_INITIATORS
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"GET/SETISTATE for %d\n"
argument_list|,
name|ioc_istate
operator|->
name|initiator_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|TARGIOCGETISTATE
condition|)
block|{
name|bcopy
argument_list|(
operator|&
name|softc
operator|->
name|istate
index|[
name|ioc_istate
operator|->
name|initiator_id
index|]
argument_list|,
operator|&
name|ioc_istate
operator|->
name|istate
argument_list|,
sizeof|sizeof
argument_list|(
name|ioc_istate
operator|->
name|istate
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
operator|&
name|ioc_istate
operator|->
name|istate
argument_list|,
operator|&
name|softc
operator|->
name|istate
index|[
name|ioc_istate
operator|->
name|initiator_id
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|ioc_istate
operator|->
name|istate
argument_list|)
argument_list|)
expr_stmt|;
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"pending_ca now %x\n"
argument_list|,
name|softc
operator|->
name|istate
index|[
name|ioc_istate
operator|->
name|initiator_id
index|]
operator|.
name|pending_ca
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
name|error
operator|=
name|ENOTTY
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * XXX JGibbs lifted from pass-thru driver.  * Generally, "ccb" should be the CCB supplied by the kernel.  "inccb"  * should be the CCB that is copied in from the user.  */
end_comment

begin_function
specifier|static
name|int
name|targsendccb
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|union
name|ccb
modifier|*
name|inccb
parameter_list|)
block|{
name|struct
name|buf
modifier|*
name|bp
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|targ_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|cam_periph_map_info
name|mapinfo
decl_stmt|;
name|int
name|error
decl_stmt|,
name|need_unmap
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|targ_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|need_unmap
operator|=
literal|0
expr_stmt|;
comment|/* 	 * There are some fields in the CCB header that need to be 	 * preserved, the rest we get from the user. 	 */
name|xpt_merge_ccb
argument_list|(
name|ccb
argument_list|,
name|inccb
argument_list|)
expr_stmt|;
comment|/* 	 * There's no way for the user to have a completion 	 * function, so we put our own completion function in here. 	 */
name|ccb
operator|->
name|ccb_h
operator|.
name|cbfcnp
operator|=
name|targdone
expr_stmt|;
comment|/* 	 * We only attempt to map the user memory into kernel space 	 * if they haven't passed in a physical memory pointer, 	 * and if there is actually an I/O operation to perform. 	 * Right now cam_periph_mapmem() only supports SCSI and device 	 * match CCBs.  For the SCSI CCBs, we only pass the CCB in if 	 * there's actually data to map.  cam_periph_mapmem() will do the 	 * right thing, even if there isn't data to map, but since CCBs 	 * without data are a reasonably common occurance (e.g. test unit 	 * ready), it will save a few cycles if we check for it here. 	 */
if|if
condition|(
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_CONT_TARGET_IO
operator|)
operator|&&
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
operator|)
operator|)
operator|||
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_DEV_MATCH
operator|)
operator|)
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|mapinfo
argument_list|,
sizeof|sizeof
argument_list|(
name|mapinfo
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|cam_periph_mapmem
argument_list|(
name|ccb
argument_list|,
operator|&
name|mapinfo
argument_list|)
expr_stmt|;
comment|/* 		 * cam_periph_mapmem returned an error, we can't continue. 		 * Return the error to the user. 		 */
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 		 * We successfully mapped the memory in, so we need to 		 * unmap it when the transaction is done. 		 */
name|need_unmap
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * If the user wants us to perform any error recovery, then honor 	 * that request.  Otherwise, it's up to the user to perform any 	 * error recovery. 	 */
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_PASS_ERR_RECOVER
operator|)
condition|?
name|targerror
else|:
name|NULL
argument_list|,
comment|/* cam_flags */
literal|0
argument_list|,
comment|/* sense_flags */
name|SF_RETRY_UA
argument_list|,
operator|&
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_unmap
operator|!=
literal|0
condition|)
name|cam_periph_unmapmem
argument_list|(
name|ccb
argument_list|,
operator|&
name|mapinfo
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|cbfcnp
operator|=
name|NULL
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|periph_priv
operator|=
name|inccb
operator|->
name|ccb_h
operator|.
name|periph_priv
expr_stmt|;
name|bcopy
argument_list|(
name|ccb
argument_list|,
name|inccb
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|ccb
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|targpoll
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|poll_events
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|targ_softc
modifier|*
name|softc
decl_stmt|;
name|u_int
name|unit
decl_stmt|;
name|int
name|revents
decl_stmt|;
name|int
name|s
decl_stmt|;
name|unit
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|periph
operator|=
name|cam_extend_get
argument_list|(
name|targperiphs
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|softc
operator|=
operator|(
expr|struct
name|targ_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|revents
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|poll_events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|softc
operator|->
name|rcv_ccb_queue
argument_list|)
operator|!=
name|NULL
operator|&&
name|bufq_first
argument_list|(
operator|&
name|softc
operator|->
name|rcv_buf_queue
argument_list|)
operator|==
name|NULL
condition|)
name|revents
operator||=
name|poll_events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|poll_events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|softc
operator|->
name|snd_ccb_queue
argument_list|)
operator|!=
name|NULL
operator|&&
name|bufq_first
argument_list|(
operator|&
name|softc
operator|->
name|snd_buf_queue
argument_list|)
operator|==
name|NULL
condition|)
name|revents
operator||=
name|poll_events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|softc
operator|->
name|state
operator|!=
name|TARG_STATE_NORMAL
condition|)
name|revents
operator||=
name|POLLERR
expr_stmt|;
if|if
condition|(
name|revents
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|poll_events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
condition|)
name|selrecord
argument_list|(
name|p
argument_list|,
operator|&
name|softc
operator|->
name|rcv_select
argument_list|)
expr_stmt|;
if|if
condition|(
name|poll_events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
condition|)
name|selrecord
argument_list|(
name|p
argument_list|,
operator|&
name|softc
operator|->
name|snd_select
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|revents
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|targread
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
if|if
condition|(
name|uio
operator|->
name|uio_iovcnt
operator|==
literal|0
operator|||
name|uio
operator|->
name|uio_iov
operator|->
name|iov_len
operator|==
literal|0
condition|)
block|{
comment|/* EOF */
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|targ_softc
modifier|*
name|softc
decl_stmt|;
name|u_int
name|unit
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|unit
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|periph
operator|=
name|cam_extend_get
argument_list|(
name|targperiphs
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|softc
operator|=
operator|(
expr|struct
name|targ_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|softc
operator|->
name|flags
operator||=
name|TARG_FLAG_SEND_EOF
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|targrunqueue
argument_list|(
name|periph
argument_list|,
name|softc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|physio
argument_list|(
name|targstrategy
argument_list|,
name|NULL
argument_list|,
name|dev
argument_list|,
literal|1
argument_list|,
name|minphys
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|targwrite
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
if|if
condition|(
name|uio
operator|->
name|uio_iovcnt
operator|==
literal|0
operator|||
name|uio
operator|->
name|uio_iov
operator|->
name|iov_len
operator|==
literal|0
condition|)
block|{
comment|/* EOF */
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|targ_softc
modifier|*
name|softc
decl_stmt|;
name|u_int
name|unit
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|unit
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|periph
operator|=
name|cam_extend_get
argument_list|(
name|targperiphs
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|softc
operator|=
operator|(
expr|struct
name|targ_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|softc
operator|->
name|flags
operator||=
name|TARG_FLAG_RECEIVE_EOF
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|targrunqueue
argument_list|(
name|periph
argument_list|,
name|softc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|physio
argument_list|(
name|targstrategy
argument_list|,
name|NULL
argument_list|,
name|dev
argument_list|,
literal|0
argument_list|,
name|minphys
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Actually translate the requested transfer into one the physical driver  * can understand.  The transfer is described by a buf and will include  * only one physical transfer.  */
end_comment

begin_function
specifier|static
name|void
name|targstrategy
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|targ_softc
modifier|*
name|softc
decl_stmt|;
name|u_int
name|unit
decl_stmt|;
name|int
name|s
decl_stmt|;
name|unit
operator|=
name|minor
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
name|periph
operator|=
name|cam_extend_get
argument_list|(
name|targperiphs
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|softc
operator|=
operator|(
expr|struct
name|targ_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
comment|/* 	 * Mask interrupts so that the device cannot be invalidated until 	 * after we are in the queue.  Otherwise, we might not properly 	 * clean up one of the buffers. 	 */
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* 	 * If there is an exception pending, error out 	 */
if|if
condition|(
name|softc
operator|->
name|state
operator|!=
name|TARG_STATE_NORMAL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|state
operator|==
name|TARG_STATE_EXCEPTION
operator|&&
operator|(
name|softc
operator|->
name|exceptions
operator|&
name|TARG_EXCEPT_DEVICE_INVALID
operator|)
operator|==
literal|0
condition|)
name|bp
operator|->
name|b_error
operator|=
name|EBUSY
expr_stmt|;
else|else
name|bp
operator|->
name|b_error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Place it in the queue of buffers available for either 	 * SEND or RECEIVE commands. 	 *  	 */
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|!=
literal|0
condition|)
block|{
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Queued a SEND buffer\n"
argument_list|)
expr_stmt|;
name|bufq_insert_tail
argument_list|(
operator|&
name|softc
operator|->
name|snd_buf_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Queued a RECEIVE buffer\n"
argument_list|)
expr_stmt|;
name|bufq_insert_tail
argument_list|(
operator|&
name|softc
operator|->
name|rcv_buf_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Attempt to use the new buffer to service any pending 	 * target commands. 	 */
name|targrunqueue
argument_list|(
name|periph
argument_list|,
name|softc
argument_list|)
expr_stmt|;
return|return;
name|bad
label|:
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
comment|/* 	 * Correctly set the buf to indicate a completed xfer 	 */
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|targrunqueue
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|targ_softc
modifier|*
name|softc
parameter_list|)
block|{
name|struct
name|ccb_queue
modifier|*
name|pending_queue
decl_stmt|;
name|struct
name|ccb_accept_tio
modifier|*
name|atio
decl_stmt|;
name|struct
name|buf_queue_head
modifier|*
name|bufq
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|targ_cmd_desc
modifier|*
name|desc
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccbh
decl_stmt|;
name|int
name|added
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|pending_queue
operator|=
name|NULL
expr_stmt|;
name|bufq
operator|=
name|NULL
expr_stmt|;
name|ccbh
operator|=
name|NULL
expr_stmt|;
comment|/* Only run one request at a time to maintain data ordering. */
if|if
condition|(
name|softc
operator|->
name|state
operator|!=
name|TARG_STATE_NORMAL
operator|||
name|TAILQ_FIRST
argument_list|(
operator|&
name|softc
operator|->
name|work_queue
argument_list|)
operator|!=
name|NULL
operator|||
name|TAILQ_FIRST
argument_list|(
operator|&
name|softc
operator|->
name|pending_queue
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
operator|(
name|bp
operator|=
name|bufq_first
argument_list|(
operator|&
name|softc
operator|->
name|snd_buf_queue
argument_list|)
operator|)
operator|!=
name|NULL
operator|||
operator|(
name|softc
operator|->
name|flags
operator|&
name|TARG_FLAG_SEND_EOF
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ccbh
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|softc
operator|->
name|snd_ccb_queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
name|softc
operator|->
name|flags
operator|&=
operator|~
name|TARG_FLAG_SEND_EOF
expr_stmt|;
else|else
block|{
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"De-Queued a SEND buffer %d\n"
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
block|}
name|bufq
operator|=
operator|&
name|softc
operator|->
name|snd_buf_queue
expr_stmt|;
name|pending_queue
operator|=
operator|&
name|softc
operator|->
name|snd_ccb_queue
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|bp
operator|=
name|bufq_first
argument_list|(
operator|&
name|softc
operator|->
name|rcv_buf_queue
argument_list|)
operator|)
operator|!=
name|NULL
operator|||
operator|(
name|softc
operator|->
name|flags
operator|&
name|TARG_FLAG_RECEIVE_EOF
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ccbh
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|softc
operator|->
name|rcv_ccb_queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
name|softc
operator|->
name|flags
operator|&=
operator|~
name|TARG_FLAG_RECEIVE_EOF
expr_stmt|;
else|else
block|{
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"De-Queued a RECEIVE buffer %d\n"
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
block|}
name|bufq
operator|=
operator|&
name|softc
operator|->
name|rcv_buf_queue
expr_stmt|;
name|pending_queue
operator|=
operator|&
name|softc
operator|->
name|rcv_ccb_queue
expr_stmt|;
block|}
if|if
condition|(
name|pending_queue
operator|!=
name|NULL
condition|)
block|{
comment|/* Process a request */
name|atio
operator|=
operator|(
expr|struct
name|ccb_accept_tio
operator|*
operator|)
name|ccbh
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
name|pending_queue
argument_list|,
name|ccbh
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|desc
operator|=
operator|(
expr|struct
name|targ_cmd_desc
operator|*
operator|)
name|atio
operator|->
name|ccb_h
operator|.
name|ccb_descr
expr_stmt|;
name|desc
operator|->
name|bp
operator|=
name|bp
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
comment|/* EOF */
name|desc
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|desc
operator|->
name|data_increment
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|data_resid
operator|=
literal|0
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator|&=
operator|~
name|CAM_DIR_MASK
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DIR_NONE
expr_stmt|;
block|}
else|else
block|{
name|bufq_remove
argument_list|(
name|bufq
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|desc
operator|->
name|data
operator|=
operator|&
name|bp
operator|->
name|b_data
index|[
name|bp
operator|->
name|b_bcount
operator|-
name|bp
operator|->
name|b_resid
index|]
expr_stmt|;
name|desc
operator|->
name|data_increment
operator|=
name|MIN
argument_list|(
name|desc
operator|->
name|data_resid
argument_list|,
name|bp
operator|->
name|b_resid
argument_list|)
expr_stmt|;
block|}
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Buffer command: data %x: datacnt %d\n"
argument_list|,
name|desc
operator|->
name|data
argument_list|,
name|desc
operator|->
name|data_increment
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|softc
operator|->
name|work_queue
argument_list|,
operator|&
name|atio
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|softc
operator|->
name|work_queue
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|xpt_schedule
argument_list|(
name|periph
argument_list|,
comment|/*XXX priority*/
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|targstart
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|start_ccb
parameter_list|)
block|{
name|struct
name|targ_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccbh
decl_stmt|;
name|struct
name|ccb_accept_tio
modifier|*
name|atio
decl_stmt|;
name|struct
name|targ_cmd_desc
modifier|*
name|desc
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|ccb_flags
name|flags
decl_stmt|;
name|int
name|s
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|targ_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|ccbh
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|softc
operator|->
name|work_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|periph
operator|->
name|immediate_priority
operator|<=
name|periph
operator|->
name|pinfo
operator|.
name|priority
condition|)
block|{
name|start_ccb
operator|->
name|ccb_h
operator|.
name|ccb_type
operator|=
name|TARG_CCB_WAITING
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|periph
operator|->
name|ccb_list
argument_list|,
operator|&
name|start_ccb
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|sle
argument_list|)
expr_stmt|;
name|periph
operator|->
name|immediate_priority
operator|=
name|CAM_PRIORITY_NONE
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|periph
operator|->
name|ccb_list
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ccbh
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|start_ccb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|softc
operator|->
name|work_queue
argument_list|,
name|ccbh
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|softc
operator|->
name|pending_queue
argument_list|,
name|ccbh
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|atio
operator|=
operator|(
expr|struct
name|ccb_accept_tio
operator|*
operator|)
name|ccbh
expr_stmt|;
name|desc
operator|=
operator|(
expr|struct
name|targ_cmd_desc
operator|*
operator|)
name|atio
operator|->
name|ccb_h
operator|.
name|ccb_descr
expr_stmt|;
comment|/* Is this a tagged request? */
name|flags
operator|=
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
operator|(
name|CAM_TAG_ACTION_VALID
operator||
name|CAM_DIR_MASK
operator|)
expr_stmt|;
comment|/* 		 * If we are done with the transaction, tell the 		 * controller to send status and perform a CMD_CMPLT. 		 */
if|if
condition|(
name|desc
operator|->
name|data_resid
operator|==
name|desc
operator|->
name|data_increment
condition|)
name|flags
operator||=
name|CAM_SEND_STATUS
expr_stmt|;
name|csio
operator|=
operator|&
name|start_ccb
operator|->
name|csio
expr_stmt|;
name|cam_fill_ctio
argument_list|(
name|csio
argument_list|,
comment|/*retries*/
literal|2
argument_list|,
name|targdone
argument_list|,
name|flags
argument_list|,
comment|/*tag_action*/
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|atio
operator|->
name|tag_id
argument_list|,
name|atio
operator|->
name|init_id
argument_list|,
name|desc
operator|->
name|status
argument_list|,
comment|/*data_ptr*/
name|desc
operator|->
name|data_increment
operator|==
literal|0
condition|?
name|NULL
else|:
name|desc
operator|->
name|data
argument_list|,
comment|/*dxfer_len*/
name|desc
operator|->
name|data_increment
argument_list|,
comment|/*timeout*/
name|desc
operator|->
name|timeout
argument_list|)
expr_stmt|;
name|start_ccb
operator|->
name|ccb_h
operator|.
name|ccb_type
operator|=
name|TARG_CCB_WORKQ
expr_stmt|;
name|start_ccb
operator|->
name|ccb_h
operator|.
name|ccb_atio
operator|=
name|atio
expr_stmt|;
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Sending a CTIO\n"
argument_list|)
expr_stmt|;
name|xpt_action
argument_list|(
name|start_ccb
argument_list|)
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|ccbh
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|softc
operator|->
name|work_queue
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ccbh
operator|!=
name|NULL
condition|)
name|targrunqueue
argument_list|(
name|periph
argument_list|,
name|softc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|targdone
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|done_ccb
parameter_list|)
block|{
name|struct
name|targ_softc
modifier|*
name|softc
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|targ_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|ccb_type
operator|==
name|TARG_CCB_WAITING
condition|)
block|{
comment|/* Caller will release the CCB */
name|wakeup
argument_list|(
operator|&
name|done_ccb
operator|->
name|ccb_h
operator|.
name|cbfcnp
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_ACCEPT_TARGET_IO
case|:
block|{
name|struct
name|ccb_accept_tio
modifier|*
name|atio
decl_stmt|;
name|struct
name|targ_cmd_desc
modifier|*
name|descr
decl_stmt|;
name|struct
name|initiator_state
modifier|*
name|istate
decl_stmt|;
name|u_int8_t
modifier|*
name|cdb
decl_stmt|;
name|atio
operator|=
operator|&
name|done_ccb
operator|->
name|atio
expr_stmt|;
name|descr
operator|=
operator|(
expr|struct
name|targ_cmd_desc
operator|*
operator|)
name|atio
operator|->
name|ccb_h
operator|.
name|ccb_descr
expr_stmt|;
name|istate
operator|=
operator|&
name|softc
operator|->
name|istate
index|[
name|atio
operator|->
name|init_id
index|]
expr_stmt|;
name|cdb
operator|=
name|atio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|state
operator|==
name|TARG_STATE_TEARDOWN
condition|)
block|{
name|freedescr
argument_list|(
name|descr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|done_ccb
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|istate
operator|->
name|pending_ca
operator|==
literal|0
operator|&&
name|istate
operator|->
name|pending_ua
operator|!=
literal|0
operator|&&
name|cdb
index|[
literal|0
index|]
operator|!=
name|INQUIRY
condition|)
block|{
comment|/* Pending UA, tell initiator */
comment|/* Direction is always relative to the initator */
name|istate
operator|->
name|pending_ca
operator|=
name|CA_UNIT_ATTN
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator|&=
operator|~
name|CAM_DIR_MASK
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DIR_NONE
expr_stmt|;
name|descr
operator|->
name|data_resid
operator|=
literal|0
expr_stmt|;
name|descr
operator|->
name|data_increment
operator|=
literal|0
expr_stmt|;
name|descr
operator|->
name|timeout
operator|=
literal|5
operator|*
literal|1000
expr_stmt|;
name|descr
operator|->
name|status
operator|=
name|SCSI_STATUS_CHECK_COND
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Save the current CA and UA status so 			 * they can be used by this command. 			 */
name|ua_types
name|pending_ua
decl_stmt|;
name|ca_types
name|pending_ca
decl_stmt|;
name|pending_ua
operator|=
name|istate
operator|->
name|pending_ua
expr_stmt|;
name|pending_ca
operator|=
name|istate
operator|->
name|pending_ca
expr_stmt|;
comment|/* 			 * As per the SCSI2 spec, any command that occurs 			 * after a CA is reported, clears the CA.  If the 			 * command is not an inquiry, we are also supposed 			 * to clear the UA condition, if any, that caused 			 * the CA to occur assuming the UA is not a 			 * persistant state. 			 */
name|istate
operator|->
name|pending_ca
operator|=
name|CA_NONE
expr_stmt|;
if|if
condition|(
operator|(
name|pending_ca
operator|&
operator|(
name|CA_CMD_SENSE
operator||
name|CA_UNIT_ATTN
operator|)
operator|)
operator|==
name|CA_UNIT_ATTN
operator|&&
name|cdb
index|[
literal|0
index|]
operator|!=
name|INQUIRY
condition|)
name|istate
operator|->
name|pending_ua
operator|=
name|UA_NONE
expr_stmt|;
comment|/* 			 * Determine the type of incoming command and 			 * setup our buffer for a response. 			 */
switch|switch
condition|(
name|cdb
index|[
literal|0
index|]
condition|)
block|{
case|case
name|INQUIRY
case|:
block|{
name|struct
name|scsi_inquiry
modifier|*
name|inq
decl_stmt|;
name|struct
name|scsi_sense_data
modifier|*
name|sense
decl_stmt|;
name|inq
operator|=
operator|(
expr|struct
name|scsi_inquiry
operator|*
operator|)
name|cdb
expr_stmt|;
name|sense
operator|=
operator|&
name|istate
operator|->
name|sense_data
expr_stmt|;
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Saw an inquiry!\n"
argument_list|)
expr_stmt|;
comment|/* 				 * Validate the command.  We don't 				 * support any VPD pages, so complain 				 * if EVPD is set. 				 */
if|if
condition|(
operator|(
name|inq
operator|->
name|byte2
operator|&
name|SI_EVPD
operator|)
operator|!=
literal|0
operator|||
name|inq
operator|->
name|page_code
operator|!=
literal|0
condition|)
block|{
name|istate
operator|->
name|pending_ca
operator|=
name|CA_CMD_SENSE
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator|&=
operator|~
name|CAM_DIR_MASK
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DIR_NONE
expr_stmt|;
name|descr
operator|->
name|data_resid
operator|=
literal|0
expr_stmt|;
name|descr
operator|->
name|data_increment
operator|=
literal|0
expr_stmt|;
name|descr
operator|->
name|status
operator|=
name|SCSI_STATUS_CHECK_COND
expr_stmt|;
name|fill_sense
argument_list|(
name|sense
argument_list|,
name|SSD_CURRENT_ERROR
argument_list|,
name|SSD_KEY_ILLEGAL_REQUEST
argument_list|,
comment|/*asc*/
literal|0x24
argument_list|,
comment|/*ascq*/
literal|0x00
argument_list|)
expr_stmt|;
name|sense
operator|->
name|extra_len
operator|=
name|offsetof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|,
name|extra_bytes
argument_list|)
operator|-
name|offsetof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|,
name|extra_len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|inq
operator|->
name|byte2
operator|&
name|SI_EVPD
operator|)
operator|!=
literal|0
condition|)
block|{
name|sense
operator|->
name|sense_key_spec
index|[
literal|0
index|]
operator|=
name|SSD_SCS_VALID
operator||
name|SSD_FIELDPTR_CMD
operator||
name|SSD_BITPTR_VALID
operator||
comment|/*bit value*/
literal|1
expr_stmt|;
name|sense
operator|->
name|sense_key_spec
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|sense
operator|->
name|sense_key_spec
index|[
literal|2
index|]
operator|=
name|offsetof
argument_list|(
expr|struct
name|scsi_inquiry
argument_list|,
name|byte2
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|inq
operator|->
name|page_code
operator|!=
literal|0
condition|)
block|{
name|sense
operator|->
name|sense_key_spec
index|[
literal|0
index|]
operator|=
name|SSD_SCS_VALID
operator||
name|SSD_FIELDPTR_CMD
expr_stmt|;
name|sense
operator|->
name|sense_key_spec
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|sense
operator|->
name|sense_key_spec
index|[
literal|2
index|]
operator|=
name|offsetof
argument_list|(
expr|struct
name|scsi_inquiry
argument_list|,
name|page_code
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 				 * Direction is always relative 				 * to the initator. 				 */
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator|&=
operator|~
name|CAM_DIR_MASK
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DIR_IN
expr_stmt|;
name|descr
operator|->
name|data
operator|=
name|softc
operator|->
name|inq_data
expr_stmt|;
name|descr
operator|->
name|data_resid
operator|=
name|MIN
argument_list|(
name|softc
operator|->
name|inq_data_len
argument_list|,
name|inq
operator|->
name|length
argument_list|)
expr_stmt|;
name|descr
operator|->
name|data_increment
operator|=
name|descr
operator|->
name|data_resid
expr_stmt|;
name|descr
operator|->
name|timeout
operator|=
literal|5
operator|*
literal|1000
expr_stmt|;
name|descr
operator|->
name|status
operator|=
name|SCSI_STATUS_OK
expr_stmt|;
break|break;
block|}
case|case
name|TEST_UNIT_READY
case|:
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator|&=
operator|~
name|CAM_DIR_MASK
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DIR_NONE
expr_stmt|;
name|descr
operator|->
name|data_resid
operator|=
literal|0
expr_stmt|;
name|descr
operator|->
name|data_increment
operator|=
literal|0
expr_stmt|;
name|descr
operator|->
name|status
operator|=
name|SCSI_STATUS_OK
expr_stmt|;
break|break;
case|case
name|REQUEST_SENSE
case|:
block|{
name|struct
name|scsi_request_sense
modifier|*
name|rsense
decl_stmt|;
name|struct
name|scsi_sense_data
modifier|*
name|sense
decl_stmt|;
name|rsense
operator|=
operator|(
expr|struct
name|scsi_request_sense
operator|*
operator|)
name|cdb
expr_stmt|;
name|sense
operator|=
operator|&
name|istate
operator|->
name|sense_data
expr_stmt|;
if|if
condition|(
name|pending_ca
operator|==
literal|0
condition|)
block|{
name|fill_sense
argument_list|(
name|sense
argument_list|,
name|SSD_CURRENT_ERROR
argument_list|,
name|SSD_KEY_NO_SENSE
argument_list|,
literal|0x00
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"No pending CA!\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pending_ca
operator|==
name|CA_UNIT_ATTN
condition|)
block|{
name|u_int
name|ascq
decl_stmt|;
if|if
condition|(
name|pending_ua
operator|==
name|UA_POWER_ON
condition|)
name|ascq
operator|=
literal|0x1
expr_stmt|;
else|else
name|ascq
operator|=
literal|0x2
expr_stmt|;
name|fill_sense
argument_list|(
name|sense
argument_list|,
name|SSD_CURRENT_ERROR
argument_list|,
name|SSD_KEY_UNIT_ATTENTION
argument_list|,
literal|0x29
argument_list|,
name|ascq
argument_list|)
expr_stmt|;
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Pending UA!\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * Direction is always relative 				 * to the initator. 				 */
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator|&=
operator|~
name|CAM_DIR_MASK
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DIR_IN
expr_stmt|;
name|descr
operator|->
name|data
operator|=
name|sense
expr_stmt|;
name|descr
operator|->
name|data_resid
operator|=
name|offsetof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|,
name|extra_len
argument_list|)
operator|+
name|sense
operator|->
name|extra_len
expr_stmt|;
name|descr
operator|->
name|data_resid
operator|=
name|MIN
argument_list|(
name|descr
operator|->
name|data_resid
argument_list|,
name|rsense
operator|->
name|length
argument_list|)
expr_stmt|;
name|descr
operator|->
name|data_increment
operator|=
name|descr
operator|->
name|data_resid
expr_stmt|;
name|descr
operator|->
name|timeout
operator|=
literal|5
operator|*
literal|1000
expr_stmt|;
name|descr
operator|->
name|status
operator|=
name|SCSI_STATUS_OK
expr_stmt|;
break|break;
block|}
case|case
name|RECEIVE
case|:
case|case
name|SEND
case|:
block|{
name|struct
name|scsi_send_receive
modifier|*
name|sr
decl_stmt|;
name|sr
operator|=
operator|(
expr|struct
name|scsi_send_receive
operator|*
operator|)
name|cdb
expr_stmt|;
comment|/* 				 * Direction is always relative 				 * to the initator. 				 */
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator|&=
operator|~
name|CAM_DIR_MASK
expr_stmt|;
if|if
condition|(
name|cdb
index|[
literal|0
index|]
operator|==
name|SEND
condition|)
block|{
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DIR_OUT
expr_stmt|;
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Saw a SEND!\n"
argument_list|)
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DIR_OUT
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|softc
operator|->
name|snd_ccb_queue
argument_list|,
operator|&
name|atio
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|selwakeup
argument_list|(
operator|&
name|softc
operator|->
name|snd_select
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DIR_IN
expr_stmt|;
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Saw a RECEIVE!\n"
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|softc
operator|->
name|rcv_ccb_queue
argument_list|,
operator|&
name|atio
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|selwakeup
argument_list|(
operator|&
name|softc
operator|->
name|rcv_select
argument_list|)
expr_stmt|;
block|}
name|descr
operator|->
name|data_resid
operator|=
name|scsi_3btoul
argument_list|(
name|sr
operator|->
name|xfer_len
argument_list|)
expr_stmt|;
name|descr
operator|->
name|timeout
operator|=
literal|5
operator|*
literal|1000
expr_stmt|;
name|descr
operator|->
name|status
operator|=
name|SCSI_STATUS_OK
expr_stmt|;
comment|/* 				 * Attempt to satisfy this request with 				 * a user buffer. 				 */
name|targrunqueue
argument_list|(
name|periph
argument_list|,
name|softc
argument_list|)
expr_stmt|;
return|return;
block|}
default|default:
comment|/* 				 * Queue for consumption by our userland 				 * counterpart and  transition to the exception 				 * state. 				 */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|softc
operator|->
name|unknown_atio_queue
argument_list|,
operator|&
name|atio
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|softc
operator|->
name|exceptions
operator||=
name|TARG_EXCEPT_UNKNOWN_ATIO
expr_stmt|;
name|targfireexception
argument_list|(
name|periph
argument_list|,
name|softc
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Queue us up to receive a Continue Target I/O ccb. */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|softc
operator|->
name|work_queue
argument_list|,
operator|&
name|atio
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|xpt_schedule
argument_list|(
name|periph
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_CONT_TARGET_IO
case|:
block|{
name|struct
name|ccb_accept_tio
modifier|*
name|atio
decl_stmt|;
name|struct
name|targ_cmd_desc
modifier|*
name|desc
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|xpt_print_path
argument_list|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Received completed CTIO\n"
argument_list|)
expr_stmt|;
name|atio
operator|=
operator|(
expr|struct
name|ccb_accept_tio
operator|*
operator|)
name|done_ccb
operator|->
name|ccb_h
operator|.
name|ccb_atio
expr_stmt|;
name|desc
operator|=
operator|(
expr|struct
name|targ_cmd_desc
operator|*
operator|)
name|atio
operator|->
name|ccb_h
operator|.
name|ccb_descr
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|softc
operator|->
name|pending_queue
argument_list|,
operator|&
name|atio
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
comment|/* XXX Check for errors */
name|desc
operator|->
name|data_resid
operator|-=
name|desc
operator|->
name|data_increment
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|=
name|desc
operator|->
name|bp
operator|)
operator|!=
name|NULL
condition|)
block|{
name|bp
operator|->
name|b_resid
operator|-=
name|desc
operator|->
name|data_increment
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
literal|0
expr_stmt|;
name|xpt_print_path
argument_list|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Buffer I/O Completed - Resid %d:%d\n"
argument_list|,
name|bp
operator|->
name|b_resid
argument_list|,
name|desc
operator|->
name|data_resid
argument_list|)
expr_stmt|;
comment|/* 			 * Send the buffer back to the client if 			 * either the command has completed or all 			 * buffer space has been consumed. 			 */
if|if
condition|(
name|desc
operator|->
name|data_resid
operator|==
literal|0
operator|||
name|bp
operator|->
name|b_resid
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_resid
operator|!=
literal|0
condition|)
comment|/* Short transfer */
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|xpt_print_path
argument_list|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Completing a buffer\n"
argument_list|)
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|desc
operator|->
name|bp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|xpt_release_ccb
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|state
operator|!=
name|TARG_STATE_TEARDOWN
condition|)
block|{
if|if
condition|(
name|desc
operator|->
name|data_resid
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Send the original accept TIO back to the 				 * controller to handle more work. 				 */
name|xpt_print_path
argument_list|(
name|atio
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Returning ATIO to target\n"
argument_list|)
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|atio
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|desc
operator|->
name|bp
operator|!=
name|NULL
condition|)
name|panic
argument_list|(
literal|"targ%d: desc->bp should be NULL"
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|)
expr_stmt|;
comment|/* Queue us up for another buffer */
if|if
condition|(
name|atio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
operator|==
name|SEND
condition|)
block|{
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|softc
operator|->
name|snd_ccb_queue
argument_list|,
operator|&
name|atio
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|softc
operator|->
name|rcv_ccb_queue
argument_list|,
operator|&
name|atio
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
block|}
name|desc
operator|->
name|bp
operator|=
name|NULL
expr_stmt|;
name|targrunqueue
argument_list|(
name|periph
argument_list|,
name|softc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|desc
operator|->
name|bp
operator|!=
name|NULL
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|ENXIO
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
name|freedescr
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|atio
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|XPT_IMMED_NOTIFY
case|:
block|{
if|if
condition|(
name|softc
operator|->
name|state
operator|==
name|TARG_STATE_TEARDOWN
condition|)
block|{
name|free
argument_list|(
name|done_ccb
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Transition to the exception state and notify our symbiotic  * userland process of the change.  */
end_comment

begin_function
specifier|static
name|void
name|targfireexception
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|targ_softc
modifier|*
name|softc
parameter_list|)
block|{
comment|/* 	 * return all pending buffers with short read/write status so our 	 * process unblocks, and do a selwakeup on any process queued 	 * waiting for reads or writes.  When the selwakeup is performed, 	 * the waking process will wakeup, call our poll routine again, 	 * and pick up the exception. 	 */
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
name|softc
operator|->
name|state
operator|!=
name|TARG_STATE_NORMAL
condition|)
comment|/* Already either tearing down or in exception state */
return|return;
name|softc
operator|->
name|state
operator|=
name|TARG_STATE_EXCEPTION
expr_stmt|;
while|while
condition|(
operator|(
name|bp
operator|=
name|bufq_first
argument_list|(
operator|&
name|softc
operator|->
name|snd_buf_queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|bufq_remove
argument_list|(
operator|&
name|softc
operator|->
name|snd_buf_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|bp
operator|=
name|bufq_first
argument_list|(
operator|&
name|softc
operator|->
name|rcv_buf_queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|bufq_remove
argument_list|(
operator|&
name|softc
operator|->
name|snd_buf_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
name|selwakeup
argument_list|(
operator|&
name|softc
operator|->
name|snd_select
argument_list|)
expr_stmt|;
name|selwakeup
argument_list|(
operator|&
name|softc
operator|->
name|rcv_select
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|targerror
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|u_int32_t
name|cam_flags
parameter_list|,
name|u_int32_t
name|sense_flags
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|targ_cmd_desc
modifier|*
name|allocdescr
parameter_list|()
block|{
name|struct
name|targ_cmd_desc
modifier|*
name|descr
decl_stmt|;
comment|/* Allocate the targ_descr structure */
name|descr
operator|=
operator|(
expr|struct
name|targ_cmd_desc
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|descr
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|descr
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|bzero
argument_list|(
name|descr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|descr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allocate buffer backing store */
name|descr
operator|->
name|backing_store
operator|=
name|malloc
argument_list|(
name|MAX_BUF_SIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|descr
operator|->
name|backing_store
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|descr
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|descr
operator|->
name|max_size
operator|=
name|MAX_BUF_SIZE
expr_stmt|;
return|return
operator|(
name|descr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|freedescr
parameter_list|(
name|struct
name|targ_cmd_desc
modifier|*
name|descr
parameter_list|)
block|{
name|free
argument_list|(
name|descr
operator|->
name|data
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|descr
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fill_sense
parameter_list|(
name|struct
name|scsi_sense_data
modifier|*
name|sense
parameter_list|,
name|u_int
name|error_code
parameter_list|,
name|u_int
name|sense_key
parameter_list|,
name|u_int
name|asc
parameter_list|,
name|u_int
name|ascq
parameter_list|)
block|{
name|bzero
argument_list|(
name|sense
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sense
argument_list|)
argument_list|)
expr_stmt|;
name|sense
operator|->
name|error_code
operator|=
name|error_code
expr_stmt|;
name|sense
operator|->
name|flags
operator|=
name|sense_key
expr_stmt|;
name|sense
operator|->
name|add_sense_code
operator|=
name|asc
expr_stmt|;
name|sense
operator|->
name|add_sense_code_qual
operator|=
name|ascq
expr_stmt|;
name|sense
operator|->
name|extra_len
operator|=
name|offsetof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|,
name|fru
argument_list|)
operator|-
name|offsetof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|,
name|extra_len
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

