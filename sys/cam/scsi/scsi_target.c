begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Implementation of a simple Target Mode SCSI Proccessor Target driver for CAM.  *  * Copyright (c) 1998, 1999 Justin T. Gibbs.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_comment
comment|/* For offsetof */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/devicestat.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_comment
comment|/* For struct selinfo. */
end_comment

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_extend.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_queue.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_pt.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_targetio.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_typedef
typedef|typedef
enum|enum
block|{
name|TARG_STATE_NORMAL
block|,
name|TARG_STATE_EXCEPTION
block|,
name|TARG_STATE_TEARDOWN
block|}
name|targ_state
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|TARG_FLAG_NONE
init|=
literal|0x00
block|,
name|TARG_FLAG_SEND_EOF
init|=
literal|0x01
block|,
name|TARG_FLAG_RECEIVE_EOF
init|=
literal|0x02
block|,
name|TARG_FLAG_LUN_ENABLED
init|=
literal|0x04
block|}
name|targ_flags
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|TARG_CCB_NONE
init|=
literal|0x00
block|,
name|TARG_CCB_WAITING
init|=
literal|0x01
block|,
name|TARG_CCB_HELDQ
init|=
literal|0x02
block|,
name|TARG_CCB_ABORT_TO_HELDQ
init|=
literal|0x04
block|}
name|targ_ccb_flags
typedef|;
end_typedef

begin_define
define|#
directive|define
name|MAX_ACCEPT
value|16
end_define

begin_define
define|#
directive|define
name|MAX_IMMEDIATE
value|16
end_define

begin_define
define|#
directive|define
name|MAX_BUF_SIZE
value|256
end_define

begin_comment
comment|/* Max inquiry/sense/mode page transfer */
end_comment

begin_define
define|#
directive|define
name|MAX_INITIATORS
value|256
end_define

begin_comment
comment|/* includes widest fibre channel for now */
end_comment

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a> b) ? b : a)
end_define

begin_define
define|#
directive|define
name|TARG_CONTROL_UNIT
value|0xffff00ff
end_define

begin_define
define|#
directive|define
name|TARG_IS_CONTROL_DEV
parameter_list|(
name|unit
parameter_list|)
value|((unit) == TARG_CONTROL_UNIT)
end_define

begin_define
define|#
directive|define
name|TARG_TAG_WILDCARD
value|((u_int)~0)
end_define

begin_comment
comment|/* Offsets into our private CCB area for storing accept information */
end_comment

begin_define
define|#
directive|define
name|ccb_flags
value|ppriv_field0
end_define

begin_define
define|#
directive|define
name|ccb_descr
value|ppriv_ptr1
end_define

begin_comment
comment|/* We stick a pointer to the originating accept TIO in each continue I/O CCB */
end_comment

begin_define
define|#
directive|define
name|ccb_atio
value|ppriv_ptr1
end_define

begin_struct
struct|struct
name|targ_softc
block|{
comment|/* CTIOs pending on the controller */
name|struct
name|ccb_queue
name|pending_queue
decl_stmt|;
comment|/* ATIOs awaiting CTIO resources from the XPT */
name|struct
name|ccb_queue
name|work_queue
decl_stmt|;
comment|/* 	 * ATIOs for SEND operations waiting for 'write' 	 * buffer resources from our userland daemon. 	 */
name|struct
name|ccb_queue
name|snd_ccb_queue
decl_stmt|;
comment|/* 	 * ATIOs for RCV operations waiting for 'read' 	 * buffer resources from our userland daemon. 	 */
name|struct
name|ccb_queue
name|rcv_ccb_queue
decl_stmt|;
comment|/* 	 * ATIOs for commands unknown to the kernel driver. 	 * These are queued for the userland daemon to 	 * consume. 	 */
name|struct
name|ccb_queue
name|unknown_atio_queue
decl_stmt|;
comment|/* 	 * Userland buffers for SEND commands waiting for 	 * SEND ATIOs to be queued by an initiator. 	 */
name|struct
name|bio_queue_head
name|snd_bio_queue
decl_stmt|;
comment|/* 	 * Userland buffers for RCV commands waiting for 	 * RCV ATIOs to be queued by an initiator. 	 */
name|struct
name|bio_queue_head
name|rcv_bio_queue
decl_stmt|;
name|struct
name|devstat
name|device_stats
decl_stmt|;
name|dev_t
name|targ_dev
decl_stmt|;
name|struct
name|selinfo
name|snd_select
decl_stmt|;
name|struct
name|selinfo
name|rcv_select
decl_stmt|;
name|targ_state
name|state
decl_stmt|;
name|targ_flags
name|flags
decl_stmt|;
name|targ_exception
name|exceptions
decl_stmt|;
name|u_int
name|init_level
decl_stmt|;
name|u_int
name|inq_data_len
decl_stmt|;
name|struct
name|scsi_inquiry_data
modifier|*
name|inq_data
decl_stmt|;
name|struct
name|ccb_accept_tio
modifier|*
name|accept_tio_list
decl_stmt|;
name|struct
name|ccb_hdr_slist
name|immed_notify_slist
decl_stmt|;
name|struct
name|initiator_state
name|istate
index|[
name|MAX_INITIATORS
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|targ_cmd_desc
block|{
name|struct
name|ccb_accept_tio
modifier|*
name|atio_link
decl_stmt|;
name|u_int
name|data_resid
decl_stmt|;
comment|/* How much left to transfer */
name|u_int
name|data_increment
decl_stmt|;
comment|/* Amount to send before next disconnect */
name|void
modifier|*
name|data
decl_stmt|;
comment|/* The data. Can be from backing_store or not */
name|void
modifier|*
name|backing_store
decl_stmt|;
comment|/* Backing store allocated for this descriptor*/
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
comment|/* Buffer for this transfer */
name|u_int
name|max_size
decl_stmt|;
comment|/* Size of backing_store */
name|u_int32_t
name|timeout
decl_stmt|;
name|u_int8_t
name|status
decl_stmt|;
comment|/* Status to return to initiator */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|d_open_t
name|targopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|targclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|targread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|targwrite
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|targioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_poll_t
name|targpoll
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_strategy_t
name|targstrategy
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TARG_CDEV_MAJOR
value|65
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|targ_cdevsw
init|=
block|{
comment|/* open */
name|targopen
block|,
comment|/* close */
name|targclose
block|,
comment|/* read */
name|targread
block|,
comment|/* write */
name|targwrite
block|,
comment|/* ioctl */
name|targioctl
block|,
comment|/* poll */
name|targpoll
block|,
comment|/* mmap */
name|nommap
block|,
comment|/* strategy */
name|targstrategy
block|,
comment|/* name */
literal|"targ"
block|,
comment|/* maj */
name|TARG_CDEV_MAJOR
block|,
comment|/* dump */
name|nodump
block|,
comment|/* psize */
name|nopsize
block|,
comment|/* flags */
literal|0
block|,
comment|/* bmaj */
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|targsendccb
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|union
name|ccb
modifier|*
name|inccb
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|periph_init_t
name|targinit
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|targasync
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|u_int32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|targallocinstance
parameter_list|(
name|struct
name|ioc_alloc_unit
modifier|*
name|alloc_unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|targfreeinstance
parameter_list|(
name|struct
name|ioc_alloc_unit
modifier|*
name|alloc_unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cam_status
name|targenlun
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cam_status
name|targdislun
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|periph_ctor_t
name|targctor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_dtor_t
name|targdtor
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|targrunqueue
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|targ_softc
modifier|*
name|softc
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|periph_start_t
name|targstart
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|targdone
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|done_ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|targfireexception
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|targ_softc
modifier|*
name|softc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|targinoterror
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|targ_softc
modifier|*
name|softc
parameter_list|,
name|struct
name|ccb_immed_notify
modifier|*
name|inot
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|targerror
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|u_int32_t
name|cam_flags
parameter_list|,
name|u_int32_t
name|sense_flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|targ_cmd_desc
modifier|*
name|allocdescr
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|freedescr
parameter_list|(
name|struct
name|targ_cmd_desc
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fill_sense
parameter_list|(
name|struct
name|targ_softc
modifier|*
name|softc
parameter_list|,
name|u_int
name|initiator_id
parameter_list|,
name|u_int
name|error_code
parameter_list|,
name|u_int
name|sense_key
parameter_list|,
name|u_int
name|asc
parameter_list|,
name|u_int
name|ascq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|copy_sense
parameter_list|(
name|struct
name|targ_softc
modifier|*
name|softc
parameter_list|,
name|struct
name|initiator_state
modifier|*
name|istate
parameter_list|,
name|u_int8_t
modifier|*
name|sense_buffer
parameter_list|,
name|size_t
name|sense_len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_unit_attention_cond
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|u_int
name|initiator_id
parameter_list|,
name|ua_types
name|ua
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_ca_condition
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|u_int
name|initiator_id
parameter_list|,
name|ca_types
name|ca
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|abort_pending_transactions
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|u_int
name|initiator_id
parameter_list|,
name|u_int
name|tag_id
parameter_list|,
name|int
name|errno
parameter_list|,
name|int
name|to_held_queue
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|periph_driver
name|targdriver
init|=
block|{
name|targinit
block|,
literal|"targ"
block|,
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|targdriver
operator|.
name|units
argument_list|)
block|,
comment|/* generation */
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DATA_SET
argument_list|(
name|periphdriver_set
argument_list|,
name|targdriver
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|extend_array
modifier|*
name|targperiphs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dev_t
name|targ_ctl_dev
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|targinit
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * Create our extend array for storing the devices we attach to. 	 */
name|targperiphs
operator|=
name|cam_extend_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|targperiphs
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"targ: Failed to alloc extend array!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|targ_ctl_dev
operator|=
name|make_dev
argument_list|(
operator|&
name|targ_cdevsw
argument_list|,
name|TARG_CONTROL_UNIT
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0600
argument_list|,
literal|"%s.ctl"
argument_list|,
literal|"targ"
argument_list|)
expr_stmt|;
if|if
condition|(
name|targ_ctl_dev
operator|==
operator|(
name|dev_t
operator|)
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"targ: failed to create control dev\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|targasync
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|u_int32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|targ_softc
modifier|*
name|softc
decl_stmt|;
name|periph
operator|=
operator|(
expr|struct
name|cam_periph
operator|*
operator|)
name|callback_arg
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|targ_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|AC_PATH_DEREGISTERED
case|:
block|{
comment|/* XXX Implement */
break|break;
block|}
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Attempt to enable our lun */
end_comment

begin_function
specifier|static
name|cam_status
name|targenlun
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|union
name|ccb
name|immed_ccb
decl_stmt|;
name|struct
name|targ_softc
modifier|*
name|softc
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|int
name|i
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|targ_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|TARG_FLAG_LUN_ENABLED
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|CAM_REQ_CMP
operator|)
return|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|immed_ccb
operator|.
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|immed_ccb
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_EN_LUN
expr_stmt|;
comment|/* Don't need support for any vendor specific commands */
name|immed_ccb
operator|.
name|cel
operator|.
name|grp6_len
operator|=
literal|0
expr_stmt|;
name|immed_ccb
operator|.
name|cel
operator|.
name|grp7_len
operator|=
literal|0
expr_stmt|;
name|immed_ccb
operator|.
name|cel
operator|.
name|enable
operator|=
literal|1
expr_stmt|;
name|xpt_action
argument_list|(
operator|&
name|immed_ccb
argument_list|)
expr_stmt|;
name|status
operator|=
name|immed_ccb
operator|.
name|ccb_h
operator|.
name|status
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"targenlun - Enable Lun Rejected with status 0x%x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
name|softc
operator|->
name|flags
operator||=
name|TARG_FLAG_LUN_ENABLED
expr_stmt|;
comment|/* 	 * Build up a buffer of accept target I/O 	 * operations for incoming selections. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_ACCEPT
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ccb_accept_tio
modifier|*
name|atio
decl_stmt|;
name|atio
operator|=
operator|(
expr|struct
name|ccb_accept_tio
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|atio
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|atio
operator|==
name|NULL
condition|)
block|{
name|status
operator|=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
break|break;
block|}
name|atio
operator|->
name|ccb_h
operator|.
name|ccb_descr
operator|=
name|allocdescr
argument_list|()
expr_stmt|;
if|if
condition|(
name|atio
operator|->
name|ccb_h
operator|.
name|ccb_descr
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|atio
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|status
operator|=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
break|break;
block|}
name|xpt_setup_ccb
argument_list|(
operator|&
name|atio
operator|->
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_ACCEPT_TARGET_IO
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|cbfcnp
operator|=
name|targdone
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|ccb_flags
operator|=
name|TARG_CCB_NONE
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|atio
argument_list|)
expr_stmt|;
name|status
operator|=
name|atio
operator|->
name|ccb_h
operator|.
name|status
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_INPROG
condition|)
block|{
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Queue of atio failed\n"
argument_list|)
expr_stmt|;
name|freedescr
argument_list|(
name|atio
operator|->
name|ccb_h
operator|.
name|ccb_descr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|atio
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
break|break;
block|}
operator|(
operator|(
expr|struct
name|targ_cmd_desc
operator|*
operator|)
name|atio
operator|->
name|ccb_h
operator|.
name|ccb_descr
operator|)
operator|->
name|atio_link
operator|=
name|softc
operator|->
name|accept_tio_list
expr_stmt|;
name|softc
operator|->
name|accept_tio_list
operator|=
name|atio
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"targenlun - Could not allocate accept tio CCBs: "
literal|"status = 0x%x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|targdislun
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
comment|/* 	 * Build up a buffer of immediate notify CCBs 	 * so the SIM can tell us of asynchronous target mode events. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_ACCEPT
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ccb_immed_notify
modifier|*
name|inot
decl_stmt|;
name|inot
operator|=
operator|(
expr|struct
name|ccb_immed_notify
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|inot
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|inot
operator|==
name|NULL
condition|)
block|{
name|status
operator|=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
break|break;
block|}
name|xpt_setup_ccb
argument_list|(
operator|&
name|inot
operator|->
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|inot
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_IMMED_NOTIFY
expr_stmt|;
name|inot
operator|->
name|ccb_h
operator|.
name|cbfcnp
operator|=
name|targdone
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|softc
operator|->
name|immed_notify_slist
argument_list|,
operator|&
name|inot
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|sle
argument_list|)
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|inot
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"targenlun - Could not allocate immediate notify CCBs: "
literal|"status = 0x%x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|targdislun
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
return|return
operator|(
name|CAM_REQ_CMP
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|cam_status
name|targdislun
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|union
name|ccb
name|ccb
decl_stmt|;
name|struct
name|targ_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ccb_accept_tio
modifier|*
name|atio
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|targ_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|TARG_FLAG_LUN_ENABLED
operator|)
operator|==
literal|0
condition|)
return|return
name|CAM_REQ_CMP
return|;
comment|/* XXX Block for Continue I/O completion */
comment|/* Kill off all ACCECPT and IMMEDIATE CCBs */
while|while
condition|(
operator|(
name|atio
operator|=
name|softc
operator|->
name|accept_tio_list
operator|)
operator|!=
name|NULL
condition|)
block|{
name|softc
operator|->
name|accept_tio_list
operator|=
operator|(
operator|(
expr|struct
name|targ_cmd_desc
operator|*
operator|)
name|atio
operator|->
name|ccb_h
operator|.
name|ccb_descr
operator|)
operator|->
name|atio_link
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|ccb
operator|.
name|cab
operator|.
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|ccb
operator|.
name|cab
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_ABORT
expr_stmt|;
name|ccb
operator|.
name|cab
operator|.
name|abort_ccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|atio
expr_stmt|;
name|xpt_action
argument_list|(
operator|&
name|ccb
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|ccb_h
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|softc
operator|->
name|immed_notify_slist
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|softc
operator|->
name|immed_notify_slist
argument_list|,
name|periph_links
operator|.
name|sle
argument_list|)
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|ccb
operator|.
name|cab
operator|.
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|ccb
operator|.
name|cab
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_ABORT
expr_stmt|;
name|ccb
operator|.
name|cab
operator|.
name|abort_ccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|ccb_h
expr_stmt|;
name|xpt_action
argument_list|(
operator|&
name|ccb
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Dissable this lun. 	 */
name|xpt_setup_ccb
argument_list|(
operator|&
name|ccb
operator|.
name|cel
operator|.
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|ccb
operator|.
name|cel
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_EN_LUN
expr_stmt|;
name|ccb
operator|.
name|cel
operator|.
name|enable
operator|=
literal|0
expr_stmt|;
name|xpt_action
argument_list|(
operator|&
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|.
name|cel
operator|.
name|ccb_h
operator|.
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
name|printf
argument_list|(
literal|"targdislun - Disabling lun on controller failed "
literal|"with status 0x%x\n"
argument_list|,
name|ccb
operator|.
name|cel
operator|.
name|ccb_h
operator|.
name|status
argument_list|)
expr_stmt|;
else|else
name|softc
operator|->
name|flags
operator|&=
operator|~
name|TARG_FLAG_LUN_ENABLED
expr_stmt|;
return|return
operator|(
name|ccb
operator|.
name|cel
operator|.
name|ccb_h
operator|.
name|status
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|cam_status
name|targctor
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ccb_pathinq
modifier|*
name|cpi
decl_stmt|;
name|struct
name|targ_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|cpi
operator|=
operator|(
expr|struct
name|ccb_pathinq
operator|*
operator|)
name|arg
expr_stmt|;
comment|/* Allocate our per-instance private storage */
name|softc
operator|=
operator|(
expr|struct
name|targ_softc
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|softc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"targctor: unable to malloc softc\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
name|bzero
argument_list|(
name|softc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|softc
argument_list|)
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|softc
operator|->
name|pending_queue
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|softc
operator|->
name|work_queue
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|softc
operator|->
name|snd_ccb_queue
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|softc
operator|->
name|rcv_ccb_queue
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|softc
operator|->
name|unknown_atio_queue
argument_list|)
expr_stmt|;
name|bioq_init
argument_list|(
operator|&
name|softc
operator|->
name|snd_bio_queue
argument_list|)
expr_stmt|;
name|bioq_init
argument_list|(
operator|&
name|softc
operator|->
name|rcv_bio_queue
argument_list|)
expr_stmt|;
name|softc
operator|->
name|accept_tio_list
operator|=
name|NULL
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|softc
operator|->
name|immed_notify_slist
argument_list|)
expr_stmt|;
name|softc
operator|->
name|state
operator|=
name|TARG_STATE_NORMAL
expr_stmt|;
name|periph
operator|->
name|softc
operator|=
name|softc
expr_stmt|;
name|softc
operator|->
name|init_level
operator|++
expr_stmt|;
name|cam_extend_set
argument_list|(
name|targperiphs
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|,
name|periph
argument_list|)
expr_stmt|;
comment|/* 	 * We start out life with a UA to indicate power-on/reset. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_INITIATORS
condition|;
name|i
operator|++
control|)
name|softc
operator|->
name|istate
index|[
name|i
index|]
operator|.
name|pending_ua
operator|=
name|UA_POWER_ON
expr_stmt|;
comment|/* 	 * Allocate an initial inquiry data buffer.  We might allow the 	 * user to override this later via an ioctl. 	 */
name|softc
operator|->
name|inq_data_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|softc
operator|->
name|inq_data
argument_list|)
expr_stmt|;
name|softc
operator|->
name|inq_data
operator|=
name|malloc
argument_list|(
name|softc
operator|->
name|inq_data_len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|inq_data
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"targctor - Unable to malloc inquiry data\n"
argument_list|)
expr_stmt|;
name|targdtor
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_RESRC_UNAVAIL
operator|)
return|;
block|}
name|bzero
argument_list|(
name|softc
operator|->
name|inq_data
argument_list|,
name|softc
operator|->
name|inq_data_len
argument_list|)
expr_stmt|;
name|softc
operator|->
name|inq_data
operator|->
name|device
operator|=
name|T_PROCESSOR
operator||
operator|(
name|SID_QUAL_LU_CONNECTED
operator|<<
literal|5
operator|)
expr_stmt|;
name|softc
operator|->
name|inq_data
operator|->
name|version
operator|=
literal|2
expr_stmt|;
name|softc
operator|->
name|inq_data
operator|->
name|response_format
operator|=
literal|2
expr_stmt|;
comment|/* SCSI2 Inquiry Format */
name|softc
operator|->
name|inq_data
operator|->
name|flags
operator|=
name|cpi
operator|->
name|hba_inquiry
operator|&
operator|(
name|PI_SDTR_ABLE
operator||
name|PI_WIDE_16
operator||
name|PI_WIDE_32
operator||
name|PI_TAG_ABLE
operator|)
expr_stmt|;
name|softc
operator|->
name|inq_data
operator|->
name|additional_length
operator|=
name|softc
operator|->
name|inq_data_len
operator|-
literal|4
expr_stmt|;
name|strncpy
argument_list|(
name|softc
operator|->
name|inq_data
operator|->
name|vendor
argument_list|,
literal|"FreeBSD "
argument_list|,
name|SID_VENDOR_SIZE
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|softc
operator|->
name|inq_data
operator|->
name|product
argument_list|,
literal|"TM-PT           "
argument_list|,
name|SID_PRODUCT_SIZE
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|softc
operator|->
name|inq_data
operator|->
name|revision
argument_list|,
literal|"0.0 "
argument_list|,
name|SID_REVISION_SIZE
argument_list|)
expr_stmt|;
name|softc
operator|->
name|targ_dev
operator|=
name|make_dev
argument_list|(
operator|&
name|targ_cdevsw
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0600
argument_list|,
literal|"%s%d"
argument_list|,
name|periph
operator|->
name|periph_name
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|)
expr_stmt|;
name|softc
operator|->
name|init_level
operator|++
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|targdtor
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|struct
name|targ_softc
modifier|*
name|softc
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|targ_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|softc
operator|->
name|state
operator|=
name|TARG_STATE_TEARDOWN
expr_stmt|;
name|targdislun
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|cam_extend_release
argument_list|(
name|targperiphs
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|softc
operator|->
name|init_level
condition|)
block|{
default|default:
comment|/* FALLTHROUGH */
case|case
literal|2
case|:
name|free
argument_list|(
name|softc
operator|->
name|inq_data
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|destroy_dev
argument_list|(
name|softc
operator|->
name|targ_dev
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|1
case|:
name|free
argument_list|(
name|softc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|panic
argument_list|(
literal|"targdtor - impossible init level"
argument_list|)
expr_stmt|;
empty_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|targopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|targ_softc
modifier|*
name|softc
decl_stmt|;
name|u_int
name|unit
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|s
decl_stmt|;
name|unit
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* An open of the control device always succeeds */
if|if
condition|(
name|TARG_IS_CONTROL_DEV
argument_list|(
name|unit
argument_list|)
condition|)
return|return
literal|0
return|;
name|s
operator|=
name|splsoftcam
argument_list|()
expr_stmt|;
name|periph
operator|=
name|cam_extend_get
argument_list|(
name|targperiphs
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|cam_periph_lock
argument_list|(
name|periph
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|softc
operator|=
operator|(
expr|struct
name|targ_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|TARG_FLAG_LUN_ENABLED
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cam_periph_acquire
argument_list|(
name|periph
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|status
operator|=
name|targenlun
argument_list|(
name|periph
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|CAM_REQ_CMP
case|:
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CAM_RESRC_UNAVAIL
case|:
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
case|case
name|CAM_LUN_ALRDY_ENA
case|:
name|error
operator|=
name|EADDRINUSE
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|cam_periph_release
argument_list|(
name|periph
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|targclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|targ_softc
modifier|*
name|softc
decl_stmt|;
name|u_int
name|unit
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|error
decl_stmt|;
name|unit
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* A close of the control device always succeeds */
if|if
condition|(
name|TARG_IS_CONTROL_DEV
argument_list|(
name|unit
argument_list|)
condition|)
return|return
literal|0
return|;
name|s
operator|=
name|splsoftcam
argument_list|()
expr_stmt|;
name|periph
operator|=
name|cam_extend_get
argument_list|(
name|targperiphs
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|cam_periph_lock
argument_list|(
name|periph
argument_list|,
name|PRIBIO
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|softc
operator|=
operator|(
expr|struct
name|targ_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|targdislun
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|cam_periph_release
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|targallocinstance
parameter_list|(
name|struct
name|ioc_alloc_unit
modifier|*
name|alloc_unit
parameter_list|)
block|{
name|struct
name|ccb_pathinq
name|cpi
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|int
name|free_path_on_return
decl_stmt|;
name|int
name|error
decl_stmt|;
name|free_path_on_return
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|alloc_unit
operator|->
name|path_id
argument_list|,
name|alloc_unit
operator|->
name|target_id
argument_list|,
name|alloc_unit
operator|->
name|lun_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"Couldn't Allocate Path %x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|free_path_on_return
operator|++
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|cpi
operator|.
name|ccb_h
argument_list|,
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|cpi
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_PATH_INQ
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|cpi
argument_list|)
expr_stmt|;
name|status
operator|=
name|cpi
operator|.
name|ccb_h
operator|.
name|status
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"Couldn't CPI %x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Can only alloc units on controllers that support target mode */
if|if
condition|(
operator|(
name|cpi
operator|.
name|target_sprt
operator|&
name|PIT_PROCESSOR
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Controller does not support target mode%x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|status
operator|=
name|CAM_PATH_INVALID
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Ensure that we don't already have an instance for this unit. */
if|if
condition|(
operator|(
name|periph
operator|=
name|cam_periph_find
argument_list|(
name|path
argument_list|,
literal|"targ"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|status
operator|=
name|CAM_LUN_ALRDY_ENA
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 * Allocate a peripheral instance for 	 * this target instance. 	 */
name|status
operator|=
name|cam_periph_alloc
argument_list|(
name|targctor
argument_list|,
name|NULL
argument_list|,
name|targdtor
argument_list|,
name|targstart
argument_list|,
literal|"targ"
argument_list|,
name|CAM_PERIPH_BIO
argument_list|,
name|path
argument_list|,
name|targasync
argument_list|,
literal|0
argument_list|,
operator|&
name|cpi
argument_list|)
expr_stmt|;
name|fail
label|:
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|CAM_REQ_CMP
case|:
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
if|if
condition|(
operator|(
name|periph
operator|=
name|cam_periph_find
argument_list|(
name|path
argument_list|,
literal|"targ"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"targallocinstance: Succeeded but no periph?"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|alloc_unit
operator|->
name|unit
operator|=
name|periph
operator|->
name|unit_number
expr_stmt|;
break|break;
block|}
case|case
name|CAM_RESRC_UNAVAIL
case|:
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
case|case
name|CAM_LUN_ALRDY_ENA
case|:
name|error
operator|=
name|EADDRINUSE
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"targallocinstance: Unexpected CAM status %x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|CAM_PATH_INVALID
case|:
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
case|case
name|CAM_PROVIDE_FAIL
case|:
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|free_path_on_return
operator|!=
literal|0
condition|)
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|targfreeinstance
parameter_list|(
name|struct
name|ioc_alloc_unit
modifier|*
name|alloc_unit
parameter_list|)
block|{
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|targ_softc
modifier|*
name|softc
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|int
name|free_path_on_return
decl_stmt|;
name|int
name|error
decl_stmt|;
name|periph
operator|=
name|NULL
expr_stmt|;
name|free_path_on_return
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|alloc_unit
operator|->
name|path_id
argument_list|,
name|alloc_unit
operator|->
name|target_id
argument_list|,
name|alloc_unit
operator|->
name|lun_id
argument_list|)
expr_stmt|;
name|free_path_on_return
operator|++
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
goto|goto
name|fail
goto|;
comment|/* Find our instance. */
if|if
condition|(
operator|(
name|periph
operator|=
name|cam_periph_find
argument_list|(
name|path
argument_list|,
literal|"targ"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|xpt_print_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Invalid path specified for freeing target instance\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|CAM_PATH_INVALID
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|softc
operator|=
operator|(
expr|struct
name|targ_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|TARG_FLAG_LUN_ENABLED
operator|)
operator|!=
literal|0
condition|)
block|{
name|status
operator|=
name|CAM_BUSY
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|fail
label|:
if|if
condition|(
name|free_path_on_return
operator|!=
literal|0
condition|)
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|CAM_REQ_CMP
case|:
if|if
condition|(
name|periph
operator|!=
name|NULL
condition|)
name|cam_periph_invalidate
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CAM_RESRC_UNAVAIL
case|:
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
case|case
name|CAM_LUN_ALRDY_ENA
case|:
name|error
operator|=
name|EADDRINUSE
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"targfreeinstance: Unexpected CAM status %x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|CAM_PATH_INVALID
case|:
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|targioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|targ_softc
modifier|*
name|softc
decl_stmt|;
name|u_int
name|unit
decl_stmt|;
name|int
name|error
decl_stmt|;
name|unit
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TARG_IS_CONTROL_DEV
argument_list|(
name|unit
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|TARGCTLIOALLOCUNIT
case|:
name|error
operator|=
name|targallocinstance
argument_list|(
operator|(
expr|struct
name|ioc_alloc_unit
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|TARGCTLIOFREEUNIT
case|:
name|error
operator|=
name|targfreeinstance
argument_list|(
operator|(
expr|struct
name|ioc_alloc_unit
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
name|periph
operator|=
name|cam_extend_get
argument_list|(
name|targperiphs
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|softc
operator|=
operator|(
expr|struct
name|targ_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|TARGIOCFETCHEXCEPTION
case|:
operator|*
operator|(
operator|(
name|targ_exception
operator|*
operator|)
name|addr
operator|)
operator|=
name|softc
operator|->
name|exceptions
expr_stmt|;
break|break;
case|case
name|TARGIOCCLEAREXCEPTION
case|:
block|{
name|targ_exception
name|clear_mask
decl_stmt|;
name|clear_mask
operator|=
operator|*
operator|(
operator|(
name|targ_exception
operator|*
operator|)
name|addr
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|clear_mask
operator|&
name|TARG_EXCEPT_UNKNOWN_ATIO
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|ccbh
decl_stmt|;
name|ccbh
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|softc
operator|->
name|unknown_atio_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccbh
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|softc
operator|->
name|unknown_atio_queue
argument_list|,
name|ccbh
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
comment|/* Requeue the ATIO back to the controller */
name|ccbh
operator|->
name|ccb_flags
operator|=
name|TARG_CCB_NONE
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|ccbh
argument_list|)
expr_stmt|;
name|ccbh
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|softc
operator|->
name|unknown_atio_queue
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ccbh
operator|!=
name|NULL
condition|)
name|clear_mask
operator|&=
operator|~
name|TARG_EXCEPT_UNKNOWN_ATIO
expr_stmt|;
block|}
name|softc
operator|->
name|exceptions
operator|&=
operator|~
name|clear_mask
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|exceptions
operator|==
name|TARG_EXCEPT_NONE
operator|&&
name|softc
operator|->
name|state
operator|==
name|TARG_STATE_EXCEPTION
condition|)
block|{
name|softc
operator|->
name|state
operator|=
name|TARG_STATE_NORMAL
expr_stmt|;
name|targrunqueue
argument_list|(
name|periph
argument_list|,
name|softc
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|TARGIOCFETCHATIO
case|:
block|{
name|struct
name|ccb_hdr
modifier|*
name|ccbh
decl_stmt|;
name|ccbh
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|softc
operator|->
name|unknown_atio_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccbh
operator|!=
name|NULL
condition|)
block|{
name|bcopy
argument_list|(
name|ccbh
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_accept_tio
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
block|}
break|break;
block|}
case|case
name|TARGIOCCOMMAND
case|:
block|{
name|union
name|ccb
modifier|*
name|inccb
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
comment|/* 		 * XXX JGibbs 		 * This code is lifted directly from the pass-thru driver. 		 * Perhaps this should be moved to a library???? 		 */
name|inccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|addr
expr_stmt|;
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
name|inccb
operator|->
name|ccb_h
operator|.
name|pinfo
operator|.
name|priority
argument_list|)
expr_stmt|;
name|error
operator|=
name|targsendccb
argument_list|(
name|periph
argument_list|,
name|ccb
argument_list|,
name|inccb
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TARGIOCGETISTATE
case|:
case|case
name|TARGIOCSETISTATE
case|:
block|{
name|struct
name|ioc_initiator_state
modifier|*
name|ioc_istate
decl_stmt|;
name|ioc_istate
operator|=
operator|(
expr|struct
name|ioc_initiator_state
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|ioc_istate
operator|->
name|initiator_id
operator|>
name|MAX_INITIATORS
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_PERIPH
argument_list|,
operator|(
literal|"GET/SETISTATE for %d\n"
operator|,
name|ioc_istate
operator|->
name|initiator_id
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|TARGIOCGETISTATE
condition|)
block|{
name|bcopy
argument_list|(
operator|&
name|softc
operator|->
name|istate
index|[
name|ioc_istate
operator|->
name|initiator_id
index|]
argument_list|,
operator|&
name|ioc_istate
operator|->
name|istate
argument_list|,
sizeof|sizeof
argument_list|(
name|ioc_istate
operator|->
name|istate
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
operator|&
name|ioc_istate
operator|->
name|istate
argument_list|,
operator|&
name|softc
operator|->
name|istate
index|[
name|ioc_istate
operator|->
name|initiator_id
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|ioc_istate
operator|->
name|istate
argument_list|)
argument_list|)
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_PERIPH
argument_list|,
operator|(
literal|"pending_ca now %x\n"
operator|,
name|softc
operator|->
name|istate
index|[
name|ioc_istate
operator|->
name|initiator_id
index|]
operator|.
name|pending_ca
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
ifdef|#
directive|ifdef
name|CAMDEBUG
case|case
name|TARGIODEBUG
case|:
block|{
name|union
name|ccb
name|ccb
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|ccb
argument_list|,
sizeof|sizeof
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|ccb
operator|.
name|ccb_h
operator|.
name|path
argument_list|,
name|periph
argument_list|,
name|xpt_path_path_id
argument_list|(
name|periph
operator|->
name|path
argument_list|)
argument_list|,
name|xpt_path_target_id
argument_list|(
name|periph
operator|->
name|path
argument_list|)
argument_list|,
name|xpt_path_lun_id
argument_list|(
name|periph
operator|->
name|path
argument_list|)
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|addr
operator|)
condition|)
block|{
name|ccb
operator|.
name|cdbg
operator|.
name|flags
operator|=
name|CAM_DEBUG_PERIPH
expr_stmt|;
block|}
else|else
block|{
name|ccb
operator|.
name|cdbg
operator|.
name|flags
operator|=
name|CAM_DEBUG_NONE
expr_stmt|;
block|}
name|xpt_setup_ccb
argument_list|(
operator|&
name|ccb
operator|.
name|ccb_h
argument_list|,
name|ccb
operator|.
name|ccb_h
operator|.
name|path
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_DEBUG
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|path_id
operator|=
name|xpt_path_path_id
argument_list|(
name|ccb
operator|.
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|target_id
operator|=
name|xpt_path_target_id
argument_list|(
name|ccb
operator|.
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|target_lun
operator|=
name|xpt_path_lun_id
argument_list|(
name|ccb
operator|.
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|cbfcnp
operator|=
name|targdone
expr_stmt|;
name|xpt_action
argument_list|(
operator|&
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|.
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|error
operator|=
name|EIO
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
literal|0
expr_stmt|;
block|}
name|xpt_free_path
argument_list|(
name|ccb
operator|.
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
default|default:
name|error
operator|=
name|ENOTTY
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * XXX JGibbs lifted from pass-thru driver.  * Generally, "ccb" should be the CCB supplied by the kernel.  "inccb"  * should be the CCB that is copied in from the user.  */
end_comment

begin_function
specifier|static
name|int
name|targsendccb
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|union
name|ccb
modifier|*
name|inccb
parameter_list|)
block|{
name|struct
name|targ_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|cam_periph_map_info
name|mapinfo
decl_stmt|;
name|int
name|error
decl_stmt|,
name|need_unmap
decl_stmt|;
name|int
name|s
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|targ_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|need_unmap
operator|=
literal|0
expr_stmt|;
comment|/* 	 * There are some fields in the CCB header that need to be 	 * preserved, the rest we get from the user. 	 */
name|xpt_merge_ccb
argument_list|(
name|ccb
argument_list|,
name|inccb
argument_list|)
expr_stmt|;
comment|/* 	 * There's no way for the user to have a completion 	 * function, so we put our own completion function in here. 	 */
name|ccb
operator|->
name|ccb_h
operator|.
name|cbfcnp
operator|=
name|targdone
expr_stmt|;
comment|/* 	 * We only attempt to map the user memory into kernel space 	 * if they haven't passed in a physical memory pointer, 	 * and if there is actually an I/O operation to perform. 	 * Right now cam_periph_mapmem() only supports SCSI and device 	 * match CCBs.  For the SCSI CCBs, we only pass the CCB in if 	 * there's actually data to map.  cam_periph_mapmem() will do the 	 * right thing, even if there isn't data to map, but since CCBs 	 * without data are a reasonably common occurance (e.g. test unit 	 * ready), it will save a few cycles if we check for it here. 	 */
if|if
condition|(
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_CONT_TARGET_IO
operator|)
operator|&&
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
operator|)
operator|)
operator|||
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_DEV_MATCH
operator|)
operator|)
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|mapinfo
argument_list|,
sizeof|sizeof
argument_list|(
name|mapinfo
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|cam_periph_mapmem
argument_list|(
name|ccb
argument_list|,
operator|&
name|mapinfo
argument_list|)
expr_stmt|;
comment|/* 		 * cam_periph_mapmem returned an error, we can't continue. 		 * Return the error to the user. 		 */
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 		 * We successfully mapped the memory in, so we need to 		 * unmap it when the transaction is done. 		 */
name|need_unmap
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Once queued on the pending CCB list, this CCB will be protected 	 * by the error recovery handling used for 'buffer I/O' ccbs.  Since 	 * we are in a process context here, however, the software interrupt 	 * for this driver may deliver an event invalidating this CCB just 	 * before we queue it.  Close this race condition by blocking 	 * software interrupt delivery, checking for any pertinent queued 	 * events, and only then queuing this CCB. 	 */
name|s
operator|=
name|splsoftcam
argument_list|()
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|exceptions
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_CONT_TARGET_IO
condition|)
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|softc
operator|->
name|pending_queue
argument_list|,
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
comment|/* 		 * If the user wants us to perform any error recovery, 		 * then honor that request.  Otherwise, it's up to the 		 * user to perform any error recovery. 		 */
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
comment|/* error handler */
name|NULL
argument_list|,
comment|/* cam_flags */
literal|0
argument_list|,
comment|/* sense_flags */
name|SF_RETRY_UA
argument_list|,
operator|&
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_CONT_TARGET_IO
condition|)
name|TAILQ_REMOVE
argument_list|(
operator|&
name|softc
operator|->
name|pending_queue
argument_list|,
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_UNACKED_EVENT
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_unmap
operator|!=
literal|0
condition|)
name|cam_periph_unmapmem
argument_list|(
name|ccb
argument_list|,
operator|&
name|mapinfo
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|cbfcnp
operator|=
name|NULL
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|periph_priv
operator|=
name|inccb
operator|->
name|ccb_h
operator|.
name|periph_priv
expr_stmt|;
name|bcopy
argument_list|(
name|ccb
argument_list|,
name|inccb
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|ccb
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|targpoll
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|poll_events
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|targ_softc
modifier|*
name|softc
decl_stmt|;
name|u_int
name|unit
decl_stmt|;
name|int
name|revents
decl_stmt|;
name|int
name|s
decl_stmt|;
name|unit
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* ioctl is the only supported operation of the control device */
if|if
condition|(
name|TARG_IS_CONTROL_DEV
argument_list|(
name|unit
argument_list|)
condition|)
return|return
name|EINVAL
return|;
name|periph
operator|=
name|cam_extend_get
argument_list|(
name|targperiphs
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|softc
operator|=
operator|(
expr|struct
name|targ_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|revents
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|poll_events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|softc
operator|->
name|rcv_ccb_queue
argument_list|)
operator|!=
name|NULL
operator|&&
name|bioq_first
argument_list|(
operator|&
name|softc
operator|->
name|rcv_bio_queue
argument_list|)
operator|==
name|NULL
condition|)
name|revents
operator||=
name|poll_events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|poll_events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|softc
operator|->
name|snd_ccb_queue
argument_list|)
operator|!=
name|NULL
operator|&&
name|bioq_first
argument_list|(
operator|&
name|softc
operator|->
name|snd_bio_queue
argument_list|)
operator|==
name|NULL
condition|)
name|revents
operator||=
name|poll_events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|softc
operator|->
name|state
operator|!=
name|TARG_STATE_NORMAL
condition|)
name|revents
operator||=
name|POLLERR
expr_stmt|;
if|if
condition|(
name|revents
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|poll_events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
condition|)
name|selrecord
argument_list|(
name|p
argument_list|,
operator|&
name|softc
operator|->
name|rcv_select
argument_list|)
expr_stmt|;
if|if
condition|(
name|poll_events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
condition|)
name|selrecord
argument_list|(
name|p
argument_list|,
operator|&
name|softc
operator|->
name|snd_select
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|revents
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|targread
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|u_int
name|unit
decl_stmt|;
name|unit
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* ioctl is the only supported operation of the control device */
if|if
condition|(
name|TARG_IS_CONTROL_DEV
argument_list|(
name|unit
argument_list|)
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|uio
operator|->
name|uio_iovcnt
operator|==
literal|0
operator|||
name|uio
operator|->
name|uio_iov
operator|->
name|iov_len
operator|==
literal|0
condition|)
block|{
comment|/* EOF */
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|targ_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|periph
operator|=
name|cam_extend_get
argument_list|(
name|targperiphs
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|softc
operator|=
operator|(
expr|struct
name|targ_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|softc
operator|->
name|flags
operator||=
name|TARG_FLAG_SEND_EOF
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|targrunqueue
argument_list|(
name|periph
argument_list|,
name|softc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|physread
argument_list|(
name|dev
argument_list|,
name|uio
argument_list|,
name|ioflag
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|targwrite
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|u_int
name|unit
decl_stmt|;
name|unit
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* ioctl is the only supported operation of the control device */
if|if
condition|(
name|TARG_IS_CONTROL_DEV
argument_list|(
name|unit
argument_list|)
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|uio
operator|->
name|uio_iovcnt
operator|==
literal|0
operator|||
name|uio
operator|->
name|uio_iov
operator|->
name|iov_len
operator|==
literal|0
condition|)
block|{
comment|/* EOF */
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|targ_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|periph
operator|=
name|cam_extend_get
argument_list|(
name|targperiphs
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|softc
operator|=
operator|(
expr|struct
name|targ_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|softc
operator|->
name|flags
operator||=
name|TARG_FLAG_RECEIVE_EOF
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|targrunqueue
argument_list|(
name|periph
argument_list|,
name|softc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|physwrite
argument_list|(
name|dev
argument_list|,
name|uio
argument_list|,
name|ioflag
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Actually translate the requested transfer into one the physical driver  * can understand.  The transfer is described by a buf and will include  * only one physical transfer.  */
end_comment

begin_function
specifier|static
name|void
name|targstrategy
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|targ_softc
modifier|*
name|softc
decl_stmt|;
name|u_int
name|unit
decl_stmt|;
name|int
name|s
decl_stmt|;
name|unit
operator|=
name|minor
argument_list|(
name|bp
operator|->
name|bio_dev
argument_list|)
expr_stmt|;
comment|/* ioctl is the only supported operation of the control device */
if|if
condition|(
name|TARG_IS_CONTROL_DEV
argument_list|(
name|unit
argument_list|)
condition|)
block|{
name|bp
operator|->
name|bio_error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|periph
operator|=
name|cam_extend_get
argument_list|(
name|targperiphs
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
block|{
name|bp
operator|->
name|bio_error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|softc
operator|=
operator|(
expr|struct
name|targ_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
comment|/* 	 * Mask interrupts so that the device cannot be invalidated until 	 * after we are in the queue.  Otherwise, we might not properly 	 * clean up one of the buffers. 	 */
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* 	 * If there is an exception pending, error out 	 */
if|if
condition|(
name|softc
operator|->
name|state
operator|!=
name|TARG_STATE_NORMAL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|state
operator|==
name|TARG_STATE_EXCEPTION
operator|&&
operator|(
name|softc
operator|->
name|exceptions
operator|&
name|TARG_EXCEPT_DEVICE_INVALID
operator|)
operator|==
literal|0
condition|)
name|bp
operator|->
name|bio_error
operator|=
name|EBUSY
expr_stmt|;
else|else
name|bp
operator|->
name|bio_error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Place it in the queue of buffers available for either 	 * SEND or RECEIVE commands. 	 *  	 */
name|bp
operator|->
name|bio_resid
operator|=
name|bp
operator|->
name|bio_bcount
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_READ
condition|)
block|{
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_PERIPH
argument_list|,
operator|(
literal|"Queued a SEND buffer\n"
operator|)
argument_list|)
expr_stmt|;
name|bioq_insert_tail
argument_list|(
operator|&
name|softc
operator|->
name|snd_bio_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_PERIPH
argument_list|,
operator|(
literal|"Queued a RECEIVE buffer\n"
operator|)
argument_list|)
expr_stmt|;
name|bioq_insert_tail
argument_list|(
operator|&
name|softc
operator|->
name|rcv_bio_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Attempt to use the new buffer to service any pending 	 * target commands. 	 */
name|targrunqueue
argument_list|(
name|periph
argument_list|,
name|softc
argument_list|)
expr_stmt|;
return|return;
name|bad
label|:
name|bp
operator|->
name|bio_flags
operator||=
name|BIO_ERROR
expr_stmt|;
comment|/* 	 * Correctly set the buf to indicate a completed xfer 	 */
name|bp
operator|->
name|bio_resid
operator|=
name|bp
operator|->
name|bio_bcount
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|targrunqueue
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|targ_softc
modifier|*
name|softc
parameter_list|)
block|{
name|struct
name|ccb_queue
modifier|*
name|pending_queue
decl_stmt|;
name|struct
name|ccb_accept_tio
modifier|*
name|atio
decl_stmt|;
name|struct
name|bio_queue_head
modifier|*
name|bioq
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|struct
name|targ_cmd_desc
modifier|*
name|desc
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccbh
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|pending_queue
operator|=
name|NULL
expr_stmt|;
name|bioq
operator|=
name|NULL
expr_stmt|;
name|ccbh
operator|=
name|NULL
expr_stmt|;
comment|/* Only run one request at a time to maintain data ordering. */
if|if
condition|(
name|softc
operator|->
name|state
operator|!=
name|TARG_STATE_NORMAL
operator|||
name|TAILQ_FIRST
argument_list|(
operator|&
name|softc
operator|->
name|work_queue
argument_list|)
operator|!=
name|NULL
operator|||
name|TAILQ_FIRST
argument_list|(
operator|&
name|softc
operator|->
name|pending_queue
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
operator|(
name|bp
operator|=
name|bioq_first
argument_list|(
operator|&
name|softc
operator|->
name|snd_bio_queue
argument_list|)
operator|)
operator|!=
name|NULL
operator|||
operator|(
name|softc
operator|->
name|flags
operator|&
name|TARG_FLAG_SEND_EOF
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ccbh
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|softc
operator|->
name|snd_ccb_queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
name|softc
operator|->
name|flags
operator|&=
operator|~
name|TARG_FLAG_SEND_EOF
expr_stmt|;
else|else
block|{
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_PERIPH
argument_list|,
operator|(
literal|"De-Queued a SEND buffer %ld\n"
operator|,
name|bp
operator|->
name|bio_bcount
operator|)
argument_list|)
expr_stmt|;
block|}
name|bioq
operator|=
operator|&
name|softc
operator|->
name|snd_bio_queue
expr_stmt|;
name|pending_queue
operator|=
operator|&
name|softc
operator|->
name|snd_ccb_queue
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|bp
operator|=
name|bioq_first
argument_list|(
operator|&
name|softc
operator|->
name|rcv_bio_queue
argument_list|)
operator|)
operator|!=
name|NULL
operator|||
operator|(
name|softc
operator|->
name|flags
operator|&
name|TARG_FLAG_RECEIVE_EOF
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ccbh
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|softc
operator|->
name|rcv_ccb_queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
name|softc
operator|->
name|flags
operator|&=
operator|~
name|TARG_FLAG_RECEIVE_EOF
expr_stmt|;
else|else
block|{
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_PERIPH
argument_list|,
operator|(
literal|"De-Queued a RECEIVE buffer %ld\n"
operator|,
name|bp
operator|->
name|bio_bcount
operator|)
argument_list|)
expr_stmt|;
block|}
name|bioq
operator|=
operator|&
name|softc
operator|->
name|rcv_bio_queue
expr_stmt|;
name|pending_queue
operator|=
operator|&
name|softc
operator|->
name|rcv_ccb_queue
expr_stmt|;
block|}
if|if
condition|(
name|pending_queue
operator|!=
name|NULL
condition|)
block|{
comment|/* Process a request */
name|atio
operator|=
operator|(
expr|struct
name|ccb_accept_tio
operator|*
operator|)
name|ccbh
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
name|pending_queue
argument_list|,
name|ccbh
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|desc
operator|=
operator|(
expr|struct
name|targ_cmd_desc
operator|*
operator|)
name|atio
operator|->
name|ccb_h
operator|.
name|ccb_descr
expr_stmt|;
name|desc
operator|->
name|bp
operator|=
name|bp
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
comment|/* EOF */
name|desc
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|desc
operator|->
name|data_increment
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|data_resid
operator|=
literal|0
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator|&=
operator|~
name|CAM_DIR_MASK
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DIR_NONE
expr_stmt|;
block|}
else|else
block|{
name|bioq_remove
argument_list|(
name|bioq
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|desc
operator|->
name|data
operator|=
operator|&
name|bp
operator|->
name|bio_data
index|[
name|bp
operator|->
name|bio_bcount
operator|-
name|bp
operator|->
name|bio_resid
index|]
expr_stmt|;
name|desc
operator|->
name|data_increment
operator|=
name|MIN
argument_list|(
name|desc
operator|->
name|data_resid
argument_list|,
name|bp
operator|->
name|bio_resid
argument_list|)
expr_stmt|;
block|}
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_PERIPH
argument_list|,
operator|(
literal|"Buffer command: data %p: datacnt %d\n"
operator|,
name|desc
operator|->
name|data
operator|,
name|desc
operator|->
name|data_increment
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|softc
operator|->
name|work_queue
argument_list|,
operator|&
name|atio
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
block|}
name|atio
operator|=
operator|(
expr|struct
name|ccb_accept_tio
operator|*
operator|)
name|TAILQ_FIRST
argument_list|(
operator|&
name|softc
operator|->
name|work_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|atio
operator|!=
name|NULL
condition|)
block|{
name|int
name|priority
decl_stmt|;
name|priority
operator|=
operator|(
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIS_DISCONNECT
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|xpt_schedule
argument_list|(
name|periph
argument_list|,
name|priority
argument_list|)
expr_stmt|;
block|}
else|else
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|targstart
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|start_ccb
parameter_list|)
block|{
name|struct
name|targ_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccbh
decl_stmt|;
name|struct
name|ccb_accept_tio
modifier|*
name|atio
decl_stmt|;
name|struct
name|targ_cmd_desc
modifier|*
name|desc
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|targ_ccb_flags
name|flags
decl_stmt|;
name|int
name|s
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|targ_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|ccbh
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|softc
operator|->
name|work_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|periph
operator|->
name|immediate_priority
operator|<=
name|periph
operator|->
name|pinfo
operator|.
name|priority
condition|)
block|{
name|start_ccb
operator|->
name|ccb_h
operator|.
name|ccb_flags
operator|=
name|TARG_CCB_WAITING
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|periph
operator|->
name|ccb_list
argument_list|,
operator|&
name|start_ccb
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|sle
argument_list|)
expr_stmt|;
name|periph
operator|->
name|immediate_priority
operator|=
name|CAM_PRIORITY_NONE
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|periph
operator|->
name|ccb_list
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ccbh
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|start_ccb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|softc
operator|->
name|work_queue
argument_list|,
name|ccbh
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|atio
operator|=
operator|(
expr|struct
name|ccb_accept_tio
operator|*
operator|)
name|ccbh
expr_stmt|;
name|desc
operator|=
operator|(
expr|struct
name|targ_cmd_desc
operator|*
operator|)
name|atio
operator|->
name|ccb_h
operator|.
name|ccb_descr
expr_stmt|;
comment|/* Is this a tagged request? */
name|flags
operator|=
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
operator|(
name|CAM_DIS_DISCONNECT
operator||
name|CAM_TAG_ACTION_VALID
operator||
name|CAM_DIR_MASK
operator|)
expr_stmt|;
comment|/* 		 * If we are done with the transaction, tell the 		 * controller to send status and perform a CMD_CMPLT. 		 */
if|if
condition|(
name|desc
operator|->
name|data_resid
operator|==
name|desc
operator|->
name|data_increment
condition|)
name|flags
operator||=
name|CAM_SEND_STATUS
expr_stmt|;
name|csio
operator|=
operator|&
name|start_ccb
operator|->
name|csio
expr_stmt|;
name|cam_fill_ctio
argument_list|(
name|csio
argument_list|,
comment|/*retries*/
literal|2
argument_list|,
name|targdone
argument_list|,
name|flags
argument_list|,
operator|(
name|flags
operator|&
name|CAM_TAG_ACTION_VALID
operator|)
condition|?
name|MSG_SIMPLE_Q_TAG
else|:
literal|0
argument_list|,
name|atio
operator|->
name|tag_id
argument_list|,
name|atio
operator|->
name|init_id
argument_list|,
name|desc
operator|->
name|status
argument_list|,
comment|/*data_ptr*/
name|desc
operator|->
name|data_increment
operator|==
literal|0
condition|?
name|NULL
else|:
name|desc
operator|->
name|data
argument_list|,
comment|/*dxfer_len*/
name|desc
operator|->
name|data_increment
argument_list|,
comment|/*timeout*/
name|desc
operator|->
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|CAM_SEND_STATUS
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|desc
operator|->
name|status
operator|==
name|SCSI_STATUS_CHECK_COND
operator|||
name|desc
operator|->
name|status
operator|==
name|SCSI_STATUS_CMD_TERMINATED
operator|)
condition|)
block|{
name|struct
name|initiator_state
modifier|*
name|istate
decl_stmt|;
name|istate
operator|=
operator|&
name|softc
operator|->
name|istate
index|[
name|atio
operator|->
name|init_id
index|]
expr_stmt|;
name|csio
operator|->
name|sense_len
operator|=
name|istate
operator|->
name|sense_data
operator|.
name|extra_len
operator|+
name|offsetof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|,
name|extra_len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|istate
operator|->
name|sense_data
argument_list|,
operator|&
name|csio
operator|->
name|sense_data
argument_list|,
name|csio
operator|->
name|sense_len
argument_list|)
expr_stmt|;
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_SEND_SENSE
expr_stmt|;
block|}
else|else
block|{
name|csio
operator|->
name|sense_len
operator|=
literal|0
expr_stmt|;
block|}
name|start_ccb
operator|->
name|ccb_h
operator|.
name|ccb_flags
operator|=
name|TARG_CCB_NONE
expr_stmt|;
name|start_ccb
operator|->
name|ccb_h
operator|.
name|ccb_atio
operator|=
name|atio
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_PERIPH
argument_list|,
operator|(
literal|"Sending a CTIO (flags 0x%x)\n"
operator|,
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|softc
operator|->
name|pending_queue
argument_list|,
operator|&
name|csio
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|xpt_action
argument_list|(
name|start_ccb
argument_list|)
expr_stmt|;
comment|/* 		 * If the queue was frozen waiting for the response 		 * to this ATIO (for instance disconnection was disallowed), 		 * then release it now that our response has been queued. 		 */
if|if
condition|(
operator|(
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|!=
literal|0
condition|)
block|{
name|cam_release_devq
argument_list|(
name|periph
operator|->
name|path
argument_list|,
comment|/*relsim_flags*/
literal|0
argument_list|,
comment|/*reduction*/
literal|0
argument_list|,
comment|/*timeout*/
literal|0
argument_list|,
comment|/*getcount_only*/
literal|0
argument_list|)
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator|&=
operator|~
name|CAM_DEV_QFRZN
expr_stmt|;
block|}
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|ccbh
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|softc
operator|->
name|work_queue
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ccbh
operator|!=
name|NULL
condition|)
name|targrunqueue
argument_list|(
name|periph
argument_list|,
name|softc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|targdone
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|done_ccb
parameter_list|)
block|{
name|struct
name|targ_softc
modifier|*
name|softc
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|targ_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|ccb_flags
operator|==
name|TARG_CCB_WAITING
condition|)
block|{
comment|/* Caller will release the CCB */
name|wakeup
argument_list|(
operator|&
name|done_ccb
operator|->
name|ccb_h
operator|.
name|cbfcnp
argument_list|)
expr_stmt|;
return|return;
block|}
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_PERIPH
argument_list|,
operator|(
literal|"targdone %x\n"
operator|,
name|done_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_ACCEPT_TARGET_IO
case|:
block|{
name|struct
name|ccb_accept_tio
modifier|*
name|atio
decl_stmt|;
name|struct
name|targ_cmd_desc
modifier|*
name|descr
decl_stmt|;
name|struct
name|initiator_state
modifier|*
name|istate
decl_stmt|;
name|u_int8_t
modifier|*
name|cdb
decl_stmt|;
name|int
name|priority
decl_stmt|;
name|atio
operator|=
operator|&
name|done_ccb
operator|->
name|atio
expr_stmt|;
name|descr
operator|=
operator|(
expr|struct
name|targ_cmd_desc
operator|*
operator|)
name|atio
operator|->
name|ccb_h
operator|.
name|ccb_descr
expr_stmt|;
name|istate
operator|=
operator|&
name|softc
operator|->
name|istate
index|[
name|atio
operator|->
name|init_id
index|]
expr_stmt|;
name|cdb
operator|=
name|atio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|state
operator|==
name|TARG_STATE_TEARDOWN
operator|||
name|atio
operator|->
name|ccb_h
operator|.
name|status
operator|==
name|CAM_REQ_ABORTED
condition|)
block|{
name|freedescr
argument_list|(
name|descr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|done_ccb
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|CAMDEBUG
block|{
name|int
name|i
decl_stmt|;
name|char
name|dcb
index|[
literal|128
index|]
decl_stmt|;
for|for
control|(
name|dcb
index|[
literal|0
index|]
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|atio
operator|->
name|cdb_len
condition|;
name|i
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|dcb
argument_list|,
sizeof|sizeof
name|dcb
argument_list|,
literal|"%s %02x"
argument_list|,
name|dcb
argument_list|,
name|cdb
index|[
name|i
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_PERIPH
argument_list|,
operator|(
literal|"cdb:%s\n"
operator|,
name|dcb
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|atio
operator|->
name|sense_len
operator|!=
literal|0
condition|)
block|{
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_PERIPH
argument_list|,
operator|(
literal|"ATIO with sense_len\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 			 * We had an error in the reception of 			 * this command.  Immediately issue a CA. 			 */
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator|&=
operator|~
name|CAM_DIR_MASK
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DIR_NONE
expr_stmt|;
name|descr
operator|->
name|data_resid
operator|=
literal|0
expr_stmt|;
name|descr
operator|->
name|data_increment
operator|=
literal|0
expr_stmt|;
name|descr
operator|->
name|timeout
operator|=
literal|5
operator|*
literal|1000
expr_stmt|;
name|descr
operator|->
name|status
operator|=
name|SCSI_STATUS_CHECK_COND
expr_stmt|;
name|copy_sense
argument_list|(
name|softc
argument_list|,
name|istate
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|atio
operator|->
name|sense_data
argument_list|,
name|atio
operator|->
name|sense_len
argument_list|)
expr_stmt|;
name|set_ca_condition
argument_list|(
name|periph
argument_list|,
name|atio
operator|->
name|init_id
argument_list|,
name|CA_CMD_SENSE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|istate
operator|->
name|pending_ca
operator|==
literal|0
operator|&&
name|istate
operator|->
name|pending_ua
operator|!=
literal|0
operator|&&
name|cdb
index|[
literal|0
index|]
operator|!=
name|INQUIRY
condition|)
block|{
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_PERIPH
argument_list|,
operator|(
literal|"pending_ca %d pending_ua %d\n"
operator|,
name|istate
operator|->
name|pending_ca
operator|,
name|istate
operator|->
name|pending_ua
operator|)
argument_list|)
expr_stmt|;
comment|/* Pending UA, tell initiator */
comment|/* Direction is always relative to the initator */
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator|&=
operator|~
name|CAM_DIR_MASK
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DIR_NONE
expr_stmt|;
name|descr
operator|->
name|data_resid
operator|=
literal|0
expr_stmt|;
name|descr
operator|->
name|data_increment
operator|=
literal|0
expr_stmt|;
name|descr
operator|->
name|timeout
operator|=
literal|5
operator|*
literal|1000
expr_stmt|;
name|descr
operator|->
name|status
operator|=
name|SCSI_STATUS_CHECK_COND
expr_stmt|;
name|fill_sense
argument_list|(
name|softc
argument_list|,
name|atio
operator|->
name|init_id
argument_list|,
name|SSD_CURRENT_ERROR
argument_list|,
name|SSD_KEY_UNIT_ATTENTION
argument_list|,
literal|0x29
argument_list|,
name|istate
operator|->
name|pending_ua
operator|==
name|UA_POWER_ON
condition|?
literal|1
else|:
literal|2
argument_list|)
expr_stmt|;
name|set_ca_condition
argument_list|(
name|periph
argument_list|,
name|atio
operator|->
name|init_id
argument_list|,
name|CA_UNIT_ATTN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Save the current CA and UA status so 			 * they can be used by this command. 			 */
name|ua_types
name|pending_ua
decl_stmt|;
name|ca_types
name|pending_ca
decl_stmt|;
name|pending_ua
operator|=
name|istate
operator|->
name|pending_ua
expr_stmt|;
name|pending_ca
operator|=
name|istate
operator|->
name|pending_ca
expr_stmt|;
comment|/* 			 * As per the SCSI2 spec, any command that occurs 			 * after a CA is reported, clears the CA.  We must 			 * also clear the UA condition, if any, that caused 			 * the CA to occur assuming the UA is not for a 			 * persistant condition. 			 */
name|istate
operator|->
name|pending_ca
operator|=
name|CA_NONE
expr_stmt|;
if|if
condition|(
name|pending_ca
operator|==
name|CA_UNIT_ATTN
condition|)
name|istate
operator|->
name|pending_ua
operator|=
name|UA_NONE
expr_stmt|;
comment|/* 			 * Determine the type of incoming command and 			 * setup our buffer for a response. 			 */
switch|switch
condition|(
name|cdb
index|[
literal|0
index|]
condition|)
block|{
case|case
name|INQUIRY
case|:
block|{
name|struct
name|scsi_inquiry
modifier|*
name|inq
decl_stmt|;
name|struct
name|scsi_sense_data
modifier|*
name|sense
decl_stmt|;
name|inq
operator|=
operator|(
expr|struct
name|scsi_inquiry
operator|*
operator|)
name|cdb
expr_stmt|;
name|sense
operator|=
operator|&
name|istate
operator|->
name|sense_data
expr_stmt|;
name|descr
operator|->
name|status
operator|=
name|SCSI_STATUS_OK
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_PERIPH
argument_list|,
operator|(
literal|"Saw an inquiry!\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 				 * Validate the command.  We don't 				 * support any VPD pages, so complain 				 * if EVPD is set. 				 */
if|if
condition|(
operator|(
name|inq
operator|->
name|byte2
operator|&
name|SI_EVPD
operator|)
operator|!=
literal|0
operator|||
name|inq
operator|->
name|page_code
operator|!=
literal|0
condition|)
block|{
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator|&=
operator|~
name|CAM_DIR_MASK
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DIR_NONE
expr_stmt|;
name|descr
operator|->
name|data_resid
operator|=
literal|0
expr_stmt|;
name|descr
operator|->
name|data_increment
operator|=
literal|0
expr_stmt|;
name|descr
operator|->
name|timeout
operator|=
literal|5
operator|*
literal|1000
expr_stmt|;
name|descr
operator|->
name|status
operator|=
name|SCSI_STATUS_CHECK_COND
expr_stmt|;
name|fill_sense
argument_list|(
name|softc
argument_list|,
name|atio
operator|->
name|init_id
argument_list|,
name|SSD_CURRENT_ERROR
argument_list|,
name|SSD_KEY_ILLEGAL_REQUEST
argument_list|,
comment|/*asc*/
literal|0x24
argument_list|,
comment|/*ascq*/
literal|0x00
argument_list|)
expr_stmt|;
name|sense
operator|->
name|extra_len
operator|=
name|offsetof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|,
name|extra_bytes
argument_list|)
operator|-
name|offsetof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|,
name|extra_len
argument_list|)
expr_stmt|;
name|set_ca_condition
argument_list|(
name|periph
argument_list|,
name|atio
operator|->
name|init_id
argument_list|,
name|CA_CMD_SENSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|inq
operator|->
name|byte2
operator|&
name|SI_EVPD
operator|)
operator|!=
literal|0
condition|)
block|{
name|sense
operator|->
name|sense_key_spec
index|[
literal|0
index|]
operator|=
name|SSD_SCS_VALID
operator||
name|SSD_FIELDPTR_CMD
operator||
name|SSD_BITPTR_VALID
operator||
comment|/*bit value*/
literal|1
expr_stmt|;
name|sense
operator|->
name|sense_key_spec
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|sense
operator|->
name|sense_key_spec
index|[
literal|2
index|]
operator|=
name|offsetof
argument_list|(
expr|struct
name|scsi_inquiry
argument_list|,
name|byte2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inq
operator|->
name|page_code
operator|!=
literal|0
condition|)
block|{
name|sense
operator|->
name|sense_key_spec
index|[
literal|0
index|]
operator|=
name|SSD_SCS_VALID
operator||
name|SSD_FIELDPTR_CMD
expr_stmt|;
name|sense
operator|->
name|sense_key_spec
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|sense
operator|->
name|sense_key_spec
index|[
literal|2
index|]
operator|=
name|offsetof
argument_list|(
expr|struct
name|scsi_inquiry
argument_list|,
name|page_code
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|descr
operator|->
name|status
operator|==
name|SCSI_STATUS_CHECK_COND
condition|)
break|break;
comment|/* 				 * Direction is always relative 				 * to the initator. 				 */
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator|&=
operator|~
name|CAM_DIR_MASK
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DIR_IN
expr_stmt|;
name|descr
operator|->
name|data
operator|=
name|softc
operator|->
name|inq_data
expr_stmt|;
name|descr
operator|->
name|data_resid
operator|=
name|MIN
argument_list|(
name|softc
operator|->
name|inq_data_len
argument_list|,
name|SCSI_CDB6_LEN
argument_list|(
name|inq
operator|->
name|length
argument_list|)
argument_list|)
expr_stmt|;
name|descr
operator|->
name|data_increment
operator|=
name|descr
operator|->
name|data_resid
expr_stmt|;
name|descr
operator|->
name|timeout
operator|=
literal|5
operator|*
literal|1000
expr_stmt|;
break|break;
block|}
case|case
name|TEST_UNIT_READY
case|:
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator|&=
operator|~
name|CAM_DIR_MASK
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DIR_NONE
expr_stmt|;
name|descr
operator|->
name|data_resid
operator|=
literal|0
expr_stmt|;
name|descr
operator|->
name|data_increment
operator|=
literal|0
expr_stmt|;
name|descr
operator|->
name|timeout
operator|=
literal|5
operator|*
literal|1000
expr_stmt|;
name|descr
operator|->
name|status
operator|=
name|SCSI_STATUS_OK
expr_stmt|;
break|break;
case|case
name|REQUEST_SENSE
case|:
block|{
name|struct
name|scsi_request_sense
modifier|*
name|rsense
decl_stmt|;
name|struct
name|scsi_sense_data
modifier|*
name|sense
decl_stmt|;
name|rsense
operator|=
operator|(
expr|struct
name|scsi_request_sense
operator|*
operator|)
name|cdb
expr_stmt|;
name|sense
operator|=
operator|&
name|istate
operator|->
name|sense_data
expr_stmt|;
if|if
condition|(
name|pending_ca
operator|==
literal|0
condition|)
block|{
name|fill_sense
argument_list|(
name|softc
argument_list|,
name|atio
operator|->
name|init_id
argument_list|,
name|SSD_CURRENT_ERROR
argument_list|,
name|SSD_KEY_NO_SENSE
argument_list|,
literal|0x00
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_PERIPH
argument_list|,
operator|(
literal|"No pending CA!\n"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * Direction is always relative 				 * to the initator. 				 */
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator|&=
operator|~
name|CAM_DIR_MASK
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DIR_IN
expr_stmt|;
name|descr
operator|->
name|data
operator|=
name|sense
expr_stmt|;
name|descr
operator|->
name|data_resid
operator|=
name|offsetof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|,
name|extra_len
argument_list|)
operator|+
name|sense
operator|->
name|extra_len
expr_stmt|;
name|descr
operator|->
name|data_resid
operator|=
name|MIN
argument_list|(
name|descr
operator|->
name|data_resid
argument_list|,
name|SCSI_CDB6_LEN
argument_list|(
name|rsense
operator|->
name|length
argument_list|)
argument_list|)
expr_stmt|;
name|descr
operator|->
name|data_increment
operator|=
name|descr
operator|->
name|data_resid
expr_stmt|;
name|descr
operator|->
name|timeout
operator|=
literal|5
operator|*
literal|1000
expr_stmt|;
name|descr
operator|->
name|status
operator|=
name|SCSI_STATUS_OK
expr_stmt|;
break|break;
block|}
case|case
name|RECEIVE
case|:
case|case
name|SEND
case|:
block|{
name|struct
name|scsi_send_receive
modifier|*
name|sr
decl_stmt|;
name|sr
operator|=
operator|(
expr|struct
name|scsi_send_receive
operator|*
operator|)
name|cdb
expr_stmt|;
comment|/* 				 * Direction is always relative 				 * to the initator. 				 */
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator|&=
operator|~
name|CAM_DIR_MASK
expr_stmt|;
name|descr
operator|->
name|data_resid
operator|=
name|scsi_3btoul
argument_list|(
name|sr
operator|->
name|xfer_len
argument_list|)
expr_stmt|;
name|descr
operator|->
name|timeout
operator|=
literal|5
operator|*
literal|1000
expr_stmt|;
name|descr
operator|->
name|status
operator|=
name|SCSI_STATUS_OK
expr_stmt|;
if|if
condition|(
name|cdb
index|[
literal|0
index|]
operator|==
name|SEND
condition|)
block|{
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DIR_OUT
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_PERIPH
argument_list|,
operator|(
literal|"Saw a SEND!\n"
operator|)
argument_list|)
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DIR_OUT
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|softc
operator|->
name|snd_ccb_queue
argument_list|,
operator|&
name|atio
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|selwakeup
argument_list|(
operator|&
name|softc
operator|->
name|snd_select
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DIR_IN
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_PERIPH
argument_list|,
operator|(
literal|"Saw a RECEIVE!\n"
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|softc
operator|->
name|rcv_ccb_queue
argument_list|,
operator|&
name|atio
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|selwakeup
argument_list|(
operator|&
name|softc
operator|->
name|rcv_select
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * Attempt to satisfy this request with 				 * a user buffer. 				 */
name|targrunqueue
argument_list|(
name|periph
argument_list|,
name|softc
argument_list|)
expr_stmt|;
return|return;
block|}
default|default:
comment|/* 				 * Queue for consumption by our userland 				 * counterpart and  transition to the exception 				 * state. 				 */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|softc
operator|->
name|unknown_atio_queue
argument_list|,
operator|&
name|atio
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|softc
operator|->
name|exceptions
operator||=
name|TARG_EXCEPT_UNKNOWN_ATIO
expr_stmt|;
name|targfireexception
argument_list|(
name|periph
argument_list|,
name|softc
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Queue us up to receive a Continue Target I/O ccb. */
if|if
condition|(
operator|(
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIS_DISCONNECT
operator|)
operator|!=
literal|0
condition|)
block|{
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|softc
operator|->
name|work_queue
argument_list|,
operator|&
name|atio
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|priority
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|softc
operator|->
name|work_queue
argument_list|,
operator|&
name|atio
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|priority
operator|=
literal|1
expr_stmt|;
block|}
name|xpt_schedule
argument_list|(
name|periph
argument_list|,
name|priority
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_CONT_TARGET_IO
case|:
block|{
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|struct
name|ccb_accept_tio
modifier|*
name|atio
decl_stmt|;
name|struct
name|targ_cmd_desc
modifier|*
name|desc
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_PERIPH
argument_list|,
operator|(
literal|"Received completed CTIO\n"
operator|)
argument_list|)
expr_stmt|;
name|csio
operator|=
operator|&
name|done_ccb
operator|->
name|csio
expr_stmt|;
name|atio
operator|=
operator|(
expr|struct
name|ccb_accept_tio
operator|*
operator|)
name|done_ccb
operator|->
name|ccb_h
operator|.
name|ccb_atio
expr_stmt|;
name|desc
operator|=
operator|(
expr|struct
name|targ_cmd_desc
operator|*
operator|)
name|atio
operator|->
name|ccb_h
operator|.
name|ccb_descr
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|softc
operator|->
name|pending_queue
argument_list|,
operator|&
name|done_ccb
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"CCB with error %x\n"
argument_list|,
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
argument_list|)
expr_stmt|;
name|error
operator|=
name|targerror
argument_list|(
name|done_ccb
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
break|break;
comment|/* 			 * Right now we don't need to do anything 			 * prior to unfreezing the queue... 			 */
if|if
condition|(
operator|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Releasing Queue\n"
argument_list|)
expr_stmt|;
name|cam_release_devq
argument_list|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*relsim_flags*/
literal|0
argument_list|,
comment|/*reduction*/
literal|0
argument_list|,
comment|/*timeout*/
literal|0
argument_list|,
comment|/*getcount_only*/
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|error
operator|=
literal|0
expr_stmt|;
comment|/* 		 * If we shipped back sense data when completing 		 * this command, clear the pending CA for it. 		 */
if|if
condition|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_SENT_SENSE
condition|)
block|{
name|struct
name|initiator_state
modifier|*
name|istate
decl_stmt|;
name|istate
operator|=
operator|&
name|softc
operator|->
name|istate
index|[
name|csio
operator|->
name|init_id
index|]
expr_stmt|;
if|if
condition|(
name|istate
operator|->
name|pending_ca
operator|==
name|CA_UNIT_ATTN
condition|)
name|istate
operator|->
name|pending_ua
operator|=
name|UA_NONE
expr_stmt|;
name|istate
operator|->
name|pending_ca
operator|=
name|CA_NONE
expr_stmt|;
name|softc
operator|->
name|istate
index|[
name|csio
operator|->
name|init_id
index|]
operator|.
name|pending_ca
operator|=
name|CA_NONE
expr_stmt|;
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_SENT_SENSE
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_PERIPH
argument_list|,
operator|(
literal|"Sent Sense\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|done_ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&=
operator|~
name|CAM_SEND_SENSE
expr_stmt|;
name|desc
operator|->
name|data_increment
operator|-=
name|csio
operator|->
name|resid
expr_stmt|;
name|desc
operator|->
name|data_resid
operator|-=
name|desc
operator|->
name|data_increment
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|=
name|desc
operator|->
name|bp
operator|)
operator|!=
name|NULL
condition|)
block|{
name|bp
operator|->
name|bio_resid
operator|-=
name|desc
operator|->
name|data_increment
expr_stmt|;
name|bp
operator|->
name|bio_error
operator|=
name|error
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_PERIPH
argument_list|,
operator|(
literal|"Buffer I/O Completed - Resid %ld:%d\n"
operator|,
name|bp
operator|->
name|bio_resid
operator|,
name|desc
operator|->
name|data_resid
operator|)
argument_list|)
expr_stmt|;
comment|/* 			 * Send the buffer back to the client if 			 * either the command has completed or all 			 * buffer space has been consumed. 			 */
if|if
condition|(
name|desc
operator|->
name|data_resid
operator|==
literal|0
operator|||
name|bp
operator|->
name|bio_resid
operator|==
literal|0
operator|||
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|bio_resid
operator|!=
literal|0
condition|)
comment|/* Short transfer */
name|bp
operator|->
name|bio_flags
operator||=
name|BIO_ERROR
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_PERIPH
argument_list|,
operator|(
literal|"Completing a buffer\n"
operator|)
argument_list|)
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|desc
operator|->
name|bp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|xpt_release_ccb
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|state
operator|!=
name|TARG_STATE_TEARDOWN
condition|)
block|{
if|if
condition|(
name|desc
operator|->
name|data_resid
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Send the original accept TIO back to the 				 * controller to handle more work. 				 */
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_PERIPH
argument_list|,
operator|(
literal|"Returning ATIO to target SIM\n"
operator|)
argument_list|)
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|ccb_flags
operator|=
name|TARG_CCB_NONE
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|atio
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Queue us up for another buffer */
if|if
condition|(
name|atio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
operator|==
name|SEND
condition|)
block|{
if|if
condition|(
name|desc
operator|->
name|bp
operator|!=
name|NULL
condition|)
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|softc
operator|->
name|snd_bio_queue
operator|.
name|queue
argument_list|,
name|bp
argument_list|,
name|bio_queue
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|softc
operator|->
name|snd_ccb_queue
argument_list|,
operator|&
name|atio
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|desc
operator|->
name|bp
operator|!=
name|NULL
condition|)
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|softc
operator|->
name|rcv_bio_queue
operator|.
name|queue
argument_list|,
name|bp
argument_list|,
name|bio_queue
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|softc
operator|->
name|rcv_ccb_queue
argument_list|,
operator|&
name|atio
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
block|}
name|desc
operator|->
name|bp
operator|=
name|NULL
expr_stmt|;
name|targrunqueue
argument_list|(
name|periph
argument_list|,
name|softc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|desc
operator|->
name|bp
operator|!=
name|NULL
condition|)
block|{
name|bp
operator|->
name|bio_flags
operator||=
name|BIO_ERROR
expr_stmt|;
name|bp
operator|->
name|bio_error
operator|=
name|ENXIO
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
name|freedescr
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|atio
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|XPT_IMMED_NOTIFY
case|:
block|{
name|int
name|frozen
decl_stmt|;
name|frozen
operator|=
operator|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|state
operator|==
name|TARG_STATE_TEARDOWN
condition|)
block|{
name|SLIST_REMOVE
argument_list|(
operator|&
name|softc
operator|->
name|immed_notify_slist
argument_list|,
operator|&
name|done_ccb
operator|->
name|ccb_h
argument_list|,
name|ccb_hdr
argument_list|,
name|periph_links
operator|.
name|sle
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|done_ccb
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|==
name|CAM_REQ_ABORTED
condition|)
block|{
name|free
argument_list|(
name|done_ccb
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Saw event %x:%x\n"
argument_list|,
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
argument_list|,
name|done_ccb
operator|->
name|cin
operator|.
name|message_args
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Process error condition. */
name|targinoterror
argument_list|(
name|periph
argument_list|,
name|softc
argument_list|,
operator|&
name|done_ccb
operator|->
name|cin
argument_list|)
expr_stmt|;
comment|/* Requeue for another immediate event */
name|xpt_action
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|frozen
operator|!=
literal|0
condition|)
name|cam_release_devq
argument_list|(
name|periph
operator|->
name|path
argument_list|,
comment|/*relsim_flags*/
literal|0
argument_list|,
comment|/*opening reduction*/
literal|0
argument_list|,
comment|/*timeout*/
literal|0
argument_list|,
comment|/*getcount_only*/
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_DEBUG
case|:
name|wakeup
argument_list|(
operator|&
name|done_ccb
operator|->
name|ccb_h
operator|.
name|cbfcnp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"targdone: Impossible xpt opcode %x encountered."
argument_list|,
name|done_ccb
operator|->
name|ccb_h
operator|.
name|func_code
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Transition to the exception state and notify our symbiotic  * userland process of the change.  */
end_comment

begin_function
specifier|static
name|void
name|targfireexception
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|targ_softc
modifier|*
name|softc
parameter_list|)
block|{
comment|/* 	 * return all pending buffers with short read/write status so our 	 * process unblocks, and do a selwakeup on any process queued 	 * waiting for reads or writes.  When the selwakeup is performed, 	 * the waking process will wakeup, call our poll routine again, 	 * and pick up the exception. 	 */
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
name|softc
operator|->
name|state
operator|!=
name|TARG_STATE_NORMAL
condition|)
comment|/* Already either tearing down or in exception state */
return|return;
name|softc
operator|->
name|state
operator|=
name|TARG_STATE_EXCEPTION
expr_stmt|;
while|while
condition|(
operator|(
name|bp
operator|=
name|bioq_first
argument_list|(
operator|&
name|softc
operator|->
name|snd_bio_queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|bioq_remove
argument_list|(
operator|&
name|softc
operator|->
name|snd_bio_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bio_flags
operator||=
name|BIO_ERROR
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|bp
operator|=
name|bioq_first
argument_list|(
operator|&
name|softc
operator|->
name|rcv_bio_queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|bioq_remove
argument_list|(
operator|&
name|softc
operator|->
name|snd_bio_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bio_flags
operator||=
name|BIO_ERROR
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
name|selwakeup
argument_list|(
operator|&
name|softc
operator|->
name|snd_select
argument_list|)
expr_stmt|;
name|selwakeup
argument_list|(
operator|&
name|softc
operator|->
name|rcv_select
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|targinoterror
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|targ_softc
modifier|*
name|softc
parameter_list|,
name|struct
name|ccb_immed_notify
modifier|*
name|inot
parameter_list|)
block|{
name|cam_status
name|status
decl_stmt|;
name|int
name|sense
decl_stmt|;
name|status
operator|=
name|inot
operator|->
name|ccb_h
operator|.
name|status
expr_stmt|;
name|sense
operator|=
operator|(
name|status
operator|&
name|CAM_AUTOSNS_VALID
operator|)
operator|!=
literal|0
expr_stmt|;
name|status
operator|&=
name|CAM_STATUS_MASK
expr_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|CAM_SCSI_BUS_RESET
case|:
name|set_unit_attention_cond
argument_list|(
name|periph
argument_list|,
comment|/*init_id*/
name|CAM_TARGET_WILDCARD
argument_list|,
name|UA_BUS_RESET
argument_list|)
expr_stmt|;
name|abort_pending_transactions
argument_list|(
name|periph
argument_list|,
comment|/*init_id*/
name|CAM_TARGET_WILDCARD
argument_list|,
name|TARG_TAG_WILDCARD
argument_list|,
name|EINTR
argument_list|,
comment|/*to_held_queue*/
name|FALSE
argument_list|)
expr_stmt|;
name|softc
operator|->
name|exceptions
operator||=
name|TARG_EXCEPT_BUS_RESET_SEEN
expr_stmt|;
name|targfireexception
argument_list|(
name|periph
argument_list|,
name|softc
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_BDR_SENT
case|:
name|set_unit_attention_cond
argument_list|(
name|periph
argument_list|,
comment|/*init_id*/
name|CAM_TARGET_WILDCARD
argument_list|,
name|UA_BDR
argument_list|)
expr_stmt|;
name|abort_pending_transactions
argument_list|(
name|periph
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|TARG_TAG_WILDCARD
argument_list|,
name|EINTR
argument_list|,
comment|/*to_held_queue*/
name|FALSE
argument_list|)
expr_stmt|;
name|softc
operator|->
name|exceptions
operator||=
name|TARG_EXCEPT_BDR_RECEIVED
expr_stmt|;
name|targfireexception
argument_list|(
name|periph
argument_list|,
name|softc
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_MESSAGE_RECV
case|:
switch|switch
condition|(
name|inot
operator|->
name|message_args
index|[
literal|0
index|]
condition|)
block|{
case|case
name|MSG_INITIATOR_DET_ERR
case|:
break|break;
case|case
name|MSG_ABORT
case|:
break|break;
case|case
name|MSG_BUS_DEV_RESET
case|:
break|break;
case|case
name|MSG_ABORT_TAG
case|:
break|break;
case|case
name|MSG_CLEAR_QUEUE
case|:
break|break;
case|case
name|MSG_TERM_IO_PROC
case|:
break|break;
default|default:
break|break;
block|}
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|targerror
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|u_int32_t
name|cam_flags
parameter_list|,
name|u_int32_t
name|sense_flags
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|targ_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|struct
name|initiator_state
modifier|*
name|istate
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|int
name|frozen
decl_stmt|;
name|int
name|sense
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|on_held_queue
decl_stmt|;
name|periph
operator|=
name|xpt_path_periph
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|targ_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|status
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|status
expr_stmt|;
name|sense
operator|=
operator|(
name|status
operator|&
name|CAM_AUTOSNS_VALID
operator|)
operator|!=
literal|0
expr_stmt|;
name|frozen
operator|=
operator|(
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|!=
literal|0
expr_stmt|;
name|status
operator|&=
name|CAM_STATUS_MASK
expr_stmt|;
name|on_held_queue
operator|=
name|FALSE
expr_stmt|;
name|csio
operator|=
operator|&
name|ccb
operator|->
name|csio
expr_stmt|;
name|istate
operator|=
operator|&
name|softc
operator|->
name|istate
index|[
name|csio
operator|->
name|init_id
index|]
expr_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|CAM_REQ_ABORTED
case|:
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_flags
operator|&
name|TARG_CCB_ABORT_TO_HELDQ
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Place this CCB into the initiators 			 * 'held' queue until the pending CA is cleared. 			 * If there is no CA pending, reissue immediately. 			 */
if|if
condition|(
name|istate
operator|->
name|pending_ca
operator|==
literal|0
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_flags
operator|=
name|TARG_CCB_NONE
expr_stmt|;
name|xpt_action
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_flags
operator|=
name|TARG_CCB_HELDQ
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|softc
operator|->
name|pending_queue
argument_list|,
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
block|}
comment|/* The command will be retried at a later time. */
name|on_held_queue
operator|=
name|TRUE
expr_stmt|;
name|error
operator|=
name|ERESTART
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
name|CAM_SCSI_BUS_RESET
case|:
case|case
name|CAM_BDR_SENT
case|:
case|case
name|CAM_REQ_TERMIO
case|:
case|case
name|CAM_CMD_TIMEOUT
case|:
comment|/* Assume we did not send any data */
name|csio
operator|->
name|resid
operator|=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
break|break;
case|case
name|CAM_SEL_TIMEOUT
case|:
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|retry_count
operator|>
literal|0
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|retry_count
operator|--
expr_stmt|;
name|error
operator|=
name|ERESTART
expr_stmt|;
block|}
else|else
block|{
comment|/* "Select or reselect failure" */
name|csio
operator|->
name|resid
operator|=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
name|fill_sense
argument_list|(
name|softc
argument_list|,
name|csio
operator|->
name|init_id
argument_list|,
name|SSD_CURRENT_ERROR
argument_list|,
name|SSD_KEY_HARDWARE_ERROR
argument_list|,
literal|0x45
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|set_ca_condition
argument_list|(
name|periph
argument_list|,
name|csio
operator|->
name|init_id
argument_list|,
name|CA_CMD_SENSE
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
block|}
break|break;
case|case
name|CAM_UNCOR_PARITY
case|:
comment|/* "SCSI parity error" */
name|fill_sense
argument_list|(
name|softc
argument_list|,
name|csio
operator|->
name|init_id
argument_list|,
name|SSD_CURRENT_ERROR
argument_list|,
name|SSD_KEY_HARDWARE_ERROR
argument_list|,
literal|0x47
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|set_ca_condition
argument_list|(
name|periph
argument_list|,
name|csio
operator|->
name|init_id
argument_list|,
name|CA_CMD_SENSE
argument_list|)
expr_stmt|;
name|csio
operator|->
name|resid
operator|=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
break|break;
case|case
name|CAM_NO_HBA
case|:
name|csio
operator|->
name|resid
operator|=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
case|case
name|CAM_SEQUENCE_FAIL
case|:
if|if
condition|(
name|sense
operator|!=
literal|0
condition|)
block|{
name|copy_sense
argument_list|(
name|softc
argument_list|,
name|istate
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|csio
operator|->
name|sense_data
argument_list|,
name|csio
operator|->
name|sense_len
argument_list|)
expr_stmt|;
name|set_ca_condition
argument_list|(
name|periph
argument_list|,
name|csio
operator|->
name|init_id
argument_list|,
name|CA_CMD_SENSE
argument_list|)
expr_stmt|;
block|}
name|csio
operator|->
name|resid
operator|=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
break|break;
case|case
name|CAM_IDE
case|:
comment|/* "Initiator detected error message received" */
name|fill_sense
argument_list|(
name|softc
argument_list|,
name|csio
operator|->
name|init_id
argument_list|,
name|SSD_CURRENT_ERROR
argument_list|,
name|SSD_KEY_HARDWARE_ERROR
argument_list|,
literal|0x48
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|set_ca_condition
argument_list|(
name|periph
argument_list|,
name|csio
operator|->
name|init_id
argument_list|,
name|CA_CMD_SENSE
argument_list|)
expr_stmt|;
name|csio
operator|->
name|resid
operator|=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
break|break;
case|case
name|CAM_REQUEUE_REQ
case|:
name|printf
argument_list|(
literal|"Requeue Request!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ERESTART
expr_stmt|;
break|break;
default|default:
name|csio
operator|->
name|resid
operator|=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
name|panic
argument_list|(
literal|"targerror: Unexpected status %x encounterd"
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|error
operator|==
name|ERESTART
operator|||
name|error
operator|==
literal|0
condition|)
block|{
comment|/* Clear the QFRZN flag as we will release the queue */
if|if
condition|(
name|frozen
operator|!=
literal|0
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_DEV_QFRZN
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ERESTART
operator|&&
operator|!
name|on_held_queue
condition|)
name|xpt_action
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|frozen
operator|!=
literal|0
condition|)
name|cam_release_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*relsim_flags*/
literal|0
argument_list|,
comment|/*opening reduction*/
literal|0
argument_list|,
comment|/*timeout*/
literal|0
argument_list|,
comment|/*getcount_only*/
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|targ_cmd_desc
modifier|*
name|allocdescr
parameter_list|()
block|{
name|struct
name|targ_cmd_desc
modifier|*
name|descr
decl_stmt|;
comment|/* Allocate the targ_descr structure */
name|descr
operator|=
operator|(
expr|struct
name|targ_cmd_desc
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|descr
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|descr
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|bzero
argument_list|(
name|descr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|descr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allocate buffer backing store */
name|descr
operator|->
name|backing_store
operator|=
name|malloc
argument_list|(
name|MAX_BUF_SIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|descr
operator|->
name|backing_store
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|descr
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|descr
operator|->
name|max_size
operator|=
name|MAX_BUF_SIZE
expr_stmt|;
return|return
operator|(
name|descr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|freedescr
parameter_list|(
name|struct
name|targ_cmd_desc
modifier|*
name|descr
parameter_list|)
block|{
name|free
argument_list|(
name|descr
operator|->
name|backing_store
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|descr
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fill_sense
parameter_list|(
name|struct
name|targ_softc
modifier|*
name|softc
parameter_list|,
name|u_int
name|initiator_id
parameter_list|,
name|u_int
name|error_code
parameter_list|,
name|u_int
name|sense_key
parameter_list|,
name|u_int
name|asc
parameter_list|,
name|u_int
name|ascq
parameter_list|)
block|{
name|struct
name|initiator_state
modifier|*
name|istate
decl_stmt|;
name|struct
name|scsi_sense_data
modifier|*
name|sense
decl_stmt|;
name|istate
operator|=
operator|&
name|softc
operator|->
name|istate
index|[
name|initiator_id
index|]
expr_stmt|;
name|sense
operator|=
operator|&
name|istate
operator|->
name|sense_data
expr_stmt|;
name|bzero
argument_list|(
name|sense
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sense
argument_list|)
argument_list|)
expr_stmt|;
name|sense
operator|->
name|error_code
operator|=
name|error_code
expr_stmt|;
name|sense
operator|->
name|flags
operator|=
name|sense_key
expr_stmt|;
name|sense
operator|->
name|add_sense_code
operator|=
name|asc
expr_stmt|;
name|sense
operator|->
name|add_sense_code_qual
operator|=
name|ascq
expr_stmt|;
name|sense
operator|->
name|extra_len
operator|=
name|offsetof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|,
name|fru
argument_list|)
operator|-
name|offsetof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|,
name|extra_len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|copy_sense
parameter_list|(
name|struct
name|targ_softc
modifier|*
name|softc
parameter_list|,
name|struct
name|initiator_state
modifier|*
name|istate
parameter_list|,
name|u_int8_t
modifier|*
name|sense_buffer
parameter_list|,
name|size_t
name|sense_len
parameter_list|)
block|{
name|struct
name|scsi_sense_data
modifier|*
name|sense
decl_stmt|;
name|size_t
name|copylen
decl_stmt|;
name|sense
operator|=
operator|&
name|istate
operator|->
name|sense_data
expr_stmt|;
name|copylen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sense
argument_list|)
expr_stmt|;
if|if
condition|(
name|copylen
operator|>
name|sense_len
condition|)
name|copylen
operator|=
name|sense_len
expr_stmt|;
name|bcopy
argument_list|(
name|sense_buffer
argument_list|,
name|sense
argument_list|,
name|copylen
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_unit_attention_cond
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|u_int
name|initiator_id
parameter_list|,
name|ua_types
name|ua
parameter_list|)
block|{
name|int
name|start
decl_stmt|;
name|int
name|end
decl_stmt|;
name|struct
name|targ_softc
modifier|*
name|softc
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|targ_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|initiator_id
operator|==
name|CAM_TARGET_WILDCARD
condition|)
block|{
name|start
operator|=
literal|0
expr_stmt|;
name|end
operator|=
name|MAX_INITIATORS
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|start
operator|=
name|end
operator|=
name|initiator_id
expr_stmt|;
while|while
condition|(
name|start
operator|<=
name|end
condition|)
block|{
name|softc
operator|->
name|istate
index|[
name|start
index|]
operator|.
name|pending_ua
operator|=
name|ua
expr_stmt|;
name|start
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|set_ca_condition
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|u_int
name|initiator_id
parameter_list|,
name|ca_types
name|ca
parameter_list|)
block|{
name|struct
name|targ_softc
modifier|*
name|softc
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|targ_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|softc
operator|->
name|istate
index|[
name|initiator_id
index|]
operator|.
name|pending_ca
operator|=
name|ca
expr_stmt|;
name|abort_pending_transactions
argument_list|(
name|periph
argument_list|,
name|initiator_id
argument_list|,
name|TARG_TAG_WILDCARD
argument_list|,
comment|/*errno*/
literal|0
argument_list|,
comment|/*to_held_queue*/
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|abort_pending_transactions
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|u_int
name|initiator_id
parameter_list|,
name|u_int
name|tag_id
parameter_list|,
name|int
name|errno
parameter_list|,
name|int
name|to_held_queue
parameter_list|)
block|{
name|struct
name|ccb_abort
name|cab
decl_stmt|;
name|struct
name|ccb_queue
modifier|*
name|atio_queues
index|[
literal|3
index|]
decl_stmt|;
name|struct
name|targ_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccbh
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|targ_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|atio_queues
index|[
literal|0
index|]
operator|=
operator|&
name|softc
operator|->
name|work_queue
expr_stmt|;
name|atio_queues
index|[
literal|1
index|]
operator|=
operator|&
name|softc
operator|->
name|snd_ccb_queue
expr_stmt|;
name|atio_queues
index|[
literal|2
index|]
operator|=
operator|&
name|softc
operator|->
name|rcv_ccb_queue
expr_stmt|;
comment|/* First address the ATIOs awaiting resources */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|atio_queues
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|atio_queues
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ccb_queue
modifier|*
name|atio_queue
decl_stmt|;
if|if
condition|(
name|to_held_queue
condition|)
block|{
comment|/* 			 * The device queue is frozen anyway, so there 			 * is nothing for us to do. 			 */
continue|continue;
block|}
name|atio_queue
operator|=
name|atio_queues
index|[
name|i
index|]
expr_stmt|;
name|ccbh
operator|=
name|TAILQ_FIRST
argument_list|(
name|atio_queue
argument_list|)
expr_stmt|;
while|while
condition|(
name|ccbh
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ccb_accept_tio
modifier|*
name|atio
decl_stmt|;
name|struct
name|targ_cmd_desc
modifier|*
name|desc
decl_stmt|;
name|atio
operator|=
operator|(
expr|struct
name|ccb_accept_tio
operator|*
operator|)
name|ccbh
expr_stmt|;
name|desc
operator|=
operator|(
expr|struct
name|targ_cmd_desc
operator|*
operator|)
name|atio
operator|->
name|ccb_h
operator|.
name|ccb_descr
expr_stmt|;
name|ccbh
operator|=
name|TAILQ_NEXT
argument_list|(
name|ccbh
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
comment|/* Only abort the CCBs that match */
if|if
condition|(
operator|(
name|atio
operator|->
name|init_id
operator|!=
name|initiator_id
operator|&&
name|initiator_id
operator|!=
name|CAM_TARGET_WILDCARD
operator|)
operator|||
operator|(
name|tag_id
operator|!=
name|TARG_TAG_WILDCARD
operator|&&
operator|(
operator|(
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_TAG_ACTION_VALID
operator|)
operator|==
literal|0
operator|||
name|atio
operator|->
name|tag_id
operator|!=
name|tag_id
operator|)
operator|)
condition|)
continue|continue;
name|TAILQ_REMOVE
argument_list|(
name|atio_queue
argument_list|,
operator|&
name|atio
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_PERIPH
argument_list|,
operator|(
literal|"Aborting ATIO\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|->
name|bp
operator|!=
name|NULL
condition|)
block|{
name|desc
operator|->
name|bp
operator|->
name|bio_flags
operator||=
name|BIO_ERROR
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|state
operator|!=
name|TARG_STATE_TEARDOWN
condition|)
name|desc
operator|->
name|bp
operator|->
name|bio_error
operator|=
name|errno
expr_stmt|;
else|else
name|desc
operator|->
name|bp
operator|->
name|bio_error
operator|=
name|ENXIO
expr_stmt|;
name|biodone
argument_list|(
name|desc
operator|->
name|bp
argument_list|)
expr_stmt|;
name|desc
operator|->
name|bp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|softc
operator|->
name|state
operator|==
name|TARG_STATE_TEARDOWN
condition|)
block|{
name|freedescr
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|atio
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Return the ATIO back to the controller */
name|atio
operator|->
name|ccb_h
operator|.
name|ccb_flags
operator|=
name|TARG_CCB_NONE
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|atio
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|ccbh
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|softc
operator|->
name|pending_queue
argument_list|)
expr_stmt|;
while|while
condition|(
name|ccbh
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|csio
operator|=
operator|(
expr|struct
name|ccb_scsiio
operator|*
operator|)
name|ccbh
expr_stmt|;
name|ccbh
operator|=
name|TAILQ_NEXT
argument_list|(
name|ccbh
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
comment|/* Only abort the CCBs that match */
if|if
condition|(
operator|(
name|csio
operator|->
name|init_id
operator|!=
name|initiator_id
operator|&&
name|initiator_id
operator|!=
name|CAM_TARGET_WILDCARD
operator|)
operator|||
operator|(
name|tag_id
operator|!=
name|TARG_TAG_WILDCARD
operator|&&
operator|(
operator|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_TAG_ACTION_VALID
operator|)
operator|==
literal|0
operator|||
name|csio
operator|->
name|tag_id
operator|!=
name|tag_id
operator|)
operator|)
condition|)
continue|continue;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_PERIPH
argument_list|,
operator|(
literal|"Aborting CTIO\n"
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|softc
operator|->
name|pending_queue
argument_list|,
operator|&
name|csio
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
if|if
condition|(
name|to_held_queue
operator|!=
literal|0
condition|)
name|csio
operator|->
name|ccb_h
operator|.
name|ccb_flags
operator||=
name|TARG_CCB_ABORT_TO_HELDQ
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|cab
operator|.
name|ccb_h
argument_list|,
name|csio
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|cab
operator|.
name|abort_ccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|csio
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|cab
argument_list|)
expr_stmt|;
if|if
condition|(
name|cab
operator|.
name|ccb_h
operator|.
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_print_path
argument_list|(
name|cab
operator|.
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Unable to abort CCB.  Status %x\n"
argument_list|,
name|cab
operator|.
name|ccb_h
operator|.
name|status
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

