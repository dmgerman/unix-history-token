begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Implementation of Utility functions for all SCSI device types.  *  * Copyright (c) 1997, 1998, 1999 Justin T. Gibbs.  * Copyright (c) 1997, 1998, 2003 Kenneth D. Merry.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stdint.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<opt_scsi.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/libkern.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/ctype.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_queue.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<sys/ata.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<cam/cam_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_internal.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<camlib.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|FALSE
end_ifndef

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FALSE */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TRUE
end_ifndef

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TRUE */
end_comment

begin_define
define|#
directive|define
name|ERESTART
value|-1
end_define

begin_comment
comment|/* restart syscall */
end_comment

begin_define
define|#
directive|define
name|EJUSTRETURN
value|-2
end_define

begin_comment
comment|/* don't modify regs, just return */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !_KERNEL */
end_comment

begin_comment
comment|/*  * This is the default number of milliseconds we wait for devices to settle  * after a SCSI bus reset.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SCSI_DELAY
end_ifndef

begin_define
define|#
directive|define
name|SCSI_DELAY
value|2000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * All devices need _some_ sort of bus settle delay, so we'll set it to  * a minimum value of 100ms. Note that this is pertinent only for SPI-  * not transport like Fibre Channel or iSCSI where 'delay' is completely  * meaningless.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SCSI_MIN_DELAY
end_ifndef

begin_define
define|#
directive|define
name|SCSI_MIN_DELAY
value|100
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Make sure the user isn't using seconds instead of milliseconds.  */
end_comment

begin_if
if|#
directive|if
operator|(
name|SCSI_DELAY
operator|<
name|SCSI_MIN_DELAY
operator|&&
name|SCSI_DELAY
operator|!=
literal|0
operator|)
end_if

begin_error
error|#
directive|error
literal|"SCSI_DELAY is in milliseconds, not seconds!  Please use a larger value"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|scsi_delay
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|ascentrycomp
parameter_list|(
specifier|const
name|void
modifier|*
name|key
parameter_list|,
specifier|const
name|void
modifier|*
name|member
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|senseentrycomp
parameter_list|(
specifier|const
name|void
modifier|*
name|key
parameter_list|,
specifier|const
name|void
modifier|*
name|member
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fetchtableentries
parameter_list|(
name|int
name|sense_key
parameter_list|,
name|int
name|asc
parameter_list|,
name|int
name|ascq
parameter_list|,
name|struct
name|scsi_inquiry_data
modifier|*
parameter_list|,
specifier|const
name|struct
name|sense_key_table_entry
modifier|*
modifier|*
parameter_list|,
specifier|const
name|struct
name|asc_table_entry
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_function_decl
specifier|static
name|void
name|init_scsi_delay
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_scsi_delay
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_scsi_delay
parameter_list|(
name|int
name|delay
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SCSI_NO_OP_STRINGS
argument_list|)
end_if

begin_define
define|#
directive|define
name|D
value|(1<< T_DIRECT)
end_define

begin_define
define|#
directive|define
name|T
value|(1<< T_SEQUENTIAL)
end_define

begin_define
define|#
directive|define
name|L
value|(1<< T_PRINTER)
end_define

begin_define
define|#
directive|define
name|P
value|(1<< T_PROCESSOR)
end_define

begin_define
define|#
directive|define
name|W
value|(1<< T_WORM)
end_define

begin_define
define|#
directive|define
name|R
value|(1<< T_CDROM)
end_define

begin_define
define|#
directive|define
name|O
value|(1<< T_OPTICAL)
end_define

begin_define
define|#
directive|define
name|M
value|(1<< T_CHANGER)
end_define

begin_define
define|#
directive|define
name|A
value|(1<< T_STORARRAY)
end_define

begin_define
define|#
directive|define
name|E
value|(1<< T_ENCLOSURE)
end_define

begin_define
define|#
directive|define
name|B
value|(1<< T_RBC)
end_define

begin_define
define|#
directive|define
name|K
value|(1<< T_OCRW)
end_define

begin_define
define|#
directive|define
name|V
value|(1<< T_ADC)
end_define

begin_define
define|#
directive|define
name|F
value|(1<< T_OSD)
end_define

begin_define
define|#
directive|define
name|S
value|(1<< T_SCANNER)
end_define

begin_define
define|#
directive|define
name|C
value|(1<< T_COMM)
end_define

begin_define
define|#
directive|define
name|ALL
value|(D | T | L | P | W | R | O | M | A | E | B | K | V | F | S | C)
end_define

begin_decl_stmt
specifier|static
name|struct
name|op_table_entry
name|plextor_cd_ops
index|[]
init|=
block|{
block|{
literal|0xD8
block|,
name|R
block|,
literal|"CD-DA READ"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|scsi_op_quirk_entry
name|scsi_op_quirk_table
index|[]
init|=
block|{
block|{
comment|/* 		 * I believe that 0xD8 is the Plextor proprietary command 		 * to read CD-DA data.  I'm not sure which Plextor CDROM 		 * models support the command, though.  I know for sure 		 * that the 4X, 8X, and 12X models do, and presumably the 		 * 12-20X does.  I don't know about any earlier models, 		 * though.  If anyone has any more complete information, 		 * feel free to change this quirk entry. 		 */
block|{
name|T_CDROM
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"PLEXTOR"
block|,
literal|"CD-ROM PX*"
block|,
literal|"*"
block|}
block|,
sizeof|sizeof
argument_list|(
name|plextor_cd_ops
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|op_table_entry
argument_list|)
block|,
name|plextor_cd_ops
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|op_table_entry
name|scsi_op_codes
index|[]
init|=
block|{
comment|/* 	 * From: http://www.t10.org/lists/op-num.txt 	 * Modifications by Kenneth Merry (ken@FreeBSD.ORG) 	 *              and Jung-uk Kim (jkim@FreeBSD.org) 	 * 	 * Note:  order is important in this table, scsi_op_desc() currently 	 * depends on the opcodes in the table being in order to save 	 * search time. 	 * Note:  scanner and comm. devices are carried over from the previous 	 * version because they were removed in the latest spec. 	 */
comment|/* File: OP-NUM.TXT 	 * 	 * SCSI Operation Codes 	 * Numeric Sorted Listing 	 * as of  3/11/08 	 * 	 *     D - DIRECT ACCESS DEVICE (SBC-2)                device column key 	 *     .T - SEQUENTIAL ACCESS DEVICE (SSC-2)           ----------------- 	 *     . L - PRINTER DEVICE (SSC)                      M = Mandatory 	 *     .  P - PROCESSOR DEVICE (SPC)                   O = Optional 	 *     .  .W - WRITE ONCE READ MULTIPLE DEVICE (SBC-2) V = Vendor spec. 	 *     .  . R - CD/DVE DEVICE (MMC-3)                  Z = Obsolete 	 *     .  .  O - OPTICAL MEMORY DEVICE (SBC-2) 	 *     .  .  .M - MEDIA CHANGER DEVICE (SMC-2) 	 *     .  .  . A - STORAGE ARRAY DEVICE (SCC-2) 	 *     .  .  . .E - ENCLOSURE SERVICES DEVICE (SES) 	 *     .  .  .  .B - SIMPLIFIED DIRECT-ACCESS DEVICE (RBC) 	 *     .  .  .  . K - OPTICAL CARD READER/WRITER DEVICE (OCRW) 	 *     .  .  .  .  V - AUTOMATION/DRIVE INTERFACE (ADC) 	 *     .  .  .  .  .F - OBJECT-BASED STORAGE (OSD) 	 * OP  DTLPWROMAEBKVF  Description 	 * --  --------------  ---------------------------------------------- */
comment|/* 00  MMMMMMMMMMMMMM  TEST UNIT READY */
block|{
literal|0x00
block|,
name|ALL
block|,
literal|"TEST UNIT READY"
block|}
block|,
comment|/* 01   M              REWIND */
block|{
literal|0x01
block|,
name|T
block|,
literal|"REWIND"
block|}
block|,
comment|/* 01  Z V ZZZZ        REZERO UNIT */
block|{
literal|0x01
block|,
name|D
operator||
name|W
operator||
name|R
operator||
name|O
operator||
name|M
block|,
literal|"REZERO UNIT"
block|}
block|,
comment|/* 02  VVVVVV V */
comment|/* 03  MMMMMMMMMMOMMM  REQUEST SENSE */
block|{
literal|0x03
block|,
name|ALL
block|,
literal|"REQUEST SENSE"
block|}
block|,
comment|/* 04  M    OO         FORMAT UNIT */
block|{
literal|0x04
block|,
name|D
operator||
name|R
operator||
name|O
block|,
literal|"FORMAT UNIT"
block|}
block|,
comment|/* 04   O              FORMAT MEDIUM */
block|{
literal|0x04
block|,
name|T
block|,
literal|"FORMAT MEDIUM"
block|}
block|,
comment|/* 04    O             FORMAT */
block|{
literal|0x04
block|,
name|L
block|,
literal|"FORMAT"
block|}
block|,
comment|/* 05  VMVVVV V        READ BLOCK LIMITS */
block|{
literal|0x05
block|,
name|T
block|,
literal|"READ BLOCK LIMITS"
block|}
block|,
comment|/* 06  VVVVVV V */
comment|/* 07  OVV O OV        REASSIGN BLOCKS */
block|{
literal|0x07
block|,
name|D
operator||
name|W
operator||
name|O
block|,
literal|"REASSIGN BLOCKS"
block|}
block|,
comment|/* 07         O        INITIALIZE ELEMENT STATUS */
block|{
literal|0x07
block|,
name|M
block|,
literal|"INITIALIZE ELEMENT STATUS"
block|}
block|,
comment|/* 08  MOV O OV        READ(6) */
block|{
literal|0x08
block|,
name|D
operator||
name|T
operator||
name|W
operator||
name|O
block|,
literal|"READ(6)"
block|}
block|,
comment|/* 08     O            RECEIVE */
block|{
literal|0x08
block|,
name|P
block|,
literal|"RECEIVE"
block|}
block|,
comment|/* 08                  GET MESSAGE(6) */
block|{
literal|0x08
block|,
name|C
block|,
literal|"GET MESSAGE(6)"
block|}
block|,
comment|/* 09  VVVVVV V */
comment|/* 0A  OO  O OV        WRITE(6) */
block|{
literal|0x0A
block|,
name|D
operator||
name|T
operator||
name|W
operator||
name|O
block|,
literal|"WRITE(6)"
block|}
block|,
comment|/* 0A     M            SEND(6) */
block|{
literal|0x0A
block|,
name|P
block|,
literal|"SEND(6)"
block|}
block|,
comment|/* 0A                  SEND MESSAGE(6) */
block|{
literal|0x0A
block|,
name|C
block|,
literal|"SEND MESSAGE(6)"
block|}
block|,
comment|/* 0A    M             PRINT */
block|{
literal|0x0A
block|,
name|L
block|,
literal|"PRINT"
block|}
block|,
comment|/* 0B  Z   ZOZV        SEEK(6) */
block|{
literal|0x0B
block|,
name|D
operator||
name|W
operator||
name|R
operator||
name|O
block|,
literal|"SEEK(6)"
block|}
block|,
comment|/* 0B   O              SET CAPACITY */
block|{
literal|0x0B
block|,
name|T
block|,
literal|"SET CAPACITY"
block|}
block|,
comment|/* 0B    O             SLEW AND PRINT */
block|{
literal|0x0B
block|,
name|L
block|,
literal|"SLEW AND PRINT"
block|}
block|,
comment|/* 0C  VVVVVV V */
comment|/* 0D  VVVVVV V */
comment|/* 0E  VVVVVV V */
comment|/* 0F  VOVVVV V        READ REVERSE(6) */
block|{
literal|0x0F
block|,
name|T
block|,
literal|"READ REVERSE(6)"
block|}
block|,
comment|/* 10  VM VVV          WRITE FILEMARKS(6) */
block|{
literal|0x10
block|,
name|T
block|,
literal|"WRITE FILEMARKS(6)"
block|}
block|,
comment|/* 10    O             SYNCHRONIZE BUFFER */
block|{
literal|0x10
block|,
name|L
block|,
literal|"SYNCHRONIZE BUFFER"
block|}
block|,
comment|/* 11  VMVVVV          SPACE(6) */
block|{
literal|0x11
block|,
name|T
block|,
literal|"SPACE(6)"
block|}
block|,
comment|/* 12  MMMMMMMMMMMMMM  INQUIRY */
block|{
literal|0x12
block|,
name|ALL
block|,
literal|"INQUIRY"
block|}
block|,
comment|/* 13  V VVVV */
comment|/* 13   O              VERIFY(6) */
block|{
literal|0x13
block|,
name|T
block|,
literal|"VERIFY(6)"
block|}
block|,
comment|/* 14  VOOVVV          RECOVER BUFFERED DATA */
block|{
literal|0x14
block|,
name|T
operator||
name|L
block|,
literal|"RECOVER BUFFERED DATA"
block|}
block|,
comment|/* 15  OMO O OOOO OO   MODE SELECT(6) */
block|{
literal|0x15
block|,
name|ALL
operator|&
operator|~
operator|(
name|P
operator||
name|R
operator||
name|B
operator||
name|F
operator|)
block|,
literal|"MODE SELECT(6)"
block|}
block|,
comment|/* 16  ZZMZO OOOZ O    RESERVE(6) */
block|{
literal|0x16
block|,
name|ALL
operator|&
operator|~
operator|(
name|R
operator||
name|B
operator||
name|V
operator||
name|F
operator||
name|C
operator|)
block|,
literal|"RESERVE(6)"
block|}
block|,
comment|/* 16         Z        RESERVE ELEMENT(6) */
block|{
literal|0x16
block|,
name|M
block|,
literal|"RESERVE ELEMENT(6)"
block|}
block|,
comment|/* 17  ZZMZO OOOZ O    RELEASE(6) */
block|{
literal|0x17
block|,
name|ALL
operator|&
operator|~
operator|(
name|R
operator||
name|B
operator||
name|V
operator||
name|F
operator||
name|C
operator|)
block|,
literal|"RELEASE(6)"
block|}
block|,
comment|/* 17         Z        RELEASE ELEMENT(6) */
block|{
literal|0x17
block|,
name|M
block|,
literal|"RELEASE ELEMENT(6)"
block|}
block|,
comment|/* 18  ZZZZOZO    Z    COPY */
block|{
literal|0x18
block|,
name|D
operator||
name|T
operator||
name|L
operator||
name|P
operator||
name|W
operator||
name|R
operator||
name|O
operator||
name|K
operator||
name|S
block|,
literal|"COPY"
block|}
block|,
comment|/* 19  VMVVVV          ERASE(6) */
block|{
literal|0x19
block|,
name|T
block|,
literal|"ERASE(6)"
block|}
block|,
comment|/* 1A  OMO O OOOO OO   MODE SENSE(6) */
block|{
literal|0x1A
block|,
name|ALL
operator|&
operator|~
operator|(
name|P
operator||
name|R
operator||
name|B
operator||
name|F
operator|)
block|,
literal|"MODE SENSE(6)"
block|}
block|,
comment|/* 1B  O   OOO O MO O  START STOP UNIT */
block|{
literal|0x1B
block|,
name|D
operator||
name|W
operator||
name|R
operator||
name|O
operator||
name|A
operator||
name|B
operator||
name|K
operator||
name|F
block|,
literal|"START STOP UNIT"
block|}
block|,
comment|/* 1B   O          M   LOAD UNLOAD */
block|{
literal|0x1B
block|,
name|T
operator||
name|V
block|,
literal|"LOAD UNLOAD"
block|}
block|,
comment|/* 1B                  SCAN */
block|{
literal|0x1B
block|,
name|S
block|,
literal|"SCAN"
block|}
block|,
comment|/* 1B    O             STOP PRINT */
block|{
literal|0x1B
block|,
name|L
block|,
literal|"STOP PRINT"
block|}
block|,
comment|/* 1B         O        OPEN/CLOSE IMPORT/EXPORT ELEMENT */
block|{
literal|0x1B
block|,
name|M
block|,
literal|"OPEN/CLOSE IMPORT/EXPORT ELEMENT"
block|}
block|,
comment|/* 1C  OOOOO OOOM OOO  RECEIVE DIAGNOSTIC RESULTS */
block|{
literal|0x1C
block|,
name|ALL
operator|&
operator|~
operator|(
name|R
operator||
name|B
operator|)
block|,
literal|"RECEIVE DIAGNOSTIC RESULTS"
block|}
block|,
comment|/* 1D  MMMMM MMOM MMM  SEND DIAGNOSTIC */
block|{
literal|0x1D
block|,
name|ALL
operator|&
operator|~
operator|(
name|R
operator||
name|B
operator|)
block|,
literal|"SEND DIAGNOSTIC"
block|}
block|,
comment|/* 1E  OO  OOOO   O O  PREVENT ALLOW MEDIUM REMOVAL */
block|{
literal|0x1E
block|,
name|D
operator||
name|T
operator||
name|W
operator||
name|R
operator||
name|O
operator||
name|M
operator||
name|K
operator||
name|F
block|,
literal|"PREVENT ALLOW MEDIUM REMOVAL"
block|}
block|,
comment|/* 1F */
comment|/* 20  V   VVV    V */
comment|/* 21  V   VVV    V */
comment|/* 22  V   VVV    V */
comment|/* 23  V   V V    V */
comment|/* 23       O          READ FORMAT CAPACITIES */
block|{
literal|0x23
block|,
name|R
block|,
literal|"READ FORMAT CAPACITIES"
block|}
block|,
comment|/* 24  V   VV          SET WINDOW */
block|{
literal|0x24
block|,
name|S
block|,
literal|"SET WINDOW"
block|}
block|,
comment|/* 25  M   M M   M     READ CAPACITY(10) */
block|{
literal|0x25
block|,
name|D
operator||
name|W
operator||
name|O
operator||
name|B
block|,
literal|"READ CAPACITY(10)"
block|}
block|,
comment|/* 25       O          READ CAPACITY */
block|{
literal|0x25
block|,
name|R
block|,
literal|"READ CAPACITY"
block|}
block|,
comment|/* 25             M    READ CARD CAPACITY */
block|{
literal|0x25
block|,
name|K
block|,
literal|"READ CARD CAPACITY"
block|}
block|,
comment|/* 25                  GET WINDOW */
block|{
literal|0x25
block|,
name|S
block|,
literal|"GET WINDOW"
block|}
block|,
comment|/* 26  V   VV */
comment|/* 27  V   VV */
comment|/* 28  M   MOM   MM    READ(10) */
block|{
literal|0x28
block|,
name|D
operator||
name|W
operator||
name|R
operator||
name|O
operator||
name|B
operator||
name|K
operator||
name|S
block|,
literal|"READ(10)"
block|}
block|,
comment|/* 28                  GET MESSAGE(10) */
block|{
literal|0x28
block|,
name|C
block|,
literal|"GET MESSAGE(10)"
block|}
block|,
comment|/* 29  V   VVO         READ GENERATION */
block|{
literal|0x29
block|,
name|O
block|,
literal|"READ GENERATION"
block|}
block|,
comment|/* 2A  O   MOM   MO    WRITE(10) */
block|{
literal|0x2A
block|,
name|D
operator||
name|W
operator||
name|R
operator||
name|O
operator||
name|B
operator||
name|K
block|,
literal|"WRITE(10)"
block|}
block|,
comment|/* 2A                  SEND(10) */
block|{
literal|0x2A
block|,
name|S
block|,
literal|"SEND(10)"
block|}
block|,
comment|/* 2A                  SEND MESSAGE(10) */
block|{
literal|0x2A
block|,
name|C
block|,
literal|"SEND MESSAGE(10)"
block|}
block|,
comment|/* 2B  Z   OOO    O    SEEK(10) */
block|{
literal|0x2B
block|,
name|D
operator||
name|W
operator||
name|R
operator||
name|O
operator||
name|K
block|,
literal|"SEEK(10)"
block|}
block|,
comment|/* 2B   O              LOCATE(10) */
block|{
literal|0x2B
block|,
name|T
block|,
literal|"LOCATE(10)"
block|}
block|,
comment|/* 2B         O        POSITION TO ELEMENT */
block|{
literal|0x2B
block|,
name|M
block|,
literal|"POSITION TO ELEMENT"
block|}
block|,
comment|/* 2C  V    OO         ERASE(10) */
block|{
literal|0x2C
block|,
name|R
operator||
name|O
block|,
literal|"ERASE(10)"
block|}
block|,
comment|/* 2D        O         READ UPDATED BLOCK */
block|{
literal|0x2D
block|,
name|O
block|,
literal|"READ UPDATED BLOCK"
block|}
block|,
comment|/* 2D  V */
comment|/* 2E  O   OOO   MO    WRITE AND VERIFY(10) */
block|{
literal|0x2E
block|,
name|D
operator||
name|W
operator||
name|R
operator||
name|O
operator||
name|B
operator||
name|K
block|,
literal|"WRITE AND VERIFY(10)"
block|}
block|,
comment|/* 2F  O   OOO         VERIFY(10) */
block|{
literal|0x2F
block|,
name|D
operator||
name|W
operator||
name|R
operator||
name|O
block|,
literal|"VERIFY(10)"
block|}
block|,
comment|/* 30  Z   ZZZ         SEARCH DATA HIGH(10) */
block|{
literal|0x30
block|,
name|D
operator||
name|W
operator||
name|R
operator||
name|O
block|,
literal|"SEARCH DATA HIGH(10)"
block|}
block|,
comment|/* 31  Z   ZZZ         SEARCH DATA EQUAL(10) */
block|{
literal|0x31
block|,
name|D
operator||
name|W
operator||
name|R
operator||
name|O
block|,
literal|"SEARCH DATA EQUAL(10)"
block|}
block|,
comment|/* 31                  OBJECT POSITION */
block|{
literal|0x31
block|,
name|S
block|,
literal|"OBJECT POSITION"
block|}
block|,
comment|/* 32  Z   ZZZ         SEARCH DATA LOW(10) */
block|{
literal|0x32
block|,
name|D
operator||
name|W
operator||
name|R
operator||
name|O
block|,
literal|"SEARCH DATA LOW(10)"
block|}
block|,
comment|/* 33  Z   OZO         SET LIMITS(10) */
block|{
literal|0x33
block|,
name|D
operator||
name|W
operator||
name|R
operator||
name|O
block|,
literal|"SET LIMITS(10)"
block|}
block|,
comment|/* 34  O   O O    O    PRE-FETCH(10) */
block|{
literal|0x34
block|,
name|D
operator||
name|W
operator||
name|O
operator||
name|K
block|,
literal|"PRE-FETCH(10)"
block|}
block|,
comment|/* 34   M              READ POSITION */
block|{
literal|0x34
block|,
name|T
block|,
literal|"READ POSITION"
block|}
block|,
comment|/* 34                  GET DATA BUFFER STATUS */
block|{
literal|0x34
block|,
name|S
block|,
literal|"GET DATA BUFFER STATUS"
block|}
block|,
comment|/* 35  O   OOO   MO    SYNCHRONIZE CACHE(10) */
block|{
literal|0x35
block|,
name|D
operator||
name|W
operator||
name|R
operator||
name|O
operator||
name|B
operator||
name|K
block|,
literal|"SYNCHRONIZE CACHE(10)"
block|}
block|,
comment|/* 36  Z   O O    O    LOCK UNLOCK CACHE(10) */
block|{
literal|0x36
block|,
name|D
operator||
name|W
operator||
name|O
operator||
name|K
block|,
literal|"LOCK UNLOCK CACHE(10)"
block|}
block|,
comment|/* 37  O     O         READ DEFECT DATA(10) */
block|{
literal|0x37
block|,
name|D
operator||
name|O
block|,
literal|"READ DEFECT DATA(10)"
block|}
block|,
comment|/* 37         O        INITIALIZE ELEMENT STATUS WITH RANGE */
block|{
literal|0x37
block|,
name|M
block|,
literal|"INITIALIZE ELEMENT STATUS WITH RANGE"
block|}
block|,
comment|/* 38      O O    O    MEDIUM SCAN */
block|{
literal|0x38
block|,
name|W
operator||
name|O
operator||
name|K
block|,
literal|"MEDIUM SCAN"
block|}
block|,
comment|/* 39  ZZZZOZO    Z    COMPARE */
block|{
literal|0x39
block|,
name|D
operator||
name|T
operator||
name|L
operator||
name|P
operator||
name|W
operator||
name|R
operator||
name|O
operator||
name|K
operator||
name|S
block|,
literal|"COMPARE"
block|}
block|,
comment|/* 3A  ZZZZOZO    Z    COPY AND VERIFY */
block|{
literal|0x3A
block|,
name|D
operator||
name|T
operator||
name|L
operator||
name|P
operator||
name|W
operator||
name|R
operator||
name|O
operator||
name|K
operator||
name|S
block|,
literal|"COPY AND VERIFY"
block|}
block|,
comment|/* 3B  OOOOOOOOOOMOOO  WRITE BUFFER */
block|{
literal|0x3B
block|,
name|ALL
block|,
literal|"WRITE BUFFER"
block|}
block|,
comment|/* 3C  OOOOOOOOOO OOO  READ BUFFER */
block|{
literal|0x3C
block|,
name|ALL
operator|&
operator|~
operator|(
name|B
operator|)
block|,
literal|"READ BUFFER"
block|}
block|,
comment|/* 3D        O         UPDATE BLOCK */
block|{
literal|0x3D
block|,
name|O
block|,
literal|"UPDATE BLOCK"
block|}
block|,
comment|/* 3E  O   O O         READ LONG(10) */
block|{
literal|0x3E
block|,
name|D
operator||
name|W
operator||
name|O
block|,
literal|"READ LONG(10)"
block|}
block|,
comment|/* 3F  O   O O         WRITE LONG(10) */
block|{
literal|0x3F
block|,
name|D
operator||
name|W
operator||
name|O
block|,
literal|"WRITE LONG(10)"
block|}
block|,
comment|/* 40  ZZZZOZOZ        CHANGE DEFINITION */
block|{
literal|0x40
block|,
name|D
operator||
name|T
operator||
name|L
operator||
name|P
operator||
name|W
operator||
name|R
operator||
name|O
operator||
name|M
operator||
name|S
operator||
name|C
block|,
literal|"CHANGE DEFINITION"
block|}
block|,
comment|/* 41  O               WRITE SAME(10) */
block|{
literal|0x41
block|,
name|D
block|,
literal|"WRITE SAME(10)"
block|}
block|,
comment|/* 42       O          UNMAP */
block|{
literal|0x42
block|,
name|D
block|,
literal|"UNMAP"
block|}
block|,
comment|/* 42       O          READ SUB-CHANNEL */
block|{
literal|0x42
block|,
name|R
block|,
literal|"READ SUB-CHANNEL"
block|}
block|,
comment|/* 43       O          READ TOC/PMA/ATIP */
block|{
literal|0x43
block|,
name|R
block|,
literal|"READ TOC/PMA/ATIP"
block|}
block|,
comment|/* 44   M          M   REPORT DENSITY SUPPORT */
block|{
literal|0x44
block|,
name|T
operator||
name|V
block|,
literal|"REPORT DENSITY SUPPORT"
block|}
block|,
comment|/* 44                  READ HEADER */
comment|/* 45       O          PLAY AUDIO(10) */
block|{
literal|0x45
block|,
name|R
block|,
literal|"PLAY AUDIO(10)"
block|}
block|,
comment|/* 46       M          GET CONFIGURATION */
block|{
literal|0x46
block|,
name|R
block|,
literal|"GET CONFIGURATION"
block|}
block|,
comment|/* 47       O          PLAY AUDIO MSF */
block|{
literal|0x47
block|,
name|R
block|,
literal|"PLAY AUDIO MSF"
block|}
block|,
comment|/* 48 */
comment|/* 49 */
comment|/* 4A       M          GET EVENT STATUS NOTIFICATION */
block|{
literal|0x4A
block|,
name|R
block|,
literal|"GET EVENT STATUS NOTIFICATION"
block|}
block|,
comment|/* 4B       O          PAUSE/RESUME */
block|{
literal|0x4B
block|,
name|R
block|,
literal|"PAUSE/RESUME"
block|}
block|,
comment|/* 4C  OOOOO OOOO OOO  LOG SELECT */
block|{
literal|0x4C
block|,
name|ALL
operator|&
operator|~
operator|(
name|R
operator||
name|B
operator|)
block|,
literal|"LOG SELECT"
block|}
block|,
comment|/* 4D  OOOOO OOOO OMO  LOG SENSE */
block|{
literal|0x4D
block|,
name|ALL
operator|&
operator|~
operator|(
name|R
operator||
name|B
operator|)
block|,
literal|"LOG SENSE"
block|}
block|,
comment|/* 4E       O          STOP PLAY/SCAN */
block|{
literal|0x4E
block|,
name|R
block|,
literal|"STOP PLAY/SCAN"
block|}
block|,
comment|/* 4F */
comment|/* 50  O               XDWRITE(10) */
block|{
literal|0x50
block|,
name|D
block|,
literal|"XDWRITE(10)"
block|}
block|,
comment|/* 51  O               XPWRITE(10) */
block|{
literal|0x51
block|,
name|D
block|,
literal|"XPWRITE(10)"
block|}
block|,
comment|/* 51       O          READ DISC INFORMATION */
block|{
literal|0x51
block|,
name|R
block|,
literal|"READ DISC INFORMATION"
block|}
block|,
comment|/* 52  O               XDREAD(10) */
block|{
literal|0x52
block|,
name|D
block|,
literal|"XDREAD(10)"
block|}
block|,
comment|/* 52       O          READ TRACK INFORMATION */
block|{
literal|0x52
block|,
name|R
block|,
literal|"READ TRACK INFORMATION"
block|}
block|,
comment|/* 53       O          RESERVE TRACK */
block|{
literal|0x53
block|,
name|R
block|,
literal|"RESERVE TRACK"
block|}
block|,
comment|/* 54       O          SEND OPC INFORMATION */
block|{
literal|0x54
block|,
name|R
block|,
literal|"SEND OPC INFORMATION"
block|}
block|,
comment|/* 55  OOO OMOOOOMOMO  MODE SELECT(10) */
block|{
literal|0x55
block|,
name|ALL
operator|&
operator|~
operator|(
name|P
operator|)
block|,
literal|"MODE SELECT(10)"
block|}
block|,
comment|/* 56  ZZMZO OOOZ      RESERVE(10) */
block|{
literal|0x56
block|,
name|ALL
operator|&
operator|~
operator|(
name|R
operator||
name|B
operator||
name|K
operator||
name|V
operator||
name|F
operator||
name|C
operator|)
block|,
literal|"RESERVE(10)"
block|}
block|,
comment|/* 56         Z        RESERVE ELEMENT(10) */
block|{
literal|0x56
block|,
name|M
block|,
literal|"RESERVE ELEMENT(10)"
block|}
block|,
comment|/* 57  ZZMZO OOOZ      RELEASE(10) */
block|{
literal|0x57
block|,
name|ALL
operator|&
operator|~
operator|(
name|R
operator||
name|B
operator||
name|K
operator||
name|V
operator||
name|F
operator||
name|C
operator|)
block|,
literal|"RELEASE(10)"
block|}
block|,
comment|/* 57         Z        RELEASE ELEMENT(10) */
block|{
literal|0x57
block|,
name|M
block|,
literal|"RELEASE ELEMENT(10)"
block|}
block|,
comment|/* 58       O          REPAIR TRACK */
block|{
literal|0x58
block|,
name|R
block|,
literal|"REPAIR TRACK"
block|}
block|,
comment|/* 59 */
comment|/* 5A  OOO OMOOOOMOMO  MODE SENSE(10) */
block|{
literal|0x5A
block|,
name|ALL
operator|&
operator|~
operator|(
name|P
operator|)
block|,
literal|"MODE SENSE(10)"
block|}
block|,
comment|/* 5B       O          CLOSE TRACK/SESSION */
block|{
literal|0x5B
block|,
name|R
block|,
literal|"CLOSE TRACK/SESSION"
block|}
block|,
comment|/* 5C       O          READ BUFFER CAPACITY */
block|{
literal|0x5C
block|,
name|R
block|,
literal|"READ BUFFER CAPACITY"
block|}
block|,
comment|/* 5D       O          SEND CUE SHEET */
block|{
literal|0x5D
block|,
name|R
block|,
literal|"SEND CUE SHEET"
block|}
block|,
comment|/* 5E  OOOOO OOOO   M  PERSISTENT RESERVE IN */
block|{
literal|0x5E
block|,
name|ALL
operator|&
operator|~
operator|(
name|R
operator||
name|B
operator||
name|K
operator||
name|V
operator||
name|C
operator|)
block|,
literal|"PERSISTENT RESERVE IN"
block|}
block|,
comment|/* 5F  OOOOO OOOO   M  PERSISTENT RESERVE OUT */
block|{
literal|0x5F
block|,
name|ALL
operator|&
operator|~
operator|(
name|R
operator||
name|B
operator||
name|K
operator||
name|V
operator||
name|C
operator|)
block|,
literal|"PERSISTENT RESERVE OUT"
block|}
block|,
comment|/* 7E  OO   O OOOO O   extended CDB */
block|{
literal|0x7E
block|,
name|D
operator||
name|T
operator||
name|R
operator||
name|M
operator||
name|A
operator||
name|E
operator||
name|B
operator||
name|V
block|,
literal|"extended CDB"
block|}
block|,
comment|/* 7F  O            M  variable length CDB (more than 16 bytes) */
block|{
literal|0x7F
block|,
name|D
operator||
name|F
block|,
literal|"variable length CDB (more than 16 bytes)"
block|}
block|,
comment|/* 80  Z               XDWRITE EXTENDED(16) */
block|{
literal|0x80
block|,
name|D
block|,
literal|"XDWRITE EXTENDED(16)"
block|}
block|,
comment|/* 80   M              WRITE FILEMARKS(16) */
block|{
literal|0x80
block|,
name|T
block|,
literal|"WRITE FILEMARKS(16)"
block|}
block|,
comment|/* 81  Z               REBUILD(16) */
block|{
literal|0x81
block|,
name|D
block|,
literal|"REBUILD(16)"
block|}
block|,
comment|/* 81   O              READ REVERSE(16) */
block|{
literal|0x81
block|,
name|T
block|,
literal|"READ REVERSE(16)"
block|}
block|,
comment|/* 82  Z               REGENERATE(16) */
block|{
literal|0x82
block|,
name|D
block|,
literal|"REGENERATE(16)"
block|}
block|,
comment|/* 83  OOOOO O    OO   EXTENDED COPY */
block|{
literal|0x83
block|,
name|D
operator||
name|T
operator||
name|L
operator||
name|P
operator||
name|W
operator||
name|O
operator||
name|K
operator||
name|V
block|,
literal|"EXTENDED COPY"
block|}
block|,
comment|/* 84  OOOOO O    OO   RECEIVE COPY RESULTS */
block|{
literal|0x84
block|,
name|D
operator||
name|T
operator||
name|L
operator||
name|P
operator||
name|W
operator||
name|O
operator||
name|K
operator||
name|V
block|,
literal|"RECEIVE COPY RESULTS"
block|}
block|,
comment|/* 85  O    O    O     ATA COMMAND PASS THROUGH(16) */
block|{
literal|0x85
block|,
name|D
operator||
name|R
operator||
name|B
block|,
literal|"ATA COMMAND PASS THROUGH(16)"
block|}
block|,
comment|/* 86  OO OO OOOOOOO   ACCESS CONTROL IN */
block|{
literal|0x86
block|,
name|ALL
operator|&
operator|~
operator|(
name|L
operator||
name|R
operator||
name|F
operator|)
block|,
literal|"ACCESS CONTROL IN"
block|}
block|,
comment|/* 87  OO OO OOOOOOO   ACCESS CONTROL OUT */
block|{
literal|0x87
block|,
name|ALL
operator|&
operator|~
operator|(
name|L
operator||
name|R
operator||
name|F
operator|)
block|,
literal|"ACCESS CONTROL OUT"
block|}
block|,
comment|/* 	 * XXX READ(16)/WRITE(16) were not listed for CD/DVE in op-num.txt 	 * but we had it since r1.40.  Do we really want them? 	 */
comment|/* 88  MM  O O   O     READ(16) */
block|{
literal|0x88
block|,
name|D
operator||
name|T
operator||
name|W
operator||
name|O
operator||
name|B
block|,
literal|"READ(16)"
block|}
block|,
comment|/* 89  O               COMPARE AND WRITE*/
block|{
literal|0x89
block|,
name|D
block|,
literal|"COMPARE AND WRITE"
block|}
block|,
comment|/* 8A  OM  O O   O     WRITE(16) */
block|{
literal|0x8A
block|,
name|D
operator||
name|T
operator||
name|W
operator||
name|O
operator||
name|B
block|,
literal|"WRITE(16)"
block|}
block|,
comment|/* 8B  O               ORWRITE */
block|{
literal|0x8B
block|,
name|D
block|,
literal|"ORWRITE"
block|}
block|,
comment|/* 8C  OO  O OO  O M   READ ATTRIBUTE */
block|{
literal|0x8C
block|,
name|D
operator||
name|T
operator||
name|W
operator||
name|O
operator||
name|M
operator||
name|B
operator||
name|V
block|,
literal|"READ ATTRIBUTE"
block|}
block|,
comment|/* 8D  OO  O OO  O O   WRITE ATTRIBUTE */
block|{
literal|0x8D
block|,
name|D
operator||
name|T
operator||
name|W
operator||
name|O
operator||
name|M
operator||
name|B
operator||
name|V
block|,
literal|"WRITE ATTRIBUTE"
block|}
block|,
comment|/* 8E  O   O O   O     WRITE AND VERIFY(16) */
block|{
literal|0x8E
block|,
name|D
operator||
name|W
operator||
name|O
operator||
name|B
block|,
literal|"WRITE AND VERIFY(16)"
block|}
block|,
comment|/* 8F  OO  O O   O     VERIFY(16) */
block|{
literal|0x8F
block|,
name|D
operator||
name|T
operator||
name|W
operator||
name|O
operator||
name|B
block|,
literal|"VERIFY(16)"
block|}
block|,
comment|/* 90  O   O O   O     PRE-FETCH(16) */
block|{
literal|0x90
block|,
name|D
operator||
name|W
operator||
name|O
operator||
name|B
block|,
literal|"PRE-FETCH(16)"
block|}
block|,
comment|/* 91  O   O O   O     SYNCHRONIZE CACHE(16) */
block|{
literal|0x91
block|,
name|D
operator||
name|W
operator||
name|O
operator||
name|B
block|,
literal|"SYNCHRONIZE CACHE(16)"
block|}
block|,
comment|/* 91   O              SPACE(16) */
block|{
literal|0x91
block|,
name|T
block|,
literal|"SPACE(16)"
block|}
block|,
comment|/* 92  Z   O O         LOCK UNLOCK CACHE(16) */
block|{
literal|0x92
block|,
name|D
operator||
name|W
operator||
name|O
block|,
literal|"LOCK UNLOCK CACHE(16)"
block|}
block|,
comment|/* 92   O              LOCATE(16) */
block|{
literal|0x92
block|,
name|T
block|,
literal|"LOCATE(16)"
block|}
block|,
comment|/* 93  O               WRITE SAME(16) */
block|{
literal|0x93
block|,
name|D
block|,
literal|"WRITE SAME(16)"
block|}
block|,
comment|/* 93   M              ERASE(16) */
block|{
literal|0x93
block|,
name|T
block|,
literal|"ERASE(16)"
block|}
block|,
comment|/* 94 [usage proposed by SCSI Socket Services project] */
comment|/* 95 [usage proposed by SCSI Socket Services project] */
comment|/* 96 [usage proposed by SCSI Socket Services project] */
comment|/* 97 [usage proposed by SCSI Socket Services project] */
comment|/* 98 */
comment|/* 99 */
comment|/* 9A */
comment|/* 9B */
comment|/* 9C */
comment|/* 9D */
comment|/* XXX KDM ALL for this?  op-num.txt defines it for none.. */
comment|/* 9E                  SERVICE ACTION IN(16) */
block|{
literal|0x9E
block|,
name|ALL
block|,
literal|"SERVICE ACTION IN(16)"
block|}
block|,
comment|/* XXX KDM ALL for this?  op-num.txt defines it for ADC.. */
comment|/* 9F              M   SERVICE ACTION OUT(16) */
block|{
literal|0x9F
block|,
name|ALL
block|,
literal|"SERVICE ACTION OUT(16)"
block|}
block|,
comment|/* A0  MMOOO OMMM OMO  REPORT LUNS */
block|{
literal|0xA0
block|,
name|ALL
operator|&
operator|~
operator|(
name|R
operator||
name|B
operator|)
block|,
literal|"REPORT LUNS"
block|}
block|,
comment|/* A1       O          BLANK */
block|{
literal|0xA1
block|,
name|R
block|,
literal|"BLANK"
block|}
block|,
comment|/* A1  O         O     ATA COMMAND PASS THROUGH(12) */
block|{
literal|0xA1
block|,
name|D
operator||
name|B
block|,
literal|"ATA COMMAND PASS THROUGH(12)"
block|}
block|,
comment|/* A2  OO   O      O   SECURITY PROTOCOL IN */
block|{
literal|0xA2
block|,
name|D
operator||
name|T
operator||
name|R
operator||
name|V
block|,
literal|"SECURITY PROTOCOL IN"
block|}
block|,
comment|/* A3  OOO O OOMOOOM   MAINTENANCE (IN) */
block|{
literal|0xA3
block|,
name|ALL
operator|&
operator|~
operator|(
name|P
operator||
name|R
operator||
name|F
operator|)
block|,
literal|"MAINTENANCE (IN)"
block|}
block|,
comment|/* A3       O          SEND KEY */
block|{
literal|0xA3
block|,
name|R
block|,
literal|"SEND KEY"
block|}
block|,
comment|/* A4  OOO O OOOOOOO   MAINTENANCE (OUT) */
block|{
literal|0xA4
block|,
name|ALL
operator|&
operator|~
operator|(
name|P
operator||
name|R
operator||
name|F
operator|)
block|,
literal|"MAINTENANCE (OUT)"
block|}
block|,
comment|/* A4       O          REPORT KEY */
block|{
literal|0xA4
block|,
name|R
block|,
literal|"REPORT KEY"
block|}
block|,
comment|/* A5   O  O OM        MOVE MEDIUM */
block|{
literal|0xA5
block|,
name|T
operator||
name|W
operator||
name|O
operator||
name|M
block|,
literal|"MOVE MEDIUM"
block|}
block|,
comment|/* A5       O          PLAY AUDIO(12) */
block|{
literal|0xA5
block|,
name|R
block|,
literal|"PLAY AUDIO(12)"
block|}
block|,
comment|/* A6         O        EXCHANGE MEDIUM */
block|{
literal|0xA6
block|,
name|M
block|,
literal|"EXCHANGE MEDIUM"
block|}
block|,
comment|/* A6       O          LOAD/UNLOAD C/DVD */
block|{
literal|0xA6
block|,
name|R
block|,
literal|"LOAD/UNLOAD C/DVD"
block|}
block|,
comment|/* A7  ZZ  O O         MOVE MEDIUM ATTACHED */
block|{
literal|0xA7
block|,
name|D
operator||
name|T
operator||
name|W
operator||
name|O
block|,
literal|"MOVE MEDIUM ATTACHED"
block|}
block|,
comment|/* A7       O          SET READ AHEAD */
block|{
literal|0xA7
block|,
name|R
block|,
literal|"SET READ AHEAD"
block|}
block|,
comment|/* A8  O   OOO         READ(12) */
block|{
literal|0xA8
block|,
name|D
operator||
name|W
operator||
name|R
operator||
name|O
block|,
literal|"READ(12)"
block|}
block|,
comment|/* A8                  GET MESSAGE(12) */
block|{
literal|0xA8
block|,
name|C
block|,
literal|"GET MESSAGE(12)"
block|}
block|,
comment|/* A9              O   SERVICE ACTION OUT(12) */
block|{
literal|0xA9
block|,
name|V
block|,
literal|"SERVICE ACTION OUT(12)"
block|}
block|,
comment|/* AA  O   OOO         WRITE(12) */
block|{
literal|0xAA
block|,
name|D
operator||
name|W
operator||
name|R
operator||
name|O
block|,
literal|"WRITE(12)"
block|}
block|,
comment|/* AA                  SEND MESSAGE(12) */
block|{
literal|0xAA
block|,
name|C
block|,
literal|"SEND MESSAGE(12)"
block|}
block|,
comment|/* AB       O      O   SERVICE ACTION IN(12) */
block|{
literal|0xAB
block|,
name|R
operator||
name|V
block|,
literal|"SERVICE ACTION IN(12)"
block|}
block|,
comment|/* AC        O         ERASE(12) */
block|{
literal|0xAC
block|,
name|O
block|,
literal|"ERASE(12)"
block|}
block|,
comment|/* AC       O          GET PERFORMANCE */
block|{
literal|0xAC
block|,
name|R
block|,
literal|"GET PERFORMANCE"
block|}
block|,
comment|/* AD       O          READ DVD STRUCTURE */
block|{
literal|0xAD
block|,
name|R
block|,
literal|"READ DVD STRUCTURE"
block|}
block|,
comment|/* AE  O   O O         WRITE AND VERIFY(12) */
block|{
literal|0xAE
block|,
name|D
operator||
name|W
operator||
name|O
block|,
literal|"WRITE AND VERIFY(12)"
block|}
block|,
comment|/* AF  O   OZO         VERIFY(12) */
block|{
literal|0xAF
block|,
name|D
operator||
name|W
operator||
name|R
operator||
name|O
block|,
literal|"VERIFY(12)"
block|}
block|,
comment|/* B0      ZZZ         SEARCH DATA HIGH(12) */
block|{
literal|0xB0
block|,
name|W
operator||
name|R
operator||
name|O
block|,
literal|"SEARCH DATA HIGH(12)"
block|}
block|,
comment|/* B1      ZZZ         SEARCH DATA EQUAL(12) */
block|{
literal|0xB1
block|,
name|W
operator||
name|R
operator||
name|O
block|,
literal|"SEARCH DATA EQUAL(12)"
block|}
block|,
comment|/* B2      ZZZ         SEARCH DATA LOW(12) */
block|{
literal|0xB2
block|,
name|W
operator||
name|R
operator||
name|O
block|,
literal|"SEARCH DATA LOW(12)"
block|}
block|,
comment|/* B3  Z   OZO         SET LIMITS(12) */
block|{
literal|0xB3
block|,
name|D
operator||
name|W
operator||
name|R
operator||
name|O
block|,
literal|"SET LIMITS(12)"
block|}
block|,
comment|/* B4  ZZ  OZO         READ ELEMENT STATUS ATTACHED */
block|{
literal|0xB4
block|,
name|D
operator||
name|T
operator||
name|W
operator||
name|R
operator||
name|O
block|,
literal|"READ ELEMENT STATUS ATTACHED"
block|}
block|,
comment|/* B5  OO   O      O   SECURITY PROTOCOL OUT */
block|{
literal|0xB5
block|,
name|D
operator||
name|T
operator||
name|R
operator||
name|V
block|,
literal|"SECURITY PROTOCOL OUT"
block|}
block|,
comment|/* B5         O        REQUEST VOLUME ELEMENT ADDRESS */
block|{
literal|0xB5
block|,
name|M
block|,
literal|"REQUEST VOLUME ELEMENT ADDRESS"
block|}
block|,
comment|/* B6         O        SEND VOLUME TAG */
block|{
literal|0xB6
block|,
name|M
block|,
literal|"SEND VOLUME TAG"
block|}
block|,
comment|/* B6       O          SET STREAMING */
block|{
literal|0xB6
block|,
name|R
block|,
literal|"SET STREAMING"
block|}
block|,
comment|/* B7  O     O         READ DEFECT DATA(12) */
block|{
literal|0xB7
block|,
name|D
operator||
name|O
block|,
literal|"READ DEFECT DATA(12)"
block|}
block|,
comment|/* B8   O  OZOM        READ ELEMENT STATUS */
block|{
literal|0xB8
block|,
name|T
operator||
name|W
operator||
name|R
operator||
name|O
operator||
name|M
block|,
literal|"READ ELEMENT STATUS"
block|}
block|,
comment|/* B9       O          READ CD MSF */
block|{
literal|0xB9
block|,
name|R
block|,
literal|"READ CD MSF"
block|}
block|,
comment|/* BA  O   O OOMO      REDUNDANCY GROUP (IN) */
block|{
literal|0xBA
block|,
name|D
operator||
name|W
operator||
name|O
operator||
name|M
operator||
name|A
operator||
name|E
block|,
literal|"REDUNDANCY GROUP (IN)"
block|}
block|,
comment|/* BA       O          SCAN */
block|{
literal|0xBA
block|,
name|R
block|,
literal|"SCAN"
block|}
block|,
comment|/* BB  O   O OOOO      REDUNDANCY GROUP (OUT) */
block|{
literal|0xBB
block|,
name|D
operator||
name|W
operator||
name|O
operator||
name|M
operator||
name|A
operator||
name|E
block|,
literal|"REDUNDANCY GROUP (OUT)"
block|}
block|,
comment|/* BB       O          SET CD SPEED */
block|{
literal|0xBB
block|,
name|R
block|,
literal|"SET CD SPEED"
block|}
block|,
comment|/* BC  O   O OOMO      SPARE (IN) */
block|{
literal|0xBC
block|,
name|D
operator||
name|W
operator||
name|O
operator||
name|M
operator||
name|A
operator||
name|E
block|,
literal|"SPARE (IN)"
block|}
block|,
comment|/* BD  O   O OOOO      SPARE (OUT) */
block|{
literal|0xBD
block|,
name|D
operator||
name|W
operator||
name|O
operator||
name|M
operator||
name|A
operator||
name|E
block|,
literal|"SPARE (OUT)"
block|}
block|,
comment|/* BD       O          MECHANISM STATUS */
block|{
literal|0xBD
block|,
name|R
block|,
literal|"MECHANISM STATUS"
block|}
block|,
comment|/* BE  O   O OOMO      VOLUME SET (IN) */
block|{
literal|0xBE
block|,
name|D
operator||
name|W
operator||
name|O
operator||
name|M
operator||
name|A
operator||
name|E
block|,
literal|"VOLUME SET (IN)"
block|}
block|,
comment|/* BE       O          READ CD */
block|{
literal|0xBE
block|,
name|R
block|,
literal|"READ CD"
block|}
block|,
comment|/* BF  O   O OOOO      VOLUME SET (OUT) */
block|{
literal|0xBF
block|,
name|D
operator||
name|W
operator||
name|O
operator||
name|M
operator||
name|A
operator||
name|E
block|,
literal|"VOLUME SET (OUT)"
block|}
block|,
comment|/* BF       O          SEND DVD STRUCTURE */
block|{
literal|0xBF
block|,
name|R
block|,
literal|"SEND DVD STRUCTURE"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|const
name|char
modifier|*
name|scsi_op_desc
parameter_list|(
name|u_int16_t
name|opcode
parameter_list|,
name|struct
name|scsi_inquiry_data
modifier|*
name|inq_data
parameter_list|)
block|{
name|caddr_t
name|match
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|u_int32_t
name|opmask
decl_stmt|;
name|u_int16_t
name|pd_type
decl_stmt|;
name|int
name|num_ops
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|op_table_entry
modifier|*
name|table
index|[
literal|2
index|]
decl_stmt|;
name|int
name|num_tables
decl_stmt|;
comment|/* 	 * If we've got inquiry data, use it to determine what type of 	 * device we're dealing with here.  Otherwise, assume direct 	 * access. 	 */
if|if
condition|(
name|inq_data
operator|==
name|NULL
condition|)
block|{
name|pd_type
operator|=
name|T_DIRECT
expr_stmt|;
name|match
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|pd_type
operator|=
name|SID_TYPE
argument_list|(
name|inq_data
argument_list|)
expr_stmt|;
name|match
operator|=
name|cam_quirkmatch
argument_list|(
operator|(
name|caddr_t
operator|)
name|inq_data
argument_list|,
operator|(
name|caddr_t
operator|)
name|scsi_op_quirk_table
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_op_quirk_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|scsi_op_quirk_table
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_op_quirk_table
argument_list|)
argument_list|,
name|scsi_inquiry_match
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|match
operator|!=
name|NULL
condition|)
block|{
name|table
index|[
literal|0
index|]
operator|=
operator|(
operator|(
expr|struct
name|scsi_op_quirk_entry
operator|*
operator|)
name|match
operator|)
operator|->
name|op_table
expr_stmt|;
name|num_ops
index|[
literal|0
index|]
operator|=
operator|(
operator|(
expr|struct
name|scsi_op_quirk_entry
operator|*
operator|)
name|match
operator|)
operator|->
name|num_ops
expr_stmt|;
name|table
index|[
literal|1
index|]
operator|=
name|scsi_op_codes
expr_stmt|;
name|num_ops
index|[
literal|1
index|]
operator|=
sizeof|sizeof
argument_list|(
name|scsi_op_codes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|scsi_op_codes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|num_tables
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/*	 		 * If this is true, we have a vendor specific opcode that 		 * wasn't covered in the quirk table. 		 */
if|if
condition|(
operator|(
name|opcode
operator|>
literal|0xBF
operator|)
operator|||
operator|(
operator|(
name|opcode
operator|>
literal|0x5F
operator|)
operator|&&
operator|(
name|opcode
operator|<
literal|0x80
operator|)
operator|)
condition|)
return|return
operator|(
literal|"Vendor Specific Command"
operator|)
return|;
name|table
index|[
literal|0
index|]
operator|=
name|scsi_op_codes
expr_stmt|;
name|num_ops
index|[
literal|0
index|]
operator|=
sizeof|sizeof
argument_list|(
name|scsi_op_codes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|scsi_op_codes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|num_tables
operator|=
literal|1
expr_stmt|;
block|}
comment|/* RBC is 'Simplified' Direct Access Device */
if|if
condition|(
name|pd_type
operator|==
name|T_RBC
condition|)
name|pd_type
operator|=
name|T_DIRECT
expr_stmt|;
comment|/* Map NODEVICE to Direct Access Device to handle REPORT LUNS, etc. */
if|if
condition|(
name|pd_type
operator|==
name|T_NODEVICE
condition|)
name|pd_type
operator|=
name|T_DIRECT
expr_stmt|;
name|opmask
operator|=
literal|1
operator|<<
name|pd_type
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_tables
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_ops
index|[
name|j
index|]
operator|&&
name|table
index|[
name|j
index|]
index|[
name|i
index|]
operator|.
name|opcode
operator|<=
name|opcode
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|table
index|[
name|j
index|]
index|[
name|i
index|]
operator|.
name|opcode
operator|==
name|opcode
operator|)
operator|&&
operator|(
operator|(
name|table
index|[
name|j
index|]
index|[
name|i
index|]
operator|.
name|opmask
operator|&
name|opmask
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return
operator|(
name|table
index|[
name|j
index|]
index|[
name|i
index|]
operator|.
name|desc
operator|)
return|;
block|}
block|}
comment|/* 	 * If we can't find a match for the command in the table, we just 	 * assume it's a vendor specifc command. 	 */
return|return
operator|(
literal|"Vendor Specific Command"
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* SCSI_NO_OP_STRINGS */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|scsi_op_desc
parameter_list|(
name|u_int16_t
name|opcode
parameter_list|,
name|struct
name|scsi_inquiry_data
modifier|*
name|inq_data
parameter_list|)
block|{
return|return
operator|(
literal|""
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SCSI_NO_SENSE_STRINGS
argument_list|)
end_if

begin_define
define|#
directive|define
name|SST
parameter_list|(
name|asc
parameter_list|,
name|ascq
parameter_list|,
name|action
parameter_list|,
name|desc
parameter_list|)
define|\
value|asc, ascq, action, desc
end_define

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|const
name|char
name|empty_string
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SST
parameter_list|(
name|asc
parameter_list|,
name|ascq
parameter_list|,
name|action
parameter_list|,
name|desc
parameter_list|)
define|\
value|asc, ascq, action, empty_string
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|const
name|struct
name|sense_key_table_entry
name|sense_key_table
index|[]
init|=
block|{
block|{
name|SSD_KEY_NO_SENSE
block|,
name|SS_NOP
block|,
literal|"NO SENSE"
block|}
block|,
block|{
name|SSD_KEY_RECOVERED_ERROR
block|,
name|SS_NOP
operator||
name|SSQ_PRINT_SENSE
block|,
literal|"RECOVERED ERROR"
block|}
block|,
block|{
name|SSD_KEY_NOT_READY
block|,
name|SS_RDEF
block|,
literal|"NOT READY"
block|}
block|,
block|{
name|SSD_KEY_MEDIUM_ERROR
block|,
name|SS_RDEF
block|,
literal|"MEDIUM ERROR"
block|}
block|,
block|{
name|SSD_KEY_HARDWARE_ERROR
block|,
name|SS_RDEF
block|,
literal|"HARDWARE FAILURE"
block|}
block|,
block|{
name|SSD_KEY_ILLEGAL_REQUEST
block|,
name|SS_FATAL
operator||
name|EINVAL
block|,
literal|"ILLEGAL REQUEST"
block|}
block|,
block|{
name|SSD_KEY_UNIT_ATTENTION
block|,
name|SS_FATAL
operator||
name|ENXIO
block|,
literal|"UNIT ATTENTION"
block|}
block|,
block|{
name|SSD_KEY_DATA_PROTECT
block|,
name|SS_FATAL
operator||
name|EACCES
block|,
literal|"DATA PROTECT"
block|}
block|,
block|{
name|SSD_KEY_BLANK_CHECK
block|,
name|SS_FATAL
operator||
name|ENOSPC
block|,
literal|"BLANK CHECK"
block|}
block|,
block|{
name|SSD_KEY_Vendor_Specific
block|,
name|SS_FATAL
operator||
name|EIO
block|,
literal|"Vendor Specific"
block|}
block|,
block|{
name|SSD_KEY_COPY_ABORTED
block|,
name|SS_FATAL
operator||
name|EIO
block|,
literal|"COPY ABORTED"
block|}
block|,
block|{
name|SSD_KEY_ABORTED_COMMAND
block|,
name|SS_RDEF
block|,
literal|"ABORTED COMMAND"
block|}
block|,
block|{
name|SSD_KEY_EQUAL
block|,
name|SS_NOP
block|,
literal|"EQUAL"
block|}
block|,
block|{
name|SSD_KEY_VOLUME_OVERFLOW
block|,
name|SS_FATAL
operator||
name|EIO
block|,
literal|"VOLUME OVERFLOW"
block|}
block|,
block|{
name|SSD_KEY_MISCOMPARE
block|,
name|SS_NOP
block|,
literal|"MISCOMPARE"
block|}
block|,
block|{
name|SSD_KEY_COMPLETED
block|,
name|SS_NOP
block|,
literal|"COMPLETED"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|sense_key_table_size
init|=
sizeof|sizeof
argument_list|(
name|sense_key_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|sense_key_table
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|asc_table_entry
name|quantum_fireball_entries
index|[]
init|=
block|{
block|{
name|SST
argument_list|(
literal|0x04
argument_list|,
literal|0x0b
argument_list|,
argument|SS_START | SSQ_DECREMENT_COUNT | ENXIO
argument_list|,
literal|"Logical unit not ready, initializing cmd. required"
argument_list|)
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|asc_table_entry
name|sony_mo_entries
index|[]
init|=
block|{
block|{
name|SST
argument_list|(
literal|0x04
argument_list|,
literal|0x00
argument_list|,
argument|SS_START | SSQ_DECREMENT_COUNT | ENXIO
argument_list|,
literal|"Logical unit not ready, cause not reportable"
argument_list|)
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|asc_table_entry
name|hgst_entries
index|[]
init|=
block|{
block|{
name|SST
argument_list|(
literal|0x04
argument_list|,
literal|0xF0
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Vendor Unique - Logical Unit Not Ready"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x0A
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Unrecovered Super Certification Log Write Error"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x0A
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Unrecovered Super Certification Log Read Error"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x15
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Unrecovered Sector Error"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x3E
argument_list|,
literal|0x04
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Unrecovered Self-Test Hard-Cache Test Fail"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x3E
argument_list|,
literal|0x05
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Unrecovered Self-Test OTF-Cache Fail"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x40
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Unrecovered SAT No Buffer Overflow Error"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x40
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Unrecovered SAT Buffer Overflow Error"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x40
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Unrecovered SAT No Buffer Overflow With ECS Fault"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x40
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Unrecovered SAT Buffer Overflow With ECS Fault"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x40
argument_list|,
literal|0x81
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"DRAM Failure"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x44
argument_list|,
literal|0x0B
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Vendor Unique - Internal Target Failure"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x44
argument_list|,
literal|0xF2
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Vendor Unique - Internal Target Failure"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x44
argument_list|,
literal|0xF6
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Vendor Unique - Internal Target Failure"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x44
argument_list|,
literal|0xF9
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Vendor Unique - Internal Target Failure"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x44
argument_list|,
literal|0xFA
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Vendor Unique - Internal Target Failure"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x22
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Extreme Over-Temperature Warning"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x50
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Load/Unload cycle Count Warning"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x81
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Vendor Unique - Internal Logic Error"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x85
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Vendor Unique - Internal Key Seed Error"
argument_list|)
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|asc_table_entry
name|seagate_entries
index|[]
init|=
block|{
block|{
name|SST
argument_list|(
literal|0x04
argument_list|,
literal|0xF0
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Logical Unit Not Ready, super certify in Progress"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x08
argument_list|,
literal|0x86
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Write Fault Data Corruption"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x09
argument_list|,
literal|0x0D
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Tracking Failure"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x09
argument_list|,
literal|0x0E
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"ETF Failure"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x0B
argument_list|,
literal|0x5D
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Pre-SMART Warning"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x0B
argument_list|,
literal|0x85
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"5V Voltage Warning"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x0B
argument_list|,
literal|0x8C
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"12V Voltage Warning"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x0C
argument_list|,
literal|0xFF
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Write Error - Too many error recovery revs"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x11
argument_list|,
literal|0xFF
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Unrecovered Read Error - Too many error recovery revs"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x19
argument_list|,
literal|0x0E
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Fewer than 1/2 defect list copies"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x20
argument_list|,
literal|0xF3
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Illegal CDB linked to skip mask cmd"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x24
argument_list|,
literal|0xF0
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Illegal byte in CDB, LBA not matching"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x24
argument_list|,
literal|0xF1
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Illegal byte in CDB, LEN not matching"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x24
argument_list|,
literal|0xF2
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Mask not matching transfer length"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x24
argument_list|,
literal|0xF3
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Drive formatted without plist"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x26
argument_list|,
literal|0x95
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Invalid Field Parameter - CAP File"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x26
argument_list|,
literal|0x96
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Invalid Field Parameter - RAP File"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x26
argument_list|,
literal|0x97
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Invalid Field Parameter - TMS Firmware Tag"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x26
argument_list|,
literal|0x98
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Invalid Field Parameter - Check Sum"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x26
argument_list|,
literal|0x99
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Invalid Field Parameter - Firmware Tag"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x29
argument_list|,
literal|0x08
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Write Log Dump data"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x29
argument_list|,
literal|0x09
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Write Log Dump data"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x29
argument_list|,
literal|0x0A
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Reserved disk space"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x29
argument_list|,
literal|0x0B
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"SDBP"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x29
argument_list|,
literal|0x0C
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"SDBP"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x31
argument_list|,
literal|0x91
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Format Corrupted World Wide Name (WWN) is Invalid"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x32
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Defect List - Length exceeds Command Allocated Length"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x33
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Flash not ready for access"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x3F
argument_list|,
literal|0x70
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Invalid RAP block"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x3F
argument_list|,
literal|0x71
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"RAP/ETF mismatch"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x3F
argument_list|,
literal|0x90
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Invalid CAP block"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x3F
argument_list|,
literal|0x91
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"World Wide Name (WWN) Mismatch"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x40
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"DRAM Parity Error"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x40
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"DRAM Parity Error"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x42
argument_list|,
literal|0x0A
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Loopback Test"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x42
argument_list|,
literal|0x0B
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Loopback Test"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x44
argument_list|,
literal|0xF2
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Compare error during data integrity check"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x44
argument_list|,
literal|0xF6
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Unrecoverable error during data integrity check"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x47
argument_list|,
literal|0x80
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Fibre Channel Sequence Error"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x4E
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Information Unit Too Short"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x80
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"General Firmware Error / Command Timeout"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x80
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Command Timeout"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x80
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Command Timeout"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x80
argument_list|,
literal|0x80
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"FC FIFO Error During Read Transfer"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x80
argument_list|,
literal|0x81
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"FC FIFO Error During Write Transfer"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x80
argument_list|,
literal|0x82
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"DISC FIFO Error During Read Transfer"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x80
argument_list|,
literal|0x83
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"DISC FIFO Error During Write Transfer"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x80
argument_list|,
literal|0x84
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"LBA Seeded LRC Error on Read"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x80
argument_list|,
literal|0x85
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"LBA Seeded LRC Error on Write"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x80
argument_list|,
literal|0x86
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"IOEDC Error on Read"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x80
argument_list|,
literal|0x87
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"IOEDC Error on Write"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x80
argument_list|,
literal|0x88
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Host Parity Check Failed"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x80
argument_list|,
literal|0x89
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"IOEDC error on read detected by formatter"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x80
argument_list|,
literal|0x8A
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Host Parity Errors / Host FIFO Initialization Failed"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x80
argument_list|,
literal|0x8B
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Host Parity Errors"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x80
argument_list|,
literal|0x8C
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Host Parity Errors"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x80
argument_list|,
literal|0x8D
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Host Parity Errors"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x81
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"LA Check Failed"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x82
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Internal client detected insufficient buffer"
argument_list|)
block|}
block|,
block|{
name|SST
argument_list|(
literal|0x84
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Scheduled Diagnostic And Repair"
argument_list|)
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|scsi_sense_quirk_entry
name|sense_quirk_table
index|[]
init|=
block|{
block|{
comment|/* 		 * XXX The Quantum Fireball ST and SE like to return 0x04 0x0b 		 * when they really should return 0x04 0x02. 		 */
block|{
name|T_DIRECT
block|,
name|SIP_MEDIA_FIXED
block|,
literal|"QUANTUM"
block|,
literal|"FIREBALL S*"
block|,
literal|"*"
block|}
block|,
comment|/*num_sense_keys*/
literal|0
block|,
sizeof|sizeof
argument_list|(
name|quantum_fireball_entries
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|asc_table_entry
argument_list|)
block|,
comment|/*sense key entries*/
name|NULL
block|,
name|quantum_fireball_entries
block|}
block|,
block|{
comment|/* 		 * This Sony MO drive likes to return 0x04, 0x00 when it 		 * isn't spun up. 		 */
block|{
name|T_DIRECT
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"SONY"
block|,
literal|"SMO-*"
block|,
literal|"*"
block|}
block|,
comment|/*num_sense_keys*/
literal|0
block|,
sizeof|sizeof
argument_list|(
name|sony_mo_entries
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|asc_table_entry
argument_list|)
block|,
comment|/*sense key entries*/
name|NULL
block|,
name|sony_mo_entries
block|}
block|,
block|{
comment|/* 		 * HGST vendor-specific error codes 		 */
block|{
name|T_DIRECT
block|,
name|SIP_MEDIA_FIXED
block|,
literal|"HGST"
block|,
literal|"*"
block|,
literal|"*"
block|}
block|,
comment|/*num_sense_keys*/
literal|0
block|,
sizeof|sizeof
argument_list|(
name|hgst_entries
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|asc_table_entry
argument_list|)
block|,
comment|/*sense key entries*/
name|NULL
block|,
name|hgst_entries
block|}
block|,
block|{
comment|/* 		 * SEAGATE vendor-specific error codes 		 */
block|{
name|T_DIRECT
block|,
name|SIP_MEDIA_FIXED
block|,
literal|"SEAGATE"
block|,
literal|"*"
block|,
literal|"*"
block|}
block|,
comment|/*num_sense_keys*/
literal|0
block|,
sizeof|sizeof
argument_list|(
name|seagate_entries
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|asc_table_entry
argument_list|)
block|,
comment|/*sense key entries*/
name|NULL
block|,
name|seagate_entries
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|sense_quirk_table_size
init|=
sizeof|sizeof
argument_list|(
name|sense_quirk_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|sense_quirk_table
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|asc_table_entry
name|asc_table
index|[]
init|=
block|{
comment|/* 	 * From: http://www.t10.org/lists/asc-num.txt 	 * Modifications by Jung-uk Kim (jkim@FreeBSD.org) 	 */
comment|/* 	 * File: ASC-NUM.TXT 	 * 	 * SCSI ASC/ASCQ Assignments 	 * Numeric Sorted Listing 	 * as of  5/20/12 	 * 	 * D - DIRECT ACCESS DEVICE (SBC-2)                   device column key 	 * .T - SEQUENTIAL ACCESS DEVICE (SSC)               ------------------- 	 * . L - PRINTER DEVICE (SSC)                           blank = reserved 	 * .  P - PROCESSOR DEVICE (SPC)                     not blank = allowed 	 * .  .W - WRITE ONCE READ MULTIPLE DEVICE (SBC-2) 	 * .  . R - CD DEVICE (MMC) 	 * .  .  O - OPTICAL MEMORY DEVICE (SBC-2) 	 * .  .  .M - MEDIA CHANGER DEVICE (SMC) 	 * .  .  . A - STORAGE ARRAY DEVICE (SCC) 	 * .  .  .  E - ENCLOSURE SERVICES DEVICE (SES) 	 * .  .  .  .B - SIMPLIFIED DIRECT-ACCESS DEVICE (RBC) 	 * .  .  .  . K - OPTICAL CARD READER/WRITER DEVICE (OCRW) 	 * .  .  .  .  V - AUTOMATION/DRIVE INTERFACE (ADC) 	 * .  .  .  .  .F - OBJECT-BASED STORAGE (OSD) 	 * DTLPWROMAEBKVF 	 * ASC      ASCQ  Action 	 * Description 	 */
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|,
argument|SS_NOP
argument_list|,
literal|"No additional sense information"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x00
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Filemark detected"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x00
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"End-of-partition/medium detected"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x00
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Setmark detected"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x00
argument_list|,
literal|0x04
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Beginning-of-partition/medium detected"
argument_list|)
block|}
block|,
comment|/*  TL            */
block|{
name|SST
argument_list|(
literal|0x00
argument_list|,
literal|0x05
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"End-of-data detected"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x00
argument_list|,
literal|0x06
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"I/O process terminated"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x00
argument_list|,
literal|0x07
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Programmable early warning detected"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x00
argument_list|,
literal|0x11
argument_list|,
argument|SS_FATAL | EBUSY
argument_list|,
literal|"Audio play operation in progress"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x00
argument_list|,
literal|0x12
argument_list|,
argument|SS_NOP
argument_list|,
literal|"Audio play operation paused"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x00
argument_list|,
literal|0x13
argument_list|,
argument|SS_NOP
argument_list|,
literal|"Audio play operation successfully completed"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x00
argument_list|,
literal|0x14
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Audio play operation stopped due to error"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x00
argument_list|,
literal|0x15
argument_list|,
argument|SS_NOP
argument_list|,
literal|"No current audio status to return"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x00
argument_list|,
literal|0x16
argument_list|,
argument|SS_FATAL | EBUSY
argument_list|,
literal|"Operation in progress"
argument_list|)
block|}
block|,
comment|/* DTL WROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x00
argument_list|,
literal|0x17
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Cleaning requested"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x00
argument_list|,
literal|0x18
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Erase operation in progress"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x00
argument_list|,
literal|0x19
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Locate operation in progress"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x00
argument_list|,
literal|0x1A
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Rewind operation in progress"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x00
argument_list|,
literal|0x1B
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Set capacity operation in progress"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x00
argument_list|,
literal|0x1C
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Verify operation in progress"
argument_list|)
block|}
block|,
comment|/* DT        B    */
block|{
name|SST
argument_list|(
literal|0x00
argument_list|,
literal|0x1D
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"ATA pass through information available"
argument_list|)
block|}
block|,
comment|/* DT   R MAEBKV  */
block|{
name|SST
argument_list|(
literal|0x00
argument_list|,
literal|0x1E
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Conflicting SA creation request"
argument_list|)
block|}
block|,
comment|/* DT        B    */
block|{
name|SST
argument_list|(
literal|0x00
argument_list|,
literal|0x1F
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Logical unit transitioning to another power condition"
argument_list|)
block|}
block|,
comment|/* DT P      B    */
block|{
name|SST
argument_list|(
literal|0x00
argument_list|,
literal|0x20
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Extended copy information available"
argument_list|)
block|}
block|,
comment|/* D   W O   BK   */
block|{
name|SST
argument_list|(
literal|0x01
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"No index/sector signal"
argument_list|)
block|}
block|,
comment|/* D   WRO   BK   */
block|{
name|SST
argument_list|(
literal|0x02
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"No seek complete"
argument_list|)
block|}
block|,
comment|/* DTL W O   BK   */
block|{
name|SST
argument_list|(
literal|0x03
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Peripheral device write fault"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x03
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"No write current"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x03
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Excessive write errors"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x04
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Logical unit not ready, cause not reportable"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x04
argument_list|,
literal|0x01
argument_list|,
argument|SS_TUR | SSQ_MANY | SSQ_DECREMENT_COUNT | EBUSY
argument_list|,
literal|"Logical unit is in process of becoming ready"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x04
argument_list|,
literal|0x02
argument_list|,
argument|SS_START | SSQ_DECREMENT_COUNT | ENXIO
argument_list|,
literal|"Logical unit not ready, initializing command required"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x04
argument_list|,
literal|0x03
argument_list|,
argument|SS_FATAL | ENXIO
argument_list|,
literal|"Logical unit not ready, manual intervention required"
argument_list|)
block|}
block|,
comment|/* DTL  RO   B    */
block|{
name|SST
argument_list|(
literal|0x04
argument_list|,
literal|0x04
argument_list|,
argument|SS_FATAL | EBUSY
argument_list|,
literal|"Logical unit not ready, format in progress"
argument_list|)
block|}
block|,
comment|/* DT  W O A BK F */
block|{
name|SST
argument_list|(
literal|0x04
argument_list|,
literal|0x05
argument_list|,
argument|SS_FATAL | EBUSY
argument_list|,
literal|"Logical unit not ready, rebuild in progress"
argument_list|)
block|}
block|,
comment|/* DT  W O A BK   */
block|{
name|SST
argument_list|(
literal|0x04
argument_list|,
literal|0x06
argument_list|,
argument|SS_FATAL | EBUSY
argument_list|,
literal|"Logical unit not ready, recalculation in progress"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x04
argument_list|,
literal|0x07
argument_list|,
argument|SS_FATAL | EBUSY
argument_list|,
literal|"Logical unit not ready, operation in progress"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x04
argument_list|,
literal|0x08
argument_list|,
argument|SS_FATAL | EBUSY
argument_list|,
literal|"Logical unit not ready, long write in progress"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x04
argument_list|,
literal|0x09
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Logical unit not ready, self-test in progress"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x04
argument_list|,
literal|0x0A
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Logical unit not accessible, asymmetric access state transition"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x04
argument_list|,
literal|0x0B
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Logical unit not accessible, target port in standby state"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x04
argument_list|,
literal|0x0C
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Logical unit not accessible, target port in unavailable state"
argument_list|)
block|}
block|,
comment|/*              F */
block|{
name|SST
argument_list|(
literal|0x04
argument_list|,
literal|0x0D
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Logical unit not ready, structure check required"
argument_list|)
block|}
block|,
comment|/* DT  WROM  B    */
block|{
name|SST
argument_list|(
literal|0x04
argument_list|,
literal|0x10
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Logical unit not ready, auxiliary memory not accessible"
argument_list|)
block|}
block|,
comment|/* DT  WRO AEB VF */
block|{
name|SST
argument_list|(
literal|0x04
argument_list|,
literal|0x11
argument_list|,
argument|SS_TUR | SSQ_MANY | SSQ_DECREMENT_COUNT | EBUSY
argument_list|,
literal|"Logical unit not ready, notify (enable spinup) required"
argument_list|)
block|}
block|,
comment|/*        M    V  */
block|{
name|SST
argument_list|(
literal|0x04
argument_list|,
literal|0x12
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Logical unit not ready, offline"
argument_list|)
block|}
block|,
comment|/* DT   R MAEBKV  */
block|{
name|SST
argument_list|(
literal|0x04
argument_list|,
literal|0x13
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Logical unit not ready, SA creation in progress"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x04
argument_list|,
literal|0x14
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Logical unit not ready, space allocation in progress"
argument_list|)
block|}
block|,
comment|/*        M       */
block|{
name|SST
argument_list|(
literal|0x04
argument_list|,
literal|0x15
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Logical unit not ready, robotics disabled"
argument_list|)
block|}
block|,
comment|/*        M       */
block|{
name|SST
argument_list|(
literal|0x04
argument_list|,
literal|0x16
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Logical unit not ready, configuration required"
argument_list|)
block|}
block|,
comment|/*        M       */
block|{
name|SST
argument_list|(
literal|0x04
argument_list|,
literal|0x17
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Logical unit not ready, calibration required"
argument_list|)
block|}
block|,
comment|/*        M       */
block|{
name|SST
argument_list|(
literal|0x04
argument_list|,
literal|0x18
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Logical unit not ready, a door is open"
argument_list|)
block|}
block|,
comment|/*        M       */
block|{
name|SST
argument_list|(
literal|0x04
argument_list|,
literal|0x19
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Logical unit not ready, operating in sequential mode"
argument_list|)
block|}
block|,
comment|/* DT        B    */
block|{
name|SST
argument_list|(
literal|0x04
argument_list|,
literal|0x1A
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Logical unit not ready, START/STOP UNIT command in progress"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x04
argument_list|,
literal|0x1B
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Logical unit not ready, sanitize in progress"
argument_list|)
block|}
block|,
comment|/* DT     MAEB    */
block|{
name|SST
argument_list|(
literal|0x04
argument_list|,
literal|0x1C
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Logical unit not ready, additional power use not yet granted"
argument_list|)
block|}
block|,
comment|/* DTL WROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x05
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Logical unit does not respond to selection"
argument_list|)
block|}
block|,
comment|/* D   WROM  BK   */
block|{
name|SST
argument_list|(
literal|0x06
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"No reference position found"
argument_list|)
block|}
block|,
comment|/* DTL WROM  BK   */
block|{
name|SST
argument_list|(
literal|0x07
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Multiple peripheral devices selected"
argument_list|)
block|}
block|,
comment|/* DTL WROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x08
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Logical unit communication failure"
argument_list|)
block|}
block|,
comment|/* DTL WROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x08
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Logical unit communication time-out"
argument_list|)
block|}
block|,
comment|/* DTL WROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x08
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Logical unit communication parity error"
argument_list|)
block|}
block|,
comment|/* DT   ROM  BK   */
block|{
name|SST
argument_list|(
literal|0x08
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Logical unit communication CRC error (Ultra-DMA/32)"
argument_list|)
block|}
block|,
comment|/* DTLPWRO    K   */
block|{
name|SST
argument_list|(
literal|0x08
argument_list|,
literal|0x04
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Unreachable copy target"
argument_list|)
block|}
block|,
comment|/* DT  WRO   B    */
block|{
name|SST
argument_list|(
literal|0x09
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Track following error"
argument_list|)
block|}
block|,
comment|/*     WRO    K   */
block|{
name|SST
argument_list|(
literal|0x09
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Tracking servo failure"
argument_list|)
block|}
block|,
comment|/*     WRO    K   */
block|{
name|SST
argument_list|(
literal|0x09
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Focus servo failure"
argument_list|)
block|}
block|,
comment|/*     WRO        */
block|{
name|SST
argument_list|(
literal|0x09
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Spindle servo failure"
argument_list|)
block|}
block|,
comment|/* DT  WRO   B    */
block|{
name|SST
argument_list|(
literal|0x09
argument_list|,
literal|0x04
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Head select fault"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x0A
argument_list|,
literal|0x00
argument_list|,
argument|SS_FATAL | ENOSPC
argument_list|,
literal|"Error log overflow"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x0B
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Warning"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x0B
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Warning - specified temperature exceeded"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x0B
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Warning - enclosure degraded"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x0B
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Warning - background self-test failed"
argument_list|)
block|}
block|,
comment|/* DTLPWRO AEBKVF */
block|{
name|SST
argument_list|(
literal|0x0B
argument_list|,
literal|0x04
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Warning - background pre-scan detected medium error"
argument_list|)
block|}
block|,
comment|/* DTLPWRO AEBKVF */
block|{
name|SST
argument_list|(
literal|0x0B
argument_list|,
literal|0x05
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Warning - background medium scan detected medium error"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x0B
argument_list|,
literal|0x06
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Warning - non-volatile cache now volatile"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x0B
argument_list|,
literal|0x07
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Warning - degraded power to non-volatile cache"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x0B
argument_list|,
literal|0x08
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Warning - power loss expected"
argument_list|)
block|}
block|,
comment|/* D              */
block|{
name|SST
argument_list|(
literal|0x0B
argument_list|,
literal|0x09
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Warning - device statistics notification available"
argument_list|)
block|}
block|,
comment|/*  T   R         */
block|{
name|SST
argument_list|(
literal|0x0C
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Write error"
argument_list|)
block|}
block|,
comment|/*            K   */
block|{
name|SST
argument_list|(
literal|0x0C
argument_list|,
literal|0x01
argument_list|,
argument|SS_NOP | SSQ_PRINT_SENSE
argument_list|,
literal|"Write error - recovered with auto reallocation"
argument_list|)
block|}
block|,
comment|/* D   W O   BK   */
block|{
name|SST
argument_list|(
literal|0x0C
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Write error - auto reallocation failed"
argument_list|)
block|}
block|,
comment|/* D   W O   BK   */
block|{
name|SST
argument_list|(
literal|0x0C
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Write error - recommend reassignment"
argument_list|)
block|}
block|,
comment|/* DT  W O   B    */
block|{
name|SST
argument_list|(
literal|0x0C
argument_list|,
literal|0x04
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Compression check miscompare error"
argument_list|)
block|}
block|,
comment|/* DT  W O   B    */
block|{
name|SST
argument_list|(
literal|0x0C
argument_list|,
literal|0x05
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Data expansion occurred during compression"
argument_list|)
block|}
block|,
comment|/* DT  W O   B    */
block|{
name|SST
argument_list|(
literal|0x0C
argument_list|,
literal|0x06
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Block not compressible"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x0C
argument_list|,
literal|0x07
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Write error - recovery needed"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x0C
argument_list|,
literal|0x08
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Write error - recovery failed"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x0C
argument_list|,
literal|0x09
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Write error - loss of streaming"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x0C
argument_list|,
literal|0x0A
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Write error - padding blocks added"
argument_list|)
block|}
block|,
comment|/* DT  WROM  B    */
block|{
name|SST
argument_list|(
literal|0x0C
argument_list|,
literal|0x0B
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Auxiliary memory write error"
argument_list|)
block|}
block|,
comment|/* DTLPWRO AEBKVF */
block|{
name|SST
argument_list|(
literal|0x0C
argument_list|,
literal|0x0C
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Write error - unexpected unsolicited data"
argument_list|)
block|}
block|,
comment|/* DTLPWRO AEBKVF */
block|{
name|SST
argument_list|(
literal|0x0C
argument_list|,
literal|0x0D
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Write error - not enough unsolicited data"
argument_list|)
block|}
block|,
comment|/* DT  W O   BK   */
block|{
name|SST
argument_list|(
literal|0x0C
argument_list|,
literal|0x0E
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Multiple write errors"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x0C
argument_list|,
literal|0x0F
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Defects in error window"
argument_list|)
block|}
block|,
comment|/* DTLPWRO A  K   */
block|{
name|SST
argument_list|(
literal|0x0D
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Error detected by third party temporary initiator"
argument_list|)
block|}
block|,
comment|/* DTLPWRO A  K   */
block|{
name|SST
argument_list|(
literal|0x0D
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Third party device failure"
argument_list|)
block|}
block|,
comment|/* DTLPWRO A  K   */
block|{
name|SST
argument_list|(
literal|0x0D
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Copy target device not reachable"
argument_list|)
block|}
block|,
comment|/* DTLPWRO A  K   */
block|{
name|SST
argument_list|(
literal|0x0D
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Incorrect copy target device type"
argument_list|)
block|}
block|,
comment|/* DTLPWRO A  K   */
block|{
name|SST
argument_list|(
literal|0x0D
argument_list|,
literal|0x04
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Copy target device data underrun"
argument_list|)
block|}
block|,
comment|/* DTLPWRO A  K   */
block|{
name|SST
argument_list|(
literal|0x0D
argument_list|,
literal|0x05
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Copy target device data overrun"
argument_list|)
block|}
block|,
comment|/* DT PWROMAEBK F */
block|{
name|SST
argument_list|(
literal|0x0E
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Invalid information unit"
argument_list|)
block|}
block|,
comment|/* DT PWROMAEBK F */
block|{
name|SST
argument_list|(
literal|0x0E
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Information unit too short"
argument_list|)
block|}
block|,
comment|/* DT PWROMAEBK F */
block|{
name|SST
argument_list|(
literal|0x0E
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Information unit too long"
argument_list|)
block|}
block|,
comment|/* DT P R MAEBK F */
block|{
name|SST
argument_list|(
literal|0x0E
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Invalid field in command information unit"
argument_list|)
block|}
block|,
comment|/* D   W O   BK   */
block|{
name|SST
argument_list|(
literal|0x10
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"ID CRC or ECC error"
argument_list|)
block|}
block|,
comment|/* DT  W O        */
block|{
name|SST
argument_list|(
literal|0x10
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Logical block guard check failed"
argument_list|)
block|}
block|,
comment|/* DT  W O        */
block|{
name|SST
argument_list|(
literal|0x10
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Logical block application tag check failed"
argument_list|)
block|}
block|,
comment|/* DT  W O        */
block|{
name|SST
argument_list|(
literal|0x10
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Logical block reference tag check failed"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x10
argument_list|,
literal|0x04
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Logical block protection error on recovered buffer data"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x10
argument_list|,
literal|0x05
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Logical block protection method error"
argument_list|)
block|}
block|,
comment|/* DT  WRO   BK   */
block|{
name|SST
argument_list|(
literal|0x11
argument_list|,
literal|0x00
argument_list|,
argument|SS_FATAL|EIO
argument_list|,
literal|"Unrecovered read error"
argument_list|)
block|}
block|,
comment|/* DT  WRO   BK   */
block|{
name|SST
argument_list|(
literal|0x11
argument_list|,
literal|0x01
argument_list|,
argument|SS_FATAL|EIO
argument_list|,
literal|"Read retries exhausted"
argument_list|)
block|}
block|,
comment|/* DT  WRO   BK   */
block|{
name|SST
argument_list|(
literal|0x11
argument_list|,
literal|0x02
argument_list|,
argument|SS_FATAL|EIO
argument_list|,
literal|"Error too long to correct"
argument_list|)
block|}
block|,
comment|/* DT  W O   BK   */
block|{
name|SST
argument_list|(
literal|0x11
argument_list|,
literal|0x03
argument_list|,
argument|SS_FATAL|EIO
argument_list|,
literal|"Multiple read errors"
argument_list|)
block|}
block|,
comment|/* D   W O   BK   */
block|{
name|SST
argument_list|(
literal|0x11
argument_list|,
literal|0x04
argument_list|,
argument|SS_FATAL|EIO
argument_list|,
literal|"Unrecovered read error - auto reallocate failed"
argument_list|)
block|}
block|,
comment|/*     WRO   B    */
block|{
name|SST
argument_list|(
literal|0x11
argument_list|,
literal|0x05
argument_list|,
argument|SS_FATAL|EIO
argument_list|,
literal|"L-EC uncorrectable error"
argument_list|)
block|}
block|,
comment|/*     WRO   B    */
block|{
name|SST
argument_list|(
literal|0x11
argument_list|,
literal|0x06
argument_list|,
argument|SS_FATAL|EIO
argument_list|,
literal|"CIRC unrecovered error"
argument_list|)
block|}
block|,
comment|/*     W O   B    */
block|{
name|SST
argument_list|(
literal|0x11
argument_list|,
literal|0x07
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Data re-synchronization error"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x11
argument_list|,
literal|0x08
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Incomplete block read"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x11
argument_list|,
literal|0x09
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"No gap found"
argument_list|)
block|}
block|,
comment|/* DT    O   BK   */
block|{
name|SST
argument_list|(
literal|0x11
argument_list|,
literal|0x0A
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Miscorrected error"
argument_list|)
block|}
block|,
comment|/* D   W O   BK   */
block|{
name|SST
argument_list|(
literal|0x11
argument_list|,
literal|0x0B
argument_list|,
argument|SS_FATAL|EIO
argument_list|,
literal|"Unrecovered read error - recommend reassignment"
argument_list|)
block|}
block|,
comment|/* D   W O   BK   */
block|{
name|SST
argument_list|(
literal|0x11
argument_list|,
literal|0x0C
argument_list|,
argument|SS_FATAL|EIO
argument_list|,
literal|"Unrecovered read error - recommend rewrite the data"
argument_list|)
block|}
block|,
comment|/* DT  WRO   B    */
block|{
name|SST
argument_list|(
literal|0x11
argument_list|,
literal|0x0D
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"De-compression CRC error"
argument_list|)
block|}
block|,
comment|/* DT  WRO   B    */
block|{
name|SST
argument_list|(
literal|0x11
argument_list|,
literal|0x0E
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Cannot decompress using declared algorithm"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x11
argument_list|,
literal|0x0F
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Error reading UPC/EAN number"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x11
argument_list|,
literal|0x10
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Error reading ISRC number"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x11
argument_list|,
literal|0x11
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Read error - loss of streaming"
argument_list|)
block|}
block|,
comment|/* DT  WROM  B    */
block|{
name|SST
argument_list|(
literal|0x11
argument_list|,
literal|0x12
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Auxiliary memory read error"
argument_list|)
block|}
block|,
comment|/* DTLPWRO AEBKVF */
block|{
name|SST
argument_list|(
literal|0x11
argument_list|,
literal|0x13
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Read error - failed retransmission request"
argument_list|)
block|}
block|,
comment|/* D              */
block|{
name|SST
argument_list|(
literal|0x11
argument_list|,
literal|0x14
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Read error - LBA marked bad by application client"
argument_list|)
block|}
block|,
comment|/* D   W O   BK   */
block|{
name|SST
argument_list|(
literal|0x12
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Address mark not found for ID field"
argument_list|)
block|}
block|,
comment|/* D   W O   BK   */
block|{
name|SST
argument_list|(
literal|0x13
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Address mark not found for data field"
argument_list|)
block|}
block|,
comment|/* DTL WRO   BK   */
block|{
name|SST
argument_list|(
literal|0x14
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Recorded entity not found"
argument_list|)
block|}
block|,
comment|/* DT  WRO   BK   */
block|{
name|SST
argument_list|(
literal|0x14
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Record not found"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x14
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Filemark or setmark not found"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x14
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"End-of-data not found"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x14
argument_list|,
literal|0x04
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Block sequence error"
argument_list|)
block|}
block|,
comment|/* DT  W O   BK   */
block|{
name|SST
argument_list|(
literal|0x14
argument_list|,
literal|0x05
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Record not found - recommend reassignment"
argument_list|)
block|}
block|,
comment|/* DT  W O   BK   */
block|{
name|SST
argument_list|(
literal|0x14
argument_list|,
literal|0x06
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Record not found - data auto-reallocated"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x14
argument_list|,
literal|0x07
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Locate operation failure"
argument_list|)
block|}
block|,
comment|/* DTL WROM  BK   */
block|{
name|SST
argument_list|(
literal|0x15
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Random positioning error"
argument_list|)
block|}
block|,
comment|/* DTL WROM  BK   */
block|{
name|SST
argument_list|(
literal|0x15
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Mechanical positioning error"
argument_list|)
block|}
block|,
comment|/* DT  WRO   BK   */
block|{
name|SST
argument_list|(
literal|0x15
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Positioning error detected by read of medium"
argument_list|)
block|}
block|,
comment|/* D   W O   BK   */
block|{
name|SST
argument_list|(
literal|0x16
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Data synchronization mark error"
argument_list|)
block|}
block|,
comment|/* D   W O   BK   */
block|{
name|SST
argument_list|(
literal|0x16
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Data sync error - data rewritten"
argument_list|)
block|}
block|,
comment|/* D   W O   BK   */
block|{
name|SST
argument_list|(
literal|0x16
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Data sync error - recommend rewrite"
argument_list|)
block|}
block|,
comment|/* D   W O   BK   */
block|{
name|SST
argument_list|(
literal|0x16
argument_list|,
literal|0x03
argument_list|,
argument|SS_NOP | SSQ_PRINT_SENSE
argument_list|,
literal|"Data sync error - data auto-reallocated"
argument_list|)
block|}
block|,
comment|/* D   W O   BK   */
block|{
name|SST
argument_list|(
literal|0x16
argument_list|,
literal|0x04
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Data sync error - recommend reassignment"
argument_list|)
block|}
block|,
comment|/* DT  WRO   BK   */
block|{
name|SST
argument_list|(
literal|0x17
argument_list|,
literal|0x00
argument_list|,
argument|SS_NOP | SSQ_PRINT_SENSE
argument_list|,
literal|"Recovered data with no error correction applied"
argument_list|)
block|}
block|,
comment|/* DT  WRO   BK   */
block|{
name|SST
argument_list|(
literal|0x17
argument_list|,
literal|0x01
argument_list|,
argument|SS_NOP | SSQ_PRINT_SENSE
argument_list|,
literal|"Recovered data with retries"
argument_list|)
block|}
block|,
comment|/* DT  WRO   BK   */
block|{
name|SST
argument_list|(
literal|0x17
argument_list|,
literal|0x02
argument_list|,
argument|SS_NOP | SSQ_PRINT_SENSE
argument_list|,
literal|"Recovered data with positive head offset"
argument_list|)
block|}
block|,
comment|/* DT  WRO   BK   */
block|{
name|SST
argument_list|(
literal|0x17
argument_list|,
literal|0x03
argument_list|,
argument|SS_NOP | SSQ_PRINT_SENSE
argument_list|,
literal|"Recovered data with negative head offset"
argument_list|)
block|}
block|,
comment|/*     WRO   B    */
block|{
name|SST
argument_list|(
literal|0x17
argument_list|,
literal|0x04
argument_list|,
argument|SS_NOP | SSQ_PRINT_SENSE
argument_list|,
literal|"Recovered data with retries and/or CIRC applied"
argument_list|)
block|}
block|,
comment|/* D   WRO   BK   */
block|{
name|SST
argument_list|(
literal|0x17
argument_list|,
literal|0x05
argument_list|,
argument|SS_NOP | SSQ_PRINT_SENSE
argument_list|,
literal|"Recovered data using previous sector ID"
argument_list|)
block|}
block|,
comment|/* D   W O   BK   */
block|{
name|SST
argument_list|(
literal|0x17
argument_list|,
literal|0x06
argument_list|,
argument|SS_NOP | SSQ_PRINT_SENSE
argument_list|,
literal|"Recovered data without ECC - data auto-reallocated"
argument_list|)
block|}
block|,
comment|/* D   WRO   BK   */
block|{
name|SST
argument_list|(
literal|0x17
argument_list|,
literal|0x07
argument_list|,
argument|SS_NOP | SSQ_PRINT_SENSE
argument_list|,
literal|"Recovered data without ECC - recommend reassignment"
argument_list|)
block|}
block|,
comment|/* D   WRO   BK   */
block|{
name|SST
argument_list|(
literal|0x17
argument_list|,
literal|0x08
argument_list|,
argument|SS_NOP | SSQ_PRINT_SENSE
argument_list|,
literal|"Recovered data without ECC - recommend rewrite"
argument_list|)
block|}
block|,
comment|/* D   WRO   BK   */
block|{
name|SST
argument_list|(
literal|0x17
argument_list|,
literal|0x09
argument_list|,
argument|SS_NOP | SSQ_PRINT_SENSE
argument_list|,
literal|"Recovered data without ECC - data rewritten"
argument_list|)
block|}
block|,
comment|/* DT  WRO   BK   */
block|{
name|SST
argument_list|(
literal|0x18
argument_list|,
literal|0x00
argument_list|,
argument|SS_NOP | SSQ_PRINT_SENSE
argument_list|,
literal|"Recovered data with error correction applied"
argument_list|)
block|}
block|,
comment|/* D   WRO   BK   */
block|{
name|SST
argument_list|(
literal|0x18
argument_list|,
literal|0x01
argument_list|,
argument|SS_NOP | SSQ_PRINT_SENSE
argument_list|,
literal|"Recovered data with error corr.& retries applied"
argument_list|)
block|}
block|,
comment|/* D   WRO   BK   */
block|{
name|SST
argument_list|(
literal|0x18
argument_list|,
literal|0x02
argument_list|,
argument|SS_NOP | SSQ_PRINT_SENSE
argument_list|,
literal|"Recovered data - data auto-reallocated"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x18
argument_list|,
literal|0x03
argument_list|,
argument|SS_NOP | SSQ_PRINT_SENSE
argument_list|,
literal|"Recovered data with CIRC"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x18
argument_list|,
literal|0x04
argument_list|,
argument|SS_NOP | SSQ_PRINT_SENSE
argument_list|,
literal|"Recovered data with L-EC"
argument_list|)
block|}
block|,
comment|/* D   WRO   BK   */
block|{
name|SST
argument_list|(
literal|0x18
argument_list|,
literal|0x05
argument_list|,
argument|SS_NOP | SSQ_PRINT_SENSE
argument_list|,
literal|"Recovered data - recommend reassignment"
argument_list|)
block|}
block|,
comment|/* D   WRO   BK   */
block|{
name|SST
argument_list|(
literal|0x18
argument_list|,
literal|0x06
argument_list|,
argument|SS_NOP | SSQ_PRINT_SENSE
argument_list|,
literal|"Recovered data - recommend rewrite"
argument_list|)
block|}
block|,
comment|/* D   W O   BK   */
block|{
name|SST
argument_list|(
literal|0x18
argument_list|,
literal|0x07
argument_list|,
argument|SS_NOP | SSQ_PRINT_SENSE
argument_list|,
literal|"Recovered data with ECC - data rewritten"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x18
argument_list|,
literal|0x08
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Recovered data with linking"
argument_list|)
block|}
block|,
comment|/* D     O    K   */
block|{
name|SST
argument_list|(
literal|0x19
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Defect list error"
argument_list|)
block|}
block|,
comment|/* D     O    K   */
block|{
name|SST
argument_list|(
literal|0x19
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Defect list not available"
argument_list|)
block|}
block|,
comment|/* D     O    K   */
block|{
name|SST
argument_list|(
literal|0x19
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Defect list error in primary list"
argument_list|)
block|}
block|,
comment|/* D     O    K   */
block|{
name|SST
argument_list|(
literal|0x19
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Defect list error in grown list"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x1A
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Parameter list length error"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x1B
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Synchronous data transfer error"
argument_list|)
block|}
block|,
comment|/* D     O   BK   */
block|{
name|SST
argument_list|(
literal|0x1C
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Defect list not found"
argument_list|)
block|}
block|,
comment|/* D     O   BK   */
block|{
name|SST
argument_list|(
literal|0x1C
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Primary defect list not found"
argument_list|)
block|}
block|,
comment|/* D     O   BK   */
block|{
name|SST
argument_list|(
literal|0x1C
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Grown defect list not found"
argument_list|)
block|}
block|,
comment|/* DT  WRO   BK   */
block|{
name|SST
argument_list|(
literal|0x1D
argument_list|,
literal|0x00
argument_list|,
argument|SS_FATAL
argument_list|,
literal|"Miscompare during verify operation"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x1D
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Miscomparable verify of unmapped LBA"
argument_list|)
block|}
block|,
comment|/* D   W O   BK   */
block|{
name|SST
argument_list|(
literal|0x1E
argument_list|,
literal|0x00
argument_list|,
argument|SS_NOP | SSQ_PRINT_SENSE
argument_list|,
literal|"Recovered ID with ECC correction"
argument_list|)
block|}
block|,
comment|/* D     O    K   */
block|{
name|SST
argument_list|(
literal|0x1F
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Partial defect list transfer"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x20
argument_list|,
literal|0x00
argument_list|,
argument|SS_FATAL | EINVAL
argument_list|,
literal|"Invalid command operation code"
argument_list|)
block|}
block|,
comment|/* DT PWROMAEBK   */
block|{
name|SST
argument_list|(
literal|0x20
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Access denied - initiator pending-enrolled"
argument_list|)
block|}
block|,
comment|/* DT PWROMAEBK   */
block|{
name|SST
argument_list|(
literal|0x20
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Access denied - no access rights"
argument_list|)
block|}
block|,
comment|/* DT PWROMAEBK   */
block|{
name|SST
argument_list|(
literal|0x20
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Access denied - invalid mgmt ID key"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x20
argument_list|,
literal|0x04
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Illegal command while in write capable state"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x20
argument_list|,
literal|0x05
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Obsolete"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x20
argument_list|,
literal|0x06
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Illegal command while in explicit address mode"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x20
argument_list|,
literal|0x07
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Illegal command while in implicit address mode"
argument_list|)
block|}
block|,
comment|/* DT PWROMAEBK   */
block|{
name|SST
argument_list|(
literal|0x20
argument_list|,
literal|0x08
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Access denied - enrollment conflict"
argument_list|)
block|}
block|,
comment|/* DT PWROMAEBK   */
block|{
name|SST
argument_list|(
literal|0x20
argument_list|,
literal|0x09
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Access denied - invalid LU identifier"
argument_list|)
block|}
block|,
comment|/* DT PWROMAEBK   */
block|{
name|SST
argument_list|(
literal|0x20
argument_list|,
literal|0x0A
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Access denied - invalid proxy token"
argument_list|)
block|}
block|,
comment|/* DT PWROMAEBK   */
block|{
name|SST
argument_list|(
literal|0x20
argument_list|,
literal|0x0B
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Access denied - ACL LUN conflict"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x20
argument_list|,
literal|0x0C
argument_list|,
argument|SS_FATAL | EINVAL
argument_list|,
literal|"Illegal command when not in append-only mode"
argument_list|)
block|}
block|,
comment|/* DT  WRO   BK   */
block|{
name|SST
argument_list|(
literal|0x21
argument_list|,
literal|0x00
argument_list|,
argument|SS_FATAL | EINVAL
argument_list|,
literal|"Logical block address out of range"
argument_list|)
block|}
block|,
comment|/* DT  WROM  BK   */
block|{
name|SST
argument_list|(
literal|0x21
argument_list|,
literal|0x01
argument_list|,
argument|SS_FATAL | EINVAL
argument_list|,
literal|"Invalid element address"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x21
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Invalid address for write"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x21
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Invalid write crossing layer jump"
argument_list|)
block|}
block|,
comment|/* D              */
block|{
name|SST
argument_list|(
literal|0x22
argument_list|,
literal|0x00
argument_list|,
argument|SS_FATAL | EINVAL
argument_list|,
literal|"Illegal function (use 20 00, 24 00, or 26 00)"
argument_list|)
block|}
block|,
comment|/* DT P      B    */
block|{
name|SST
argument_list|(
literal|0x23
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Invalid token operation, cause not reportable"
argument_list|)
block|}
block|,
comment|/* DT P      B    */
block|{
name|SST
argument_list|(
literal|0x23
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Invalid token operation, unsupported token type"
argument_list|)
block|}
block|,
comment|/* DT P      B    */
block|{
name|SST
argument_list|(
literal|0x23
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Invalid token operation, remote token usage not supported"
argument_list|)
block|}
block|,
comment|/* DT P      B    */
block|{
name|SST
argument_list|(
literal|0x23
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Invalid token operation, remote ROD token creation not supported"
argument_list|)
block|}
block|,
comment|/* DT P      B    */
block|{
name|SST
argument_list|(
literal|0x23
argument_list|,
literal|0x04
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Invalid token operation, token unknown"
argument_list|)
block|}
block|,
comment|/* DT P      B    */
block|{
name|SST
argument_list|(
literal|0x23
argument_list|,
literal|0x05
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Invalid token operation, token corrupt"
argument_list|)
block|}
block|,
comment|/* DT P      B    */
block|{
name|SST
argument_list|(
literal|0x23
argument_list|,
literal|0x06
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Invalid token operation, token revoked"
argument_list|)
block|}
block|,
comment|/* DT P      B    */
block|{
name|SST
argument_list|(
literal|0x23
argument_list|,
literal|0x07
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Invalid token operation, token expired"
argument_list|)
block|}
block|,
comment|/* DT P      B    */
block|{
name|SST
argument_list|(
literal|0x23
argument_list|,
literal|0x08
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Invalid token operation, token cancelled"
argument_list|)
block|}
block|,
comment|/* DT P      B    */
block|{
name|SST
argument_list|(
literal|0x23
argument_list|,
literal|0x09
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Invalid token operation, token deleted"
argument_list|)
block|}
block|,
comment|/* DT P      B    */
block|{
name|SST
argument_list|(
literal|0x23
argument_list|,
literal|0x0A
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Invalid token operation, invalid token length"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x24
argument_list|,
literal|0x00
argument_list|,
argument|SS_FATAL | EINVAL
argument_list|,
literal|"Invalid field in CDB"
argument_list|)
block|}
block|,
comment|/* DTLPWRO AEBKVF */
block|{
name|SST
argument_list|(
literal|0x24
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"CDB decryption error"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x24
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Obsolete"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x24
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Obsolete"
argument_list|)
block|}
block|,
comment|/*              F */
block|{
name|SST
argument_list|(
literal|0x24
argument_list|,
literal|0x04
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Security audit value frozen"
argument_list|)
block|}
block|,
comment|/*              F */
block|{
name|SST
argument_list|(
literal|0x24
argument_list|,
literal|0x05
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Security working key frozen"
argument_list|)
block|}
block|,
comment|/*              F */
block|{
name|SST
argument_list|(
literal|0x24
argument_list|,
literal|0x06
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"NONCE not unique"
argument_list|)
block|}
block|,
comment|/*              F */
block|{
name|SST
argument_list|(
literal|0x24
argument_list|,
literal|0x07
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"NONCE timestamp out of range"
argument_list|)
block|}
block|,
comment|/* DT   R MAEBKV  */
block|{
name|SST
argument_list|(
literal|0x24
argument_list|,
literal|0x08
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Invalid XCDB"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x25
argument_list|,
literal|0x00
argument_list|,
argument|SS_FATAL | ENXIO | SSQ_LOST
argument_list|,
literal|"Logical unit not supported"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x26
argument_list|,
literal|0x00
argument_list|,
argument|SS_FATAL | EINVAL
argument_list|,
literal|"Invalid field in parameter list"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x26
argument_list|,
literal|0x01
argument_list|,
argument|SS_FATAL | EINVAL
argument_list|,
literal|"Parameter not supported"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x26
argument_list|,
literal|0x02
argument_list|,
argument|SS_FATAL | EINVAL
argument_list|,
literal|"Parameter value invalid"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAE K   */
block|{
name|SST
argument_list|(
literal|0x26
argument_list|,
literal|0x03
argument_list|,
argument|SS_FATAL | EINVAL
argument_list|,
literal|"Threshold parameters not supported"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x26
argument_list|,
literal|0x04
argument_list|,
argument|SS_FATAL | EINVAL
argument_list|,
literal|"Invalid release of persistent reservation"
argument_list|)
block|}
block|,
comment|/* DTLPWRO A BK   */
block|{
name|SST
argument_list|(
literal|0x26
argument_list|,
literal|0x05
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Data decryption error"
argument_list|)
block|}
block|,
comment|/* DTLPWRO    K   */
block|{
name|SST
argument_list|(
literal|0x26
argument_list|,
literal|0x06
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Too many target descriptors"
argument_list|)
block|}
block|,
comment|/* DTLPWRO    K   */
block|{
name|SST
argument_list|(
literal|0x26
argument_list|,
literal|0x07
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Unsupported target descriptor type code"
argument_list|)
block|}
block|,
comment|/* DTLPWRO    K   */
block|{
name|SST
argument_list|(
literal|0x26
argument_list|,
literal|0x08
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Too many segment descriptors"
argument_list|)
block|}
block|,
comment|/* DTLPWRO    K   */
block|{
name|SST
argument_list|(
literal|0x26
argument_list|,
literal|0x09
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Unsupported segment descriptor type code"
argument_list|)
block|}
block|,
comment|/* DTLPWRO    K   */
block|{
name|SST
argument_list|(
literal|0x26
argument_list|,
literal|0x0A
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Unexpected inexact segment"
argument_list|)
block|}
block|,
comment|/* DTLPWRO    K   */
block|{
name|SST
argument_list|(
literal|0x26
argument_list|,
literal|0x0B
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Inline data length exceeded"
argument_list|)
block|}
block|,
comment|/* DTLPWRO    K   */
block|{
name|SST
argument_list|(
literal|0x26
argument_list|,
literal|0x0C
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Invalid operation for copy source or destination"
argument_list|)
block|}
block|,
comment|/* DTLPWRO    K   */
block|{
name|SST
argument_list|(
literal|0x26
argument_list|,
literal|0x0D
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Copy segment granularity violation"
argument_list|)
block|}
block|,
comment|/* DT PWROMAEBK   */
block|{
name|SST
argument_list|(
literal|0x26
argument_list|,
literal|0x0E
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Invalid parameter while port is enabled"
argument_list|)
block|}
block|,
comment|/*              F */
block|{
name|SST
argument_list|(
literal|0x26
argument_list|,
literal|0x0F
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Invalid data-out buffer integrity check value"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x26
argument_list|,
literal|0x10
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Data decryption key fail limit reached"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x26
argument_list|,
literal|0x11
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Incomplete key-associated data set"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x26
argument_list|,
literal|0x12
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Vendor specific key reference not found"
argument_list|)
block|}
block|,
comment|/* DT  WRO   BK   */
block|{
name|SST
argument_list|(
literal|0x27
argument_list|,
literal|0x00
argument_list|,
argument|SS_FATAL | EACCES
argument_list|,
literal|"Write protected"
argument_list|)
block|}
block|,
comment|/* DT  WRO   BK   */
block|{
name|SST
argument_list|(
literal|0x27
argument_list|,
literal|0x01
argument_list|,
argument|SS_FATAL | EACCES
argument_list|,
literal|"Hardware write protected"
argument_list|)
block|}
block|,
comment|/* DT  WRO   BK   */
block|{
name|SST
argument_list|(
literal|0x27
argument_list|,
literal|0x02
argument_list|,
argument|SS_FATAL | EACCES
argument_list|,
literal|"Logical unit software write protected"
argument_list|)
block|}
block|,
comment|/*  T   R         */
block|{
name|SST
argument_list|(
literal|0x27
argument_list|,
literal|0x03
argument_list|,
argument|SS_FATAL | EACCES
argument_list|,
literal|"Associated write protect"
argument_list|)
block|}
block|,
comment|/*  T   R         */
block|{
name|SST
argument_list|(
literal|0x27
argument_list|,
literal|0x04
argument_list|,
argument|SS_FATAL | EACCES
argument_list|,
literal|"Persistent write protect"
argument_list|)
block|}
block|,
comment|/*  T   R         */
block|{
name|SST
argument_list|(
literal|0x27
argument_list|,
literal|0x05
argument_list|,
argument|SS_FATAL | EACCES
argument_list|,
literal|"Permanent write protect"
argument_list|)
block|}
block|,
comment|/*      R       F */
block|{
name|SST
argument_list|(
literal|0x27
argument_list|,
literal|0x06
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Conditional write protect"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x27
argument_list|,
literal|0x07
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Space allocation failed write protect"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x28
argument_list|,
literal|0x00
argument_list|,
argument|SS_FATAL | ENXIO
argument_list|,
literal|"Not ready to ready change, medium may have changed"
argument_list|)
block|}
block|,
comment|/* DT  WROM  B    */
block|{
name|SST
argument_list|(
literal|0x28
argument_list|,
literal|0x01
argument_list|,
argument|SS_FATAL | ENXIO
argument_list|,
literal|"Import or export element accessed"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x28
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Format-layer may have changed"
argument_list|)
block|}
block|,
comment|/*        M       */
block|{
name|SST
argument_list|(
literal|0x28
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Import/export element accessed, medium changed"
argument_list|)
block|}
block|,
comment|/* 	 * XXX JGibbs - All of these should use the same errno, but I don't 	 * think ENXIO is the correct choice.  Should we borrow from 	 * the networking errnos?  ECONNRESET anyone? 	 */
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x29
argument_list|,
literal|0x00
argument_list|,
argument|SS_FATAL | ENXIO
argument_list|,
literal|"Power on, reset, or bus device reset occurred"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x29
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Power on occurred"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x29
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"SCSI bus reset occurred"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x29
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Bus device reset function occurred"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x29
argument_list|,
literal|0x04
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Device internal reset"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x29
argument_list|,
literal|0x05
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Transceiver mode changed to single-ended"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x29
argument_list|,
literal|0x06
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Transceiver mode changed to LVD"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x29
argument_list|,
literal|0x07
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"I_T nexus loss occurred"
argument_list|)
block|}
block|,
comment|/* DTL WROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x2A
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Parameters changed"
argument_list|)
block|}
block|,
comment|/* DTL WROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x2A
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Mode parameters changed"
argument_list|)
block|}
block|,
comment|/* DTL WROMAE K   */
block|{
name|SST
argument_list|(
literal|0x2A
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Log parameters changed"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAE K   */
block|{
name|SST
argument_list|(
literal|0x2A
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Reservations preempted"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAE     */
block|{
name|SST
argument_list|(
literal|0x2A
argument_list|,
literal|0x04
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Reservations released"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAE     */
block|{
name|SST
argument_list|(
literal|0x2A
argument_list|,
literal|0x05
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Registrations preempted"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x2A
argument_list|,
literal|0x06
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Asymmetric access state changed"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x2A
argument_list|,
literal|0x07
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Implicit asymmetric access state transition failed"
argument_list|)
block|}
block|,
comment|/* DT  WROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x2A
argument_list|,
literal|0x08
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Priority changed"
argument_list|)
block|}
block|,
comment|/* D              */
block|{
name|SST
argument_list|(
literal|0x2A
argument_list|,
literal|0x09
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Capacity data has changed"
argument_list|)
block|}
block|,
comment|/* DT             */
block|{
name|SST
argument_list|(
literal|0x2A
argument_list|,
literal|0x0A
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Error history I_T nexus cleared"
argument_list|)
block|}
block|,
comment|/* DT             */
block|{
name|SST
argument_list|(
literal|0x2A
argument_list|,
literal|0x0B
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Error history snapshot released"
argument_list|)
block|}
block|,
comment|/*              F */
block|{
name|SST
argument_list|(
literal|0x2A
argument_list|,
literal|0x0C
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Error recovery attributes have changed"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x2A
argument_list|,
literal|0x0D
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Data encryption capabilities changed"
argument_list|)
block|}
block|,
comment|/* DT     M E  V  */
block|{
name|SST
argument_list|(
literal|0x2A
argument_list|,
literal|0x10
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Timestamp changed"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x2A
argument_list|,
literal|0x11
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Data encryption parameters changed by another I_T nexus"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x2A
argument_list|,
literal|0x12
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Data encryption parameters changed by vendor specific event"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x2A
argument_list|,
literal|0x13
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Data encryption key instance counter has changed"
argument_list|)
block|}
block|,
comment|/* DT   R MAEBKV  */
block|{
name|SST
argument_list|(
literal|0x2A
argument_list|,
literal|0x14
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"SA creation capabilities data has changed"
argument_list|)
block|}
block|,
comment|/*  T     M    V  */
block|{
name|SST
argument_list|(
literal|0x2A
argument_list|,
literal|0x15
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Medium removal prevention preempted"
argument_list|)
block|}
block|,
comment|/* DTLPWRO    K   */
block|{
name|SST
argument_list|(
literal|0x2B
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Copy cannot execute since host cannot disconnect"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x2C
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Command sequence error"
argument_list|)
block|}
block|,
comment|/*                */
block|{
name|SST
argument_list|(
literal|0x2C
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Too many windows specified"
argument_list|)
block|}
block|,
comment|/*                */
block|{
name|SST
argument_list|(
literal|0x2C
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Invalid combination of windows specified"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x2C
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Current program area is not empty"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x2C
argument_list|,
literal|0x04
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Current program area is empty"
argument_list|)
block|}
block|,
comment|/*           B    */
block|{
name|SST
argument_list|(
literal|0x2C
argument_list|,
literal|0x05
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Illegal power condition request"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x2C
argument_list|,
literal|0x06
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Persistent prevent conflict"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x2C
argument_list|,
literal|0x07
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Previous busy status"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x2C
argument_list|,
literal|0x08
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Previous task set full status"
argument_list|)
block|}
block|,
comment|/* DTLPWROM EBKVF */
block|{
name|SST
argument_list|(
literal|0x2C
argument_list|,
literal|0x09
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Previous reservation conflict status"
argument_list|)
block|}
block|,
comment|/*              F */
block|{
name|SST
argument_list|(
literal|0x2C
argument_list|,
literal|0x0A
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Partition or collection contains user objects"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x2C
argument_list|,
literal|0x0B
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Not reserved"
argument_list|)
block|}
block|,
comment|/* D              */
block|{
name|SST
argument_list|(
literal|0x2C
argument_list|,
literal|0x0C
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"ORWRITE generation does not match"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x2D
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Overwrite error on update in place"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x2E
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Insufficient time for operation"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x2F
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Commands cleared by another initiator"
argument_list|)
block|}
block|,
comment|/* D              */
block|{
name|SST
argument_list|(
literal|0x2F
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Commands cleared by power loss notification"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x2F
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Commands cleared by device server"
argument_list|)
block|}
block|,
comment|/* DT  WROM  BK   */
block|{
name|SST
argument_list|(
literal|0x30
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Incompatible medium installed"
argument_list|)
block|}
block|,
comment|/* DT  WRO   BK   */
block|{
name|SST
argument_list|(
literal|0x30
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Cannot read medium - unknown format"
argument_list|)
block|}
block|,
comment|/* DT  WRO   BK   */
block|{
name|SST
argument_list|(
literal|0x30
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Cannot read medium - incompatible format"
argument_list|)
block|}
block|,
comment|/* DT   R     K   */
block|{
name|SST
argument_list|(
literal|0x30
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Cleaning cartridge installed"
argument_list|)
block|}
block|,
comment|/* DT  WRO   BK   */
block|{
name|SST
argument_list|(
literal|0x30
argument_list|,
literal|0x04
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Cannot write medium - unknown format"
argument_list|)
block|}
block|,
comment|/* DT  WRO   BK   */
block|{
name|SST
argument_list|(
literal|0x30
argument_list|,
literal|0x05
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Cannot write medium - incompatible format"
argument_list|)
block|}
block|,
comment|/* DT  WRO   B    */
block|{
name|SST
argument_list|(
literal|0x30
argument_list|,
literal|0x06
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Cannot format medium - incompatible medium"
argument_list|)
block|}
block|,
comment|/* DTL WROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x30
argument_list|,
literal|0x07
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Cleaning failure"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x30
argument_list|,
literal|0x08
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Cannot write - application code mismatch"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x30
argument_list|,
literal|0x09
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Current session not fixated for append"
argument_list|)
block|}
block|,
comment|/* DT  WRO AEBK   */
block|{
name|SST
argument_list|(
literal|0x30
argument_list|,
literal|0x0A
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Cleaning request rejected"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x30
argument_list|,
literal|0x0C
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"WORM medium - overwrite attempted"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x30
argument_list|,
literal|0x0D
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"WORM medium - integrity check"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x30
argument_list|,
literal|0x10
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Medium not formatted"
argument_list|)
block|}
block|,
comment|/*        M       */
block|{
name|SST
argument_list|(
literal|0x30
argument_list|,
literal|0x11
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Incompatible volume type"
argument_list|)
block|}
block|,
comment|/*        M       */
block|{
name|SST
argument_list|(
literal|0x30
argument_list|,
literal|0x12
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Incompatible volume qualifier"
argument_list|)
block|}
block|,
comment|/*        M       */
block|{
name|SST
argument_list|(
literal|0x30
argument_list|,
literal|0x13
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Cleaning volume expired"
argument_list|)
block|}
block|,
comment|/* DT  WRO   BK   */
block|{
name|SST
argument_list|(
literal|0x31
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Medium format corrupted"
argument_list|)
block|}
block|,
comment|/* D L  RO   B    */
block|{
name|SST
argument_list|(
literal|0x31
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Format command failed"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x31
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Zoned formatting failed due to spare linking"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x31
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"SANITIZE command failed"
argument_list|)
block|}
block|,
comment|/* D   W O   BK   */
block|{
name|SST
argument_list|(
literal|0x32
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"No defect spare location available"
argument_list|)
block|}
block|,
comment|/* D   W O   BK   */
block|{
name|SST
argument_list|(
literal|0x32
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Defect list update failure"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x33
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Tape length error"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x34
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Enclosure failure"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x35
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Enclosure services failure"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x35
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Unsupported enclosure function"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x35
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Enclosure services unavailable"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x35
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Enclosure services transfer failure"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x35
argument_list|,
literal|0x04
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Enclosure services transfer refused"
argument_list|)
block|}
block|,
comment|/* DTL WROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x35
argument_list|,
literal|0x05
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Enclosure services checksum error"
argument_list|)
block|}
block|,
comment|/*   L            */
block|{
name|SST
argument_list|(
literal|0x36
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Ribbon, ink, or toner failure"
argument_list|)
block|}
block|,
comment|/* DTL WROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x37
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Rounded parameter"
argument_list|)
block|}
block|,
comment|/*           B    */
block|{
name|SST
argument_list|(
literal|0x38
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Event status notification"
argument_list|)
block|}
block|,
comment|/*           B    */
block|{
name|SST
argument_list|(
literal|0x38
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"ESN - power management class event"
argument_list|)
block|}
block|,
comment|/*           B    */
block|{
name|SST
argument_list|(
literal|0x38
argument_list|,
literal|0x04
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"ESN - media class event"
argument_list|)
block|}
block|,
comment|/*           B    */
block|{
name|SST
argument_list|(
literal|0x38
argument_list|,
literal|0x06
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"ESN - device busy class event"
argument_list|)
block|}
block|,
comment|/* D              */
block|{
name|SST
argument_list|(
literal|0x38
argument_list|,
literal|0x07
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Thin provisioning soft threshold reached"
argument_list|)
block|}
block|,
comment|/* DTL WROMAE K   */
block|{
name|SST
argument_list|(
literal|0x39
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Saving parameters not supported"
argument_list|)
block|}
block|,
comment|/* DTL WROM  BK   */
block|{
name|SST
argument_list|(
literal|0x3A
argument_list|,
literal|0x00
argument_list|,
argument|SS_FATAL | ENXIO
argument_list|,
literal|"Medium not present"
argument_list|)
block|}
block|,
comment|/* DT  WROM  BK   */
block|{
name|SST
argument_list|(
literal|0x3A
argument_list|,
literal|0x01
argument_list|,
argument|SS_FATAL | ENXIO
argument_list|,
literal|"Medium not present - tray closed"
argument_list|)
block|}
block|,
comment|/* DT  WROM  BK   */
block|{
name|SST
argument_list|(
literal|0x3A
argument_list|,
literal|0x02
argument_list|,
argument|SS_FATAL | ENXIO
argument_list|,
literal|"Medium not present - tray open"
argument_list|)
block|}
block|,
comment|/* DT  WROM  B    */
block|{
name|SST
argument_list|(
literal|0x3A
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Medium not present - loadable"
argument_list|)
block|}
block|,
comment|/* DT  WRO   B    */
block|{
name|SST
argument_list|(
literal|0x3A
argument_list|,
literal|0x04
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Medium not present - medium auxiliary memory accessible"
argument_list|)
block|}
block|,
comment|/*  TL            */
block|{
name|SST
argument_list|(
literal|0x3B
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Sequential positioning error"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x3B
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Tape position error at beginning-of-medium"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x3B
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Tape position error at end-of-medium"
argument_list|)
block|}
block|,
comment|/*   L            */
block|{
name|SST
argument_list|(
literal|0x3B
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Tape or electronic vertical forms unit not ready"
argument_list|)
block|}
block|,
comment|/*   L            */
block|{
name|SST
argument_list|(
literal|0x3B
argument_list|,
literal|0x04
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Slew failure"
argument_list|)
block|}
block|,
comment|/*   L            */
block|{
name|SST
argument_list|(
literal|0x3B
argument_list|,
literal|0x05
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Paper jam"
argument_list|)
block|}
block|,
comment|/*   L            */
block|{
name|SST
argument_list|(
literal|0x3B
argument_list|,
literal|0x06
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Failed to sense top-of-form"
argument_list|)
block|}
block|,
comment|/*   L            */
block|{
name|SST
argument_list|(
literal|0x3B
argument_list|,
literal|0x07
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Failed to sense bottom-of-form"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x3B
argument_list|,
literal|0x08
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Reposition error"
argument_list|)
block|}
block|,
comment|/*                */
block|{
name|SST
argument_list|(
literal|0x3B
argument_list|,
literal|0x09
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Read past end of medium"
argument_list|)
block|}
block|,
comment|/*                */
block|{
name|SST
argument_list|(
literal|0x3B
argument_list|,
literal|0x0A
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Read past beginning of medium"
argument_list|)
block|}
block|,
comment|/*                */
block|{
name|SST
argument_list|(
literal|0x3B
argument_list|,
literal|0x0B
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Position past end of medium"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x3B
argument_list|,
literal|0x0C
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Position past beginning of medium"
argument_list|)
block|}
block|,
comment|/* DT  WROM  BK   */
block|{
name|SST
argument_list|(
literal|0x3B
argument_list|,
literal|0x0D
argument_list|,
argument|SS_FATAL | ENOSPC
argument_list|,
literal|"Medium destination element full"
argument_list|)
block|}
block|,
comment|/* DT  WROM  BK   */
block|{
name|SST
argument_list|(
literal|0x3B
argument_list|,
literal|0x0E
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Medium source element empty"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x3B
argument_list|,
literal|0x0F
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"End of medium reached"
argument_list|)
block|}
block|,
comment|/* DT  WROM  BK   */
block|{
name|SST
argument_list|(
literal|0x3B
argument_list|,
literal|0x11
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Medium magazine not accessible"
argument_list|)
block|}
block|,
comment|/* DT  WROM  BK   */
block|{
name|SST
argument_list|(
literal|0x3B
argument_list|,
literal|0x12
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Medium magazine removed"
argument_list|)
block|}
block|,
comment|/* DT  WROM  BK   */
block|{
name|SST
argument_list|(
literal|0x3B
argument_list|,
literal|0x13
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Medium magazine inserted"
argument_list|)
block|}
block|,
comment|/* DT  WROM  BK   */
block|{
name|SST
argument_list|(
literal|0x3B
argument_list|,
literal|0x14
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Medium magazine locked"
argument_list|)
block|}
block|,
comment|/* DT  WROM  BK   */
block|{
name|SST
argument_list|(
literal|0x3B
argument_list|,
literal|0x15
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Medium magazine unlocked"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x3B
argument_list|,
literal|0x16
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Mechanical positioning or changer error"
argument_list|)
block|}
block|,
comment|/*              F */
block|{
name|SST
argument_list|(
literal|0x3B
argument_list|,
literal|0x17
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Read past end of user object"
argument_list|)
block|}
block|,
comment|/*        M       */
block|{
name|SST
argument_list|(
literal|0x3B
argument_list|,
literal|0x18
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Element disabled"
argument_list|)
block|}
block|,
comment|/*        M       */
block|{
name|SST
argument_list|(
literal|0x3B
argument_list|,
literal|0x19
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Element enabled"
argument_list|)
block|}
block|,
comment|/*        M       */
block|{
name|SST
argument_list|(
literal|0x3B
argument_list|,
literal|0x1A
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Data transfer device removed"
argument_list|)
block|}
block|,
comment|/*        M       */
block|{
name|SST
argument_list|(
literal|0x3B
argument_list|,
literal|0x1B
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Data transfer device inserted"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x3B
argument_list|,
literal|0x1C
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Too many logical objects on partition to support operation"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAE K   */
block|{
name|SST
argument_list|(
literal|0x3D
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Invalid bits in IDENTIFY message"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x3E
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Logical unit has not self-configured yet"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x3E
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Logical unit failure"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x3E
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Timeout on logical unit"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x3E
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Logical unit failed self-test"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x3E
argument_list|,
literal|0x04
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Logical unit unable to update self-test log"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x3F
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Target operating conditions have changed"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x3F
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Microcode has been changed"
argument_list|)
block|}
block|,
comment|/* DTLPWROM  BK   */
block|{
name|SST
argument_list|(
literal|0x3F
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Changed operating definition"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x3F
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"INQUIRY data has changed"
argument_list|)
block|}
block|,
comment|/* DT  WROMAEBK   */
block|{
name|SST
argument_list|(
literal|0x3F
argument_list|,
literal|0x04
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Component device attached"
argument_list|)
block|}
block|,
comment|/* DT  WROMAEBK   */
block|{
name|SST
argument_list|(
literal|0x3F
argument_list|,
literal|0x05
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Device identifier changed"
argument_list|)
block|}
block|,
comment|/* DT  WROMAEB    */
block|{
name|SST
argument_list|(
literal|0x3F
argument_list|,
literal|0x06
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Redundancy group created or modified"
argument_list|)
block|}
block|,
comment|/* DT  WROMAEB    */
block|{
name|SST
argument_list|(
literal|0x3F
argument_list|,
literal|0x07
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Redundancy group deleted"
argument_list|)
block|}
block|,
comment|/* DT  WROMAEB    */
block|{
name|SST
argument_list|(
literal|0x3F
argument_list|,
literal|0x08
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Spare created or modified"
argument_list|)
block|}
block|,
comment|/* DT  WROMAEB    */
block|{
name|SST
argument_list|(
literal|0x3F
argument_list|,
literal|0x09
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Spare deleted"
argument_list|)
block|}
block|,
comment|/* DT  WROMAEBK   */
block|{
name|SST
argument_list|(
literal|0x3F
argument_list|,
literal|0x0A
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Volume set created or modified"
argument_list|)
block|}
block|,
comment|/* DT  WROMAEBK   */
block|{
name|SST
argument_list|(
literal|0x3F
argument_list|,
literal|0x0B
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Volume set deleted"
argument_list|)
block|}
block|,
comment|/* DT  WROMAEBK   */
block|{
name|SST
argument_list|(
literal|0x3F
argument_list|,
literal|0x0C
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Volume set deassigned"
argument_list|)
block|}
block|,
comment|/* DT  WROMAEBK   */
block|{
name|SST
argument_list|(
literal|0x3F
argument_list|,
literal|0x0D
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Volume set reassigned"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAE     */
block|{
name|SST
argument_list|(
literal|0x3F
argument_list|,
literal|0x0E
argument_list|,
argument|SS_RDEF | SSQ_RESCAN
argument_list|,
literal|"Reported LUNs data has changed"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x3F
argument_list|,
literal|0x0F
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Echo buffer overwritten"
argument_list|)
block|}
block|,
comment|/* DT  WROM  B    */
block|{
name|SST
argument_list|(
literal|0x3F
argument_list|,
literal|0x10
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Medium loadable"
argument_list|)
block|}
block|,
comment|/* DT  WROM  B    */
block|{
name|SST
argument_list|(
literal|0x3F
argument_list|,
literal|0x11
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Medium auxiliary memory accessible"
argument_list|)
block|}
block|,
comment|/* DTLPWR MAEBK F */
block|{
name|SST
argument_list|(
literal|0x3F
argument_list|,
literal|0x12
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"iSCSI IP address added"
argument_list|)
block|}
block|,
comment|/* DTLPWR MAEBK F */
block|{
name|SST
argument_list|(
literal|0x3F
argument_list|,
literal|0x13
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"iSCSI IP address removed"
argument_list|)
block|}
block|,
comment|/* DTLPWR MAEBK F */
block|{
name|SST
argument_list|(
literal|0x3F
argument_list|,
literal|0x14
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"iSCSI IP address changed"
argument_list|)
block|}
block|,
comment|/* D              */
block|{
name|SST
argument_list|(
literal|0x40
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"RAM failure"
argument_list|)
block|}
block|,
comment|/* deprecated - use 40 NN instead */
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x40
argument_list|,
literal|0x80
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Diagnostic failure: ASCQ = Component ID"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x40
argument_list|,
literal|0xFF
argument_list|,
argument|SS_RDEF | SSQ_RANGE
argument_list|,
argument|NULL
argument_list|)
block|}
block|,
comment|/* Range 0x80->0xFF */
comment|/* D              */
block|{
name|SST
argument_list|(
literal|0x41
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Data path failure"
argument_list|)
block|}
block|,
comment|/* deprecated - use 40 NN instead */
comment|/* D              */
block|{
name|SST
argument_list|(
literal|0x42
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Power-on or self-test failure"
argument_list|)
block|}
block|,
comment|/* deprecated - use 40 NN instead */
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x43
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Message error"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x44
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Internal target failure"
argument_list|)
block|}
block|,
comment|/* DT P   MAEBKVF */
block|{
name|SST
argument_list|(
literal|0x44
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Persistent reservation information lost"
argument_list|)
block|}
block|,
comment|/* DT        B    */
block|{
name|SST
argument_list|(
literal|0x44
argument_list|,
literal|0x71
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"ATA device failed set features"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x45
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Select or reselect failure"
argument_list|)
block|}
block|,
comment|/* DTLPWROM  BK   */
block|{
name|SST
argument_list|(
literal|0x46
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Unsuccessful soft reset"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x47
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"SCSI parity error"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x47
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Data phase CRC error detected"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x47
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"SCSI parity error detected during ST data phase"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x47
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Information unit iuCRC error detected"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x47
argument_list|,
literal|0x04
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Asynchronous information protection error detected"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x47
argument_list|,
literal|0x05
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Protocol service CRC error"
argument_list|)
block|}
block|,
comment|/* DT     MAEBKVF */
block|{
name|SST
argument_list|(
literal|0x47
argument_list|,
literal|0x06
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"PHY test function in progress"
argument_list|)
block|}
block|,
comment|/* DT PWROMAEBK   */
block|{
name|SST
argument_list|(
literal|0x47
argument_list|,
literal|0x7F
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Some commands cleared by iSCSI protocol event"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x48
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Initiator detected error message received"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x49
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Invalid message error"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x4A
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Command phase error"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x4B
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Data phase error"
argument_list|)
block|}
block|,
comment|/* DT PWROMAEBK   */
block|{
name|SST
argument_list|(
literal|0x4B
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Invalid target port transfer tag received"
argument_list|)
block|}
block|,
comment|/* DT PWROMAEBK   */
block|{
name|SST
argument_list|(
literal|0x4B
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Too much write data"
argument_list|)
block|}
block|,
comment|/* DT PWROMAEBK   */
block|{
name|SST
argument_list|(
literal|0x4B
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"ACK/NAK timeout"
argument_list|)
block|}
block|,
comment|/* DT PWROMAEBK   */
block|{
name|SST
argument_list|(
literal|0x4B
argument_list|,
literal|0x04
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"NAK received"
argument_list|)
block|}
block|,
comment|/* DT PWROMAEBK   */
block|{
name|SST
argument_list|(
literal|0x4B
argument_list|,
literal|0x05
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Data offset error"
argument_list|)
block|}
block|,
comment|/* DT PWROMAEBK   */
block|{
name|SST
argument_list|(
literal|0x4B
argument_list|,
literal|0x06
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Initiator response timeout"
argument_list|)
block|}
block|,
comment|/* DT PWROMAEBK F */
block|{
name|SST
argument_list|(
literal|0x4B
argument_list|,
literal|0x07
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Connection lost"
argument_list|)
block|}
block|,
comment|/* DT PWROMAEBK F */
block|{
name|SST
argument_list|(
literal|0x4B
argument_list|,
literal|0x08
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Data-in buffer overflow - data buffer size"
argument_list|)
block|}
block|,
comment|/* DT PWROMAEBK F */
block|{
name|SST
argument_list|(
literal|0x4B
argument_list|,
literal|0x09
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Data-in buffer overflow - data buffer descriptor area"
argument_list|)
block|}
block|,
comment|/* DT PWROMAEBK F */
block|{
name|SST
argument_list|(
literal|0x4B
argument_list|,
literal|0x0A
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Data-in buffer error"
argument_list|)
block|}
block|,
comment|/* DT PWROMAEBK F */
block|{
name|SST
argument_list|(
literal|0x4B
argument_list|,
literal|0x0B
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Data-out buffer overflow - data buffer size"
argument_list|)
block|}
block|,
comment|/* DT PWROMAEBK F */
block|{
name|SST
argument_list|(
literal|0x4B
argument_list|,
literal|0x0C
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Data-out buffer overflow - data buffer descriptor area"
argument_list|)
block|}
block|,
comment|/* DT PWROMAEBK F */
block|{
name|SST
argument_list|(
literal|0x4B
argument_list|,
literal|0x0D
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Data-out buffer error"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x4C
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Logical unit failed self-configuration"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x4D
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Tagged overlapped commands: ASCQ = Queue tag ID"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x4D
argument_list|,
literal|0xFF
argument_list|,
argument|SS_RDEF | SSQ_RANGE
argument_list|,
argument|NULL
argument_list|)
block|}
block|,
comment|/* Range 0x00->0xFF */
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x4E
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Overlapped commands attempted"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x50
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Write append error"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x50
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Write append position error"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x50
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Position error related to timing"
argument_list|)
block|}
block|,
comment|/*  T   RO        */
block|{
name|SST
argument_list|(
literal|0x51
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Erase failure"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x51
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Erase failure - incomplete erase operation detected"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x52
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Cartridge fault"
argument_list|)
block|}
block|,
comment|/* DTL WROM  BK   */
block|{
name|SST
argument_list|(
literal|0x53
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Media load or eject failed"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x53
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Unload tape failure"
argument_list|)
block|}
block|,
comment|/* DT  WROM  BK   */
block|{
name|SST
argument_list|(
literal|0x53
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Medium removal prevented"
argument_list|)
block|}
block|,
comment|/*        M       */
block|{
name|SST
argument_list|(
literal|0x53
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Medium removal prevented by data transfer element"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x53
argument_list|,
literal|0x04
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Medium thread or unthread failure"
argument_list|)
block|}
block|,
comment|/*        M       */
block|{
name|SST
argument_list|(
literal|0x53
argument_list|,
literal|0x05
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Volume identifier invalid"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x53
argument_list|,
literal|0x06
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Volume identifier missing"
argument_list|)
block|}
block|,
comment|/*        M       */
block|{
name|SST
argument_list|(
literal|0x53
argument_list|,
literal|0x07
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Duplicate volume identifier"
argument_list|)
block|}
block|,
comment|/*        M       */
block|{
name|SST
argument_list|(
literal|0x53
argument_list|,
literal|0x08
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Element status unknown"
argument_list|)
block|}
block|,
comment|/*    P           */
block|{
name|SST
argument_list|(
literal|0x54
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"SCSI to host system interface failure"
argument_list|)
block|}
block|,
comment|/*    P           */
block|{
name|SST
argument_list|(
literal|0x55
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"System resource failure"
argument_list|)
block|}
block|,
comment|/* D     O   BK   */
block|{
name|SST
argument_list|(
literal|0x55
argument_list|,
literal|0x01
argument_list|,
argument|SS_FATAL | ENOSPC
argument_list|,
literal|"System buffer full"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAE K   */
block|{
name|SST
argument_list|(
literal|0x55
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Insufficient reservation resources"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAE K   */
block|{
name|SST
argument_list|(
literal|0x55
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Insufficient resources"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAE K   */
block|{
name|SST
argument_list|(
literal|0x55
argument_list|,
literal|0x04
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Insufficient registration resources"
argument_list|)
block|}
block|,
comment|/* DT PWROMAEBK   */
block|{
name|SST
argument_list|(
literal|0x55
argument_list|,
literal|0x05
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Insufficient access control resources"
argument_list|)
block|}
block|,
comment|/* DT  WROM  B    */
block|{
name|SST
argument_list|(
literal|0x55
argument_list|,
literal|0x06
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Auxiliary memory out of space"
argument_list|)
block|}
block|,
comment|/*              F */
block|{
name|SST
argument_list|(
literal|0x55
argument_list|,
literal|0x07
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Quota error"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x55
argument_list|,
literal|0x08
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Maximum number of supplemental decryption keys exceeded"
argument_list|)
block|}
block|,
comment|/*        M       */
block|{
name|SST
argument_list|(
literal|0x55
argument_list|,
literal|0x09
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Medium auxiliary memory not accessible"
argument_list|)
block|}
block|,
comment|/*        M       */
block|{
name|SST
argument_list|(
literal|0x55
argument_list|,
literal|0x0A
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Data currently unavailable"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x55
argument_list|,
literal|0x0B
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Insufficient power for operation"
argument_list|)
block|}
block|,
comment|/* DT P      B    */
block|{
name|SST
argument_list|(
literal|0x55
argument_list|,
literal|0x0C
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Insufficient resources to create ROD"
argument_list|)
block|}
block|,
comment|/* DT P      B    */
block|{
name|SST
argument_list|(
literal|0x55
argument_list|,
literal|0x0D
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Insufficient resources to create ROD token"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x57
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Unable to recover table-of-contents"
argument_list|)
block|}
block|,
comment|/*       O        */
block|{
name|SST
argument_list|(
literal|0x58
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Generation does not exist"
argument_list|)
block|}
block|,
comment|/*       O        */
block|{
name|SST
argument_list|(
literal|0x59
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Updated block read"
argument_list|)
block|}
block|,
comment|/* DTLPWRO   BK   */
block|{
name|SST
argument_list|(
literal|0x5A
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Operator request or state change input"
argument_list|)
block|}
block|,
comment|/* DT  WROM  BK   */
block|{
name|SST
argument_list|(
literal|0x5A
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Operator medium removal request"
argument_list|)
block|}
block|,
comment|/* DT  WRO A BK   */
block|{
name|SST
argument_list|(
literal|0x5A
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Operator selected write protect"
argument_list|)
block|}
block|,
comment|/* DT  WRO A BK   */
block|{
name|SST
argument_list|(
literal|0x5A
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Operator selected write permit"
argument_list|)
block|}
block|,
comment|/* DTLPWROM   K   */
block|{
name|SST
argument_list|(
literal|0x5B
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Log exception"
argument_list|)
block|}
block|,
comment|/* DTLPWROM   K   */
block|{
name|SST
argument_list|(
literal|0x5B
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Threshold condition met"
argument_list|)
block|}
block|,
comment|/* DTLPWROM   K   */
block|{
name|SST
argument_list|(
literal|0x5B
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Log counter at maximum"
argument_list|)
block|}
block|,
comment|/* DTLPWROM   K   */
block|{
name|SST
argument_list|(
literal|0x5B
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Log list codes exhausted"
argument_list|)
block|}
block|,
comment|/* D     O        */
block|{
name|SST
argument_list|(
literal|0x5C
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"RPL status change"
argument_list|)
block|}
block|,
comment|/* D     O        */
block|{
name|SST
argument_list|(
literal|0x5C
argument_list|,
literal|0x01
argument_list|,
argument|SS_NOP | SSQ_PRINT_SENSE
argument_list|,
literal|"Spindles synchronized"
argument_list|)
block|}
block|,
comment|/* D     O        */
block|{
name|SST
argument_list|(
literal|0x5C
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Spindles not synchronized"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Failure prediction threshold exceeded"
argument_list|)
block|}
block|,
comment|/*      R    B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Media failure prediction threshold exceeded"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Logical unit failure prediction threshold exceeded"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Spare area exhaustion prediction threshold exceeded"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x10
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Hardware impending failure general hard drive failure"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x11
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Hardware impending failure drive error rate too high"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x12
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Hardware impending failure data error rate too high"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x13
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Hardware impending failure seek error rate too high"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x14
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Hardware impending failure too many block reassigns"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x15
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Hardware impending failure access times too high"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x16
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Hardware impending failure start unit times too high"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x17
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Hardware impending failure channel parametrics"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x18
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Hardware impending failure controller detected"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x19
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Hardware impending failure throughput performance"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x1A
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Hardware impending failure seek time performance"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x1B
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Hardware impending failure spin-up retry count"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x1C
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Hardware impending failure drive calibration retry count"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x20
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Controller impending failure general hard drive failure"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x21
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Controller impending failure drive error rate too high"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x22
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Controller impending failure data error rate too high"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x23
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Controller impending failure seek error rate too high"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x24
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Controller impending failure too many block reassigns"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x25
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Controller impending failure access times too high"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x26
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Controller impending failure start unit times too high"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x27
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Controller impending failure channel parametrics"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x28
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Controller impending failure controller detected"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x29
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Controller impending failure throughput performance"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x2A
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Controller impending failure seek time performance"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x2B
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Controller impending failure spin-up retry count"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x2C
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Controller impending failure drive calibration retry count"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x30
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Data channel impending failure general hard drive failure"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x31
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Data channel impending failure drive error rate too high"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x32
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Data channel impending failure data error rate too high"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x33
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Data channel impending failure seek error rate too high"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x34
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Data channel impending failure too many block reassigns"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x35
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Data channel impending failure access times too high"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x36
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Data channel impending failure start unit times too high"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x37
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Data channel impending failure channel parametrics"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x38
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Data channel impending failure controller detected"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x39
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Data channel impending failure throughput performance"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x3A
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Data channel impending failure seek time performance"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x3B
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Data channel impending failure spin-up retry count"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x3C
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Data channel impending failure drive calibration retry count"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x40
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Servo impending failure general hard drive failure"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x41
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Servo impending failure drive error rate too high"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x42
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Servo impending failure data error rate too high"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x43
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Servo impending failure seek error rate too high"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x44
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Servo impending failure too many block reassigns"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x45
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Servo impending failure access times too high"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x46
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Servo impending failure start unit times too high"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x47
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Servo impending failure channel parametrics"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x48
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Servo impending failure controller detected"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x49
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Servo impending failure throughput performance"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x4A
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Servo impending failure seek time performance"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x4B
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Servo impending failure spin-up retry count"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x4C
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Servo impending failure drive calibration retry count"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x50
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Spindle impending failure general hard drive failure"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x51
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Spindle impending failure drive error rate too high"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x52
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Spindle impending failure data error rate too high"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x53
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Spindle impending failure seek error rate too high"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x54
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Spindle impending failure too many block reassigns"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x55
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Spindle impending failure access times too high"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x56
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Spindle impending failure start unit times too high"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x57
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Spindle impending failure channel parametrics"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x58
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Spindle impending failure controller detected"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x59
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Spindle impending failure throughput performance"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x5A
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Spindle impending failure seek time performance"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x5B
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Spindle impending failure spin-up retry count"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x5C
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Spindle impending failure drive calibration retry count"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x60
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Firmware impending failure general hard drive failure"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x61
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Firmware impending failure drive error rate too high"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x62
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Firmware impending failure data error rate too high"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x63
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Firmware impending failure seek error rate too high"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x64
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Firmware impending failure too many block reassigns"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x65
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Firmware impending failure access times too high"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x66
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Firmware impending failure start unit times too high"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x67
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Firmware impending failure channel parametrics"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x68
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Firmware impending failure controller detected"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x69
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Firmware impending failure throughput performance"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x6A
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Firmware impending failure seek time performance"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x6B
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Firmware impending failure spin-up retry count"
argument_list|)
block|}
block|,
comment|/* D         B    */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x6C
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Firmware impending failure drive calibration retry count"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0xFF
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Failure prediction threshold exceeded (false)"
argument_list|)
block|}
block|,
comment|/* DTLPWRO A  K   */
block|{
name|SST
argument_list|(
literal|0x5E
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Low power condition on"
argument_list|)
block|}
block|,
comment|/* DTLPWRO A  K   */
block|{
name|SST
argument_list|(
literal|0x5E
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Idle condition activated by timer"
argument_list|)
block|}
block|,
comment|/* DTLPWRO A  K   */
block|{
name|SST
argument_list|(
literal|0x5E
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Standby condition activated by timer"
argument_list|)
block|}
block|,
comment|/* DTLPWRO A  K   */
block|{
name|SST
argument_list|(
literal|0x5E
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Idle condition activated by command"
argument_list|)
block|}
block|,
comment|/* DTLPWRO A  K   */
block|{
name|SST
argument_list|(
literal|0x5E
argument_list|,
literal|0x04
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Standby condition activated by command"
argument_list|)
block|}
block|,
comment|/* DTLPWRO A  K   */
block|{
name|SST
argument_list|(
literal|0x5E
argument_list|,
literal|0x05
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Idle-B condition activated by timer"
argument_list|)
block|}
block|,
comment|/* DTLPWRO A  K   */
block|{
name|SST
argument_list|(
literal|0x5E
argument_list|,
literal|0x06
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Idle-B condition activated by command"
argument_list|)
block|}
block|,
comment|/* DTLPWRO A  K   */
block|{
name|SST
argument_list|(
literal|0x5E
argument_list|,
literal|0x07
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Idle-C condition activated by timer"
argument_list|)
block|}
block|,
comment|/* DTLPWRO A  K   */
block|{
name|SST
argument_list|(
literal|0x5E
argument_list|,
literal|0x08
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Idle-C condition activated by command"
argument_list|)
block|}
block|,
comment|/* DTLPWRO A  K   */
block|{
name|SST
argument_list|(
literal|0x5E
argument_list|,
literal|0x09
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Standby-Y condition activated by timer"
argument_list|)
block|}
block|,
comment|/* DTLPWRO A  K   */
block|{
name|SST
argument_list|(
literal|0x5E
argument_list|,
literal|0x0A
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Standby-Y condition activated by command"
argument_list|)
block|}
block|,
comment|/*           B    */
block|{
name|SST
argument_list|(
literal|0x5E
argument_list|,
literal|0x41
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Power state change to active"
argument_list|)
block|}
block|,
comment|/*           B    */
block|{
name|SST
argument_list|(
literal|0x5E
argument_list|,
literal|0x42
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Power state change to idle"
argument_list|)
block|}
block|,
comment|/*           B    */
block|{
name|SST
argument_list|(
literal|0x5E
argument_list|,
literal|0x43
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Power state change to standby"
argument_list|)
block|}
block|,
comment|/*           B    */
block|{
name|SST
argument_list|(
literal|0x5E
argument_list|,
literal|0x45
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Power state change to sleep"
argument_list|)
block|}
block|,
comment|/*           BK   */
block|{
name|SST
argument_list|(
literal|0x5E
argument_list|,
literal|0x47
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Power state change to device control"
argument_list|)
block|}
block|,
comment|/*                */
block|{
name|SST
argument_list|(
literal|0x60
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Lamp failure"
argument_list|)
block|}
block|,
comment|/*                */
block|{
name|SST
argument_list|(
literal|0x61
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Video acquisition error"
argument_list|)
block|}
block|,
comment|/*                */
block|{
name|SST
argument_list|(
literal|0x61
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Unable to acquire video"
argument_list|)
block|}
block|,
comment|/*                */
block|{
name|SST
argument_list|(
literal|0x61
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Out of focus"
argument_list|)
block|}
block|,
comment|/*                */
block|{
name|SST
argument_list|(
literal|0x62
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Scan head positioning error"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x63
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"End of user area encountered on this track"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x63
argument_list|,
literal|0x01
argument_list|,
argument|SS_FATAL | ENOSPC
argument_list|,
literal|"Packet does not fit in available space"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x64
argument_list|,
literal|0x00
argument_list|,
argument|SS_FATAL | ENXIO
argument_list|,
literal|"Illegal mode for this track"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x64
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Invalid packet size"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x65
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Voltage fault"
argument_list|)
block|}
block|,
comment|/*                */
block|{
name|SST
argument_list|(
literal|0x66
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Automatic document feeder cover up"
argument_list|)
block|}
block|,
comment|/*                */
block|{
name|SST
argument_list|(
literal|0x66
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Automatic document feeder lift up"
argument_list|)
block|}
block|,
comment|/*                */
block|{
name|SST
argument_list|(
literal|0x66
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Document jam in automatic document feeder"
argument_list|)
block|}
block|,
comment|/*                */
block|{
name|SST
argument_list|(
literal|0x66
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Document miss feed automatic in document feeder"
argument_list|)
block|}
block|,
comment|/*         A      */
block|{
name|SST
argument_list|(
literal|0x67
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Configuration failure"
argument_list|)
block|}
block|,
comment|/*         A      */
block|{
name|SST
argument_list|(
literal|0x67
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Configuration of incapable logical units failed"
argument_list|)
block|}
block|,
comment|/*         A      */
block|{
name|SST
argument_list|(
literal|0x67
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Add logical unit failed"
argument_list|)
block|}
block|,
comment|/*         A      */
block|{
name|SST
argument_list|(
literal|0x67
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Modification of logical unit failed"
argument_list|)
block|}
block|,
comment|/*         A      */
block|{
name|SST
argument_list|(
literal|0x67
argument_list|,
literal|0x04
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Exchange of logical unit failed"
argument_list|)
block|}
block|,
comment|/*         A      */
block|{
name|SST
argument_list|(
literal|0x67
argument_list|,
literal|0x05
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Remove of logical unit failed"
argument_list|)
block|}
block|,
comment|/*         A      */
block|{
name|SST
argument_list|(
literal|0x67
argument_list|,
literal|0x06
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Attachment of logical unit failed"
argument_list|)
block|}
block|,
comment|/*         A      */
block|{
name|SST
argument_list|(
literal|0x67
argument_list|,
literal|0x07
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Creation of logical unit failed"
argument_list|)
block|}
block|,
comment|/*         A      */
block|{
name|SST
argument_list|(
literal|0x67
argument_list|,
literal|0x08
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Assign failure occurred"
argument_list|)
block|}
block|,
comment|/*         A      */
block|{
name|SST
argument_list|(
literal|0x67
argument_list|,
literal|0x09
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Multiply assigned logical unit"
argument_list|)
block|}
block|,
comment|/* DTLPWROMAEBKVF */
block|{
name|SST
argument_list|(
literal|0x67
argument_list|,
literal|0x0A
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Set target port groups command failed"
argument_list|)
block|}
block|,
comment|/* DT        B    */
block|{
name|SST
argument_list|(
literal|0x67
argument_list|,
literal|0x0B
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"ATA device feature not enabled"
argument_list|)
block|}
block|,
comment|/*         A      */
block|{
name|SST
argument_list|(
literal|0x68
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Logical unit not configured"
argument_list|)
block|}
block|,
comment|/*         A      */
block|{
name|SST
argument_list|(
literal|0x69
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Data loss on logical unit"
argument_list|)
block|}
block|,
comment|/*         A      */
block|{
name|SST
argument_list|(
literal|0x69
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Multiple logical unit failures"
argument_list|)
block|}
block|,
comment|/*         A      */
block|{
name|SST
argument_list|(
literal|0x69
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Parity/data mismatch"
argument_list|)
block|}
block|,
comment|/*         A      */
block|{
name|SST
argument_list|(
literal|0x6A
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Informational, refer to log"
argument_list|)
block|}
block|,
comment|/*         A      */
block|{
name|SST
argument_list|(
literal|0x6B
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"State change has occurred"
argument_list|)
block|}
block|,
comment|/*         A      */
block|{
name|SST
argument_list|(
literal|0x6B
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Redundancy level got better"
argument_list|)
block|}
block|,
comment|/*         A      */
block|{
name|SST
argument_list|(
literal|0x6B
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Redundancy level got worse"
argument_list|)
block|}
block|,
comment|/*         A      */
block|{
name|SST
argument_list|(
literal|0x6C
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Rebuild failure occurred"
argument_list|)
block|}
block|,
comment|/*         A      */
block|{
name|SST
argument_list|(
literal|0x6D
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Recalculate failure occurred"
argument_list|)
block|}
block|,
comment|/*         A      */
block|{
name|SST
argument_list|(
literal|0x6E
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Command to logical unit failed"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x6F
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Copy protection key exchange failure - authentication failure"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x6F
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Copy protection key exchange failure - key not present"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x6F
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Copy protection key exchange failure - key not established"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x6F
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Read of scrambled sector without authentication"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x6F
argument_list|,
literal|0x04
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Media region code is mismatched to logical unit region"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x6F
argument_list|,
literal|0x05
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Drive region must be permanent/region reset count error"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x6F
argument_list|,
literal|0x06
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Insufficient block count for binding NONCE recording"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x6F
argument_list|,
literal|0x07
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Conflict in binding NONCE recording"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x70
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Decompression exception short: ASCQ = Algorithm ID"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x70
argument_list|,
literal|0xFF
argument_list|,
argument|SS_RDEF | SSQ_RANGE
argument_list|,
argument|NULL
argument_list|)
block|}
block|,
comment|/* Range 0x00 -> 0xFF */
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x71
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Decompression exception long: ASCQ = Algorithm ID"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x71
argument_list|,
literal|0xFF
argument_list|,
argument|SS_RDEF | SSQ_RANGE
argument_list|,
argument|NULL
argument_list|)
block|}
block|,
comment|/* Range 0x00 -> 0xFF */
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x72
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Session fixation error"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x72
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Session fixation error writing lead-in"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x72
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Session fixation error writing lead-out"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x72
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Session fixation error - incomplete track in session"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x72
argument_list|,
literal|0x04
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Empty or partially written reserved track"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x72
argument_list|,
literal|0x05
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"No more track reservations allowed"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x72
argument_list|,
literal|0x06
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"RMZ extension is not allowed"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x72
argument_list|,
literal|0x07
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"No more test zone extensions are allowed"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x73
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"CD control error"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x73
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Power calibration area almost full"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x73
argument_list|,
literal|0x02
argument_list|,
argument|SS_FATAL | ENOSPC
argument_list|,
literal|"Power calibration area is full"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x73
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Power calibration area error"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x73
argument_list|,
literal|0x04
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Program memory area update failure"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x73
argument_list|,
literal|0x05
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Program memory area is full"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x73
argument_list|,
literal|0x06
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"RMA/PMA is almost full"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x73
argument_list|,
literal|0x10
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Current power calibration area almost full"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x73
argument_list|,
literal|0x11
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Current power calibration area is full"
argument_list|)
block|}
block|,
comment|/*      R         */
block|{
name|SST
argument_list|(
literal|0x73
argument_list|,
literal|0x17
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"RDZ is full"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x74
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Security error"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x74
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Unable to decrypt data"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x74
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Unencrypted data encountered while decrypting"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x74
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Incorrect data encryption key"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x74
argument_list|,
literal|0x04
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Cryptographic integrity validation failed"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x74
argument_list|,
literal|0x05
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Error decrypting data"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x74
argument_list|,
literal|0x06
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Unknown signature verification key"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x74
argument_list|,
literal|0x07
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Encryption parameters not useable"
argument_list|)
block|}
block|,
comment|/* DT   R M E  VF */
block|{
name|SST
argument_list|(
literal|0x74
argument_list|,
literal|0x08
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Digital signature validation failure"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x74
argument_list|,
literal|0x09
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Encryption mode mismatch on read"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x74
argument_list|,
literal|0x0A
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Encrypted block not raw read enabled"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x74
argument_list|,
literal|0x0B
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Incorrect encryption parameters"
argument_list|)
block|}
block|,
comment|/* DT   R MAEBKV  */
block|{
name|SST
argument_list|(
literal|0x74
argument_list|,
literal|0x0C
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Unable to decrypt parameter list"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x74
argument_list|,
literal|0x0D
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Encryption algorithm disabled"
argument_list|)
block|}
block|,
comment|/* DT   R MAEBKV  */
block|{
name|SST
argument_list|(
literal|0x74
argument_list|,
literal|0x10
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"SA creation parameter value invalid"
argument_list|)
block|}
block|,
comment|/* DT   R MAEBKV  */
block|{
name|SST
argument_list|(
literal|0x74
argument_list|,
literal|0x11
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"SA creation parameter value rejected"
argument_list|)
block|}
block|,
comment|/* DT   R MAEBKV  */
block|{
name|SST
argument_list|(
literal|0x74
argument_list|,
literal|0x12
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Invalid SA usage"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x74
argument_list|,
literal|0x21
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Data encryption configuration prevented"
argument_list|)
block|}
block|,
comment|/* DT   R MAEBKV  */
block|{
name|SST
argument_list|(
literal|0x74
argument_list|,
literal|0x30
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"SA creation parameter not supported"
argument_list|)
block|}
block|,
comment|/* DT   R MAEBKV  */
block|{
name|SST
argument_list|(
literal|0x74
argument_list|,
literal|0x40
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Authentication failed"
argument_list|)
block|}
block|,
comment|/*             V  */
block|{
name|SST
argument_list|(
literal|0x74
argument_list|,
literal|0x61
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"External data encryption key manager access error"
argument_list|)
block|}
block|,
comment|/*             V  */
block|{
name|SST
argument_list|(
literal|0x74
argument_list|,
literal|0x62
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"External data encryption key manager error"
argument_list|)
block|}
block|,
comment|/*             V  */
block|{
name|SST
argument_list|(
literal|0x74
argument_list|,
literal|0x63
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"External data encryption key not found"
argument_list|)
block|}
block|,
comment|/*             V  */
block|{
name|SST
argument_list|(
literal|0x74
argument_list|,
literal|0x64
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"External data encryption request not authorized"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x74
argument_list|,
literal|0x6E
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"External data encryption control timeout"
argument_list|)
block|}
block|,
comment|/*  T             */
block|{
name|SST
argument_list|(
literal|0x74
argument_list|,
literal|0x6F
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"External data encryption control error"
argument_list|)
block|}
block|,
comment|/* DT   R M E  V  */
block|{
name|SST
argument_list|(
literal|0x74
argument_list|,
literal|0x71
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Logical unit access not authorized"
argument_list|)
block|}
block|,
comment|/* D              */
block|{
name|SST
argument_list|(
literal|0x74
argument_list|,
literal|0x79
argument_list|,
argument|SS_RDEF
argument_list|,
comment|/* XXX TBD */
literal|"Security conflict in translated device"
argument_list|)
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|asc_table_size
init|=
sizeof|sizeof
argument_list|(
name|asc_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|asc_table
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|asc_key
block|{
name|int
name|asc
decl_stmt|;
name|int
name|ascq
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|ascentrycomp
parameter_list|(
specifier|const
name|void
modifier|*
name|key
parameter_list|,
specifier|const
name|void
modifier|*
name|member
parameter_list|)
block|{
name|int
name|asc
decl_stmt|;
name|int
name|ascq
decl_stmt|;
specifier|const
name|struct
name|asc_table_entry
modifier|*
name|table_entry
decl_stmt|;
name|asc
operator|=
operator|(
operator|(
specifier|const
expr|struct
name|asc_key
operator|*
operator|)
name|key
operator|)
operator|->
name|asc
expr_stmt|;
name|ascq
operator|=
operator|(
operator|(
specifier|const
expr|struct
name|asc_key
operator|*
operator|)
name|key
operator|)
operator|->
name|ascq
expr_stmt|;
name|table_entry
operator|=
operator|(
specifier|const
expr|struct
name|asc_table_entry
operator|*
operator|)
name|member
expr_stmt|;
if|if
condition|(
name|asc
operator|>=
name|table_entry
operator|->
name|asc
condition|)
block|{
if|if
condition|(
name|asc
operator|>
name|table_entry
operator|->
name|asc
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|ascq
operator|<=
name|table_entry
operator|->
name|ascq
condition|)
block|{
comment|/* Check for ranges */
if|if
condition|(
name|ascq
operator|==
name|table_entry
operator|->
name|ascq
operator|||
operator|(
operator|(
name|table_entry
operator|->
name|action
operator|&
name|SSQ_RANGE
operator|)
operator|!=
literal|0
operator|&&
name|ascq
operator|>=
operator|(
name|table_entry
operator|-
literal|1
operator|)
operator|->
name|ascq
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|senseentrycomp
parameter_list|(
specifier|const
name|void
modifier|*
name|key
parameter_list|,
specifier|const
name|void
modifier|*
name|member
parameter_list|)
block|{
name|int
name|sense_key
decl_stmt|;
specifier|const
name|struct
name|sense_key_table_entry
modifier|*
name|table_entry
decl_stmt|;
name|sense_key
operator|=
operator|*
operator|(
operator|(
specifier|const
name|int
operator|*
operator|)
name|key
operator|)
expr_stmt|;
name|table_entry
operator|=
operator|(
specifier|const
expr|struct
name|sense_key_table_entry
operator|*
operator|)
name|member
expr_stmt|;
if|if
condition|(
name|sense_key
operator|>=
name|table_entry
operator|->
name|sense_key
condition|)
block|{
if|if
condition|(
name|sense_key
operator|==
name|table_entry
operator|->
name|sense_key
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fetchtableentries
parameter_list|(
name|int
name|sense_key
parameter_list|,
name|int
name|asc
parameter_list|,
name|int
name|ascq
parameter_list|,
name|struct
name|scsi_inquiry_data
modifier|*
name|inq_data
parameter_list|,
specifier|const
name|struct
name|sense_key_table_entry
modifier|*
modifier|*
name|sense_entry
parameter_list|,
specifier|const
name|struct
name|asc_table_entry
modifier|*
modifier|*
name|asc_entry
parameter_list|)
block|{
name|caddr_t
name|match
decl_stmt|;
specifier|const
name|struct
name|asc_table_entry
modifier|*
name|asc_tables
index|[
literal|2
index|]
decl_stmt|;
specifier|const
name|struct
name|sense_key_table_entry
modifier|*
name|sense_tables
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|asc_key
name|asc_ascq
decl_stmt|;
name|size_t
name|asc_tables_size
index|[
literal|2
index|]
decl_stmt|;
name|size_t
name|sense_tables_size
index|[
literal|2
index|]
decl_stmt|;
name|int
name|num_asc_tables
decl_stmt|;
name|int
name|num_sense_tables
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Default to failure */
operator|*
name|sense_entry
operator|=
name|NULL
expr_stmt|;
operator|*
name|asc_entry
operator|=
name|NULL
expr_stmt|;
name|match
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|inq_data
operator|!=
name|NULL
condition|)
name|match
operator|=
name|cam_quirkmatch
argument_list|(
operator|(
name|caddr_t
operator|)
name|inq_data
argument_list|,
operator|(
name|caddr_t
operator|)
name|sense_quirk_table
argument_list|,
name|sense_quirk_table_size
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sense_quirk_table
argument_list|)
argument_list|,
name|scsi_inquiry_match
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
operator|!=
name|NULL
condition|)
block|{
name|struct
name|scsi_sense_quirk_entry
modifier|*
name|quirk
decl_stmt|;
name|quirk
operator|=
operator|(
expr|struct
name|scsi_sense_quirk_entry
operator|*
operator|)
name|match
expr_stmt|;
name|asc_tables
index|[
literal|0
index|]
operator|=
name|quirk
operator|->
name|asc_info
expr_stmt|;
name|asc_tables_size
index|[
literal|0
index|]
operator|=
name|quirk
operator|->
name|num_ascs
expr_stmt|;
name|asc_tables
index|[
literal|1
index|]
operator|=
name|asc_table
expr_stmt|;
name|asc_tables_size
index|[
literal|1
index|]
operator|=
name|asc_table_size
expr_stmt|;
name|num_asc_tables
operator|=
literal|2
expr_stmt|;
name|sense_tables
index|[
literal|0
index|]
operator|=
name|quirk
operator|->
name|sense_key_info
expr_stmt|;
name|sense_tables_size
index|[
literal|0
index|]
operator|=
name|quirk
operator|->
name|num_sense_keys
expr_stmt|;
name|sense_tables
index|[
literal|1
index|]
operator|=
name|sense_key_table
expr_stmt|;
name|sense_tables_size
index|[
literal|1
index|]
operator|=
name|sense_key_table_size
expr_stmt|;
name|num_sense_tables
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|asc_tables
index|[
literal|0
index|]
operator|=
name|asc_table
expr_stmt|;
name|asc_tables_size
index|[
literal|0
index|]
operator|=
name|asc_table_size
expr_stmt|;
name|num_asc_tables
operator|=
literal|1
expr_stmt|;
name|sense_tables
index|[
literal|0
index|]
operator|=
name|sense_key_table
expr_stmt|;
name|sense_tables_size
index|[
literal|0
index|]
operator|=
name|sense_key_table_size
expr_stmt|;
name|num_sense_tables
operator|=
literal|1
expr_stmt|;
block|}
name|asc_ascq
operator|.
name|asc
operator|=
name|asc
expr_stmt|;
name|asc_ascq
operator|.
name|ascq
operator|=
name|ascq
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_asc_tables
condition|;
name|i
operator|++
control|)
block|{
name|void
modifier|*
name|found_entry
decl_stmt|;
name|found_entry
operator|=
name|bsearch
argument_list|(
operator|&
name|asc_ascq
argument_list|,
name|asc_tables
index|[
name|i
index|]
argument_list|,
name|asc_tables_size
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|asc_tables
argument_list|)
argument_list|,
name|ascentrycomp
argument_list|)
expr_stmt|;
if|if
condition|(
name|found_entry
condition|)
block|{
operator|*
name|asc_entry
operator|=
operator|(
expr|struct
name|asc_table_entry
operator|*
operator|)
name|found_entry
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_sense_tables
condition|;
name|i
operator|++
control|)
block|{
name|void
modifier|*
name|found_entry
decl_stmt|;
name|found_entry
operator|=
name|bsearch
argument_list|(
operator|&
name|sense_key
argument_list|,
name|sense_tables
index|[
name|i
index|]
argument_list|,
name|sense_tables_size
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|sense_tables
argument_list|)
argument_list|,
name|senseentrycomp
argument_list|)
expr_stmt|;
if|if
condition|(
name|found_entry
condition|)
block|{
operator|*
name|sense_entry
operator|=
operator|(
expr|struct
name|sense_key_table_entry
operator|*
operator|)
name|found_entry
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
name|void
name|scsi_sense_desc
parameter_list|(
name|int
name|sense_key
parameter_list|,
name|int
name|asc
parameter_list|,
name|int
name|ascq
parameter_list|,
name|struct
name|scsi_inquiry_data
modifier|*
name|inq_data
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|sense_key_desc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|asc_desc
parameter_list|)
block|{
specifier|const
name|struct
name|asc_table_entry
modifier|*
name|asc_entry
decl_stmt|;
specifier|const
name|struct
name|sense_key_table_entry
modifier|*
name|sense_entry
decl_stmt|;
name|fetchtableentries
argument_list|(
name|sense_key
argument_list|,
name|asc
argument_list|,
name|ascq
argument_list|,
name|inq_data
argument_list|,
operator|&
name|sense_entry
argument_list|,
operator|&
name|asc_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|sense_entry
operator|!=
name|NULL
condition|)
operator|*
name|sense_key_desc
operator|=
name|sense_entry
operator|->
name|desc
expr_stmt|;
else|else
operator|*
name|sense_key_desc
operator|=
literal|"Invalid Sense Key"
expr_stmt|;
if|if
condition|(
name|asc_entry
operator|!=
name|NULL
condition|)
operator|*
name|asc_desc
operator|=
name|asc_entry
operator|->
name|desc
expr_stmt|;
elseif|else
if|if
condition|(
name|asc
operator|>=
literal|0x80
operator|&&
name|asc
operator|<=
literal|0xff
condition|)
operator|*
name|asc_desc
operator|=
literal|"Vendor Specific ASC"
expr_stmt|;
elseif|else
if|if
condition|(
name|ascq
operator|>=
literal|0x80
operator|&&
name|ascq
operator|<=
literal|0xff
condition|)
operator|*
name|asc_desc
operator|=
literal|"Vendor Specific ASCQ"
expr_stmt|;
else|else
operator|*
name|asc_desc
operator|=
literal|"Reserved ASC/ASCQ pair"
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Given sense and device type information, return the appropriate action.  * If we do not understand the specific error as identified by the ASC/ASCQ  * pair, fall back on the more generic actions derived from the sense key.  */
end_comment

begin_function
name|scsi_sense_action
name|scsi_error_action
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|struct
name|scsi_inquiry_data
modifier|*
name|inq_data
parameter_list|,
name|u_int32_t
name|sense_flags
parameter_list|)
block|{
specifier|const
name|struct
name|asc_table_entry
modifier|*
name|asc_entry
decl_stmt|;
specifier|const
name|struct
name|sense_key_table_entry
modifier|*
name|sense_entry
decl_stmt|;
name|int
name|error_code
decl_stmt|,
name|sense_key
decl_stmt|,
name|asc
decl_stmt|,
name|ascq
decl_stmt|;
name|scsi_sense_action
name|action
decl_stmt|;
if|if
condition|(
operator|!
name|scsi_extract_sense_ccb
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|csio
argument_list|,
operator|&
name|error_code
argument_list|,
operator|&
name|sense_key
argument_list|,
operator|&
name|asc
argument_list|,
operator|&
name|ascq
argument_list|)
condition|)
block|{
name|action
operator|=
name|SS_RETRY
operator||
name|SSQ_DECREMENT_COUNT
operator||
name|SSQ_PRINT_SENSE
operator||
name|EIO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|error_code
operator|==
name|SSD_DEFERRED_ERROR
operator|)
operator|||
operator|(
name|error_code
operator|==
name|SSD_DESC_DEFERRED_ERROR
operator|)
condition|)
block|{
comment|/* 		 * XXX dufault@FreeBSD.org 		 * This error doesn't relate to the command associated 		 * with this request sense.  A deferred error is an error 		 * for a command that has already returned GOOD status 		 * (see SCSI2 8.2.14.2). 		 * 		 * By my reading of that section, it looks like the current 		 * command has been cancelled, we should now clean things up 		 * (hopefully recovering any lost data) and then retry the 		 * current command.  There are two easy choices, both wrong: 		 * 		 * 1. Drop through (like we had been doing), thus treating 		 *    this as if the error were for the current command and 		 *    return and stop the current command. 		 *  		 * 2. Issue a retry (like I made it do) thus hopefully 		 *    recovering the current transfer, and ignoring the 		 *    fact that we've dropped a command. 		 * 		 * These should probably be handled in a device specific 		 * sense handler or punted back up to a user mode daemon 		 */
name|action
operator|=
name|SS_RETRY
operator||
name|SSQ_DECREMENT_COUNT
operator||
name|SSQ_PRINT_SENSE
expr_stmt|;
block|}
else|else
block|{
name|fetchtableentries
argument_list|(
name|sense_key
argument_list|,
name|asc
argument_list|,
name|ascq
argument_list|,
name|inq_data
argument_list|,
operator|&
name|sense_entry
argument_list|,
operator|&
name|asc_entry
argument_list|)
expr_stmt|;
comment|/* 		 * Override the 'No additional Sense' entry (0,0) 		 * with the error action of the sense key. 		 */
if|if
condition|(
name|asc_entry
operator|!=
name|NULL
operator|&&
operator|(
name|asc
operator|!=
literal|0
operator|||
name|ascq
operator|!=
literal|0
operator|)
condition|)
name|action
operator|=
name|asc_entry
operator|->
name|action
expr_stmt|;
elseif|else
if|if
condition|(
name|sense_entry
operator|!=
name|NULL
condition|)
name|action
operator|=
name|sense_entry
operator|->
name|action
expr_stmt|;
else|else
name|action
operator|=
name|SS_RETRY
operator||
name|SSQ_DECREMENT_COUNT
operator||
name|SSQ_PRINT_SENSE
expr_stmt|;
if|if
condition|(
name|sense_key
operator|==
name|SSD_KEY_RECOVERED_ERROR
condition|)
block|{
comment|/* 			 * The action succeeded but the device wants 			 * the user to know that some recovery action 			 * was required. 			 */
name|action
operator|&=
operator|~
operator|(
name|SS_MASK
operator||
name|SSQ_MASK
operator||
name|SS_ERRMASK
operator|)
expr_stmt|;
name|action
operator||=
name|SS_NOP
operator||
name|SSQ_PRINT_SENSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sense_key
operator|==
name|SSD_KEY_ILLEGAL_REQUEST
condition|)
block|{
if|if
condition|(
operator|(
name|sense_flags
operator|&
name|SF_QUIET_IR
operator|)
operator|!=
literal|0
condition|)
name|action
operator|&=
operator|~
name|SSQ_PRINT_SENSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sense_key
operator|==
name|SSD_KEY_UNIT_ATTENTION
condition|)
block|{
if|if
condition|(
operator|(
name|sense_flags
operator|&
name|SF_RETRY_UA
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|action
operator|&
name|SS_MASK
operator|)
operator|==
name|SS_FAIL
condition|)
block|{
name|action
operator|&=
operator|~
operator|(
name|SS_MASK
operator||
name|SSQ_MASK
operator|)
expr_stmt|;
name|action
operator||=
name|SS_RETRY
operator||
name|SSQ_DECREMENT_COUNT
operator||
name|SSQ_PRINT_SENSE
expr_stmt|;
block|}
name|action
operator||=
name|SSQ_UA
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|action
operator|&
name|SS_MASK
operator|)
operator|>=
name|SS_START
operator|&&
operator|(
name|sense_flags
operator|&
name|SF_NO_RECOVERY
operator|)
condition|)
block|{
name|action
operator|&=
operator|~
name|SS_MASK
expr_stmt|;
name|action
operator||=
name|SS_FAIL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|action
operator|&
name|SS_MASK
operator|)
operator|==
name|SS_RETRY
operator|&&
operator|(
name|sense_flags
operator|&
name|SF_NO_RETRY
operator|)
condition|)
block|{
name|action
operator|&=
operator|~
name|SS_MASK
expr_stmt|;
name|action
operator||=
name|SS_FAIL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sense_flags
operator|&
name|SF_PRINT_ALWAYS
operator|)
operator|!=
literal|0
condition|)
name|action
operator||=
name|SSQ_PRINT_SENSE
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|sense_flags
operator|&
name|SF_NO_PRINT
operator|)
operator|!=
literal|0
condition|)
name|action
operator|&=
operator|~
name|SSQ_PRINT_SENSE
expr_stmt|;
return|return
operator|(
name|action
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|scsi_cdb_string
parameter_list|(
name|u_int8_t
modifier|*
name|cdb_ptr
parameter_list|,
name|char
modifier|*
name|cdb_string
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|u_int8_t
name|cdb_len
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|cdb_ptr
operator|==
name|NULL
condition|)
return|return
operator|(
literal|""
operator|)
return|;
comment|/* Silence warnings */
name|cdb_len
operator|=
literal|0
expr_stmt|;
comment|/* 	 * This is taken from the SCSI-3 draft spec. 	 * (T10/1157D revision 0.3) 	 * The top 3 bits of an opcode are the group code.  The next 5 bits 	 * are the command code. 	 * Group 0:  six byte commands 	 * Group 1:  ten byte commands 	 * Group 2:  ten byte commands 	 * Group 3:  reserved 	 * Group 4:  sixteen byte commands 	 * Group 5:  twelve byte commands 	 * Group 6:  vendor specific 	 * Group 7:  vendor specific 	 */
switch|switch
condition|(
operator|(
operator|*
name|cdb_ptr
operator|>>
literal|5
operator|)
operator|&
literal|0x7
condition|)
block|{
case|case
literal|0
case|:
name|cdb_len
operator|=
literal|6
expr_stmt|;
break|break;
case|case
literal|1
case|:
case|case
literal|2
case|:
name|cdb_len
operator|=
literal|10
expr_stmt|;
break|break;
case|case
literal|3
case|:
case|case
literal|6
case|:
case|case
literal|7
case|:
comment|/* in this case, just print out the opcode */
name|cdb_len
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|cdb_len
operator|=
literal|16
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|cdb_len
operator|=
literal|12
expr_stmt|;
break|break;
block|}
operator|*
name|cdb_string
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cdb_len
condition|;
name|i
operator|++
control|)
name|snprintf
argument_list|(
name|cdb_string
operator|+
name|strlen
argument_list|(
name|cdb_string
argument_list|)
argument_list|,
name|len
operator|-
name|strlen
argument_list|(
name|cdb_string
argument_list|)
argument_list|,
literal|"%02hhx "
argument_list|,
name|cdb_ptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|cdb_string
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|scsi_status_string
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|)
block|{
switch|switch
condition|(
name|csio
operator|->
name|scsi_status
condition|)
block|{
case|case
name|SCSI_STATUS_OK
case|:
return|return
operator|(
literal|"OK"
operator|)
return|;
case|case
name|SCSI_STATUS_CHECK_COND
case|:
return|return
operator|(
literal|"Check Condition"
operator|)
return|;
case|case
name|SCSI_STATUS_BUSY
case|:
return|return
operator|(
literal|"Busy"
operator|)
return|;
case|case
name|SCSI_STATUS_INTERMED
case|:
return|return
operator|(
literal|"Intermediate"
operator|)
return|;
case|case
name|SCSI_STATUS_INTERMED_COND_MET
case|:
return|return
operator|(
literal|"Intermediate-Condition Met"
operator|)
return|;
case|case
name|SCSI_STATUS_RESERV_CONFLICT
case|:
return|return
operator|(
literal|"Reservation Conflict"
operator|)
return|;
case|case
name|SCSI_STATUS_CMD_TERMINATED
case|:
return|return
operator|(
literal|"Command Terminated"
operator|)
return|;
case|case
name|SCSI_STATUS_QUEUE_FULL
case|:
return|return
operator|(
literal|"Queue Full"
operator|)
return|;
case|case
name|SCSI_STATUS_ACA_ACTIVE
case|:
return|return
operator|(
literal|"ACA Active"
operator|)
return|;
case|case
name|SCSI_STATUS_TASK_ABORTED
case|:
return|return
operator|(
literal|"Task Aborted"
operator|)
return|;
default|default:
block|{
specifier|static
name|char
name|unkstr
index|[
literal|64
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|unkstr
argument_list|,
sizeof|sizeof
argument_list|(
name|unkstr
argument_list|)
argument_list|,
literal|"Unknown %#x"
argument_list|,
name|csio
operator|->
name|scsi_status
argument_list|)
expr_stmt|;
return|return
operator|(
name|unkstr
operator|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * scsi_command_string() returns 0 for success and -1 for failure.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_decl_stmt
name|int
name|scsi_command_string
argument_list|(
expr|struct
name|ccb_scsiio
operator|*
name|csio
argument_list|,
expr|struct
name|sbuf
operator|*
name|sb
argument_list|)
else|#
directive|else
comment|/* !_KERNEL */
name|int
name|scsi_command_string
argument_list|(
expr|struct
name|cam_device
operator|*
name|device
argument_list|,
expr|struct
name|ccb_scsiio
operator|*
name|csio
argument_list|,
expr|struct
name|sbuf
operator|*
name|sb
argument_list|)
endif|#
directive|endif
comment|/* _KERNEL/!_KERNEL */
block|{
name|struct
name|scsi_inquiry_data
modifier|*
name|inq_data
decl_stmt|;
name|char
name|cdb_str
index|[
operator|(
name|SCSI_MAX_CDBLEN
operator|*
literal|3
operator|)
operator|+
literal|1
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
name|struct
name|ccb_getdev
modifier|*
name|cgd
decl_stmt|;
endif|#
directive|endif
comment|/* _KERNEL */
ifdef|#
directive|ifdef
name|_KERNEL
if|if
condition|(
operator|(
name|cgd
operator|=
operator|(
expr|struct
name|ccb_getdev
operator|*
operator|)
name|xpt_alloc_ccb_nowait
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Get the device information. 	 */
name|xpt_setup_ccb
argument_list|(
operator|&
name|cgd
operator|->
name|ccb_h
argument_list|,
name|csio
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_PRIORITY_NORMAL
argument_list|)
expr_stmt|;
name|cgd
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_GDEV_TYPE
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|cgd
argument_list|)
expr_stmt|;
comment|/* 	 * If the device is unconfigured, just pretend that it is a hard 	 * drive.  scsi_op_desc() needs this. 	 */
if|if
condition|(
name|cgd
operator|->
name|ccb_h
operator|.
name|status
operator|==
name|CAM_DEV_NOT_THERE
condition|)
name|cgd
operator|->
name|inq_data
operator|.
name|device
operator|=
name|T_DIRECT
expr_stmt|;
name|inq_data
operator|=
operator|&
name|cgd
operator|->
name|inq_data
expr_stmt|;
else|#
directive|else
comment|/* !_KERNEL */
name|inq_data
operator|=
operator|&
name|device
operator|->
name|inq_data
expr_stmt|;
endif|#
directive|endif
comment|/* _KERNEL/!_KERNEL */
if|if
condition|(
operator|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_POINTER
operator|)
operator|!=
literal|0
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s. CDB: %s"
argument_list|,
name|scsi_op_desc
argument_list|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_ptr
index|[
literal|0
index|]
argument_list|,
name|inq_data
argument_list|)
argument_list|,
name|scsi_cdb_string
argument_list|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_ptr
argument_list|,
name|cdb_str
argument_list|,
sizeof|sizeof
argument_list|(
name|cdb_str
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s. CDB: %s"
argument_list|,
name|scsi_op_desc
argument_list|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
argument_list|,
name|inq_data
argument_list|)
argument_list|,
name|scsi_cdb_string
argument_list|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|cdb_str
argument_list|,
sizeof|sizeof
argument_list|(
name|cdb_str
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|_KERNEL
name|xpt_free_ccb
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|cgd
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/*  * Iterate over sense descriptors.  Each descriptor is passed into iter_func().   * If iter_func() returns 0, list traversal continues.  If iter_func()  * returns non-zero, list traversal is stopped.  */
end_comment

begin_function
name|void
name|scsi_desc_iterate
parameter_list|(
name|struct
name|scsi_sense_data_desc
modifier|*
name|sense
parameter_list|,
name|u_int
name|sense_len
parameter_list|,
name|int
function_decl|(
modifier|*
name|iter_func
function_decl|)
parameter_list|(
name|struct
name|scsi_sense_data_desc
modifier|*
name|sense
parameter_list|,
name|u_int
parameter_list|,
name|struct
name|scsi_sense_desc_header
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|cur_pos
decl_stmt|;
name|int
name|desc_len
decl_stmt|;
comment|/* 	 * First make sure the extra length field is present. 	 */
if|if
condition|(
name|SSD_DESC_IS_PRESENT
argument_list|(
name|sense
argument_list|,
name|sense_len
argument_list|,
name|extra_len
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * The length of data actually returned may be different than the 	 * extra_len recorded in the sturcture. 	 */
name|desc_len
operator|=
name|sense_len
operator|-
name|offsetof
argument_list|(
expr|struct
name|scsi_sense_data_desc
argument_list|,
name|sense_desc
argument_list|)
expr_stmt|;
comment|/* 	 * Limit this further by the extra length reported, and the maximum 	 * allowed extra length. 	 */
name|desc_len
operator|=
name|MIN
argument_list|(
name|desc_len
argument_list|,
name|MIN
argument_list|(
name|sense
operator|->
name|extra_len
argument_list|,
name|SSD_EXTRA_MAX
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Subtract the size of the header from the descriptor length. 	 * This is to ensure that we have at least the header left, so we 	 * don't have to check that inside the loop.  This can wind up 	 * being a negative value. 	 */
name|desc_len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_desc_header
argument_list|)
expr_stmt|;
for|for
control|(
name|cur_pos
operator|=
literal|0
init|;
name|cur_pos
operator|<
name|desc_len
condition|;
control|)
block|{
name|struct
name|scsi_sense_desc_header
modifier|*
name|header
decl_stmt|;
name|header
operator|=
operator|(
expr|struct
name|scsi_sense_desc_header
operator|*
operator|)
operator|&
name|sense
operator|->
name|sense_desc
index|[
name|cur_pos
index|]
expr_stmt|;
comment|/* 		 * Check to make sure we have the entire descriptor.  We 		 * don't call iter_func() unless we do. 		 * 		 * Note that although cur_pos is at the beginning of the 		 * descriptor, desc_len already has the header length 		 * subtracted.  So the comparison of the length in the 		 * header (which does not include the header itself) to 		 * desc_len - cur_pos is correct. 		 */
if|if
condition|(
name|header
operator|->
name|length
operator|>
operator|(
name|desc_len
operator|-
name|cur_pos
operator|)
condition|)
break|break;
if|if
condition|(
name|iter_func
argument_list|(
name|sense
argument_list|,
name|sense_len
argument_list|,
name|header
argument_list|,
name|arg
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|cur_pos
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|header
argument_list|)
operator|+
name|header
operator|->
name|length
expr_stmt|;
block|}
block|}
end_function

begin_struct
struct|struct
name|scsi_find_desc_info
block|{
name|uint8_t
name|desc_type
decl_stmt|;
name|struct
name|scsi_sense_desc_header
modifier|*
name|header
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|scsi_find_desc_func
parameter_list|(
name|struct
name|scsi_sense_data_desc
modifier|*
name|sense
parameter_list|,
name|u_int
name|sense_len
parameter_list|,
name|struct
name|scsi_sense_desc_header
modifier|*
name|header
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|scsi_find_desc_info
modifier|*
name|desc_info
decl_stmt|;
name|desc_info
operator|=
operator|(
expr|struct
name|scsi_find_desc_info
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|desc_type
operator|==
name|desc_info
operator|->
name|desc_type
condition|)
block|{
name|desc_info
operator|->
name|header
operator|=
name|header
expr_stmt|;
comment|/* We found the descriptor, tell the iterator to stop. */
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a descriptor type, return a pointer to it if it is in the sense  * data and not truncated.  Avoiding truncating sense data will simplify  * things significantly for the caller.  */
end_comment

begin_function
name|uint8_t
modifier|*
name|scsi_find_desc
parameter_list|(
name|struct
name|scsi_sense_data_desc
modifier|*
name|sense
parameter_list|,
name|u_int
name|sense_len
parameter_list|,
name|uint8_t
name|desc_type
parameter_list|)
block|{
name|struct
name|scsi_find_desc_info
name|desc_info
decl_stmt|;
name|desc_info
operator|.
name|desc_type
operator|=
name|desc_type
expr_stmt|;
name|desc_info
operator|.
name|header
operator|=
name|NULL
expr_stmt|;
name|scsi_desc_iterate
argument_list|(
name|sense
argument_list|,
name|sense_len
argument_list|,
name|scsi_find_desc_func
argument_list|,
operator|&
name|desc_info
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|desc_info
operator|.
name|header
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fill in SCSI sense data with the specified parameters.  This routine can  * fill in either fixed or descriptor type sense data.  */
end_comment

begin_function
name|void
name|scsi_set_sense_data_va
parameter_list|(
name|struct
name|scsi_sense_data
modifier|*
name|sense_data
parameter_list|,
name|scsi_sense_data_type
name|sense_format
parameter_list|,
name|int
name|current_error
parameter_list|,
name|int
name|sense_key
parameter_list|,
name|int
name|asc
parameter_list|,
name|int
name|ascq
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|int
name|descriptor_sense
decl_stmt|;
name|scsi_sense_elem_type
name|elem_type
decl_stmt|;
comment|/* 	 * Determine whether to return fixed or descriptor format sense 	 * data.  If the user specifies SSD_TYPE_NONE for some reason, 	 * they'll just get fixed sense data. 	 */
if|if
condition|(
name|sense_format
operator|==
name|SSD_TYPE_DESC
condition|)
name|descriptor_sense
operator|=
literal|1
expr_stmt|;
else|else
name|descriptor_sense
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Zero the sense data, so that we don't pass back any garbage data 	 * to the user. 	 */
name|memset
argument_list|(
name|sense_data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sense_data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|descriptor_sense
operator|!=
literal|0
condition|)
block|{
name|struct
name|scsi_sense_data_desc
modifier|*
name|sense
decl_stmt|;
name|sense
operator|=
operator|(
expr|struct
name|scsi_sense_data_desc
operator|*
operator|)
name|sense_data
expr_stmt|;
comment|/* 		 * The descriptor sense format eliminates the use of the 		 * valid bit. 		 */
if|if
condition|(
name|current_error
operator|!=
literal|0
condition|)
name|sense
operator|->
name|error_code
operator|=
name|SSD_DESC_CURRENT_ERROR
expr_stmt|;
else|else
name|sense
operator|->
name|error_code
operator|=
name|SSD_DESC_DEFERRED_ERROR
expr_stmt|;
name|sense
operator|->
name|sense_key
operator|=
name|sense_key
expr_stmt|;
name|sense
operator|->
name|add_sense_code
operator|=
name|asc
expr_stmt|;
name|sense
operator|->
name|add_sense_code_qual
operator|=
name|ascq
expr_stmt|;
comment|/* 		 * Start off with no extra length, since the above data 		 * fits in the standard descriptor sense information. 		 */
name|sense
operator|->
name|extra_len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|elem_type
operator|=
operator|(
name|scsi_sense_elem_type
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|scsi_sense_elem_type
argument_list|)
operator|)
operator|!=
name|SSD_ELEM_NONE
condition|)
block|{
name|int
name|sense_len
decl_stmt|,
name|len_to_copy
decl_stmt|;
name|uint8_t
modifier|*
name|data
decl_stmt|;
if|if
condition|(
name|elem_type
operator|>=
name|SSD_ELEM_MAX
condition|)
block|{
name|printf
argument_list|(
literal|"%s: invalid sense type %d\n"
argument_list|,
name|__func__
argument_list|,
name|elem_type
argument_list|)
expr_stmt|;
break|break;
block|}
name|sense_len
operator|=
operator|(
name|int
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|len_to_copy
operator|=
name|MIN
argument_list|(
name|sense_len
argument_list|,
name|SSD_EXTRA_MAX
operator|-
name|sense
operator|->
name|extra_len
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint8_t
operator|*
argument_list|)
expr_stmt|;
comment|/* 			 * We've already consumed the arguments for this one. 			 */
if|if
condition|(
name|elem_type
operator|==
name|SSD_ELEM_SKIP
condition|)
continue|continue;
switch|switch
condition|(
name|elem_type
condition|)
block|{
case|case
name|SSD_ELEM_DESC
case|:
block|{
comment|/* 				 * This is a straight descriptor.  All we 				 * need to do is copy the data in. 				 */
name|bcopy
argument_list|(
name|data
argument_list|,
operator|&
name|sense
operator|->
name|sense_desc
index|[
name|sense
operator|->
name|extra_len
index|]
argument_list|,
name|len_to_copy
argument_list|)
expr_stmt|;
name|sense
operator|->
name|extra_len
operator|+=
name|len_to_copy
expr_stmt|;
break|break;
block|}
case|case
name|SSD_ELEM_SKS
case|:
block|{
name|struct
name|scsi_sense_sks
name|sks
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|sks
argument_list|,
sizeof|sizeof
argument_list|(
name|sks
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 				 * This is already-formatted sense key 				 * specific data.  We just need to fill out 				 * the header and copy everything in. 				 */
name|bcopy
argument_list|(
name|data
argument_list|,
operator|&
name|sks
operator|.
name|sense_key_spec
argument_list|,
name|MIN
argument_list|(
name|len_to_copy
argument_list|,
sizeof|sizeof
argument_list|(
name|sks
operator|.
name|sense_key_spec
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|sks
operator|.
name|desc_type
operator|=
name|SSD_DESC_SKS
expr_stmt|;
name|sks
operator|.
name|length
operator|=
sizeof|sizeof
argument_list|(
name|sks
argument_list|)
operator|-
name|offsetof
argument_list|(
expr|struct
name|scsi_sense_sks
argument_list|,
name|reserved1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|sks
argument_list|,
operator|&
name|sense
operator|->
name|sense_desc
index|[
name|sense
operator|->
name|extra_len
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|sks
argument_list|)
argument_list|)
expr_stmt|;
name|sense
operator|->
name|extra_len
operator|+=
sizeof|sizeof
argument_list|(
name|sks
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SSD_ELEM_INFO
case|:
case|case
name|SSD_ELEM_COMMAND
case|:
block|{
name|struct
name|scsi_sense_command
name|cmd
decl_stmt|;
name|struct
name|scsi_sense_info
name|info
decl_stmt|;
name|uint8_t
modifier|*
name|data_dest
decl_stmt|;
name|uint8_t
modifier|*
name|descriptor
decl_stmt|;
name|int
name|descriptor_size
decl_stmt|,
name|i
decl_stmt|,
name|copy_len
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|info
argument_list|,
sizeof|sizeof
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 				 * Command or information data.  The 				 * operate in pretty much the same way. 				 */
if|if
condition|(
name|elem_type
operator|==
name|SSD_ELEM_COMMAND
condition|)
block|{
name|len_to_copy
operator|=
name|MIN
argument_list|(
name|len_to_copy
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
operator|.
name|command_info
argument_list|)
argument_list|)
expr_stmt|;
name|descriptor
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|cmd
expr_stmt|;
name|descriptor_size
operator|=
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|data_dest
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|cmd
operator|.
name|command_info
expr_stmt|;
name|cmd
operator|.
name|desc_type
operator|=
name|SSD_DESC_COMMAND
expr_stmt|;
name|cmd
operator|.
name|length
operator|=
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
operator|-
name|offsetof
argument_list|(
expr|struct
name|scsi_sense_command
argument_list|,
name|reserved
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|len_to_copy
operator|=
name|MIN
argument_list|(
name|len_to_copy
argument_list|,
sizeof|sizeof
argument_list|(
name|info
operator|.
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|descriptor
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|info
expr_stmt|;
name|descriptor_size
operator|=
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|data_dest
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|info
operator|.
name|info
expr_stmt|;
name|info
operator|.
name|desc_type
operator|=
name|SSD_DESC_INFO
expr_stmt|;
name|info
operator|.
name|byte2
operator|=
name|SSD_INFO_VALID
expr_stmt|;
name|info
operator|.
name|length
operator|=
sizeof|sizeof
argument_list|(
name|info
argument_list|)
operator|-
name|offsetof
argument_list|(
expr|struct
name|scsi_sense_info
argument_list|,
name|byte2
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * Copy this in reverse because the spec 				 * (SPC-4) says that when 4 byte quantities 				 * are stored in this 8 byte field, the 				 * first four bytes shall be 0. 				 * 				 * So we fill the bytes in from the end, and 				 * if we have less than 8 bytes to copy, 				 * the initial, most significant bytes will 				 * be 0. 				 */
for|for
control|(
name|i
operator|=
name|sense_len
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
operator|&&
name|len_to_copy
operator|>
literal|0
condition|;
name|i
operator|--
operator|,
name|len_to_copy
operator|--
control|)
name|data_dest
index|[
name|len_to_copy
operator|-
literal|1
index|]
operator|=
name|data
index|[
name|i
index|]
expr_stmt|;
comment|/* 				 * This calculation looks much like the 				 * initial len_to_copy calculation, but 				 * we have to do it again here, because 				 * we're looking at a larger amount that 				 * may or may not fit.  It's not only the 				 * data the user passed in, but also the 				 * rest of the descriptor. 				 */
name|copy_len
operator|=
name|MIN
argument_list|(
name|descriptor_size
argument_list|,
name|SSD_EXTRA_MAX
operator|-
name|sense
operator|->
name|extra_len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|descriptor
argument_list|,
operator|&
name|sense
operator|->
name|sense_desc
index|[
name|sense
operator|->
name|extra_len
index|]
argument_list|,
name|copy_len
argument_list|)
expr_stmt|;
name|sense
operator|->
name|extra_len
operator|+=
name|copy_len
expr_stmt|;
break|break;
block|}
case|case
name|SSD_ELEM_FRU
case|:
block|{
name|struct
name|scsi_sense_fru
name|fru
decl_stmt|;
name|int
name|copy_len
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|fru
argument_list|,
sizeof|sizeof
argument_list|(
name|fru
argument_list|)
argument_list|)
expr_stmt|;
name|fru
operator|.
name|desc_type
operator|=
name|SSD_DESC_FRU
expr_stmt|;
name|fru
operator|.
name|length
operator|=
sizeof|sizeof
argument_list|(
name|fru
argument_list|)
operator|-
name|offsetof
argument_list|(
expr|struct
name|scsi_sense_fru
argument_list|,
name|reserved
argument_list|)
expr_stmt|;
name|fru
operator|.
name|fru
operator|=
operator|*
name|data
expr_stmt|;
name|copy_len
operator|=
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
name|fru
argument_list|)
argument_list|,
name|SSD_EXTRA_MAX
operator|-
name|sense
operator|->
name|extra_len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|fru
argument_list|,
operator|&
name|sense
operator|->
name|sense_desc
index|[
name|sense
operator|->
name|extra_len
index|]
argument_list|,
name|copy_len
argument_list|)
expr_stmt|;
name|sense
operator|->
name|extra_len
operator|+=
name|copy_len
expr_stmt|;
break|break;
block|}
case|case
name|SSD_ELEM_STREAM
case|:
block|{
name|struct
name|scsi_sense_stream
name|stream_sense
decl_stmt|;
name|int
name|copy_len
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|stream_sense
argument_list|,
sizeof|sizeof
argument_list|(
name|stream_sense
argument_list|)
argument_list|)
expr_stmt|;
name|stream_sense
operator|.
name|desc_type
operator|=
name|SSD_DESC_STREAM
expr_stmt|;
name|stream_sense
operator|.
name|length
operator|=
sizeof|sizeof
argument_list|(
name|stream_sense
argument_list|)
operator|-
name|offsetof
argument_list|(
expr|struct
name|scsi_sense_stream
argument_list|,
name|reserved
argument_list|)
expr_stmt|;
name|stream_sense
operator|.
name|byte3
operator|=
operator|*
name|data
expr_stmt|;
name|copy_len
operator|=
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
name|stream_sense
argument_list|)
argument_list|,
name|SSD_EXTRA_MAX
operator|-
name|sense
operator|->
name|extra_len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|stream_sense
argument_list|,
operator|&
name|sense
operator|->
name|sense_desc
index|[
name|sense
operator|->
name|extra_len
index|]
argument_list|,
name|copy_len
argument_list|)
expr_stmt|;
name|sense
operator|->
name|extra_len
operator|+=
name|copy_len
expr_stmt|;
break|break;
block|}
default|default:
comment|/* 				 * We shouldn't get here, but if we do, do 				 * nothing.  We've already consumed the 				 * arguments above. 				 */
break|break;
block|}
block|}
block|}
else|else
block|{
name|struct
name|scsi_sense_data_fixed
modifier|*
name|sense
decl_stmt|;
name|sense
operator|=
operator|(
expr|struct
name|scsi_sense_data_fixed
operator|*
operator|)
name|sense_data
expr_stmt|;
if|if
condition|(
name|current_error
operator|!=
literal|0
condition|)
name|sense
operator|->
name|error_code
operator|=
name|SSD_CURRENT_ERROR
expr_stmt|;
else|else
name|sense
operator|->
name|error_code
operator|=
name|SSD_DEFERRED_ERROR
expr_stmt|;
name|sense
operator|->
name|flags
operator|=
name|sense_key
expr_stmt|;
name|sense
operator|->
name|add_sense_code
operator|=
name|asc
expr_stmt|;
name|sense
operator|->
name|add_sense_code_qual
operator|=
name|ascq
expr_stmt|;
comment|/* 		 * We've set the ASC and ASCQ, so we have 6 more bytes of 		 * valid data.  If we wind up setting any of the other 		 * fields, we'll bump this to 10 extra bytes. 		 */
name|sense
operator|->
name|extra_len
operator|=
literal|6
expr_stmt|;
while|while
condition|(
operator|(
name|elem_type
operator|=
operator|(
name|scsi_sense_elem_type
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|scsi_sense_elem_type
argument_list|)
operator|)
operator|!=
name|SSD_ELEM_NONE
condition|)
block|{
name|int
name|sense_len
decl_stmt|,
name|len_to_copy
decl_stmt|;
name|uint8_t
modifier|*
name|data
decl_stmt|;
if|if
condition|(
name|elem_type
operator|>=
name|SSD_ELEM_MAX
condition|)
block|{
name|printf
argument_list|(
literal|"%s: invalid sense type %d\n"
argument_list|,
name|__func__
argument_list|,
name|elem_type
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 			 * If we get in here, just bump the extra length to 			 * 10 bytes.  That will encompass anything we're 			 * going to set here. 			 */
name|sense
operator|->
name|extra_len
operator|=
literal|10
expr_stmt|;
name|sense_len
operator|=
operator|(
name|int
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|len_to_copy
operator|=
name|MIN
argument_list|(
name|sense_len
argument_list|,
name|SSD_EXTRA_MAX
operator|-
name|sense
operator|->
name|extra_len
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint8_t
operator|*
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|elem_type
condition|)
block|{
case|case
name|SSD_ELEM_SKS
case|:
comment|/* 				 * The user passed in pre-formatted sense 				 * key specific data. 				 */
name|bcopy
argument_list|(
name|data
argument_list|,
operator|&
name|sense
operator|->
name|sense_key_spec
index|[
literal|0
index|]
argument_list|,
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
name|sense
operator|->
name|sense_key_spec
argument_list|)
argument_list|,
name|sense_len
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SSD_ELEM_INFO
case|:
case|case
name|SSD_ELEM_COMMAND
case|:
block|{
name|uint8_t
modifier|*
name|data_dest
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|elem_type
operator|==
name|SSD_ELEM_COMMAND
condition|)
name|data_dest
operator|=
operator|&
name|sense
operator|->
name|cmd_spec_info
index|[
literal|0
index|]
expr_stmt|;
else|else
block|{
name|data_dest
operator|=
operator|&
name|sense
operator|->
name|info
index|[
literal|0
index|]
expr_stmt|;
comment|/* 					 * We're setting the info field, so 					 * set the valid bit. 					 */
name|sense
operator|->
name|error_code
operator||=
name|SSD_ERRCODE_VALID
expr_stmt|;
block|}
comment|/* 			 	 * Copy this in reverse so that if we have 				 * less than 4 bytes to fill, the least 				 * significant bytes will be at the end. 				 * If we have more than 4 bytes, only the 				 * least significant bytes will be included. 				 */
for|for
control|(
name|i
operator|=
name|sense_len
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
operator|&&
name|len_to_copy
operator|>
literal|0
condition|;
name|i
operator|--
operator|,
name|len_to_copy
operator|--
control|)
name|data_dest
index|[
name|len_to_copy
operator|-
literal|1
index|]
operator|=
name|data
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
case|case
name|SSD_ELEM_FRU
case|:
name|sense
operator|->
name|fru
operator|=
operator|*
name|data
expr_stmt|;
break|break;
case|case
name|SSD_ELEM_STREAM
case|:
name|sense
operator|->
name|flags
operator||=
operator|*
name|data
expr_stmt|;
break|break;
case|case
name|SSD_ELEM_DESC
case|:
default|default:
comment|/* 				 * If the user passes in descriptor sense, 				 * we can't handle that in fixed format. 				 * So just skip it, and any unknown argument 				 * types. 				 */
break|break;
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|scsi_set_sense_data
parameter_list|(
name|struct
name|scsi_sense_data
modifier|*
name|sense_data
parameter_list|,
name|scsi_sense_data_type
name|sense_format
parameter_list|,
name|int
name|current_error
parameter_list|,
name|int
name|sense_key
parameter_list|,
name|int
name|asc
parameter_list|,
name|int
name|ascq
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|ascq
argument_list|)
expr_stmt|;
name|scsi_set_sense_data_va
argument_list|(
name|sense_data
argument_list|,
name|sense_format
argument_list|,
name|current_error
argument_list|,
name|sense_key
argument_list|,
name|asc
argument_list|,
name|ascq
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get sense information for three similar sense data types.  */
end_comment

begin_function
name|int
name|scsi_get_sense_info
parameter_list|(
name|struct
name|scsi_sense_data
modifier|*
name|sense_data
parameter_list|,
name|u_int
name|sense_len
parameter_list|,
name|uint8_t
name|info_type
parameter_list|,
name|uint64_t
modifier|*
name|info
parameter_list|,
name|int64_t
modifier|*
name|signed_info
parameter_list|)
block|{
name|scsi_sense_data_type
name|sense_type
decl_stmt|;
if|if
condition|(
name|sense_len
operator|==
literal|0
condition|)
goto|goto
name|bailout
goto|;
name|sense_type
operator|=
name|scsi_sense_type
argument_list|(
name|sense_data
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sense_type
condition|)
block|{
case|case
name|SSD_TYPE_DESC
case|:
block|{
name|struct
name|scsi_sense_data_desc
modifier|*
name|sense
decl_stmt|;
name|uint8_t
modifier|*
name|desc
decl_stmt|;
name|sense
operator|=
operator|(
expr|struct
name|scsi_sense_data_desc
operator|*
operator|)
name|sense_data
expr_stmt|;
name|desc
operator|=
name|scsi_find_desc
argument_list|(
name|sense
argument_list|,
name|sense_len
argument_list|,
name|info_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|==
name|NULL
condition|)
goto|goto
name|bailout
goto|;
switch|switch
condition|(
name|info_type
condition|)
block|{
case|case
name|SSD_DESC_INFO
case|:
block|{
name|struct
name|scsi_sense_info
modifier|*
name|info_desc
decl_stmt|;
name|info_desc
operator|=
operator|(
expr|struct
name|scsi_sense_info
operator|*
operator|)
name|desc
expr_stmt|;
operator|*
name|info
operator|=
name|scsi_8btou64
argument_list|(
name|info_desc
operator|->
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|signed_info
operator|!=
name|NULL
condition|)
operator|*
name|signed_info
operator|=
operator|*
name|info
expr_stmt|;
break|break;
block|}
case|case
name|SSD_DESC_COMMAND
case|:
block|{
name|struct
name|scsi_sense_command
modifier|*
name|cmd_desc
decl_stmt|;
name|cmd_desc
operator|=
operator|(
expr|struct
name|scsi_sense_command
operator|*
operator|)
name|desc
expr_stmt|;
operator|*
name|info
operator|=
name|scsi_8btou64
argument_list|(
name|cmd_desc
operator|->
name|command_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|signed_info
operator|!=
name|NULL
condition|)
operator|*
name|signed_info
operator|=
operator|*
name|info
expr_stmt|;
break|break;
block|}
case|case
name|SSD_DESC_FRU
case|:
block|{
name|struct
name|scsi_sense_fru
modifier|*
name|fru_desc
decl_stmt|;
name|fru_desc
operator|=
operator|(
expr|struct
name|scsi_sense_fru
operator|*
operator|)
name|desc
expr_stmt|;
operator|*
name|info
operator|=
name|fru_desc
operator|->
name|fru
expr_stmt|;
if|if
condition|(
name|signed_info
operator|!=
name|NULL
condition|)
operator|*
name|signed_info
operator|=
operator|(
name|int8_t
operator|)
name|fru_desc
operator|->
name|fru
expr_stmt|;
break|break;
block|}
default|default:
goto|goto
name|bailout
goto|;
break|break;
block|}
break|break;
block|}
case|case
name|SSD_TYPE_FIXED
case|:
block|{
name|struct
name|scsi_sense_data_fixed
modifier|*
name|sense
decl_stmt|;
name|sense
operator|=
operator|(
expr|struct
name|scsi_sense_data_fixed
operator|*
operator|)
name|sense_data
expr_stmt|;
switch|switch
condition|(
name|info_type
condition|)
block|{
case|case
name|SSD_DESC_INFO
case|:
block|{
name|uint32_t
name|info_val
decl_stmt|;
if|if
condition|(
operator|(
name|sense
operator|->
name|error_code
operator|&
name|SSD_ERRCODE_VALID
operator|)
operator|==
literal|0
condition|)
goto|goto
name|bailout
goto|;
if|if
condition|(
name|SSD_FIXED_IS_PRESENT
argument_list|(
name|sense
argument_list|,
name|sense_len
argument_list|,
name|info
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|bailout
goto|;
name|info_val
operator|=
name|scsi_4btoul
argument_list|(
name|sense
operator|->
name|info
argument_list|)
expr_stmt|;
operator|*
name|info
operator|=
name|info_val
expr_stmt|;
if|if
condition|(
name|signed_info
operator|!=
name|NULL
condition|)
operator|*
name|signed_info
operator|=
operator|(
name|int32_t
operator|)
name|info_val
expr_stmt|;
break|break;
block|}
case|case
name|SSD_DESC_COMMAND
case|:
block|{
name|uint32_t
name|cmd_val
decl_stmt|;
if|if
condition|(
operator|(
name|SSD_FIXED_IS_PRESENT
argument_list|(
name|sense
argument_list|,
name|sense_len
argument_list|,
name|cmd_spec_info
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|SSD_FIXED_IS_FILLED
argument_list|(
name|sense
argument_list|,
name|cmd_spec_info
argument_list|)
operator|==
literal|0
operator|)
condition|)
goto|goto
name|bailout
goto|;
name|cmd_val
operator|=
name|scsi_4btoul
argument_list|(
name|sense
operator|->
name|cmd_spec_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd_val
operator|==
literal|0
condition|)
goto|goto
name|bailout
goto|;
operator|*
name|info
operator|=
name|cmd_val
expr_stmt|;
if|if
condition|(
name|signed_info
operator|!=
name|NULL
condition|)
operator|*
name|signed_info
operator|=
operator|(
name|int32_t
operator|)
name|cmd_val
expr_stmt|;
break|break;
block|}
case|case
name|SSD_DESC_FRU
case|:
if|if
condition|(
operator|(
name|SSD_FIXED_IS_PRESENT
argument_list|(
name|sense
argument_list|,
name|sense_len
argument_list|,
name|fru
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|SSD_FIXED_IS_FILLED
argument_list|(
name|sense
argument_list|,
name|fru
argument_list|)
operator|==
literal|0
operator|)
condition|)
goto|goto
name|bailout
goto|;
if|if
condition|(
name|sense
operator|->
name|fru
operator|==
literal|0
condition|)
goto|goto
name|bailout
goto|;
operator|*
name|info
operator|=
name|sense
operator|->
name|fru
expr_stmt|;
if|if
condition|(
name|signed_info
operator|!=
name|NULL
condition|)
operator|*
name|signed_info
operator|=
operator|(
name|int8_t
operator|)
name|sense
operator|->
name|fru
expr_stmt|;
break|break;
default|default:
goto|goto
name|bailout
goto|;
break|break;
block|}
break|break;
block|}
default|default:
goto|goto
name|bailout
goto|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|bailout
label|:
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|scsi_get_sks
parameter_list|(
name|struct
name|scsi_sense_data
modifier|*
name|sense_data
parameter_list|,
name|u_int
name|sense_len
parameter_list|,
name|uint8_t
modifier|*
name|sks
parameter_list|)
block|{
name|scsi_sense_data_type
name|sense_type
decl_stmt|;
if|if
condition|(
name|sense_len
operator|==
literal|0
condition|)
goto|goto
name|bailout
goto|;
name|sense_type
operator|=
name|scsi_sense_type
argument_list|(
name|sense_data
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sense_type
condition|)
block|{
case|case
name|SSD_TYPE_DESC
case|:
block|{
name|struct
name|scsi_sense_data_desc
modifier|*
name|sense
decl_stmt|;
name|struct
name|scsi_sense_sks
modifier|*
name|desc
decl_stmt|;
name|sense
operator|=
operator|(
expr|struct
name|scsi_sense_data_desc
operator|*
operator|)
name|sense_data
expr_stmt|;
name|desc
operator|=
operator|(
expr|struct
name|scsi_sense_sks
operator|*
operator|)
name|scsi_find_desc
argument_list|(
name|sense
argument_list|,
name|sense_len
argument_list|,
name|SSD_DESC_SKS
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|==
name|NULL
condition|)
goto|goto
name|bailout
goto|;
comment|/* 		 * No need to check the SKS valid bit for descriptor sense. 		 * If the descriptor is present, it is valid. 		 */
name|bcopy
argument_list|(
name|desc
operator|->
name|sense_key_spec
argument_list|,
name|sks
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
operator|->
name|sense_key_spec
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SSD_TYPE_FIXED
case|:
block|{
name|struct
name|scsi_sense_data_fixed
modifier|*
name|sense
decl_stmt|;
name|sense
operator|=
operator|(
expr|struct
name|scsi_sense_data_fixed
operator|*
operator|)
name|sense_data
expr_stmt|;
if|if
condition|(
operator|(
name|SSD_FIXED_IS_PRESENT
argument_list|(
name|sense
argument_list|,
name|sense_len
argument_list|,
name|sense_key_spec
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|SSD_FIXED_IS_FILLED
argument_list|(
name|sense
argument_list|,
name|sense_key_spec
argument_list|)
operator|==
literal|0
operator|)
condition|)
goto|goto
name|bailout
goto|;
if|if
condition|(
operator|(
name|sense
operator|->
name|sense_key_spec
index|[
literal|0
index|]
operator|&
name|SSD_SCS_VALID
operator|)
operator|==
literal|0
condition|)
goto|goto
name|bailout
goto|;
name|bcopy
argument_list|(
name|sense
operator|->
name|sense_key_spec
argument_list|,
name|sks
argument_list|,
sizeof|sizeof
argument_list|(
name|sense
operator|->
name|sense_key_spec
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
goto|goto
name|bailout
goto|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|bailout
label|:
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Provide a common interface for fixed and descriptor sense to detect  * whether we have block-specific sense information.  It is clear by the  * presence of the block descriptor in descriptor mode, but we have to  * infer from the inquiry data and ILI bit in fixed mode.  */
end_comment

begin_function
name|int
name|scsi_get_block_info
parameter_list|(
name|struct
name|scsi_sense_data
modifier|*
name|sense_data
parameter_list|,
name|u_int
name|sense_len
parameter_list|,
name|struct
name|scsi_inquiry_data
modifier|*
name|inq_data
parameter_list|,
name|uint8_t
modifier|*
name|block_bits
parameter_list|)
block|{
name|scsi_sense_data_type
name|sense_type
decl_stmt|;
if|if
condition|(
name|inq_data
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|SID_TYPE
argument_list|(
name|inq_data
argument_list|)
condition|)
block|{
case|case
name|T_DIRECT
case|:
case|case
name|T_RBC
case|:
break|break;
default|default:
goto|goto
name|bailout
goto|;
break|break;
block|}
block|}
name|sense_type
operator|=
name|scsi_sense_type
argument_list|(
name|sense_data
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sense_type
condition|)
block|{
case|case
name|SSD_TYPE_DESC
case|:
block|{
name|struct
name|scsi_sense_data_desc
modifier|*
name|sense
decl_stmt|;
name|struct
name|scsi_sense_block
modifier|*
name|block
decl_stmt|;
name|sense
operator|=
operator|(
expr|struct
name|scsi_sense_data_desc
operator|*
operator|)
name|sense_data
expr_stmt|;
name|block
operator|=
operator|(
expr|struct
name|scsi_sense_block
operator|*
operator|)
name|scsi_find_desc
argument_list|(
name|sense
argument_list|,
name|sense_len
argument_list|,
name|SSD_DESC_BLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|block
operator|==
name|NULL
condition|)
goto|goto
name|bailout
goto|;
operator|*
name|block_bits
operator|=
name|block
operator|->
name|byte3
expr_stmt|;
break|break;
block|}
case|case
name|SSD_TYPE_FIXED
case|:
block|{
name|struct
name|scsi_sense_data_fixed
modifier|*
name|sense
decl_stmt|;
name|sense
operator|=
operator|(
expr|struct
name|scsi_sense_data_fixed
operator|*
operator|)
name|sense_data
expr_stmt|;
if|if
condition|(
name|SSD_FIXED_IS_PRESENT
argument_list|(
name|sense
argument_list|,
name|sense_len
argument_list|,
name|flags
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|bailout
goto|;
if|if
condition|(
operator|(
name|sense
operator|->
name|flags
operator|&
name|SSD_ILI
operator|)
operator|==
literal|0
condition|)
goto|goto
name|bailout
goto|;
operator|*
name|block_bits
operator|=
name|sense
operator|->
name|flags
operator|&
name|SSD_ILI
expr_stmt|;
break|break;
block|}
default|default:
goto|goto
name|bailout
goto|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|bailout
label|:
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|scsi_get_stream_info
parameter_list|(
name|struct
name|scsi_sense_data
modifier|*
name|sense_data
parameter_list|,
name|u_int
name|sense_len
parameter_list|,
name|struct
name|scsi_inquiry_data
modifier|*
name|inq_data
parameter_list|,
name|uint8_t
modifier|*
name|stream_bits
parameter_list|)
block|{
name|scsi_sense_data_type
name|sense_type
decl_stmt|;
if|if
condition|(
name|inq_data
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|SID_TYPE
argument_list|(
name|inq_data
argument_list|)
condition|)
block|{
case|case
name|T_SEQUENTIAL
case|:
break|break;
default|default:
goto|goto
name|bailout
goto|;
break|break;
block|}
block|}
name|sense_type
operator|=
name|scsi_sense_type
argument_list|(
name|sense_data
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sense_type
condition|)
block|{
case|case
name|SSD_TYPE_DESC
case|:
block|{
name|struct
name|scsi_sense_data_desc
modifier|*
name|sense
decl_stmt|;
name|struct
name|scsi_sense_stream
modifier|*
name|stream
decl_stmt|;
name|sense
operator|=
operator|(
expr|struct
name|scsi_sense_data_desc
operator|*
operator|)
name|sense_data
expr_stmt|;
name|stream
operator|=
operator|(
expr|struct
name|scsi_sense_stream
operator|*
operator|)
name|scsi_find_desc
argument_list|(
name|sense
argument_list|,
name|sense_len
argument_list|,
name|SSD_DESC_STREAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|stream
operator|==
name|NULL
condition|)
goto|goto
name|bailout
goto|;
operator|*
name|stream_bits
operator|=
name|stream
operator|->
name|byte3
expr_stmt|;
break|break;
block|}
case|case
name|SSD_TYPE_FIXED
case|:
block|{
name|struct
name|scsi_sense_data_fixed
modifier|*
name|sense
decl_stmt|;
name|sense
operator|=
operator|(
expr|struct
name|scsi_sense_data_fixed
operator|*
operator|)
name|sense_data
expr_stmt|;
if|if
condition|(
name|SSD_FIXED_IS_PRESENT
argument_list|(
name|sense
argument_list|,
name|sense_len
argument_list|,
name|flags
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|bailout
goto|;
if|if
condition|(
operator|(
name|sense
operator|->
name|flags
operator|&
operator|(
name|SSD_ILI
operator||
name|SSD_EOM
operator||
name|SSD_FILEMARK
operator|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|bailout
goto|;
operator|*
name|stream_bits
operator|=
name|sense
operator|->
name|flags
operator|&
operator|(
name|SSD_ILI
operator||
name|SSD_EOM
operator||
name|SSD_FILEMARK
operator|)
expr_stmt|;
break|break;
block|}
default|default:
goto|goto
name|bailout
goto|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|bailout
label|:
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|scsi_info_sbuf
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|uint8_t
modifier|*
name|cdb
parameter_list|,
name|int
name|cdb_len
parameter_list|,
name|struct
name|scsi_inquiry_data
modifier|*
name|inq_data
parameter_list|,
name|uint64_t
name|info
parameter_list|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"Info: %#jx"
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_command_sbuf
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|uint8_t
modifier|*
name|cdb
parameter_list|,
name|int
name|cdb_len
parameter_list|,
name|struct
name|scsi_inquiry_data
modifier|*
name|inq_data
parameter_list|,
name|uint64_t
name|csi
parameter_list|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"Command Specific Info: %#jx"
argument_list|,
name|csi
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_progress_sbuf
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|uint16_t
name|progress
parameter_list|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"Progress: %d%% (%d/%d) complete"
argument_list|,
operator|(
name|progress
operator|*
literal|100
operator|)
operator|/
name|SSD_SKS_PROGRESS_DENOM
argument_list|,
name|progress
argument_list|,
name|SSD_SKS_PROGRESS_DENOM
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns 1 for failure (i.e. SKS isn't valid) and 0 for success.  */
end_comment

begin_function
name|int
name|scsi_sks_sbuf
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|int
name|sense_key
parameter_list|,
name|uint8_t
modifier|*
name|sks
parameter_list|)
block|{
if|if
condition|(
operator|(
name|sks
index|[
literal|0
index|]
operator|&
name|SSD_SKS_VALID
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
switch|switch
condition|(
name|sense_key
condition|)
block|{
case|case
name|SSD_KEY_ILLEGAL_REQUEST
case|:
block|{
name|struct
name|scsi_sense_sks_field
modifier|*
name|field
decl_stmt|;
name|int
name|bad_command
decl_stmt|;
name|char
name|tmpstr
index|[
literal|40
index|]
decl_stmt|;
comment|/*Field Pointer*/
name|field
operator|=
operator|(
expr|struct
name|scsi_sense_sks_field
operator|*
operator|)
name|sks
expr_stmt|;
if|if
condition|(
name|field
operator|->
name|byte0
operator|&
name|SSD_SKS_FIELD_CMD
condition|)
name|bad_command
operator|=
literal|1
expr_stmt|;
else|else
name|bad_command
operator|=
literal|0
expr_stmt|;
name|tmpstr
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Bit pointer is valid */
if|if
condition|(
name|field
operator|->
name|byte0
operator|&
name|SSD_SKS_BPV
condition|)
name|snprintf
argument_list|(
name|tmpstr
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
literal|"bit %d "
argument_list|,
name|field
operator|->
name|byte0
operator|&
name|SSD_SKS_BIT_VALUE
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s byte %d %sis invalid"
argument_list|,
name|bad_command
condition|?
literal|"Command"
else|:
literal|"Data"
argument_list|,
name|scsi_2btoul
argument_list|(
name|field
operator|->
name|field
argument_list|)
argument_list|,
name|tmpstr
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SSD_KEY_UNIT_ATTENTION
case|:
block|{
name|struct
name|scsi_sense_sks_overflow
modifier|*
name|overflow
decl_stmt|;
name|overflow
operator|=
operator|(
expr|struct
name|scsi_sense_sks_overflow
operator|*
operator|)
name|sks
expr_stmt|;
comment|/*UA Condition Queue Overflow*/
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"Unit Attention Condition Queue %s"
argument_list|,
operator|(
name|overflow
operator|->
name|byte0
operator|&
name|SSD_SKS_OVERFLOW_SET
operator|)
condition|?
literal|"Overflowed"
else|:
literal|"Did Not Overflow??"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SSD_KEY_RECOVERED_ERROR
case|:
case|case
name|SSD_KEY_HARDWARE_ERROR
case|:
case|case
name|SSD_KEY_MEDIUM_ERROR
case|:
block|{
name|struct
name|scsi_sense_sks_retry
modifier|*
name|retry
decl_stmt|;
comment|/*Actual Retry Count*/
name|retry
operator|=
operator|(
expr|struct
name|scsi_sense_sks_retry
operator|*
operator|)
name|sks
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"Actual Retry Count: %d"
argument_list|,
name|scsi_2btoul
argument_list|(
name|retry
operator|->
name|actual_retry_count
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SSD_KEY_NO_SENSE
case|:
case|case
name|SSD_KEY_NOT_READY
case|:
block|{
name|struct
name|scsi_sense_sks_progress
modifier|*
name|progress
decl_stmt|;
name|int
name|progress_val
decl_stmt|;
comment|/*Progress Indication*/
name|progress
operator|=
operator|(
expr|struct
name|scsi_sense_sks_progress
operator|*
operator|)
name|sks
expr_stmt|;
name|progress_val
operator|=
name|scsi_2btoul
argument_list|(
name|progress
operator|->
name|progress
argument_list|)
expr_stmt|;
name|scsi_progress_sbuf
argument_list|(
name|sb
argument_list|,
name|progress_val
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SSD_KEY_COPY_ABORTED
case|:
block|{
name|struct
name|scsi_sense_sks_segment
modifier|*
name|segment
decl_stmt|;
name|char
name|tmpstr
index|[
literal|40
index|]
decl_stmt|;
comment|/*Segment Pointer*/
name|segment
operator|=
operator|(
expr|struct
name|scsi_sense_sks_segment
operator|*
operator|)
name|sks
expr_stmt|;
name|tmpstr
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|segment
operator|->
name|byte0
operator|&
name|SSD_SKS_SEGMENT_BPV
condition|)
name|snprintf
argument_list|(
name|tmpstr
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
literal|"bit %d "
argument_list|,
name|segment
operator|->
name|byte0
operator|&
name|SSD_SKS_SEGMENT_BITPTR
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s byte %d %sis invalid"
argument_list|,
operator|(
name|segment
operator|->
name|byte0
operator|&
name|SSD_SKS_SEGMENT_SD
operator|)
condition|?
literal|"Segment"
else|:
literal|"Data"
argument_list|,
name|scsi_2btoul
argument_list|(
name|segment
operator|->
name|field
argument_list|)
argument_list|,
name|tmpstr
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"Sense Key Specific: %#x,%#x"
argument_list|,
name|sks
index|[
literal|0
index|]
argument_list|,
name|scsi_2btoul
argument_list|(
operator|&
name|sks
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|scsi_fru_sbuf
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|uint64_t
name|fru
parameter_list|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"Field Replaceable Unit: %d"
argument_list|,
operator|(
name|int
operator|)
name|fru
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_stream_sbuf
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|uint8_t
name|stream_bits
parameter_list|,
name|uint64_t
name|info
parameter_list|)
block|{
name|int
name|need_comma
decl_stmt|;
name|need_comma
operator|=
literal|0
expr_stmt|;
comment|/* 	 * XXX KDM this needs more descriptive decoding. 	 */
if|if
condition|(
name|stream_bits
operator|&
name|SSD_DESC_STREAM_FM
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"Filemark"
argument_list|)
expr_stmt|;
name|need_comma
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|stream_bits
operator|&
name|SSD_DESC_STREAM_EOM
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%sEOM"
argument_list|,
operator|(
name|need_comma
operator|)
condition|?
literal|","
else|:
literal|""
argument_list|)
expr_stmt|;
name|need_comma
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|stream_bits
operator|&
name|SSD_DESC_STREAM_ILI
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%sILI"
argument_list|,
operator|(
name|need_comma
operator|)
condition|?
literal|","
else|:
literal|""
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|": Info: %#jx"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|info
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_block_sbuf
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|uint8_t
name|block_bits
parameter_list|,
name|uint64_t
name|info
parameter_list|)
block|{
if|if
condition|(
name|block_bits
operator|&
name|SSD_DESC_BLOCK_ILI
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"ILI: residue %#jx"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|info
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_sense_info_sbuf
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|struct
name|scsi_sense_data
modifier|*
name|sense
parameter_list|,
name|u_int
name|sense_len
parameter_list|,
name|uint8_t
modifier|*
name|cdb
parameter_list|,
name|int
name|cdb_len
parameter_list|,
name|struct
name|scsi_inquiry_data
modifier|*
name|inq_data
parameter_list|,
name|struct
name|scsi_sense_desc_header
modifier|*
name|header
parameter_list|)
block|{
name|struct
name|scsi_sense_info
modifier|*
name|info
decl_stmt|;
name|info
operator|=
operator|(
expr|struct
name|scsi_sense_info
operator|*
operator|)
name|header
expr_stmt|;
name|scsi_info_sbuf
argument_list|(
name|sb
argument_list|,
name|cdb
argument_list|,
name|cdb_len
argument_list|,
name|inq_data
argument_list|,
name|scsi_8btou64
argument_list|(
name|info
operator|->
name|info
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_sense_command_sbuf
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|struct
name|scsi_sense_data
modifier|*
name|sense
parameter_list|,
name|u_int
name|sense_len
parameter_list|,
name|uint8_t
modifier|*
name|cdb
parameter_list|,
name|int
name|cdb_len
parameter_list|,
name|struct
name|scsi_inquiry_data
modifier|*
name|inq_data
parameter_list|,
name|struct
name|scsi_sense_desc_header
modifier|*
name|header
parameter_list|)
block|{
name|struct
name|scsi_sense_command
modifier|*
name|command
decl_stmt|;
name|command
operator|=
operator|(
expr|struct
name|scsi_sense_command
operator|*
operator|)
name|header
expr_stmt|;
name|scsi_command_sbuf
argument_list|(
name|sb
argument_list|,
name|cdb
argument_list|,
name|cdb_len
argument_list|,
name|inq_data
argument_list|,
name|scsi_8btou64
argument_list|(
name|command
operator|->
name|command_info
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_sense_sks_sbuf
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|struct
name|scsi_sense_data
modifier|*
name|sense
parameter_list|,
name|u_int
name|sense_len
parameter_list|,
name|uint8_t
modifier|*
name|cdb
parameter_list|,
name|int
name|cdb_len
parameter_list|,
name|struct
name|scsi_inquiry_data
modifier|*
name|inq_data
parameter_list|,
name|struct
name|scsi_sense_desc_header
modifier|*
name|header
parameter_list|)
block|{
name|struct
name|scsi_sense_sks
modifier|*
name|sks
decl_stmt|;
name|int
name|error_code
decl_stmt|,
name|sense_key
decl_stmt|,
name|asc
decl_stmt|,
name|ascq
decl_stmt|;
name|sks
operator|=
operator|(
expr|struct
name|scsi_sense_sks
operator|*
operator|)
name|header
expr_stmt|;
name|scsi_extract_sense_len
argument_list|(
name|sense
argument_list|,
name|sense_len
argument_list|,
operator|&
name|error_code
argument_list|,
operator|&
name|sense_key
argument_list|,
operator|&
name|asc
argument_list|,
operator|&
name|ascq
argument_list|,
comment|/*show_errors*/
literal|1
argument_list|)
expr_stmt|;
name|scsi_sks_sbuf
argument_list|(
name|sb
argument_list|,
name|sense_key
argument_list|,
name|sks
operator|->
name|sense_key_spec
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_sense_fru_sbuf
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|struct
name|scsi_sense_data
modifier|*
name|sense
parameter_list|,
name|u_int
name|sense_len
parameter_list|,
name|uint8_t
modifier|*
name|cdb
parameter_list|,
name|int
name|cdb_len
parameter_list|,
name|struct
name|scsi_inquiry_data
modifier|*
name|inq_data
parameter_list|,
name|struct
name|scsi_sense_desc_header
modifier|*
name|header
parameter_list|)
block|{
name|struct
name|scsi_sense_fru
modifier|*
name|fru
decl_stmt|;
name|fru
operator|=
operator|(
expr|struct
name|scsi_sense_fru
operator|*
operator|)
name|header
expr_stmt|;
name|scsi_fru_sbuf
argument_list|(
name|sb
argument_list|,
operator|(
name|uint64_t
operator|)
name|fru
operator|->
name|fru
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_sense_stream_sbuf
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|struct
name|scsi_sense_data
modifier|*
name|sense
parameter_list|,
name|u_int
name|sense_len
parameter_list|,
name|uint8_t
modifier|*
name|cdb
parameter_list|,
name|int
name|cdb_len
parameter_list|,
name|struct
name|scsi_inquiry_data
modifier|*
name|inq_data
parameter_list|,
name|struct
name|scsi_sense_desc_header
modifier|*
name|header
parameter_list|)
block|{
name|struct
name|scsi_sense_stream
modifier|*
name|stream
decl_stmt|;
name|uint64_t
name|info
decl_stmt|;
name|stream
operator|=
operator|(
expr|struct
name|scsi_sense_stream
operator|*
operator|)
name|header
expr_stmt|;
name|info
operator|=
literal|0
expr_stmt|;
name|scsi_get_sense_info
argument_list|(
name|sense
argument_list|,
name|sense_len
argument_list|,
name|SSD_DESC_INFO
argument_list|,
operator|&
name|info
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|scsi_stream_sbuf
argument_list|(
name|sb
argument_list|,
name|stream
operator|->
name|byte3
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_sense_block_sbuf
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|struct
name|scsi_sense_data
modifier|*
name|sense
parameter_list|,
name|u_int
name|sense_len
parameter_list|,
name|uint8_t
modifier|*
name|cdb
parameter_list|,
name|int
name|cdb_len
parameter_list|,
name|struct
name|scsi_inquiry_data
modifier|*
name|inq_data
parameter_list|,
name|struct
name|scsi_sense_desc_header
modifier|*
name|header
parameter_list|)
block|{
name|struct
name|scsi_sense_block
modifier|*
name|block
decl_stmt|;
name|uint64_t
name|info
decl_stmt|;
name|block
operator|=
operator|(
expr|struct
name|scsi_sense_block
operator|*
operator|)
name|header
expr_stmt|;
name|info
operator|=
literal|0
expr_stmt|;
name|scsi_get_sense_info
argument_list|(
name|sense
argument_list|,
name|sense_len
argument_list|,
name|SSD_DESC_INFO
argument_list|,
operator|&
name|info
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|scsi_block_sbuf
argument_list|(
name|sb
argument_list|,
name|block
operator|->
name|byte3
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_sense_progress_sbuf
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|struct
name|scsi_sense_data
modifier|*
name|sense
parameter_list|,
name|u_int
name|sense_len
parameter_list|,
name|uint8_t
modifier|*
name|cdb
parameter_list|,
name|int
name|cdb_len
parameter_list|,
name|struct
name|scsi_inquiry_data
modifier|*
name|inq_data
parameter_list|,
name|struct
name|scsi_sense_desc_header
modifier|*
name|header
parameter_list|)
block|{
name|struct
name|scsi_sense_progress
modifier|*
name|progress
decl_stmt|;
specifier|const
name|char
modifier|*
name|sense_key_desc
decl_stmt|;
specifier|const
name|char
modifier|*
name|asc_desc
decl_stmt|;
name|int
name|progress_val
decl_stmt|;
name|progress
operator|=
operator|(
expr|struct
name|scsi_sense_progress
operator|*
operator|)
name|header
expr_stmt|;
comment|/* 	 * Get descriptions for the sense key, ASC, and ASCQ in the 	 * progress descriptor.  These could be different than the values 	 * in the overall sense data. 	 */
name|scsi_sense_desc
argument_list|(
name|progress
operator|->
name|sense_key
argument_list|,
name|progress
operator|->
name|add_sense_code
argument_list|,
name|progress
operator|->
name|add_sense_code_qual
argument_list|,
name|inq_data
argument_list|,
operator|&
name|sense_key_desc
argument_list|,
operator|&
name|asc_desc
argument_list|)
expr_stmt|;
name|progress_val
operator|=
name|scsi_2btoul
argument_list|(
name|progress
operator|->
name|progress
argument_list|)
expr_stmt|;
comment|/* 	 * The progress indicator is for the operation described by the 	 * sense key, ASC, and ASCQ in the descriptor. 	 */
name|sbuf_cat
argument_list|(
name|sb
argument_list|,
name|sense_key_desc
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" asc:%x,%x (%s): "
argument_list|,
name|progress
operator|->
name|add_sense_code
argument_list|,
name|progress
operator|->
name|add_sense_code_qual
argument_list|,
name|asc_desc
argument_list|)
expr_stmt|;
name|scsi_progress_sbuf
argument_list|(
name|sb
argument_list|,
name|progress_val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Generic sense descriptor printing routine.  This is used when we have  * not yet implemented a specific printing routine for this descriptor.  */
end_comment

begin_function
name|void
name|scsi_sense_generic_sbuf
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|struct
name|scsi_sense_data
modifier|*
name|sense
parameter_list|,
name|u_int
name|sense_len
parameter_list|,
name|uint8_t
modifier|*
name|cdb
parameter_list|,
name|int
name|cdb_len
parameter_list|,
name|struct
name|scsi_inquiry_data
modifier|*
name|inq_data
parameter_list|,
name|struct
name|scsi_sense_desc_header
modifier|*
name|header
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint8_t
modifier|*
name|buf_ptr
decl_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"Descriptor %#x:"
argument_list|,
name|header
operator|->
name|desc_type
argument_list|)
expr_stmt|;
name|buf_ptr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|header
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|header
operator|->
name|length
condition|;
name|i
operator|++
operator|,
name|buf_ptr
operator|++
control|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" %02x"
argument_list|,
operator|*
name|buf_ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Keep this list in numeric order.  This speeds the array traversal.  */
end_comment

begin_struct
struct|struct
name|scsi_sense_desc_printer
block|{
name|uint8_t
name|desc_type
decl_stmt|;
comment|/* 	 * The function arguments here are the superset of what is needed 	 * to print out various different descriptors.  Command and 	 * information descriptors need inquiry data and command type. 	 * Sense key specific descriptors need the sense key. 	 * 	 * The sense, cdb, and inquiry data arguments may be NULL, but the 	 * information printed may not be fully decoded as a result. 	 */
name|void
function_decl|(
modifier|*
name|print_func
function_decl|)
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|struct
name|scsi_sense_data
modifier|*
name|sense
parameter_list|,
name|u_int
name|sense_len
parameter_list|,
name|uint8_t
modifier|*
name|cdb
parameter_list|,
name|int
name|cdb_len
parameter_list|,
name|struct
name|scsi_inquiry_data
modifier|*
name|inq_data
parameter_list|,
name|struct
name|scsi_sense_desc_header
modifier|*
name|header
parameter_list|)
function_decl|;
block|}
name|scsi_sense_printers
index|[]
init|=
block|{
block|{
name|SSD_DESC_INFO
block|,
name|scsi_sense_info_sbuf
block|}
block|,
block|{
name|SSD_DESC_COMMAND
block|,
name|scsi_sense_command_sbuf
block|}
block|,
block|{
name|SSD_DESC_SKS
block|,
name|scsi_sense_sks_sbuf
block|}
block|,
block|{
name|SSD_DESC_FRU
block|,
name|scsi_sense_fru_sbuf
block|}
block|,
block|{
name|SSD_DESC_STREAM
block|,
name|scsi_sense_stream_sbuf
block|}
block|,
block|{
name|SSD_DESC_BLOCK
block|,
name|scsi_sense_block_sbuf
block|}
block|,
block|{
name|SSD_DESC_PROGRESS
block|,
name|scsi_sense_progress_sbuf
block|}
block|}
struct|;
end_struct

begin_function
name|void
name|scsi_sense_desc_sbuf
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|struct
name|scsi_sense_data
modifier|*
name|sense
parameter_list|,
name|u_int
name|sense_len
parameter_list|,
name|uint8_t
modifier|*
name|cdb
parameter_list|,
name|int
name|cdb_len
parameter_list|,
name|struct
name|scsi_inquiry_data
modifier|*
name|inq_data
parameter_list|,
name|struct
name|scsi_sense_desc_header
modifier|*
name|header
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|scsi_sense_printers
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|scsi_sense_printers
index|[
literal|0
index|]
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|scsi_sense_desc_printer
modifier|*
name|printer
decl_stmt|;
name|printer
operator|=
operator|&
name|scsi_sense_printers
index|[
name|i
index|]
expr_stmt|;
comment|/* 		 * The list is sorted, so quit if we've passed our 		 * descriptor number. 		 */
if|if
condition|(
name|printer
operator|->
name|desc_type
operator|>
name|header
operator|->
name|desc_type
condition|)
break|break;
if|if
condition|(
name|printer
operator|->
name|desc_type
operator|!=
name|header
operator|->
name|desc_type
condition|)
continue|continue;
name|printer
operator|->
name|print_func
argument_list|(
name|sb
argument_list|,
name|sense
argument_list|,
name|sense_len
argument_list|,
name|cdb
argument_list|,
name|cdb_len
argument_list|,
name|inq_data
argument_list|,
name|header
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * No specific printing routine, so use the generic routine. 	 */
name|scsi_sense_generic_sbuf
argument_list|(
name|sb
argument_list|,
name|sense
argument_list|,
name|sense_len
argument_list|,
name|cdb
argument_list|,
name|cdb_len
argument_list|,
name|inq_data
argument_list|,
name|header
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|scsi_sense_data_type
name|scsi_sense_type
parameter_list|(
name|struct
name|scsi_sense_data
modifier|*
name|sense_data
parameter_list|)
block|{
switch|switch
condition|(
name|sense_data
operator|->
name|error_code
operator|&
name|SSD_ERRCODE
condition|)
block|{
case|case
name|SSD_DESC_CURRENT_ERROR
case|:
case|case
name|SSD_DESC_DEFERRED_ERROR
case|:
return|return
operator|(
name|SSD_TYPE_DESC
operator|)
return|;
break|break;
case|case
name|SSD_CURRENT_ERROR
case|:
case|case
name|SSD_DEFERRED_ERROR
case|:
return|return
operator|(
name|SSD_TYPE_FIXED
operator|)
return|;
break|break;
default|default:
break|break;
block|}
return|return
operator|(
name|SSD_TYPE_NONE
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|scsi_print_sense_info
block|{
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|char
modifier|*
name|path_str
decl_stmt|;
name|uint8_t
modifier|*
name|cdb
decl_stmt|;
name|int
name|cdb_len
decl_stmt|;
name|struct
name|scsi_inquiry_data
modifier|*
name|inq_data
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|scsi_print_desc_func
parameter_list|(
name|struct
name|scsi_sense_data_desc
modifier|*
name|sense
parameter_list|,
name|u_int
name|sense_len
parameter_list|,
name|struct
name|scsi_sense_desc_header
modifier|*
name|header
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|scsi_print_sense_info
modifier|*
name|print_info
decl_stmt|;
name|print_info
operator|=
operator|(
expr|struct
name|scsi_print_sense_info
operator|*
operator|)
name|arg
expr_stmt|;
switch|switch
condition|(
name|header
operator|->
name|desc_type
condition|)
block|{
case|case
name|SSD_DESC_INFO
case|:
case|case
name|SSD_DESC_FRU
case|:
case|case
name|SSD_DESC_COMMAND
case|:
case|case
name|SSD_DESC_SKS
case|:
case|case
name|SSD_DESC_BLOCK
case|:
case|case
name|SSD_DESC_STREAM
case|:
comment|/* 		 * We have already printed these descriptors, if they are 		 * present. 		 */
break|break;
default|default:
block|{
name|sbuf_printf
argument_list|(
name|print_info
operator|->
name|sb
argument_list|,
literal|"%s"
argument_list|,
name|print_info
operator|->
name|path_str
argument_list|)
expr_stmt|;
name|scsi_sense_desc_sbuf
argument_list|(
name|print_info
operator|->
name|sb
argument_list|,
operator|(
expr|struct
name|scsi_sense_data
operator|*
operator|)
name|sense
argument_list|,
name|sense_len
argument_list|,
name|print_info
operator|->
name|cdb
argument_list|,
name|print_info
operator|->
name|cdb_len
argument_list|,
name|print_info
operator|->
name|inq_data
argument_list|,
name|header
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|print_info
operator|->
name|sb
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * Tell the iterator that we want to see more descriptors if they 	 * are present. 	 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|scsi_sense_only_sbuf
parameter_list|(
name|struct
name|scsi_sense_data
modifier|*
name|sense
parameter_list|,
name|u_int
name|sense_len
parameter_list|,
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|char
modifier|*
name|path_str
parameter_list|,
name|struct
name|scsi_inquiry_data
modifier|*
name|inq_data
parameter_list|,
name|uint8_t
modifier|*
name|cdb
parameter_list|,
name|int
name|cdb_len
parameter_list|)
block|{
name|int
name|error_code
decl_stmt|,
name|sense_key
decl_stmt|,
name|asc
decl_stmt|,
name|ascq
decl_stmt|;
name|sbuf_cat
argument_list|(
name|sb
argument_list|,
name|path_str
argument_list|)
expr_stmt|;
name|scsi_extract_sense_len
argument_list|(
name|sense
argument_list|,
name|sense_len
argument_list|,
operator|&
name|error_code
argument_list|,
operator|&
name|sense_key
argument_list|,
operator|&
name|asc
argument_list|,
operator|&
name|ascq
argument_list|,
comment|/*show_errors*/
literal|1
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"SCSI sense: "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|error_code
condition|)
block|{
case|case
name|SSD_DEFERRED_ERROR
case|:
case|case
name|SSD_DESC_DEFERRED_ERROR
case|:
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"Deferred error: "
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|SSD_CURRENT_ERROR
case|:
case|case
name|SSD_DESC_CURRENT_ERROR
case|:
block|{
name|struct
name|scsi_sense_data_desc
modifier|*
name|desc_sense
decl_stmt|;
name|struct
name|scsi_print_sense_info
name|print_info
decl_stmt|;
specifier|const
name|char
modifier|*
name|sense_key_desc
decl_stmt|;
specifier|const
name|char
modifier|*
name|asc_desc
decl_stmt|;
name|uint8_t
name|sks
index|[
literal|3
index|]
decl_stmt|;
name|uint64_t
name|val
decl_stmt|;
name|int
name|info_valid
decl_stmt|;
comment|/* 		 * Get descriptions for the sense key, ASC, and ASCQ.  If 		 * these aren't present in the sense data (i.e. the sense 		 * data isn't long enough), the -1 values that 		 * scsi_extract_sense_len() returns will yield default 		 * or error descriptions. 		 */
name|scsi_sense_desc
argument_list|(
name|sense_key
argument_list|,
name|asc
argument_list|,
name|ascq
argument_list|,
name|inq_data
argument_list|,
operator|&
name|sense_key_desc
argument_list|,
operator|&
name|asc_desc
argument_list|)
expr_stmt|;
comment|/* 		 * We first print the sense key and ASC/ASCQ. 		 */
name|sbuf_cat
argument_list|(
name|sb
argument_list|,
name|sense_key_desc
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" asc:%x,%x (%s)\n"
argument_list|,
name|asc
argument_list|,
name|ascq
argument_list|,
name|asc_desc
argument_list|)
expr_stmt|;
comment|/* 		 * Get the info field if it is valid. 		 */
if|if
condition|(
name|scsi_get_sense_info
argument_list|(
name|sense
argument_list|,
name|sense_len
argument_list|,
name|SSD_DESC_INFO
argument_list|,
operator|&
name|val
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
name|info_valid
operator|=
literal|1
expr_stmt|;
else|else
name|info_valid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|info_valid
operator|!=
literal|0
condition|)
block|{
name|uint8_t
name|bits
decl_stmt|;
comment|/* 			 * Determine whether we have any block or stream 			 * device-specific information. 			 */
if|if
condition|(
name|scsi_get_block_info
argument_list|(
name|sense
argument_list|,
name|sense_len
argument_list|,
name|inq_data
argument_list|,
operator|&
name|bits
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sbuf_cat
argument_list|(
name|sb
argument_list|,
name|path_str
argument_list|)
expr_stmt|;
name|scsi_block_sbuf
argument_list|(
name|sb
argument_list|,
name|bits
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scsi_get_stream_info
argument_list|(
name|sense
argument_list|,
name|sense_len
argument_list|,
name|inq_data
argument_list|,
operator|&
name|bits
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sbuf_cat
argument_list|(
name|sb
argument_list|,
name|path_str
argument_list|)
expr_stmt|;
name|scsi_stream_sbuf
argument_list|(
name|sb
argument_list|,
name|bits
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * The information field can be valid but 0. 				 * If the block or stream bits aren't set, 				 * and this is 0, it isn't terribly useful 				 * to print it out. 				 */
name|sbuf_cat
argument_list|(
name|sb
argument_list|,
name|path_str
argument_list|)
expr_stmt|;
name|scsi_info_sbuf
argument_list|(
name|sb
argument_list|,
name|cdb
argument_list|,
name|cdb_len
argument_list|,
name|inq_data
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  		 * Print the FRU. 		 */
if|if
condition|(
name|scsi_get_sense_info
argument_list|(
name|sense
argument_list|,
name|sense_len
argument_list|,
name|SSD_DESC_FRU
argument_list|,
operator|&
name|val
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sbuf_cat
argument_list|(
name|sb
argument_list|,
name|path_str
argument_list|)
expr_stmt|;
name|scsi_fru_sbuf
argument_list|(
name|sb
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Print any command-specific information. 		 */
if|if
condition|(
name|scsi_get_sense_info
argument_list|(
name|sense
argument_list|,
name|sense_len
argument_list|,
name|SSD_DESC_COMMAND
argument_list|,
operator|&
name|val
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sbuf_cat
argument_list|(
name|sb
argument_list|,
name|path_str
argument_list|)
expr_stmt|;
name|scsi_command_sbuf
argument_list|(
name|sb
argument_list|,
name|cdb
argument_list|,
name|cdb_len
argument_list|,
name|inq_data
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Print out any sense-key-specific information. 		 */
if|if
condition|(
name|scsi_get_sks
argument_list|(
name|sense
argument_list|,
name|sense_len
argument_list|,
name|sks
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sbuf_cat
argument_list|(
name|sb
argument_list|,
name|path_str
argument_list|)
expr_stmt|;
name|scsi_sks_sbuf
argument_list|(
name|sb
argument_list|,
name|sense_key
argument_list|,
name|sks
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If this is fixed sense, we're done.  If we have 		 * descriptor sense, we might have more information 		 * available. 		 */
if|if
condition|(
name|scsi_sense_type
argument_list|(
name|sense
argument_list|)
operator|!=
name|SSD_TYPE_DESC
condition|)
break|break;
name|desc_sense
operator|=
operator|(
expr|struct
name|scsi_sense_data_desc
operator|*
operator|)
name|sense
expr_stmt|;
name|print_info
operator|.
name|sb
operator|=
name|sb
expr_stmt|;
name|print_info
operator|.
name|path_str
operator|=
name|path_str
expr_stmt|;
name|print_info
operator|.
name|cdb
operator|=
name|cdb
expr_stmt|;
name|print_info
operator|.
name|cdb_len
operator|=
name|cdb_len
expr_stmt|;
name|print_info
operator|.
name|inq_data
operator|=
name|inq_data
expr_stmt|;
comment|/* 		 * Print any sense descriptors that we have not already printed. 		 */
name|scsi_desc_iterate
argument_list|(
name|desc_sense
argument_list|,
name|sense_len
argument_list|,
name|scsi_print_desc_func
argument_list|,
operator|&
name|print_info
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
operator|-
literal|1
case|:
comment|/* 		 * scsi_extract_sense_len() sets values to -1 if the 		 * show_errors flag is set and they aren't present in the 		 * sense data.  This means that sense_len is 0. 		 */
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"No sense data present\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"Error code 0x%x"
argument_list|,
name|error_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|sense
operator|->
name|error_code
operator|&
name|SSD_ERRCODE_VALID
condition|)
block|{
name|struct
name|scsi_sense_data_fixed
modifier|*
name|fixed_sense
decl_stmt|;
name|fixed_sense
operator|=
operator|(
expr|struct
name|scsi_sense_data_fixed
operator|*
operator|)
name|sense
expr_stmt|;
if|if
condition|(
name|SSD_FIXED_IS_PRESENT
argument_list|(
name|fixed_sense
argument_list|,
name|sense_len
argument_list|,
name|info
argument_list|)
condition|)
block|{
name|uint32_t
name|info
decl_stmt|;
name|info
operator|=
name|scsi_4btoul
argument_list|(
name|fixed_sense
operator|->
name|info
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" at block no. %d (decimal)"
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * scsi_sense_sbuf() returns 0 for success and -1 for failure.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_decl_stmt
name|int
name|scsi_sense_sbuf
argument_list|(
expr|struct
name|ccb_scsiio
operator|*
name|csio
argument_list|,
expr|struct
name|sbuf
operator|*
name|sb
argument_list|,
name|scsi_sense_string_flags
name|flags
argument_list|)
else|#
directive|else
comment|/* !_KERNEL */
name|int
name|scsi_sense_sbuf
argument_list|(
expr|struct
name|cam_device
operator|*
name|device
argument_list|,
expr|struct
name|ccb_scsiio
operator|*
name|csio
argument_list|,
expr|struct
name|sbuf
operator|*
name|sb
argument_list|,
name|scsi_sense_string_flags
name|flags
argument_list|)
endif|#
directive|endif
comment|/* _KERNEL/!_KERNEL */
block|{
name|struct
name|scsi_sense_data
modifier|*
name|sense
decl_stmt|;
name|struct
name|scsi_inquiry_data
modifier|*
name|inq_data
decl_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
name|struct
name|ccb_getdev
modifier|*
name|cgd
decl_stmt|;
endif|#
directive|endif
comment|/* _KERNEL */
name|char
name|path_str
index|[
literal|64
index|]
decl_stmt|;
name|uint8_t
modifier|*
name|cdb
decl_stmt|;
ifndef|#
directive|ifndef
name|_KERNEL
if|if
condition|(
name|device
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
endif|#
directive|endif
comment|/* !_KERNEL */
if|if
condition|(
operator|(
name|csio
operator|==
name|NULL
operator|)
operator|||
operator|(
name|sb
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * If the CDB is a physical address, we can't deal with it.. 	 */
if|if
condition|(
operator|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_PHYS
operator|)
operator|!=
literal|0
condition|)
name|flags
operator|&=
operator|~
name|SSS_FLAG_PRINT_COMMAND
expr_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
name|xpt_path_string
argument_list|(
name|csio
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|path_str
argument_list|,
sizeof|sizeof
argument_list|(
name|path_str
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !_KERNEL */
name|cam_path_string
argument_list|(
name|device
argument_list|,
name|path_str
argument_list|,
sizeof|sizeof
argument_list|(
name|path_str
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _KERNEL/!_KERNEL */
ifdef|#
directive|ifdef
name|_KERNEL
if|if
condition|(
operator|(
name|cgd
operator|=
operator|(
expr|struct
name|ccb_getdev
operator|*
operator|)
name|xpt_alloc_ccb_nowait
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Get the device information. 	 */
name|xpt_setup_ccb
argument_list|(
operator|&
name|cgd
operator|->
name|ccb_h
argument_list|,
name|csio
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_PRIORITY_NORMAL
argument_list|)
expr_stmt|;
name|cgd
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_GDEV_TYPE
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|cgd
argument_list|)
expr_stmt|;
comment|/* 	 * If the device is unconfigured, just pretend that it is a hard 	 * drive.  scsi_op_desc() needs this. 	 */
if|if
condition|(
name|cgd
operator|->
name|ccb_h
operator|.
name|status
operator|==
name|CAM_DEV_NOT_THERE
condition|)
name|cgd
operator|->
name|inq_data
operator|.
name|device
operator|=
name|T_DIRECT
expr_stmt|;
name|inq_data
operator|=
operator|&
name|cgd
operator|->
name|inq_data
expr_stmt|;
else|#
directive|else
comment|/* !_KERNEL */
name|inq_data
operator|=
operator|&
name|device
operator|->
name|inq_data
expr_stmt|;
endif|#
directive|endif
comment|/* _KERNEL/!_KERNEL */
name|sense
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SSS_FLAG_PRINT_COMMAND
condition|)
block|{
name|sbuf_cat
argument_list|(
name|sb
argument_list|,
name|path_str
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
name|scsi_command_string
argument_list|(
name|csio
argument_list|,
name|sb
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !_KERNEL */
name|scsi_command_string
argument_list|(
name|device
argument_list|,
name|csio
argument_list|,
name|sb
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _KERNEL/!_KERNEL */
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the sense data is a physical pointer, forget it. 	 */
if|if
condition|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SENSE_PTR
condition|)
block|{
if|if
condition|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SENSE_PHYS
condition|)
block|{
ifdef|#
directive|ifdef
name|_KERNEL
name|xpt_free_ccb
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|cgd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _KERNEL/!_KERNEL */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
comment|/*  			 * bcopy the pointer to avoid unaligned access 			 * errors on finicky architectures.  We don't 			 * ensure that the sense data is pointer aligned. 			 */
name|bcopy
argument_list|(
operator|&
name|csio
operator|->
name|sense_data
argument_list|,
operator|&
name|sense
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * If the physical sense flag is set, but the sense pointer 		 * is not also set, we assume that the user is an idiot and 		 * return.  (Well, okay, it could be that somehow, the 		 * entire csio is physical, but we would have probably core 		 * dumped on one of the bogus pointer deferences above 		 * already.) 		 */
if|if
condition|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SENSE_PHYS
condition|)
block|{
ifdef|#
directive|ifdef
name|_KERNEL
name|xpt_free_ccb
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|cgd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _KERNEL/!_KERNEL */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
name|sense
operator|=
operator|&
name|csio
operator|->
name|sense_data
expr_stmt|;
block|}
if|if
condition|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_POINTER
condition|)
name|cdb
operator|=
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_ptr
expr_stmt|;
else|else
name|cdb
operator|=
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|scsi_sense_only_sbuf
argument_list|(
name|sense
argument_list|,
name|csio
operator|->
name|sense_len
operator|-
name|csio
operator|->
name|sense_resid
argument_list|,
name|sb
argument_list|,
name|path_str
argument_list|,
name|inq_data
argument_list|,
name|cdb
argument_list|,
name|csio
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
name|xpt_free_ccb
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|cgd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _KERNEL/!_KERNEL */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|scsi_sense_string
argument_list|(
expr|struct
name|ccb_scsiio
operator|*
name|csio
argument_list|,
name|char
operator|*
name|str
argument_list|,
name|int
name|str_len
argument_list|)
else|#
directive|else
comment|/* !_KERNEL */
name|char
modifier|*
name|scsi_sense_string
argument_list|(
expr|struct
name|cam_device
operator|*
name|device
argument_list|,
expr|struct
name|ccb_scsiio
operator|*
name|csio
argument_list|,
name|char
operator|*
name|str
argument_list|,
name|int
name|str_len
argument_list|)
endif|#
directive|endif
comment|/* _KERNEL/!_KERNEL */
block|{
name|struct
name|sbuf
name|sb
decl_stmt|;
name|sbuf_new
argument_list|(
operator|&
name|sb
argument_list|,
name|str
argument_list|,
name|str_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
name|scsi_sense_sbuf
argument_list|(
name|csio
argument_list|,
operator|&
name|sb
argument_list|,
name|SSS_FLAG_PRINT_COMMAND
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !_KERNEL */
name|scsi_sense_sbuf
argument_list|(
name|device
argument_list|,
name|csio
argument_list|,
operator|&
name|sb
argument_list|,
name|SSS_FLAG_PRINT_COMMAND
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _KERNEL/!_KERNEL */
name|sbuf_finish
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|sbuf_data
argument_list|(
operator|&
name|sb
argument_list|)
operator|)
return|;
block|}
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_function
name|void
name|scsi_sense_print
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|)
block|{
name|struct
name|sbuf
name|sb
decl_stmt|;
name|char
name|str
index|[
literal|512
index|]
decl_stmt|;
name|sbuf_new
argument_list|(
operator|&
name|sb
argument_list|,
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|scsi_sense_sbuf
argument_list|(
name|csio
argument_list|,
operator|&
name|sb
argument_list|,
name|SSS_FLAG_PRINT_COMMAND
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|sbuf_data
argument_list|(
operator|&
name|sb
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !_KERNEL */
end_comment

begin_function
name|void
name|scsi_sense_print
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|FILE
modifier|*
name|ofile
parameter_list|)
block|{
name|struct
name|sbuf
name|sb
decl_stmt|;
name|char
name|str
index|[
literal|512
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|device
operator|==
name|NULL
operator|)
operator|||
operator|(
name|csio
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ofile
operator|==
name|NULL
operator|)
condition|)
return|return;
name|sbuf_new
argument_list|(
operator|&
name|sb
argument_list|,
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|scsi_sense_sbuf
argument_list|(
name|device
argument_list|,
name|csio
argument_list|,
operator|&
name|sb
argument_list|,
name|SSS_FLAG_PRINT_COMMAND
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ofile
argument_list|,
literal|"%s"
argument_list|,
name|sbuf_data
argument_list|(
operator|&
name|sb
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _KERNEL/!_KERNEL */
end_comment

begin_comment
comment|/*  * Extract basic sense information.  This is backward-compatible with the  * previous implementation.  For new implementations,  * scsi_extract_sense_len() is recommended.  */
end_comment

begin_function
name|void
name|scsi_extract_sense
parameter_list|(
name|struct
name|scsi_sense_data
modifier|*
name|sense_data
parameter_list|,
name|int
modifier|*
name|error_code
parameter_list|,
name|int
modifier|*
name|sense_key
parameter_list|,
name|int
modifier|*
name|asc
parameter_list|,
name|int
modifier|*
name|ascq
parameter_list|)
block|{
name|scsi_extract_sense_len
argument_list|(
name|sense_data
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sense_data
argument_list|)
argument_list|,
name|error_code
argument_list|,
name|sense_key
argument_list|,
name|asc
argument_list|,
name|ascq
argument_list|,
comment|/*show_errors*/
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Extract basic sense information from SCSI I/O CCB structure.  */
end_comment

begin_function
name|int
name|scsi_extract_sense_ccb
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|int
modifier|*
name|error_code
parameter_list|,
name|int
modifier|*
name|sense_key
parameter_list|,
name|int
modifier|*
name|asc
parameter_list|,
name|int
modifier|*
name|ascq
parameter_list|)
block|{
name|struct
name|scsi_sense_data
modifier|*
name|sense_data
decl_stmt|;
comment|/* Make sure there are some sense data we can access. */
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|!=
name|XPT_SCSI_IO
operator|||
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_SCSI_STATUS_ERROR
operator|||
operator|(
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
operator|!=
name|SCSI_STATUS_CHECK_COND
operator|)
operator|||
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_AUTOSNS_VALID
operator|)
operator|==
literal|0
operator|||
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SENSE_PHYS
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SENSE_PTR
condition|)
name|bcopy
argument_list|(
operator|&
name|ccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|,
operator|&
name|sense_data
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
operator|*
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sense_data
operator|=
operator|&
name|ccb
operator|->
name|csio
operator|.
name|sense_data
expr_stmt|;
name|scsi_extract_sense_len
argument_list|(
name|sense_data
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|sense_len
operator|-
name|ccb
operator|->
name|csio
operator|.
name|sense_resid
argument_list|,
name|error_code
argument_list|,
name|sense_key
argument_list|,
name|asc
argument_list|,
name|ascq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|error_code
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Extract basic sense information.  If show_errors is set, sense values  * will be set to -1 if they are not present.  */
end_comment

begin_function
name|void
name|scsi_extract_sense_len
parameter_list|(
name|struct
name|scsi_sense_data
modifier|*
name|sense_data
parameter_list|,
name|u_int
name|sense_len
parameter_list|,
name|int
modifier|*
name|error_code
parameter_list|,
name|int
modifier|*
name|sense_key
parameter_list|,
name|int
modifier|*
name|asc
parameter_list|,
name|int
modifier|*
name|ascq
parameter_list|,
name|int
name|show_errors
parameter_list|)
block|{
comment|/* 	 * If we have no length, we have no sense. 	 */
if|if
condition|(
name|sense_len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|show_errors
operator|==
literal|0
condition|)
block|{
operator|*
name|error_code
operator|=
literal|0
expr_stmt|;
operator|*
name|sense_key
operator|=
literal|0
expr_stmt|;
operator|*
name|asc
operator|=
literal|0
expr_stmt|;
operator|*
name|ascq
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|error_code
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|sense_key
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|asc
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|ascq
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return;
block|}
operator|*
name|error_code
operator|=
name|sense_data
operator|->
name|error_code
operator|&
name|SSD_ERRCODE
expr_stmt|;
switch|switch
condition|(
operator|*
name|error_code
condition|)
block|{
case|case
name|SSD_DESC_CURRENT_ERROR
case|:
case|case
name|SSD_DESC_DEFERRED_ERROR
case|:
block|{
name|struct
name|scsi_sense_data_desc
modifier|*
name|sense
decl_stmt|;
name|sense
operator|=
operator|(
expr|struct
name|scsi_sense_data_desc
operator|*
operator|)
name|sense_data
expr_stmt|;
if|if
condition|(
name|SSD_DESC_IS_PRESENT
argument_list|(
name|sense
argument_list|,
name|sense_len
argument_list|,
name|sense_key
argument_list|)
condition|)
operator|*
name|sense_key
operator|=
name|sense
operator|->
name|sense_key
operator|&
name|SSD_KEY
expr_stmt|;
else|else
operator|*
name|sense_key
operator|=
operator|(
name|show_errors
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|SSD_DESC_IS_PRESENT
argument_list|(
name|sense
argument_list|,
name|sense_len
argument_list|,
name|add_sense_code
argument_list|)
condition|)
operator|*
name|asc
operator|=
name|sense
operator|->
name|add_sense_code
expr_stmt|;
else|else
operator|*
name|asc
operator|=
operator|(
name|show_errors
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|SSD_DESC_IS_PRESENT
argument_list|(
name|sense
argument_list|,
name|sense_len
argument_list|,
name|add_sense_code_qual
argument_list|)
condition|)
operator|*
name|ascq
operator|=
name|sense
operator|->
name|add_sense_code_qual
expr_stmt|;
else|else
operator|*
name|ascq
operator|=
operator|(
name|show_errors
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
expr_stmt|;
break|break;
block|}
case|case
name|SSD_CURRENT_ERROR
case|:
case|case
name|SSD_DEFERRED_ERROR
case|:
default|default:
block|{
name|struct
name|scsi_sense_data_fixed
modifier|*
name|sense
decl_stmt|;
name|sense
operator|=
operator|(
expr|struct
name|scsi_sense_data_fixed
operator|*
operator|)
name|sense_data
expr_stmt|;
if|if
condition|(
name|SSD_FIXED_IS_PRESENT
argument_list|(
name|sense
argument_list|,
name|sense_len
argument_list|,
name|flags
argument_list|)
condition|)
operator|*
name|sense_key
operator|=
name|sense
operator|->
name|flags
operator|&
name|SSD_KEY
expr_stmt|;
else|else
operator|*
name|sense_key
operator|=
operator|(
name|show_errors
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|SSD_FIXED_IS_PRESENT
argument_list|(
name|sense
argument_list|,
name|sense_len
argument_list|,
name|add_sense_code
argument_list|)
operator|)
operator|&&
operator|(
name|SSD_FIXED_IS_FILLED
argument_list|(
name|sense
argument_list|,
name|add_sense_code
argument_list|)
operator|)
condition|)
operator|*
name|asc
operator|=
name|sense
operator|->
name|add_sense_code
expr_stmt|;
else|else
operator|*
name|asc
operator|=
operator|(
name|show_errors
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|SSD_FIXED_IS_PRESENT
argument_list|(
name|sense
argument_list|,
name|sense_len
argument_list|,
name|add_sense_code_qual
argument_list|)
operator|)
operator|&&
operator|(
name|SSD_FIXED_IS_FILLED
argument_list|(
name|sense
argument_list|,
name|add_sense_code_qual
argument_list|)
operator|)
condition|)
operator|*
name|ascq
operator|=
name|sense
operator|->
name|add_sense_code_qual
expr_stmt|;
else|else
operator|*
name|ascq
operator|=
operator|(
name|show_errors
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
name|int
name|scsi_get_sense_key
parameter_list|(
name|struct
name|scsi_sense_data
modifier|*
name|sense_data
parameter_list|,
name|u_int
name|sense_len
parameter_list|,
name|int
name|show_errors
parameter_list|)
block|{
name|int
name|error_code
decl_stmt|,
name|sense_key
decl_stmt|,
name|asc
decl_stmt|,
name|ascq
decl_stmt|;
name|scsi_extract_sense_len
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
operator|&
name|error_code
argument_list|,
operator|&
name|sense_key
argument_list|,
operator|&
name|asc
argument_list|,
operator|&
name|ascq
argument_list|,
name|show_errors
argument_list|)
expr_stmt|;
return|return
operator|(
name|sense_key
operator|)
return|;
block|}
end_function

begin_function
name|int
name|scsi_get_asc
parameter_list|(
name|struct
name|scsi_sense_data
modifier|*
name|sense_data
parameter_list|,
name|u_int
name|sense_len
parameter_list|,
name|int
name|show_errors
parameter_list|)
block|{
name|int
name|error_code
decl_stmt|,
name|sense_key
decl_stmt|,
name|asc
decl_stmt|,
name|ascq
decl_stmt|;
name|scsi_extract_sense_len
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
operator|&
name|error_code
argument_list|,
operator|&
name|sense_key
argument_list|,
operator|&
name|asc
argument_list|,
operator|&
name|ascq
argument_list|,
name|show_errors
argument_list|)
expr_stmt|;
return|return
operator|(
name|asc
operator|)
return|;
block|}
end_function

begin_function
name|int
name|scsi_get_ascq
parameter_list|(
name|struct
name|scsi_sense_data
modifier|*
name|sense_data
parameter_list|,
name|u_int
name|sense_len
parameter_list|,
name|int
name|show_errors
parameter_list|)
block|{
name|int
name|error_code
decl_stmt|,
name|sense_key
decl_stmt|,
name|asc
decl_stmt|,
name|ascq
decl_stmt|;
name|scsi_extract_sense_len
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
operator|&
name|error_code
argument_list|,
operator|&
name|sense_key
argument_list|,
operator|&
name|asc
argument_list|,
operator|&
name|ascq
argument_list|,
name|show_errors
argument_list|)
expr_stmt|;
return|return
operator|(
name|ascq
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function currently requires at least 36 bytes, or  * SHORT_INQUIRY_LENGTH, worth of data to function properly.  If this  * function needs more or less data in the future, another length should be  * defined in scsi_all.h to indicate the minimum amount of data necessary  * for this routine to function properly.  */
end_comment

begin_function
name|void
name|scsi_print_inquiry
parameter_list|(
name|struct
name|scsi_inquiry_data
modifier|*
name|inq_data
parameter_list|)
block|{
name|u_int8_t
name|type
decl_stmt|;
name|char
modifier|*
name|dtype
decl_stmt|,
modifier|*
name|qtype
decl_stmt|;
name|char
name|vendor
index|[
literal|16
index|]
decl_stmt|,
name|product
index|[
literal|48
index|]
decl_stmt|,
name|revision
index|[
literal|16
index|]
decl_stmt|,
name|rstr
index|[
literal|4
index|]
decl_stmt|;
name|type
operator|=
name|SID_TYPE
argument_list|(
name|inq_data
argument_list|)
expr_stmt|;
comment|/* 	 * Figure out basic device type and qualifier. 	 */
if|if
condition|(
name|SID_QUAL_IS_VENDOR_UNIQUE
argument_list|(
name|inq_data
argument_list|)
condition|)
block|{
name|qtype
operator|=
literal|"(vendor-unique qualifier)"
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|SID_QUAL
argument_list|(
name|inq_data
argument_list|)
condition|)
block|{
case|case
name|SID_QUAL_LU_CONNECTED
case|:
name|qtype
operator|=
literal|""
expr_stmt|;
break|break;
case|case
name|SID_QUAL_LU_OFFLINE
case|:
name|qtype
operator|=
literal|"(offline)"
expr_stmt|;
break|break;
case|case
name|SID_QUAL_RSVD
case|:
name|qtype
operator|=
literal|"(reserved qualifier)"
expr_stmt|;
break|break;
default|default:
case|case
name|SID_QUAL_BAD_LU
case|:
name|qtype
operator|=
literal|"(LUN not supported)"
expr_stmt|;
break|break;
block|}
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_DIRECT
case|:
name|dtype
operator|=
literal|"Direct Access"
expr_stmt|;
break|break;
case|case
name|T_SEQUENTIAL
case|:
name|dtype
operator|=
literal|"Sequential Access"
expr_stmt|;
break|break;
case|case
name|T_PRINTER
case|:
name|dtype
operator|=
literal|"Printer"
expr_stmt|;
break|break;
case|case
name|T_PROCESSOR
case|:
name|dtype
operator|=
literal|"Processor"
expr_stmt|;
break|break;
case|case
name|T_WORM
case|:
name|dtype
operator|=
literal|"WORM"
expr_stmt|;
break|break;
case|case
name|T_CDROM
case|:
name|dtype
operator|=
literal|"CD-ROM"
expr_stmt|;
break|break;
case|case
name|T_SCANNER
case|:
name|dtype
operator|=
literal|"Scanner"
expr_stmt|;
break|break;
case|case
name|T_OPTICAL
case|:
name|dtype
operator|=
literal|"Optical"
expr_stmt|;
break|break;
case|case
name|T_CHANGER
case|:
name|dtype
operator|=
literal|"Changer"
expr_stmt|;
break|break;
case|case
name|T_COMM
case|:
name|dtype
operator|=
literal|"Communication"
expr_stmt|;
break|break;
case|case
name|T_STORARRAY
case|:
name|dtype
operator|=
literal|"Storage Array"
expr_stmt|;
break|break;
case|case
name|T_ENCLOSURE
case|:
name|dtype
operator|=
literal|"Enclosure Services"
expr_stmt|;
break|break;
case|case
name|T_RBC
case|:
name|dtype
operator|=
literal|"Simplified Direct Access"
expr_stmt|;
break|break;
case|case
name|T_OCRW
case|:
name|dtype
operator|=
literal|"Optical Card Read/Write"
expr_stmt|;
break|break;
case|case
name|T_OSD
case|:
name|dtype
operator|=
literal|"Object-Based Storage"
expr_stmt|;
break|break;
case|case
name|T_ADC
case|:
name|dtype
operator|=
literal|"Automation/Drive Interface"
expr_stmt|;
break|break;
case|case
name|T_NODEVICE
case|:
name|dtype
operator|=
literal|"Uninstalled"
expr_stmt|;
break|break;
default|default:
name|dtype
operator|=
literal|"unknown"
expr_stmt|;
break|break;
block|}
name|cam_strvis
argument_list|(
name|vendor
argument_list|,
name|inq_data
operator|->
name|vendor
argument_list|,
sizeof|sizeof
argument_list|(
name|inq_data
operator|->
name|vendor
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|vendor
argument_list|)
argument_list|)
expr_stmt|;
name|cam_strvis
argument_list|(
name|product
argument_list|,
name|inq_data
operator|->
name|product
argument_list|,
sizeof|sizeof
argument_list|(
name|inq_data
operator|->
name|product
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|product
argument_list|)
argument_list|)
expr_stmt|;
name|cam_strvis
argument_list|(
name|revision
argument_list|,
name|inq_data
operator|->
name|revision
argument_list|,
sizeof|sizeof
argument_list|(
name|inq_data
operator|->
name|revision
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|revision
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SID_ANSI_REV
argument_list|(
name|inq_data
argument_list|)
operator|==
name|SCSI_REV_CCS
condition|)
name|bcopy
argument_list|(
literal|"CCS"
argument_list|,
name|rstr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|rstr
argument_list|,
sizeof|sizeof
argument_list|(
name|rstr
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|SID_ANSI_REV
argument_list|(
name|inq_data
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"<%s %s %s> %s %s SCSI-%s device %s\n"
argument_list|,
name|vendor
argument_list|,
name|product
argument_list|,
name|revision
argument_list|,
name|SID_IS_REMOVABLE
argument_list|(
name|inq_data
argument_list|)
condition|?
literal|"Removable"
else|:
literal|"Fixed"
argument_list|,
name|dtype
argument_list|,
name|rstr
argument_list|,
name|qtype
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_print_inquiry_short
parameter_list|(
name|struct
name|scsi_inquiry_data
modifier|*
name|inq_data
parameter_list|)
block|{
name|char
name|vendor
index|[
literal|16
index|]
decl_stmt|,
name|product
index|[
literal|48
index|]
decl_stmt|,
name|revision
index|[
literal|16
index|]
decl_stmt|;
name|cam_strvis
argument_list|(
name|vendor
argument_list|,
name|inq_data
operator|->
name|vendor
argument_list|,
sizeof|sizeof
argument_list|(
name|inq_data
operator|->
name|vendor
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|vendor
argument_list|)
argument_list|)
expr_stmt|;
name|cam_strvis
argument_list|(
name|product
argument_list|,
name|inq_data
operator|->
name|product
argument_list|,
sizeof|sizeof
argument_list|(
name|inq_data
operator|->
name|product
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|product
argument_list|)
argument_list|)
expr_stmt|;
name|cam_strvis
argument_list|(
name|revision
argument_list|,
name|inq_data
operator|->
name|revision
argument_list|,
sizeof|sizeof
argument_list|(
name|inq_data
operator|->
name|revision
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|revision
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"<%s %s %s>"
argument_list|,
name|vendor
argument_list|,
name|product
argument_list|,
name|revision
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Table of syncrates that don't follow the "divisible by 4"  * rule. This table will be expanded in future SCSI specs.  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|u_int
name|period_factor
decl_stmt|;
name|u_int
name|period
decl_stmt|;
comment|/* in 100ths of ns */
block|}
name|scsi_syncrates
index|[]
init|=
block|{
block|{
literal|0x08
block|,
literal|625
block|}
block|,
comment|/* FAST-160 */
block|{
literal|0x09
block|,
literal|1250
block|}
block|,
comment|/* FAST-80 */
block|{
literal|0x0a
block|,
literal|2500
block|}
block|,
comment|/* FAST-40 40MHz */
block|{
literal|0x0b
block|,
literal|3030
block|}
block|,
comment|/* FAST-40 33MHz */
block|{
literal|0x0c
block|,
literal|5000
block|}
comment|/* FAST-20 */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Return the frequency in kHz corresponding to the given  * sync period factor.  */
end_comment

begin_function
name|u_int
name|scsi_calc_syncsrate
parameter_list|(
name|u_int
name|period_factor
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|num_syncrates
decl_stmt|;
comment|/* 	 * It's a bug if period is zero, but if it is anyway, don't 	 * die with a divide fault- instead return something which 	 * 'approximates' async 	 */
if|if
condition|(
name|period_factor
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|3300
operator|)
return|;
block|}
name|num_syncrates
operator|=
sizeof|sizeof
argument_list|(
name|scsi_syncrates
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|scsi_syncrates
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* See if the period is in the "exception" table */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_syncrates
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|period_factor
operator|==
name|scsi_syncrates
index|[
name|i
index|]
operator|.
name|period_factor
condition|)
block|{
comment|/* Period in kHz */
return|return
operator|(
literal|100000000
operator|/
name|scsi_syncrates
index|[
name|i
index|]
operator|.
name|period
operator|)
return|;
block|}
block|}
comment|/* 	 * Wasn't in the table, so use the standard 	 * 4 times conversion. 	 */
return|return
operator|(
literal|10000000
operator|/
operator|(
name|period_factor
operator|*
literal|4
operator|*
literal|10
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the SCSI sync parameter that corresponsd to  * the passed in period in 10ths of ns.  */
end_comment

begin_function
name|u_int
name|scsi_calc_syncparam
parameter_list|(
name|u_int
name|period
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|num_syncrates
decl_stmt|;
if|if
condition|(
name|period
operator|==
literal|0
condition|)
return|return
operator|(
operator|~
literal|0
operator|)
return|;
comment|/* Async */
comment|/* Adjust for exception table being in 100ths. */
name|period
operator|*=
literal|10
expr_stmt|;
name|num_syncrates
operator|=
sizeof|sizeof
argument_list|(
name|scsi_syncrates
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|scsi_syncrates
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* See if the period is in the "exception" table */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_syncrates
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|period
operator|<=
name|scsi_syncrates
index|[
name|i
index|]
operator|.
name|period
condition|)
block|{
comment|/* Period in 100ths of ns */
return|return
operator|(
name|scsi_syncrates
index|[
name|i
index|]
operator|.
name|period_factor
operator|)
return|;
block|}
block|}
comment|/* 	 * Wasn't in the table, so use the standard 	 * 1/4 period in ns conversion. 	 */
return|return
operator|(
name|period
operator|/
literal|400
operator|)
return|;
block|}
end_function

begin_function
name|int
name|scsi_devid_is_naa_ieee_reg
parameter_list|(
name|uint8_t
modifier|*
name|bufp
parameter_list|)
block|{
name|struct
name|scsi_vpd_id_descriptor
modifier|*
name|descr
decl_stmt|;
name|struct
name|scsi_vpd_id_naa_basic
modifier|*
name|naa
decl_stmt|;
name|descr
operator|=
operator|(
expr|struct
name|scsi_vpd_id_descriptor
operator|*
operator|)
name|bufp
expr_stmt|;
name|naa
operator|=
operator|(
expr|struct
name|scsi_vpd_id_naa_basic
operator|*
operator|)
name|descr
operator|->
name|identifier
expr_stmt|;
if|if
condition|(
operator|(
name|descr
operator|->
name|id_type
operator|&
name|SVPD_ID_TYPE_MASK
operator|)
operator|!=
name|SVPD_ID_TYPE_NAA
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|descr
operator|->
name|length
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_id_naa_ieee_reg
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|naa
operator|->
name|naa
operator|>>
name|SVPD_ID_NAA_NAA_SHIFT
operator|)
operator|!=
name|SVPD_ID_NAA_IEEE_REG
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|scsi_devid_is_sas_target
parameter_list|(
name|uint8_t
modifier|*
name|bufp
parameter_list|)
block|{
name|struct
name|scsi_vpd_id_descriptor
modifier|*
name|descr
decl_stmt|;
name|descr
operator|=
operator|(
expr|struct
name|scsi_vpd_id_descriptor
operator|*
operator|)
name|bufp
expr_stmt|;
if|if
condition|(
operator|!
name|scsi_devid_is_naa_ieee_reg
argument_list|(
name|bufp
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|descr
operator|->
name|id_type
operator|&
name|SVPD_ID_PIV
operator|)
operator|==
literal|0
condition|)
comment|/* proto field reserved */
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|descr
operator|->
name|proto_codeset
operator|>>
name|SVPD_ID_PROTO_SHIFT
operator|)
operator|!=
name|SCSI_PROTO_SAS
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|scsi_devid_is_lun_eui64
parameter_list|(
name|uint8_t
modifier|*
name|bufp
parameter_list|)
block|{
name|struct
name|scsi_vpd_id_descriptor
modifier|*
name|descr
decl_stmt|;
name|descr
operator|=
operator|(
expr|struct
name|scsi_vpd_id_descriptor
operator|*
operator|)
name|bufp
expr_stmt|;
if|if
condition|(
operator|(
name|descr
operator|->
name|id_type
operator|&
name|SVPD_ID_ASSOC_MASK
operator|)
operator|!=
name|SVPD_ID_ASSOC_LUN
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|descr
operator|->
name|id_type
operator|&
name|SVPD_ID_TYPE_MASK
operator|)
operator|!=
name|SVPD_ID_TYPE_EUI64
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|scsi_devid_is_lun_naa
parameter_list|(
name|uint8_t
modifier|*
name|bufp
parameter_list|)
block|{
name|struct
name|scsi_vpd_id_descriptor
modifier|*
name|descr
decl_stmt|;
name|descr
operator|=
operator|(
expr|struct
name|scsi_vpd_id_descriptor
operator|*
operator|)
name|bufp
expr_stmt|;
if|if
condition|(
operator|(
name|descr
operator|->
name|id_type
operator|&
name|SVPD_ID_ASSOC_MASK
operator|)
operator|!=
name|SVPD_ID_ASSOC_LUN
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|descr
operator|->
name|id_type
operator|&
name|SVPD_ID_TYPE_MASK
operator|)
operator|!=
name|SVPD_ID_TYPE_NAA
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|scsi_devid_is_lun_t10
parameter_list|(
name|uint8_t
modifier|*
name|bufp
parameter_list|)
block|{
name|struct
name|scsi_vpd_id_descriptor
modifier|*
name|descr
decl_stmt|;
name|descr
operator|=
operator|(
expr|struct
name|scsi_vpd_id_descriptor
operator|*
operator|)
name|bufp
expr_stmt|;
if|if
condition|(
operator|(
name|descr
operator|->
name|id_type
operator|&
name|SVPD_ID_ASSOC_MASK
operator|)
operator|!=
name|SVPD_ID_ASSOC_LUN
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|descr
operator|->
name|id_type
operator|&
name|SVPD_ID_TYPE_MASK
operator|)
operator|!=
name|SVPD_ID_TYPE_T10
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|scsi_devid_is_lun_name
parameter_list|(
name|uint8_t
modifier|*
name|bufp
parameter_list|)
block|{
name|struct
name|scsi_vpd_id_descriptor
modifier|*
name|descr
decl_stmt|;
name|descr
operator|=
operator|(
expr|struct
name|scsi_vpd_id_descriptor
operator|*
operator|)
name|bufp
expr_stmt|;
if|if
condition|(
operator|(
name|descr
operator|->
name|id_type
operator|&
name|SVPD_ID_ASSOC_MASK
operator|)
operator|!=
name|SVPD_ID_ASSOC_LUN
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|descr
operator|->
name|id_type
operator|&
name|SVPD_ID_TYPE_MASK
operator|)
operator|!=
name|SVPD_ID_TYPE_SCSI_NAME
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|struct
name|scsi_vpd_id_descriptor
modifier|*
name|scsi_get_devid
parameter_list|(
name|struct
name|scsi_vpd_device_id
modifier|*
name|id
parameter_list|,
name|uint32_t
name|page_len
parameter_list|,
name|scsi_devid_checkfn_t
name|ck_fn
parameter_list|)
block|{
name|struct
name|scsi_vpd_id_descriptor
modifier|*
name|desc
decl_stmt|;
name|uint8_t
modifier|*
name|page_end
decl_stmt|;
name|uint8_t
modifier|*
name|desc_buf_end
decl_stmt|;
name|page_end
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|id
operator|+
name|page_len
expr_stmt|;
if|if
condition|(
name|page_end
operator|<
name|id
operator|->
name|desc_list
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|desc_buf_end
operator|=
name|MIN
argument_list|(
name|id
operator|->
name|desc_list
operator|+
name|scsi_2btoul
argument_list|(
name|id
operator|->
name|length
argument_list|)
argument_list|,
name|page_end
argument_list|)
expr_stmt|;
for|for
control|(
name|desc
operator|=
operator|(
expr|struct
name|scsi_vpd_id_descriptor
operator|*
operator|)
name|id
operator|->
name|desc_list
init|;
name|desc
operator|->
name|identifier
operator|<=
name|desc_buf_end
operator|&&
name|desc
operator|->
name|identifier
operator|+
name|desc
operator|->
name|length
operator|<=
name|desc_buf_end
condition|;
name|desc
operator|=
operator|(
expr|struct
name|scsi_vpd_id_descriptor
operator|*
operator|)
operator|(
name|desc
operator|->
name|identifier
operator|+
name|desc
operator|->
name|length
operator|)
control|)
block|{
if|if
condition|(
name|ck_fn
operator|==
name|NULL
operator|||
name|ck_fn
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|desc
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|desc
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|scsi_transportid_sbuf
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|struct
name|scsi_transportid_header
modifier|*
name|hdr
parameter_list|,
name|uint32_t
name|valid_len
parameter_list|)
block|{
switch|switch
condition|(
name|hdr
operator|->
name|format_protocol
operator|&
name|SCSI_TRN_PROTO_MASK
condition|)
block|{
case|case
name|SCSI_PROTO_FC
case|:
block|{
name|struct
name|scsi_transportid_fcp
modifier|*
name|fcp
decl_stmt|;
name|uint64_t
name|n_port_name
decl_stmt|;
name|fcp
operator|=
operator|(
expr|struct
name|scsi_transportid_fcp
operator|*
operator|)
name|hdr
expr_stmt|;
name|n_port_name
operator|=
name|scsi_8btou64
argument_list|(
name|fcp
operator|->
name|n_port_name
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"FCP address: 0x%.16jx"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|n_port_name
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SCSI_PROTO_SPI
case|:
block|{
name|struct
name|scsi_transportid_spi
modifier|*
name|spi
decl_stmt|;
name|spi
operator|=
operator|(
expr|struct
name|scsi_transportid_spi
operator|*
operator|)
name|hdr
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"SPI address: %u,%u"
argument_list|,
name|scsi_2btoul
argument_list|(
name|spi
operator|->
name|scsi_addr
argument_list|)
argument_list|,
name|scsi_2btoul
argument_list|(
name|spi
operator|->
name|rel_trgt_port_id
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SCSI_PROTO_SSA
case|:
comment|/* 		 * XXX KDM there is no transport ID defined in SPC-4 for 		 * SSA. 		 */
break|break;
case|case
name|SCSI_PROTO_1394
case|:
block|{
name|struct
name|scsi_transportid_1394
modifier|*
name|sbp
decl_stmt|;
name|uint64_t
name|eui64
decl_stmt|;
name|sbp
operator|=
operator|(
expr|struct
name|scsi_transportid_1394
operator|*
operator|)
name|hdr
expr_stmt|;
name|eui64
operator|=
name|scsi_8btou64
argument_list|(
name|sbp
operator|->
name|eui64
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"SBP address: 0x%.16jx"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|eui64
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SCSI_PROTO_RDMA
case|:
block|{
name|struct
name|scsi_transportid_rdma
modifier|*
name|rdma
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|rdma
operator|=
operator|(
expr|struct
name|scsi_transportid_rdma
operator|*
operator|)
name|hdr
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"RDMA address: 0x"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|rdma
operator|->
name|initiator_port_id
argument_list|)
condition|;
name|i
operator|++
control|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%02x"
argument_list|,
name|rdma
operator|->
name|initiator_port_id
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SCSI_PROTO_ISCSI
case|:
block|{
name|uint32_t
name|add_len
decl_stmt|,
name|i
decl_stmt|;
name|uint8_t
modifier|*
name|iscsi_name
init|=
name|NULL
decl_stmt|;
name|int
name|nul_found
init|=
literal|0
decl_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"iSCSI address: "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hdr
operator|->
name|format_protocol
operator|&
name|SCSI_TRN_FORMAT_MASK
operator|)
operator|==
name|SCSI_TRN_ISCSI_FORMAT_DEVICE
condition|)
block|{
name|struct
name|scsi_transportid_iscsi_device
modifier|*
name|dev
decl_stmt|;
name|dev
operator|=
operator|(
expr|struct
name|scsi_transportid_iscsi_device
operator|*
operator|)
name|hdr
expr_stmt|;
comment|/* 			 * Verify how much additional data we really have. 			 */
name|add_len
operator|=
name|scsi_2btoul
argument_list|(
name|dev
operator|->
name|additional_length
argument_list|)
expr_stmt|;
name|add_len
operator|=
name|MIN
argument_list|(
name|add_len
argument_list|,
name|valid_len
operator|-
name|__offsetof
argument_list|(
expr|struct
name|scsi_transportid_iscsi_device
argument_list|,
name|iscsi_name
argument_list|)
argument_list|)
expr_stmt|;
name|iscsi_name
operator|=
operator|&
name|dev
operator|->
name|iscsi_name
index|[
literal|0
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|hdr
operator|->
name|format_protocol
operator|&
name|SCSI_TRN_FORMAT_MASK
operator|)
operator|==
name|SCSI_TRN_ISCSI_FORMAT_PORT
condition|)
block|{
name|struct
name|scsi_transportid_iscsi_port
modifier|*
name|port
decl_stmt|;
name|port
operator|=
operator|(
expr|struct
name|scsi_transportid_iscsi_port
operator|*
operator|)
name|hdr
expr_stmt|;
name|add_len
operator|=
name|scsi_2btoul
argument_list|(
name|port
operator|->
name|additional_length
argument_list|)
expr_stmt|;
name|add_len
operator|=
name|MIN
argument_list|(
name|add_len
argument_list|,
name|valid_len
operator|-
name|__offsetof
argument_list|(
expr|struct
name|scsi_transportid_iscsi_port
argument_list|,
name|iscsi_name
argument_list|)
argument_list|)
expr_stmt|;
name|iscsi_name
operator|=
operator|&
name|port
operator|->
name|iscsi_name
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"unknown format %x"
argument_list|,
operator|(
name|hdr
operator|->
name|format_protocol
operator|&
name|SCSI_TRN_FORMAT_MASK
operator|)
operator|>>
name|SCSI_TRN_FORMAT_SHIFT
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|add_len
operator|==
literal|0
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"not enough data"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * This is supposed to be a NUL-terminated ASCII  		 * string, but you never know.  So we're going to 		 * check.  We need to do this because there is no 		 * sbuf equivalent of strncat(). 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|add_len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|iscsi_name
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
block|{
name|nul_found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* 		 * If there is a NUL in the name, we can just use 		 * sbuf_cat().  Otherwise we need to use sbuf_bcat(). 		 */
if|if
condition|(
name|nul_found
operator|!=
literal|0
condition|)
name|sbuf_cat
argument_list|(
name|sb
argument_list|,
name|iscsi_name
argument_list|)
expr_stmt|;
else|else
name|sbuf_bcat
argument_list|(
name|sb
argument_list|,
name|iscsi_name
argument_list|,
name|add_len
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SCSI_PROTO_SAS
case|:
block|{
name|struct
name|scsi_transportid_sas
modifier|*
name|sas
decl_stmt|;
name|uint64_t
name|sas_addr
decl_stmt|;
name|sas
operator|=
operator|(
expr|struct
name|scsi_transportid_sas
operator|*
operator|)
name|hdr
expr_stmt|;
name|sas_addr
operator|=
name|scsi_8btou64
argument_list|(
name|sas
operator|->
name|sas_address
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"SAS address: 0x%.16jx"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sas_addr
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SCSI_PROTO_ADITP
case|:
case|case
name|SCSI_PROTO_ATA
case|:
case|case
name|SCSI_PROTO_UAS
case|:
comment|/* 		 * No Transport ID format for ADI, ATA or USB is defined in 		 * SPC-4. 		 */
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"No known Transport ID format for protocol "
literal|"%#x"
argument_list|,
name|hdr
operator|->
name|format_protocol
operator|&
name|SCSI_TRN_PROTO_MASK
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCSI_PROTO_SOP
case|:
block|{
name|struct
name|scsi_transportid_sop
modifier|*
name|sop
decl_stmt|;
name|struct
name|scsi_sop_routing_id_norm
modifier|*
name|rid
decl_stmt|;
name|sop
operator|=
operator|(
expr|struct
name|scsi_transportid_sop
operator|*
operator|)
name|hdr
expr_stmt|;
name|rid
operator|=
operator|(
expr|struct
name|scsi_sop_routing_id_norm
operator|*
operator|)
name|sop
operator|->
name|routing_id
expr_stmt|;
comment|/* 		 * Note that there is no alternate format specified in SPC-4 		 * for the PCIe routing ID, so we don't really have a way 		 * to know whether the second byte of the routing ID is 		 * a device and function or just a function.  So we just 		 * assume bus,device,function. 		 */
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"SOP Routing ID: %u,%u,%u"
argument_list|,
name|rid
operator|->
name|bus
argument_list|,
name|rid
operator|->
name|devfunc
operator|>>
name|SCSI_TRN_SOP_DEV_SHIFT
argument_list|,
name|rid
operator|->
name|devfunc
operator|&
name|SCSI_TRN_SOP_FUNC_NORM_MAX
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SCSI_PROTO_NONE
case|:
default|default:
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"Unknown protocol %#x"
argument_list|,
name|hdr
operator|->
name|format_protocol
operator|&
name|SCSI_TRN_PROTO_MASK
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|scsi_nv
name|scsi_proto_map
index|[]
init|=
block|{
block|{
literal|"fcp"
block|,
name|SCSI_PROTO_FC
block|}
block|,
block|{
literal|"spi"
block|,
name|SCSI_PROTO_SPI
block|}
block|,
block|{
literal|"ssa"
block|,
name|SCSI_PROTO_SSA
block|}
block|,
block|{
literal|"sbp"
block|,
name|SCSI_PROTO_1394
block|}
block|,
block|{
literal|"1394"
block|,
name|SCSI_PROTO_1394
block|}
block|,
block|{
literal|"srp"
block|,
name|SCSI_PROTO_RDMA
block|}
block|,
block|{
literal|"rdma"
block|,
name|SCSI_PROTO_RDMA
block|}
block|,
block|{
literal|"iscsi"
block|,
name|SCSI_PROTO_ISCSI
block|}
block|,
block|{
literal|"iqn"
block|,
name|SCSI_PROTO_ISCSI
block|}
block|,
block|{
literal|"sas"
block|,
name|SCSI_PROTO_SAS
block|}
block|,
block|{
literal|"aditp"
block|,
name|SCSI_PROTO_ADITP
block|}
block|,
block|{
literal|"ata"
block|,
name|SCSI_PROTO_ATA
block|}
block|,
block|{
literal|"uas"
block|,
name|SCSI_PROTO_UAS
block|}
block|,
block|{
literal|"usb"
block|,
name|SCSI_PROTO_UAS
block|}
block|,
block|{
literal|"sop"
block|,
name|SCSI_PROTO_SOP
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|const
name|char
modifier|*
name|scsi_nv_to_str
parameter_list|(
name|struct
name|scsi_nv
modifier|*
name|table
parameter_list|,
name|int
name|num_table_entries
parameter_list|,
name|uint64_t
name|value
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_table_entries
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|table
index|[
name|i
index|]
operator|.
name|value
operator|==
name|value
condition|)
return|return
operator|(
name|table
index|[
name|i
index|]
operator|.
name|name
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a name/value table, find a value matching the given name.  * Return values:  *	SCSI_NV_FOUND - match found  *	SCSI_NV_AMBIGUOUS - more than one match, none of them exact  *	SCSI_NV_NOT_FOUND - no match found  */
end_comment

begin_function
name|scsi_nv_status
name|scsi_get_nv
parameter_list|(
name|struct
name|scsi_nv
modifier|*
name|table
parameter_list|,
name|int
name|num_table_entries
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
modifier|*
name|table_entry
parameter_list|,
name|scsi_nv_flags
name|flags
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|num_matches
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_table_entries
condition|;
name|i
operator|++
control|)
block|{
name|size_t
name|table_len
decl_stmt|,
name|name_len
decl_stmt|;
name|table_len
operator|=
name|strlen
argument_list|(
name|table
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|name_len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|(
name|flags
operator|&
name|SCSI_NV_FLAG_IG_CASE
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|strncasecmp
argument_list|(
name|table
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|,
name|name_len
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
operator|(
operator|(
name|flags
operator|&
name|SCSI_NV_FLAG_IG_CASE
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|table
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|,
name|name_len
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
operator|*
name|table_entry
operator|=
name|i
expr_stmt|;
comment|/* 			 * Check for an exact match.  If we have the same 			 * number of characters in the table as the argument, 			 * and we already know they're the same, we have 			 * an exact match. 		 	 */
if|if
condition|(
name|table_len
operator|==
name|name_len
condition|)
return|return
operator|(
name|SCSI_NV_FOUND
operator|)
return|;
comment|/* 			 * Otherwise, bump up the number of matches.  We'll 			 * see later how many we have. 			 */
name|num_matches
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|num_matches
operator|>
literal|1
condition|)
return|return
operator|(
name|SCSI_NV_AMBIGUOUS
operator|)
return|;
elseif|else
if|if
condition|(
name|num_matches
operator|==
literal|1
condition|)
return|return
operator|(
name|SCSI_NV_FOUND
operator|)
return|;
else|else
return|return
operator|(
name|SCSI_NV_NOT_FOUND
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse transport IDs for Fibre Channel, 1394 and SAS.  Since these are  * all 64-bit numbers, the code is similar.  */
end_comment

begin_function
name|int
name|scsi_parse_transportid_64bit
parameter_list|(
name|int
name|proto_id
parameter_list|,
name|char
modifier|*
name|id_str
parameter_list|,
name|struct
name|scsi_transportid_header
modifier|*
modifier|*
name|hdr
parameter_list|,
name|unsigned
name|int
modifier|*
name|alloc_len
parameter_list|,
ifdef|#
directive|ifdef
name|_KERNEL
name|struct
name|malloc_type
modifier|*
name|type
parameter_list|,
name|int
name|flags
parameter_list|,
endif|#
directive|endif
name|char
modifier|*
name|error_str
parameter_list|,
name|int
name|error_str_len
parameter_list|)
block|{
name|uint64_t
name|value
decl_stmt|;
name|char
modifier|*
name|endptr
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|size_t
name|alloc_size
decl_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|value
operator|=
name|strtouq
argument_list|(
name|id_str
argument_list|,
operator|&
name|endptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|endptr
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|error_str
operator|!=
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|error_str
argument_list|,
name|error_str_len
argument_list|,
literal|"%s: error "
literal|"parsing ID %s, 64-bit number required"
argument_list|,
name|__func__
argument_list|,
name|id_str
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
switch|switch
condition|(
name|proto_id
condition|)
block|{
case|case
name|SCSI_PROTO_FC
case|:
name|alloc_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_transportid_fcp
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCSI_PROTO_1394
case|:
name|alloc_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_transportid_1394
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCSI_PROTO_SAS
case|:
name|alloc_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_transportid_sas
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|error_str
operator|!=
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|error_str
argument_list|,
name|error_str_len
argument_list|,
literal|"%s: unsupoprted "
literal|"protocol %d"
argument_list|,
name|__func__
argument_list|,
name|proto_id
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
break|break;
comment|/* NOTREACHED */
block|}
ifdef|#
directive|ifdef
name|_KERNEL
operator|*
name|hdr
operator|=
name|malloc
argument_list|(
name|alloc_size
argument_list|,
name|type
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* _KERNEL */
operator|*
name|hdr
operator|=
name|malloc
argument_list|(
name|alloc_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*_KERNEL */
if|if
condition|(
operator|*
name|hdr
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|error_str
operator|!=
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|error_str
argument_list|,
name|error_str_len
argument_list|,
literal|"%s: unable to "
literal|"allocate %zu bytes"
argument_list|,
name|__func__
argument_list|,
name|alloc_size
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
operator|*
name|alloc_len
operator|=
name|alloc_size
expr_stmt|;
name|bzero
argument_list|(
operator|*
name|hdr
argument_list|,
name|alloc_size
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|proto_id
condition|)
block|{
case|case
name|SCSI_PROTO_FC
case|:
block|{
name|struct
name|scsi_transportid_fcp
modifier|*
name|fcp
decl_stmt|;
name|fcp
operator|=
operator|(
expr|struct
name|scsi_transportid_fcp
operator|*
operator|)
operator|(
operator|*
name|hdr
operator|)
expr_stmt|;
name|fcp
operator|->
name|format_protocol
operator|=
name|SCSI_PROTO_FC
operator||
name|SCSI_TRN_FCP_FORMAT_DEFAULT
expr_stmt|;
name|scsi_u64to8b
argument_list|(
name|value
argument_list|,
name|fcp
operator|->
name|n_port_name
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SCSI_PROTO_1394
case|:
block|{
name|struct
name|scsi_transportid_1394
modifier|*
name|sbp
decl_stmt|;
name|sbp
operator|=
operator|(
expr|struct
name|scsi_transportid_1394
operator|*
operator|)
operator|(
operator|*
name|hdr
operator|)
expr_stmt|;
name|sbp
operator|->
name|format_protocol
operator|=
name|SCSI_PROTO_1394
operator||
name|SCSI_TRN_1394_FORMAT_DEFAULT
expr_stmt|;
name|scsi_u64to8b
argument_list|(
name|value
argument_list|,
name|sbp
operator|->
name|eui64
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SCSI_PROTO_SAS
case|:
block|{
name|struct
name|scsi_transportid_sas
modifier|*
name|sas
decl_stmt|;
name|sas
operator|=
operator|(
expr|struct
name|scsi_transportid_sas
operator|*
operator|)
operator|(
operator|*
name|hdr
operator|)
expr_stmt|;
name|sas
operator|->
name|format_protocol
operator|=
name|SCSI_PROTO_SAS
operator||
name|SCSI_TRN_SAS_FORMAT_DEFAULT
expr_stmt|;
name|scsi_u64to8b
argument_list|(
name|value
argument_list|,
name|sas
operator|->
name|sas_address
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
name|bailout
label|:
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse a SPI (Parallel SCSI) address of the form: id,rel_tgt_port  */
end_comment

begin_function
name|int
name|scsi_parse_transportid_spi
parameter_list|(
name|char
modifier|*
name|id_str
parameter_list|,
name|struct
name|scsi_transportid_header
modifier|*
modifier|*
name|hdr
parameter_list|,
name|unsigned
name|int
modifier|*
name|alloc_len
parameter_list|,
ifdef|#
directive|ifdef
name|_KERNEL
name|struct
name|malloc_type
modifier|*
name|type
parameter_list|,
name|int
name|flags
parameter_list|,
endif|#
directive|endif
name|char
modifier|*
name|error_str
parameter_list|,
name|int
name|error_str_len
parameter_list|)
block|{
name|unsigned
name|long
name|scsi_addr
decl_stmt|,
name|target_port
decl_stmt|;
name|struct
name|scsi_transportid_spi
modifier|*
name|spi
decl_stmt|;
name|char
modifier|*
name|tmpstr
decl_stmt|,
modifier|*
name|endptr
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|tmpstr
operator|=
name|strsep
argument_list|(
operator|&
name|id_str
argument_list|,
literal|","
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpstr
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|error_str
operator|!=
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|error_str
argument_list|,
name|error_str_len
argument_list|,
literal|"%s: no ID found"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|scsi_addr
operator|=
name|strtoul
argument_list|(
name|tmpstr
argument_list|,
operator|&
name|endptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|endptr
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|error_str
operator|!=
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|error_str
argument_list|,
name|error_str_len
argument_list|,
literal|"%s: error "
literal|"parsing SCSI ID %s, number required"
argument_list|,
name|__func__
argument_list|,
name|tmpstr
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
name|id_str
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|error_str
operator|!=
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|error_str
argument_list|,
name|error_str_len
argument_list|,
literal|"%s: no relative "
literal|"target port found"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|target_port
operator|=
name|strtoul
argument_list|(
name|id_str
argument_list|,
operator|&
name|endptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|endptr
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|error_str
operator|!=
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|error_str
argument_list|,
name|error_str_len
argument_list|,
literal|"%s: error "
literal|"parsing relative target port %s, number "
literal|"required"
argument_list|,
name|__func__
argument_list|,
name|id_str
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
ifdef|#
directive|ifdef
name|_KERNEL
name|spi
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|spi
argument_list|)
argument_list|,
name|type
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|#
directive|else
name|spi
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|spi
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|spi
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|error_str
operator|!=
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|error_str
argument_list|,
name|error_str_len
argument_list|,
literal|"%s: unable to "
literal|"allocate %zu bytes"
argument_list|,
name|__func__
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|spi
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
operator|*
name|alloc_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|spi
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|spi
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|spi
argument_list|)
argument_list|)
expr_stmt|;
name|spi
operator|->
name|format_protocol
operator|=
name|SCSI_PROTO_SPI
operator||
name|SCSI_TRN_SPI_FORMAT_DEFAULT
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|scsi_addr
argument_list|,
name|spi
operator|->
name|scsi_addr
argument_list|)
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|target_port
argument_list|,
name|spi
operator|->
name|rel_trgt_port_id
argument_list|)
expr_stmt|;
operator|*
name|hdr
operator|=
operator|(
expr|struct
name|scsi_transportid_header
operator|*
operator|)
name|spi
expr_stmt|;
name|bailout
label|:
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse an RDMA/SRP Initiator Port ID string.  This is 32 hexadecimal digits,  * optionally prefixed by "0x" or "0X".  */
end_comment

begin_function
name|int
name|scsi_parse_transportid_rdma
parameter_list|(
name|char
modifier|*
name|id_str
parameter_list|,
name|struct
name|scsi_transportid_header
modifier|*
modifier|*
name|hdr
parameter_list|,
name|unsigned
name|int
modifier|*
name|alloc_len
parameter_list|,
ifdef|#
directive|ifdef
name|_KERNEL
name|struct
name|malloc_type
modifier|*
name|type
parameter_list|,
name|int
name|flags
parameter_list|,
endif|#
directive|endif
name|char
modifier|*
name|error_str
parameter_list|,
name|int
name|error_str_len
parameter_list|)
block|{
name|struct
name|scsi_transportid_rdma
modifier|*
name|rdma
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|size_t
name|id_len
decl_stmt|,
name|rdma_id_size
decl_stmt|;
name|uint8_t
name|rdma_id
index|[
name|SCSI_TRN_RDMA_PORT_LEN
index|]
decl_stmt|;
name|char
modifier|*
name|tmpstr
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|id_len
operator|=
name|strlen
argument_list|(
name|id_str
argument_list|)
expr_stmt|;
name|rdma_id_size
operator|=
name|SCSI_TRN_RDMA_PORT_LEN
expr_stmt|;
comment|/* 	 * Check the size.  It needs to be either 32 or 34 characters long. 	 */
if|if
condition|(
operator|(
name|id_len
operator|!=
operator|(
name|rdma_id_size
operator|*
literal|2
operator|)
operator|)
operator|&&
operator|(
name|id_len
operator|!=
operator|(
operator|(
name|rdma_id_size
operator|*
literal|2
operator|)
operator|+
literal|2
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|error_str
operator|!=
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|error_str
argument_list|,
name|error_str_len
argument_list|,
literal|"%s: RDMA ID "
literal|"must be 32 hex digits (0x prefix "
literal|"optional), only %zu seen"
argument_list|,
name|__func__
argument_list|,
name|id_len
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|tmpstr
operator|=
name|id_str
expr_stmt|;
comment|/* 	 * If the user gave us 34 characters, the string needs to start 	 * with '0x'. 	 */
if|if
condition|(
name|id_len
operator|==
operator|(
operator|(
name|rdma_id_size
operator|*
literal|2
operator|)
operator|+
literal|2
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|tmpstr
index|[
literal|0
index|]
operator|==
literal|'0'
operator|)
operator|&&
operator|(
operator|(
name|tmpstr
index|[
literal|1
index|]
operator|==
literal|'x'
operator|)
operator|||
operator|(
name|tmpstr
index|[
literal|1
index|]
operator|==
literal|'X'
operator|)
operator|)
condition|)
block|{
name|tmpstr
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|error_str
operator|!=
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|error_str
argument_list|,
name|error_str_len
argument_list|,
literal|"%s: RDMA "
literal|"ID prefix, if used, must be \"0x\", "
literal|"got %s"
argument_list|,
name|__func__
argument_list|,
name|tmpstr
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
block|}
name|bzero
argument_list|(
name|rdma_id
argument_list|,
sizeof|sizeof
argument_list|(
name|rdma_id
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Convert ASCII hex into binary bytes.  There is no standard 	 * 128-bit integer type, and so no strtou128t() routine to convert 	 * from hex into a large integer.  In the end, we're not going to 	 * an integer, but rather to a byte array, so that and the fact 	 * that we require the user to give us 32 hex digits simplifies the 	 * logic. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|rdma_id_size
operator|*
literal|2
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|cur_shift
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
comment|/* Increment the byte array one for every 2 hex digits */
name|j
operator|=
name|i
operator|>>
literal|1
expr_stmt|;
comment|/* 		 * The first digit in every pair is the most significant 		 * 4 bits.  The second is the least significant 4 bits. 		 */
if|if
condition|(
operator|(
name|i
operator|%
literal|2
operator|)
operator|==
literal|0
condition|)
name|cur_shift
operator|=
literal|4
expr_stmt|;
else|else
name|cur_shift
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|tmpstr
index|[
name|i
index|]
expr_stmt|;
comment|/* Convert the ASCII hex character into a number */
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|-=
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|-=
name|isupper
argument_list|(
name|c
argument_list|)
condition|?
literal|'A'
operator|-
literal|10
else|:
literal|'a'
operator|-
literal|10
expr_stmt|;
else|else
block|{
if|if
condition|(
name|error_str
operator|!=
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|error_str
argument_list|,
name|error_str_len
argument_list|,
literal|"%s: "
literal|"RDMA ID must be hex digits, got "
literal|"invalid character %c"
argument_list|,
name|__func__
argument_list|,
name|tmpstr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
comment|/* 		 * The converted number can't be less than 0; the type is 		 * unsigned, and the subtraction logic will not give us  		 * a negative number.  So we only need to make sure that 		 * the value is not greater than 0xf.  (i.e. make sure the 		 * user didn't give us a value like "0x12jklmno"). 		 */
if|if
condition|(
name|c
operator|>
literal|0xf
condition|)
block|{
if|if
condition|(
name|error_str
operator|!=
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|error_str
argument_list|,
name|error_str_len
argument_list|,
literal|"%s: "
literal|"RDMA ID must be hex digits, got "
literal|"invalid character %c"
argument_list|,
name|__func__
argument_list|,
name|tmpstr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|rdma_id
index|[
name|j
index|]
operator||=
name|c
operator|<<
name|cur_shift
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|_KERNEL
name|rdma
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|rdma
argument_list|)
argument_list|,
name|type
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|#
directive|else
name|rdma
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|rdma
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|rdma
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|error_str
operator|!=
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|error_str
argument_list|,
name|error_str_len
argument_list|,
literal|"%s: unable to "
literal|"allocate %zu bytes"
argument_list|,
name|__func__
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rdma
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
operator|*
name|alloc_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|rdma
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|rdma
argument_list|,
sizeof|sizeof
argument_list|(
name|rdma
argument_list|)
argument_list|)
expr_stmt|;
name|rdma
operator|->
name|format_protocol
operator|=
name|SCSI_PROTO_RDMA
operator||
name|SCSI_TRN_RDMA_FORMAT_DEFAULT
expr_stmt|;
name|bcopy
argument_list|(
name|rdma_id
argument_list|,
name|rdma
operator|->
name|initiator_port_id
argument_list|,
name|SCSI_TRN_RDMA_PORT_LEN
argument_list|)
expr_stmt|;
operator|*
name|hdr
operator|=
operator|(
expr|struct
name|scsi_transportid_header
operator|*
operator|)
name|rdma
expr_stmt|;
name|bailout
label|:
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse an iSCSI name.  The format is either just the name:  *  *	iqn.2012-06.com.example:target0  * or the name, separator and initiator session ID:  *  *	iqn.2012-06.com.example:target0,i,0x123  *  * The separator format is exact.  */
end_comment

begin_function
name|int
name|scsi_parse_transportid_iscsi
parameter_list|(
name|char
modifier|*
name|id_str
parameter_list|,
name|struct
name|scsi_transportid_header
modifier|*
modifier|*
name|hdr
parameter_list|,
name|unsigned
name|int
modifier|*
name|alloc_len
parameter_list|,
ifdef|#
directive|ifdef
name|_KERNEL
name|struct
name|malloc_type
modifier|*
name|type
parameter_list|,
name|int
name|flags
parameter_list|,
endif|#
directive|endif
name|char
modifier|*
name|error_str
parameter_list|,
name|int
name|error_str_len
parameter_list|)
block|{
name|size_t
name|id_len
decl_stmt|,
name|sep_len
decl_stmt|,
name|id_size
decl_stmt|,
name|name_len
decl_stmt|;
name|int
name|is_full_id
decl_stmt|,
name|retval
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|sep_pos
decl_stmt|,
name|sep_found
decl_stmt|;
specifier|const
name|char
modifier|*
name|sep_template
init|=
literal|",i,0x"
decl_stmt|;
specifier|const
name|char
modifier|*
name|iqn_prefix
init|=
literal|"iqn."
decl_stmt|;
name|struct
name|scsi_transportid_iscsi_device
modifier|*
name|iscsi
decl_stmt|;
name|is_full_id
operator|=
literal|0
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|sep_found
operator|=
literal|0
expr_stmt|;
name|id_len
operator|=
name|strlen
argument_list|(
name|id_str
argument_list|)
expr_stmt|;
name|sep_len
operator|=
name|strlen
argument_list|(
name|sep_template
argument_list|)
expr_stmt|;
comment|/* 	 * The separator is defined as exactly ',i,0x'.  Any other commas, 	 * or any other form, is an error.  So look for a comma, and once 	 * we find that, the next few characters must match the separator 	 * exactly.  Once we get through the separator, there should be at 	 * least one character. 	 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sep_pos
operator|=
literal|0
init|;
name|i
operator|<
name|id_len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sep_pos
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|id_str
index|[
name|i
index|]
operator|==
name|sep_template
index|[
name|sep_pos
index|]
condition|)
name|sep_pos
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sep_pos
operator|<
name|sep_len
condition|)
block|{
if|if
condition|(
name|id_str
index|[
name|i
index|]
operator|==
name|sep_template
index|[
name|sep_pos
index|]
condition|)
block|{
name|sep_pos
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|error_str
operator|!=
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|error_str
argument_list|,
name|error_str_len
argument_list|,
literal|"%s: "
literal|"invalid separator in iSCSI name "
literal|"\"%s\""
argument_list|,
name|__func__
argument_list|,
name|id_str
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
else|else
block|{
name|sep_found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * Check to see whether we have a separator but no digits after it. 	 */
if|if
condition|(
operator|(
name|sep_pos
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|sep_found
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|error_str
operator|!=
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|error_str
argument_list|,
name|error_str_len
argument_list|,
literal|"%s: no digits "
literal|"found after separator in iSCSI name \"%s\""
argument_list|,
name|__func__
argument_list|,
name|id_str
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
comment|/* 	 * The incoming ID string has the "iqn." prefix stripped off.  We 	 * need enough space for the base structure (the structures are the 	 * same for the two iSCSI forms), the prefix, the ID string and a 	 * terminating NUL. 	 */
name|id_size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|iscsi
argument_list|)
operator|+
name|strlen
argument_list|(
name|iqn_prefix
argument_list|)
operator|+
name|id_len
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
name|iscsi
operator|=
name|malloc
argument_list|(
name|id_size
argument_list|,
name|type
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|#
directive|else
name|iscsi
operator|=
name|malloc
argument_list|(
name|id_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|iscsi
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|error_str
operator|!=
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|error_str
argument_list|,
name|error_str_len
argument_list|,
literal|"%s: unable to "
literal|"allocate %zu bytes"
argument_list|,
name|__func__
argument_list|,
name|id_size
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
operator|*
name|alloc_len
operator|=
name|id_size
expr_stmt|;
name|bzero
argument_list|(
name|iscsi
argument_list|,
name|id_size
argument_list|)
expr_stmt|;
name|iscsi
operator|->
name|format_protocol
operator|=
name|SCSI_PROTO_ISCSI
expr_stmt|;
if|if
condition|(
name|sep_found
operator|==
literal|0
condition|)
name|iscsi
operator|->
name|format_protocol
operator||=
name|SCSI_TRN_ISCSI_FORMAT_DEVICE
expr_stmt|;
else|else
name|iscsi
operator|->
name|format_protocol
operator||=
name|SCSI_TRN_ISCSI_FORMAT_PORT
expr_stmt|;
name|name_len
operator|=
name|id_size
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|iscsi
argument_list|)
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|name_len
argument_list|,
name|iscsi
operator|->
name|additional_length
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|iscsi
operator|->
name|iscsi_name
argument_list|,
name|name_len
argument_list|,
literal|"%s%s"
argument_list|,
name|iqn_prefix
argument_list|,
name|id_str
argument_list|)
expr_stmt|;
operator|*
name|hdr
operator|=
operator|(
expr|struct
name|scsi_transportid_header
operator|*
operator|)
name|iscsi
expr_stmt|;
name|bailout
label|:
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse a SCSI over PCIe (SOP) identifier.  The Routing ID can either be  * of the form 'bus,device,function' or 'bus,function'.  */
end_comment

begin_function
name|int
name|scsi_parse_transportid_sop
parameter_list|(
name|char
modifier|*
name|id_str
parameter_list|,
name|struct
name|scsi_transportid_header
modifier|*
modifier|*
name|hdr
parameter_list|,
name|unsigned
name|int
modifier|*
name|alloc_len
parameter_list|,
ifdef|#
directive|ifdef
name|_KERNEL
name|struct
name|malloc_type
modifier|*
name|type
parameter_list|,
name|int
name|flags
parameter_list|,
endif|#
directive|endif
name|char
modifier|*
name|error_str
parameter_list|,
name|int
name|error_str_len
parameter_list|)
block|{
name|struct
name|scsi_transportid_sop
modifier|*
name|sop
decl_stmt|;
name|unsigned
name|long
name|bus
decl_stmt|,
name|device
decl_stmt|,
name|function
decl_stmt|;
name|char
modifier|*
name|tmpstr
decl_stmt|,
modifier|*
name|endptr
decl_stmt|;
name|int
name|retval
decl_stmt|,
name|device_spec
decl_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|device_spec
operator|=
literal|0
expr_stmt|;
name|device
operator|=
literal|0
expr_stmt|;
name|tmpstr
operator|=
name|strsep
argument_list|(
operator|&
name|id_str
argument_list|,
literal|","
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmpstr
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|*
name|tmpstr
operator|==
literal|'\0'
operator|)
condition|)
block|{
if|if
condition|(
name|error_str
operator|!=
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|error_str
argument_list|,
name|error_str_len
argument_list|,
literal|"%s: no ID found"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|bus
operator|=
name|strtoul
argument_list|(
name|tmpstr
argument_list|,
operator|&
name|endptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|endptr
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|error_str
operator|!=
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|error_str
argument_list|,
name|error_str_len
argument_list|,
literal|"%s: error "
literal|"parsing PCIe bus %s, number required"
argument_list|,
name|__func__
argument_list|,
name|tmpstr
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
operator|(
name|id_str
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|*
name|id_str
operator|==
literal|'\0'
operator|)
condition|)
block|{
if|if
condition|(
name|error_str
operator|!=
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|error_str
argument_list|,
name|error_str_len
argument_list|,
literal|"%s: no PCIe "
literal|"device or function found"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|tmpstr
operator|=
name|strsep
argument_list|(
operator|&
name|id_str
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|function
operator|=
name|strtoul
argument_list|(
name|tmpstr
argument_list|,
operator|&
name|endptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|endptr
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|error_str
operator|!=
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|error_str
argument_list|,
name|error_str_len
argument_list|,
literal|"%s: error "
literal|"parsing PCIe device/function %s, number "
literal|"required"
argument_list|,
name|__func__
argument_list|,
name|tmpstr
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
comment|/* 	 * Check to see whether the user specified a third value.  If so, 	 * the second is the device. 	 */
if|if
condition|(
name|id_str
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|id_str
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|error_str
operator|!=
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|error_str
argument_list|,
name|error_str_len
argument_list|,
literal|"%s: "
literal|"no PCIe function found"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|device
operator|=
name|function
expr_stmt|;
name|device_spec
operator|=
literal|1
expr_stmt|;
name|function
operator|=
name|strtoul
argument_list|(
name|id_str
argument_list|,
operator|&
name|endptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|endptr
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|error_str
operator|!=
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|error_str
argument_list|,
name|error_str_len
argument_list|,
literal|"%s: "
literal|"error parsing PCIe function %s, "
literal|"number required"
argument_list|,
name|__func__
argument_list|,
name|id_str
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
block|}
if|if
condition|(
name|bus
operator|>
name|SCSI_TRN_SOP_BUS_MAX
condition|)
block|{
if|if
condition|(
name|error_str
operator|!=
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|error_str
argument_list|,
name|error_str_len
argument_list|,
literal|"%s: bus value "
literal|"%lu greater than maximum %u"
argument_list|,
name|__func__
argument_list|,
name|bus
argument_list|,
name|SCSI_TRN_SOP_BUS_MAX
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
operator|(
name|device_spec
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|device
operator|>
name|SCSI_TRN_SOP_DEV_MASK
operator|)
condition|)
block|{
if|if
condition|(
name|error_str
operator|!=
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|error_str
argument_list|,
name|error_str_len
argument_list|,
literal|"%s: device value "
literal|"%lu greater than maximum %u"
argument_list|,
name|__func__
argument_list|,
name|device
argument_list|,
name|SCSI_TRN_SOP_DEV_MAX
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
operator|(
operator|(
name|device_spec
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|function
operator|>
name|SCSI_TRN_SOP_FUNC_NORM_MAX
operator|)
operator|)
operator|||
operator|(
operator|(
name|device_spec
operator|==
literal|0
operator|)
operator|&&
operator|(
name|function
operator|>
name|SCSI_TRN_SOP_FUNC_ALT_MAX
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|error_str
operator|!=
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|error_str
argument_list|,
name|error_str_len
argument_list|,
literal|"%s: function value "
literal|"%lu greater than maximum %u"
argument_list|,
name|__func__
argument_list|,
name|function
argument_list|,
operator|(
name|device_spec
operator|==
literal|0
operator|)
condition|?
name|SCSI_TRN_SOP_FUNC_ALT_MAX
else|:
name|SCSI_TRN_SOP_FUNC_NORM_MAX
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
ifdef|#
directive|ifdef
name|_KERNEL
name|sop
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sop
argument_list|)
argument_list|,
name|type
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|#
directive|else
name|sop
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sop
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sop
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|error_str
operator|!=
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|error_str
argument_list|,
name|error_str_len
argument_list|,
literal|"%s: unable to "
literal|"allocate %zu bytes"
argument_list|,
name|__func__
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sop
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
operator|*
name|alloc_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sop
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sop
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sop
argument_list|)
argument_list|)
expr_stmt|;
name|sop
operator|->
name|format_protocol
operator|=
name|SCSI_PROTO_SOP
operator||
name|SCSI_TRN_SOP_FORMAT_DEFAULT
expr_stmt|;
if|if
condition|(
name|device_spec
operator|!=
literal|0
condition|)
block|{
name|struct
name|scsi_sop_routing_id_norm
name|rid
decl_stmt|;
name|rid
operator|.
name|bus
operator|=
name|bus
expr_stmt|;
name|rid
operator|.
name|devfunc
operator|=
operator|(
name|device
operator|<<
name|SCSI_TRN_SOP_DEV_SHIFT
operator|)
operator||
name|function
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|rid
argument_list|,
name|sop
operator|->
name|routing_id
argument_list|,
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
name|rid
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|sop
operator|->
name|routing_id
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|scsi_sop_routing_id_alt
name|rid
decl_stmt|;
name|rid
operator|.
name|bus
operator|=
name|bus
expr_stmt|;
name|rid
operator|.
name|function
operator|=
name|function
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|rid
argument_list|,
name|sop
operator|->
name|routing_id
argument_list|,
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
name|rid
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|sop
operator|->
name|routing_id
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|hdr
operator|=
operator|(
expr|struct
name|scsi_transportid_header
operator|*
operator|)
name|sop
expr_stmt|;
name|bailout
label|:
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * transportid_str: NUL-terminated string with format: protcol,id  *		    The ID is protocol specific.  * hdr:		    Storage will be allocated for the transport ID.  * alloc_len:	    The amount of memory allocated is returned here.  * type:	    Malloc bucket (kernel only).  * flags:	    Malloc flags (kernel only).  * error_str:	    If non-NULL, it will contain error information (without  * 		    a terminating newline) if an error is returned.  * error_str_len:   Allocated length of the error string.  *  * Returns 0 for success, non-zero for failure.  */
end_comment

begin_function
name|int
name|scsi_parse_transportid
parameter_list|(
name|char
modifier|*
name|transportid_str
parameter_list|,
name|struct
name|scsi_transportid_header
modifier|*
modifier|*
name|hdr
parameter_list|,
name|unsigned
name|int
modifier|*
name|alloc_len
parameter_list|,
ifdef|#
directive|ifdef
name|_KERNEL
name|struct
name|malloc_type
modifier|*
name|type
parameter_list|,
name|int
name|flags
parameter_list|,
endif|#
directive|endif
name|char
modifier|*
name|error_str
parameter_list|,
name|int
name|error_str_len
parameter_list|)
block|{
name|char
modifier|*
name|tmpstr
decl_stmt|;
name|scsi_nv_status
name|status
decl_stmt|;
name|int
name|retval
decl_stmt|,
name|num_proto_entries
decl_stmt|,
name|table_entry
decl_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|table_entry
operator|=
literal|0
expr_stmt|;
comment|/* 	 * We do allow a period as well as a comma to separate the protocol 	 * from the ID string.  This is to accommodate iSCSI names, which 	 * start with "iqn.". 	 */
name|tmpstr
operator|=
name|strsep
argument_list|(
operator|&
name|transportid_str
argument_list|,
literal|",."
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpstr
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|error_str
operator|!=
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|error_str
argument_list|,
name|error_str_len
argument_list|,
literal|"%s: transportid_str is NULL"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|num_proto_entries
operator|=
sizeof|sizeof
argument_list|(
name|scsi_proto_map
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|scsi_proto_map
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|status
operator|=
name|scsi_get_nv
argument_list|(
name|scsi_proto_map
argument_list|,
name|num_proto_entries
argument_list|,
name|tmpstr
argument_list|,
operator|&
name|table_entry
argument_list|,
name|SCSI_NV_FLAG_IG_CASE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|SCSI_NV_FOUND
condition|)
block|{
if|if
condition|(
name|error_str
operator|!=
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|error_str
argument_list|,
name|error_str_len
argument_list|,
literal|"%s: %s protocol "
literal|"name %s"
argument_list|,
name|__func__
argument_list|,
operator|(
name|status
operator|==
name|SCSI_NV_AMBIGUOUS
operator|)
condition|?
literal|"ambiguous"
else|:
literal|"invalid"
argument_list|,
name|tmpstr
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
switch|switch
condition|(
name|scsi_proto_map
index|[
name|table_entry
index|]
operator|.
name|value
condition|)
block|{
case|case
name|SCSI_PROTO_FC
case|:
case|case
name|SCSI_PROTO_1394
case|:
case|case
name|SCSI_PROTO_SAS
case|:
name|retval
operator|=
name|scsi_parse_transportid_64bit
argument_list|(
name|scsi_proto_map
index|[
name|table_entry
index|]
operator|.
name|value
argument_list|,
name|transportid_str
argument_list|,
name|hdr
argument_list|,
name|alloc_len
argument_list|,
ifdef|#
directive|ifdef
name|_KERNEL
name|type
argument_list|,
name|flags
argument_list|,
endif|#
directive|endif
name|error_str
argument_list|,
name|error_str_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCSI_PROTO_SPI
case|:
name|retval
operator|=
name|scsi_parse_transportid_spi
argument_list|(
name|transportid_str
argument_list|,
name|hdr
argument_list|,
name|alloc_len
argument_list|,
ifdef|#
directive|ifdef
name|_KERNEL
name|type
argument_list|,
name|flags
argument_list|,
endif|#
directive|endif
name|error_str
argument_list|,
name|error_str_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCSI_PROTO_RDMA
case|:
name|retval
operator|=
name|scsi_parse_transportid_rdma
argument_list|(
name|transportid_str
argument_list|,
name|hdr
argument_list|,
name|alloc_len
argument_list|,
ifdef|#
directive|ifdef
name|_KERNEL
name|type
argument_list|,
name|flags
argument_list|,
endif|#
directive|endif
name|error_str
argument_list|,
name|error_str_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCSI_PROTO_ISCSI
case|:
name|retval
operator|=
name|scsi_parse_transportid_iscsi
argument_list|(
name|transportid_str
argument_list|,
name|hdr
argument_list|,
name|alloc_len
argument_list|,
ifdef|#
directive|ifdef
name|_KERNEL
name|type
argument_list|,
name|flags
argument_list|,
endif|#
directive|endif
name|error_str
argument_list|,
name|error_str_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCSI_PROTO_SOP
case|:
name|retval
operator|=
name|scsi_parse_transportid_sop
argument_list|(
name|transportid_str
argument_list|,
name|hdr
argument_list|,
name|alloc_len
argument_list|,
ifdef|#
directive|ifdef
name|_KERNEL
name|type
argument_list|,
name|flags
argument_list|,
endif|#
directive|endif
name|error_str
argument_list|,
name|error_str_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCSI_PROTO_SSA
case|:
case|case
name|SCSI_PROTO_ADITP
case|:
case|case
name|SCSI_PROTO_ATA
case|:
case|case
name|SCSI_PROTO_UAS
case|:
case|case
name|SCSI_PROTO_NONE
case|:
default|default:
comment|/* 		 * There is no format defined for a Transport ID for these 		 * protocols.  So even if the user gives us something, we 		 * have no way to turn it into a standard SCSI Transport ID. 		 */
name|retval
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|error_str
operator|!=
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|error_str
argument_list|,
name|error_str_len
argument_list|,
literal|"%s: no Transport "
literal|"ID format exists for protocol %s"
argument_list|,
name|__func__
argument_list|,
name|tmpstr
argument_list|)
expr_stmt|;
block|}
goto|goto
name|bailout
goto|;
break|break;
comment|/* NOTREACHED */
block|}
name|bailout
label|:
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|void
name|scsi_test_unit_ready
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_test_unit_ready
modifier|*
name|scsi_cmd
decl_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
name|CAM_DIR_NONE
argument_list|,
name|tag_action
argument_list|,
comment|/*data_ptr*/
name|NULL
argument_list|,
comment|/*dxfer_len*/
literal|0
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_test_unit_ready
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|TEST_UNIT_READY
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_request_sense
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|data_ptr
parameter_list|,
name|u_int8_t
name|dxfer_len
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_request_sense
modifier|*
name|scsi_cmd
decl_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
name|CAM_DIR_IN
argument_list|,
name|tag_action
argument_list|,
name|data_ptr
argument_list|,
name|dxfer_len
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_request_sense
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|REQUEST_SENSE
expr_stmt|;
name|scsi_cmd
operator|->
name|length
operator|=
name|dxfer_len
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_inquiry
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|u_int8_t
modifier|*
name|inq_buf
parameter_list|,
name|u_int32_t
name|inq_len
parameter_list|,
name|int
name|evpd
parameter_list|,
name|u_int8_t
name|page_code
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_inquiry
modifier|*
name|scsi_cmd
decl_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|CAM_DIR_IN
argument_list|,
name|tag_action
argument_list|,
comment|/*data_ptr*/
name|inq_buf
argument_list|,
comment|/*dxfer_len*/
name|inq_len
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_inquiry
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|INQUIRY
expr_stmt|;
if|if
condition|(
name|evpd
condition|)
block|{
name|scsi_cmd
operator|->
name|byte2
operator||=
name|SI_EVPD
expr_stmt|;
name|scsi_cmd
operator|->
name|page_code
operator|=
name|page_code
expr_stmt|;
block|}
name|scsi_ulto2b
argument_list|(
name|inq_len
argument_list|,
name|scsi_cmd
operator|->
name|length
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_mode_sense
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|int
name|dbd
parameter_list|,
name|u_int8_t
name|page_code
parameter_list|,
name|u_int8_t
name|page
parameter_list|,
name|u_int8_t
modifier|*
name|param_buf
parameter_list|,
name|u_int32_t
name|param_len
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|scsi_mode_sense_len
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
name|tag_action
argument_list|,
name|dbd
argument_list|,
name|page_code
argument_list|,
name|page
argument_list|,
name|param_buf
argument_list|,
name|param_len
argument_list|,
literal|0
argument_list|,
name|sense_len
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_mode_sense_len
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|int
name|dbd
parameter_list|,
name|u_int8_t
name|page_code
parameter_list|,
name|u_int8_t
name|page
parameter_list|,
name|u_int8_t
modifier|*
name|param_buf
parameter_list|,
name|u_int32_t
name|param_len
parameter_list|,
name|int
name|minimum_cmd_size
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|u_int8_t
name|cdb_len
decl_stmt|;
comment|/* 	 * Use the smallest possible command to perform the operation. 	 */
if|if
condition|(
operator|(
name|param_len
operator|<
literal|256
operator|)
operator|&&
operator|(
name|minimum_cmd_size
operator|<
literal|10
operator|)
condition|)
block|{
comment|/* 		 * We can fit in a 6 byte cdb. 		 */
name|struct
name|scsi_mode_sense_6
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_mode_sense_6
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|MODE_SENSE_6
expr_stmt|;
if|if
condition|(
name|dbd
operator|!=
literal|0
condition|)
name|scsi_cmd
operator|->
name|byte2
operator||=
name|SMS_DBD
expr_stmt|;
name|scsi_cmd
operator|->
name|page
operator|=
name|page_code
operator||
name|page
expr_stmt|;
name|scsi_cmd
operator|->
name|length
operator|=
name|param_len
expr_stmt|;
name|cdb_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Need a 10 byte cdb. 		 */
name|struct
name|scsi_mode_sense_10
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_mode_sense_10
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|MODE_SENSE_10
expr_stmt|;
if|if
condition|(
name|dbd
operator|!=
literal|0
condition|)
name|scsi_cmd
operator|->
name|byte2
operator||=
name|SMS_DBD
expr_stmt|;
name|scsi_cmd
operator|->
name|page
operator|=
name|page_code
operator||
name|page
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|param_len
argument_list|,
name|scsi_cmd
operator|->
name|length
argument_list|)
expr_stmt|;
name|cdb_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
expr_stmt|;
block|}
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
name|CAM_DIR_IN
argument_list|,
name|tag_action
argument_list|,
name|param_buf
argument_list|,
name|param_len
argument_list|,
name|sense_len
argument_list|,
name|cdb_len
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_mode_select
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|int
name|scsi_page_fmt
parameter_list|,
name|int
name|save_pages
parameter_list|,
name|u_int8_t
modifier|*
name|param_buf
parameter_list|,
name|u_int32_t
name|param_len
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|scsi_mode_select_len
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
name|tag_action
argument_list|,
name|scsi_page_fmt
argument_list|,
name|save_pages
argument_list|,
name|param_buf
argument_list|,
name|param_len
argument_list|,
literal|0
argument_list|,
name|sense_len
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_mode_select_len
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|int
name|scsi_page_fmt
parameter_list|,
name|int
name|save_pages
parameter_list|,
name|u_int8_t
modifier|*
name|param_buf
parameter_list|,
name|u_int32_t
name|param_len
parameter_list|,
name|int
name|minimum_cmd_size
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|u_int8_t
name|cdb_len
decl_stmt|;
comment|/* 	 * Use the smallest possible command to perform the operation. 	 */
if|if
condition|(
operator|(
name|param_len
operator|<
literal|256
operator|)
operator|&&
operator|(
name|minimum_cmd_size
operator|<
literal|10
operator|)
condition|)
block|{
comment|/* 		 * We can fit in a 6 byte cdb. 		 */
name|struct
name|scsi_mode_select_6
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_mode_select_6
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|MODE_SELECT_6
expr_stmt|;
if|if
condition|(
name|scsi_page_fmt
operator|!=
literal|0
condition|)
name|scsi_cmd
operator|->
name|byte2
operator||=
name|SMS_PF
expr_stmt|;
if|if
condition|(
name|save_pages
operator|!=
literal|0
condition|)
name|scsi_cmd
operator|->
name|byte2
operator||=
name|SMS_SP
expr_stmt|;
name|scsi_cmd
operator|->
name|length
operator|=
name|param_len
expr_stmt|;
name|cdb_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Need a 10 byte cdb. 		 */
name|struct
name|scsi_mode_select_10
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_mode_select_10
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|MODE_SELECT_10
expr_stmt|;
if|if
condition|(
name|scsi_page_fmt
operator|!=
literal|0
condition|)
name|scsi_cmd
operator|->
name|byte2
operator||=
name|SMS_PF
expr_stmt|;
if|if
condition|(
name|save_pages
operator|!=
literal|0
condition|)
name|scsi_cmd
operator|->
name|byte2
operator||=
name|SMS_SP
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|param_len
argument_list|,
name|scsi_cmd
operator|->
name|length
argument_list|)
expr_stmt|;
name|cdb_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
expr_stmt|;
block|}
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
name|CAM_DIR_OUT
argument_list|,
name|tag_action
argument_list|,
name|param_buf
argument_list|,
name|param_len
argument_list|,
name|sense_len
argument_list|,
name|cdb_len
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_log_sense
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|u_int8_t
name|page_code
parameter_list|,
name|u_int8_t
name|page
parameter_list|,
name|int
name|save_pages
parameter_list|,
name|int
name|ppc
parameter_list|,
name|u_int32_t
name|paramptr
parameter_list|,
name|u_int8_t
modifier|*
name|param_buf
parameter_list|,
name|u_int32_t
name|param_len
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_log_sense
modifier|*
name|scsi_cmd
decl_stmt|;
name|u_int8_t
name|cdb_len
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_log_sense
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|LOG_SENSE
expr_stmt|;
name|scsi_cmd
operator|->
name|page
operator|=
name|page_code
operator||
name|page
expr_stmt|;
if|if
condition|(
name|save_pages
operator|!=
literal|0
condition|)
name|scsi_cmd
operator|->
name|byte2
operator||=
name|SLS_SP
expr_stmt|;
if|if
condition|(
name|ppc
operator|!=
literal|0
condition|)
name|scsi_cmd
operator|->
name|byte2
operator||=
name|SLS_PPC
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|paramptr
argument_list|,
name|scsi_cmd
operator|->
name|paramptr
argument_list|)
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|param_len
argument_list|,
name|scsi_cmd
operator|->
name|length
argument_list|)
expr_stmt|;
name|cdb_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|CAM_DIR_IN
argument_list|,
name|tag_action
argument_list|,
comment|/*data_ptr*/
name|param_buf
argument_list|,
comment|/*dxfer_len*/
name|param_len
argument_list|,
name|sense_len
argument_list|,
name|cdb_len
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_log_select
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|u_int8_t
name|page_code
parameter_list|,
name|int
name|save_pages
parameter_list|,
name|int
name|pc_reset
parameter_list|,
name|u_int8_t
modifier|*
name|param_buf
parameter_list|,
name|u_int32_t
name|param_len
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_log_select
modifier|*
name|scsi_cmd
decl_stmt|;
name|u_int8_t
name|cdb_len
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_log_select
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|LOG_SELECT
expr_stmt|;
name|scsi_cmd
operator|->
name|page
operator|=
name|page_code
operator|&
name|SLS_PAGE_CODE
expr_stmt|;
if|if
condition|(
name|save_pages
operator|!=
literal|0
condition|)
name|scsi_cmd
operator|->
name|byte2
operator||=
name|SLS_SP
expr_stmt|;
if|if
condition|(
name|pc_reset
operator|!=
literal|0
condition|)
name|scsi_cmd
operator|->
name|byte2
operator||=
name|SLS_PCR
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|param_len
argument_list|,
name|scsi_cmd
operator|->
name|length
argument_list|)
expr_stmt|;
name|cdb_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|CAM_DIR_OUT
argument_list|,
name|tag_action
argument_list|,
comment|/*data_ptr*/
name|param_buf
argument_list|,
comment|/*dxfer_len*/
name|param_len
argument_list|,
name|sense_len
argument_list|,
name|cdb_len
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Prevent or allow the user to remove the media  */
end_comment

begin_function
name|void
name|scsi_prevent
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|u_int8_t
name|action
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_prevent
modifier|*
name|scsi_cmd
decl_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|CAM_DIR_NONE
argument_list|,
name|tag_action
argument_list|,
comment|/*data_ptr*/
name|NULL
argument_list|,
comment|/*dxfer_len*/
literal|0
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_prevent
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|PREVENT_ALLOW
expr_stmt|;
name|scsi_cmd
operator|->
name|how
operator|=
name|action
expr_stmt|;
block|}
end_function

begin_comment
comment|/* XXX allow specification of address and PMI bit and LBA */
end_comment

begin_function
name|void
name|scsi_read_capacity
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|struct
name|scsi_read_capacity_data
modifier|*
name|rcap_buf
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_read_capacity
modifier|*
name|scsi_cmd
decl_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|CAM_DIR_IN
argument_list|,
name|tag_action
argument_list|,
comment|/*data_ptr*/
operator|(
name|u_int8_t
operator|*
operator|)
name|rcap_buf
argument_list|,
comment|/*dxfer_len*/
sizeof|sizeof
argument_list|(
operator|*
name|rcap_buf
argument_list|)
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_read_capacity
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|READ_CAPACITY
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_read_capacity_16
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|uint32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|uint8_t
name|tag_action
parameter_list|,
name|uint64_t
name|lba
parameter_list|,
name|int
name|reladr
parameter_list|,
name|int
name|pmi
parameter_list|,
name|uint8_t
modifier|*
name|rcap_buf
parameter_list|,
name|int
name|rcap_buf_len
parameter_list|,
name|uint8_t
name|sense_len
parameter_list|,
name|uint32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_read_capacity_16
modifier|*
name|scsi_cmd
decl_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|CAM_DIR_IN
argument_list|,
name|tag_action
argument_list|,
comment|/*data_ptr*/
operator|(
name|u_int8_t
operator|*
operator|)
name|rcap_buf
argument_list|,
comment|/*dxfer_len*/
name|rcap_buf_len
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_read_capacity_16
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|SERVICE_ACTION_IN
expr_stmt|;
name|scsi_cmd
operator|->
name|service_action
operator|=
name|SRC16_SERVICE_ACTION
expr_stmt|;
name|scsi_u64to8b
argument_list|(
name|lba
argument_list|,
name|scsi_cmd
operator|->
name|addr
argument_list|)
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|rcap_buf_len
argument_list|,
name|scsi_cmd
operator|->
name|alloc_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmi
condition|)
name|reladr
operator||=
name|SRC16_PMI
expr_stmt|;
if|if
condition|(
name|reladr
condition|)
name|reladr
operator||=
name|SRC16_RELADR
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_report_luns
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|u_int8_t
name|select_report
parameter_list|,
name|struct
name|scsi_report_luns_data
modifier|*
name|rpl_buf
parameter_list|,
name|u_int32_t
name|alloc_len
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_report_luns
modifier|*
name|scsi_cmd
decl_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|CAM_DIR_IN
argument_list|,
name|tag_action
argument_list|,
comment|/*data_ptr*/
operator|(
name|u_int8_t
operator|*
operator|)
name|rpl_buf
argument_list|,
comment|/*dxfer_len*/
name|alloc_len
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_report_luns
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|REPORT_LUNS
expr_stmt|;
name|scsi_cmd
operator|->
name|select_report
operator|=
name|select_report
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|alloc_len
argument_list|,
name|scsi_cmd
operator|->
name|length
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_report_target_group
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|u_int8_t
name|pdf
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|u_int32_t
name|alloc_len
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_target_group
modifier|*
name|scsi_cmd
decl_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|CAM_DIR_IN
argument_list|,
name|tag_action
argument_list|,
comment|/*data_ptr*/
operator|(
name|u_int8_t
operator|*
operator|)
name|buf
argument_list|,
comment|/*dxfer_len*/
name|alloc_len
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_target_group
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|MAINTENANCE_IN
expr_stmt|;
name|scsi_cmd
operator|->
name|service_action
operator|=
name|REPORT_TARGET_PORT_GROUPS
operator||
name|pdf
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|alloc_len
argument_list|,
name|scsi_cmd
operator|->
name|length
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_set_target_group
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|u_int32_t
name|alloc_len
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_target_group
modifier|*
name|scsi_cmd
decl_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|CAM_DIR_OUT
argument_list|,
name|tag_action
argument_list|,
comment|/*data_ptr*/
operator|(
name|u_int8_t
operator|*
operator|)
name|buf
argument_list|,
comment|/*dxfer_len*/
name|alloc_len
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_target_group
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|MAINTENANCE_OUT
expr_stmt|;
name|scsi_cmd
operator|->
name|service_action
operator|=
name|SET_TARGET_PORT_GROUPS
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|alloc_len
argument_list|,
name|scsi_cmd
operator|->
name|length
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Syncronize the media to the contents of the cache for  * the given lba/count pair.  Specifying 0/0 means sync  * the whole cache.  */
end_comment

begin_function
name|void
name|scsi_synchronize_cache
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|u_int32_t
name|begin_lba
parameter_list|,
name|u_int16_t
name|lb_count
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_sync_cache
modifier|*
name|scsi_cmd
decl_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|CAM_DIR_NONE
argument_list|,
name|tag_action
argument_list|,
comment|/*data_ptr*/
name|NULL
argument_list|,
comment|/*dxfer_len*/
literal|0
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_sync_cache
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|SYNCHRONIZE_CACHE
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|begin_lba
argument_list|,
name|scsi_cmd
operator|->
name|begin_lba
argument_list|)
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|lb_count
argument_list|,
name|scsi_cmd
operator|->
name|lb_count
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_read_write
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|int
name|readop
parameter_list|,
name|u_int8_t
name|byte2
parameter_list|,
name|int
name|minimum_cmd_size
parameter_list|,
name|u_int64_t
name|lba
parameter_list|,
name|u_int32_t
name|block_count
parameter_list|,
name|u_int8_t
modifier|*
name|data_ptr
parameter_list|,
name|u_int32_t
name|dxfer_len
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|int
name|read
decl_stmt|;
name|u_int8_t
name|cdb_len
decl_stmt|;
name|read
operator|=
operator|(
name|readop
operator|&
name|SCSI_RW_DIRMASK
operator|)
operator|==
name|SCSI_RW_READ
expr_stmt|;
comment|/* 	 * Use the smallest possible command to perform the operation 	 * as some legacy hardware does not support the 10 byte commands. 	 * If any of the bits in byte2 is set, we have to go with a larger 	 * command. 	 */
if|if
condition|(
operator|(
name|minimum_cmd_size
operator|<
literal|10
operator|)
operator|&&
operator|(
operator|(
name|lba
operator|&
literal|0x1fffff
operator|)
operator|==
name|lba
operator|)
operator|&&
operator|(
operator|(
name|block_count
operator|&
literal|0xff
operator|)
operator|==
name|block_count
operator|)
operator|&&
operator|(
name|byte2
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * We can fit in a 6 byte cdb. 		 */
name|struct
name|scsi_rw_6
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_rw_6
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|read
condition|?
name|READ_6
else|:
name|WRITE_6
expr_stmt|;
name|scsi_ulto3b
argument_list|(
name|lba
argument_list|,
name|scsi_cmd
operator|->
name|addr
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|length
operator|=
name|block_count
operator|&
literal|0xff
expr_stmt|;
name|scsi_cmd
operator|->
name|control
operator|=
literal|0
expr_stmt|;
name|cdb_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|csio
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"6byte: %x%x%x:%d:%d\n"
operator|,
name|scsi_cmd
operator|->
name|addr
index|[
literal|0
index|]
operator|,
name|scsi_cmd
operator|->
name|addr
index|[
literal|1
index|]
operator|,
name|scsi_cmd
operator|->
name|addr
index|[
literal|2
index|]
operator|,
name|scsi_cmd
operator|->
name|length
operator|,
name|dxfer_len
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|minimum_cmd_size
operator|<
literal|12
operator|)
operator|&&
operator|(
operator|(
name|block_count
operator|&
literal|0xffff
operator|)
operator|==
name|block_count
operator|)
operator|&&
operator|(
operator|(
name|lba
operator|&
literal|0xffffffff
operator|)
operator|==
name|lba
operator|)
condition|)
block|{
comment|/* 		 * Need a 10 byte cdb. 		 */
name|struct
name|scsi_rw_10
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_rw_10
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|read
condition|?
name|READ_10
else|:
name|WRITE_10
expr_stmt|;
name|scsi_cmd
operator|->
name|byte2
operator|=
name|byte2
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|lba
argument_list|,
name|scsi_cmd
operator|->
name|addr
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|reserved
operator|=
literal|0
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|block_count
argument_list|,
name|scsi_cmd
operator|->
name|length
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|control
operator|=
literal|0
expr_stmt|;
name|cdb_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|csio
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"10byte: %x%x%x%x:%x%x: %d\n"
operator|,
name|scsi_cmd
operator|->
name|addr
index|[
literal|0
index|]
operator|,
name|scsi_cmd
operator|->
name|addr
index|[
literal|1
index|]
operator|,
name|scsi_cmd
operator|->
name|addr
index|[
literal|2
index|]
operator|,
name|scsi_cmd
operator|->
name|addr
index|[
literal|3
index|]
operator|,
name|scsi_cmd
operator|->
name|length
index|[
literal|0
index|]
operator|,
name|scsi_cmd
operator|->
name|length
index|[
literal|1
index|]
operator|,
name|dxfer_len
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|minimum_cmd_size
operator|<
literal|16
operator|)
operator|&&
operator|(
operator|(
name|block_count
operator|&
literal|0xffffffff
operator|)
operator|==
name|block_count
operator|)
operator|&&
operator|(
operator|(
name|lba
operator|&
literal|0xffffffff
operator|)
operator|==
name|lba
operator|)
condition|)
block|{
comment|/*  		 * The block count is too big for a 10 byte CDB, use a 12 		 * byte CDB. 		 */
name|struct
name|scsi_rw_12
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_rw_12
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|read
condition|?
name|READ_12
else|:
name|WRITE_12
expr_stmt|;
name|scsi_cmd
operator|->
name|byte2
operator|=
name|byte2
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|lba
argument_list|,
name|scsi_cmd
operator|->
name|addr
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|reserved
operator|=
literal|0
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|block_count
argument_list|,
name|scsi_cmd
operator|->
name|length
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|control
operator|=
literal|0
expr_stmt|;
name|cdb_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|csio
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"12byte: %x%x%x%x:%x%x%x%x: %d\n"
operator|,
name|scsi_cmd
operator|->
name|addr
index|[
literal|0
index|]
operator|,
name|scsi_cmd
operator|->
name|addr
index|[
literal|1
index|]
operator|,
name|scsi_cmd
operator|->
name|addr
index|[
literal|2
index|]
operator|,
name|scsi_cmd
operator|->
name|addr
index|[
literal|3
index|]
operator|,
name|scsi_cmd
operator|->
name|length
index|[
literal|0
index|]
operator|,
name|scsi_cmd
operator|->
name|length
index|[
literal|1
index|]
operator|,
name|scsi_cmd
operator|->
name|length
index|[
literal|2
index|]
operator|,
name|scsi_cmd
operator|->
name|length
index|[
literal|3
index|]
operator|,
name|dxfer_len
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * 16 byte CDB.  We'll only get here if the LBA is larger 		 * than 2^32, or if the user asks for a 16 byte command. 		 */
name|struct
name|scsi_rw_16
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_rw_16
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|read
condition|?
name|READ_16
else|:
name|WRITE_16
expr_stmt|;
name|scsi_cmd
operator|->
name|byte2
operator|=
name|byte2
expr_stmt|;
name|scsi_u64to8b
argument_list|(
name|lba
argument_list|,
name|scsi_cmd
operator|->
name|addr
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|reserved
operator|=
literal|0
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|block_count
argument_list|,
name|scsi_cmd
operator|->
name|length
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|control
operator|=
literal|0
expr_stmt|;
name|cdb_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
expr_stmt|;
block|}
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
operator|(
name|read
condition|?
name|CAM_DIR_IN
else|:
name|CAM_DIR_OUT
operator|)
operator||
operator|(
operator|(
name|readop
operator|&
name|SCSI_RW_BIO
operator|)
operator|!=
literal|0
condition|?
name|CAM_DATA_BIO
else|:
literal|0
operator|)
argument_list|,
name|tag_action
argument_list|,
name|data_ptr
argument_list|,
name|dxfer_len
argument_list|,
name|sense_len
argument_list|,
name|cdb_len
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_write_same
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|u_int8_t
name|byte2
parameter_list|,
name|int
name|minimum_cmd_size
parameter_list|,
name|u_int64_t
name|lba
parameter_list|,
name|u_int32_t
name|block_count
parameter_list|,
name|u_int8_t
modifier|*
name|data_ptr
parameter_list|,
name|u_int32_t
name|dxfer_len
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|u_int8_t
name|cdb_len
decl_stmt|;
if|if
condition|(
operator|(
name|minimum_cmd_size
operator|<
literal|16
operator|)
operator|&&
operator|(
operator|(
name|block_count
operator|&
literal|0xffff
operator|)
operator|==
name|block_count
operator|)
operator|&&
operator|(
operator|(
name|lba
operator|&
literal|0xffffffff
operator|)
operator|==
name|lba
operator|)
condition|)
block|{
comment|/* 		 * Need a 10 byte cdb. 		 */
name|struct
name|scsi_write_same_10
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_write_same_10
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|WRITE_SAME_10
expr_stmt|;
name|scsi_cmd
operator|->
name|byte2
operator|=
name|byte2
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|lba
argument_list|,
name|scsi_cmd
operator|->
name|addr
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|group
operator|=
literal|0
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|block_count
argument_list|,
name|scsi_cmd
operator|->
name|length
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|control
operator|=
literal|0
expr_stmt|;
name|cdb_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|csio
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"10byte: %x%x%x%x:%x%x: %d\n"
operator|,
name|scsi_cmd
operator|->
name|addr
index|[
literal|0
index|]
operator|,
name|scsi_cmd
operator|->
name|addr
index|[
literal|1
index|]
operator|,
name|scsi_cmd
operator|->
name|addr
index|[
literal|2
index|]
operator|,
name|scsi_cmd
operator|->
name|addr
index|[
literal|3
index|]
operator|,
name|scsi_cmd
operator|->
name|length
index|[
literal|0
index|]
operator|,
name|scsi_cmd
operator|->
name|length
index|[
literal|1
index|]
operator|,
name|dxfer_len
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * 16 byte CDB.  We'll only get here if the LBA is larger 		 * than 2^32, or if the user asks for a 16 byte command. 		 */
name|struct
name|scsi_write_same_16
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_write_same_16
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|WRITE_SAME_16
expr_stmt|;
name|scsi_cmd
operator|->
name|byte2
operator|=
name|byte2
expr_stmt|;
name|scsi_u64to8b
argument_list|(
name|lba
argument_list|,
name|scsi_cmd
operator|->
name|addr
argument_list|)
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|block_count
argument_list|,
name|scsi_cmd
operator|->
name|length
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|group
operator|=
literal|0
expr_stmt|;
name|scsi_cmd
operator|->
name|control
operator|=
literal|0
expr_stmt|;
name|cdb_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|csio
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"16byte: %x%x%x%x%x%x%x%x:%x%x%x%x: %d\n"
operator|,
name|scsi_cmd
operator|->
name|addr
index|[
literal|0
index|]
operator|,
name|scsi_cmd
operator|->
name|addr
index|[
literal|1
index|]
operator|,
name|scsi_cmd
operator|->
name|addr
index|[
literal|2
index|]
operator|,
name|scsi_cmd
operator|->
name|addr
index|[
literal|3
index|]
operator|,
name|scsi_cmd
operator|->
name|addr
index|[
literal|4
index|]
operator|,
name|scsi_cmd
operator|->
name|addr
index|[
literal|5
index|]
operator|,
name|scsi_cmd
operator|->
name|addr
index|[
literal|6
index|]
operator|,
name|scsi_cmd
operator|->
name|addr
index|[
literal|7
index|]
operator|,
name|scsi_cmd
operator|->
name|length
index|[
literal|0
index|]
operator|,
name|scsi_cmd
operator|->
name|length
index|[
literal|1
index|]
operator|,
name|scsi_cmd
operator|->
name|length
index|[
literal|2
index|]
operator|,
name|scsi_cmd
operator|->
name|length
index|[
literal|3
index|]
operator|,
name|dxfer_len
operator|)
argument_list|)
expr_stmt|;
block|}
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|CAM_DIR_OUT
argument_list|,
name|tag_action
argument_list|,
name|data_ptr
argument_list|,
name|dxfer_len
argument_list|,
name|sense_len
argument_list|,
name|cdb_len
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_ata_identify
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|u_int8_t
modifier|*
name|data_ptr
parameter_list|,
name|u_int16_t
name|dxfer_len
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|scsi_ata_pass_16
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|CAM_DIR_IN
argument_list|,
name|tag_action
argument_list|,
comment|/*protocol*/
name|AP_PROTO_PIO_IN
argument_list|,
comment|/*ata_flags*/
name|AP_FLAG_TDIR_FROM_DEV
operator||
name|AP_FLAG_BYT_BLOK_BYTES
operator||
name|AP_FLAG_TLEN_SECT_CNT
argument_list|,
comment|/*features*/
literal|0
argument_list|,
comment|/*sector_count*/
name|dxfer_len
argument_list|,
comment|/*lba*/
literal|0
argument_list|,
comment|/*command*/
name|ATA_ATA_IDENTIFY
argument_list|,
comment|/*control*/
literal|0
argument_list|,
name|data_ptr
argument_list|,
name|dxfer_len
argument_list|,
name|sense_len
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_ata_trim
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|u_int16_t
name|block_count
parameter_list|,
name|u_int8_t
modifier|*
name|data_ptr
parameter_list|,
name|u_int16_t
name|dxfer_len
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|scsi_ata_pass_16
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|CAM_DIR_OUT
argument_list|,
name|tag_action
argument_list|,
comment|/*protocol*/
name|AP_EXTEND
operator||
name|AP_PROTO_DMA
argument_list|,
comment|/*ata_flags*/
name|AP_FLAG_TLEN_SECT_CNT
operator||
name|AP_FLAG_BYT_BLOK_BLOCKS
argument_list|,
comment|/*features*/
name|ATA_DSM_TRIM
argument_list|,
comment|/*sector_count*/
name|block_count
argument_list|,
comment|/*lba*/
literal|0
argument_list|,
comment|/*command*/
name|ATA_DATA_SET_MANAGEMENT
argument_list|,
comment|/*control*/
literal|0
argument_list|,
name|data_ptr
argument_list|,
name|dxfer_len
argument_list|,
name|sense_len
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_ata_pass_16
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int32_t
name|flags
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|u_int8_t
name|protocol
parameter_list|,
name|u_int8_t
name|ata_flags
parameter_list|,
name|u_int16_t
name|features
parameter_list|,
name|u_int16_t
name|sector_count
parameter_list|,
name|uint64_t
name|lba
parameter_list|,
name|u_int8_t
name|command
parameter_list|,
name|u_int8_t
name|control
parameter_list|,
name|u_int8_t
modifier|*
name|data_ptr
parameter_list|,
name|u_int16_t
name|dxfer_len
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|ata_pass_16
modifier|*
name|ata_cmd
decl_stmt|;
name|ata_cmd
operator|=
operator|(
expr|struct
name|ata_pass_16
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|ata_cmd
operator|->
name|opcode
operator|=
name|ATA_PASS_16
expr_stmt|;
name|ata_cmd
operator|->
name|protocol
operator|=
name|protocol
expr_stmt|;
name|ata_cmd
operator|->
name|flags
operator|=
name|ata_flags
expr_stmt|;
name|ata_cmd
operator|->
name|features_ext
operator|=
name|features
operator|>>
literal|8
expr_stmt|;
name|ata_cmd
operator|->
name|features
operator|=
name|features
expr_stmt|;
name|ata_cmd
operator|->
name|sector_count_ext
operator|=
name|sector_count
operator|>>
literal|8
expr_stmt|;
name|ata_cmd
operator|->
name|sector_count
operator|=
name|sector_count
expr_stmt|;
name|ata_cmd
operator|->
name|lba_low
operator|=
name|lba
expr_stmt|;
name|ata_cmd
operator|->
name|lba_mid
operator|=
name|lba
operator|>>
literal|8
expr_stmt|;
name|ata_cmd
operator|->
name|lba_high
operator|=
name|lba
operator|>>
literal|16
expr_stmt|;
name|ata_cmd
operator|->
name|device
operator|=
name|ATA_DEV_LBA
expr_stmt|;
if|if
condition|(
name|protocol
operator|&
name|AP_EXTEND
condition|)
block|{
name|ata_cmd
operator|->
name|lba_low_ext
operator|=
name|lba
operator|>>
literal|24
expr_stmt|;
name|ata_cmd
operator|->
name|lba_mid_ext
operator|=
name|lba
operator|>>
literal|32
expr_stmt|;
name|ata_cmd
operator|->
name|lba_high_ext
operator|=
name|lba
operator|>>
literal|40
expr_stmt|;
block|}
else|else
name|ata_cmd
operator|->
name|device
operator||=
operator|(
name|lba
operator|>>
literal|24
operator|)
operator|&
literal|0x0f
expr_stmt|;
name|ata_cmd
operator|->
name|command
operator|=
name|command
expr_stmt|;
name|ata_cmd
operator|->
name|control
operator|=
name|control
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
name|flags
argument_list|,
name|tag_action
argument_list|,
name|data_ptr
argument_list|,
name|dxfer_len
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ata_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_unmap
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|u_int8_t
name|byte2
parameter_list|,
name|u_int8_t
modifier|*
name|data_ptr
parameter_list|,
name|u_int16_t
name|dxfer_len
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_unmap
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_unmap
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|UNMAP
expr_stmt|;
name|scsi_cmd
operator|->
name|byte2
operator|=
name|byte2
expr_stmt|;
name|scsi_ulto4b
argument_list|(
literal|0
argument_list|,
name|scsi_cmd
operator|->
name|reserved
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|group
operator|=
literal|0
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|dxfer_len
argument_list|,
name|scsi_cmd
operator|->
name|length
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|control
operator|=
literal|0
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|CAM_DIR_OUT
argument_list|,
name|tag_action
argument_list|,
name|data_ptr
argument_list|,
name|dxfer_len
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_receive_diagnostic_results
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|uint8_t
name|tag_action
parameter_list|,
name|int
name|pcv
parameter_list|,
name|uint8_t
name|page_code
parameter_list|,
name|uint8_t
modifier|*
name|data_ptr
parameter_list|,
name|uint16_t
name|allocation_length
parameter_list|,
name|uint8_t
name|sense_len
parameter_list|,
name|uint32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_receive_diag
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_receive_diag
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|memset
argument_list|(
name|scsi_cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|RECEIVE_DIAGNOSTIC
expr_stmt|;
if|if
condition|(
name|pcv
condition|)
block|{
name|scsi_cmd
operator|->
name|byte2
operator||=
name|SRD_PCV
expr_stmt|;
name|scsi_cmd
operator|->
name|page_code
operator|=
name|page_code
expr_stmt|;
block|}
name|scsi_ulto2b
argument_list|(
name|allocation_length
argument_list|,
name|scsi_cmd
operator|->
name|length
argument_list|)
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|CAM_DIR_IN
argument_list|,
name|tag_action
argument_list|,
name|data_ptr
argument_list|,
name|allocation_length
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_send_diagnostic
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|uint8_t
name|tag_action
parameter_list|,
name|int
name|unit_offline
parameter_list|,
name|int
name|device_offline
parameter_list|,
name|int
name|self_test
parameter_list|,
name|int
name|page_format
parameter_list|,
name|int
name|self_test_code
parameter_list|,
name|uint8_t
modifier|*
name|data_ptr
parameter_list|,
name|uint16_t
name|param_list_length
parameter_list|,
name|uint8_t
name|sense_len
parameter_list|,
name|uint32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_send_diag
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_send_diag
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|memset
argument_list|(
name|scsi_cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|SEND_DIAGNOSTIC
expr_stmt|;
comment|/* 	 * The default self-test mode control and specific test 	 * control are mutually exclusive. 	 */
if|if
condition|(
name|self_test
condition|)
name|self_test_code
operator|=
name|SSD_SELF_TEST_CODE_NONE
expr_stmt|;
name|scsi_cmd
operator|->
name|byte2
operator|=
operator|(
operator|(
name|self_test_code
operator|<<
name|SSD_SELF_TEST_CODE_SHIFT
operator|)
operator|&
name|SSD_SELF_TEST_CODE_MASK
operator|)
operator||
operator|(
name|unit_offline
condition|?
name|SSD_UNITOFFL
else|:
literal|0
operator|)
operator||
operator|(
name|device_offline
condition|?
name|SSD_DEVOFFL
else|:
literal|0
operator|)
operator||
operator|(
name|self_test
condition|?
name|SSD_SELFTEST
else|:
literal|0
operator|)
operator||
operator|(
name|page_format
condition|?
name|SSD_PF
else|:
literal|0
operator|)
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|param_list_length
argument_list|,
name|scsi_cmd
operator|->
name|length
argument_list|)
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|param_list_length
condition|?
name|CAM_DIR_OUT
else|:
name|CAM_DIR_NONE
argument_list|,
name|tag_action
argument_list|,
name|data_ptr
argument_list|,
name|param_list_length
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_read_buffer
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|uint8_t
name|tag_action
parameter_list|,
name|int
name|mode
parameter_list|,
name|uint8_t
name|buffer_id
parameter_list|,
name|u_int32_t
name|offset
parameter_list|,
name|uint8_t
modifier|*
name|data_ptr
parameter_list|,
name|uint32_t
name|allocation_length
parameter_list|,
name|uint8_t
name|sense_len
parameter_list|,
name|uint32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_read_buffer
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_read_buffer
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|memset
argument_list|(
name|scsi_cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|READ_BUFFER
expr_stmt|;
name|scsi_cmd
operator|->
name|byte2
operator|=
name|mode
expr_stmt|;
name|scsi_cmd
operator|->
name|buffer_id
operator|=
name|buffer_id
expr_stmt|;
name|scsi_ulto3b
argument_list|(
name|offset
argument_list|,
name|scsi_cmd
operator|->
name|offset
argument_list|)
expr_stmt|;
name|scsi_ulto3b
argument_list|(
name|allocation_length
argument_list|,
name|scsi_cmd
operator|->
name|length
argument_list|)
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|CAM_DIR_IN
argument_list|,
name|tag_action
argument_list|,
name|data_ptr
argument_list|,
name|allocation_length
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_write_buffer
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|uint8_t
name|tag_action
parameter_list|,
name|int
name|mode
parameter_list|,
name|uint8_t
name|buffer_id
parameter_list|,
name|u_int32_t
name|offset
parameter_list|,
name|uint8_t
modifier|*
name|data_ptr
parameter_list|,
name|uint32_t
name|param_list_length
parameter_list|,
name|uint8_t
name|sense_len
parameter_list|,
name|uint32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_write_buffer
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_write_buffer
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|memset
argument_list|(
name|scsi_cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|WRITE_BUFFER
expr_stmt|;
name|scsi_cmd
operator|->
name|byte2
operator|=
name|mode
expr_stmt|;
name|scsi_cmd
operator|->
name|buffer_id
operator|=
name|buffer_id
expr_stmt|;
name|scsi_ulto3b
argument_list|(
name|offset
argument_list|,
name|scsi_cmd
operator|->
name|offset
argument_list|)
expr_stmt|;
name|scsi_ulto3b
argument_list|(
name|param_list_length
argument_list|,
name|scsi_cmd
operator|->
name|length
argument_list|)
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|param_list_length
condition|?
name|CAM_DIR_OUT
else|:
name|CAM_DIR_NONE
argument_list|,
name|tag_action
argument_list|,
name|data_ptr
argument_list|,
name|param_list_length
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_start_stop
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|load_eject
parameter_list|,
name|int
name|immediate
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_start_stop_unit
modifier|*
name|scsi_cmd
decl_stmt|;
name|int
name|extra_flags
init|=
literal|0
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_start_stop_unit
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|START_STOP_UNIT
expr_stmt|;
if|if
condition|(
name|start
operator|!=
literal|0
condition|)
block|{
name|scsi_cmd
operator|->
name|how
operator||=
name|SSS_START
expr_stmt|;
comment|/* it takes a lot of power to start a drive */
name|extra_flags
operator||=
name|CAM_HIGH_POWER
expr_stmt|;
block|}
if|if
condition|(
name|load_eject
operator|!=
literal|0
condition|)
name|scsi_cmd
operator|->
name|how
operator||=
name|SSS_LOEJ
expr_stmt|;
if|if
condition|(
name|immediate
operator|!=
literal|0
condition|)
name|scsi_cmd
operator|->
name|byte2
operator||=
name|SSS_IMMED
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|CAM_DIR_NONE
operator||
name|extra_flags
argument_list|,
name|tag_action
argument_list|,
comment|/*data_ptr*/
name|NULL
argument_list|,
comment|/*dxfer_len*/
literal|0
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_persistent_reserve_in
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|uint32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|uint8_t
name|tag_action
parameter_list|,
name|int
name|service_action
parameter_list|,
name|uint8_t
modifier|*
name|data_ptr
parameter_list|,
name|uint32_t
name|dxfer_len
parameter_list|,
name|int
name|sense_len
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_per_res_in
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_per_res_in
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|PERSISTENT_RES_IN
expr_stmt|;
name|scsi_cmd
operator|->
name|action
operator|=
name|service_action
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|dxfer_len
argument_list|,
name|scsi_cmd
operator|->
name|length
argument_list|)
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|CAM_DIR_IN
argument_list|,
name|tag_action
argument_list|,
name|data_ptr
argument_list|,
name|dxfer_len
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_persistent_reserve_out
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|uint32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|uint8_t
name|tag_action
parameter_list|,
name|int
name|service_action
parameter_list|,
name|int
name|scope
parameter_list|,
name|int
name|res_type
parameter_list|,
name|uint8_t
modifier|*
name|data_ptr
parameter_list|,
name|uint32_t
name|dxfer_len
parameter_list|,
name|int
name|sense_len
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_per_res_out
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_per_res_out
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|PERSISTENT_RES_OUT
expr_stmt|;
name|scsi_cmd
operator|->
name|action
operator|=
name|service_action
expr_stmt|;
name|scsi_cmd
operator|->
name|scope_type
operator|=
name|scope
operator||
name|res_type
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|dxfer_len
argument_list|,
name|scsi_cmd
operator|->
name|length
argument_list|)
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|CAM_DIR_OUT
argument_list|,
name|tag_action
argument_list|,
name|data_ptr
argument_list|,
name|dxfer_len
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*        * Try make as good a match as possible with  * available sub drivers  */
end_comment

begin_function
name|int
name|scsi_inquiry_match
parameter_list|(
name|caddr_t
name|inqbuffer
parameter_list|,
name|caddr_t
name|table_entry
parameter_list|)
block|{
name|struct
name|scsi_inquiry_pattern
modifier|*
name|entry
decl_stmt|;
name|struct
name|scsi_inquiry_data
modifier|*
name|inq
decl_stmt|;
name|entry
operator|=
operator|(
expr|struct
name|scsi_inquiry_pattern
operator|*
operator|)
name|table_entry
expr_stmt|;
name|inq
operator|=
operator|(
expr|struct
name|scsi_inquiry_data
operator|*
operator|)
name|inqbuffer
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|SID_TYPE
argument_list|(
name|inq
argument_list|)
operator|==
name|entry
operator|->
name|type
operator|)
operator|||
operator|(
name|entry
operator|->
name|type
operator|==
name|T_ANY
operator|)
operator|)
operator|&&
operator|(
name|SID_IS_REMOVABLE
argument_list|(
name|inq
argument_list|)
condition|?
name|entry
operator|->
name|media_type
operator|&
name|SIP_MEDIA_REMOVABLE
else|:
name|entry
operator|->
name|media_type
operator|&
name|SIP_MEDIA_FIXED
operator|)
operator|&&
operator|(
name|cam_strmatch
argument_list|(
name|inq
operator|->
name|vendor
argument_list|,
name|entry
operator|->
name|vendor
argument_list|,
sizeof|sizeof
argument_list|(
name|inq
operator|->
name|vendor
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|cam_strmatch
argument_list|(
name|inq
operator|->
name|product
argument_list|,
name|entry
operator|->
name|product
argument_list|,
sizeof|sizeof
argument_list|(
name|inq
operator|->
name|product
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|cam_strmatch
argument_list|(
name|inq
operator|->
name|revision
argument_list|,
name|entry
operator|->
name|revision
argument_list|,
sizeof|sizeof
argument_list|(
name|inq
operator|->
name|revision
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*        * Try make as good a match as possible with  * available sub drivers  */
end_comment

begin_function
name|int
name|scsi_static_inquiry_match
parameter_list|(
name|caddr_t
name|inqbuffer
parameter_list|,
name|caddr_t
name|table_entry
parameter_list|)
block|{
name|struct
name|scsi_static_inquiry_pattern
modifier|*
name|entry
decl_stmt|;
name|struct
name|scsi_inquiry_data
modifier|*
name|inq
decl_stmt|;
name|entry
operator|=
operator|(
expr|struct
name|scsi_static_inquiry_pattern
operator|*
operator|)
name|table_entry
expr_stmt|;
name|inq
operator|=
operator|(
expr|struct
name|scsi_inquiry_data
operator|*
operator|)
name|inqbuffer
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|SID_TYPE
argument_list|(
name|inq
argument_list|)
operator|==
name|entry
operator|->
name|type
operator|)
operator|||
operator|(
name|entry
operator|->
name|type
operator|==
name|T_ANY
operator|)
operator|)
operator|&&
operator|(
name|SID_IS_REMOVABLE
argument_list|(
name|inq
argument_list|)
condition|?
name|entry
operator|->
name|media_type
operator|&
name|SIP_MEDIA_REMOVABLE
else|:
name|entry
operator|->
name|media_type
operator|&
name|SIP_MEDIA_FIXED
operator|)
operator|&&
operator|(
name|cam_strmatch
argument_list|(
name|inq
operator|->
name|vendor
argument_list|,
name|entry
operator|->
name|vendor
argument_list|,
sizeof|sizeof
argument_list|(
name|inq
operator|->
name|vendor
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|cam_strmatch
argument_list|(
name|inq
operator|->
name|product
argument_list|,
name|entry
operator|->
name|product
argument_list|,
sizeof|sizeof
argument_list|(
name|inq
operator|->
name|product
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|cam_strmatch
argument_list|(
name|inq
operator|->
name|revision
argument_list|,
name|entry
operator|->
name|revision
argument_list|,
sizeof|sizeof
argument_list|(
name|inq
operator|->
name|revision
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Compare two buffers of vpd device descriptors for a match.  *  * \param lhs      Pointer to first buffer of descriptors to compare.  * \param lhs_len  The length of the first buffer.  * \param rhs	   Pointer to second buffer of descriptors to compare.  * \param rhs_len  The length of the second buffer.  *  * \return  0 on a match, -1 otherwise.  *  * Treat rhs and lhs as arrays of vpd device id descriptors.  Walk lhs matching  * agains each element in rhs until all data are exhausted or we have found  * a match.  */
end_comment

begin_function
name|int
name|scsi_devid_match
parameter_list|(
name|uint8_t
modifier|*
name|lhs
parameter_list|,
name|size_t
name|lhs_len
parameter_list|,
name|uint8_t
modifier|*
name|rhs
parameter_list|,
name|size_t
name|rhs_len
parameter_list|)
block|{
name|struct
name|scsi_vpd_id_descriptor
modifier|*
name|lhs_id
decl_stmt|;
name|struct
name|scsi_vpd_id_descriptor
modifier|*
name|lhs_last
decl_stmt|;
name|struct
name|scsi_vpd_id_descriptor
modifier|*
name|rhs_last
decl_stmt|;
name|uint8_t
modifier|*
name|lhs_end
decl_stmt|;
name|uint8_t
modifier|*
name|rhs_end
decl_stmt|;
name|lhs_end
operator|=
name|lhs
operator|+
name|lhs_len
expr_stmt|;
name|rhs_end
operator|=
name|rhs
operator|+
name|rhs_len
expr_stmt|;
comment|/* 	 * rhs_last and lhs_last are the last posible position of a valid 	 * descriptor assuming it had a zero length identifier.  We use 	 * these variables to insure we can safely dereference the length 	 * field in our loop termination tests. 	 */
name|lhs_last
operator|=
operator|(
expr|struct
name|scsi_vpd_id_descriptor
operator|*
operator|)
operator|(
name|lhs_end
operator|-
name|__offsetof
argument_list|(
expr|struct
name|scsi_vpd_id_descriptor
argument_list|,
name|identifier
argument_list|)
operator|)
expr_stmt|;
name|rhs_last
operator|=
operator|(
expr|struct
name|scsi_vpd_id_descriptor
operator|*
operator|)
operator|(
name|rhs_end
operator|-
name|__offsetof
argument_list|(
expr|struct
name|scsi_vpd_id_descriptor
argument_list|,
name|identifier
argument_list|)
operator|)
expr_stmt|;
name|lhs_id
operator|=
operator|(
expr|struct
name|scsi_vpd_id_descriptor
operator|*
operator|)
name|lhs
expr_stmt|;
while|while
condition|(
name|lhs_id
operator|<=
name|lhs_last
operator|&&
operator|(
name|lhs_id
operator|->
name|identifier
operator|+
name|lhs_id
operator|->
name|length
operator|)
operator|<=
name|lhs_end
condition|)
block|{
name|struct
name|scsi_vpd_id_descriptor
modifier|*
name|rhs_id
decl_stmt|;
name|rhs_id
operator|=
operator|(
expr|struct
name|scsi_vpd_id_descriptor
operator|*
operator|)
name|rhs
expr_stmt|;
while|while
condition|(
name|rhs_id
operator|<=
name|rhs_last
operator|&&
operator|(
name|rhs_id
operator|->
name|identifier
operator|+
name|rhs_id
operator|->
name|length
operator|)
operator|<=
name|rhs_end
condition|)
block|{
if|if
condition|(
operator|(
name|rhs_id
operator|->
name|id_type
operator|&
operator|(
name|SVPD_ID_ASSOC_MASK
operator||
name|SVPD_ID_TYPE_MASK
operator|)
operator|)
operator|==
operator|(
name|lhs_id
operator|->
name|id_type
operator|&
operator|(
name|SVPD_ID_ASSOC_MASK
operator||
name|SVPD_ID_TYPE_MASK
operator|)
operator|)
operator|&&
name|rhs_id
operator|->
name|length
operator|==
name|lhs_id
operator|->
name|length
operator|&&
name|memcmp
argument_list|(
name|rhs_id
operator|->
name|identifier
argument_list|,
name|lhs_id
operator|->
name|identifier
argument_list|,
name|rhs_id
operator|->
name|length
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|rhs_id
operator|=
operator|(
expr|struct
name|scsi_vpd_id_descriptor
operator|*
operator|)
operator|(
name|rhs_id
operator|->
name|identifier
operator|+
name|rhs_id
operator|->
name|length
operator|)
expr_stmt|;
block|}
name|lhs_id
operator|=
operator|(
expr|struct
name|scsi_vpd_id_descriptor
operator|*
operator|)
operator|(
name|lhs_id
operator|->
name|identifier
operator|+
name|lhs_id
operator|->
name|length
operator|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_function
name|int
name|scsi_vpd_supported_page
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|uint8_t
name|page_id
parameter_list|)
block|{
name|struct
name|cam_ed
modifier|*
name|device
decl_stmt|;
name|struct
name|scsi_vpd_supported_pages
modifier|*
name|vpds
decl_stmt|;
name|int
name|i
decl_stmt|,
name|num_pages
decl_stmt|;
name|device
operator|=
name|periph
operator|->
name|path
operator|->
name|device
expr_stmt|;
name|vpds
operator|=
operator|(
expr|struct
name|scsi_vpd_supported_pages
operator|*
operator|)
name|device
operator|->
name|supported_vpds
expr_stmt|;
if|if
condition|(
name|vpds
operator|!=
name|NULL
condition|)
block|{
name|num_pages
operator|=
name|device
operator|->
name|supported_vpds_len
operator|-
name|SVPD_SUPPORTED_PAGES_HDR_LEN
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_pages
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|vpds
operator|->
name|page_list
index|[
name|i
index|]
operator|==
name|page_id
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_scsi_delay
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|delay
decl_stmt|;
name|delay
operator|=
name|SCSI_DELAY
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"kern.cam.scsi_delay"
argument_list|,
operator|&
name|delay
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_scsi_delay
argument_list|(
name|delay
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"cam: invalid value for tunable kern.cam.scsi_delay\n"
argument_list|)
expr_stmt|;
name|set_scsi_delay
argument_list|(
name|SCSI_DELAY
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|scsi_delay
argument_list|,
name|SI_SUB_TUNABLES
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|init_scsi_delay
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|sysctl_scsi_delay
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|delay
decl_stmt|;
name|delay
operator|=
name|scsi_delay
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|delay
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
name|set_scsi_delay
argument_list|(
name|delay
argument_list|)
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern_cam
argument_list|,
name|OID_AUTO
argument_list|,
name|scsi_delay
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sysctl_scsi_delay
argument_list|,
literal|"I"
argument_list|,
literal|"Delay to allow devices to settle after a SCSI bus reset (ms)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|set_scsi_delay
parameter_list|(
name|int
name|delay
parameter_list|)
block|{
comment|/*          * If someone sets this to 0, we assume that they want the          * minimum allowable bus settle delay. 	 */
if|if
condition|(
name|delay
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"cam: using minimum scsi_delay (%dms)\n"
argument_list|,
name|SCSI_MIN_DELAY
argument_list|)
expr_stmt|;
name|delay
operator|=
name|SCSI_MIN_DELAY
expr_stmt|;
block|}
if|if
condition|(
name|delay
operator|<
name|SCSI_MIN_DELAY
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|scsi_delay
operator|=
name|delay
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _KERNEL */
end_comment

end_unit

