begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Implementation of Utility functions for all SCSI device types.  *  * Copyright (c) 1997, 1998, 1999 Justin T. Gibbs.  * Copyright (c) 1997, 1998, 2003 Kenneth D. Merry.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<opt_scsi.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/libkern.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|_KERNEL
end_ifndef

begin_include
include|#
directive|include
file|<camlib.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|FALSE
end_ifndef

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FALSE */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TRUE
end_ifndef

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TRUE */
end_comment

begin_define
define|#
directive|define
name|ERESTART
value|-1
end_define

begin_comment
comment|/* restart syscall */
end_comment

begin_define
define|#
directive|define
name|EJUSTRETURN
value|-2
end_define

begin_comment
comment|/* don't modify regs, just return */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !_KERNEL */
end_comment

begin_comment
comment|/*  * This is the default number of seconds we wait for devices to settle  * after a SCSI bus reset.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SCSI_DELAY
end_ifndef

begin_define
define|#
directive|define
name|SCSI_DELAY
value|2000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * All devices need _some_ sort of bus settle delay, so we'll set it to  * a minimum value of 100ms. Note that this is pertinent only for SPI-  * not transport like Fibre Channel or iSCSI where 'delay' is completely  * meaningless.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SCSI_MIN_DELAY
end_ifndef

begin_define
define|#
directive|define
name|SCSI_MIN_DELAY
value|100
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Make sure the user isn't using seconds instead of milliseconds.  */
end_comment

begin_if
if|#
directive|if
operator|(
name|SCSI_DELAY
operator|<
name|SCSI_MIN_DELAY
operator|&&
name|SCSI_DELAY
operator|!=
literal|0
operator|)
end_if

begin_error
error|#
directive|error
literal|"SCSI_DELAY is in milliseconds, not seconds!  Please use a larger value"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|scsi_delay
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|ascentrycomp
parameter_list|(
specifier|const
name|void
modifier|*
name|key
parameter_list|,
specifier|const
name|void
modifier|*
name|member
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|senseentrycomp
parameter_list|(
specifier|const
name|void
modifier|*
name|key
parameter_list|,
specifier|const
name|void
modifier|*
name|member
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fetchtableentries
parameter_list|(
name|int
name|sense_key
parameter_list|,
name|int
name|asc
parameter_list|,
name|int
name|ascq
parameter_list|,
name|struct
name|scsi_inquiry_data
modifier|*
parameter_list|,
specifier|const
name|struct
name|sense_key_table_entry
modifier|*
modifier|*
parameter_list|,
specifier|const
name|struct
name|asc_table_entry
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_function_decl
specifier|static
name|void
name|init_scsi_delay
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_scsi_delay
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_scsi_delay
parameter_list|(
name|int
name|delay
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SCSI_NO_OP_STRINGS
argument_list|)
end_if

begin_define
define|#
directive|define
name|D
value|0x001
end_define

begin_define
define|#
directive|define
name|T
value|0x002
end_define

begin_define
define|#
directive|define
name|L
value|0x004
end_define

begin_define
define|#
directive|define
name|P
value|0x008
end_define

begin_define
define|#
directive|define
name|W
value|0x010
end_define

begin_define
define|#
directive|define
name|R
value|0x020
end_define

begin_define
define|#
directive|define
name|S
value|0x040
end_define

begin_define
define|#
directive|define
name|O
value|0x080
end_define

begin_define
define|#
directive|define
name|M
value|0x100
end_define

begin_define
define|#
directive|define
name|C
value|0x200
end_define

begin_define
define|#
directive|define
name|A
value|0x400
end_define

begin_define
define|#
directive|define
name|E
value|0x800
end_define

begin_define
define|#
directive|define
name|ALL
value|0xFFF
end_define

begin_decl_stmt
specifier|static
name|struct
name|op_table_entry
name|plextor_cd_ops
index|[]
init|=
block|{
block|{
literal|0xD8
block|,
name|R
block|,
literal|"CD-DA READ"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|scsi_op_quirk_entry
name|scsi_op_quirk_table
index|[]
init|=
block|{
block|{
comment|/* 		 * I believe that 0xD8 is the Plextor proprietary command 		 * to read CD-DA data.  I'm not sure which Plextor CDROM 		 * models support the command, though.  I know for sure 		 * that the 4X, 8X, and 12X models do, and presumably the 		 * 12-20X does.  I don't know about any earlier models, 		 * though.  If anyone has any more complete information, 		 * feel free to change this quirk entry. 		 */
block|{
name|T_CDROM
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"PLEXTOR"
block|,
literal|"CD-ROM PX*"
block|,
literal|"*"
block|}
block|,
sizeof|sizeof
argument_list|(
name|plextor_cd_ops
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|op_table_entry
argument_list|)
block|,
name|plextor_cd_ops
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|op_table_entry
name|scsi_op_codes
index|[]
init|=
block|{
comment|/*  * From: ftp://ftp.symbios.com/pub/standards/io/t10/drafts/spc/op-num.txt  * Modifications by Kenneth Merry (ken@FreeBSD.ORG)  *  * Note:  order is important in this table, scsi_op_desc() currently  * depends on the opcodes in the table being in order to save search time.  */
comment|/*    * File: OP-NUM.TXT  *  * SCSI Operation Codes  * Numeric Sorted Listing  * as of 11/13/96  *   *     D - DIRECT ACCESS DEVICE (SBC)                    device column key  *     .T - SEQUENTIAL ACCESS DEVICE (SSC)              -------------------  *     . L - PRINTER DEVICE (SSC)                       M = Mandatory  *     .  P - PROCESSOR DEVICE (SPC)                    O = Optional  *     .  .W - WRITE ONCE READ MULTIPLE DEVICE (SBC)    V = Vendor specific  *     .  . R - CD DEVICE (MMC)                         R = Reserved  *     .  .  S - SCANNER DEVICE (SGC)                   Z = Obsolete  *     .  .  .O - OPTICAL MEMORY DEVICE (SBC)  *     .  .  . M - MEDIA CHANGER DEVICE (SMC)  *     .  .  .  C - COMMUNICATION DEVICE (SSC)  *     .  .  .  .A - STORAGE ARRAY DEVICE (SCC)  *     .  .  .  . E - ENCLOSURE SERVICES DEVICE (SES)  * OP  DTLPWRSOMCAE  Description  * --  ------------  ---------------------------------------------------- */
comment|/* 00  MMMMMMMMMMMM  TEST UNIT READY */
block|{
literal|0x00
block|,
name|ALL
block|,
literal|"TEST UNIT READY"
block|}
block|,
comment|/* 01   M            REWIND */
block|{
literal|0x01
block|,
name|T
block|,
literal|"REWIND"
block|}
block|,
comment|/* 01  Z V ZO ZO     REZERO UNIT */
block|{
literal|0x01
block|,
name|D
operator||
name|L
operator||
name|W
operator||
name|O
operator||
name|M
block|,
literal|"REZERO UNIT"
block|}
block|,
comment|/* 02  VVVVVV  V   */
comment|/* 03  MMMMMMMMMMMM  REQUEST SENSE */
block|{
literal|0x03
block|,
name|ALL
block|,
literal|"REQUEST SENSE"
block|}
block|,
comment|/* 04  M    O O      FORMAT UNIT */
block|{
literal|0x04
block|,
name|D
operator||
name|R
operator||
name|O
block|,
literal|"FORMAT UNIT"
block|}
block|,
comment|/* 04   O            FORMAT MEDIUM */
block|{
literal|0x04
block|,
name|T
block|,
literal|"FORMAT MEDIUM"
block|}
block|,
comment|/* 04    O           FORMAT */
block|{
literal|0x04
block|,
name|L
block|,
literal|"FORMAT"
block|}
block|,
comment|/* 05  VMVVVV  V     READ BLOCK LIMITS */
block|{
literal|0x05
block|,
name|T
block|,
literal|"READ BLOCK LIMITS"
block|}
block|,
comment|/* 06  VVVVVV  V   */
comment|/* 07  OVV O  OV     REASSIGN BLOCKS */
block|{
literal|0x07
block|,
name|D
operator||
name|W
operator||
name|O
block|,
literal|"REASSIGN BLOCKS"
block|}
block|,
comment|/* 07          O     INITIALIZE ELEMENT STATUS */
block|{
literal|0x07
block|,
name|M
block|,
literal|"INITIALIZE ELEMENT STATUS"
block|}
block|,
comment|/* 08  OMV OO OV     READ(06) */
block|{
literal|0x08
block|,
name|D
operator||
name|T
operator||
name|W
operator||
name|R
operator||
name|O
block|,
literal|"READ(06)"
block|}
block|,
comment|/* 08     O          RECEIVE */
block|{
literal|0x08
block|,
name|P
block|,
literal|"RECEIVE"
block|}
block|,
comment|/* 08           M    GET MESSAGE(06) */
block|{
literal|0x08
block|,
name|C
block|,
literal|"GET MESSAGE(06)"
block|}
block|,
comment|/* 09  VVVVVV  V   */
comment|/* 0A  OM  O  OV     WRITE(06) */
block|{
literal|0x0A
block|,
name|D
operator||
name|T
operator||
name|W
operator||
name|O
block|,
literal|"WRITE(06)"
block|}
block|,
comment|/* 0A     M          SEND(06) */
block|{
literal|0x0A
block|,
name|P
block|,
literal|"SEND(06)"
block|}
block|,
comment|/* 0A           M    SEND MESSAGE(06) */
block|{
literal|0x0A
block|,
name|C
block|,
literal|"SEND MESSAGE(06)"
block|}
block|,
comment|/* 0A    M           PRINT */
block|{
literal|0x0A
block|,
name|L
block|,
literal|"PRINT"
block|}
block|,
comment|/* 0B  Z   ZO ZV     SEEK(06) */
block|{
literal|0x0B
block|,
name|D
operator||
name|W
operator||
name|R
operator||
name|O
block|,
literal|"SEEK(06)"
block|}
block|,
comment|/* 0B    O           SLEW AND PRINT */
block|{
literal|0x0B
block|,
name|L
block|,
literal|"SLEW AND PRINT"
block|}
block|,
comment|/* 0C  VVVVVV  V   */
comment|/* 0D  VVVVVV  V   */
comment|/* 0E  VVVVVV  V   */
comment|/* 0F  VOVVVV  V     READ REVERSE */
block|{
literal|0x0F
block|,
name|T
block|,
literal|"READ REVERSE"
block|}
block|,
comment|/* 10  VM VVV        WRITE FILEMARKS */
block|{
literal|0x10
block|,
name|T
block|,
literal|"WRITE FILEMARKS"
block|}
block|,
comment|/* 10    O O         SYNCHRONIZE BUFFER */
block|{
literal|0x10
block|,
name|L
operator||
name|W
block|,
literal|"SYNCHRONIZE BUFFER"
block|}
block|,
comment|/* 11  VMVVVV        SPACE */
block|{
literal|0x11
block|,
name|T
block|,
literal|"SPACE"
block|}
block|,
comment|/* 12  MMMMMMMMMMMM  INQUIRY */
block|{
literal|0x12
block|,
name|ALL
block|,
literal|"INQUIRY"
block|}
block|,
comment|/* 13  VOVVVV        VERIFY(06) */
block|{
literal|0x13
block|,
name|T
block|,
literal|"VERIFY(06)"
block|}
block|,
comment|/* 14  VOOVVV        RECOVER BUFFERED DATA */
block|{
literal|0x14
block|,
name|T
operator||
name|L
block|,
literal|"RECOVER BUFFERED DATA"
block|}
block|,
comment|/* 15  OMO OOOOOOOO  MODE SELECT(06) */
block|{
literal|0x15
block|,
name|ALL
operator|&
operator|~
operator|(
name|P
operator|)
block|,
literal|"MODE SELECT(06)"
block|}
block|,
comment|/* 16  MMMOMMMM   O  RESERVE(06) */
block|{
literal|0x16
block|,
name|D
operator||
name|T
operator||
name|L
operator||
name|P
operator||
name|W
operator||
name|R
operator||
name|S
operator||
name|O
operator||
name|E
block|,
literal|"RESERVE(06)"
block|}
block|,
comment|/* 16          M     RESERVE ELEMENT(06) */
block|{
literal|0x16
block|,
name|M
block|,
literal|"RESERVE ELEMENT(06)"
block|}
block|,
comment|/* 17  MMMOMMMM   O  RELEASE(06) */
block|{
literal|0x17
block|,
name|ALL
operator|&
operator|~
operator|(
name|M
operator||
name|C
operator||
name|A
operator|)
block|,
literal|"RELEASE(06)"
block|}
block|,
comment|/* 17          M     RELEASE ELEMENT(06) */
block|{
literal|0x17
block|,
name|M
block|,
literal|"RELEASE ELEMENT(06)"
block|}
block|,
comment|/* 18  OOOOOOOO      COPY */
block|{
literal|0x18
block|,
name|ALL
operator|&
operator|~
operator|(
name|M
operator||
name|C
operator||
name|A
operator||
name|E
operator|)
block|,
literal|"COPY"
block|}
block|,
comment|/* 19  VMVVVV        ERASE */
block|{
literal|0x19
block|,
name|T
block|,
literal|"ERASE"
block|}
block|,
comment|/* 1A  OMO OOOOOOOO  MODE SENSE(06) */
block|{
literal|0x1A
block|,
name|ALL
operator|&
operator|~
operator|(
name|P
operator|)
block|,
literal|"MODE SENSE(06)"
block|}
block|,
comment|/* 1B  O   OM O      STOP START UNIT */
block|{
literal|0x1B
block|,
name|D
operator||
name|W
operator||
name|R
operator||
name|O
block|,
literal|"STOP START UNIT"
block|}
block|,
comment|/* 1B   O            LOAD UNLOAD */
block|{
literal|0x1B
block|,
name|T
block|,
literal|"LOAD UNLOAD"
block|}
block|,
comment|/* 1B        O       SCAN */
block|{
literal|0x1B
block|,
name|S
block|,
literal|"SCAN"
block|}
block|,
comment|/* 1B    O           STOP PRINT */
block|{
literal|0x1B
block|,
name|L
block|,
literal|"STOP PRINT"
block|}
block|,
comment|/* 1C  OOOOOOOOOO M  RECEIVE DIAGNOSTIC RESULTS */
block|{
literal|0x1C
block|,
name|ALL
operator|&
operator|~
operator|(
name|A
operator|)
block|,
literal|"RECEIVE DIAGNOSTIC RESULTS"
block|}
block|,
comment|/* 1D  MMMMMMMMMMMM  SEND DIAGNOSTIC */
block|{
literal|0x1D
block|,
name|ALL
block|,
literal|"SEND DIAGNOSTIC"
block|}
block|,
comment|/* 1E  OO  OM OO     PREVENT ALLOW MEDIUM REMOVAL */
block|{
literal|0x1E
block|,
name|D
operator||
name|T
operator||
name|W
operator||
name|R
operator||
name|O
operator||
name|M
block|,
literal|"PREVENT ALLOW MEDIUM REMOVAL"
block|}
block|,
comment|/* 1F */
comment|/* 20  V   VV V */
comment|/* 21  V   VV V */
comment|/* 22  V   VV V */
comment|/* 23  V   VV V */
comment|/* 24  V   VVM       SET WINDOW */
block|{
literal|0x24
block|,
name|S
block|,
literal|"SET WINDOW"
block|}
block|,
comment|/* 25  M   M  M      READ CAPACITY */
block|{
literal|0x25
block|,
name|D
operator||
name|W
operator||
name|O
block|,
literal|"READ CAPACITY"
block|}
block|,
comment|/* 25       M        READ CD RECORDED CAPACITY */
block|{
literal|0x25
block|,
name|R
block|,
literal|"READ CD RECORDED CAPACITY"
block|}
block|,
comment|/* 25        O       GET WINDOW */
block|{
literal|0x25
block|,
name|S
block|,
literal|"GET WINDOW"
block|}
block|,
comment|/* 26  V   VV */
comment|/* 27  V   VV */
comment|/* 28  M   MMMM      READ(10) */
block|{
literal|0x28
block|,
name|D
operator||
name|W
operator||
name|R
operator||
name|S
operator||
name|O
block|,
literal|"READ(10)"
block|}
block|,
comment|/* 28           O    GET MESSAGE(10) */
block|{
literal|0x28
block|,
name|C
block|,
literal|"GET MESSAGE(10)"
block|}
block|,
comment|/* 29  V   VV O      READ GENERATION */
block|{
literal|0x29
block|,
name|O
block|,
literal|"READ GENERATION"
block|}
block|,
comment|/* 2A  M   MM M      WRITE(10) */
block|{
literal|0x2A
block|,
name|D
operator||
name|W
operator||
name|R
operator||
name|O
block|,
literal|"WRITE(10)"
block|}
block|,
comment|/* 2A        O       SEND(10) */
block|{
literal|0x2A
block|,
name|S
block|,
literal|"SEND(10)"
block|}
block|,
comment|/* 2A           O    SEND MESSAGE(10) */
block|{
literal|0x2A
block|,
name|C
block|,
literal|"SEND MESSAGE(10)"
block|}
block|,
comment|/* 2B  O   OM O      SEEK(10) */
block|{
literal|0x2B
block|,
name|D
operator||
name|W
operator||
name|R
operator||
name|O
block|,
literal|"SEEK(10)"
block|}
block|,
comment|/* 2B   O            LOCATE */
block|{
literal|0x2B
block|,
name|T
block|,
literal|"LOCATE"
block|}
block|,
comment|/* 2B          O     POSITION TO ELEMENT */
block|{
literal|0x2B
block|,
name|M
block|,
literal|"POSITION TO ELEMENT"
block|}
block|,
comment|/* 2C  V      O      ERASE(10) */
block|{
literal|0x2C
block|,
name|O
block|,
literal|"ERASE(10)"
block|}
block|,
comment|/* 2D  V   O  O      READ UPDATED BLOCK */
block|{
literal|0x2D
block|,
name|W
operator||
name|O
block|,
literal|"READ UPDATED BLOCK"
block|}
block|,
comment|/* 2E  O   O  O      WRITE AND VERIFY(10) */
block|{
literal|0x2E
block|,
name|D
operator||
name|W
operator||
name|O
block|,
literal|"WRITE AND VERIFY(10)"
block|}
block|,
comment|/* 2F  O   OO O      VERIFY(10) */
block|{
literal|0x2F
block|,
name|D
operator||
name|W
operator||
name|R
operator||
name|O
block|,
literal|"VERIFY(10)"
block|}
block|,
comment|/* 30  Z   ZO Z      SEARCH DATA HIGH(10) */
block|{
literal|0x30
block|,
name|D
operator||
name|W
operator||
name|R
operator||
name|O
block|,
literal|"SEARCH DATA HIGH(10)"
block|}
block|,
comment|/* 31  Z   ZO Z      SEARCH DATA EQUAL(10) */
block|{
literal|0x31
block|,
name|D
operator||
name|W
operator||
name|R
operator||
name|O
block|,
literal|"SEARCH DATA EQUAL(10)"
block|}
block|,
comment|/* 31        O       OBJECT POSITION */
block|{
literal|0x31
block|,
name|S
block|,
literal|"OBJECT POSITION"
block|}
block|,
comment|/* 32  Z   ZO Z      SEARCH DATA LOW(10) */
block|{
literal|0x32
block|,
name|D
operator||
name|W
operator||
name|R
operator||
name|O
block|,
literal|"SEARCH DATA LOW(10"
block|}
block|,
comment|/* 33  O   OO O      SET LIMITS(10) */
block|{
literal|0x33
block|,
name|D
operator||
name|W
operator||
name|R
operator||
name|O
block|,
literal|"SET LIMITS(10)"
block|}
block|,
comment|/* 34  O   OO O      PRE-FETCH */
block|{
literal|0x34
block|,
name|D
operator||
name|W
operator||
name|R
operator||
name|O
block|,
literal|"PRE-FETCH"
block|}
block|,
comment|/* 34   O            READ POSITION */
block|{
literal|0x34
block|,
name|T
block|,
literal|"READ POSITION"
block|}
block|,
comment|/* 34        O       GET DATA BUFFER STATUS */
block|{
literal|0x34
block|,
name|S
block|,
literal|"GET DATA BUFFER STATUS"
block|}
block|,
comment|/* 35  O   OM O      SYNCHRONIZE CACHE */
block|{
literal|0x35
block|,
name|D
operator||
name|W
operator||
name|R
operator||
name|O
block|,
literal|"SYNCHRONIZE CACHE"
block|}
block|,
comment|/* 36  O   OO O      LOCK UNLOCK CACHE */
block|{
literal|0x36
block|,
name|D
operator||
name|W
operator||
name|R
operator||
name|O
block|,
literal|"LOCK UNLOCK CACHE"
block|}
block|,
comment|/* 37  O      O      READ DEFECT DATA(10) */
block|{
literal|0x37
block|,
name|D
operator||
name|O
block|,
literal|"READ DEFECT DATA(10)"
block|}
block|,
comment|/* 38      O  O      MEDIUM SCAN */
block|{
literal|0x38
block|,
name|W
operator||
name|O
block|,
literal|"MEDIUM SCAN"
block|}
block|,
comment|/* 39  OOOOOOOO      COMPARE */
block|{
literal|0x39
block|,
name|ALL
operator|&
operator|~
operator|(
name|M
operator||
name|C
operator||
name|A
operator||
name|E
operator|)
block|,
literal|"COMPARE"
block|}
block|,
comment|/* 3A  OOOOOOOO      COPY AND VERIFY */
block|{
literal|0x3A
block|,
name|ALL
operator|&
operator|~
operator|(
name|M
operator||
name|C
operator||
name|A
operator||
name|E
operator|)
block|,
literal|"COPY AND VERIFY"
block|}
block|,
comment|/* 3B  OOOOOOOOOO O  WRITE BUFFER */
block|{
literal|0x3B
block|,
name|ALL
operator|&
operator|~
operator|(
name|A
operator|)
block|,
literal|"WRITE BUFFER"
block|}
block|,
comment|/* 3C  OOOOOOOOOO    READ BUFFER */
block|{
literal|0x3C
block|,
name|ALL
operator|&
operator|~
operator|(
name|A
operator||
name|E
operator|)
block|,
literal|"READ BUFFER"
block|}
block|,
comment|/* 3D      O  O      UPDATE BLOCK */
block|{
literal|0x3D
block|,
name|W
operator||
name|O
block|,
literal|"UPDATE BLOCK"
block|}
block|,
comment|/* 3E  O   OO O      READ LONG */
block|{
literal|0x3E
block|,
name|D
operator||
name|W
operator||
name|R
operator||
name|O
block|,
literal|"READ LONG"
block|}
block|,
comment|/* 3F  O   O  O      WRITE LONG */
block|{
literal|0x3F
block|,
name|D
operator||
name|W
operator||
name|O
block|,
literal|"WRITE LONG"
block|}
block|,
comment|/* 40  OOOOOOOOOO    CHANGE DEFINITION */
block|{
literal|0x40
block|,
name|ALL
operator|&
operator|~
operator|(
name|A
operator||
name|E
operator|)
block|,
literal|"CHANGE DEFINITION"
block|}
block|,
comment|/* 41  O             WRITE SAME */
block|{
literal|0x41
block|,
name|D
block|,
literal|"WRITE SAME"
block|}
block|,
comment|/* 42       M        READ SUB-CHANNEL */
block|{
literal|0x42
block|,
name|R
block|,
literal|"READ SUB-CHANNEL"
block|}
block|,
comment|/* 43       M        READ TOC/PMA/ATIP {MMC Proposed} */
block|{
literal|0x43
block|,
name|R
block|,
literal|"READ TOC/PMA/ATIP {MMC Proposed}"
block|}
block|,
comment|/* 44   M            REPORT DENSITY SUPPORT */
block|{
literal|0x44
block|,
name|T
block|,
literal|"REPORT DENSITY SUPPORT"
block|}
block|,
comment|/* 44       M        READ HEADER */
block|{
literal|0x44
block|,
name|R
block|,
literal|"READ HEADER"
block|}
block|,
comment|/* 45       O        PLAY AUDIO(10) */
block|{
literal|0x45
block|,
name|R
block|,
literal|"PLAY AUDIO(10)"
block|}
block|,
comment|/* 46 */
comment|/* 47       O        PLAY AUDIO MSF */
block|{
literal|0x47
block|,
name|R
block|,
literal|"PLAY AUDIO MSF"
block|}
block|,
comment|/* 48       O        PLAY AUDIO TRACK INDEX */
block|{
literal|0x48
block|,
name|R
block|,
literal|"PLAY AUDIO TRACK INDEX"
block|}
block|,
comment|/* 49       O        PLAY TRACK RELATIVE(10) */
block|{
literal|0x49
block|,
name|R
block|,
literal|"PLAY TRACK RELATIVE(10)"
block|}
block|,
comment|/* 4A */
comment|/* 4B       O        PAUSE/RESUME */
block|{
literal|0x4B
block|,
name|R
block|,
literal|"PAUSE/RESUME"
block|}
block|,
comment|/* 4C  OOOOOOOOOOO   LOG SELECT */
block|{
literal|0x4C
block|,
name|ALL
operator|&
operator|~
operator|(
name|E
operator|)
block|,
literal|"LOG SELECT"
block|}
block|,
comment|/* 4D  OOOOOOOOOOO   LOG SENSE */
block|{
literal|0x4D
block|,
name|ALL
operator|&
operator|~
operator|(
name|E
operator|)
block|,
literal|"LOG SENSE"
block|}
block|,
comment|/* 4E       O        STOP PLAY/SCAN {MMC Proposed} */
block|{
literal|0x4E
block|,
name|R
block|,
literal|"STOP PLAY/SCAN {MMC Proposed}"
block|}
block|,
comment|/* 4F */
comment|/* 50  O             XDWRITE(10) */
block|{
literal|0x50
block|,
name|D
block|,
literal|"XDWRITE(10)"
block|}
block|,
comment|/* 51  O             XPWRITE(10) */
block|{
literal|0x51
block|,
name|D
block|,
literal|"XPWRITE(10)"
block|}
block|,
comment|/* 51       M        READ DISC INFORMATION {MMC Proposed} */
block|{
literal|0x51
block|,
name|R
block|,
literal|"READ DISC INFORMATION {MMC Proposed}"
block|}
block|,
comment|/* 52  O             XDREAD(10) */
block|{
literal|0x52
block|,
name|D
block|,
literal|"XDREAD(10)"
block|}
block|,
comment|/* 52       M        READ TRACK INFORMATION {MMC Proposed} */
block|{
literal|0x52
block|,
name|R
block|,
literal|"READ TRACK INFORMATION {MMC Proposed}"
block|}
block|,
comment|/* 53       M        RESERVE TRACK {MMC Proposed} */
block|{
literal|0x53
block|,
name|R
block|,
literal|"RESERVE TRACK {MMC Proposed}"
block|}
block|,
comment|/* 54       O        SEND OPC INFORMATION {MMC Proposed} */
block|{
literal|0x54
block|,
name|R
block|,
literal|"SEND OPC INFORMATION {MMC Proposed}"
block|}
block|,
comment|/* 55  OOO OOOOOOOO  MODE SELECT(10) */
block|{
literal|0x55
block|,
name|ALL
operator|&
operator|~
operator|(
name|P
operator|)
block|,
literal|"MODE SELECT(10)"
block|}
block|,
comment|/* 56  MMMOMMMM   O  RESERVE(10) */
block|{
literal|0x56
block|,
name|ALL
operator|&
operator|~
operator|(
name|M
operator||
name|C
operator||
name|A
operator|)
block|,
literal|"RESERVE(10)"
block|}
block|,
comment|/* 56          M     RESERVE ELEMENT(10) */
block|{
literal|0x56
block|,
name|M
block|,
literal|"RESERVE ELEMENT(10)"
block|}
block|,
comment|/* 57  MMMOMMMM   O  RELEASE(10) */
block|{
literal|0x57
block|,
name|ALL
operator|&
operator|~
operator|(
name|M
operator||
name|C
operator||
name|A
operator|)
block|,
literal|"RELEASE(10"
block|}
block|,
comment|/* 57          M     RELEASE ELEMENT(10) */
block|{
literal|0x57
block|,
name|M
block|,
literal|"RELEASE ELEMENT(10)"
block|}
block|,
comment|/* 58       O        REPAIR TRACK {MMC Proposed} */
block|{
literal|0x58
block|,
name|R
block|,
literal|"REPAIR TRACK {MMC Proposed}"
block|}
block|,
comment|/* 59       O        READ MASTER CUE {MMC Proposed} */
block|{
literal|0x59
block|,
name|R
block|,
literal|"READ MASTER CUE {MMC Proposed}"
block|}
block|,
comment|/* 5A  OOO OOOOOOOO  MODE SENSE(10) */
block|{
literal|0x5A
block|,
name|ALL
operator|&
operator|~
operator|(
name|P
operator|)
block|,
literal|"MODE SENSE(10)"
block|}
block|,
comment|/* 5B       M        CLOSE TRACK/SESSION {MMC Proposed} */
block|{
literal|0x5B
block|,
name|R
block|,
literal|"CLOSE TRACK/SESSION {MMC Proposed}"
block|}
block|,
comment|/* 5C       O        READ BUFFER CAPACITY {MMC Proposed} */
block|{
literal|0x5C
block|,
name|R
block|,
literal|"READ BUFFER CAPACITY {MMC Proposed}"
block|}
block|,
comment|/* 5D       O        SEND CUE SHEET {MMC Proposed} */
block|{
literal|0x5D
block|,
name|R
block|,
literal|"SEND CUE SHEET {MMC Proposed}"
block|}
block|,
comment|/* 5E  OOOOOOOOO  O  PERSISTENT RESERVE IN */
block|{
literal|0x5E
block|,
name|ALL
operator|&
operator|~
operator|(
name|C
operator||
name|A
operator|)
block|,
literal|"PERSISTENT RESERVE IN"
block|}
block|,
comment|/* 5F  OOOOOOOOO  O  PERSISTENT RESERVE OUT */
block|{
literal|0x5F
block|,
name|ALL
operator|&
operator|~
operator|(
name|C
operator||
name|A
operator|)
block|,
literal|"PERSISTENT RESERVE OUT"
block|}
block|,
comment|/* 80  O             XDWRITE EXTENDED(16) */
block|{
literal|0x80
block|,
name|D
block|,
literal|"XDWRITE EXTENDED(16)"
block|}
block|,
comment|/* 81  O             REBUILD(16) */
block|{
literal|0x81
block|,
name|D
block|,
literal|"REBUILD(16)"
block|}
block|,
comment|/* 82  O             REGENERATE(16) */
block|{
literal|0x82
block|,
name|D
block|,
literal|"REGENERATE(16)"
block|}
block|,
comment|/* 83 */
comment|/* 84 */
comment|/* 85 */
comment|/* 86 */
comment|/* 87 */
comment|/* 88  MM  OO O    O   READ(16) */
block|{
literal|0x88
block|,
name|D
operator||
name|T
operator||
name|W
operator||
name|R
operator||
name|O
block|,
literal|"READ(16)"
block|}
block|,
comment|/* 89 */
comment|/* 8A  OM  O  O    O   WRITE(16) */
block|{
literal|0x8A
block|,
name|D
operator||
name|T
operator||
name|W
operator||
name|R
operator||
name|O
block|,
literal|"WRITE(16)"
block|}
block|,
comment|/* 8B */
comment|/* 8C */
comment|/* 8D */
comment|/* 8E */
comment|/* 8F */
comment|/* 90 */
comment|/* 91 */
comment|/* 92 */
comment|/* 93 */
comment|/* 94 */
comment|/* 95 */
comment|/* 96 */
comment|/* 97 */
comment|/* 98 */
comment|/* 99 */
comment|/* 9A */
comment|/* 9B */
comment|/* 9C */
comment|/* 9D */
comment|/* XXX KDM ALL for these?  op-num.txt defines them for none.. */
comment|/* 9E                  SERVICE ACTION IN(16) */
block|{
literal|0x9E
block|,
name|ALL
block|,
literal|"SERVICE ACTION IN(16)"
block|}
block|,
comment|/* 9F                  SERVICE ACTION OUT(16) */
block|{
literal|0x9F
block|,
name|ALL
block|,
literal|"SERVICE ACTION OUT(16)"
block|}
block|,
comment|/* A0  OOOOOOOOOOO   REPORT LUNS */
block|{
literal|0xA0
block|,
name|ALL
operator|&
operator|~
operator|(
name|E
operator|)
block|,
literal|"REPORT LUNS"
block|}
block|,
comment|/* A1       O        BLANK {MMC Proposed} */
block|{
literal|0xA1
block|,
name|R
block|,
literal|"BLANK {MMC Proposed}"
block|}
block|,
comment|/* A2       O        WRITE CD MSF {MMC Proposed} */
block|{
literal|0xA2
block|,
name|R
block|,
literal|"WRITE CD MSF {MMC Proposed}"
block|}
block|,
comment|/* A3            M   MAINTENANCE (IN) */
block|{
literal|0xA3
block|,
name|A
block|,
literal|"MAINTENANCE (IN)"
block|}
block|,
comment|/* A4            O   MAINTENANCE (OUT) */
block|{
literal|0xA4
block|,
name|A
block|,
literal|"MAINTENANCE (OUT)"
block|}
block|,
comment|/* A5   O      M     MOVE MEDIUM */
block|{
literal|0xA5
block|,
name|T
operator||
name|M
block|,
literal|"MOVE MEDIUM"
block|}
block|,
comment|/* A5       O        PLAY AUDIO(12) */
block|{
literal|0xA5
block|,
name|R
block|,
literal|"PLAY AUDIO(12)"
block|}
block|,
comment|/* A6          O     EXCHANGE MEDIUM */
block|{
literal|0xA6
block|,
name|M
block|,
literal|"EXCHANGE MEDIUM"
block|}
block|,
comment|/* A6       O        LOAD/UNLOAD CD {MMC Proposed} */
block|{
literal|0xA6
block|,
name|R
block|,
literal|"LOAD/UNLOAD CD {MMC Proposed}"
block|}
block|,
comment|/* A7  OO  OO OO     MOVE MEDIUM ATTACHED */
block|{
literal|0xA7
block|,
name|D
operator||
name|T
operator||
name|W
operator||
name|R
operator||
name|O
operator||
name|M
block|,
literal|"MOVE MEDIUM ATTACHED"
block|}
block|,
comment|/* A8  O   OM O      READ(12) */
block|{
literal|0xA8
block|,
name|D
operator||
name|W
operator||
name|R
operator||
name|O
block|,
literal|"READ(12)"
block|}
block|,
comment|/* A8           O    GET MESSAGE(12) */
block|{
literal|0xA8
block|,
name|C
block|,
literal|"GET MESSAGE(12)"
block|}
block|,
comment|/* A9       O        PLAY TRACK RELATIVE(12) */
block|{
literal|0xA9
block|,
name|R
block|,
literal|"PLAY TRACK RELATIVE(12)"
block|}
block|,
comment|/* AA  O   O  O      WRITE(12) */
block|{
literal|0xAA
block|,
name|D
operator||
name|W
operator||
name|O
block|,
literal|"WRITE(12)"
block|}
block|,
comment|/* AA       O        WRITE CD(12) {MMC Proposed} */
block|{
literal|0xAA
block|,
name|R
block|,
literal|"WRITE CD(12) {MMC Proposed}"
block|}
block|,
comment|/* AA           O    SEND MESSAGE(12) */
block|{
literal|0xAA
block|,
name|C
block|,
literal|"SEND MESSAGE(12)"
block|}
block|,
comment|/* AB */
comment|/* AC         O      ERASE(12) */
block|{
literal|0xAC
block|,
name|O
block|,
literal|"ERASE(12)"
block|}
block|,
comment|/* AD */
comment|/* AE      O  O      WRITE AND VERIFY(12) */
block|{
literal|0xAE
block|,
name|W
operator||
name|O
block|,
literal|"WRITE AND VERIFY(12)"
block|}
block|,
comment|/* AF      OO O      VERIFY(12) */
block|{
literal|0xAF
block|,
name|W
operator||
name|R
operator||
name|O
block|,
literal|"VERIFY(12)"
block|}
block|,
comment|/* B0      ZO Z      SEARCH DATA HIGH(12) */
block|{
literal|0xB0
block|,
name|W
operator||
name|R
operator||
name|O
block|,
literal|"SEARCH DATA HIGH(12)"
block|}
block|,
comment|/* B1      ZO Z      SEARCH DATA EQUAL(12) */
block|{
literal|0xB1
block|,
name|W
operator||
name|R
operator||
name|O
block|,
literal|"SEARCH DATA EQUAL(12)"
block|}
block|,
comment|/* B2      ZO Z      SEARCH DATA LOW(12) */
block|{
literal|0xB2
block|,
name|W
operator||
name|R
operator||
name|O
block|,
literal|"SEARCH DATA LOW(12)"
block|}
block|,
comment|/* B3      OO O      SET LIMITS(12) */
block|{
literal|0xB3
block|,
name|W
operator||
name|R
operator||
name|O
block|,
literal|"SET LIMITS(12)"
block|}
block|,
comment|/* B4  OO  OO OO     READ ELEMENT STATUS ATTACHED */
block|{
literal|0xB4
block|,
name|D
operator||
name|T
operator||
name|W
operator||
name|R
operator||
name|O
operator||
name|M
block|,
literal|"READ ELEMENT STATUS ATTACHED"
block|}
block|,
comment|/* B5          O     REQUEST VOLUME ELEMENT ADDRESS */
block|{
literal|0xB5
block|,
name|M
block|,
literal|"REQUEST VOLUME ELEMENT ADDRESS"
block|}
block|,
comment|/* B6          O     SEND VOLUME TAG */
block|{
literal|0xB6
block|,
name|M
block|,
literal|"SEND VOLUME TAG"
block|}
block|,
comment|/* B7         O      READ DEFECT DATA(12) */
block|{
literal|0xB7
block|,
name|O
block|,
literal|"READ DEFECT DATA(12)"
block|}
block|,
comment|/* B8   O      M     READ ELEMENT STATUS */
block|{
literal|0xB8
block|,
name|T
operator||
name|M
block|,
literal|"READ ELEMENT STATUS"
block|}
block|,
comment|/* B8       O        SET CD SPEED {MMC Proposed} */
block|{
literal|0xB8
block|,
name|R
block|,
literal|"SET CD SPEED {MMC Proposed}"
block|}
block|,
comment|/* B9       M        READ CD MSF {MMC Proposed} */
block|{
literal|0xB9
block|,
name|R
block|,
literal|"READ CD MSF {MMC Proposed}"
block|}
block|,
comment|/* BA       O        SCAN {MMC Proposed} */
block|{
literal|0xBA
block|,
name|R
block|,
literal|"SCAN {MMC Proposed}"
block|}
block|,
comment|/* BA            M   REDUNDANCY GROUP (IN) */
block|{
literal|0xBA
block|,
name|A
block|,
literal|"REDUNDANCY GROUP (IN)"
block|}
block|,
comment|/* BB       O        SET CD-ROM SPEED {proposed} */
block|{
literal|0xBB
block|,
name|R
block|,
literal|"SET CD-ROM SPEED {proposed}"
block|}
block|,
comment|/* BB            O   REDUNDANCY GROUP (OUT) */
block|{
literal|0xBB
block|,
name|A
block|,
literal|"REDUNDANCY GROUP (OUT)"
block|}
block|,
comment|/* BC       O        PLAY CD {MMC Proposed} */
block|{
literal|0xBC
block|,
name|R
block|,
literal|"PLAY CD {MMC Proposed}"
block|}
block|,
comment|/* BC            M   SPARE (IN) */
block|{
literal|0xBC
block|,
name|A
block|,
literal|"SPARE (IN)"
block|}
block|,
comment|/* BD       M        MECHANISM STATUS {MMC Proposed} */
block|{
literal|0xBD
block|,
name|R
block|,
literal|"MECHANISM STATUS {MMC Proposed}"
block|}
block|,
comment|/* BD            O   SPARE (OUT) */
block|{
literal|0xBD
block|,
name|A
block|,
literal|"SPARE (OUT)"
block|}
block|,
comment|/* BE       O        READ CD {MMC Proposed} */
block|{
literal|0xBE
block|,
name|R
block|,
literal|"READ CD {MMC Proposed}"
block|}
block|,
comment|/* BE            M   VOLUME SET (IN) */
block|{
literal|0xBE
block|,
name|A
block|,
literal|"VOLUME SET (IN)"
block|}
block|,
comment|/* BF            O   VOLUME SET (OUT) */
block|{
literal|0xBF
block|,
name|A
block|,
literal|"VOLUME SET (OUT)"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|const
name|char
modifier|*
name|scsi_op_desc
parameter_list|(
name|u_int16_t
name|opcode
parameter_list|,
name|struct
name|scsi_inquiry_data
modifier|*
name|inq_data
parameter_list|)
block|{
name|caddr_t
name|match
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|u_int16_t
name|opmask
decl_stmt|;
name|u_int16_t
name|pd_type
decl_stmt|;
name|int
name|num_ops
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|op_table_entry
modifier|*
name|table
index|[
literal|2
index|]
decl_stmt|;
name|int
name|num_tables
decl_stmt|;
name|pd_type
operator|=
name|SID_TYPE
argument_list|(
name|inq_data
argument_list|)
expr_stmt|;
name|match
operator|=
name|cam_quirkmatch
argument_list|(
operator|(
name|caddr_t
operator|)
name|inq_data
argument_list|,
operator|(
name|caddr_t
operator|)
name|scsi_op_quirk_table
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_op_quirk_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|scsi_op_quirk_table
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_op_quirk_table
argument_list|)
argument_list|,
name|scsi_inquiry_match
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
operator|!=
name|NULL
condition|)
block|{
name|table
index|[
literal|0
index|]
operator|=
operator|(
operator|(
expr|struct
name|scsi_op_quirk_entry
operator|*
operator|)
name|match
operator|)
operator|->
name|op_table
expr_stmt|;
name|num_ops
index|[
literal|0
index|]
operator|=
operator|(
operator|(
expr|struct
name|scsi_op_quirk_entry
operator|*
operator|)
name|match
operator|)
operator|->
name|num_ops
expr_stmt|;
name|table
index|[
literal|1
index|]
operator|=
name|scsi_op_codes
expr_stmt|;
name|num_ops
index|[
literal|1
index|]
operator|=
sizeof|sizeof
argument_list|(
name|scsi_op_codes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|scsi_op_codes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|num_tables
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/*	 		 * If this is true, we have a vendor specific opcode that 		 * wasn't covered in the quirk table. 		 */
if|if
condition|(
operator|(
name|opcode
operator|>
literal|0xBF
operator|)
operator|||
operator|(
operator|(
name|opcode
operator|>
literal|0x5F
operator|)
operator|&&
operator|(
name|opcode
operator|<
literal|0x80
operator|)
operator|)
condition|)
return|return
operator|(
literal|"Vendor Specific Command"
operator|)
return|;
name|table
index|[
literal|0
index|]
operator|=
name|scsi_op_codes
expr_stmt|;
name|num_ops
index|[
literal|0
index|]
operator|=
sizeof|sizeof
argument_list|(
name|scsi_op_codes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|scsi_op_codes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|num_tables
operator|=
literal|1
expr_stmt|;
block|}
comment|/* RBC is 'Simplified' Direct Access Device */
if|if
condition|(
name|pd_type
operator|==
name|T_RBC
condition|)
name|pd_type
operator|=
name|T_DIRECT
expr_stmt|;
name|opmask
operator|=
literal|1
operator|<<
name|pd_type
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_tables
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_ops
index|[
name|j
index|]
operator|&&
name|table
index|[
name|j
index|]
index|[
name|i
index|]
operator|.
name|opcode
operator|<=
name|opcode
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|table
index|[
name|j
index|]
index|[
name|i
index|]
operator|.
name|opcode
operator|==
name|opcode
operator|)
operator|&&
operator|(
operator|(
name|table
index|[
name|j
index|]
index|[
name|i
index|]
operator|.
name|opmask
operator|&
name|opmask
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return
operator|(
name|table
index|[
name|j
index|]
index|[
name|i
index|]
operator|.
name|desc
operator|)
return|;
block|}
block|}
comment|/* 	 * If we can't find a match for the command in the table, we just 	 * assume it's a vendor specifc command. 	 */
return|return
operator|(
literal|"Vendor Specific Command"
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* SCSI_NO_OP_STRINGS */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|scsi_op_desc
parameter_list|(
name|u_int16_t
name|opcode
parameter_list|,
name|struct
name|scsi_inquiry_data
modifier|*
name|inq_data
parameter_list|)
block|{
return|return
operator|(
literal|""
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SCSI_NO_SENSE_STRINGS
argument_list|)
end_if

begin_define
define|#
directive|define
name|SST
parameter_list|(
name|asc
parameter_list|,
name|ascq
parameter_list|,
name|action
parameter_list|,
name|desc
parameter_list|)
define|\
value|asc, ascq, action, desc
end_define

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|const
name|char
name|empty_string
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SST
parameter_list|(
name|asc
parameter_list|,
name|ascq
parameter_list|,
name|action
parameter_list|,
name|desc
parameter_list|)
define|\
value|asc, ascq, action, empty_string
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|const
name|struct
name|sense_key_table_entry
name|sense_key_table
index|[]
init|=
block|{
block|{
name|SSD_KEY_NO_SENSE
block|,
name|SS_NOP
block|,
literal|"NO SENSE"
block|}
block|,
block|{
name|SSD_KEY_RECOVERED_ERROR
block|,
name|SS_NOP
operator||
name|SSQ_PRINT_SENSE
block|,
literal|"RECOVERED ERROR"
block|}
block|,
block|{
name|SSD_KEY_NOT_READY
block|,
name|SS_TUR
operator||
name|SSQ_MANY
operator||
name|SSQ_DECREMENT_COUNT
operator||
name|EBUSY
block|,
literal|"NOT READY"
block|}
block|,
block|{
name|SSD_KEY_MEDIUM_ERROR
block|,
name|SS_RDEF
block|,
literal|"MEDIUM ERROR"
block|}
block|,
block|{
name|SSD_KEY_HARDWARE_ERROR
block|,
name|SS_RDEF
block|,
literal|"HARDWARE FAILURE"
block|}
block|,
block|{
name|SSD_KEY_ILLEGAL_REQUEST
block|,
name|SS_FATAL
operator||
name|EINVAL
block|,
literal|"ILLEGAL REQUEST"
block|}
block|,
block|{
name|SSD_KEY_UNIT_ATTENTION
block|,
name|SS_FATAL
operator||
name|ENXIO
block|,
literal|"UNIT ATTENTION"
block|}
block|,
block|{
name|SSD_KEY_DATA_PROTECT
block|,
name|SS_FATAL
operator||
name|EACCES
block|,
literal|"DATA PROTECT"
block|}
block|,
block|{
name|SSD_KEY_BLANK_CHECK
block|,
name|SS_FATAL
operator||
name|ENOSPC
block|,
literal|"BLANK CHECK"
block|}
block|,
block|{
name|SSD_KEY_Vendor_Specific
block|,
name|SS_FATAL
operator||
name|EIO
block|,
literal|"Vendor Specific"
block|}
block|,
block|{
name|SSD_KEY_COPY_ABORTED
block|,
name|SS_FATAL
operator||
name|EIO
block|,
literal|"COPY ABORTED"
block|}
block|,
block|{
name|SSD_KEY_ABORTED_COMMAND
block|,
name|SS_RDEF
block|,
literal|"ABORTED COMMAND"
block|}
block|,
block|{
name|SSD_KEY_EQUAL
block|,
name|SS_NOP
block|,
literal|"EQUAL"
block|}
block|,
block|{
name|SSD_KEY_VOLUME_OVERFLOW
block|,
name|SS_FATAL
operator||
name|EIO
block|,
literal|"VOLUME OVERFLOW"
block|}
block|,
block|{
name|SSD_KEY_MISCOMPARE
block|,
name|SS_NOP
block|,
literal|"MISCOMPARE"
block|}
block|,
block|{
name|SSD_KEY_RESERVED
block|,
name|SS_FATAL
operator||
name|EIO
block|,
literal|"RESERVED"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|sense_key_table_size
init|=
sizeof|sizeof
argument_list|(
name|sense_key_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|sense_key_table
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|asc_table_entry
name|quantum_fireball_entries
index|[]
init|=
block|{
block|{
name|SST
argument_list|(
literal|0x04
argument_list|,
literal|0x0b
argument_list|,
argument|SS_START|SSQ_DECREMENT_COUNT|ENXIO
argument_list|,
literal|"Logical unit not ready, initializing cmd. required"
argument_list|)
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|asc_table_entry
name|sony_mo_entries
index|[]
init|=
block|{
block|{
name|SST
argument_list|(
literal|0x04
argument_list|,
literal|0x00
argument_list|,
argument|SS_START|SSQ_DECREMENT_COUNT|ENXIO
argument_list|,
literal|"Logical unit not ready, cause not reportable"
argument_list|)
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|scsi_sense_quirk_entry
name|sense_quirk_table
index|[]
init|=
block|{
block|{
comment|/* 		 * The Quantum Fireball ST and SE like to return 0x04 0x0b when 		 * they really should return 0x04 0x02.  0x04,0x0b isn't 		 * defined in any SCSI spec, and it isn't mentioned in the 		 * hardware manual for these drives. 		 */
block|{
name|T_DIRECT
block|,
name|SIP_MEDIA_FIXED
block|,
literal|"QUANTUM"
block|,
literal|"FIREBALL S*"
block|,
literal|"*"
block|}
block|,
comment|/*num_sense_keys*/
literal|0
block|,
sizeof|sizeof
argument_list|(
name|quantum_fireball_entries
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|asc_table_entry
argument_list|)
block|,
comment|/*sense key entries*/
name|NULL
block|,
name|quantum_fireball_entries
block|}
block|,
block|{
comment|/* 		 * This Sony MO drive likes to return 0x04, 0x00 when it 		 * isn't spun up. 		 */
block|{
name|T_DIRECT
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"SONY"
block|,
literal|"SMO-*"
block|,
literal|"*"
block|}
block|,
comment|/*num_sense_keys*/
literal|0
block|,
sizeof|sizeof
argument_list|(
name|sony_mo_entries
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|asc_table_entry
argument_list|)
block|,
comment|/*sense key entries*/
name|NULL
block|,
name|sony_mo_entries
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|sense_quirk_table_size
init|=
sizeof|sizeof
argument_list|(
name|sense_quirk_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|sense_quirk_table
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|asc_table_entry
name|asc_table
index|[]
init|=
block|{
comment|/*  * From File: ASC-NUM.TXT  * SCSI ASC/ASCQ Assignments  * Numeric Sorted Listing  * as of  5/12/97  *  * D - DIRECT ACCESS DEVICE (SBC)                     device column key  * .T - SEQUENTIAL ACCESS DEVICE (SSC)               -------------------  * . L - PRINTER DEVICE (SSC)                           blank = reserved  * .  P - PROCESSOR DEVICE (SPC)                     not blank = allowed  * .  .W - WRITE ONCE READ MULTIPLE DEVICE (SBC)  * .  . R - CD DEVICE (MMC)  * .  .  S - SCANNER DEVICE (SGC)  * .  .  .O - OPTICAL MEMORY DEVICE (SBC)  * .  .  . M - MEDIA CHANGER DEVICE (SMC)  * .  .  .  C - COMMUNICATION DEVICE (SSC)  * .  .  .  .A - STORAGE ARRAY DEVICE (SCC)  * .  .  .  . E - ENCLOSURE SERVICES DEVICE (SES)  * DTLPWRSOMCAE        ASC   ASCQ  Action  Description  * ------------        ----  ----  ------  -----------------------------------*/
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|,
argument|SS_NOP
argument_list|,
literal|"No additional sense information"
argument_list|)
block|}
block|,
comment|/*  T    S      */
block|{
name|SST
argument_list|(
literal|0x00
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Filemark detected"
argument_list|)
block|}
block|,
comment|/*  T    S      */
block|{
name|SST
argument_list|(
literal|0x00
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"End-of-partition/medium detected"
argument_list|)
block|}
block|,
comment|/*  T           */
block|{
name|SST
argument_list|(
literal|0x00
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Setmark detected"
argument_list|)
block|}
block|,
comment|/*  T    S      */
block|{
name|SST
argument_list|(
literal|0x00
argument_list|,
literal|0x04
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Beginning-of-partition/medium detected"
argument_list|)
block|}
block|,
comment|/*  T    S      */
block|{
name|SST
argument_list|(
literal|0x00
argument_list|,
literal|0x05
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"End-of-data detected"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x00
argument_list|,
literal|0x06
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"I/O process terminated"
argument_list|)
block|}
block|,
comment|/*      R       */
block|{
name|SST
argument_list|(
literal|0x00
argument_list|,
literal|0x11
argument_list|,
argument|SS_FATAL|EBUSY
argument_list|,
literal|"Audio play operation in progress"
argument_list|)
block|}
block|,
comment|/*      R       */
block|{
name|SST
argument_list|(
literal|0x00
argument_list|,
literal|0x12
argument_list|,
argument|SS_NOP
argument_list|,
literal|"Audio play operation paused"
argument_list|)
block|}
block|,
comment|/*      R       */
block|{
name|SST
argument_list|(
literal|0x00
argument_list|,
literal|0x13
argument_list|,
argument|SS_NOP
argument_list|,
literal|"Audio play operation successfully completed"
argument_list|)
block|}
block|,
comment|/*      R       */
block|{
name|SST
argument_list|(
literal|0x00
argument_list|,
literal|0x14
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Audio play operation stopped due to error"
argument_list|)
block|}
block|,
comment|/*      R       */
block|{
name|SST
argument_list|(
literal|0x00
argument_list|,
literal|0x15
argument_list|,
argument|SS_NOP
argument_list|,
literal|"No current audio status to return"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x00
argument_list|,
literal|0x16
argument_list|,
argument|SS_FATAL|EBUSY
argument_list|,
literal|"Operation in progress"
argument_list|)
block|}
block|,
comment|/* DTL WRSOM AE */
block|{
name|SST
argument_list|(
literal|0x00
argument_list|,
literal|0x17
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Cleaning requested"
argument_list|)
block|}
block|,
comment|/* D   W  O     */
block|{
name|SST
argument_list|(
literal|0x01
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"No index/sector signal"
argument_list|)
block|}
block|,
comment|/* D   WR OM    */
block|{
name|SST
argument_list|(
literal|0x02
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"No seek complete"
argument_list|)
block|}
block|,
comment|/* DTL W SO     */
block|{
name|SST
argument_list|(
literal|0x03
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Peripheral device write fault"
argument_list|)
block|}
block|,
comment|/*  T           */
block|{
name|SST
argument_list|(
literal|0x03
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"No write current"
argument_list|)
block|}
block|,
comment|/*  T           */
block|{
name|SST
argument_list|(
literal|0x03
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Excessive write errors"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x04
argument_list|,
literal|0x00
argument_list|,
argument|SS_TUR|SSQ_MANY|SSQ_DECREMENT_COUNT|EIO
argument_list|,
literal|"Logical unit not ready, cause not reportable"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x04
argument_list|,
literal|0x01
argument_list|,
argument|SS_TUR|SSQ_MANY|SSQ_DECREMENT_COUNT|EBUSY
argument_list|,
literal|"Logical unit is in process of becoming ready"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x04
argument_list|,
literal|0x02
argument_list|,
argument|SS_START|SSQ_DECREMENT_COUNT|ENXIO
argument_list|,
literal|"Logical unit not ready, initializing cmd. required"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x04
argument_list|,
literal|0x03
argument_list|,
argument|SS_FATAL|ENXIO
argument_list|,
literal|"Logical unit not ready, manual intervention required"
argument_list|)
block|}
block|,
comment|/* DTL    O     */
block|{
name|SST
argument_list|(
literal|0x04
argument_list|,
literal|0x04
argument_list|,
argument|SS_FATAL|EBUSY
argument_list|,
literal|"Logical unit not ready, format in progress"
argument_list|)
block|}
block|,
comment|/* DT  W  OMCA  */
block|{
name|SST
argument_list|(
literal|0x04
argument_list|,
literal|0x05
argument_list|,
argument|SS_FATAL|EBUSY
argument_list|,
literal|"Logical unit not ready, rebuild in progress"
argument_list|)
block|}
block|,
comment|/* DT  W  OMCA  */
block|{
name|SST
argument_list|(
literal|0x04
argument_list|,
literal|0x06
argument_list|,
argument|SS_FATAL|EBUSY
argument_list|,
literal|"Logical unit not ready, recalculation in progress"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x04
argument_list|,
literal|0x07
argument_list|,
argument|SS_FATAL|EBUSY
argument_list|,
literal|"Logical unit not ready, operation in progress"
argument_list|)
block|}
block|,
comment|/*      R       */
block|{
name|SST
argument_list|(
literal|0x04
argument_list|,
literal|0x08
argument_list|,
argument|SS_FATAL|EBUSY
argument_list|,
literal|"Logical unit not ready, long write in progress"
argument_list|)
block|}
block|,
comment|/* DTL WRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x05
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Logical unit does not respond to selection"
argument_list|)
block|}
block|,
comment|/* D   WR OM    */
block|{
name|SST
argument_list|(
literal|0x06
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"No reference position found"
argument_list|)
block|}
block|,
comment|/* DTL WRSOM    */
block|{
name|SST
argument_list|(
literal|0x07
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Multiple peripheral devices selected"
argument_list|)
block|}
block|,
comment|/* DTL WRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x08
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Logical unit communication failure"
argument_list|)
block|}
block|,
comment|/* DTL WRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x08
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Logical unit communication time-out"
argument_list|)
block|}
block|,
comment|/* DTL WRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x08
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Logical unit communication parity error"
argument_list|)
block|}
block|,
comment|/* DT   R OM    */
block|{
name|SST
argument_list|(
literal|0x08
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Logical unit communication crc error (ultra-dma/32)"
argument_list|)
block|}
block|,
comment|/* DT  WR O     */
block|{
name|SST
argument_list|(
literal|0x09
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Track following error"
argument_list|)
block|}
block|,
comment|/*     WR O     */
block|{
name|SST
argument_list|(
literal|0x09
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Tracking servo failure"
argument_list|)
block|}
block|,
comment|/*     WR O     */
block|{
name|SST
argument_list|(
literal|0x09
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Focus servo failure"
argument_list|)
block|}
block|,
comment|/*     WR O     */
block|{
name|SST
argument_list|(
literal|0x09
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Spindle servo failure"
argument_list|)
block|}
block|,
comment|/* DT  WR O     */
block|{
name|SST
argument_list|(
literal|0x09
argument_list|,
literal|0x04
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Head select fault"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x0A
argument_list|,
literal|0x00
argument_list|,
argument|SS_FATAL|ENOSPC
argument_list|,
literal|"Error log overflow"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x0B
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Warning"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x0B
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Specified temperature exceeded"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x0B
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Enclosure degraded"
argument_list|)
block|}
block|,
comment|/*  T   RS      */
block|{
name|SST
argument_list|(
literal|0x0C
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Write error"
argument_list|)
block|}
block|,
comment|/* D   W  O     */
block|{
name|SST
argument_list|(
literal|0x0C
argument_list|,
literal|0x01
argument_list|,
argument|SS_NOP|SSQ_PRINT_SENSE
argument_list|,
literal|"Write error - recovered with auto reallocation"
argument_list|)
block|}
block|,
comment|/* D   W  O     */
block|{
name|SST
argument_list|(
literal|0x0C
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Write error - auto reallocation failed"
argument_list|)
block|}
block|,
comment|/* D   W  O     */
block|{
name|SST
argument_list|(
literal|0x0C
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Write error - recommend reassignment"
argument_list|)
block|}
block|,
comment|/* DT  W  O     */
block|{
name|SST
argument_list|(
literal|0x0C
argument_list|,
literal|0x04
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Compression check miscompare error"
argument_list|)
block|}
block|,
comment|/* DT  W  O     */
block|{
name|SST
argument_list|(
literal|0x0C
argument_list|,
literal|0x05
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Data expansion occurred during compression"
argument_list|)
block|}
block|,
comment|/* DT  W  O     */
block|{
name|SST
argument_list|(
literal|0x0C
argument_list|,
literal|0x06
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Block not compressible"
argument_list|)
block|}
block|,
comment|/*      R       */
block|{
name|SST
argument_list|(
literal|0x0C
argument_list|,
literal|0x07
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Write error - recovery needed"
argument_list|)
block|}
block|,
comment|/*      R       */
block|{
name|SST
argument_list|(
literal|0x0C
argument_list|,
literal|0x08
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Write error - recovery failed"
argument_list|)
block|}
block|,
comment|/*      R       */
block|{
name|SST
argument_list|(
literal|0x0C
argument_list|,
literal|0x09
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Write error - loss of streaming"
argument_list|)
block|}
block|,
comment|/*      R       */
block|{
name|SST
argument_list|(
literal|0x0C
argument_list|,
literal|0x0A
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Write error - padding blocks added"
argument_list|)
block|}
block|,
comment|/* D   W  O     */
block|{
name|SST
argument_list|(
literal|0x10
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"ID CRC or ECC error"
argument_list|)
block|}
block|,
comment|/* DT  WRSO     */
block|{
name|SST
argument_list|(
literal|0x11
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Unrecovered read error"
argument_list|)
block|}
block|,
comment|/* DT  W SO     */
block|{
name|SST
argument_list|(
literal|0x11
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Read retries exhausted"
argument_list|)
block|}
block|,
comment|/* DT  W SO     */
block|{
name|SST
argument_list|(
literal|0x11
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Error too long to correct"
argument_list|)
block|}
block|,
comment|/* DT  W SO     */
block|{
name|SST
argument_list|(
literal|0x11
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Multiple read errors"
argument_list|)
block|}
block|,
comment|/* D   W  O     */
block|{
name|SST
argument_list|(
literal|0x11
argument_list|,
literal|0x04
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Unrecovered read error - auto reallocate failed"
argument_list|)
block|}
block|,
comment|/*     WR O     */
block|{
name|SST
argument_list|(
literal|0x11
argument_list|,
literal|0x05
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"L-EC uncorrectable error"
argument_list|)
block|}
block|,
comment|/*     WR O     */
block|{
name|SST
argument_list|(
literal|0x11
argument_list|,
literal|0x06
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"CIRC unrecovered error"
argument_list|)
block|}
block|,
comment|/*     W  O     */
block|{
name|SST
argument_list|(
literal|0x11
argument_list|,
literal|0x07
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Data re-synchronization error"
argument_list|)
block|}
block|,
comment|/*  T           */
block|{
name|SST
argument_list|(
literal|0x11
argument_list|,
literal|0x08
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Incomplete block read"
argument_list|)
block|}
block|,
comment|/*  T           */
block|{
name|SST
argument_list|(
literal|0x11
argument_list|,
literal|0x09
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"No gap found"
argument_list|)
block|}
block|,
comment|/* DT     O     */
block|{
name|SST
argument_list|(
literal|0x11
argument_list|,
literal|0x0A
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Miscorrected error"
argument_list|)
block|}
block|,
comment|/* D   W  O     */
block|{
name|SST
argument_list|(
literal|0x11
argument_list|,
literal|0x0B
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Unrecovered read error - recommend reassignment"
argument_list|)
block|}
block|,
comment|/* D   W  O     */
block|{
name|SST
argument_list|(
literal|0x11
argument_list|,
literal|0x0C
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Unrecovered read error - recommend rewrite the data"
argument_list|)
block|}
block|,
comment|/* DT  WR O     */
block|{
name|SST
argument_list|(
literal|0x11
argument_list|,
literal|0x0D
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"De-compression CRC error"
argument_list|)
block|}
block|,
comment|/* DT  WR O     */
block|{
name|SST
argument_list|(
literal|0x11
argument_list|,
literal|0x0E
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Cannot decompress using declared algorithm"
argument_list|)
block|}
block|,
comment|/*      R       */
block|{
name|SST
argument_list|(
literal|0x11
argument_list|,
literal|0x0F
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Error reading UPC/EAN number"
argument_list|)
block|}
block|,
comment|/*      R       */
block|{
name|SST
argument_list|(
literal|0x11
argument_list|,
literal|0x10
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Error reading ISRC number"
argument_list|)
block|}
block|,
comment|/*      R       */
block|{
name|SST
argument_list|(
literal|0x11
argument_list|,
literal|0x11
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Read error - loss of streaming"
argument_list|)
block|}
block|,
comment|/* D   W  O     */
block|{
name|SST
argument_list|(
literal|0x12
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Address mark not found for id field"
argument_list|)
block|}
block|,
comment|/* D   W  O     */
block|{
name|SST
argument_list|(
literal|0x13
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Address mark not found for data field"
argument_list|)
block|}
block|,
comment|/* DTL WRSO     */
block|{
name|SST
argument_list|(
literal|0x14
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Recorded entity not found"
argument_list|)
block|}
block|,
comment|/* DT  WR O     */
block|{
name|SST
argument_list|(
literal|0x14
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Record not found"
argument_list|)
block|}
block|,
comment|/*  T           */
block|{
name|SST
argument_list|(
literal|0x14
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Filemark or setmark not found"
argument_list|)
block|}
block|,
comment|/*  T           */
block|{
name|SST
argument_list|(
literal|0x14
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"End-of-data not found"
argument_list|)
block|}
block|,
comment|/*  T           */
block|{
name|SST
argument_list|(
literal|0x14
argument_list|,
literal|0x04
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Block sequence error"
argument_list|)
block|}
block|,
comment|/* DT  W  O     */
block|{
name|SST
argument_list|(
literal|0x14
argument_list|,
literal|0x05
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Record not found - recommend reassignment"
argument_list|)
block|}
block|,
comment|/* DT  W  O     */
block|{
name|SST
argument_list|(
literal|0x14
argument_list|,
literal|0x06
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Record not found - data auto-reallocated"
argument_list|)
block|}
block|,
comment|/* DTL WRSOM    */
block|{
name|SST
argument_list|(
literal|0x15
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Random positioning error"
argument_list|)
block|}
block|,
comment|/* DTL WRSOM    */
block|{
name|SST
argument_list|(
literal|0x15
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Mechanical positioning error"
argument_list|)
block|}
block|,
comment|/* DT  WR O     */
block|{
name|SST
argument_list|(
literal|0x15
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Positioning error detected by read of medium"
argument_list|)
block|}
block|,
comment|/* D   W  O     */
block|{
name|SST
argument_list|(
literal|0x16
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Data synchronization mark error"
argument_list|)
block|}
block|,
comment|/* D   W  O     */
block|{
name|SST
argument_list|(
literal|0x16
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Data sync error - data rewritten"
argument_list|)
block|}
block|,
comment|/* D   W  O     */
block|{
name|SST
argument_list|(
literal|0x16
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Data sync error - recommend rewrite"
argument_list|)
block|}
block|,
comment|/* D   W  O     */
block|{
name|SST
argument_list|(
literal|0x16
argument_list|,
literal|0x03
argument_list|,
argument|SS_NOP|SSQ_PRINT_SENSE
argument_list|,
literal|"Data sync error - data auto-reallocated"
argument_list|)
block|}
block|,
comment|/* D   W  O     */
block|{
name|SST
argument_list|(
literal|0x16
argument_list|,
literal|0x04
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Data sync error - recommend reassignment"
argument_list|)
block|}
block|,
comment|/* DT  WRSO     */
block|{
name|SST
argument_list|(
literal|0x17
argument_list|,
literal|0x00
argument_list|,
argument|SS_NOP|SSQ_PRINT_SENSE
argument_list|,
literal|"Recovered data with no error correction applied"
argument_list|)
block|}
block|,
comment|/* DT  WRSO     */
block|{
name|SST
argument_list|(
literal|0x17
argument_list|,
literal|0x01
argument_list|,
argument|SS_NOP|SSQ_PRINT_SENSE
argument_list|,
literal|"Recovered data with retries"
argument_list|)
block|}
block|,
comment|/* DT  WR O     */
block|{
name|SST
argument_list|(
literal|0x17
argument_list|,
literal|0x02
argument_list|,
argument|SS_NOP|SSQ_PRINT_SENSE
argument_list|,
literal|"Recovered data with positive head offset"
argument_list|)
block|}
block|,
comment|/* DT  WR O     */
block|{
name|SST
argument_list|(
literal|0x17
argument_list|,
literal|0x03
argument_list|,
argument|SS_NOP|SSQ_PRINT_SENSE
argument_list|,
literal|"Recovered data with negative head offset"
argument_list|)
block|}
block|,
comment|/*     WR O     */
block|{
name|SST
argument_list|(
literal|0x17
argument_list|,
literal|0x04
argument_list|,
argument|SS_NOP|SSQ_PRINT_SENSE
argument_list|,
literal|"Recovered data with retries and/or CIRC applied"
argument_list|)
block|}
block|,
comment|/* D   WR O     */
block|{
name|SST
argument_list|(
literal|0x17
argument_list|,
literal|0x05
argument_list|,
argument|SS_NOP|SSQ_PRINT_SENSE
argument_list|,
literal|"Recovered data using previous sector id"
argument_list|)
block|}
block|,
comment|/* D   W  O     */
block|{
name|SST
argument_list|(
literal|0x17
argument_list|,
literal|0x06
argument_list|,
argument|SS_NOP|SSQ_PRINT_SENSE
argument_list|,
literal|"Recovered data without ECC - data auto-reallocated"
argument_list|)
block|}
block|,
comment|/* D   W  O     */
block|{
name|SST
argument_list|(
literal|0x17
argument_list|,
literal|0x07
argument_list|,
argument|SS_NOP|SSQ_PRINT_SENSE
argument_list|,
literal|"Recovered data without ECC - recommend reassignment"
argument_list|)
block|}
block|,
comment|/* D   W  O     */
block|{
name|SST
argument_list|(
literal|0x17
argument_list|,
literal|0x08
argument_list|,
argument|SS_NOP|SSQ_PRINT_SENSE
argument_list|,
literal|"Recovered data without ECC - recommend rewrite"
argument_list|)
block|}
block|,
comment|/* D   W  O     */
block|{
name|SST
argument_list|(
literal|0x17
argument_list|,
literal|0x09
argument_list|,
argument|SS_NOP|SSQ_PRINT_SENSE
argument_list|,
literal|"Recovered data without ECC - data rewritten"
argument_list|)
block|}
block|,
comment|/* D   W  O     */
block|{
name|SST
argument_list|(
literal|0x18
argument_list|,
literal|0x00
argument_list|,
argument|SS_NOP|SSQ_PRINT_SENSE
argument_list|,
literal|"Recovered data with error correction applied"
argument_list|)
block|}
block|,
comment|/* D   WR O     */
block|{
name|SST
argument_list|(
literal|0x18
argument_list|,
literal|0x01
argument_list|,
argument|SS_NOP|SSQ_PRINT_SENSE
argument_list|,
literal|"Recovered data with error corr.& retries applied"
argument_list|)
block|}
block|,
comment|/* D   WR O     */
block|{
name|SST
argument_list|(
literal|0x18
argument_list|,
literal|0x02
argument_list|,
argument|SS_NOP|SSQ_PRINT_SENSE
argument_list|,
literal|"Recovered data - data auto-reallocated"
argument_list|)
block|}
block|,
comment|/*      R       */
block|{
name|SST
argument_list|(
literal|0x18
argument_list|,
literal|0x03
argument_list|,
argument|SS_NOP|SSQ_PRINT_SENSE
argument_list|,
literal|"Recovered data with CIRC"
argument_list|)
block|}
block|,
comment|/*      R       */
block|{
name|SST
argument_list|(
literal|0x18
argument_list|,
literal|0x04
argument_list|,
argument|SS_NOP|SSQ_PRINT_SENSE
argument_list|,
literal|"Recovered data with L-EC"
argument_list|)
block|}
block|,
comment|/* D   WR O     */
block|{
name|SST
argument_list|(
literal|0x18
argument_list|,
literal|0x05
argument_list|,
argument|SS_NOP|SSQ_PRINT_SENSE
argument_list|,
literal|"Recovered data - recommend reassignment"
argument_list|)
block|}
block|,
comment|/* D   WR O     */
block|{
name|SST
argument_list|(
literal|0x18
argument_list|,
literal|0x06
argument_list|,
argument|SS_NOP|SSQ_PRINT_SENSE
argument_list|,
literal|"Recovered data - recommend rewrite"
argument_list|)
block|}
block|,
comment|/* D   W  O     */
block|{
name|SST
argument_list|(
literal|0x18
argument_list|,
literal|0x07
argument_list|,
argument|SS_NOP|SSQ_PRINT_SENSE
argument_list|,
literal|"Recovered data with ECC - data rewritten"
argument_list|)
block|}
block|,
comment|/* D      O     */
block|{
name|SST
argument_list|(
literal|0x19
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Defect list error"
argument_list|)
block|}
block|,
comment|/* D      O     */
block|{
name|SST
argument_list|(
literal|0x19
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Defect list not available"
argument_list|)
block|}
block|,
comment|/* D      O     */
block|{
name|SST
argument_list|(
literal|0x19
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Defect list error in primary list"
argument_list|)
block|}
block|,
comment|/* D      O     */
block|{
name|SST
argument_list|(
literal|0x19
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Defect list error in grown list"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x1A
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Parameter list length error"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x1B
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Synchronous data transfer error"
argument_list|)
block|}
block|,
comment|/* D      O     */
block|{
name|SST
argument_list|(
literal|0x1C
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Defect list not found"
argument_list|)
block|}
block|,
comment|/* D      O     */
block|{
name|SST
argument_list|(
literal|0x1C
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Primary defect list not found"
argument_list|)
block|}
block|,
comment|/* D      O     */
block|{
name|SST
argument_list|(
literal|0x1C
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Grown defect list not found"
argument_list|)
block|}
block|,
comment|/* D   W  O     */
block|{
name|SST
argument_list|(
literal|0x1D
argument_list|,
literal|0x00
argument_list|,
argument|SS_FATAL
argument_list|,
literal|"Miscompare during verify operation"
argument_list|)
block|}
block|,
comment|/* D   W  O     */
block|{
name|SST
argument_list|(
literal|0x1E
argument_list|,
literal|0x00
argument_list|,
argument|SS_NOP|SSQ_PRINT_SENSE
argument_list|,
literal|"Recovered id with ecc correction"
argument_list|)
block|}
block|,
comment|/* D      O     */
block|{
name|SST
argument_list|(
literal|0x1F
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Partial defect list transfer"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x20
argument_list|,
literal|0x00
argument_list|,
argument|SS_FATAL|EINVAL
argument_list|,
literal|"Invalid command operation code"
argument_list|)
block|}
block|,
comment|/* DT  WR OM    */
block|{
name|SST
argument_list|(
literal|0x21
argument_list|,
literal|0x00
argument_list|,
argument|SS_FATAL|EINVAL
argument_list|,
literal|"Logical block address out of range"
argument_list|)
block|}
block|,
comment|/* DT  WR OM    */
block|{
name|SST
argument_list|(
literal|0x21
argument_list|,
literal|0x01
argument_list|,
argument|SS_FATAL|EINVAL
argument_list|,
literal|"Invalid element address"
argument_list|)
block|}
block|,
comment|/* D            */
block|{
name|SST
argument_list|(
literal|0x22
argument_list|,
literal|0x00
argument_list|,
argument|SS_FATAL|EINVAL
argument_list|,
literal|"Illegal function"
argument_list|)
block|}
block|,
comment|/* Deprecated. Use 20 00, 24 00, or 26 00 instead */
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x24
argument_list|,
literal|0x00
argument_list|,
argument|SS_FATAL|EINVAL
argument_list|,
literal|"Invalid field in CDB"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x25
argument_list|,
literal|0x00
argument_list|,
argument|SS_FATAL|ENXIO
argument_list|,
literal|"Logical unit not supported"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x26
argument_list|,
literal|0x00
argument_list|,
argument|SS_FATAL|EINVAL
argument_list|,
literal|"Invalid field in parameter list"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x26
argument_list|,
literal|0x01
argument_list|,
argument|SS_FATAL|EINVAL
argument_list|,
literal|"Parameter not supported"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x26
argument_list|,
literal|0x02
argument_list|,
argument|SS_FATAL|EINVAL
argument_list|,
literal|"Parameter value invalid"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x26
argument_list|,
literal|0x03
argument_list|,
argument|SS_FATAL|EINVAL
argument_list|,
literal|"Threshold parameters not supported"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x26
argument_list|,
literal|0x04
argument_list|,
argument|SS_FATAL|EINVAL
argument_list|,
literal|"Invalid release of active persistent reservation"
argument_list|)
block|}
block|,
comment|/* DT  W  O     */
block|{
name|SST
argument_list|(
literal|0x27
argument_list|,
literal|0x00
argument_list|,
argument|SS_FATAL|EACCES
argument_list|,
literal|"Write protected"
argument_list|)
block|}
block|,
comment|/* DT  W  O     */
block|{
name|SST
argument_list|(
literal|0x27
argument_list|,
literal|0x01
argument_list|,
argument|SS_FATAL|EACCES
argument_list|,
literal|"Hardware write protected"
argument_list|)
block|}
block|,
comment|/* DT  W  O     */
block|{
name|SST
argument_list|(
literal|0x27
argument_list|,
literal|0x02
argument_list|,
argument|SS_FATAL|EACCES
argument_list|,
literal|"Logical unit software write protected"
argument_list|)
block|}
block|,
comment|/*  T           */
block|{
name|SST
argument_list|(
literal|0x27
argument_list|,
literal|0x03
argument_list|,
argument|SS_FATAL|EACCES
argument_list|,
literal|"Associated write protect"
argument_list|)
block|}
block|,
comment|/*  T           */
block|{
name|SST
argument_list|(
literal|0x27
argument_list|,
literal|0x04
argument_list|,
argument|SS_FATAL|EACCES
argument_list|,
literal|"Persistent write protect"
argument_list|)
block|}
block|,
comment|/*  T           */
block|{
name|SST
argument_list|(
literal|0x27
argument_list|,
literal|0x05
argument_list|,
argument|SS_FATAL|EACCES
argument_list|,
literal|"Permanent write protect"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x28
argument_list|,
literal|0x00
argument_list|,
argument|SS_FATAL|ENXIO
argument_list|,
literal|"Not ready to ready change, medium may have changed"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x28
argument_list|,
literal|0x01
argument_list|,
argument|SS_FATAL|ENXIO
argument_list|,
literal|"Import or export element accessed"
argument_list|)
block|}
block|,
comment|/*  * XXX JGibbs - All of these should use the same errno, but I don't think  * ENXIO is the correct choice.  Should we borrow from the networking  * errnos?  ECONNRESET anyone?  */
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x29
argument_list|,
literal|0x00
argument_list|,
argument|SS_FATAL|ENXIO
argument_list|,
literal|"Power on, reset, or bus device reset occurred"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x29
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Power on occurred"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x29
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Scsi bus reset occurred"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x29
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Bus device reset function occurred"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x29
argument_list|,
literal|0x04
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Device internal reset"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x29
argument_list|,
literal|0x05
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Transceiver mode changed to single-ended"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x29
argument_list|,
literal|0x06
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Transceiver mode changed to LVD"
argument_list|)
block|}
block|,
comment|/* DTL WRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x2A
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Parameters changed"
argument_list|)
block|}
block|,
comment|/* DTL WRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x2A
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Mode parameters changed"
argument_list|)
block|}
block|,
comment|/* DTL WRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x2A
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Log parameters changed"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x2A
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Reservations preempted"
argument_list|)
block|}
block|,
comment|/* DTLPWRSO C   */
block|{
name|SST
argument_list|(
literal|0x2B
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Copy cannot execute since host cannot disconnect"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x2C
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Command sequence error"
argument_list|)
block|}
block|,
comment|/*       S      */
block|{
name|SST
argument_list|(
literal|0x2C
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Too many windows specified"
argument_list|)
block|}
block|,
comment|/*       S      */
block|{
name|SST
argument_list|(
literal|0x2C
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Invalid combination of windows specified"
argument_list|)
block|}
block|,
comment|/*      R       */
block|{
name|SST
argument_list|(
literal|0x2C
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Current program area is not empty"
argument_list|)
block|}
block|,
comment|/*      R       */
block|{
name|SST
argument_list|(
literal|0x2C
argument_list|,
literal|0x04
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Current program area is empty"
argument_list|)
block|}
block|,
comment|/*  T           */
block|{
name|SST
argument_list|(
literal|0x2D
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Overwrite error on update in place"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x2F
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Commands cleared by another initiator"
argument_list|)
block|}
block|,
comment|/* DT  WR OM    */
block|{
name|SST
argument_list|(
literal|0x30
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Incompatible medium installed"
argument_list|)
block|}
block|,
comment|/* DT  WR O     */
block|{
name|SST
argument_list|(
literal|0x30
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Cannot read medium - unknown format"
argument_list|)
block|}
block|,
comment|/* DT  WR O     */
block|{
name|SST
argument_list|(
literal|0x30
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Cannot read medium - incompatible format"
argument_list|)
block|}
block|,
comment|/* DT           */
block|{
name|SST
argument_list|(
literal|0x30
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Cleaning cartridge installed"
argument_list|)
block|}
block|,
comment|/* DT  WR O     */
block|{
name|SST
argument_list|(
literal|0x30
argument_list|,
literal|0x04
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Cannot write medium - unknown format"
argument_list|)
block|}
block|,
comment|/* DT  WR O     */
block|{
name|SST
argument_list|(
literal|0x30
argument_list|,
literal|0x05
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Cannot write medium - incompatible format"
argument_list|)
block|}
block|,
comment|/* DT  W  O     */
block|{
name|SST
argument_list|(
literal|0x30
argument_list|,
literal|0x06
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Cannot format medium - incompatible medium"
argument_list|)
block|}
block|,
comment|/* DTL WRSOM AE */
block|{
name|SST
argument_list|(
literal|0x30
argument_list|,
literal|0x07
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Cleaning failure"
argument_list|)
block|}
block|,
comment|/*      R       */
block|{
name|SST
argument_list|(
literal|0x30
argument_list|,
literal|0x08
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Cannot write - application code mismatch"
argument_list|)
block|}
block|,
comment|/*      R       */
block|{
name|SST
argument_list|(
literal|0x30
argument_list|,
literal|0x09
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Current session not fixated for append"
argument_list|)
block|}
block|,
comment|/* DT  WR O     */
block|{
name|SST
argument_list|(
literal|0x31
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Medium format corrupted"
argument_list|)
block|}
block|,
comment|/* D L  R O     */
block|{
name|SST
argument_list|(
literal|0x31
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Format command failed"
argument_list|)
block|}
block|,
comment|/* D   W  O     */
block|{
name|SST
argument_list|(
literal|0x32
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"No defect spare location available"
argument_list|)
block|}
block|,
comment|/* D   W  O     */
block|{
name|SST
argument_list|(
literal|0x32
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Defect list update failure"
argument_list|)
block|}
block|,
comment|/*  T           */
block|{
name|SST
argument_list|(
literal|0x33
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Tape length error"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x34
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Enclosure failure"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x35
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Enclosure services failure"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x35
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Unsupported enclosure function"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x35
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Enclosure services unavailable"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x35
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Enclosure services transfer failure"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x35
argument_list|,
literal|0x04
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Enclosure services transfer refused"
argument_list|)
block|}
block|,
comment|/*   L          */
block|{
name|SST
argument_list|(
literal|0x36
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Ribbon, ink, or toner failure"
argument_list|)
block|}
block|,
comment|/* DTL WRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x37
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Rounded parameter"
argument_list|)
block|}
block|,
comment|/* DTL WRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x39
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Saving parameters not supported"
argument_list|)
block|}
block|,
comment|/* DTL WRSOM    */
block|{
name|SST
argument_list|(
literal|0x3A
argument_list|,
literal|0x00
argument_list|,
argument|SS_FATAL|ENXIO
argument_list|,
literal|"Medium not present"
argument_list|)
block|}
block|,
comment|/* DT  WR OM    */
block|{
name|SST
argument_list|(
literal|0x3A
argument_list|,
literal|0x01
argument_list|,
argument|SS_FATAL|ENXIO
argument_list|,
literal|"Medium not present - tray closed"
argument_list|)
block|}
block|,
comment|/* DT  WR OM    */
block|{
name|SST
argument_list|(
literal|0x3A
argument_list|,
literal|0x02
argument_list|,
argument|SS_FATAL|ENXIO
argument_list|,
literal|"Medium not present - tray open"
argument_list|)
block|}
block|,
comment|/*  TL          */
block|{
name|SST
argument_list|(
literal|0x3B
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Sequential positioning error"
argument_list|)
block|}
block|,
comment|/*  T           */
block|{
name|SST
argument_list|(
literal|0x3B
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Tape position error at beginning-of-medium"
argument_list|)
block|}
block|,
comment|/*  T           */
block|{
name|SST
argument_list|(
literal|0x3B
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Tape position error at end-of-medium"
argument_list|)
block|}
block|,
comment|/*   L          */
block|{
name|SST
argument_list|(
literal|0x3B
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Tape or electronic vertical forms unit not ready"
argument_list|)
block|}
block|,
comment|/*   L          */
block|{
name|SST
argument_list|(
literal|0x3B
argument_list|,
literal|0x04
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Slew failure"
argument_list|)
block|}
block|,
comment|/*   L          */
block|{
name|SST
argument_list|(
literal|0x3B
argument_list|,
literal|0x05
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Paper jam"
argument_list|)
block|}
block|,
comment|/*   L          */
block|{
name|SST
argument_list|(
literal|0x3B
argument_list|,
literal|0x06
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Failed to sense top-of-form"
argument_list|)
block|}
block|,
comment|/*   L          */
block|{
name|SST
argument_list|(
literal|0x3B
argument_list|,
literal|0x07
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Failed to sense bottom-of-form"
argument_list|)
block|}
block|,
comment|/*  T           */
block|{
name|SST
argument_list|(
literal|0x3B
argument_list|,
literal|0x08
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Reposition error"
argument_list|)
block|}
block|,
comment|/*       S      */
block|{
name|SST
argument_list|(
literal|0x3B
argument_list|,
literal|0x09
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Read past end of medium"
argument_list|)
block|}
block|,
comment|/*       S      */
block|{
name|SST
argument_list|(
literal|0x3B
argument_list|,
literal|0x0A
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Read past beginning of medium"
argument_list|)
block|}
block|,
comment|/*       S      */
block|{
name|SST
argument_list|(
literal|0x3B
argument_list|,
literal|0x0B
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Position past end of medium"
argument_list|)
block|}
block|,
comment|/*  T    S      */
block|{
name|SST
argument_list|(
literal|0x3B
argument_list|,
literal|0x0C
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Position past beginning of medium"
argument_list|)
block|}
block|,
comment|/* DT  WR OM    */
block|{
name|SST
argument_list|(
literal|0x3B
argument_list|,
literal|0x0D
argument_list|,
argument|SS_FATAL|ENOSPC
argument_list|,
literal|"Medium destination element full"
argument_list|)
block|}
block|,
comment|/* DT  WR OM    */
block|{
name|SST
argument_list|(
literal|0x3B
argument_list|,
literal|0x0E
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Medium source element empty"
argument_list|)
block|}
block|,
comment|/*      R       */
block|{
name|SST
argument_list|(
literal|0x3B
argument_list|,
literal|0x0F
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"End of medium reached"
argument_list|)
block|}
block|,
comment|/* DT  WR OM    */
block|{
name|SST
argument_list|(
literal|0x3B
argument_list|,
literal|0x11
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Medium magazine not accessible"
argument_list|)
block|}
block|,
comment|/* DT  WR OM    */
block|{
name|SST
argument_list|(
literal|0x3B
argument_list|,
literal|0x12
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Medium magazine removed"
argument_list|)
block|}
block|,
comment|/* DT  WR OM    */
block|{
name|SST
argument_list|(
literal|0x3B
argument_list|,
literal|0x13
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Medium magazine inserted"
argument_list|)
block|}
block|,
comment|/* DT  WR OM    */
block|{
name|SST
argument_list|(
literal|0x3B
argument_list|,
literal|0x14
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Medium magazine locked"
argument_list|)
block|}
block|,
comment|/* DT  WR OM    */
block|{
name|SST
argument_list|(
literal|0x3B
argument_list|,
literal|0x15
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Medium magazine unlocked"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x3D
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Invalid bits in identify message"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x3E
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Logical unit has not self-configured yet"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x3E
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Logical unit failure"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x3E
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Timeout on logical unit"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x3F
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Target operating conditions have changed"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x3F
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Microcode has been changed"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMC   */
block|{
name|SST
argument_list|(
literal|0x3F
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Changed operating definition"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x3F
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Inquiry data has changed"
argument_list|)
block|}
block|,
comment|/* DT  WR OMCAE */
block|{
name|SST
argument_list|(
literal|0x3F
argument_list|,
literal|0x04
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Component device attached"
argument_list|)
block|}
block|,
comment|/* DT  WR OMCAE */
block|{
name|SST
argument_list|(
literal|0x3F
argument_list|,
literal|0x05
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Device identifier changed"
argument_list|)
block|}
block|,
comment|/* DT  WR OMCAE */
block|{
name|SST
argument_list|(
literal|0x3F
argument_list|,
literal|0x06
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Redundancy group created or modified"
argument_list|)
block|}
block|,
comment|/* DT  WR OMCAE */
block|{
name|SST
argument_list|(
literal|0x3F
argument_list|,
literal|0x07
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Redundancy group deleted"
argument_list|)
block|}
block|,
comment|/* DT  WR OMCAE */
block|{
name|SST
argument_list|(
literal|0x3F
argument_list|,
literal|0x08
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Spare created or modified"
argument_list|)
block|}
block|,
comment|/* DT  WR OMCAE */
block|{
name|SST
argument_list|(
literal|0x3F
argument_list|,
literal|0x09
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Spare deleted"
argument_list|)
block|}
block|,
comment|/* DT  WR OMCAE */
block|{
name|SST
argument_list|(
literal|0x3F
argument_list|,
literal|0x0A
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Volume set created or modified"
argument_list|)
block|}
block|,
comment|/* DT  WR OMCAE */
block|{
name|SST
argument_list|(
literal|0x3F
argument_list|,
literal|0x0B
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Volume set deleted"
argument_list|)
block|}
block|,
comment|/* DT  WR OMCAE */
block|{
name|SST
argument_list|(
literal|0x3F
argument_list|,
literal|0x0C
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Volume set deassigned"
argument_list|)
block|}
block|,
comment|/* DT  WR OMCAE */
block|{
name|SST
argument_list|(
literal|0x3F
argument_list|,
literal|0x0D
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Volume set reassigned"
argument_list|)
block|}
block|,
comment|/* D            */
block|{
name|SST
argument_list|(
literal|0x40
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Ram failure"
argument_list|)
block|}
block|,
comment|/* deprecated - use 40 NN instead */
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x40
argument_list|,
literal|0x80
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Diagnostic failure: ASCQ = Component ID"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x40
argument_list|,
literal|0xFF
argument_list|,
argument|SS_RDEF|SSQ_RANGE
argument_list|,
argument|NULL
argument_list|)
block|}
block|,
comment|/* Range 0x80->0xFF */
comment|/* D            */
block|{
name|SST
argument_list|(
literal|0x41
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Data path failure"
argument_list|)
block|}
block|,
comment|/* deprecated - use 40 NN instead */
comment|/* D            */
block|{
name|SST
argument_list|(
literal|0x42
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Power-on or self-test failure"
argument_list|)
block|}
block|,
comment|/* deprecated - use 40 NN instead */
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x43
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Message error"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x44
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Internal target failure"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x45
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Select or reselect failure"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMC   */
block|{
name|SST
argument_list|(
literal|0x46
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Unsuccessful soft reset"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x47
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"SCSI parity error"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x48
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Initiator detected error message received"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x49
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Invalid message error"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x4A
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Command phase error"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x4B
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Data phase error"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x4C
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Logical unit failed self-configuration"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x4D
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Tagged overlapped commands: ASCQ = Queue tag ID"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x4D
argument_list|,
literal|0xFF
argument_list|,
argument|SS_RDEF|SSQ_RANGE
argument_list|,
argument|NULL
argument_list|)
block|}
block|,
comment|/* Range 0x00->0xFF */
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x4E
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Overlapped commands attempted"
argument_list|)
block|}
block|,
comment|/*  T           */
block|{
name|SST
argument_list|(
literal|0x50
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Write append error"
argument_list|)
block|}
block|,
comment|/*  T           */
block|{
name|SST
argument_list|(
literal|0x50
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Write append position error"
argument_list|)
block|}
block|,
comment|/*  T           */
block|{
name|SST
argument_list|(
literal|0x50
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Position error related to timing"
argument_list|)
block|}
block|,
comment|/*  T     O     */
block|{
name|SST
argument_list|(
literal|0x51
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Erase failure"
argument_list|)
block|}
block|,
comment|/*  T           */
block|{
name|SST
argument_list|(
literal|0x52
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Cartridge fault"
argument_list|)
block|}
block|,
comment|/* DTL WRSOM    */
block|{
name|SST
argument_list|(
literal|0x53
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Media load or eject failed"
argument_list|)
block|}
block|,
comment|/*  T           */
block|{
name|SST
argument_list|(
literal|0x53
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Unload tape failure"
argument_list|)
block|}
block|,
comment|/* DT  WR OM    */
block|{
name|SST
argument_list|(
literal|0x53
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Medium removal prevented"
argument_list|)
block|}
block|,
comment|/*    P         */
block|{
name|SST
argument_list|(
literal|0x54
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Scsi to host system interface failure"
argument_list|)
block|}
block|,
comment|/*    P         */
block|{
name|SST
argument_list|(
literal|0x55
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"System resource failure"
argument_list|)
block|}
block|,
comment|/* D      O     */
block|{
name|SST
argument_list|(
literal|0x55
argument_list|,
literal|0x01
argument_list|,
argument|SS_FATAL|ENOSPC
argument_list|,
literal|"System buffer full"
argument_list|)
block|}
block|,
comment|/*      R       */
block|{
name|SST
argument_list|(
literal|0x57
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Unable to recover table-of-contents"
argument_list|)
block|}
block|,
comment|/*        O     */
block|{
name|SST
argument_list|(
literal|0x58
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Generation does not exist"
argument_list|)
block|}
block|,
comment|/*        O     */
block|{
name|SST
argument_list|(
literal|0x59
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Updated block read"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOM    */
block|{
name|SST
argument_list|(
literal|0x5A
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Operator request or state change input"
argument_list|)
block|}
block|,
comment|/* DT  WR OM    */
block|{
name|SST
argument_list|(
literal|0x5A
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Operator medium removal request"
argument_list|)
block|}
block|,
comment|/* DT  W  O     */
block|{
name|SST
argument_list|(
literal|0x5A
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Operator selected write protect"
argument_list|)
block|}
block|,
comment|/* DT  W  O     */
block|{
name|SST
argument_list|(
literal|0x5A
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Operator selected write permit"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOM    */
block|{
name|SST
argument_list|(
literal|0x5B
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Log exception"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOM    */
block|{
name|SST
argument_list|(
literal|0x5B
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Threshold condition met"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOM    */
block|{
name|SST
argument_list|(
literal|0x5B
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Log counter at maximum"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOM    */
block|{
name|SST
argument_list|(
literal|0x5B
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Log list codes exhausted"
argument_list|)
block|}
block|,
comment|/* D      O     */
block|{
name|SST
argument_list|(
literal|0x5C
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"RPL status change"
argument_list|)
block|}
block|,
comment|/* D      O     */
block|{
name|SST
argument_list|(
literal|0x5C
argument_list|,
literal|0x01
argument_list|,
argument|SS_NOP|SSQ_PRINT_SENSE
argument_list|,
literal|"Spindles synchronized"
argument_list|)
block|}
block|,
comment|/* D      O     */
block|{
name|SST
argument_list|(
literal|0x5C
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Spindles not synchronized"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Failure prediction threshold exceeded"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x5D
argument_list|,
literal|0xFF
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Failure prediction threshold exceeded (false)"
argument_list|)
block|}
block|,
comment|/* DTLPWRSO CA  */
block|{
name|SST
argument_list|(
literal|0x5E
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Low power condition on"
argument_list|)
block|}
block|,
comment|/* DTLPWRSO CA  */
block|{
name|SST
argument_list|(
literal|0x5E
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Idle condition activated by timer"
argument_list|)
block|}
block|,
comment|/* DTLPWRSO CA  */
block|{
name|SST
argument_list|(
literal|0x5E
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Standby condition activated by timer"
argument_list|)
block|}
block|,
comment|/* DTLPWRSO CA  */
block|{
name|SST
argument_list|(
literal|0x5E
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Idle condition activated by command"
argument_list|)
block|}
block|,
comment|/* DTLPWRSO CA  */
block|{
name|SST
argument_list|(
literal|0x5E
argument_list|,
literal|0x04
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Standby condition activated by command"
argument_list|)
block|}
block|,
comment|/*       S      */
block|{
name|SST
argument_list|(
literal|0x60
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Lamp failure"
argument_list|)
block|}
block|,
comment|/*       S      */
block|{
name|SST
argument_list|(
literal|0x61
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Video acquisition error"
argument_list|)
block|}
block|,
comment|/*       S      */
block|{
name|SST
argument_list|(
literal|0x61
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Unable to acquire video"
argument_list|)
block|}
block|,
comment|/*       S      */
block|{
name|SST
argument_list|(
literal|0x61
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Out of focus"
argument_list|)
block|}
block|,
comment|/*       S      */
block|{
name|SST
argument_list|(
literal|0x62
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Scan head positioning error"
argument_list|)
block|}
block|,
comment|/*      R       */
block|{
name|SST
argument_list|(
literal|0x63
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"End of user area encountered on this track"
argument_list|)
block|}
block|,
comment|/*      R       */
block|{
name|SST
argument_list|(
literal|0x63
argument_list|,
literal|0x01
argument_list|,
argument|SS_FATAL|ENOSPC
argument_list|,
literal|"Packet does not fit in available space"
argument_list|)
block|}
block|,
comment|/*      R       */
block|{
name|SST
argument_list|(
literal|0x64
argument_list|,
literal|0x00
argument_list|,
argument|SS_FATAL|ENXIO
argument_list|,
literal|"Illegal mode for this track"
argument_list|)
block|}
block|,
comment|/*      R       */
block|{
name|SST
argument_list|(
literal|0x64
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Invalid packet size"
argument_list|)
block|}
block|,
comment|/* DTLPWRSOMCAE */
block|{
name|SST
argument_list|(
literal|0x65
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Voltage fault"
argument_list|)
block|}
block|,
comment|/*       S      */
block|{
name|SST
argument_list|(
literal|0x66
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Automatic document feeder cover up"
argument_list|)
block|}
block|,
comment|/*       S      */
block|{
name|SST
argument_list|(
literal|0x66
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Automatic document feeder lift up"
argument_list|)
block|}
block|,
comment|/*       S      */
block|{
name|SST
argument_list|(
literal|0x66
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Document jam in automatic document feeder"
argument_list|)
block|}
block|,
comment|/*       S      */
block|{
name|SST
argument_list|(
literal|0x66
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Document miss feed automatic in document feeder"
argument_list|)
block|}
block|,
comment|/*           A  */
block|{
name|SST
argument_list|(
literal|0x67
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Configuration failure"
argument_list|)
block|}
block|,
comment|/*           A  */
block|{
name|SST
argument_list|(
literal|0x67
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Configuration of incapable logical units failed"
argument_list|)
block|}
block|,
comment|/*           A  */
block|{
name|SST
argument_list|(
literal|0x67
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Add logical unit failed"
argument_list|)
block|}
block|,
comment|/*           A  */
block|{
name|SST
argument_list|(
literal|0x67
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Modification of logical unit failed"
argument_list|)
block|}
block|,
comment|/*           A  */
block|{
name|SST
argument_list|(
literal|0x67
argument_list|,
literal|0x04
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Exchange of logical unit failed"
argument_list|)
block|}
block|,
comment|/*           A  */
block|{
name|SST
argument_list|(
literal|0x67
argument_list|,
literal|0x05
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Remove of logical unit failed"
argument_list|)
block|}
block|,
comment|/*           A  */
block|{
name|SST
argument_list|(
literal|0x67
argument_list|,
literal|0x06
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Attachment of logical unit failed"
argument_list|)
block|}
block|,
comment|/*           A  */
block|{
name|SST
argument_list|(
literal|0x67
argument_list|,
literal|0x07
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Creation of logical unit failed"
argument_list|)
block|}
block|,
comment|/*           A  */
block|{
name|SST
argument_list|(
literal|0x68
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Logical unit not configured"
argument_list|)
block|}
block|,
comment|/*           A  */
block|{
name|SST
argument_list|(
literal|0x69
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Data loss on logical unit"
argument_list|)
block|}
block|,
comment|/*           A  */
block|{
name|SST
argument_list|(
literal|0x69
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Multiple logical unit failures"
argument_list|)
block|}
block|,
comment|/*           A  */
block|{
name|SST
argument_list|(
literal|0x69
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Parity/data mismatch"
argument_list|)
block|}
block|,
comment|/*           A  */
block|{
name|SST
argument_list|(
literal|0x6A
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Informational, refer to log"
argument_list|)
block|}
block|,
comment|/*           A  */
block|{
name|SST
argument_list|(
literal|0x6B
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"State change has occurred"
argument_list|)
block|}
block|,
comment|/*           A  */
block|{
name|SST
argument_list|(
literal|0x6B
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Redundancy level got better"
argument_list|)
block|}
block|,
comment|/*           A  */
block|{
name|SST
argument_list|(
literal|0x6B
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Redundancy level got worse"
argument_list|)
block|}
block|,
comment|/*           A  */
block|{
name|SST
argument_list|(
literal|0x6C
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Rebuild failure occurred"
argument_list|)
block|}
block|,
comment|/*           A  */
block|{
name|SST
argument_list|(
literal|0x6D
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Recalculate failure occurred"
argument_list|)
block|}
block|,
comment|/*           A  */
block|{
name|SST
argument_list|(
literal|0x6E
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Command to logical unit failed"
argument_list|)
block|}
block|,
comment|/*  T           */
block|{
name|SST
argument_list|(
literal|0x70
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Decompression exception short: ASCQ = Algorithm ID"
argument_list|)
block|}
block|,
comment|/*  T           */
block|{
name|SST
argument_list|(
literal|0x70
argument_list|,
literal|0xFF
argument_list|,
argument|SS_RDEF|SSQ_RANGE
argument_list|,
argument|NULL
argument_list|)
block|}
block|,
comment|/* Range 0x00 -> 0xFF */
comment|/*  T           */
block|{
name|SST
argument_list|(
literal|0x71
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Decompression exception long: ASCQ = Algorithm ID"
argument_list|)
block|}
block|,
comment|/*  T           */
block|{
name|SST
argument_list|(
literal|0x71
argument_list|,
literal|0xFF
argument_list|,
argument|SS_RDEF|SSQ_RANGE
argument_list|,
argument|NULL
argument_list|)
block|}
block|,
comment|/* Range 0x00 -> 0xFF */
comment|/*      R       */
block|{
name|SST
argument_list|(
literal|0x72
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Session fixation error"
argument_list|)
block|}
block|,
comment|/*      R       */
block|{
name|SST
argument_list|(
literal|0x72
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Session fixation error writing lead-in"
argument_list|)
block|}
block|,
comment|/*      R       */
block|{
name|SST
argument_list|(
literal|0x72
argument_list|,
literal|0x02
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Session fixation error writing lead-out"
argument_list|)
block|}
block|,
comment|/*      R       */
block|{
name|SST
argument_list|(
literal|0x72
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Session fixation error - incomplete track in session"
argument_list|)
block|}
block|,
comment|/*      R       */
block|{
name|SST
argument_list|(
literal|0x72
argument_list|,
literal|0x04
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Empty or partially written reserved track"
argument_list|)
block|}
block|,
comment|/*      R       */
block|{
name|SST
argument_list|(
literal|0x73
argument_list|,
literal|0x00
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"CD control error"
argument_list|)
block|}
block|,
comment|/*      R       */
block|{
name|SST
argument_list|(
literal|0x73
argument_list|,
literal|0x01
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Power calibration area almost full"
argument_list|)
block|}
block|,
comment|/*      R       */
block|{
name|SST
argument_list|(
literal|0x73
argument_list|,
literal|0x02
argument_list|,
argument|SS_FATAL|ENOSPC
argument_list|,
literal|"Power calibration area is full"
argument_list|)
block|}
block|,
comment|/*      R       */
block|{
name|SST
argument_list|(
literal|0x73
argument_list|,
literal|0x03
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Power calibration area error"
argument_list|)
block|}
block|,
comment|/*      R       */
block|{
name|SST
argument_list|(
literal|0x73
argument_list|,
literal|0x04
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"Program memory area update failure"
argument_list|)
block|}
block|,
comment|/*      R       */
block|{
name|SST
argument_list|(
literal|0x73
argument_list|,
literal|0x05
argument_list|,
argument|SS_RDEF
argument_list|,
literal|"program memory area is full"
argument_list|)
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|asc_table_size
init|=
sizeof|sizeof
argument_list|(
name|asc_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|asc_table
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|asc_key
block|{
name|int
name|asc
decl_stmt|;
name|int
name|ascq
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|ascentrycomp
parameter_list|(
specifier|const
name|void
modifier|*
name|key
parameter_list|,
specifier|const
name|void
modifier|*
name|member
parameter_list|)
block|{
name|int
name|asc
decl_stmt|;
name|int
name|ascq
decl_stmt|;
specifier|const
name|struct
name|asc_table_entry
modifier|*
name|table_entry
decl_stmt|;
name|asc
operator|=
operator|(
operator|(
specifier|const
expr|struct
name|asc_key
operator|*
operator|)
name|key
operator|)
operator|->
name|asc
expr_stmt|;
name|ascq
operator|=
operator|(
operator|(
specifier|const
expr|struct
name|asc_key
operator|*
operator|)
name|key
operator|)
operator|->
name|ascq
expr_stmt|;
name|table_entry
operator|=
operator|(
specifier|const
expr|struct
name|asc_table_entry
operator|*
operator|)
name|member
expr_stmt|;
if|if
condition|(
name|asc
operator|>=
name|table_entry
operator|->
name|asc
condition|)
block|{
if|if
condition|(
name|asc
operator|>
name|table_entry
operator|->
name|asc
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|ascq
operator|<=
name|table_entry
operator|->
name|ascq
condition|)
block|{
comment|/* Check for ranges */
if|if
condition|(
name|ascq
operator|==
name|table_entry
operator|->
name|ascq
operator|||
operator|(
operator|(
name|table_entry
operator|->
name|action
operator|&
name|SSQ_RANGE
operator|)
operator|!=
literal|0
operator|&&
name|ascq
operator|>=
operator|(
name|table_entry
operator|-
literal|1
operator|)
operator|->
name|ascq
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|senseentrycomp
parameter_list|(
specifier|const
name|void
modifier|*
name|key
parameter_list|,
specifier|const
name|void
modifier|*
name|member
parameter_list|)
block|{
name|int
name|sense_key
decl_stmt|;
specifier|const
name|struct
name|sense_key_table_entry
modifier|*
name|table_entry
decl_stmt|;
name|sense_key
operator|=
operator|*
operator|(
operator|(
specifier|const
name|int
operator|*
operator|)
name|key
operator|)
expr_stmt|;
name|table_entry
operator|=
operator|(
specifier|const
expr|struct
name|sense_key_table_entry
operator|*
operator|)
name|member
expr_stmt|;
if|if
condition|(
name|sense_key
operator|>=
name|table_entry
operator|->
name|sense_key
condition|)
block|{
if|if
condition|(
name|sense_key
operator|==
name|table_entry
operator|->
name|sense_key
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fetchtableentries
parameter_list|(
name|int
name|sense_key
parameter_list|,
name|int
name|asc
parameter_list|,
name|int
name|ascq
parameter_list|,
name|struct
name|scsi_inquiry_data
modifier|*
name|inq_data
parameter_list|,
specifier|const
name|struct
name|sense_key_table_entry
modifier|*
modifier|*
name|sense_entry
parameter_list|,
specifier|const
name|struct
name|asc_table_entry
modifier|*
modifier|*
name|asc_entry
parameter_list|)
block|{
name|caddr_t
name|match
decl_stmt|;
specifier|const
name|struct
name|asc_table_entry
modifier|*
name|asc_tables
index|[
literal|2
index|]
decl_stmt|;
specifier|const
name|struct
name|sense_key_table_entry
modifier|*
name|sense_tables
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|asc_key
name|asc_ascq
decl_stmt|;
name|size_t
name|asc_tables_size
index|[
literal|2
index|]
decl_stmt|;
name|size_t
name|sense_tables_size
index|[
literal|2
index|]
decl_stmt|;
name|int
name|num_asc_tables
decl_stmt|;
name|int
name|num_sense_tables
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Default to failure */
operator|*
name|sense_entry
operator|=
name|NULL
expr_stmt|;
operator|*
name|asc_entry
operator|=
name|NULL
expr_stmt|;
name|match
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|inq_data
operator|!=
name|NULL
condition|)
name|match
operator|=
name|cam_quirkmatch
argument_list|(
operator|(
name|caddr_t
operator|)
name|inq_data
argument_list|,
operator|(
name|caddr_t
operator|)
name|sense_quirk_table
argument_list|,
name|sense_quirk_table_size
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sense_quirk_table
argument_list|)
argument_list|,
name|scsi_inquiry_match
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
operator|!=
name|NULL
condition|)
block|{
name|struct
name|scsi_sense_quirk_entry
modifier|*
name|quirk
decl_stmt|;
name|quirk
operator|=
operator|(
expr|struct
name|scsi_sense_quirk_entry
operator|*
operator|)
name|match
expr_stmt|;
name|asc_tables
index|[
literal|0
index|]
operator|=
name|quirk
operator|->
name|asc_info
expr_stmt|;
name|asc_tables_size
index|[
literal|0
index|]
operator|=
name|quirk
operator|->
name|num_ascs
expr_stmt|;
name|asc_tables
index|[
literal|1
index|]
operator|=
name|asc_table
expr_stmt|;
name|asc_tables_size
index|[
literal|1
index|]
operator|=
name|asc_table_size
expr_stmt|;
name|num_asc_tables
operator|=
literal|2
expr_stmt|;
name|sense_tables
index|[
literal|0
index|]
operator|=
name|quirk
operator|->
name|sense_key_info
expr_stmt|;
name|sense_tables_size
index|[
literal|0
index|]
operator|=
name|quirk
operator|->
name|num_sense_keys
expr_stmt|;
name|sense_tables
index|[
literal|1
index|]
operator|=
name|sense_key_table
expr_stmt|;
name|sense_tables_size
index|[
literal|1
index|]
operator|=
name|sense_key_table_size
expr_stmt|;
name|num_sense_tables
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|asc_tables
index|[
literal|0
index|]
operator|=
name|asc_table
expr_stmt|;
name|asc_tables_size
index|[
literal|0
index|]
operator|=
name|asc_table_size
expr_stmt|;
name|num_asc_tables
operator|=
literal|1
expr_stmt|;
name|sense_tables
index|[
literal|0
index|]
operator|=
name|sense_key_table
expr_stmt|;
name|sense_tables_size
index|[
literal|0
index|]
operator|=
name|sense_key_table_size
expr_stmt|;
name|num_sense_tables
operator|=
literal|1
expr_stmt|;
block|}
name|asc_ascq
operator|.
name|asc
operator|=
name|asc
expr_stmt|;
name|asc_ascq
operator|.
name|ascq
operator|=
name|ascq
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_asc_tables
condition|;
name|i
operator|++
control|)
block|{
name|void
modifier|*
name|found_entry
decl_stmt|;
name|found_entry
operator|=
name|bsearch
argument_list|(
operator|&
name|asc_ascq
argument_list|,
name|asc_tables
index|[
name|i
index|]
argument_list|,
name|asc_tables_size
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|asc_tables
argument_list|)
argument_list|,
name|ascentrycomp
argument_list|)
expr_stmt|;
if|if
condition|(
name|found_entry
condition|)
block|{
operator|*
name|asc_entry
operator|=
operator|(
expr|struct
name|asc_table_entry
operator|*
operator|)
name|found_entry
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_sense_tables
condition|;
name|i
operator|++
control|)
block|{
name|void
modifier|*
name|found_entry
decl_stmt|;
name|found_entry
operator|=
name|bsearch
argument_list|(
operator|&
name|sense_key
argument_list|,
name|sense_tables
index|[
name|i
index|]
argument_list|,
name|sense_tables_size
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|sense_tables
argument_list|)
argument_list|,
name|senseentrycomp
argument_list|)
expr_stmt|;
if|if
condition|(
name|found_entry
condition|)
block|{
operator|*
name|sense_entry
operator|=
operator|(
expr|struct
name|sense_key_table_entry
operator|*
operator|)
name|found_entry
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
name|void
name|scsi_sense_desc
parameter_list|(
name|int
name|sense_key
parameter_list|,
name|int
name|asc
parameter_list|,
name|int
name|ascq
parameter_list|,
name|struct
name|scsi_inquiry_data
modifier|*
name|inq_data
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|sense_key_desc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|asc_desc
parameter_list|)
block|{
specifier|const
name|struct
name|asc_table_entry
modifier|*
name|asc_entry
decl_stmt|;
specifier|const
name|struct
name|sense_key_table_entry
modifier|*
name|sense_entry
decl_stmt|;
name|fetchtableentries
argument_list|(
name|sense_key
argument_list|,
name|asc
argument_list|,
name|ascq
argument_list|,
name|inq_data
argument_list|,
operator|&
name|sense_entry
argument_list|,
operator|&
name|asc_entry
argument_list|)
expr_stmt|;
operator|*
name|sense_key_desc
operator|=
name|sense_entry
operator|->
name|desc
expr_stmt|;
if|if
condition|(
name|asc_entry
operator|!=
name|NULL
condition|)
operator|*
name|asc_desc
operator|=
name|asc_entry
operator|->
name|desc
expr_stmt|;
elseif|else
if|if
condition|(
name|asc
operator|>=
literal|0x80
operator|&&
name|asc
operator|<=
literal|0xff
condition|)
operator|*
name|asc_desc
operator|=
literal|"Vendor Specific ASC"
expr_stmt|;
elseif|else
if|if
condition|(
name|ascq
operator|>=
literal|0x80
operator|&&
name|ascq
operator|<=
literal|0xff
condition|)
operator|*
name|asc_desc
operator|=
literal|"Vendor Specific ASCQ"
expr_stmt|;
else|else
operator|*
name|asc_desc
operator|=
literal|"Reserved ASC/ASCQ pair"
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Given sense and device type information, return the appropriate action.  * If we do not understand the specific error as identified by the ASC/ASCQ  * pair, fall back on the more generic actions derived from the sense key.  */
end_comment

begin_function
name|scsi_sense_action
name|scsi_error_action
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|struct
name|scsi_inquiry_data
modifier|*
name|inq_data
parameter_list|,
name|u_int32_t
name|sense_flags
parameter_list|)
block|{
specifier|const
name|struct
name|asc_table_entry
modifier|*
name|asc_entry
decl_stmt|;
specifier|const
name|struct
name|sense_key_table_entry
modifier|*
name|sense_entry
decl_stmt|;
name|int
name|error_code
decl_stmt|,
name|sense_key
decl_stmt|,
name|asc
decl_stmt|,
name|ascq
decl_stmt|;
name|scsi_sense_action
name|action
decl_stmt|;
name|scsi_extract_sense
argument_list|(
operator|&
name|csio
operator|->
name|sense_data
argument_list|,
operator|&
name|error_code
argument_list|,
operator|&
name|sense_key
argument_list|,
operator|&
name|asc
argument_list|,
operator|&
name|ascq
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_code
operator|==
name|SSD_DEFERRED_ERROR
condition|)
block|{
comment|/* 		 * XXX dufault@FreeBSD.org 		 * This error doesn't relate to the command associated 		 * with this request sense.  A deferred error is an error 		 * for a command that has already returned GOOD status 		 * (see SCSI2 8.2.14.2). 		 * 		 * By my reading of that section, it looks like the current 		 * command has been cancelled, we should now clean things up 		 * (hopefully recovering any lost data) and then retry the 		 * current command.  There are two easy choices, both wrong: 		 * 		 * 1. Drop through (like we had been doing), thus treating 		 *    this as if the error were for the current command and 		 *    return and stop the current command. 		 *  		 * 2. Issue a retry (like I made it do) thus hopefully 		 *    recovering the current transfer, and ignoring the 		 *    fact that we've dropped a command. 		 * 		 * These should probably be handled in a device specific 		 * sense handler or punted back up to a user mode daemon 		 */
name|action
operator|=
name|SS_RETRY
operator||
name|SSQ_DECREMENT_COUNT
operator||
name|SSQ_PRINT_SENSE
expr_stmt|;
block|}
else|else
block|{
name|fetchtableentries
argument_list|(
name|sense_key
argument_list|,
name|asc
argument_list|,
name|ascq
argument_list|,
name|inq_data
argument_list|,
operator|&
name|sense_entry
argument_list|,
operator|&
name|asc_entry
argument_list|)
expr_stmt|;
comment|/* 		 * Override the 'No additional Sense' entry (0,0) 		 * with the error action of the sense key. 		 */
if|if
condition|(
name|asc_entry
operator|!=
name|NULL
operator|&&
operator|(
name|asc
operator|!=
literal|0
operator|||
name|ascq
operator|!=
literal|0
operator|)
condition|)
name|action
operator|=
name|asc_entry
operator|->
name|action
expr_stmt|;
else|else
name|action
operator|=
name|sense_entry
operator|->
name|action
expr_stmt|;
if|if
condition|(
name|sense_key
operator|==
name|SSD_KEY_RECOVERED_ERROR
condition|)
block|{
comment|/* 			 * The action succeeded but the device wants 			 * the user to know that some recovery action 			 * was required. 			 */
name|action
operator|&=
operator|~
operator|(
name|SS_MASK
operator||
name|SSQ_MASK
operator||
name|SS_ERRMASK
operator|)
expr_stmt|;
name|action
operator||=
name|SS_NOP
operator||
name|SSQ_PRINT_SENSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sense_key
operator|==
name|SSD_KEY_ILLEGAL_REQUEST
condition|)
block|{
if|if
condition|(
operator|(
name|sense_flags
operator|&
name|SF_QUIET_IR
operator|)
operator|!=
literal|0
condition|)
name|action
operator|&=
operator|~
name|SSQ_PRINT_SENSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sense_key
operator|==
name|SSD_KEY_UNIT_ATTENTION
condition|)
block|{
if|if
condition|(
operator|(
name|sense_flags
operator|&
name|SF_RETRY_UA
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|action
operator|&
name|SS_MASK
operator|)
operator|==
name|SS_FAIL
condition|)
block|{
name|action
operator|&=
operator|~
operator|(
name|SS_MASK
operator||
name|SSQ_MASK
operator|)
expr_stmt|;
name|action
operator||=
name|SS_RETRY
operator||
name|SSQ_DECREMENT_COUNT
operator||
name|SSQ_PRINT_SENSE
expr_stmt|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|KERNEL
if|if
condition|(
name|bootverbose
condition|)
name|sense_flags
operator||=
name|SF_PRINT_ALWAYS
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|sense_flags
operator|&
name|SF_PRINT_ALWAYS
operator|)
operator|!=
literal|0
condition|)
name|action
operator||=
name|SSQ_PRINT_SENSE
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|sense_flags
operator|&
name|SF_NO_PRINT
operator|)
operator|!=
literal|0
condition|)
name|action
operator|&=
operator|~
name|SSQ_PRINT_SENSE
expr_stmt|;
return|return
operator|(
name|action
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|scsi_cdb_string
parameter_list|(
name|u_int8_t
modifier|*
name|cdb_ptr
parameter_list|,
name|char
modifier|*
name|cdb_string
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|u_int8_t
name|cdb_len
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|cdb_ptr
operator|==
name|NULL
condition|)
return|return
operator|(
literal|""
operator|)
return|;
comment|/* Silence warnings */
name|cdb_len
operator|=
literal|0
expr_stmt|;
comment|/* 	 * This is taken from the SCSI-3 draft spec. 	 * (T10/1157D revision 0.3) 	 * The top 3 bits of an opcode are the group code.  The next 5 bits 	 * are the command code. 	 * Group 0:  six byte commands 	 * Group 1:  ten byte commands 	 * Group 2:  ten byte commands 	 * Group 3:  reserved 	 * Group 4:  sixteen byte commands 	 * Group 5:  twelve byte commands 	 * Group 6:  vendor specific 	 * Group 7:  vendor specific 	 */
switch|switch
condition|(
operator|(
operator|*
name|cdb_ptr
operator|>>
literal|5
operator|)
operator|&
literal|0x7
condition|)
block|{
case|case
literal|0
case|:
name|cdb_len
operator|=
literal|6
expr_stmt|;
break|break;
case|case
literal|1
case|:
case|case
literal|2
case|:
name|cdb_len
operator|=
literal|10
expr_stmt|;
break|break;
case|case
literal|3
case|:
case|case
literal|6
case|:
case|case
literal|7
case|:
comment|/* in this case, just print out the opcode */
name|cdb_len
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|cdb_len
operator|=
literal|16
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|cdb_len
operator|=
literal|12
expr_stmt|;
break|break;
block|}
operator|*
name|cdb_string
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cdb_len
condition|;
name|i
operator|++
control|)
name|snprintf
argument_list|(
name|cdb_string
operator|+
name|strlen
argument_list|(
name|cdb_string
argument_list|)
argument_list|,
name|len
operator|-
name|strlen
argument_list|(
name|cdb_string
argument_list|)
argument_list|,
literal|"%x "
argument_list|,
name|cdb_ptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|cdb_string
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|scsi_status_string
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|)
block|{
switch|switch
condition|(
name|csio
operator|->
name|scsi_status
condition|)
block|{
case|case
name|SCSI_STATUS_OK
case|:
return|return
operator|(
literal|"OK"
operator|)
return|;
case|case
name|SCSI_STATUS_CHECK_COND
case|:
return|return
operator|(
literal|"Check Condition"
operator|)
return|;
case|case
name|SCSI_STATUS_BUSY
case|:
return|return
operator|(
literal|"Busy"
operator|)
return|;
case|case
name|SCSI_STATUS_INTERMED
case|:
return|return
operator|(
literal|"Intermediate"
operator|)
return|;
case|case
name|SCSI_STATUS_INTERMED_COND_MET
case|:
return|return
operator|(
literal|"Intermediate-Condition Met"
operator|)
return|;
case|case
name|SCSI_STATUS_RESERV_CONFLICT
case|:
return|return
operator|(
literal|"Reservation Conflict"
operator|)
return|;
case|case
name|SCSI_STATUS_CMD_TERMINATED
case|:
return|return
operator|(
literal|"Command Terminated"
operator|)
return|;
case|case
name|SCSI_STATUS_QUEUE_FULL
case|:
return|return
operator|(
literal|"Queue Full"
operator|)
return|;
case|case
name|SCSI_STATUS_ACA_ACTIVE
case|:
return|return
operator|(
literal|"ACA Active"
operator|)
return|;
case|case
name|SCSI_STATUS_TASK_ABORTED
case|:
return|return
operator|(
literal|"Task Aborted"
operator|)
return|;
default|default:
block|{
specifier|static
name|char
name|unkstr
index|[
literal|64
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|unkstr
argument_list|,
sizeof|sizeof
argument_list|(
name|unkstr
argument_list|)
argument_list|,
literal|"Unknown %#x"
argument_list|,
name|csio
operator|->
name|scsi_status
argument_list|)
expr_stmt|;
return|return
operator|(
name|unkstr
operator|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * scsi_command_string() returns 0 for success and -1 for failure.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_decl_stmt
name|int
name|scsi_command_string
argument_list|(
expr|struct
name|ccb_scsiio
operator|*
name|csio
argument_list|,
expr|struct
name|sbuf
operator|*
name|sb
argument_list|)
else|#
directive|else
comment|/* !_KERNEL */
name|int
name|scsi_command_string
argument_list|(
expr|struct
name|cam_device
operator|*
name|device
argument_list|,
expr|struct
name|ccb_scsiio
operator|*
name|csio
argument_list|,
expr|struct
name|sbuf
operator|*
name|sb
argument_list|)
endif|#
directive|endif
comment|/* _KERNEL/!_KERNEL */
block|{
name|struct
name|scsi_inquiry_data
modifier|*
name|inq_data
decl_stmt|;
name|char
name|cdb_str
index|[
operator|(
name|SCSI_MAX_CDBLEN
operator|*
literal|3
operator|)
operator|+
literal|1
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
name|struct
name|ccb_getdev
name|cgd
decl_stmt|;
endif|#
directive|endif
comment|/* _KERNEL */
ifdef|#
directive|ifdef
name|_KERNEL
comment|/* 	 * Get the device information. 	 */
name|xpt_setup_ccb
argument_list|(
operator|&
name|cgd
operator|.
name|ccb_h
argument_list|,
name|csio
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|cgd
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_GDEV_TYPE
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|cgd
argument_list|)
expr_stmt|;
comment|/* 	 * If the device is unconfigured, just pretend that it is a hard 	 * drive.  scsi_op_desc() needs this. 	 */
if|if
condition|(
name|cgd
operator|.
name|ccb_h
operator|.
name|status
operator|==
name|CAM_DEV_NOT_THERE
condition|)
name|cgd
operator|.
name|inq_data
operator|.
name|device
operator|=
name|T_DIRECT
expr_stmt|;
name|inq_data
operator|=
operator|&
name|cgd
operator|.
name|inq_data
expr_stmt|;
else|#
directive|else
comment|/* !_KERNEL */
name|inq_data
operator|=
operator|&
name|device
operator|->
name|inq_data
expr_stmt|;
endif|#
directive|endif
comment|/* _KERNEL/!_KERNEL */
if|if
condition|(
operator|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_POINTER
operator|)
operator|!=
literal|0
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s. CDB: %s"
argument_list|,
name|scsi_op_desc
argument_list|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_ptr
index|[
literal|0
index|]
argument_list|,
name|inq_data
argument_list|)
argument_list|,
name|scsi_cdb_string
argument_list|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_ptr
argument_list|,
name|cdb_str
argument_list|,
sizeof|sizeof
argument_list|(
name|cdb_str
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s. CDB: %s"
argument_list|,
name|scsi_op_desc
argument_list|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
argument_list|,
name|inq_data
argument_list|)
argument_list|,
name|scsi_cdb_string
argument_list|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|cdb_str
argument_list|,
sizeof|sizeof
argument_list|(
name|cdb_str
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/*  * scsi_sense_sbuf() returns 0 for success and -1 for failure.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_decl_stmt
name|int
name|scsi_sense_sbuf
argument_list|(
expr|struct
name|ccb_scsiio
operator|*
name|csio
argument_list|,
expr|struct
name|sbuf
operator|*
name|sb
argument_list|,
name|scsi_sense_string_flags
name|flags
argument_list|)
else|#
directive|else
comment|/* !_KERNEL */
name|int
name|scsi_sense_sbuf
argument_list|(
expr|struct
name|cam_device
operator|*
name|device
argument_list|,
expr|struct
name|ccb_scsiio
operator|*
name|csio
argument_list|,
expr|struct
name|sbuf
operator|*
name|sb
argument_list|,
name|scsi_sense_string_flags
name|flags
argument_list|)
endif|#
directive|endif
comment|/* _KERNEL/!_KERNEL */
block|{
name|struct
name|scsi_sense_data
modifier|*
name|sense
decl_stmt|;
name|struct
name|scsi_inquiry_data
modifier|*
name|inq_data
decl_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
name|struct
name|ccb_getdev
name|cgd
decl_stmt|;
endif|#
directive|endif
comment|/* _KERNEL */
name|u_int32_t
name|info
decl_stmt|;
name|int
name|error_code
decl_stmt|;
name|int
name|sense_key
decl_stmt|;
name|int
name|asc
decl_stmt|,
name|ascq
decl_stmt|;
name|char
name|path_str
index|[
literal|64
index|]
decl_stmt|;
ifndef|#
directive|ifndef
name|_KERNEL
if|if
condition|(
name|device
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
endif|#
directive|endif
comment|/* !_KERNEL */
if|if
condition|(
operator|(
name|csio
operator|==
name|NULL
operator|)
operator|||
operator|(
name|sb
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * If the CDB is a physical address, we can't deal with it.. 	 */
if|if
condition|(
operator|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_PHYS
operator|)
operator|!=
literal|0
condition|)
name|flags
operator|&=
operator|~
name|SSS_FLAG_PRINT_COMMAND
expr_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
name|xpt_path_string
argument_list|(
name|csio
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|path_str
argument_list|,
sizeof|sizeof
argument_list|(
name|path_str
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !_KERNEL */
name|cam_path_string
argument_list|(
name|device
argument_list|,
name|path_str
argument_list|,
sizeof|sizeof
argument_list|(
name|path_str
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _KERNEL/!_KERNEL */
ifdef|#
directive|ifdef
name|_KERNEL
comment|/* 	 * Get the device information. 	 */
name|xpt_setup_ccb
argument_list|(
operator|&
name|cgd
operator|.
name|ccb_h
argument_list|,
name|csio
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|cgd
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_GDEV_TYPE
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|cgd
argument_list|)
expr_stmt|;
comment|/* 	 * If the device is unconfigured, just pretend that it is a hard 	 * drive.  scsi_op_desc() needs this. 	 */
if|if
condition|(
name|cgd
operator|.
name|ccb_h
operator|.
name|status
operator|==
name|CAM_DEV_NOT_THERE
condition|)
name|cgd
operator|.
name|inq_data
operator|.
name|device
operator|=
name|T_DIRECT
expr_stmt|;
name|inq_data
operator|=
operator|&
name|cgd
operator|.
name|inq_data
expr_stmt|;
else|#
directive|else
comment|/* !_KERNEL */
name|inq_data
operator|=
operator|&
name|device
operator|->
name|inq_data
expr_stmt|;
endif|#
directive|endif
comment|/* _KERNEL/!_KERNEL */
name|sense
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SSS_FLAG_PRINT_COMMAND
condition|)
block|{
name|sbuf_cat
argument_list|(
name|sb
argument_list|,
name|path_str
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
name|scsi_command_string
argument_list|(
name|csio
argument_list|,
name|sb
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !_KERNEL */
name|scsi_command_string
argument_list|(
name|device
argument_list|,
name|csio
argument_list|,
name|sb
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _KERNEL/!_KERNEL */
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the sense data is a physical pointer, forget it. 	 */
if|if
condition|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SENSE_PTR
condition|)
block|{
if|if
condition|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SENSE_PHYS
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|else
block|{
comment|/*  			 * bcopy the pointer to avoid unaligned access 			 * errors on finicky architectures.  We don't 			 * ensure that the sense data is pointer aligned. 			 */
name|bcopy
argument_list|(
operator|&
name|csio
operator|->
name|sense_data
argument_list|,
name|sense
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * If the physical sense flag is set, but the sense pointer 		 * is not also set, we assume that the user is an idiot and 		 * return.  (Well, okay, it could be that somehow, the 		 * entire csio is physical, but we would have probably core 		 * dumped on one of the bogus pointer deferences above 		 * already.) 		 */
if|if
condition|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SENSE_PHYS
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|else
name|sense
operator|=
operator|&
name|csio
operator|->
name|sense_data
expr_stmt|;
block|}
name|sbuf_cat
argument_list|(
name|sb
argument_list|,
name|path_str
argument_list|)
expr_stmt|;
name|error_code
operator|=
name|sense
operator|->
name|error_code
operator|&
name|SSD_ERRCODE
expr_stmt|;
name|sense_key
operator|=
name|sense
operator|->
name|flags
operator|&
name|SSD_KEY
expr_stmt|;
switch|switch
condition|(
name|error_code
condition|)
block|{
case|case
name|SSD_DEFERRED_ERROR
case|:
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"Deferred Error: "
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|SSD_CURRENT_ERROR
case|:
block|{
specifier|const
name|char
modifier|*
name|sense_key_desc
decl_stmt|;
specifier|const
name|char
modifier|*
name|asc_desc
decl_stmt|;
name|asc
operator|=
operator|(
name|sense
operator|->
name|extra_len
operator|>=
literal|5
operator|)
condition|?
name|sense
operator|->
name|add_sense_code
else|:
literal|0
expr_stmt|;
name|ascq
operator|=
operator|(
name|sense
operator|->
name|extra_len
operator|>=
literal|6
operator|)
condition|?
name|sense
operator|->
name|add_sense_code_qual
else|:
literal|0
expr_stmt|;
name|scsi_sense_desc
argument_list|(
name|sense_key
argument_list|,
name|asc
argument_list|,
name|ascq
argument_list|,
name|inq_data
argument_list|,
operator|&
name|sense_key_desc
argument_list|,
operator|&
name|asc_desc
argument_list|)
expr_stmt|;
name|sbuf_cat
argument_list|(
name|sb
argument_list|,
name|sense_key_desc
argument_list|)
expr_stmt|;
name|info
operator|=
name|scsi_4btoul
argument_list|(
name|sense
operator|->
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|sense
operator|->
name|error_code
operator|&
name|SSD_ERRCODE_VALID
condition|)
block|{
switch|switch
condition|(
name|sense_key
condition|)
block|{
case|case
name|SSD_KEY_NOT_READY
case|:
case|case
name|SSD_KEY_ILLEGAL_REQUEST
case|:
case|case
name|SSD_KEY_UNIT_ATTENTION
case|:
case|case
name|SSD_KEY_DATA_PROTECT
case|:
break|break;
case|case
name|SSD_KEY_BLANK_CHECK
case|:
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" req sz: %d (decimal)"
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|info
condition|)
block|{
if|if
condition|(
name|sense
operator|->
name|flags
operator|&
name|SSD_ILI
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" ILI (length "
literal|"mismatch): %d"
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" info:%x"
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|info
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" info?:%x"
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sense
operator|->
name|extra_len
operator|>=
literal|4
condition|)
block|{
if|if
condition|(
name|bcmp
argument_list|(
name|sense
operator|->
name|cmd_spec_info
argument_list|,
literal|"\0\0\0\0"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" csi:%x,%x,%x,%x"
argument_list|,
name|sense
operator|->
name|cmd_spec_info
index|[
literal|0
index|]
argument_list|,
name|sense
operator|->
name|cmd_spec_info
index|[
literal|1
index|]
argument_list|,
name|sense
operator|->
name|cmd_spec_info
index|[
literal|2
index|]
argument_list|,
name|sense
operator|->
name|cmd_spec_info
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" asc:%x,%x\n%s%s"
argument_list|,
name|asc
argument_list|,
name|ascq
argument_list|,
name|path_str
argument_list|,
name|asc_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sense
operator|->
name|extra_len
operator|>=
literal|7
operator|&&
name|sense
operator|->
name|fru
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" field replaceable unit: %x"
argument_list|,
name|sense
operator|->
name|fru
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sense
operator|->
name|extra_len
operator|>=
literal|10
operator|)
operator|&&
operator|(
name|sense
operator|->
name|sense_key_spec
index|[
literal|0
index|]
operator|&
name|SSD_SCS_VALID
operator|)
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|sense_key
condition|)
block|{
case|case
name|SSD_KEY_ILLEGAL_REQUEST
case|:
block|{
name|int
name|bad_command
decl_stmt|;
name|char
name|tmpstr2
index|[
literal|40
index|]
decl_stmt|;
if|if
condition|(
name|sense
operator|->
name|sense_key_spec
index|[
literal|0
index|]
operator|&
literal|0x40
condition|)
name|bad_command
operator|=
literal|1
expr_stmt|;
else|else
name|bad_command
operator|=
literal|0
expr_stmt|;
name|tmpstr2
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Bit pointer is valid */
if|if
condition|(
name|sense
operator|->
name|sense_key_spec
index|[
literal|0
index|]
operator|&
literal|0x08
condition|)
name|snprintf
argument_list|(
name|tmpstr2
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr2
argument_list|)
argument_list|,
literal|"bit %d "
argument_list|,
name|sense
operator|->
name|sense_key_spec
index|[
literal|0
index|]
operator|&
literal|0x7
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|": %s byte %d %sis invalid"
argument_list|,
name|bad_command
condition|?
literal|"Command"
else|:
literal|"Data"
argument_list|,
name|scsi_2btoul
argument_list|(
operator|&
name|sense
operator|->
name|sense_key_spec
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|tmpstr2
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SSD_KEY_RECOVERED_ERROR
case|:
case|case
name|SSD_KEY_HARDWARE_ERROR
case|:
case|case
name|SSD_KEY_MEDIUM_ERROR
case|:
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" actual retry count: %d"
argument_list|,
name|scsi_2btoul
argument_list|(
operator|&
name|sense
operator|->
name|sense_key_spec
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" sks:%#x,%#x"
argument_list|,
name|sense
operator|->
name|sense_key_spec
index|[
literal|0
index|]
argument_list|,
name|scsi_2btoul
argument_list|(
operator|&
name|sense
operator|->
name|sense_key_spec
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
block|}
default|default:
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"Sense Error Code 0x%x"
argument_list|,
name|sense
operator|->
name|error_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|sense
operator|->
name|error_code
operator|&
name|SSD_ERRCODE_VALID
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" at block no. %d (decimal)"
argument_list|,
name|info
operator|=
name|scsi_4btoul
argument_list|(
name|sense
operator|->
name|info
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|scsi_sense_string
argument_list|(
expr|struct
name|ccb_scsiio
operator|*
name|csio
argument_list|,
name|char
operator|*
name|str
argument_list|,
name|int
name|str_len
argument_list|)
else|#
directive|else
comment|/* !_KERNEL */
name|char
modifier|*
name|scsi_sense_string
argument_list|(
expr|struct
name|cam_device
operator|*
name|device
argument_list|,
expr|struct
name|ccb_scsiio
operator|*
name|csio
argument_list|,
name|char
operator|*
name|str
argument_list|,
name|int
name|str_len
argument_list|)
endif|#
directive|endif
comment|/* _KERNEL/!_KERNEL */
block|{
name|struct
name|sbuf
name|sb
decl_stmt|;
name|sbuf_new
argument_list|(
operator|&
name|sb
argument_list|,
name|str
argument_list|,
name|str_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
name|scsi_sense_sbuf
argument_list|(
name|csio
argument_list|,
operator|&
name|sb
argument_list|,
name|SSS_FLAG_PRINT_COMMAND
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !_KERNEL */
name|scsi_sense_sbuf
argument_list|(
name|device
argument_list|,
name|csio
argument_list|,
operator|&
name|sb
argument_list|,
name|SSS_FLAG_PRINT_COMMAND
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _KERNEL/!_KERNEL */
name|sbuf_finish
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|sbuf_data
argument_list|(
operator|&
name|sb
argument_list|)
operator|)
return|;
block|}
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_function
name|void
name|scsi_sense_print
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|)
block|{
name|struct
name|sbuf
name|sb
decl_stmt|;
name|char
name|str
index|[
literal|512
index|]
decl_stmt|;
name|sbuf_new
argument_list|(
operator|&
name|sb
argument_list|,
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|scsi_sense_sbuf
argument_list|(
name|csio
argument_list|,
operator|&
name|sb
argument_list|,
name|SSS_FLAG_PRINT_COMMAND
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|sbuf_data
argument_list|(
operator|&
name|sb
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !_KERNEL */
end_comment

begin_function
name|void
name|scsi_sense_print
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|FILE
modifier|*
name|ofile
parameter_list|)
block|{
name|struct
name|sbuf
name|sb
decl_stmt|;
name|char
name|str
index|[
literal|512
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|device
operator|==
name|NULL
operator|)
operator|||
operator|(
name|csio
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ofile
operator|==
name|NULL
operator|)
condition|)
return|return;
name|sbuf_new
argument_list|(
operator|&
name|sb
argument_list|,
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|scsi_sense_sbuf
argument_list|(
name|device
argument_list|,
name|csio
argument_list|,
operator|&
name|sb
argument_list|,
name|SSS_FLAG_PRINT_COMMAND
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ofile
argument_list|,
literal|"%s"
argument_list|,
name|sbuf_data
argument_list|(
operator|&
name|sb
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _KERNEL/!_KERNEL */
end_comment

begin_comment
comment|/*  * This function currently requires at least 36 bytes, or  * SHORT_INQUIRY_LENGTH, worth of data to function properly.  If this  * function needs more or less data in the future, another length should be  * defined in scsi_all.h to indicate the minimum amount of data necessary  * for this routine to function properly.  */
end_comment

begin_function
name|void
name|scsi_print_inquiry
parameter_list|(
name|struct
name|scsi_inquiry_data
modifier|*
name|inq_data
parameter_list|)
block|{
name|u_int8_t
name|type
decl_stmt|;
name|char
modifier|*
name|dtype
decl_stmt|,
modifier|*
name|qtype
decl_stmt|;
name|char
name|vendor
index|[
literal|16
index|]
decl_stmt|,
name|product
index|[
literal|48
index|]
decl_stmt|,
name|revision
index|[
literal|16
index|]
decl_stmt|,
name|rstr
index|[
literal|4
index|]
decl_stmt|;
name|type
operator|=
name|SID_TYPE
argument_list|(
name|inq_data
argument_list|)
expr_stmt|;
comment|/* 	 * Figure out basic device type and qualifier. 	 */
if|if
condition|(
name|SID_QUAL_IS_VENDOR_UNIQUE
argument_list|(
name|inq_data
argument_list|)
condition|)
block|{
name|qtype
operator|=
literal|"(vendor-unique qualifier)"
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|SID_QUAL
argument_list|(
name|inq_data
argument_list|)
condition|)
block|{
case|case
name|SID_QUAL_LU_CONNECTED
case|:
name|qtype
operator|=
literal|""
expr_stmt|;
break|break;
case|case
name|SID_QUAL_LU_OFFLINE
case|:
name|qtype
operator|=
literal|"(offline)"
expr_stmt|;
break|break;
case|case
name|SID_QUAL_RSVD
case|:
name|qtype
operator|=
literal|"(reserved qualifier)"
expr_stmt|;
break|break;
default|default:
case|case
name|SID_QUAL_BAD_LU
case|:
name|qtype
operator|=
literal|"(lun not supported)"
expr_stmt|;
break|break;
block|}
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_DIRECT
case|:
name|dtype
operator|=
literal|"Direct Access"
expr_stmt|;
break|break;
case|case
name|T_SEQUENTIAL
case|:
name|dtype
operator|=
literal|"Sequential Access"
expr_stmt|;
break|break;
case|case
name|T_PRINTER
case|:
name|dtype
operator|=
literal|"Printer"
expr_stmt|;
break|break;
case|case
name|T_PROCESSOR
case|:
name|dtype
operator|=
literal|"Processor"
expr_stmt|;
break|break;
case|case
name|T_CDROM
case|:
name|dtype
operator|=
literal|"CD-ROM"
expr_stmt|;
break|break;
case|case
name|T_WORM
case|:
name|dtype
operator|=
literal|"Worm"
expr_stmt|;
break|break;
case|case
name|T_SCANNER
case|:
name|dtype
operator|=
literal|"Scanner"
expr_stmt|;
break|break;
case|case
name|T_OPTICAL
case|:
name|dtype
operator|=
literal|"Optical"
expr_stmt|;
break|break;
case|case
name|T_CHANGER
case|:
name|dtype
operator|=
literal|"Changer"
expr_stmt|;
break|break;
case|case
name|T_COMM
case|:
name|dtype
operator|=
literal|"Communication"
expr_stmt|;
break|break;
case|case
name|T_STORARRAY
case|:
name|dtype
operator|=
literal|"Storage Array"
expr_stmt|;
break|break;
case|case
name|T_ENCLOSURE
case|:
name|dtype
operator|=
literal|"Enclosure Services"
expr_stmt|;
break|break;
case|case
name|T_RBC
case|:
name|dtype
operator|=
literal|"Simplified Direct Access"
expr_stmt|;
break|break;
case|case
name|T_OCRW
case|:
name|dtype
operator|=
literal|"Optical Card Read/Write"
expr_stmt|;
break|break;
case|case
name|T_NODEVICE
case|:
name|dtype
operator|=
literal|"Uninstalled"
expr_stmt|;
default|default:
name|dtype
operator|=
literal|"unknown"
expr_stmt|;
break|break;
block|}
name|cam_strvis
argument_list|(
name|vendor
argument_list|,
name|inq_data
operator|->
name|vendor
argument_list|,
sizeof|sizeof
argument_list|(
name|inq_data
operator|->
name|vendor
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|vendor
argument_list|)
argument_list|)
expr_stmt|;
name|cam_strvis
argument_list|(
name|product
argument_list|,
name|inq_data
operator|->
name|product
argument_list|,
sizeof|sizeof
argument_list|(
name|inq_data
operator|->
name|product
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|product
argument_list|)
argument_list|)
expr_stmt|;
name|cam_strvis
argument_list|(
name|revision
argument_list|,
name|inq_data
operator|->
name|revision
argument_list|,
sizeof|sizeof
argument_list|(
name|inq_data
operator|->
name|revision
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|revision
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SID_ANSI_REV
argument_list|(
name|inq_data
argument_list|)
operator|==
name|SCSI_REV_CCS
condition|)
name|bcopy
argument_list|(
literal|"CCS"
argument_list|,
name|rstr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|rstr
argument_list|,
sizeof|sizeof
argument_list|(
name|rstr
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|SID_ANSI_REV
argument_list|(
name|inq_data
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"<%s %s %s> %s %s SCSI-%s device %s\n"
argument_list|,
name|vendor
argument_list|,
name|product
argument_list|,
name|revision
argument_list|,
name|SID_IS_REMOVABLE
argument_list|(
name|inq_data
argument_list|)
condition|?
literal|"Removable"
else|:
literal|"Fixed"
argument_list|,
name|dtype
argument_list|,
name|rstr
argument_list|,
name|qtype
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Table of syncrates that don't follow the "divisible by 4"  * rule. This table will be expanded in future SCSI specs.  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|u_int
name|period_factor
decl_stmt|;
name|u_int
name|period
decl_stmt|;
comment|/* in 100ths of ns */
block|}
name|scsi_syncrates
index|[]
init|=
block|{
block|{
literal|0x08
block|,
literal|625
block|}
block|,
comment|/* FAST-160 */
block|{
literal|0x09
block|,
literal|1250
block|}
block|,
comment|/* FAST-80 */
block|{
literal|0x0a
block|,
literal|2500
block|}
block|,
comment|/* FAST-40 40MHz */
block|{
literal|0x0b
block|,
literal|3030
block|}
block|,
comment|/* FAST-40 33MHz */
block|{
literal|0x0c
block|,
literal|5000
block|}
comment|/* FAST-20 */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Return the frequency in kHz corresponding to the given  * sync period factor.  */
end_comment

begin_function
name|u_int
name|scsi_calc_syncsrate
parameter_list|(
name|u_int
name|period_factor
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|num_syncrates
decl_stmt|;
name|num_syncrates
operator|=
sizeof|sizeof
argument_list|(
name|scsi_syncrates
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|scsi_syncrates
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* See if the period is in the "exception" table */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_syncrates
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|period_factor
operator|==
name|scsi_syncrates
index|[
name|i
index|]
operator|.
name|period_factor
condition|)
block|{
comment|/* Period in kHz */
return|return
operator|(
literal|100000000
operator|/
name|scsi_syncrates
index|[
name|i
index|]
operator|.
name|period
operator|)
return|;
block|}
block|}
comment|/* 	 * Wasn't in the table, so use the standard 	 * 4 times conversion. 	 */
return|return
operator|(
literal|10000000
operator|/
operator|(
name|period_factor
operator|*
literal|4
operator|*
literal|10
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the SCSI sync parameter that corresponsd to  * the passed in period in 10ths of ns.  */
end_comment

begin_function
name|u_int
name|scsi_calc_syncparam
parameter_list|(
name|u_int
name|period
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|num_syncrates
decl_stmt|;
if|if
condition|(
name|period
operator|==
literal|0
condition|)
return|return
operator|(
operator|~
literal|0
operator|)
return|;
comment|/* Async */
comment|/* Adjust for exception table being in 100ths. */
name|period
operator|*=
literal|10
expr_stmt|;
name|num_syncrates
operator|=
sizeof|sizeof
argument_list|(
name|scsi_syncrates
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|scsi_syncrates
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* See if the period is in the "exception" table */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_syncrates
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|period
operator|<=
name|scsi_syncrates
index|[
name|i
index|]
operator|.
name|period
condition|)
block|{
comment|/* Period in 100ths of ns */
return|return
operator|(
name|scsi_syncrates
index|[
name|i
index|]
operator|.
name|period_factor
operator|)
return|;
block|}
block|}
comment|/* 	 * Wasn't in the table, so use the standard 	 * 1/4 period in ns conversion. 	 */
return|return
operator|(
name|period
operator|/
literal|400
operator|)
return|;
block|}
end_function

begin_function
name|void
name|scsi_test_unit_ready
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_test_unit_ready
modifier|*
name|scsi_cmd
decl_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
name|CAM_DIR_NONE
argument_list|,
name|tag_action
argument_list|,
comment|/*data_ptr*/
name|NULL
argument_list|,
comment|/*dxfer_len*/
literal|0
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_test_unit_ready
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|TEST_UNIT_READY
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_request_sense
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|data_ptr
parameter_list|,
name|u_int8_t
name|dxfer_len
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_request_sense
modifier|*
name|scsi_cmd
decl_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
name|CAM_DIR_IN
argument_list|,
name|tag_action
argument_list|,
name|data_ptr
argument_list|,
name|dxfer_len
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_request_sense
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|REQUEST_SENSE
expr_stmt|;
name|scsi_cmd
operator|->
name|length
operator|=
name|dxfer_len
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_inquiry
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|u_int8_t
modifier|*
name|inq_buf
parameter_list|,
name|u_int32_t
name|inq_len
parameter_list|,
name|int
name|evpd
parameter_list|,
name|u_int8_t
name|page_code
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_inquiry
modifier|*
name|scsi_cmd
decl_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|CAM_DIR_IN
argument_list|,
name|tag_action
argument_list|,
comment|/*data_ptr*/
name|inq_buf
argument_list|,
comment|/*dxfer_len*/
name|inq_len
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_inquiry
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|INQUIRY
expr_stmt|;
if|if
condition|(
name|evpd
condition|)
block|{
name|scsi_cmd
operator|->
name|byte2
operator||=
name|SI_EVPD
expr_stmt|;
name|scsi_cmd
operator|->
name|page_code
operator|=
name|page_code
expr_stmt|;
block|}
comment|/* 	 * A 'transfer units' count of 256 is coded as 	 * zero for all commands with a single byte count 	 * field.  	 */
if|if
condition|(
name|inq_len
operator|==
literal|256
condition|)
name|inq_len
operator|=
literal|0
expr_stmt|;
name|scsi_cmd
operator|->
name|length
operator|=
name|inq_len
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_mode_sense
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|int
name|dbd
parameter_list|,
name|u_int8_t
name|page_code
parameter_list|,
name|u_int8_t
name|page
parameter_list|,
name|u_int8_t
modifier|*
name|param_buf
parameter_list|,
name|u_int32_t
name|param_len
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|scsi_mode_sense_len
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
name|tag_action
argument_list|,
name|dbd
argument_list|,
name|page_code
argument_list|,
name|page
argument_list|,
name|param_buf
argument_list|,
name|param_len
argument_list|,
literal|0
argument_list|,
name|sense_len
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_mode_sense_len
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|int
name|dbd
parameter_list|,
name|u_int8_t
name|page_code
parameter_list|,
name|u_int8_t
name|page
parameter_list|,
name|u_int8_t
modifier|*
name|param_buf
parameter_list|,
name|u_int32_t
name|param_len
parameter_list|,
name|int
name|minimum_cmd_size
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|u_int8_t
name|cdb_len
decl_stmt|;
comment|/* 	 * Use the smallest possible command to perform the operation. 	 */
if|if
condition|(
operator|(
name|param_len
operator|<
literal|256
operator|)
operator|&&
operator|(
name|minimum_cmd_size
operator|<
literal|10
operator|)
condition|)
block|{
comment|/* 		 * We can fit in a 6 byte cdb. 		 */
name|struct
name|scsi_mode_sense_6
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_mode_sense_6
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|MODE_SENSE_6
expr_stmt|;
if|if
condition|(
name|dbd
operator|!=
literal|0
condition|)
name|scsi_cmd
operator|->
name|byte2
operator||=
name|SMS_DBD
expr_stmt|;
name|scsi_cmd
operator|->
name|page
operator|=
name|page_code
operator||
name|page
expr_stmt|;
name|scsi_cmd
operator|->
name|length
operator|=
name|param_len
expr_stmt|;
name|cdb_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Need a 10 byte cdb. 		 */
name|struct
name|scsi_mode_sense_10
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_mode_sense_10
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|MODE_SENSE_10
expr_stmt|;
if|if
condition|(
name|dbd
operator|!=
literal|0
condition|)
name|scsi_cmd
operator|->
name|byte2
operator||=
name|SMS_DBD
expr_stmt|;
name|scsi_cmd
operator|->
name|page
operator|=
name|page_code
operator||
name|page
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|param_len
argument_list|,
name|scsi_cmd
operator|->
name|length
argument_list|)
expr_stmt|;
name|cdb_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
expr_stmt|;
block|}
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
name|CAM_DIR_IN
argument_list|,
name|tag_action
argument_list|,
name|param_buf
argument_list|,
name|param_len
argument_list|,
name|sense_len
argument_list|,
name|cdb_len
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_mode_select
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|int
name|scsi_page_fmt
parameter_list|,
name|int
name|save_pages
parameter_list|,
name|u_int8_t
modifier|*
name|param_buf
parameter_list|,
name|u_int32_t
name|param_len
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|scsi_mode_select_len
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
name|tag_action
argument_list|,
name|scsi_page_fmt
argument_list|,
name|save_pages
argument_list|,
name|param_buf
argument_list|,
name|param_len
argument_list|,
literal|0
argument_list|,
name|sense_len
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_mode_select_len
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|int
name|scsi_page_fmt
parameter_list|,
name|int
name|save_pages
parameter_list|,
name|u_int8_t
modifier|*
name|param_buf
parameter_list|,
name|u_int32_t
name|param_len
parameter_list|,
name|int
name|minimum_cmd_size
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|u_int8_t
name|cdb_len
decl_stmt|;
comment|/* 	 * Use the smallest possible command to perform the operation. 	 */
if|if
condition|(
operator|(
name|param_len
operator|<
literal|256
operator|)
operator|&&
operator|(
name|minimum_cmd_size
operator|<
literal|10
operator|)
condition|)
block|{
comment|/* 		 * We can fit in a 6 byte cdb. 		 */
name|struct
name|scsi_mode_select_6
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_mode_select_6
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|MODE_SELECT_6
expr_stmt|;
if|if
condition|(
name|scsi_page_fmt
operator|!=
literal|0
condition|)
name|scsi_cmd
operator|->
name|byte2
operator||=
name|SMS_PF
expr_stmt|;
if|if
condition|(
name|save_pages
operator|!=
literal|0
condition|)
name|scsi_cmd
operator|->
name|byte2
operator||=
name|SMS_SP
expr_stmt|;
name|scsi_cmd
operator|->
name|length
operator|=
name|param_len
expr_stmt|;
name|cdb_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Need a 10 byte cdb. 		 */
name|struct
name|scsi_mode_select_10
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_mode_select_10
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|MODE_SELECT_10
expr_stmt|;
if|if
condition|(
name|scsi_page_fmt
operator|!=
literal|0
condition|)
name|scsi_cmd
operator|->
name|byte2
operator||=
name|SMS_PF
expr_stmt|;
if|if
condition|(
name|save_pages
operator|!=
literal|0
condition|)
name|scsi_cmd
operator|->
name|byte2
operator||=
name|SMS_SP
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|param_len
argument_list|,
name|scsi_cmd
operator|->
name|length
argument_list|)
expr_stmt|;
name|cdb_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
expr_stmt|;
block|}
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
name|CAM_DIR_OUT
argument_list|,
name|tag_action
argument_list|,
name|param_buf
argument_list|,
name|param_len
argument_list|,
name|sense_len
argument_list|,
name|cdb_len
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_log_sense
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|u_int8_t
name|page_code
parameter_list|,
name|u_int8_t
name|page
parameter_list|,
name|int
name|save_pages
parameter_list|,
name|int
name|ppc
parameter_list|,
name|u_int32_t
name|paramptr
parameter_list|,
name|u_int8_t
modifier|*
name|param_buf
parameter_list|,
name|u_int32_t
name|param_len
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_log_sense
modifier|*
name|scsi_cmd
decl_stmt|;
name|u_int8_t
name|cdb_len
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_log_sense
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|LOG_SENSE
expr_stmt|;
name|scsi_cmd
operator|->
name|page
operator|=
name|page_code
operator||
name|page
expr_stmt|;
if|if
condition|(
name|save_pages
operator|!=
literal|0
condition|)
name|scsi_cmd
operator|->
name|byte2
operator||=
name|SLS_SP
expr_stmt|;
if|if
condition|(
name|ppc
operator|!=
literal|0
condition|)
name|scsi_cmd
operator|->
name|byte2
operator||=
name|SLS_PPC
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|paramptr
argument_list|,
name|scsi_cmd
operator|->
name|paramptr
argument_list|)
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|param_len
argument_list|,
name|scsi_cmd
operator|->
name|length
argument_list|)
expr_stmt|;
name|cdb_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|CAM_DIR_IN
argument_list|,
name|tag_action
argument_list|,
comment|/*data_ptr*/
name|param_buf
argument_list|,
comment|/*dxfer_len*/
name|param_len
argument_list|,
name|sense_len
argument_list|,
name|cdb_len
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_log_select
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|u_int8_t
name|page_code
parameter_list|,
name|int
name|save_pages
parameter_list|,
name|int
name|pc_reset
parameter_list|,
name|u_int8_t
modifier|*
name|param_buf
parameter_list|,
name|u_int32_t
name|param_len
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_log_select
modifier|*
name|scsi_cmd
decl_stmt|;
name|u_int8_t
name|cdb_len
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_log_select
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|LOG_SELECT
expr_stmt|;
name|scsi_cmd
operator|->
name|page
operator|=
name|page_code
operator|&
name|SLS_PAGE_CODE
expr_stmt|;
if|if
condition|(
name|save_pages
operator|!=
literal|0
condition|)
name|scsi_cmd
operator|->
name|byte2
operator||=
name|SLS_SP
expr_stmt|;
if|if
condition|(
name|pc_reset
operator|!=
literal|0
condition|)
name|scsi_cmd
operator|->
name|byte2
operator||=
name|SLS_PCR
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|param_len
argument_list|,
name|scsi_cmd
operator|->
name|length
argument_list|)
expr_stmt|;
name|cdb_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|CAM_DIR_OUT
argument_list|,
name|tag_action
argument_list|,
comment|/*data_ptr*/
name|param_buf
argument_list|,
comment|/*dxfer_len*/
name|param_len
argument_list|,
name|sense_len
argument_list|,
name|cdb_len
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Prevent or allow the user to remove the media  */
end_comment

begin_function
name|void
name|scsi_prevent
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|u_int8_t
name|action
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_prevent
modifier|*
name|scsi_cmd
decl_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|CAM_DIR_NONE
argument_list|,
name|tag_action
argument_list|,
comment|/*data_ptr*/
name|NULL
argument_list|,
comment|/*dxfer_len*/
literal|0
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_prevent
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|PREVENT_ALLOW
expr_stmt|;
name|scsi_cmd
operator|->
name|how
operator|=
name|action
expr_stmt|;
block|}
end_function

begin_comment
comment|/* XXX allow specification of address and PMI bit and LBA */
end_comment

begin_function
name|void
name|scsi_read_capacity
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|struct
name|scsi_read_capacity_data
modifier|*
name|rcap_buf
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_read_capacity
modifier|*
name|scsi_cmd
decl_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|CAM_DIR_IN
argument_list|,
name|tag_action
argument_list|,
comment|/*data_ptr*/
operator|(
name|u_int8_t
operator|*
operator|)
name|rcap_buf
argument_list|,
comment|/*dxfer_len*/
sizeof|sizeof
argument_list|(
operator|*
name|rcap_buf
argument_list|)
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_read_capacity
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|READ_CAPACITY
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_read_capacity_16
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|uint32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|uint8_t
name|tag_action
parameter_list|,
name|uint64_t
name|lba
parameter_list|,
name|int
name|reladr
parameter_list|,
name|int
name|pmi
parameter_list|,
name|struct
name|scsi_read_capacity_data_long
modifier|*
name|rcap_buf
parameter_list|,
name|uint8_t
name|sense_len
parameter_list|,
name|uint32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_read_capacity_16
modifier|*
name|scsi_cmd
decl_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|CAM_DIR_IN
argument_list|,
name|tag_action
argument_list|,
comment|/*data_ptr*/
operator|(
name|u_int8_t
operator|*
operator|)
name|rcap_buf
argument_list|,
comment|/*dxfer_len*/
sizeof|sizeof
argument_list|(
operator|*
name|rcap_buf
argument_list|)
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_read_capacity_16
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|SERVICE_ACTION_IN
expr_stmt|;
name|scsi_cmd
operator|->
name|service_action
operator|=
name|SRC16_SERVICE_ACTION
expr_stmt|;
name|scsi_u64to8b
argument_list|(
name|lba
argument_list|,
name|scsi_cmd
operator|->
name|addr
argument_list|)
expr_stmt|;
name|scsi_ulto4b
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|rcap_buf
argument_list|)
argument_list|,
name|scsi_cmd
operator|->
name|alloc_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmi
condition|)
name|reladr
operator||=
name|SRC16_PMI
expr_stmt|;
if|if
condition|(
name|reladr
condition|)
name|reladr
operator||=
name|SRC16_RELADR
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_report_luns
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|struct
name|scsi_report_luns_data
modifier|*
name|rpl_buf
parameter_list|,
name|u_int32_t
name|alloc_len
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_report_luns
modifier|*
name|scsi_cmd
decl_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|CAM_DIR_IN
argument_list|,
name|tag_action
argument_list|,
comment|/*data_ptr*/
operator|(
name|u_int8_t
operator|*
operator|)
name|rpl_buf
argument_list|,
comment|/*dxfer_len*/
name|alloc_len
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_report_luns
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|REPORT_LUNS
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|alloc_len
argument_list|,
name|scsi_cmd
operator|->
name|addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Syncronize the media to the contents of the cache for  * the given lba/count pair.  Specifying 0/0 means sync  * the whole cache.  */
end_comment

begin_function
name|void
name|scsi_synchronize_cache
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|u_int32_t
name|begin_lba
parameter_list|,
name|u_int16_t
name|lb_count
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_sync_cache
modifier|*
name|scsi_cmd
decl_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|CAM_DIR_NONE
argument_list|,
name|tag_action
argument_list|,
comment|/*data_ptr*/
name|NULL
argument_list|,
comment|/*dxfer_len*/
literal|0
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_sync_cache
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|SYNCHRONIZE_CACHE
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|begin_lba
argument_list|,
name|scsi_cmd
operator|->
name|begin_lba
argument_list|)
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|lb_count
argument_list|,
name|scsi_cmd
operator|->
name|lb_count
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_read_write
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|int
name|readop
parameter_list|,
name|u_int8_t
name|byte2
parameter_list|,
name|int
name|minimum_cmd_size
parameter_list|,
name|u_int64_t
name|lba
parameter_list|,
name|u_int32_t
name|block_count
parameter_list|,
name|u_int8_t
modifier|*
name|data_ptr
parameter_list|,
name|u_int32_t
name|dxfer_len
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|u_int8_t
name|cdb_len
decl_stmt|;
comment|/* 	 * Use the smallest possible command to perform the operation 	 * as some legacy hardware does not support the 10 byte commands. 	 * If any of the bits in byte2 is set, we have to go with a larger 	 * command. 	 */
if|if
condition|(
operator|(
name|minimum_cmd_size
operator|<
literal|10
operator|)
operator|&&
operator|(
operator|(
name|lba
operator|&
literal|0x1fffff
operator|)
operator|==
name|lba
operator|)
operator|&&
operator|(
operator|(
name|block_count
operator|&
literal|0xff
operator|)
operator|==
name|block_count
operator|)
operator|&&
operator|(
name|byte2
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * We can fit in a 6 byte cdb. 		 */
name|struct
name|scsi_rw_6
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_rw_6
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|readop
condition|?
name|READ_6
else|:
name|WRITE_6
expr_stmt|;
name|scsi_ulto3b
argument_list|(
name|lba
argument_list|,
name|scsi_cmd
operator|->
name|addr
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|length
operator|=
name|block_count
operator|&
literal|0xff
expr_stmt|;
name|scsi_cmd
operator|->
name|control
operator|=
literal|0
expr_stmt|;
name|cdb_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|csio
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"6byte: %x%x%x:%d:%d\n"
operator|,
name|scsi_cmd
operator|->
name|addr
index|[
literal|0
index|]
operator|,
name|scsi_cmd
operator|->
name|addr
index|[
literal|1
index|]
operator|,
name|scsi_cmd
operator|->
name|addr
index|[
literal|2
index|]
operator|,
name|scsi_cmd
operator|->
name|length
operator|,
name|dxfer_len
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|minimum_cmd_size
operator|<
literal|12
operator|)
operator|&&
operator|(
operator|(
name|block_count
operator|&
literal|0xffff
operator|)
operator|==
name|block_count
operator|)
operator|&&
operator|(
operator|(
name|lba
operator|&
literal|0xffffffff
operator|)
operator|==
name|lba
operator|)
condition|)
block|{
comment|/* 		 * Need a 10 byte cdb. 		 */
name|struct
name|scsi_rw_10
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_rw_10
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|readop
condition|?
name|READ_10
else|:
name|WRITE_10
expr_stmt|;
name|scsi_cmd
operator|->
name|byte2
operator|=
name|byte2
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|lba
argument_list|,
name|scsi_cmd
operator|->
name|addr
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|reserved
operator|=
literal|0
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|block_count
argument_list|,
name|scsi_cmd
operator|->
name|length
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|control
operator|=
literal|0
expr_stmt|;
name|cdb_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|csio
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"10byte: %x%x%x%x:%x%x: %d\n"
operator|,
name|scsi_cmd
operator|->
name|addr
index|[
literal|0
index|]
operator|,
name|scsi_cmd
operator|->
name|addr
index|[
literal|1
index|]
operator|,
name|scsi_cmd
operator|->
name|addr
index|[
literal|2
index|]
operator|,
name|scsi_cmd
operator|->
name|addr
index|[
literal|3
index|]
operator|,
name|scsi_cmd
operator|->
name|length
index|[
literal|0
index|]
operator|,
name|scsi_cmd
operator|->
name|length
index|[
literal|1
index|]
operator|,
name|dxfer_len
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|minimum_cmd_size
operator|<
literal|16
operator|)
operator|&&
operator|(
operator|(
name|block_count
operator|&
literal|0xffffffff
operator|)
operator|==
name|block_count
operator|)
operator|&&
operator|(
operator|(
name|lba
operator|&
literal|0xffffffff
operator|)
operator|==
name|lba
operator|)
condition|)
block|{
comment|/*  		 * The block count is too big for a 10 byte CDB, use a 12 		 * byte CDB. 		 */
name|struct
name|scsi_rw_12
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_rw_12
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|readop
condition|?
name|READ_12
else|:
name|WRITE_12
expr_stmt|;
name|scsi_cmd
operator|->
name|byte2
operator|=
name|byte2
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|lba
argument_list|,
name|scsi_cmd
operator|->
name|addr
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|reserved
operator|=
literal|0
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|block_count
argument_list|,
name|scsi_cmd
operator|->
name|length
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|control
operator|=
literal|0
expr_stmt|;
name|cdb_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|csio
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"12byte: %x%x%x%x:%x%x%x%x: %d\n"
operator|,
name|scsi_cmd
operator|->
name|addr
index|[
literal|0
index|]
operator|,
name|scsi_cmd
operator|->
name|addr
index|[
literal|1
index|]
operator|,
name|scsi_cmd
operator|->
name|addr
index|[
literal|2
index|]
operator|,
name|scsi_cmd
operator|->
name|addr
index|[
literal|3
index|]
operator|,
name|scsi_cmd
operator|->
name|length
index|[
literal|0
index|]
operator|,
name|scsi_cmd
operator|->
name|length
index|[
literal|1
index|]
operator|,
name|scsi_cmd
operator|->
name|length
index|[
literal|2
index|]
operator|,
name|scsi_cmd
operator|->
name|length
index|[
literal|3
index|]
operator|,
name|dxfer_len
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * 16 byte CDB.  We'll only get here if the LBA is larger 		 * than 2^32, or if the user asks for a 16 byte command. 		 */
name|struct
name|scsi_rw_16
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_rw_16
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|readop
condition|?
name|READ_16
else|:
name|WRITE_16
expr_stmt|;
name|scsi_cmd
operator|->
name|byte2
operator|=
name|byte2
expr_stmt|;
name|scsi_u64to8b
argument_list|(
name|lba
argument_list|,
name|scsi_cmd
operator|->
name|addr
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|reserved
operator|=
literal|0
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|block_count
argument_list|,
name|scsi_cmd
operator|->
name|length
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|control
operator|=
literal|0
expr_stmt|;
name|cdb_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
expr_stmt|;
block|}
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|readop
condition|?
name|CAM_DIR_IN
else|:
name|CAM_DIR_OUT
argument_list|,
name|tag_action
argument_list|,
name|data_ptr
argument_list|,
name|dxfer_len
argument_list|,
name|sense_len
argument_list|,
name|cdb_len
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_start_stop
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|load_eject
parameter_list|,
name|int
name|immediate
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_start_stop_unit
modifier|*
name|scsi_cmd
decl_stmt|;
name|int
name|extra_flags
init|=
literal|0
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_start_stop_unit
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|START_STOP_UNIT
expr_stmt|;
if|if
condition|(
name|start
operator|!=
literal|0
condition|)
block|{
name|scsi_cmd
operator|->
name|how
operator||=
name|SSS_START
expr_stmt|;
comment|/* it takes a lot of power to start a drive */
name|extra_flags
operator||=
name|CAM_HIGH_POWER
expr_stmt|;
block|}
if|if
condition|(
name|load_eject
operator|!=
literal|0
condition|)
name|scsi_cmd
operator|->
name|how
operator||=
name|SSS_LOEJ
expr_stmt|;
if|if
condition|(
name|immediate
operator|!=
literal|0
condition|)
name|scsi_cmd
operator|->
name|byte2
operator||=
name|SSS_IMMED
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|CAM_DIR_NONE
operator||
name|extra_flags
argument_list|,
name|tag_action
argument_list|,
comment|/*data_ptr*/
name|NULL
argument_list|,
comment|/*dxfer_len*/
literal|0
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*        * Try make as good a match as possible with  * available sub drivers  */
end_comment

begin_function
name|int
name|scsi_inquiry_match
parameter_list|(
name|caddr_t
name|inqbuffer
parameter_list|,
name|caddr_t
name|table_entry
parameter_list|)
block|{
name|struct
name|scsi_inquiry_pattern
modifier|*
name|entry
decl_stmt|;
name|struct
name|scsi_inquiry_data
modifier|*
name|inq
decl_stmt|;
name|entry
operator|=
operator|(
expr|struct
name|scsi_inquiry_pattern
operator|*
operator|)
name|table_entry
expr_stmt|;
name|inq
operator|=
operator|(
expr|struct
name|scsi_inquiry_data
operator|*
operator|)
name|inqbuffer
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|SID_TYPE
argument_list|(
name|inq
argument_list|)
operator|==
name|entry
operator|->
name|type
operator|)
operator|||
operator|(
name|entry
operator|->
name|type
operator|==
name|T_ANY
operator|)
operator|)
operator|&&
operator|(
name|SID_IS_REMOVABLE
argument_list|(
name|inq
argument_list|)
condition|?
name|entry
operator|->
name|media_type
operator|&
name|SIP_MEDIA_REMOVABLE
else|:
name|entry
operator|->
name|media_type
operator|&
name|SIP_MEDIA_FIXED
operator|)
operator|&&
operator|(
name|cam_strmatch
argument_list|(
name|inq
operator|->
name|vendor
argument_list|,
name|entry
operator|->
name|vendor
argument_list|,
sizeof|sizeof
argument_list|(
name|inq
operator|->
name|vendor
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|cam_strmatch
argument_list|(
name|inq
operator|->
name|product
argument_list|,
name|entry
operator|->
name|product
argument_list|,
sizeof|sizeof
argument_list|(
name|inq
operator|->
name|product
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|cam_strmatch
argument_list|(
name|inq
operator|->
name|revision
argument_list|,
name|entry
operator|->
name|revision
argument_list|,
sizeof|sizeof
argument_list|(
name|inq
operator|->
name|revision
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*        * Try make as good a match as possible with  * available sub drivers  */
end_comment

begin_function
name|int
name|scsi_static_inquiry_match
parameter_list|(
name|caddr_t
name|inqbuffer
parameter_list|,
name|caddr_t
name|table_entry
parameter_list|)
block|{
name|struct
name|scsi_static_inquiry_pattern
modifier|*
name|entry
decl_stmt|;
name|struct
name|scsi_inquiry_data
modifier|*
name|inq
decl_stmt|;
name|entry
operator|=
operator|(
expr|struct
name|scsi_static_inquiry_pattern
operator|*
operator|)
name|table_entry
expr_stmt|;
name|inq
operator|=
operator|(
expr|struct
name|scsi_inquiry_data
operator|*
operator|)
name|inqbuffer
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|SID_TYPE
argument_list|(
name|inq
argument_list|)
operator|==
name|entry
operator|->
name|type
operator|)
operator|||
operator|(
name|entry
operator|->
name|type
operator|==
name|T_ANY
operator|)
operator|)
operator|&&
operator|(
name|SID_IS_REMOVABLE
argument_list|(
name|inq
argument_list|)
condition|?
name|entry
operator|->
name|media_type
operator|&
name|SIP_MEDIA_REMOVABLE
else|:
name|entry
operator|->
name|media_type
operator|&
name|SIP_MEDIA_FIXED
operator|)
operator|&&
operator|(
name|cam_strmatch
argument_list|(
name|inq
operator|->
name|vendor
argument_list|,
name|entry
operator|->
name|vendor
argument_list|,
sizeof|sizeof
argument_list|(
name|inq
operator|->
name|vendor
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|cam_strmatch
argument_list|(
name|inq
operator|->
name|product
argument_list|,
name|entry
operator|->
name|product
argument_list|,
sizeof|sizeof
argument_list|(
name|inq
operator|->
name|product
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|cam_strmatch
argument_list|(
name|inq
operator|->
name|revision
argument_list|,
name|entry
operator|->
name|revision
argument_list|,
sizeof|sizeof
argument_list|(
name|inq
operator|->
name|revision
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_function
specifier|static
name|void
name|init_scsi_delay
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|delay
decl_stmt|;
name|delay
operator|=
name|SCSI_DELAY
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"kern.cam.scsi_delay"
argument_list|,
operator|&
name|delay
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_scsi_delay
argument_list|(
name|delay
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"cam: invalid value for tunable kern.cam.scsi_delay\n"
argument_list|)
expr_stmt|;
name|set_scsi_delay
argument_list|(
name|SCSI_DELAY
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|scsi_delay
argument_list|,
name|SI_SUB_TUNABLES
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|init_scsi_delay
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|sysctl_scsi_delay
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|delay
decl_stmt|;
name|delay
operator|=
name|scsi_delay
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|delay
argument_list|,
sizeof|sizeof
argument_list|(
name|delay
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
name|set_scsi_delay
argument_list|(
name|delay
argument_list|)
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern_cam
argument_list|,
name|OID_AUTO
argument_list|,
name|scsi_delay
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sysctl_scsi_delay
argument_list|,
literal|"I"
argument_list|,
literal|"Delay to allow devices to settle after a SCSI bus reset (ms)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|set_scsi_delay
parameter_list|(
name|int
name|delay
parameter_list|)
block|{
comment|/*          * If someone sets this to 0, we assume that they want the          * minimum allowable bus settle delay. 	 */
if|if
condition|(
name|delay
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"cam: using minimum scsi_delay (%dms)\n"
argument_list|,
name|SCSI_MIN_DELAY
argument_list|)
expr_stmt|;
name|delay
operator|=
name|SCSI_MIN_DELAY
expr_stmt|;
block|}
if|if
condition|(
name|delay
operator|<
name|SCSI_MIN_DELAY
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|scsi_delay
operator|=
name|delay
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _KERNEL */
end_comment

end_unit

