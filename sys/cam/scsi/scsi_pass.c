begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1997, 1998, 2000 Justin T. Gibbs.  * Copyright (c) 1997, 1998, 1999 Kenneth D. Merry.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/devicestat.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/sdt.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_queue.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_compat.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_pass.h>
end_include

begin_typedef
typedef|typedef
enum|enum
block|{
name|PASS_FLAG_OPEN
init|=
literal|0x01
block|,
name|PASS_FLAG_LOCKED
init|=
literal|0x02
block|,
name|PASS_FLAG_INVALID
init|=
literal|0x04
block|,
name|PASS_FLAG_INITIAL_PHYSPATH
init|=
literal|0x08
block|,
name|PASS_FLAG_ZONE_INPROG
init|=
literal|0x10
block|,
name|PASS_FLAG_ZONE_VALID
init|=
literal|0x20
block|,
name|PASS_FLAG_UNMAPPED_CAPABLE
init|=
literal|0x40
block|,
name|PASS_FLAG_ABANDONED_REF_SET
init|=
literal|0x80
block|}
name|pass_flags
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|PASS_STATE_NORMAL
block|}
name|pass_state
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|PASS_CCB_BUFFER_IO
block|,
name|PASS_CCB_QUEUED_IO
block|}
name|pass_ccb_types
typedef|;
end_typedef

begin_define
define|#
directive|define
name|ccb_type
value|ppriv_field0
end_define

begin_define
define|#
directive|define
name|ccb_ioreq
value|ppriv_ptr1
end_define

begin_comment
comment|/*  * The maximum number of memory segments we preallocate.  */
end_comment

begin_define
define|#
directive|define
name|PASS_MAX_SEGS
value|16
end_define

begin_typedef
typedef|typedef
enum|enum
block|{
name|PASS_IO_NONE
init|=
literal|0x00
block|,
name|PASS_IO_USER_SEG_MALLOC
init|=
literal|0x01
block|,
name|PASS_IO_KERN_SEG_MALLOC
init|=
literal|0x02
block|,
name|PASS_IO_ABANDONED
init|=
literal|0x04
block|}
name|pass_io_flags
typedef|;
end_typedef

begin_struct
struct|struct
name|pass_io_req
block|{
name|union
name|ccb
name|ccb
decl_stmt|;
name|union
name|ccb
modifier|*
name|alloced_ccb
decl_stmt|;
name|union
name|ccb
modifier|*
name|user_ccb_ptr
decl_stmt|;
name|camq_entry
name|user_periph_links
decl_stmt|;
name|ccb_ppriv_area
name|user_periph_priv
decl_stmt|;
name|struct
name|cam_periph_map_info
name|mapinfo
decl_stmt|;
name|pass_io_flags
name|flags
decl_stmt|;
name|ccb_flags
name|data_flags
decl_stmt|;
name|int
name|num_user_segs
decl_stmt|;
name|bus_dma_segment_t
name|user_segs
index|[
name|PASS_MAX_SEGS
index|]
decl_stmt|;
name|int
name|num_kern_segs
decl_stmt|;
name|bus_dma_segment_t
name|kern_segs
index|[
name|PASS_MAX_SEGS
index|]
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|user_segptr
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|kern_segptr
decl_stmt|;
name|int
name|num_bufs
decl_stmt|;
name|uint32_t
name|dirs
index|[
name|CAM_PERIPH_MAXMAPS
index|]
decl_stmt|;
name|uint32_t
name|lengths
index|[
name|CAM_PERIPH_MAXMAPS
index|]
decl_stmt|;
name|uint8_t
modifier|*
name|user_bufs
index|[
name|CAM_PERIPH_MAXMAPS
index|]
decl_stmt|;
name|uint8_t
modifier|*
name|kern_bufs
index|[
name|CAM_PERIPH_MAXMAPS
index|]
decl_stmt|;
name|struct
name|bintime
name|start_time
decl_stmt|;
name|TAILQ_ENTRY
argument_list|(
argument|pass_io_req
argument_list|)
name|links
expr_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|pass_softc
block|{
name|pass_state
name|state
decl_stmt|;
name|pass_flags
name|flags
decl_stmt|;
name|u_int8_t
name|pd_type
decl_stmt|;
name|union
name|ccb
name|saved_ccb
decl_stmt|;
name|int
name|open_count
decl_stmt|;
name|u_int
name|maxio
decl_stmt|;
name|struct
name|devstat
modifier|*
name|device_stats
decl_stmt|;
name|struct
name|cdev
modifier|*
name|dev
decl_stmt|;
name|struct
name|cdev
modifier|*
name|alias_dev
decl_stmt|;
name|struct
name|task
name|add_physpath_task
decl_stmt|;
name|struct
name|task
name|shutdown_kqueue_task
decl_stmt|;
name|struct
name|selinfo
name|read_select
decl_stmt|;
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|pass_io_req
argument_list|)
name|incoming_queue
expr_stmt|;
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|pass_io_req
argument_list|)
name|active_queue
expr_stmt|;
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|pass_io_req
argument_list|)
name|abandoned_queue
expr_stmt|;
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|pass_io_req
argument_list|)
name|done_queue
expr_stmt|;
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|char
name|zone_name
index|[
literal|12
index|]
decl_stmt|;
name|char
name|io_zone_name
index|[
literal|12
index|]
decl_stmt|;
name|uma_zone_t
name|pass_zone
decl_stmt|;
name|uma_zone_t
name|pass_io_zone
decl_stmt|;
name|size_t
name|io_zone_size
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|d_open_t
name|passopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|passclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|passioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|passdoioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_poll_t
name|passpoll
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_kqfilter_t
name|passkqfilter
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|passreadfiltdetach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|passreadfilt
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|periph_init_t
name|passinit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_ctor_t
name|passregister
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_oninv_t
name|passoninvalidate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_dtor_t
name|passcleanup
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_start_t
name|passstart
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|pass_shutdown_kqueue
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pass_add_physpath
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|passasync
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|u_int32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|passdone
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|done_ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|passcreatezone
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|passiocleanup
parameter_list|(
name|struct
name|pass_softc
modifier|*
name|softc
parameter_list|,
name|struct
name|pass_io_req
modifier|*
name|io_req
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|passcopysglist
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|pass_io_req
modifier|*
name|io_req
parameter_list|,
name|ccb_flags
name|direction
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|passmemsetup
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|pass_io_req
modifier|*
name|io_req
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|passmemdone
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|pass_io_req
modifier|*
name|io_req
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|passerror
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|u_int32_t
name|cam_flags
parameter_list|,
name|u_int32_t
name|sense_flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|passsendccb
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|union
name|ccb
modifier|*
name|inccb
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|periph_driver
name|passdriver
init|=
block|{
name|passinit
block|,
literal|"pass"
block|,
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|passdriver
operator|.
name|units
argument_list|)
block|,
comment|/* generation */
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|PERIPHDRIVER_DECLARE
argument_list|(
name|pass
argument_list|,
name|passdriver
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|pass_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_flags
operator|=
name|D_TRACKCLOSE
block|,
operator|.
name|d_open
operator|=
name|passopen
block|,
operator|.
name|d_close
operator|=
name|passclose
block|,
operator|.
name|d_ioctl
operator|=
name|passioctl
block|,
operator|.
name|d_poll
operator|=
name|passpoll
block|,
operator|.
name|d_kqfilter
operator|=
name|passkqfilter
block|,
operator|.
name|d_name
operator|=
literal|"pass"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|filterops
name|passread_filtops
init|=
block|{
operator|.
name|f_isfd
operator|=
literal|1
block|,
operator|.
name|f_detach
operator|=
name|passreadfiltdetach
block|,
operator|.
name|f_event
operator|=
name|passreadfilt
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_SCSIPASS
argument_list|,
literal|"scsi_pass"
argument_list|,
literal|"scsi passthrough buffers"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|passinit
parameter_list|(
name|void
parameter_list|)
block|{
name|cam_status
name|status
decl_stmt|;
comment|/* 	 * Install a global async callback.  This callback will 	 * receive async callbacks like "new device found". 	 */
name|status
operator|=
name|xpt_register_async
argument_list|(
name|AC_FOUND_DEVICE
argument_list|,
name|passasync
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"pass: Failed to attach master async callback "
literal|"due to status 0x%x!\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|passrejectios
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|struct
name|pass_io_req
modifier|*
name|io_req
decl_stmt|,
modifier|*
name|io_req2
decl_stmt|;
name|struct
name|pass_softc
modifier|*
name|softc
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|pass_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
comment|/* 	 * The user can no longer get status for I/O on the done queue, so 	 * clean up all outstanding I/O on the done queue. 	 */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|io_req
argument_list|,
argument|&softc->done_queue
argument_list|,
argument|links
argument_list|,
argument|io_req2
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|softc
operator|->
name|done_queue
argument_list|,
name|io_req
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|passiocleanup
argument_list|(
name|softc
argument_list|,
name|io_req
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|softc
operator|->
name|pass_zone
argument_list|,
name|io_req
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The underlying device is gone, so we can't issue these I/Os. 	 * The devfs node has been shut down, so we can't return status to 	 * the user.  Free any I/O left on the incoming queue. 	 */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|io_req
argument_list|,
argument|&softc->incoming_queue
argument_list|,
argument|links
argument_list|,
argument|io_req2
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|softc
operator|->
name|incoming_queue
argument_list|,
name|io_req
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|passiocleanup
argument_list|(
name|softc
argument_list|,
name|io_req
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|softc
operator|->
name|pass_zone
argument_list|,
name|io_req
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Normally we would put I/Os on the abandoned queue and acquire a 	 * reference when we saw the final close.  But, the device went 	 * away and devfs may have moved everything off to deadfs by the 	 * time the I/O done callback is called; as a result, we won't see 	 * any more closes.  So, if we have any active I/Os, we need to put 	 * them on the abandoned queue.  When the abandoned queue is empty, 	 * we'll release the remaining reference (see below) to the peripheral. 	 */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|io_req
argument_list|,
argument|&softc->active_queue
argument_list|,
argument|links
argument_list|,
argument|io_req2
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|softc
operator|->
name|active_queue
argument_list|,
name|io_req
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|io_req
operator|->
name|flags
operator||=
name|PASS_IO_ABANDONED
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|softc
operator|->
name|abandoned_queue
argument_list|,
name|io_req
argument_list|,
name|links
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we put any I/O on the abandoned queue, acquire a reference. 	 */
if|if
condition|(
operator|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|softc
operator|->
name|abandoned_queue
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|PASS_FLAG_ABANDONED_REF_SET
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|cam_periph_doacquire
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|softc
operator|->
name|flags
operator||=
name|PASS_FLAG_ABANDONED_REF_SET
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|passdevgonecb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|mtx
modifier|*
name|mtx
decl_stmt|;
name|struct
name|pass_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|periph
operator|=
operator|(
expr|struct
name|cam_periph
operator|*
operator|)
name|arg
expr_stmt|;
name|mtx
operator|=
name|cam_periph_mtx
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
name|mtx
argument_list|)
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|pass_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|KASSERT
argument_list|(
name|softc
operator|->
name|open_count
operator|>=
literal|0
argument_list|,
operator|(
literal|"Negative open count %d"
operator|,
name|softc
operator|->
name|open_count
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * When we get this callback, we will get no more close calls from 	 * devfs.  So if we have any dangling opens, we need to release the 	 * reference held for that particular context. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|softc
operator|->
name|open_count
condition|;
name|i
operator|++
control|)
name|cam_periph_release_locked
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|softc
operator|->
name|open_count
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Release the reference held for the device node, it is gone now. 	 * Accordingly, inform all queued I/Os of their fate. 	 */
name|cam_periph_release_locked
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|passrejectios
argument_list|(
name|periph
argument_list|)
expr_stmt|;
comment|/* 	 * We reference the SIM lock directly here, instead of using 	 * cam_periph_unlock().  The reason is that the final call to 	 * cam_periph_release_locked() above could result in the periph 	 * getting freed.  If that is the case, dereferencing the periph 	 * with a cam_periph_unlock() call would cause a page fault. 	 */
name|mtx_unlock
argument_list|(
name|mtx
argument_list|)
expr_stmt|;
comment|/* 	 * We have to remove our kqueue context from a thread because it 	 * may sleep.  It would be nice if we could get a callback from 	 * kqueue when it is done cleaning up resources. 	 */
name|taskqueue_enqueue
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|softc
operator|->
name|shutdown_kqueue_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|passoninvalidate
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|struct
name|pass_softc
modifier|*
name|softc
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|pass_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
comment|/* 	 * De-register any async callbacks. 	 */
name|xpt_register_async
argument_list|(
literal|0
argument_list|,
name|passasync
argument_list|,
name|periph
argument_list|,
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|softc
operator|->
name|flags
operator||=
name|PASS_FLAG_INVALID
expr_stmt|;
comment|/* 	 * Tell devfs this device has gone away, and ask for a callback 	 * when it has cleaned up its state. 	 */
name|destroy_dev_sched_cb
argument_list|(
name|softc
operator|->
name|dev
argument_list|,
name|passdevgonecb
argument_list|,
name|periph
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|passcleanup
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|struct
name|pass_softc
modifier|*
name|softc
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|pass_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|cam_periph_assert
argument_list|(
name|periph
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|softc
operator|->
name|active_queue
argument_list|)
argument_list|,
operator|(
literal|"%s called when there are commands on the active queue!\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|softc
operator|->
name|abandoned_queue
argument_list|)
argument_list|,
operator|(
literal|"%s called when there are commands on the abandoned queue!\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|softc
operator|->
name|incoming_queue
argument_list|)
argument_list|,
operator|(
literal|"%s called when there are commands on the incoming queue!\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|softc
operator|->
name|done_queue
argument_list|)
argument_list|,
operator|(
literal|"%s called when there are commands on the done queue!\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|devstat_remove_entry
argument_list|(
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
comment|/* 	 * We call taskqueue_drain() for the physpath task to make sure it 	 * is complete.  We drop the lock because this can potentially 	 * sleep.  XXX KDM that is bad.  Need a way to get a callback when 	 * a taskqueue is drained. 	 *  	 * Note that we don't drain the kqueue shutdown task queue.  This 	 * is because we hold a reference on the periph for kqueue, and 	 * release that reference from the kqueue shutdown task queue.  So 	 * we cannot come into this routine unless we've released that 	 * reference.  Also, because that could be the last reference, we 	 * could be called from the cam_periph_release() call in 	 * pass_shutdown_kqueue().  In that case, the taskqueue_drain() 	 * would deadlock.  It would be preferable if we had a way to 	 * get a callback when a taskqueue is done. 	 */
name|taskqueue_drain
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|softc
operator|->
name|add_physpath_task
argument_list|)
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|softc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pass_shutdown_kqueue
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|pass_softc
modifier|*
name|softc
decl_stmt|;
name|periph
operator|=
name|context
expr_stmt|;
name|softc
operator|=
name|periph
operator|->
name|softc
expr_stmt|;
name|knlist_clear
argument_list|(
operator|&
name|softc
operator|->
name|read_select
operator|.
name|si_note
argument_list|,
comment|/*is_locked*/
literal|0
argument_list|)
expr_stmt|;
name|knlist_destroy
argument_list|(
operator|&
name|softc
operator|->
name|read_select
operator|.
name|si_note
argument_list|)
expr_stmt|;
comment|/* 	 * Release the reference we held for kqueue. 	 */
name|cam_periph_release
argument_list|(
name|periph
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pass_add_physpath
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|pass_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|mtx
modifier|*
name|mtx
decl_stmt|;
name|char
modifier|*
name|physpath
decl_stmt|;
comment|/* 	 * If we have one, create a devfs alias for our 	 * physical path. 	 */
name|periph
operator|=
name|context
expr_stmt|;
name|softc
operator|=
name|periph
operator|->
name|softc
expr_stmt|;
name|physpath
operator|=
name|malloc
argument_list|(
name|MAXPATHLEN
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|mtx
operator|=
name|cam_periph_mtx
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|periph
operator|->
name|flags
operator|&
name|CAM_PERIPH_INVALID
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|xpt_getattr
argument_list|(
name|physpath
argument_list|,
name|MAXPATHLEN
argument_list|,
literal|"GEOM::physpath"
argument_list|,
name|periph
operator|->
name|path
argument_list|)
operator|==
literal|0
operator|&&
name|strlen
argument_list|(
name|physpath
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
name|mtx
argument_list|)
expr_stmt|;
name|make_dev_physpath_alias
argument_list|(
name|MAKEDEV_WAITOK
argument_list|,
operator|&
name|softc
operator|->
name|alias_dev
argument_list|,
name|softc
operator|->
name|dev
argument_list|,
name|softc
operator|->
name|alias_dev
argument_list|,
name|physpath
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
name|mtx
argument_list|)
expr_stmt|;
block|}
name|out
label|:
comment|/* 	 * Now that we've made our alias, we no longer have to have a 	 * reference to the device. 	 */
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|PASS_FLAG_INITIAL_PHYSPATH
operator|)
operator|==
literal|0
condition|)
name|softc
operator|->
name|flags
operator||=
name|PASS_FLAG_INITIAL_PHYSPATH
expr_stmt|;
comment|/* 	 * We always acquire a reference to the periph before queueing this 	 * task queue function, so it won't go away before we run. 	 */
while|while
condition|(
name|pending
operator|--
operator|>
literal|0
condition|)
name|cam_periph_release_locked
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
name|mtx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|physpath
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|passasync
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|u_int32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|periph
operator|=
operator|(
expr|struct
name|cam_periph
operator|*
operator|)
name|callback_arg
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|AC_FOUND_DEVICE
case|:
block|{
name|struct
name|ccb_getdev
modifier|*
name|cgd
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|cgd
operator|=
operator|(
expr|struct
name|ccb_getdev
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|cgd
operator|==
name|NULL
condition|)
break|break;
comment|/* 		 * Allocate a peripheral instance for 		 * this device and start the probe 		 * process. 		 */
name|status
operator|=
name|cam_periph_alloc
argument_list|(
name|passregister
argument_list|,
name|passoninvalidate
argument_list|,
name|passcleanup
argument_list|,
name|passstart
argument_list|,
literal|"pass"
argument_list|,
name|CAM_PERIPH_BIO
argument_list|,
name|path
argument_list|,
name|passasync
argument_list|,
name|AC_FOUND_DEVICE
argument_list|,
name|cgd
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
operator|&&
name|status
operator|!=
name|CAM_REQ_INPROG
condition|)
block|{
specifier|const
name|struct
name|cam_status_entry
modifier|*
name|entry
decl_stmt|;
name|entry
operator|=
name|cam_fetch_status_entry
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"passasync: Unable to attach new device "
literal|"due to status %#x: %s\n"
argument_list|,
name|status
argument_list|,
name|entry
condition|?
name|entry
operator|->
name|status_text
else|:
literal|"Unknown"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|AC_ADVINFO_CHANGED
case|:
block|{
name|uintptr_t
name|buftype
decl_stmt|;
name|buftype
operator|=
operator|(
name|uintptr_t
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|buftype
operator|==
name|CDAI_TYPE_PHYS_PATH
condition|)
block|{
name|struct
name|pass_softc
modifier|*
name|softc
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|pass_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
comment|/* 			 * Acquire a reference to the periph before we 			 * start the taskqueue, so that we don't run into 			 * a situation where the periph goes away before 			 * the task queue has a chance to run. 			 */
name|status
operator|=
name|cam_periph_acquire
argument_list|(
name|periph
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
break|break;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|softc
operator|->
name|add_physpath_task
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
name|cam_periph_async
argument_list|(
name|periph
argument_list|,
name|code
argument_list|,
name|path
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|cam_status
name|passregister
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|pass_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ccb_getdev
modifier|*
name|cgd
decl_stmt|;
name|struct
name|ccb_pathinq
name|cpi
decl_stmt|;
name|struct
name|make_dev_args
name|args
decl_stmt|;
name|int
name|error
decl_stmt|,
name|no_tags
decl_stmt|;
name|cgd
operator|=
operator|(
expr|struct
name|ccb_getdev
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|cgd
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: no getdev CCB, can't register device\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
name|softc
operator|=
operator|(
expr|struct
name|pass_softc
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|softc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Unable to probe new device. "
literal|"Unable to allocate softc\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
name|bzero
argument_list|(
name|softc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|softc
argument_list|)
argument_list|)
expr_stmt|;
name|softc
operator|->
name|state
operator|=
name|PASS_STATE_NORMAL
expr_stmt|;
if|if
condition|(
name|cgd
operator|->
name|protocol
operator|==
name|PROTO_SCSI
operator|||
name|cgd
operator|->
name|protocol
operator|==
name|PROTO_ATAPI
condition|)
name|softc
operator|->
name|pd_type
operator|=
name|SID_TYPE
argument_list|(
operator|&
name|cgd
operator|->
name|inq_data
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cgd
operator|->
name|protocol
operator|==
name|PROTO_SATAPM
condition|)
name|softc
operator|->
name|pd_type
operator|=
name|T_ENCLOSURE
expr_stmt|;
else|else
name|softc
operator|->
name|pd_type
operator|=
name|T_DIRECT
expr_stmt|;
name|periph
operator|->
name|softc
operator|=
name|softc
expr_stmt|;
name|softc
operator|->
name|periph
operator|=
name|periph
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|softc
operator|->
name|incoming_queue
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|softc
operator|->
name|active_queue
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|softc
operator|->
name|abandoned_queue
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|softc
operator|->
name|done_queue
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|softc
operator|->
name|zone_name
argument_list|,
sizeof|sizeof
argument_list|(
name|softc
operator|->
name|zone_name
argument_list|)
argument_list|,
literal|"%s%d"
argument_list|,
name|periph
operator|->
name|periph_name
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|softc
operator|->
name|io_zone_name
argument_list|,
sizeof|sizeof
argument_list|(
name|softc
operator|->
name|io_zone_name
argument_list|)
argument_list|,
literal|"%s%dIO"
argument_list|,
name|periph
operator|->
name|periph_name
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|)
expr_stmt|;
name|softc
operator|->
name|io_zone_size
operator|=
name|MAXPHYS
expr_stmt|;
name|knlist_init_mtx
argument_list|(
operator|&
name|softc
operator|->
name|read_select
operator|.
name|si_note
argument_list|,
name|cam_periph_mtx
argument_list|(
name|periph
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|cpi
argument_list|,
sizeof|sizeof
argument_list|(
name|cpi
argument_list|)
argument_list|)
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|cpi
operator|.
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
name|CAM_PRIORITY_NORMAL
argument_list|)
expr_stmt|;
name|cpi
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_PATH_INQ
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|cpi
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpi
operator|.
name|maxio
operator|==
literal|0
condition|)
name|softc
operator|->
name|maxio
operator|=
name|DFLTPHYS
expr_stmt|;
comment|/* traditional default */
elseif|else
if|if
condition|(
name|cpi
operator|.
name|maxio
operator|>
name|MAXPHYS
condition|)
name|softc
operator|->
name|maxio
operator|=
name|MAXPHYS
expr_stmt|;
comment|/* for safety */
else|else
name|softc
operator|->
name|maxio
operator|=
name|cpi
operator|.
name|maxio
expr_stmt|;
comment|/* real value */
if|if
condition|(
name|cpi
operator|.
name|hba_misc
operator|&
name|PIM_UNMAPPED
condition|)
name|softc
operator|->
name|flags
operator||=
name|PASS_FLAG_UNMAPPED_CAPABLE
expr_stmt|;
comment|/* 	 * We pass in 0 for a blocksize, since we don't  	 * know what the blocksize of this device is, if  	 * it even has a blocksize. 	 */
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|no_tags
operator|=
operator|(
name|cgd
operator|->
name|inq_data
operator|.
name|flags
operator|&
name|SID_CmdQue
operator|)
operator|==
literal|0
expr_stmt|;
name|softc
operator|->
name|device_stats
operator|=
name|devstat_new_entry
argument_list|(
literal|"pass"
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|,
literal|0
argument_list|,
name|DEVSTAT_NO_BLOCKSIZE
operator||
operator|(
name|no_tags
condition|?
name|DEVSTAT_NO_ORDERED_TAGS
else|:
literal|0
operator|)
argument_list|,
name|softc
operator|->
name|pd_type
operator||
name|XPORT_DEVSTAT_TYPE
argument_list|(
name|cpi
operator|.
name|transport
argument_list|)
operator||
name|DEVSTAT_TYPE_PASS
argument_list|,
name|DEVSTAT_PRIORITY_PASS
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the taskqueue handler for shutting down kqueue. 	 */
name|TASK_INIT
argument_list|(
operator|&
name|softc
operator|->
name|shutdown_kqueue_task
argument_list|,
comment|/*priority*/
literal|0
argument_list|,
name|pass_shutdown_kqueue
argument_list|,
name|periph
argument_list|)
expr_stmt|;
comment|/* 	 * Acquire a reference to the periph that we can release once we've 	 * cleaned up the kqueue. 	 */
if|if
condition|(
name|cam_periph_acquire
argument_list|(
name|periph
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"%s: lost periph during "
literal|"registration!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
comment|/* 	 * Acquire a reference to the periph before we create the devfs 	 * instance for it.  We'll release this reference once the devfs 	 * instance has been freed. 	 */
if|if
condition|(
name|cam_periph_acquire
argument_list|(
name|periph
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"%s: lost periph during "
literal|"registration!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
comment|/* Register the device */
name|make_dev_args_init
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
name|args
operator|.
name|mda_devsw
operator|=
operator|&
name|pass_cdevsw
expr_stmt|;
name|args
operator|.
name|mda_unit
operator|=
name|periph
operator|->
name|unit_number
expr_stmt|;
name|args
operator|.
name|mda_uid
operator|=
name|UID_ROOT
expr_stmt|;
name|args
operator|.
name|mda_gid
operator|=
name|GID_OPERATOR
expr_stmt|;
name|args
operator|.
name|mda_mode
operator|=
literal|0600
expr_stmt|;
name|args
operator|.
name|mda_si_drv1
operator|=
name|periph
expr_stmt|;
name|error
operator|=
name|make_dev_s
argument_list|(
operator|&
name|args
argument_list|,
operator|&
name|softc
operator|->
name|dev
argument_list|,
literal|"%s%d"
argument_list|,
name|periph
operator|->
name|periph_name
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|cam_periph_release_locked
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
comment|/* 	 * Hold a reference to the periph before we create the physical 	 * path alias so it can't go away. 	 */
if|if
condition|(
name|cam_periph_acquire
argument_list|(
name|periph
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"%s: lost periph during "
literal|"registration!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|softc
operator|->
name|add_physpath_task
argument_list|,
comment|/*priority*/
literal|0
argument_list|,
name|pass_add_physpath
argument_list|,
name|periph
argument_list|)
expr_stmt|;
comment|/* 	 * See if physical path information is already available. 	 */
name|taskqueue_enqueue
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|softc
operator|->
name|add_physpath_task
argument_list|)
expr_stmt|;
comment|/* 	 * Add an async callback so that we get notified if 	 * this device goes away or its physical path 	 * (stored in the advanced info data of the EDT) has 	 * changed. 	 */
name|xpt_register_async
argument_list|(
name|AC_LOST_DEVICE
operator||
name|AC_ADVINFO_CHANGED
argument_list|,
name|passasync
argument_list|,
name|periph
argument_list|,
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|xpt_announce_periph
argument_list|(
name|periph
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|passopen
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|pass_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|periph
operator|=
operator|(
expr|struct
name|cam_periph
operator|*
operator|)
name|dev
operator|->
name|si_drv1
expr_stmt|;
if|if
condition|(
name|cam_periph_acquire
argument_list|(
name|periph
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|pass_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|flags
operator|&
name|PASS_FLAG_INVALID
condition|)
block|{
name|cam_periph_release_locked
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * Don't allow access when we're running at a high securelevel. 	 */
name|error
operator|=
name|securelevel_gt
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|cam_periph_release_locked
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Only allow read-write access. 	 */
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
name|FWRITE
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|flags
operator|&
name|FREAD
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|cam_periph_release_locked
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
comment|/* 	 * We don't allow nonblocking access. 	 */
if|if
condition|(
operator|(
name|flags
operator|&
name|O_NONBLOCK
operator|)
operator|!=
literal|0
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"can't do nonblocking access\n"
argument_list|)
expr_stmt|;
name|cam_periph_release_locked
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|softc
operator|->
name|open_count
operator|++
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|passclose
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|pass_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|mtx
modifier|*
name|mtx
decl_stmt|;
name|periph
operator|=
operator|(
expr|struct
name|cam_periph
operator|*
operator|)
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|mtx
operator|=
name|cam_periph_mtx
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
name|mtx
argument_list|)
expr_stmt|;
name|softc
operator|=
name|periph
operator|->
name|softc
expr_stmt|;
name|softc
operator|->
name|open_count
operator|--
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|open_count
operator|==
literal|0
condition|)
block|{
name|struct
name|pass_io_req
modifier|*
name|io_req
decl_stmt|,
modifier|*
name|io_req2
decl_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|io_req
argument_list|,
argument|&softc->done_queue
argument_list|,
argument|links
argument_list|,
argument|io_req2
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|softc
operator|->
name|done_queue
argument_list|,
name|io_req
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|passiocleanup
argument_list|(
name|softc
argument_list|,
name|io_req
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|softc
operator|->
name|pass_zone
argument_list|,
name|io_req
argument_list|)
expr_stmt|;
block|}
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|io_req
argument_list|,
argument|&softc->incoming_queue
argument_list|,
argument|links
argument_list|,
argument|io_req2
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|softc
operator|->
name|incoming_queue
argument_list|,
name|io_req
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|passiocleanup
argument_list|(
name|softc
argument_list|,
name|io_req
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|softc
operator|->
name|pass_zone
argument_list|,
name|io_req
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If there are any active I/Os, we need to forcibly acquire a 		 * reference to the peripheral so that we don't go away 		 * before they complete.  We'll release the reference when 		 * the abandoned queue is empty. 		 */
name|io_req
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|softc
operator|->
name|active_queue
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|io_req
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|softc
operator|->
name|flags
operator|&
name|PASS_FLAG_ABANDONED_REF_SET
operator|)
operator|==
literal|0
condition|)
block|{
name|cam_periph_doacquire
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|softc
operator|->
name|flags
operator||=
name|PASS_FLAG_ABANDONED_REF_SET
expr_stmt|;
block|}
comment|/* 		 * Since the I/O in the active queue is not under our 		 * control, just set a flag so that we can clean it up when 		 * it completes and put it on the abandoned queue.  This 		 * will prevent our sending spurious completions in the 		 * event that the device is opened again before these I/Os 		 * complete. 		 */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|io_req
argument_list|,
argument|&softc->active_queue
argument_list|,
argument|links
argument_list|,
argument|io_req2
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|softc
operator|->
name|active_queue
argument_list|,
name|io_req
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|io_req
operator|->
name|flags
operator||=
name|PASS_IO_ABANDONED
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|softc
operator|->
name|abandoned_queue
argument_list|,
name|io_req
argument_list|,
name|links
argument_list|)
expr_stmt|;
block|}
block|}
name|cam_periph_release_locked
argument_list|(
name|periph
argument_list|)
expr_stmt|;
comment|/* 	 * We reference the lock directly here, instead of using 	 * cam_periph_unlock().  The reason is that the call to 	 * cam_periph_release_locked() above could result in the periph 	 * getting freed.  If that is the case, dereferencing the periph 	 * with a cam_periph_unlock() call would cause a page fault. 	 * 	 * cam_periph_release() avoids this problem using the same method, 	 * but we're manually acquiring and dropping the lock here to 	 * protect the open count and avoid another lock acquisition and 	 * release. 	 */
name|mtx_unlock
argument_list|(
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|passstart
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|start_ccb
parameter_list|)
block|{
name|struct
name|pass_softc
modifier|*
name|softc
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|pass_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
switch|switch
condition|(
name|softc
operator|->
name|state
condition|)
block|{
case|case
name|PASS_STATE_NORMAL
case|:
block|{
name|struct
name|pass_io_req
modifier|*
name|io_req
decl_stmt|;
comment|/* 		 * Check for any queued I/O requests that require an 		 * allocated slot. 		 */
name|io_req
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|softc
operator|->
name|incoming_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|io_req
operator|==
name|NULL
condition|)
block|{
name|xpt_release_ccb
argument_list|(
name|start_ccb
argument_list|)
expr_stmt|;
break|break;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|softc
operator|->
name|incoming_queue
argument_list|,
name|io_req
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|softc
operator|->
name|active_queue
argument_list|,
name|io_req
argument_list|,
name|links
argument_list|)
expr_stmt|;
comment|/* 		 * Merge the user's CCB into the allocated CCB. 		 */
name|xpt_merge_ccb
argument_list|(
name|start_ccb
argument_list|,
operator|&
name|io_req
operator|->
name|ccb
argument_list|)
expr_stmt|;
name|start_ccb
operator|->
name|ccb_h
operator|.
name|ccb_type
operator|=
name|PASS_CCB_QUEUED_IO
expr_stmt|;
name|start_ccb
operator|->
name|ccb_h
operator|.
name|ccb_ioreq
operator|=
name|io_req
expr_stmt|;
name|start_ccb
operator|->
name|ccb_h
operator|.
name|cbfcnp
operator|=
name|passdone
expr_stmt|;
name|io_req
operator|->
name|alloced_ccb
operator|=
name|start_ccb
expr_stmt|;
name|binuptime
argument_list|(
operator|&
name|io_req
operator|->
name|start_time
argument_list|)
expr_stmt|;
name|devstat_start_transaction
argument_list|(
name|softc
operator|->
name|device_stats
argument_list|,
operator|&
name|io_req
operator|->
name|start_time
argument_list|)
expr_stmt|;
name|xpt_action
argument_list|(
name|start_ccb
argument_list|)
expr_stmt|;
comment|/* 		 * If we have any more I/O waiting, schedule ourselves again. 		 */
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|softc
operator|->
name|incoming_queue
argument_list|)
condition|)
name|xpt_schedule
argument_list|(
name|periph
argument_list|,
name|CAM_PRIORITY_NORMAL
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|passdone
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|done_ccb
parameter_list|)
block|{
name|struct
name|pass_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|pass_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|cam_periph_assert
argument_list|(
name|periph
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|csio
operator|=
operator|&
name|done_ccb
operator|->
name|csio
expr_stmt|;
switch|switch
condition|(
name|csio
operator|->
name|ccb_h
operator|.
name|ccb_type
condition|)
block|{
case|case
name|PASS_CCB_QUEUED_IO
case|:
block|{
name|struct
name|pass_io_req
modifier|*
name|io_req
decl_stmt|;
name|io_req
operator|=
name|done_ccb
operator|->
name|ccb_h
operator|.
name|ccb_ioreq
expr_stmt|;
if|#
directive|if
literal|0
block|xpt_print(periph->path, "%s: called for user CCB %p\n", 			  __func__, io_req->user_ccb_ptr);
endif|#
directive|endif
if|if
condition|(
operator|(
operator|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
operator|)
operator|&&
operator|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_PASS_ERR_RECOVER
operator|)
operator|&&
operator|(
operator|(
name|io_req
operator|->
name|flags
operator|&
name|PASS_IO_ABANDONED
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|passerror
argument_list|(
name|done_ccb
argument_list|,
name|CAM_RETRY_SELTO
argument_list|,
name|SF_RETRY_UA
operator||
name|SF_NO_PRINT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
block|{
comment|/* 				 * A retry was scheduled, so  				 * just return. 				 */
return|return;
block|}
block|}
comment|/* 		 * Copy the allocated CCB contents back to the malloced CCB 		 * so we can give status back to the user when he requests it. 		 */
name|bcopy
argument_list|(
name|done_ccb
argument_list|,
operator|&
name|io_req
operator|->
name|ccb
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|done_ccb
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Log data/transaction completion with devstat(9). 		 */
switch|switch
condition|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_SCSI_IO
case|:
name|devstat_end_transaction
argument_list|(
name|softc
operator|->
name|device_stats
argument_list|,
name|done_ccb
operator|->
name|csio
operator|.
name|dxfer_len
operator|-
name|done_ccb
operator|->
name|csio
operator|.
name|resid
argument_list|,
name|done_ccb
operator|->
name|csio
operator|.
name|tag_action
operator|&
literal|0x3
argument_list|,
operator|(
operator|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_NONE
operator|)
condition|?
name|DEVSTAT_NO_DATA
else|:
operator|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_OUT
operator|)
condition|?
name|DEVSTAT_WRITE
else|:
name|DEVSTAT_READ
argument_list|,
name|NULL
argument_list|,
operator|&
name|io_req
operator|->
name|start_time
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_ATA_IO
case|:
name|devstat_end_transaction
argument_list|(
name|softc
operator|->
name|device_stats
argument_list|,
name|done_ccb
operator|->
name|ataio
operator|.
name|dxfer_len
operator|-
name|done_ccb
operator|->
name|ataio
operator|.
name|resid
argument_list|,
literal|0
argument_list|,
comment|/* Not used in ATA */
operator|(
operator|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_NONE
operator|)
condition|?
name|DEVSTAT_NO_DATA
else|:
operator|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_OUT
operator|)
condition|?
name|DEVSTAT_WRITE
else|:
name|DEVSTAT_READ
argument_list|,
name|NULL
argument_list|,
operator|&
name|io_req
operator|->
name|start_time
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_SMP_IO
case|:
comment|/* 			 * XXX KDM this isn't quite right, but there isn't 			 * currently an easy way to represent a bidirectional  			 * transfer in devstat.  The only way to do it 			 * and have the byte counts come out right would 			 * mean that we would have to record two 			 * transactions, one for the request and one for the 			 * response.  For now, so that we report something, 			 * just treat the entire thing as a read. 			 */
name|devstat_end_transaction
argument_list|(
name|softc
operator|->
name|device_stats
argument_list|,
name|done_ccb
operator|->
name|smpio
operator|.
name|smp_request_len
operator|+
name|done_ccb
operator|->
name|smpio
operator|.
name|smp_response_len
argument_list|,
name|DEVSTAT_TAG_SIMPLE
argument_list|,
name|DEVSTAT_READ
argument_list|,
name|NULL
argument_list|,
operator|&
name|io_req
operator|->
name|start_time
argument_list|)
expr_stmt|;
break|break;
default|default:
name|devstat_end_transaction
argument_list|(
name|softc
operator|->
name|device_stats
argument_list|,
literal|0
argument_list|,
name|DEVSTAT_TAG_NONE
argument_list|,
name|DEVSTAT_NO_DATA
argument_list|,
name|NULL
argument_list|,
operator|&
name|io_req
operator|->
name|start_time
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * In the normal case, take the completed I/O off of the 		 * active queue and put it on the done queue.  Notitfy the 		 * user that we have a completed I/O. 		 */
if|if
condition|(
operator|(
name|io_req
operator|->
name|flags
operator|&
name|PASS_IO_ABANDONED
operator|)
operator|==
literal|0
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|softc
operator|->
name|active_queue
argument_list|,
name|io_req
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|softc
operator|->
name|done_queue
argument_list|,
name|io_req
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|selwakeuppri
argument_list|(
operator|&
name|softc
operator|->
name|read_select
argument_list|,
name|PRIBIO
argument_list|)
expr_stmt|;
name|KNOTE_LOCKED
argument_list|(
operator|&
name|softc
operator|->
name|read_select
operator|.
name|si_note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * In the case of an abandoned I/O (final close 			 * without fetching the I/O), take it off of the 			 * abandoned queue and free it. 			 */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|softc
operator|->
name|abandoned_queue
argument_list|,
name|io_req
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|passiocleanup
argument_list|(
name|softc
argument_list|,
name|io_req
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|softc
operator|->
name|pass_zone
argument_list|,
name|io_req
argument_list|)
expr_stmt|;
comment|/* 			 * Release the done_ccb here, since we may wind up 			 * freeing the peripheral when we decrement the 			 * reference count below. 			 */
name|xpt_release_ccb
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
comment|/* 			 * If the abandoned queue is empty, we can release 			 * our reference to the periph since we won't have 			 * any more completions coming. 			 */
if|if
condition|(
operator|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|softc
operator|->
name|abandoned_queue
argument_list|)
operator|)
operator|&&
operator|(
name|softc
operator|->
name|flags
operator|&
name|PASS_FLAG_ABANDONED_REF_SET
operator|)
condition|)
block|{
name|softc
operator|->
name|flags
operator|&=
operator|~
name|PASS_FLAG_ABANDONED_REF_SET
expr_stmt|;
name|cam_periph_release_locked
argument_list|(
name|periph
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * We have already released the CCB, so we can 			 * return. 			 */
return|return;
block|}
break|break;
block|}
block|}
name|xpt_release_ccb
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|passcreatezone
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|struct
name|pass_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|pass_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|cam_periph_assert
argument_list|(
name|periph
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|PASS_FLAG_ZONE_VALID
operator|)
operator|==
literal|0
operator|)
argument_list|,
operator|(
literal|"%s called when the pass(4) zone is valid!\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|softc
operator|->
name|pass_zone
operator|==
name|NULL
operator|)
argument_list|,
operator|(
literal|"%s called when the pass(4) zone is allocated!\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|PASS_FLAG_ZONE_INPROG
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * We're the first context through, so we need to create 		 * the pass(4) UMA zone for I/O requests. 		 */
name|softc
operator|->
name|flags
operator||=
name|PASS_FLAG_ZONE_INPROG
expr_stmt|;
comment|/* 		 * uma_zcreate() does a blocking (M_WAITOK) allocation, 		 * so we cannot hold a mutex while we call it. 		 */
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|softc
operator|->
name|pass_zone
operator|=
name|uma_zcreate
argument_list|(
name|softc
operator|->
name|zone_name
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pass_io_req
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/*align*/
literal|0
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
name|softc
operator|->
name|pass_io_zone
operator|=
name|uma_zcreate
argument_list|(
name|softc
operator|->
name|io_zone_name
argument_list|,
name|softc
operator|->
name|io_zone_size
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/*align*/
literal|0
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|softc
operator|->
name|pass_zone
operator|==
name|NULL
operator|)
operator|||
operator|(
name|softc
operator|->
name|pass_io_zone
operator|==
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|softc
operator|->
name|pass_zone
operator|==
name|NULL
condition|)
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"unable to allocate "
literal|"IO Req UMA zone\n"
argument_list|)
expr_stmt|;
else|else
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"unable to allocate "
literal|"IO UMA zone\n"
argument_list|)
expr_stmt|;
name|softc
operator|->
name|flags
operator|&=
operator|~
name|PASS_FLAG_ZONE_INPROG
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
comment|/* 		 * Set the flags appropriately and notify any other waiters. 		 */
name|softc
operator|->
name|flags
operator|&=
name|PASS_FLAG_ZONE_INPROG
expr_stmt|;
name|softc
operator|->
name|flags
operator||=
name|PASS_FLAG_ZONE_VALID
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|softc
operator|->
name|pass_zone
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * In this case, the UMA zone has not yet been created, but 		 * another context is in the process of creating it.  We 		 * need to sleep until the creation is either done or has 		 * failed. 		 */
while|while
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|PASS_FLAG_ZONE_INPROG
operator|)
operator|&&
operator|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|PASS_FLAG_ZONE_VALID
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|error
operator|=
name|msleep
argument_list|(
operator|&
name|softc
operator|->
name|pass_zone
argument_list|,
name|cam_periph_mtx
argument_list|(
name|periph
argument_list|)
argument_list|,
name|PRIBIO
argument_list|,
literal|"paszon"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|bailout
goto|;
block|}
comment|/* 		 * If the zone creation failed, no luck for the user. 		 */
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|PASS_FLAG_ZONE_VALID
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
block|}
name|bailout
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|passiocleanup
parameter_list|(
name|struct
name|pass_softc
modifier|*
name|softc
parameter_list|,
name|struct
name|pass_io_req
modifier|*
name|io_req
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|u_int8_t
modifier|*
modifier|*
name|data_ptrs
index|[
name|CAM_PERIPH_MAXMAPS
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|numbufs
decl_stmt|;
name|ccb
operator|=
operator|&
name|io_req
operator|->
name|ccb
expr_stmt|;
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_DEV_MATCH
case|:
name|numbufs
operator|=
name|min
argument_list|(
name|io_req
operator|->
name|num_bufs
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|numbufs
operator|==
literal|1
condition|)
block|{
name|data_ptrs
index|[
literal|0
index|]
operator|=
operator|(
name|u_int8_t
operator|*
operator|*
operator|)
operator|&
name|ccb
operator|->
name|cdm
operator|.
name|matches
expr_stmt|;
block|}
else|else
block|{
name|data_ptrs
index|[
literal|0
index|]
operator|=
operator|(
name|u_int8_t
operator|*
operator|*
operator|)
operator|&
name|ccb
operator|->
name|cdm
operator|.
name|patterns
expr_stmt|;
name|data_ptrs
index|[
literal|1
index|]
operator|=
operator|(
name|u_int8_t
operator|*
operator|*
operator|)
operator|&
name|ccb
operator|->
name|cdm
operator|.
name|matches
expr_stmt|;
block|}
break|break;
case|case
name|XPT_SCSI_IO
case|:
case|case
name|XPT_CONT_TARGET_IO
case|:
name|data_ptrs
index|[
literal|0
index|]
operator|=
operator|&
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
expr_stmt|;
name|numbufs
operator|=
name|min
argument_list|(
name|io_req
operator|->
name|num_bufs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_ATA_IO
case|:
name|data_ptrs
index|[
literal|0
index|]
operator|=
operator|&
name|ccb
operator|->
name|ataio
operator|.
name|data_ptr
expr_stmt|;
name|numbufs
operator|=
name|min
argument_list|(
name|io_req
operator|->
name|num_bufs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_SMP_IO
case|:
name|numbufs
operator|=
name|min
argument_list|(
name|io_req
operator|->
name|num_bufs
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|data_ptrs
index|[
literal|0
index|]
operator|=
operator|&
name|ccb
operator|->
name|smpio
operator|.
name|smp_request
expr_stmt|;
name|data_ptrs
index|[
literal|1
index|]
operator|=
operator|&
name|ccb
operator|->
name|smpio
operator|.
name|smp_response
expr_stmt|;
break|break;
case|case
name|XPT_DEV_ADVINFO
case|:
name|numbufs
operator|=
name|min
argument_list|(
name|io_req
operator|->
name|num_bufs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|data_ptrs
index|[
literal|0
index|]
operator|=
operator|(
name|uint8_t
operator|*
operator|*
operator|)
operator|&
name|ccb
operator|->
name|cdai
operator|.
name|buf
expr_stmt|;
break|break;
default|default:
comment|/* allow ourselves to be swapped once again */
return|return;
break|break;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|io_req
operator|->
name|flags
operator|&
name|PASS_IO_USER_SEG_MALLOC
condition|)
block|{
name|free
argument_list|(
name|io_req
operator|->
name|user_segptr
argument_list|,
name|M_SCSIPASS
argument_list|)
expr_stmt|;
name|io_req
operator|->
name|user_segptr
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * We only want to free memory we malloced. 	 */
if|if
condition|(
name|io_req
operator|->
name|data_flags
operator|==
name|CAM_DATA_VADDR
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|io_req
operator|->
name|num_bufs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|io_req
operator|->
name|kern_bufs
index|[
name|i
index|]
operator|==
name|NULL
condition|)
continue|continue;
name|free
argument_list|(
name|io_req
operator|->
name|kern_bufs
index|[
name|i
index|]
argument_list|,
name|M_SCSIPASS
argument_list|)
expr_stmt|;
name|io_req
operator|->
name|kern_bufs
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|io_req
operator|->
name|data_flags
operator|==
name|CAM_DATA_SG
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|io_req
operator|->
name|num_kern_segs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|io_req
operator|->
name|kern_segptr
index|[
name|i
index|]
operator|.
name|ds_addr
operator|==
name|NULL
condition|)
continue|continue;
name|uma_zfree
argument_list|(
name|softc
operator|->
name|pass_io_zone
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|io_req
operator|->
name|kern_segptr
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|io_req
operator|->
name|kern_segptr
index|[
name|i
index|]
operator|.
name|ds_addr
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|io_req
operator|->
name|flags
operator|&
name|PASS_IO_KERN_SEG_MALLOC
condition|)
block|{
name|free
argument_list|(
name|io_req
operator|->
name|kern_segptr
argument_list|,
name|M_SCSIPASS
argument_list|)
expr_stmt|;
name|io_req
operator|->
name|kern_segptr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|io_req
operator|->
name|data_flags
operator|!=
name|CAM_DATA_PADDR
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numbufs
condition|;
name|i
operator|++
control|)
block|{
comment|/* 			 * Restore the user's buffer pointers to their 			 * previous values. 			 */
if|if
condition|(
name|io_req
operator|->
name|user_bufs
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
operator|*
name|data_ptrs
index|[
name|i
index|]
operator|=
name|io_req
operator|->
name|user_bufs
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|passcopysglist
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|pass_io_req
modifier|*
name|io_req
parameter_list|,
name|ccb_flags
name|direction
parameter_list|)
block|{
name|bus_size_t
name|kern_watermark
decl_stmt|,
name|user_watermark
decl_stmt|,
name|len_copied
decl_stmt|,
name|len_to_copy
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|user_sglist
decl_stmt|,
modifier|*
name|kern_sglist
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|kern_watermark
operator|=
literal|0
expr_stmt|;
name|user_watermark
operator|=
literal|0
expr_stmt|;
name|len_to_copy
operator|=
literal|0
expr_stmt|;
name|len_copied
operator|=
literal|0
expr_stmt|;
name|user_sglist
operator|=
name|io_req
operator|->
name|user_segptr
expr_stmt|;
name|kern_sglist
operator|=
name|io_req
operator|->
name|kern_segptr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|io_req
operator|->
name|num_user_segs
operator|&&
name|j
operator|<
name|io_req
operator|->
name|num_kern_segs
condition|;
control|)
block|{
name|uint8_t
modifier|*
name|user_ptr
decl_stmt|,
modifier|*
name|kern_ptr
decl_stmt|;
name|len_to_copy
operator|=
name|min
argument_list|(
name|user_sglist
index|[
name|i
index|]
operator|.
name|ds_len
operator|-
name|user_watermark
argument_list|,
name|kern_sglist
index|[
name|j
index|]
operator|.
name|ds_len
operator|-
name|kern_watermark
argument_list|)
expr_stmt|;
name|user_ptr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|user_sglist
index|[
name|i
index|]
operator|.
name|ds_addr
expr_stmt|;
name|user_ptr
operator|=
name|user_ptr
operator|+
name|user_watermark
expr_stmt|;
name|kern_ptr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|kern_sglist
index|[
name|j
index|]
operator|.
name|ds_addr
expr_stmt|;
name|kern_ptr
operator|=
name|kern_ptr
operator|+
name|kern_watermark
expr_stmt|;
name|user_watermark
operator|+=
name|len_to_copy
expr_stmt|;
name|kern_watermark
operator|+=
name|len_to_copy
expr_stmt|;
if|if
condition|(
operator|!
name|useracc
argument_list|(
name|user_ptr
argument_list|,
name|len_to_copy
argument_list|,
operator|(
name|direction
operator|==
name|CAM_DIR_IN
operator|)
condition|?
name|VM_PROT_WRITE
else|:
name|VM_PROT_READ
argument_list|)
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"%s: unable to access user "
literal|"S/G list element %p len %zu\n"
argument_list|,
name|__func__
argument_list|,
name|user_ptr
argument_list|,
name|len_to_copy
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
name|direction
operator|==
name|CAM_DIR_IN
condition|)
block|{
name|error
operator|=
name|copyout
argument_list|(
name|kern_ptr
argument_list|,
name|user_ptr
argument_list|,
name|len_to_copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"%s: copyout of %u "
literal|"bytes from %p to %p failed with "
literal|"error %d\n"
argument_list|,
name|__func__
argument_list|,
name|len_to_copy
argument_list|,
name|kern_ptr
argument_list|,
name|user_ptr
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
block|}
else|else
block|{
name|error
operator|=
name|copyin
argument_list|(
name|user_ptr
argument_list|,
name|kern_ptr
argument_list|,
name|len_to_copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"%s: copyin of %u "
literal|"bytes from %p to %p failed with "
literal|"error %d\n"
argument_list|,
name|__func__
argument_list|,
name|len_to_copy
argument_list|,
name|user_ptr
argument_list|,
name|kern_ptr
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
block|}
name|len_copied
operator|+=
name|len_to_copy
expr_stmt|;
if|if
condition|(
name|user_sglist
index|[
name|i
index|]
operator|.
name|ds_len
operator|==
name|user_watermark
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|user_watermark
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|kern_sglist
index|[
name|j
index|]
operator|.
name|ds_len
operator|==
name|kern_watermark
condition|)
block|{
name|j
operator|++
expr_stmt|;
name|kern_watermark
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|bailout
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|passmemsetup
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|pass_io_req
modifier|*
name|io_req
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|pass_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|numbufs
decl_stmt|,
name|i
decl_stmt|;
name|uint8_t
modifier|*
modifier|*
name|data_ptrs
index|[
name|CAM_PERIPH_MAXMAPS
index|]
decl_stmt|;
name|uint32_t
name|lengths
index|[
name|CAM_PERIPH_MAXMAPS
index|]
decl_stmt|;
name|uint32_t
name|dirs
index|[
name|CAM_PERIPH_MAXMAPS
index|]
decl_stmt|;
name|uint32_t
name|num_segs
decl_stmt|;
name|uint16_t
modifier|*
name|seg_cnt_ptr
decl_stmt|;
name|size_t
name|maxmap
decl_stmt|;
name|int
name|error
decl_stmt|;
name|cam_periph_assert
argument_list|(
name|periph
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
name|softc
operator|=
name|periph
operator|->
name|softc
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|ccb
operator|=
operator|&
name|io_req
operator|->
name|ccb
expr_stmt|;
name|maxmap
operator|=
literal|0
expr_stmt|;
name|num_segs
operator|=
literal|0
expr_stmt|;
name|seg_cnt_ptr
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_DEV_MATCH
case|:
if|if
condition|(
name|ccb
operator|->
name|cdm
operator|.
name|match_buf_len
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: invalid match buffer length 0\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|ccb
operator|->
name|cdm
operator|.
name|pattern_buf_len
operator|>
literal|0
condition|)
block|{
name|data_ptrs
index|[
literal|0
index|]
operator|=
operator|(
name|u_int8_t
operator|*
operator|*
operator|)
operator|&
name|ccb
operator|->
name|cdm
operator|.
name|patterns
expr_stmt|;
name|lengths
index|[
literal|0
index|]
operator|=
name|ccb
operator|->
name|cdm
operator|.
name|pattern_buf_len
expr_stmt|;
name|dirs
index|[
literal|0
index|]
operator|=
name|CAM_DIR_OUT
expr_stmt|;
name|data_ptrs
index|[
literal|1
index|]
operator|=
operator|(
name|u_int8_t
operator|*
operator|*
operator|)
operator|&
name|ccb
operator|->
name|cdm
operator|.
name|matches
expr_stmt|;
name|lengths
index|[
literal|1
index|]
operator|=
name|ccb
operator|->
name|cdm
operator|.
name|match_buf_len
expr_stmt|;
name|dirs
index|[
literal|1
index|]
operator|=
name|CAM_DIR_IN
expr_stmt|;
name|numbufs
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|data_ptrs
index|[
literal|0
index|]
operator|=
operator|(
name|u_int8_t
operator|*
operator|*
operator|)
operator|&
name|ccb
operator|->
name|cdm
operator|.
name|matches
expr_stmt|;
name|lengths
index|[
literal|0
index|]
operator|=
name|ccb
operator|->
name|cdm
operator|.
name|match_buf_len
expr_stmt|;
name|dirs
index|[
literal|0
index|]
operator|=
name|CAM_DIR_IN
expr_stmt|;
name|numbufs
operator|=
literal|1
expr_stmt|;
block|}
name|io_req
operator|->
name|data_flags
operator|=
name|CAM_DATA_VADDR
expr_stmt|;
break|break;
case|case
name|XPT_SCSI_IO
case|:
case|case
name|XPT_CONT_TARGET_IO
case|:
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_NONE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 		 * The user shouldn't be able to supply a bio. 		 */
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DATA_MASK
operator|)
operator|==
name|CAM_DATA_BIO
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|io_req
operator|->
name|data_flags
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DATA_MASK
expr_stmt|;
name|data_ptrs
index|[
literal|0
index|]
operator|=
operator|&
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
expr_stmt|;
name|lengths
index|[
literal|0
index|]
operator|=
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
expr_stmt|;
name|dirs
index|[
literal|0
index|]
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
expr_stmt|;
name|num_segs
operator|=
name|ccb
operator|->
name|csio
operator|.
name|sglist_cnt
expr_stmt|;
name|seg_cnt_ptr
operator|=
operator|&
name|ccb
operator|->
name|csio
operator|.
name|sglist_cnt
expr_stmt|;
name|numbufs
operator|=
literal|1
expr_stmt|;
name|maxmap
operator|=
name|softc
operator|->
name|maxio
expr_stmt|;
break|break;
case|case
name|XPT_ATA_IO
case|:
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_NONE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 		 * We only support a single virtual address for ATA I/O. 		 */
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DATA_MASK
operator|)
operator|!=
name|CAM_DATA_VADDR
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|io_req
operator|->
name|data_flags
operator|=
name|CAM_DATA_VADDR
expr_stmt|;
name|data_ptrs
index|[
literal|0
index|]
operator|=
operator|&
name|ccb
operator|->
name|ataio
operator|.
name|data_ptr
expr_stmt|;
name|lengths
index|[
literal|0
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|dxfer_len
expr_stmt|;
name|dirs
index|[
literal|0
index|]
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
expr_stmt|;
name|numbufs
operator|=
literal|1
expr_stmt|;
name|maxmap
operator|=
name|softc
operator|->
name|maxio
expr_stmt|;
break|break;
case|case
name|XPT_SMP_IO
case|:
name|io_req
operator|->
name|data_flags
operator|=
name|CAM_DATA_VADDR
expr_stmt|;
name|data_ptrs
index|[
literal|0
index|]
operator|=
operator|&
name|ccb
operator|->
name|smpio
operator|.
name|smp_request
expr_stmt|;
name|lengths
index|[
literal|0
index|]
operator|=
name|ccb
operator|->
name|smpio
operator|.
name|smp_request_len
expr_stmt|;
name|dirs
index|[
literal|0
index|]
operator|=
name|CAM_DIR_OUT
expr_stmt|;
name|data_ptrs
index|[
literal|1
index|]
operator|=
operator|&
name|ccb
operator|->
name|smpio
operator|.
name|smp_response
expr_stmt|;
name|lengths
index|[
literal|1
index|]
operator|=
name|ccb
operator|->
name|smpio
operator|.
name|smp_response_len
expr_stmt|;
name|dirs
index|[
literal|1
index|]
operator|=
name|CAM_DIR_IN
expr_stmt|;
name|numbufs
operator|=
literal|2
expr_stmt|;
name|maxmap
operator|=
name|softc
operator|->
name|maxio
expr_stmt|;
break|break;
case|case
name|XPT_DEV_ADVINFO
case|:
if|if
condition|(
name|ccb
operator|->
name|cdai
operator|.
name|bufsiz
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|io_req
operator|->
name|data_flags
operator|=
name|CAM_DATA_VADDR
expr_stmt|;
name|data_ptrs
index|[
literal|0
index|]
operator|=
operator|(
name|uint8_t
operator|*
operator|*
operator|)
operator|&
name|ccb
operator|->
name|cdai
operator|.
name|buf
expr_stmt|;
name|lengths
index|[
literal|0
index|]
operator|=
name|ccb
operator|->
name|cdai
operator|.
name|bufsiz
expr_stmt|;
name|dirs
index|[
literal|0
index|]
operator|=
name|CAM_DIR_IN
expr_stmt|;
name|numbufs
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
comment|/* NOTREACHED */
block|}
name|io_req
operator|->
name|num_bufs
operator|=
name|numbufs
expr_stmt|;
comment|/* 	 * If there is a maximum, check to make sure that the user's 	 * request fits within the limit.  In general, we should only have 	 * a maximum length for requests that go to hardware.  Otherwise it 	 * is whatever we're able to malloc. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numbufs
condition|;
name|i
operator|++
control|)
block|{
name|io_req
operator|->
name|user_bufs
index|[
name|i
index|]
operator|=
operator|*
name|data_ptrs
index|[
name|i
index|]
expr_stmt|;
name|io_req
operator|->
name|dirs
index|[
name|i
index|]
operator|=
name|dirs
index|[
name|i
index|]
expr_stmt|;
name|io_req
operator|->
name|lengths
index|[
name|i
index|]
operator|=
name|lengths
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|maxmap
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|lengths
index|[
name|i
index|]
operator|<=
name|maxmap
condition|)
continue|continue;
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"%s: data length %u> max allowed %u "
literal|"bytes\n"
argument_list|,
name|__func__
argument_list|,
name|lengths
index|[
name|i
index|]
argument_list|,
name|maxmap
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
switch|switch
condition|(
name|io_req
operator|->
name|data_flags
condition|)
block|{
case|case
name|CAM_DATA_VADDR
case|:
comment|/* Map or copy the buffer into kernel address space */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numbufs
condition|;
name|i
operator|++
control|)
block|{
name|uint8_t
modifier|*
name|tmp_buf
decl_stmt|;
comment|/* 			 * If for some reason no length is specified, we 			 * don't need to allocate anything. 			 */
if|if
condition|(
name|io_req
operator|->
name|lengths
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
comment|/* 			 * Make sure that the user's buffer is accessible 			 * to that process. 			 */
if|if
condition|(
operator|!
name|useracc
argument_list|(
name|io_req
operator|->
name|user_bufs
index|[
name|i
index|]
argument_list|,
name|io_req
operator|->
name|lengths
index|[
name|i
index|]
argument_list|,
operator|(
name|io_req
operator|->
name|dirs
index|[
name|i
index|]
operator|==
name|CAM_DIR_IN
operator|)
condition|?
name|VM_PROT_WRITE
else|:
name|VM_PROT_READ
argument_list|)
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"%s: user address %p "
literal|"length %u is not accessible\n"
argument_list|,
name|__func__
argument_list|,
name|io_req
operator|->
name|user_bufs
index|[
name|i
index|]
argument_list|,
name|io_req
operator|->
name|lengths
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|tmp_buf
operator|=
name|malloc
argument_list|(
name|lengths
index|[
name|i
index|]
argument_list|,
name|M_SCSIPASS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|io_req
operator|->
name|kern_bufs
index|[
name|i
index|]
operator|=
name|tmp_buf
expr_stmt|;
operator|*
name|data_ptrs
index|[
name|i
index|]
operator|=
name|tmp_buf
expr_stmt|;
if|#
directive|if
literal|0
block|xpt_print(periph->path, "%s: malloced %p len %u, user " 				  "buffer %p, operation: %s\n", __func__, 				  tmp_buf, lengths[i], io_req->user_bufs[i], 				  (dirs[i] == CAM_DIR_IN) ? "read" : "write");
endif|#
directive|endif
comment|/* 			 * We only need to copy in if the user is writing. 			 */
if|if
condition|(
name|dirs
index|[
name|i
index|]
operator|!=
name|CAM_DIR_OUT
condition|)
continue|continue;
name|error
operator|=
name|copyin
argument_list|(
name|io_req
operator|->
name|user_bufs
index|[
name|i
index|]
argument_list|,
name|io_req
operator|->
name|kern_bufs
index|[
name|i
index|]
argument_list|,
name|lengths
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"%s: copy of user "
literal|"buffer from %p to %p failed with "
literal|"error %d\n"
argument_list|,
name|__func__
argument_list|,
name|io_req
operator|->
name|user_bufs
index|[
name|i
index|]
argument_list|,
name|io_req
operator|->
name|kern_bufs
index|[
name|i
index|]
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
block|}
break|break;
case|case
name|CAM_DATA_PADDR
case|:
comment|/* Pass down the pointer as-is */
break|break;
case|case
name|CAM_DATA_SG
case|:
block|{
name|size_t
name|sg_length
decl_stmt|,
name|size_to_go
decl_stmt|,
name|alloc_size
decl_stmt|;
name|uint32_t
name|num_segs_needed
decl_stmt|;
comment|/* 		 * Copy the user S/G list in, and then copy in the 		 * individual segments. 		 */
comment|/* 		 * We shouldn't see this, but check just in case. 		 */
if|if
condition|(
name|numbufs
operator|!=
literal|1
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"%s: cannot currently handle "
literal|"more than one S/G list per CCB\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
comment|/* 		 * We have to have at least one segment. 		 */
if|if
condition|(
name|num_segs
operator|==
literal|0
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"%s: CAM_DATA_SG flag set, "
literal|"but sglist_cnt=0!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
comment|/* 		 * Make sure the user specified the total length and didn't 		 * just leave it to us to decode the S/G list. 		 */
if|if
condition|(
name|lengths
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"%s: no dxfer_len specified, "
literal|"but CAM_DATA_SG flag is set!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
comment|/* 		 * We allocate buffers in io_zone_size increments for an 		 * S/G list.  This will generally be MAXPHYS. 		 */
if|if
condition|(
name|lengths
index|[
literal|0
index|]
operator|<=
name|softc
operator|->
name|io_zone_size
condition|)
name|num_segs_needed
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|num_segs_needed
operator|=
name|lengths
index|[
literal|0
index|]
operator|/
name|softc
operator|->
name|io_zone_size
expr_stmt|;
if|if
condition|(
operator|(
name|lengths
index|[
literal|0
index|]
operator|%
name|softc
operator|->
name|io_zone_size
operator|)
operator|!=
literal|0
condition|)
name|num_segs_needed
operator|++
expr_stmt|;
block|}
comment|/* Figure out the size of the S/G list */
name|sg_length
operator|=
name|num_segs
operator|*
sizeof|sizeof
argument_list|(
name|bus_dma_segment_t
argument_list|)
expr_stmt|;
name|io_req
operator|->
name|num_user_segs
operator|=
name|num_segs
expr_stmt|;
name|io_req
operator|->
name|num_kern_segs
operator|=
name|num_segs_needed
expr_stmt|;
comment|/* Save the user's S/G list pointer for later restoration */
name|io_req
operator|->
name|user_bufs
index|[
literal|0
index|]
operator|=
operator|*
name|data_ptrs
index|[
literal|0
index|]
expr_stmt|;
comment|/* 		 * If we have enough segments allocated by default to handle 		 * the length of the user's S/G list, 		 */
if|if
condition|(
name|num_segs
operator|>
name|PASS_MAX_SEGS
condition|)
block|{
name|io_req
operator|->
name|user_segptr
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|bus_dma_segment_t
argument_list|)
operator|*
name|num_segs
argument_list|,
name|M_SCSIPASS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|io_req
operator|->
name|flags
operator||=
name|PASS_IO_USER_SEG_MALLOC
expr_stmt|;
block|}
else|else
name|io_req
operator|->
name|user_segptr
operator|=
name|io_req
operator|->
name|user_segs
expr_stmt|;
if|if
condition|(
operator|!
name|useracc
argument_list|(
operator|*
name|data_ptrs
index|[
literal|0
index|]
argument_list|,
name|sg_length
argument_list|,
name|VM_PROT_READ
argument_list|)
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"%s: unable to access user "
literal|"S/G list at %p\n"
argument_list|,
name|__func__
argument_list|,
operator|*
name|data_ptrs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|error
operator|=
name|copyin
argument_list|(
operator|*
name|data_ptrs
index|[
literal|0
index|]
argument_list|,
name|io_req
operator|->
name|user_segptr
argument_list|,
name|sg_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"%s: copy of user S/G list "
literal|"from %p to %p failed with error %d\n"
argument_list|,
name|__func__
argument_list|,
operator|*
name|data_ptrs
index|[
literal|0
index|]
argument_list|,
name|io_req
operator|->
name|user_segptr
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
name|num_segs_needed
operator|>
name|PASS_MAX_SEGS
condition|)
block|{
name|io_req
operator|->
name|kern_segptr
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|bus_dma_segment_t
argument_list|)
operator|*
name|num_segs_needed
argument_list|,
name|M_SCSIPASS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|io_req
operator|->
name|flags
operator||=
name|PASS_IO_KERN_SEG_MALLOC
expr_stmt|;
block|}
else|else
block|{
name|io_req
operator|->
name|kern_segptr
operator|=
name|io_req
operator|->
name|kern_segs
expr_stmt|;
block|}
comment|/* 		 * Allocate the kernel S/G list. 		 */
for|for
control|(
name|size_to_go
operator|=
name|lengths
index|[
literal|0
index|]
operator|,
name|i
operator|=
literal|0
init|;
name|size_to_go
operator|>
literal|0
operator|&&
name|i
operator|<
name|num_segs_needed
condition|;
name|i
operator|++
operator|,
name|size_to_go
operator|-=
name|alloc_size
control|)
block|{
name|uint8_t
modifier|*
name|kern_ptr
decl_stmt|;
name|alloc_size
operator|=
name|min
argument_list|(
name|size_to_go
argument_list|,
name|softc
operator|->
name|io_zone_size
argument_list|)
expr_stmt|;
name|kern_ptr
operator|=
name|uma_zalloc
argument_list|(
name|softc
operator|->
name|pass_io_zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|io_req
operator|->
name|kern_segptr
index|[
name|i
index|]
operator|.
name|ds_addr
operator|=
operator|(
name|bus_addr_t
operator|)
operator|(
name|uintptr_t
operator|)
name|kern_ptr
expr_stmt|;
name|io_req
operator|->
name|kern_segptr
index|[
name|i
index|]
operator|.
name|ds_len
operator|=
name|alloc_size
expr_stmt|;
block|}
if|if
condition|(
name|size_to_go
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: size_to_go = %zu, software error!\n"
argument_list|,
name|__func__
argument_list|,
name|size_to_go
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
operator|*
name|data_ptrs
index|[
literal|0
index|]
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|io_req
operator|->
name|kern_segptr
expr_stmt|;
operator|*
name|seg_cnt_ptr
operator|=
name|io_req
operator|->
name|num_kern_segs
expr_stmt|;
comment|/* 		 * We only need to copy data here if the user is writing. 		 */
if|if
condition|(
name|dirs
index|[
literal|0
index|]
operator|==
name|CAM_DIR_OUT
condition|)
name|error
operator|=
name|passcopysglist
argument_list|(
name|periph
argument_list|,
name|io_req
argument_list|,
name|dirs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CAM_DATA_SG_PADDR
case|:
block|{
name|size_t
name|sg_length
decl_stmt|;
comment|/* 		 * We shouldn't see this, but check just in case. 		 */
if|if
condition|(
name|numbufs
operator|!=
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"%s: cannot currently handle more than one "
literal|"S/G list per CCB\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
comment|/* 		 * We have to have at least one segment. 		 */
if|if
condition|(
name|num_segs
operator|==
literal|0
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"%s: CAM_DATA_SG_PADDR flag "
literal|"set, but sglist_cnt=0!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
comment|/* 		 * Make sure the user specified the total length and didn't 		 * just leave it to us to decode the S/G list. 		 */
if|if
condition|(
name|lengths
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"%s: no dxfer_len specified, "
literal|"but CAM_DATA_SG flag is set!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
comment|/* Figure out the size of the S/G list */
name|sg_length
operator|=
name|num_segs
operator|*
sizeof|sizeof
argument_list|(
name|bus_dma_segment_t
argument_list|)
expr_stmt|;
name|io_req
operator|->
name|num_user_segs
operator|=
name|num_segs
expr_stmt|;
name|io_req
operator|->
name|num_kern_segs
operator|=
name|io_req
operator|->
name|num_user_segs
expr_stmt|;
comment|/* Save the user's S/G list pointer for later restoration */
name|io_req
operator|->
name|user_bufs
index|[
literal|0
index|]
operator|=
operator|*
name|data_ptrs
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|num_segs
operator|>
name|PASS_MAX_SEGS
condition|)
block|{
name|io_req
operator|->
name|user_segptr
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|bus_dma_segment_t
argument_list|)
operator|*
name|num_segs
argument_list|,
name|M_SCSIPASS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|io_req
operator|->
name|flags
operator||=
name|PASS_IO_USER_SEG_MALLOC
expr_stmt|;
block|}
else|else
name|io_req
operator|->
name|user_segptr
operator|=
name|io_req
operator|->
name|user_segs
expr_stmt|;
name|io_req
operator|->
name|kern_segptr
operator|=
name|io_req
operator|->
name|user_segptr
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
operator|*
name|data_ptrs
index|[
literal|0
index|]
argument_list|,
name|io_req
operator|->
name|user_segptr
argument_list|,
name|sg_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"%s: copy of user S/G list "
literal|"from %p to %p failed with error %d\n"
argument_list|,
name|__func__
argument_list|,
operator|*
name|data_ptrs
index|[
literal|0
index|]
argument_list|,
name|io_req
operator|->
name|user_segptr
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
break|break;
block|}
default|default:
case|case
name|CAM_DATA_BIO
case|:
comment|/* 		 * A user shouldn't be attaching a bio to the CCB.  It 		 * isn't a user-accessible structure. 		 */
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|bailout
label|:
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|passiocleanup
argument_list|(
name|softc
argument_list|,
name|io_req
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|passmemdone
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|pass_io_req
modifier|*
name|io_req
parameter_list|)
block|{
name|struct
name|pass_softc
modifier|*
name|softc
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|i
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|pass_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|ccb
operator|=
operator|&
name|io_req
operator|->
name|ccb
expr_stmt|;
switch|switch
condition|(
name|io_req
operator|->
name|data_flags
condition|)
block|{
case|case
name|CAM_DATA_VADDR
case|:
comment|/* 		 * Copy back to the user buffer if this was a read. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|io_req
operator|->
name|num_bufs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|io_req
operator|->
name|dirs
index|[
name|i
index|]
operator|!=
name|CAM_DIR_IN
condition|)
continue|continue;
name|error
operator|=
name|copyout
argument_list|(
name|io_req
operator|->
name|kern_bufs
index|[
name|i
index|]
argument_list|,
name|io_req
operator|->
name|user_bufs
index|[
name|i
index|]
argument_list|,
name|io_req
operator|->
name|lengths
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"Unable to copy %u "
literal|"bytes from %p to user address %p\n"
argument_list|,
name|io_req
operator|->
name|lengths
index|[
name|i
index|]
argument_list|,
name|io_req
operator|->
name|kern_bufs
index|[
name|i
index|]
argument_list|,
name|io_req
operator|->
name|user_bufs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
block|}
break|break;
case|case
name|CAM_DATA_PADDR
case|:
comment|/* Do nothing.  The pointer is a physical address already */
break|break;
case|case
name|CAM_DATA_SG
case|:
comment|/* 		 * Copy back to the user buffer if this was a read. 		 * Restore the user's S/G list buffer pointer. 		 */
if|if
condition|(
name|io_req
operator|->
name|dirs
index|[
literal|0
index|]
operator|==
name|CAM_DIR_IN
condition|)
name|error
operator|=
name|passcopysglist
argument_list|(
name|periph
argument_list|,
name|io_req
argument_list|,
name|io_req
operator|->
name|dirs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_DATA_SG_PADDR
case|:
comment|/* 		 * Restore the user's S/G list buffer pointer.  No need to 		 * copy. 		 */
break|break;
default|default:
case|case
name|CAM_DATA_BIO
case|:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|bailout
label|:
comment|/* 	 * Reset the user's pointers to their original values and free 	 * allocated memory. 	 */
name|passiocleanup
argument_list|(
name|softc
argument_list|,
name|io_req
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|passioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|passdoioctl
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|addr
argument_list|,
name|flag
argument_list|,
name|td
argument_list|)
operator|)
operator|==
name|ENOTTY
condition|)
block|{
name|error
operator|=
name|cam_compat_ioctl
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|addr
argument_list|,
name|flag
argument_list|,
name|td
argument_list|,
name|passdoioctl
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|passdoioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|pass_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint32_t
name|priority
decl_stmt|;
name|periph
operator|=
operator|(
expr|struct
name|cam_periph
operator|*
operator|)
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|pass_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|CAMIOCOMMAND
case|:
block|{
name|union
name|ccb
modifier|*
name|inccb
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|ccb_malloced
decl_stmt|;
name|inccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|addr
expr_stmt|;
comment|/* 		 * Some CCB types, like scan bus and scan lun can only go 		 * through the transport layer device. 		 */
if|if
condition|(
name|inccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|&
name|XPT_FC_XPT_ONLY
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"CCB function code %#x is "
literal|"restricted to the XPT device\n"
argument_list|,
name|inccb
operator|->
name|ccb_h
operator|.
name|func_code
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
comment|/* Compatibility for RL/priority-unaware code. */
name|priority
operator|=
name|inccb
operator|->
name|ccb_h
operator|.
name|pinfo
operator|.
name|priority
expr_stmt|;
if|if
condition|(
name|priority
operator|<=
name|CAM_PRIORITY_OOB
condition|)
name|priority
operator|+=
name|CAM_PRIORITY_OOB
operator|+
literal|1
expr_stmt|;
comment|/* 		 * Non-immediate CCBs need a CCB from the per-device pool 		 * of CCBs, which is scheduled by the transport layer. 		 * Immediate CCBs and user-supplied CCBs should just be 		 * malloced. 		 */
if|if
condition|(
operator|(
name|inccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|&
name|XPT_FC_QUEUED
operator|)
operator|&&
operator|(
operator|(
name|inccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|&
name|XPT_FC_USER_CCB
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
name|priority
argument_list|)
expr_stmt|;
name|ccb_malloced
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ccb
operator|=
name|xpt_alloc_ccb_nowait
argument_list|()
expr_stmt|;
if|if
condition|(
name|ccb
operator|!=
name|NULL
condition|)
name|xpt_setup_ccb
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
name|priority
argument_list|)
expr_stmt|;
name|ccb_malloced
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"unable to allocate CCB\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|passsendccb
argument_list|(
name|periph
argument_list|,
name|ccb
argument_list|,
name|inccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb_malloced
condition|)
name|xpt_free_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
else|else
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CAMIOQUEUE
case|:
block|{
name|struct
name|pass_io_req
modifier|*
name|io_req
decl_stmt|;
name|union
name|ccb
modifier|*
modifier|*
name|user_ccb
decl_stmt|,
modifier|*
name|ccb
decl_stmt|;
name|xpt_opcode
name|fc
decl_stmt|;
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|PASS_FLAG_ZONE_VALID
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|passcreatezone
argument_list|(
name|periph
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|bailout
goto|;
block|}
comment|/* 		 * We're going to do a blocking allocation for this I/O 		 * request, so we have to drop the lock. 		 */
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|io_req
operator|=
name|uma_zalloc
argument_list|(
name|softc
operator|->
name|pass_zone
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ccb
operator|=
operator|&
name|io_req
operator|->
name|ccb
expr_stmt|;
name|user_ccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|*
operator|)
name|addr
expr_stmt|;
comment|/* 		 * Unlike the CAMIOCOMMAND ioctl above, we only have a 		 * pointer to the user's CCB, so we have to copy the whole 		 * thing in to a buffer we have allocated (above) instead 		 * of allowing the ioctl code to malloc a buffer and copy 		 * it in. 		 * 		 * This is an advantage for this asynchronous interface, 		 * since we don't want the memory to get freed while the 		 * CCB is outstanding. 		 */
if|#
directive|if
literal|0
block|xpt_print(periph->path, "Copying user CCB %p to " 			  "kernel address %p\n", *user_ccb, ccb);
endif|#
directive|endif
name|error
operator|=
name|copyin
argument_list|(
operator|*
name|user_ccb
argument_list|,
name|ccb
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ccb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"Copy of user CCB %p to "
literal|"kernel address %p failed with error %d\n"
argument_list|,
operator|*
name|user_ccb
argument_list|,
name|ccb
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|softc
operator|->
name|pass_zone
argument_list|,
name|io_req
argument_list|)
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_POINTER
condition|)
block|{
if|if
condition|(
name|ccb
operator|->
name|csio
operator|.
name|cdb_len
operator|>
name|IOCDBLEN
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|copyin
argument_list|(
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_ptr
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|cdb_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&=
operator|~
name|CAM_CDB_POINTER
expr_stmt|;
block|}
comment|/* 		 * Some CCB types, like scan bus and scan lun can only go 		 * through the transport layer device. 		 */
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|&
name|XPT_FC_XPT_ONLY
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"CCB function code %#x is "
literal|"restricted to the XPT device\n"
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|softc
operator|->
name|pass_zone
argument_list|,
name|io_req
argument_list|)
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
comment|/* 		 * Save the user's CCB pointer as well as his linked list 		 * pointers and peripheral private area so that we can 		 * restore these later. 		 */
name|io_req
operator|->
name|user_ccb_ptr
operator|=
operator|*
name|user_ccb
expr_stmt|;
name|io_req
operator|->
name|user_periph_links
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|periph_links
expr_stmt|;
name|io_req
operator|->
name|user_periph_priv
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|periph_priv
expr_stmt|;
comment|/* 		 * Now that we've saved the user's values, we can set our 		 * own peripheral private entry. 		 */
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_ioreq
operator|=
name|io_req
expr_stmt|;
comment|/* Compatibility for RL/priority-unaware code. */
name|priority
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|pinfo
operator|.
name|priority
expr_stmt|;
if|if
condition|(
name|priority
operator|<=
name|CAM_PRIORITY_OOB
condition|)
name|priority
operator|+=
name|CAM_PRIORITY_OOB
operator|+
literal|1
expr_stmt|;
comment|/* 		 * Setup fields in the CCB like the path and the priority. 		 * The path in particular cannot be done in userland, since 		 * it is a pointer to a kernel data structure. 		 */
name|xpt_setup_ccb_flags
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
name|priority
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
argument_list|)
expr_stmt|;
comment|/* 		 * Setup our done routine.  There is no way for the user to 		 * have a valid pointer here. 		 */
name|ccb
operator|->
name|ccb_h
operator|.
name|cbfcnp
operator|=
name|passdone
expr_stmt|;
name|fc
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
expr_stmt|;
comment|/* 		 * If this function code has memory that can be mapped in 		 * or out, we need to call passmemsetup(). 		 */
if|if
condition|(
operator|(
name|fc
operator|==
name|XPT_SCSI_IO
operator|)
operator|||
operator|(
name|fc
operator|==
name|XPT_ATA_IO
operator|)
operator|||
operator|(
name|fc
operator|==
name|XPT_SMP_IO
operator|)
operator|||
operator|(
name|fc
operator|==
name|XPT_DEV_MATCH
operator|)
operator|||
operator|(
name|fc
operator|==
name|XPT_DEV_ADVINFO
operator|)
condition|)
block|{
name|error
operator|=
name|passmemsetup
argument_list|(
name|periph
argument_list|,
name|io_req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|uma_zfree
argument_list|(
name|softc
operator|->
name|pass_zone
argument_list|,
name|io_req
argument_list|)
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
name|io_req
operator|->
name|mapinfo
operator|.
name|num_bufs_used
operator|=
literal|0
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
comment|/* 		 * Everything goes on the incoming queue initially. 		 */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|softc
operator|->
name|incoming_queue
argument_list|,
name|io_req
argument_list|,
name|links
argument_list|)
expr_stmt|;
comment|/* 		 * If the CCB is queued, and is not a user CCB, then 		 * we need to allocate a slot for it.  Call xpt_schedule() 		 * so that our start routine will get called when a CCB is 		 * available. 		 */
if|if
condition|(
operator|(
name|fc
operator|&
name|XPT_FC_QUEUED
operator|)
operator|&&
operator|(
operator|(
name|fc
operator|&
name|XPT_FC_USER_CCB
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|xpt_schedule
argument_list|(
name|periph
argument_list|,
name|priority
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * At this point, the CCB in question is either an 		 * immediate CCB (like XPT_DEV_ADVINFO) or it is a user CCB 		 * and therefore should be malloced, not allocated via a slot. 		 * Remove the CCB from the incoming queue and add it to the 		 * active queue. 		 */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|softc
operator|->
name|incoming_queue
argument_list|,
name|io_req
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|softc
operator|->
name|active_queue
argument_list|,
name|io_req
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|xpt_action
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
comment|/* 		 * If this is not a queued CCB (i.e. it is an immediate CCB), 		 * then it is already done.  We need to put it on the done 		 * queue for the user to fetch. 		 */
if|if
condition|(
operator|(
name|fc
operator|&
name|XPT_FC_QUEUED
operator|)
operator|==
literal|0
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|softc
operator|->
name|active_queue
argument_list|,
name|io_req
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|softc
operator|->
name|done_queue
argument_list|,
name|io_req
argument_list|,
name|links
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|CAMIOGET
case|:
block|{
name|union
name|ccb
modifier|*
modifier|*
name|user_ccb
decl_stmt|;
name|struct
name|pass_io_req
modifier|*
name|io_req
decl_stmt|;
name|int
name|old_error
decl_stmt|;
name|user_ccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|*
operator|)
name|addr
expr_stmt|;
name|old_error
operator|=
literal|0
expr_stmt|;
name|io_req
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|softc
operator|->
name|done_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|io_req
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
comment|/* 		 * Remove the I/O from the done queue. 		 */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|softc
operator|->
name|done_queue
argument_list|,
name|io_req
argument_list|,
name|links
argument_list|)
expr_stmt|;
comment|/* 		 * We have to drop the lock during the copyout because the 		 * copyout can result in VM faults that require sleeping. 		 */
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
comment|/* 		 * Do any needed copies (e.g. for reads) and revert the 		 * pointers in the CCB back to the user's pointers. 		 */
name|error
operator|=
name|passmemdone
argument_list|(
name|periph
argument_list|,
name|io_req
argument_list|)
expr_stmt|;
name|old_error
operator|=
name|error
expr_stmt|;
name|io_req
operator|->
name|ccb
operator|.
name|ccb_h
operator|.
name|periph_links
operator|=
name|io_req
operator|->
name|user_periph_links
expr_stmt|;
name|io_req
operator|->
name|ccb
operator|.
name|ccb_h
operator|.
name|periph_priv
operator|=
name|io_req
operator|->
name|user_periph_priv
expr_stmt|;
if|#
directive|if
literal|0
block|xpt_print(periph->path, "Copying to user CCB %p from " 			  "kernel address %p\n", *user_ccb,&io_req->ccb);
endif|#
directive|endif
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|io_req
operator|->
name|ccb
argument_list|,
operator|*
name|user_ccb
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|ccb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"Copy to user CCB %p from "
literal|"kernel address %p failed with error %d\n"
argument_list|,
operator|*
name|user_ccb
argument_list|,
operator|&
name|io_req
operator|->
name|ccb
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Prefer the first error we got back, and make sure we 		 * don't overwrite bad status with good. 		 */
if|if
condition|(
name|old_error
operator|!=
literal|0
condition|)
name|error
operator|=
name|old_error
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
comment|/* 		 * At this point, if there was an error, we could potentially 		 * re-queue the I/O and try again.  But why?  The error 		 * would almost certainly happen again.  We might as well 		 * not leak memory. 		 */
name|uma_zfree
argument_list|(
name|softc
operator|->
name|pass_zone
argument_list|,
name|io_req
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|error
operator|=
name|cam_periph_ioctl
argument_list|(
name|periph
argument_list|,
name|cmd
argument_list|,
name|addr
argument_list|,
name|passerror
argument_list|)
expr_stmt|;
break|break;
block|}
name|bailout
label|:
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|passpoll
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|poll_events
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|pass_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|revents
decl_stmt|;
name|periph
operator|=
operator|(
expr|struct
name|cam_periph
operator|*
operator|)
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|pass_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|revents
operator|=
name|poll_events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|poll_events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|softc
operator|->
name|done_queue
argument_list|)
condition|)
block|{
name|revents
operator||=
name|poll_events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
block|}
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
if|if
condition|(
name|revents
operator|==
literal|0
condition|)
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|softc
operator|->
name|read_select
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|revents
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|passkqfilter
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|pass_softc
modifier|*
name|softc
decl_stmt|;
name|periph
operator|=
operator|(
expr|struct
name|cam_periph
operator|*
operator|)
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|pass_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|kn
operator|->
name|kn_hook
operator|=
operator|(
name|caddr_t
operator|)
name|periph
expr_stmt|;
name|kn
operator|->
name|kn_fop
operator|=
operator|&
name|passread_filtops
expr_stmt|;
name|knlist_add
argument_list|(
operator|&
name|softc
operator|->
name|read_select
operator|.
name|si_note
argument_list|,
name|kn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|passreadfiltdetach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|pass_softc
modifier|*
name|softc
decl_stmt|;
name|periph
operator|=
operator|(
expr|struct
name|cam_periph
operator|*
operator|)
name|kn
operator|->
name|kn_hook
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|pass_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|knlist_remove
argument_list|(
operator|&
name|softc
operator|->
name|read_select
operator|.
name|si_note
argument_list|,
name|kn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|passreadfilt
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|pass_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|periph
operator|=
operator|(
expr|struct
name|cam_periph
operator|*
operator|)
name|kn
operator|->
name|kn_hook
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|pass_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|cam_periph_assert
argument_list|(
name|periph
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|softc
operator|->
name|done_queue
argument_list|)
condition|)
name|retval
operator|=
literal|0
expr_stmt|;
else|else
name|retval
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generally, "ccb" should be the CCB supplied by the kernel.  "inccb"  * should be the CCB that is copied in from the user.  */
end_comment

begin_function
specifier|static
name|int
name|passsendccb
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|union
name|ccb
modifier|*
name|inccb
parameter_list|)
block|{
name|struct
name|pass_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|cam_periph_map_info
name|mapinfo
decl_stmt|;
name|uint8_t
modifier|*
name|cmd
decl_stmt|;
name|xpt_opcode
name|fc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|pass_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
comment|/* 	 * There are some fields in the CCB header that need to be 	 * preserved, the rest we get from the user. 	 */
name|xpt_merge_ccb
argument_list|(
name|ccb
argument_list|,
name|inccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_POINTER
condition|)
block|{
name|cmd
operator|=
name|__builtin_alloca
argument_list|(
name|ccb
operator|->
name|csio
operator|.
name|cdb_len
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_ptr
argument_list|,
name|cmd
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|cdb_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_ptr
operator|=
name|cmd
expr_stmt|;
block|}
comment|/* 	 */
name|ccb
operator|->
name|ccb_h
operator|.
name|cbfcnp
operator|=
name|passdone
expr_stmt|;
comment|/* 	 * Let cam_periph_mapmem do a sanity check on the data pointer format. 	 * Even if no data transfer is needed, it's a cheap check and it 	 * simplifies the code. 	 */
name|fc
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
expr_stmt|;
if|if
condition|(
operator|(
name|fc
operator|==
name|XPT_SCSI_IO
operator|)
operator|||
operator|(
name|fc
operator|==
name|XPT_ATA_IO
operator|)
operator|||
operator|(
name|fc
operator|==
name|XPT_SMP_IO
operator|)
operator|||
operator|(
name|fc
operator|==
name|XPT_DEV_MATCH
operator|)
operator|||
operator|(
name|fc
operator|==
name|XPT_DEV_ADVINFO
operator|)
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|mapinfo
argument_list|,
sizeof|sizeof
argument_list|(
name|mapinfo
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * cam_periph_mapmem calls into proc and vm functions that can 		 * sleep as well as trigger I/O, so we can't hold the lock. 		 * Dropping it here is reasonably safe. 		 */
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|error
operator|=
name|cam_periph_mapmem
argument_list|(
name|ccb
argument_list|,
operator|&
name|mapinfo
argument_list|,
name|softc
operator|->
name|maxio
argument_list|)
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
comment|/* 		 * cam_periph_mapmem returned an error, we can't continue. 		 * Return the error to the user. 		 */
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
else|else
comment|/* Ensure that the unmap call later on is a no-op. */
name|mapinfo
operator|.
name|num_bufs_used
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If the user wants us to perform any error recovery, then honor 	 * that request.  Otherwise, it's up to the user to perform any 	 * error recovery. 	 */
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|passerror
argument_list|,
comment|/* cam_flags */
name|CAM_RETRY_SELTO
argument_list|,
comment|/* sense_flags */
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_PASS_ERR_RECOVER
operator|)
condition|?
name|SF_RETRY_UA
else|:
name|SF_NO_RECOVERY
operator|)
operator||
name|SF_NO_PRINT
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
name|cam_periph_unmapmem
argument_list|(
name|ccb
argument_list|,
operator|&
name|mapinfo
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|cbfcnp
operator|=
name|NULL
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|periph_priv
operator|=
name|inccb
operator|->
name|ccb_h
operator|.
name|periph_priv
expr_stmt|;
name|bcopy
argument_list|(
name|ccb
argument_list|,
name|inccb
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|ccb
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|passerror
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|u_int32_t
name|cam_flags
parameter_list|,
name|u_int32_t
name|sense_flags
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|pass_softc
modifier|*
name|softc
decl_stmt|;
name|periph
operator|=
name|xpt_path_periph
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|pass_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
return|return
operator|(
name|cam_periph_error
argument_list|(
name|ccb
argument_list|,
name|cam_flags
argument_list|,
name|sense_flags
argument_list|,
operator|&
name|softc
operator|->
name|saved_ccb
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

