begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2000 Matthew Jacob  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/devicestat.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_extend.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_ses.h>
end_include

begin_include
include|#
directive|include
file|<opt_ses.h>
end_include

begin_comment
comment|/*  * Platform Independent Driver Internal Definitions for SES devices.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|SES_NONE
block|,
name|SES_SES_SCSI2
block|,
name|SES_SES
block|,
name|SES_SES_PASSTHROUGH
block|,
name|SES_SEN
block|,
name|SES_SAFT
block|}
name|enctyp
typedef|;
end_typedef

begin_struct_decl
struct_decl|struct
name|ses_softc
struct_decl|;
end_struct_decl

begin_typedef
typedef|typedef
name|struct
name|ses_softc
name|ses_softc_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
function_decl|(
modifier|*
name|softc_init
function_decl|)
parameter_list|(
name|ses_softc_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|init_enc
function_decl|)
parameter_list|(
name|ses_softc_t
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|get_encstat
function_decl|)
parameter_list|(
name|ses_softc_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|set_encstat
function_decl|)
parameter_list|(
name|ses_softc_t
modifier|*
parameter_list|,
name|ses_encstat
parameter_list|,
name|int
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|get_objstat
function_decl|)
parameter_list|(
name|ses_softc_t
modifier|*
parameter_list|,
name|ses_objstat
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|set_objstat
function_decl|)
parameter_list|(
name|ses_softc_t
modifier|*
parameter_list|,
name|ses_objstat
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
block|}
name|encvec
typedef|;
end_typedef

begin_define
define|#
directive|define
name|ENCI_SVALID
value|0x80
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|uint32_t
name|enctype
range|:
literal|8
decl_stmt|,
comment|/* enclosure type */
name|subenclosure
range|:
literal|8
decl_stmt|,
comment|/* subenclosure id */
name|svalid
range|:
literal|1
decl_stmt|,
comment|/* enclosure information valid */
name|priv
range|:
literal|15
decl_stmt|;
comment|/* private data, per object */
name|uint8_t
name|encstat
index|[
literal|4
index|]
decl_stmt|;
comment|/* state&& stats */
block|}
name|encobj
typedef|;
end_typedef

begin_define
define|#
directive|define
name|SEN_ID
value|"UNISYS           SUN_SEN"
end_define

begin_define
define|#
directive|define
name|SEN_ID_LEN
value|24
end_define

begin_function_decl
specifier|static
name|enctyp
name|ses_type
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Forward reference to Enclosure Functions */
end_comment

begin_function_decl
specifier|static
name|int
name|ses_softc_init
parameter_list|(
name|ses_softc_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ses_init_enc
parameter_list|(
name|ses_softc_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ses_get_encstat
parameter_list|(
name|ses_softc_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ses_set_encstat
parameter_list|(
name|ses_softc_t
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ses_get_objstat
parameter_list|(
name|ses_softc_t
modifier|*
parameter_list|,
name|ses_objstat
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ses_set_objstat
parameter_list|(
name|ses_softc_t
modifier|*
parameter_list|,
name|ses_objstat
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|safte_softc_init
parameter_list|(
name|ses_softc_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|safte_init_enc
parameter_list|(
name|ses_softc_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|safte_get_encstat
parameter_list|(
name|ses_softc_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|safte_set_encstat
parameter_list|(
name|ses_softc_t
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|safte_get_objstat
parameter_list|(
name|ses_softc_t
modifier|*
parameter_list|,
name|ses_objstat
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|safte_set_objstat
parameter_list|(
name|ses_softc_t
modifier|*
parameter_list|,
name|ses_objstat
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Platform implementation defines/functions for SES internal kernel stuff  */
end_comment

begin_define
define|#
directive|define
name|STRNCMP
value|strncmp
end_define

begin_define
define|#
directive|define
name|PRINTF
value|printf
end_define

begin_define
define|#
directive|define
name|SES_LOG
value|ses_log
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|SES_DLOG
value|ses_log
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SES_DLOG
value|if (0) ses_log
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SES_VLOG
value|if (bootverbose) ses_log
end_define

begin_define
define|#
directive|define
name|SES_MALLOC
parameter_list|(
name|amt
parameter_list|)
value|malloc(amt, M_DEVBUF, M_NOWAIT)
end_define

begin_define
define|#
directive|define
name|SES_FREE
parameter_list|(
name|ptr
parameter_list|,
name|amt
parameter_list|)
value|free(ptr, M_DEVBUF)
end_define

begin_define
define|#
directive|define
name|MEMZERO
value|bzero
end_define

begin_define
define|#
directive|define
name|MEMCPY
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|,
name|amt
parameter_list|)
value|bcopy(src, dest, amt)
end_define

begin_function_decl
specifier|static
name|int
name|ses_runcmd
parameter_list|(
name|struct
name|ses_softc
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ses_log
parameter_list|(
name|struct
name|ses_softc
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Gerenal FreeBSD kernel stuff.  */
end_comment

begin_define
define|#
directive|define
name|ccb_state
value|ppriv_field0
end_define

begin_define
define|#
directive|define
name|ccb_bp
value|ppriv_ptr1
end_define

begin_struct
struct|struct
name|ses_softc
block|{
name|enctyp
name|ses_type
decl_stmt|;
comment|/* type of enclosure */
name|encvec
name|ses_vec
decl_stmt|;
comment|/* vector to handlers */
name|void
modifier|*
name|ses_private
decl_stmt|;
comment|/* per-type private data */
name|encobj
modifier|*
name|ses_objmap
decl_stmt|;
comment|/* objects */
name|u_int32_t
name|ses_nobjects
decl_stmt|;
comment|/* number of objects */
name|ses_encstat
name|ses_encstat
decl_stmt|;
comment|/* overall status */
name|u_int8_t
name|ses_flags
decl_stmt|;
name|union
name|ccb
name|ses_saved_ccb
decl_stmt|;
name|dev_t
name|ses_dev
decl_stmt|;
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|SES_FLAG_INVALID
value|0x01
end_define

begin_define
define|#
directive|define
name|SES_FLAG_OPEN
value|0x02
end_define

begin_define
define|#
directive|define
name|SES_FLAG_INITIALIZED
value|0x04
end_define

begin_define
define|#
directive|define
name|SESUNIT
parameter_list|(
name|x
parameter_list|)
value|(minor((x)))
end_define

begin_define
define|#
directive|define
name|SES_CDEV_MAJOR
value|110
end_define

begin_decl_stmt
specifier|static
name|d_open_t
name|sesopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|sesclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|sesioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_init_t
name|sesinit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_ctor_t
name|sesregister
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_oninv_t
name|sesoninvalidate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_dtor_t
name|sescleanup
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_start_t
name|sesstart
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|sesasync
parameter_list|(
name|void
modifier|*
parameter_list|,
name|u_int32_t
parameter_list|,
name|struct
name|cam_path
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sesdone
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|seserror
parameter_list|(
name|union
name|ccb
modifier|*
parameter_list|,
name|u_int32_t
parameter_list|,
name|u_int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|periph_driver
name|sesdriver
init|=
block|{
name|sesinit
block|,
literal|"ses"
block|,
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|sesdriver
operator|.
name|units
argument_list|)
block|,
comment|/* generation */
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|PERIPHDRIVER_DECLARE
argument_list|(
name|ses
argument_list|,
name|sesdriver
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|ses_cdevsw
init|=
block|{
comment|/* open */
name|sesopen
block|,
comment|/* close */
name|sesclose
block|,
comment|/* read */
name|noread
block|,
comment|/* write */
name|nowrite
block|,
comment|/* ioctl */
name|sesioctl
block|,
comment|/* poll */
name|nopoll
block|,
comment|/* mmap */
name|nommap
block|,
comment|/* strategy */
name|nostrategy
block|,
comment|/* name */
literal|"ses"
block|,
comment|/* maj */
name|SES_CDEV_MAJOR
block|,
comment|/* dump */
name|nodump
block|,
comment|/* psize */
name|nopsize
block|,
comment|/* flags */
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|extend_array
modifier|*
name|sesperiphs
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|sesinit
parameter_list|(
name|void
parameter_list|)
block|{
name|cam_status
name|status
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
comment|/* 	 * Create our extend array for storing the devices we attach to. 	 */
name|sesperiphs
operator|=
name|cam_extend_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|sesperiphs
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ses: Failed to alloc extend array!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Install a global async callback.  This callback will 	 * receive async callbacks like "new device found". 	 */
name|status
operator|=
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
name|NULL
argument_list|,
name|CAM_XPT_PATH_ID
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|CAM_REQ_CMP
condition|)
block|{
name|struct
name|ccb_setasync
name|csa
decl_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|csa
operator|.
name|ccb_h
argument_list|,
name|path
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|csa
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SASYNC_CB
expr_stmt|;
name|csa
operator|.
name|event_enable
operator|=
name|AC_FOUND_DEVICE
expr_stmt|;
name|csa
operator|.
name|callback
operator|=
name|sesasync
expr_stmt|;
name|csa
operator|.
name|callback_arg
operator|=
name|NULL
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|csa
argument_list|)
expr_stmt|;
name|status
operator|=
name|csa
operator|.
name|ccb_h
operator|.
name|status
expr_stmt|;
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"ses: Failed to attach master async callback "
literal|"due to status 0x%x!\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sesoninvalidate
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|struct
name|ses_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ccb_setasync
name|csa
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|ses_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
comment|/* 	 * Unregister any async callbacks. 	 */
name|xpt_setup_ccb
argument_list|(
operator|&
name|csa
operator|.
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|csa
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SASYNC_CB
expr_stmt|;
name|csa
operator|.
name|event_enable
operator|=
literal|0
expr_stmt|;
name|csa
operator|.
name|callback
operator|=
name|sesasync
expr_stmt|;
name|csa
operator|.
name|callback_arg
operator|=
name|periph
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|csa
argument_list|)
expr_stmt|;
name|softc
operator|->
name|ses_flags
operator||=
name|SES_FLAG_INVALID
expr_stmt|;
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"lost device\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sescleanup
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|struct
name|ses_softc
modifier|*
name|softc
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|ses_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|destroy_dev
argument_list|(
name|softc
operator|->
name|ses_dev
argument_list|)
expr_stmt|;
name|cam_extend_release
argument_list|(
name|sesperiphs
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|)
expr_stmt|;
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"removing device entry\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|softc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sesasync
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|u_int32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|periph
operator|=
operator|(
expr|struct
name|cam_periph
operator|*
operator|)
name|callback_arg
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|AC_FOUND_DEVICE
case|:
block|{
name|cam_status
name|status
decl_stmt|;
name|struct
name|ccb_getdev
modifier|*
name|cgd
decl_stmt|;
name|int
name|inq_len
decl_stmt|;
name|cgd
operator|=
operator|(
expr|struct
name|ccb_getdev
operator|*
operator|)
name|arg
expr_stmt|;
name|inq_len
operator|=
name|cgd
operator|->
name|inq_data
operator|.
name|additional_length
operator|+
literal|4
expr_stmt|;
comment|/* 		 * PROBLEM: WE NEED TO LOOK AT BYTES 48-53 TO SEE IF THIS IS 		 * PROBLEM: IS A SAF-TE DEVICE. 		 */
switch|switch
condition|(
name|ses_type
argument_list|(
operator|&
name|cgd
operator|->
name|inq_data
argument_list|,
name|inq_len
argument_list|)
condition|)
block|{
case|case
name|SES_SES
case|:
case|case
name|SES_SES_SCSI2
case|:
case|case
name|SES_SES_PASSTHROUGH
case|:
case|case
name|SES_SEN
case|:
case|case
name|SES_SAFT
case|:
break|break;
default|default:
return|return;
block|}
name|status
operator|=
name|cam_periph_alloc
argument_list|(
name|sesregister
argument_list|,
name|sesoninvalidate
argument_list|,
name|sescleanup
argument_list|,
name|sesstart
argument_list|,
literal|"ses"
argument_list|,
name|CAM_PERIPH_BIO
argument_list|,
name|cgd
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|sesasync
argument_list|,
name|AC_FOUND_DEVICE
argument_list|,
name|cgd
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
operator|&&
name|status
operator|!=
name|CAM_REQ_INPROG
condition|)
block|{
name|printf
argument_list|(
literal|"sesasync: Unable to probe new device due to "
literal|"status 0x%x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
name|cam_periph_async
argument_list|(
name|periph
argument_list|,
name|code
argument_list|,
name|path
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|cam_status
name|sesregister
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ses_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ccb_setasync
name|csa
decl_stmt|;
name|struct
name|ccb_getdev
modifier|*
name|cgd
decl_stmt|;
name|char
modifier|*
name|tname
decl_stmt|;
name|cgd
operator|=
operator|(
expr|struct
name|ccb_getdev
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"sesregister: periph was NULL!!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
if|if
condition|(
name|cgd
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"sesregister: no getdev CCB, can't register device\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
name|softc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ses_softc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"sesregister: Unable to probe new device. "
literal|"Unable to allocate softc\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
name|bzero
argument_list|(
name|softc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ses_softc
argument_list|)
argument_list|)
expr_stmt|;
name|periph
operator|->
name|softc
operator|=
name|softc
expr_stmt|;
name|softc
operator|->
name|periph
operator|=
name|periph
expr_stmt|;
name|softc
operator|->
name|ses_type
operator|=
name|ses_type
argument_list|(
operator|&
name|cgd
operator|->
name|inq_data
argument_list|,
sizeof|sizeof
argument_list|(
name|cgd
operator|->
name|inq_data
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|softc
operator|->
name|ses_type
condition|)
block|{
case|case
name|SES_SES
case|:
case|case
name|SES_SES_SCSI2
case|:
case|case
name|SES_SES_PASSTHROUGH
case|:
name|softc
operator|->
name|ses_vec
operator|.
name|softc_init
operator|=
name|ses_softc_init
expr_stmt|;
name|softc
operator|->
name|ses_vec
operator|.
name|init_enc
operator|=
name|ses_init_enc
expr_stmt|;
name|softc
operator|->
name|ses_vec
operator|.
name|get_encstat
operator|=
name|ses_get_encstat
expr_stmt|;
name|softc
operator|->
name|ses_vec
operator|.
name|set_encstat
operator|=
name|ses_set_encstat
expr_stmt|;
name|softc
operator|->
name|ses_vec
operator|.
name|get_objstat
operator|=
name|ses_get_objstat
expr_stmt|;
name|softc
operator|->
name|ses_vec
operator|.
name|set_objstat
operator|=
name|ses_set_objstat
expr_stmt|;
break|break;
case|case
name|SES_SAFT
case|:
name|softc
operator|->
name|ses_vec
operator|.
name|softc_init
operator|=
name|safte_softc_init
expr_stmt|;
name|softc
operator|->
name|ses_vec
operator|.
name|init_enc
operator|=
name|safte_init_enc
expr_stmt|;
name|softc
operator|->
name|ses_vec
operator|.
name|get_encstat
operator|=
name|safte_get_encstat
expr_stmt|;
name|softc
operator|->
name|ses_vec
operator|.
name|set_encstat
operator|=
name|safte_set_encstat
expr_stmt|;
name|softc
operator|->
name|ses_vec
operator|.
name|get_objstat
operator|=
name|safte_get_objstat
expr_stmt|;
name|softc
operator|->
name|ses_vec
operator|.
name|set_objstat
operator|=
name|safte_set_objstat
expr_stmt|;
break|break;
case|case
name|SES_SEN
case|:
break|break;
case|case
name|SES_NONE
case|:
default|default:
name|free
argument_list|(
name|softc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
name|cam_extend_set
argument_list|(
name|sesperiphs
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|,
name|periph
argument_list|)
expr_stmt|;
name|softc
operator|->
name|ses_dev
operator|=
name|make_dev
argument_list|(
operator|&
name|ses_cdevsw
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0600
argument_list|,
literal|"%s%d"
argument_list|,
name|periph
operator|->
name|periph_name
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|)
expr_stmt|;
comment|/* 	 * Add an async callback so that we get 	 * notified if this device goes away. 	 */
name|xpt_setup_ccb
argument_list|(
operator|&
name|csa
operator|.
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|csa
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SASYNC_CB
expr_stmt|;
name|csa
operator|.
name|event_enable
operator|=
name|AC_LOST_DEVICE
expr_stmt|;
name|csa
operator|.
name|callback
operator|=
name|sesasync
expr_stmt|;
name|csa
operator|.
name|callback_arg
operator|=
name|periph
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|csa
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|softc
operator|->
name|ses_type
condition|)
block|{
default|default:
case|case
name|SES_NONE
case|:
name|tname
operator|=
literal|"No SES device"
expr_stmt|;
break|break;
case|case
name|SES_SES_SCSI2
case|:
name|tname
operator|=
literal|"SCSI-2 SES Device"
expr_stmt|;
break|break;
case|case
name|SES_SES
case|:
name|tname
operator|=
literal|"SCSI-3 SES Device"
expr_stmt|;
break|break;
case|case
name|SES_SES_PASSTHROUGH
case|:
name|tname
operator|=
literal|"SES Passthrough Device"
expr_stmt|;
break|break;
case|case
name|SES_SEN
case|:
name|tname
operator|=
literal|"UNISYS SEN Device (NOT HANDLED YET)"
expr_stmt|;
break|break;
case|case
name|SES_SAFT
case|:
name|tname
operator|=
literal|"SAF-TE Compliant Device"
expr_stmt|;
break|break;
block|}
name|xpt_announce_periph
argument_list|(
name|periph
argument_list|,
name|tname
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sesopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|ses_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|s
decl_stmt|;
name|s
operator|=
name|splsoftcam
argument_list|()
expr_stmt|;
name|periph
operator|=
name|cam_extend_get
argument_list|(
name|sesperiphs
argument_list|,
name|SESUNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|cam_periph_lock
argument_list|(
name|periph
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|cam_periph_acquire
argument_list|(
name|periph
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|softc
operator|=
operator|(
expr|struct
name|ses_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|ses_flags
operator|&
name|SES_FLAG_INVALID
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|softc
operator|->
name|ses_flags
operator|&
name|SES_FLAG_OPEN
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|softc
operator|->
name|ses_vec
operator|.
name|softc_init
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|softc
operator|->
name|ses_flags
operator||=
name|SES_FLAG_OPEN
expr_stmt|;
if|if
condition|(
operator|(
name|softc
operator|->
name|ses_flags
operator|&
name|SES_FLAG_INITIALIZED
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
call|(
modifier|*
name|softc
operator|->
name|ses_vec
operator|.
name|softc_init
call|)
argument_list|(
name|softc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|softc
operator|->
name|ses_flags
operator|&=
operator|~
name|SES_FLAG_OPEN
expr_stmt|;
else|else
name|softc
operator|->
name|ses_flags
operator||=
name|SES_FLAG_INITIALIZED
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|error
condition|)
block|{
name|cam_periph_release
argument_list|(
name|periph
argument_list|)
expr_stmt|;
block|}
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sesclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|ses_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|unit
operator|=
name|SESUNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|periph
operator|=
name|cam_extend_get
argument_list|(
name|sesperiphs
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|softc
operator|=
operator|(
expr|struct
name|ses_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|cam_periph_lock
argument_list|(
name|periph
argument_list|,
name|PRIBIO
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|softc
operator|->
name|ses_flags
operator|&=
operator|~
name|SES_FLAG_OPEN
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|cam_periph_release
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sesstart
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|p
parameter_list|,
name|union
name|ccb
modifier|*
name|sccb
parameter_list|)
block|{
name|int
name|s
init|=
name|splbio
argument_list|()
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|immediate_priority
operator|<=
name|p
operator|->
name|pinfo
operator|.
name|priority
condition|)
block|{
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|p
operator|->
name|ccb_list
argument_list|,
operator|&
name|sccb
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|sle
argument_list|)
expr_stmt|;
name|p
operator|->
name|immediate_priority
operator|=
name|CAM_PRIORITY_NONE
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|p
operator|->
name|ccb_list
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sesdone
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|dccb
parameter_list|)
block|{
name|wakeup
argument_list|(
operator|&
name|dccb
operator|->
name|ccb_h
operator|.
name|cbfcnp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|seserror
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|u_int32_t
name|cflags
parameter_list|,
name|u_int32_t
name|sflags
parameter_list|)
block|{
name|struct
name|ses_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|periph
operator|=
name|xpt_path_periph
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|ses_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
return|return
operator|(
name|cam_periph_error
argument_list|(
name|ccb
argument_list|,
name|cflags
argument_list|,
name|sflags
argument_list|,
operator|&
name|softc
operator|->
name|ses_saved_ccb
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sesioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|arg_addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|ses_encstat
name|tmp
decl_stmt|;
name|ses_objstat
name|objs
decl_stmt|;
name|ses_object
name|obj
decl_stmt|,
modifier|*
name|uobj
decl_stmt|;
name|struct
name|ses_softc
modifier|*
name|ssc
decl_stmt|;
name|void
modifier|*
name|addr
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|arg_addr
condition|)
name|addr
operator|=
operator|*
operator|(
operator|(
name|caddr_t
operator|*
operator|)
name|arg_addr
operator|)
expr_stmt|;
else|else
name|addr
operator|=
name|NULL
expr_stmt|;
name|periph
operator|=
name|cam_extend_get
argument_list|(
name|sesperiphs
argument_list|,
name|SESUNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"entering sesioctl\n"
operator|)
argument_list|)
expr_stmt|;
name|ssc
operator|=
operator|(
expr|struct
name|ses_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
comment|/* 	 * Now check to see whether we're initialized or not. 	 */
if|if
condition|(
operator|(
name|ssc
operator|->
name|ses_flags
operator|&
name|SES_FLAG_INITIALIZED
operator|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"trying to do ioctl %#lx\n"
operator|,
name|cmd
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If this command can change the device's state, 	 * we must have the device open for writing. 	 */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SESIOC_GETNOBJ
case|:
case|case
name|SESIOC_GETOBJMAP
case|:
case|case
name|SESIOC_GETENCSTAT
case|:
case|case
name|SESIOC_GETOBJSTAT
case|:
break|break;
default|default:
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|EBADF
operator|)
return|;
block|}
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SESIOC_GETNOBJ
case|:
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|ssc
operator|->
name|ses_nobjects
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|ssc
operator|->
name|ses_nobjects
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SESIOC_GETOBJMAP
case|:
for|for
control|(
name|uobj
operator|=
name|addr
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|ssc
operator|->
name|ses_nobjects
condition|;
name|i
operator|++
operator|,
name|uobj
operator|++
control|)
block|{
name|obj
operator|.
name|obj_id
operator|=
name|i
expr_stmt|;
name|obj
operator|.
name|subencid
operator|=
name|ssc
operator|->
name|ses_objmap
index|[
name|i
index|]
operator|.
name|subenclosure
expr_stmt|;
name|obj
operator|.
name|object_type
operator|=
name|ssc
operator|->
name|ses_objmap
index|[
name|i
index|]
operator|.
name|enctype
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|obj
argument_list|,
name|uobj
argument_list|,
sizeof|sizeof
argument_list|(
name|ses_object
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
block|}
break|break;
case|case
name|SESIOC_GETENCSTAT
case|:
name|error
operator|=
call|(
modifier|*
name|ssc
operator|->
name|ses_vec
operator|.
name|get_encstat
call|)
argument_list|(
name|ssc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|tmp
operator|=
name|ssc
operator|->
name|ses_encstat
operator|&
operator|~
name|ENCI_SVALID
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|tmp
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|ses_encstat
argument_list|)
argument_list|)
expr_stmt|;
name|ssc
operator|->
name|ses_encstat
operator|=
name|tmp
expr_stmt|;
break|break;
case|case
name|SESIOC_SETENCSTAT
case|:
name|error
operator|=
name|copyin
argument_list|(
name|addr
argument_list|,
operator|&
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|ses_encstat
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|error
operator|=
call|(
modifier|*
name|ssc
operator|->
name|ses_vec
operator|.
name|set_encstat
call|)
argument_list|(
name|ssc
argument_list|,
name|tmp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|SESIOC_GETOBJSTAT
case|:
name|error
operator|=
name|copyin
argument_list|(
name|addr
argument_list|,
operator|&
name|objs
argument_list|,
sizeof|sizeof
argument_list|(
name|ses_objstat
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|objs
operator|.
name|obj_id
operator|>=
name|ssc
operator|->
name|ses_nobjects
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|error
operator|=
call|(
modifier|*
name|ssc
operator|->
name|ses_vec
operator|.
name|get_objstat
call|)
argument_list|(
name|ssc
argument_list|,
operator|&
name|objs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|objs
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|ses_objstat
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Always (for now) invalidate entry. 		 */
name|ssc
operator|->
name|ses_objmap
index|[
name|objs
operator|.
name|obj_id
index|]
operator|.
name|svalid
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SESIOC_SETOBJSTAT
case|:
name|error
operator|=
name|copyin
argument_list|(
name|addr
argument_list|,
operator|&
name|objs
argument_list|,
sizeof|sizeof
argument_list|(
name|ses_objstat
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|objs
operator|.
name|obj_id
operator|>=
name|ssc
operator|->
name|ses_nobjects
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|error
operator|=
call|(
modifier|*
name|ssc
operator|->
name|ses_vec
operator|.
name|set_objstat
call|)
argument_list|(
name|ssc
argument_list|,
operator|&
name|objs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * Always (for now) invalidate entry. 		 */
name|ssc
operator|->
name|ses_objmap
index|[
name|objs
operator|.
name|obj_id
index|]
operator|.
name|svalid
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SESIOC_INIT
case|:
name|error
operator|=
call|(
modifier|*
name|ssc
operator|->
name|ses_vec
operator|.
name|init_enc
call|)
argument_list|(
name|ssc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|cam_periph_ioctl
argument_list|(
name|periph
argument_list|,
name|cmd
argument_list|,
name|arg_addr
argument_list|,
name|seserror
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|SES_CFLAGS
value|CAM_RETRY_SELTO
end_define

begin_define
define|#
directive|define
name|SES_FLAGS
value|SF_NO_PRINT | SF_RETRY_UA
end_define

begin_function
specifier|static
name|int
name|ses_runcmd
parameter_list|(
name|struct
name|ses_softc
modifier|*
name|ssc
parameter_list|,
name|char
modifier|*
name|cdb
parameter_list|,
name|int
name|cdbl
parameter_list|,
name|char
modifier|*
name|dptr
parameter_list|,
name|int
modifier|*
name|dlenp
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|dlen
decl_stmt|;
name|ccb_flags
name|ddf
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
if|if
condition|(
name|dptr
condition|)
block|{
if|if
condition|(
operator|(
name|dlen
operator|=
operator|*
name|dlenp
operator|)
operator|<
literal|0
condition|)
block|{
name|dlen
operator|=
operator|-
name|dlen
expr_stmt|;
name|ddf
operator|=
name|CAM_DIR_OUT
expr_stmt|;
block|}
else|else
block|{
name|ddf
operator|=
name|CAM_DIR_IN
expr_stmt|;
block|}
block|}
else|else
block|{
name|dlen
operator|=
literal|0
expr_stmt|;
name|ddf
operator|=
name|CAM_DIR_NONE
expr_stmt|;
block|}
if|if
condition|(
name|cdbl
operator|>
name|IOCDBLEN
condition|)
block|{
name|cdbl
operator|=
name|IOCDBLEN
expr_stmt|;
block|}
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|ssc
operator|->
name|periph
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cam_fill_csio
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
literal|0
argument_list|,
name|sesdone
argument_list|,
name|ddf
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|dptr
argument_list|,
name|dlen
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
argument_list|,
name|cdbl
argument_list|,
literal|60
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|cdb
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|cdbl
argument_list|)
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|seserror
argument_list|,
name|SES_CFLAGS
argument_list|,
name|SES_FLAGS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|!=
literal|0
condition|)
name|cam_release_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|dptr
condition|)
block|{
operator|*
name|dlenp
operator|=
name|dlen
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|dptr
condition|)
block|{
operator|*
name|dlenp
operator|=
name|ccb
operator|->
name|csio
operator|.
name|resid
expr_stmt|;
block|}
block|}
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ses_log
parameter_list|(
name|struct
name|ses_softc
modifier|*
name|ssc
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|printf
argument_list|(
literal|"%s%d: "
argument_list|,
name|ssc
operator|->
name|periph
operator|->
name|periph_name
argument_list|,
name|ssc
operator|->
name|periph
operator|->
name|unit_number
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vprintf
argument_list|(
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The code after this point runs on many platforms,  * so forgive the slightly awkward and nonconforming  * appearance.  */
end_comment

begin_comment
comment|/*  * Is this a device that supports enclosure services?  *  * It's a a pretty simple ruleset- if it is device type 0x0D (13), it's  * an SES device. If it happens to be an old UNISYS SEN device, we can  * handle that too.  */
end_comment

begin_define
define|#
directive|define
name|SAFTE_START
value|44
end_define

begin_define
define|#
directive|define
name|SAFTE_END
value|50
end_define

begin_define
define|#
directive|define
name|SAFTE_LEN
value|SAFTE_END-SAFTE_START
end_define

begin_function
specifier|static
name|enctyp
name|ses_type
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|int
name|buflen
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|iqd
init|=
name|buf
decl_stmt|;
if|if
condition|(
name|buflen
operator|<
literal|8
operator|+
name|SEN_ID_LEN
condition|)
return|return
operator|(
name|SES_NONE
operator|)
return|;
if|if
condition|(
operator|(
name|iqd
index|[
literal|0
index|]
operator|&
literal|0x1f
operator|)
operator|==
name|T_ENCLOSURE
condition|)
block|{
if|if
condition|(
name|STRNCMP
argument_list|(
operator|&
name|iqd
index|[
literal|8
index|]
argument_list|,
name|SEN_ID
argument_list|,
name|SEN_ID_LEN
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|SES_SEN
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|iqd
index|[
literal|2
index|]
operator|&
literal|0x7
operator|)
operator|>
literal|2
condition|)
block|{
return|return
operator|(
name|SES_SES
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|SES_SES_SCSI2
operator|)
return|;
block|}
return|return
operator|(
name|SES_NONE
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|SES_ENABLE_PASSTHROUGH
if|if
condition|(
operator|(
name|iqd
index|[
literal|6
index|]
operator|&
literal|0x40
operator|)
operator|&&
operator|(
name|iqd
index|[
literal|2
index|]
operator|&
literal|0x7
operator|)
operator|>=
literal|2
condition|)
block|{
comment|/* 		 * PassThrough Device. 		 */
return|return
operator|(
name|SES_SES_PASSTHROUGH
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* 	 * The comparison is short for a reason- 	 * some vendors were chopping it short. 	 */
if|if
condition|(
name|buflen
operator|<
name|SAFTE_END
operator|-
literal|2
condition|)
block|{
return|return
operator|(
name|SES_NONE
operator|)
return|;
block|}
if|if
condition|(
name|STRNCMP
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|iqd
index|[
name|SAFTE_START
index|]
argument_list|,
literal|"SAF-TE"
argument_list|,
name|SAFTE_LEN
operator|-
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|SES_SAFT
operator|)
return|;
block|}
return|return
operator|(
name|SES_NONE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * SES Native Type Device Support  */
end_comment

begin_comment
comment|/*  * SES Diagnostic Page Codes  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|SesConfigPage
init|=
literal|0x1
block|,
name|SesControlPage
block|,
define|#
directive|define
name|SesStatusPage
value|SesControlPage
name|SesHelpTxt
block|,
name|SesStringOut
block|,
define|#
directive|define
name|SesStringIn
value|SesStringOut
name|SesThresholdOut
block|,
define|#
directive|define
name|SesThresholdIn
value|SesThresholdOut
name|SesArrayControl
block|,
define|#
directive|define
name|SesArrayStatus
value|SesArrayControl
name|SesElementDescriptor
block|,
name|SesShortStatus
block|}
name|SesDiagPageCodes
typedef|;
end_typedef

begin_comment
comment|/*  * minimal amounts  */
end_comment

begin_comment
comment|/*  * Minimum amount of data, starting from byte 0, to have  * the config header.  */
end_comment

begin_define
define|#
directive|define
name|SES_CFGHDR_MINLEN
value|12
end_define

begin_comment
comment|/*  * Minimum amount of data, starting from byte 0, to have  * the config header and one enclosure header.  */
end_comment

begin_define
define|#
directive|define
name|SES_ENCHDR_MINLEN
value|48
end_define

begin_comment
comment|/*  * Take this value, subtract it from VEnclen and you know  * the length of the vendor unique bytes.  */
end_comment

begin_define
define|#
directive|define
name|SES_ENCHDR_VMIN
value|36
end_define

begin_comment
comment|/*  * SES Data Structures  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|uint32_t
name|GenCode
decl_stmt|;
comment|/* Generation Code */
name|uint8_t
name|Nsubenc
decl_stmt|;
comment|/* Number of Subenclosures */
block|}
name|SesCfgHdr
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|uint8_t
name|Subencid
decl_stmt|;
comment|/* SubEnclosure Identifier */
name|uint8_t
name|Ntypes
decl_stmt|;
comment|/* # of supported types */
name|uint8_t
name|VEnclen
decl_stmt|;
comment|/* Enclosure Descriptor Length */
block|}
name|SesEncHdr
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|uint8_t
name|encWWN
index|[
literal|8
index|]
decl_stmt|;
comment|/* XXX- Not Right Yet */
name|uint8_t
name|encVid
index|[
literal|8
index|]
decl_stmt|;
name|uint8_t
name|encPid
index|[
literal|16
index|]
decl_stmt|;
name|uint8_t
name|encRev
index|[
literal|4
index|]
decl_stmt|;
name|uint8_t
name|encVen
index|[
literal|1
index|]
decl_stmt|;
block|}
name|SesEncDesc
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|uint8_t
name|enc_type
decl_stmt|;
comment|/* type of element */
name|uint8_t
name|enc_maxelt
decl_stmt|;
comment|/* maximum supported */
name|uint8_t
name|enc_subenc
decl_stmt|;
comment|/* in SubEnc # N */
name|uint8_t
name|enc_tlen
decl_stmt|;
comment|/* Type Descriptor Text Length */
block|}
name|SesThdr
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|uint8_t
name|comstatus
decl_stmt|;
name|uint8_t
name|comstat
index|[
literal|3
index|]
decl_stmt|;
block|}
name|SesComStat
typedef|;
end_typedef

begin_struct
struct|struct
name|typidx
block|{
name|int
name|ses_tidx
decl_stmt|;
name|int
name|ses_oidx
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sscfg
block|{
name|uint8_t
name|ses_ntypes
decl_stmt|;
comment|/* total number of types supported */
comment|/* 	 * We need to keep a type index as well as an 	 * object index for each object in an enclosure. 	 */
name|struct
name|typidx
modifier|*
name|ses_typidx
decl_stmt|;
comment|/* 	 * We also need to keep track of the number of elements 	 * per type of element. This is needed later so that we 	 * can find precisely in the returned status data the 	 * status for the Nth element of the Kth type. 	 */
name|uint8_t
modifier|*
name|ses_eltmap
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * (de)canonicalization defines  */
end_comment

begin_define
define|#
directive|define
name|sbyte
parameter_list|(
name|x
parameter_list|,
name|byte
parameter_list|)
value|((((uint32_t)(x))>> (byte * 8))& 0xff)
end_define

begin_define
define|#
directive|define
name|sbit
parameter_list|(
name|x
parameter_list|,
name|bit
parameter_list|)
value|(((uint32_t)(x))<< bit)
end_define

begin_define
define|#
directive|define
name|sset8
parameter_list|(
name|outp
parameter_list|,
name|idx
parameter_list|,
name|sval
parameter_list|)
value|(((uint8_t *)(outp))[idx++]) = sbyte(sval, 0)
end_define

begin_define
define|#
directive|define
name|sset16
parameter_list|(
name|outp
parameter_list|,
name|idx
parameter_list|,
name|sval
parameter_list|)
define|\
value|(((uint8_t *)(outp))[idx++]) = sbyte(sval, 1), \ 	(((uint8_t *)(outp))[idx++]) = sbyte(sval, 0)
end_define

begin_define
define|#
directive|define
name|sset24
parameter_list|(
name|outp
parameter_list|,
name|idx
parameter_list|,
name|sval
parameter_list|)
define|\
value|(((uint8_t *)(outp))[idx++]) = sbyte(sval, 2), \ 	(((uint8_t *)(outp))[idx++]) = sbyte(sval, 1), \ 	(((uint8_t *)(outp))[idx++]) = sbyte(sval, 0)
end_define

begin_define
define|#
directive|define
name|sset32
parameter_list|(
name|outp
parameter_list|,
name|idx
parameter_list|,
name|sval
parameter_list|)
define|\
value|(((uint8_t *)(outp))[idx++]) = sbyte(sval, 3), \ 	(((uint8_t *)(outp))[idx++]) = sbyte(sval, 2), \ 	(((uint8_t *)(outp))[idx++]) = sbyte(sval, 1), \ 	(((uint8_t *)(outp))[idx++]) = sbyte(sval, 0)
end_define

begin_define
define|#
directive|define
name|gbyte
parameter_list|(
name|x
parameter_list|,
name|byte
parameter_list|)
value|((((uint32_t)(x))& 0xff)<< (byte * 8))
end_define

begin_define
define|#
directive|define
name|gbit
parameter_list|(
name|lv
parameter_list|,
name|in
parameter_list|,
name|idx
parameter_list|,
name|shft
parameter_list|,
name|mask
parameter_list|)
value|lv = ((in[idx]>> shft)& mask)
end_define

begin_define
define|#
directive|define
name|sget8
parameter_list|(
name|inp
parameter_list|,
name|idx
parameter_list|,
name|lval
parameter_list|)
value|lval = (((uint8_t *)(inp))[idx++])
end_define

begin_define
define|#
directive|define
name|gget8
parameter_list|(
name|inp
parameter_list|,
name|idx
parameter_list|,
name|lval
parameter_list|)
value|lval = (((uint8_t *)(inp))[idx])
end_define

begin_define
define|#
directive|define
name|sget16
parameter_list|(
name|inp
parameter_list|,
name|idx
parameter_list|,
name|lval
parameter_list|)
define|\
value|lval = gbyte((((uint8_t *)(inp))[idx]), 1) | \ 		(((uint8_t *)(inp))[idx+1]), idx += 2
end_define

begin_define
define|#
directive|define
name|gget16
parameter_list|(
name|inp
parameter_list|,
name|idx
parameter_list|,
name|lval
parameter_list|)
define|\
value|lval = gbyte((((uint8_t *)(inp))[idx]), 1) | \ 		(((uint8_t *)(inp))[idx+1])
end_define

begin_define
define|#
directive|define
name|sget24
parameter_list|(
name|inp
parameter_list|,
name|idx
parameter_list|,
name|lval
parameter_list|)
define|\
value|lval = gbyte((((uint8_t *)(inp))[idx]), 2) | \ 		gbyte((((uint8_t *)(inp))[idx+1]), 1) | \ 			(((uint8_t *)(inp))[idx+2]), idx += 3
end_define

begin_define
define|#
directive|define
name|gget24
parameter_list|(
name|inp
parameter_list|,
name|idx
parameter_list|,
name|lval
parameter_list|)
define|\
value|lval = gbyte((((uint8_t *)(inp))[idx]), 2) | \ 		gbyte((((uint8_t *)(inp))[idx+1]), 1) | \ 			(((uint8_t *)(inp))[idx+2])
end_define

begin_define
define|#
directive|define
name|sget32
parameter_list|(
name|inp
parameter_list|,
name|idx
parameter_list|,
name|lval
parameter_list|)
define|\
value|lval = gbyte((((uint8_t *)(inp))[idx]), 3) | \ 		gbyte((((uint8_t *)(inp))[idx+1]), 2) | \ 		gbyte((((uint8_t *)(inp))[idx+2]), 1) | \ 			(((uint8_t *)(inp))[idx+3]), idx += 4
end_define

begin_define
define|#
directive|define
name|gget32
parameter_list|(
name|inp
parameter_list|,
name|idx
parameter_list|,
name|lval
parameter_list|)
define|\
value|lval = gbyte((((uint8_t *)(inp))[idx]), 3) | \ 		gbyte((((uint8_t *)(inp))[idx+1]), 2) | \ 		gbyte((((uint8_t *)(inp))[idx+2]), 1) | \ 			(((uint8_t *)(inp))[idx+3])
end_define

begin_define
define|#
directive|define
name|SCSZ
value|0x2000
end_define

begin_define
define|#
directive|define
name|CFLEN
value|(256 + SES_ENCHDR_MINLEN)
end_define

begin_comment
comment|/*  * Routines specific&& private to SES only  */
end_comment

begin_function_decl
specifier|static
name|int
name|ses_getconfig
parameter_list|(
name|ses_softc_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ses_getputstat
parameter_list|(
name|ses_softc_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|SesComStat
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ses_cfghdr
parameter_list|(
name|uint8_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|SesCfgHdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ses_enchdr
parameter_list|(
name|uint8_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|uint8_t
parameter_list|,
name|SesEncHdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ses_encdesc
parameter_list|(
name|uint8_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|uint8_t
parameter_list|,
name|SesEncDesc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ses_getthdr
parameter_list|(
name|uint8_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|SesThdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ses_decode
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|uint8_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|SesComStat
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ses_encode
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|uint8_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|SesComStat
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|ses_softc_init
parameter_list|(
name|ses_softc_t
modifier|*
name|ssc
parameter_list|,
name|int
name|doinit
parameter_list|)
block|{
if|if
condition|(
name|doinit
operator|==
literal|0
condition|)
block|{
name|struct
name|sscfg
modifier|*
name|cc
decl_stmt|;
if|if
condition|(
name|ssc
operator|->
name|ses_nobjects
condition|)
block|{
name|SES_FREE
argument_list|(
name|ssc
operator|->
name|ses_objmap
argument_list|,
name|ssc
operator|->
name|ses_nobjects
operator|*
sizeof|sizeof
argument_list|(
name|encobj
argument_list|)
argument_list|)
expr_stmt|;
name|ssc
operator|->
name|ses_objmap
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cc
operator|=
name|ssc
operator|->
name|ses_private
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cc
operator|->
name|ses_eltmap
operator|&&
name|cc
operator|->
name|ses_ntypes
condition|)
block|{
name|SES_FREE
argument_list|(
name|cc
operator|->
name|ses_eltmap
argument_list|,
name|cc
operator|->
name|ses_ntypes
argument_list|)
expr_stmt|;
name|cc
operator|->
name|ses_eltmap
operator|=
name|NULL
expr_stmt|;
name|cc
operator|->
name|ses_ntypes
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|cc
operator|->
name|ses_typidx
operator|&&
name|ssc
operator|->
name|ses_nobjects
condition|)
block|{
name|SES_FREE
argument_list|(
name|cc
operator|->
name|ses_typidx
argument_list|,
name|ssc
operator|->
name|ses_nobjects
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|typidx
argument_list|)
argument_list|)
expr_stmt|;
name|cc
operator|->
name|ses_typidx
operator|=
name|NULL
expr_stmt|;
block|}
name|SES_FREE
argument_list|(
name|cc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sscfg
argument_list|)
argument_list|)
expr_stmt|;
name|ssc
operator|->
name|ses_private
operator|=
name|NULL
expr_stmt|;
block|}
name|ssc
operator|->
name|ses_nobjects
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|ssc
operator|->
name|ses_private
operator|==
name|NULL
condition|)
block|{
name|ssc
operator|->
name|ses_private
operator|=
name|SES_MALLOC
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sscfg
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ssc
operator|->
name|ses_private
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|ssc
operator|->
name|ses_nobjects
operator|=
literal|0
expr_stmt|;
name|ssc
operator|->
name|ses_encstat
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ses_getconfig
argument_list|(
name|ssc
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ses_init_enc
parameter_list|(
name|ses_softc_t
modifier|*
name|ssc
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ses_get_encstat
parameter_list|(
name|ses_softc_t
modifier|*
name|ssc
parameter_list|,
name|int
name|slpflag
parameter_list|)
block|{
name|SesComStat
name|ComStat
decl_stmt|;
name|int
name|status
decl_stmt|;
if|if
condition|(
operator|(
name|status
operator|=
name|ses_getputstat
argument_list|(
name|ssc
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|ComStat
argument_list|,
name|slpflag
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|status
operator|)
return|;
block|}
name|ssc
operator|->
name|ses_encstat
operator|=
name|ComStat
operator|.
name|comstatus
operator||
name|ENCI_SVALID
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ses_set_encstat
parameter_list|(
name|ses_softc_t
modifier|*
name|ssc
parameter_list|,
name|uint8_t
name|encstat
parameter_list|,
name|int
name|slpflag
parameter_list|)
block|{
name|SesComStat
name|ComStat
decl_stmt|;
name|int
name|status
decl_stmt|;
name|ComStat
operator|.
name|comstatus
operator|=
name|encstat
operator|&
literal|0xf
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|=
name|ses_getputstat
argument_list|(
name|ssc
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|ComStat
argument_list|,
name|slpflag
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|status
operator|)
return|;
block|}
name|ssc
operator|->
name|ses_encstat
operator|=
name|encstat
operator|&
literal|0xf
expr_stmt|;
comment|/* note no SVALID set */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ses_get_objstat
parameter_list|(
name|ses_softc_t
modifier|*
name|ssc
parameter_list|,
name|ses_objstat
modifier|*
name|obp
parameter_list|,
name|int
name|slpflag
parameter_list|)
block|{
name|int
name|i
init|=
operator|(
name|int
operator|)
name|obp
operator|->
name|obj_id
decl_stmt|;
if|if
condition|(
name|ssc
operator|->
name|ses_objmap
index|[
name|i
index|]
operator|.
name|svalid
operator|==
literal|0
condition|)
block|{
name|SesComStat
name|ComStat
decl_stmt|;
name|int
name|err
init|=
name|ses_getputstat
argument_list|(
name|ssc
argument_list|,
name|i
argument_list|,
operator|&
name|ComStat
argument_list|,
name|slpflag
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|ssc
operator|->
name|ses_objmap
index|[
name|i
index|]
operator|.
name|encstat
index|[
literal|0
index|]
operator|=
name|ComStat
operator|.
name|comstatus
expr_stmt|;
name|ssc
operator|->
name|ses_objmap
index|[
name|i
index|]
operator|.
name|encstat
index|[
literal|1
index|]
operator|=
name|ComStat
operator|.
name|comstat
index|[
literal|0
index|]
expr_stmt|;
name|ssc
operator|->
name|ses_objmap
index|[
name|i
index|]
operator|.
name|encstat
index|[
literal|2
index|]
operator|=
name|ComStat
operator|.
name|comstat
index|[
literal|1
index|]
expr_stmt|;
name|ssc
operator|->
name|ses_objmap
index|[
name|i
index|]
operator|.
name|encstat
index|[
literal|3
index|]
operator|=
name|ComStat
operator|.
name|comstat
index|[
literal|2
index|]
expr_stmt|;
name|ssc
operator|->
name|ses_objmap
index|[
name|i
index|]
operator|.
name|svalid
operator|=
literal|1
expr_stmt|;
block|}
name|obp
operator|->
name|cstat
index|[
literal|0
index|]
operator|=
name|ssc
operator|->
name|ses_objmap
index|[
name|i
index|]
operator|.
name|encstat
index|[
literal|0
index|]
expr_stmt|;
name|obp
operator|->
name|cstat
index|[
literal|1
index|]
operator|=
name|ssc
operator|->
name|ses_objmap
index|[
name|i
index|]
operator|.
name|encstat
index|[
literal|1
index|]
expr_stmt|;
name|obp
operator|->
name|cstat
index|[
literal|2
index|]
operator|=
name|ssc
operator|->
name|ses_objmap
index|[
name|i
index|]
operator|.
name|encstat
index|[
literal|2
index|]
expr_stmt|;
name|obp
operator|->
name|cstat
index|[
literal|3
index|]
operator|=
name|ssc
operator|->
name|ses_objmap
index|[
name|i
index|]
operator|.
name|encstat
index|[
literal|3
index|]
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ses_set_objstat
parameter_list|(
name|ses_softc_t
modifier|*
name|ssc
parameter_list|,
name|ses_objstat
modifier|*
name|obp
parameter_list|,
name|int
name|slpflag
parameter_list|)
block|{
name|SesComStat
name|ComStat
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* 	 * If this is clear, we don't do diddly. 	 */
if|if
condition|(
operator|(
name|obp
operator|->
name|cstat
index|[
literal|0
index|]
operator|&
name|SESCTL_CSEL
operator|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ComStat
operator|.
name|comstatus
operator|=
name|obp
operator|->
name|cstat
index|[
literal|0
index|]
expr_stmt|;
name|ComStat
operator|.
name|comstat
index|[
literal|0
index|]
operator|=
name|obp
operator|->
name|cstat
index|[
literal|1
index|]
expr_stmt|;
name|ComStat
operator|.
name|comstat
index|[
literal|1
index|]
operator|=
name|obp
operator|->
name|cstat
index|[
literal|2
index|]
expr_stmt|;
name|ComStat
operator|.
name|comstat
index|[
literal|2
index|]
operator|=
name|obp
operator|->
name|cstat
index|[
literal|3
index|]
expr_stmt|;
name|err
operator|=
name|ses_getputstat
argument_list|(
name|ssc
argument_list|,
operator|(
name|int
operator|)
name|obp
operator|->
name|obj_id
argument_list|,
operator|&
name|ComStat
argument_list|,
name|slpflag
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ssc
operator|->
name|ses_objmap
index|[
operator|(
name|int
operator|)
name|obp
operator|->
name|obj_id
index|]
operator|.
name|svalid
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ses_getconfig
parameter_list|(
name|ses_softc_t
modifier|*
name|ssc
parameter_list|)
block|{
name|struct
name|sscfg
modifier|*
name|cc
decl_stmt|;
name|SesCfgHdr
name|cf
decl_stmt|;
name|SesEncHdr
name|hd
decl_stmt|;
name|SesEncDesc
modifier|*
name|cdp
decl_stmt|;
name|SesThdr
name|thdr
decl_stmt|;
name|int
name|err
decl_stmt|,
name|amt
decl_stmt|,
name|i
decl_stmt|,
name|nobj
decl_stmt|,
name|ntype
decl_stmt|,
name|maxima
decl_stmt|;
name|char
name|storage
index|[
name|CFLEN
index|]
decl_stmt|,
modifier|*
name|sdata
decl_stmt|;
specifier|static
name|char
name|cdb
index|[
literal|6
index|]
init|=
block|{
name|RECEIVE_DIAGNOSTIC
block|,
literal|0x1
block|,
name|SesConfigPage
block|,
name|SCSZ
operator|>>
literal|8
block|,
name|SCSZ
operator|&
literal|0xff
block|,
literal|0
block|}
decl_stmt|;
name|cc
operator|=
name|ssc
operator|->
name|ses_private
expr_stmt|;
if|if
condition|(
name|cc
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sdata
operator|=
name|SES_MALLOC
argument_list|(
name|SCSZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdata
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|amt
operator|=
name|SCSZ
expr_stmt|;
name|err
operator|=
name|ses_runcmd
argument_list|(
name|ssc
argument_list|,
name|cdb
argument_list|,
literal|6
argument_list|,
name|sdata
argument_list|,
operator|&
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|SES_FREE
argument_list|(
name|sdata
argument_list|,
name|SCSZ
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|amt
operator|=
name|SCSZ
operator|-
name|amt
expr_stmt|;
if|if
condition|(
name|ses_cfghdr
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|sdata
argument_list|,
name|amt
argument_list|,
operator|&
name|cf
argument_list|)
condition|)
block|{
name|SES_LOG
argument_list|(
name|ssc
argument_list|,
literal|"Unable to parse SES Config Header\n"
argument_list|)
expr_stmt|;
name|SES_FREE
argument_list|(
name|sdata
argument_list|,
name|SCSZ
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
name|amt
operator|<
name|SES_ENCHDR_MINLEN
condition|)
block|{
name|SES_LOG
argument_list|(
name|ssc
argument_list|,
literal|"runt enclosure length (%d)\n"
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|SES_FREE
argument_list|(
name|sdata
argument_list|,
name|SCSZ
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|SES_VLOG
argument_list|(
name|ssc
argument_list|,
literal|"GenCode %x %d Subenclosures\n"
argument_list|,
name|cf
operator|.
name|GenCode
argument_list|,
name|cf
operator|.
name|Nsubenc
argument_list|)
expr_stmt|;
comment|/* 	 * Now waltz through all the subenclosures toting up the 	 * number of types available in each. For this, we only 	 * really need the enclosure header. However, we get the 	 * enclosure descriptor for debug purposes, as well 	 * as self-consistency checking purposes. 	 */
name|maxima
operator|=
name|cf
operator|.
name|Nsubenc
operator|+
literal|1
expr_stmt|;
name|cdp
operator|=
operator|(
name|SesEncDesc
operator|*
operator|)
name|storage
expr_stmt|;
for|for
control|(
name|ntype
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxima
condition|;
name|i
operator|++
control|)
block|{
name|MEMZERO
argument_list|(
operator|(
name|caddr_t
operator|)
name|cdp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cdp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ses_enchdr
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|sdata
argument_list|,
name|amt
argument_list|,
name|i
argument_list|,
operator|&
name|hd
argument_list|)
condition|)
block|{
name|SES_LOG
argument_list|(
name|ssc
argument_list|,
literal|"Cannot Extract Enclosure Header %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|SES_FREE
argument_list|(
name|sdata
argument_list|,
name|SCSZ
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|SES_VLOG
argument_list|(
name|ssc
argument_list|,
literal|" SubEnclosure ID %d, %d Types With this ID, En"
literal|"closure Length %d\n"
argument_list|,
name|hd
operator|.
name|Subencid
argument_list|,
name|hd
operator|.
name|Ntypes
argument_list|,
name|hd
operator|.
name|VEnclen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ses_encdesc
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|sdata
argument_list|,
name|amt
argument_list|,
name|i
argument_list|,
name|cdp
argument_list|)
condition|)
block|{
name|SES_LOG
argument_list|(
name|ssc
argument_list|,
literal|"Can't get Enclosure Descriptor %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|SES_FREE
argument_list|(
name|sdata
argument_list|,
name|SCSZ
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|SES_VLOG
argument_list|(
name|ssc
argument_list|,
literal|" WWN: %02x%02x%02x%02x%02x%02x%02x%02x\n"
argument_list|,
name|cdp
operator|->
name|encWWN
index|[
literal|0
index|]
argument_list|,
name|cdp
operator|->
name|encWWN
index|[
literal|1
index|]
argument_list|,
name|cdp
operator|->
name|encWWN
index|[
literal|2
index|]
argument_list|,
name|cdp
operator|->
name|encWWN
index|[
literal|3
index|]
argument_list|,
name|cdp
operator|->
name|encWWN
index|[
literal|4
index|]
argument_list|,
name|cdp
operator|->
name|encWWN
index|[
literal|5
index|]
argument_list|,
name|cdp
operator|->
name|encWWN
index|[
literal|6
index|]
argument_list|,
name|cdp
operator|->
name|encWWN
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
name|ntype
operator|+=
name|hd
operator|.
name|Ntypes
expr_stmt|;
block|}
comment|/* 	 * Now waltz through all the types that are available, getting 	 * the type header so we can start adding up the number of 	 * objects available. 	 */
for|for
control|(
name|nobj
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntype
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ses_getthdr
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|sdata
argument_list|,
name|amt
argument_list|,
name|i
argument_list|,
operator|&
name|thdr
argument_list|)
condition|)
block|{
name|SES_LOG
argument_list|(
name|ssc
argument_list|,
literal|"Can't get Enclosure Type Header %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|SES_FREE
argument_list|(
name|sdata
argument_list|,
name|SCSZ
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|SES_LOG
argument_list|(
name|ssc
argument_list|,
literal|" Type Desc[%d]: Type 0x%x, MaxElt %d, In Subenc "
literal|"%d, Text Length %d\n"
argument_list|,
name|i
argument_list|,
name|thdr
operator|.
name|enc_type
argument_list|,
name|thdr
operator|.
name|enc_maxelt
argument_list|,
name|thdr
operator|.
name|enc_subenc
argument_list|,
name|thdr
operator|.
name|enc_tlen
argument_list|)
expr_stmt|;
name|nobj
operator|+=
name|thdr
operator|.
name|enc_maxelt
expr_stmt|;
block|}
comment|/* 	 * Now allocate the object array and type map. 	 */
name|ssc
operator|->
name|ses_objmap
operator|=
name|SES_MALLOC
argument_list|(
name|nobj
operator|*
sizeof|sizeof
argument_list|(
name|encobj
argument_list|)
argument_list|)
expr_stmt|;
name|cc
operator|->
name|ses_typidx
operator|=
name|SES_MALLOC
argument_list|(
name|nobj
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|typidx
argument_list|)
argument_list|)
expr_stmt|;
name|cc
operator|->
name|ses_eltmap
operator|=
name|SES_MALLOC
argument_list|(
name|ntype
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssc
operator|->
name|ses_objmap
operator|==
name|NULL
operator|||
name|cc
operator|->
name|ses_typidx
operator|==
name|NULL
operator|||
name|cc
operator|->
name|ses_eltmap
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ssc
operator|->
name|ses_objmap
condition|)
block|{
name|SES_FREE
argument_list|(
name|ssc
operator|->
name|ses_objmap
argument_list|,
operator|(
name|nobj
operator|*
sizeof|sizeof
argument_list|(
name|encobj
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ssc
operator|->
name|ses_objmap
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|cc
operator|->
name|ses_typidx
condition|)
block|{
name|SES_FREE
argument_list|(
name|cc
operator|->
name|ses_typidx
argument_list|,
operator|(
name|nobj
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|typidx
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|cc
operator|->
name|ses_typidx
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|cc
operator|->
name|ses_eltmap
condition|)
block|{
name|SES_FREE
argument_list|(
name|cc
operator|->
name|ses_eltmap
argument_list|,
name|ntype
argument_list|)
expr_stmt|;
name|cc
operator|->
name|ses_eltmap
operator|=
name|NULL
expr_stmt|;
block|}
name|SES_FREE
argument_list|(
name|sdata
argument_list|,
name|SCSZ
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|MEMZERO
argument_list|(
name|ssc
operator|->
name|ses_objmap
argument_list|,
name|nobj
operator|*
sizeof|sizeof
argument_list|(
name|encobj
argument_list|)
argument_list|)
expr_stmt|;
name|MEMZERO
argument_list|(
name|cc
operator|->
name|ses_typidx
argument_list|,
name|nobj
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|typidx
argument_list|)
argument_list|)
expr_stmt|;
name|MEMZERO
argument_list|(
name|cc
operator|->
name|ses_eltmap
argument_list|,
name|ntype
argument_list|)
expr_stmt|;
name|cc
operator|->
name|ses_ntypes
operator|=
operator|(
name|uint8_t
operator|)
name|ntype
expr_stmt|;
name|ssc
operator|->
name|ses_nobjects
operator|=
name|nobj
expr_stmt|;
comment|/* 	 * Now waltz through the # of types again to fill in the types 	 * (and subenclosure ids) of the allocated objects. 	 */
name|nobj
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntype
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
if|if
condition|(
name|ses_getthdr
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|sdata
argument_list|,
name|amt
argument_list|,
name|i
argument_list|,
operator|&
name|thdr
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|cc
operator|->
name|ses_eltmap
index|[
name|i
index|]
operator|=
name|thdr
operator|.
name|enc_maxelt
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|thdr
operator|.
name|enc_maxelt
condition|;
name|j
operator|++
control|)
block|{
name|cc
operator|->
name|ses_typidx
index|[
name|nobj
index|]
operator|.
name|ses_tidx
operator|=
name|i
expr_stmt|;
name|cc
operator|->
name|ses_typidx
index|[
name|nobj
index|]
operator|.
name|ses_oidx
operator|=
name|j
expr_stmt|;
name|ssc
operator|->
name|ses_objmap
index|[
name|nobj
index|]
operator|.
name|subenclosure
operator|=
name|thdr
operator|.
name|enc_subenc
expr_stmt|;
name|ssc
operator|->
name|ses_objmap
index|[
name|nobj
operator|++
index|]
operator|.
name|enctype
operator|=
name|thdr
operator|.
name|enc_type
expr_stmt|;
block|}
block|}
name|SES_FREE
argument_list|(
name|sdata
argument_list|,
name|SCSZ
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ses_getputstat
parameter_list|(
name|ses_softc_t
modifier|*
name|ssc
parameter_list|,
name|int
name|objid
parameter_list|,
name|SesComStat
modifier|*
name|sp
parameter_list|,
name|int
name|slp
parameter_list|,
name|int
name|in
parameter_list|)
block|{
name|struct
name|sscfg
modifier|*
name|cc
decl_stmt|;
name|int
name|err
decl_stmt|,
name|amt
decl_stmt|,
name|bufsiz
decl_stmt|,
name|tidx
decl_stmt|,
name|oidx
decl_stmt|;
name|char
name|cdb
index|[
literal|6
index|]
decl_stmt|,
modifier|*
name|sdata
decl_stmt|;
name|cc
operator|=
name|ssc
operator|->
name|ses_private
expr_stmt|;
if|if
condition|(
name|cc
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * If we're just getting overall enclosure status, 	 * we only need 2 bytes of data storage. 	 * 	 * If we're getting anything else, we know how much 	 * storage we need by noting that starting at offset 	 * 8 in returned data, all object status bytes are 4 	 * bytes long, and are stored in chunks of types(M) 	 * and nth+1 instances of type M. 	 */
if|if
condition|(
name|objid
operator|==
operator|-
literal|1
condition|)
block|{
name|bufsiz
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|bufsiz
operator|=
operator|(
name|ssc
operator|->
name|ses_nobjects
operator|*
literal|4
operator|)
operator|+
operator|(
name|cc
operator|->
name|ses_ntypes
operator|*
literal|4
operator|)
operator|+
literal|8
expr_stmt|;
block|}
name|sdata
operator|=
name|SES_MALLOC
argument_list|(
name|bufsiz
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdata
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|cdb
index|[
literal|0
index|]
operator|=
name|RECEIVE_DIAGNOSTIC
expr_stmt|;
name|cdb
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|cdb
index|[
literal|2
index|]
operator|=
name|SesStatusPage
expr_stmt|;
name|cdb
index|[
literal|3
index|]
operator|=
name|bufsiz
operator|>>
literal|8
expr_stmt|;
name|cdb
index|[
literal|4
index|]
operator|=
name|bufsiz
operator|&
literal|0xff
expr_stmt|;
name|cdb
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
name|amt
operator|=
name|bufsiz
expr_stmt|;
name|err
operator|=
name|ses_runcmd
argument_list|(
name|ssc
argument_list|,
name|cdb
argument_list|,
literal|6
argument_list|,
name|sdata
argument_list|,
operator|&
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|SES_FREE
argument_list|(
name|sdata
argument_list|,
name|bufsiz
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|amt
operator|=
name|bufsiz
operator|-
name|amt
expr_stmt|;
if|if
condition|(
name|objid
operator|==
operator|-
literal|1
condition|)
block|{
name|tidx
operator|=
operator|-
literal|1
expr_stmt|;
name|oidx
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|tidx
operator|=
name|cc
operator|->
name|ses_typidx
index|[
name|objid
index|]
operator|.
name|ses_tidx
expr_stmt|;
name|oidx
operator|=
name|cc
operator|->
name|ses_typidx
index|[
name|objid
index|]
operator|.
name|ses_oidx
expr_stmt|;
block|}
if|if
condition|(
name|in
condition|)
block|{
if|if
condition|(
name|ses_decode
argument_list|(
name|sdata
argument_list|,
name|amt
argument_list|,
name|cc
operator|->
name|ses_eltmap
argument_list|,
name|tidx
argument_list|,
name|oidx
argument_list|,
name|sp
argument_list|)
condition|)
block|{
name|err
operator|=
name|ENODEV
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ses_encode
argument_list|(
name|sdata
argument_list|,
name|amt
argument_list|,
name|cc
operator|->
name|ses_eltmap
argument_list|,
name|tidx
argument_list|,
name|oidx
argument_list|,
name|sp
argument_list|)
condition|)
block|{
name|err
operator|=
name|ENODEV
expr_stmt|;
block|}
else|else
block|{
name|cdb
index|[
literal|0
index|]
operator|=
name|SEND_DIAGNOSTIC
expr_stmt|;
name|cdb
index|[
literal|1
index|]
operator|=
literal|0x10
expr_stmt|;
name|cdb
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|cdb
index|[
literal|3
index|]
operator|=
name|bufsiz
operator|>>
literal|8
expr_stmt|;
name|cdb
index|[
literal|4
index|]
operator|=
name|bufsiz
operator|&
literal|0xff
expr_stmt|;
name|cdb
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
name|amt
operator|=
operator|-
name|bufsiz
expr_stmt|;
name|err
operator|=
name|ses_runcmd
argument_list|(
name|ssc
argument_list|,
name|cdb
argument_list|,
literal|6
argument_list|,
name|sdata
argument_list|,
operator|&
name|amt
argument_list|)
expr_stmt|;
block|}
block|}
name|SES_FREE
argument_list|(
name|sdata
argument_list|,
name|bufsiz
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Routines to parse returned SES data structures.  * Architecture and compiler independent.  */
end_comment

begin_function
specifier|static
name|int
name|ses_cfghdr
parameter_list|(
name|uint8_t
modifier|*
name|buffer
parameter_list|,
name|int
name|buflen
parameter_list|,
name|SesCfgHdr
modifier|*
name|cfp
parameter_list|)
block|{
if|if
condition|(
name|buflen
operator|<
name|SES_CFGHDR_MINLEN
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|gget8
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
name|cfp
operator|->
name|Nsubenc
argument_list|)
expr_stmt|;
name|gget32
argument_list|(
name|buffer
argument_list|,
literal|4
argument_list|,
name|cfp
operator|->
name|GenCode
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ses_enchdr
parameter_list|(
name|uint8_t
modifier|*
name|buffer
parameter_list|,
name|int
name|amt
parameter_list|,
name|uint8_t
name|SubEncId
parameter_list|,
name|SesEncHdr
modifier|*
name|chp
parameter_list|)
block|{
name|int
name|s
decl_stmt|,
name|off
init|=
literal|8
decl_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|SubEncId
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
name|off
operator|+
literal|3
operator|>
name|amt
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|off
operator|+=
name|buffer
index|[
name|off
operator|+
literal|3
index|]
operator|+
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|off
operator|+
literal|3
operator|>
name|amt
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|gget8
argument_list|(
name|buffer
argument_list|,
name|off
operator|+
literal|1
argument_list|,
name|chp
operator|->
name|Subencid
argument_list|)
expr_stmt|;
name|gget8
argument_list|(
name|buffer
argument_list|,
name|off
operator|+
literal|2
argument_list|,
name|chp
operator|->
name|Ntypes
argument_list|)
expr_stmt|;
name|gget8
argument_list|(
name|buffer
argument_list|,
name|off
operator|+
literal|3
argument_list|,
name|chp
operator|->
name|VEnclen
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ses_encdesc
parameter_list|(
name|uint8_t
modifier|*
name|buffer
parameter_list|,
name|int
name|amt
parameter_list|,
name|uint8_t
name|SubEncId
parameter_list|,
name|SesEncDesc
modifier|*
name|cdp
parameter_list|)
block|{
name|int
name|s
decl_stmt|,
name|e
decl_stmt|,
name|enclen
decl_stmt|,
name|off
init|=
literal|8
decl_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|SubEncId
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
name|off
operator|+
literal|3
operator|>
name|amt
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|off
operator|+=
name|buffer
index|[
name|off
operator|+
literal|3
index|]
operator|+
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|off
operator|+
literal|3
operator|>
name|amt
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|gget8
argument_list|(
name|buffer
argument_list|,
name|off
operator|+
literal|3
argument_list|,
name|enclen
argument_list|)
expr_stmt|;
name|off
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|off
operator|>=
name|amt
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|e
operator|=
name|off
operator|+
name|enclen
expr_stmt|;
if|if
condition|(
name|e
operator|>
name|amt
condition|)
block|{
name|e
operator|=
name|amt
expr_stmt|;
block|}
name|MEMCPY
argument_list|(
name|cdp
argument_list|,
operator|&
name|buffer
index|[
name|off
index|]
argument_list|,
name|e
operator|-
name|off
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ses_getthdr
parameter_list|(
name|uint8_t
modifier|*
name|buffer
parameter_list|,
name|int
name|amt
parameter_list|,
name|int
name|nth
parameter_list|,
name|SesThdr
modifier|*
name|thp
parameter_list|)
block|{
name|int
name|s
decl_stmt|,
name|off
init|=
literal|8
decl_stmt|;
if|if
condition|(
name|amt
operator|<
name|SES_CFGHDR_MINLEN
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|buffer
index|[
literal|1
index|]
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
name|off
operator|+
literal|3
operator|>
name|amt
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|off
operator|+=
name|buffer
index|[
name|off
operator|+
literal|3
index|]
operator|+
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|off
operator|+
literal|3
operator|>
name|amt
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|off
operator|+=
name|buffer
index|[
name|off
operator|+
literal|3
index|]
operator|+
literal|4
operator|+
operator|(
name|nth
operator|*
literal|4
operator|)
expr_stmt|;
if|if
condition|(
name|amt
operator|<
operator|(
name|off
operator|+
literal|4
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|gget8
argument_list|(
name|buffer
argument_list|,
name|off
operator|++
argument_list|,
name|thp
operator|->
name|enc_type
argument_list|)
expr_stmt|;
name|gget8
argument_list|(
name|buffer
argument_list|,
name|off
operator|++
argument_list|,
name|thp
operator|->
name|enc_maxelt
argument_list|)
expr_stmt|;
name|gget8
argument_list|(
name|buffer
argument_list|,
name|off
operator|++
argument_list|,
name|thp
operator|->
name|enc_subenc
argument_list|)
expr_stmt|;
name|gget8
argument_list|(
name|buffer
argument_list|,
name|off
argument_list|,
name|thp
operator|->
name|enc_tlen
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function needs a little explanation.  *  * The arguments are:  *  *  *	char *b, int amt  *  *		These describes the raw input SES status data and length.  *  *	uint8_t *ep  *  *		This is a map of the number of types for each element type  *		in the enclosure.  *  *	int elt  *  *		This is the element type being sought. If elt is -1,  *		then overall enclosure status is being sought.  *  *	int elm  *  *		This is the ordinal Mth element of type elt being sought.  *  *	SesComStat *sp  *  *		This is the output area to store the status for  *		the Mth element of type Elt.  */
end_comment

begin_function
specifier|static
name|int
name|ses_decode
parameter_list|(
name|char
modifier|*
name|b
parameter_list|,
name|int
name|amt
parameter_list|,
name|uint8_t
modifier|*
name|ep
parameter_list|,
name|int
name|elt
parameter_list|,
name|int
name|elm
parameter_list|,
name|SesComStat
modifier|*
name|sp
parameter_list|)
block|{
name|int
name|idx
decl_stmt|,
name|i
decl_stmt|;
comment|/* 	 * If it's overall enclosure status being sought, get that. 	 * We need at least 2 bytes of status data to get that. 	 */
if|if
condition|(
name|elt
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|amt
operator|<
literal|2
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|gget8
argument_list|(
name|b
argument_list|,
literal|1
argument_list|,
name|sp
operator|->
name|comstatus
argument_list|)
expr_stmt|;
name|sp
operator|->
name|comstat
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|comstat
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|comstat
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Check to make sure that the Mth element is legal for type Elt. 	 */
if|if
condition|(
name|elm
operator|>=
name|ep
index|[
name|elt
index|]
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Starting at offset 8, start skipping over the storage 	 * for the element types we're not interested in. 	 */
for|for
control|(
name|idx
operator|=
literal|8
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|elt
condition|;
name|i
operator|++
control|)
block|{
name|idx
operator|+=
operator|(
operator|(
name|ep
index|[
name|i
index|]
operator|+
literal|1
operator|)
operator|*
literal|4
operator|)
expr_stmt|;
block|}
comment|/* 	 * Skip over Overall status for this element type. 	 */
name|idx
operator|+=
literal|4
expr_stmt|;
comment|/* 	 * And skip to the index for the Mth element that we're going for. 	 */
name|idx
operator|+=
operator|(
literal|4
operator|*
name|elm
operator|)
expr_stmt|;
comment|/* 	 * Make sure we haven't overflowed the buffer. 	 */
if|if
condition|(
name|idx
operator|+
literal|4
operator|>
name|amt
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Retrieve the status. 	 */
name|gget8
argument_list|(
name|b
argument_list|,
name|idx
operator|++
argument_list|,
name|sp
operator|->
name|comstatus
argument_list|)
expr_stmt|;
name|gget8
argument_list|(
name|b
argument_list|,
name|idx
operator|++
argument_list|,
name|sp
operator|->
name|comstat
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|gget8
argument_list|(
name|b
argument_list|,
name|idx
operator|++
argument_list|,
name|sp
operator|->
name|comstat
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|gget8
argument_list|(
name|b
argument_list|,
name|idx
operator|++
argument_list|,
name|sp
operator|->
name|comstat
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|PRINTF("Get Elt 0x%x Elm 0x%x (idx %d)\n", elt, elm, idx-4);
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is the mirror function to ses_decode, but we set the 'select'  * bit for the object which we're interested in. All other objects,  * after a status fetch, should have that bit off. Hmm. It'd be easy  * enough to ensure this, so we will.  */
end_comment

begin_function
specifier|static
name|int
name|ses_encode
parameter_list|(
name|char
modifier|*
name|b
parameter_list|,
name|int
name|amt
parameter_list|,
name|uint8_t
modifier|*
name|ep
parameter_list|,
name|int
name|elt
parameter_list|,
name|int
name|elm
parameter_list|,
name|SesComStat
modifier|*
name|sp
parameter_list|)
block|{
name|int
name|idx
decl_stmt|,
name|i
decl_stmt|;
comment|/* 	 * If it's overall enclosure status being sought, get that. 	 * We need at least 2 bytes of status data to get that. 	 */
if|if
condition|(
name|elt
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|amt
operator|<
literal|2
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|i
operator|=
literal|0
expr_stmt|;
name|sset8
argument_list|(
name|b
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sset8
argument_list|(
name|b
argument_list|,
name|i
argument_list|,
name|sp
operator|->
name|comstatus
operator|&
literal|0xf
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|PRINTF("set EncStat %x\n", sp->comstatus);
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Check to make sure that the Mth element is legal for type Elt. 	 */
if|if
condition|(
name|elm
operator|>=
name|ep
index|[
name|elt
index|]
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Starting at offset 8, start skipping over the storage 	 * for the element types we're not interested in. 	 */
for|for
control|(
name|idx
operator|=
literal|8
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|elt
condition|;
name|i
operator|++
control|)
block|{
name|idx
operator|+=
operator|(
operator|(
name|ep
index|[
name|i
index|]
operator|+
literal|1
operator|)
operator|*
literal|4
operator|)
expr_stmt|;
block|}
comment|/* 	 * Skip over Overall status for this element type. 	 */
name|idx
operator|+=
literal|4
expr_stmt|;
comment|/* 	 * And skip to the index for the Mth element that we're going for. 	 */
name|idx
operator|+=
operator|(
literal|4
operator|*
name|elm
operator|)
expr_stmt|;
comment|/* 	 * Make sure we haven't overflowed the buffer. 	 */
if|if
condition|(
name|idx
operator|+
literal|4
operator|>
name|amt
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Set the status. 	 */
name|sset8
argument_list|(
name|b
argument_list|,
name|idx
argument_list|,
name|sp
operator|->
name|comstatus
argument_list|)
expr_stmt|;
name|sset8
argument_list|(
name|b
argument_list|,
name|idx
argument_list|,
name|sp
operator|->
name|comstat
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sset8
argument_list|(
name|b
argument_list|,
name|idx
argument_list|,
name|sp
operator|->
name|comstat
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|sset8
argument_list|(
name|b
argument_list|,
name|idx
argument_list|,
name|sp
operator|->
name|comstat
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|idx
operator|-=
literal|4
expr_stmt|;
if|#
directive|if
literal|0
block|PRINTF("Set Elt 0x%x Elm 0x%x (idx %d) with %x %x %x %x\n", 	    elt, elm, idx, sp->comstatus, sp->comstat[0], 	    sp->comstat[1], sp->comstat[2]);
endif|#
directive|endif
comment|/* 	 * Now make sure all other 'Select' bits are off. 	 */
for|for
control|(
name|i
operator|=
literal|8
init|;
name|i
operator|<
name|amt
condition|;
name|i
operator|+=
literal|4
control|)
block|{
if|if
condition|(
name|i
operator|!=
name|idx
condition|)
name|b
index|[
name|i
index|]
operator|&=
operator|~
literal|0x80
expr_stmt|;
block|}
comment|/* 	 * And make sure the INVOP bit is clear. 	 */
name|b
index|[
literal|2
index|]
operator|&=
operator|~
literal|0x10
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * SAF-TE Type Device Emulation  */
end_comment

begin_function_decl
specifier|static
name|int
name|safte_getconfig
parameter_list|(
name|ses_softc_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|safte_rdstat
parameter_list|(
name|ses_softc_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|static
name|int
name|set_objstat_sel
parameter_list|(
name|ses_softc_t
modifier|*
parameter_list|,
name|ses_objstat
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wrbuf16
parameter_list|(
name|ses_softc_t
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|uint8_t
parameter_list|,
name|uint8_t
parameter_list|,
name|uint8_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wrslot_stat
parameter_list|(
name|ses_softc_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|perf_slotop
parameter_list|(
name|ses_softc_t
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|uint8_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|ALL_ENC_STAT
value|(SES_ENCSTAT_CRITICAL | SES_ENCSTAT_UNRECOV | \ 	SES_ENCSTAT_NONCRITICAL | SES_ENCSTAT_INFO)
end_define

begin_comment
comment|/*  * SAF-TE specific defines- Mandatory ones only...  */
end_comment

begin_comment
comment|/*  * READ BUFFER ('get' commands) IDs- placed in offset 2 of cdb  */
end_comment

begin_define
define|#
directive|define
name|SAFTE_RD_RDCFG
value|0x00
end_define

begin_comment
comment|/* read enclosure configuration */
end_comment

begin_define
define|#
directive|define
name|SAFTE_RD_RDESTS
value|0x01
end_define

begin_comment
comment|/* read enclosure status */
end_comment

begin_define
define|#
directive|define
name|SAFTE_RD_RDDSTS
value|0x04
end_define

begin_comment
comment|/* read drive slot status */
end_comment

begin_comment
comment|/*  * WRITE BUFFER ('set' commands) IDs- placed in offset 0 of databuf  */
end_comment

begin_define
define|#
directive|define
name|SAFTE_WT_DSTAT
value|0x10
end_define

begin_comment
comment|/* write device slot status */
end_comment

begin_define
define|#
directive|define
name|SAFTE_WT_SLTOP
value|0x12
end_define

begin_comment
comment|/* perform slot operation */
end_comment

begin_define
define|#
directive|define
name|SAFTE_WT_FANSPD
value|0x13
end_define

begin_comment
comment|/* set fan speed */
end_comment

begin_define
define|#
directive|define
name|SAFTE_WT_ACTPWS
value|0x14
end_define

begin_comment
comment|/* turn on/off power supply */
end_comment

begin_define
define|#
directive|define
name|SAFTE_WT_GLOBAL
value|0x15
end_define

begin_comment
comment|/* send global command */
end_comment

begin_define
define|#
directive|define
name|SAFT_SCRATCH
value|64
end_define

begin_define
define|#
directive|define
name|NPSEUDO_THERM
value|16
end_define

begin_define
define|#
directive|define
name|NPSEUDO_ALARM
value|1
end_define

begin_struct
struct|struct
name|scfg
block|{
comment|/* 	 * Cached Configuration 	 */
name|uint8_t
name|Nfans
decl_stmt|;
comment|/* Number of Fans */
name|uint8_t
name|Npwr
decl_stmt|;
comment|/* Number of Power Supplies */
name|uint8_t
name|Nslots
decl_stmt|;
comment|/* Number of Device Slots */
name|uint8_t
name|DoorLock
decl_stmt|;
comment|/* Door Lock Installed */
name|uint8_t
name|Ntherm
decl_stmt|;
comment|/* Number of Temperature Sensors */
name|uint8_t
name|Nspkrs
decl_stmt|;
comment|/* Number of Speakers */
name|uint8_t
name|Nalarm
decl_stmt|;
comment|/* Number of Alarms (at least one) */
comment|/* 	 * Cached Flag Bytes for Global Status 	 */
name|uint8_t
name|flag1
decl_stmt|;
name|uint8_t
name|flag2
decl_stmt|;
comment|/* 	 * What object index ID is where various slots start. 	 */
name|uint8_t
name|pwroff
decl_stmt|;
name|uint8_t
name|slotoff
decl_stmt|;
define|#
directive|define
name|SAFT_ALARM_OFFSET
parameter_list|(
name|cc
parameter_list|)
value|(cc)->slotoff - 1
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|SAFT_FLG1_ALARM
value|0x1
end_define

begin_define
define|#
directive|define
name|SAFT_FLG1_GLOBFAIL
value|0x2
end_define

begin_define
define|#
directive|define
name|SAFT_FLG1_GLOBWARN
value|0x4
end_define

begin_define
define|#
directive|define
name|SAFT_FLG1_ENCPWROFF
value|0x8
end_define

begin_define
define|#
directive|define
name|SAFT_FLG1_ENCFANFAIL
value|0x10
end_define

begin_define
define|#
directive|define
name|SAFT_FLG1_ENCPWRFAIL
value|0x20
end_define

begin_define
define|#
directive|define
name|SAFT_FLG1_ENCDRVFAIL
value|0x40
end_define

begin_define
define|#
directive|define
name|SAFT_FLG1_ENCDRVWARN
value|0x80
end_define

begin_define
define|#
directive|define
name|SAFT_FLG2_LOCKDOOR
value|0x4
end_define

begin_define
define|#
directive|define
name|SAFT_PRIVATE
value|sizeof (struct scfg)
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|safte_2little
init|=
literal|"Too Little Data Returned (%d) at line %d\n"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SAFT_BAIL
parameter_list|(
name|r
parameter_list|,
name|x
parameter_list|,
name|k
parameter_list|,
name|l
parameter_list|)
define|\
value|if (r>= x) { \ 		SES_LOG(ssc, safte_2little, x, __LINE__);\ 		SES_FREE(k, l); \ 		return (EIO); \ 	}
end_define

begin_function
name|int
name|safte_softc_init
parameter_list|(
name|ses_softc_t
modifier|*
name|ssc
parameter_list|,
name|int
name|doinit
parameter_list|)
block|{
name|int
name|err
decl_stmt|,
name|i
decl_stmt|,
name|r
decl_stmt|;
name|struct
name|scfg
modifier|*
name|cc
decl_stmt|;
if|if
condition|(
name|doinit
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ssc
operator|->
name|ses_nobjects
condition|)
block|{
if|if
condition|(
name|ssc
operator|->
name|ses_objmap
condition|)
block|{
name|SES_FREE
argument_list|(
name|ssc
operator|->
name|ses_objmap
argument_list|,
name|ssc
operator|->
name|ses_nobjects
operator|*
sizeof|sizeof
argument_list|(
name|encobj
argument_list|)
argument_list|)
expr_stmt|;
name|ssc
operator|->
name|ses_objmap
operator|=
name|NULL
expr_stmt|;
block|}
name|ssc
operator|->
name|ses_nobjects
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ssc
operator|->
name|ses_private
condition|)
block|{
name|SES_FREE
argument_list|(
name|ssc
operator|->
name|ses_private
argument_list|,
name|SAFT_PRIVATE
argument_list|)
expr_stmt|;
name|ssc
operator|->
name|ses_private
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|ssc
operator|->
name|ses_private
operator|==
name|NULL
condition|)
block|{
name|ssc
operator|->
name|ses_private
operator|=
name|SES_MALLOC
argument_list|(
name|SAFT_PRIVATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssc
operator|->
name|ses_private
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|MEMZERO
argument_list|(
name|ssc
operator|->
name|ses_private
argument_list|,
name|SAFT_PRIVATE
argument_list|)
expr_stmt|;
block|}
name|ssc
operator|->
name|ses_nobjects
operator|=
literal|0
expr_stmt|;
name|ssc
operator|->
name|ses_encstat
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|safte_getconfig
argument_list|(
name|ssc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/* 	 * The number of objects here, as well as that reported by the 	 * READ_BUFFER/GET_CONFIG call, are the over-temperature flags (15) 	 * that get reported during READ_BUFFER/READ_ENC_STATUS. 	 */
name|cc
operator|=
name|ssc
operator|->
name|ses_private
expr_stmt|;
name|ssc
operator|->
name|ses_nobjects
operator|=
name|cc
operator|->
name|Nfans
operator|+
name|cc
operator|->
name|Npwr
operator|+
name|cc
operator|->
name|Nslots
operator|+
name|cc
operator|->
name|DoorLock
operator|+
name|cc
operator|->
name|Ntherm
operator|+
name|cc
operator|->
name|Nspkrs
operator|+
name|NPSEUDO_THERM
operator|+
name|NPSEUDO_ALARM
expr_stmt|;
name|ssc
operator|->
name|ses_objmap
operator|=
operator|(
name|encobj
operator|*
operator|)
name|SES_MALLOC
argument_list|(
name|ssc
operator|->
name|ses_nobjects
operator|*
sizeof|sizeof
argument_list|(
name|encobj
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssc
operator|->
name|ses_objmap
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|MEMZERO
argument_list|(
name|ssc
operator|->
name|ses_objmap
argument_list|,
name|ssc
operator|->
name|ses_nobjects
operator|*
sizeof|sizeof
argument_list|(
name|encobj
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Note that this is all arranged for the convenience 	 * in later fetches of status. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cc
operator|->
name|Nfans
condition|;
name|i
operator|++
control|)
name|ssc
operator|->
name|ses_objmap
index|[
name|r
operator|++
index|]
operator|.
name|enctype
operator|=
name|SESTYP_FAN
expr_stmt|;
name|cc
operator|->
name|pwroff
operator|=
operator|(
name|uint8_t
operator|)
name|r
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cc
operator|->
name|Npwr
condition|;
name|i
operator|++
control|)
name|ssc
operator|->
name|ses_objmap
index|[
name|r
operator|++
index|]
operator|.
name|enctype
operator|=
name|SESTYP_POWER
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cc
operator|->
name|DoorLock
condition|;
name|i
operator|++
control|)
name|ssc
operator|->
name|ses_objmap
index|[
name|r
operator|++
index|]
operator|.
name|enctype
operator|=
name|SESTYP_DOORLOCK
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cc
operator|->
name|Nspkrs
condition|;
name|i
operator|++
control|)
name|ssc
operator|->
name|ses_objmap
index|[
name|r
operator|++
index|]
operator|.
name|enctype
operator|=
name|SESTYP_ALARM
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cc
operator|->
name|Ntherm
condition|;
name|i
operator|++
control|)
name|ssc
operator|->
name|ses_objmap
index|[
name|r
operator|++
index|]
operator|.
name|enctype
operator|=
name|SESTYP_THERM
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NPSEUDO_THERM
condition|;
name|i
operator|++
control|)
name|ssc
operator|->
name|ses_objmap
index|[
name|r
operator|++
index|]
operator|.
name|enctype
operator|=
name|SESTYP_THERM
expr_stmt|;
name|ssc
operator|->
name|ses_objmap
index|[
name|r
operator|++
index|]
operator|.
name|enctype
operator|=
name|SESTYP_ALARM
expr_stmt|;
name|cc
operator|->
name|slotoff
operator|=
operator|(
name|uint8_t
operator|)
name|r
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cc
operator|->
name|Nslots
condition|;
name|i
operator|++
control|)
name|ssc
operator|->
name|ses_objmap
index|[
name|r
operator|++
index|]
operator|.
name|enctype
operator|=
name|SESTYP_DEVICE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|safte_init_enc
parameter_list|(
name|ses_softc_t
modifier|*
name|ssc
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
specifier|static
name|char
name|cdb0
index|[
literal|6
index|]
init|=
block|{
name|SEND_DIAGNOSTIC
block|}
decl_stmt|;
name|err
operator|=
name|ses_runcmd
argument_list|(
name|ssc
argument_list|,
name|cdb0
argument_list|,
literal|6
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
return|return
operator|(
name|err
operator|)
return|;
block|}
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
name|err
operator|=
name|wrbuf16
argument_list|(
name|ssc
argument_list|,
name|SAFTE_WT_GLOBAL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|safte_get_encstat
parameter_list|(
name|ses_softc_t
modifier|*
name|ssc
parameter_list|,
name|int
name|slpflg
parameter_list|)
block|{
return|return
operator|(
name|safte_rdstat
argument_list|(
name|ssc
argument_list|,
name|slpflg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|safte_set_encstat
parameter_list|(
name|ses_softc_t
modifier|*
name|ssc
parameter_list|,
name|uint8_t
name|encstat
parameter_list|,
name|int
name|slpflg
parameter_list|)
block|{
name|struct
name|scfg
modifier|*
name|cc
init|=
name|ssc
operator|->
name|ses_private
decl_stmt|;
if|if
condition|(
name|cc
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Since SAF-TE devices aren't necessarily sticky in terms 	 * of state, make our soft copy of enclosure status 'sticky'- 	 * that is, things set in enclosure status stay set (as implied 	 * by conditions set in reading object status) until cleared. 	 */
name|ssc
operator|->
name|ses_encstat
operator|&=
operator|~
name|ALL_ENC_STAT
expr_stmt|;
name|ssc
operator|->
name|ses_encstat
operator||=
operator|(
name|encstat
operator|&
name|ALL_ENC_STAT
operator|)
expr_stmt|;
name|ssc
operator|->
name|ses_encstat
operator||=
name|ENCI_SVALID
expr_stmt|;
name|cc
operator|->
name|flag1
operator|&=
operator|~
operator|(
name|SAFT_FLG1_ALARM
operator||
name|SAFT_FLG1_GLOBFAIL
operator||
name|SAFT_FLG1_GLOBWARN
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|encstat
operator|&
operator|(
name|SES_ENCSTAT_CRITICAL
operator||
name|SES_ENCSTAT_UNRECOV
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|cc
operator|->
name|flag1
operator||=
name|SAFT_FLG1_ALARM
operator||
name|SAFT_FLG1_GLOBFAIL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|encstat
operator|&
name|SES_ENCSTAT_NONCRITICAL
operator|)
operator|!=
literal|0
condition|)
block|{
name|cc
operator|->
name|flag1
operator||=
name|SAFT_FLG1_GLOBWARN
expr_stmt|;
block|}
return|return
operator|(
name|wrbuf16
argument_list|(
name|ssc
argument_list|,
name|SAFTE_WT_GLOBAL
argument_list|,
name|cc
operator|->
name|flag1
argument_list|,
name|cc
operator|->
name|flag2
argument_list|,
literal|0
argument_list|,
name|slpflg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|safte_get_objstat
parameter_list|(
name|ses_softc_t
modifier|*
name|ssc
parameter_list|,
name|ses_objstat
modifier|*
name|obp
parameter_list|,
name|int
name|slpflg
parameter_list|)
block|{
name|int
name|i
init|=
operator|(
name|int
operator|)
name|obp
operator|->
name|obj_id
decl_stmt|;
if|if
condition|(
operator|(
name|ssc
operator|->
name|ses_encstat
operator|&
name|ENCI_SVALID
operator|)
operator|==
literal|0
operator|||
operator|(
name|ssc
operator|->
name|ses_objmap
index|[
name|i
index|]
operator|.
name|svalid
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|err
init|=
name|safte_rdstat
argument_list|(
name|ssc
argument_list|,
name|slpflg
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
block|}
name|obp
operator|->
name|cstat
index|[
literal|0
index|]
operator|=
name|ssc
operator|->
name|ses_objmap
index|[
name|i
index|]
operator|.
name|encstat
index|[
literal|0
index|]
expr_stmt|;
name|obp
operator|->
name|cstat
index|[
literal|1
index|]
operator|=
name|ssc
operator|->
name|ses_objmap
index|[
name|i
index|]
operator|.
name|encstat
index|[
literal|1
index|]
expr_stmt|;
name|obp
operator|->
name|cstat
index|[
literal|2
index|]
operator|=
name|ssc
operator|->
name|ses_objmap
index|[
name|i
index|]
operator|.
name|encstat
index|[
literal|2
index|]
expr_stmt|;
name|obp
operator|->
name|cstat
index|[
literal|3
index|]
operator|=
name|ssc
operator|->
name|ses_objmap
index|[
name|i
index|]
operator|.
name|encstat
index|[
literal|3
index|]
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|safte_set_objstat
parameter_list|(
name|ses_softc_t
modifier|*
name|ssc
parameter_list|,
name|ses_objstat
modifier|*
name|obp
parameter_list|,
name|int
name|slp
parameter_list|)
block|{
name|int
name|idx
decl_stmt|,
name|err
decl_stmt|;
name|encobj
modifier|*
name|ep
decl_stmt|;
name|struct
name|scfg
modifier|*
name|cc
decl_stmt|;
name|SES_DLOG
argument_list|(
name|ssc
argument_list|,
literal|"safte_set_objstat(%d): %x %x %x %x\n"
argument_list|,
operator|(
name|int
operator|)
name|obp
operator|->
name|obj_id
argument_list|,
name|obp
operator|->
name|cstat
index|[
literal|0
index|]
argument_list|,
name|obp
operator|->
name|cstat
index|[
literal|1
index|]
argument_list|,
name|obp
operator|->
name|cstat
index|[
literal|2
index|]
argument_list|,
name|obp
operator|->
name|cstat
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * If this is clear, we don't do diddly. 	 */
if|if
condition|(
operator|(
name|obp
operator|->
name|cstat
index|[
literal|0
index|]
operator|&
name|SESCTL_CSEL
operator|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|err
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Check to see if the common bits are set and do them first. 	 */
if|if
condition|(
name|obp
operator|->
name|cstat
index|[
literal|0
index|]
operator|&
operator|~
name|SESCTL_CSEL
condition|)
block|{
name|err
operator|=
name|set_objstat_sel
argument_list|(
name|ssc
argument_list|,
name|obp
argument_list|,
name|slp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
block|}
name|cc
operator|=
name|ssc
operator|->
name|ses_private
expr_stmt|;
if|if
condition|(
name|cc
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|idx
operator|=
operator|(
name|int
operator|)
name|obp
operator|->
name|obj_id
expr_stmt|;
name|ep
operator|=
operator|&
name|ssc
operator|->
name|ses_objmap
index|[
name|idx
index|]
expr_stmt|;
switch|switch
condition|(
name|ep
operator|->
name|enctype
condition|)
block|{
case|case
name|SESTYP_DEVICE
case|:
block|{
name|uint8_t
name|slotop
init|=
literal|0
decl_stmt|;
comment|/* 		 * XXX: I should probably cache the previous state 		 * XXX: of SESCTL_DEVOFF so that when it goes from 		 * XXX: true to false I can then set PREPARE FOR OPERATION 		 * XXX: flag in PERFORM SLOT OPERATION write buffer command. 		 */
if|if
condition|(
name|obp
operator|->
name|cstat
index|[
literal|2
index|]
operator|&
operator|(
name|SESCTL_RQSINS
operator||
name|SESCTL_RQSRMV
operator|)
condition|)
block|{
name|slotop
operator||=
literal|0x2
expr_stmt|;
block|}
if|if
condition|(
name|obp
operator|->
name|cstat
index|[
literal|2
index|]
operator|&
name|SESCTL_RQSID
condition|)
block|{
name|slotop
operator||=
literal|0x4
expr_stmt|;
block|}
name|err
operator|=
name|perf_slotop
argument_list|(
name|ssc
argument_list|,
operator|(
name|uint8_t
operator|)
name|idx
operator|-
operator|(
name|uint8_t
operator|)
name|cc
operator|->
name|slotoff
argument_list|,
name|slotop
argument_list|,
name|slp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|obp
operator|->
name|cstat
index|[
literal|3
index|]
operator|&
name|SESCTL_RQSFLT
condition|)
block|{
name|ep
operator|->
name|priv
operator||=
literal|0x2
expr_stmt|;
block|}
else|else
block|{
name|ep
operator|->
name|priv
operator|&=
operator|~
literal|0x2
expr_stmt|;
block|}
if|if
condition|(
name|ep
operator|->
name|priv
operator|&
literal|0xc6
condition|)
block|{
name|ep
operator|->
name|priv
operator|&=
operator|~
literal|0x1
expr_stmt|;
block|}
else|else
block|{
name|ep
operator|->
name|priv
operator||=
literal|0x1
expr_stmt|;
comment|/* no errors */
block|}
name|wrslot_stat
argument_list|(
name|ssc
argument_list|,
name|slp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SESTYP_POWER
case|:
if|if
condition|(
name|obp
operator|->
name|cstat
index|[
literal|3
index|]
operator|&
name|SESCTL_RQSTFAIL
condition|)
block|{
name|cc
operator|->
name|flag1
operator||=
name|SAFT_FLG1_ENCPWRFAIL
expr_stmt|;
block|}
else|else
block|{
name|cc
operator|->
name|flag1
operator|&=
operator|~
name|SAFT_FLG1_ENCPWRFAIL
expr_stmt|;
block|}
name|err
operator|=
name|wrbuf16
argument_list|(
name|ssc
argument_list|,
name|SAFTE_WT_GLOBAL
argument_list|,
name|cc
operator|->
name|flag1
argument_list|,
name|cc
operator|->
name|flag2
argument_list|,
literal|0
argument_list|,
name|slp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|obp
operator|->
name|cstat
index|[
literal|3
index|]
operator|&
name|SESCTL_RQSTON
condition|)
block|{
operator|(
name|void
operator|)
name|wrbuf16
argument_list|(
name|ssc
argument_list|,
name|SAFTE_WT_ACTPWS
argument_list|,
name|idx
operator|-
name|cc
operator|->
name|pwroff
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|slp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|wrbuf16
argument_list|(
name|ssc
argument_list|,
name|SAFTE_WT_ACTPWS
argument_list|,
name|idx
operator|-
name|cc
operator|->
name|pwroff
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|slp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SESTYP_FAN
case|:
if|if
condition|(
name|obp
operator|->
name|cstat
index|[
literal|3
index|]
operator|&
name|SESCTL_RQSTFAIL
condition|)
block|{
name|cc
operator|->
name|flag1
operator||=
name|SAFT_FLG1_ENCFANFAIL
expr_stmt|;
block|}
else|else
block|{
name|cc
operator|->
name|flag1
operator|&=
operator|~
name|SAFT_FLG1_ENCFANFAIL
expr_stmt|;
block|}
name|err
operator|=
name|wrbuf16
argument_list|(
name|ssc
argument_list|,
name|SAFTE_WT_GLOBAL
argument_list|,
name|cc
operator|->
name|flag1
argument_list|,
name|cc
operator|->
name|flag2
argument_list|,
literal|0
argument_list|,
name|slp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|obp
operator|->
name|cstat
index|[
literal|3
index|]
operator|&
name|SESCTL_RQSTON
condition|)
block|{
name|uint8_t
name|fsp
decl_stmt|;
if|if
condition|(
operator|(
name|obp
operator|->
name|cstat
index|[
literal|3
index|]
operator|&
literal|0x7
operator|)
operator|==
literal|7
condition|)
block|{
name|fsp
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|obp
operator|->
name|cstat
index|[
literal|3
index|]
operator|&
literal|0x7
operator|)
operator|==
literal|6
condition|)
block|{
name|fsp
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|obp
operator|->
name|cstat
index|[
literal|3
index|]
operator|&
literal|0x7
operator|)
operator|==
literal|4
condition|)
block|{
name|fsp
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|fsp
operator|=
literal|1
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|wrbuf16
argument_list|(
name|ssc
argument_list|,
name|SAFTE_WT_FANSPD
argument_list|,
name|idx
argument_list|,
name|fsp
argument_list|,
literal|0
argument_list|,
name|slp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|wrbuf16
argument_list|(
name|ssc
argument_list|,
name|SAFTE_WT_FANSPD
argument_list|,
name|idx
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|slp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SESTYP_DOORLOCK
case|:
if|if
condition|(
name|obp
operator|->
name|cstat
index|[
literal|3
index|]
operator|&
literal|0x1
condition|)
block|{
name|cc
operator|->
name|flag2
operator|&=
operator|~
name|SAFT_FLG2_LOCKDOOR
expr_stmt|;
block|}
else|else
block|{
name|cc
operator|->
name|flag2
operator||=
name|SAFT_FLG2_LOCKDOOR
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|wrbuf16
argument_list|(
name|ssc
argument_list|,
name|SAFTE_WT_GLOBAL
argument_list|,
name|cc
operator|->
name|flag1
argument_list|,
name|cc
operator|->
name|flag2
argument_list|,
literal|0
argument_list|,
name|slp
argument_list|)
expr_stmt|;
break|break;
case|case
name|SESTYP_ALARM
case|:
comment|/* 		 * On all nonzero but the 'muted' bit, we turn on the alarm, 		 */
name|obp
operator|->
name|cstat
index|[
literal|3
index|]
operator|&=
operator|~
literal|0xa
expr_stmt|;
if|if
condition|(
name|obp
operator|->
name|cstat
index|[
literal|3
index|]
operator|&
literal|0x40
condition|)
block|{
name|cc
operator|->
name|flag2
operator|&=
operator|~
name|SAFT_FLG1_ALARM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|obp
operator|->
name|cstat
index|[
literal|3
index|]
operator|!=
literal|0
condition|)
block|{
name|cc
operator|->
name|flag2
operator||=
name|SAFT_FLG1_ALARM
expr_stmt|;
block|}
else|else
block|{
name|cc
operator|->
name|flag2
operator|&=
operator|~
name|SAFT_FLG1_ALARM
expr_stmt|;
block|}
name|ep
operator|->
name|priv
operator|=
name|obp
operator|->
name|cstat
index|[
literal|3
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|wrbuf16
argument_list|(
name|ssc
argument_list|,
name|SAFTE_WT_GLOBAL
argument_list|,
name|cc
operator|->
name|flag1
argument_list|,
name|cc
operator|->
name|flag2
argument_list|,
literal|0
argument_list|,
name|slp
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|ep
operator|->
name|svalid
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|safte_getconfig
parameter_list|(
name|ses_softc_t
modifier|*
name|ssc
parameter_list|)
block|{
name|struct
name|scfg
modifier|*
name|cfg
decl_stmt|;
name|int
name|err
decl_stmt|,
name|amt
decl_stmt|;
name|char
modifier|*
name|sdata
decl_stmt|;
specifier|static
name|char
name|cdb
index|[
literal|10
index|]
init|=
block|{
name|READ_BUFFER
block|,
literal|1
block|,
name|SAFTE_RD_RDCFG
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SAFT_SCRATCH
block|,
literal|0
block|}
decl_stmt|;
name|cfg
operator|=
name|ssc
operator|->
name|ses_private
expr_stmt|;
if|if
condition|(
name|cfg
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|sdata
operator|=
name|SES_MALLOC
argument_list|(
name|SAFT_SCRATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdata
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|amt
operator|=
name|SAFT_SCRATCH
expr_stmt|;
name|err
operator|=
name|ses_runcmd
argument_list|(
name|ssc
argument_list|,
name|cdb
argument_list|,
literal|10
argument_list|,
name|sdata
argument_list|,
operator|&
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|SES_FREE
argument_list|(
name|sdata
argument_list|,
name|SAFT_SCRATCH
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|amt
operator|=
name|SAFT_SCRATCH
operator|-
name|amt
expr_stmt|;
if|if
condition|(
name|amt
operator|<
literal|6
condition|)
block|{
name|SES_LOG
argument_list|(
name|ssc
argument_list|,
literal|"too little data (%d) for configuration\n"
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|SES_FREE
argument_list|(
name|sdata
argument_list|,
name|SAFT_SCRATCH
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|SES_VLOG
argument_list|(
name|ssc
argument_list|,
literal|"Nfans %d Npwr %d Nslots %d Lck %d Ntherm %d Nspkrs %d\n"
argument_list|,
name|sdata
index|[
literal|0
index|]
argument_list|,
name|sdata
index|[
literal|1
index|]
argument_list|,
name|sdata
index|[
literal|2
index|]
argument_list|,
name|sdata
index|[
literal|3
index|]
argument_list|,
name|sdata
index|[
literal|4
index|]
argument_list|,
name|sdata
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|Nfans
operator|=
name|sdata
index|[
literal|0
index|]
expr_stmt|;
name|cfg
operator|->
name|Npwr
operator|=
name|sdata
index|[
literal|1
index|]
expr_stmt|;
name|cfg
operator|->
name|Nslots
operator|=
name|sdata
index|[
literal|2
index|]
expr_stmt|;
name|cfg
operator|->
name|DoorLock
operator|=
name|sdata
index|[
literal|3
index|]
expr_stmt|;
name|cfg
operator|->
name|Ntherm
operator|=
name|sdata
index|[
literal|4
index|]
expr_stmt|;
name|cfg
operator|->
name|Nspkrs
operator|=
name|sdata
index|[
literal|5
index|]
expr_stmt|;
name|cfg
operator|->
name|Nalarm
operator|=
name|NPSEUDO_ALARM
expr_stmt|;
name|SES_FREE
argument_list|(
name|sdata
argument_list|,
name|SAFT_SCRATCH
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|safte_rdstat
parameter_list|(
name|ses_softc_t
modifier|*
name|ssc
parameter_list|,
name|int
name|slpflg
parameter_list|)
block|{
name|int
name|err
decl_stmt|,
name|oid
decl_stmt|,
name|r
decl_stmt|,
name|i
decl_stmt|,
name|hiwater
decl_stmt|,
name|nitems
decl_stmt|,
name|amt
decl_stmt|;
name|uint16_t
name|tempflags
decl_stmt|;
name|size_t
name|buflen
decl_stmt|;
name|uint8_t
name|status
decl_stmt|,
name|oencstat
decl_stmt|;
name|char
modifier|*
name|sdata
decl_stmt|,
name|cdb
index|[
literal|10
index|]
decl_stmt|;
name|struct
name|scfg
modifier|*
name|cc
init|=
name|ssc
operator|->
name|ses_private
decl_stmt|;
comment|/* 	 * The number of objects overstates things a bit, 	 * both for the bogus 'thermometer' entries and 	 * the drive status (which isn't read at the same 	 * time as the enclosure status), but that's okay. 	 */
name|buflen
operator|=
literal|4
operator|*
name|cc
operator|->
name|Nslots
expr_stmt|;
if|if
condition|(
name|ssc
operator|->
name|ses_nobjects
operator|>
name|buflen
condition|)
name|buflen
operator|=
name|ssc
operator|->
name|ses_nobjects
expr_stmt|;
name|sdata
operator|=
name|SES_MALLOC
argument_list|(
name|buflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdata
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|cdb
index|[
literal|0
index|]
operator|=
name|READ_BUFFER
expr_stmt|;
name|cdb
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|cdb
index|[
literal|2
index|]
operator|=
name|SAFTE_RD_RDESTS
expr_stmt|;
name|cdb
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|cdb
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|cdb
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
name|cdb
index|[
literal|6
index|]
operator|=
literal|0
expr_stmt|;
name|cdb
index|[
literal|7
index|]
operator|=
operator|(
name|buflen
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|cdb
index|[
literal|8
index|]
operator|=
name|buflen
operator|&
literal|0xff
expr_stmt|;
name|cdb
index|[
literal|9
index|]
operator|=
literal|0
expr_stmt|;
name|amt
operator|=
name|buflen
expr_stmt|;
name|err
operator|=
name|ses_runcmd
argument_list|(
name|ssc
argument_list|,
name|cdb
argument_list|,
literal|10
argument_list|,
name|sdata
argument_list|,
operator|&
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|SES_FREE
argument_list|(
name|sdata
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|hiwater
operator|=
name|buflen
operator|-
name|amt
expr_stmt|;
comment|/* 	 * invalidate all status bits. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ssc
operator|->
name|ses_nobjects
condition|;
name|i
operator|++
control|)
name|ssc
operator|->
name|ses_objmap
index|[
name|i
index|]
operator|.
name|svalid
operator|=
literal|0
expr_stmt|;
name|oencstat
operator|=
name|ssc
operator|->
name|ses_encstat
operator|&
name|ALL_ENC_STAT
expr_stmt|;
name|ssc
operator|->
name|ses_encstat
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Now parse returned buffer. 	 * If we didn't get enough data back, 	 * that's considered a fatal error. 	 */
name|oid
operator|=
name|r
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|nitems
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cc
operator|->
name|Nfans
condition|;
name|i
operator|++
control|)
block|{
name|SAFT_BAIL
argument_list|(
name|r
argument_list|,
name|hiwater
argument_list|,
name|sdata
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
comment|/* 		 * 0 = Fan Operational 		 * 1 = Fan is malfunctioning 		 * 2 = Fan is not present 		 * 0x80 = Unknown or Not Reportable Status 		 */
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* resvd */
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
comment|/* resvd */
switch|switch
condition|(
operator|(
name|int
operator|)
operator|(
name|uint8_t
operator|)
name|sdata
index|[
name|r
index|]
condition|)
block|{
case|case
literal|0
case|:
name|nitems
operator|++
expr_stmt|;
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|0
index|]
operator|=
name|SES_OBJSTAT_OK
expr_stmt|;
comment|/* 			 * We could get fancier and cache 			 * fan speeds that we have set, but 			 * that isn't done now. 			 */
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|3
index|]
operator|=
literal|7
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|0
index|]
operator|=
name|SES_OBJSTAT_CRIT
expr_stmt|;
comment|/* 			 * FAIL and FAN STOPPED synthesized 			 */
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|3
index|]
operator|=
literal|0x40
expr_stmt|;
comment|/* 			 * Enclosure marked with CRITICAL error 			 * if only one fan or no thermometers, 			 * else the NONCRITICAL error is set. 			 */
if|if
condition|(
name|cc
operator|->
name|Nfans
operator|==
literal|1
operator|||
name|cc
operator|->
name|Ntherm
operator|==
literal|0
condition|)
name|ssc
operator|->
name|ses_encstat
operator||=
name|SES_ENCSTAT_CRITICAL
expr_stmt|;
else|else
name|ssc
operator|->
name|ses_encstat
operator||=
name|SES_ENCSTAT_NONCRITICAL
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|0
index|]
operator|=
name|SES_OBJSTAT_NOTINSTALLED
expr_stmt|;
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 			 * Enclosure marked with CRITICAL error 			 * if only one fan or no thermometers, 			 * else the NONCRITICAL error is set. 			 */
if|if
condition|(
name|cc
operator|->
name|Nfans
operator|==
literal|1
condition|)
name|ssc
operator|->
name|ses_encstat
operator||=
name|SES_ENCSTAT_CRITICAL
expr_stmt|;
else|else
name|ssc
operator|->
name|ses_encstat
operator||=
name|SES_ENCSTAT_NONCRITICAL
expr_stmt|;
break|break;
case|case
literal|0x80
case|:
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|0
index|]
operator|=
name|SES_OBJSTAT_UNKNOWN
expr_stmt|;
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|ssc
operator|->
name|ses_encstat
operator||=
name|SES_ENCSTAT_INFO
expr_stmt|;
break|break;
default|default:
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|0
index|]
operator|=
name|SES_OBJSTAT_UNSUPPORTED
expr_stmt|;
name|SES_LOG
argument_list|(
name|ssc
argument_list|,
literal|"Unknown fan%d status 0x%x\n"
argument_list|,
name|i
argument_list|,
name|sdata
index|[
name|r
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
block|}
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
operator|++
index|]
operator|.
name|svalid
operator|=
literal|1
expr_stmt|;
name|r
operator|++
expr_stmt|;
block|}
comment|/* 	 * No matter how you cut it, no cooling elements when there 	 * should be some there is critical. 	 */
if|if
condition|(
name|cc
operator|->
name|Nfans
operator|&&
name|nitems
operator|==
literal|0
condition|)
block|{
name|ssc
operator|->
name|ses_encstat
operator||=
name|SES_ENCSTAT_CRITICAL
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cc
operator|->
name|Npwr
condition|;
name|i
operator|++
control|)
block|{
name|SAFT_BAIL
argument_list|(
name|r
argument_list|,
name|hiwater
argument_list|,
name|sdata
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|0
index|]
operator|=
name|SES_OBJSTAT_UNKNOWN
expr_stmt|;
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* resvd */
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
comment|/* resvd */
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|3
index|]
operator|=
literal|0x20
expr_stmt|;
comment|/* requested on */
switch|switch
condition|(
operator|(
name|uint8_t
operator|)
name|sdata
index|[
name|r
index|]
condition|)
block|{
case|case
literal|0x00
case|:
comment|/* pws operational and on */
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|0
index|]
operator|=
name|SES_OBJSTAT_OK
expr_stmt|;
break|break;
case|case
literal|0x01
case|:
comment|/* pws operational and off */
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|0
index|]
operator|=
name|SES_OBJSTAT_OK
expr_stmt|;
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|3
index|]
operator|=
literal|0x10
expr_stmt|;
name|ssc
operator|->
name|ses_encstat
operator||=
name|SES_ENCSTAT_INFO
expr_stmt|;
break|break;
case|case
literal|0x10
case|:
comment|/* pws is malfunctioning and commanded on */
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|0
index|]
operator|=
name|SES_OBJSTAT_CRIT
expr_stmt|;
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|3
index|]
operator|=
literal|0x61
expr_stmt|;
name|ssc
operator|->
name|ses_encstat
operator||=
name|SES_ENCSTAT_NONCRITICAL
expr_stmt|;
break|break;
case|case
literal|0x11
case|:
comment|/* pws is malfunctioning and commanded off */
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|0
index|]
operator|=
name|SES_OBJSTAT_NONCRIT
expr_stmt|;
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|3
index|]
operator|=
literal|0x51
expr_stmt|;
name|ssc
operator|->
name|ses_encstat
operator||=
name|SES_ENCSTAT_NONCRITICAL
expr_stmt|;
break|break;
case|case
literal|0x20
case|:
comment|/* pws is not present */
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|0
index|]
operator|=
name|SES_OBJSTAT_NOTINSTALLED
expr_stmt|;
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|ssc
operator|->
name|ses_encstat
operator||=
name|SES_ENCSTAT_INFO
expr_stmt|;
break|break;
case|case
literal|0x21
case|:
comment|/* pws is present */
comment|/* 			 * This is for enclosures that cannot tell whether the 			 * device is on or malfunctioning, but know that it is 			 * present. Just fall through. 			 */
comment|/* FALLTHROUGH */
case|case
literal|0x80
case|:
comment|/* Unknown or Not Reportable Status */
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|0
index|]
operator|=
name|SES_OBJSTAT_UNKNOWN
expr_stmt|;
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|ssc
operator|->
name|ses_encstat
operator||=
name|SES_ENCSTAT_INFO
expr_stmt|;
break|break;
default|default:
name|SES_LOG
argument_list|(
name|ssc
argument_list|,
literal|"unknown power supply %d status (0x%x)\n"
argument_list|,
name|i
argument_list|,
name|sdata
index|[
name|r
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
block|}
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
operator|++
index|]
operator|.
name|svalid
operator|=
literal|1
expr_stmt|;
name|r
operator|++
expr_stmt|;
block|}
comment|/* 	 * Skip over Slot SCSI IDs 	 */
name|r
operator|+=
name|cc
operator|->
name|Nslots
expr_stmt|;
comment|/* 	 * We always have doorlock status, no matter what, 	 * but we only save the status if we have one. 	 */
name|SAFT_BAIL
argument_list|(
name|r
argument_list|,
name|hiwater
argument_list|,
name|sdata
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|->
name|DoorLock
condition|)
block|{
comment|/* 		 * 0 = Door Locked 		 * 1 = Door Unlocked, or no Lock Installed 		 * 0x80 = Unknown or Not Reportable Status 		 */
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
operator|(
name|uint8_t
operator|)
name|sdata
index|[
name|r
index|]
condition|)
block|{
case|case
literal|0
case|:
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|0
index|]
operator|=
name|SES_OBJSTAT_OK
expr_stmt|;
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|0
index|]
operator|=
name|SES_OBJSTAT_OK
expr_stmt|;
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|3
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|0x80
case|:
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|0
index|]
operator|=
name|SES_OBJSTAT_UNKNOWN
expr_stmt|;
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|ssc
operator|->
name|ses_encstat
operator||=
name|SES_ENCSTAT_INFO
expr_stmt|;
break|break;
default|default:
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|0
index|]
operator|=
name|SES_OBJSTAT_UNSUPPORTED
expr_stmt|;
name|SES_LOG
argument_list|(
name|ssc
argument_list|,
literal|"unknown lock status 0x%x\n"
argument_list|,
name|sdata
index|[
name|r
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
block|}
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
operator|++
index|]
operator|.
name|svalid
operator|=
literal|1
expr_stmt|;
block|}
name|r
operator|++
expr_stmt|;
comment|/* 	 * We always have speaker status, no matter what, 	 * but we only save the status if we have one. 	 */
name|SAFT_BAIL
argument_list|(
name|r
argument_list|,
name|hiwater
argument_list|,
name|sdata
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|->
name|Nspkrs
condition|)
block|{
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sdata
index|[
name|r
index|]
operator|==
literal|1
condition|)
block|{
comment|/* 			 * We need to cache tone urgency indicators. 			 * Someday. 			 */
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|0
index|]
operator|=
name|SES_OBJSTAT_NONCRIT
expr_stmt|;
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|3
index|]
operator|=
literal|0x8
expr_stmt|;
name|ssc
operator|->
name|ses_encstat
operator||=
name|SES_ENCSTAT_NONCRITICAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sdata
index|[
name|r
index|]
operator|==
literal|0
condition|)
block|{
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|0
index|]
operator|=
name|SES_OBJSTAT_OK
expr_stmt|;
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|0
index|]
operator|=
name|SES_OBJSTAT_UNSUPPORTED
expr_stmt|;
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|SES_LOG
argument_list|(
name|ssc
argument_list|,
literal|"unknown spkr status 0x%x\n"
argument_list|,
name|sdata
index|[
name|r
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
operator|++
index|]
operator|.
name|svalid
operator|=
literal|1
expr_stmt|;
block|}
name|r
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cc
operator|->
name|Ntherm
condition|;
name|i
operator|++
control|)
block|{
name|SAFT_BAIL
argument_list|(
name|r
argument_list|,
name|hiwater
argument_list|,
name|sdata
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
comment|/* 		 * Status is a range from -10 to 245 deg Celsius, 		 * which we need to normalize to -20 to -245 according 		 * to the latest SCSI spec, which makes little 		 * sense since this would overflow an 8bit value. 		 * Well, still, the base normalization is -20, 		 * not -10, so we have to adjust. 		 * 		 * So what's over and under temperature? 		 * Hmm- we'll state that 'normal' operating 		 * is 10 to 40 deg Celsius. 		 */
comment|/* 		 * Actually.... All of the units that people out in the world 		 * seem to have do not come even close to setting a value that 		 * complies with this spec. 		 * 		 * The closest explanation I could find was in an 		 * LSI-Logic manual, which seemed to indicate that 		 * this value would be set by whatever the I2C code 		 * would interpolate from the output of an LM75 		 * temperature sensor. 		 * 		 * This means that it is impossible to use the actual 		 * numeric value to predict anything. But we don't want 		 * to lose the value. So, we'll propagate the *uncorrected* 		 * value and set SES_OBJSTAT_NOTAVAIL. We'll depend on the 		 * temperature flags for warnings. 		 */
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|0
index|]
operator|=
name|SES_OBJSTAT_NOTAVAIL
expr_stmt|;
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|2
index|]
operator|=
name|sdata
index|[
name|r
index|]
expr_stmt|;
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
empty_stmt|;
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
operator|++
index|]
operator|.
name|svalid
operator|=
literal|1
expr_stmt|;
name|r
operator|++
expr_stmt|;
block|}
comment|/* 	 * Now, for "pseudo" thermometers, we have two bytes 	 * of information in enclosure status- 16 bits. Actually, 	 * the MSB is a single TEMP ALERT flag indicating whether 	 * any other bits are set, but, thanks to fuzzy thinking, 	 * in the SAF-TE spec, this can also be set even if no 	 * other bits are set, thus making this really another 	 * binary temperature sensor. 	 */
name|SAFT_BAIL
argument_list|(
name|r
argument_list|,
name|hiwater
argument_list|,
name|sdata
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
name|tempflags
operator|=
name|sdata
index|[
name|r
operator|++
index|]
expr_stmt|;
name|SAFT_BAIL
argument_list|(
name|r
argument_list|,
name|hiwater
argument_list|,
name|sdata
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
name|tempflags
operator||=
operator|(
name|tempflags
operator|<<
literal|8
operator|)
operator||
name|sdata
index|[
name|r
operator|++
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NPSEUDO_THERM
condition|;
name|i
operator|++
control|)
block|{
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tempflags
operator|&
operator|(
literal|1
operator|<<
operator|(
name|NPSEUDO_THERM
operator|-
name|i
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|0
index|]
operator|=
name|SES_OBJSTAT_CRIT
expr_stmt|;
name|ssc
operator|->
name|ses_objmap
index|[
literal|4
index|]
operator|.
name|encstat
index|[
literal|2
index|]
operator|=
literal|0xff
expr_stmt|;
comment|/* 			 * Set 'over temperature' failure. 			 */
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|3
index|]
operator|=
literal|8
expr_stmt|;
name|ssc
operator|->
name|ses_encstat
operator||=
name|SES_ENCSTAT_CRITICAL
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * We used to say 'not available' and synthesize a 			 * nominal 30 deg (C)- that was wrong. Actually, 			 * Just say 'OK', and use the reserved value of 			 * zero. 			 */
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|0
index|]
operator|=
name|SES_OBJSTAT_OK
expr_stmt|;
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
operator|++
index|]
operator|.
name|svalid
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Get alarm status. 	 */
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|0
index|]
operator|=
name|SES_OBJSTAT_OK
expr_stmt|;
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|3
index|]
operator|=
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|priv
expr_stmt|;
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
operator|++
index|]
operator|.
name|svalid
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Now get drive slot status 	 */
name|cdb
index|[
literal|2
index|]
operator|=
name|SAFTE_RD_RDDSTS
expr_stmt|;
name|amt
operator|=
name|buflen
expr_stmt|;
name|err
operator|=
name|ses_runcmd
argument_list|(
name|ssc
argument_list|,
name|cdb
argument_list|,
literal|10
argument_list|,
name|sdata
argument_list|,
operator|&
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|SES_FREE
argument_list|(
name|sdata
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|hiwater
operator|=
name|buflen
operator|-
name|amt
expr_stmt|;
for|for
control|(
name|r
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cc
operator|->
name|Nslots
condition|;
name|i
operator|++
operator|,
name|r
operator|+=
literal|4
control|)
block|{
name|SAFT_BAIL
argument_list|(
name|r
operator|+
literal|3
argument_list|,
name|hiwater
argument_list|,
name|sdata
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|0
index|]
operator|=
name|SES_OBJSTAT_UNSUPPORTED
expr_stmt|;
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|1
index|]
operator|=
operator|(
name|uint8_t
operator|)
name|i
expr_stmt|;
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|sdata
index|[
name|r
operator|+
literal|3
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
literal|0x1
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* no device */
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|0
index|]
operator|=
name|SES_OBJSTAT_NOTINSTALLED
expr_stmt|;
block|}
else|else
block|{
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|0
index|]
operator|=
name|SES_OBJSTAT_OK
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
literal|0x2
condition|)
block|{
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|2
index|]
operator|=
literal|0x8
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|status
operator|&
literal|0x4
operator|)
operator|==
literal|0
condition|)
block|{
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
index|]
operator|.
name|encstat
index|[
literal|3
index|]
operator|=
literal|0x10
expr_stmt|;
block|}
name|ssc
operator|->
name|ses_objmap
index|[
name|oid
operator|++
index|]
operator|.
name|svalid
operator|=
literal|1
expr_stmt|;
block|}
comment|/* see comment below about sticky enclosure status */
name|ssc
operator|->
name|ses_encstat
operator||=
name|ENCI_SVALID
operator||
name|oencstat
expr_stmt|;
name|SES_FREE
argument_list|(
name|sdata
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_objstat_sel
parameter_list|(
name|ses_softc_t
modifier|*
name|ssc
parameter_list|,
name|ses_objstat
modifier|*
name|obp
parameter_list|,
name|int
name|slp
parameter_list|)
block|{
name|int
name|idx
decl_stmt|;
name|encobj
modifier|*
name|ep
decl_stmt|;
name|struct
name|scfg
modifier|*
name|cc
init|=
name|ssc
operator|->
name|ses_private
decl_stmt|;
if|if
condition|(
name|cc
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|idx
operator|=
operator|(
name|int
operator|)
name|obp
operator|->
name|obj_id
expr_stmt|;
name|ep
operator|=
operator|&
name|ssc
operator|->
name|ses_objmap
index|[
name|idx
index|]
expr_stmt|;
switch|switch
condition|(
name|ep
operator|->
name|enctype
condition|)
block|{
case|case
name|SESTYP_DEVICE
case|:
if|if
condition|(
name|obp
operator|->
name|cstat
index|[
literal|0
index|]
operator|&
name|SESCTL_PRDFAIL
condition|)
block|{
name|ep
operator|->
name|priv
operator||=
literal|0x40
expr_stmt|;
block|}
comment|/* SESCTL_RSTSWAP has no correspondence in SAF-TE */
if|if
condition|(
name|obp
operator|->
name|cstat
index|[
literal|0
index|]
operator|&
name|SESCTL_DISABLE
condition|)
block|{
name|ep
operator|->
name|priv
operator||=
literal|0x80
expr_stmt|;
comment|/* 			 * Hmm. Try to set the 'No Drive' flag. 			 * Maybe that will count as a 'disable'. 			 */
block|}
if|if
condition|(
name|ep
operator|->
name|priv
operator|&
literal|0xc6
condition|)
block|{
name|ep
operator|->
name|priv
operator|&=
operator|~
literal|0x1
expr_stmt|;
block|}
else|else
block|{
name|ep
operator|->
name|priv
operator||=
literal|0x1
expr_stmt|;
comment|/* no errors */
block|}
name|wrslot_stat
argument_list|(
name|ssc
argument_list|,
name|slp
argument_list|)
expr_stmt|;
break|break;
case|case
name|SESTYP_POWER
case|:
comment|/* 		 * Okay- the only one that makes sense here is to 		 * do the 'disable' for a power supply. 		 */
if|if
condition|(
name|obp
operator|->
name|cstat
index|[
literal|0
index|]
operator|&
name|SESCTL_DISABLE
condition|)
block|{
operator|(
name|void
operator|)
name|wrbuf16
argument_list|(
name|ssc
argument_list|,
name|SAFTE_WT_ACTPWS
argument_list|,
name|idx
operator|-
name|cc
operator|->
name|pwroff
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|slp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SESTYP_FAN
case|:
comment|/* 		 * Okay- the only one that makes sense here is to 		 * set fan speed to zero on disable. 		 */
if|if
condition|(
name|obp
operator|->
name|cstat
index|[
literal|0
index|]
operator|&
name|SESCTL_DISABLE
condition|)
block|{
comment|/* remember- fans are the first items, so idx works */
operator|(
name|void
operator|)
name|wrbuf16
argument_list|(
name|ssc
argument_list|,
name|SAFTE_WT_FANSPD
argument_list|,
name|idx
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|slp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SESTYP_DOORLOCK
case|:
comment|/* 		 * Well, we can 'disable' the lock. 		 */
if|if
condition|(
name|obp
operator|->
name|cstat
index|[
literal|0
index|]
operator|&
name|SESCTL_DISABLE
condition|)
block|{
name|cc
operator|->
name|flag2
operator|&=
operator|~
name|SAFT_FLG2_LOCKDOOR
expr_stmt|;
operator|(
name|void
operator|)
name|wrbuf16
argument_list|(
name|ssc
argument_list|,
name|SAFTE_WT_GLOBAL
argument_list|,
name|cc
operator|->
name|flag1
argument_list|,
name|cc
operator|->
name|flag2
argument_list|,
literal|0
argument_list|,
name|slp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SESTYP_ALARM
case|:
comment|/* 		 * Well, we can 'disable' the alarm. 		 */
if|if
condition|(
name|obp
operator|->
name|cstat
index|[
literal|0
index|]
operator|&
name|SESCTL_DISABLE
condition|)
block|{
name|cc
operator|->
name|flag2
operator|&=
operator|~
name|SAFT_FLG1_ALARM
expr_stmt|;
name|ep
operator|->
name|priv
operator||=
literal|0x40
expr_stmt|;
comment|/* Muted */
operator|(
name|void
operator|)
name|wrbuf16
argument_list|(
name|ssc
argument_list|,
name|SAFTE_WT_GLOBAL
argument_list|,
name|cc
operator|->
name|flag1
argument_list|,
name|cc
operator|->
name|flag2
argument_list|,
literal|0
argument_list|,
name|slp
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
name|ep
operator|->
name|svalid
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function handles all of the 16 byte WRITE BUFFER commands.  */
end_comment

begin_function
specifier|static
name|int
name|wrbuf16
parameter_list|(
name|ses_softc_t
modifier|*
name|ssc
parameter_list|,
name|uint8_t
name|op
parameter_list|,
name|uint8_t
name|b1
parameter_list|,
name|uint8_t
name|b2
parameter_list|,
name|uint8_t
name|b3
parameter_list|,
name|int
name|slp
parameter_list|)
block|{
name|int
name|err
decl_stmt|,
name|amt
decl_stmt|;
name|char
modifier|*
name|sdata
decl_stmt|;
name|struct
name|scfg
modifier|*
name|cc
init|=
name|ssc
operator|->
name|ses_private
decl_stmt|;
specifier|static
name|char
name|cdb
index|[
literal|10
index|]
init|=
block|{
name|WRITE_BUFFER
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|16
block|,
literal|0
block|}
decl_stmt|;
if|if
condition|(
name|cc
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sdata
operator|=
name|SES_MALLOC
argument_list|(
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdata
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|SES_DLOG
argument_list|(
name|ssc
argument_list|,
literal|"saf_wrbuf16 %x %x %x %x\n"
argument_list|,
name|op
argument_list|,
name|b1
argument_list|,
name|b2
argument_list|,
name|b3
argument_list|)
expr_stmt|;
name|sdata
index|[
literal|0
index|]
operator|=
name|op
expr_stmt|;
name|sdata
index|[
literal|1
index|]
operator|=
name|b1
expr_stmt|;
name|sdata
index|[
literal|2
index|]
operator|=
name|b2
expr_stmt|;
name|sdata
index|[
literal|3
index|]
operator|=
name|b3
expr_stmt|;
name|MEMZERO
argument_list|(
operator|&
name|sdata
index|[
literal|4
index|]
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|amt
operator|=
operator|-
literal|16
expr_stmt|;
name|err
operator|=
name|ses_runcmd
argument_list|(
name|ssc
argument_list|,
name|cdb
argument_list|,
literal|10
argument_list|,
name|sdata
argument_list|,
operator|&
name|amt
argument_list|)
expr_stmt|;
name|SES_FREE
argument_list|(
name|sdata
argument_list|,
literal|16
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function updates the status byte for the device slot described.  *  * Since this is an optional SAF-TE command, there's no point in  * returning an error.  */
end_comment

begin_function
specifier|static
name|void
name|wrslot_stat
parameter_list|(
name|ses_softc_t
modifier|*
name|ssc
parameter_list|,
name|int
name|slp
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|amt
decl_stmt|;
name|encobj
modifier|*
name|ep
decl_stmt|;
name|char
name|cdb
index|[
literal|10
index|]
decl_stmt|,
modifier|*
name|sdata
decl_stmt|;
name|struct
name|scfg
modifier|*
name|cc
init|=
name|ssc
operator|->
name|ses_private
decl_stmt|;
if|if
condition|(
name|cc
operator|==
name|NULL
condition|)
return|return;
name|SES_DLOG
argument_list|(
name|ssc
argument_list|,
literal|"saf_wrslot\n"
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|0
index|]
operator|=
name|WRITE_BUFFER
expr_stmt|;
name|cdb
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|cdb
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|cdb
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|cdb
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|cdb
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
name|cdb
index|[
literal|6
index|]
operator|=
literal|0
expr_stmt|;
name|cdb
index|[
literal|7
index|]
operator|=
literal|0
expr_stmt|;
name|cdb
index|[
literal|8
index|]
operator|=
name|cc
operator|->
name|Nslots
operator|*
literal|3
operator|+
literal|1
expr_stmt|;
name|cdb
index|[
literal|9
index|]
operator|=
literal|0
expr_stmt|;
name|sdata
operator|=
name|SES_MALLOC
argument_list|(
name|cc
operator|->
name|Nslots
operator|*
literal|3
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdata
operator|==
name|NULL
condition|)
return|return;
name|MEMZERO
argument_list|(
name|sdata
argument_list|,
name|cc
operator|->
name|Nslots
operator|*
literal|3
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sdata
index|[
literal|0
index|]
operator|=
name|SAFTE_WT_DSTAT
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cc
operator|->
name|Nslots
condition|;
name|i
operator|++
control|)
block|{
name|ep
operator|=
operator|&
name|ssc
operator|->
name|ses_objmap
index|[
name|cc
operator|->
name|slotoff
operator|+
name|i
index|]
expr_stmt|;
name|SES_DLOG
argument_list|(
name|ssc
argument_list|,
literal|"saf_wrslot %d<- %x\n"
argument_list|,
name|i
argument_list|,
name|ep
operator|->
name|priv
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|sdata
index|[
literal|1
operator|+
operator|(
literal|3
operator|*
name|i
operator|)
index|]
operator|=
name|ep
operator|->
name|priv
operator|&
literal|0xff
expr_stmt|;
block|}
name|amt
operator|=
operator|-
operator|(
name|cc
operator|->
name|Nslots
operator|*
literal|3
operator|+
literal|1
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|ses_runcmd
argument_list|(
name|ssc
argument_list|,
name|cdb
argument_list|,
literal|10
argument_list|,
name|sdata
argument_list|,
operator|&
name|amt
argument_list|)
expr_stmt|;
name|SES_FREE
argument_list|(
name|sdata
argument_list|,
name|cc
operator|->
name|Nslots
operator|*
literal|3
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function issues the "PERFORM SLOT OPERATION" command.  */
end_comment

begin_function
specifier|static
name|int
name|perf_slotop
parameter_list|(
name|ses_softc_t
modifier|*
name|ssc
parameter_list|,
name|uint8_t
name|slot
parameter_list|,
name|uint8_t
name|opflag
parameter_list|,
name|int
name|slp
parameter_list|)
block|{
name|int
name|err
decl_stmt|,
name|amt
decl_stmt|;
name|char
modifier|*
name|sdata
decl_stmt|;
name|struct
name|scfg
modifier|*
name|cc
init|=
name|ssc
operator|->
name|ses_private
decl_stmt|;
specifier|static
name|char
name|cdb
index|[
literal|10
index|]
init|=
block|{
name|WRITE_BUFFER
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SAFT_SCRATCH
block|,
literal|0
block|}
decl_stmt|;
if|if
condition|(
name|cc
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sdata
operator|=
name|SES_MALLOC
argument_list|(
name|SAFT_SCRATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdata
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|MEMZERO
argument_list|(
name|sdata
argument_list|,
name|SAFT_SCRATCH
argument_list|)
expr_stmt|;
name|sdata
index|[
literal|0
index|]
operator|=
name|SAFTE_WT_SLTOP
expr_stmt|;
name|sdata
index|[
literal|1
index|]
operator|=
name|slot
expr_stmt|;
name|sdata
index|[
literal|2
index|]
operator|=
name|opflag
expr_stmt|;
name|SES_DLOG
argument_list|(
name|ssc
argument_list|,
literal|"saf_slotop slot %d op %x\n"
argument_list|,
name|slot
argument_list|,
name|opflag
argument_list|)
expr_stmt|;
name|amt
operator|=
operator|-
name|SAFT_SCRATCH
expr_stmt|;
name|err
operator|=
name|ses_runcmd
argument_list|(
name|ssc
argument_list|,
name|cdb
argument_list|,
literal|10
argument_list|,
name|sdata
argument_list|,
operator|&
name|amt
argument_list|)
expr_stmt|;
name|SES_FREE
argument_list|(
name|sdata
argument_list|,
name|SAFT_SCRATCH
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

end_unit

