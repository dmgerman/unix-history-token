begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2000 Matthew Jacob  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/devicestat.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_extend.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_queue.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_ses.h>
end_include

begin_include
include|#
directive|include
file|<opt_ses.h>
end_include

begin_define
define|#
directive|define
name|QFRLS
parameter_list|(
name|ccb
parameter_list|)
define|\
value|if (((ccb)->ccb_h.status& CAM_DEV_QFRZN) != 0)	\ 		cam_release_devq((ccb)->ccb_h.path, 0, 0, 0, FALSE)
end_define

begin_define
define|#
directive|define
name|ccb_state
value|ppriv_field0
end_define

begin_define
define|#
directive|define
name|ccb_bp
value|ppriv_ptr1
end_define

begin_struct
struct|struct
name|ses_softc
block|{
name|enctyp
name|ses_type
decl_stmt|;
comment|/* type of enclosure */
name|encvec
name|ses_vec
decl_stmt|;
comment|/* vector to handlers */
name|u_int32_t
name|ses_nobjects
decl_stmt|;
comment|/* number of objects */
name|void
modifier|*
name|ses_private
decl_stmt|;
comment|/* private data */
name|encobj
modifier|*
name|ses_objmap
decl_stmt|;
comment|/* objects */
name|u_int8_t
name|ses_encstat
decl_stmt|;
comment|/* overall status */
name|u_int8_t
name|ses_flags
decl_stmt|;
name|union
name|ccb
name|ses_saved_ccb
decl_stmt|;
name|dev_t
name|ses_dev
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|SES_FLAG_INVALID
value|0x01
end_define

begin_define
define|#
directive|define
name|SES_FLAG_OPEN
value|0x02
end_define

begin_define
define|#
directive|define
name|SESUNIT
parameter_list|(
name|x
parameter_list|)
value|(minor((x)))
end_define

begin_define
define|#
directive|define
name|SES_CDEV_MAJOR
value|110
end_define

begin_typedef
typedef|typedef
enum|enum
block|{
name|SES_CCB_BUFFER_IO
block|,
name|SES_CCB_WAITING
block|}
name|ses_ccb_types
typedef|;
end_typedef

begin_define
define|#
directive|define
name|ccb_type
value|ppriv_field0
end_define

begin_decl_stmt
specifier|static
name|d_open_t
name|sesopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|sesclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|sesioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_init_t
name|sesinit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_ctor_t
name|sesregister
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_oninv_t
name|sesoninvalidate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_dtor_t
name|sescleanup
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_start_t
name|sesstart
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|sesasync
parameter_list|(
name|void
modifier|*
parameter_list|,
name|u_int32_t
parameter_list|,
name|struct
name|cam_path
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sesdone
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|seserror
parameter_list|(
name|union
name|ccb
modifier|*
parameter_list|,
name|u_int32_t
parameter_list|,
name|u_int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|periph_driver
name|sesdriver
init|=
block|{
name|sesinit
block|,
literal|"ses"
block|,
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|sesdriver
operator|.
name|units
argument_list|)
block|,
comment|/* generation */
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DATA_SET
argument_list|(
name|periphdriver_set
argument_list|,
name|sesdriver
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|ses_cdevsw
init|=
block|{
comment|/* open */
name|sesopen
block|,
comment|/* close */
name|sesclose
block|,
comment|/* read */
name|noread
block|,
comment|/* write */
name|nowrite
block|,
comment|/* ioctl */
name|sesioctl
block|,
comment|/* poll */
name|nopoll
block|,
comment|/* mmap */
name|nommap
block|,
comment|/* strategy */
name|nostrategy
block|,
comment|/* name */
literal|"ses"
block|,
comment|/* maj */
name|SES_CDEV_MAJOR
block|,
comment|/* dump */
name|nodump
block|,
comment|/* psize */
name|nopsize
block|,
comment|/* flags */
literal|0
block|,
comment|/* bmaj */
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|extend_array
modifier|*
name|sesperiphs
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|sesinit
parameter_list|(
name|void
parameter_list|)
block|{
name|cam_status
name|status
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
comment|/* 	 * Create our extend array for storing the devices we attach to. 	 */
name|sesperiphs
operator|=
name|cam_extend_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|sesperiphs
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ses: Failed to alloc extend array!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Install a global async callback.  This callback will 	 * receive async callbacks like "new device found". 	 */
name|status
operator|=
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
name|NULL
argument_list|,
name|CAM_XPT_PATH_ID
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|CAM_REQ_CMP
condition|)
block|{
name|struct
name|ccb_setasync
name|csa
decl_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|csa
operator|.
name|ccb_h
argument_list|,
name|path
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|csa
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SASYNC_CB
expr_stmt|;
name|csa
operator|.
name|event_enable
operator|=
name|AC_FOUND_DEVICE
expr_stmt|;
name|csa
operator|.
name|callback
operator|=
name|sesasync
expr_stmt|;
name|csa
operator|.
name|callback_arg
operator|=
name|NULL
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|csa
argument_list|)
expr_stmt|;
name|status
operator|=
name|csa
operator|.
name|ccb_h
operator|.
name|status
expr_stmt|;
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"ses: Failed to attach master async callback "
literal|"due to status 0x%x!\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sesoninvalidate
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|struct
name|ses_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ccb_setasync
name|csa
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|ses_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
comment|/* 	 * Unregister any async callbacks. 	 */
name|xpt_setup_ccb
argument_list|(
operator|&
name|csa
operator|.
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|csa
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SASYNC_CB
expr_stmt|;
name|csa
operator|.
name|event_enable
operator|=
literal|0
expr_stmt|;
name|csa
operator|.
name|callback
operator|=
name|sesasync
expr_stmt|;
name|csa
operator|.
name|callback_arg
operator|=
name|periph
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|csa
argument_list|)
expr_stmt|;
name|softc
operator|->
name|ses_flags
operator||=
name|SES_FLAG_INVALID
expr_stmt|;
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"lost device\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sescleanup
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|struct
name|ses_softc
modifier|*
name|softc
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|ses_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|destroy_dev
argument_list|(
name|softc
operator|->
name|ses_dev
argument_list|)
expr_stmt|;
name|cam_extend_release
argument_list|(
name|sesperiphs
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|)
expr_stmt|;
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"removing device entry\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|softc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sesasync
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|u_int32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|periph
operator|=
operator|(
expr|struct
name|cam_periph
operator|*
operator|)
name|callback_arg
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|AC_FOUND_DEVICE
case|:
block|{
name|struct
name|ccb_getdev
modifier|*
name|cgd
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|cgd
operator|=
operator|(
expr|struct
name|ccb_getdev
operator|*
operator|)
name|arg
expr_stmt|;
comment|/* 		 * PROBLEM: WE NEED TO LOOK AT BYTES 48-53 TO SEE IF THIS IS 		 * PROBLEM: IS A SAF-TE DEVICE. 		 */
switch|switch
condition|(
name|ses_type
argument_list|(
operator|&
name|cgd
operator|->
name|inq_data
argument_list|,
sizeof|sizeof
argument_list|(
name|cgd
operator|->
name|inq_data
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|SES_SES
case|:
case|case
name|SES_SEN
case|:
case|case
name|SES_SAFT
case|:
break|break;
default|default:
return|return;
block|}
name|status
operator|=
name|cam_periph_alloc
argument_list|(
name|sesregister
argument_list|,
name|sesoninvalidate
argument_list|,
name|sescleanup
argument_list|,
name|sesstart
argument_list|,
literal|"ses"
argument_list|,
name|CAM_PERIPH_BIO
argument_list|,
name|cgd
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|sesasync
argument_list|,
name|AC_FOUND_DEVICE
argument_list|,
name|cgd
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
operator|&&
name|status
operator|!=
name|CAM_REQ_INPROG
condition|)
block|{
name|printf
argument_list|(
literal|"sesasync: Unable to probe new device due to "
literal|"status 0x%x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
name|cam_periph_async
argument_list|(
name|periph
argument_list|,
name|code
argument_list|,
name|path
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|cam_status
name|sesregister
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ses_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ccb_setasync
name|csa
decl_stmt|;
name|struct
name|ccb_getdev
modifier|*
name|cgd
decl_stmt|;
name|char
modifier|*
name|tname
decl_stmt|;
name|cgd
operator|=
operator|(
expr|struct
name|ccb_getdev
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"chregister: periph was NULL!!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
if|if
condition|(
name|cgd
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"chregister: no getdev CCB, can't register device\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
name|softc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ses_softc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"sesregister: Unable to probe new device. "
literal|"Unable to allocate softc\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
name|bzero
argument_list|(
name|softc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ses_softc
argument_list|)
argument_list|)
expr_stmt|;
name|softc
operator|->
name|ses_type
operator|=
name|ses_type
argument_list|(
operator|&
name|cgd
operator|->
name|inq_data
argument_list|,
sizeof|sizeof
argument_list|(
name|cgd
operator|->
name|inq_data
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|softc
operator|->
name|ses_type
condition|)
block|{
case|case
name|SES_SES_SCSI2
case|:
case|case
name|SES_SES
case|:
case|case
name|SES_SES_PASSTHROUGH
case|:
case|case
name|SES_SEN
case|:
case|case
name|SES_SAFT
case|:
break|break;
case|case
name|SES_NONE
case|:
default|default:
name|free
argument_list|(
name|softc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
name|periph
operator|->
name|softc
operator|=
name|softc
expr_stmt|;
name|cam_extend_set
argument_list|(
name|sesperiphs
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|,
name|periph
argument_list|)
expr_stmt|;
name|softc
operator|->
name|ses_dev
operator|=
name|make_dev
argument_list|(
operator|&
name|ses_cdevsw
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0600
argument_list|,
literal|"%s%d"
argument_list|,
name|periph
operator|->
name|periph_name
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|)
expr_stmt|;
comment|/* 	 * Add an async callback so that we get 	 * notified if this device goes away. 	 */
name|xpt_setup_ccb
argument_list|(
operator|&
name|csa
operator|.
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|csa
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SASYNC_CB
expr_stmt|;
name|csa
operator|.
name|event_enable
operator|=
name|AC_LOST_DEVICE
expr_stmt|;
name|csa
operator|.
name|callback
operator|=
name|sesasync
expr_stmt|;
name|csa
operator|.
name|callback_arg
operator|=
name|periph
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|csa
argument_list|)
expr_stmt|;
comment|/* 	 * Lock this peripheral until we are setup. 	 * This first call can't block 	 */
operator|(
name|void
operator|)
name|cam_periph_lock
argument_list|(
name|periph
argument_list|,
name|PRIBIO
argument_list|)
expr_stmt|;
name|xpt_schedule
argument_list|(
name|periph
argument_list|,
literal|5
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|softc
operator|->
name|ses_type
condition|)
block|{
default|default:
case|case
name|SES_NONE
case|:
name|tname
operator|=
literal|"No SES device"
expr_stmt|;
break|break;
case|case
name|SES_SES_SCSI2
case|:
name|tname
operator|=
literal|"SCSI-2 SES Device"
expr_stmt|;
break|break;
case|case
name|SES_SES
case|:
name|tname
operator|=
literal|"SCSI-3 SES Device"
expr_stmt|;
break|break;
case|case
name|SES_SES_PASSTHROUGH
case|:
name|tname
operator|=
literal|"SES Passthrough Device"
expr_stmt|;
break|break;
case|case
name|SES_SEN
case|:
name|tname
operator|=
literal|"Unisys SEN Device"
expr_stmt|;
break|break;
case|case
name|SES_SAFT
case|:
name|tname
operator|=
literal|"SAF-TE Compliant Device"
expr_stmt|;
break|break;
block|}
name|xpt_announce_periph
argument_list|(
name|periph
argument_list|,
name|tname
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sesopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|ses_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|s
decl_stmt|;
name|periph
operator|=
name|cam_extend_get
argument_list|(
name|sesperiphs
argument_list|,
name|SESUNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|softc
operator|=
operator|(
expr|struct
name|ses_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|s
operator|=
name|splsoftcam
argument_list|()
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|ses_flags
operator|&
name|SES_FLAG_INVALID
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|cam_periph_lock
argument_list|(
name|periph
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|softc
operator|->
name|ses_flags
operator|&
name|SES_FLAG_OPEN
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cam_periph_acquire
argument_list|(
name|periph
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|softc
operator|->
name|ses_flags
operator||=
name|SES_FLAG_OPEN
expr_stmt|;
block|}
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sesclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|ses_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|unit
operator|=
name|SESUNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|periph
operator|=
name|cam_extend_get
argument_list|(
name|sesperiphs
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|softc
operator|=
operator|(
expr|struct
name|ses_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|cam_periph_lock
argument_list|(
name|periph
argument_list|,
name|PRIBIO
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|softc
operator|->
name|ses_flags
operator|&=
operator|~
name|SES_FLAG_OPEN
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|cam_periph_release
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sesstart
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|start_ccb
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
name|periph
operator|->
name|immediate_priority
operator|<=
name|periph
operator|->
name|pinfo
operator|.
name|priority
condition|)
block|{
name|start_ccb
operator|->
name|ccb_h
operator|.
name|ccb_type
operator|=
name|SES_CCB_WAITING
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|periph
operator|->
name|ccb_list
argument_list|,
operator|&
name|start_ccb
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|sle
argument_list|)
expr_stmt|;
name|periph
operator|->
name|immediate_priority
operator|=
name|CAM_PRIORITY_NONE
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|periph
operator|->
name|ccb_list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sesdone
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|done_ccb
parameter_list|)
block|{
name|struct
name|ses_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|ses_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|csio
operator|=
operator|&
name|done_ccb
operator|->
name|csio
expr_stmt|;
switch|switch
condition|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|ccb_type
condition|)
block|{
case|case
name|SES_CCB_WAITING
case|:
block|{
comment|/* Caller will release the CCB */
name|wakeup
argument_list|(
operator|&
name|done_ccb
operator|->
name|ccb_h
operator|.
name|cbfcnp
argument_list|)
expr_stmt|;
return|return;
block|}
default|default:
break|break;
block|}
name|xpt_release_ccb
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|seserror
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|u_int32_t
name|cflags
parameter_list|,
name|u_int32_t
name|sflags
parameter_list|)
block|{
name|struct
name|ses_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|periph
operator|=
name|xpt_path_periph
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|ses_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
return|return
operator|(
name|cam_periph_error
argument_list|(
name|ccb
argument_list|,
name|cflags
argument_list|,
name|sflags
argument_list|,
operator|&
name|softc
operator|->
name|ses_saved_ccb
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sesioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|ses_softc
modifier|*
name|softc
decl_stmt|;
name|u_int8_t
name|unit
decl_stmt|;
name|int
name|error
decl_stmt|;
name|unit
operator|=
name|SESUNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|periph
operator|=
name|cam_extend_get
argument_list|(
name|sesperiphs
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"entering sesioctl\n"
operator|)
argument_list|)
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|ses_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"trying to do ioctl %#lx\n"
operator|,
name|cmd
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If this command can change the device's state, we must 	 * have the device open for writing. 	 */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SESIOC_GETNOBJ
case|:
case|case
name|SESIOC_GETOBJMAP
case|:
case|case
name|SESIOC_GETENCSTAT
case|:
case|case
name|SESIOC_GETOBJSTAT
case|:
break|break;
default|default:
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EBADF
operator|)
return|;
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SESIOC_GETNOBJ
case|:
case|case
name|SESIOC_GETOBJMAP
case|:
case|case
name|SESIOC_GETENCSTAT
case|:
case|case
name|SESIOC_SETENCSTAT
case|:
case|case
name|SESIOC_GETOBJSTAT
case|:
case|case
name|SESIOC_SETOBJSTAT
case|:
case|case
name|SESIOC_INIT
case|:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|cam_periph_ioctl
argument_list|(
name|periph
argument_list|,
name|cmd
argument_list|,
name|addr
argument_list|,
name|seserror
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Is this a device that supports enclosure services?  *  * It's a a pretty simple ruleset- if it is device type 0x0D (13), it's  * an SES device. If it happens to be an old UNISYS SEN device, we can  * handle that too.  */
end_comment

begin_function
name|enctyp
name|ses_type
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|int
name|buflen
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|iqd
init|=
name|buf
decl_stmt|;
if|if
condition|(
name|buflen
operator|<
literal|32
condition|)
return|return
operator|(
name|SES_NONE
operator|)
return|;
if|if
condition|(
operator|(
name|iqd
index|[
literal|0
index|]
operator|&
literal|0x1f
operator|)
operator|==
name|SES_DEVICE_TYPE
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
operator|&
name|iqd
index|[
literal|8
index|]
argument_list|,
name|SEN_ID
argument_list|,
name|SEN_ID_LEN
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|SES_SEN
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|iqd
index|[
literal|2
index|]
operator|&
literal|0x7
operator|)
operator|>
literal|2
condition|)
block|{
return|return
operator|(
name|SES_SES
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|SES_SES_SCSI2
operator|)
return|;
block|}
return|return
operator|(
name|SES_NONE
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|SES_ENABLE_PASSTHROUGH
if|if
condition|(
operator|(
name|iqd
index|[
literal|6
index|]
operator|&
literal|0x40
operator|)
operator|&&
operator|(
name|iqd
index|[
literal|2
index|]
operator|&
literal|0x7
operator|)
operator|>=
literal|2
condition|)
block|{
comment|/* 		 * PassThrough Device. 		 */
return|return
operator|(
name|SES_SES_PASSTHRU
operator|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|buflen
operator|<
literal|47
condition|)
block|{
return|return
operator|(
name|SES_NONE
operator|)
return|;
block|}
comment|/* 	 * The comparison is short for a reason- some vendors were chopping 	 * it short. 	 */
if|if
condition|(
name|strncmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|iqd
index|[
literal|44
index|]
argument_list|,
literal|"SAF-TE"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|SES_SAFT
operator|)
return|;
block|}
return|return
operator|(
name|SES_NONE
operator|)
return|;
block|}
end_function

end_unit

