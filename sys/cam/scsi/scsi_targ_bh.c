begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Implementation of the Target Mode 'Black Hole device' for CAM.  *  * Copyright (c) 1999 Justin T. Gibbs.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_comment
comment|/* For offsetof */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/devicestat.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_extend.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_queue.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_typedef
typedef|typedef
enum|enum
block|{
name|TARGBH_STATE_NORMAL
block|,
name|TARGBH_STATE_EXCEPTION
block|,
name|TARGBH_STATE_TEARDOWN
block|}
name|targbh_state
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|TARGBH_FLAG_NONE
init|=
literal|0x00
block|,
name|TARGBH_FLAG_LUN_ENABLED
init|=
literal|0x01
block|}
name|targbh_flags
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|TARGBH_CCB_WORKQ
block|,
name|TARGBH_CCB_WAITING
block|}
name|targbh_ccb_types
typedef|;
end_typedef

begin_define
define|#
directive|define
name|MAX_ACCEPT
value|8
end_define

begin_define
define|#
directive|define
name|MAX_IMMEDIATE
value|16
end_define

begin_define
define|#
directive|define
name|MAX_BUF_SIZE
value|256
end_define

begin_comment
comment|/* Max inquiry/sense/mode page transfer */
end_comment

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a> b) ? b : a)
end_define

begin_comment
comment|/* Offsets into our private CCB area for storing accept information */
end_comment

begin_define
define|#
directive|define
name|ccb_type
value|ppriv_field0
end_define

begin_define
define|#
directive|define
name|ccb_descr
value|ppriv_ptr1
end_define

begin_comment
comment|/* We stick a pointer to the originating accept TIO in each continue I/O CCB */
end_comment

begin_define
define|#
directive|define
name|ccb_atio
value|ppriv_ptr1
end_define

begin_expr_stmt
name|TAILQ_HEAD
argument_list|(
name|ccb_queue
argument_list|,
name|ccb_hdr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|targbh_softc
block|{
name|struct
name|ccb_queue
name|pending_queue
decl_stmt|;
name|struct
name|ccb_queue
name|work_queue
decl_stmt|;
name|struct
name|ccb_queue
name|unknown_atio_queue
decl_stmt|;
name|struct
name|devstat
name|device_stats
decl_stmt|;
name|targbh_state
name|state
decl_stmt|;
name|targbh_flags
name|flags
decl_stmt|;
name|u_int
name|init_level
decl_stmt|;
name|u_int
name|inq_data_len
decl_stmt|;
name|struct
name|ccb_accept_tio
modifier|*
name|accept_tio_list
decl_stmt|;
name|struct
name|ccb_hdr_slist
name|immed_notify_slist
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|targbh_cmd_desc
block|{
name|struct
name|ccb_accept_tio
modifier|*
name|atio_link
decl_stmt|;
name|u_int
name|data_resid
decl_stmt|;
comment|/* How much left to transfer */
name|u_int
name|data_increment
decl_stmt|;
comment|/* Amount to send before next disconnect */
name|void
modifier|*
name|data
decl_stmt|;
comment|/* The data. Can be from backing_store or not */
name|void
modifier|*
name|backing_store
decl_stmt|;
comment|/* Backing store allocated for this descriptor*/
name|u_int
name|max_size
decl_stmt|;
comment|/* Size of backing_store */
name|u_int32_t
name|timeout
decl_stmt|;
name|u_int8_t
name|status
decl_stmt|;
comment|/* Status to return to initiator */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|scsi_inquiry_data
name|no_lun_inq_data
init|=
block|{
name|T_NODEVICE
operator||
operator|(
name|SID_QUAL_BAD_LU
operator|<<
literal|5
operator|)
block|,
literal|0
block|,
comment|/* version */
literal|2
block|,
comment|/* format version */
literal|2
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|scsi_sense_data
name|no_lun_sense_data
init|=
block|{
name|SSD_CURRENT_ERROR
operator||
name|SSD_ERRCODE_VALID
block|,
literal|0
block|,
name|SSD_KEY_NOT_READY
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/*extra_len*/
name|offsetof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|,
name|fru
argument_list|)
operator|-
name|offsetof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|,
name|extra_len
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Logical Unit Not Supported */
comment|/*ASC*/
literal|0x25
block|,
comment|/*ASCQ*/
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|request_sense_size
init|=
name|offsetof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|,
name|fru
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_init_t
name|targbhinit
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|targbhasync
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|u_int32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cam_status
name|targbhenlun
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cam_status
name|targbhdislun
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|periph_ctor_t
name|targbhctor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_dtor_t
name|targbhdtor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_start_t
name|targbhstart
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|targbhdone
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|done_ccb
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|NOTYET
end_ifdef

begin_function_decl
specifier|static
name|int
name|targbherror
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|u_int32_t
name|cam_flags
parameter_list|,
name|u_int32_t
name|sense_flags
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|struct
name|targbh_cmd_desc
modifier|*
name|targbhallocdescr
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|targbhfreedescr
parameter_list|(
name|struct
name|targbh_cmd_desc
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|periph_driver
name|targbhdriver
init|=
block|{
name|targbhinit
block|,
literal|"targbh"
block|,
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|targbhdriver
operator|.
name|units
argument_list|)
block|,
comment|/* generation */
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DATA_SET
argument_list|(
name|periphdriver_set
argument_list|,
name|targbhdriver
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|targbhinit
parameter_list|(
name|void
parameter_list|)
block|{
name|cam_status
name|status
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
comment|/* 	 * Install a global async callback.  This callback will 	 * receive async callbacks like "new path registered". 	 */
name|status
operator|=
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|CAM_XPT_PATH_ID
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|CAM_REQ_CMP
condition|)
block|{
name|struct
name|ccb_setasync
name|csa
decl_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|csa
operator|.
name|ccb_h
argument_list|,
name|path
argument_list|,
comment|/*priority*/
literal|5
argument_list|)
expr_stmt|;
name|csa
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SASYNC_CB
expr_stmt|;
name|csa
operator|.
name|event_enable
operator|=
name|AC_PATH_REGISTERED
expr_stmt|;
name|csa
operator|.
name|callback
operator|=
name|targbhasync
expr_stmt|;
name|csa
operator|.
name|callback_arg
operator|=
name|NULL
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|csa
argument_list|)
expr_stmt|;
name|status
operator|=
name|csa
operator|.
name|ccb_h
operator|.
name|status
expr_stmt|;
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"targbh: Failed to attach master async callback "
literal|"due to status 0x%x!\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|targbhasync
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|u_int32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|periph
operator|=
operator|(
expr|struct
name|cam_periph
operator|*
operator|)
name|callback_arg
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|AC_PATH_REGISTERED
case|:
block|{
name|struct
name|ccb_pathinq
modifier|*
name|cpi
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|new_path
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|cpi
operator|=
operator|(
expr|struct
name|ccb_pathinq
operator|*
operator|)
name|arg
expr_stmt|;
comment|/* Only attach to controllers that support target mode */
if|if
condition|(
operator|(
name|cpi
operator|->
name|target_sprt
operator|&
name|PIT_PROCESSOR
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/* 		 * Allocate a peripheral instance for 		 * this target instance. 		 */
name|status
operator|=
name|xpt_create_path
argument_list|(
operator|&
name|new_path
argument_list|,
name|NULL
argument_list|,
name|xpt_path_path_id
argument_list|(
name|path
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"targbhasync: Unable to create path "
literal|"due to status 0x%x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
break|break;
block|}
name|status
operator|=
name|cam_periph_alloc
argument_list|(
name|targbhctor
argument_list|,
name|NULL
argument_list|,
name|targbhdtor
argument_list|,
name|targbhstart
argument_list|,
literal|"targbh"
argument_list|,
name|CAM_PERIPH_BIO
argument_list|,
name|new_path
argument_list|,
name|targbhasync
argument_list|,
name|AC_PATH_REGISTERED
argument_list|,
name|cpi
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|new_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
operator|&&
name|status
operator|!=
name|CAM_REQ_INPROG
condition|)
name|printf
argument_list|(
literal|"targbhasync: Unable to allocate new periph "
literal|"due to status 0x%x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|AC_PATH_DEREGISTERED
case|:
block|{
name|targbhdislun
argument_list|(
name|periph
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Attempt to enable our lun */
end_comment

begin_function
specifier|static
name|cam_status
name|targbhenlun
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|union
name|ccb
name|immed_ccb
decl_stmt|;
name|struct
name|targbh_softc
modifier|*
name|softc
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|int
name|i
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|targbh_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|TARGBH_FLAG_LUN_ENABLED
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|CAM_REQ_CMP
operator|)
return|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|immed_ccb
operator|.
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|immed_ccb
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_EN_LUN
expr_stmt|;
comment|/* Don't need support for any vendor specific commands */
name|immed_ccb
operator|.
name|cel
operator|.
name|grp6_len
operator|=
literal|0
expr_stmt|;
name|immed_ccb
operator|.
name|cel
operator|.
name|grp7_len
operator|=
literal|0
expr_stmt|;
name|immed_ccb
operator|.
name|cel
operator|.
name|enable
operator|=
literal|1
expr_stmt|;
name|xpt_action
argument_list|(
operator|&
name|immed_ccb
argument_list|)
expr_stmt|;
name|status
operator|=
name|immed_ccb
operator|.
name|ccb_h
operator|.
name|status
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"targbhenlun - Enable Lun Rejected for status 0x%x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
name|softc
operator|->
name|flags
operator||=
name|TARGBH_FLAG_LUN_ENABLED
expr_stmt|;
comment|/* 	 * Build up a buffer of accept target I/O 	 * operations for incoming selections. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_ACCEPT
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ccb_accept_tio
modifier|*
name|atio
decl_stmt|;
name|atio
operator|=
operator|(
expr|struct
name|ccb_accept_tio
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|atio
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|atio
operator|==
name|NULL
condition|)
block|{
name|status
operator|=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
break|break;
block|}
name|atio
operator|->
name|ccb_h
operator|.
name|ccb_descr
operator|=
name|targbhallocdescr
argument_list|()
expr_stmt|;
if|if
condition|(
name|atio
operator|->
name|ccb_h
operator|.
name|ccb_descr
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|atio
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|status
operator|=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
break|break;
block|}
name|xpt_setup_ccb
argument_list|(
operator|&
name|atio
operator|->
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_ACCEPT_TARGET_IO
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|cbfcnp
operator|=
name|targbhdone
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|atio
argument_list|)
expr_stmt|;
name|status
operator|=
name|atio
operator|->
name|ccb_h
operator|.
name|status
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_INPROG
condition|)
block|{
name|targbhfreedescr
argument_list|(
name|atio
operator|->
name|ccb_h
operator|.
name|ccb_descr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|atio
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
break|break;
block|}
operator|(
operator|(
expr|struct
name|targbh_cmd_desc
operator|*
operator|)
name|atio
operator|->
name|ccb_h
operator|.
name|ccb_descr
operator|)
operator|->
name|atio_link
operator|=
name|softc
operator|->
name|accept_tio_list
expr_stmt|;
name|softc
operator|->
name|accept_tio_list
operator|=
name|atio
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"targbhenlun - Could not allocate accept tio CCBs: "
literal|"status = 0x%x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|targbhdislun
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
comment|/* 	 * Build up a buffer of immediate notify CCBs 	 * so the SIM can tell us of asynchronous target mode events. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_ACCEPT
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ccb_immed_notify
modifier|*
name|inot
decl_stmt|;
name|inot
operator|=
operator|(
expr|struct
name|ccb_immed_notify
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|inot
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|inot
operator|==
name|NULL
condition|)
block|{
name|status
operator|=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
break|break;
block|}
name|xpt_setup_ccb
argument_list|(
operator|&
name|inot
operator|->
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|inot
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_IMMED_NOTIFY
expr_stmt|;
name|inot
operator|->
name|ccb_h
operator|.
name|cbfcnp
operator|=
name|targbhdone
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|inot
argument_list|)
expr_stmt|;
name|status
operator|=
name|inot
operator|->
name|ccb_h
operator|.
name|status
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_INPROG
condition|)
block|{
name|free
argument_list|(
name|inot
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
break|break;
block|}
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|softc
operator|->
name|immed_notify_slist
argument_list|,
operator|&
name|inot
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|sle
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"targbhenlun - Could not allocate immediate notify "
literal|"CCBs: status = 0x%x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|targbhdislun
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
return|return
operator|(
name|CAM_REQ_CMP
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|cam_status
name|targbhdislun
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|union
name|ccb
name|ccb
decl_stmt|;
name|struct
name|targbh_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ccb_accept_tio
modifier|*
name|atio
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|targbh_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|TARGBH_FLAG_LUN_ENABLED
operator|)
operator|==
literal|0
condition|)
return|return
name|CAM_REQ_CMP
return|;
comment|/* XXX Block for Continue I/O completion */
comment|/* Kill off all ACCECPT and IMMEDIATE CCBs */
while|while
condition|(
operator|(
name|atio
operator|=
name|softc
operator|->
name|accept_tio_list
operator|)
operator|!=
name|NULL
condition|)
block|{
name|softc
operator|->
name|accept_tio_list
operator|=
operator|(
operator|(
expr|struct
name|targbh_cmd_desc
operator|*
operator|)
name|atio
operator|->
name|ccb_h
operator|.
name|ccb_descr
operator|)
operator|->
name|atio_link
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|ccb
operator|.
name|cab
operator|.
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|ccb
operator|.
name|cab
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_ABORT
expr_stmt|;
name|ccb
operator|.
name|cab
operator|.
name|abort_ccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|atio
expr_stmt|;
name|xpt_action
argument_list|(
operator|&
name|ccb
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|ccb_h
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|softc
operator|->
name|immed_notify_slist
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|softc
operator|->
name|immed_notify_slist
argument_list|,
name|periph_links
operator|.
name|sle
argument_list|)
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|ccb
operator|.
name|cab
operator|.
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|ccb
operator|.
name|cab
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_ABORT
expr_stmt|;
name|ccb
operator|.
name|cab
operator|.
name|abort_ccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|ccb_h
expr_stmt|;
name|xpt_action
argument_list|(
operator|&
name|ccb
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Dissable this lun. 	 */
name|xpt_setup_ccb
argument_list|(
operator|&
name|ccb
operator|.
name|cel
operator|.
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|ccb
operator|.
name|cel
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_EN_LUN
expr_stmt|;
name|ccb
operator|.
name|cel
operator|.
name|enable
operator|=
literal|0
expr_stmt|;
name|xpt_action
argument_list|(
operator|&
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|.
name|cel
operator|.
name|ccb_h
operator|.
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
name|printf
argument_list|(
literal|"targbhdislun - Disabling lun on controller failed "
literal|"with status 0x%x\n"
argument_list|,
name|ccb
operator|.
name|cel
operator|.
name|ccb_h
operator|.
name|status
argument_list|)
expr_stmt|;
else|else
name|softc
operator|->
name|flags
operator|&=
operator|~
name|TARGBH_FLAG_LUN_ENABLED
expr_stmt|;
return|return
operator|(
name|ccb
operator|.
name|cel
operator|.
name|ccb_h
operator|.
name|status
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|cam_status
name|targbhctor
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ccb_pathinq
modifier|*
name|cpi
decl_stmt|;
name|struct
name|targbh_softc
modifier|*
name|softc
decl_stmt|;
name|cpi
operator|=
operator|(
expr|struct
name|ccb_pathinq
operator|*
operator|)
name|arg
expr_stmt|;
comment|/* Allocate our per-instance private storage */
name|softc
operator|=
operator|(
expr|struct
name|targbh_softc
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|softc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"targctor: unable to malloc softc\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
name|bzero
argument_list|(
name|softc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|softc
argument_list|)
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|softc
operator|->
name|pending_queue
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|softc
operator|->
name|work_queue
argument_list|)
expr_stmt|;
name|softc
operator|->
name|accept_tio_list
operator|=
name|NULL
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|softc
operator|->
name|immed_notify_slist
argument_list|)
expr_stmt|;
name|softc
operator|->
name|state
operator|=
name|TARGBH_STATE_NORMAL
expr_stmt|;
name|periph
operator|->
name|softc
operator|=
name|softc
expr_stmt|;
name|softc
operator|->
name|init_level
operator|++
expr_stmt|;
return|return
operator|(
name|targbhenlun
argument_list|(
name|periph
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|targbhdtor
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|struct
name|targbh_softc
modifier|*
name|softc
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|targbh_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|softc
operator|->
name|state
operator|=
name|TARGBH_STATE_TEARDOWN
expr_stmt|;
name|targbhdislun
argument_list|(
name|periph
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|softc
operator|->
name|init_level
condition|)
block|{
default|default:
comment|/* FALLTHROUGH */
case|case
literal|1
case|:
name|free
argument_list|(
name|softc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|panic
argument_list|(
literal|"targdtor - impossible init level"
argument_list|)
expr_stmt|;
empty_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|targbhstart
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|start_ccb
parameter_list|)
block|{
name|struct
name|targbh_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccbh
decl_stmt|;
name|struct
name|ccb_accept_tio
modifier|*
name|atio
decl_stmt|;
name|struct
name|targbh_cmd_desc
modifier|*
name|desc
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|ccb_flags
name|flags
decl_stmt|;
name|int
name|s
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|targbh_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|ccbh
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|softc
operator|->
name|work_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|periph
operator|->
name|immediate_priority
operator|<=
name|periph
operator|->
name|pinfo
operator|.
name|priority
condition|)
block|{
name|start_ccb
operator|->
name|ccb_h
operator|.
name|ccb_type
operator|=
name|TARGBH_CCB_WAITING
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|periph
operator|->
name|ccb_list
argument_list|,
operator|&
name|start_ccb
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|sle
argument_list|)
expr_stmt|;
name|periph
operator|->
name|immediate_priority
operator|=
name|CAM_PRIORITY_NONE
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|periph
operator|->
name|ccb_list
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ccbh
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|start_ccb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|softc
operator|->
name|work_queue
argument_list|,
name|ccbh
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|softc
operator|->
name|pending_queue
argument_list|,
name|ccbh
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|atio
operator|=
operator|(
expr|struct
name|ccb_accept_tio
operator|*
operator|)
name|ccbh
expr_stmt|;
name|desc
operator|=
operator|(
expr|struct
name|targbh_cmd_desc
operator|*
operator|)
name|atio
operator|->
name|ccb_h
operator|.
name|ccb_descr
expr_stmt|;
comment|/* Is this a tagged request? */
name|flags
operator|=
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
operator|(
name|CAM_TAG_ACTION_VALID
operator||
name|CAM_DIR_MASK
operator|)
expr_stmt|;
name|csio
operator|=
operator|&
name|start_ccb
operator|->
name|csio
expr_stmt|;
comment|/* 		 * If we are done with the transaction, tell the 		 * controller to send status and perform a CMD_CMPLT. 		 * If we have associated sense data, see if we can 		 * send that too. 		 */
if|if
condition|(
name|desc
operator|->
name|data_resid
operator|==
name|desc
operator|->
name|data_increment
condition|)
block|{
name|flags
operator||=
name|CAM_SEND_STATUS
expr_stmt|;
if|if
condition|(
name|atio
operator|->
name|sense_len
condition|)
block|{
name|csio
operator|->
name|sense_len
operator|=
name|atio
operator|->
name|sense_len
expr_stmt|;
name|csio
operator|->
name|sense_data
operator|=
name|atio
operator|->
name|sense_data
expr_stmt|;
name|flags
operator||=
name|CAM_SEND_SENSE
expr_stmt|;
block|}
block|}
name|cam_fill_ctio
argument_list|(
name|csio
argument_list|,
comment|/*retries*/
literal|2
argument_list|,
name|targbhdone
argument_list|,
name|flags
argument_list|,
operator|(
name|flags
operator|&
name|CAM_TAG_ACTION_VALID
operator|)
condition|?
name|MSG_SIMPLE_Q_TAG
else|:
literal|0
argument_list|,
name|atio
operator|->
name|tag_id
argument_list|,
name|atio
operator|->
name|init_id
argument_list|,
name|desc
operator|->
name|status
argument_list|,
comment|/*data_ptr*/
name|desc
operator|->
name|data_increment
operator|==
literal|0
condition|?
name|NULL
else|:
name|desc
operator|->
name|data
argument_list|,
comment|/*dxfer_len*/
name|desc
operator|->
name|data_increment
argument_list|,
comment|/*timeout*/
name|desc
operator|->
name|timeout
argument_list|)
expr_stmt|;
comment|/* Override our wildcard attachment */
name|start_ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|=
name|atio
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|start_ccb
operator|->
name|ccb_h
operator|.
name|target_lun
operator|=
name|atio
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
name|start_ccb
operator|->
name|ccb_h
operator|.
name|ccb_type
operator|=
name|TARGBH_CCB_WORKQ
expr_stmt|;
name|start_ccb
operator|->
name|ccb_h
operator|.
name|ccb_atio
operator|=
name|atio
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"Sending a CTIO\n"
operator|)
argument_list|)
expr_stmt|;
name|xpt_action
argument_list|(
name|start_ccb
argument_list|)
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|ccbh
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|softc
operator|->
name|work_queue
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ccbh
operator|!=
name|NULL
condition|)
name|xpt_schedule
argument_list|(
name|periph
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|targbhdone
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|done_ccb
parameter_list|)
block|{
name|struct
name|targbh_softc
modifier|*
name|softc
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|targbh_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|ccb_type
operator|==
name|TARGBH_CCB_WAITING
condition|)
block|{
comment|/* Caller will release the CCB */
name|wakeup
argument_list|(
operator|&
name|done_ccb
operator|->
name|ccb_h
operator|.
name|cbfcnp
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_ACCEPT_TARGET_IO
case|:
block|{
name|struct
name|ccb_accept_tio
modifier|*
name|atio
decl_stmt|;
name|struct
name|targbh_cmd_desc
modifier|*
name|descr
decl_stmt|;
name|u_int8_t
modifier|*
name|cdb
decl_stmt|;
name|atio
operator|=
operator|&
name|done_ccb
operator|->
name|atio
expr_stmt|;
name|descr
operator|=
operator|(
expr|struct
name|targbh_cmd_desc
operator|*
operator|)
name|atio
operator|->
name|ccb_h
operator|.
name|ccb_descr
expr_stmt|;
name|cdb
operator|=
name|atio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|state
operator|==
name|TARGBH_STATE_TEARDOWN
operator|||
name|atio
operator|->
name|ccb_h
operator|.
name|status
operator|==
name|CAM_REQ_ABORTED
condition|)
block|{
name|targbhfreedescr
argument_list|(
name|descr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|done_ccb
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * Determine the type of incoming command and 		 * setup our buffer for a response. 		 */
switch|switch
condition|(
name|cdb
index|[
literal|0
index|]
condition|)
block|{
case|case
name|INQUIRY
case|:
block|{
name|struct
name|scsi_inquiry
modifier|*
name|inq
decl_stmt|;
name|inq
operator|=
operator|(
expr|struct
name|scsi_inquiry
operator|*
operator|)
name|cdb
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"Saw an inquiry!\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 			 * Validate the command.  We don't 			 * support any VPD pages, so complain 			 * if EVPD is set. 			 */
if|if
condition|(
operator|(
name|inq
operator|->
name|byte2
operator|&
name|SI_EVPD
operator|)
operator|!=
literal|0
operator|||
name|inq
operator|->
name|page_code
operator|!=
literal|0
condition|)
block|{
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator|&=
operator|~
name|CAM_DIR_MASK
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DIR_NONE
expr_stmt|;
comment|/* 				 * This needs to have other than a 				 * no_lun_sense_data response. 				 */
name|atio
operator|->
name|sense_data
operator|=
name|no_lun_sense_data
expr_stmt|;
name|atio
operator|->
name|sense_len
operator|=
sizeof|sizeof
argument_list|(
name|no_lun_sense_data
argument_list|)
expr_stmt|;
name|descr
operator|->
name|data_resid
operator|=
literal|0
expr_stmt|;
name|descr
operator|->
name|data_increment
operator|=
literal|0
expr_stmt|;
name|descr
operator|->
name|status
operator|=
name|SCSI_STATUS_CHECK_COND
expr_stmt|;
break|break;
block|}
comment|/* 			 * Direction is always relative 			 * to the initator. 			 */
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator|&=
operator|~
name|CAM_DIR_MASK
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DIR_IN
expr_stmt|;
name|descr
operator|->
name|data
operator|=
operator|&
name|no_lun_inq_data
expr_stmt|;
name|descr
operator|->
name|data_resid
operator|=
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
name|no_lun_inq_data
argument_list|)
argument_list|,
name|SCSI_CDB6_LEN
argument_list|(
name|inq
operator|->
name|length
argument_list|)
argument_list|)
expr_stmt|;
name|descr
operator|->
name|data_increment
operator|=
name|descr
operator|->
name|data_resid
expr_stmt|;
name|descr
operator|->
name|timeout
operator|=
literal|5
operator|*
literal|1000
expr_stmt|;
name|descr
operator|->
name|status
operator|=
name|SCSI_STATUS_OK
expr_stmt|;
break|break;
block|}
case|case
name|REQUEST_SENSE
case|:
block|{
name|struct
name|scsi_request_sense
modifier|*
name|rsense
decl_stmt|;
name|rsense
operator|=
operator|(
expr|struct
name|scsi_request_sense
operator|*
operator|)
name|cdb
expr_stmt|;
comment|/* Refer to static sense data */
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator|&=
operator|~
name|CAM_DIR_MASK
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DIR_IN
expr_stmt|;
name|descr
operator|->
name|data
operator|=
operator|&
name|no_lun_sense_data
expr_stmt|;
name|descr
operator|->
name|data_resid
operator|=
name|request_sense_size
expr_stmt|;
name|descr
operator|->
name|data_resid
operator|=
name|MIN
argument_list|(
name|descr
operator|->
name|data_resid
argument_list|,
name|SCSI_CDB6_LEN
argument_list|(
name|rsense
operator|->
name|length
argument_list|)
argument_list|)
expr_stmt|;
name|descr
operator|->
name|data_increment
operator|=
name|descr
operator|->
name|data_resid
expr_stmt|;
name|descr
operator|->
name|timeout
operator|=
literal|5
operator|*
literal|1000
expr_stmt|;
name|descr
operator|->
name|status
operator|=
name|SCSI_STATUS_OK
expr_stmt|;
break|break;
block|}
default|default:
comment|/* Constant CA, tell initiator */
comment|/* Direction is always relative to the initator */
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator|&=
operator|~
name|CAM_DIR_MASK
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DIR_NONE
expr_stmt|;
name|atio
operator|->
name|sense_data
operator|=
name|no_lun_sense_data
expr_stmt|;
name|atio
operator|->
name|sense_len
operator|=
sizeof|sizeof
argument_list|(
name|no_lun_sense_data
argument_list|)
expr_stmt|;
name|descr
operator|->
name|data_resid
operator|=
literal|0
expr_stmt|;
name|descr
operator|->
name|data_increment
operator|=
literal|0
expr_stmt|;
name|descr
operator|->
name|timeout
operator|=
literal|5
operator|*
literal|1000
expr_stmt|;
name|descr
operator|->
name|status
operator|=
name|SCSI_STATUS_CHECK_COND
expr_stmt|;
break|break;
block|}
comment|/* Queue us up to receive a Continue Target I/O ccb. */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|softc
operator|->
name|work_queue
argument_list|,
operator|&
name|atio
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|xpt_schedule
argument_list|(
name|periph
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_CONT_TARGET_IO
case|:
block|{
name|struct
name|ccb_accept_tio
modifier|*
name|atio
decl_stmt|;
name|struct
name|targbh_cmd_desc
modifier|*
name|desc
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"Received completed CTIO\n"
operator|)
argument_list|)
expr_stmt|;
name|atio
operator|=
operator|(
expr|struct
name|ccb_accept_tio
operator|*
operator|)
name|done_ccb
operator|->
name|ccb_h
operator|.
name|ccb_atio
expr_stmt|;
name|desc
operator|=
operator|(
expr|struct
name|targbh_cmd_desc
operator|*
operator|)
name|atio
operator|->
name|ccb_h
operator|.
name|ccb_descr
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|softc
operator|->
name|pending_queue
argument_list|,
operator|&
name|atio
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
comment|/* 		 * We could check for CAM_SENT_SENSE bein set here, 		 * but since we're not maintaining any CA/UA state, 		 * there's no point. 		 */
name|atio
operator|->
name|sense_len
operator|=
literal|0
expr_stmt|;
name|done_ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&=
operator|~
name|CAM_SEND_SENSE
expr_stmt|;
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_SENT_SENSE
expr_stmt|;
comment|/* XXX Check for errors */
name|desc
operator|->
name|data_resid
operator|-=
name|desc
operator|->
name|data_increment
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|state
operator|!=
name|TARGBH_STATE_TEARDOWN
condition|)
block|{
comment|/* 			 * Send the original accept TIO back to the 			 * controller to handle more work. 			 */
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"Returning ATIO to target\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Restore wildcards */
name|atio
operator|->
name|ccb_h
operator|.
name|target_id
operator|=
name|CAM_TARGET_WILDCARD
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|target_lun
operator|=
name|CAM_LUN_WILDCARD
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|atio
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|targbhfreedescr
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|atio
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|XPT_IMMED_NOTIFY
case|:
block|{
if|if
condition|(
name|softc
operator|->
name|state
operator|==
name|TARGBH_STATE_TEARDOWN
operator|||
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|==
name|CAM_REQ_ABORTED
condition|)
block|{
name|printf
argument_list|(
literal|"Freed an immediate notify\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|done_ccb
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
name|panic
argument_list|(
literal|"targbhdone: Unexpected ccb opcode"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|NOTYET
end_ifdef

begin_function
specifier|static
name|int
name|targbherror
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|u_int32_t
name|cam_flags
parameter_list|,
name|u_int32_t
name|sense_flags
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|struct
name|targbh_cmd_desc
modifier|*
name|targbhallocdescr
parameter_list|()
block|{
name|struct
name|targbh_cmd_desc
modifier|*
name|descr
decl_stmt|;
comment|/* Allocate the targbh_descr structure */
name|descr
operator|=
operator|(
expr|struct
name|targbh_cmd_desc
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|descr
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|descr
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|bzero
argument_list|(
name|descr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|descr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allocate buffer backing store */
name|descr
operator|->
name|backing_store
operator|=
name|malloc
argument_list|(
name|MAX_BUF_SIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|descr
operator|->
name|backing_store
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|descr
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|descr
operator|->
name|max_size
operator|=
name|MAX_BUF_SIZE
expr_stmt|;
return|return
operator|(
name|descr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|targbhfreedescr
parameter_list|(
name|struct
name|targbh_cmd_desc
modifier|*
name|descr
parameter_list|)
block|{
name|free
argument_list|(
name|descr
operator|->
name|backing_store
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|descr
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

