begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997 Justin T. Gibbs.  * Copyright (c) 1997, 1998, 1999, 2000 Kenneth D. Merry.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * Portions of this driver taken from the original FreeBSD cd driver.  * Written by Julian Elischer (julian@tfs.com)  * for TRW Financial Systems for use under the MACH(2.5) operating system.  *  * TRW Financial Systems, in accordance with their agreement with Carnegie  * Mellon University, makes this software available to CMU to distribute  * or use in any manner that they see fit as long as this message is kept with  * the software. For this reason TFS also grants any other persons or  * organisations permission to use or modify this software.  *  * TFS supplies this software to be publicly redistributed  * on the understanding that TFS is not responsible for the correct  * functioning of this software in any circumstances.  *  * Ported to run under 386BSD by Julian Elischer (julian@tfs.com) Sept 1992  *  *      from: cd.c,v 1.83 1997/05/04 15:24:22 joerg Exp $  */
end_comment

begin_include
include|#
directive|include
file|"opt_cd.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/disk.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/cdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/dvdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/devicestat.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_extend.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_queue.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_da.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_cd.h>
end_include

begin_define
define|#
directive|define
name|LEADOUT
value|0xaa
end_define

begin_comment
comment|/* leadout toc entry */
end_comment

begin_struct
struct|struct
name|cd_params
block|{
name|u_int32_t
name|blksize
decl_stmt|;
name|u_long
name|disksize
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
enum|enum
block|{
name|CD_Q_NONE
init|=
literal|0x00
block|,
name|CD_Q_NO_TOUCH
init|=
literal|0x01
block|,
name|CD_Q_BCD_TRACKS
init|=
literal|0x02
block|,
name|CD_Q_NO_CHANGER
init|=
literal|0x04
block|,
name|CD_Q_CHANGER
init|=
literal|0x08
block|}
name|cd_quirks
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|CD_FLAG_INVALID
init|=
literal|0x001
block|,
name|CD_FLAG_NEW_DISC
init|=
literal|0x002
block|,
name|CD_FLAG_DISC_LOCKED
init|=
literal|0x004
block|,
name|CD_FLAG_DISC_REMOVABLE
init|=
literal|0x008
block|,
name|CD_FLAG_TAGGED_QUEUING
init|=
literal|0x010
block|,
name|CD_FLAG_CHANGER
init|=
literal|0x040
block|,
name|CD_FLAG_ACTIVE
init|=
literal|0x080
block|,
name|CD_FLAG_SCHED_ON_COMP
init|=
literal|0x100
block|,
name|CD_FLAG_RETRY_UA
init|=
literal|0x200
block|}
name|cd_flags
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|CD_CCB_PROBE
init|=
literal|0x01
block|,
name|CD_CCB_BUFFER_IO
init|=
literal|0x02
block|,
name|CD_CCB_WAITING
init|=
literal|0x03
block|,
name|CD_CCB_TYPE_MASK
init|=
literal|0x0F
block|,
name|CD_CCB_RETRY_UA
init|=
literal|0x10
block|}
name|cd_ccb_state
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|CHANGER_TIMEOUT_SCHED
init|=
literal|0x01
block|,
name|CHANGER_SHORT_TMOUT_SCHED
init|=
literal|0x02
block|,
name|CHANGER_MANUAL_CALL
init|=
literal|0x04
block|,
name|CHANGER_NEED_TIMEOUT
init|=
literal|0x08
block|}
name|cd_changer_flags
typedef|;
end_typedef

begin_define
define|#
directive|define
name|ccb_state
value|ppriv_field0
end_define

begin_define
define|#
directive|define
name|ccb_bp
value|ppriv_ptr1
end_define

begin_typedef
typedef|typedef
enum|enum
block|{
name|CD_STATE_PROBE
block|,
name|CD_STATE_NORMAL
block|}
name|cd_state
typedef|;
end_typedef

begin_struct
struct|struct
name|cd_softc
block|{
name|cam_pinfo
name|pinfo
decl_stmt|;
name|cd_state
name|state
decl_stmt|;
specifier|volatile
name|cd_flags
name|flags
decl_stmt|;
name|struct
name|buf_queue_head
name|buf_queue
decl_stmt|;
name|LIST_HEAD
argument_list|(
argument_list|,
argument|ccb_hdr
argument_list|)
name|pending_ccbs
expr_stmt|;
name|struct
name|cd_params
name|params
decl_stmt|;
name|struct
name|disk
name|disk
decl_stmt|;
name|union
name|ccb
name|saved_ccb
decl_stmt|;
name|cd_quirks
name|quirks
decl_stmt|;
name|struct
name|devstat
name|device_stats
decl_stmt|;
name|STAILQ_ENTRY
argument_list|(
argument|cd_softc
argument_list|)
name|changer_links
expr_stmt|;
name|struct
name|cdchanger
modifier|*
name|changer
decl_stmt|;
name|int
name|bufs_left
decl_stmt|;
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|cd_quirk_entry
block|{
name|struct
name|scsi_inquiry_pattern
name|inq_pat
decl_stmt|;
name|cd_quirks
name|quirks
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * These quirk entries aren't strictly necessary.  Basically, what they do  * is tell cdregister() up front that a device is a changer.  Otherwise, it  * will figure that fact out once it sees a LUN on the device that is  * greater than 0.  If it is known up front that a device is a changer, all  * I/O to the device will go through the changer scheduling routines, as  * opposed to the "normal" CD code.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cd_quirk_entry
name|cd_quirk_table
index|[]
init|=
block|{
block|{
block|{
name|T_CDROM
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"NRC"
block|,
literal|"MBR-7"
block|,
literal|"*"
block|}
block|,
comment|/*quirks*/
name|CD_Q_CHANGER
block|}
block|,
block|{
block|{
name|T_CDROM
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"PIONEER"
block|,
literal|"CD-ROM DRM*"
block|,
literal|"*"
block|}
block|,
comment|/* quirks */
name|CD_Q_CHANGER
block|}
block|,
block|{
block|{
name|T_CDROM
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"NAKAMICH"
block|,
literal|"MJ-*"
block|,
literal|"*"
block|}
block|,
comment|/* quirks */
name|CD_Q_CHANGER
block|}
block|,
block|{
block|{
name|T_CDROM
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"CHINON"
block|,
literal|"CD-ROM CDS-535"
block|,
literal|"*"
block|}
block|,
comment|/* quirks */
name|CD_Q_BCD_TRACKS
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|MIN
end_ifndef

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x<y) ? x : y)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CD_CDEV_MAJOR
value|15
end_define

begin_define
define|#
directive|define
name|CD_BDEV_MAJOR
value|6
end_define

begin_decl_stmt
specifier|static
name|d_open_t
name|cdopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|cdclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|cdioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_strategy_t
name|cdstrategy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_init_t
name|cdinit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_ctor_t
name|cdregister
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_dtor_t
name|cdcleanup
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_start_t
name|cdstart
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_oninv_t
name|cdoninvalidate
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|cdasync
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|u_int32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cdshorttimeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cdschedule
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|priority
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cdrunchangerqueue
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cdchangerschedule
parameter_list|(
name|struct
name|cd_softc
modifier|*
name|softc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cdrunccb
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|int
function_decl|(
modifier|*
name|error_routine
function_decl|)
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|u_int32_t
name|cam_flags
parameter_list|,
name|u_int32_t
name|sense_flags
parameter_list|)
parameter_list|,
name|u_int32_t
name|cam_flags
parameter_list|,
name|u_int32_t
name|sense_flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|union
name|ccb
modifier|*
name|cdgetccb
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|u_int32_t
name|priority
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cddone
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|start_ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cderror
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|u_int32_t
name|cam_flags
parameter_list|,
name|u_int32_t
name|sense_flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cdprevent
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|action
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cdsize
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|u_int32_t
modifier|*
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cdfirsttrackisdata
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cdreadtoc
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|u_int32_t
name|mode
parameter_list|,
name|u_int32_t
name|start
parameter_list|,
name|struct
name|cd_toc_entry
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cdgetmode
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|cd_mode_data
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|page
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cdsetmode
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|cd_mode_data
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cdplay
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|u_int32_t
name|blk
parameter_list|,
name|u_int32_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cdreadsubchannel
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|u_int32_t
name|mode
parameter_list|,
name|u_int32_t
name|format
parameter_list|,
name|int
name|track
parameter_list|,
name|struct
name|cd_sub_channel_info
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cdplaymsf
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|u_int32_t
name|startm
parameter_list|,
name|u_int32_t
name|starts
parameter_list|,
name|u_int32_t
name|startf
parameter_list|,
name|u_int32_t
name|endm
parameter_list|,
name|u_int32_t
name|ends
parameter_list|,
name|u_int32_t
name|endf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cdplaytracks
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|u_int32_t
name|strack
parameter_list|,
name|u_int32_t
name|sindex
parameter_list|,
name|u_int32_t
name|etrack
parameter_list|,
name|u_int32_t
name|eindex
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cdpause
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|u_int32_t
name|go
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cdstopunit
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|u_int32_t
name|eject
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cdstartunit
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cdreportkey
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|dvd_authinfo
modifier|*
name|authinfo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cdsendkey
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|dvd_authinfo
modifier|*
name|authinfo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cdreaddvdstructure
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|dvd_struct
modifier|*
name|dvdstruct
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|periph_driver
name|cddriver
init|=
block|{
name|cdinit
block|,
literal|"cd"
block|,
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|cddriver
operator|.
name|units
argument_list|)
block|,
comment|/* generation */
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DATA_SET
argument_list|(
name|periphdriver_set
argument_list|,
name|cddriver
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* For 2.2-stable support */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|D_DISK
end_ifndef

begin_define
define|#
directive|define
name|D_DISK
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|cd_cdevsw
init|=
block|{
comment|/* open */
name|cdopen
block|,
comment|/* close */
name|cdclose
block|,
comment|/* read */
name|physread
block|,
comment|/* write */
name|physwrite
block|,
comment|/* ioctl */
name|cdioctl
block|,
comment|/* poll */
name|nopoll
block|,
comment|/* mmap */
name|nommap
block|,
comment|/* strategy */
name|cdstrategy
block|,
comment|/* name */
literal|"cd"
block|,
comment|/* maj */
name|CD_CDEV_MAJOR
block|,
comment|/* dump */
name|nodump
block|,
comment|/* psize */
name|nopsize
block|,
comment|/* flags */
name|D_DISK
block|,
comment|/* bmaj */
name|CD_BDEV_MAJOR
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|cddisk_cdevsw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|extend_array
modifier|*
name|cdperiphs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|num_changers
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|CHANGER_MIN_BUSY_SECONDS
end_ifndef

begin_define
define|#
directive|define
name|CHANGER_MIN_BUSY_SECONDS
value|5
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CHANGER_MAX_BUSY_SECONDS
end_ifndef

begin_define
define|#
directive|define
name|CHANGER_MAX_BUSY_SECONDS
value|15
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|changer_min_busy_seconds
init|=
name|CHANGER_MIN_BUSY_SECONDS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|changer_max_busy_seconds
init|=
name|CHANGER_MAX_BUSY_SECONDS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * XXX KDM this CAM node should be moved if we ever get more CAM sysctl  * variables.  */
end_comment

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|cam
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"CAM Subsystem"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_kern_cam
argument_list|,
name|OID_AUTO
argument_list|,
name|cd
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"CAM CDROM driver"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_kern_cam_cd
argument_list|,
name|OID_AUTO
argument_list|,
name|changer
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"CD Changer"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_cam_cd_changer
argument_list|,
name|OID_AUTO
argument_list|,
name|min_busy_seconds
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|changer_min_busy_seconds
argument_list|,
literal|0
argument_list|,
literal|"Minimum changer scheduling quantum"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_cam_cd_changer
argument_list|,
name|OID_AUTO
argument_list|,
name|max_busy_seconds
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|changer_max_busy_seconds
argument_list|,
literal|0
argument_list|,
literal|"Maximum changer scheduling quantum"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|cdchanger
block|{
name|path_id_t
name|path_id
decl_stmt|;
name|target_id_t
name|target_id
decl_stmt|;
name|int
name|num_devices
decl_stmt|;
name|struct
name|camq
name|devq
decl_stmt|;
name|struct
name|timeval
name|start_time
decl_stmt|;
name|struct
name|cd_softc
modifier|*
name|cur_device
decl_stmt|;
name|struct
name|callout_handle
name|short_handle
decl_stmt|;
name|struct
name|callout_handle
name|long_handle
decl_stmt|;
specifier|volatile
name|cd_changer_flags
name|flags
decl_stmt|;
name|STAILQ_ENTRY
argument_list|(
argument|cdchanger
argument_list|)
name|changer_links
expr_stmt|;
name|STAILQ_HEAD
argument_list|(
argument|chdevlist
argument_list|,
argument|cd_softc
argument_list|)
name|chluns
expr_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|STAILQ_HEAD
argument_list|(
argument|changerlist
argument_list|,
argument|cdchanger
argument_list|)
name|changerq
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|cdinit
parameter_list|(
name|void
parameter_list|)
block|{
name|cam_status
name|status
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
comment|/* 	 * Create our extend array for storing the devices we attach to. 	 */
name|cdperiphs
operator|=
name|cam_extend_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|cdperiphs
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"cd: Failed to alloc extend array!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Install a global async callback.  This callback will 	 * receive async callbacks like "new device found". 	 */
name|status
operator|=
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|CAM_XPT_PATH_ID
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|CAM_REQ_CMP
condition|)
block|{
name|struct
name|ccb_setasync
name|csa
decl_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|csa
operator|.
name|ccb_h
argument_list|,
name|path
argument_list|,
comment|/*priority*/
literal|5
argument_list|)
expr_stmt|;
name|csa
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SASYNC_CB
expr_stmt|;
name|csa
operator|.
name|event_enable
operator|=
name|AC_FOUND_DEVICE
expr_stmt|;
name|csa
operator|.
name|callback
operator|=
name|cdasync
expr_stmt|;
name|csa
operator|.
name|callback_arg
operator|=
name|NULL
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|csa
argument_list|)
expr_stmt|;
name|status
operator|=
name|csa
operator|.
name|ccb_h
operator|.
name|status
expr_stmt|;
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"cd: Failed to attach master async callback "
literal|"due to status 0x%x!\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cdoninvalidate
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|struct
name|cd_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|buf
modifier|*
name|q_bp
decl_stmt|;
name|struct
name|ccb_setasync
name|csa
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|cd_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
comment|/* 	 * De-register any async callbacks. 	 */
name|xpt_setup_ccb
argument_list|(
operator|&
name|csa
operator|.
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
comment|/* priority */
literal|5
argument_list|)
expr_stmt|;
name|csa
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SASYNC_CB
expr_stmt|;
name|csa
operator|.
name|event_enable
operator|=
literal|0
expr_stmt|;
name|csa
operator|.
name|callback
operator|=
name|cdasync
expr_stmt|;
name|csa
operator|.
name|callback_arg
operator|=
name|periph
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|csa
argument_list|)
expr_stmt|;
name|softc
operator|->
name|flags
operator||=
name|CD_FLAG_INVALID
expr_stmt|;
comment|/* 	 * Although the oninvalidate() routines are always called at 	 * splsoftcam, we need to be at splbio() here to keep the buffer 	 * queue from being modified while we traverse it. 	 */
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* 	 * Return all queued I/O with ENXIO. 	 * XXX Handle any transactions queued to the card 	 *     with XPT_ABORT_CCB. 	 */
while|while
condition|(
operator|(
name|q_bp
operator|=
name|bufq_first
argument_list|(
operator|&
name|softc
operator|->
name|buf_queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|bufq_remove
argument_list|(
operator|&
name|softc
operator|->
name|buf_queue
argument_list|,
name|q_bp
argument_list|)
expr_stmt|;
name|q_bp
operator|->
name|b_resid
operator|=
name|q_bp
operator|->
name|b_bcount
expr_stmt|;
name|q_bp
operator|->
name|b_error
operator|=
name|ENXIO
expr_stmt|;
name|q_bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|biodone
argument_list|(
name|q_bp
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * If this device is part of a changer, and it was scheduled 	 * to run, remove it from the run queue since we just nuked 	 * all of its scheduled I/O. 	 */
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|CD_FLAG_CHANGER
operator|)
operator|&&
operator|(
name|softc
operator|->
name|pinfo
operator|.
name|index
operator|!=
name|CAM_UNQUEUED_INDEX
operator|)
condition|)
name|camq_remove
argument_list|(
operator|&
name|softc
operator|->
name|changer
operator|->
name|devq
argument_list|,
name|softc
operator|->
name|pinfo
operator|.
name|index
argument_list|)
expr_stmt|;
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"lost device\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cdcleanup
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|struct
name|cd_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|s
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|cd_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"removing device entry\n"
argument_list|)
expr_stmt|;
name|s
operator|=
name|splsoftcam
argument_list|()
expr_stmt|;
comment|/* 	 * In the queued, non-active case, the device in question 	 * has already been removed from the changer run queue.  Since this 	 * device is active, we need to de-activate it, and schedule 	 * another device to run.  (if there is another one to run) 	 */
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|CD_FLAG_CHANGER
operator|)
operator|&&
operator|(
name|softc
operator|->
name|flags
operator|&
name|CD_FLAG_ACTIVE
operator|)
condition|)
block|{
comment|/* 		 * The purpose of the short timeout is soley to determine 		 * whether the current device has finished or not.  Well, 		 * since we're removing the active device, we know that it 		 * is finished.  So, get rid of the short timeout. 		 * Otherwise, if we're in the time period before the short 		 * timeout fires, and there are no other devices in the 		 * queue to run, there won't be any other device put in the 		 * active slot.  i.e., when we call cdrunchangerqueue() 		 * below, it won't do anything.  Then, when the short 		 * timeout fires, it'll look at the "current device", which 		 * we are free below, and possibly panic the kernel on a 		 * bogus pointer reference. 		 * 		 * The long timeout doesn't really matter, since we 		 * decrement the qfrozen_cnt to indicate that there is 		 * nothing in the active slot now.  Therefore, there won't 		 * be any bogus pointer references there. 		 */
if|if
condition|(
name|softc
operator|->
name|changer
operator|->
name|flags
operator|&
name|CHANGER_SHORT_TMOUT_SCHED
condition|)
block|{
name|untimeout
argument_list|(
name|cdshorttimeout
argument_list|,
name|softc
operator|->
name|changer
argument_list|,
name|softc
operator|->
name|changer
operator|->
name|short_handle
argument_list|)
expr_stmt|;
name|softc
operator|->
name|changer
operator|->
name|flags
operator|&=
operator|~
name|CHANGER_SHORT_TMOUT_SCHED
expr_stmt|;
block|}
name|softc
operator|->
name|changer
operator|->
name|devq
operator|.
name|qfrozen_cnt
operator|--
expr_stmt|;
name|softc
operator|->
name|changer
operator|->
name|flags
operator||=
name|CHANGER_MANUAL_CALL
expr_stmt|;
name|cdrunchangerqueue
argument_list|(
name|softc
operator|->
name|changer
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we're removing the last device on the changer, go ahead and 	 * remove the changer device structure. 	 */
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|CD_FLAG_CHANGER
operator|)
operator|&&
operator|(
operator|--
name|softc
operator|->
name|changer
operator|->
name|num_devices
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * Theoretically, there shouldn't be any timeouts left, but 		 * I'm not completely sure that that will be the case.  So, 		 * it won't hurt to check and see if there are any left. 		 */
if|if
condition|(
name|softc
operator|->
name|changer
operator|->
name|flags
operator|&
name|CHANGER_TIMEOUT_SCHED
condition|)
block|{
name|untimeout
argument_list|(
name|cdrunchangerqueue
argument_list|,
name|softc
operator|->
name|changer
argument_list|,
name|softc
operator|->
name|changer
operator|->
name|long_handle
argument_list|)
expr_stmt|;
name|softc
operator|->
name|changer
operator|->
name|flags
operator|&=
operator|~
name|CHANGER_TIMEOUT_SCHED
expr_stmt|;
block|}
if|if
condition|(
name|softc
operator|->
name|changer
operator|->
name|flags
operator|&
name|CHANGER_SHORT_TMOUT_SCHED
condition|)
block|{
name|untimeout
argument_list|(
name|cdshorttimeout
argument_list|,
name|softc
operator|->
name|changer
argument_list|,
name|softc
operator|->
name|changer
operator|->
name|short_handle
argument_list|)
expr_stmt|;
name|softc
operator|->
name|changer
operator|->
name|flags
operator|&=
operator|~
name|CHANGER_SHORT_TMOUT_SCHED
expr_stmt|;
block|}
name|STAILQ_REMOVE
argument_list|(
operator|&
name|changerq
argument_list|,
name|softc
operator|->
name|changer
argument_list|,
name|cdchanger
argument_list|,
name|changer_links
argument_list|)
expr_stmt|;
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"removing changer entry\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|softc
operator|->
name|changer
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|num_changers
operator|--
expr_stmt|;
block|}
name|devstat_remove_entry
argument_list|(
operator|&
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
name|cam_extend_release
argument_list|(
name|cdperiphs
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|disk
operator|.
name|d_dev
condition|)
block|{
name|disk_destroy
argument_list|(
name|softc
operator|->
name|disk
operator|.
name|d_dev
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|softc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cdasync
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|u_int32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|periph
operator|=
operator|(
expr|struct
name|cam_periph
operator|*
operator|)
name|callback_arg
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|AC_FOUND_DEVICE
case|:
block|{
name|struct
name|ccb_getdev
modifier|*
name|cgd
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|cgd
operator|=
operator|(
expr|struct
name|ccb_getdev
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|SID_TYPE
argument_list|(
operator|&
name|cgd
operator|->
name|inq_data
argument_list|)
operator|!=
name|T_CDROM
operator|&&
name|SID_TYPE
argument_list|(
operator|&
name|cgd
operator|->
name|inq_data
argument_list|)
operator|!=
name|T_WORM
condition|)
break|break;
comment|/* 		 * Allocate a peripheral instance for 		 * this device and start the probe 		 * process. 		 */
name|status
operator|=
name|cam_periph_alloc
argument_list|(
name|cdregister
argument_list|,
name|cdoninvalidate
argument_list|,
name|cdcleanup
argument_list|,
name|cdstart
argument_list|,
literal|"cd"
argument_list|,
name|CAM_PERIPH_BIO
argument_list|,
name|cgd
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|cdasync
argument_list|,
name|AC_FOUND_DEVICE
argument_list|,
name|cgd
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
operator|&&
name|status
operator|!=
name|CAM_REQ_INPROG
condition|)
name|printf
argument_list|(
literal|"cdasync: Unable to attach new device "
literal|"due to status 0x%x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|AC_SENT_BDR
case|:
case|case
name|AC_BUS_RESET
case|:
block|{
name|struct
name|cd_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccbh
decl_stmt|;
name|int
name|s
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|cd_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|s
operator|=
name|splsoftcam
argument_list|()
expr_stmt|;
comment|/* 		 * Don't fail on the expected unit attention 		 * that will occur. 		 */
name|softc
operator|->
name|flags
operator||=
name|CD_FLAG_RETRY_UA
expr_stmt|;
for|for
control|(
name|ccbh
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|softc
operator|->
name|pending_ccbs
argument_list|)
init|;
name|ccbh
operator|!=
name|NULL
condition|;
name|ccbh
operator|=
name|LIST_NEXT
argument_list|(
name|ccbh
argument_list|,
name|periph_links
operator|.
name|le
argument_list|)
control|)
name|ccbh
operator|->
name|ccb_state
operator||=
name|CD_CCB_RETRY_UA
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
block|}
default|default:
name|cam_periph_async
argument_list|(
name|periph
argument_list|,
name|code
argument_list|,
name|path
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|cam_status
name|cdregister
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cd_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ccb_setasync
name|csa
decl_stmt|;
name|struct
name|ccb_getdev
modifier|*
name|cgd
decl_stmt|;
name|caddr_t
name|match
decl_stmt|;
name|cgd
operator|=
operator|(
expr|struct
name|ccb_getdev
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"cdregister: periph was NULL!!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
if|if
condition|(
name|cgd
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"cdregister: no getdev CCB, can't register device\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
name|softc
operator|=
operator|(
expr|struct
name|cd_softc
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|softc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"cdregister: Unable to probe new device. "
literal|"Unable to allocate softc\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
name|bzero
argument_list|(
name|softc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|softc
argument_list|)
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|softc
operator|->
name|pending_ccbs
argument_list|)
expr_stmt|;
name|softc
operator|->
name|state
operator|=
name|CD_STATE_PROBE
expr_stmt|;
name|bufq_init
argument_list|(
operator|&
name|softc
operator|->
name|buf_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|SID_IS_REMOVABLE
argument_list|(
operator|&
name|cgd
operator|->
name|inq_data
argument_list|)
condition|)
name|softc
operator|->
name|flags
operator||=
name|CD_FLAG_DISC_REMOVABLE
expr_stmt|;
if|if
condition|(
operator|(
name|cgd
operator|->
name|inq_data
operator|.
name|flags
operator|&
name|SID_CmdQue
operator|)
operator|!=
literal|0
condition|)
name|softc
operator|->
name|flags
operator||=
name|CD_FLAG_TAGGED_QUEUING
expr_stmt|;
name|periph
operator|->
name|softc
operator|=
name|softc
expr_stmt|;
name|softc
operator|->
name|periph
operator|=
name|periph
expr_stmt|;
name|cam_extend_set
argument_list|(
name|cdperiphs
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|,
name|periph
argument_list|)
expr_stmt|;
comment|/* 	 * See if this device has any quirks. 	 */
name|match
operator|=
name|cam_quirkmatch
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|cgd
operator|->
name|inq_data
argument_list|,
operator|(
name|caddr_t
operator|)
name|cd_quirk_table
argument_list|,
sizeof|sizeof
argument_list|(
name|cd_quirk_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|cd_quirk_table
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cd_quirk_table
argument_list|)
argument_list|,
name|scsi_inquiry_match
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
operator|!=
name|NULL
condition|)
name|softc
operator|->
name|quirks
operator|=
operator|(
operator|(
expr|struct
name|cd_quirk_entry
operator|*
operator|)
name|match
operator|)
operator|->
name|quirks
expr_stmt|;
else|else
name|softc
operator|->
name|quirks
operator|=
name|CD_Q_NONE
expr_stmt|;
comment|/* 	 * We need to register the statistics structure for this device, 	 * but we don't have the blocksize yet for it.  So, we register 	 * the structure and indicate that we don't have the blocksize 	 * yet.  Unlike other SCSI peripheral drivers, we explicitly set 	 * the device type here to be CDROM, rather than just ORing in 	 * the device type.  This is because this driver can attach to either 	 * CDROM or WORM devices, and we want this peripheral driver to 	 * show up in the devstat list as a CD peripheral driver, not a 	 * WORM peripheral driver.  WORM drives will also have the WORM 	 * driver attached to them. 	 */
name|devstat_add_entry
argument_list|(
operator|&
name|softc
operator|->
name|device_stats
argument_list|,
literal|"cd"
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|,
literal|0
argument_list|,
name|DEVSTAT_BS_UNAVAILABLE
argument_list|,
name|DEVSTAT_TYPE_CDROM
operator||
name|DEVSTAT_TYPE_IF_SCSI
argument_list|,
name|DEVSTAT_PRIORITY_CD
argument_list|)
expr_stmt|;
name|disk_create
argument_list|(
name|periph
operator|->
name|unit_number
argument_list|,
operator|&
name|softc
operator|->
name|disk
argument_list|,
name|DSO_ONESLICE
operator||
name|DSO_COMPATLABEL
argument_list|,
operator|&
name|cd_cdevsw
argument_list|,
operator|&
name|cddisk_cdevsw
argument_list|)
expr_stmt|;
comment|/* 	 * Add an async callback so that we get 	 * notified if this device goes away. 	 */
name|xpt_setup_ccb
argument_list|(
operator|&
name|csa
operator|.
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
comment|/* priority */
literal|5
argument_list|)
expr_stmt|;
name|csa
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SASYNC_CB
expr_stmt|;
name|csa
operator|.
name|event_enable
operator|=
name|AC_SENT_BDR
operator||
name|AC_BUS_RESET
operator||
name|AC_LOST_DEVICE
expr_stmt|;
name|csa
operator|.
name|callback
operator|=
name|cdasync
expr_stmt|;
name|csa
operator|.
name|callback_arg
operator|=
name|periph
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|csa
argument_list|)
expr_stmt|;
comment|/* 	 * If the target lun is greater than 0, we most likely have a CD 	 * changer device.  Check the quirk entries as well, though, just 	 * in case someone has a CD tower with one lun per drive or 	 * something like that.  Also, if we know up front that a 	 * particular device is a changer, we can mark it as such starting 	 * with lun 0, instead of lun 1.  It shouldn't be necessary to have 	 * a quirk entry to define something as a changer, however. 	 */
if|if
condition|(
operator|(
operator|(
name|cgd
operator|->
name|ccb_h
operator|.
name|target_lun
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|(
name|softc
operator|->
name|quirks
operator|&
name|CD_Q_NO_CHANGER
operator|)
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
operator|(
name|softc
operator|->
name|quirks
operator|&
name|CD_Q_CHANGER
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|struct
name|cdchanger
modifier|*
name|nchanger
decl_stmt|;
name|struct
name|cam_periph
modifier|*
name|nperiph
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|int
name|found
decl_stmt|;
comment|/* Set the changer flag in the current device's softc */
name|softc
operator|->
name|flags
operator||=
name|CD_FLAG_CHANGER
expr_stmt|;
if|if
condition|(
name|num_changers
operator|==
literal|0
condition|)
name|STAILQ_INIT
argument_list|(
operator|&
name|changerq
argument_list|)
expr_stmt|;
comment|/* 		 * Now, look around for an existing changer device with the 		 * same path and target ID as the current device. 		 */
for|for
control|(
name|found
operator|=
literal|0
operator|,
name|nchanger
operator|=
operator|(
expr|struct
name|cdchanger
operator|*
operator|)
name|STAILQ_FIRST
argument_list|(
operator|&
name|changerq
argument_list|)
init|;
name|nchanger
operator|!=
name|NULL
condition|;
name|nchanger
operator|=
name|STAILQ_NEXT
argument_list|(
name|nchanger
argument_list|,
name|changer_links
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|nchanger
operator|->
name|path_id
operator|==
name|cgd
operator|->
name|ccb_h
operator|.
name|path_id
operator|)
operator|&&
operator|(
name|nchanger
operator|->
name|target_id
operator|==
name|cgd
operator|->
name|ccb_h
operator|.
name|target_id
operator|)
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* 		 * If we found a matching entry, just add this device to 		 * the list of devices on this changer. 		 */
if|if
condition|(
name|found
operator|==
literal|1
condition|)
block|{
name|struct
name|chdevlist
modifier|*
name|chlunhead
decl_stmt|;
name|chlunhead
operator|=
operator|&
name|nchanger
operator|->
name|chluns
expr_stmt|;
comment|/* 			 * XXX KDM look at consolidating this code with the 			 * code below in a separate function. 			 */
comment|/* 			 * Create a path with lun id 0, and see if we can 			 * find a matching device 			 */
name|status
operator|=
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
comment|/*periph*/
name|periph
argument_list|,
name|cgd
operator|->
name|ccb_h
operator|.
name|path_id
argument_list|,
name|cgd
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|==
name|CAM_REQ_CMP
operator|)
operator|&&
operator|(
operator|(
name|nperiph
operator|=
name|cam_periph_find
argument_list|(
name|path
argument_list|,
literal|"cd"
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
condition|)
block|{
name|struct
name|cd_softc
modifier|*
name|nsoftc
decl_stmt|;
name|nsoftc
operator|=
operator|(
expr|struct
name|cd_softc
operator|*
operator|)
name|nperiph
operator|->
name|softc
expr_stmt|;
if|if
condition|(
operator|(
name|nsoftc
operator|->
name|flags
operator|&
name|CD_FLAG_CHANGER
operator|)
operator|==
literal|0
condition|)
block|{
name|nsoftc
operator|->
name|flags
operator||=
name|CD_FLAG_CHANGER
expr_stmt|;
name|nchanger
operator|->
name|num_devices
operator|++
expr_stmt|;
if|if
condition|(
name|camq_resize
argument_list|(
operator|&
name|nchanger
operator|->
name|devq
argument_list|,
name|nchanger
operator|->
name|num_devices
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"cdregister: "
literal|"camq_resize "
literal|"failed, changer "
literal|"support may "
literal|"be messed up\n"
argument_list|)
expr_stmt|;
block|}
name|nsoftc
operator|->
name|changer
operator|=
name|nchanger
expr_stmt|;
name|nsoftc
operator|->
name|pinfo
operator|.
name|index
operator|=
name|CAM_UNQUEUED_INDEX
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|nchanger
operator|->
name|chluns
argument_list|,
name|nsoftc
argument_list|,
name|changer_links
argument_list|)
expr_stmt|;
block|}
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|CAM_REQ_CMP
condition|)
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"cdregister: unable to allocate path\n"
literal|"cdregister: changer support may be "
literal|"broken\n"
argument_list|)
expr_stmt|;
block|}
name|nchanger
operator|->
name|num_devices
operator|++
expr_stmt|;
name|softc
operator|->
name|changer
operator|=
name|nchanger
expr_stmt|;
name|softc
operator|->
name|pinfo
operator|.
name|index
operator|=
name|CAM_UNQUEUED_INDEX
expr_stmt|;
if|if
condition|(
name|camq_resize
argument_list|(
operator|&
name|nchanger
operator|->
name|devq
argument_list|,
name|nchanger
operator|->
name|num_devices
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"cdregister: camq_resize "
literal|"failed, changer support may "
literal|"be messed up\n"
argument_list|)
expr_stmt|;
block|}
name|STAILQ_INSERT_TAIL
argument_list|(
name|chlunhead
argument_list|,
name|softc
argument_list|,
name|changer_links
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * In this case, we don't already have an entry for this 		 * particular changer, so we need to create one, add it to 		 * the queue, and queue this device on the list for this 		 * changer.  Before we queue this device, however, we need 		 * to search for lun id 0 on this target, and add it to the 		 * queue first, if it exists.  (and if it hasn't already 		 * been marked as part of the changer.) 		 */
else|else
block|{
name|nchanger
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cdchanger
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|nchanger
operator|==
name|NULL
condition|)
block|{
name|softc
operator|->
name|flags
operator|&=
operator|~
name|CD_FLAG_CHANGER
expr_stmt|;
name|printf
argument_list|(
literal|"cdregister: unable to malloc "
literal|"changer structure\ncdregister: "
literal|"changer support disabled\n"
argument_list|)
expr_stmt|;
comment|/* 				 * Yes, gotos can be gross but in this case 				 * I think it's justified.. 				 */
goto|goto
name|cdregisterexit
goto|;
block|}
comment|/* zero the structure */
name|bzero
argument_list|(
name|nchanger
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cdchanger
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|camq_init
argument_list|(
operator|&
name|nchanger
operator|->
name|devq
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|softc
operator|->
name|flags
operator|&=
operator|~
name|CD_FLAG_CHANGER
expr_stmt|;
name|printf
argument_list|(
literal|"cdregister: changer support "
literal|"disabled\n"
argument_list|)
expr_stmt|;
goto|goto
name|cdregisterexit
goto|;
block|}
name|num_changers
operator|++
expr_stmt|;
name|nchanger
operator|->
name|path_id
operator|=
name|cgd
operator|->
name|ccb_h
operator|.
name|path_id
expr_stmt|;
name|nchanger
operator|->
name|target_id
operator|=
name|cgd
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
comment|/* this is superfluous, but it makes things clearer */
name|nchanger
operator|->
name|num_devices
operator|=
literal|0
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|nchanger
operator|->
name|chluns
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|changerq
argument_list|,
name|nchanger
argument_list|,
name|changer_links
argument_list|)
expr_stmt|;
comment|/* 			 * Create a path with lun id 0, and see if we can 			 * find a matching device 			 */
name|status
operator|=
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
comment|/*periph*/
name|periph
argument_list|,
name|cgd
operator|->
name|ccb_h
operator|.
name|path_id
argument_list|,
name|cgd
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 			 * If we were able to allocate the path, and if we 			 * find a matching device and it isn't already 			 * marked as part of a changer, then we add it to 			 * the current changer. 			 */
if|if
condition|(
operator|(
name|status
operator|==
name|CAM_REQ_CMP
operator|)
operator|&&
operator|(
operator|(
name|nperiph
operator|=
name|cam_periph_find
argument_list|(
name|path
argument_list|,
literal|"cd"
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
operator|(
operator|(
expr|struct
name|cd_softc
operator|*
operator|)
name|periph
operator|->
name|softc
operator|)
operator|->
name|flags
operator|&
name|CD_FLAG_CHANGER
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|struct
name|cd_softc
modifier|*
name|nsoftc
decl_stmt|;
name|nsoftc
operator|=
operator|(
expr|struct
name|cd_softc
operator|*
operator|)
name|nperiph
operator|->
name|softc
expr_stmt|;
name|nsoftc
operator|->
name|flags
operator||=
name|CD_FLAG_CHANGER
expr_stmt|;
name|nchanger
operator|->
name|num_devices
operator|++
expr_stmt|;
if|if
condition|(
name|camq_resize
argument_list|(
operator|&
name|nchanger
operator|->
name|devq
argument_list|,
name|nchanger
operator|->
name|num_devices
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"cdregister: camq_resize "
literal|"failed, changer support may "
literal|"be messed up\n"
argument_list|)
expr_stmt|;
block|}
name|nsoftc
operator|->
name|changer
operator|=
name|nchanger
expr_stmt|;
name|nsoftc
operator|->
name|pinfo
operator|.
name|index
operator|=
name|CAM_UNQUEUED_INDEX
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|nchanger
operator|->
name|chluns
argument_list|,
name|nsoftc
argument_list|,
name|changer_links
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|CAM_REQ_CMP
condition|)
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"cdregister: unable to allocate path\n"
literal|"cdregister: changer support may be "
literal|"broken\n"
argument_list|)
expr_stmt|;
block|}
name|softc
operator|->
name|changer
operator|=
name|nchanger
expr_stmt|;
name|softc
operator|->
name|pinfo
operator|.
name|index
operator|=
name|CAM_UNQUEUED_INDEX
expr_stmt|;
name|nchanger
operator|->
name|num_devices
operator|++
expr_stmt|;
if|if
condition|(
name|camq_resize
argument_list|(
operator|&
name|nchanger
operator|->
name|devq
argument_list|,
name|nchanger
operator|->
name|num_devices
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"cdregister: camq_resize "
literal|"failed, changer support may "
literal|"be messed up\n"
argument_list|)
expr_stmt|;
block|}
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|nchanger
operator|->
name|chluns
argument_list|,
name|softc
argument_list|,
name|changer_links
argument_list|)
expr_stmt|;
block|}
block|}
name|cdregisterexit
label|:
comment|/* Lock this peripheral until we are setup */
comment|/* Can't block */
name|cam_periph_lock
argument_list|(
name|periph
argument_list|,
name|PRIBIO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|CD_FLAG_CHANGER
operator|)
operator|==
literal|0
condition|)
name|xpt_schedule
argument_list|(
name|periph
argument_list|,
comment|/*priority*/
literal|5
argument_list|)
expr_stmt|;
else|else
name|cdschedule
argument_list|(
name|periph
argument_list|,
comment|/*priority*/
literal|5
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cdopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|disklabel
modifier|*
name|label
decl_stmt|;
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|cd_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ccb_getdev
name|cgd
decl_stmt|;
name|u_int32_t
name|size
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|error
decl_stmt|;
name|int
name|s
decl_stmt|;
name|unit
operator|=
name|dkunit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|periph
operator|=
name|cam_extend_get
argument_list|(
name|cdperiphs
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|softc
operator|=
operator|(
expr|struct
name|cd_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
comment|/* 	 * Grab splsoftcam and hold it until we lock the peripheral. 	 */
name|s
operator|=
name|splsoftcam
argument_list|()
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|flags
operator|&
name|CD_FLAG_INVALID
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|cam_periph_lock
argument_list|(
name|periph
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|cam_periph_acquire
argument_list|(
name|periph
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|cdprevent
argument_list|(
name|periph
argument_list|,
name|PR_PREVENT
argument_list|)
expr_stmt|;
comment|/* find out the size */
if|if
condition|(
operator|(
name|error
operator|=
name|cdsize
argument_list|(
name|dev
argument_list|,
operator|&
name|size
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|cdprevent
argument_list|(
name|periph
argument_list|,
name|PR_ALLOW
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|cam_periph_release
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * If we get a non-zero return, revert back to not reading the 	 * label off the disk.  The first track is likely audio, which 	 * won't have a disklabel. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|cdfirsttrackisdata
argument_list|(
name|periph
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|softc
operator|->
name|disk
operator|.
name|d_dsflags
operator|&=
operator|~
name|DSO_COMPATLABEL
expr_stmt|;
name|softc
operator|->
name|disk
operator|.
name|d_dsflags
operator||=
name|DSO_NOLABELS
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Build prototype label for whole disk. 	 * Should take information about different data tracks from the 	 * TOC and put it in the partition table. 	 */
name|label
operator|=
operator|&
name|softc
operator|->
name|disk
operator|.
name|d_label
expr_stmt|;
name|bzero
argument_list|(
name|label
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|label
operator|->
name|d_type
operator|=
name|DTYPE_SCSI
expr_stmt|;
comment|/* 	 * Grab the inquiry data to get the vendor and product names. 	 * Put them in the typename and packname for the label. 	 */
name|xpt_setup_ccb
argument_list|(
operator|&
name|cgd
operator|.
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|cgd
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_GDEV_TYPE
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|cgd
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|label
operator|->
name|d_typename
argument_list|,
name|cgd
operator|.
name|inq_data
operator|.
name|vendor
argument_list|,
name|min
argument_list|(
name|SID_VENDOR_SIZE
argument_list|,
sizeof|sizeof
argument_list|(
name|label
operator|->
name|d_typename
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|label
operator|->
name|d_packname
argument_list|,
name|cgd
operator|.
name|inq_data
operator|.
name|product
argument_list|,
name|min
argument_list|(
name|SID_PRODUCT_SIZE
argument_list|,
sizeof|sizeof
argument_list|(
name|label
operator|->
name|d_packname
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|label
operator|->
name|d_secsize
operator|=
name|softc
operator|->
name|params
operator|.
name|blksize
expr_stmt|;
name|label
operator|->
name|d_secperunit
operator|=
name|softc
operator|->
name|params
operator|.
name|disksize
expr_stmt|;
name|label
operator|->
name|d_flags
operator|=
name|D_REMOVABLE
expr_stmt|;
comment|/* 	 * Make partition 'a' cover the whole disk.  This is a temporary 	 * compatibility hack.  The 'a' partition should not exist, so 	 * the slice code won't create it.  The slice code will make 	 * partition (RAW_PART + 'a') cover the whole disk and fill in 	 * some more defaults. 	 */
name|label
operator|->
name|d_partitions
index|[
literal|0
index|]
operator|.
name|p_size
operator|=
name|label
operator|->
name|d_secperunit
expr_stmt|;
name|label
operator|->
name|d_partitions
index|[
literal|0
index|]
operator|.
name|p_fstype
operator|=
name|FS_OTHER
expr_stmt|;
comment|/* 	 * We unconditionally (re)set the blocksize each time the 	 * CD device is opened.  This is because the CD can change, 	 * and therefore the blocksize might change. 	 * XXX problems here if some slice or partition is still 	 * open with the old size? 	 */
if|if
condition|(
operator|(
name|softc
operator|->
name|device_stats
operator|.
name|flags
operator|&
name|DEVSTAT_BS_UNAVAILABLE
operator|)
operator|!=
literal|0
condition|)
name|softc
operator|->
name|device_stats
operator|.
name|flags
operator|&=
operator|~
name|DEVSTAT_BS_UNAVAILABLE
expr_stmt|;
name|softc
operator|->
name|device_stats
operator|.
name|block_size
operator|=
name|softc
operator|->
name|params
operator|.
name|blksize
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"leaving cdopen\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cdclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|cd_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|error
decl_stmt|;
name|unit
operator|=
name|dkunit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|periph
operator|=
name|cam_extend_get
argument_list|(
name|cdperiphs
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|softc
operator|=
operator|(
expr|struct
name|cd_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|cam_periph_lock
argument_list|(
name|periph
argument_list|,
name|PRIBIO
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|CD_FLAG_DISC_REMOVABLE
operator|)
operator|!=
literal|0
condition|)
name|cdprevent
argument_list|(
name|periph
argument_list|,
name|PR_ALLOW
argument_list|)
expr_stmt|;
comment|/* 	 * Unconditionally set the dsopen() flags back to their default 	 * state. 	 */
name|softc
operator|->
name|disk
operator|.
name|d_dsflags
operator|&=
operator|~
name|DSO_NOLABELS
expr_stmt|;
name|softc
operator|->
name|disk
operator|.
name|d_dsflags
operator||=
name|DSO_COMPATLABEL
expr_stmt|;
comment|/* 	 * Since we're closing this CD, mark the blocksize as unavailable. 	 * It will be marked as available whence the CD is opened again. 	 */
name|softc
operator|->
name|device_stats
operator|.
name|flags
operator||=
name|DEVSTAT_BS_UNAVAILABLE
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|cam_periph_release
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cdshorttimeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cdchanger
modifier|*
name|changer
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splsoftcam
argument_list|()
expr_stmt|;
name|changer
operator|=
operator|(
expr|struct
name|cdchanger
operator|*
operator|)
name|arg
expr_stmt|;
comment|/* Always clear the short timeout flag, since that's what we're in */
name|changer
operator|->
name|flags
operator|&=
operator|~
name|CHANGER_SHORT_TMOUT_SCHED
expr_stmt|;
comment|/* 	 * Check to see if there is any more pending or outstanding I/O for 	 * this device.  If not, move it out of the active slot. 	 */
if|if
condition|(
operator|(
name|bufq_first
argument_list|(
operator|&
name|changer
operator|->
name|cur_device
operator|->
name|buf_queue
argument_list|)
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|changer
operator|->
name|cur_device
operator|->
name|device_stats
operator|.
name|busy_count
operator|==
literal|0
operator|)
condition|)
block|{
name|changer
operator|->
name|flags
operator||=
name|CHANGER_MANUAL_CALL
expr_stmt|;
name|cdrunchangerqueue
argument_list|(
name|changer
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is a wrapper for xpt_schedule.  It only applies to changers.  */
end_comment

begin_function
specifier|static
name|void
name|cdschedule
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|priority
parameter_list|)
block|{
name|struct
name|cd_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splsoftcam
argument_list|()
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|cd_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
comment|/* 	 * If this device isn't currently queued, and if it isn't 	 * the active device, then we queue this device and run the 	 * changer queue if there is no timeout scheduled to do it. 	 * If this device is the active device, just schedule it 	 * to run again.  If this device is queued, there should be 	 * a timeout in place already that will make sure it runs. 	 */
if|if
condition|(
operator|(
name|softc
operator|->
name|pinfo
operator|.
name|index
operator|==
name|CAM_UNQUEUED_INDEX
operator|)
operator|&&
operator|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|CD_FLAG_ACTIVE
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * We don't do anything with the priority here. 		 * This is strictly a fifo queue. 		 */
name|softc
operator|->
name|pinfo
operator|.
name|priority
operator|=
literal|1
expr_stmt|;
name|softc
operator|->
name|pinfo
operator|.
name|generation
operator|=
operator|++
name|softc
operator|->
name|changer
operator|->
name|devq
operator|.
name|generation
expr_stmt|;
name|camq_insert
argument_list|(
operator|&
name|softc
operator|->
name|changer
operator|->
name|devq
argument_list|,
operator|(
name|cam_pinfo
operator|*
operator|)
name|softc
argument_list|)
expr_stmt|;
comment|/* 		 * Since we just put a device in the changer queue, 		 * check and see if there is a timeout scheduled for 		 * this changer.  If so, let the timeout handle 		 * switching this device into the active slot.  If 		 * not, manually call the timeout routine to 		 * bootstrap things. 		 */
if|if
condition|(
operator|(
operator|(
name|softc
operator|->
name|changer
operator|->
name|flags
operator|&
name|CHANGER_TIMEOUT_SCHED
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|softc
operator|->
name|changer
operator|->
name|flags
operator|&
name|CHANGER_NEED_TIMEOUT
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|softc
operator|->
name|changer
operator|->
name|flags
operator|&
name|CHANGER_SHORT_TMOUT_SCHED
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|softc
operator|->
name|changer
operator|->
name|flags
operator||=
name|CHANGER_MANUAL_CALL
expr_stmt|;
name|cdrunchangerqueue
argument_list|(
name|softc
operator|->
name|changer
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|CD_FLAG_ACTIVE
operator|)
operator|&&
operator|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|CD_FLAG_SCHED_ON_COMP
operator|)
operator|==
literal|0
operator|)
condition|)
name|xpt_schedule
argument_list|(
name|periph
argument_list|,
name|priority
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cdrunchangerqueue
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cd_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|cdchanger
modifier|*
name|changer
decl_stmt|;
name|int
name|called_from_timeout
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splsoftcam
argument_list|()
expr_stmt|;
name|changer
operator|=
operator|(
expr|struct
name|cdchanger
operator|*
operator|)
name|arg
expr_stmt|;
comment|/* 	 * If we have NOT been called from cdstrategy() or cddone(), and 	 * instead from a timeout routine, go ahead and clear the 	 * timeout flag. 	 */
if|if
condition|(
operator|(
name|changer
operator|->
name|flags
operator|&
name|CHANGER_MANUAL_CALL
operator|)
operator|==
literal|0
condition|)
block|{
name|changer
operator|->
name|flags
operator|&=
operator|~
name|CHANGER_TIMEOUT_SCHED
expr_stmt|;
name|called_from_timeout
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|called_from_timeout
operator|=
literal|0
expr_stmt|;
comment|/* Always clear the manual call flag */
name|changer
operator|->
name|flags
operator|&=
operator|~
name|CHANGER_MANUAL_CALL
expr_stmt|;
comment|/* nothing to do if the queue is empty */
if|if
condition|(
name|changer
operator|->
name|devq
operator|.
name|entries
operator|<=
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If the changer queue is frozen, that means we have an active 	 * device. 	 */
if|if
condition|(
name|changer
operator|->
name|devq
operator|.
name|qfrozen_cnt
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|changer
operator|->
name|cur_device
operator|->
name|device_stats
operator|.
name|busy_count
operator|>
literal|0
condition|)
block|{
name|changer
operator|->
name|cur_device
operator|->
name|flags
operator||=
name|CD_FLAG_SCHED_ON_COMP
expr_stmt|;
name|changer
operator|->
name|cur_device
operator|->
name|bufs_left
operator|=
name|changer
operator|->
name|cur_device
operator|->
name|device_stats
operator|.
name|busy_count
expr_stmt|;
if|if
condition|(
name|called_from_timeout
condition|)
block|{
name|changer
operator|->
name|long_handle
operator|=
name|timeout
argument_list|(
name|cdrunchangerqueue
argument_list|,
name|changer
argument_list|,
name|changer_max_busy_seconds
operator|*
name|hz
argument_list|)
expr_stmt|;
name|changer
operator|->
name|flags
operator||=
name|CHANGER_TIMEOUT_SCHED
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * We always need to reset the frozen count and clear the 		 * active flag. 		 */
name|changer
operator|->
name|devq
operator|.
name|qfrozen_cnt
operator|--
expr_stmt|;
name|changer
operator|->
name|cur_device
operator|->
name|flags
operator|&=
operator|~
name|CD_FLAG_ACTIVE
expr_stmt|;
name|changer
operator|->
name|cur_device
operator|->
name|flags
operator|&=
operator|~
name|CD_FLAG_SCHED_ON_COMP
expr_stmt|;
comment|/* 		 * Check to see whether the current device has any I/O left 		 * to do.  If so, requeue it at the end of the queue.  If 		 * not, there is no need to requeue it. 		 */
if|if
condition|(
name|bufq_first
argument_list|(
operator|&
name|changer
operator|->
name|cur_device
operator|->
name|buf_queue
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|changer
operator|->
name|cur_device
operator|->
name|pinfo
operator|.
name|generation
operator|=
operator|++
name|changer
operator|->
name|devq
operator|.
name|generation
expr_stmt|;
name|camq_insert
argument_list|(
operator|&
name|changer
operator|->
name|devq
argument_list|,
operator|(
name|cam_pinfo
operator|*
operator|)
name|changer
operator|->
name|cur_device
argument_list|)
expr_stmt|;
block|}
block|}
name|softc
operator|=
operator|(
expr|struct
name|cd_softc
operator|*
operator|)
name|camq_remove
argument_list|(
operator|&
name|changer
operator|->
name|devq
argument_list|,
name|CAMQ_HEAD
argument_list|)
expr_stmt|;
name|changer
operator|->
name|cur_device
operator|=
name|softc
expr_stmt|;
name|changer
operator|->
name|devq
operator|.
name|qfrozen_cnt
operator|++
expr_stmt|;
name|softc
operator|->
name|flags
operator||=
name|CD_FLAG_ACTIVE
expr_stmt|;
comment|/* Just in case this device is waiting */
name|wakeup
argument_list|(
operator|&
name|softc
operator|->
name|changer
argument_list|)
expr_stmt|;
name|xpt_schedule
argument_list|(
name|softc
operator|->
name|periph
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Get rid of any pending timeouts, and set a flag to schedule new 	 * ones so this device gets its full time quantum. 	 */
if|if
condition|(
name|changer
operator|->
name|flags
operator|&
name|CHANGER_TIMEOUT_SCHED
condition|)
block|{
name|untimeout
argument_list|(
name|cdrunchangerqueue
argument_list|,
name|changer
argument_list|,
name|changer
operator|->
name|long_handle
argument_list|)
expr_stmt|;
name|changer
operator|->
name|flags
operator|&=
operator|~
name|CHANGER_TIMEOUT_SCHED
expr_stmt|;
block|}
if|if
condition|(
name|changer
operator|->
name|flags
operator|&
name|CHANGER_SHORT_TMOUT_SCHED
condition|)
block|{
name|untimeout
argument_list|(
name|cdshorttimeout
argument_list|,
name|changer
argument_list|,
name|changer
operator|->
name|short_handle
argument_list|)
expr_stmt|;
name|changer
operator|->
name|flags
operator|&=
operator|~
name|CHANGER_SHORT_TMOUT_SCHED
expr_stmt|;
block|}
comment|/* 	 * We need to schedule timeouts, but we only do this after the 	 * first transaction has completed.  This eliminates the changer 	 * switch time. 	 */
name|changer
operator|->
name|flags
operator||=
name|CHANGER_NEED_TIMEOUT
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cdchangerschedule
parameter_list|(
name|struct
name|cd_softc
modifier|*
name|softc
parameter_list|)
block|{
name|struct
name|cdchanger
modifier|*
name|changer
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splsoftcam
argument_list|()
expr_stmt|;
name|changer
operator|=
name|softc
operator|->
name|changer
expr_stmt|;
comment|/* 	 * If this is a changer, and this is the current device, 	 * and this device has at least the minimum time quantum to 	 * run, see if we can switch it out. 	 */
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|CD_FLAG_ACTIVE
operator|)
operator|&&
operator|(
operator|(
name|changer
operator|->
name|flags
operator|&
name|CHANGER_SHORT_TMOUT_SCHED
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|changer
operator|->
name|flags
operator|&
name|CHANGER_NEED_TIMEOUT
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * We try three things here.  The first is that we 		 * check to see whether the schedule on completion 		 * flag is set.  If it is, we decrement the number 		 * of buffers left, and if it's zero, we reschedule. 		 * Next, we check to see whether the pending buffer 		 * queue is empty and whether there are no 		 * outstanding transactions.  If so, we reschedule. 		 * Next, we see if the pending buffer queue is empty. 		 * If it is, we set the number of buffers left to 		 * the current active buffer count and set the 		 * schedule on complete flag. 		 */
if|if
condition|(
name|softc
operator|->
name|flags
operator|&
name|CD_FLAG_SCHED_ON_COMP
condition|)
block|{
if|if
condition|(
operator|--
name|softc
operator|->
name|bufs_left
operator|==
literal|0
condition|)
block|{
name|softc
operator|->
name|changer
operator|->
name|flags
operator||=
name|CHANGER_MANUAL_CALL
expr_stmt|;
name|softc
operator|->
name|flags
operator|&=
operator|~
name|CD_FLAG_SCHED_ON_COMP
expr_stmt|;
name|cdrunchangerqueue
argument_list|(
name|softc
operator|->
name|changer
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|bufq_first
argument_list|(
operator|&
name|softc
operator|->
name|buf_queue
argument_list|)
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|softc
operator|->
name|device_stats
operator|.
name|busy_count
operator|==
literal|0
operator|)
condition|)
block|{
name|softc
operator|->
name|changer
operator|->
name|flags
operator||=
name|CHANGER_MANUAL_CALL
expr_stmt|;
name|cdrunchangerqueue
argument_list|(
name|softc
operator|->
name|changer
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|softc
operator|->
name|changer
operator|->
name|flags
operator|&
name|CHANGER_NEED_TIMEOUT
operator|)
operator|&&
operator|(
name|softc
operator|->
name|flags
operator|&
name|CD_FLAG_ACTIVE
operator|)
condition|)
block|{
comment|/* 		 * Now that the first transaction to this 		 * particular device has completed, we can go ahead 		 * and schedule our timeouts. 		 */
if|if
condition|(
operator|(
name|changer
operator|->
name|flags
operator|&
name|CHANGER_TIMEOUT_SCHED
operator|)
operator|==
literal|0
condition|)
block|{
name|changer
operator|->
name|long_handle
operator|=
name|timeout
argument_list|(
name|cdrunchangerqueue
argument_list|,
name|changer
argument_list|,
name|changer_max_busy_seconds
operator|*
name|hz
argument_list|)
expr_stmt|;
name|changer
operator|->
name|flags
operator||=
name|CHANGER_TIMEOUT_SCHED
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"cdchangerschedule: already have a long"
literal|" timeout!\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|changer
operator|->
name|flags
operator|&
name|CHANGER_SHORT_TMOUT_SCHED
operator|)
operator|==
literal|0
condition|)
block|{
name|changer
operator|->
name|short_handle
operator|=
name|timeout
argument_list|(
name|cdshorttimeout
argument_list|,
name|changer
argument_list|,
name|changer_min_busy_seconds
operator|*
name|hz
argument_list|)
expr_stmt|;
name|changer
operator|->
name|flags
operator||=
name|CHANGER_SHORT_TMOUT_SCHED
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"cdchangerschedule: already have a short "
literal|"timeout!\n"
argument_list|)
expr_stmt|;
comment|/* 		 * We just scheduled timeouts, no need to schedule 		 * more. 		 */
name|changer
operator|->
name|flags
operator|&=
operator|~
name|CHANGER_NEED_TIMEOUT
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cdrunccb
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|int
function_decl|(
modifier|*
name|error_routine
function_decl|)
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|u_int32_t
name|cam_flags
parameter_list|,
name|u_int32_t
name|sense_flags
parameter_list|)
parameter_list|,
name|u_int32_t
name|cam_flags
parameter_list|,
name|u_int32_t
name|sense_flags
parameter_list|)
block|{
name|struct
name|cd_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|int
name|error
decl_stmt|;
name|periph
operator|=
name|xpt_path_periph
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|cd_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|error_routine
argument_list|,
name|cam_flags
argument_list|,
name|sense_flags
argument_list|,
operator|&
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|flags
operator|&
name|CD_FLAG_CHANGER
condition|)
name|cdchangerschedule
argument_list|(
name|softc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|union
name|ccb
modifier|*
name|cdgetccb
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|u_int32_t
name|priority
parameter_list|)
block|{
name|struct
name|cd_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|s
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|cd_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|flags
operator|&
name|CD_FLAG_CHANGER
condition|)
block|{
name|s
operator|=
name|splsoftcam
argument_list|()
expr_stmt|;
comment|/* 		 * This should work the first time this device is woken up, 		 * but just in case it doesn't, we use a while loop. 		 */
while|while
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|CD_FLAG_ACTIVE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * If this changer isn't already queued, queue it up. 			 */
if|if
condition|(
name|softc
operator|->
name|pinfo
operator|.
name|index
operator|==
name|CAM_UNQUEUED_INDEX
condition|)
block|{
name|softc
operator|->
name|pinfo
operator|.
name|priority
operator|=
literal|1
expr_stmt|;
name|softc
operator|->
name|pinfo
operator|.
name|generation
operator|=
operator|++
name|softc
operator|->
name|changer
operator|->
name|devq
operator|.
name|generation
expr_stmt|;
name|camq_insert
argument_list|(
operator|&
name|softc
operator|->
name|changer
operator|->
name|devq
argument_list|,
operator|(
name|cam_pinfo
operator|*
operator|)
name|softc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|softc
operator|->
name|changer
operator|->
name|flags
operator|&
name|CHANGER_TIMEOUT_SCHED
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|softc
operator|->
name|changer
operator|->
name|flags
operator|&
name|CHANGER_NEED_TIMEOUT
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|softc
operator|->
name|changer
operator|->
name|flags
operator|&
name|CHANGER_SHORT_TMOUT_SCHED
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|softc
operator|->
name|changer
operator|->
name|flags
operator||=
name|CHANGER_MANUAL_CALL
expr_stmt|;
name|cdrunchangerqueue
argument_list|(
name|softc
operator|->
name|changer
argument_list|)
expr_stmt|;
block|}
else|else
name|tsleep
argument_list|(
operator|&
name|softc
operator|->
name|changer
argument_list|,
name|PRIBIO
argument_list|,
literal|"cgticb"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
name|priority
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Actually translate the requested transfer into one the physical driver  * can understand.  The transfer is described by a buf and will include  * only one physical transfer.  */
end_comment

begin_function
specifier|static
name|void
name|cdstrategy
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|cd_softc
modifier|*
name|softc
decl_stmt|;
name|u_int
name|unit
decl_stmt|,
name|part
decl_stmt|;
name|int
name|s
decl_stmt|;
name|unit
operator|=
name|dkunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
name|part
operator|=
name|dkpart
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
name|periph
operator|=
name|cam_extend_get
argument_list|(
name|cdperiphs
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"entering cdstrategy\n"
operator|)
argument_list|)
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|cd_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
comment|/* 	 * Mask interrupts so that the pack cannot be invalidated until 	 * after we are in the queue.  Otherwise, we might not properly 	 * clean up one of the buffers. 	 */
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* 	 * If the device has been made invalid, error out 	 */
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|CD_FLAG_INVALID
operator|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Place it in the queue of disk activities for this disk 	 */
name|bufqdisksort
argument_list|(
operator|&
name|softc
operator|->
name|buf_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Schedule ourselves for performing the work.  We do things 	 * differently for changers. 	 */
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|CD_FLAG_CHANGER
operator|)
operator|==
literal|0
condition|)
name|xpt_schedule
argument_list|(
name|periph
argument_list|,
comment|/* XXX priority */
literal|1
argument_list|)
expr_stmt|;
else|else
name|cdschedule
argument_list|(
name|periph
argument_list|,
comment|/* priority */
literal|1
argument_list|)
expr_stmt|;
return|return;
name|bad
label|:
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
comment|/* 	 * Correctly set the buf to indicate a completed xfer 	 */
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|cdstart
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|start_ccb
parameter_list|)
block|{
name|struct
name|cd_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|struct
name|scsi_read_capacity_data
modifier|*
name|rcap
decl_stmt|;
name|int
name|s
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|cd_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"entering cdstart\n"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|softc
operator|->
name|state
condition|)
block|{
case|case
name|CD_STATE_NORMAL
case|:
block|{
name|int
name|oldspl
decl_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|bp
operator|=
name|bufq_first
argument_list|(
operator|&
name|softc
operator|->
name|buf_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|periph
operator|->
name|immediate_priority
operator|<=
name|periph
operator|->
name|pinfo
operator|.
name|priority
condition|)
block|{
name|start_ccb
operator|->
name|ccb_h
operator|.
name|ccb_state
operator|=
name|CD_CCB_WAITING
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|periph
operator|->
name|ccb_list
argument_list|,
operator|&
name|start_ccb
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|sle
argument_list|)
expr_stmt|;
name|periph
operator|->
name|immediate_priority
operator|=
name|CAM_PRIORITY_NONE
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|periph
operator|->
name|ccb_list
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|start_ccb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bufq_remove
argument_list|(
operator|&
name|softc
operator|->
name|buf_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|devstat_start_transaction
argument_list|(
operator|&
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
name|scsi_read_write
argument_list|(
operator|&
name|start_ccb
operator|->
name|csio
argument_list|,
comment|/*retries*/
literal|4
argument_list|,
comment|/* cbfcnp */
name|cddone
argument_list|,
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ORDERED
operator|)
operator|!=
literal|0
condition|?
name|MSG_ORDERED_Q_TAG
else|:
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* read */
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
argument_list|,
comment|/* byte2 */
literal|0
argument_list|,
comment|/* minimum_cmd_size */
literal|10
argument_list|,
comment|/* lba */
name|bp
operator|->
name|b_pblkno
argument_list|,
name|bp
operator|->
name|b_bcount
operator|/
name|softc
operator|->
name|params
operator|.
name|blksize
argument_list|,
comment|/* data_ptr */
name|bp
operator|->
name|b_data
argument_list|,
comment|/* dxfer_len */
name|bp
operator|->
name|b_bcount
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
literal|30000
argument_list|)
expr_stmt|;
name|start_ccb
operator|->
name|ccb_h
operator|.
name|ccb_state
operator|=
name|CD_CCB_BUFFER_IO
expr_stmt|;
comment|/* 			 * Block out any asyncronous callbacks 			 * while we touch the pending ccb list. 			 */
name|oldspl
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|softc
operator|->
name|pending_ccbs
argument_list|,
operator|&
name|start_ccb
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|le
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
comment|/* We expect a unit attention from this device */
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|CD_FLAG_RETRY_UA
operator|)
operator|!=
literal|0
condition|)
block|{
name|start_ccb
operator|->
name|ccb_h
operator|.
name|ccb_state
operator||=
name|CD_CCB_RETRY_UA
expr_stmt|;
name|softc
operator|->
name|flags
operator|&=
operator|~
name|CD_FLAG_RETRY_UA
expr_stmt|;
block|}
name|start_ccb
operator|->
name|ccb_h
operator|.
name|ccb_bp
operator|=
name|bp
expr_stmt|;
name|bp
operator|=
name|bufq_first
argument_list|(
operator|&
name|softc
operator|->
name|buf_queue
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|xpt_action
argument_list|(
name|start_ccb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
block|{
comment|/* Have more work to do, so ensure we stay scheduled */
name|xpt_schedule
argument_list|(
name|periph
argument_list|,
comment|/* XXX priority */
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|CD_STATE_PROBE
case|:
block|{
name|rcap
operator|=
operator|(
expr|struct
name|scsi_read_capacity_data
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|rcap
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcap
operator|==
name|NULL
condition|)
block|{
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cdstart: Couldn't malloc read_capacity data\n"
argument_list|)
expr_stmt|;
comment|/* cd_free_periph??? */
break|break;
block|}
name|csio
operator|=
operator|&
name|start_ccb
operator|->
name|csio
expr_stmt|;
name|scsi_read_capacity
argument_list|(
name|csio
argument_list|,
comment|/*retries*/
literal|1
argument_list|,
name|cddone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|rcap
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
comment|/*timeout*/
literal|20000
argument_list|)
expr_stmt|;
name|start_ccb
operator|->
name|ccb_h
operator|.
name|ccb_bp
operator|=
name|NULL
expr_stmt|;
name|start_ccb
operator|->
name|ccb_h
operator|.
name|ccb_state
operator|=
name|CD_CCB_PROBE
expr_stmt|;
name|xpt_action
argument_list|(
name|start_ccb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cddone
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|done_ccb
parameter_list|)
block|{
name|struct
name|cd_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"entering cddone\n"
operator|)
argument_list|)
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|cd_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|csio
operator|=
operator|&
name|done_ccb
operator|->
name|csio
expr_stmt|;
switch|switch
condition|(
name|csio
operator|->
name|ccb_h
operator|.
name|ccb_state
operator|&
name|CD_CCB_TYPE_MASK
condition|)
block|{
case|case
name|CD_CCB_BUFFER_IO
case|:
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|oldspl
decl_stmt|;
name|bp
operator|=
operator|(
expr|struct
name|buf
operator|*
operator|)
name|done_ccb
operator|->
name|ccb_h
operator|.
name|ccb_bp
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|int
name|sf
decl_stmt|;
if|if
condition|(
operator|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|ccb_state
operator|&
name|CD_CCB_RETRY_UA
operator|)
operator|!=
literal|0
condition|)
name|sf
operator|=
name|SF_RETRY_UA
expr_stmt|;
else|else
name|sf
operator|=
literal|0
expr_stmt|;
comment|/* Retry selection timeouts */
name|sf
operator||=
name|SF_RETRY_SELTO
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|cderror
argument_list|(
name|done_ccb
argument_list|,
literal|0
argument_list|,
name|sf
argument_list|)
operator|)
operator|==
name|ERESTART
condition|)
block|{
comment|/* 				 * A retry was scheuled, so 				 * just return. 				 */
return|return;
block|}
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|int
name|s
decl_stmt|;
name|struct
name|buf
modifier|*
name|q_bp
decl_stmt|;
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cddone: got error %#x back\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|q_bp
operator|=
name|bufq_first
argument_list|(
operator|&
name|softc
operator|->
name|buf_queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|bufq_remove
argument_list|(
operator|&
name|softc
operator|->
name|buf_queue
argument_list|,
name|q_bp
argument_list|)
expr_stmt|;
name|q_bp
operator|->
name|b_resid
operator|=
name|q_bp
operator|->
name|b_bcount
expr_stmt|;
name|q_bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
name|q_bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|biodone
argument_list|(
name|q_bp
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|error
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|cam_release_devq
argument_list|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*relsim_flags*/
literal|0
argument_list|,
comment|/*reduction*/
literal|0
argument_list|,
comment|/*timeout*/
literal|0
argument_list|,
comment|/*getcount_only*/
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bp
operator|->
name|b_resid
operator|=
name|csio
operator|->
name|resid
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_resid
operator|!=
literal|0
condition|)
block|{
comment|/* Short transfer ??? */
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
block|}
block|}
comment|/* 		 * Block out any asyncronous callbacks 		 * while we touch the pending ccb list. 		 */
name|oldspl
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|LIST_REMOVE
argument_list|(
operator|&
name|done_ccb
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|le
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|flags
operator|&
name|CD_FLAG_CHANGER
condition|)
name|cdchangerschedule
argument_list|(
name|softc
argument_list|)
expr_stmt|;
name|devstat_end_transaction_buf
argument_list|(
operator|&
name|softc
operator|->
name|device_stats
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CD_CCB_PROBE
case|:
block|{
name|struct
name|scsi_read_capacity_data
modifier|*
name|rdcap
decl_stmt|;
name|char
name|announce_buf
index|[
literal|120
index|]
decl_stmt|;
comment|/* 					       * Currently (9/30/97) the  					       * longest possible announce  					       * buffer is 108 bytes, for the  					       * first error case below.   					       * That is 39 bytes for the  					       * basic string, 16 bytes for the 					       * biggest sense key (hardware  					       * error), 52 bytes for the 					       * text of the largest sense  					       * qualifier valid for a CDROM, 					       * (0x72, 0x03 or 0x04, 					       * 0x03), and one byte for the 					       * null terminating character. 					       * To allow for longer strings,  					       * the announce buffer is 120 					       * bytes. 					       */
name|struct
name|cd_params
modifier|*
name|cdp
decl_stmt|;
name|cdp
operator|=
operator|&
name|softc
operator|->
name|params
expr_stmt|;
name|rdcap
operator|=
operator|(
expr|struct
name|scsi_read_capacity_data
operator|*
operator|)
name|csio
operator|->
name|data_ptr
expr_stmt|;
name|cdp
operator|->
name|disksize
operator|=
name|scsi_4btoul
argument_list|(
name|rdcap
operator|->
name|addr
argument_list|)
operator|+
literal|1
expr_stmt|;
name|cdp
operator|->
name|blksize
operator|=
name|scsi_4btoul
argument_list|(
name|rdcap
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_CMP
condition|)
block|{
name|snprintf
argument_list|(
name|announce_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|announce_buf
argument_list|)
argument_list|,
literal|"cd present [%lu x %lu byte records]"
argument_list|,
name|cdp
operator|->
name|disksize
argument_list|,
operator|(
name|u_long
operator|)
name|cdp
operator|->
name|blksize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|error
decl_stmt|;
comment|/* 			 * Retry any UNIT ATTENTION type errors.  They 			 * are expected at boot. 			 */
name|error
operator|=
name|cderror
argument_list|(
name|done_ccb
argument_list|,
literal|0
argument_list|,
name|SF_RETRY_UA
operator||
name|SF_NO_PRINT
operator||
name|SF_RETRY_SELTO
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
block|{
comment|/* 				 * A retry was scheuled, so 				 * just return. 				 */
return|return;
block|}
elseif|else
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|struct
name|scsi_sense_data
modifier|*
name|sense
decl_stmt|;
name|int
name|asc
decl_stmt|,
name|ascq
decl_stmt|;
name|int
name|sense_key
decl_stmt|,
name|error_code
decl_stmt|;
name|int
name|have_sense
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|struct
name|ccb_getdev
name|cgd
decl_stmt|;
comment|/* Don't wedge this device's queue */
name|cam_release_devq
argument_list|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*relsim_flags*/
literal|0
argument_list|,
comment|/*reduction*/
literal|0
argument_list|,
comment|/*timeout*/
literal|0
argument_list|,
comment|/*getcount_only*/
literal|0
argument_list|)
expr_stmt|;
name|status
operator|=
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|cgd
operator|.
name|ccb_h
argument_list|,
name|done_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/* priority */
literal|1
argument_list|)
expr_stmt|;
name|cgd
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_GDEV_TYPE
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|cgd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SENSE_PHYS
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SENSE_PTR
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|status
operator|&
name|CAM_AUTOSNS_VALID
operator|)
operator|==
literal|0
operator|)
condition|)
name|have_sense
operator|=
name|FALSE
expr_stmt|;
else|else
name|have_sense
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|have_sense
condition|)
block|{
name|sense
operator|=
operator|&
name|csio
operator|->
name|sense_data
expr_stmt|;
name|scsi_extract_sense
argument_list|(
name|sense
argument_list|,
operator|&
name|error_code
argument_list|,
operator|&
name|sense_key
argument_list|,
operator|&
name|asc
argument_list|,
operator|&
name|ascq
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * Attach to anything that claims to be a 				 * CDROM or WORM device, as long as it 				 * doesn't return a "Logical unit not 				 * supported" (0x25) error. 				 */
if|if
condition|(
operator|(
name|have_sense
operator|)
operator|&&
operator|(
name|asc
operator|!=
literal|0x25
operator|)
operator|&&
operator|(
name|error_code
operator|==
name|SSD_CURRENT_ERROR
operator|)
condition|)
name|snprintf
argument_list|(
name|announce_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|announce_buf
argument_list|)
argument_list|,
literal|"Attempt to query device "
literal|"size failed: %s, %s"
argument_list|,
name|scsi_sense_key_text
index|[
name|sense_key
index|]
argument_list|,
name|scsi_sense_desc
argument_list|(
name|asc
argument_list|,
name|ascq
argument_list|,
operator|&
name|cgd
operator|.
name|inq_data
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|have_sense
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_SCSI_STATUS_ERROR
operator|)
operator|&&
operator|(
name|csio
operator|->
name|scsi_status
operator|==
name|SCSI_STATUS_BUSY
operator|)
condition|)
block|{
name|snprintf
argument_list|(
name|announce_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|announce_buf
argument_list|)
argument_list|,
literal|"Attempt to query device "
literal|"size failed: SCSI status: BUSY"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SID_TYPE
argument_list|(
operator|&
name|cgd
operator|.
name|inq_data
argument_list|)
operator|==
name|T_CDROM
condition|)
block|{
comment|/* 					 * We only print out an error for 					 * CDROM type devices.  For WORM 					 * devices, we don't print out an 					 * error since a few WORM devices 					 * don't support CDROM commands. 					 * If we have sense information, go 					 * ahead and print it out. 					 * Otherwise, just say that we  					 * couldn't attach. 					 */
comment|/* 					 * Just print out the error, not 					 * the full probe message, when we 					 * don't attach. 					 */
if|if
condition|(
name|have_sense
condition|)
name|scsi_sense_print
argument_list|(
operator|&
name|done_ccb
operator|->
name|csio
argument_list|)
expr_stmt|;
else|else
block|{
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"got CAM status %#x\n"
argument_list|,
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
argument_list|)
expr_stmt|;
block|}
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"fatal error, failed"
literal|" to attach to device\n"
argument_list|)
expr_stmt|;
comment|/* 					 * Invalidate this peripheral. 					 */
name|cam_periph_invalidate
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|announce_buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
comment|/* 					 * Invalidate this peripheral. 					 */
name|cam_periph_invalidate
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|announce_buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
name|rdcap
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|announce_buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|xpt_announce_periph
argument_list|(
name|periph
argument_list|,
name|announce_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|flags
operator|&
name|CD_FLAG_CHANGER
condition|)
name|cdchangerschedule
argument_list|(
name|softc
argument_list|)
expr_stmt|;
block|}
name|softc
operator|->
name|state
operator|=
name|CD_STATE_NORMAL
expr_stmt|;
comment|/* 		 * Since our peripheral may be invalidated by an error 		 * above or an external event, we must release our CCB 		 * before releasing the probe lock on the peripheral. 		 * The peripheral will only go away once the last lock 		 * is removed, and we need it around for the CCB release 		 * operation. 		 */
name|xpt_release_ccb
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|CD_CCB_WAITING
case|:
block|{
comment|/* Caller will release the CCB */
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"trying to wakeup ccbwait\n"
operator|)
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|done_ccb
operator|->
name|ccb_h
operator|.
name|cbfcnp
argument_list|)
expr_stmt|;
return|return;
block|}
default|default:
break|break;
block|}
name|xpt_release_ccb
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cdioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|cd_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|unit
decl_stmt|;
name|unit
operator|=
name|dkunit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|periph
operator|=
name|cam_extend_get
argument_list|(
name|cdperiphs
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"entering cdioctl\n"
operator|)
argument_list|)
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|cd_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"trying to do ioctl %#lx\n"
operator|,
name|cmd
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|cam_periph_lock
argument_list|(
name|periph
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|CDIOCPLAYTRACKS
case|:
block|{
name|struct
name|ioc_play_track
modifier|*
name|args
init|=
operator|(
expr|struct
name|ioc_play_track
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|cd_mode_data
modifier|*
name|data
decl_stmt|;
name|data
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cd_mode_data
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"trying to do CDIOCPLAYTRACKS\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdgetmode
argument_list|(
name|periph
argument_list|,
name|data
argument_list|,
name|AUDIO_PAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
name|data
operator|->
name|page
operator|.
name|audio
operator|.
name|flags
operator|&=
operator|~
name|CD_PA_SOTC
expr_stmt|;
name|data
operator|->
name|page
operator|.
name|audio
operator|.
name|flags
operator||=
name|CD_PA_IMMED
expr_stmt|;
name|error
operator|=
name|cdsetmode
argument_list|(
name|periph
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|softc
operator|->
name|quirks
operator|&
name|CD_Q_BCD_TRACKS
condition|)
block|{
name|args
operator|->
name|start_track
operator|=
name|bin2bcd
argument_list|(
name|args
operator|->
name|start_track
argument_list|)
expr_stmt|;
name|args
operator|->
name|end_track
operator|=
name|bin2bcd
argument_list|(
name|args
operator|->
name|end_track
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|cdplaytracks
argument_list|(
name|periph
argument_list|,
name|args
operator|->
name|start_track
argument_list|,
name|args
operator|->
name|start_index
argument_list|,
name|args
operator|->
name|end_track
argument_list|,
name|args
operator|->
name|end_index
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CDIOCPLAYMSF
case|:
block|{
name|struct
name|ioc_play_msf
modifier|*
name|args
init|=
operator|(
expr|struct
name|ioc_play_msf
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|cd_mode_data
modifier|*
name|data
decl_stmt|;
name|data
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cd_mode_data
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"trying to do CDIOCPLAYMSF\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdgetmode
argument_list|(
name|periph
argument_list|,
name|data
argument_list|,
name|AUDIO_PAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
name|data
operator|->
name|page
operator|.
name|audio
operator|.
name|flags
operator|&=
operator|~
name|CD_PA_SOTC
expr_stmt|;
name|data
operator|->
name|page
operator|.
name|audio
operator|.
name|flags
operator||=
name|CD_PA_IMMED
expr_stmt|;
name|error
operator|=
name|cdsetmode
argument_list|(
name|periph
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|error
operator|=
name|cdplaymsf
argument_list|(
name|periph
argument_list|,
name|args
operator|->
name|start_m
argument_list|,
name|args
operator|->
name|start_s
argument_list|,
name|args
operator|->
name|start_f
argument_list|,
name|args
operator|->
name|end_m
argument_list|,
name|args
operator|->
name|end_s
argument_list|,
name|args
operator|->
name|end_f
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CDIOCPLAYBLOCKS
case|:
block|{
name|struct
name|ioc_play_blocks
modifier|*
name|args
init|=
operator|(
expr|struct
name|ioc_play_blocks
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|cd_mode_data
modifier|*
name|data
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"trying to do CDIOCPLAYBLOCKS\n"
operator|)
argument_list|)
expr_stmt|;
name|data
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cd_mode_data
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdgetmode
argument_list|(
name|periph
argument_list|,
name|data
argument_list|,
name|AUDIO_PAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
name|data
operator|->
name|page
operator|.
name|audio
operator|.
name|flags
operator|&=
operator|~
name|CD_PA_SOTC
expr_stmt|;
name|data
operator|->
name|page
operator|.
name|audio
operator|.
name|flags
operator||=
name|CD_PA_IMMED
expr_stmt|;
name|error
operator|=
name|cdsetmode
argument_list|(
name|periph
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|error
operator|=
name|cdplay
argument_list|(
name|periph
argument_list|,
name|args
operator|->
name|blk
argument_list|,
name|args
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CDIOCREADSUBCHANNEL
case|:
block|{
name|struct
name|ioc_read_subchannel
modifier|*
name|args
init|=
operator|(
expr|struct
name|ioc_read_subchannel
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|cd_sub_channel_info
modifier|*
name|data
decl_stmt|;
name|u_int32_t
name|len
init|=
name|args
operator|->
name|data_len
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"trying to do CDIOCREADSUBCHANNEL\n"
operator|)
argument_list|)
expr_stmt|;
name|data
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cd_sub_channel_info
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|cd_sub_channel_info
argument_list|)
operator|)
operator|||
operator|(
name|len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|cd_sub_channel_header
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"scsi_cd: cdioctl: "
literal|"cdioreadsubchannel: error, len=%d\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|softc
operator|->
name|quirks
operator|&
name|CD_Q_BCD_TRACKS
condition|)
name|args
operator|->
name|track
operator|=
name|bin2bcd
argument_list|(
name|args
operator|->
name|track
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdreadsubchannel
argument_list|(
name|periph
argument_list|,
name|args
operator|->
name|address_format
argument_list|,
name|args
operator|->
name|data_format
argument_list|,
name|args
operator|->
name|track
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|softc
operator|->
name|quirks
operator|&
name|CD_Q_BCD_TRACKS
condition|)
name|data
operator|->
name|what
operator|.
name|track_info
operator|.
name|track_number
operator|=
name|bcd2bin
argument_list|(
name|data
operator|->
name|what
operator|.
name|track_info
operator|.
name|track_number
argument_list|)
expr_stmt|;
name|len
operator|=
name|min
argument_list|(
name|len
argument_list|,
operator|(
operator|(
name|data
operator|->
name|header
operator|.
name|data_len
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator|+
name|data
operator|->
name|header
operator|.
name|data_len
index|[
literal|1
index|]
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|cd_sub_channel_header
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyout
argument_list|(
name|data
argument_list|,
name|args
operator|->
name|data
argument_list|,
name|len
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
block|}
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CDIOREADTOCHEADER
case|:
block|{
name|struct
name|ioc_toc_header
modifier|*
name|th
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"trying to do CDIOREADTOCHEADER\n"
operator|)
argument_list|)
expr_stmt|;
name|th
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ioc_toc_header
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdreadtoc
argument_list|(
name|periph
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|cd_toc_entry
operator|*
operator|)
name|th
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|th
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|th
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|softc
operator|->
name|quirks
operator|&
name|CD_Q_BCD_TRACKS
condition|)
block|{
comment|/* we are going to have to convert the BCD 				 * encoding on the cd to what is expected 				 */
name|th
operator|->
name|starting_track
operator|=
name|bcd2bin
argument_list|(
name|th
operator|->
name|starting_track
argument_list|)
expr_stmt|;
name|th
operator|->
name|ending_track
operator|=
name|bcd2bin
argument_list|(
name|th
operator|->
name|ending_track
argument_list|)
expr_stmt|;
block|}
name|NTOHS
argument_list|(
name|th
operator|->
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|th
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|th
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|th
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CDIOREADTOCENTRYS
case|:
block|{
typedef|typedef
struct|struct
block|{
name|struct
name|ioc_toc_header
name|header
decl_stmt|;
name|struct
name|cd_toc_entry
name|entries
index|[
literal|100
index|]
decl_stmt|;
block|}
name|data_t
typedef|;
typedef|typedef
struct|struct
block|{
name|struct
name|ioc_toc_header
name|header
decl_stmt|;
name|struct
name|cd_toc_entry
name|entry
decl_stmt|;
block|}
name|lead_t
typedef|;
name|data_t
modifier|*
name|data
decl_stmt|;
name|lead_t
modifier|*
name|lead
decl_stmt|;
name|struct
name|ioc_read_toc_entry
modifier|*
name|te
init|=
operator|(
expr|struct
name|ioc_read_toc_entry
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|ioc_toc_header
modifier|*
name|th
decl_stmt|;
name|u_int32_t
name|len
decl_stmt|,
name|readlen
decl_stmt|,
name|idx
decl_stmt|,
name|num
decl_stmt|;
name|u_int32_t
name|starting_track
init|=
name|te
operator|->
name|starting_track
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"trying to do CDIOREADTOCENTRYS\n"
operator|)
argument_list|)
expr_stmt|;
name|data
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|data_t
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|lead
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|lead_t
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|te
operator|->
name|data_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|cd_toc_entry
argument_list|)
operator|||
operator|(
name|te
operator|->
name|data_len
operator|%
sizeof|sizeof
argument_list|(
expr|struct
name|cd_toc_entry
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|te
operator|->
name|address_format
operator|!=
name|CD_MSF_FORMAT
operator|&&
name|te
operator|->
name|address_format
operator|!=
name|CD_LBA_FORMAT
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
name|printf
argument_list|(
literal|"scsi_cd: error in readtocentries, "
literal|"returning EINVAL\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lead
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
name|th
operator|=
operator|&
name|data
operator|->
name|header
expr_stmt|;
name|error
operator|=
name|cdreadtoc
argument_list|(
name|periph
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|cd_toc_entry
operator|*
operator|)
name|th
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|th
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lead
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|softc
operator|->
name|quirks
operator|&
name|CD_Q_BCD_TRACKS
condition|)
block|{
comment|/* we are going to have to convert the BCD 				 * encoding on the cd to what is expected 				 */
name|th
operator|->
name|starting_track
operator|=
name|bcd2bin
argument_list|(
name|th
operator|->
name|starting_track
argument_list|)
expr_stmt|;
name|th
operator|->
name|ending_track
operator|=
name|bcd2bin
argument_list|(
name|th
operator|->
name|ending_track
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|starting_track
operator|==
literal|0
condition|)
name|starting_track
operator|=
name|th
operator|->
name|starting_track
expr_stmt|;
elseif|else
if|if
condition|(
name|starting_track
operator|==
name|LEADOUT
condition|)
name|starting_track
operator|=
name|th
operator|->
name|ending_track
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|starting_track
operator|<
name|th
operator|->
name|starting_track
operator|||
name|starting_track
operator|>
name|th
operator|->
name|ending_track
operator|+
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"scsi_cd: error in readtocentries, "
literal|"returning EINVAL\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lead
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* calculate reading length without leadout entry */
name|readlen
operator|=
operator|(
name|th
operator|->
name|ending_track
operator|-
name|starting_track
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|cd_toc_entry
argument_list|)
expr_stmt|;
comment|/* and with leadout entry */
name|len
operator|=
name|readlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|cd_toc_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|te
operator|->
name|data_len
operator|<
name|len
condition|)
block|{
name|len
operator|=
name|te
operator|->
name|data_len
expr_stmt|;
if|if
condition|(
name|readlen
operator|>
name|len
condition|)
name|readlen
operator|=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>
sizeof|sizeof
argument_list|(
name|data
operator|->
name|entries
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"scsi_cd: error in readtocentries, "
literal|"returning EINVAL\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lead
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
name|num
operator|=
name|len
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|cd_toc_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|readlen
operator|>
literal|0
condition|)
block|{
name|error
operator|=
name|cdreadtoc
argument_list|(
name|periph
argument_list|,
name|te
operator|->
name|address_format
argument_list|,
name|starting_track
argument_list|,
operator|(
expr|struct
name|cd_toc_entry
operator|*
operator|)
name|data
argument_list|,
name|readlen
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|th
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lead
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* make leadout entry if needed */
name|idx
operator|=
name|starting_track
operator|+
name|num
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|quirks
operator|&
name|CD_Q_BCD_TRACKS
condition|)
name|th
operator|->
name|ending_track
operator|=
name|bcd2bin
argument_list|(
name|th
operator|->
name|ending_track
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
name|th
operator|->
name|ending_track
operator|+
literal|1
condition|)
block|{
name|error
operator|=
name|cdreadtoc
argument_list|(
name|periph
argument_list|,
name|te
operator|->
name|address_format
argument_list|,
name|LEADOUT
argument_list|,
operator|(
expr|struct
name|cd_toc_entry
operator|*
operator|)
name|lead
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lead
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lead
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
name|data
operator|->
name|entries
index|[
name|idx
operator|-
name|starting_track
index|]
operator|=
name|lead
operator|->
name|entry
expr_stmt|;
block|}
if|if
condition|(
name|softc
operator|->
name|quirks
operator|&
name|CD_Q_BCD_TRACKS
condition|)
block|{
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|num
operator|-
literal|1
condition|;
name|idx
operator|++
control|)
block|{
name|data
operator|->
name|entries
index|[
name|idx
index|]
operator|.
name|track
operator|=
name|bcd2bin
argument_list|(
name|data
operator|->
name|entries
index|[
name|idx
index|]
operator|.
name|track
argument_list|)
expr_stmt|;
block|}
block|}
name|error
operator|=
name|copyout
argument_list|(
name|data
operator|->
name|entries
argument_list|,
name|te
operator|->
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lead
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CDIOREADTOCENTRY
case|:
block|{
comment|/* yeah yeah, this is ugly */
typedef|typedef
struct|struct
block|{
name|struct
name|ioc_toc_header
name|header
decl_stmt|;
name|struct
name|cd_toc_entry
name|entry
decl_stmt|;
block|}
name|data_t
typedef|;
name|data_t
modifier|*
name|data
decl_stmt|;
name|struct
name|ioc_read_toc_single_entry
modifier|*
name|te
init|=
operator|(
expr|struct
name|ioc_read_toc_single_entry
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|ioc_toc_header
modifier|*
name|th
decl_stmt|;
name|u_int32_t
name|track
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"trying to do CDIOREADTOCENTRY\n"
operator|)
argument_list|)
expr_stmt|;
name|data
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|data_t
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|te
operator|->
name|address_format
operator|!=
name|CD_MSF_FORMAT
operator|&&
name|te
operator|->
name|address_format
operator|!=
name|CD_LBA_FORMAT
condition|)
block|{
name|printf
argument_list|(
literal|"error in readtocentry, "
literal|" returning EINVAL\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|th
operator|=
operator|&
name|data
operator|->
name|header
expr_stmt|;
name|error
operator|=
name|cdreadtoc
argument_list|(
name|periph
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|cd_toc_entry
operator|*
operator|)
name|th
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|th
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|softc
operator|->
name|quirks
operator|&
name|CD_Q_BCD_TRACKS
condition|)
block|{
comment|/* we are going to have to convert the BCD 				 * encoding on the cd to what is expected 				 */
name|th
operator|->
name|starting_track
operator|=
name|bcd2bin
argument_list|(
name|th
operator|->
name|starting_track
argument_list|)
expr_stmt|;
name|th
operator|->
name|ending_track
operator|=
name|bcd2bin
argument_list|(
name|th
operator|->
name|ending_track
argument_list|)
expr_stmt|;
block|}
name|track
operator|=
name|te
operator|->
name|track
expr_stmt|;
if|if
condition|(
name|track
operator|==
literal|0
condition|)
name|track
operator|=
name|th
operator|->
name|starting_track
expr_stmt|;
elseif|else
if|if
condition|(
name|track
operator|==
name|LEADOUT
condition|)
comment|/* OK */
empty_stmt|;
elseif|else
if|if
condition|(
name|track
operator|<
name|th
operator|->
name|starting_track
operator|||
name|track
operator|>
name|th
operator|->
name|ending_track
operator|+
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"error in readtocentry, "
literal|" returning EINVAL\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|cdreadtoc
argument_list|(
name|periph
argument_list|,
name|te
operator|->
name|address_format
argument_list|,
name|track
argument_list|,
operator|(
expr|struct
name|cd_toc_entry
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|data_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|softc
operator|->
name|quirks
operator|&
name|CD_Q_BCD_TRACKS
condition|)
name|data
operator|->
name|entry
operator|.
name|track
operator|=
name|bcd2bin
argument_list|(
name|data
operator|->
name|entry
operator|.
name|track
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|data
operator|->
name|entry
argument_list|,
operator|&
name|te
operator|->
name|entry
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cd_toc_entry
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CDIOCSETPATCH
case|:
block|{
name|struct
name|ioc_patch
modifier|*
name|arg
init|=
operator|(
expr|struct
name|ioc_patch
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|cd_mode_data
modifier|*
name|data
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"trying to do CDIOCSETPATCH\n"
operator|)
argument_list|)
expr_stmt|;
name|data
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cd_mode_data
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdgetmode
argument_list|(
name|periph
argument_list|,
name|data
argument_list|,
name|AUDIO_PAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
name|data
operator|->
name|page
operator|.
name|audio
operator|.
name|port
index|[
name|LEFT_PORT
index|]
operator|.
name|channels
operator|=
name|arg
operator|->
name|patch
index|[
literal|0
index|]
expr_stmt|;
name|data
operator|->
name|page
operator|.
name|audio
operator|.
name|port
index|[
name|RIGHT_PORT
index|]
operator|.
name|channels
operator|=
name|arg
operator|->
name|patch
index|[
literal|1
index|]
expr_stmt|;
name|data
operator|->
name|page
operator|.
name|audio
operator|.
name|port
index|[
literal|2
index|]
operator|.
name|channels
operator|=
name|arg
operator|->
name|patch
index|[
literal|2
index|]
expr_stmt|;
name|data
operator|->
name|page
operator|.
name|audio
operator|.
name|port
index|[
literal|3
index|]
operator|.
name|channels
operator|=
name|arg
operator|->
name|patch
index|[
literal|3
index|]
expr_stmt|;
name|error
operator|=
name|cdsetmode
argument_list|(
name|periph
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CDIOCGETVOL
case|:
block|{
name|struct
name|ioc_vol
modifier|*
name|arg
init|=
operator|(
expr|struct
name|ioc_vol
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|cd_mode_data
modifier|*
name|data
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"trying to do CDIOCGETVOL\n"
operator|)
argument_list|)
expr_stmt|;
name|data
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cd_mode_data
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdgetmode
argument_list|(
name|periph
argument_list|,
name|data
argument_list|,
name|AUDIO_PAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
name|arg
operator|->
name|vol
index|[
name|LEFT_PORT
index|]
operator|=
name|data
operator|->
name|page
operator|.
name|audio
operator|.
name|port
index|[
name|LEFT_PORT
index|]
operator|.
name|volume
expr_stmt|;
name|arg
operator|->
name|vol
index|[
name|RIGHT_PORT
index|]
operator|=
name|data
operator|->
name|page
operator|.
name|audio
operator|.
name|port
index|[
name|RIGHT_PORT
index|]
operator|.
name|volume
expr_stmt|;
name|arg
operator|->
name|vol
index|[
literal|2
index|]
operator|=
name|data
operator|->
name|page
operator|.
name|audio
operator|.
name|port
index|[
literal|2
index|]
operator|.
name|volume
expr_stmt|;
name|arg
operator|->
name|vol
index|[
literal|3
index|]
operator|=
name|data
operator|->
name|page
operator|.
name|audio
operator|.
name|port
index|[
literal|3
index|]
operator|.
name|volume
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CDIOCSETVOL
case|:
block|{
name|struct
name|ioc_vol
modifier|*
name|arg
init|=
operator|(
expr|struct
name|ioc_vol
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|cd_mode_data
modifier|*
name|data
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"trying to do CDIOCSETVOL\n"
operator|)
argument_list|)
expr_stmt|;
name|data
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cd_mode_data
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdgetmode
argument_list|(
name|periph
argument_list|,
name|data
argument_list|,
name|AUDIO_PAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
name|data
operator|->
name|page
operator|.
name|audio
operator|.
name|port
index|[
name|LEFT_PORT
index|]
operator|.
name|channels
operator|=
name|CHANNEL_0
expr_stmt|;
name|data
operator|->
name|page
operator|.
name|audio
operator|.
name|port
index|[
name|LEFT_PORT
index|]
operator|.
name|volume
operator|=
name|arg
operator|->
name|vol
index|[
name|LEFT_PORT
index|]
expr_stmt|;
name|data
operator|->
name|page
operator|.
name|audio
operator|.
name|port
index|[
name|RIGHT_PORT
index|]
operator|.
name|channels
operator|=
name|CHANNEL_1
expr_stmt|;
name|data
operator|->
name|page
operator|.
name|audio
operator|.
name|port
index|[
name|RIGHT_PORT
index|]
operator|.
name|volume
operator|=
name|arg
operator|->
name|vol
index|[
name|RIGHT_PORT
index|]
expr_stmt|;
name|data
operator|->
name|page
operator|.
name|audio
operator|.
name|port
index|[
literal|2
index|]
operator|.
name|volume
operator|=
name|arg
operator|->
name|vol
index|[
literal|2
index|]
expr_stmt|;
name|data
operator|->
name|page
operator|.
name|audio
operator|.
name|port
index|[
literal|3
index|]
operator|.
name|volume
operator|=
name|arg
operator|->
name|vol
index|[
literal|3
index|]
expr_stmt|;
name|error
operator|=
name|cdsetmode
argument_list|(
name|periph
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CDIOCSETMONO
case|:
block|{
name|struct
name|cd_mode_data
modifier|*
name|data
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"trying to do CDIOCSETMONO\n"
operator|)
argument_list|)
expr_stmt|;
name|data
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cd_mode_data
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdgetmode
argument_list|(
name|periph
argument_list|,
name|data
argument_list|,
name|AUDIO_PAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
name|data
operator|->
name|page
operator|.
name|audio
operator|.
name|port
index|[
name|LEFT_PORT
index|]
operator|.
name|channels
operator|=
name|LEFT_CHANNEL
operator||
name|RIGHT_CHANNEL
expr_stmt|;
name|data
operator|->
name|page
operator|.
name|audio
operator|.
name|port
index|[
name|RIGHT_PORT
index|]
operator|.
name|channels
operator|=
name|LEFT_CHANNEL
operator||
name|RIGHT_CHANNEL
expr_stmt|;
name|data
operator|->
name|page
operator|.
name|audio
operator|.
name|port
index|[
literal|2
index|]
operator|.
name|channels
operator|=
literal|0
expr_stmt|;
name|data
operator|->
name|page
operator|.
name|audio
operator|.
name|port
index|[
literal|3
index|]
operator|.
name|channels
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|cdsetmode
argument_list|(
name|periph
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CDIOCSETSTEREO
case|:
block|{
name|struct
name|cd_mode_data
modifier|*
name|data
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"trying to do CDIOCSETSTEREO\n"
operator|)
argument_list|)
expr_stmt|;
name|data
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cd_mode_data
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdgetmode
argument_list|(
name|periph
argument_list|,
name|data
argument_list|,
name|AUDIO_PAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
name|data
operator|->
name|page
operator|.
name|audio
operator|.
name|port
index|[
name|LEFT_PORT
index|]
operator|.
name|channels
operator|=
name|LEFT_CHANNEL
expr_stmt|;
name|data
operator|->
name|page
operator|.
name|audio
operator|.
name|port
index|[
name|RIGHT_PORT
index|]
operator|.
name|channels
operator|=
name|RIGHT_CHANNEL
expr_stmt|;
name|data
operator|->
name|page
operator|.
name|audio
operator|.
name|port
index|[
literal|2
index|]
operator|.
name|channels
operator|=
literal|0
expr_stmt|;
name|data
operator|->
name|page
operator|.
name|audio
operator|.
name|port
index|[
literal|3
index|]
operator|.
name|channels
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|cdsetmode
argument_list|(
name|periph
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CDIOCSETMUTE
case|:
block|{
name|struct
name|cd_mode_data
modifier|*
name|data
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"trying to do CDIOCSETMUTE\n"
operator|)
argument_list|)
expr_stmt|;
name|data
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cd_mode_data
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdgetmode
argument_list|(
name|periph
argument_list|,
name|data
argument_list|,
name|AUDIO_PAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
name|data
operator|->
name|page
operator|.
name|audio
operator|.
name|port
index|[
name|LEFT_PORT
index|]
operator|.
name|channels
operator|=
literal|0
expr_stmt|;
name|data
operator|->
name|page
operator|.
name|audio
operator|.
name|port
index|[
name|RIGHT_PORT
index|]
operator|.
name|channels
operator|=
literal|0
expr_stmt|;
name|data
operator|->
name|page
operator|.
name|audio
operator|.
name|port
index|[
literal|2
index|]
operator|.
name|channels
operator|=
literal|0
expr_stmt|;
name|data
operator|->
name|page
operator|.
name|audio
operator|.
name|port
index|[
literal|3
index|]
operator|.
name|channels
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|cdsetmode
argument_list|(
name|periph
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CDIOCSETLEFT
case|:
block|{
name|struct
name|cd_mode_data
modifier|*
name|data
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"trying to do CDIOCSETLEFT\n"
operator|)
argument_list|)
expr_stmt|;
name|data
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cd_mode_data
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdgetmode
argument_list|(
name|periph
argument_list|,
name|data
argument_list|,
name|AUDIO_PAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
name|data
operator|->
name|page
operator|.
name|audio
operator|.
name|port
index|[
name|LEFT_PORT
index|]
operator|.
name|channels
operator|=
name|LEFT_CHANNEL
expr_stmt|;
name|data
operator|->
name|page
operator|.
name|audio
operator|.
name|port
index|[
name|RIGHT_PORT
index|]
operator|.
name|channels
operator|=
name|LEFT_CHANNEL
expr_stmt|;
name|data
operator|->
name|page
operator|.
name|audio
operator|.
name|port
index|[
literal|2
index|]
operator|.
name|channels
operator|=
literal|0
expr_stmt|;
name|data
operator|->
name|page
operator|.
name|audio
operator|.
name|port
index|[
literal|3
index|]
operator|.
name|channels
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|cdsetmode
argument_list|(
name|periph
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CDIOCSETRIGHT
case|:
block|{
name|struct
name|cd_mode_data
modifier|*
name|data
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"trying to do CDIOCSETRIGHT\n"
operator|)
argument_list|)
expr_stmt|;
name|data
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cd_mode_data
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdgetmode
argument_list|(
name|periph
argument_list|,
name|data
argument_list|,
name|AUDIO_PAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
name|data
operator|->
name|page
operator|.
name|audio
operator|.
name|port
index|[
name|LEFT_PORT
index|]
operator|.
name|channels
operator|=
name|RIGHT_CHANNEL
expr_stmt|;
name|data
operator|->
name|page
operator|.
name|audio
operator|.
name|port
index|[
name|RIGHT_PORT
index|]
operator|.
name|channels
operator|=
name|RIGHT_CHANNEL
expr_stmt|;
name|data
operator|->
name|page
operator|.
name|audio
operator|.
name|port
index|[
literal|2
index|]
operator|.
name|channels
operator|=
literal|0
expr_stmt|;
name|data
operator|->
name|page
operator|.
name|audio
operator|.
name|port
index|[
literal|3
index|]
operator|.
name|channels
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|cdsetmode
argument_list|(
name|periph
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CDIOCRESUME
case|:
name|error
operator|=
name|cdpause
argument_list|(
name|periph
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|CDIOCPAUSE
case|:
name|error
operator|=
name|cdpause
argument_list|(
name|periph
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|CDIOCSTART
case|:
name|error
operator|=
name|cdstartunit
argument_list|(
name|periph
argument_list|)
expr_stmt|;
break|break;
case|case
name|CDIOCSTOP
case|:
name|error
operator|=
name|cdstopunit
argument_list|(
name|periph
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|CDIOCEJECT
case|:
name|error
operator|=
name|cdstopunit
argument_list|(
name|periph
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|CDIOCALLOW
case|:
name|cdprevent
argument_list|(
name|periph
argument_list|,
name|PR_ALLOW
argument_list|)
expr_stmt|;
break|break;
case|case
name|CDIOCPREVENT
case|:
name|cdprevent
argument_list|(
name|periph
argument_list|,
name|PR_PREVENT
argument_list|)
expr_stmt|;
break|break;
case|case
name|CDIOCSETDEBUG
case|:
comment|/* sc_link->flags |= (SDEV_DB1 | SDEV_DB2); */
name|error
operator|=
name|ENOTTY
expr_stmt|;
break|break;
case|case
name|CDIOCCLRDEBUG
case|:
comment|/* sc_link->flags&= ~(SDEV_DB1 | SDEV_DB2); */
name|error
operator|=
name|ENOTTY
expr_stmt|;
break|break;
case|case
name|CDIOCRESET
case|:
comment|/* return (cd_reset(periph)); */
name|error
operator|=
name|ENOTTY
expr_stmt|;
break|break;
case|case
name|DVDIOCSENDKEY
case|:
case|case
name|DVDIOCREPORTKEY
case|:
block|{
name|struct
name|dvd_authinfo
modifier|*
name|authinfo
decl_stmt|;
name|authinfo
operator|=
operator|(
expr|struct
name|dvd_authinfo
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|DVDIOCREPORTKEY
condition|)
name|error
operator|=
name|cdreportkey
argument_list|(
name|periph
argument_list|,
name|authinfo
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|cdsendkey
argument_list|(
name|periph
argument_list|,
name|authinfo
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DVDIOCREADSTRUCTURE
case|:
block|{
name|struct
name|dvd_struct
modifier|*
name|dvdstruct
decl_stmt|;
name|dvdstruct
operator|=
operator|(
expr|struct
name|dvd_struct
operator|*
operator|)
name|addr
expr_stmt|;
name|error
operator|=
name|cdreaddvdstructure
argument_list|(
name|periph
argument_list|,
name|dvdstruct
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|error
operator|=
name|cam_periph_ioctl
argument_list|(
name|periph
argument_list|,
name|cmd
argument_list|,
name|addr
argument_list|,
name|cderror
argument_list|)
expr_stmt|;
break|break;
block|}
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"leaving cdioctl\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cdprevent
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|action
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|cd_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"entering cdprevent\n"
operator|)
argument_list|)
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|cd_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|action
operator|==
name|PR_ALLOW
operator|)
operator|&&
operator|(
name|softc
operator|->
name|flags
operator|&
name|CD_FLAG_DISC_LOCKED
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|action
operator|==
name|PR_PREVENT
operator|)
operator|&&
operator|(
name|softc
operator|->
name|flags
operator|&
name|CD_FLAG_DISC_LOCKED
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
return|return;
block|}
name|ccb
operator|=
name|cdgetccb
argument_list|(
name|periph
argument_list|,
comment|/* priority */
literal|1
argument_list|)
expr_stmt|;
name|scsi_prevent
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/*retries*/
literal|1
argument_list|,
name|cddone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|action
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
literal|60000
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdrunccb
argument_list|(
name|ccb
argument_list|,
name|cderror
argument_list|,
comment|/*cam_flags*/
literal|0
argument_list|,
comment|/*sense_flags*/
name|SF_RETRY_UA
operator||
name|SF_NO_PRINT
operator||
name|SF_RETRY_SELTO
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|action
operator|==
name|PR_ALLOW
condition|)
name|softc
operator|->
name|flags
operator|&=
operator|~
name|CD_FLAG_DISC_LOCKED
expr_stmt|;
else|else
name|softc
operator|->
name|flags
operator||=
name|CD_FLAG_DISC_LOCKED
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|cdsize
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|u_int32_t
modifier|*
name|size
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|cd_softc
modifier|*
name|softc
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|scsi_read_capacity_data
modifier|*
name|rcap_buf
decl_stmt|;
name|int
name|error
decl_stmt|;
name|periph
operator|=
name|cam_extend_get
argument_list|(
name|cdperiphs
argument_list|,
name|dkunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"entering cdsize\n"
operator|)
argument_list|)
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|cd_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|ccb
operator|=
name|cdgetccb
argument_list|(
name|periph
argument_list|,
comment|/* priority */
literal|1
argument_list|)
expr_stmt|;
name|rcap_buf
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_capacity_data
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|scsi_read_capacity
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/*retries*/
literal|1
argument_list|,
name|cddone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|rcap_buf
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
literal|20000
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdrunccb
argument_list|(
name|ccb
argument_list|,
name|cderror
argument_list|,
comment|/*cam_flags*/
literal|0
argument_list|,
comment|/*sense_flags*/
name|SF_RETRY_UA
operator||
name|SF_NO_PRINT
operator||
name|SF_RETRY_SELTO
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|softc
operator|->
name|params
operator|.
name|disksize
operator|=
name|scsi_4btoul
argument_list|(
name|rcap_buf
operator|->
name|addr
argument_list|)
operator|+
literal|1
expr_stmt|;
name|softc
operator|->
name|params
operator|.
name|blksize
operator|=
name|scsi_4btoul
argument_list|(
name|rcap_buf
operator|->
name|length
argument_list|)
expr_stmt|;
comment|/* 	 * SCSI-3 mandates that the reported blocksize shall be 2048. 	 * Older drives sometimes report funny values, trim it down to 	 * 2048, or other parts of the kernel will get confused. 	 * 	 * XXX we leave drives alone that might report 512 bytes, as 	 * well as drives reporting more weird sizes like perhaps 4K. 	 */
if|if
condition|(
name|softc
operator|->
name|params
operator|.
name|blksize
operator|>
literal|2048
operator|&&
name|softc
operator|->
name|params
operator|.
name|blksize
operator|<=
literal|2352
condition|)
name|softc
operator|->
name|params
operator|.
name|blksize
operator|=
literal|2048
expr_stmt|;
name|free
argument_list|(
name|rcap_buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
operator|*
name|size
operator|=
name|softc
operator|->
name|params
operator|.
name|disksize
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The idea here is to try to figure out whether the first track is data or  * audio.  If it is data, we can at least attempt to read a disklabel off  * the first sector of the disk.  If it is audio, there won't be a  * disklabel.  *  * This routine returns 0 if the first track is data, and non-zero if there  * is an error or the first track is audio.  (If either non-zero case, we  * should not attempt to read the disklabel.)  */
end_comment

begin_function
specifier|static
name|int
name|cdfirsttrackisdata
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
struct|struct
name|cdtocdata
block|{
name|struct
name|ioc_toc_header
name|header
decl_stmt|;
name|struct
name|cd_toc_entry
name|entries
index|[
literal|100
index|]
decl_stmt|;
block|}
struct|;
name|struct
name|cd_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ioc_toc_header
modifier|*
name|th
decl_stmt|;
name|struct
name|cdtocdata
modifier|*
name|data
decl_stmt|;
name|int
name|num_entries
decl_stmt|,
name|i
decl_stmt|;
name|int
name|error
decl_stmt|,
name|first_track_audio
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|first_track_audio
operator|=
operator|-
literal|1
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|cd_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|data
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cdtocdata
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|th
operator|=
operator|&
name|data
operator|->
name|header
expr_stmt|;
name|error
operator|=
name|cdreadtoc
argument_list|(
name|periph
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|cd_toc_entry
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bailout
goto|;
if|if
condition|(
name|softc
operator|->
name|quirks
operator|&
name|CD_Q_BCD_TRACKS
condition|)
block|{
comment|/* we are going to have to convert the BCD 		 * encoding on the cd to what is expected 		 */
name|th
operator|->
name|starting_track
operator|=
name|bcd2bin
argument_list|(
name|th
operator|->
name|starting_track
argument_list|)
expr_stmt|;
name|th
operator|->
name|ending_track
operator|=
name|bcd2bin
argument_list|(
name|th
operator|->
name|ending_track
argument_list|)
expr_stmt|;
block|}
name|th
operator|->
name|len
operator|=
name|scsi_2btoul
argument_list|(
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|th
operator|->
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|th
operator|->
name|len
operator|-
literal|2
operator|)
operator|>
literal|0
condition|)
name|num_entries
operator|=
operator|(
name|th
operator|->
name|len
operator|-
literal|2
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|cd_toc_entry
argument_list|)
expr_stmt|;
else|else
name|num_entries
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_entries
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|data
operator|->
name|entries
index|[
name|i
index|]
operator|.
name|track
operator|==
name|th
operator|->
name|starting_track
condition|)
block|{
if|if
condition|(
name|data
operator|->
name|entries
index|[
name|i
index|]
operator|.
name|control
operator|&
literal|0x4
condition|)
name|first_track_audio
operator|=
literal|0
expr_stmt|;
else|else
name|first_track_audio
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|first_track_audio
operator|==
operator|-
literal|1
condition|)
name|error
operator|=
name|ENOENT
expr_stmt|;
elseif|else
if|if
condition|(
name|first_track_audio
operator|==
literal|1
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
name|error
operator|=
literal|0
expr_stmt|;
name|bailout
label|:
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cderror
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|u_int32_t
name|cam_flags
parameter_list|,
name|u_int32_t
name|sense_flags
parameter_list|)
block|{
name|struct
name|cd_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|periph
operator|=
name|xpt_path_periph
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|cd_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
comment|/* 	 * XXX 	 * Until we have a better way of doing pack validation, 	 * don't treat UAs as errors. 	 */
name|sense_flags
operator||=
name|SF_RETRY_UA
expr_stmt|;
return|return
operator|(
name|cam_periph_error
argument_list|(
name|ccb
argument_list|,
name|cam_flags
argument_list|,
name|sense_flags
argument_list|,
operator|&
name|softc
operator|->
name|saved_ccb
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read table of contents  */
end_comment

begin_function
specifier|static
name|int
name|cdreadtoc
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|u_int32_t
name|mode
parameter_list|,
name|u_int32_t
name|start
parameter_list|,
name|struct
name|cd_toc_entry
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|len
parameter_list|)
block|{
name|struct
name|scsi_read_toc
modifier|*
name|scsi_cmd
decl_stmt|;
name|u_int32_t
name|ntoc
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ntoc
operator|=
name|len
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|ccb
operator|=
name|cdgetccb
argument_list|(
name|periph
argument_list|,
comment|/* priority */
literal|1
argument_list|)
expr_stmt|;
name|csio
operator|=
operator|&
name|ccb
operator|->
name|csio
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
comment|/* retries */
literal|1
argument_list|,
comment|/* cbfcnp */
name|cddone
argument_list|,
comment|/* flags */
name|CAM_DIR_IN
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* data_ptr */
operator|(
name|u_int8_t
operator|*
operator|)
name|data
argument_list|,
comment|/* dxfer_len */
name|len
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_toc
argument_list|)
argument_list|,
comment|/* timeout */
literal|50000
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_read_toc
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|CD_MSF_FORMAT
condition|)
name|scsi_cmd
operator|->
name|byte2
operator||=
name|CD_MSF
expr_stmt|;
name|scsi_cmd
operator|->
name|from_track
operator|=
name|start
expr_stmt|;
comment|/* scsi_ulto2b(ntoc, (u_int8_t *)scsi_cmd->data_len); */
name|scsi_cmd
operator|->
name|data_len
index|[
literal|0
index|]
operator|=
operator|(
name|ntoc
operator|)
operator|>>
literal|8
expr_stmt|;
name|scsi_cmd
operator|->
name|data_len
index|[
literal|1
index|]
operator|=
operator|(
name|ntoc
operator|)
operator|&
literal|0xff
expr_stmt|;
name|scsi_cmd
operator|->
name|op_code
operator|=
name|READ_TOC
expr_stmt|;
name|error
operator|=
name|cdrunccb
argument_list|(
name|ccb
argument_list|,
name|cderror
argument_list|,
comment|/*cam_flags*/
literal|0
argument_list|,
comment|/*sense_flags*/
name|SF_RETRY_UA
operator||
name|SF_RETRY_SELTO
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cdreadsubchannel
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|u_int32_t
name|mode
parameter_list|,
name|u_int32_t
name|format
parameter_list|,
name|int
name|track
parameter_list|,
name|struct
name|cd_sub_channel_info
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|len
parameter_list|)
block|{
name|struct
name|scsi_read_subchannel
modifier|*
name|scsi_cmd
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|ccb
operator|=
name|cdgetccb
argument_list|(
name|periph
argument_list|,
comment|/* priority */
literal|1
argument_list|)
expr_stmt|;
name|csio
operator|=
operator|&
name|ccb
operator|->
name|csio
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
comment|/* retries */
literal|1
argument_list|,
comment|/* cbfcnp */
name|cddone
argument_list|,
comment|/* flags */
name|CAM_DIR_IN
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* data_ptr */
operator|(
name|u_int8_t
operator|*
operator|)
name|data
argument_list|,
comment|/* dxfer_len */
name|len
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_subchannel
argument_list|)
argument_list|,
comment|/* timeout */
literal|50000
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_read_subchannel
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|op_code
operator|=
name|READ_SUBCHANNEL
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|CD_MSF_FORMAT
condition|)
name|scsi_cmd
operator|->
name|byte1
operator||=
name|CD_MSF
expr_stmt|;
name|scsi_cmd
operator|->
name|byte2
operator|=
name|SRS_SUBQ
expr_stmt|;
name|scsi_cmd
operator|->
name|subchan_format
operator|=
name|format
expr_stmt|;
name|scsi_cmd
operator|->
name|track
operator|=
name|track
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|len
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
name|scsi_cmd
operator|->
name|data_len
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|control
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|cdrunccb
argument_list|(
name|ccb
argument_list|,
name|cderror
argument_list|,
comment|/*cam_flags*/
literal|0
argument_list|,
comment|/*sense_flags*/
name|SF_RETRY_UA
operator||
name|SF_RETRY_SELTO
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cdgetmode
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|cd_mode_data
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|page
parameter_list|)
block|{
name|struct
name|scsi_mode_sense_6
modifier|*
name|scsi_cmd
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ccb
operator|=
name|cdgetccb
argument_list|(
name|periph
argument_list|,
comment|/* priority */
literal|1
argument_list|)
expr_stmt|;
name|csio
operator|=
operator|&
name|ccb
operator|->
name|csio
expr_stmt|;
name|bzero
argument_list|(
name|data
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
comment|/* retries */
literal|1
argument_list|,
comment|/* cbfcnp */
name|cddone
argument_list|,
comment|/* flags */
name|CAM_DIR_IN
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* data_ptr */
operator|(
name|u_int8_t
operator|*
operator|)
name|data
argument_list|,
comment|/* dxfer_len */
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_mode_sense_6
argument_list|)
argument_list|,
comment|/* timeout */
literal|50000
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_mode_sense_6
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|page
operator|=
name|page
expr_stmt|;
name|scsi_cmd
operator|->
name|length
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
operator|&
literal|0xff
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|MODE_SENSE
expr_stmt|;
name|error
operator|=
name|cdrunccb
argument_list|(
name|ccb
argument_list|,
name|cderror
argument_list|,
comment|/*cam_flags*/
literal|0
argument_list|,
comment|/*sense_flags*/
name|SF_RETRY_UA
operator||
name|SF_RETRY_SELTO
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cdsetmode
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|cd_mode_data
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|scsi_mode_select_6
modifier|*
name|scsi_cmd
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ccb
operator|=
name|cdgetccb
argument_list|(
name|periph
argument_list|,
comment|/* priority */
literal|1
argument_list|)
expr_stmt|;
name|csio
operator|=
operator|&
name|ccb
operator|->
name|csio
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
comment|/* retries */
literal|1
argument_list|,
comment|/* cbfcnp */
name|cddone
argument_list|,
comment|/* flags */
name|CAM_DIR_OUT
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* data_ptr */
operator|(
name|u_int8_t
operator|*
operator|)
name|data
argument_list|,
comment|/* dxfer_len */
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_mode_select_6
argument_list|)
argument_list|,
comment|/* timeout */
literal|50000
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_mode_select_6
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|MODE_SELECT
expr_stmt|;
name|scsi_cmd
operator|->
name|byte2
operator||=
name|SMS_PF
expr_stmt|;
name|scsi_cmd
operator|->
name|length
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
operator|&
literal|0xff
expr_stmt|;
name|data
operator|->
name|header
operator|.
name|data_length
operator|=
literal|0
expr_stmt|;
comment|/* 	 * SONY drives do not allow a mode select with a medium_type 	 * value that has just been returned by a mode sense; use a 	 * medium_type of 0 (Default) instead. 	 */
name|data
operator|->
name|header
operator|.
name|medium_type
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|cdrunccb
argument_list|(
name|ccb
argument_list|,
name|cderror
argument_list|,
comment|/*cam_flags*/
literal|0
argument_list|,
comment|/*sense_flags*/
name|SF_RETRY_UA
operator||
name|SF_RETRY_SELTO
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cdplay
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|u_int32_t
name|blk
parameter_list|,
name|u_int32_t
name|len
parameter_list|)
block|{
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_int8_t
name|cdb_len
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|ccb
operator|=
name|cdgetccb
argument_list|(
name|periph
argument_list|,
comment|/* priority */
literal|1
argument_list|)
expr_stmt|;
name|csio
operator|=
operator|&
name|ccb
operator|->
name|csio
expr_stmt|;
comment|/* 	 * Use the smallest possible command to perform the operation. 	 */
if|if
condition|(
operator|(
name|len
operator|&
literal|0xffff0000
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * We can fit in a 10 byte cdb. 		 */
name|struct
name|scsi_play_10
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_play_10
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|op_code
operator|=
name|PLAY_10
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|blk
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
name|scsi_cmd
operator|->
name|blk_addr
argument_list|)
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|len
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
name|scsi_cmd
operator|->
name|xfer_len
argument_list|)
expr_stmt|;
name|cdb_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|scsi_play_12
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_play_12
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|op_code
operator|=
name|PLAY_12
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|blk
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
name|scsi_cmd
operator|->
name|blk_addr
argument_list|)
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|len
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
name|scsi_cmd
operator|->
name|xfer_len
argument_list|)
expr_stmt|;
name|cdb_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
expr_stmt|;
block|}
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
comment|/*retries*/
literal|2
argument_list|,
name|cddone
argument_list|,
comment|/*flags*/
name|CAM_DIR_NONE
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*dataptr*/
name|NULL
argument_list|,
comment|/*datalen*/
literal|0
argument_list|,
comment|/*sense_len*/
name|SSD_FULL_SIZE
argument_list|,
name|cdb_len
argument_list|,
comment|/*timeout*/
literal|50
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdrunccb
argument_list|(
name|ccb
argument_list|,
name|cderror
argument_list|,
comment|/*cam_flags*/
literal|0
argument_list|,
comment|/*sense_flags*/
name|SF_RETRY_UA
operator||
name|SF_RETRY_SELTO
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cdplaymsf
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|u_int32_t
name|startm
parameter_list|,
name|u_int32_t
name|starts
parameter_list|,
name|u_int32_t
name|startf
parameter_list|,
name|u_int32_t
name|endm
parameter_list|,
name|u_int32_t
name|ends
parameter_list|,
name|u_int32_t
name|endf
parameter_list|)
block|{
name|struct
name|scsi_play_msf
modifier|*
name|scsi_cmd
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|ccb
operator|=
name|cdgetccb
argument_list|(
name|periph
argument_list|,
comment|/* priority */
literal|1
argument_list|)
expr_stmt|;
name|csio
operator|=
operator|&
name|ccb
operator|->
name|csio
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
comment|/* retries */
literal|1
argument_list|,
comment|/* cbfcnp */
name|cddone
argument_list|,
comment|/* flags */
name|CAM_DIR_NONE
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* data_ptr */
name|NULL
argument_list|,
comment|/* dxfer_len */
literal|0
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_play_msf
argument_list|)
argument_list|,
comment|/* timeout */
literal|50000
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_play_msf
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|op_code
operator|=
name|PLAY_MSF
expr_stmt|;
name|scsi_cmd
operator|->
name|start_m
operator|=
name|startm
expr_stmt|;
name|scsi_cmd
operator|->
name|start_s
operator|=
name|starts
expr_stmt|;
name|scsi_cmd
operator|->
name|start_f
operator|=
name|startf
expr_stmt|;
name|scsi_cmd
operator|->
name|end_m
operator|=
name|endm
expr_stmt|;
name|scsi_cmd
operator|->
name|end_s
operator|=
name|ends
expr_stmt|;
name|scsi_cmd
operator|->
name|end_f
operator|=
name|endf
expr_stmt|;
name|error
operator|=
name|cdrunccb
argument_list|(
name|ccb
argument_list|,
name|cderror
argument_list|,
comment|/*cam_flags*/
literal|0
argument_list|,
comment|/*sense_flags*/
name|SF_RETRY_UA
operator||
name|SF_RETRY_SELTO
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cdplaytracks
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|u_int32_t
name|strack
parameter_list|,
name|u_int32_t
name|sindex
parameter_list|,
name|u_int32_t
name|etrack
parameter_list|,
name|u_int32_t
name|eindex
parameter_list|)
block|{
name|struct
name|scsi_play_track
modifier|*
name|scsi_cmd
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|ccb
operator|=
name|cdgetccb
argument_list|(
name|periph
argument_list|,
comment|/* priority */
literal|1
argument_list|)
expr_stmt|;
name|csio
operator|=
operator|&
name|ccb
operator|->
name|csio
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
comment|/* retries */
literal|1
argument_list|,
comment|/* cbfcnp */
name|cddone
argument_list|,
comment|/* flags */
name|CAM_DIR_NONE
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* data_ptr */
name|NULL
argument_list|,
comment|/* dxfer_len */
literal|0
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_play_track
argument_list|)
argument_list|,
comment|/* timeout */
literal|50000
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_play_track
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|op_code
operator|=
name|PLAY_TRACK
expr_stmt|;
name|scsi_cmd
operator|->
name|start_track
operator|=
name|strack
expr_stmt|;
name|scsi_cmd
operator|->
name|start_index
operator|=
name|sindex
expr_stmt|;
name|scsi_cmd
operator|->
name|end_track
operator|=
name|etrack
expr_stmt|;
name|scsi_cmd
operator|->
name|end_index
operator|=
name|eindex
expr_stmt|;
name|error
operator|=
name|cdrunccb
argument_list|(
name|ccb
argument_list|,
name|cderror
argument_list|,
comment|/*cam_flags*/
literal|0
argument_list|,
comment|/*sense_flags*/
name|SF_RETRY_UA
operator||
name|SF_RETRY_SELTO
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cdpause
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|u_int32_t
name|go
parameter_list|)
block|{
name|struct
name|scsi_pause
modifier|*
name|scsi_cmd
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|ccb
operator|=
name|cdgetccb
argument_list|(
name|periph
argument_list|,
comment|/* priority */
literal|1
argument_list|)
expr_stmt|;
name|csio
operator|=
operator|&
name|ccb
operator|->
name|csio
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
comment|/* retries */
literal|1
argument_list|,
comment|/* cbfcnp */
name|cddone
argument_list|,
comment|/* flags */
name|CAM_DIR_NONE
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* data_ptr */
name|NULL
argument_list|,
comment|/* dxfer_len */
literal|0
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_pause
argument_list|)
argument_list|,
comment|/* timeout */
literal|50000
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_pause
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|op_code
operator|=
name|PAUSE
expr_stmt|;
name|scsi_cmd
operator|->
name|resume
operator|=
name|go
expr_stmt|;
name|error
operator|=
name|cdrunccb
argument_list|(
name|ccb
argument_list|,
name|cderror
argument_list|,
comment|/*cam_flags*/
literal|0
argument_list|,
comment|/*sense_flags*/
name|SF_RETRY_UA
operator||
name|SF_RETRY_SELTO
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cdstartunit
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|ccb
operator|=
name|cdgetccb
argument_list|(
name|periph
argument_list|,
comment|/* priority */
literal|1
argument_list|)
expr_stmt|;
name|scsi_start_stop
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/* retries */
literal|1
argument_list|,
comment|/* cbfcnp */
name|cddone
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* start */
name|TRUE
argument_list|,
comment|/* load_eject */
name|FALSE
argument_list|,
comment|/* immediate */
name|FALSE
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
literal|50000
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdrunccb
argument_list|(
name|ccb
argument_list|,
name|cderror
argument_list|,
comment|/*cam_flags*/
literal|0
argument_list|,
comment|/*sense_flags*/
name|SF_RETRY_UA
operator||
name|SF_RETRY_SELTO
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cdstopunit
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|u_int32_t
name|eject
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|ccb
operator|=
name|cdgetccb
argument_list|(
name|periph
argument_list|,
comment|/* priority */
literal|1
argument_list|)
expr_stmt|;
name|scsi_start_stop
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/* retries */
literal|1
argument_list|,
comment|/* cbfcnp */
name|cddone
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* start */
name|FALSE
argument_list|,
comment|/* load_eject */
name|eject
argument_list|,
comment|/* immediate */
name|FALSE
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
literal|50000
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdrunccb
argument_list|(
name|ccb
argument_list|,
name|cderror
argument_list|,
comment|/*cam_flags*/
literal|0
argument_list|,
comment|/*sense_flags*/
name|SF_RETRY_UA
operator||
name|SF_RETRY_SELTO
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cdreportkey
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|dvd_authinfo
modifier|*
name|authinfo
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|u_int8_t
modifier|*
name|databuf
decl_stmt|;
name|u_int32_t
name|lba
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|length
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|databuf
operator|=
name|NULL
expr_stmt|;
name|lba
operator|=
literal|0
expr_stmt|;
name|ccb
operator|=
name|cdgetccb
argument_list|(
name|periph
argument_list|,
comment|/* priority */
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|authinfo
operator|->
name|format
condition|)
block|{
case|case
name|DVD_REPORT_AGID
case|:
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_report_key_data_agid
argument_list|)
expr_stmt|;
break|break;
case|case
name|DVD_REPORT_CHALLENGE
case|:
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_report_key_data_challenge
argument_list|)
expr_stmt|;
break|break;
case|case
name|DVD_REPORT_KEY1
case|:
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_report_key_data_key1_key2
argument_list|)
expr_stmt|;
break|break;
case|case
name|DVD_REPORT_TITLE_KEY
case|:
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_report_key_data_title
argument_list|)
expr_stmt|;
comment|/* The lba field is only set for the title key */
name|lba
operator|=
name|authinfo
operator|->
name|lba
expr_stmt|;
break|break;
case|case
name|DVD_REPORT_ASF
case|:
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_report_key_data_asf
argument_list|)
expr_stmt|;
break|break;
case|case
name|DVD_REPORT_RPC
case|:
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_report_key_data_rpc
argument_list|)
expr_stmt|;
break|break;
case|case
name|DVD_INVALIDATE_AGID
case|:
name|length
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bailout
goto|;
break|break;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|length
operator|!=
literal|0
condition|)
block|{
name|databuf
operator|=
name|malloc
argument_list|(
name|length
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
block|}
else|else
name|databuf
operator|=
name|NULL
expr_stmt|;
name|scsi_report_key
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/* retries */
literal|1
argument_list|,
comment|/* cbfcnp */
name|cddone
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* lba */
name|lba
argument_list|,
comment|/* agid */
name|authinfo
operator|->
name|agid
argument_list|,
comment|/* key_format */
name|authinfo
operator|->
name|format
argument_list|,
comment|/* data_ptr */
name|databuf
argument_list|,
comment|/* dxfer_len */
name|length
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
literal|50000
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdrunccb
argument_list|(
name|ccb
argument_list|,
name|cderror
argument_list|,
comment|/*cam_flags*/
literal|0
argument_list|,
comment|/*sense_flags*/
name|SF_RETRY_UA
operator||
name|SF_RETRY_SELTO
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|bailout
goto|;
if|if
condition|(
name|ccb
operator|->
name|csio
operator|.
name|resid
operator|!=
literal|0
condition|)
block|{
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"warning, residual for report key command is %d\n"
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|resid
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|authinfo
operator|->
name|format
condition|)
block|{
case|case
name|DVD_REPORT_AGID
case|:
block|{
name|struct
name|scsi_report_key_data_agid
modifier|*
name|agid_data
decl_stmt|;
name|agid_data
operator|=
operator|(
expr|struct
name|scsi_report_key_data_agid
operator|*
operator|)
name|databuf
expr_stmt|;
name|authinfo
operator|->
name|agid
operator|=
operator|(
name|agid_data
operator|->
name|agid
operator|&
name|RKD_AGID_MASK
operator|)
operator|>>
name|RKD_AGID_SHIFT
expr_stmt|;
break|break;
block|}
case|case
name|DVD_REPORT_CHALLENGE
case|:
block|{
name|struct
name|scsi_report_key_data_challenge
modifier|*
name|chal_data
decl_stmt|;
name|chal_data
operator|=
operator|(
expr|struct
name|scsi_report_key_data_challenge
operator|*
operator|)
name|databuf
expr_stmt|;
name|bcopy
argument_list|(
name|chal_data
operator|->
name|challenge_key
argument_list|,
name|authinfo
operator|->
name|keychal
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|chal_data
operator|->
name|challenge_key
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|authinfo
operator|->
name|keychal
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DVD_REPORT_KEY1
case|:
block|{
name|struct
name|scsi_report_key_data_key1_key2
modifier|*
name|key1_data
decl_stmt|;
name|key1_data
operator|=
operator|(
expr|struct
name|scsi_report_key_data_key1_key2
operator|*
operator|)
name|databuf
expr_stmt|;
name|bcopy
argument_list|(
name|key1_data
operator|->
name|key1
argument_list|,
name|authinfo
operator|->
name|keychal
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|key1_data
operator|->
name|key1
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|authinfo
operator|->
name|keychal
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DVD_REPORT_TITLE_KEY
case|:
block|{
name|struct
name|scsi_report_key_data_title
modifier|*
name|title_data
decl_stmt|;
name|title_data
operator|=
operator|(
expr|struct
name|scsi_report_key_data_title
operator|*
operator|)
name|databuf
expr_stmt|;
name|authinfo
operator|->
name|cpm
operator|=
operator|(
name|title_data
operator|->
name|byte0
operator|&
name|RKD_TITLE_CPM
operator|)
operator|>>
name|RKD_TITLE_CPM_SHIFT
expr_stmt|;
name|authinfo
operator|->
name|cp_sec
operator|=
operator|(
name|title_data
operator|->
name|byte0
operator|&
name|RKD_TITLE_CP_SEC
operator|)
operator|>>
name|RKD_TITLE_CP_SEC_SHIFT
expr_stmt|;
name|authinfo
operator|->
name|cgms
operator|=
operator|(
name|title_data
operator|->
name|byte0
operator|&
name|RKD_TITLE_CMGS_MASK
operator|)
operator|>>
name|RKD_TITLE_CMGS_SHIFT
expr_stmt|;
name|bcopy
argument_list|(
name|title_data
operator|->
name|title_key
argument_list|,
name|authinfo
operator|->
name|keychal
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|title_data
operator|->
name|title_key
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|authinfo
operator|->
name|keychal
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DVD_REPORT_ASF
case|:
block|{
name|struct
name|scsi_report_key_data_asf
modifier|*
name|asf_data
decl_stmt|;
name|asf_data
operator|=
operator|(
expr|struct
name|scsi_report_key_data_asf
operator|*
operator|)
name|databuf
expr_stmt|;
name|authinfo
operator|->
name|asf
operator|=
name|asf_data
operator|->
name|success
operator|&
name|RKD_ASF_SUCCESS
expr_stmt|;
break|break;
block|}
case|case
name|DVD_REPORT_RPC
case|:
block|{
name|struct
name|scsi_report_key_data_rpc
modifier|*
name|rpc_data
decl_stmt|;
name|rpc_data
operator|=
operator|(
expr|struct
name|scsi_report_key_data_rpc
operator|*
operator|)
name|databuf
expr_stmt|;
name|authinfo
operator|->
name|reg_type
operator|=
operator|(
name|rpc_data
operator|->
name|byte4
operator|&
name|RKD_RPC_TYPE_MASK
operator|)
operator|>>
name|RKD_RPC_TYPE_SHIFT
expr_stmt|;
name|authinfo
operator|->
name|vend_rsts
operator|=
operator|(
name|rpc_data
operator|->
name|byte4
operator|&
name|RKD_RPC_VENDOR_RESET_MASK
operator|)
operator|>>
name|RKD_RPC_VENDOR_RESET_SHIFT
expr_stmt|;
name|authinfo
operator|->
name|user_rsts
operator|=
name|rpc_data
operator|->
name|byte4
operator|&
name|RKD_RPC_USER_RESET_MASK
expr_stmt|;
break|break;
block|}
case|case
name|DVD_INVALIDATE_AGID
case|:
break|break;
default|default:
comment|/* This should be impossible, since we checked above */
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bailout
goto|;
break|break;
comment|/* NOTREACHED */
block|}
name|bailout
label|:
if|if
condition|(
name|databuf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|databuf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cdsendkey
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|dvd_authinfo
modifier|*
name|authinfo
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|u_int8_t
modifier|*
name|databuf
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|databuf
operator|=
name|NULL
expr_stmt|;
name|ccb
operator|=
name|cdgetccb
argument_list|(
name|periph
argument_list|,
comment|/* priority */
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|authinfo
operator|->
name|format
condition|)
block|{
case|case
name|DVD_SEND_CHALLENGE
case|:
block|{
name|struct
name|scsi_report_key_data_challenge
modifier|*
name|challenge_data
decl_stmt|;
name|length
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|challenge_data
argument_list|)
expr_stmt|;
name|challenge_data
operator|=
name|malloc
argument_list|(
name|length
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|databuf
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|challenge_data
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|length
operator|-
sizeof|sizeof
argument_list|(
name|challenge_data
operator|->
name|data_len
argument_list|)
argument_list|,
name|challenge_data
operator|->
name|data_len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|authinfo
operator|->
name|keychal
argument_list|,
name|challenge_data
operator|->
name|challenge_key
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|authinfo
operator|->
name|keychal
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|challenge_data
operator|->
name|challenge_key
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DVD_SEND_KEY2
case|:
block|{
name|struct
name|scsi_report_key_data_key1_key2
modifier|*
name|key2_data
decl_stmt|;
name|length
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|key2_data
argument_list|)
expr_stmt|;
name|key2_data
operator|=
name|malloc
argument_list|(
name|length
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|databuf
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|key2_data
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|length
operator|-
sizeof|sizeof
argument_list|(
name|key2_data
operator|->
name|data_len
argument_list|)
argument_list|,
name|key2_data
operator|->
name|data_len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|authinfo
operator|->
name|keychal
argument_list|,
name|key2_data
operator|->
name|key1
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|authinfo
operator|->
name|keychal
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|key2_data
operator|->
name|key1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DVD_SEND_RPC
case|:
block|{
name|struct
name|scsi_send_key_data_rpc
modifier|*
name|rpc_data
decl_stmt|;
name|length
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|rpc_data
argument_list|)
expr_stmt|;
name|rpc_data
operator|=
name|malloc
argument_list|(
name|length
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|databuf
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|rpc_data
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|length
operator|-
sizeof|sizeof
argument_list|(
name|rpc_data
operator|->
name|data_len
argument_list|)
argument_list|,
name|rpc_data
operator|->
name|data_len
argument_list|)
expr_stmt|;
comment|/* 		 * XXX KDM is this the right field from authinfo to use? 		 */
name|rpc_data
operator|->
name|region_code
operator|=
name|authinfo
operator|->
name|region
expr_stmt|;
break|break;
block|}
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bailout
goto|;
break|break;
comment|/* NOTREACHED */
block|}
name|scsi_send_key
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/* retries */
literal|1
argument_list|,
comment|/* cbfcnp */
name|cddone
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* agid */
name|authinfo
operator|->
name|agid
argument_list|,
comment|/* key_format */
name|authinfo
operator|->
name|format
argument_list|,
comment|/* data_ptr */
name|databuf
argument_list|,
comment|/* dxfer_len */
name|length
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
literal|50000
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdrunccb
argument_list|(
name|ccb
argument_list|,
name|cderror
argument_list|,
comment|/*cam_flags*/
literal|0
argument_list|,
comment|/*sense_flags*/
name|SF_RETRY_UA
operator||
name|SF_RETRY_SELTO
argument_list|)
expr_stmt|;
name|bailout
label|:
if|if
condition|(
name|databuf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|databuf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cdreaddvdstructure
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|dvd_struct
modifier|*
name|dvdstruct
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|u_int8_t
modifier|*
name|databuf
decl_stmt|;
name|u_int32_t
name|address
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|length
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|databuf
operator|=
name|NULL
expr_stmt|;
comment|/* The address is reserved for many of the formats */
name|address
operator|=
literal|0
expr_stmt|;
name|ccb
operator|=
name|cdgetccb
argument_list|(
name|periph
argument_list|,
comment|/* priority */
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dvdstruct
operator|->
name|format
condition|)
block|{
case|case
name|DVD_STRUCT_PHYSICAL
case|:
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_dvd_struct_data_physical
argument_list|)
expr_stmt|;
break|break;
case|case
name|DVD_STRUCT_COPYRIGHT
case|:
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_dvd_struct_data_copyright
argument_list|)
expr_stmt|;
break|break;
case|case
name|DVD_STRUCT_DISCKEY
case|:
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_dvd_struct_data_disc_key
argument_list|)
expr_stmt|;
break|break;
case|case
name|DVD_STRUCT_BCA
case|:
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_dvd_struct_data_bca
argument_list|)
expr_stmt|;
break|break;
case|case
name|DVD_STRUCT_MANUFACT
case|:
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_dvd_struct_data_manufacturer
argument_list|)
expr_stmt|;
break|break;
case|case
name|DVD_STRUCT_CMI
case|:
name|error
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|bailout
goto|;
ifdef|#
directive|ifdef
name|notyet
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_dvd_struct_data_copy_manage
argument_list|)
expr_stmt|;
name|address
operator|=
name|dvdstruct
operator|->
name|address
expr_stmt|;
endif|#
directive|endif
break|break;
comment|/* NOTREACHED */
case|case
name|DVD_STRUCT_PROTDISCID
case|:
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_dvd_struct_data_prot_discid
argument_list|)
expr_stmt|;
break|break;
case|case
name|DVD_STRUCT_DISCKEYBLOCK
case|:
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_dvd_struct_data_disc_key_blk
argument_list|)
expr_stmt|;
break|break;
case|case
name|DVD_STRUCT_DDS
case|:
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_dvd_struct_data_dds
argument_list|)
expr_stmt|;
break|break;
case|case
name|DVD_STRUCT_MEDIUM_STAT
case|:
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_dvd_struct_data_medium_status
argument_list|)
expr_stmt|;
break|break;
case|case
name|DVD_STRUCT_SPARE_AREA
case|:
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_dvd_struct_data_spare_area
argument_list|)
expr_stmt|;
break|break;
case|case
name|DVD_STRUCT_RMD_LAST
case|:
name|error
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|bailout
goto|;
ifdef|#
directive|ifdef
name|notyet
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_dvd_struct_data_rmd_borderout
argument_list|)
expr_stmt|;
name|address
operator|=
name|dvdstruct
operator|->
name|address
expr_stmt|;
endif|#
directive|endif
break|break;
comment|/* NOTREACHED */
case|case
name|DVD_STRUCT_RMD_RMA
case|:
name|error
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|bailout
goto|;
ifdef|#
directive|ifdef
name|notyet
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_dvd_struct_data_rmd
argument_list|)
expr_stmt|;
name|address
operator|=
name|dvdstruct
operator|->
name|address
expr_stmt|;
endif|#
directive|endif
break|break;
comment|/* NOTREACHED */
case|case
name|DVD_STRUCT_PRERECORDED
case|:
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_dvd_struct_data_leadin
argument_list|)
expr_stmt|;
break|break;
case|case
name|DVD_STRUCT_UNIQUEID
case|:
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_dvd_struct_data_disc_id
argument_list|)
expr_stmt|;
break|break;
case|case
name|DVD_STRUCT_DCB
case|:
name|error
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|bailout
goto|;
ifdef|#
directive|ifdef
name|notyet
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_dvd_struct_data_dcb
argument_list|)
expr_stmt|;
name|address
operator|=
name|dvdstruct
operator|->
name|address
expr_stmt|;
endif|#
directive|endif
break|break;
comment|/* NOTREACHED */
case|case
name|DVD_STRUCT_LIST
case|:
comment|/* 		 * This is the maximum allocation length for the READ DVD 		 * STRUCTURE command.  There's nothing in the MMC3 spec 		 * that indicates a limit in the amount of data that can 		 * be returned from this call, other than the limits 		 * imposed by the 2-byte length variables. 		 */
name|length
operator|=
literal|65535
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bailout
goto|;
break|break;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|length
operator|!=
literal|0
condition|)
block|{
name|databuf
operator|=
name|malloc
argument_list|(
name|length
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
block|}
else|else
name|databuf
operator|=
name|NULL
expr_stmt|;
name|scsi_read_dvd_structure
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/* retries */
literal|1
argument_list|,
comment|/* cbfcnp */
name|cddone
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* lba */
name|address
argument_list|,
comment|/* layer_number */
name|dvdstruct
operator|->
name|layer_num
argument_list|,
comment|/* key_format */
name|dvdstruct
operator|->
name|format
argument_list|,
comment|/* agid */
name|dvdstruct
operator|->
name|agid
argument_list|,
comment|/* data_ptr */
name|databuf
argument_list|,
comment|/* dxfer_len */
name|length
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
literal|50000
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdrunccb
argument_list|(
name|ccb
argument_list|,
name|cderror
argument_list|,
comment|/*cam_flags*/
literal|0
argument_list|,
comment|/*sense_flags*/
name|SF_RETRY_UA
operator||
name|SF_RETRY_SELTO
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|bailout
goto|;
switch|switch
condition|(
name|dvdstruct
operator|->
name|format
condition|)
block|{
case|case
name|DVD_STRUCT_PHYSICAL
case|:
block|{
name|struct
name|scsi_read_dvd_struct_data_layer_desc
modifier|*
name|inlayer
decl_stmt|;
name|struct
name|dvd_layer
modifier|*
name|outlayer
decl_stmt|;
name|struct
name|scsi_read_dvd_struct_data_physical
modifier|*
name|phys_data
decl_stmt|;
name|phys_data
operator|=
operator|(
expr|struct
name|scsi_read_dvd_struct_data_physical
operator|*
operator|)
name|databuf
expr_stmt|;
name|inlayer
operator|=
operator|&
name|phys_data
operator|->
name|layer_desc
expr_stmt|;
name|outlayer
operator|=
operator|(
expr|struct
name|dvd_layer
operator|*
operator|)
operator|&
name|dvdstruct
operator|->
name|data
expr_stmt|;
name|dvdstruct
operator|->
name|length
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|inlayer
argument_list|)
expr_stmt|;
name|outlayer
operator|->
name|book_type
operator|=
operator|(
name|inlayer
operator|->
name|book_type_version
operator|&
name|RDSD_BOOK_TYPE_MASK
operator|)
operator|>>
name|RDSD_BOOK_TYPE_SHIFT
expr_stmt|;
name|outlayer
operator|->
name|book_version
operator|=
operator|(
name|inlayer
operator|->
name|book_type_version
operator|&
name|RDSD_BOOK_VERSION_MASK
operator|)
expr_stmt|;
name|outlayer
operator|->
name|disc_size
operator|=
operator|(
name|inlayer
operator|->
name|disc_size_max_rate
operator|&
name|RDSD_DISC_SIZE_MASK
operator|)
operator|>>
name|RDSD_DISC_SIZE_SHIFT
expr_stmt|;
name|outlayer
operator|->
name|max_rate
operator|=
operator|(
name|inlayer
operator|->
name|disc_size_max_rate
operator|&
name|RDSD_MAX_RATE_MASK
operator|)
expr_stmt|;
name|outlayer
operator|->
name|nlayers
operator|=
operator|(
name|inlayer
operator|->
name|layer_info
operator|&
name|RDSD_NUM_LAYERS_MASK
operator|)
operator|>>
name|RDSD_NUM_LAYERS_SHIFT
expr_stmt|;
name|outlayer
operator|->
name|track_path
operator|=
operator|(
name|inlayer
operator|->
name|layer_info
operator|&
name|RDSD_TRACK_PATH_MASK
operator|)
operator|>>
name|RDSD_TRACK_PATH_SHIFT
expr_stmt|;
name|outlayer
operator|->
name|layer_type
operator|=
operator|(
name|inlayer
operator|->
name|layer_info
operator|&
name|RDSD_LAYER_TYPE_MASK
operator|)
expr_stmt|;
name|outlayer
operator|->
name|linear_density
operator|=
operator|(
name|inlayer
operator|->
name|density
operator|&
name|RDSD_LIN_DENSITY_MASK
operator|)
operator|>>
name|RDSD_LIN_DENSITY_SHIFT
expr_stmt|;
name|outlayer
operator|->
name|track_density
operator|=
operator|(
name|inlayer
operator|->
name|density
operator|&
name|RDSD_TRACK_DENSITY_MASK
operator|)
expr_stmt|;
name|outlayer
operator|->
name|bca
operator|=
operator|(
name|inlayer
operator|->
name|bca
operator|&
name|RDSD_BCA_MASK
operator|)
operator|>>
name|RDSD_BCA_SHIFT
expr_stmt|;
name|outlayer
operator|->
name|start_sector
operator|=
name|scsi_3btoul
argument_list|(
name|inlayer
operator|->
name|main_data_start
argument_list|)
expr_stmt|;
name|outlayer
operator|->
name|end_sector
operator|=
name|scsi_3btoul
argument_list|(
name|inlayer
operator|->
name|main_data_end
argument_list|)
expr_stmt|;
name|outlayer
operator|->
name|end_sector_l0
operator|=
name|scsi_3btoul
argument_list|(
name|inlayer
operator|->
name|end_sector_layer0
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DVD_STRUCT_COPYRIGHT
case|:
block|{
name|struct
name|scsi_read_dvd_struct_data_copyright
modifier|*
name|copy_data
decl_stmt|;
name|copy_data
operator|=
operator|(
expr|struct
name|scsi_read_dvd_struct_data_copyright
operator|*
operator|)
name|databuf
expr_stmt|;
name|dvdstruct
operator|->
name|cpst
operator|=
name|copy_data
operator|->
name|cps_type
expr_stmt|;
name|dvdstruct
operator|->
name|rmi
operator|=
name|copy_data
operator|->
name|region_info
expr_stmt|;
name|dvdstruct
operator|->
name|length
operator|=
literal|0
expr_stmt|;
break|break;
block|}
default|default:
comment|/* 		 * Tell the user what the overall length is, no matter 		 * what we can actually fit in the data buffer. 		 */
name|dvdstruct
operator|->
name|length
operator|=
name|length
operator|-
name|ccb
operator|->
name|csio
operator|.
name|resid
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_dvd_struct_data_header
argument_list|)
expr_stmt|;
comment|/* 		 * But only actually copy out the smaller of what we read 		 * in or what the structure can take. 		 */
name|bcopy
argument_list|(
name|databuf
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_dvd_struct_data_header
argument_list|)
argument_list|,
name|dvdstruct
operator|->
name|data
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|dvdstruct
operator|->
name|data
argument_list|)
argument_list|,
name|dvdstruct
operator|->
name|length
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|bailout
label|:
if|if
condition|(
name|databuf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|databuf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|scsi_report_key
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|u_int32_t
name|lba
parameter_list|,
name|u_int8_t
name|agid
parameter_list|,
name|u_int8_t
name|key_format
parameter_list|,
name|u_int8_t
modifier|*
name|data_ptr
parameter_list|,
name|u_int32_t
name|dxfer_len
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_report_key
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_report_key
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|REPORT_KEY
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|lba
argument_list|,
name|scsi_cmd
operator|->
name|lba
argument_list|)
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|dxfer_len
argument_list|,
name|scsi_cmd
operator|->
name|alloc_len
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|agid_keyformat
operator|=
operator|(
name|agid
operator|<<
name|RK_KF_AGID_SHIFT
operator|)
operator||
operator|(
name|key_format
operator|&
name|RK_KF_KEYFORMAT_MASK
operator|)
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
operator|(
name|dxfer_len
operator|==
literal|0
operator|)
condition|?
name|CAM_DIR_NONE
else|:
name|CAM_DIR_IN
argument_list|,
name|tag_action
argument_list|,
comment|/*data_ptr*/
name|data_ptr
argument_list|,
comment|/*dxfer_len*/
name|dxfer_len
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_send_key
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|u_int8_t
name|agid
parameter_list|,
name|u_int8_t
name|key_format
parameter_list|,
name|u_int8_t
modifier|*
name|data_ptr
parameter_list|,
name|u_int32_t
name|dxfer_len
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_send_key
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_send_key
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|SEND_KEY
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|dxfer_len
argument_list|,
name|scsi_cmd
operator|->
name|param_len
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|agid_keyformat
operator|=
operator|(
name|agid
operator|<<
name|RK_KF_AGID_SHIFT
operator|)
operator||
operator|(
name|key_format
operator|&
name|RK_KF_KEYFORMAT_MASK
operator|)
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|CAM_DIR_OUT
argument_list|,
name|tag_action
argument_list|,
comment|/*data_ptr*/
name|data_ptr
argument_list|,
comment|/*dxfer_len*/
name|dxfer_len
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_read_dvd_structure
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|u_int32_t
name|address
parameter_list|,
name|u_int8_t
name|layer_number
parameter_list|,
name|u_int8_t
name|format
parameter_list|,
name|u_int8_t
name|agid
parameter_list|,
name|u_int8_t
modifier|*
name|data_ptr
parameter_list|,
name|u_int32_t
name|dxfer_len
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_read_dvd_structure
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_read_dvd_structure
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|READ_DVD_STRUCTURE
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|address
argument_list|,
name|scsi_cmd
operator|->
name|address
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|layer_number
operator|=
name|layer_number
expr_stmt|;
name|scsi_cmd
operator|->
name|format
operator|=
name|format
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|dxfer_len
argument_list|,
name|scsi_cmd
operator|->
name|alloc_len
argument_list|)
expr_stmt|;
comment|/* The AGID is the top two bits of this byte */
name|scsi_cmd
operator|->
name|agid
operator|=
name|agid
operator|<<
literal|6
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|CAM_DIR_IN
argument_list|,
name|tag_action
argument_list|,
comment|/*data_ptr*/
name|data_ptr
argument_list|,
comment|/*dxfer_len*/
name|dxfer_len
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

