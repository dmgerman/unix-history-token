begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1997 Justin T. Gibbs.  * Copyright (c) 1997, 1998, 1999, 2000, 2001, 2002, 2003 Kenneth D. Merry.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*-  * Portions of this driver taken from the original FreeBSD cd driver.  * Written by Julian Elischer (julian@tfs.com)  * for TRW Financial Systems for use under the MACH(2.5) operating system.  *  * TRW Financial Systems, in accordance with their agreement with Carnegie  * Mellon University, makes this software available to CMU to distribute  * or use in any manner that they see fit as long as this message is kept with  * the software. For this reason TFS also grants any other persons or  * organisations permission to use or modify this software.  *  * TFS supplies this software to be publicly redistributed  * on the understanding that TFS is not responsible for the correct  * functioning of this software in any circumstances.  *  * Ported to run under 386BSD by Julian Elischer (julian@tfs.com) Sept 1992  *  *      from: cd.c,v 1.83 1997/05/04 15:24:22 joerg Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_cd.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/disk.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/cdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/cdrio.h>
end_include

begin_include
include|#
directive|include
file|<sys/dvdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/devicestat.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom_disk.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_queue.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_da.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_cd.h>
end_include

begin_define
define|#
directive|define
name|LEADOUT
value|0xaa
end_define

begin_comment
comment|/* leadout toc entry */
end_comment

begin_struct
struct|struct
name|cd_params
block|{
name|u_int32_t
name|blksize
decl_stmt|;
name|u_long
name|disksize
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
enum|enum
block|{
name|CD_Q_NONE
init|=
literal|0x00
block|,
name|CD_Q_NO_TOUCH
init|=
literal|0x01
block|,
name|CD_Q_BCD_TRACKS
init|=
literal|0x02
block|,
name|CD_Q_NO_CHANGER
init|=
literal|0x04
block|,
name|CD_Q_CHANGER
init|=
literal|0x08
block|,
name|CD_Q_10_BYTE_ONLY
init|=
literal|0x10
block|}
name|cd_quirks
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|CD_FLAG_INVALID
init|=
literal|0x0001
block|,
name|CD_FLAG_NEW_DISC
init|=
literal|0x0002
block|,
name|CD_FLAG_DISC_LOCKED
init|=
literal|0x0004
block|,
name|CD_FLAG_DISC_REMOVABLE
init|=
literal|0x0008
block|,
name|CD_FLAG_TAGGED_QUEUING
init|=
literal|0x0010
block|,
name|CD_FLAG_CHANGER
init|=
literal|0x0040
block|,
name|CD_FLAG_ACTIVE
init|=
literal|0x0080
block|,
name|CD_FLAG_SCHED_ON_COMP
init|=
literal|0x0100
block|,
name|CD_FLAG_RETRY_UA
init|=
literal|0x0200
block|,
name|CD_FLAG_VALID_MEDIA
init|=
literal|0x0400
block|,
name|CD_FLAG_VALID_TOC
init|=
literal|0x0800
block|,
name|CD_FLAG_SCTX_INIT
init|=
literal|0x1000
block|,
name|CD_FLAG_OPEN
init|=
literal|0x2000
block|}
name|cd_flags
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|CD_CCB_PROBE
init|=
literal|0x01
block|,
name|CD_CCB_BUFFER_IO
init|=
literal|0x02
block|,
name|CD_CCB_WAITING
init|=
literal|0x03
block|,
name|CD_CCB_TYPE_MASK
init|=
literal|0x0F
block|,
name|CD_CCB_RETRY_UA
init|=
literal|0x10
block|}
name|cd_ccb_state
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|CHANGER_TIMEOUT_SCHED
init|=
literal|0x01
block|,
name|CHANGER_SHORT_TMOUT_SCHED
init|=
literal|0x02
block|,
name|CHANGER_MANUAL_CALL
init|=
literal|0x04
block|,
name|CHANGER_NEED_TIMEOUT
init|=
literal|0x08
block|}
name|cd_changer_flags
typedef|;
end_typedef

begin_define
define|#
directive|define
name|ccb_state
value|ppriv_field0
end_define

begin_define
define|#
directive|define
name|ccb_bp
value|ppriv_ptr1
end_define

begin_struct
struct|struct
name|cd_tocdata
block|{
name|struct
name|ioc_toc_header
name|header
decl_stmt|;
name|struct
name|cd_toc_entry
name|entries
index|[
literal|100
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|cd_toc_single
block|{
name|struct
name|ioc_toc_header
name|header
decl_stmt|;
name|struct
name|cd_toc_entry
name|entry
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
enum|enum
block|{
name|CD_STATE_PROBE
block|,
name|CD_STATE_NORMAL
block|}
name|cd_state
typedef|;
end_typedef

begin_struct
struct|struct
name|cd_softc
block|{
name|cam_pinfo
name|pinfo
decl_stmt|;
name|cd_state
name|state
decl_stmt|;
specifier|volatile
name|cd_flags
name|flags
decl_stmt|;
name|struct
name|bio_queue_head
name|bio_queue
decl_stmt|;
name|LIST_HEAD
argument_list|(
argument_list|,
argument|ccb_hdr
argument_list|)
name|pending_ccbs
expr_stmt|;
name|struct
name|cd_params
name|params
decl_stmt|;
name|union
name|ccb
name|saved_ccb
decl_stmt|;
name|cd_quirks
name|quirks
decl_stmt|;
name|STAILQ_ENTRY
argument_list|(
argument|cd_softc
argument_list|)
name|changer_links
expr_stmt|;
name|struct
name|cdchanger
modifier|*
name|changer
decl_stmt|;
name|int
name|bufs_left
decl_stmt|;
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|int
name|minimum_command_size
decl_stmt|;
name|int
name|outstanding_cmds
decl_stmt|;
name|struct
name|task
name|sysctl_task
decl_stmt|;
name|struct
name|sysctl_ctx_list
name|sysctl_ctx
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|sysctl_tree
decl_stmt|;
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|cd_mode_params
argument_list|)
name|mode_queue
expr_stmt|;
name|struct
name|cd_tocdata
name|toc
decl_stmt|;
name|struct
name|disk
modifier|*
name|disk
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|cd_page_sizes
block|{
name|int
name|page
decl_stmt|;
name|int
name|page_size
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|cd_page_sizes
name|cd_page_size_table
index|[]
init|=
block|{
block|{
name|AUDIO_PAGE
block|,
expr|sizeof
operator|(
expr|struct
name|cd_audio_page
operator|)
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|cd_quirk_entry
block|{
name|struct
name|scsi_inquiry_pattern
name|inq_pat
decl_stmt|;
name|cd_quirks
name|quirks
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * The changer quirk entries aren't strictly necessary.  Basically, what  * they do is tell cdregister() up front that a device is a changer.  * Otherwise, it will figure that fact out once it sees a LUN on the device  * that is greater than 0.  If it is known up front that a device is a changer,  * all I/O to the device will go through the changer scheduling routines, as  * opposed to the "normal" CD code.  *  * NOTE ON 10_BYTE_ONLY quirks:  Any 10_BYTE_ONLY quirks MUST be because  * your device hangs when it gets a 10 byte command.  Adding a quirk just  * to get rid of the informative diagnostic message is not acceptable.  All  * 10_BYTE_ONLY quirks must be documented in full in a PR (which should be  * referenced in a comment along with the quirk) , and must be approved by  * ken@FreeBSD.org.  Any quirks added that don't adhere to this policy may  * be removed until the submitter can explain why they are needed.  * 10_BYTE_ONLY quirks will be removed (as they will no longer be necessary)  * when the CAM_NEW_TRAN_CODE work is done.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cd_quirk_entry
name|cd_quirk_table
index|[]
init|=
block|{
block|{
block|{
name|T_CDROM
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"NRC"
block|,
literal|"MBR-7"
block|,
literal|"*"
block|}
block|,
comment|/*quirks*/
name|CD_Q_CHANGER
block|}
block|,
block|{
block|{
name|T_CDROM
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"PIONEER"
block|,
literal|"CD-ROM DRM*"
block|,
literal|"*"
block|}
block|,
comment|/* quirks */
name|CD_Q_CHANGER
block|}
block|,
block|{
block|{
name|T_CDROM
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"NAKAMICH"
block|,
literal|"MJ-*"
block|,
literal|"*"
block|}
block|,
comment|/* quirks */
name|CD_Q_CHANGER
block|}
block|,
block|{
block|{
name|T_CDROM
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"CHINON"
block|,
literal|"CD-ROM CDS-535"
block|,
literal|"*"
block|}
block|,
comment|/* quirks */
name|CD_Q_BCD_TRACKS
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|disk_open_t
name|cdopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|disk_close_t
name|cdclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|disk_ioctl_t
name|cdioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|disk_strategy_t
name|cdstrategy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_init_t
name|cdinit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_ctor_t
name|cdregister
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_dtor_t
name|cdcleanup
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_start_t
name|cdstart
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_oninv_t
name|cdoninvalidate
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|cdasync
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|u_int32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cdcmdsizesysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cdshorttimeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cdschedule
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|priority
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cdrunchangerqueue
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cdchangerschedule
parameter_list|(
name|struct
name|cd_softc
modifier|*
name|softc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cdrunccb
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|int
function_decl|(
modifier|*
name|error_routine
function_decl|)
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|u_int32_t
name|cam_flags
parameter_list|,
name|u_int32_t
name|sense_flags
parameter_list|)
parameter_list|,
name|u_int32_t
name|cam_flags
parameter_list|,
name|u_int32_t
name|sense_flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|union
name|ccb
modifier|*
name|cdgetccb
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|u_int32_t
name|priority
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cddone
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|start_ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|union
name|cd_pages
modifier|*
name|cdgetpage
parameter_list|(
name|struct
name|cd_mode_params
modifier|*
name|mode_params
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cdgetpagesize
parameter_list|(
name|int
name|page_num
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cdprevent
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|action
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cdcheckmedia
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cdsize
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|u_int32_t
modifier|*
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cd6byteworkaround
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cderror
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|u_int32_t
name|cam_flags
parameter_list|,
name|u_int32_t
name|sense_flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cdreadtoc
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|u_int32_t
name|mode
parameter_list|,
name|u_int32_t
name|start
parameter_list|,
name|u_int8_t
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|len
parameter_list|,
name|u_int32_t
name|sense_flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cdgetmode
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|cd_mode_params
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|page
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cdsetmode
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|cd_mode_params
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cdplay
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|u_int32_t
name|blk
parameter_list|,
name|u_int32_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cdreadsubchannel
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|u_int32_t
name|mode
parameter_list|,
name|u_int32_t
name|format
parameter_list|,
name|int
name|track
parameter_list|,
name|struct
name|cd_sub_channel_info
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cdplaymsf
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|u_int32_t
name|startm
parameter_list|,
name|u_int32_t
name|starts
parameter_list|,
name|u_int32_t
name|startf
parameter_list|,
name|u_int32_t
name|endm
parameter_list|,
name|u_int32_t
name|ends
parameter_list|,
name|u_int32_t
name|endf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cdplaytracks
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|u_int32_t
name|strack
parameter_list|,
name|u_int32_t
name|sindex
parameter_list|,
name|u_int32_t
name|etrack
parameter_list|,
name|u_int32_t
name|eindex
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cdpause
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|u_int32_t
name|go
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cdstopunit
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|u_int32_t
name|eject
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cdstartunit
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|load
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cdsetspeed
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|u_int32_t
name|rdspeed
parameter_list|,
name|u_int32_t
name|wrspeed
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cdreportkey
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|dvd_authinfo
modifier|*
name|authinfo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cdsendkey
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|dvd_authinfo
modifier|*
name|authinfo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cdreaddvdstructure
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|dvd_struct
modifier|*
name|dvdstruct
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|periph_driver
name|cddriver
init|=
block|{
name|cdinit
block|,
literal|"cd"
block|,
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|cddriver
operator|.
name|units
argument_list|)
block|,
comment|/* generation */
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|PERIPHDRIVER_DECLARE
argument_list|(
name|cd
argument_list|,
name|cddriver
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|CHANGER_MIN_BUSY_SECONDS
end_ifndef

begin_define
define|#
directive|define
name|CHANGER_MIN_BUSY_SECONDS
value|5
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CHANGER_MAX_BUSY_SECONDS
end_ifndef

begin_define
define|#
directive|define
name|CHANGER_MAX_BUSY_SECONDS
value|15
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|changer_min_busy_seconds
init|=
name|CHANGER_MIN_BUSY_SECONDS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|changer_max_busy_seconds
init|=
name|CHANGER_MAX_BUSY_SECONDS
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_kern_cam
argument_list|,
name|OID_AUTO
argument_list|,
name|cd
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"CAM CDROM driver"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_kern_cam_cd
argument_list|,
name|OID_AUTO
argument_list|,
name|changer
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"CD Changer"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_cam_cd_changer
argument_list|,
name|OID_AUTO
argument_list|,
name|min_busy_seconds
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|changer_min_busy_seconds
argument_list|,
literal|0
argument_list|,
literal|"Minimum changer scheduling quantum"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"kern.cam.cd.changer.min_busy_seconds"
argument_list|,
operator|&
name|changer_min_busy_seconds
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_cam_cd_changer
argument_list|,
name|OID_AUTO
argument_list|,
name|max_busy_seconds
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|changer_max_busy_seconds
argument_list|,
literal|0
argument_list|,
literal|"Maximum changer scheduling quantum"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"kern.cam.cd.changer.max_busy_seconds"
argument_list|,
operator|&
name|changer_max_busy_seconds
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|cdchanger
block|{
name|path_id_t
name|path_id
decl_stmt|;
name|target_id_t
name|target_id
decl_stmt|;
name|int
name|num_devices
decl_stmt|;
name|struct
name|camq
name|devq
decl_stmt|;
name|struct
name|timeval
name|start_time
decl_stmt|;
name|struct
name|cd_softc
modifier|*
name|cur_device
decl_stmt|;
name|struct
name|callout
name|short_handle
decl_stmt|;
name|struct
name|callout
name|long_handle
decl_stmt|;
specifier|volatile
name|cd_changer_flags
name|flags
decl_stmt|;
name|STAILQ_ENTRY
argument_list|(
argument|cdchanger
argument_list|)
name|changer_links
expr_stmt|;
name|STAILQ_HEAD
argument_list|(
argument|chdevlist
argument_list|,
argument|cd_softc
argument_list|)
name|chluns
expr_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|changerq_mtx
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|STAILQ_HEAD
argument_list|(
argument|changerlist
argument_list|,
argument|cdchanger
argument_list|)
name|changerq
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|num_changers
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|cdinit
parameter_list|(
name|void
parameter_list|)
block|{
name|cam_status
name|status
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|mtx_init
argument_list|(
operator|&
name|changerq_mtx
argument_list|,
literal|"cdchangerq"
argument_list|,
literal|"SCSI CD Changer List"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|changerq
argument_list|)
expr_stmt|;
comment|/* 	 * Install a global async callback.  This callback will 	 * receive async callbacks like "new device found". 	 */
name|status
operator|=
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|CAM_XPT_PATH_ID
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|CAM_REQ_CMP
condition|)
block|{
name|struct
name|ccb_setasync
name|csa
decl_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|csa
operator|.
name|ccb_h
argument_list|,
name|path
argument_list|,
comment|/*priority*/
literal|5
argument_list|)
expr_stmt|;
name|csa
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SASYNC_CB
expr_stmt|;
name|csa
operator|.
name|event_enable
operator|=
name|AC_FOUND_DEVICE
expr_stmt|;
name|csa
operator|.
name|callback
operator|=
name|cdasync
expr_stmt|;
name|csa
operator|.
name|callback_arg
operator|=
name|NULL
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|csa
argument_list|)
expr_stmt|;
name|status
operator|=
name|csa
operator|.
name|ccb_h
operator|.
name|status
expr_stmt|;
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"cd: Failed to attach master async callback "
literal|"due to status 0x%x!\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cdoninvalidate
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|struct
name|cd_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ccb_setasync
name|csa
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|cd_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
comment|/* 	 * De-register any async callbacks. 	 */
name|xpt_setup_ccb
argument_list|(
operator|&
name|csa
operator|.
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
comment|/* priority */
literal|5
argument_list|)
expr_stmt|;
name|csa
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SASYNC_CB
expr_stmt|;
name|csa
operator|.
name|event_enable
operator|=
literal|0
expr_stmt|;
name|csa
operator|.
name|callback
operator|=
name|cdasync
expr_stmt|;
name|csa
operator|.
name|callback_arg
operator|=
name|periph
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|csa
argument_list|)
expr_stmt|;
name|softc
operator|->
name|flags
operator||=
name|CD_FLAG_INVALID
expr_stmt|;
comment|/* 	 * Return all queued I/O with ENXIO. 	 * XXX Handle any transactions queued to the card 	 *     with XPT_ABORT_CCB. 	 */
name|bioq_flush
argument_list|(
operator|&
name|softc
operator|->
name|bio_queue
argument_list|,
name|NULL
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
comment|/* 	 * If this device is part of a changer, and it was scheduled 	 * to run, remove it from the run queue since we just nuked 	 * all of its scheduled I/O. 	 */
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|CD_FLAG_CHANGER
operator|)
operator|&&
operator|(
name|softc
operator|->
name|pinfo
operator|.
name|index
operator|!=
name|CAM_UNQUEUED_INDEX
operator|)
condition|)
name|camq_remove
argument_list|(
operator|&
name|softc
operator|->
name|changer
operator|->
name|devq
argument_list|,
name|softc
operator|->
name|pinfo
operator|.
name|index
argument_list|)
expr_stmt|;
name|disk_gone
argument_list|(
name|softc
operator|->
name|disk
argument_list|)
expr_stmt|;
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"lost device\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cdcleanup
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|struct
name|cd_softc
modifier|*
name|softc
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|cd_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"removing device entry\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|CD_FLAG_SCTX_INIT
operator|)
operator|!=
literal|0
operator|&&
name|sysctl_ctx_free
argument_list|(
operator|&
name|softc
operator|->
name|sysctl_ctx
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"can't remove sysctl context\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * In the queued, non-active case, the device in question 	 * has already been removed from the changer run queue.  Since this 	 * device is active, we need to de-activate it, and schedule 	 * another device to run.  (if there is another one to run) 	 */
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|CD_FLAG_CHANGER
operator|)
operator|&&
operator|(
name|softc
operator|->
name|flags
operator|&
name|CD_FLAG_ACTIVE
operator|)
condition|)
block|{
comment|/* 		 * The purpose of the short timeout is soley to determine 		 * whether the current device has finished or not.  Well, 		 * since we're removing the active device, we know that it 		 * is finished.  So, get rid of the short timeout. 		 * Otherwise, if we're in the time period before the short 		 * timeout fires, and there are no other devices in the 		 * queue to run, there won't be any other device put in the 		 * active slot.  i.e., when we call cdrunchangerqueue() 		 * below, it won't do anything.  Then, when the short 		 * timeout fires, it'll look at the "current device", which 		 * we are free below, and possibly panic the kernel on a 		 * bogus pointer reference. 		 * 		 * The long timeout doesn't really matter, since we 		 * decrement the qfrozen_cnt to indicate that there is 		 * nothing in the active slot now.  Therefore, there won't 		 * be any bogus pointer references there. 		 */
if|if
condition|(
name|softc
operator|->
name|changer
operator|->
name|flags
operator|&
name|CHANGER_SHORT_TMOUT_SCHED
condition|)
block|{
name|callout_stop
argument_list|(
operator|&
name|softc
operator|->
name|changer
operator|->
name|short_handle
argument_list|)
expr_stmt|;
name|softc
operator|->
name|changer
operator|->
name|flags
operator|&=
operator|~
name|CHANGER_SHORT_TMOUT_SCHED
expr_stmt|;
block|}
name|softc
operator|->
name|changer
operator|->
name|devq
operator|.
name|qfrozen_cnt
operator|--
expr_stmt|;
name|softc
operator|->
name|changer
operator|->
name|flags
operator||=
name|CHANGER_MANUAL_CALL
expr_stmt|;
name|cdrunchangerqueue
argument_list|(
name|softc
operator|->
name|changer
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we're removing the last device on the changer, go ahead and 	 * remove the changer device structure. 	 */
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|CD_FLAG_CHANGER
operator|)
operator|&&
operator|(
operator|--
name|softc
operator|->
name|changer
operator|->
name|num_devices
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * Theoretically, there shouldn't be any timeouts left, but 		 * I'm not completely sure that that will be the case.  So, 		 * it won't hurt to check and see if there are any left. 		 */
if|if
condition|(
name|softc
operator|->
name|changer
operator|->
name|flags
operator|&
name|CHANGER_TIMEOUT_SCHED
condition|)
block|{
name|callout_stop
argument_list|(
operator|&
name|softc
operator|->
name|changer
operator|->
name|long_handle
argument_list|)
expr_stmt|;
name|softc
operator|->
name|changer
operator|->
name|flags
operator|&=
operator|~
name|CHANGER_TIMEOUT_SCHED
expr_stmt|;
block|}
if|if
condition|(
name|softc
operator|->
name|changer
operator|->
name|flags
operator|&
name|CHANGER_SHORT_TMOUT_SCHED
condition|)
block|{
name|callout_stop
argument_list|(
operator|&
name|softc
operator|->
name|changer
operator|->
name|short_handle
argument_list|)
expr_stmt|;
name|softc
operator|->
name|changer
operator|->
name|flags
operator|&=
operator|~
name|CHANGER_SHORT_TMOUT_SCHED
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|changerq_mtx
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE
argument_list|(
operator|&
name|changerq
argument_list|,
name|softc
operator|->
name|changer
argument_list|,
name|cdchanger
argument_list|,
name|changer_links
argument_list|)
expr_stmt|;
name|num_changers
operator|--
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|changerq_mtx
argument_list|)
expr_stmt|;
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"removing changer entry\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|softc
operator|->
name|changer
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|disk_destroy
argument_list|(
name|softc
operator|->
name|disk
argument_list|)
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|softc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cdasync
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|u_int32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|periph
operator|=
operator|(
expr|struct
name|cam_periph
operator|*
operator|)
name|callback_arg
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|AC_FOUND_DEVICE
case|:
block|{
name|struct
name|ccb_getdev
modifier|*
name|cgd
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|cgd
operator|=
operator|(
expr|struct
name|ccb_getdev
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|cgd
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|SID_TYPE
argument_list|(
operator|&
name|cgd
operator|->
name|inq_data
argument_list|)
operator|!=
name|T_CDROM
operator|&&
name|SID_TYPE
argument_list|(
operator|&
name|cgd
operator|->
name|inq_data
argument_list|)
operator|!=
name|T_WORM
condition|)
break|break;
comment|/* 		 * Allocate a peripheral instance for 		 * this device and start the probe 		 * process. 		 */
name|status
operator|=
name|cam_periph_alloc
argument_list|(
name|cdregister
argument_list|,
name|cdoninvalidate
argument_list|,
name|cdcleanup
argument_list|,
name|cdstart
argument_list|,
literal|"cd"
argument_list|,
name|CAM_PERIPH_BIO
argument_list|,
name|cgd
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|cdasync
argument_list|,
name|AC_FOUND_DEVICE
argument_list|,
name|cgd
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
operator|&&
name|status
operator|!=
name|CAM_REQ_INPROG
condition|)
name|printf
argument_list|(
literal|"cdasync: Unable to attach new device "
literal|"due to status 0x%x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|AC_SENT_BDR
case|:
case|case
name|AC_BUS_RESET
case|:
block|{
name|struct
name|cd_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccbh
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|cd_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
comment|/* 		 * Don't fail on the expected unit attention 		 * that will occur. 		 */
name|softc
operator|->
name|flags
operator||=
name|CD_FLAG_RETRY_UA
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|ccbh
argument_list|,
argument|&softc->pending_ccbs
argument_list|,
argument|periph_links.le
argument_list|)
name|ccbh
operator|->
name|ccb_state
operator||=
name|CD_CCB_RETRY_UA
expr_stmt|;
comment|/* FALLTHROUGH */
block|}
default|default:
name|cam_periph_async
argument_list|(
name|periph
argument_list|,
name|code
argument_list|,
name|path
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cdsysctlinit
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|cd_softc
modifier|*
name|softc
decl_stmt|;
name|char
name|tmpstr
index|[
literal|80
index|]
decl_stmt|,
name|tmpstr2
index|[
literal|80
index|]
decl_stmt|;
name|periph
operator|=
operator|(
expr|struct
name|cam_periph
operator|*
operator|)
name|context
expr_stmt|;
if|if
condition|(
name|cam_periph_acquire
argument_list|(
name|periph
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
return|return;
name|softc
operator|=
operator|(
expr|struct
name|cd_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|snprintf
argument_list|(
name|tmpstr
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
literal|"CAM CD unit %d"
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|tmpstr2
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr2
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|sysctl_ctx_init
argument_list|(
operator|&
name|softc
operator|->
name|sysctl_ctx
argument_list|)
expr_stmt|;
name|softc
operator|->
name|flags
operator||=
name|CD_FLAG_SCTX_INIT
expr_stmt|;
name|softc
operator|->
name|sysctl_tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
operator|&
name|softc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_STATIC_CHILDREN
argument_list|(
name|_kern_cam_cd
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|tmpstr2
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
name|tmpstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|sysctl_tree
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"cdsysctlinit: unable to allocate sysctl tree\n"
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|cam_periph_release
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Now register the sysctl handler, so the user can the value on 	 * the fly. 	 */
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|softc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|softc
operator|->
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"minimum_cmd_size"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|softc
operator|->
name|minimum_command_size
argument_list|,
literal|0
argument_list|,
name|cdcmdsizesysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Minimum CDB size"
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|cam_periph_release
argument_list|(
name|periph
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * We have a handler function for this so we can check the values when the  * user sets them, instead of every time we look at them.  */
end_comment

begin_function
specifier|static
name|int
name|cdcmdsizesysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|value
decl_stmt|;
name|value
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg1
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|value
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|!=
literal|0
operator|)
operator|||
operator|(
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * The only real values we can have here are 6 or 10.  I don't 	 * really forsee having 12 be an option at any time in the future. 	 * So if the user sets something less than or equal to 6, we'll set 	 * it to 6.  If he sets something greater than 6, we'll set it to 10. 	 * 	 * I suppose we could just return an error here for the wrong values, 	 * but I don't think it's necessary to do so, as long as we can 	 * determine the user's intent without too much trouble. 	 */
if|if
condition|(
name|value
operator|<
literal|6
condition|)
name|value
operator|=
literal|6
expr_stmt|;
elseif|else
if|if
condition|(
name|value
operator|>
literal|6
condition|)
name|value
operator|=
literal|10
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|arg1
operator|=
name|value
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|cam_status
name|cdregister
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cd_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ccb_setasync
name|csa
decl_stmt|;
name|struct
name|ccb_pathinq
name|cpi
decl_stmt|;
name|struct
name|ccb_getdev
modifier|*
name|cgd
decl_stmt|;
name|char
name|tmpstr
index|[
literal|80
index|]
decl_stmt|;
name|caddr_t
name|match
decl_stmt|;
name|cgd
operator|=
operator|(
expr|struct
name|ccb_getdev
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"cdregister: periph was NULL!!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
if|if
condition|(
name|cgd
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"cdregister: no getdev CCB, can't register device\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
name|softc
operator|=
operator|(
expr|struct
name|cd_softc
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|softc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"cdregister: Unable to probe new device. "
literal|"Unable to allocate softc\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
name|bzero
argument_list|(
name|softc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|softc
argument_list|)
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|softc
operator|->
name|pending_ccbs
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|softc
operator|->
name|mode_queue
argument_list|)
expr_stmt|;
name|softc
operator|->
name|state
operator|=
name|CD_STATE_PROBE
expr_stmt|;
name|bioq_init
argument_list|(
operator|&
name|softc
operator|->
name|bio_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|SID_IS_REMOVABLE
argument_list|(
operator|&
name|cgd
operator|->
name|inq_data
argument_list|)
condition|)
name|softc
operator|->
name|flags
operator||=
name|CD_FLAG_DISC_REMOVABLE
expr_stmt|;
if|if
condition|(
operator|(
name|cgd
operator|->
name|inq_data
operator|.
name|flags
operator|&
name|SID_CmdQue
operator|)
operator|!=
literal|0
condition|)
name|softc
operator|->
name|flags
operator||=
name|CD_FLAG_TAGGED_QUEUING
expr_stmt|;
name|periph
operator|->
name|softc
operator|=
name|softc
expr_stmt|;
name|softc
operator|->
name|periph
operator|=
name|periph
expr_stmt|;
comment|/* 	 * See if this device has any quirks. 	 */
name|match
operator|=
name|cam_quirkmatch
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|cgd
operator|->
name|inq_data
argument_list|,
operator|(
name|caddr_t
operator|)
name|cd_quirk_table
argument_list|,
sizeof|sizeof
argument_list|(
name|cd_quirk_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|cd_quirk_table
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cd_quirk_table
argument_list|)
argument_list|,
name|scsi_inquiry_match
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
operator|!=
name|NULL
condition|)
name|softc
operator|->
name|quirks
operator|=
operator|(
operator|(
expr|struct
name|cd_quirk_entry
operator|*
operator|)
name|match
operator|)
operator|->
name|quirks
expr_stmt|;
else|else
name|softc
operator|->
name|quirks
operator|=
name|CD_Q_NONE
expr_stmt|;
comment|/* Check if the SIM does not want 6 byte commands */
name|xpt_setup_ccb
argument_list|(
operator|&
name|cpi
operator|.
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|cpi
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_PATH_INQ
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|cpi
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpi
operator|.
name|ccb_h
operator|.
name|status
operator|==
name|CAM_REQ_CMP
operator|&&
operator|(
name|cpi
operator|.
name|hba_misc
operator|&
name|PIM_NO_6_BYTE
operator|)
condition|)
name|softc
operator|->
name|quirks
operator||=
name|CD_Q_10_BYTE_ONLY
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|softc
operator|->
name|sysctl_task
argument_list|,
literal|0
argument_list|,
name|cdsysctlinit
argument_list|,
name|periph
argument_list|)
expr_stmt|;
comment|/* The default is 6 byte commands, unless quirked otherwise */
if|if
condition|(
name|softc
operator|->
name|quirks
operator|&
name|CD_Q_10_BYTE_ONLY
condition|)
name|softc
operator|->
name|minimum_command_size
operator|=
literal|10
expr_stmt|;
else|else
name|softc
operator|->
name|minimum_command_size
operator|=
literal|6
expr_stmt|;
comment|/* 	 * Load the user's default, if any. 	 */
name|snprintf
argument_list|(
name|tmpstr
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
literal|"kern.cam.cd.%d.minimum_cmd_size"
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
name|tmpstr
argument_list|,
operator|&
name|softc
operator|->
name|minimum_command_size
argument_list|)
expr_stmt|;
comment|/* 6 and 10 are the only permissible values here. */
if|if
condition|(
name|softc
operator|->
name|minimum_command_size
operator|<
literal|6
condition|)
name|softc
operator|->
name|minimum_command_size
operator|=
literal|6
expr_stmt|;
elseif|else
if|if
condition|(
name|softc
operator|->
name|minimum_command_size
operator|>
literal|6
condition|)
name|softc
operator|->
name|minimum_command_size
operator|=
literal|10
expr_stmt|;
comment|/* 	 * We need to register the statistics structure for this device, 	 * but we don't have the blocksize yet for it.  So, we register 	 * the structure and indicate that we don't have the blocksize 	 * yet.  Unlike other SCSI peripheral drivers, we explicitly set 	 * the device type here to be CDROM, rather than just ORing in 	 * the device type.  This is because this driver can attach to either 	 * CDROM or WORM devices, and we want this peripheral driver to 	 * show up in the devstat list as a CD peripheral driver, not a 	 * WORM peripheral driver.  WORM drives will also have the WORM 	 * driver attached to them. 	 */
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|softc
operator|->
name|disk
operator|=
name|disk_alloc
argument_list|()
expr_stmt|;
name|softc
operator|->
name|disk
operator|->
name|d_devstat
operator|=
name|devstat_new_entry
argument_list|(
literal|"cd"
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|,
literal|0
argument_list|,
name|DEVSTAT_BS_UNAVAILABLE
argument_list|,
name|DEVSTAT_TYPE_CDROM
operator||
name|DEVSTAT_TYPE_IF_SCSI
argument_list|,
name|DEVSTAT_PRIORITY_CD
argument_list|)
expr_stmt|;
name|softc
operator|->
name|disk
operator|->
name|d_open
operator|=
name|cdopen
expr_stmt|;
name|softc
operator|->
name|disk
operator|->
name|d_close
operator|=
name|cdclose
expr_stmt|;
name|softc
operator|->
name|disk
operator|->
name|d_strategy
operator|=
name|cdstrategy
expr_stmt|;
name|softc
operator|->
name|disk
operator|->
name|d_ioctl
operator|=
name|cdioctl
expr_stmt|;
name|softc
operator|->
name|disk
operator|->
name|d_name
operator|=
literal|"cd"
expr_stmt|;
name|softc
operator|->
name|disk
operator|->
name|d_unit
operator|=
name|periph
operator|->
name|unit_number
expr_stmt|;
name|softc
operator|->
name|disk
operator|->
name|d_drv1
operator|=
name|periph
expr_stmt|;
name|softc
operator|->
name|disk
operator|->
name|d_flags
operator|=
literal|0
expr_stmt|;
name|disk_create
argument_list|(
name|softc
operator|->
name|disk
argument_list|,
name|DISK_VERSION
argument_list|)
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
comment|/* 	 * Add an async callback so that we get 	 * notified if this device goes away. 	 */
name|xpt_setup_ccb
argument_list|(
operator|&
name|csa
operator|.
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
comment|/* priority */
literal|5
argument_list|)
expr_stmt|;
name|csa
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SASYNC_CB
expr_stmt|;
name|csa
operator|.
name|event_enable
operator|=
name|AC_SENT_BDR
operator||
name|AC_BUS_RESET
operator||
name|AC_LOST_DEVICE
expr_stmt|;
name|csa
operator|.
name|callback
operator|=
name|cdasync
expr_stmt|;
name|csa
operator|.
name|callback_arg
operator|=
name|periph
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|csa
argument_list|)
expr_stmt|;
comment|/* 	 * If the target lun is greater than 0, we most likely have a CD 	 * changer device.  Check the quirk entries as well, though, just 	 * in case someone has a CD tower with one lun per drive or 	 * something like that.  Also, if we know up front that a 	 * particular device is a changer, we can mark it as such starting 	 * with lun 0, instead of lun 1.  It shouldn't be necessary to have 	 * a quirk entry to define something as a changer, however. 	 */
if|if
condition|(
operator|(
operator|(
name|cgd
operator|->
name|ccb_h
operator|.
name|target_lun
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|(
name|softc
operator|->
name|quirks
operator|&
name|CD_Q_NO_CHANGER
operator|)
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
operator|(
name|softc
operator|->
name|quirks
operator|&
name|CD_Q_CHANGER
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|struct
name|cdchanger
modifier|*
name|nchanger
decl_stmt|;
name|struct
name|cam_periph
modifier|*
name|nperiph
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|int
name|found
decl_stmt|;
comment|/* Set the changer flag in the current device's softc */
name|softc
operator|->
name|flags
operator||=
name|CD_FLAG_CHANGER
expr_stmt|;
comment|/* 		 * Now, look around for an existing changer device with the 		 * same path and target ID as the current device. 		 */
name|mtx_lock
argument_list|(
operator|&
name|changerq_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|found
operator|=
literal|0
operator|,
name|nchanger
operator|=
operator|(
expr|struct
name|cdchanger
operator|*
operator|)
name|STAILQ_FIRST
argument_list|(
operator|&
name|changerq
argument_list|)
init|;
name|nchanger
operator|!=
name|NULL
condition|;
name|nchanger
operator|=
name|STAILQ_NEXT
argument_list|(
name|nchanger
argument_list|,
name|changer_links
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|nchanger
operator|->
name|path_id
operator|==
name|cgd
operator|->
name|ccb_h
operator|.
name|path_id
operator|)
operator|&&
operator|(
name|nchanger
operator|->
name|target_id
operator|==
name|cgd
operator|->
name|ccb_h
operator|.
name|target_id
operator|)
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|changerq_mtx
argument_list|)
expr_stmt|;
comment|/* 		 * If we found a matching entry, just add this device to 		 * the list of devices on this changer. 		 */
if|if
condition|(
name|found
operator|==
literal|1
condition|)
block|{
name|struct
name|chdevlist
modifier|*
name|chlunhead
decl_stmt|;
name|chlunhead
operator|=
operator|&
name|nchanger
operator|->
name|chluns
expr_stmt|;
comment|/* 			 * XXX KDM look at consolidating this code with the 			 * code below in a separate function. 			 */
comment|/* 			 * Create a path with lun id 0, and see if we can 			 * find a matching device 			 */
name|status
operator|=
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
comment|/*periph*/
name|periph
argument_list|,
name|cgd
operator|->
name|ccb_h
operator|.
name|path_id
argument_list|,
name|cgd
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|==
name|CAM_REQ_CMP
operator|)
operator|&&
operator|(
operator|(
name|nperiph
operator|=
name|cam_periph_find
argument_list|(
name|path
argument_list|,
literal|"cd"
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
condition|)
block|{
name|struct
name|cd_softc
modifier|*
name|nsoftc
decl_stmt|;
name|nsoftc
operator|=
operator|(
expr|struct
name|cd_softc
operator|*
operator|)
name|nperiph
operator|->
name|softc
expr_stmt|;
if|if
condition|(
operator|(
name|nsoftc
operator|->
name|flags
operator|&
name|CD_FLAG_CHANGER
operator|)
operator|==
literal|0
condition|)
block|{
name|nsoftc
operator|->
name|flags
operator||=
name|CD_FLAG_CHANGER
expr_stmt|;
name|nchanger
operator|->
name|num_devices
operator|++
expr_stmt|;
if|if
condition|(
name|camq_resize
argument_list|(
operator|&
name|nchanger
operator|->
name|devq
argument_list|,
name|nchanger
operator|->
name|num_devices
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"cdregister: "
literal|"camq_resize "
literal|"failed, changer "
literal|"support may "
literal|"be messed up\n"
argument_list|)
expr_stmt|;
block|}
name|nsoftc
operator|->
name|changer
operator|=
name|nchanger
expr_stmt|;
name|nsoftc
operator|->
name|pinfo
operator|.
name|index
operator|=
name|CAM_UNQUEUED_INDEX
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|nchanger
operator|->
name|chluns
argument_list|,
name|nsoftc
argument_list|,
name|changer_links
argument_list|)
expr_stmt|;
block|}
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|CAM_REQ_CMP
condition|)
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"cdregister: unable to allocate path\n"
literal|"cdregister: changer support may be "
literal|"broken\n"
argument_list|)
expr_stmt|;
block|}
name|nchanger
operator|->
name|num_devices
operator|++
expr_stmt|;
name|softc
operator|->
name|changer
operator|=
name|nchanger
expr_stmt|;
name|softc
operator|->
name|pinfo
operator|.
name|index
operator|=
name|CAM_UNQUEUED_INDEX
expr_stmt|;
if|if
condition|(
name|camq_resize
argument_list|(
operator|&
name|nchanger
operator|->
name|devq
argument_list|,
name|nchanger
operator|->
name|num_devices
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"cdregister: camq_resize "
literal|"failed, changer support may "
literal|"be messed up\n"
argument_list|)
expr_stmt|;
block|}
name|STAILQ_INSERT_TAIL
argument_list|(
name|chlunhead
argument_list|,
name|softc
argument_list|,
name|changer_links
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * In this case, we don't already have an entry for this 		 * particular changer, so we need to create one, add it to 		 * the queue, and queue this device on the list for this 		 * changer.  Before we queue this device, however, we need 		 * to search for lun id 0 on this target, and add it to the 		 * queue first, if it exists.  (and if it hasn't already 		 * been marked as part of the changer.) 		 */
else|else
block|{
name|nchanger
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cdchanger
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|nchanger
operator|==
name|NULL
condition|)
block|{
name|softc
operator|->
name|flags
operator|&=
operator|~
name|CD_FLAG_CHANGER
expr_stmt|;
name|printf
argument_list|(
literal|"cdregister: unable to malloc "
literal|"changer structure\ncdregister: "
literal|"changer support disabled\n"
argument_list|)
expr_stmt|;
comment|/* 				 * Yes, gotos can be gross but in this case 				 * I think it's justified.. 				 */
goto|goto
name|cdregisterexit
goto|;
block|}
comment|/* zero the structure */
name|bzero
argument_list|(
name|nchanger
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cdchanger
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|camq_init
argument_list|(
operator|&
name|nchanger
operator|->
name|devq
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|softc
operator|->
name|flags
operator|&=
operator|~
name|CD_FLAG_CHANGER
expr_stmt|;
name|printf
argument_list|(
literal|"cdregister: changer support "
literal|"disabled\n"
argument_list|)
expr_stmt|;
goto|goto
name|cdregisterexit
goto|;
block|}
name|nchanger
operator|->
name|path_id
operator|=
name|cgd
operator|->
name|ccb_h
operator|.
name|path_id
expr_stmt|;
name|nchanger
operator|->
name|target_id
operator|=
name|cgd
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
comment|/* this is superfluous, but it makes things clearer */
name|nchanger
operator|->
name|num_devices
operator|=
literal|0
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|nchanger
operator|->
name|chluns
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|nchanger
operator|->
name|long_handle
argument_list|,
name|periph
operator|->
name|sim
operator|->
name|mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|nchanger
operator|->
name|short_handle
argument_list|,
name|periph
operator|->
name|sim
operator|->
name|mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|changerq_mtx
argument_list|)
expr_stmt|;
name|num_changers
operator|++
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|changerq
argument_list|,
name|nchanger
argument_list|,
name|changer_links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|changerq_mtx
argument_list|)
expr_stmt|;
comment|/* 			 * Create a path with lun id 0, and see if we can 			 * find a matching device 			 */
name|status
operator|=
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
comment|/*periph*/
name|periph
argument_list|,
name|cgd
operator|->
name|ccb_h
operator|.
name|path_id
argument_list|,
name|cgd
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 			 * If we were able to allocate the path, and if we 			 * find a matching device and it isn't already 			 * marked as part of a changer, then we add it to 			 * the current changer. 			 */
if|if
condition|(
operator|(
name|status
operator|==
name|CAM_REQ_CMP
operator|)
operator|&&
operator|(
operator|(
name|nperiph
operator|=
name|cam_periph_find
argument_list|(
name|path
argument_list|,
literal|"cd"
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
operator|(
operator|(
expr|struct
name|cd_softc
operator|*
operator|)
name|periph
operator|->
name|softc
operator|)
operator|->
name|flags
operator|&
name|CD_FLAG_CHANGER
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|struct
name|cd_softc
modifier|*
name|nsoftc
decl_stmt|;
name|nsoftc
operator|=
operator|(
expr|struct
name|cd_softc
operator|*
operator|)
name|nperiph
operator|->
name|softc
expr_stmt|;
name|nsoftc
operator|->
name|flags
operator||=
name|CD_FLAG_CHANGER
expr_stmt|;
name|nchanger
operator|->
name|num_devices
operator|++
expr_stmt|;
if|if
condition|(
name|camq_resize
argument_list|(
operator|&
name|nchanger
operator|->
name|devq
argument_list|,
name|nchanger
operator|->
name|num_devices
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"cdregister: camq_resize "
literal|"failed, changer support may "
literal|"be messed up\n"
argument_list|)
expr_stmt|;
block|}
name|nsoftc
operator|->
name|changer
operator|=
name|nchanger
expr_stmt|;
name|nsoftc
operator|->
name|pinfo
operator|.
name|index
operator|=
name|CAM_UNQUEUED_INDEX
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|nchanger
operator|->
name|chluns
argument_list|,
name|nsoftc
argument_list|,
name|changer_links
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|CAM_REQ_CMP
condition|)
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"cdregister: unable to allocate path\n"
literal|"cdregister: changer support may be "
literal|"broken\n"
argument_list|)
expr_stmt|;
block|}
name|softc
operator|->
name|changer
operator|=
name|nchanger
expr_stmt|;
name|softc
operator|->
name|pinfo
operator|.
name|index
operator|=
name|CAM_UNQUEUED_INDEX
expr_stmt|;
name|nchanger
operator|->
name|num_devices
operator|++
expr_stmt|;
if|if
condition|(
name|camq_resize
argument_list|(
operator|&
name|nchanger
operator|->
name|devq
argument_list|,
name|nchanger
operator|->
name|num_devices
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"cdregister: camq_resize "
literal|"failed, changer support may "
literal|"be messed up\n"
argument_list|)
expr_stmt|;
block|}
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|nchanger
operator|->
name|chluns
argument_list|,
name|softc
argument_list|,
name|changer_links
argument_list|)
expr_stmt|;
block|}
block|}
name|cdregisterexit
label|:
comment|/* 	 * Refcount and block open attempts until we are setup 	 * Can't block 	 */
operator|(
name|void
operator|)
name|cam_periph_hold
argument_list|(
name|periph
argument_list|,
name|PRIBIO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|CD_FLAG_CHANGER
operator|)
operator|==
literal|0
condition|)
name|xpt_schedule
argument_list|(
name|periph
argument_list|,
comment|/*priority*/
literal|5
argument_list|)
expr_stmt|;
else|else
name|cdschedule
argument_list|(
name|periph
argument_list|,
comment|/*priority*/
literal|5
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cdopen
parameter_list|(
name|struct
name|disk
modifier|*
name|dp
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|cd_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|periph
operator|=
operator|(
expr|struct
name|cam_periph
operator|*
operator|)
name|dp
operator|->
name|d_drv1
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|softc
operator|=
operator|(
expr|struct
name|cd_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|cam_periph_acquire
argument_list|(
name|periph
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|flags
operator|&
name|CD_FLAG_INVALID
condition|)
block|{
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|cam_periph_release
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|cam_periph_hold
argument_list|(
name|periph
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|cam_periph_release
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Closes aren't symmetrical with opens, so fix up the refcounting. */
if|if
condition|(
name|softc
operator|->
name|flags
operator|&
name|CD_FLAG_OPEN
condition|)
name|cam_periph_release
argument_list|(
name|periph
argument_list|)
expr_stmt|;
else|else
name|softc
operator|->
name|flags
operator||=
name|CD_FLAG_OPEN
expr_stmt|;
comment|/* 	 * Check for media, and set the appropriate flags.  We don't bail 	 * if we don't have media, but then we don't allow anything but the 	 * CDIOCEJECT/CDIOCCLOSE ioctls if there is no media. 	 */
name|cdcheckmedia
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"leaving cdopen\n"
operator|)
argument_list|)
expr_stmt|;
name|cam_periph_unhold
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cdclose
parameter_list|(
name|struct
name|disk
modifier|*
name|dp
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|cd_softc
modifier|*
name|softc
decl_stmt|;
name|periph
operator|=
operator|(
expr|struct
name|cam_periph
operator|*
operator|)
name|dp
operator|->
name|d_drv1
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|softc
operator|=
operator|(
expr|struct
name|cd_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|cam_periph_hold
argument_list|(
name|periph
argument_list|,
name|PRIBIO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|CD_FLAG_DISC_REMOVABLE
operator|)
operator|!=
literal|0
condition|)
name|cdprevent
argument_list|(
name|periph
argument_list|,
name|PR_ALLOW
argument_list|)
expr_stmt|;
comment|/* 	 * Since we're closing this CD, mark the blocksize as unavailable. 	 * It will be marked as available when the CD is opened again. 	 */
name|softc
operator|->
name|disk
operator|->
name|d_devstat
operator|->
name|flags
operator||=
name|DEVSTAT_BS_UNAVAILABLE
expr_stmt|;
comment|/* 	 * We'll check the media and toc again at the next open(). 	 */
name|softc
operator|->
name|flags
operator|&=
operator|~
operator|(
name|CD_FLAG_VALID_MEDIA
operator||
name|CD_FLAG_VALID_TOC
operator||
name|CD_FLAG_OPEN
operator|)
expr_stmt|;
name|cam_periph_unhold
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|cam_periph_release
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cdshorttimeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cdchanger
modifier|*
name|changer
decl_stmt|;
name|changer
operator|=
operator|(
expr|struct
name|cdchanger
operator|*
operator|)
name|arg
expr_stmt|;
comment|/* Always clear the short timeout flag, since that's what we're in */
name|changer
operator|->
name|flags
operator|&=
operator|~
name|CHANGER_SHORT_TMOUT_SCHED
expr_stmt|;
comment|/* 	 * Check to see if there is any more pending or outstanding I/O for 	 * this device.  If not, move it out of the active slot. 	 */
if|if
condition|(
operator|(
name|bioq_first
argument_list|(
operator|&
name|changer
operator|->
name|cur_device
operator|->
name|bio_queue
argument_list|)
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|changer
operator|->
name|cur_device
operator|->
name|outstanding_cmds
operator|==
literal|0
operator|)
condition|)
block|{
name|changer
operator|->
name|flags
operator||=
name|CHANGER_MANUAL_CALL
expr_stmt|;
name|cdrunchangerqueue
argument_list|(
name|changer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This is a wrapper for xpt_schedule.  It only applies to changers.  */
end_comment

begin_function
specifier|static
name|void
name|cdschedule
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|priority
parameter_list|)
block|{
name|struct
name|cd_softc
modifier|*
name|softc
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|cd_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
comment|/* 	 * If this device isn't currently queued, and if it isn't 	 * the active device, then we queue this device and run the 	 * changer queue if there is no timeout scheduled to do it. 	 * If this device is the active device, just schedule it 	 * to run again.  If this device is queued, there should be 	 * a timeout in place already that will make sure it runs. 	 */
if|if
condition|(
operator|(
name|softc
operator|->
name|pinfo
operator|.
name|index
operator|==
name|CAM_UNQUEUED_INDEX
operator|)
operator|&&
operator|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|CD_FLAG_ACTIVE
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * We don't do anything with the priority here. 		 * This is strictly a fifo queue. 		 */
name|softc
operator|->
name|pinfo
operator|.
name|priority
operator|=
literal|1
expr_stmt|;
name|softc
operator|->
name|pinfo
operator|.
name|generation
operator|=
operator|++
name|softc
operator|->
name|changer
operator|->
name|devq
operator|.
name|generation
expr_stmt|;
name|camq_insert
argument_list|(
operator|&
name|softc
operator|->
name|changer
operator|->
name|devq
argument_list|,
operator|(
name|cam_pinfo
operator|*
operator|)
name|softc
argument_list|)
expr_stmt|;
comment|/* 		 * Since we just put a device in the changer queue, 		 * check and see if there is a timeout scheduled for 		 * this changer.  If so, let the timeout handle 		 * switching this device into the active slot.  If 		 * not, manually call the timeout routine to 		 * bootstrap things. 		 */
if|if
condition|(
operator|(
operator|(
name|softc
operator|->
name|changer
operator|->
name|flags
operator|&
name|CHANGER_TIMEOUT_SCHED
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|softc
operator|->
name|changer
operator|->
name|flags
operator|&
name|CHANGER_NEED_TIMEOUT
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|softc
operator|->
name|changer
operator|->
name|flags
operator|&
name|CHANGER_SHORT_TMOUT_SCHED
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|softc
operator|->
name|changer
operator|->
name|flags
operator||=
name|CHANGER_MANUAL_CALL
expr_stmt|;
name|cdrunchangerqueue
argument_list|(
name|softc
operator|->
name|changer
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|CD_FLAG_ACTIVE
operator|)
operator|&&
operator|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|CD_FLAG_SCHED_ON_COMP
operator|)
operator|==
literal|0
operator|)
condition|)
name|xpt_schedule
argument_list|(
name|periph
argument_list|,
name|priority
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cdrunchangerqueue
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cd_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|cdchanger
modifier|*
name|changer
decl_stmt|;
name|int
name|called_from_timeout
decl_stmt|;
name|changer
operator|=
operator|(
expr|struct
name|cdchanger
operator|*
operator|)
name|arg
expr_stmt|;
comment|/* 	 * If we have NOT been called from cdstrategy() or cddone(), and 	 * instead from a timeout routine, go ahead and clear the 	 * timeout flag. 	 */
if|if
condition|(
operator|(
name|changer
operator|->
name|flags
operator|&
name|CHANGER_MANUAL_CALL
operator|)
operator|==
literal|0
condition|)
block|{
name|changer
operator|->
name|flags
operator|&=
operator|~
name|CHANGER_TIMEOUT_SCHED
expr_stmt|;
name|called_from_timeout
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|called_from_timeout
operator|=
literal|0
expr_stmt|;
comment|/* Always clear the manual call flag */
name|changer
operator|->
name|flags
operator|&=
operator|~
name|CHANGER_MANUAL_CALL
expr_stmt|;
comment|/* nothing to do if the queue is empty */
if|if
condition|(
name|changer
operator|->
name|devq
operator|.
name|entries
operator|<=
literal|0
condition|)
block|{
return|return;
block|}
comment|/* 	 * If the changer queue is frozen, that means we have an active 	 * device. 	 */
if|if
condition|(
name|changer
operator|->
name|devq
operator|.
name|qfrozen_cnt
operator|>
literal|0
condition|)
block|{
comment|/* 		 * We always need to reset the frozen count and clear the 		 * active flag. 		 */
name|changer
operator|->
name|devq
operator|.
name|qfrozen_cnt
operator|--
expr_stmt|;
name|changer
operator|->
name|cur_device
operator|->
name|flags
operator|&=
operator|~
name|CD_FLAG_ACTIVE
expr_stmt|;
name|changer
operator|->
name|cur_device
operator|->
name|flags
operator|&=
operator|~
name|CD_FLAG_SCHED_ON_COMP
expr_stmt|;
if|if
condition|(
name|changer
operator|->
name|cur_device
operator|->
name|outstanding_cmds
operator|>
literal|0
condition|)
block|{
name|changer
operator|->
name|cur_device
operator|->
name|flags
operator||=
name|CD_FLAG_SCHED_ON_COMP
expr_stmt|;
name|changer
operator|->
name|cur_device
operator|->
name|bufs_left
operator|=
name|changer
operator|->
name|cur_device
operator|->
name|outstanding_cmds
expr_stmt|;
if|if
condition|(
name|called_from_timeout
condition|)
block|{
name|callout_reset
argument_list|(
operator|&
name|changer
operator|->
name|long_handle
argument_list|,
name|changer_max_busy_seconds
operator|*
name|hz
argument_list|,
name|cdrunchangerqueue
argument_list|,
name|changer
argument_list|)
expr_stmt|;
name|changer
operator|->
name|flags
operator||=
name|CHANGER_TIMEOUT_SCHED
expr_stmt|;
block|}
return|return;
block|}
comment|/* 		 * Check to see whether the current device has any I/O left 		 * to do.  If so, requeue it at the end of the queue.  If 		 * not, there is no need to requeue it. 		 */
if|if
condition|(
name|bioq_first
argument_list|(
operator|&
name|changer
operator|->
name|cur_device
operator|->
name|bio_queue
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|changer
operator|->
name|cur_device
operator|->
name|pinfo
operator|.
name|generation
operator|=
operator|++
name|changer
operator|->
name|devq
operator|.
name|generation
expr_stmt|;
name|camq_insert
argument_list|(
operator|&
name|changer
operator|->
name|devq
argument_list|,
operator|(
name|cam_pinfo
operator|*
operator|)
name|changer
operator|->
name|cur_device
argument_list|)
expr_stmt|;
block|}
block|}
name|softc
operator|=
operator|(
expr|struct
name|cd_softc
operator|*
operator|)
name|camq_remove
argument_list|(
operator|&
name|changer
operator|->
name|devq
argument_list|,
name|CAMQ_HEAD
argument_list|)
expr_stmt|;
name|changer
operator|->
name|cur_device
operator|=
name|softc
expr_stmt|;
name|changer
operator|->
name|devq
operator|.
name|qfrozen_cnt
operator|++
expr_stmt|;
name|softc
operator|->
name|flags
operator||=
name|CD_FLAG_ACTIVE
expr_stmt|;
comment|/* Just in case this device is waiting */
name|wakeup
argument_list|(
operator|&
name|softc
operator|->
name|changer
argument_list|)
expr_stmt|;
name|xpt_schedule
argument_list|(
name|softc
operator|->
name|periph
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Get rid of any pending timeouts, and set a flag to schedule new 	 * ones so this device gets its full time quantum. 	 */
if|if
condition|(
name|changer
operator|->
name|flags
operator|&
name|CHANGER_TIMEOUT_SCHED
condition|)
block|{
name|callout_stop
argument_list|(
operator|&
name|changer
operator|->
name|long_handle
argument_list|)
expr_stmt|;
name|changer
operator|->
name|flags
operator|&=
operator|~
name|CHANGER_TIMEOUT_SCHED
expr_stmt|;
block|}
if|if
condition|(
name|changer
operator|->
name|flags
operator|&
name|CHANGER_SHORT_TMOUT_SCHED
condition|)
block|{
name|callout_stop
argument_list|(
operator|&
name|changer
operator|->
name|short_handle
argument_list|)
expr_stmt|;
name|changer
operator|->
name|flags
operator|&=
operator|~
name|CHANGER_SHORT_TMOUT_SCHED
expr_stmt|;
block|}
comment|/* 	 * We need to schedule timeouts, but we only do this after the 	 * first transaction has completed.  This eliminates the changer 	 * switch time. 	 */
name|changer
operator|->
name|flags
operator||=
name|CHANGER_NEED_TIMEOUT
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cdchangerschedule
parameter_list|(
name|struct
name|cd_softc
modifier|*
name|softc
parameter_list|)
block|{
name|struct
name|cdchanger
modifier|*
name|changer
decl_stmt|;
name|changer
operator|=
name|softc
operator|->
name|changer
expr_stmt|;
comment|/* 	 * If this is a changer, and this is the current device, 	 * and this device has at least the minimum time quantum to 	 * run, see if we can switch it out. 	 */
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|CD_FLAG_ACTIVE
operator|)
operator|&&
operator|(
operator|(
name|changer
operator|->
name|flags
operator|&
name|CHANGER_SHORT_TMOUT_SCHED
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|changer
operator|->
name|flags
operator|&
name|CHANGER_NEED_TIMEOUT
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * We try three things here.  The first is that we 		 * check to see whether the schedule on completion 		 * flag is set.  If it is, we decrement the number 		 * of buffers left, and if it's zero, we reschedule. 		 * Next, we check to see whether the pending buffer 		 * queue is empty and whether there are no 		 * outstanding transactions.  If so, we reschedule. 		 * Next, we see if the pending buffer queue is empty. 		 * If it is, we set the number of buffers left to 		 * the current active buffer count and set the 		 * schedule on complete flag. 		 */
if|if
condition|(
name|softc
operator|->
name|flags
operator|&
name|CD_FLAG_SCHED_ON_COMP
condition|)
block|{
if|if
condition|(
operator|--
name|softc
operator|->
name|bufs_left
operator|==
literal|0
condition|)
block|{
name|softc
operator|->
name|changer
operator|->
name|flags
operator||=
name|CHANGER_MANUAL_CALL
expr_stmt|;
name|softc
operator|->
name|flags
operator|&=
operator|~
name|CD_FLAG_SCHED_ON_COMP
expr_stmt|;
name|cdrunchangerqueue
argument_list|(
name|softc
operator|->
name|changer
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|bioq_first
argument_list|(
operator|&
name|softc
operator|->
name|bio_queue
argument_list|)
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|softc
operator|->
name|outstanding_cmds
operator|==
literal|0
operator|)
condition|)
block|{
name|softc
operator|->
name|changer
operator|->
name|flags
operator||=
name|CHANGER_MANUAL_CALL
expr_stmt|;
name|cdrunchangerqueue
argument_list|(
name|softc
operator|->
name|changer
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|softc
operator|->
name|changer
operator|->
name|flags
operator|&
name|CHANGER_NEED_TIMEOUT
operator|)
operator|&&
operator|(
name|softc
operator|->
name|flags
operator|&
name|CD_FLAG_ACTIVE
operator|)
condition|)
block|{
comment|/* 		 * Now that the first transaction to this 		 * particular device has completed, we can go ahead 		 * and schedule our timeouts. 		 */
if|if
condition|(
operator|(
name|changer
operator|->
name|flags
operator|&
name|CHANGER_TIMEOUT_SCHED
operator|)
operator|==
literal|0
condition|)
block|{
name|callout_reset
argument_list|(
operator|&
name|changer
operator|->
name|long_handle
argument_list|,
name|changer_max_busy_seconds
operator|*
name|hz
argument_list|,
name|cdrunchangerqueue
argument_list|,
name|changer
argument_list|)
expr_stmt|;
name|changer
operator|->
name|flags
operator||=
name|CHANGER_TIMEOUT_SCHED
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"cdchangerschedule: already have a long"
literal|" timeout!\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|changer
operator|->
name|flags
operator|&
name|CHANGER_SHORT_TMOUT_SCHED
operator|)
operator|==
literal|0
condition|)
block|{
name|callout_reset
argument_list|(
operator|&
name|changer
operator|->
name|short_handle
argument_list|,
name|changer_min_busy_seconds
operator|*
name|hz
argument_list|,
name|cdshorttimeout
argument_list|,
name|changer
argument_list|)
expr_stmt|;
name|changer
operator|->
name|flags
operator||=
name|CHANGER_SHORT_TMOUT_SCHED
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"cdchangerschedule: already have a short "
literal|"timeout!\n"
argument_list|)
expr_stmt|;
comment|/* 		 * We just scheduled timeouts, no need to schedule 		 * more. 		 */
name|changer
operator|->
name|flags
operator|&=
operator|~
name|CHANGER_NEED_TIMEOUT
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|cdrunccb
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|int
function_decl|(
modifier|*
name|error_routine
function_decl|)
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|u_int32_t
name|cam_flags
parameter_list|,
name|u_int32_t
name|sense_flags
parameter_list|)
parameter_list|,
name|u_int32_t
name|cam_flags
parameter_list|,
name|u_int32_t
name|sense_flags
parameter_list|)
block|{
name|struct
name|cd_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|int
name|error
decl_stmt|;
name|periph
operator|=
name|xpt_path_periph
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|cd_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|error_routine
argument_list|,
name|cam_flags
argument_list|,
name|sense_flags
argument_list|,
name|softc
operator|->
name|disk
operator|->
name|d_devstat
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|flags
operator|&
name|CD_FLAG_CHANGER
condition|)
name|cdchangerschedule
argument_list|(
name|softc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|union
name|ccb
modifier|*
name|cdgetccb
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|u_int32_t
name|priority
parameter_list|)
block|{
name|struct
name|cd_softc
modifier|*
name|softc
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|cd_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|flags
operator|&
name|CD_FLAG_CHANGER
condition|)
block|{
comment|/* 		 * This should work the first time this device is woken up, 		 * but just in case it doesn't, we use a while loop. 		 */
while|while
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|CD_FLAG_ACTIVE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * If this changer isn't already queued, queue it up. 			 */
if|if
condition|(
name|softc
operator|->
name|pinfo
operator|.
name|index
operator|==
name|CAM_UNQUEUED_INDEX
condition|)
block|{
name|softc
operator|->
name|pinfo
operator|.
name|priority
operator|=
literal|1
expr_stmt|;
name|softc
operator|->
name|pinfo
operator|.
name|generation
operator|=
operator|++
name|softc
operator|->
name|changer
operator|->
name|devq
operator|.
name|generation
expr_stmt|;
name|camq_insert
argument_list|(
operator|&
name|softc
operator|->
name|changer
operator|->
name|devq
argument_list|,
operator|(
name|cam_pinfo
operator|*
operator|)
name|softc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|softc
operator|->
name|changer
operator|->
name|flags
operator|&
name|CHANGER_TIMEOUT_SCHED
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|softc
operator|->
name|changer
operator|->
name|flags
operator|&
name|CHANGER_NEED_TIMEOUT
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|softc
operator|->
name|changer
operator|->
name|flags
operator|&
name|CHANGER_SHORT_TMOUT_SCHED
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|softc
operator|->
name|changer
operator|->
name|flags
operator||=
name|CHANGER_MANUAL_CALL
expr_stmt|;
name|cdrunchangerqueue
argument_list|(
name|softc
operator|->
name|changer
argument_list|)
expr_stmt|;
block|}
else|else
name|msleep
argument_list|(
operator|&
name|softc
operator|->
name|changer
argument_list|,
name|periph
operator|->
name|sim
operator|->
name|mtx
argument_list|,
name|PRIBIO
argument_list|,
literal|"cgticb"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
name|priority
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Actually translate the requested transfer into one the physical driver  * can understand.  The transfer is described by a buf and will include  * only one physical transfer.  */
end_comment

begin_function
specifier|static
name|void
name|cdstrategy
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|cd_softc
modifier|*
name|softc
decl_stmt|;
name|periph
operator|=
operator|(
expr|struct
name|cam_periph
operator|*
operator|)
name|bp
operator|->
name|bio_disk
operator|->
name|d_drv1
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
block|{
name|biofinish
argument_list|(
name|bp
argument_list|,
name|NULL
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
return|return;
block|}
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"entering cdstrategy\n"
operator|)
argument_list|)
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|cd_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
comment|/* 	 * If the device has been made invalid, error out 	 */
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|CD_FLAG_INVALID
operator|)
condition|)
block|{
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|biofinish
argument_list|(
name|bp
argument_list|,
name|NULL
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If we don't have valid media, look for it before trying to 	 * schedule the I/O. 	 */
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|CD_FLAG_VALID_MEDIA
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|cdcheckmedia
argument_list|(
name|periph
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|biofinish
argument_list|(
name|bp
argument_list|,
name|NULL
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * Place it in the queue of disk activities for this disk 	 */
name|bioq_disksort
argument_list|(
operator|&
name|softc
operator|->
name|bio_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * Schedule ourselves for performing the work.  We do things 	 * differently for changers. 	 */
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|CD_FLAG_CHANGER
operator|)
operator|==
literal|0
condition|)
name|xpt_schedule
argument_list|(
name|periph
argument_list|,
comment|/* XXX priority */
literal|1
argument_list|)
expr_stmt|;
else|else
name|cdschedule
argument_list|(
name|periph
argument_list|,
comment|/* priority */
literal|1
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|cdstart
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|start_ccb
parameter_list|)
block|{
name|struct
name|cd_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|struct
name|scsi_read_capacity_data
modifier|*
name|rcap
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|cd_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"entering cdstart\n"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|softc
operator|->
name|state
condition|)
block|{
case|case
name|CD_STATE_NORMAL
case|:
block|{
name|bp
operator|=
name|bioq_first
argument_list|(
operator|&
name|softc
operator|->
name|bio_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|periph
operator|->
name|immediate_priority
operator|<=
name|periph
operator|->
name|pinfo
operator|.
name|priority
condition|)
block|{
name|start_ccb
operator|->
name|ccb_h
operator|.
name|ccb_state
operator|=
name|CD_CCB_WAITING
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|periph
operator|->
name|ccb_list
argument_list|,
operator|&
name|start_ccb
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|sle
argument_list|)
expr_stmt|;
name|periph
operator|->
name|immediate_priority
operator|=
name|CAM_PRIORITY_NONE
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|periph
operator|->
name|ccb_list
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
name|xpt_release_ccb
argument_list|(
name|start_ccb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bioq_remove
argument_list|(
operator|&
name|softc
operator|->
name|bio_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|devstat_start_transaction_bio
argument_list|(
name|softc
operator|->
name|disk
operator|->
name|d_devstat
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|scsi_read_write
argument_list|(
operator|&
name|start_ccb
operator|->
name|csio
argument_list|,
comment|/*retries*/
literal|4
argument_list|,
comment|/* cbfcnp */
name|cddone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* read */
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_READ
argument_list|,
comment|/* byte2 */
literal|0
argument_list|,
comment|/* minimum_cmd_size */
literal|10
argument_list|,
comment|/* lba */
name|bp
operator|->
name|bio_offset
operator|/
name|softc
operator|->
name|params
operator|.
name|blksize
argument_list|,
name|bp
operator|->
name|bio_bcount
operator|/
name|softc
operator|->
name|params
operator|.
name|blksize
argument_list|,
comment|/* data_ptr */
name|bp
operator|->
name|bio_data
argument_list|,
comment|/* dxfer_len */
name|bp
operator|->
name|bio_bcount
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
literal|30000
argument_list|)
expr_stmt|;
name|start_ccb
operator|->
name|ccb_h
operator|.
name|ccb_state
operator|=
name|CD_CCB_BUFFER_IO
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|softc
operator|->
name|pending_ccbs
argument_list|,
operator|&
name|start_ccb
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|le
argument_list|)
expr_stmt|;
name|softc
operator|->
name|outstanding_cmds
operator|++
expr_stmt|;
comment|/* We expect a unit attention from this device */
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|CD_FLAG_RETRY_UA
operator|)
operator|!=
literal|0
condition|)
block|{
name|start_ccb
operator|->
name|ccb_h
operator|.
name|ccb_state
operator||=
name|CD_CCB_RETRY_UA
expr_stmt|;
name|softc
operator|->
name|flags
operator|&=
operator|~
name|CD_FLAG_RETRY_UA
expr_stmt|;
block|}
name|start_ccb
operator|->
name|ccb_h
operator|.
name|ccb_bp
operator|=
name|bp
expr_stmt|;
name|bp
operator|=
name|bioq_first
argument_list|(
operator|&
name|softc
operator|->
name|bio_queue
argument_list|)
expr_stmt|;
name|xpt_action
argument_list|(
name|start_ccb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
block|{
comment|/* Have more work to do, so ensure we stay scheduled */
name|xpt_schedule
argument_list|(
name|periph
argument_list|,
comment|/* XXX priority */
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|CD_STATE_PROBE
case|:
block|{
name|rcap
operator|=
operator|(
expr|struct
name|scsi_read_capacity_data
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|rcap
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcap
operator|==
name|NULL
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"cdstart: Couldn't malloc read_capacity data\n"
argument_list|)
expr_stmt|;
comment|/* cd_free_periph??? */
break|break;
block|}
name|csio
operator|=
operator|&
name|start_ccb
operator|->
name|csio
expr_stmt|;
name|scsi_read_capacity
argument_list|(
name|csio
argument_list|,
comment|/*retries*/
literal|1
argument_list|,
name|cddone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|rcap
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
comment|/*timeout*/
literal|20000
argument_list|)
expr_stmt|;
name|start_ccb
operator|->
name|ccb_h
operator|.
name|ccb_bp
operator|=
name|NULL
expr_stmt|;
name|start_ccb
operator|->
name|ccb_h
operator|.
name|ccb_state
operator|=
name|CD_CCB_PROBE
expr_stmt|;
name|xpt_action
argument_list|(
name|start_ccb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cddone
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|done_ccb
parameter_list|)
block|{
name|struct
name|cd_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"entering cddone\n"
operator|)
argument_list|)
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|cd_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|csio
operator|=
operator|&
name|done_ccb
operator|->
name|csio
expr_stmt|;
switch|switch
condition|(
name|csio
operator|->
name|ccb_h
operator|.
name|ccb_state
operator|&
name|CD_CCB_TYPE_MASK
condition|)
block|{
case|case
name|CD_CCB_BUFFER_IO
case|:
block|{
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bp
operator|=
operator|(
expr|struct
name|bio
operator|*
operator|)
name|done_ccb
operator|->
name|ccb_h
operator|.
name|ccb_bp
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|int
name|sf
decl_stmt|;
if|if
condition|(
operator|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|ccb_state
operator|&
name|CD_CCB_RETRY_UA
operator|)
operator|!=
literal|0
condition|)
name|sf
operator|=
name|SF_RETRY_UA
expr_stmt|;
else|else
name|sf
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|cderror
argument_list|(
name|done_ccb
argument_list|,
name|CAM_RETRY_SELTO
argument_list|,
name|sf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
block|{
comment|/* 				 * A retry was scheuled, so 				 * just return. 				 */
return|return;
block|}
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"cddone: got error %#x back\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|bioq_flush
argument_list|(
operator|&
name|softc
operator|->
name|bio_queue
argument_list|,
name|NULL
argument_list|,
name|EIO
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bio_resid
operator|=
name|bp
operator|->
name|bio_bcount
expr_stmt|;
name|bp
operator|->
name|bio_error
operator|=
name|error
expr_stmt|;
name|bp
operator|->
name|bio_flags
operator||=
name|BIO_ERROR
expr_stmt|;
name|cam_release_devq
argument_list|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*relsim_flags*/
literal|0
argument_list|,
comment|/*reduction*/
literal|0
argument_list|,
comment|/*timeout*/
literal|0
argument_list|,
comment|/*getcount_only*/
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bp
operator|->
name|bio_resid
operator|=
name|csio
operator|->
name|resid
expr_stmt|;
name|bp
operator|->
name|bio_error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_resid
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * Short transfer ???  				 * XXX: not sure this is correct for partial 				 * transfers at EOM 				 */
name|bp
operator|->
name|bio_flags
operator||=
name|BIO_ERROR
expr_stmt|;
block|}
block|}
name|LIST_REMOVE
argument_list|(
operator|&
name|done_ccb
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|le
argument_list|)
expr_stmt|;
name|softc
operator|->
name|outstanding_cmds
operator|--
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|flags
operator|&
name|CD_FLAG_CHANGER
condition|)
name|cdchangerschedule
argument_list|(
name|softc
argument_list|)
expr_stmt|;
name|biofinish
argument_list|(
name|bp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CD_CCB_PROBE
case|:
block|{
name|struct
name|scsi_read_capacity_data
modifier|*
name|rdcap
decl_stmt|;
name|char
name|announce_buf
index|[
literal|120
index|]
decl_stmt|;
comment|/* 					       * Currently (9/30/97) the  					       * longest possible announce  					       * buffer is 108 bytes, for the  					       * first error case below.   					       * That is 39 bytes for the  					       * basic string, 16 bytes for the 					       * biggest sense key (hardware  					       * error), 52 bytes for the 					       * text of the largest sense  					       * qualifier valid for a CDROM, 					       * (0x72, 0x03 or 0x04, 					       * 0x03), and one byte for the 					       * null terminating character. 					       * To allow for longer strings,  					       * the announce buffer is 120 					       * bytes. 					       */
name|struct
name|cd_params
modifier|*
name|cdp
decl_stmt|;
name|cdp
operator|=
operator|&
name|softc
operator|->
name|params
expr_stmt|;
name|rdcap
operator|=
operator|(
expr|struct
name|scsi_read_capacity_data
operator|*
operator|)
name|csio
operator|->
name|data_ptr
expr_stmt|;
name|cdp
operator|->
name|disksize
operator|=
name|scsi_4btoul
argument_list|(
name|rdcap
operator|->
name|addr
argument_list|)
operator|+
literal|1
expr_stmt|;
name|cdp
operator|->
name|blksize
operator|=
name|scsi_4btoul
argument_list|(
name|rdcap
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_CMP
condition|)
block|{
name|snprintf
argument_list|(
name|announce_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|announce_buf
argument_list|)
argument_list|,
literal|"cd present [%lu x %lu byte records]"
argument_list|,
name|cdp
operator|->
name|disksize
argument_list|,
operator|(
name|u_long
operator|)
name|cdp
operator|->
name|blksize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|error
decl_stmt|;
comment|/* 			 * Retry any UNIT ATTENTION type errors.  They 			 * are expected at boot. 			 */
name|error
operator|=
name|cderror
argument_list|(
name|done_ccb
argument_list|,
name|CAM_RETRY_SELTO
argument_list|,
name|SF_RETRY_UA
operator||
name|SF_NO_PRINT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
block|{
comment|/* 				 * A retry was scheuled, so 				 * just return. 				 */
return|return;
block|}
elseif|else
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|struct
name|scsi_sense_data
modifier|*
name|sense
decl_stmt|;
name|int
name|asc
decl_stmt|,
name|ascq
decl_stmt|;
name|int
name|sense_key
decl_stmt|,
name|error_code
decl_stmt|;
name|int
name|have_sense
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|struct
name|ccb_getdev
name|cgd
decl_stmt|;
comment|/* Don't wedge this device's queue */
name|cam_release_devq
argument_list|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*relsim_flags*/
literal|0
argument_list|,
comment|/*reduction*/
literal|0
argument_list|,
comment|/*timeout*/
literal|0
argument_list|,
comment|/*getcount_only*/
literal|0
argument_list|)
expr_stmt|;
name|status
operator|=
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|cgd
operator|.
name|ccb_h
argument_list|,
name|done_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/* priority */
literal|1
argument_list|)
expr_stmt|;
name|cgd
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_GDEV_TYPE
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|cgd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SENSE_PHYS
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SENSE_PTR
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|status
operator|&
name|CAM_AUTOSNS_VALID
operator|)
operator|==
literal|0
operator|)
condition|)
name|have_sense
operator|=
name|FALSE
expr_stmt|;
else|else
name|have_sense
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|have_sense
condition|)
block|{
name|sense
operator|=
operator|&
name|csio
operator|->
name|sense_data
expr_stmt|;
name|scsi_extract_sense
argument_list|(
name|sense
argument_list|,
operator|&
name|error_code
argument_list|,
operator|&
name|sense_key
argument_list|,
operator|&
name|asc
argument_list|,
operator|&
name|ascq
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * Attach to anything that claims to be a 				 * CDROM or WORM device, as long as it 				 * doesn't return a "Logical unit not 				 * supported" (0x25) error. 				 */
if|if
condition|(
operator|(
name|have_sense
operator|)
operator|&&
operator|(
name|asc
operator|!=
literal|0x25
operator|)
operator|&&
operator|(
name|error_code
operator|==
name|SSD_CURRENT_ERROR
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|sense_key_desc
decl_stmt|;
specifier|const
name|char
modifier|*
name|asc_desc
decl_stmt|;
name|scsi_sense_desc
argument_list|(
name|sense_key
argument_list|,
name|asc
argument_list|,
name|ascq
argument_list|,
operator|&
name|cgd
operator|.
name|inq_data
argument_list|,
operator|&
name|sense_key_desc
argument_list|,
operator|&
name|asc_desc
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|announce_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|announce_buf
argument_list|)
argument_list|,
literal|"Attempt to query device "
literal|"size failed: %s, %s"
argument_list|,
name|sense_key_desc
argument_list|,
name|asc_desc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|have_sense
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_SCSI_STATUS_ERROR
operator|)
operator|&&
operator|(
name|csio
operator|->
name|scsi_status
operator|==
name|SCSI_STATUS_BUSY
operator|)
condition|)
block|{
name|snprintf
argument_list|(
name|announce_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|announce_buf
argument_list|)
argument_list|,
literal|"Attempt to query device "
literal|"size failed: SCSI Status: %s"
argument_list|,
name|scsi_status_string
argument_list|(
name|csio
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SID_TYPE
argument_list|(
operator|&
name|cgd
operator|.
name|inq_data
argument_list|)
operator|==
name|T_CDROM
condition|)
block|{
comment|/* 					 * We only print out an error for 					 * CDROM type devices.  For WORM 					 * devices, we don't print out an 					 * error since a few WORM devices 					 * don't support CDROM commands. 					 * If we have sense information, go 					 * ahead and print it out. 					 * Otherwise, just say that we  					 * couldn't attach. 					 */
comment|/* 					 * Just print out the error, not 					 * the full probe message, when we 					 * don't attach. 					 */
if|if
condition|(
name|have_sense
condition|)
name|scsi_sense_print
argument_list|(
operator|&
name|done_ccb
operator|->
name|csio
argument_list|)
expr_stmt|;
else|else
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"got CAM status %#x\n"
argument_list|,
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
argument_list|)
expr_stmt|;
block|}
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"fatal error, "
literal|"failed to attach to device\n"
argument_list|)
expr_stmt|;
comment|/* 					 * Invalidate this peripheral. 					 */
name|cam_periph_invalidate
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|announce_buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
comment|/* 					 * Invalidate this peripheral. 					 */
name|cam_periph_invalidate
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|announce_buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
name|rdcap
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|announce_buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|xpt_announce_periph
argument_list|(
name|periph
argument_list|,
name|announce_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|flags
operator|&
name|CD_FLAG_CHANGER
condition|)
name|cdchangerschedule
argument_list|(
name|softc
argument_list|)
expr_stmt|;
comment|/* 			 * Create our sysctl variables, now that we know 			 * we have successfully attached. 			 */
name|taskqueue_enqueue
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|softc
operator|->
name|sysctl_task
argument_list|)
expr_stmt|;
block|}
name|softc
operator|->
name|state
operator|=
name|CD_STATE_NORMAL
expr_stmt|;
comment|/* 		 * Since our peripheral may be invalidated by an error 		 * above or an external event, we must release our CCB 		 * before releasing the probe lock on the peripheral. 		 * The peripheral will only go away once the last lock 		 * is removed, and we need it around for the CCB release 		 * operation. 		 */
name|xpt_release_ccb
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
name|cam_periph_unhold
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|CD_CCB_WAITING
case|:
block|{
comment|/* Caller will release the CCB */
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"trying to wakeup ccbwait\n"
operator|)
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|done_ccb
operator|->
name|ccb_h
operator|.
name|cbfcnp
argument_list|)
expr_stmt|;
return|return;
block|}
default|default:
break|break;
block|}
name|xpt_release_ccb
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|union
name|cd_pages
modifier|*
name|cdgetpage
parameter_list|(
name|struct
name|cd_mode_params
modifier|*
name|mode_params
parameter_list|)
block|{
name|union
name|cd_pages
modifier|*
name|page
decl_stmt|;
if|if
condition|(
name|mode_params
operator|->
name|cdb_size
operator|==
literal|10
condition|)
name|page
operator|=
operator|(
expr|union
name|cd_pages
operator|*
operator|)
name|find_mode_page_10
argument_list|(
operator|(
expr|struct
name|scsi_mode_header_10
operator|*
operator|)
name|mode_params
operator|->
name|mode_buf
argument_list|)
expr_stmt|;
else|else
name|page
operator|=
operator|(
expr|union
name|cd_pages
operator|*
operator|)
name|find_mode_page_6
argument_list|(
operator|(
expr|struct
name|scsi_mode_header_6
operator|*
operator|)
name|mode_params
operator|->
name|mode_buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|page
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cdgetpagesize
parameter_list|(
name|int
name|page_num
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|cd_page_size_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|cd_page_size_table
index|[
literal|0
index|]
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cd_page_size_table
index|[
name|i
index|]
operator|.
name|page
operator|==
name|page_num
condition|)
return|return
operator|(
name|cd_page_size_table
index|[
name|i
index|]
operator|.
name|page_size
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cdioctl
parameter_list|(
name|struct
name|disk
modifier|*
name|dp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|void
modifier|*
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|cd_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|nocopyout
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|periph
operator|=
operator|(
expr|struct
name|cam_periph
operator|*
operator|)
name|dp
operator|->
name|d_drv1
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"entering cdioctl\n"
operator|)
argument_list|)
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|cd_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"trying to do ioctl %#lx\n"
operator|,
name|cmd
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|cam_periph_hold
argument_list|(
name|periph
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|cam_periph_release
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * If we don't have media loaded, check for it.  If still don't 	 * have media loaded, we can only do a load or eject. 	 * 	 * We only care whether media is loaded if this is a cd-specific ioctl 	 * (thus the IOCGROUP check below).  Note that this will break if 	 * anyone adds any ioctls into the switch statement below that don't 	 * have their ioctl group set to 'c'. 	 */
if|if
condition|(
operator|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|CD_FLAG_VALID_MEDIA
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|cmd
operator|!=
name|CDIOCCLOSE
operator|)
operator|&&
operator|(
name|cmd
operator|!=
name|CDIOCEJECT
operator|)
operator|)
operator|&&
operator|(
name|IOCGROUP
argument_list|(
name|cmd
argument_list|)
operator|==
literal|'c'
operator|)
condition|)
block|{
name|error
operator|=
name|cdcheckmedia
argument_list|(
name|periph
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Drop the lock here so later mallocs can use WAITOK.  The periph 	 * is essentially locked still with the cam_periph_hold call above. 	 */
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|nocopyout
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|CDIOCPLAYTRACKS
case|:
block|{
name|struct
name|ioc_play_track
modifier|*
name|args
init|=
operator|(
expr|struct
name|ioc_play_track
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|cd_mode_params
name|params
decl_stmt|;
name|union
name|cd_pages
modifier|*
name|page
decl_stmt|;
name|params
operator|.
name|alloc_len
operator|=
sizeof|sizeof
argument_list|(
expr|union
name|cd_mode_data_6_10
argument_list|)
expr_stmt|;
name|params
operator|.
name|mode_buf
operator|=
name|malloc
argument_list|(
name|params
operator|.
name|alloc_len
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"trying to do CDIOCPLAYTRACKS\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdgetmode
argument_list|(
name|periph
argument_list|,
operator|&
name|params
argument_list|,
name|AUDIO_PAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|params
operator|.
name|mode_buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
break|break;
block|}
name|page
operator|=
name|cdgetpage
argument_list|(
operator|&
name|params
argument_list|)
expr_stmt|;
name|page
operator|->
name|audio
operator|.
name|flags
operator|&=
operator|~
name|CD_PA_SOTC
expr_stmt|;
name|page
operator|->
name|audio
operator|.
name|flags
operator||=
name|CD_PA_IMMED
expr_stmt|;
name|error
operator|=
name|cdsetmode
argument_list|(
name|periph
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|params
operator|.
name|mode_buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 			 * This was originally implemented with the PLAY 			 * AUDIO TRACK INDEX command, but that command was 			 * deprecated after SCSI-2.  Most (all?) SCSI CDROM 			 * drives support it but ATAPI and ATAPI-derivative 			 * drives don't seem to support it.  So we keep a 			 * cache of the table of contents and translate 			 * track numbers to MSF format. 			 */
if|if
condition|(
name|softc
operator|->
name|flags
operator|&
name|CD_FLAG_VALID_TOC
condition|)
block|{
name|union
name|msf_lba
modifier|*
name|sentry
decl_stmt|,
modifier|*
name|eentry
decl_stmt|;
name|int
name|st
decl_stmt|,
name|et
decl_stmt|;
if|if
condition|(
name|args
operator|->
name|end_track
operator|<
name|softc
operator|->
name|toc
operator|.
name|header
operator|.
name|ending_track
operator|+
literal|1
condition|)
name|args
operator|->
name|end_track
operator|++
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|end_track
operator|>
name|softc
operator|->
name|toc
operator|.
name|header
operator|.
name|ending_track
operator|+
literal|1
condition|)
name|args
operator|->
name|end_track
operator|=
name|softc
operator|->
name|toc
operator|.
name|header
operator|.
name|ending_track
operator|+
literal|1
expr_stmt|;
name|st
operator|=
name|args
operator|->
name|start_track
operator|-
name|softc
operator|->
name|toc
operator|.
name|header
operator|.
name|starting_track
expr_stmt|;
name|et
operator|=
name|args
operator|->
name|end_track
operator|-
name|softc
operator|->
name|toc
operator|.
name|header
operator|.
name|starting_track
expr_stmt|;
if|if
condition|(
operator|(
name|st
operator|<
literal|0
operator|)
operator|||
operator|(
name|et
operator|<
literal|0
operator|)
operator|||
operator|(
name|st
operator|>
operator|(
name|softc
operator|->
name|toc
operator|.
name|header
operator|.
name|ending_track
operator|-
name|softc
operator|->
name|toc
operator|.
name|header
operator|.
name|starting_track
operator|)
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|sentry
operator|=
operator|&
name|softc
operator|->
name|toc
operator|.
name|entries
index|[
name|st
index|]
operator|.
name|addr
expr_stmt|;
name|eentry
operator|=
operator|&
name|softc
operator|->
name|toc
operator|.
name|entries
index|[
name|et
index|]
operator|.
name|addr
expr_stmt|;
name|error
operator|=
name|cdplaymsf
argument_list|(
name|periph
argument_list|,
name|sentry
operator|->
name|msf
operator|.
name|minute
argument_list|,
name|sentry
operator|->
name|msf
operator|.
name|second
argument_list|,
name|sentry
operator|->
name|msf
operator|.
name|frame
argument_list|,
name|eentry
operator|->
name|msf
operator|.
name|minute
argument_list|,
name|eentry
operator|->
name|msf
operator|.
name|second
argument_list|,
name|eentry
operator|->
name|msf
operator|.
name|frame
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * If we don't have a valid TOC, try the 				 * play track index command.  It is part of 				 * the SCSI-2 spec, but was removed in the 				 * MMC specs.  ATAPI and ATAPI-derived 				 * drives don't support it. 				 */
if|if
condition|(
name|softc
operator|->
name|quirks
operator|&
name|CD_Q_BCD_TRACKS
condition|)
block|{
name|args
operator|->
name|start_track
operator|=
name|bin2bcd
argument_list|(
name|args
operator|->
name|start_track
argument_list|)
expr_stmt|;
name|args
operator|->
name|end_track
operator|=
name|bin2bcd
argument_list|(
name|args
operator|->
name|end_track
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|cdplaytracks
argument_list|(
name|periph
argument_list|,
name|args
operator|->
name|start_track
argument_list|,
name|args
operator|->
name|start_index
argument_list|,
name|args
operator|->
name|end_track
argument_list|,
name|args
operator|->
name|end_index
argument_list|)
expr_stmt|;
block|}
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CDIOCPLAYMSF
case|:
block|{
name|struct
name|ioc_play_msf
modifier|*
name|args
init|=
operator|(
expr|struct
name|ioc_play_msf
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|cd_mode_params
name|params
decl_stmt|;
name|union
name|cd_pages
modifier|*
name|page
decl_stmt|;
name|params
operator|.
name|alloc_len
operator|=
sizeof|sizeof
argument_list|(
expr|union
name|cd_mode_data_6_10
argument_list|)
expr_stmt|;
name|params
operator|.
name|mode_buf
operator|=
name|malloc
argument_list|(
name|params
operator|.
name|alloc_len
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"trying to do CDIOCPLAYMSF\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdgetmode
argument_list|(
name|periph
argument_list|,
operator|&
name|params
argument_list|,
name|AUDIO_PAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|params
operator|.
name|mode_buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
break|break;
block|}
name|page
operator|=
name|cdgetpage
argument_list|(
operator|&
name|params
argument_list|)
expr_stmt|;
name|page
operator|->
name|audio
operator|.
name|flags
operator|&=
operator|~
name|CD_PA_SOTC
expr_stmt|;
name|page
operator|->
name|audio
operator|.
name|flags
operator||=
name|CD_PA_IMMED
expr_stmt|;
name|error
operator|=
name|cdsetmode
argument_list|(
name|periph
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|params
operator|.
name|mode_buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|cdplaymsf
argument_list|(
name|periph
argument_list|,
name|args
operator|->
name|start_m
argument_list|,
name|args
operator|->
name|start_s
argument_list|,
name|args
operator|->
name|start_f
argument_list|,
name|args
operator|->
name|end_m
argument_list|,
name|args
operator|->
name|end_s
argument_list|,
name|args
operator|->
name|end_f
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CDIOCPLAYBLOCKS
case|:
block|{
name|struct
name|ioc_play_blocks
modifier|*
name|args
init|=
operator|(
expr|struct
name|ioc_play_blocks
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|cd_mode_params
name|params
decl_stmt|;
name|union
name|cd_pages
modifier|*
name|page
decl_stmt|;
name|params
operator|.
name|alloc_len
operator|=
sizeof|sizeof
argument_list|(
expr|union
name|cd_mode_data_6_10
argument_list|)
expr_stmt|;
name|params
operator|.
name|mode_buf
operator|=
name|malloc
argument_list|(
name|params
operator|.
name|alloc_len
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"trying to do CDIOCPLAYBLOCKS\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdgetmode
argument_list|(
name|periph
argument_list|,
operator|&
name|params
argument_list|,
name|AUDIO_PAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|params
operator|.
name|mode_buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
break|break;
block|}
name|page
operator|=
name|cdgetpage
argument_list|(
operator|&
name|params
argument_list|)
expr_stmt|;
name|page
operator|->
name|audio
operator|.
name|flags
operator|&=
operator|~
name|CD_PA_SOTC
expr_stmt|;
name|page
operator|->
name|audio
operator|.
name|flags
operator||=
name|CD_PA_IMMED
expr_stmt|;
name|error
operator|=
name|cdsetmode
argument_list|(
name|periph
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|params
operator|.
name|mode_buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|cdplay
argument_list|(
name|periph
argument_list|,
name|args
operator|->
name|blk
argument_list|,
name|args
operator|->
name|len
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CDIOCREADSUBCHANNEL_SYSSPACE
case|:
name|nocopyout
operator|=
literal|1
expr_stmt|;
comment|/* Fallthrough */
case|case
name|CDIOCREADSUBCHANNEL
case|:
block|{
name|struct
name|ioc_read_subchannel
modifier|*
name|args
init|=
operator|(
expr|struct
name|ioc_read_subchannel
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|cd_sub_channel_info
modifier|*
name|data
decl_stmt|;
name|u_int32_t
name|len
init|=
name|args
operator|->
name|data_len
decl_stmt|;
name|data
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cd_sub_channel_info
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"trying to do CDIOCREADSUBCHANNEL\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|cd_sub_channel_info
argument_list|)
operator|)
operator|||
operator|(
name|len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|cd_sub_channel_header
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"scsi_cd: cdioctl: "
literal|"cdioreadsubchannel: error, len=%d\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|softc
operator|->
name|quirks
operator|&
name|CD_Q_BCD_TRACKS
condition|)
name|args
operator|->
name|track
operator|=
name|bin2bcd
argument_list|(
name|args
operator|->
name|track
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdreadsubchannel
argument_list|(
name|periph
argument_list|,
name|args
operator|->
name|address_format
argument_list|,
name|args
operator|->
name|data_format
argument_list|,
name|args
operator|->
name|track
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|softc
operator|->
name|quirks
operator|&
name|CD_Q_BCD_TRACKS
condition|)
name|data
operator|->
name|what
operator|.
name|track_info
operator|.
name|track_number
operator|=
name|bcd2bin
argument_list|(
name|data
operator|->
name|what
operator|.
name|track_info
operator|.
name|track_number
argument_list|)
expr_stmt|;
name|len
operator|=
name|min
argument_list|(
name|len
argument_list|,
operator|(
operator|(
name|data
operator|->
name|header
operator|.
name|data_len
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator|+
name|data
operator|->
name|header
operator|.
name|data_len
index|[
literal|1
index|]
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|cd_sub_channel_header
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
if|if
condition|(
name|nocopyout
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|copyout
argument_list|(
name|data
argument_list|,
name|args
operator|->
name|data
argument_list|,
name|len
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
block|}
block|}
else|else
block|{
name|bcopy
argument_list|(
name|data
argument_list|,
name|args
operator|->
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CDIOREADTOCHEADER
case|:
block|{
name|struct
name|ioc_toc_header
modifier|*
name|th
decl_stmt|;
name|th
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ioc_toc_header
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"trying to do CDIOREADTOCHEADER\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdreadtoc
argument_list|(
name|periph
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
name|th
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|th
argument_list|)
argument_list|,
comment|/*sense_flags*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|th
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|softc
operator|->
name|quirks
operator|&
name|CD_Q_BCD_TRACKS
condition|)
block|{
comment|/* we are going to have to convert the BCD 				 * encoding on the cd to what is expected 				 */
name|th
operator|->
name|starting_track
operator|=
name|bcd2bin
argument_list|(
name|th
operator|->
name|starting_track
argument_list|)
expr_stmt|;
name|th
operator|->
name|ending_track
operator|=
name|bcd2bin
argument_list|(
name|th
operator|->
name|ending_track
argument_list|)
expr_stmt|;
block|}
name|th
operator|->
name|len
operator|=
name|ntohs
argument_list|(
name|th
operator|->
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|th
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|th
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|th
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CDIOREADTOCENTRYS
case|:
block|{
name|struct
name|cd_tocdata
modifier|*
name|data
decl_stmt|;
name|struct
name|cd_toc_single
modifier|*
name|lead
decl_stmt|;
name|struct
name|ioc_read_toc_entry
modifier|*
name|te
init|=
operator|(
expr|struct
name|ioc_read_toc_entry
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|ioc_toc_header
modifier|*
name|th
decl_stmt|;
name|u_int32_t
name|len
decl_stmt|,
name|readlen
decl_stmt|,
name|idx
decl_stmt|,
name|num
decl_stmt|;
name|u_int32_t
name|starting_track
init|=
name|te
operator|->
name|starting_track
decl_stmt|;
name|data
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|lead
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|lead
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"trying to do CDIOREADTOCENTRYS\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|te
operator|->
name|data_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|cd_toc_entry
argument_list|)
operator|||
operator|(
name|te
operator|->
name|data_len
operator|%
sizeof|sizeof
argument_list|(
expr|struct
name|cd_toc_entry
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|te
operator|->
name|address_format
operator|!=
name|CD_MSF_FORMAT
operator|&&
name|te
operator|->
name|address_format
operator|!=
name|CD_LBA_FORMAT
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
name|printf
argument_list|(
literal|"scsi_cd: error in readtocentries, "
literal|"returning EINVAL\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lead
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
break|break;
block|}
name|th
operator|=
operator|&
name|data
operator|->
name|header
expr_stmt|;
name|error
operator|=
name|cdreadtoc
argument_list|(
name|periph
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
name|th
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|th
argument_list|)
argument_list|,
comment|/*sense_flags*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lead
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|softc
operator|->
name|quirks
operator|&
name|CD_Q_BCD_TRACKS
condition|)
block|{
comment|/* we are going to have to convert the BCD 				 * encoding on the cd to what is expected 				 */
name|th
operator|->
name|starting_track
operator|=
name|bcd2bin
argument_list|(
name|th
operator|->
name|starting_track
argument_list|)
expr_stmt|;
name|th
operator|->
name|ending_track
operator|=
name|bcd2bin
argument_list|(
name|th
operator|->
name|ending_track
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|starting_track
operator|==
literal|0
condition|)
name|starting_track
operator|=
name|th
operator|->
name|starting_track
expr_stmt|;
elseif|else
if|if
condition|(
name|starting_track
operator|==
name|LEADOUT
condition|)
name|starting_track
operator|=
name|th
operator|->
name|ending_track
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|starting_track
operator|<
name|th
operator|->
name|starting_track
operator|||
name|starting_track
operator|>
name|th
operator|->
name|ending_track
operator|+
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"scsi_cd: error in readtocentries, "
literal|"returning EINVAL\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lead
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* calculate reading length without leadout entry */
name|readlen
operator|=
operator|(
name|th
operator|->
name|ending_track
operator|-
name|starting_track
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|cd_toc_entry
argument_list|)
expr_stmt|;
comment|/* and with leadout entry */
name|len
operator|=
name|readlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|cd_toc_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|te
operator|->
name|data_len
operator|<
name|len
condition|)
block|{
name|len
operator|=
name|te
operator|->
name|data_len
expr_stmt|;
if|if
condition|(
name|readlen
operator|>
name|len
condition|)
name|readlen
operator|=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>
sizeof|sizeof
argument_list|(
name|data
operator|->
name|entries
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"scsi_cd: error in readtocentries, "
literal|"returning EINVAL\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lead
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
break|break;
block|}
name|num
operator|=
name|len
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|cd_toc_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|readlen
operator|>
literal|0
condition|)
block|{
name|error
operator|=
name|cdreadtoc
argument_list|(
name|periph
argument_list|,
name|te
operator|->
name|address_format
argument_list|,
name|starting_track
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
name|data
argument_list|,
name|readlen
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|th
argument_list|)
argument_list|,
comment|/*sense_flags*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lead
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* make leadout entry if needed */
name|idx
operator|=
name|starting_track
operator|+
name|num
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|quirks
operator|&
name|CD_Q_BCD_TRACKS
condition|)
name|th
operator|->
name|ending_track
operator|=
name|bcd2bin
argument_list|(
name|th
operator|->
name|ending_track
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
name|th
operator|->
name|ending_track
operator|+
literal|1
condition|)
block|{
name|error
operator|=
name|cdreadtoc
argument_list|(
name|periph
argument_list|,
name|te
operator|->
name|address_format
argument_list|,
name|LEADOUT
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
name|lead
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lead
argument_list|)
argument_list|,
comment|/*sense_flags*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lead
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
break|break;
block|}
name|data
operator|->
name|entries
index|[
name|idx
operator|-
name|starting_track
index|]
operator|=
name|lead
operator|->
name|entry
expr_stmt|;
block|}
if|if
condition|(
name|softc
operator|->
name|quirks
operator|&
name|CD_Q_BCD_TRACKS
condition|)
block|{
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|num
operator|-
literal|1
condition|;
name|idx
operator|++
control|)
block|{
name|data
operator|->
name|entries
index|[
name|idx
index|]
operator|.
name|track
operator|=
name|bcd2bin
argument_list|(
name|data
operator|->
name|entries
index|[
name|idx
index|]
operator|.
name|track
argument_list|)
expr_stmt|;
block|}
block|}
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
name|data
operator|->
name|entries
argument_list|,
name|te
operator|->
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lead
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CDIOREADTOCENTRY
case|:
block|{
name|struct
name|cd_toc_single
modifier|*
name|data
decl_stmt|;
name|struct
name|ioc_read_toc_single_entry
modifier|*
name|te
init|=
operator|(
expr|struct
name|ioc_read_toc_single_entry
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|ioc_toc_header
modifier|*
name|th
decl_stmt|;
name|u_int32_t
name|track
decl_stmt|;
name|data
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"trying to do CDIOREADTOCENTRY\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|te
operator|->
name|address_format
operator|!=
name|CD_MSF_FORMAT
operator|&&
name|te
operator|->
name|address_format
operator|!=
name|CD_LBA_FORMAT
condition|)
block|{
name|printf
argument_list|(
literal|"error in readtocentry, "
literal|" returning EINVAL\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
break|break;
block|}
name|th
operator|=
operator|&
name|data
operator|->
name|header
expr_stmt|;
name|error
operator|=
name|cdreadtoc
argument_list|(
name|periph
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
name|th
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|th
argument_list|)
argument_list|,
comment|/*sense_flags*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|softc
operator|->
name|quirks
operator|&
name|CD_Q_BCD_TRACKS
condition|)
block|{
comment|/* we are going to have to convert the BCD 				 * encoding on the cd to what is expected 				 */
name|th
operator|->
name|starting_track
operator|=
name|bcd2bin
argument_list|(
name|th
operator|->
name|starting_track
argument_list|)
expr_stmt|;
name|th
operator|->
name|ending_track
operator|=
name|bcd2bin
argument_list|(
name|th
operator|->
name|ending_track
argument_list|)
expr_stmt|;
block|}
name|track
operator|=
name|te
operator|->
name|track
expr_stmt|;
if|if
condition|(
name|track
operator|==
literal|0
condition|)
name|track
operator|=
name|th
operator|->
name|starting_track
expr_stmt|;
elseif|else
if|if
condition|(
name|track
operator|==
name|LEADOUT
condition|)
comment|/* OK */
empty_stmt|;
elseif|else
if|if
condition|(
name|track
operator|<
name|th
operator|->
name|starting_track
operator|||
name|track
operator|>
name|th
operator|->
name|ending_track
operator|+
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"error in readtocentry, "
literal|" returning EINVAL\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|cdreadtoc
argument_list|(
name|periph
argument_list|,
name|te
operator|->
name|address_format
argument_list|,
name|track
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
argument_list|,
comment|/*sense_flags*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|softc
operator|->
name|quirks
operator|&
name|CD_Q_BCD_TRACKS
condition|)
name|data
operator|->
name|entry
operator|.
name|track
operator|=
name|bcd2bin
argument_list|(
name|data
operator|->
name|entry
operator|.
name|track
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|data
operator|->
name|entry
argument_list|,
operator|&
name|te
operator|->
name|entry
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cd_toc_entry
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CDIOCSETPATCH
case|:
block|{
name|struct
name|ioc_patch
modifier|*
name|arg
init|=
operator|(
expr|struct
name|ioc_patch
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|cd_mode_params
name|params
decl_stmt|;
name|union
name|cd_pages
modifier|*
name|page
decl_stmt|;
name|params
operator|.
name|alloc_len
operator|=
sizeof|sizeof
argument_list|(
expr|union
name|cd_mode_data_6_10
argument_list|)
expr_stmt|;
name|params
operator|.
name|mode_buf
operator|=
name|malloc
argument_list|(
name|params
operator|.
name|alloc_len
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"trying to do CDIOCSETPATCH\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdgetmode
argument_list|(
name|periph
argument_list|,
operator|&
name|params
argument_list|,
name|AUDIO_PAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|params
operator|.
name|mode_buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
break|break;
block|}
name|page
operator|=
name|cdgetpage
argument_list|(
operator|&
name|params
argument_list|)
expr_stmt|;
name|page
operator|->
name|audio
operator|.
name|port
index|[
name|LEFT_PORT
index|]
operator|.
name|channels
operator|=
name|arg
operator|->
name|patch
index|[
literal|0
index|]
expr_stmt|;
name|page
operator|->
name|audio
operator|.
name|port
index|[
name|RIGHT_PORT
index|]
operator|.
name|channels
operator|=
name|arg
operator|->
name|patch
index|[
literal|1
index|]
expr_stmt|;
name|page
operator|->
name|audio
operator|.
name|port
index|[
literal|2
index|]
operator|.
name|channels
operator|=
name|arg
operator|->
name|patch
index|[
literal|2
index|]
expr_stmt|;
name|page
operator|->
name|audio
operator|.
name|port
index|[
literal|3
index|]
operator|.
name|channels
operator|=
name|arg
operator|->
name|patch
index|[
literal|3
index|]
expr_stmt|;
name|error
operator|=
name|cdsetmode
argument_list|(
name|periph
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|params
operator|.
name|mode_buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CDIOCGETVOL
case|:
block|{
name|struct
name|ioc_vol
modifier|*
name|arg
init|=
operator|(
expr|struct
name|ioc_vol
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|cd_mode_params
name|params
decl_stmt|;
name|union
name|cd_pages
modifier|*
name|page
decl_stmt|;
name|params
operator|.
name|alloc_len
operator|=
sizeof|sizeof
argument_list|(
expr|union
name|cd_mode_data_6_10
argument_list|)
expr_stmt|;
name|params
operator|.
name|mode_buf
operator|=
name|malloc
argument_list|(
name|params
operator|.
name|alloc_len
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"trying to do CDIOCGETVOL\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdgetmode
argument_list|(
name|periph
argument_list|,
operator|&
name|params
argument_list|,
name|AUDIO_PAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|params
operator|.
name|mode_buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
break|break;
block|}
name|page
operator|=
name|cdgetpage
argument_list|(
operator|&
name|params
argument_list|)
expr_stmt|;
name|arg
operator|->
name|vol
index|[
name|LEFT_PORT
index|]
operator|=
name|page
operator|->
name|audio
operator|.
name|port
index|[
name|LEFT_PORT
index|]
operator|.
name|volume
expr_stmt|;
name|arg
operator|->
name|vol
index|[
name|RIGHT_PORT
index|]
operator|=
name|page
operator|->
name|audio
operator|.
name|port
index|[
name|RIGHT_PORT
index|]
operator|.
name|volume
expr_stmt|;
name|arg
operator|->
name|vol
index|[
literal|2
index|]
operator|=
name|page
operator|->
name|audio
operator|.
name|port
index|[
literal|2
index|]
operator|.
name|volume
expr_stmt|;
name|arg
operator|->
name|vol
index|[
literal|3
index|]
operator|=
name|page
operator|->
name|audio
operator|.
name|port
index|[
literal|3
index|]
operator|.
name|volume
expr_stmt|;
name|free
argument_list|(
name|params
operator|.
name|mode_buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CDIOCSETVOL
case|:
block|{
name|struct
name|ioc_vol
modifier|*
name|arg
init|=
operator|(
expr|struct
name|ioc_vol
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|cd_mode_params
name|params
decl_stmt|;
name|union
name|cd_pages
modifier|*
name|page
decl_stmt|;
name|params
operator|.
name|alloc_len
operator|=
sizeof|sizeof
argument_list|(
expr|union
name|cd_mode_data_6_10
argument_list|)
expr_stmt|;
name|params
operator|.
name|mode_buf
operator|=
name|malloc
argument_list|(
name|params
operator|.
name|alloc_len
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"trying to do CDIOCSETVOL\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdgetmode
argument_list|(
name|periph
argument_list|,
operator|&
name|params
argument_list|,
name|AUDIO_PAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|params
operator|.
name|mode_buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
break|break;
block|}
name|page
operator|=
name|cdgetpage
argument_list|(
operator|&
name|params
argument_list|)
expr_stmt|;
name|page
operator|->
name|audio
operator|.
name|port
index|[
name|LEFT_PORT
index|]
operator|.
name|channels
operator|=
name|CHANNEL_0
expr_stmt|;
name|page
operator|->
name|audio
operator|.
name|port
index|[
name|LEFT_PORT
index|]
operator|.
name|volume
operator|=
name|arg
operator|->
name|vol
index|[
name|LEFT_PORT
index|]
expr_stmt|;
name|page
operator|->
name|audio
operator|.
name|port
index|[
name|RIGHT_PORT
index|]
operator|.
name|channels
operator|=
name|CHANNEL_1
expr_stmt|;
name|page
operator|->
name|audio
operator|.
name|port
index|[
name|RIGHT_PORT
index|]
operator|.
name|volume
operator|=
name|arg
operator|->
name|vol
index|[
name|RIGHT_PORT
index|]
expr_stmt|;
name|page
operator|->
name|audio
operator|.
name|port
index|[
literal|2
index|]
operator|.
name|volume
operator|=
name|arg
operator|->
name|vol
index|[
literal|2
index|]
expr_stmt|;
name|page
operator|->
name|audio
operator|.
name|port
index|[
literal|3
index|]
operator|.
name|volume
operator|=
name|arg
operator|->
name|vol
index|[
literal|3
index|]
expr_stmt|;
name|error
operator|=
name|cdsetmode
argument_list|(
name|periph
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|params
operator|.
name|mode_buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CDIOCSETMONO
case|:
block|{
name|struct
name|cd_mode_params
name|params
decl_stmt|;
name|union
name|cd_pages
modifier|*
name|page
decl_stmt|;
name|params
operator|.
name|alloc_len
operator|=
sizeof|sizeof
argument_list|(
expr|union
name|cd_mode_data_6_10
argument_list|)
expr_stmt|;
name|params
operator|.
name|mode_buf
operator|=
name|malloc
argument_list|(
name|params
operator|.
name|alloc_len
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"trying to do CDIOCSETMONO\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdgetmode
argument_list|(
name|periph
argument_list|,
operator|&
name|params
argument_list|,
name|AUDIO_PAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|params
operator|.
name|mode_buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
break|break;
block|}
name|page
operator|=
name|cdgetpage
argument_list|(
operator|&
name|params
argument_list|)
expr_stmt|;
name|page
operator|->
name|audio
operator|.
name|port
index|[
name|LEFT_PORT
index|]
operator|.
name|channels
operator|=
name|LEFT_CHANNEL
operator||
name|RIGHT_CHANNEL
expr_stmt|;
name|page
operator|->
name|audio
operator|.
name|port
index|[
name|RIGHT_PORT
index|]
operator|.
name|channels
operator|=
name|LEFT_CHANNEL
operator||
name|RIGHT_CHANNEL
expr_stmt|;
name|page
operator|->
name|audio
operator|.
name|port
index|[
literal|2
index|]
operator|.
name|channels
operator|=
literal|0
expr_stmt|;
name|page
operator|->
name|audio
operator|.
name|port
index|[
literal|3
index|]
operator|.
name|channels
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|cdsetmode
argument_list|(
name|periph
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|params
operator|.
name|mode_buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CDIOCSETSTEREO
case|:
block|{
name|struct
name|cd_mode_params
name|params
decl_stmt|;
name|union
name|cd_pages
modifier|*
name|page
decl_stmt|;
name|params
operator|.
name|alloc_len
operator|=
sizeof|sizeof
argument_list|(
expr|union
name|cd_mode_data_6_10
argument_list|)
expr_stmt|;
name|params
operator|.
name|mode_buf
operator|=
name|malloc
argument_list|(
name|params
operator|.
name|alloc_len
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"trying to do CDIOCSETSTEREO\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdgetmode
argument_list|(
name|periph
argument_list|,
operator|&
name|params
argument_list|,
name|AUDIO_PAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|params
operator|.
name|mode_buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
break|break;
block|}
name|page
operator|=
name|cdgetpage
argument_list|(
operator|&
name|params
argument_list|)
expr_stmt|;
name|page
operator|->
name|audio
operator|.
name|port
index|[
name|LEFT_PORT
index|]
operator|.
name|channels
operator|=
name|LEFT_CHANNEL
expr_stmt|;
name|page
operator|->
name|audio
operator|.
name|port
index|[
name|RIGHT_PORT
index|]
operator|.
name|channels
operator|=
name|RIGHT_CHANNEL
expr_stmt|;
name|page
operator|->
name|audio
operator|.
name|port
index|[
literal|2
index|]
operator|.
name|channels
operator|=
literal|0
expr_stmt|;
name|page
operator|->
name|audio
operator|.
name|port
index|[
literal|3
index|]
operator|.
name|channels
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|cdsetmode
argument_list|(
name|periph
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|params
operator|.
name|mode_buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CDIOCSETMUTE
case|:
block|{
name|struct
name|cd_mode_params
name|params
decl_stmt|;
name|union
name|cd_pages
modifier|*
name|page
decl_stmt|;
name|params
operator|.
name|alloc_len
operator|=
sizeof|sizeof
argument_list|(
expr|union
name|cd_mode_data_6_10
argument_list|)
expr_stmt|;
name|params
operator|.
name|mode_buf
operator|=
name|malloc
argument_list|(
name|params
operator|.
name|alloc_len
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"trying to do CDIOCSETMUTE\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdgetmode
argument_list|(
name|periph
argument_list|,
operator|&
name|params
argument_list|,
name|AUDIO_PAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
operator|&
name|params
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
break|break;
block|}
name|page
operator|=
name|cdgetpage
argument_list|(
operator|&
name|params
argument_list|)
expr_stmt|;
name|page
operator|->
name|audio
operator|.
name|port
index|[
name|LEFT_PORT
index|]
operator|.
name|channels
operator|=
literal|0
expr_stmt|;
name|page
operator|->
name|audio
operator|.
name|port
index|[
name|RIGHT_PORT
index|]
operator|.
name|channels
operator|=
literal|0
expr_stmt|;
name|page
operator|->
name|audio
operator|.
name|port
index|[
literal|2
index|]
operator|.
name|channels
operator|=
literal|0
expr_stmt|;
name|page
operator|->
name|audio
operator|.
name|port
index|[
literal|3
index|]
operator|.
name|channels
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|cdsetmode
argument_list|(
name|periph
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|params
operator|.
name|mode_buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CDIOCSETLEFT
case|:
block|{
name|struct
name|cd_mode_params
name|params
decl_stmt|;
name|union
name|cd_pages
modifier|*
name|page
decl_stmt|;
name|params
operator|.
name|alloc_len
operator|=
sizeof|sizeof
argument_list|(
expr|union
name|cd_mode_data_6_10
argument_list|)
expr_stmt|;
name|params
operator|.
name|mode_buf
operator|=
name|malloc
argument_list|(
name|params
operator|.
name|alloc_len
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"trying to do CDIOCSETLEFT\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdgetmode
argument_list|(
name|periph
argument_list|,
operator|&
name|params
argument_list|,
name|AUDIO_PAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|params
operator|.
name|mode_buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
break|break;
block|}
name|page
operator|=
name|cdgetpage
argument_list|(
operator|&
name|params
argument_list|)
expr_stmt|;
name|page
operator|->
name|audio
operator|.
name|port
index|[
name|LEFT_PORT
index|]
operator|.
name|channels
operator|=
name|LEFT_CHANNEL
expr_stmt|;
name|page
operator|->
name|audio
operator|.
name|port
index|[
name|RIGHT_PORT
index|]
operator|.
name|channels
operator|=
name|LEFT_CHANNEL
expr_stmt|;
name|page
operator|->
name|audio
operator|.
name|port
index|[
literal|2
index|]
operator|.
name|channels
operator|=
literal|0
expr_stmt|;
name|page
operator|->
name|audio
operator|.
name|port
index|[
literal|3
index|]
operator|.
name|channels
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|cdsetmode
argument_list|(
name|periph
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|params
operator|.
name|mode_buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CDIOCSETRIGHT
case|:
block|{
name|struct
name|cd_mode_params
name|params
decl_stmt|;
name|union
name|cd_pages
modifier|*
name|page
decl_stmt|;
name|params
operator|.
name|alloc_len
operator|=
sizeof|sizeof
argument_list|(
expr|union
name|cd_mode_data_6_10
argument_list|)
expr_stmt|;
name|params
operator|.
name|mode_buf
operator|=
name|malloc
argument_list|(
name|params
operator|.
name|alloc_len
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"trying to do CDIOCSETRIGHT\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdgetmode
argument_list|(
name|periph
argument_list|,
operator|&
name|params
argument_list|,
name|AUDIO_PAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|params
operator|.
name|mode_buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
break|break;
block|}
name|page
operator|=
name|cdgetpage
argument_list|(
operator|&
name|params
argument_list|)
expr_stmt|;
name|page
operator|->
name|audio
operator|.
name|port
index|[
name|LEFT_PORT
index|]
operator|.
name|channels
operator|=
name|RIGHT_CHANNEL
expr_stmt|;
name|page
operator|->
name|audio
operator|.
name|port
index|[
name|RIGHT_PORT
index|]
operator|.
name|channels
operator|=
name|RIGHT_CHANNEL
expr_stmt|;
name|page
operator|->
name|audio
operator|.
name|port
index|[
literal|2
index|]
operator|.
name|channels
operator|=
literal|0
expr_stmt|;
name|page
operator|->
name|audio
operator|.
name|port
index|[
literal|3
index|]
operator|.
name|channels
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|cdsetmode
argument_list|(
name|periph
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|params
operator|.
name|mode_buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CDIOCRESUME
case|:
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdpause
argument_list|(
name|periph
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
break|break;
case|case
name|CDIOCPAUSE
case|:
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdpause
argument_list|(
name|periph
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
break|break;
case|case
name|CDIOCSTART
case|:
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdstartunit
argument_list|(
name|periph
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
break|break;
case|case
name|CDIOCCLOSE
case|:
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdstartunit
argument_list|(
name|periph
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
break|break;
case|case
name|CDIOCSTOP
case|:
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdstopunit
argument_list|(
name|periph
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
break|break;
case|case
name|CDIOCEJECT
case|:
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdstopunit
argument_list|(
name|periph
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
break|break;
case|case
name|CDIOCALLOW
case|:
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|cdprevent
argument_list|(
name|periph
argument_list|,
name|PR_ALLOW
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
break|break;
case|case
name|CDIOCPREVENT
case|:
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|cdprevent
argument_list|(
name|periph
argument_list|,
name|PR_PREVENT
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
break|break;
case|case
name|CDIOCSETDEBUG
case|:
comment|/* sc_link->flags |= (SDEV_DB1 | SDEV_DB2); */
name|error
operator|=
name|ENOTTY
expr_stmt|;
break|break;
case|case
name|CDIOCCLRDEBUG
case|:
comment|/* sc_link->flags&= ~(SDEV_DB1 | SDEV_DB2); */
name|error
operator|=
name|ENOTTY
expr_stmt|;
break|break;
case|case
name|CDIOCRESET
case|:
comment|/* return (cd_reset(periph)); */
name|error
operator|=
name|ENOTTY
expr_stmt|;
break|break;
case|case
name|CDRIOCREADSPEED
case|:
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdsetspeed
argument_list|(
name|periph
argument_list|,
operator|*
operator|(
name|u_int32_t
operator|*
operator|)
name|addr
argument_list|,
name|CDR_MAX_SPEED
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
break|break;
case|case
name|CDRIOCWRITESPEED
case|:
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdsetspeed
argument_list|(
name|periph
argument_list|,
name|CDR_MAX_SPEED
argument_list|,
operator|*
operator|(
name|u_int32_t
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
break|break;
case|case
name|DVDIOCSENDKEY
case|:
case|case
name|DVDIOCREPORTKEY
case|:
block|{
name|struct
name|dvd_authinfo
modifier|*
name|authinfo
decl_stmt|;
name|authinfo
operator|=
operator|(
expr|struct
name|dvd_authinfo
operator|*
operator|)
name|addr
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|DVDIOCREPORTKEY
condition|)
name|error
operator|=
name|cdreportkey
argument_list|(
name|periph
argument_list|,
name|authinfo
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|cdsendkey
argument_list|(
name|periph
argument_list|,
name|authinfo
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DVDIOCREADSTRUCTURE
case|:
block|{
name|struct
name|dvd_struct
modifier|*
name|dvdstruct
decl_stmt|;
name|dvdstruct
operator|=
operator|(
expr|struct
name|dvd_struct
operator|*
operator|)
name|addr
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdreaddvdstructure
argument_list|(
name|periph
argument_list|,
name|dvdstruct
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|error
operator|=
name|cam_periph_ioctl
argument_list|(
name|periph
argument_list|,
name|cmd
argument_list|,
name|addr
argument_list|,
name|cderror
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
break|break;
block|}
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|cam_periph_unhold
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"leaving cdioctl\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"scsi_cd.c::ioctl cmd=%08lx error=%d\n"
argument_list|,
name|cmd
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cdprevent
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|action
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|cd_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"entering cdprevent\n"
operator|)
argument_list|)
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|cd_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|action
operator|==
name|PR_ALLOW
operator|)
operator|&&
operator|(
name|softc
operator|->
name|flags
operator|&
name|CD_FLAG_DISC_LOCKED
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|action
operator|==
name|PR_PREVENT
operator|)
operator|&&
operator|(
name|softc
operator|->
name|flags
operator|&
name|CD_FLAG_DISC_LOCKED
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
return|return;
block|}
name|ccb
operator|=
name|cdgetccb
argument_list|(
name|periph
argument_list|,
comment|/* priority */
literal|1
argument_list|)
expr_stmt|;
name|scsi_prevent
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/*retries*/
literal|1
argument_list|,
name|cddone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|action
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
literal|60000
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdrunccb
argument_list|(
name|ccb
argument_list|,
name|cderror
argument_list|,
comment|/*cam_flags*/
name|CAM_RETRY_SELTO
argument_list|,
comment|/*sense_flags*/
name|SF_RETRY_UA
operator||
name|SF_NO_PRINT
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|action
operator|==
name|PR_ALLOW
condition|)
name|softc
operator|->
name|flags
operator|&=
operator|~
name|CD_FLAG_DISC_LOCKED
expr_stmt|;
else|else
name|softc
operator|->
name|flags
operator||=
name|CD_FLAG_DISC_LOCKED
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * XXX: the disk media and sector size is only really able to change  * XXX: while the device is closed.  */
end_comment

begin_function
specifier|static
name|int
name|cdcheckmedia
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|struct
name|cd_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ioc_toc_header
modifier|*
name|toch
decl_stmt|;
name|struct
name|cd_toc_single
name|leadout
decl_stmt|;
name|u_int32_t
name|size
decl_stmt|,
name|toclen
decl_stmt|;
name|int
name|error
decl_stmt|,
name|num_entries
decl_stmt|,
name|cdindex
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|cd_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|cdprevent
argument_list|(
name|periph
argument_list|,
name|PR_PREVENT
argument_list|)
expr_stmt|;
name|softc
operator|->
name|disk
operator|->
name|d_maxsize
operator|=
name|DFLTPHYS
expr_stmt|;
name|softc
operator|->
name|disk
operator|->
name|d_sectorsize
operator|=
literal|2048
expr_stmt|;
name|softc
operator|->
name|disk
operator|->
name|d_mediasize
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Get the disc size and block size.  If we can't get it, we don't 	 * have media, most likely. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|cdsize
argument_list|(
name|periph
argument_list|,
operator|&
name|size
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|softc
operator|->
name|flags
operator|&=
operator|~
operator|(
name|CD_FLAG_VALID_MEDIA
operator||
name|CD_FLAG_VALID_TOC
operator|)
expr_stmt|;
name|cdprevent
argument_list|(
name|periph
argument_list|,
name|PR_ALLOW
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
else|else
name|softc
operator|->
name|flags
operator||=
name|CD_FLAG_VALID_MEDIA
expr_stmt|;
comment|/* 	 * Now we check the table of contents.  This (currently) is only 	 * used for the CDIOCPLAYTRACKS ioctl.  It may be used later to do 	 * things like present a separate entry in /dev for each track, 	 * like that acd(4) driver does. 	 */
name|bzero
argument_list|(
operator|&
name|softc
operator|->
name|toc
argument_list|,
sizeof|sizeof
argument_list|(
name|softc
operator|->
name|toc
argument_list|)
argument_list|)
expr_stmt|;
name|toch
operator|=
operator|&
name|softc
operator|->
name|toc
operator|.
name|header
expr_stmt|;
comment|/* 	 * We will get errors here for media that doesn't have a table of 	 * contents.  According to the MMC-3 spec: "When a Read TOC/PMA/ATIP 	 * command is presented for a DDCD/CD-R/RW media, where the first TOC 	 * has not been recorded (no complete session) and the Format codes 	 * 0000b, 0001b, or 0010b are specified, this command shall be rejected 	 * with an INVALID FIELD IN CDB.  Devices that are not capable of 	 * reading an incomplete session on DDC/CD-R/RW media shall report 	 * CANNOT READ MEDIUM - INCOMPATIBLE FORMAT." 	 * 	 * So this isn't fatal if we can't read the table of contents, it 	 * just means that the user won't be able to issue the play tracks 	 * ioctl, and likely lots of other stuff won't work either.  They 	 * need to burn the CD before we can do a whole lot with it.  So 	 * we don't print anything here if we get an error back. 	 */
name|error
operator|=
name|cdreadtoc
argument_list|(
name|periph
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
name|toch
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|toch
argument_list|)
argument_list|,
name|SF_NO_PRINT
argument_list|)
expr_stmt|;
comment|/* 	 * Errors in reading the table of contents aren't fatal, we just 	 * won't have a valid table of contents cached. 	 */
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|softc
operator|->
name|toc
argument_list|,
sizeof|sizeof
argument_list|(
name|softc
operator|->
name|toc
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
name|softc
operator|->
name|quirks
operator|&
name|CD_Q_BCD_TRACKS
condition|)
block|{
name|toch
operator|->
name|starting_track
operator|=
name|bcd2bin
argument_list|(
name|toch
operator|->
name|starting_track
argument_list|)
expr_stmt|;
name|toch
operator|->
name|ending_track
operator|=
name|bcd2bin
argument_list|(
name|toch
operator|->
name|ending_track
argument_list|)
expr_stmt|;
block|}
comment|/* Number of TOC entries, plus leadout */
name|num_entries
operator|=
operator|(
name|toch
operator|->
name|ending_track
operator|-
name|toch
operator|->
name|starting_track
operator|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|num_entries
operator|<=
literal|0
condition|)
goto|goto
name|bailout
goto|;
name|toclen
operator|=
name|num_entries
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|cd_toc_entry
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdreadtoc
argument_list|(
name|periph
argument_list|,
name|CD_MSF_FORMAT
argument_list|,
name|toch
operator|->
name|starting_track
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|softc
operator|->
name|toc
argument_list|,
name|toclen
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|toch
argument_list|)
argument_list|,
name|SF_NO_PRINT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|softc
operator|->
name|toc
argument_list|,
sizeof|sizeof
argument_list|(
name|softc
operator|->
name|toc
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
name|softc
operator|->
name|quirks
operator|&
name|CD_Q_BCD_TRACKS
condition|)
block|{
name|toch
operator|->
name|starting_track
operator|=
name|bcd2bin
argument_list|(
name|toch
operator|->
name|starting_track
argument_list|)
expr_stmt|;
name|toch
operator|->
name|ending_track
operator|=
name|bcd2bin
argument_list|(
name|toch
operator|->
name|ending_track
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * XXX KDM is this necessary?  Probably only if the drive doesn't 	 * return leadout information with the table of contents. 	 */
name|cdindex
operator|=
name|toch
operator|->
name|starting_track
operator|+
name|num_entries
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|cdindex
operator|==
name|toch
operator|->
name|ending_track
operator|+
literal|1
condition|)
block|{
name|error
operator|=
name|cdreadtoc
argument_list|(
name|periph
argument_list|,
name|CD_MSF_FORMAT
argument_list|,
name|LEADOUT
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|leadout
argument_list|,
sizeof|sizeof
argument_list|(
name|leadout
argument_list|)
argument_list|,
name|SF_NO_PRINT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|softc
operator|->
name|toc
operator|.
name|entries
index|[
name|cdindex
operator|-
name|toch
operator|->
name|starting_track
index|]
operator|=
name|leadout
operator|.
name|entry
expr_stmt|;
block|}
if|if
condition|(
name|softc
operator|->
name|quirks
operator|&
name|CD_Q_BCD_TRACKS
condition|)
block|{
for|for
control|(
name|cdindex
operator|=
literal|0
init|;
name|cdindex
operator|<
name|num_entries
operator|-
literal|1
condition|;
name|cdindex
operator|++
control|)
block|{
name|softc
operator|->
name|toc
operator|.
name|entries
index|[
name|cdindex
index|]
operator|.
name|track
operator|=
name|bcd2bin
argument_list|(
name|softc
operator|->
name|toc
operator|.
name|entries
index|[
name|cdindex
index|]
operator|.
name|track
argument_list|)
expr_stmt|;
block|}
block|}
name|softc
operator|->
name|flags
operator||=
name|CD_FLAG_VALID_TOC
expr_stmt|;
name|softc
operator|->
name|disk
operator|->
name|d_maxsize
operator|=
name|DFLTPHYS
expr_stmt|;
name|softc
operator|->
name|disk
operator|->
name|d_sectorsize
operator|=
name|softc
operator|->
name|params
operator|.
name|blksize
expr_stmt|;
name|softc
operator|->
name|disk
operator|->
name|d_mediasize
operator|=
operator|(
name|off_t
operator|)
name|softc
operator|->
name|params
operator|.
name|blksize
operator|*
name|softc
operator|->
name|params
operator|.
name|disksize
expr_stmt|;
name|bailout
label|:
comment|/* 	 * We unconditionally (re)set the blocksize each time the 	 * CD device is opened.  This is because the CD can change, 	 * and therefore the blocksize might change. 	 * XXX problems here if some slice or partition is still 	 * open with the old size? 	 */
if|if
condition|(
operator|(
name|softc
operator|->
name|disk
operator|->
name|d_devstat
operator|->
name|flags
operator|&
name|DEVSTAT_BS_UNAVAILABLE
operator|)
operator|!=
literal|0
condition|)
name|softc
operator|->
name|disk
operator|->
name|d_devstat
operator|->
name|flags
operator|&=
operator|~
name|DEVSTAT_BS_UNAVAILABLE
expr_stmt|;
name|softc
operator|->
name|disk
operator|->
name|d_devstat
operator|->
name|block_size
operator|=
name|softc
operator|->
name|params
operator|.
name|blksize
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cdsize
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|u_int32_t
modifier|*
name|size
parameter_list|)
block|{
name|struct
name|cd_softc
modifier|*
name|softc
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|scsi_read_capacity_data
modifier|*
name|rcap_buf
decl_stmt|;
name|int
name|error
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"entering cdsize\n"
operator|)
argument_list|)
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|cd_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|ccb
operator|=
name|cdgetccb
argument_list|(
name|periph
argument_list|,
comment|/* priority */
literal|1
argument_list|)
expr_stmt|;
comment|/* XXX Should be M_WAITOK */
name|rcap_buf
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_capacity_data
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcap_buf
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|scsi_read_capacity
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/*retries*/
literal|1
argument_list|,
name|cddone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|rcap_buf
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
literal|20000
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdrunccb
argument_list|(
name|ccb
argument_list|,
name|cderror
argument_list|,
comment|/*cam_flags*/
name|CAM_RETRY_SELTO
argument_list|,
comment|/*sense_flags*/
name|SF_RETRY_UA
operator||
name|SF_NO_PRINT
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|softc
operator|->
name|params
operator|.
name|disksize
operator|=
name|scsi_4btoul
argument_list|(
name|rcap_buf
operator|->
name|addr
argument_list|)
operator|+
literal|1
expr_stmt|;
name|softc
operator|->
name|params
operator|.
name|blksize
operator|=
name|scsi_4btoul
argument_list|(
name|rcap_buf
operator|->
name|length
argument_list|)
expr_stmt|;
comment|/* 	 * SCSI-3 mandates that the reported blocksize shall be 2048. 	 * Older drives sometimes report funny values, trim it down to 	 * 2048, or other parts of the kernel will get confused. 	 * 	 * XXX we leave drives alone that might report 512 bytes, as 	 * well as drives reporting more weird sizes like perhaps 4K. 	 */
if|if
condition|(
name|softc
operator|->
name|params
operator|.
name|blksize
operator|>
literal|2048
operator|&&
name|softc
operator|->
name|params
operator|.
name|blksize
operator|<=
literal|2352
condition|)
name|softc
operator|->
name|params
operator|.
name|blksize
operator|=
literal|2048
expr_stmt|;
name|free
argument_list|(
name|rcap_buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
operator|*
name|size
operator|=
name|softc
operator|->
name|params
operator|.
name|disksize
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cd6byteworkaround
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|u_int8_t
modifier|*
name|cdb
decl_stmt|;
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|cd_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|cd_mode_params
modifier|*
name|params
decl_stmt|;
name|int
name|frozen
decl_stmt|,
name|found
decl_stmt|;
name|periph
operator|=
name|xpt_path_periph
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|cd_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|cdb
operator|=
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_POINTER
operator|)
operator|||
operator|(
operator|(
name|cdb
index|[
literal|0
index|]
operator|!=
name|MODE_SENSE_6
operator|)
operator|&&
operator|(
name|cdb
index|[
literal|0
index|]
operator|!=
name|MODE_SELECT_6
operator|)
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Because there is no convenient place to stash the overall 	 * cd_mode_params structure pointer, we have to grab it like this. 	 * This means that ALL MODE_SENSE and MODE_SELECT requests in the 	 * cd(4) driver MUST go through cdgetmode() and cdsetmode()! 	 * 	 * XXX It would be nice if, at some point, we could increase the 	 * number of available peripheral private pointers.  Both pointers 	 * are currently used in most every peripheral driver. 	 */
name|found
operator|=
literal|0
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|params
argument_list|,
argument|&softc->mode_queue
argument_list|,
argument|links
argument_list|)
block|{
if|if
condition|(
name|params
operator|->
name|mode_buf
operator|==
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * This shouldn't happen.  All mode sense and mode select 	 * operations in the cd(4) driver MUST go through cdgetmode() and 	 * cdsetmode()! 	 */
if|if
condition|(
name|found
operator|==
literal|0
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"mode buffer not found in mode queue!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|params
operator|->
name|cdb_size
operator|=
literal|10
expr_stmt|;
name|softc
operator|->
name|minimum_command_size
operator|=
literal|10
expr_stmt|;
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"%s(6) failed, increasing minimum CDB size to 10 bytes\n"
argument_list|,
operator|(
name|cdb
index|[
literal|0
index|]
operator|==
name|MODE_SENSE_6
operator|)
condition|?
literal|"MODE_SENSE"
else|:
literal|"MODE_SELECT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdb
index|[
literal|0
index|]
operator|==
name|MODE_SENSE_6
condition|)
block|{
name|struct
name|scsi_mode_sense_10
name|ms10
decl_stmt|;
name|struct
name|scsi_mode_sense_6
modifier|*
name|ms6
decl_stmt|;
name|int
name|len
decl_stmt|;
name|ms6
operator|=
operator|(
expr|struct
name|scsi_mode_sense_6
operator|*
operator|)
name|cdb
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|ms10
argument_list|,
sizeof|sizeof
argument_list|(
name|ms10
argument_list|)
argument_list|)
expr_stmt|;
name|ms10
operator|.
name|opcode
operator|=
name|MODE_SENSE_10
expr_stmt|;
name|ms10
operator|.
name|byte2
operator|=
name|ms6
operator|->
name|byte2
expr_stmt|;
name|ms10
operator|.
name|page
operator|=
name|ms6
operator|->
name|page
expr_stmt|;
comment|/* 		 * 10 byte mode header, block descriptor, 		 * sizeof(union cd_pages) 		 */
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|cd_mode_data_10
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
operator|=
name|len
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|len
argument_list|,
name|ms10
operator|.
name|length
argument_list|)
expr_stmt|;
name|ms10
operator|.
name|control
operator|=
name|ms6
operator|->
name|control
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|ms10
argument_list|,
name|cdb
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|csio
operator|.
name|cdb_len
operator|=
literal|10
expr_stmt|;
block|}
else|else
block|{
name|struct
name|scsi_mode_select_10
name|ms10
decl_stmt|;
name|struct
name|scsi_mode_select_6
modifier|*
name|ms6
decl_stmt|;
name|struct
name|scsi_mode_header_6
modifier|*
name|header6
decl_stmt|;
name|struct
name|scsi_mode_header_10
modifier|*
name|header10
decl_stmt|;
name|struct
name|scsi_mode_page_header
modifier|*
name|page_header
decl_stmt|;
name|int
name|blk_desc_len
decl_stmt|,
name|page_num
decl_stmt|,
name|page_size
decl_stmt|,
name|len
decl_stmt|;
name|ms6
operator|=
operator|(
expr|struct
name|scsi_mode_select_6
operator|*
operator|)
name|cdb
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|ms10
argument_list|,
sizeof|sizeof
argument_list|(
name|ms10
argument_list|)
argument_list|)
expr_stmt|;
name|ms10
operator|.
name|opcode
operator|=
name|MODE_SELECT_10
expr_stmt|;
name|ms10
operator|.
name|byte2
operator|=
name|ms6
operator|->
name|byte2
expr_stmt|;
name|header6
operator|=
operator|(
expr|struct
name|scsi_mode_header_6
operator|*
operator|)
name|params
operator|->
name|mode_buf
expr_stmt|;
name|header10
operator|=
operator|(
expr|struct
name|scsi_mode_header_10
operator|*
operator|)
name|params
operator|->
name|mode_buf
expr_stmt|;
name|page_header
operator|=
name|find_mode_page_6
argument_list|(
name|header6
argument_list|)
expr_stmt|;
name|page_num
operator|=
name|page_header
operator|->
name|page_code
expr_stmt|;
name|blk_desc_len
operator|=
name|header6
operator|->
name|blk_desc_len
expr_stmt|;
name|page_size
operator|=
name|cdgetpagesize
argument_list|(
name|page_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|page_size
operator|!=
operator|(
name|page_header
operator|->
name|page_length
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|page_header
argument_list|)
operator|)
condition|)
name|page_size
operator|=
name|page_header
operator|->
name|page_length
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|page_header
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|header10
argument_list|)
operator|+
name|blk_desc_len
operator|+
name|page_size
expr_stmt|;
name|len
operator|=
name|min
argument_list|(
name|params
operator|->
name|alloc_len
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* 		 * Since the 6 byte parameter header is shorter than the 10 		 * byte parameter header, we need to copy the actual mode 		 * page data, and the block descriptor, if any, so things wind 		 * up in the right place.  The regions will overlap, but 		 * bcopy() does the right thing. 		 */
name|bcopy
argument_list|(
name|params
operator|->
name|mode_buf
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|header6
argument_list|)
argument_list|,
name|params
operator|->
name|mode_buf
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|header10
argument_list|)
argument_list|,
name|len
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|header10
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure these fields are set correctly. */
name|scsi_ulto2b
argument_list|(
literal|0
argument_list|,
name|header10
operator|->
name|data_length
argument_list|)
expr_stmt|;
name|header10
operator|->
name|medium_type
operator|=
literal|0
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|blk_desc_len
argument_list|,
name|header10
operator|->
name|blk_desc_len
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
operator|=
name|len
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|len
argument_list|,
name|ms10
operator|.
name|length
argument_list|)
expr_stmt|;
name|ms10
operator|.
name|control
operator|=
name|ms6
operator|->
name|control
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|ms10
argument_list|,
name|cdb
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|csio
operator|.
name|cdb_len
operator|=
literal|10
expr_stmt|;
block|}
name|frozen
operator|=
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|!=
literal|0
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQUEUE_REQ
expr_stmt|;
name|xpt_action
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|frozen
condition|)
block|{
name|cam_release_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*relsim_flags*/
literal|0
argument_list|,
comment|/*openings*/
literal|0
argument_list|,
comment|/*timeout*/
literal|0
argument_list|,
comment|/*getcount_only*/
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ERESTART
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cderror
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|u_int32_t
name|cam_flags
parameter_list|,
name|u_int32_t
name|sense_flags
parameter_list|)
block|{
name|struct
name|cd_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|int
name|error
decl_stmt|;
name|periph
operator|=
name|xpt_path_periph
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|cd_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* 	 * We use a status of CAM_REQ_INVALID as shorthand -- if a 6 byte 	 * CDB comes back with this particular error, try transforming it 	 * into the 10 byte version. 	 */
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_INVALID
condition|)
block|{
name|error
operator|=
name|cd6byteworkaround
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_SCSI_STATUS_ERROR
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_AUTOSNS_VALID
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
operator|==
name|SCSI_STATUS_CHECK_COND
operator|)
operator|&&
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SENSE_PHYS
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SENSE_PTR
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|int
name|sense_key
decl_stmt|,
name|error_code
decl_stmt|,
name|asc
decl_stmt|,
name|ascq
decl_stmt|;
name|scsi_extract_sense
argument_list|(
operator|&
name|ccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|,
operator|&
name|error_code
argument_list|,
operator|&
name|sense_key
argument_list|,
operator|&
name|asc
argument_list|,
operator|&
name|ascq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sense_key
operator|==
name|SSD_KEY_ILLEGAL_REQUEST
condition|)
name|error
operator|=
name|cd6byteworkaround
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * XXX 	 * Until we have a better way of doing pack validation, 	 * don't treat UAs as errors. 	 */
name|sense_flags
operator||=
name|SF_RETRY_UA
expr_stmt|;
return|return
operator|(
name|cam_periph_error
argument_list|(
name|ccb
argument_list|,
name|cam_flags
argument_list|,
name|sense_flags
argument_list|,
operator|&
name|softc
operator|->
name|saved_ccb
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read table of contents  */
end_comment

begin_function
specifier|static
name|int
name|cdreadtoc
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|u_int32_t
name|mode
parameter_list|,
name|u_int32_t
name|start
parameter_list|,
name|u_int8_t
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|len
parameter_list|,
name|u_int32_t
name|sense_flags
parameter_list|)
block|{
name|struct
name|scsi_read_toc
modifier|*
name|scsi_cmd
decl_stmt|;
name|u_int32_t
name|ntoc
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ntoc
operator|=
name|len
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|ccb
operator|=
name|cdgetccb
argument_list|(
name|periph
argument_list|,
comment|/* priority */
literal|1
argument_list|)
expr_stmt|;
name|csio
operator|=
operator|&
name|ccb
operator|->
name|csio
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
comment|/* retries */
literal|1
argument_list|,
comment|/* cbfcnp */
name|cddone
argument_list|,
comment|/* flags */
name|CAM_DIR_IN
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* data_ptr */
name|data
argument_list|,
comment|/* dxfer_len */
name|len
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_toc
argument_list|)
argument_list|,
comment|/* timeout */
literal|50000
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_read_toc
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|CD_MSF_FORMAT
condition|)
name|scsi_cmd
operator|->
name|byte2
operator||=
name|CD_MSF
expr_stmt|;
name|scsi_cmd
operator|->
name|from_track
operator|=
name|start
expr_stmt|;
comment|/* scsi_ulto2b(ntoc, (u_int8_t *)scsi_cmd->data_len); */
name|scsi_cmd
operator|->
name|data_len
index|[
literal|0
index|]
operator|=
operator|(
name|ntoc
operator|)
operator|>>
literal|8
expr_stmt|;
name|scsi_cmd
operator|->
name|data_len
index|[
literal|1
index|]
operator|=
operator|(
name|ntoc
operator|)
operator|&
literal|0xff
expr_stmt|;
name|scsi_cmd
operator|->
name|op_code
operator|=
name|READ_TOC
expr_stmt|;
name|error
operator|=
name|cdrunccb
argument_list|(
name|ccb
argument_list|,
name|cderror
argument_list|,
comment|/*cam_flags*/
name|CAM_RETRY_SELTO
argument_list|,
comment|/*sense_flags*/
name|SF_RETRY_UA
operator||
name|sense_flags
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cdreadsubchannel
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|u_int32_t
name|mode
parameter_list|,
name|u_int32_t
name|format
parameter_list|,
name|int
name|track
parameter_list|,
name|struct
name|cd_sub_channel_info
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|len
parameter_list|)
block|{
name|struct
name|scsi_read_subchannel
modifier|*
name|scsi_cmd
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|ccb
operator|=
name|cdgetccb
argument_list|(
name|periph
argument_list|,
comment|/* priority */
literal|1
argument_list|)
expr_stmt|;
name|csio
operator|=
operator|&
name|ccb
operator|->
name|csio
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
comment|/* retries */
literal|1
argument_list|,
comment|/* cbfcnp */
name|cddone
argument_list|,
comment|/* flags */
name|CAM_DIR_IN
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* data_ptr */
operator|(
name|u_int8_t
operator|*
operator|)
name|data
argument_list|,
comment|/* dxfer_len */
name|len
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_subchannel
argument_list|)
argument_list|,
comment|/* timeout */
literal|50000
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_read_subchannel
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|op_code
operator|=
name|READ_SUBCHANNEL
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|CD_MSF_FORMAT
condition|)
name|scsi_cmd
operator|->
name|byte1
operator||=
name|CD_MSF
expr_stmt|;
name|scsi_cmd
operator|->
name|byte2
operator|=
name|SRS_SUBQ
expr_stmt|;
name|scsi_cmd
operator|->
name|subchan_format
operator|=
name|format
expr_stmt|;
name|scsi_cmd
operator|->
name|track
operator|=
name|track
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|len
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
name|scsi_cmd
operator|->
name|data_len
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|control
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|cdrunccb
argument_list|(
name|ccb
argument_list|,
name|cderror
argument_list|,
comment|/*cam_flags*/
name|CAM_RETRY_SELTO
argument_list|,
comment|/*sense_flags*/
name|SF_RETRY_UA
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * All MODE_SENSE requests in the cd(4) driver MUST go through this  * routine.  See comments in cd6byteworkaround() for details.  */
end_comment

begin_function
specifier|static
name|int
name|cdgetmode
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|cd_mode_params
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|page
parameter_list|)
block|{
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|struct
name|cd_softc
modifier|*
name|softc
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|param_len
decl_stmt|;
name|int
name|error
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|cd_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|ccb
operator|=
name|cdgetccb
argument_list|(
name|periph
argument_list|,
comment|/* priority */
literal|1
argument_list|)
expr_stmt|;
name|csio
operator|=
operator|&
name|ccb
operator|->
name|csio
expr_stmt|;
name|data
operator|->
name|cdb_size
operator|=
name|softc
operator|->
name|minimum_command_size
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|cdb_size
operator|<
literal|10
condition|)
name|param_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|cd_mode_data
argument_list|)
expr_stmt|;
else|else
name|param_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|cd_mode_data_10
argument_list|)
expr_stmt|;
comment|/* Don't say we've got more room than we actually allocated */
name|param_len
operator|=
name|min
argument_list|(
name|param_len
argument_list|,
name|data
operator|->
name|alloc_len
argument_list|)
expr_stmt|;
name|scsi_mode_sense_len
argument_list|(
name|csio
argument_list|,
comment|/* retries */
literal|1
argument_list|,
comment|/* cbfcnp */
name|cddone
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* dbd */
literal|0
argument_list|,
comment|/* page_code */
name|SMS_PAGE_CTRL_CURRENT
argument_list|,
comment|/* page */
name|page
argument_list|,
comment|/* param_buf */
name|data
operator|->
name|mode_buf
argument_list|,
comment|/* param_len */
name|param_len
argument_list|,
comment|/* minimum_cmd_size */
name|softc
operator|->
name|minimum_command_size
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
literal|50000
argument_list|)
expr_stmt|;
comment|/* 	 * It would be nice not to have to do this, but there's no 	 * available pointer in the CCB that would allow us to stuff the 	 * mode params structure in there and retrieve it in 	 * cd6byteworkaround(), so we can set the cdb size.  The cdb size 	 * lets the caller know what CDB size we ended up using, so they 	 * can find the actual mode page offset. 	 */
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|softc
operator|->
name|mode_queue
argument_list|,
name|data
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdrunccb
argument_list|(
name|ccb
argument_list|,
name|cderror
argument_list|,
comment|/*cam_flags*/
name|CAM_RETRY_SELTO
argument_list|,
comment|/*sense_flags*/
name|SF_RETRY_UA
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE
argument_list|(
operator|&
name|softc
operator|->
name|mode_queue
argument_list|,
name|data
argument_list|,
name|cd_mode_params
argument_list|,
name|links
argument_list|)
expr_stmt|;
comment|/* 	 * This is a bit of belt-and-suspenders checking, but if we run 	 * into a situation where the target sends back multiple block 	 * descriptors, we might not have enough space in the buffer to 	 * see the whole mode page.  Better to return an error than 	 * potentially access memory beyond our malloced region. 	 */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|u_int32_t
name|data_len
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|cdb_size
operator|==
literal|10
condition|)
block|{
name|struct
name|scsi_mode_header_10
modifier|*
name|hdr10
decl_stmt|;
name|hdr10
operator|=
operator|(
expr|struct
name|scsi_mode_header_10
operator|*
operator|)
name|data
operator|->
name|mode_buf
expr_stmt|;
name|data_len
operator|=
name|scsi_2btoul
argument_list|(
name|hdr10
operator|->
name|data_length
argument_list|)
expr_stmt|;
name|data_len
operator|+=
sizeof|sizeof
argument_list|(
name|hdr10
operator|->
name|data_length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|scsi_mode_header_6
modifier|*
name|hdr6
decl_stmt|;
name|hdr6
operator|=
operator|(
expr|struct
name|scsi_mode_header_6
operator|*
operator|)
name|data
operator|->
name|mode_buf
expr_stmt|;
name|data_len
operator|=
name|hdr6
operator|->
name|data_length
expr_stmt|;
name|data_len
operator|+=
sizeof|sizeof
argument_list|(
name|hdr6
operator|->
name|data_length
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Complain if there is more mode data available than we 		 * allocated space for.  This could potentially happen if 		 * we miscalculated the page length for some reason, if the 		 * drive returns multiple block descriptors, or if it sets 		 * the data length incorrectly. 		 */
if|if
condition|(
name|data_len
operator|>
name|data
operator|->
name|alloc_len
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"allocated modepage %d length "
literal|"%d< returned length %d\n"
argument_list|,
name|page
argument_list|,
name|data
operator|->
name|alloc_len
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOSPC
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * All MODE_SELECT requests in the cd(4) driver MUST go through this  * routine.  See comments in cd6byteworkaround() for details.  */
end_comment

begin_function
specifier|static
name|int
name|cdsetmode
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|cd_mode_params
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|struct
name|cd_softc
modifier|*
name|softc
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|cdb_size
decl_stmt|,
name|param_len
decl_stmt|;
name|int
name|error
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|cd_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|ccb
operator|=
name|cdgetccb
argument_list|(
name|periph
argument_list|,
comment|/* priority */
literal|1
argument_list|)
expr_stmt|;
name|csio
operator|=
operator|&
name|ccb
operator|->
name|csio
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If the data is formatted for the 10 byte version of the mode 	 * select parameter list, we need to use the 10 byte CDB. 	 * Otherwise, we use whatever the stored minimum command size. 	 */
if|if
condition|(
name|data
operator|->
name|cdb_size
operator|==
literal|10
condition|)
name|cdb_size
operator|=
name|data
operator|->
name|cdb_size
expr_stmt|;
else|else
name|cdb_size
operator|=
name|softc
operator|->
name|minimum_command_size
expr_stmt|;
if|if
condition|(
name|cdb_size
operator|>=
literal|10
condition|)
block|{
name|struct
name|scsi_mode_header_10
modifier|*
name|mode_header
decl_stmt|;
name|u_int32_t
name|data_len
decl_stmt|;
name|mode_header
operator|=
operator|(
expr|struct
name|scsi_mode_header_10
operator|*
operator|)
name|data
operator|->
name|mode_buf
expr_stmt|;
name|data_len
operator|=
name|scsi_2btoul
argument_list|(
name|mode_header
operator|->
name|data_length
argument_list|)
expr_stmt|;
name|scsi_ulto2b
argument_list|(
literal|0
argument_list|,
name|mode_header
operator|->
name|data_length
argument_list|)
expr_stmt|;
comment|/* 		 * SONY drives do not allow a mode select with a medium_type 		 * value that has just been returned by a mode sense; use a 		 * medium_type of 0 (Default) instead. 		 */
name|mode_header
operator|->
name|medium_type
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Pass back whatever the drive passed to us, plus the size 		 * of the data length field. 		 */
name|param_len
operator|=
name|data_len
operator|+
sizeof|sizeof
argument_list|(
name|mode_header
operator|->
name|data_length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|scsi_mode_header_6
modifier|*
name|mode_header
decl_stmt|;
name|mode_header
operator|=
operator|(
expr|struct
name|scsi_mode_header_6
operator|*
operator|)
name|data
operator|->
name|mode_buf
expr_stmt|;
name|param_len
operator|=
name|mode_header
operator|->
name|data_length
operator|+
literal|1
expr_stmt|;
name|mode_header
operator|->
name|data_length
operator|=
literal|0
expr_stmt|;
comment|/* 		 * SONY drives do not allow a mode select with a medium_type 		 * value that has just been returned by a mode sense; use a 		 * medium_type of 0 (Default) instead. 		 */
name|mode_header
operator|->
name|medium_type
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Don't say we've got more room than we actually allocated */
name|param_len
operator|=
name|min
argument_list|(
name|param_len
argument_list|,
name|data
operator|->
name|alloc_len
argument_list|)
expr_stmt|;
name|scsi_mode_select_len
argument_list|(
name|csio
argument_list|,
comment|/* retries */
literal|1
argument_list|,
comment|/* cbfcnp */
name|cddone
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* scsi_page_fmt */
literal|1
argument_list|,
comment|/* save_pages */
literal|0
argument_list|,
comment|/* param_buf */
name|data
operator|->
name|mode_buf
argument_list|,
comment|/* param_len */
name|param_len
argument_list|,
comment|/* minimum_cmd_size */
name|cdb_size
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
literal|50000
argument_list|)
expr_stmt|;
comment|/* See comments in cdgetmode() and cd6byteworkaround(). */
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|softc
operator|->
name|mode_queue
argument_list|,
name|data
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdrunccb
argument_list|(
name|ccb
argument_list|,
name|cderror
argument_list|,
comment|/*cam_flags*/
name|CAM_RETRY_SELTO
argument_list|,
comment|/*sense_flags*/
name|SF_RETRY_UA
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE
argument_list|(
operator|&
name|softc
operator|->
name|mode_queue
argument_list|,
name|data
argument_list|,
name|cd_mode_params
argument_list|,
name|links
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cdplay
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|u_int32_t
name|blk
parameter_list|,
name|u_int32_t
name|len
parameter_list|)
block|{
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_int8_t
name|cdb_len
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|ccb
operator|=
name|cdgetccb
argument_list|(
name|periph
argument_list|,
comment|/* priority */
literal|1
argument_list|)
expr_stmt|;
name|csio
operator|=
operator|&
name|ccb
operator|->
name|csio
expr_stmt|;
comment|/* 	 * Use the smallest possible command to perform the operation. 	 */
if|if
condition|(
operator|(
name|len
operator|&
literal|0xffff0000
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * We can fit in a 10 byte cdb. 		 */
name|struct
name|scsi_play_10
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_play_10
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|op_code
operator|=
name|PLAY_10
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|blk
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
name|scsi_cmd
operator|->
name|blk_addr
argument_list|)
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|len
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
name|scsi_cmd
operator|->
name|xfer_len
argument_list|)
expr_stmt|;
name|cdb_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|scsi_play_12
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_play_12
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|op_code
operator|=
name|PLAY_12
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|blk
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
name|scsi_cmd
operator|->
name|blk_addr
argument_list|)
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|len
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
name|scsi_cmd
operator|->
name|xfer_len
argument_list|)
expr_stmt|;
name|cdb_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
expr_stmt|;
block|}
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
comment|/*retries*/
literal|2
argument_list|,
name|cddone
argument_list|,
comment|/*flags*/
name|CAM_DIR_NONE
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*dataptr*/
name|NULL
argument_list|,
comment|/*datalen*/
literal|0
argument_list|,
comment|/*sense_len*/
name|SSD_FULL_SIZE
argument_list|,
name|cdb_len
argument_list|,
comment|/*timeout*/
literal|50
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdrunccb
argument_list|(
name|ccb
argument_list|,
name|cderror
argument_list|,
comment|/*cam_flags*/
name|CAM_RETRY_SELTO
argument_list|,
comment|/*sense_flags*/
name|SF_RETRY_UA
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cdplaymsf
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|u_int32_t
name|startm
parameter_list|,
name|u_int32_t
name|starts
parameter_list|,
name|u_int32_t
name|startf
parameter_list|,
name|u_int32_t
name|endm
parameter_list|,
name|u_int32_t
name|ends
parameter_list|,
name|u_int32_t
name|endf
parameter_list|)
block|{
name|struct
name|scsi_play_msf
modifier|*
name|scsi_cmd
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|ccb
operator|=
name|cdgetccb
argument_list|(
name|periph
argument_list|,
comment|/* priority */
literal|1
argument_list|)
expr_stmt|;
name|csio
operator|=
operator|&
name|ccb
operator|->
name|csio
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
comment|/* retries */
literal|1
argument_list|,
comment|/* cbfcnp */
name|cddone
argument_list|,
comment|/* flags */
name|CAM_DIR_NONE
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* data_ptr */
name|NULL
argument_list|,
comment|/* dxfer_len */
literal|0
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_play_msf
argument_list|)
argument_list|,
comment|/* timeout */
literal|50000
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_play_msf
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|op_code
operator|=
name|PLAY_MSF
expr_stmt|;
name|scsi_cmd
operator|->
name|start_m
operator|=
name|startm
expr_stmt|;
name|scsi_cmd
operator|->
name|start_s
operator|=
name|starts
expr_stmt|;
name|scsi_cmd
operator|->
name|start_f
operator|=
name|startf
expr_stmt|;
name|scsi_cmd
operator|->
name|end_m
operator|=
name|endm
expr_stmt|;
name|scsi_cmd
operator|->
name|end_s
operator|=
name|ends
expr_stmt|;
name|scsi_cmd
operator|->
name|end_f
operator|=
name|endf
expr_stmt|;
name|error
operator|=
name|cdrunccb
argument_list|(
name|ccb
argument_list|,
name|cderror
argument_list|,
comment|/*cam_flags*/
name|CAM_RETRY_SELTO
argument_list|,
comment|/*sense_flags*/
name|SF_RETRY_UA
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cdplaytracks
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|u_int32_t
name|strack
parameter_list|,
name|u_int32_t
name|sindex
parameter_list|,
name|u_int32_t
name|etrack
parameter_list|,
name|u_int32_t
name|eindex
parameter_list|)
block|{
name|struct
name|scsi_play_track
modifier|*
name|scsi_cmd
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|ccb
operator|=
name|cdgetccb
argument_list|(
name|periph
argument_list|,
comment|/* priority */
literal|1
argument_list|)
expr_stmt|;
name|csio
operator|=
operator|&
name|ccb
operator|->
name|csio
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
comment|/* retries */
literal|1
argument_list|,
comment|/* cbfcnp */
name|cddone
argument_list|,
comment|/* flags */
name|CAM_DIR_NONE
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* data_ptr */
name|NULL
argument_list|,
comment|/* dxfer_len */
literal|0
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_play_track
argument_list|)
argument_list|,
comment|/* timeout */
literal|50000
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_play_track
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|op_code
operator|=
name|PLAY_TRACK
expr_stmt|;
name|scsi_cmd
operator|->
name|start_track
operator|=
name|strack
expr_stmt|;
name|scsi_cmd
operator|->
name|start_index
operator|=
name|sindex
expr_stmt|;
name|scsi_cmd
operator|->
name|end_track
operator|=
name|etrack
expr_stmt|;
name|scsi_cmd
operator|->
name|end_index
operator|=
name|eindex
expr_stmt|;
name|error
operator|=
name|cdrunccb
argument_list|(
name|ccb
argument_list|,
name|cderror
argument_list|,
comment|/*cam_flags*/
name|CAM_RETRY_SELTO
argument_list|,
comment|/*sense_flags*/
name|SF_RETRY_UA
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cdpause
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|u_int32_t
name|go
parameter_list|)
block|{
name|struct
name|scsi_pause
modifier|*
name|scsi_cmd
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|ccb
operator|=
name|cdgetccb
argument_list|(
name|periph
argument_list|,
comment|/* priority */
literal|1
argument_list|)
expr_stmt|;
name|csio
operator|=
operator|&
name|ccb
operator|->
name|csio
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
comment|/* retries */
literal|1
argument_list|,
comment|/* cbfcnp */
name|cddone
argument_list|,
comment|/* flags */
name|CAM_DIR_NONE
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* data_ptr */
name|NULL
argument_list|,
comment|/* dxfer_len */
literal|0
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_pause
argument_list|)
argument_list|,
comment|/* timeout */
literal|50000
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_pause
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|op_code
operator|=
name|PAUSE
expr_stmt|;
name|scsi_cmd
operator|->
name|resume
operator|=
name|go
expr_stmt|;
name|error
operator|=
name|cdrunccb
argument_list|(
name|ccb
argument_list|,
name|cderror
argument_list|,
comment|/*cam_flags*/
name|CAM_RETRY_SELTO
argument_list|,
comment|/*sense_flags*/
name|SF_RETRY_UA
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cdstartunit
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|load
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|ccb
operator|=
name|cdgetccb
argument_list|(
name|periph
argument_list|,
comment|/* priority */
literal|1
argument_list|)
expr_stmt|;
name|scsi_start_stop
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/* retries */
literal|1
argument_list|,
comment|/* cbfcnp */
name|cddone
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* start */
name|TRUE
argument_list|,
comment|/* load_eject */
name|load
argument_list|,
comment|/* immediate */
name|FALSE
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
literal|50000
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdrunccb
argument_list|(
name|ccb
argument_list|,
name|cderror
argument_list|,
comment|/*cam_flags*/
name|CAM_RETRY_SELTO
argument_list|,
comment|/*sense_flags*/
name|SF_RETRY_UA
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cdstopunit
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|u_int32_t
name|eject
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|ccb
operator|=
name|cdgetccb
argument_list|(
name|periph
argument_list|,
comment|/* priority */
literal|1
argument_list|)
expr_stmt|;
name|scsi_start_stop
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/* retries */
literal|1
argument_list|,
comment|/* cbfcnp */
name|cddone
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* start */
name|FALSE
argument_list|,
comment|/* load_eject */
name|eject
argument_list|,
comment|/* immediate */
name|FALSE
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
literal|50000
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdrunccb
argument_list|(
name|ccb
argument_list|,
name|cderror
argument_list|,
comment|/*cam_flags*/
name|CAM_RETRY_SELTO
argument_list|,
comment|/*sense_flags*/
name|SF_RETRY_UA
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cdsetspeed
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|u_int32_t
name|rdspeed
parameter_list|,
name|u_int32_t
name|wrspeed
parameter_list|)
block|{
name|struct
name|scsi_set_speed
modifier|*
name|scsi_cmd
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|ccb
operator|=
name|cdgetccb
argument_list|(
name|periph
argument_list|,
comment|/* priority */
literal|1
argument_list|)
expr_stmt|;
name|csio
operator|=
operator|&
name|ccb
operator|->
name|csio
expr_stmt|;
comment|/* Preserve old behavior: units in multiples of CDROM speed */
if|if
condition|(
name|rdspeed
operator|<
literal|177
condition|)
name|rdspeed
operator|*=
literal|177
expr_stmt|;
if|if
condition|(
name|wrspeed
operator|<
literal|177
condition|)
name|wrspeed
operator|*=
literal|177
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
comment|/* retries */
literal|1
argument_list|,
comment|/* cbfcnp */
name|cddone
argument_list|,
comment|/* flags */
name|CAM_DIR_NONE
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* data_ptr */
name|NULL
argument_list|,
comment|/* dxfer_len */
literal|0
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_set_speed
argument_list|)
argument_list|,
comment|/* timeout */
literal|50000
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_set_speed
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|SET_CD_SPEED
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|rdspeed
argument_list|,
name|scsi_cmd
operator|->
name|readspeed
argument_list|)
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|wrspeed
argument_list|,
name|scsi_cmd
operator|->
name|writespeed
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdrunccb
argument_list|(
name|ccb
argument_list|,
name|cderror
argument_list|,
comment|/*cam_flags*/
name|CAM_RETRY_SELTO
argument_list|,
comment|/*sense_flags*/
name|SF_RETRY_UA
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cdreportkey
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|dvd_authinfo
modifier|*
name|authinfo
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|u_int8_t
modifier|*
name|databuf
decl_stmt|;
name|u_int32_t
name|lba
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|length
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|databuf
operator|=
name|NULL
expr_stmt|;
name|lba
operator|=
literal|0
expr_stmt|;
name|ccb
operator|=
name|cdgetccb
argument_list|(
name|periph
argument_list|,
comment|/* priority */
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|authinfo
operator|->
name|format
condition|)
block|{
case|case
name|DVD_REPORT_AGID
case|:
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_report_key_data_agid
argument_list|)
expr_stmt|;
break|break;
case|case
name|DVD_REPORT_CHALLENGE
case|:
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_report_key_data_challenge
argument_list|)
expr_stmt|;
break|break;
case|case
name|DVD_REPORT_KEY1
case|:
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_report_key_data_key1_key2
argument_list|)
expr_stmt|;
break|break;
case|case
name|DVD_REPORT_TITLE_KEY
case|:
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_report_key_data_title
argument_list|)
expr_stmt|;
comment|/* The lba field is only set for the title key */
name|lba
operator|=
name|authinfo
operator|->
name|lba
expr_stmt|;
break|break;
case|case
name|DVD_REPORT_ASF
case|:
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_report_key_data_asf
argument_list|)
expr_stmt|;
break|break;
case|case
name|DVD_REPORT_RPC
case|:
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_report_key_data_rpc
argument_list|)
expr_stmt|;
break|break;
case|case
name|DVD_INVALIDATE_AGID
case|:
name|length
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bailout
goto|;
break|break;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|length
operator|!=
literal|0
condition|)
block|{
name|databuf
operator|=
name|malloc
argument_list|(
name|length
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
block|}
else|else
name|databuf
operator|=
name|NULL
expr_stmt|;
name|scsi_report_key
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/* retries */
literal|1
argument_list|,
comment|/* cbfcnp */
name|cddone
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* lba */
name|lba
argument_list|,
comment|/* agid */
name|authinfo
operator|->
name|agid
argument_list|,
comment|/* key_format */
name|authinfo
operator|->
name|format
argument_list|,
comment|/* data_ptr */
name|databuf
argument_list|,
comment|/* dxfer_len */
name|length
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
literal|50000
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdrunccb
argument_list|(
name|ccb
argument_list|,
name|cderror
argument_list|,
comment|/*cam_flags*/
name|CAM_RETRY_SELTO
argument_list|,
comment|/*sense_flags*/
name|SF_RETRY_UA
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|bailout
goto|;
if|if
condition|(
name|ccb
operator|->
name|csio
operator|.
name|resid
operator|!=
literal|0
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"warning, residual for report key "
literal|"command is %d\n"
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|resid
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|authinfo
operator|->
name|format
condition|)
block|{
case|case
name|DVD_REPORT_AGID
case|:
block|{
name|struct
name|scsi_report_key_data_agid
modifier|*
name|agid_data
decl_stmt|;
name|agid_data
operator|=
operator|(
expr|struct
name|scsi_report_key_data_agid
operator|*
operator|)
name|databuf
expr_stmt|;
name|authinfo
operator|->
name|agid
operator|=
operator|(
name|agid_data
operator|->
name|agid
operator|&
name|RKD_AGID_MASK
operator|)
operator|>>
name|RKD_AGID_SHIFT
expr_stmt|;
break|break;
block|}
case|case
name|DVD_REPORT_CHALLENGE
case|:
block|{
name|struct
name|scsi_report_key_data_challenge
modifier|*
name|chal_data
decl_stmt|;
name|chal_data
operator|=
operator|(
expr|struct
name|scsi_report_key_data_challenge
operator|*
operator|)
name|databuf
expr_stmt|;
name|bcopy
argument_list|(
name|chal_data
operator|->
name|challenge_key
argument_list|,
name|authinfo
operator|->
name|keychal
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|chal_data
operator|->
name|challenge_key
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|authinfo
operator|->
name|keychal
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DVD_REPORT_KEY1
case|:
block|{
name|struct
name|scsi_report_key_data_key1_key2
modifier|*
name|key1_data
decl_stmt|;
name|key1_data
operator|=
operator|(
expr|struct
name|scsi_report_key_data_key1_key2
operator|*
operator|)
name|databuf
expr_stmt|;
name|bcopy
argument_list|(
name|key1_data
operator|->
name|key1
argument_list|,
name|authinfo
operator|->
name|keychal
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|key1_data
operator|->
name|key1
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|authinfo
operator|->
name|keychal
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DVD_REPORT_TITLE_KEY
case|:
block|{
name|struct
name|scsi_report_key_data_title
modifier|*
name|title_data
decl_stmt|;
name|title_data
operator|=
operator|(
expr|struct
name|scsi_report_key_data_title
operator|*
operator|)
name|databuf
expr_stmt|;
name|authinfo
operator|->
name|cpm
operator|=
operator|(
name|title_data
operator|->
name|byte0
operator|&
name|RKD_TITLE_CPM
operator|)
operator|>>
name|RKD_TITLE_CPM_SHIFT
expr_stmt|;
name|authinfo
operator|->
name|cp_sec
operator|=
operator|(
name|title_data
operator|->
name|byte0
operator|&
name|RKD_TITLE_CP_SEC
operator|)
operator|>>
name|RKD_TITLE_CP_SEC_SHIFT
expr_stmt|;
name|authinfo
operator|->
name|cgms
operator|=
operator|(
name|title_data
operator|->
name|byte0
operator|&
name|RKD_TITLE_CMGS_MASK
operator|)
operator|>>
name|RKD_TITLE_CMGS_SHIFT
expr_stmt|;
name|bcopy
argument_list|(
name|title_data
operator|->
name|title_key
argument_list|,
name|authinfo
operator|->
name|keychal
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|title_data
operator|->
name|title_key
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|authinfo
operator|->
name|keychal
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DVD_REPORT_ASF
case|:
block|{
name|struct
name|scsi_report_key_data_asf
modifier|*
name|asf_data
decl_stmt|;
name|asf_data
operator|=
operator|(
expr|struct
name|scsi_report_key_data_asf
operator|*
operator|)
name|databuf
expr_stmt|;
name|authinfo
operator|->
name|asf
operator|=
name|asf_data
operator|->
name|success
operator|&
name|RKD_ASF_SUCCESS
expr_stmt|;
break|break;
block|}
case|case
name|DVD_REPORT_RPC
case|:
block|{
name|struct
name|scsi_report_key_data_rpc
modifier|*
name|rpc_data
decl_stmt|;
name|rpc_data
operator|=
operator|(
expr|struct
name|scsi_report_key_data_rpc
operator|*
operator|)
name|databuf
expr_stmt|;
name|authinfo
operator|->
name|reg_type
operator|=
operator|(
name|rpc_data
operator|->
name|byte4
operator|&
name|RKD_RPC_TYPE_MASK
operator|)
operator|>>
name|RKD_RPC_TYPE_SHIFT
expr_stmt|;
name|authinfo
operator|->
name|vend_rsts
operator|=
operator|(
name|rpc_data
operator|->
name|byte4
operator|&
name|RKD_RPC_VENDOR_RESET_MASK
operator|)
operator|>>
name|RKD_RPC_VENDOR_RESET_SHIFT
expr_stmt|;
name|authinfo
operator|->
name|user_rsts
operator|=
name|rpc_data
operator|->
name|byte4
operator|&
name|RKD_RPC_USER_RESET_MASK
expr_stmt|;
name|authinfo
operator|->
name|region
operator|=
name|rpc_data
operator|->
name|region_mask
expr_stmt|;
name|authinfo
operator|->
name|rpc_scheme
operator|=
name|rpc_data
operator|->
name|rpc_scheme1
expr_stmt|;
break|break;
block|}
case|case
name|DVD_INVALIDATE_AGID
case|:
break|break;
default|default:
comment|/* This should be impossible, since we checked above */
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bailout
goto|;
break|break;
comment|/* NOTREACHED */
block|}
name|bailout
label|:
if|if
condition|(
name|databuf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|databuf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cdsendkey
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|dvd_authinfo
modifier|*
name|authinfo
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|u_int8_t
modifier|*
name|databuf
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|databuf
operator|=
name|NULL
expr_stmt|;
name|ccb
operator|=
name|cdgetccb
argument_list|(
name|periph
argument_list|,
comment|/* priority */
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|authinfo
operator|->
name|format
condition|)
block|{
case|case
name|DVD_SEND_CHALLENGE
case|:
block|{
name|struct
name|scsi_report_key_data_challenge
modifier|*
name|challenge_data
decl_stmt|;
name|length
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|challenge_data
argument_list|)
expr_stmt|;
name|challenge_data
operator|=
name|malloc
argument_list|(
name|length
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|databuf
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|challenge_data
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|length
operator|-
sizeof|sizeof
argument_list|(
name|challenge_data
operator|->
name|data_len
argument_list|)
argument_list|,
name|challenge_data
operator|->
name|data_len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|authinfo
operator|->
name|keychal
argument_list|,
name|challenge_data
operator|->
name|challenge_key
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|authinfo
operator|->
name|keychal
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|challenge_data
operator|->
name|challenge_key
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DVD_SEND_KEY2
case|:
block|{
name|struct
name|scsi_report_key_data_key1_key2
modifier|*
name|key2_data
decl_stmt|;
name|length
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|key2_data
argument_list|)
expr_stmt|;
name|key2_data
operator|=
name|malloc
argument_list|(
name|length
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|databuf
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|key2_data
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|length
operator|-
sizeof|sizeof
argument_list|(
name|key2_data
operator|->
name|data_len
argument_list|)
argument_list|,
name|key2_data
operator|->
name|data_len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|authinfo
operator|->
name|keychal
argument_list|,
name|key2_data
operator|->
name|key1
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|authinfo
operator|->
name|keychal
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|key2_data
operator|->
name|key1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DVD_SEND_RPC
case|:
block|{
name|struct
name|scsi_send_key_data_rpc
modifier|*
name|rpc_data
decl_stmt|;
name|length
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|rpc_data
argument_list|)
expr_stmt|;
name|rpc_data
operator|=
name|malloc
argument_list|(
name|length
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|databuf
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|rpc_data
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|length
operator|-
sizeof|sizeof
argument_list|(
name|rpc_data
operator|->
name|data_len
argument_list|)
argument_list|,
name|rpc_data
operator|->
name|data_len
argument_list|)
expr_stmt|;
name|rpc_data
operator|->
name|region_code
operator|=
name|authinfo
operator|->
name|region
expr_stmt|;
break|break;
block|}
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bailout
goto|;
break|break;
comment|/* NOTREACHED */
block|}
name|scsi_send_key
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/* retries */
literal|1
argument_list|,
comment|/* cbfcnp */
name|cddone
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* agid */
name|authinfo
operator|->
name|agid
argument_list|,
comment|/* key_format */
name|authinfo
operator|->
name|format
argument_list|,
comment|/* data_ptr */
name|databuf
argument_list|,
comment|/* dxfer_len */
name|length
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
literal|50000
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdrunccb
argument_list|(
name|ccb
argument_list|,
name|cderror
argument_list|,
comment|/*cam_flags*/
name|CAM_RETRY_SELTO
argument_list|,
comment|/*sense_flags*/
name|SF_RETRY_UA
argument_list|)
expr_stmt|;
name|bailout
label|:
if|if
condition|(
name|databuf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|databuf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cdreaddvdstructure
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|dvd_struct
modifier|*
name|dvdstruct
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|u_int8_t
modifier|*
name|databuf
decl_stmt|;
name|u_int32_t
name|address
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|length
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|databuf
operator|=
name|NULL
expr_stmt|;
comment|/* The address is reserved for many of the formats */
name|address
operator|=
literal|0
expr_stmt|;
name|ccb
operator|=
name|cdgetccb
argument_list|(
name|periph
argument_list|,
comment|/* priority */
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dvdstruct
operator|->
name|format
condition|)
block|{
case|case
name|DVD_STRUCT_PHYSICAL
case|:
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_dvd_struct_data_physical
argument_list|)
expr_stmt|;
break|break;
case|case
name|DVD_STRUCT_COPYRIGHT
case|:
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_dvd_struct_data_copyright
argument_list|)
expr_stmt|;
break|break;
case|case
name|DVD_STRUCT_DISCKEY
case|:
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_dvd_struct_data_disc_key
argument_list|)
expr_stmt|;
break|break;
case|case
name|DVD_STRUCT_BCA
case|:
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_dvd_struct_data_bca
argument_list|)
expr_stmt|;
break|break;
case|case
name|DVD_STRUCT_MANUFACT
case|:
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_dvd_struct_data_manufacturer
argument_list|)
expr_stmt|;
break|break;
case|case
name|DVD_STRUCT_CMI
case|:
name|error
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|bailout
goto|;
ifdef|#
directive|ifdef
name|notyet
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_dvd_struct_data_copy_manage
argument_list|)
expr_stmt|;
name|address
operator|=
name|dvdstruct
operator|->
name|address
expr_stmt|;
endif|#
directive|endif
break|break;
comment|/* NOTREACHED */
case|case
name|DVD_STRUCT_PROTDISCID
case|:
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_dvd_struct_data_prot_discid
argument_list|)
expr_stmt|;
break|break;
case|case
name|DVD_STRUCT_DISCKEYBLOCK
case|:
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_dvd_struct_data_disc_key_blk
argument_list|)
expr_stmt|;
break|break;
case|case
name|DVD_STRUCT_DDS
case|:
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_dvd_struct_data_dds
argument_list|)
expr_stmt|;
break|break;
case|case
name|DVD_STRUCT_MEDIUM_STAT
case|:
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_dvd_struct_data_medium_status
argument_list|)
expr_stmt|;
break|break;
case|case
name|DVD_STRUCT_SPARE_AREA
case|:
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_dvd_struct_data_spare_area
argument_list|)
expr_stmt|;
break|break;
case|case
name|DVD_STRUCT_RMD_LAST
case|:
name|error
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|bailout
goto|;
ifdef|#
directive|ifdef
name|notyet
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_dvd_struct_data_rmd_borderout
argument_list|)
expr_stmt|;
name|address
operator|=
name|dvdstruct
operator|->
name|address
expr_stmt|;
endif|#
directive|endif
break|break;
comment|/* NOTREACHED */
case|case
name|DVD_STRUCT_RMD_RMA
case|:
name|error
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|bailout
goto|;
ifdef|#
directive|ifdef
name|notyet
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_dvd_struct_data_rmd
argument_list|)
expr_stmt|;
name|address
operator|=
name|dvdstruct
operator|->
name|address
expr_stmt|;
endif|#
directive|endif
break|break;
comment|/* NOTREACHED */
case|case
name|DVD_STRUCT_PRERECORDED
case|:
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_dvd_struct_data_leadin
argument_list|)
expr_stmt|;
break|break;
case|case
name|DVD_STRUCT_UNIQUEID
case|:
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_dvd_struct_data_disc_id
argument_list|)
expr_stmt|;
break|break;
case|case
name|DVD_STRUCT_DCB
case|:
name|error
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|bailout
goto|;
ifdef|#
directive|ifdef
name|notyet
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_dvd_struct_data_dcb
argument_list|)
expr_stmt|;
name|address
operator|=
name|dvdstruct
operator|->
name|address
expr_stmt|;
endif|#
directive|endif
break|break;
comment|/* NOTREACHED */
case|case
name|DVD_STRUCT_LIST
case|:
comment|/* 		 * This is the maximum allocation length for the READ DVD 		 * STRUCTURE command.  There's nothing in the MMC3 spec 		 * that indicates a limit in the amount of data that can 		 * be returned from this call, other than the limits 		 * imposed by the 2-byte length variables. 		 */
name|length
operator|=
literal|65535
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bailout
goto|;
break|break;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|length
operator|!=
literal|0
condition|)
block|{
name|databuf
operator|=
name|malloc
argument_list|(
name|length
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
block|}
else|else
name|databuf
operator|=
name|NULL
expr_stmt|;
name|scsi_read_dvd_structure
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/* retries */
literal|1
argument_list|,
comment|/* cbfcnp */
name|cddone
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* lba */
name|address
argument_list|,
comment|/* layer_number */
name|dvdstruct
operator|->
name|layer_num
argument_list|,
comment|/* key_format */
name|dvdstruct
operator|->
name|format
argument_list|,
comment|/* agid */
name|dvdstruct
operator|->
name|agid
argument_list|,
comment|/* data_ptr */
name|databuf
argument_list|,
comment|/* dxfer_len */
name|length
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
literal|50000
argument_list|)
expr_stmt|;
name|error
operator|=
name|cdrunccb
argument_list|(
name|ccb
argument_list|,
name|cderror
argument_list|,
comment|/*cam_flags*/
name|CAM_RETRY_SELTO
argument_list|,
comment|/*sense_flags*/
name|SF_RETRY_UA
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|bailout
goto|;
switch|switch
condition|(
name|dvdstruct
operator|->
name|format
condition|)
block|{
case|case
name|DVD_STRUCT_PHYSICAL
case|:
block|{
name|struct
name|scsi_read_dvd_struct_data_layer_desc
modifier|*
name|inlayer
decl_stmt|;
name|struct
name|dvd_layer
modifier|*
name|outlayer
decl_stmt|;
name|struct
name|scsi_read_dvd_struct_data_physical
modifier|*
name|phys_data
decl_stmt|;
name|phys_data
operator|=
operator|(
expr|struct
name|scsi_read_dvd_struct_data_physical
operator|*
operator|)
name|databuf
expr_stmt|;
name|inlayer
operator|=
operator|&
name|phys_data
operator|->
name|layer_desc
expr_stmt|;
name|outlayer
operator|=
operator|(
expr|struct
name|dvd_layer
operator|*
operator|)
operator|&
name|dvdstruct
operator|->
name|data
expr_stmt|;
name|dvdstruct
operator|->
name|length
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|inlayer
argument_list|)
expr_stmt|;
name|outlayer
operator|->
name|book_type
operator|=
operator|(
name|inlayer
operator|->
name|book_type_version
operator|&
name|RDSD_BOOK_TYPE_MASK
operator|)
operator|>>
name|RDSD_BOOK_TYPE_SHIFT
expr_stmt|;
name|outlayer
operator|->
name|book_version
operator|=
operator|(
name|inlayer
operator|->
name|book_type_version
operator|&
name|RDSD_BOOK_VERSION_MASK
operator|)
expr_stmt|;
name|outlayer
operator|->
name|disc_size
operator|=
operator|(
name|inlayer
operator|->
name|disc_size_max_rate
operator|&
name|RDSD_DISC_SIZE_MASK
operator|)
operator|>>
name|RDSD_DISC_SIZE_SHIFT
expr_stmt|;
name|outlayer
operator|->
name|max_rate
operator|=
operator|(
name|inlayer
operator|->
name|disc_size_max_rate
operator|&
name|RDSD_MAX_RATE_MASK
operator|)
expr_stmt|;
name|outlayer
operator|->
name|nlayers
operator|=
operator|(
name|inlayer
operator|->
name|layer_info
operator|&
name|RDSD_NUM_LAYERS_MASK
operator|)
operator|>>
name|RDSD_NUM_LAYERS_SHIFT
expr_stmt|;
name|outlayer
operator|->
name|track_path
operator|=
operator|(
name|inlayer
operator|->
name|layer_info
operator|&
name|RDSD_TRACK_PATH_MASK
operator|)
operator|>>
name|RDSD_TRACK_PATH_SHIFT
expr_stmt|;
name|outlayer
operator|->
name|layer_type
operator|=
operator|(
name|inlayer
operator|->
name|layer_info
operator|&
name|RDSD_LAYER_TYPE_MASK
operator|)
expr_stmt|;
name|outlayer
operator|->
name|linear_density
operator|=
operator|(
name|inlayer
operator|->
name|density
operator|&
name|RDSD_LIN_DENSITY_MASK
operator|)
operator|>>
name|RDSD_LIN_DENSITY_SHIFT
expr_stmt|;
name|outlayer
operator|->
name|track_density
operator|=
operator|(
name|inlayer
operator|->
name|density
operator|&
name|RDSD_TRACK_DENSITY_MASK
operator|)
expr_stmt|;
name|outlayer
operator|->
name|bca
operator|=
operator|(
name|inlayer
operator|->
name|bca
operator|&
name|RDSD_BCA_MASK
operator|)
operator|>>
name|RDSD_BCA_SHIFT
expr_stmt|;
name|outlayer
operator|->
name|start_sector
operator|=
name|scsi_3btoul
argument_list|(
name|inlayer
operator|->
name|main_data_start
argument_list|)
expr_stmt|;
name|outlayer
operator|->
name|end_sector
operator|=
name|scsi_3btoul
argument_list|(
name|inlayer
operator|->
name|main_data_end
argument_list|)
expr_stmt|;
name|outlayer
operator|->
name|end_sector_l0
operator|=
name|scsi_3btoul
argument_list|(
name|inlayer
operator|->
name|end_sector_layer0
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DVD_STRUCT_COPYRIGHT
case|:
block|{
name|struct
name|scsi_read_dvd_struct_data_copyright
modifier|*
name|copy_data
decl_stmt|;
name|copy_data
operator|=
operator|(
expr|struct
name|scsi_read_dvd_struct_data_copyright
operator|*
operator|)
name|databuf
expr_stmt|;
name|dvdstruct
operator|->
name|cpst
operator|=
name|copy_data
operator|->
name|cps_type
expr_stmt|;
name|dvdstruct
operator|->
name|rmi
operator|=
name|copy_data
operator|->
name|region_info
expr_stmt|;
name|dvdstruct
operator|->
name|length
operator|=
literal|0
expr_stmt|;
break|break;
block|}
default|default:
comment|/* 		 * Tell the user what the overall length is, no matter 		 * what we can actually fit in the data buffer. 		 */
name|dvdstruct
operator|->
name|length
operator|=
name|length
operator|-
name|ccb
operator|->
name|csio
operator|.
name|resid
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_dvd_struct_data_header
argument_list|)
expr_stmt|;
comment|/* 		 * But only actually copy out the smaller of what we read 		 * in or what the structure can take. 		 */
name|bcopy
argument_list|(
name|databuf
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_dvd_struct_data_header
argument_list|)
argument_list|,
name|dvdstruct
operator|->
name|data
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|dvdstruct
operator|->
name|data
argument_list|)
argument_list|,
name|dvdstruct
operator|->
name|length
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|bailout
label|:
if|if
condition|(
name|databuf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|databuf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|scsi_report_key
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|u_int32_t
name|lba
parameter_list|,
name|u_int8_t
name|agid
parameter_list|,
name|u_int8_t
name|key_format
parameter_list|,
name|u_int8_t
modifier|*
name|data_ptr
parameter_list|,
name|u_int32_t
name|dxfer_len
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_report_key
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_report_key
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|REPORT_KEY
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|lba
argument_list|,
name|scsi_cmd
operator|->
name|lba
argument_list|)
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|dxfer_len
argument_list|,
name|scsi_cmd
operator|->
name|alloc_len
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|agid_keyformat
operator|=
operator|(
name|agid
operator|<<
name|RK_KF_AGID_SHIFT
operator|)
operator||
operator|(
name|key_format
operator|&
name|RK_KF_KEYFORMAT_MASK
operator|)
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
operator|(
name|dxfer_len
operator|==
literal|0
operator|)
condition|?
name|CAM_DIR_NONE
else|:
name|CAM_DIR_IN
argument_list|,
name|tag_action
argument_list|,
comment|/*data_ptr*/
name|data_ptr
argument_list|,
comment|/*dxfer_len*/
name|dxfer_len
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_send_key
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|u_int8_t
name|agid
parameter_list|,
name|u_int8_t
name|key_format
parameter_list|,
name|u_int8_t
modifier|*
name|data_ptr
parameter_list|,
name|u_int32_t
name|dxfer_len
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_send_key
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_send_key
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|SEND_KEY
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|dxfer_len
argument_list|,
name|scsi_cmd
operator|->
name|param_len
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|agid_keyformat
operator|=
operator|(
name|agid
operator|<<
name|RK_KF_AGID_SHIFT
operator|)
operator||
operator|(
name|key_format
operator|&
name|RK_KF_KEYFORMAT_MASK
operator|)
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|CAM_DIR_OUT
argument_list|,
name|tag_action
argument_list|,
comment|/*data_ptr*/
name|data_ptr
argument_list|,
comment|/*dxfer_len*/
name|dxfer_len
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_read_dvd_structure
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|u_int32_t
name|address
parameter_list|,
name|u_int8_t
name|layer_number
parameter_list|,
name|u_int8_t
name|format
parameter_list|,
name|u_int8_t
name|agid
parameter_list|,
name|u_int8_t
modifier|*
name|data_ptr
parameter_list|,
name|u_int32_t
name|dxfer_len
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_read_dvd_structure
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_read_dvd_structure
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|READ_DVD_STRUCTURE
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|address
argument_list|,
name|scsi_cmd
operator|->
name|address
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|layer_number
operator|=
name|layer_number
expr_stmt|;
name|scsi_cmd
operator|->
name|format
operator|=
name|format
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|dxfer_len
argument_list|,
name|scsi_cmd
operator|->
name|alloc_len
argument_list|)
expr_stmt|;
comment|/* The AGID is the top two bits of this byte */
name|scsi_cmd
operator|->
name|agid
operator|=
name|agid
operator|<<
literal|6
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|CAM_DIR_IN
argument_list|,
name|tag_action
argument_list|,
comment|/*data_ptr*/
name|data_ptr
argument_list|,
comment|/*dxfer_len*/
name|dxfer_len
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

