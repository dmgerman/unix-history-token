begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1997 Justin T. Gibbs.  * Copyright (c) 1997, 1998, 1999 Kenneth D. Merry.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Derived from the NetBSD SCSI changer driver.  *  *	$NetBSD: ch.c,v 1.32 1998/01/12 09:49:12 thorpej Exp $  *  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1996, 1997 Jason R. Thorpe<thorpej@and.com>  * All rights reserved.  *  * Partially based on an autochanger driver written by Stefan Grefen  * and on an autochanger driver written by the Systems Programming Group  * at the University of Utah Computer Science Department.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgements:  *	This product includes software developed by Jason R. Thorpe  *	for And Communications, http://www.and.com/  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,  * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED  * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/chio.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/devicestat.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_ch.h>
end_include

begin_comment
comment|/*  * Timeout definitions for various changer related commands.  They may  * be too short for some devices (especially the timeout for INITIALIZE  * ELEMENT STATUS).  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|u_int32_t
name|CH_TIMEOUT_MODE_SENSE
init|=
literal|6000
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|u_int32_t
name|CH_TIMEOUT_MOVE_MEDIUM
init|=
literal|100000
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|u_int32_t
name|CH_TIMEOUT_EXCHANGE_MEDIUM
init|=
literal|100000
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|u_int32_t
name|CH_TIMEOUT_POSITION_TO_ELEMENT
init|=
literal|100000
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|u_int32_t
name|CH_TIMEOUT_READ_ELEMENT_STATUS
init|=
literal|10000
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|u_int32_t
name|CH_TIMEOUT_SEND_VOLTAG
init|=
literal|10000
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|u_int32_t
name|CH_TIMEOUT_INITIALIZE_ELEMENT_STATUS
init|=
literal|500000
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
enum|enum
block|{
name|CH_FLAG_INVALID
init|=
literal|0x001
block|,
name|CH_FLAG_OPEN
init|=
literal|0x002
block|}
name|ch_flags
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|CH_STATE_PROBE
block|,
name|CH_STATE_NORMAL
block|}
name|ch_state
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|CH_CCB_PROBE
block|,
name|CH_CCB_WAITING
block|}
name|ch_ccb_types
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|CH_Q_NONE
init|=
literal|0x00
block|,
name|CH_Q_NO_DBD
init|=
literal|0x01
block|}
name|ch_quirks
typedef|;
end_typedef

begin_define
define|#
directive|define
name|ccb_state
value|ppriv_field0
end_define

begin_define
define|#
directive|define
name|ccb_bp
value|ppriv_ptr1
end_define

begin_struct
struct|struct
name|scsi_mode_sense_data
block|{
name|struct
name|scsi_mode_header_6
name|header
decl_stmt|;
name|struct
name|scsi_mode_blk_desc
name|blk_desc
decl_stmt|;
union|union
block|{
name|struct
name|page_element_address_assignment
name|ea
decl_stmt|;
name|struct
name|page_transport_geometry_parameters
name|tg
decl_stmt|;
name|struct
name|page_device_capabilities
name|cap
decl_stmt|;
block|}
name|pages
union|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ch_softc
block|{
name|ch_flags
name|flags
decl_stmt|;
name|ch_state
name|state
decl_stmt|;
name|ch_quirks
name|quirks
decl_stmt|;
name|union
name|ccb
name|saved_ccb
decl_stmt|;
name|struct
name|devstat
modifier|*
name|device_stats
decl_stmt|;
name|struct
name|cdev
modifier|*
name|dev
decl_stmt|;
name|int
name|sc_picker
decl_stmt|;
comment|/* current picker */
comment|/* 	 * The following information is obtained from the 	 * element address assignment page. 	 */
name|int
name|sc_firsts
index|[
name|CHET_MAX
operator|+
literal|1
index|]
decl_stmt|;
comment|/* firsts */
name|int
name|sc_counts
index|[
name|CHET_MAX
operator|+
literal|1
index|]
decl_stmt|;
comment|/* counts */
comment|/* 	 * The following mask defines the legal combinations 	 * of elements for the MOVE MEDIUM command. 	 */
name|u_int8_t
name|sc_movemask
index|[
name|CHET_MAX
operator|+
literal|1
index|]
decl_stmt|;
comment|/* 	 * As above, but for EXCHANGE MEDIUM. 	 */
name|u_int8_t
name|sc_exchangemask
index|[
name|CHET_MAX
operator|+
literal|1
index|]
decl_stmt|;
comment|/* 	 * Quirks; see below.  XXX KDM not implemented yet 	 */
name|int
name|sc_settledelay
decl_stmt|;
comment|/* delay for settle */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|CHUNIT
parameter_list|(
name|x
parameter_list|)
value|(minor((x)))
end_define

begin_decl_stmt
specifier|static
name|d_open_t
name|chopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|chclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|chioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_init_t
name|chinit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_ctor_t
name|chregister
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_oninv_t
name|choninvalidate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_dtor_t
name|chcleanup
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_start_t
name|chstart
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|chasync
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|u_int32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|chdone
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|done_ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cherror
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|u_int32_t
name|cam_flags
parameter_list|,
name|u_int32_t
name|sense_flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|chmove
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|changer_move
modifier|*
name|cm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|chexchange
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|changer_exchange
modifier|*
name|ce
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|chposition
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|changer_position
modifier|*
name|cp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|chgetelemstatus
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|changer_element_status_request
modifier|*
name|csr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|chsetvoltag
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|changer_set_voltag_request
modifier|*
name|csvr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|chielem
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|unsigned
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|chgetparams
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|periph_driver
name|chdriver
init|=
block|{
name|chinit
block|,
literal|"ch"
block|,
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|chdriver
operator|.
name|units
argument_list|)
block|,
comment|/* generation */
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|PERIPHDRIVER_DECLARE
argument_list|(
name|ch
argument_list|,
name|chdriver
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|ch_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_flags
operator|=
name|D_NEEDGIANT
block|,
operator|.
name|d_open
operator|=
name|chopen
block|,
operator|.
name|d_close
operator|=
name|chclose
block|,
operator|.
name|d_ioctl
operator|=
name|chioctl
block|,
operator|.
name|d_name
operator|=
literal|"ch"
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|chinit
parameter_list|(
name|void
parameter_list|)
block|{
name|cam_status
name|status
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
comment|/* 	 * Install a global async callback.  This callback will 	 * receive async callbacks like "new device found". 	 */
name|status
operator|=
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|CAM_XPT_PATH_ID
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|CAM_REQ_CMP
condition|)
block|{
name|struct
name|ccb_setasync
name|csa
decl_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|csa
operator|.
name|ccb_h
argument_list|,
name|path
argument_list|,
comment|/*priority*/
literal|5
argument_list|)
expr_stmt|;
name|csa
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SASYNC_CB
expr_stmt|;
name|csa
operator|.
name|event_enable
operator|=
name|AC_FOUND_DEVICE
expr_stmt|;
name|csa
operator|.
name|callback
operator|=
name|chasync
expr_stmt|;
name|csa
operator|.
name|callback_arg
operator|=
name|NULL
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|csa
argument_list|)
expr_stmt|;
name|status
operator|=
name|csa
operator|.
name|ccb_h
operator|.
name|status
expr_stmt|;
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"ch: Failed to attach master async callback "
literal|"due to status 0x%x!\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|choninvalidate
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|struct
name|ch_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ccb_setasync
name|csa
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|ch_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
comment|/* 	 * De-register any async callbacks. 	 */
name|xpt_setup_ccb
argument_list|(
operator|&
name|csa
operator|.
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
comment|/* priority */
literal|5
argument_list|)
expr_stmt|;
name|csa
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SASYNC_CB
expr_stmt|;
name|csa
operator|.
name|event_enable
operator|=
literal|0
expr_stmt|;
name|csa
operator|.
name|callback
operator|=
name|chasync
expr_stmt|;
name|csa
operator|.
name|callback_arg
operator|=
name|periph
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|csa
argument_list|)
expr_stmt|;
name|softc
operator|->
name|flags
operator||=
name|CH_FLAG_INVALID
expr_stmt|;
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"lost device\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|chcleanup
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|struct
name|ch_softc
modifier|*
name|softc
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|ch_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|devstat_remove_entry
argument_list|(
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
name|destroy_dev
argument_list|(
name|softc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"removing device entry\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|softc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|chasync
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|u_int32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|periph
operator|=
operator|(
expr|struct
name|cam_periph
operator|*
operator|)
name|callback_arg
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|AC_FOUND_DEVICE
case|:
block|{
name|struct
name|ccb_getdev
modifier|*
name|cgd
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|cgd
operator|=
operator|(
expr|struct
name|ccb_getdev
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|cgd
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|SID_TYPE
argument_list|(
operator|&
name|cgd
operator|->
name|inq_data
argument_list|)
operator|!=
name|T_CHANGER
condition|)
break|break;
comment|/* 		 * Allocate a peripheral instance for 		 * this device and start the probe 		 * process. 		 */
name|status
operator|=
name|cam_periph_alloc
argument_list|(
name|chregister
argument_list|,
name|choninvalidate
argument_list|,
name|chcleanup
argument_list|,
name|chstart
argument_list|,
literal|"ch"
argument_list|,
name|CAM_PERIPH_BIO
argument_list|,
name|cgd
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|chasync
argument_list|,
name|AC_FOUND_DEVICE
argument_list|,
name|cgd
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
operator|&&
name|status
operator|!=
name|CAM_REQ_INPROG
condition|)
name|printf
argument_list|(
literal|"chasync: Unable to probe new device "
literal|"due to status 0x%x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|cam_periph_async
argument_list|(
name|periph
argument_list|,
name|code
argument_list|,
name|path
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|cam_status
name|chregister
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ch_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ccb_setasync
name|csa
decl_stmt|;
name|struct
name|ccb_getdev
modifier|*
name|cgd
decl_stmt|;
name|cgd
operator|=
operator|(
expr|struct
name|ccb_getdev
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"chregister: periph was NULL!!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
if|if
condition|(
name|cgd
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"chregister: no getdev CCB, can't register device\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
name|softc
operator|=
operator|(
expr|struct
name|ch_softc
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|softc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"chregister: Unable to probe new device. "
literal|"Unable to allocate softc\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
name|bzero
argument_list|(
name|softc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|softc
argument_list|)
argument_list|)
expr_stmt|;
name|softc
operator|->
name|state
operator|=
name|CH_STATE_PROBE
expr_stmt|;
name|periph
operator|->
name|softc
operator|=
name|softc
expr_stmt|;
name|softc
operator|->
name|quirks
operator|=
name|CH_Q_NONE
expr_stmt|;
comment|/* 	 * Changers don't have a blocksize, and obviously don't support 	 * tagged queueing. 	 */
name|softc
operator|->
name|device_stats
operator|=
name|devstat_new_entry
argument_list|(
literal|"ch"
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|,
literal|0
argument_list|,
name|DEVSTAT_NO_BLOCKSIZE
operator||
name|DEVSTAT_NO_ORDERED_TAGS
argument_list|,
name|SID_TYPE
argument_list|(
operator|&
name|cgd
operator|->
name|inq_data
argument_list|)
operator||
name|DEVSTAT_TYPE_IF_SCSI
argument_list|,
name|DEVSTAT_PRIORITY_OTHER
argument_list|)
expr_stmt|;
comment|/* Register the device */
name|softc
operator|->
name|dev
operator|=
name|make_dev
argument_list|(
operator|&
name|ch_cdevsw
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0600
argument_list|,
literal|"%s%d"
argument_list|,
name|periph
operator|->
name|periph_name
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|)
expr_stmt|;
name|softc
operator|->
name|dev
operator|->
name|si_drv1
operator|=
name|periph
expr_stmt|;
comment|/* 	 * Add an async callback so that we get 	 * notified if this device goes away. 	 */
name|xpt_setup_ccb
argument_list|(
operator|&
name|csa
operator|.
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
comment|/* priority */
literal|5
argument_list|)
expr_stmt|;
name|csa
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SASYNC_CB
expr_stmt|;
name|csa
operator|.
name|event_enable
operator|=
name|AC_LOST_DEVICE
expr_stmt|;
name|csa
operator|.
name|callback
operator|=
name|chasync
expr_stmt|;
name|csa
operator|.
name|callback_arg
operator|=
name|periph
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|csa
argument_list|)
expr_stmt|;
comment|/* 	 * Lock this peripheral until we are setup. 	 * This first call can't block 	 */
operator|(
name|void
operator|)
name|cam_periph_lock
argument_list|(
name|periph
argument_list|,
name|PRIBIO
argument_list|)
expr_stmt|;
name|xpt_schedule
argument_list|(
name|periph
argument_list|,
comment|/*priority*/
literal|5
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|chopen
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|ch_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|s
decl_stmt|;
name|periph
operator|=
operator|(
expr|struct
name|cam_periph
operator|*
operator|)
name|dev
operator|->
name|si_drv1
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|softc
operator|=
operator|(
expr|struct
name|ch_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|s
operator|=
name|splsoftcam
argument_list|()
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|flags
operator|&
name|CH_FLAG_INVALID
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|cam_periph_lock
argument_list|(
name|periph
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|CH_FLAG_OPEN
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cam_periph_acquire
argument_list|(
name|periph
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|softc
operator|->
name|flags
operator||=
name|CH_FLAG_OPEN
expr_stmt|;
block|}
comment|/* 	 * Load information about this changer device into the softc. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|chgetparams
argument_list|(
name|periph
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|softc
operator|->
name|flags
operator|&=
operator|~
name|CH_FLAG_OPEN
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|cam_periph_release
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|chclose
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|ch_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|periph
operator|=
operator|(
expr|struct
name|cam_periph
operator|*
operator|)
name|dev
operator|->
name|si_drv1
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|softc
operator|=
operator|(
expr|struct
name|ch_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|cam_periph_lock
argument_list|(
name|periph
argument_list|,
name|PRIBIO
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|softc
operator|->
name|flags
operator|&=
operator|~
name|CH_FLAG_OPEN
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|cam_periph_release
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|chstart
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|start_ccb
parameter_list|)
block|{
name|struct
name|ch_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|s
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|ch_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
switch|switch
condition|(
name|softc
operator|->
name|state
condition|)
block|{
case|case
name|CH_STATE_NORMAL
case|:
block|{
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
name|periph
operator|->
name|immediate_priority
operator|<=
name|periph
operator|->
name|pinfo
operator|.
name|priority
condition|)
block|{
name|start_ccb
operator|->
name|ccb_h
operator|.
name|ccb_state
operator|=
name|CH_CCB_WAITING
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|periph
operator|->
name|ccb_list
argument_list|,
operator|&
name|start_ccb
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|sle
argument_list|)
expr_stmt|;
name|periph
operator|->
name|immediate_priority
operator|=
name|CAM_PRIORITY_NONE
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|periph
operator|->
name|ccb_list
argument_list|)
expr_stmt|;
block|}
else|else
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CH_STATE_PROBE
case|:
block|{
name|int
name|mode_buffer_len
decl_stmt|;
name|void
modifier|*
name|mode_buffer
decl_stmt|;
comment|/* 		 * Include the block descriptor when calculating the mode 		 * buffer length, 		 */
name|mode_buffer_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_mode_header_6
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_mode_blk_desc
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|page_element_address_assignment
argument_list|)
expr_stmt|;
name|mode_buffer
operator|=
name|malloc
argument_list|(
name|mode_buffer_len
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode_buffer
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"chstart: couldn't malloc mode sense data\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|bzero
argument_list|(
name|mode_buffer
argument_list|,
name|mode_buffer_len
argument_list|)
expr_stmt|;
comment|/* 		 * Get the element address assignment page. 		 */
name|scsi_mode_sense
argument_list|(
operator|&
name|start_ccb
operator|->
name|csio
argument_list|,
comment|/* retries */
literal|1
argument_list|,
comment|/* cbfcnp */
name|chdone
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* dbd */
operator|(
name|softc
operator|->
name|quirks
operator|&
name|CH_Q_NO_DBD
operator|)
condition|?
name|FALSE
else|:
name|TRUE
argument_list|,
comment|/* page_code */
name|SMS_PAGE_CTRL_CURRENT
argument_list|,
comment|/* page */
name|CH_ELEMENT_ADDR_ASSIGN_PAGE
argument_list|,
comment|/* param_buf */
operator|(
name|u_int8_t
operator|*
operator|)
name|mode_buffer
argument_list|,
comment|/* param_len */
name|mode_buffer_len
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
name|CH_TIMEOUT_MODE_SENSE
argument_list|)
expr_stmt|;
name|start_ccb
operator|->
name|ccb_h
operator|.
name|ccb_bp
operator|=
name|NULL
expr_stmt|;
name|start_ccb
operator|->
name|ccb_h
operator|.
name|ccb_state
operator|=
name|CH_CCB_PROBE
expr_stmt|;
name|xpt_action
argument_list|(
name|start_ccb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|chdone
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|done_ccb
parameter_list|)
block|{
name|struct
name|ch_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|ch_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|csio
operator|=
operator|&
name|done_ccb
operator|->
name|csio
expr_stmt|;
switch|switch
condition|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|ccb_state
condition|)
block|{
case|case
name|CH_CCB_PROBE
case|:
block|{
name|struct
name|scsi_mode_header_6
modifier|*
name|mode_header
decl_stmt|;
name|struct
name|page_element_address_assignment
modifier|*
name|ea
decl_stmt|;
name|char
name|announce_buf
index|[
literal|80
index|]
decl_stmt|;
name|mode_header
operator|=
operator|(
expr|struct
name|scsi_mode_header_6
operator|*
operator|)
name|csio
operator|->
name|data_ptr
expr_stmt|;
name|ea
operator|=
operator|(
expr|struct
name|page_element_address_assignment
operator|*
operator|)
name|find_mode_page_6
argument_list|(
name|mode_header
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_CMP
condition|)
block|{
name|softc
operator|->
name|sc_firsts
index|[
name|CHET_MT
index|]
operator|=
name|scsi_2btoul
argument_list|(
name|ea
operator|->
name|mtea
argument_list|)
expr_stmt|;
name|softc
operator|->
name|sc_counts
index|[
name|CHET_MT
index|]
operator|=
name|scsi_2btoul
argument_list|(
name|ea
operator|->
name|nmte
argument_list|)
expr_stmt|;
name|softc
operator|->
name|sc_firsts
index|[
name|CHET_ST
index|]
operator|=
name|scsi_2btoul
argument_list|(
name|ea
operator|->
name|fsea
argument_list|)
expr_stmt|;
name|softc
operator|->
name|sc_counts
index|[
name|CHET_ST
index|]
operator|=
name|scsi_2btoul
argument_list|(
name|ea
operator|->
name|nse
argument_list|)
expr_stmt|;
name|softc
operator|->
name|sc_firsts
index|[
name|CHET_IE
index|]
operator|=
name|scsi_2btoul
argument_list|(
name|ea
operator|->
name|fieea
argument_list|)
expr_stmt|;
name|softc
operator|->
name|sc_counts
index|[
name|CHET_IE
index|]
operator|=
name|scsi_2btoul
argument_list|(
name|ea
operator|->
name|niee
argument_list|)
expr_stmt|;
name|softc
operator|->
name|sc_firsts
index|[
name|CHET_DT
index|]
operator|=
name|scsi_2btoul
argument_list|(
name|ea
operator|->
name|fdtea
argument_list|)
expr_stmt|;
name|softc
operator|->
name|sc_counts
index|[
name|CHET_DT
index|]
operator|=
name|scsi_2btoul
argument_list|(
name|ea
operator|->
name|ndte
argument_list|)
expr_stmt|;
name|softc
operator|->
name|sc_picker
operator|=
name|softc
operator|->
name|sc_firsts
index|[
name|CHET_MT
index|]
expr_stmt|;
define|#
directive|define
name|PLURAL
parameter_list|(
name|c
parameter_list|)
value|(c) == 1 ? "" : "s"
name|snprintf
argument_list|(
name|announce_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|announce_buf
argument_list|)
argument_list|,
literal|"%d slot%s, %d drive%s, "
literal|"%d picker%s, %d portal%s"
argument_list|,
name|softc
operator|->
name|sc_counts
index|[
name|CHET_ST
index|]
argument_list|,
name|PLURAL
argument_list|(
name|softc
operator|->
name|sc_counts
index|[
name|CHET_ST
index|]
argument_list|)
argument_list|,
name|softc
operator|->
name|sc_counts
index|[
name|CHET_DT
index|]
argument_list|,
name|PLURAL
argument_list|(
name|softc
operator|->
name|sc_counts
index|[
name|CHET_DT
index|]
argument_list|)
argument_list|,
name|softc
operator|->
name|sc_counts
index|[
name|CHET_MT
index|]
argument_list|,
name|PLURAL
argument_list|(
name|softc
operator|->
name|sc_counts
index|[
name|CHET_MT
index|]
argument_list|)
argument_list|,
name|softc
operator|->
name|sc_counts
index|[
name|CHET_IE
index|]
argument_list|,
name|PLURAL
argument_list|(
name|softc
operator|->
name|sc_counts
index|[
name|CHET_IE
index|]
argument_list|)
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|PLURAL
block|}
else|else
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|cherror
argument_list|(
name|done_ccb
argument_list|,
name|CAM_RETRY_SELTO
argument_list|,
name|SF_RETRY_UA
operator||
name|SF_NO_PRINT
argument_list|)
expr_stmt|;
comment|/* 			 * Retry any UNIT ATTENTION type errors.  They 			 * are expected at boot. 			 */
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
block|{
comment|/* 				 * A retry was scheuled, so 				 * just return. 				 */
return|return;
block|}
elseif|else
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|int
name|retry_scheduled
decl_stmt|;
name|struct
name|scsi_mode_sense_6
modifier|*
name|sms
decl_stmt|;
name|sms
operator|=
operator|(
expr|struct
name|scsi_mode_sense_6
operator|*
operator|)
name|done_ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
comment|/* 				 * Check to see if block descriptors were 				 * disabled.  Some devices don't like that. 				 * We're taking advantage of the fact that 				 * the first few bytes of the 6 and 10 byte 				 * mode sense commands are the same.  If 				 * block descriptors were disabled, enable 				 * them and re-send the command. 				 */
if|if
condition|(
name|sms
operator|->
name|byte2
operator|&
name|SMS_DBD
condition|)
block|{
name|sms
operator|->
name|byte2
operator|&=
operator|~
name|SMS_DBD
expr_stmt|;
name|xpt_action
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
name|softc
operator|->
name|quirks
operator||=
name|CH_Q_NO_DBD
expr_stmt|;
name|retry_scheduled
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|retry_scheduled
operator|=
literal|0
expr_stmt|;
comment|/* Don't wedge this device's queue */
name|cam_release_devq
argument_list|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*relsim_flags*/
literal|0
argument_list|,
comment|/*reduction*/
literal|0
argument_list|,
comment|/*timeout*/
literal|0
argument_list|,
comment|/*getcount_only*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|retry_scheduled
condition|)
return|return;
if|if
condition|(
operator|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_SCSI_STATUS_ERROR
condition|)
name|scsi_sense_print
argument_list|(
operator|&
name|done_ccb
operator|->
name|csio
argument_list|)
expr_stmt|;
else|else
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"got CAM status %#x\n"
argument_list|,
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
argument_list|)
expr_stmt|;
block|}
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"fatal error, failed "
literal|"to attach to device\n"
argument_list|)
expr_stmt|;
name|cam_periph_invalidate
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|announce_buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
if|if
condition|(
name|announce_buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|xpt_announce_periph
argument_list|(
name|periph
argument_list|,
name|announce_buf
argument_list|)
expr_stmt|;
name|softc
operator|->
name|state
operator|=
name|CH_STATE_NORMAL
expr_stmt|;
name|free
argument_list|(
name|mode_header
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
comment|/* 		 * Since our peripheral may be invalidated by an error 		 * above or an external event, we must release our CCB 		 * before releasing the probe lock on the peripheral. 		 * The peripheral will only go away once the last lock 		 * is removed, and we need it around for the CCB release 		 * operation. 		 */
name|xpt_release_ccb
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|CH_CCB_WAITING
case|:
block|{
comment|/* Caller will release the CCB */
name|wakeup
argument_list|(
operator|&
name|done_ccb
operator|->
name|ccb_h
operator|.
name|cbfcnp
argument_list|)
expr_stmt|;
return|return;
block|}
default|default:
break|break;
block|}
name|xpt_release_ccb
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cherror
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|u_int32_t
name|cam_flags
parameter_list|,
name|u_int32_t
name|sense_flags
parameter_list|)
block|{
name|struct
name|ch_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|periph
operator|=
name|xpt_path_periph
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|ch_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
return|return
operator|(
name|cam_periph_error
argument_list|(
name|ccb
argument_list|,
name|cam_flags
argument_list|,
name|sense_flags
argument_list|,
operator|&
name|softc
operator|->
name|saved_ccb
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|chioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|ch_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|periph
operator|=
operator|(
expr|struct
name|cam_periph
operator|*
operator|)
name|dev
operator|->
name|si_drv1
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"entering chioctl\n"
operator|)
argument_list|)
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|ch_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"trying to do ioctl %#lx\n"
operator|,
name|cmd
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If this command can change the device's state, we must 	 * have the device open for writing. 	 */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|CHIOGPICKER
case|:
case|case
name|CHIOGPARAMS
case|:
case|case
name|CHIOGSTATUS
case|:
break|break;
default|default:
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EBADF
operator|)
return|;
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|CHIOMOVE
case|:
name|error
operator|=
name|chmove
argument_list|(
name|periph
argument_list|,
operator|(
expr|struct
name|changer_move
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHIOEXCHANGE
case|:
name|error
operator|=
name|chexchange
argument_list|(
name|periph
argument_list|,
operator|(
expr|struct
name|changer_exchange
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHIOPOSITION
case|:
name|error
operator|=
name|chposition
argument_list|(
name|periph
argument_list|,
operator|(
expr|struct
name|changer_position
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHIOGPICKER
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|=
name|softc
operator|->
name|sc_picker
operator|-
name|softc
operator|->
name|sc_firsts
index|[
name|CHET_MT
index|]
expr_stmt|;
break|break;
case|case
name|CHIOSPICKER
case|:
block|{
name|int
name|new_picker
init|=
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|new_picker
operator|>
operator|(
name|softc
operator|->
name|sc_counts
index|[
name|CHET_MT
index|]
operator|-
literal|1
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|softc
operator|->
name|sc_picker
operator|=
name|softc
operator|->
name|sc_firsts
index|[
name|CHET_MT
index|]
operator|+
name|new_picker
expr_stmt|;
break|break;
block|}
case|case
name|CHIOGPARAMS
case|:
block|{
name|struct
name|changer_params
modifier|*
name|cp
init|=
operator|(
expr|struct
name|changer_params
operator|*
operator|)
name|addr
decl_stmt|;
name|cp
operator|->
name|cp_npickers
operator|=
name|softc
operator|->
name|sc_counts
index|[
name|CHET_MT
index|]
expr_stmt|;
name|cp
operator|->
name|cp_nslots
operator|=
name|softc
operator|->
name|sc_counts
index|[
name|CHET_ST
index|]
expr_stmt|;
name|cp
operator|->
name|cp_nportals
operator|=
name|softc
operator|->
name|sc_counts
index|[
name|CHET_IE
index|]
expr_stmt|;
name|cp
operator|->
name|cp_ndrives
operator|=
name|softc
operator|->
name|sc_counts
index|[
name|CHET_DT
index|]
expr_stmt|;
break|break;
block|}
case|case
name|CHIOIELEM
case|:
name|error
operator|=
name|chielem
argument_list|(
name|periph
argument_list|,
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHIOGSTATUS
case|:
block|{
name|error
operator|=
name|chgetelemstatus
argument_list|(
name|periph
argument_list|,
operator|(
expr|struct
name|changer_element_status_request
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CHIOSETVOLTAG
case|:
block|{
name|error
operator|=
name|chsetvoltag
argument_list|(
name|periph
argument_list|,
operator|(
expr|struct
name|changer_set_voltag_request
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Implement prevent/allow? */
default|default:
name|error
operator|=
name|cam_periph_ioctl
argument_list|(
name|periph
argument_list|,
name|cmd
argument_list|,
name|addr
argument_list|,
name|cherror
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|chmove
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|changer_move
modifier|*
name|cm
parameter_list|)
block|{
name|struct
name|ch_softc
modifier|*
name|softc
decl_stmt|;
name|u_int16_t
name|fromelem
decl_stmt|,
name|toelem
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|ch_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
comment|/* 	 * Check arguments. 	 */
if|if
condition|(
operator|(
name|cm
operator|->
name|cm_fromtype
operator|>
name|CHET_DT
operator|)
operator|||
operator|(
name|cm
operator|->
name|cm_totype
operator|>
name|CHET_DT
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|cm
operator|->
name|cm_fromunit
operator|>
operator|(
name|softc
operator|->
name|sc_counts
index|[
name|cm
operator|->
name|cm_fromtype
index|]
operator|-
literal|1
operator|)
operator|)
operator|||
operator|(
name|cm
operator|->
name|cm_tounit
operator|>
operator|(
name|softc
operator|->
name|sc_counts
index|[
name|cm
operator|->
name|cm_totype
index|]
operator|-
literal|1
operator|)
operator|)
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
comment|/* 	 * Check the request against the changer's capabilities. 	 */
if|if
condition|(
operator|(
name|softc
operator|->
name|sc_movemask
index|[
name|cm
operator|->
name|cm_fromtype
index|]
operator|&
operator|(
literal|1
operator|<<
name|cm
operator|->
name|cm_totype
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
comment|/* 	 * Calculate the source and destination elements. 	 */
name|fromelem
operator|=
name|softc
operator|->
name|sc_firsts
index|[
name|cm
operator|->
name|cm_fromtype
index|]
operator|+
name|cm
operator|->
name|cm_fromunit
expr_stmt|;
name|toelem
operator|=
name|softc
operator|->
name|sc_firsts
index|[
name|cm
operator|->
name|cm_totype
index|]
operator|+
name|cm
operator|->
name|cm_tounit
expr_stmt|;
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|scsi_move_medium
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/* retries */
literal|1
argument_list|,
comment|/* cbfcnp */
name|chdone
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* tea */
name|softc
operator|->
name|sc_picker
argument_list|,
comment|/* src */
name|fromelem
argument_list|,
comment|/* dst */
name|toelem
argument_list|,
comment|/* invert */
operator|(
name|cm
operator|->
name|cm_flags
operator|&
name|CM_INVERT
operator|)
condition|?
name|TRUE
else|:
name|FALSE
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
name|CH_TIMEOUT_MOVE_MEDIUM
argument_list|)
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|cherror
argument_list|,
comment|/*cam_flags*/
name|CAM_RETRY_SELTO
argument_list|,
comment|/*sense_flags*/
name|SF_RETRY_UA
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|chexchange
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|changer_exchange
modifier|*
name|ce
parameter_list|)
block|{
name|struct
name|ch_softc
modifier|*
name|softc
decl_stmt|;
name|u_int16_t
name|src
decl_stmt|,
name|dst1
decl_stmt|,
name|dst2
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|ch_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
comment|/* 	 * Check arguments. 	 */
if|if
condition|(
operator|(
name|ce
operator|->
name|ce_srctype
operator|>
name|CHET_DT
operator|)
operator|||
operator|(
name|ce
operator|->
name|ce_fdsttype
operator|>
name|CHET_DT
operator|)
operator|||
operator|(
name|ce
operator|->
name|ce_sdsttype
operator|>
name|CHET_DT
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|ce
operator|->
name|ce_srcunit
operator|>
operator|(
name|softc
operator|->
name|sc_counts
index|[
name|ce
operator|->
name|ce_srctype
index|]
operator|-
literal|1
operator|)
operator|)
operator|||
operator|(
name|ce
operator|->
name|ce_fdstunit
operator|>
operator|(
name|softc
operator|->
name|sc_counts
index|[
name|ce
operator|->
name|ce_fdsttype
index|]
operator|-
literal|1
operator|)
operator|)
operator|||
operator|(
name|ce
operator|->
name|ce_sdstunit
operator|>
operator|(
name|softc
operator|->
name|sc_counts
index|[
name|ce
operator|->
name|ce_sdsttype
index|]
operator|-
literal|1
operator|)
operator|)
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
comment|/* 	 * Check the request against the changer's capabilities. 	 */
if|if
condition|(
operator|(
operator|(
name|softc
operator|->
name|sc_exchangemask
index|[
name|ce
operator|->
name|ce_srctype
index|]
operator|&
operator|(
literal|1
operator|<<
name|ce
operator|->
name|ce_fdsttype
operator|)
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|softc
operator|->
name|sc_exchangemask
index|[
name|ce
operator|->
name|ce_fdsttype
index|]
operator|&
operator|(
literal|1
operator|<<
name|ce
operator|->
name|ce_sdsttype
operator|)
operator|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
comment|/* 	 * Calculate the source and destination elements. 	 */
name|src
operator|=
name|softc
operator|->
name|sc_firsts
index|[
name|ce
operator|->
name|ce_srctype
index|]
operator|+
name|ce
operator|->
name|ce_srcunit
expr_stmt|;
name|dst1
operator|=
name|softc
operator|->
name|sc_firsts
index|[
name|ce
operator|->
name|ce_fdsttype
index|]
operator|+
name|ce
operator|->
name|ce_fdstunit
expr_stmt|;
name|dst2
operator|=
name|softc
operator|->
name|sc_firsts
index|[
name|ce
operator|->
name|ce_sdsttype
index|]
operator|+
name|ce
operator|->
name|ce_sdstunit
expr_stmt|;
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|scsi_exchange_medium
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/* retries */
literal|1
argument_list|,
comment|/* cbfcnp */
name|chdone
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* tea */
name|softc
operator|->
name|sc_picker
argument_list|,
comment|/* src */
name|src
argument_list|,
comment|/* dst1 */
name|dst1
argument_list|,
comment|/* dst2 */
name|dst2
argument_list|,
comment|/* invert1 */
operator|(
name|ce
operator|->
name|ce_flags
operator|&
name|CE_INVERT1
operator|)
condition|?
name|TRUE
else|:
name|FALSE
argument_list|,
comment|/* invert2 */
operator|(
name|ce
operator|->
name|ce_flags
operator|&
name|CE_INVERT2
operator|)
condition|?
name|TRUE
else|:
name|FALSE
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
name|CH_TIMEOUT_EXCHANGE_MEDIUM
argument_list|)
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|cherror
argument_list|,
comment|/*cam_flags*/
name|CAM_RETRY_SELTO
argument_list|,
comment|/*sense_flags*/
name|SF_RETRY_UA
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|chposition
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|changer_position
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|ch_softc
modifier|*
name|softc
decl_stmt|;
name|u_int16_t
name|dst
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|ch_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
comment|/* 	 * Check arguments. 	 */
if|if
condition|(
name|cp
operator|->
name|cp_type
operator|>
name|CHET_DT
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|cp
operator|->
name|cp_unit
operator|>
operator|(
name|softc
operator|->
name|sc_counts
index|[
name|cp
operator|->
name|cp_type
index|]
operator|-
literal|1
operator|)
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
comment|/* 	 * Calculate the destination element. 	 */
name|dst
operator|=
name|softc
operator|->
name|sc_firsts
index|[
name|cp
operator|->
name|cp_type
index|]
operator|+
name|cp
operator|->
name|cp_unit
expr_stmt|;
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|scsi_position_to_element
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/* retries */
literal|1
argument_list|,
comment|/* cbfcnp */
name|chdone
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* tea */
name|softc
operator|->
name|sc_picker
argument_list|,
comment|/* dst */
name|dst
argument_list|,
comment|/* invert */
operator|(
name|cp
operator|->
name|cp_flags
operator|&
name|CP_INVERT
operator|)
condition|?
name|TRUE
else|:
name|FALSE
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
name|CH_TIMEOUT_POSITION_TO_ELEMENT
argument_list|)
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|cherror
argument_list|,
comment|/*cam_flags*/
name|CAM_RETRY_SELTO
argument_list|,
comment|/*sense_flags*/
name|SF_RETRY_UA
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copy a volume tag to a volume_tag struct, converting SCSI byte order  * to host native byte order in the volume serial number.  The volume  * label as returned by the changer is transferred to user mode as  * nul-terminated string.  Volume labels are truncated at the first  * space, as suggested by SCSI-2.  */
end_comment

begin_function
specifier|static
name|void
name|copy_voltag
parameter_list|(
name|struct
name|changer_voltag
modifier|*
name|uvoltag
parameter_list|,
name|struct
name|volume_tag
modifier|*
name|voltag
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CH_VOLTAG_MAXLEN
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|voltag
operator|->
name|vif
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|&&
name|c
operator|!=
literal|' '
condition|)
name|uvoltag
operator|->
name|cv_volid
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
else|else
break|break;
block|}
name|uvoltag
operator|->
name|cv_serial
operator|=
name|scsi_2btoul
argument_list|(
name|voltag
operator|->
name|vsn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Copy an an element status descriptor to a user-mode  * changer_element_status structure.  */
end_comment

begin_function
specifier|static
name|void
name|copy_element_status
parameter_list|(
name|struct
name|ch_softc
modifier|*
name|softc
parameter_list|,
name|u_int16_t
name|flags
parameter_list|,
name|struct
name|read_element_status_descriptor
modifier|*
name|desc
parameter_list|,
name|struct
name|changer_element_status
modifier|*
name|ces
parameter_list|)
block|{
name|u_int16_t
name|eaddr
init|=
name|scsi_2btoul
argument_list|(
name|desc
operator|->
name|eaddr
argument_list|)
decl_stmt|;
name|u_int16_t
name|et
decl_stmt|;
name|ces
operator|->
name|ces_int_addr
operator|=
name|eaddr
expr_stmt|;
comment|/* set up logical address in element status */
for|for
control|(
name|et
operator|=
name|CHET_MT
init|;
name|et
operator|<=
name|CHET_DT
condition|;
name|et
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|softc
operator|->
name|sc_firsts
index|[
name|et
index|]
operator|<=
name|eaddr
operator|)
operator|&&
operator|(
operator|(
name|softc
operator|->
name|sc_firsts
index|[
name|et
index|]
operator|+
name|softc
operator|->
name|sc_counts
index|[
name|et
index|]
operator|)
operator|>
name|eaddr
operator|)
condition|)
block|{
name|ces
operator|->
name|ces_addr
operator|=
name|eaddr
operator|-
name|softc
operator|->
name|sc_firsts
index|[
name|et
index|]
expr_stmt|;
name|ces
operator|->
name|ces_type
operator|=
name|et
expr_stmt|;
break|break;
block|}
block|}
name|ces
operator|->
name|ces_flags
operator|=
name|desc
operator|->
name|flags1
expr_stmt|;
name|ces
operator|->
name|ces_sensecode
operator|=
name|desc
operator|->
name|sense_code
expr_stmt|;
name|ces
operator|->
name|ces_sensequal
operator|=
name|desc
operator|->
name|sense_qual
expr_stmt|;
if|if
condition|(
name|desc
operator|->
name|flags2
operator|&
name|READ_ELEMENT_STATUS_INVERT
condition|)
name|ces
operator|->
name|ces_flags
operator||=
name|CES_INVERT
expr_stmt|;
if|if
condition|(
name|desc
operator|->
name|flags2
operator|&
name|READ_ELEMENT_STATUS_SVALID
condition|)
block|{
name|eaddr
operator|=
name|scsi_2btoul
argument_list|(
name|desc
operator|->
name|ssea
argument_list|)
expr_stmt|;
comment|/* convert source address to logical format */
for|for
control|(
name|et
operator|=
name|CHET_MT
init|;
name|et
operator|<=
name|CHET_DT
condition|;
name|et
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|softc
operator|->
name|sc_firsts
index|[
name|et
index|]
operator|<=
name|eaddr
operator|)
operator|&&
operator|(
operator|(
name|softc
operator|->
name|sc_firsts
index|[
name|et
index|]
operator|+
name|softc
operator|->
name|sc_counts
index|[
name|et
index|]
operator|)
operator|>
name|eaddr
operator|)
condition|)
block|{
name|ces
operator|->
name|ces_source_addr
operator|=
name|eaddr
operator|-
name|softc
operator|->
name|sc_firsts
index|[
name|et
index|]
expr_stmt|;
name|ces
operator|->
name|ces_source_type
operator|=
name|et
expr_stmt|;
name|ces
operator|->
name|ces_flags
operator||=
name|CES_SOURCE_VALID
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|ces
operator|->
name|ces_flags
operator|&
name|CES_SOURCE_VALID
operator|)
condition|)
name|printf
argument_list|(
literal|"ch: warning: could not map element source "
literal|"address %ud to a valid element type\n"
argument_list|,
name|eaddr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|READ_ELEMENT_STATUS_PVOLTAG
condition|)
name|copy_voltag
argument_list|(
operator|&
operator|(
name|ces
operator|->
name|ces_pvoltag
operator|)
argument_list|,
operator|&
operator|(
name|desc
operator|->
name|pvoltag
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|READ_ELEMENT_STATUS_AVOLTAG
condition|)
name|copy_voltag
argument_list|(
operator|&
operator|(
name|ces
operator|->
name|ces_avoltag
operator|)
argument_list|,
operator|&
operator|(
name|desc
operator|->
name|avoltag
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|->
name|dt_scsi_flags
operator|&
name|READ_ELEMENT_STATUS_DT_IDVALID
condition|)
block|{
name|ces
operator|->
name|ces_flags
operator||=
name|CES_SCSIID_VALID
expr_stmt|;
name|ces
operator|->
name|ces_scsi_id
operator|=
name|desc
operator|->
name|dt_scsi_addr
expr_stmt|;
block|}
if|if
condition|(
name|desc
operator|->
name|dt_scsi_addr
operator|&
name|READ_ELEMENT_STATUS_DT_LUVALID
condition|)
block|{
name|ces
operator|->
name|ces_flags
operator||=
name|CES_LUN_VALID
expr_stmt|;
name|ces
operator|->
name|ces_scsi_lun
operator|=
name|desc
operator|->
name|dt_scsi_flags
operator|&
name|READ_ELEMENT_STATUS_DT_LUNMASK
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|chgetelemstatus
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|changer_element_status_request
modifier|*
name|cesr
parameter_list|)
block|{
name|struct
name|read_element_status_header
modifier|*
name|st_hdr
decl_stmt|;
name|struct
name|read_element_status_page_header
modifier|*
name|pg_hdr
decl_stmt|;
name|struct
name|read_element_status_descriptor
modifier|*
name|desc
decl_stmt|;
name|caddr_t
name|data
init|=
name|NULL
decl_stmt|;
name|size_t
name|size
decl_stmt|,
name|desclen
decl_stmt|;
name|int
name|avail
decl_stmt|,
name|i
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|changer_element_status
modifier|*
name|user_data
init|=
name|NULL
decl_stmt|;
name|struct
name|ch_softc
modifier|*
name|softc
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|chet
init|=
name|cesr
operator|->
name|cesr_element_type
decl_stmt|;
name|int
name|want_voltags
init|=
operator|(
name|cesr
operator|->
name|cesr_flags
operator|&
name|CESR_VOLTAGS
operator|)
condition|?
literal|1
else|:
literal|0
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|ch_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
comment|/* perform argument checking */
comment|/* 	 * Perform a range check on the cesr_element_{base,count} 	 * request argument fields. 	 */
if|if
condition|(
operator|(
name|softc
operator|->
name|sc_counts
index|[
name|chet
index|]
operator|-
name|cesr
operator|->
name|cesr_element_base
operator|)
operator|<=
literal|0
operator|||
operator|(
name|cesr
operator|->
name|cesr_element_base
operator|+
name|cesr
operator|->
name|cesr_element_count
operator|)
operator|>
name|softc
operator|->
name|sc_counts
index|[
name|chet
index|]
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Request one descriptor for the given element type.  This 	 * is used to determine the size of the descriptor so that 	 * we can allocate enough storage for all of them.  We assume 	 * that the first one can fit into 1k. 	 */
name|data
operator|=
operator|(
name|caddr_t
operator|)
name|malloc
argument_list|(
literal|1024
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|scsi_read_element_status
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/* retries */
literal|1
argument_list|,
comment|/* cbfcnp */
name|chdone
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* voltag */
name|want_voltags
argument_list|,
comment|/* sea */
name|softc
operator|->
name|sc_firsts
index|[
name|chet
index|]
argument_list|,
comment|/* count */
literal|1
argument_list|,
comment|/* data_ptr */
name|data
argument_list|,
comment|/* dxfer_len */
literal|1024
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
name|CH_TIMEOUT_READ_ELEMENT_STATUS
argument_list|)
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|cherror
argument_list|,
comment|/*cam_flags*/
name|CAM_RETRY_SELTO
argument_list|,
comment|/*sense_flags*/
name|SF_RETRY_UA
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
name|st_hdr
operator|=
operator|(
expr|struct
name|read_element_status_header
operator|*
operator|)
name|data
expr_stmt|;
name|pg_hdr
operator|=
operator|(
expr|struct
name|read_element_status_page_header
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|st_hdr
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|read_element_status_header
argument_list|)
operator|)
expr_stmt|;
name|desclen
operator|=
name|scsi_2btoul
argument_list|(
name|pg_hdr
operator|->
name|edl
argument_list|)
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|read_element_status_header
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|read_element_status_page_header
argument_list|)
operator|+
operator|(
name|desclen
operator|*
name|cesr
operator|->
name|cesr_element_count
operator|)
expr_stmt|;
comment|/* 	 * Reallocate storage for descriptors and get them from the 	 * device. 	 */
name|free
argument_list|(
name|data
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
name|caddr_t
operator|)
name|malloc
argument_list|(
name|size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|scsi_read_element_status
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/* retries */
literal|1
argument_list|,
comment|/* cbfcnp */
name|chdone
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* voltag */
name|want_voltags
argument_list|,
comment|/* sea */
name|softc
operator|->
name|sc_firsts
index|[
name|chet
index|]
operator|+
name|cesr
operator|->
name|cesr_element_base
argument_list|,
comment|/* count */
name|cesr
operator|->
name|cesr_element_count
argument_list|,
comment|/* data_ptr */
name|data
argument_list|,
comment|/* dxfer_len */
name|size
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
name|CH_TIMEOUT_READ_ELEMENT_STATUS
argument_list|)
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|cherror
argument_list|,
comment|/*cam_flags*/
name|CAM_RETRY_SELTO
argument_list|,
comment|/*sense_flags*/
name|SF_RETRY_UA
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
comment|/* 	 * Fill in the user status array. 	 */
name|st_hdr
operator|=
operator|(
expr|struct
name|read_element_status_header
operator|*
operator|)
name|data
expr_stmt|;
name|pg_hdr
operator|=
operator|(
expr|struct
name|read_element_status_page_header
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|st_hdr
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|read_element_status_header
argument_list|)
operator|)
expr_stmt|;
name|avail
operator|=
name|scsi_2btoul
argument_list|(
name|st_hdr
operator|->
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|avail
operator|!=
name|cesr
operator|->
name|cesr_element_count
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"warning, READ ELEMENT STATUS avail != count\n"
argument_list|)
expr_stmt|;
block|}
name|user_data
operator|=
operator|(
expr|struct
name|changer_element_status
operator|*
operator|)
name|malloc
argument_list|(
name|avail
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|changer_element_status
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|desc
operator|=
operator|(
expr|struct
name|read_element_status_descriptor
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|data
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|read_element_status_header
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|read_element_status_page_header
argument_list|)
operator|)
expr_stmt|;
comment|/* 	 * Set up the individual element status structures 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|avail
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|changer_element_status
modifier|*
name|ces
init|=
operator|&
operator|(
name|user_data
index|[
name|i
index|]
operator|)
decl_stmt|;
name|copy_element_status
argument_list|(
name|softc
argument_list|,
name|pg_hdr
operator|->
name|flags
argument_list|,
name|desc
argument_list|,
name|ces
argument_list|)
expr_stmt|;
name|desc
operator|=
operator|(
expr|struct
name|read_element_status_descriptor
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|desc
operator|+
name|desclen
operator|)
expr_stmt|;
block|}
comment|/* Copy element status structures out to userspace. */
name|error
operator|=
name|copyout
argument_list|(
name|user_data
argument_list|,
name|cesr
operator|->
name|cesr_element_status
argument_list|,
name|avail
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|changer_element_status
argument_list|)
argument_list|)
expr_stmt|;
name|done
label|:
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|data
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|user_data
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|user_data
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|chielem
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|unsigned
name|int
name|timeout
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|ch_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|!
name|timeout
condition|)
block|{
name|timeout
operator|=
name|CH_TIMEOUT_INITIALIZE_ELEMENT_STATUS
expr_stmt|;
block|}
else|else
block|{
name|timeout
operator|*=
literal|1000
expr_stmt|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|ch_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|scsi_initialize_element_status
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/* retries */
literal|1
argument_list|,
comment|/* cbfcnp */
name|chdone
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
name|timeout
argument_list|)
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|cherror
argument_list|,
comment|/*cam_flags*/
name|CAM_RETRY_SELTO
argument_list|,
comment|/*sense_flags*/
name|SF_RETRY_UA
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|chsetvoltag
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|changer_set_voltag_request
modifier|*
name|csvr
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|ch_softc
modifier|*
name|softc
decl_stmt|;
name|u_int16_t
name|ea
decl_stmt|;
name|u_int8_t
name|sac
decl_stmt|;
name|struct
name|scsi_send_volume_tag_parameters
name|ssvtp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|i
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|ch_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|ssvtp
argument_list|,
sizeof|sizeof
argument_list|(
name|ssvtp
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|ssvtp
operator|.
name|vitf
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|ssvtp
operator|.
name|vitf
index|[
name|i
index|]
operator|=
literal|' '
expr_stmt|;
block|}
comment|/* 	 * Check arguments. 	 */
if|if
condition|(
name|csvr
operator|->
name|csvr_type
operator|>
name|CHET_DT
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|csvr
operator|->
name|csvr_addr
operator|>
operator|(
name|softc
operator|->
name|sc_counts
index|[
name|csvr
operator|->
name|csvr_type
index|]
operator|-
literal|1
operator|)
condition|)
return|return
name|ENODEV
return|;
name|ea
operator|=
name|softc
operator|->
name|sc_firsts
index|[
name|csvr
operator|->
name|csvr_type
index|]
operator|+
name|csvr
operator|->
name|csvr_addr
expr_stmt|;
if|if
condition|(
name|csvr
operator|->
name|csvr_flags
operator|&
name|CSVR_ALTERNATE
condition|)
block|{
switch|switch
condition|(
name|csvr
operator|->
name|csvr_flags
operator|&
name|CSVR_MODE_MASK
condition|)
block|{
case|case
name|CSVR_MODE_SET
case|:
name|sac
operator|=
name|SEND_VOLUME_TAG_ASSERT_ALTERNATE
expr_stmt|;
break|break;
case|case
name|CSVR_MODE_REPLACE
case|:
name|sac
operator|=
name|SEND_VOLUME_TAG_REPLACE_ALTERNATE
expr_stmt|;
break|break;
case|case
name|CSVR_MODE_CLEAR
case|:
name|sac
operator|=
name|SEND_VOLUME_TAG_UNDEFINED_ALTERNATE
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|csvr
operator|->
name|csvr_flags
operator|&
name|CSVR_MODE_MASK
condition|)
block|{
case|case
name|CSVR_MODE_SET
case|:
name|sac
operator|=
name|SEND_VOLUME_TAG_ASSERT_PRIMARY
expr_stmt|;
break|break;
case|case
name|CSVR_MODE_REPLACE
case|:
name|sac
operator|=
name|SEND_VOLUME_TAG_REPLACE_PRIMARY
expr_stmt|;
break|break;
case|case
name|CSVR_MODE_CLEAR
case|:
name|sac
operator|=
name|SEND_VOLUME_TAG_UNDEFINED_PRIMARY
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|memcpy
argument_list|(
name|ssvtp
operator|.
name|vitf
argument_list|,
name|csvr
operator|->
name|csvr_voltag
operator|.
name|cv_volid
argument_list|,
name|min
argument_list|(
name|strlen
argument_list|(
name|csvr
operator|->
name|csvr_voltag
operator|.
name|cv_volid
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|ssvtp
operator|.
name|vitf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|csvr
operator|->
name|csvr_voltag
operator|.
name|cv_serial
argument_list|,
name|ssvtp
operator|.
name|minvsn
argument_list|)
expr_stmt|;
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|scsi_send_volume_tag
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/* retries */
literal|1
argument_list|,
comment|/* cbfcnp */
name|chdone
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* element_address */
name|ea
argument_list|,
comment|/* send_action_code */
name|sac
argument_list|,
comment|/* parameters */
operator|&
name|ssvtp
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
name|CH_TIMEOUT_SEND_VOLTAG
argument_list|)
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|cherror
argument_list|,
comment|/*cam_flags*/
name|CAM_RETRY_SELTO
argument_list|,
comment|/*sense_flags*/
name|SF_RETRY_UA
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|chgetparams
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|ch_softc
modifier|*
name|softc
decl_stmt|;
name|void
modifier|*
name|mode_buffer
decl_stmt|;
name|int
name|mode_buffer_len
decl_stmt|;
name|struct
name|page_element_address_assignment
modifier|*
name|ea
decl_stmt|;
name|struct
name|page_device_capabilities
modifier|*
name|cap
decl_stmt|;
name|int
name|error
decl_stmt|,
name|from
decl_stmt|,
name|dbd
decl_stmt|;
name|u_int8_t
modifier|*
name|moves
decl_stmt|,
modifier|*
name|exchanges
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|ch_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * The scsi_mode_sense_data structure is just a convenience 	 * structure that allows us to easily calculate the worst-case 	 * storage size of the mode sense buffer. 	 */
name|mode_buffer_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_mode_sense_data
argument_list|)
expr_stmt|;
name|mode_buffer
operator|=
name|malloc
argument_list|(
name|mode_buffer_len
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode_buffer
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"chgetparams: couldn't malloc mode sense data\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
name|bzero
argument_list|(
name|mode_buffer
argument_list|,
name|mode_buffer_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|quirks
operator|&
name|CH_Q_NO_DBD
condition|)
name|dbd
operator|=
name|FALSE
expr_stmt|;
else|else
name|dbd
operator|=
name|TRUE
expr_stmt|;
comment|/* 	 * Get the element address assignment page. 	 */
name|scsi_mode_sense
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/* retries */
literal|1
argument_list|,
comment|/* cbfcnp */
name|chdone
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* dbd */
name|dbd
argument_list|,
comment|/* page_code */
name|SMS_PAGE_CTRL_CURRENT
argument_list|,
comment|/* page */
name|CH_ELEMENT_ADDR_ASSIGN_PAGE
argument_list|,
comment|/* param_buf */
operator|(
name|u_int8_t
operator|*
operator|)
name|mode_buffer
argument_list|,
comment|/* param_len */
name|mode_buffer_len
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
name|CH_TIMEOUT_MODE_SENSE
argument_list|)
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|cherror
argument_list|,
comment|/*cam_flags*/
name|CAM_RETRY_SELTO
argument_list|,
comment|/* sense_flags */
name|SF_RETRY_UA
operator||
name|SF_NO_PRINT
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|dbd
condition|)
block|{
name|struct
name|scsi_mode_sense_6
modifier|*
name|sms
decl_stmt|;
name|sms
operator|=
operator|(
expr|struct
name|scsi_mode_sense_6
operator|*
operator|)
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|sms
operator|->
name|byte2
operator|&=
operator|~
name|SMS_DBD
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|cherror
argument_list|,
comment|/*cam_flags*/
name|CAM_RETRY_SELTO
argument_list|,
comment|/*sense_flags*/
name|SF_RETRY_UA
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Since we disabled sense printing above, print 			 * out the sense here since we got an error. 			 */
name|scsi_sense_print
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"chgetparams: error getting element "
literal|"address page\n"
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mode_buffer
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|ea
operator|=
operator|(
expr|struct
name|page_element_address_assignment
operator|*
operator|)
name|find_mode_page_6
argument_list|(
operator|(
expr|struct
name|scsi_mode_header_6
operator|*
operator|)
name|mode_buffer
argument_list|)
expr_stmt|;
name|softc
operator|->
name|sc_firsts
index|[
name|CHET_MT
index|]
operator|=
name|scsi_2btoul
argument_list|(
name|ea
operator|->
name|mtea
argument_list|)
expr_stmt|;
name|softc
operator|->
name|sc_counts
index|[
name|CHET_MT
index|]
operator|=
name|scsi_2btoul
argument_list|(
name|ea
operator|->
name|nmte
argument_list|)
expr_stmt|;
name|softc
operator|->
name|sc_firsts
index|[
name|CHET_ST
index|]
operator|=
name|scsi_2btoul
argument_list|(
name|ea
operator|->
name|fsea
argument_list|)
expr_stmt|;
name|softc
operator|->
name|sc_counts
index|[
name|CHET_ST
index|]
operator|=
name|scsi_2btoul
argument_list|(
name|ea
operator|->
name|nse
argument_list|)
expr_stmt|;
name|softc
operator|->
name|sc_firsts
index|[
name|CHET_IE
index|]
operator|=
name|scsi_2btoul
argument_list|(
name|ea
operator|->
name|fieea
argument_list|)
expr_stmt|;
name|softc
operator|->
name|sc_counts
index|[
name|CHET_IE
index|]
operator|=
name|scsi_2btoul
argument_list|(
name|ea
operator|->
name|niee
argument_list|)
expr_stmt|;
name|softc
operator|->
name|sc_firsts
index|[
name|CHET_DT
index|]
operator|=
name|scsi_2btoul
argument_list|(
name|ea
operator|->
name|fdtea
argument_list|)
expr_stmt|;
name|softc
operator|->
name|sc_counts
index|[
name|CHET_DT
index|]
operator|=
name|scsi_2btoul
argument_list|(
name|ea
operator|->
name|ndte
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|mode_buffer
argument_list|,
name|mode_buffer_len
argument_list|)
expr_stmt|;
comment|/* 	 * Now get the device capabilities page. 	 */
name|scsi_mode_sense
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/* retries */
literal|1
argument_list|,
comment|/* cbfcnp */
name|chdone
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* dbd */
name|dbd
argument_list|,
comment|/* page_code */
name|SMS_PAGE_CTRL_CURRENT
argument_list|,
comment|/* page */
name|CH_DEVICE_CAP_PAGE
argument_list|,
comment|/* param_buf */
operator|(
name|u_int8_t
operator|*
operator|)
name|mode_buffer
argument_list|,
comment|/* param_len */
name|mode_buffer_len
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
name|CH_TIMEOUT_MODE_SENSE
argument_list|)
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|cherror
argument_list|,
comment|/*cam_flags*/
name|CAM_RETRY_SELTO
argument_list|,
comment|/* sense_flags */
name|SF_RETRY_UA
operator||
name|SF_NO_PRINT
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|dbd
condition|)
block|{
name|struct
name|scsi_mode_sense_6
modifier|*
name|sms
decl_stmt|;
name|sms
operator|=
operator|(
expr|struct
name|scsi_mode_sense_6
operator|*
operator|)
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|sms
operator|->
name|byte2
operator|&=
operator|~
name|SMS_DBD
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|cherror
argument_list|,
comment|/*cam_flags*/
name|CAM_RETRY_SELTO
argument_list|,
comment|/*sense_flags*/
name|SF_RETRY_UA
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Since we disabled sense printing above, print 			 * out the sense here since we got an error. 			 */
name|scsi_sense_print
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"chgetparams: error getting device "
literal|"capabilities page\n"
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mode_buffer
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|cap
operator|=
operator|(
expr|struct
name|page_device_capabilities
operator|*
operator|)
name|find_mode_page_6
argument_list|(
operator|(
expr|struct
name|scsi_mode_header_6
operator|*
operator|)
name|mode_buffer
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|softc
operator|->
name|sc_movemask
argument_list|,
sizeof|sizeof
argument_list|(
name|softc
operator|->
name|sc_movemask
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|softc
operator|->
name|sc_exchangemask
argument_list|,
sizeof|sizeof
argument_list|(
name|softc
operator|->
name|sc_exchangemask
argument_list|)
argument_list|)
expr_stmt|;
name|moves
operator|=
name|cap
operator|->
name|move_from
expr_stmt|;
name|exchanges
operator|=
name|cap
operator|->
name|exchange_with
expr_stmt|;
for|for
control|(
name|from
operator|=
name|CHET_MT
init|;
name|from
operator|<=
name|CHET_MAX
condition|;
operator|++
name|from
control|)
block|{
name|softc
operator|->
name|sc_movemask
index|[
name|from
index|]
operator|=
name|moves
index|[
name|from
index|]
expr_stmt|;
name|softc
operator|->
name|sc_exchangemask
index|[
name|from
index|]
operator|=
name|exchanges
index|[
name|from
index|]
expr_stmt|;
block|}
name|free
argument_list|(
name|mode_buffer
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|scsi_move_medium
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|u_int32_t
name|tea
parameter_list|,
name|u_int32_t
name|src
parameter_list|,
name|u_int32_t
name|dst
parameter_list|,
name|int
name|invert
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_move_medium
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_move_medium
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|MOVE_MEDIUM
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|tea
argument_list|,
name|scsi_cmd
operator|->
name|tea
argument_list|)
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|src
argument_list|,
name|scsi_cmd
operator|->
name|src
argument_list|)
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|dst
argument_list|,
name|scsi_cmd
operator|->
name|dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|invert
condition|)
name|scsi_cmd
operator|->
name|invert
operator||=
name|MOVE_MEDIUM_INVERT
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|CAM_DIR_NONE
argument_list|,
name|tag_action
argument_list|,
comment|/*data_ptr*/
name|NULL
argument_list|,
comment|/*dxfer_len*/
literal|0
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_exchange_medium
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|u_int32_t
name|tea
parameter_list|,
name|u_int32_t
name|src
parameter_list|,
name|u_int32_t
name|dst1
parameter_list|,
name|u_int32_t
name|dst2
parameter_list|,
name|int
name|invert1
parameter_list|,
name|int
name|invert2
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_exchange_medium
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_exchange_medium
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|EXCHANGE_MEDIUM
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|tea
argument_list|,
name|scsi_cmd
operator|->
name|tea
argument_list|)
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|src
argument_list|,
name|scsi_cmd
operator|->
name|src
argument_list|)
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|dst1
argument_list|,
name|scsi_cmd
operator|->
name|fdst
argument_list|)
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|dst2
argument_list|,
name|scsi_cmd
operator|->
name|sdst
argument_list|)
expr_stmt|;
if|if
condition|(
name|invert1
condition|)
name|scsi_cmd
operator|->
name|invert
operator||=
name|EXCHANGE_MEDIUM_INV1
expr_stmt|;
if|if
condition|(
name|invert2
condition|)
name|scsi_cmd
operator|->
name|invert
operator||=
name|EXCHANGE_MEDIUM_INV2
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|CAM_DIR_NONE
argument_list|,
name|tag_action
argument_list|,
comment|/*data_ptr*/
name|NULL
argument_list|,
comment|/*dxfer_len*/
literal|0
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_position_to_element
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|u_int32_t
name|tea
parameter_list|,
name|u_int32_t
name|dst
parameter_list|,
name|int
name|invert
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_position_to_element
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_position_to_element
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|POSITION_TO_ELEMENT
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|tea
argument_list|,
name|scsi_cmd
operator|->
name|tea
argument_list|)
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|dst
argument_list|,
name|scsi_cmd
operator|->
name|dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|invert
condition|)
name|scsi_cmd
operator|->
name|invert
operator||=
name|POSITION_TO_ELEMENT_INVERT
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|CAM_DIR_NONE
argument_list|,
name|tag_action
argument_list|,
comment|/*data_ptr*/
name|NULL
argument_list|,
comment|/*dxfer_len*/
literal|0
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_read_element_status
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|int
name|voltag
parameter_list|,
name|u_int32_t
name|sea
parameter_list|,
name|u_int32_t
name|count
parameter_list|,
name|u_int8_t
modifier|*
name|data_ptr
parameter_list|,
name|u_int32_t
name|dxfer_len
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_read_element_status
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_read_element_status
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|READ_ELEMENT_STATUS
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|sea
argument_list|,
name|scsi_cmd
operator|->
name|sea
argument_list|)
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|count
argument_list|,
name|scsi_cmd
operator|->
name|count
argument_list|)
expr_stmt|;
name|scsi_ulto3b
argument_list|(
name|dxfer_len
argument_list|,
name|scsi_cmd
operator|->
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|voltag
condition|)
name|scsi_cmd
operator|->
name|byte2
operator||=
name|READ_ELEMENT_STATUS_VOLTAG
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|CAM_DIR_IN
argument_list|,
name|tag_action
argument_list|,
name|data_ptr
argument_list|,
name|dxfer_len
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_initialize_element_status
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_initialize_element_status
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_initialize_element_status
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|INITIALIZE_ELEMENT_STATUS
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|CAM_DIR_NONE
argument_list|,
name|tag_action
argument_list|,
comment|/* data_ptr */
name|NULL
argument_list|,
comment|/* dxfer_len */
literal|0
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_send_volume_tag
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|u_int16_t
name|element_address
parameter_list|,
name|u_int8_t
name|send_action_code
parameter_list|,
name|struct
name|scsi_send_volume_tag_parameters
modifier|*
name|parameters
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_send_volume_tag
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_send_volume_tag
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|SEND_VOLUME_TAG
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|element_address
argument_list|,
name|scsi_cmd
operator|->
name|ea
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|sac
operator|=
name|send_action_code
expr_stmt|;
name|scsi_ulto2b
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|parameters
argument_list|)
argument_list|,
name|scsi_cmd
operator|->
name|pll
argument_list|)
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|CAM_DIR_OUT
argument_list|,
name|tag_action
argument_list|,
comment|/* data_ptr */
operator|(
name|u_int8_t
operator|*
operator|)
name|parameters
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|parameters
argument_list|)
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

