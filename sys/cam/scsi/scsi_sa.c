begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Implementation of SCSI Sequential Access Peripheral driver for CAM.  *  * Copyright (c) 1999, 2000 Matthew Jacob  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mtio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/devicestat.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|_KERNEL
end_ifndef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_sa.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<opt_sa.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|SA_IO_TIMEOUT
end_ifndef

begin_define
define|#
directive|define
name|SA_IO_TIMEOUT
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SA_SPACE_TIMEOUT
end_ifndef

begin_define
define|#
directive|define
name|SA_SPACE_TIMEOUT
value|1 * 60
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SA_REWIND_TIMEOUT
end_ifndef

begin_define
define|#
directive|define
name|SA_REWIND_TIMEOUT
value|2 * 60
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SA_ERASE_TIMEOUT
end_ifndef

begin_define
define|#
directive|define
name|SA_ERASE_TIMEOUT
value|4 * 60
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SCSIOP_TIMEOUT
value|(60 * 1000)
end_define

begin_comment
comment|/* not an option */
end_comment

begin_define
define|#
directive|define
name|IO_TIMEOUT
value|(SA_IO_TIMEOUT * 60 * 1000)
end_define

begin_define
define|#
directive|define
name|REWIND_TIMEOUT
value|(SA_REWIND_TIMEOUT * 60 * 1000)
end_define

begin_define
define|#
directive|define
name|ERASE_TIMEOUT
value|(SA_ERASE_TIMEOUT * 60 * 1000)
end_define

begin_define
define|#
directive|define
name|SPACE_TIMEOUT
value|(SA_SPACE_TIMEOUT * 60 * 1000)
end_define

begin_comment
comment|/*  * Additional options that can be set for config: SA_1FM_AT_EOT  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|UNUSED_PARAMETER
end_ifndef

begin_define
define|#
directive|define
name|UNUSED_PARAMETER
parameter_list|(
name|x
parameter_list|)
value|x = x
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|QFRLS
parameter_list|(
name|ccb
parameter_list|)
define|\
value|if (((ccb)->ccb_h.status& CAM_DEV_QFRZN) != 0)	\ 		cam_release_devq((ccb)->ccb_h.path, 0, 0, 0, FALSE)
end_define

begin_comment
comment|/*  * Driver states  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|SA_STATE_NORMAL
block|,
name|SA_STATE_ABNORMAL
block|}
name|sa_state
typedef|;
end_typedef

begin_define
define|#
directive|define
name|ccb_pflags
value|ppriv_field0
end_define

begin_define
define|#
directive|define
name|ccb_bp
value|ppriv_ptr1
end_define

begin_define
define|#
directive|define
name|SA_CCB_BUFFER_IO
value|0x0
end_define

begin_define
define|#
directive|define
name|SA_CCB_WAITING
value|0x1
end_define

begin_define
define|#
directive|define
name|SA_CCB_TYPEMASK
value|0x1
end_define

begin_define
define|#
directive|define
name|SA_POSITION_UPDATED
value|0x2
end_define

begin_define
define|#
directive|define
name|Set_CCB_Type
parameter_list|(
name|x
parameter_list|,
name|type
parameter_list|)
define|\
value|x->ccb_h.ccb_pflags&= ~SA_CCB_TYPEMASK;	\ 	x->ccb_h.ccb_pflags |= type
end_define

begin_define
define|#
directive|define
name|CCB_Type
parameter_list|(
name|x
parameter_list|)
value|(x->ccb_h.ccb_pflags& SA_CCB_TYPEMASK)
end_define

begin_typedef
typedef|typedef
enum|enum
block|{
name|SA_FLAG_OPEN
init|=
literal|0x0001
block|,
name|SA_FLAG_FIXED
init|=
literal|0x0002
block|,
name|SA_FLAG_TAPE_LOCKED
init|=
literal|0x0004
block|,
name|SA_FLAG_TAPE_MOUNTED
init|=
literal|0x0008
block|,
name|SA_FLAG_TAPE_WP
init|=
literal|0x0010
block|,
name|SA_FLAG_TAPE_WRITTEN
init|=
literal|0x0020
block|,
name|SA_FLAG_EOM_PENDING
init|=
literal|0x0040
block|,
name|SA_FLAG_EIO_PENDING
init|=
literal|0x0080
block|,
name|SA_FLAG_EOF_PENDING
init|=
literal|0x0100
block|,
name|SA_FLAG_ERR_PENDING
init|=
operator|(
name|SA_FLAG_EOM_PENDING
operator||
name|SA_FLAG_EIO_PENDING
operator||
name|SA_FLAG_EOF_PENDING
operator|)
block|,
name|SA_FLAG_INVALID
init|=
literal|0x0200
block|,
name|SA_FLAG_COMP_ENABLED
init|=
literal|0x0400
block|,
name|SA_FLAG_COMP_SUPP
init|=
literal|0x0800
block|,
name|SA_FLAG_COMP_UNSUPP
init|=
literal|0x1000
block|,
name|SA_FLAG_TAPE_FROZEN
init|=
literal|0x2000
block|}
name|sa_flags
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|SA_MODE_REWIND
init|=
literal|0x00
block|,
name|SA_MODE_NOREWIND
init|=
literal|0x01
block|,
name|SA_MODE_OFFLINE
init|=
literal|0x02
block|}
name|sa_mode
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|SA_PARAM_NONE
init|=
literal|0x00
block|,
name|SA_PARAM_BLOCKSIZE
init|=
literal|0x01
block|,
name|SA_PARAM_DENSITY
init|=
literal|0x02
block|,
name|SA_PARAM_COMPRESSION
init|=
literal|0x04
block|,
name|SA_PARAM_BUFF_MODE
init|=
literal|0x08
block|,
name|SA_PARAM_NUMBLOCKS
init|=
literal|0x10
block|,
name|SA_PARAM_WP
init|=
literal|0x20
block|,
name|SA_PARAM_SPEED
init|=
literal|0x40
block|,
name|SA_PARAM_ALL
init|=
literal|0x7f
block|}
name|sa_params
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|SA_QUIRK_NONE
init|=
literal|0x00
block|,
name|SA_QUIRK_NOCOMP
init|=
literal|0x01
block|,
comment|/* Can't deal with compression at all */
name|SA_QUIRK_FIXED
init|=
literal|0x02
block|,
comment|/* Force fixed mode */
name|SA_QUIRK_VARIABLE
init|=
literal|0x04
block|,
comment|/* Force variable mode */
name|SA_QUIRK_2FM
init|=
literal|0x08
block|,
comment|/* Needs Two File Marks at EOD */
name|SA_QUIRK_1FM
init|=
literal|0x10
block|,
comment|/* No more than 1 File Mark at EOD */
name|SA_QUIRK_NODREAD
init|=
literal|0x20
block|,
comment|/* Don't try and dummy read density */
name|SA_QUIRK_NO_MODESEL
init|=
literal|0x40
block|,
comment|/* Don't do mode select at all */
name|SA_QUIRK_NO_CPAGE
init|=
literal|0x80
comment|/* Don't use DEVICE COMPRESSION page */
block|}
name|sa_quirks
typedef|;
end_typedef

begin_comment
comment|/* units are bits 4-7, 16-21 (1024 units) */
end_comment

begin_define
define|#
directive|define
name|SAUNIT
parameter_list|(
name|DEV
parameter_list|)
define|\
value|(((minor(DEV)& 0xF0)>> 4) |  ((minor(DEV)& 0x3f0000)>> 16))
end_define

begin_define
define|#
directive|define
name|SAMODE
parameter_list|(
name|z
parameter_list|)
value|((minor(z)& 0x3))
end_define

begin_define
define|#
directive|define
name|SADENSITY
parameter_list|(
name|z
parameter_list|)
value|(((minor(z)>> 2)& 0x3))
end_define

begin_define
define|#
directive|define
name|SA_IS_CTRL
parameter_list|(
name|z
parameter_list|)
value|(minor(z)& (1<< 29))
end_define

begin_define
define|#
directive|define
name|SA_NOT_CTLDEV
value|0
end_define

begin_define
define|#
directive|define
name|SA_CTLDEV
value|1
end_define

begin_define
define|#
directive|define
name|SA_ATYPE_R
value|0
end_define

begin_define
define|#
directive|define
name|SA_ATYPE_NR
value|1
end_define

begin_define
define|#
directive|define
name|SA_ATYPE_ER
value|2
end_define

begin_define
define|#
directive|define
name|SAMINOR
parameter_list|(
name|ctl
parameter_list|,
name|unit
parameter_list|,
name|mode
parameter_list|,
name|access
parameter_list|)
define|\
value|((ctl<< 29) | ((unit& 0x3f0)<< 16) | ((unit& 0xf)<< 4) | \ 	(mode<< 0x2) | (access& 0x3))
end_define

begin_define
define|#
directive|define
name|SA_NUM_MODES
value|4
end_define

begin_struct
struct|struct
name|sa_devs
block|{
name|struct
name|cdev
modifier|*
name|ctl_dev
decl_stmt|;
struct|struct
name|sa_mode_devs
block|{
name|struct
name|cdev
modifier|*
name|r_dev
decl_stmt|;
name|struct
name|cdev
modifier|*
name|nr_dev
decl_stmt|;
name|struct
name|cdev
modifier|*
name|er_dev
decl_stmt|;
block|}
name|mode_devs
index|[
name|SA_NUM_MODES
index|]
struct|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sa_softc
block|{
name|sa_state
name|state
decl_stmt|;
name|sa_flags
name|flags
decl_stmt|;
name|sa_quirks
name|quirks
decl_stmt|;
name|struct
name|bio_queue_head
name|bio_queue
decl_stmt|;
name|int
name|queue_count
decl_stmt|;
name|struct
name|devstat
modifier|*
name|device_stats
decl_stmt|;
name|struct
name|sa_devs
name|devs
decl_stmt|;
name|int
name|blk_gran
decl_stmt|;
name|int
name|blk_mask
decl_stmt|;
name|int
name|blk_shift
decl_stmt|;
name|u_int32_t
name|max_blk
decl_stmt|;
name|u_int32_t
name|min_blk
decl_stmt|;
name|u_int32_t
name|comp_algorithm
decl_stmt|;
name|u_int32_t
name|saved_comp_algorithm
decl_stmt|;
name|u_int32_t
name|media_blksize
decl_stmt|;
name|u_int32_t
name|last_media_blksize
decl_stmt|;
name|u_int32_t
name|media_numblks
decl_stmt|;
name|u_int8_t
name|media_density
decl_stmt|;
name|u_int8_t
name|speed
decl_stmt|;
name|u_int8_t
name|scsi_rev
decl_stmt|;
name|u_int8_t
name|dsreg
decl_stmt|;
comment|/* mtio mt_dsreg, redux */
name|int
name|buffer_mode
decl_stmt|;
name|int
name|filemarks
decl_stmt|;
name|union
name|ccb
name|saved_ccb
decl_stmt|;
name|int
name|last_resid_was_io
decl_stmt|;
comment|/* 	 * Relative to BOT Location. 	 */
name|daddr_t
name|fileno
decl_stmt|;
name|daddr_t
name|blkno
decl_stmt|;
comment|/* 	 * Latched Error Info 	 */
struct|struct
block|{
name|struct
name|scsi_sense_data
name|_last_io_sense
decl_stmt|;
name|u_int32_t
name|_last_io_resid
decl_stmt|;
name|u_int8_t
name|_last_io_cdb
index|[
name|CAM_MAX_CDBLEN
index|]
decl_stmt|;
name|struct
name|scsi_sense_data
name|_last_ctl_sense
decl_stmt|;
name|u_int32_t
name|_last_ctl_resid
decl_stmt|;
name|u_int8_t
name|_last_ctl_cdb
index|[
name|CAM_MAX_CDBLEN
index|]
decl_stmt|;
define|#
directive|define
name|last_io_sense
value|errinfo._last_io_sense
define|#
directive|define
name|last_io_resid
value|errinfo._last_io_resid
define|#
directive|define
name|last_io_cdb
value|errinfo._last_io_cdb
define|#
directive|define
name|last_ctl_sense
value|errinfo._last_ctl_sense
define|#
directive|define
name|last_ctl_resid
value|errinfo._last_ctl_resid
define|#
directive|define
name|last_ctl_cdb
value|errinfo._last_ctl_cdb
block|}
name|errinfo
struct|;
comment|/* 	 * Misc other flags/state 	 */
name|u_int32_t
label|:
literal|31
operator|,
name|ctrl_mode
operator|:
literal|1
expr_stmt|;
comment|/* control device open */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sa_quirk_entry
block|{
name|struct
name|scsi_inquiry_pattern
name|inq_pat
decl_stmt|;
comment|/* matching pattern */
name|sa_quirks
name|quirks
decl_stmt|;
comment|/* specific quirk type */
name|u_int32_t
name|prefblk
decl_stmt|;
comment|/* preferred blocksize when in fixed mode */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|sa_quirk_entry
name|sa_quirk_table
index|[]
init|=
block|{
block|{
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"OnStream"
block|,
literal|"ADR*"
block|,
literal|"*"
block|}
block|,
name|SA_QUIRK_FIXED
operator||
name|SA_QUIRK_NODREAD
operator||
name|SA_QUIRK_1FM
operator||
name|SA_QUIRK_NO_MODESEL
block|,
literal|32768
block|}
block|,
block|{
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"ARCHIVE"
block|,
literal|"Python 06408*"
block|,
literal|"*"
block|}
block|,
name|SA_QUIRK_NODREAD
block|,
literal|0
block|}
block|,
block|{
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"ARCHIVE"
block|,
literal|"Python 25601*"
block|,
literal|"*"
block|}
block|,
name|SA_QUIRK_NOCOMP
operator||
name|SA_QUIRK_NODREAD
block|,
literal|0
block|}
block|,
block|{
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"ARCHIVE"
block|,
literal|"Python*"
block|,
literal|"*"
block|}
block|,
name|SA_QUIRK_NODREAD
block|,
literal|0
block|}
block|,
block|{
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"ARCHIVE"
block|,
literal|"VIPER 150*"
block|,
literal|"*"
block|}
block|,
name|SA_QUIRK_FIXED
operator||
name|SA_QUIRK_1FM
block|,
literal|512
block|}
block|,
block|{
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"ARCHIVE"
block|,
literal|"VIPER 2525 25462"
block|,
literal|"-011"
block|}
block|,
name|SA_QUIRK_NOCOMP
operator||
name|SA_QUIRK_1FM
operator||
name|SA_QUIRK_NODREAD
block|,
literal|0
block|}
block|,
block|{
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"ARCHIVE"
block|,
literal|"VIPER 2525*"
block|,
literal|"*"
block|}
block|,
name|SA_QUIRK_FIXED
operator||
name|SA_QUIRK_1FM
block|,
literal|1024
block|}
block|,
if|#
directive|if
literal|0
block|{ 		{ T_SEQUENTIAL, SIP_MEDIA_REMOVABLE, "HP", 		  "C15*", "*"}, SA_QUIRK_VARIABLE|SA_QUIRK_NO_CPAGE, 0, 	},
endif|#
directive|endif
block|{
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"HP"
block|,
literal|"C56*"
block|,
literal|"*"
block|}
block|,
name|SA_QUIRK_VARIABLE
operator||
name|SA_QUIRK_2FM
block|,
literal|0
block|}
block|,
block|{
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"HP"
block|,
literal|"T20*"
block|,
literal|"*"
block|}
block|,
name|SA_QUIRK_FIXED
operator||
name|SA_QUIRK_1FM
block|,
literal|512
block|}
block|,
block|{
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"HP"
block|,
literal|"T4000*"
block|,
literal|"*"
block|}
block|,
name|SA_QUIRK_FIXED
operator||
name|SA_QUIRK_1FM
block|,
literal|512
block|}
block|,
block|{
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"HP"
block|,
literal|"HP-88780*"
block|,
literal|"*"
block|}
block|,
name|SA_QUIRK_VARIABLE
operator||
name|SA_QUIRK_2FM
block|,
literal|0
block|}
block|,
block|{
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"KENNEDY"
block|,
literal|"*"
block|,
literal|"*"
block|}
block|,
name|SA_QUIRK_VARIABLE
operator||
name|SA_QUIRK_2FM
block|,
literal|0
block|}
block|,
block|{
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"M4 DATA"
block|,
literal|"123107 SCSI*"
block|,
literal|"*"
block|}
block|,
name|SA_QUIRK_VARIABLE
operator||
name|SA_QUIRK_2FM
block|,
literal|0
block|}
block|,
block|{
comment|/* jreynold@primenet.com */
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"Seagate"
block|,
literal|"STT8000N*"
block|,
literal|"*"
block|}
block|,
name|SA_QUIRK_1FM
block|,
literal|0
block|}
block|,
block|{
comment|/* mike@sentex.net */
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"Seagate"
block|,
literal|"STT20000*"
block|,
literal|"*"
block|}
block|,
name|SA_QUIRK_1FM
block|,
literal|0
block|}
block|,
block|{
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"TANDBERG"
block|,
literal|" TDC 3600"
block|,
literal|"U07:"
block|}
block|,
name|SA_QUIRK_NOCOMP
operator||
name|SA_QUIRK_1FM
block|,
literal|512
block|}
block|,
block|{
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"TANDBERG"
block|,
literal|" TDC 3800"
block|,
literal|"*"
block|}
block|,
name|SA_QUIRK_NOCOMP
operator||
name|SA_QUIRK_1FM
block|,
literal|512
block|}
block|,
block|{
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"TANDBERG"
block|,
literal|" TDC 4100"
block|,
literal|"*"
block|}
block|,
name|SA_QUIRK_NOCOMP
operator||
name|SA_QUIRK_1FM
block|,
literal|512
block|}
block|,
block|{
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"TANDBERG"
block|,
literal|" TDC 4200"
block|,
literal|"*"
block|}
block|,
name|SA_QUIRK_NOCOMP
operator||
name|SA_QUIRK_1FM
block|,
literal|512
block|}
block|,
block|{
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"TANDBERG"
block|,
literal|" SLR*"
block|,
literal|"*"
block|}
block|,
name|SA_QUIRK_1FM
block|,
literal|0
block|}
block|,
block|{
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"WANGTEK"
block|,
literal|"5525ES*"
block|,
literal|"*"
block|}
block|,
name|SA_QUIRK_FIXED
operator||
name|SA_QUIRK_1FM
block|,
literal|512
block|}
block|,
block|{
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"WANGTEK"
block|,
literal|"51000*"
block|,
literal|"*"
block|}
block|,
name|SA_QUIRK_FIXED
operator||
name|SA_QUIRK_1FM
block|,
literal|1024
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|saopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|saclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_strategy_t
name|sastrategy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|saioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_init_t
name|sainit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_ctor_t
name|saregister
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_oninv_t
name|saoninvalidate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_dtor_t
name|sacleanup
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_start_t
name|sastart
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|saasync
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|u_int32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sadone
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|start_ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|saerror
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|u_int32_t
name|cam_flags
parameter_list|,
name|u_int32_t
name|sense_flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|samarkswanted
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sacheckeod
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sagetparams
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|sa_params
name|params_to_get
parameter_list|,
name|u_int32_t
modifier|*
name|blocksize
parameter_list|,
name|u_int8_t
modifier|*
name|density
parameter_list|,
name|u_int32_t
modifier|*
name|numblocks
parameter_list|,
name|int
modifier|*
name|buff_mode
parameter_list|,
name|u_int8_t
modifier|*
name|write_protect
parameter_list|,
name|u_int8_t
modifier|*
name|speed
parameter_list|,
name|int
modifier|*
name|comp_supported
parameter_list|,
name|int
modifier|*
name|comp_enabled
parameter_list|,
name|u_int32_t
modifier|*
name|comp_algorithm
parameter_list|,
name|sa_comp_t
modifier|*
name|comp_page
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sasetparams
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|sa_params
name|params_to_set
parameter_list|,
name|u_int32_t
name|blocksize
parameter_list|,
name|u_int8_t
name|density
parameter_list|,
name|u_int32_t
name|comp_algorithm
parameter_list|,
name|u_int32_t
name|sense_flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|saprevent
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|action
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sarewind
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|saspace
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|count
parameter_list|,
name|scsi_space_code
name|code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|samount
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|cdev
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|saretension
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sareservereleaseunit
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|reserve
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|saloadunload
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|load
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|saerase
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|longerase
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sawritefilemarks
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|nmarks
parameter_list|,
name|int
name|setmarks
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sardpos
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
parameter_list|,
name|u_int32_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sasetpos
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
parameter_list|,
name|u_int32_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|periph_driver
name|sadriver
init|=
block|{
name|sainit
block|,
literal|"sa"
block|,
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|sadriver
operator|.
name|units
argument_list|)
block|,
comment|/* generation */
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|PERIPHDRIVER_DECLARE
argument_list|(
name|sa
argument_list|,
name|sadriver
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* For 2.2-stable support */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|D_TAPE
end_ifndef

begin_define
define|#
directive|define
name|D_TAPE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|sa_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_open
operator|=
name|saopen
block|,
operator|.
name|d_close
operator|=
name|saclose
block|,
operator|.
name|d_read
operator|=
name|physread
block|,
operator|.
name|d_write
operator|=
name|physwrite
block|,
operator|.
name|d_ioctl
operator|=
name|saioctl
block|,
operator|.
name|d_strategy
operator|=
name|sastrategy
block|,
operator|.
name|d_name
operator|=
literal|"sa"
block|,
operator|.
name|d_flags
operator|=
name|D_TAPE
operator||
name|D_NEEDGIANT
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|saopen
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|s
decl_stmt|;
name|unit
operator|=
name|SAUNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|s
operator|=
name|splsoftcam
argument_list|()
expr_stmt|;
name|periph
operator|=
operator|(
expr|struct
name|cam_periph
operator|*
operator|)
name|dev
operator|->
name|si_drv1
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|cam_periph_lock
argument_list|(
name|periph
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_TRACE
operator||
name|CAM_DEBUG_INFO
argument_list|,
operator|(
literal|"saopen(%d): dev=0x%x softc=0x%x\n"
operator|,
name|unit
operator|,
name|unit
operator|,
name|softc
operator|->
name|flags
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cam_periph_acquire
argument_list|(
name|periph
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|SA_IS_CTRL
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|softc
operator|->
name|ctrl_mode
operator|=
literal|1
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_OPEN
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_INVALID
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * The function samount ensures media is loaded and ready. 		 * It also does a device RESERVE if the tape isn't yet mounted. 		 */
name|error
operator|=
name|samount
argument_list|(
name|periph
argument_list|,
name|flags
argument_list|,
name|dev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|cam_periph_release
argument_list|(
name|periph
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|saprevent
argument_list|(
name|periph
argument_list|,
name|PR_PREVENT
argument_list|)
expr_stmt|;
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_OPEN
expr_stmt|;
block|}
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|saclose
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|mode
decl_stmt|,
name|error
decl_stmt|,
name|writing
decl_stmt|,
name|tmp
decl_stmt|;
name|int
name|closedbits
init|=
name|SA_FLAG_OPEN
decl_stmt|;
name|unit
operator|=
name|SAUNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mode
operator|=
name|SAMODE
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|periph
operator|=
operator|(
expr|struct
name|cam_periph
operator|*
operator|)
name|dev
operator|->
name|si_drv1
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_TRACE
operator||
name|CAM_DEBUG_INFO
argument_list|,
operator|(
literal|"saclose(%d): dev=0x%x softc=0x%x\n"
operator|,
name|unit
operator|,
name|unit
operator|,
name|softc
operator|->
name|flags
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|cam_periph_lock
argument_list|(
name|periph
argument_list|,
name|PRIBIO
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|SA_IS_CTRL
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|softc
operator|->
name|ctrl_mode
operator|=
literal|0
expr_stmt|;
name|cam_periph_release
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Were we writing the tape? 	 */
name|writing
operator|=
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_TAPE_WRITTEN
operator|)
operator|!=
literal|0
expr_stmt|;
comment|/* 	 * See whether or not we need to write filemarks. If this 	 * fails, we probably have to assume we've lost tape 	 * position. 	 */
name|error
operator|=
name|sacheckeod
argument_list|(
name|periph
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"failed to write terminating filemark(s)\n"
argument_list|)
expr_stmt|;
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_TAPE_FROZEN
expr_stmt|;
block|}
comment|/* 	 * Whatever we end up doing, allow users to eject tapes from here on. 	 */
name|saprevent
argument_list|(
name|periph
argument_list|,
name|PR_ALLOW
argument_list|)
expr_stmt|;
comment|/* 	 * Decide how to end... 	 */
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_TAPE_MOUNTED
operator|)
operator|==
literal|0
condition|)
block|{
name|closedbits
operator||=
name|SA_FLAG_TAPE_FROZEN
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|SA_MODE_OFFLINE
case|:
comment|/* 		 * An 'offline' close is an unconditional release of 		 * frozen&& mount conditions, irrespective of whether 		 * these operations succeeded. The reason for this is 		 * to allow at least some kind of programmatic way 		 * around our state getting all fouled up. If somebody 		 * issues an 'offline' command, that will be allowed 		 * to clear state. 		 */
operator|(
name|void
operator|)
name|sarewind
argument_list|(
name|periph
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|saloadunload
argument_list|(
name|periph
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|closedbits
operator||=
name|SA_FLAG_TAPE_MOUNTED
operator||
name|SA_FLAG_TAPE_FROZEN
expr_stmt|;
break|break;
case|case
name|SA_MODE_REWIND
case|:
comment|/* 		 * If the rewind fails, return an error- if anyone cares, 		 * but not overwriting any previous error. 		 * 		 * We don't clear the notion of mounted here, but we do 		 * clear the notion of frozen if we successfully rewound. 		 */
name|tmp
operator|=
name|sarewind
argument_list|(
name|periph
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
block|{
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|error
operator|=
name|tmp
expr_stmt|;
block|}
else|else
block|{
name|closedbits
operator||=
name|SA_FLAG_TAPE_FROZEN
expr_stmt|;
block|}
break|break;
case|case
name|SA_MODE_NOREWIND
case|:
comment|/* 		 * If we're not rewinding/unloading the tape, find out 		 * whether we need to back up over one of two filemarks 		 * we wrote (if we wrote two filemarks) so that appends 		 * from this point on will be sane. 		 */
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|writing
operator|&&
operator|(
name|softc
operator|->
name|quirks
operator|&
name|SA_QUIRK_2FM
operator|)
condition|)
block|{
name|tmp
operator|=
name|saspace
argument_list|(
name|periph
argument_list|,
operator|-
literal|1
argument_list|,
name|SS_FILEMARKS
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
block|{
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"unable to backspace over one of double"
literal|" filemarks at end of tape\n"
argument_list|)
expr_stmt|;
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"it is possible that this device"
literal|" needs a SA_QUIRK_1FM quirk set for it\n"
argument_list|)
expr_stmt|;
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_TAPE_FROZEN
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"unknown mode 0x%x in saclose"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
break|break;
block|}
comment|/* 	 * We wish to note here that there are no more filemarks to be written. 	 */
name|softc
operator|->
name|filemarks
operator|=
literal|0
expr_stmt|;
name|softc
operator|->
name|flags
operator|&=
operator|~
name|SA_FLAG_TAPE_WRITTEN
expr_stmt|;
comment|/* 	 * And we are no longer open for business. 	 */
name|softc
operator|->
name|flags
operator|&=
operator|~
name|closedbits
expr_stmt|;
comment|/* 	 * Inform users if tape state if frozen.... 	 */
if|if
condition|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_TAPE_FROZEN
condition|)
block|{
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"tape is now frozen- use an OFFLINE, REWIND or MTEOM "
literal|"command to clear this state.\n"
argument_list|)
expr_stmt|;
block|}
comment|/* release the device if it is no longer mounted */
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_TAPE_MOUNTED
operator|)
operator|==
literal|0
condition|)
name|sareservereleaseunit
argument_list|(
name|periph
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|cam_periph_release
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Actually translate the requested transfer into one the physical driver  * can understand.  The transfer is described by a buf and will include  * only one physical transfer.  */
end_comment

begin_function
specifier|static
name|void
name|sastrategy
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|s
decl_stmt|;
name|bp
operator|->
name|bio_resid
operator|=
name|bp
operator|->
name|bio_bcount
expr_stmt|;
if|if
condition|(
name|SA_IS_CTRL
argument_list|(
name|bp
operator|->
name|bio_dev
argument_list|)
condition|)
block|{
name|biofinish
argument_list|(
name|bp
argument_list|,
name|NULL
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return;
block|}
name|periph
operator|=
operator|(
expr|struct
name|cam_periph
operator|*
operator|)
name|bp
operator|->
name|bio_dev
operator|->
name|si_drv1
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
block|{
name|biofinish
argument_list|(
name|bp
argument_list|,
name|NULL
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
return|return;
block|}
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|s
operator|=
name|splsoftcam
argument_list|()
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_INVALID
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|biofinish
argument_list|(
name|bp
argument_list|,
name|NULL
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_TAPE_FROZEN
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|biofinish
argument_list|(
name|bp
argument_list|,
name|NULL
argument_list|,
name|EPERM
argument_list|)
expr_stmt|;
return|return;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * If it's a null transfer, return immediatly 	 */
if|if
condition|(
name|bp
operator|->
name|bio_bcount
operator|==
literal|0
condition|)
block|{
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* valid request?  */
if|if
condition|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_FIXED
condition|)
block|{
comment|/* 		 * Fixed block device.  The byte count must 		 * be a multiple of our block size. 		 */
if|if
condition|(
operator|(
operator|(
name|softc
operator|->
name|blk_mask
operator|!=
operator|~
literal|0
operator|)
operator|&&
operator|(
operator|(
name|bp
operator|->
name|bio_bcount
operator|&
name|softc
operator|->
name|blk_mask
operator|)
operator|!=
literal|0
operator|)
operator|)
operator|||
operator|(
operator|(
name|softc
operator|->
name|blk_mask
operator|==
operator|~
literal|0
operator|)
operator|&&
operator|(
operator|(
name|bp
operator|->
name|bio_bcount
operator|%
name|softc
operator|->
name|min_blk
operator|)
operator|!=
literal|0
operator|)
operator|)
condition|)
block|{
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Invalid request.  Fixed block device "
literal|"requests must be a multiple "
literal|"of %d bytes\n"
argument_list|,
name|softc
operator|->
name|min_blk
argument_list|)
expr_stmt|;
name|biofinish
argument_list|(
name|bp
argument_list|,
name|NULL
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|bp
operator|->
name|bio_bcount
operator|>
name|softc
operator|->
name|max_blk
operator|)
operator|||
operator|(
name|bp
operator|->
name|bio_bcount
operator|<
name|softc
operator|->
name|min_blk
operator|)
operator|||
operator|(
name|bp
operator|->
name|bio_bcount
operator|&
name|softc
operator|->
name|blk_mask
operator|)
operator|!=
literal|0
condition|)
block|{
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Invalid request.  Variable block device "
literal|"requests must be "
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|blk_mask
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"a multiple of %d "
argument_list|,
operator|(
literal|0x1
operator|<<
name|softc
operator|->
name|blk_gran
operator|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"between %d and %d bytes\n"
argument_list|,
name|softc
operator|->
name|min_blk
argument_list|,
name|softc
operator|->
name|max_blk
argument_list|)
expr_stmt|;
name|biofinish
argument_list|(
name|bp
argument_list|,
name|NULL
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Mask interrupts so that the device cannot be invalidated until 	 * after we are in the queue.  Otherwise, we might not properly 	 * clean up one of the buffers. 	 */
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* 	 * Place it at the end of the queue. 	 */
name|bioq_insert_tail
argument_list|(
operator|&
name|softc
operator|->
name|bio_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|softc
operator|->
name|queue_count
operator|++
expr_stmt|;
if|#
directive|if
literal|0
block|CAM_DEBUG(periph->path, CAM_DEBUG_INFO, 	    ("sastrategy: queuing a %ld %s byte %s\n", bp->bio_bcount,  	    (softc->flags& SA_FLAG_FIXED)?  "fixed" : "variable", 	    (bp->bio_cmd == BIO_READ)? "read" : "write"));
endif|#
directive|endif
if|if
condition|(
name|softc
operator|->
name|queue_count
operator|>
literal|1
condition|)
block|{
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_INFO
argument_list|,
operator|(
literal|"sastrategy: queue count now %d\n"
operator|,
name|softc
operator|->
name|queue_count
operator|)
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Schedule ourselves for performing the work. 	 */
name|xpt_schedule
argument_list|(
name|periph
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|saioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|scsi_space_code
name|spaceop
decl_stmt|;
name|int
name|didlockperiph
init|=
literal|0
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|mode
operator|=
name|SAMODE
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* shut up gcc */
name|spaceop
operator|=
literal|0
expr_stmt|;
comment|/* shut up gcc */
name|periph
operator|=
operator|(
expr|struct
name|cam_periph
operator|*
operator|)
name|dev
operator|->
name|si_drv1
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
comment|/* 	 * Check for control mode accesses. We allow MTIOCGET and 	 * MTIOCERRSTAT (but need to be the only one open in order 	 * to clear latched status), and MTSETBSIZE, MTSETDNSTY 	 * and MTCOMP (but need to be the only one accessing this 	 * device to run those). 	 */
if|if
condition|(
name|SA_IS_CTRL
argument_list|(
name|dev
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MTIOCGETEOTMODEL
case|:
case|case
name|MTIOCGET
case|:
break|break;
case|case
name|MTIOCERRSTAT
case|:
comment|/* 			 * If the periph isn't already locked, lock it 			 * so our MTIOCERRSTAT can reset latched error stats. 			 * 			 * If the periph is already locked, skip it because 			 * we're just getting status and it'll be up to the 			 * other thread that has this device open to do 			 * an MTIOCERRSTAT that would clear latched status. 			 */
name|s
operator|=
name|splsoftcam
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|periph
operator|->
name|flags
operator|&
name|CAM_PERIPH_LOCKED
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|cam_periph_lock
argument_list|(
name|periph
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|didlockperiph
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|MTIOCSETEOTMODEL
case|:
case|case
name|MTSETBSIZ
case|:
case|case
name|MTSETDNSTY
case|:
case|case
name|MTCOMP
case|:
comment|/* 			 * We need to acquire the peripheral here rather 			 * than at open time because we are sharing writable 			 * access to data structures. 			 */
name|s
operator|=
name|splsoftcam
argument_list|()
expr_stmt|;
name|error
operator|=
name|cam_periph_lock
argument_list|(
name|periph
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|didlockperiph
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
comment|/* 	 * Find the device that the user is talking about 	 */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MTIOCGET
case|:
block|{
name|struct
name|mtget
modifier|*
name|g
init|=
operator|(
expr|struct
name|mtget
operator|*
operator|)
name|arg
decl_stmt|;
comment|/* 		 * If this isn't the control mode device, actually go out 		 * and ask the drive again what it's set to. 		 */
if|if
condition|(
operator|!
name|SA_IS_CTRL
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|u_int8_t
name|write_protect
decl_stmt|;
name|int
name|comp_enabled
decl_stmt|,
name|comp_supported
decl_stmt|;
name|error
operator|=
name|sagetparams
argument_list|(
name|periph
argument_list|,
name|SA_PARAM_ALL
argument_list|,
operator|&
name|softc
operator|->
name|media_blksize
argument_list|,
operator|&
name|softc
operator|->
name|media_density
argument_list|,
operator|&
name|softc
operator|->
name|media_numblks
argument_list|,
operator|&
name|softc
operator|->
name|buffer_mode
argument_list|,
operator|&
name|write_protect
argument_list|,
operator|&
name|softc
operator|->
name|speed
argument_list|,
operator|&
name|comp_supported
argument_list|,
operator|&
name|comp_enabled
argument_list|,
operator|&
name|softc
operator|->
name|comp_algorithm
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|write_protect
condition|)
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_TAPE_WP
expr_stmt|;
else|else
name|softc
operator|->
name|flags
operator|&=
operator|~
name|SA_FLAG_TAPE_WP
expr_stmt|;
name|softc
operator|->
name|flags
operator|&=
operator|~
operator|(
name|SA_FLAG_COMP_SUPP
operator||
name|SA_FLAG_COMP_ENABLED
operator||
name|SA_FLAG_COMP_UNSUPP
operator|)
expr_stmt|;
if|if
condition|(
name|comp_supported
condition|)
block|{
if|if
condition|(
name|softc
operator|->
name|saved_comp_algorithm
operator|==
literal|0
condition|)
name|softc
operator|->
name|saved_comp_algorithm
operator|=
name|softc
operator|->
name|comp_algorithm
expr_stmt|;
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_COMP_SUPP
expr_stmt|;
if|if
condition|(
name|comp_enabled
condition|)
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_COMP_ENABLED
expr_stmt|;
block|}
else|else
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_COMP_UNSUPP
expr_stmt|;
block|}
name|bzero
argument_list|(
name|g
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mtget
argument_list|)
argument_list|)
expr_stmt|;
name|g
operator|->
name|mt_type
operator|=
name|MT_ISAR
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_COMP_UNSUPP
condition|)
block|{
name|g
operator|->
name|mt_comp
operator|=
name|MT_COMP_UNSUPP
expr_stmt|;
name|g
operator|->
name|mt_comp0
operator|=
name|MT_COMP_UNSUPP
expr_stmt|;
name|g
operator|->
name|mt_comp1
operator|=
name|MT_COMP_UNSUPP
expr_stmt|;
name|g
operator|->
name|mt_comp2
operator|=
name|MT_COMP_UNSUPP
expr_stmt|;
name|g
operator|->
name|mt_comp3
operator|=
name|MT_COMP_UNSUPP
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_COMP_ENABLED
operator|)
operator|==
literal|0
condition|)
block|{
name|g
operator|->
name|mt_comp
operator|=
name|MT_COMP_DISABLED
expr_stmt|;
block|}
else|else
block|{
name|g
operator|->
name|mt_comp
operator|=
name|softc
operator|->
name|comp_algorithm
expr_stmt|;
block|}
name|g
operator|->
name|mt_comp0
operator|=
name|softc
operator|->
name|comp_algorithm
expr_stmt|;
name|g
operator|->
name|mt_comp1
operator|=
name|softc
operator|->
name|comp_algorithm
expr_stmt|;
name|g
operator|->
name|mt_comp2
operator|=
name|softc
operator|->
name|comp_algorithm
expr_stmt|;
name|g
operator|->
name|mt_comp3
operator|=
name|softc
operator|->
name|comp_algorithm
expr_stmt|;
block|}
name|g
operator|->
name|mt_density
operator|=
name|softc
operator|->
name|media_density
expr_stmt|;
name|g
operator|->
name|mt_density0
operator|=
name|softc
operator|->
name|media_density
expr_stmt|;
name|g
operator|->
name|mt_density1
operator|=
name|softc
operator|->
name|media_density
expr_stmt|;
name|g
operator|->
name|mt_density2
operator|=
name|softc
operator|->
name|media_density
expr_stmt|;
name|g
operator|->
name|mt_density3
operator|=
name|softc
operator|->
name|media_density
expr_stmt|;
name|g
operator|->
name|mt_blksiz
operator|=
name|softc
operator|->
name|media_blksize
expr_stmt|;
name|g
operator|->
name|mt_blksiz0
operator|=
name|softc
operator|->
name|media_blksize
expr_stmt|;
name|g
operator|->
name|mt_blksiz1
operator|=
name|softc
operator|->
name|media_blksize
expr_stmt|;
name|g
operator|->
name|mt_blksiz2
operator|=
name|softc
operator|->
name|media_blksize
expr_stmt|;
name|g
operator|->
name|mt_blksiz3
operator|=
name|softc
operator|->
name|media_blksize
expr_stmt|;
name|g
operator|->
name|mt_fileno
operator|=
name|softc
operator|->
name|fileno
expr_stmt|;
name|g
operator|->
name|mt_blkno
operator|=
name|softc
operator|->
name|blkno
expr_stmt|;
name|g
operator|->
name|mt_dsreg
operator|=
operator|(
name|short
operator|)
name|softc
operator|->
name|dsreg
expr_stmt|;
comment|/* 		 * Yes, we know that this is likely to overflow 		 */
if|if
condition|(
name|softc
operator|->
name|last_resid_was_io
condition|)
block|{
if|if
condition|(
operator|(
name|g
operator|->
name|mt_resid
operator|=
operator|(
name|short
operator|)
name|softc
operator|->
name|last_io_resid
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|SA_IS_CTRL
argument_list|(
name|dev
argument_list|)
operator|==
literal|0
operator|||
name|didlockperiph
condition|)
block|{
name|softc
operator|->
name|last_io_resid
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|g
operator|->
name|mt_resid
operator|=
operator|(
name|short
operator|)
name|softc
operator|->
name|last_ctl_resid
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|SA_IS_CTRL
argument_list|(
name|dev
argument_list|)
operator|==
literal|0
operator|||
name|didlockperiph
condition|)
block|{
name|softc
operator|->
name|last_ctl_resid
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
case|case
name|MTIOCERRSTAT
case|:
block|{
name|struct
name|scsi_tape_errors
modifier|*
name|sep
init|=
operator|&
operator|(
operator|(
expr|union
name|mterrstat
operator|*
operator|)
name|arg
operator|)
operator|->
name|scsi_errstat
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"saioctl: MTIOCERRSTAT\n"
operator|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sep
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sep
argument_list|)
argument_list|)
expr_stmt|;
name|sep
operator|->
name|io_resid
operator|=
name|softc
operator|->
name|last_io_resid
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|softc
operator|->
name|last_io_sense
argument_list|,
name|sep
operator|->
name|io_sense
argument_list|,
sizeof|sizeof
argument_list|(
name|sep
operator|->
name|io_sense
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|softc
operator|->
name|last_io_cdb
argument_list|,
name|sep
operator|->
name|io_cdb
argument_list|,
sizeof|sizeof
argument_list|(
name|sep
operator|->
name|io_cdb
argument_list|)
argument_list|)
expr_stmt|;
name|sep
operator|->
name|ctl_resid
operator|=
name|softc
operator|->
name|last_ctl_resid
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|softc
operator|->
name|last_ctl_sense
argument_list|,
name|sep
operator|->
name|ctl_sense
argument_list|,
sizeof|sizeof
argument_list|(
name|sep
operator|->
name|ctl_sense
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|softc
operator|->
name|last_ctl_cdb
argument_list|,
name|sep
operator|->
name|ctl_cdb
argument_list|,
sizeof|sizeof
argument_list|(
name|sep
operator|->
name|ctl_cdb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SA_IS_CTRL
argument_list|(
name|dev
argument_list|)
operator|==
literal|0
operator|||
name|didlockperiph
condition|)
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|softc
operator|->
name|errinfo
argument_list|,
sizeof|sizeof
argument_list|(
name|softc
operator|->
name|errinfo
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
case|case
name|MTIOCTOP
case|:
block|{
name|struct
name|mtop
modifier|*
name|mt
decl_stmt|;
name|int
name|count
decl_stmt|;
name|mt
operator|=
operator|(
expr|struct
name|mtop
operator|*
operator|)
name|arg
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"saioctl: op=0x%x count=0x%x\n"
operator|,
name|mt
operator|->
name|mt_op
operator|,
name|mt
operator|->
name|mt_count
operator|)
argument_list|)
expr_stmt|;
name|count
operator|=
name|mt
operator|->
name|mt_count
expr_stmt|;
switch|switch
condition|(
name|mt
operator|->
name|mt_op
condition|)
block|{
case|case
name|MTWEOF
case|:
comment|/* write an end-of-file marker */
comment|/* 			 * We don't need to clear the SA_FLAG_TAPE_WRITTEN 			 * flag because by keeping track of filemarks 			 * we have last written we know ehether or not 			 * we need to write more when we close the device. 			 */
name|error
operator|=
name|sawritefilemarks
argument_list|(
name|periph
argument_list|,
name|count
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|MTWSS
case|:
comment|/* write a setmark */
name|error
operator|=
name|sawritefilemarks
argument_list|(
name|periph
argument_list|,
name|count
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|MTBSR
case|:
comment|/* backward space record */
case|case
name|MTFSR
case|:
comment|/* forward space record */
case|case
name|MTBSF
case|:
comment|/* backward space file */
case|case
name|MTFSF
case|:
comment|/* forward space file */
case|case
name|MTBSS
case|:
comment|/* backward space setmark */
case|case
name|MTFSS
case|:
comment|/* forward space setmark */
case|case
name|MTEOD
case|:
comment|/* space to end of recorded medium */
block|{
name|int
name|nmarks
decl_stmt|;
name|spaceop
operator|=
name|SS_FILEMARKS
expr_stmt|;
name|nmarks
operator|=
name|softc
operator|->
name|filemarks
expr_stmt|;
name|error
operator|=
name|sacheckeod
argument_list|(
name|periph
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"EOD check prior to spacing failed\n"
argument_list|)
expr_stmt|;
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_EIO_PENDING
expr_stmt|;
break|break;
block|}
name|nmarks
operator|-=
name|softc
operator|->
name|filemarks
expr_stmt|;
switch|switch
condition|(
name|mt
operator|->
name|mt_op
condition|)
block|{
case|case
name|MTBSR
case|:
name|count
operator|=
operator|-
name|count
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|MTFSR
case|:
name|spaceop
operator|=
name|SS_BLOCKS
expr_stmt|;
break|break;
case|case
name|MTBSF
case|:
name|count
operator|=
operator|-
name|count
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|MTFSF
case|:
break|break;
case|case
name|MTBSS
case|:
name|count
operator|=
operator|-
name|count
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|MTFSS
case|:
name|spaceop
operator|=
name|SS_SETMARKS
expr_stmt|;
break|break;
case|case
name|MTEOD
case|:
name|spaceop
operator|=
name|SS_EOD
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|nmarks
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|error
condition|)
break|break;
name|nmarks
operator|=
name|softc
operator|->
name|filemarks
expr_stmt|;
comment|/* 			 * XXX: Why are we checking again? 			 */
name|error
operator|=
name|sacheckeod
argument_list|(
name|periph
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|nmarks
operator|-=
name|softc
operator|->
name|filemarks
expr_stmt|;
name|error
operator|=
name|saspace
argument_list|(
name|periph
argument_list|,
name|count
operator|-
name|nmarks
argument_list|,
name|spaceop
argument_list|)
expr_stmt|;
comment|/* 			 * At this point, clear that we've written the tape 			 * and that we've written any filemarks. We really 			 * don't know what the applications wishes to do next- 			 * the sacheckeod's will make sure we terminated the 			 * tape correctly if we'd been writing, but the next 			 * action the user application takes will set again 			 * whether we need to write filemarks. 			 */
name|softc
operator|->
name|flags
operator|&=
operator|~
operator|(
name|SA_FLAG_TAPE_WRITTEN
operator||
name|SA_FLAG_TAPE_FROZEN
operator|)
expr_stmt|;
name|softc
operator|->
name|filemarks
operator|=
literal|0
expr_stmt|;
break|break;
block|}
case|case
name|MTREW
case|:
comment|/* rewind */
operator|(
name|void
operator|)
name|sacheckeod
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|error
operator|=
name|sarewind
argument_list|(
name|periph
argument_list|)
expr_stmt|;
comment|/* see above */
name|softc
operator|->
name|flags
operator|&=
operator|~
operator|(
name|SA_FLAG_TAPE_WRITTEN
operator||
name|SA_FLAG_TAPE_FROZEN
operator|)
expr_stmt|;
name|softc
operator|->
name|flags
operator|&=
operator|~
name|SA_FLAG_ERR_PENDING
expr_stmt|;
name|softc
operator|->
name|filemarks
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MTERASE
case|:
comment|/* erase */
name|error
operator|=
name|saerase
argument_list|(
name|periph
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|softc
operator|->
name|flags
operator|&=
operator|~
operator|(
name|SA_FLAG_TAPE_WRITTEN
operator||
name|SA_FLAG_TAPE_FROZEN
operator|)
expr_stmt|;
name|softc
operator|->
name|flags
operator|&=
operator|~
name|SA_FLAG_ERR_PENDING
expr_stmt|;
break|break;
case|case
name|MTRETENS
case|:
comment|/* re-tension tape */
name|error
operator|=
name|saretension
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|softc
operator|->
name|flags
operator|&=
operator|~
operator|(
name|SA_FLAG_TAPE_WRITTEN
operator||
name|SA_FLAG_TAPE_FROZEN
operator|)
expr_stmt|;
name|softc
operator|->
name|flags
operator|&=
operator|~
name|SA_FLAG_ERR_PENDING
expr_stmt|;
break|break;
case|case
name|MTOFFL
case|:
comment|/* rewind and put the drive offline */
operator|(
name|void
operator|)
name|sacheckeod
argument_list|(
name|periph
argument_list|)
expr_stmt|;
comment|/* see above */
name|softc
operator|->
name|flags
operator|&=
operator|~
name|SA_FLAG_TAPE_WRITTEN
expr_stmt|;
name|softc
operator|->
name|filemarks
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|sarewind
argument_list|(
name|periph
argument_list|)
expr_stmt|;
comment|/* clear the frozen flag anyway */
name|softc
operator|->
name|flags
operator|&=
operator|~
name|SA_FLAG_TAPE_FROZEN
expr_stmt|;
comment|/* 			 * Be sure to allow media removal before ejecting. 			 */
name|saprevent
argument_list|(
name|periph
argument_list|,
name|PR_ALLOW
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|saloadunload
argument_list|(
name|periph
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|softc
operator|->
name|flags
operator|&=
operator|~
name|SA_FLAG_TAPE_MOUNTED
expr_stmt|;
block|}
block|}
break|break;
case|case
name|MTNOP
case|:
comment|/* no operation, sets status only */
case|case
name|MTCACHE
case|:
comment|/* enable controller cache */
case|case
name|MTNOCACHE
case|:
comment|/* disable controller cache */
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MTSETBSIZ
case|:
comment|/* Set block size for device */
name|error
operator|=
name|sasetparams
argument_list|(
name|periph
argument_list|,
name|SA_PARAM_BLOCKSIZE
argument_list|,
name|count
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|softc
operator|->
name|last_media_blksize
operator|=
name|softc
operator|->
name|media_blksize
expr_stmt|;
name|softc
operator|->
name|media_blksize
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|count
condition|)
block|{
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_FIXED
expr_stmt|;
if|if
condition|(
name|powerof2
argument_list|(
name|count
argument_list|)
condition|)
block|{
name|softc
operator|->
name|blk_shift
operator|=
name|ffs
argument_list|(
name|count
argument_list|)
operator|-
literal|1
expr_stmt|;
name|softc
operator|->
name|blk_mask
operator|=
name|count
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|softc
operator|->
name|blk_mask
operator|=
operator|~
literal|0
expr_stmt|;
name|softc
operator|->
name|blk_shift
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 					 * Make the user's desire 'persistent'. 					 */
name|softc
operator|->
name|quirks
operator|&=
operator|~
name|SA_QUIRK_VARIABLE
expr_stmt|;
name|softc
operator|->
name|quirks
operator||=
name|SA_QUIRK_FIXED
expr_stmt|;
block|}
else|else
block|{
name|softc
operator|->
name|flags
operator|&=
operator|~
name|SA_FLAG_FIXED
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|max_blk
operator|==
literal|0
condition|)
block|{
name|softc
operator|->
name|max_blk
operator|=
operator|~
literal|0
expr_stmt|;
block|}
name|softc
operator|->
name|blk_shift
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|blk_gran
operator|!=
literal|0
condition|)
block|{
name|softc
operator|->
name|blk_mask
operator|=
name|softc
operator|->
name|blk_gran
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|softc
operator|->
name|blk_mask
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 					 * Make the user's desire 'persistent'. 					 */
name|softc
operator|->
name|quirks
operator||=
name|SA_QUIRK_VARIABLE
expr_stmt|;
name|softc
operator|->
name|quirks
operator|&=
operator|~
name|SA_QUIRK_FIXED
expr_stmt|;
block|}
block|}
break|break;
case|case
name|MTSETDNSTY
case|:
comment|/* Set density for device and mode */
if|if
condition|(
name|count
operator|>
name|UCHAR_MAX
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
else|else
block|{
name|error
operator|=
name|sasetparams
argument_list|(
name|periph
argument_list|,
name|SA_PARAM_DENSITY
argument_list|,
literal|0
argument_list|,
name|count
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MTCOMP
case|:
comment|/* enable compression */
comment|/* 			 * Some devices don't support compression, and 			 * don't like it if you ask them for the 			 * compression page. 			 */
if|if
condition|(
operator|(
name|softc
operator|->
name|quirks
operator|&
name|SA_QUIRK_NOCOMP
operator|)
operator|||
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_COMP_UNSUPP
operator|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|sasetparams
argument_list|(
name|periph
argument_list|,
name|SA_PARAM_COMPRESSION
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|count
argument_list|,
name|SF_NO_PRINT
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
block|}
case|case
name|MTIOCIEOT
case|:
case|case
name|MTIOCEEOT
case|:
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MTIOCRDSPOS
case|:
name|error
operator|=
name|sardpos
argument_list|(
name|periph
argument_list|,
literal|0
argument_list|,
operator|(
name|u_int32_t
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|MTIOCRDHPOS
case|:
name|error
operator|=
name|sardpos
argument_list|(
name|periph
argument_list|,
literal|1
argument_list|,
operator|(
name|u_int32_t
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|MTIOCSLOCATE
case|:
name|error
operator|=
name|sasetpos
argument_list|(
name|periph
argument_list|,
literal|0
argument_list|,
operator|(
name|u_int32_t
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|MTIOCHLOCATE
case|:
name|error
operator|=
name|sasetpos
argument_list|(
name|periph
argument_list|,
literal|1
argument_list|,
operator|(
name|u_int32_t
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|MTIOCGETEOTMODEL
case|:
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|quirks
operator|&
name|SA_QUIRK_1FM
condition|)
name|mode
operator|=
literal|1
expr_stmt|;
else|else
name|mode
operator|=
literal|2
expr_stmt|;
operator|*
operator|(
operator|(
name|u_int32_t
operator|*
operator|)
name|arg
operator|)
operator|=
name|mode
expr_stmt|;
break|break;
case|case
name|MTIOCSETEOTMODEL
case|:
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
operator|*
operator|(
operator|(
name|u_int32_t
operator|*
operator|)
name|arg
operator|)
condition|)
block|{
case|case
literal|1
case|:
name|softc
operator|->
name|quirks
operator|&=
operator|~
name|SA_QUIRK_2FM
expr_stmt|;
name|softc
operator|->
name|quirks
operator||=
name|SA_QUIRK_1FM
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|softc
operator|->
name|quirks
operator|&=
operator|~
name|SA_QUIRK_1FM
expr_stmt|;
name|softc
operator|->
name|quirks
operator||=
name|SA_QUIRK_2FM
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|error
operator|=
name|cam_periph_ioctl
argument_list|(
name|periph
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|,
name|saerror
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	 * Check to see if we cleared a frozen state 	 */
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_TAPE_FROZEN
operator|)
condition|)
block|{
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MTIOCRDSPOS
case|:
case|case
name|MTIOCRDHPOS
case|:
case|case
name|MTIOCSLOCATE
case|:
case|case
name|MTIOCHLOCATE
case|:
name|softc
operator|->
name|fileno
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
name|softc
operator|->
name|blkno
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
name|softc
operator|->
name|flags
operator|&=
operator|~
name|SA_FLAG_TAPE_FROZEN
expr_stmt|;
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"tape state now unfrozen.\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|didlockperiph
condition|)
block|{
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sainit
parameter_list|(
name|void
parameter_list|)
block|{
name|cam_status
name|status
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
comment|/* 	 * Install a global async callback. 	 */
name|status
operator|=
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
name|NULL
argument_list|,
name|CAM_XPT_PATH_ID
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|CAM_REQ_CMP
condition|)
block|{
comment|/* Register the async callbacks of interrest */
name|struct
name|ccb_setasync
name|csa
decl_stmt|;
comment|/* 					  * This is an immediate CCB, 					  * so using the stack is OK 					  */
name|xpt_setup_ccb
argument_list|(
operator|&
name|csa
operator|.
name|ccb_h
argument_list|,
name|path
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|csa
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SASYNC_CB
expr_stmt|;
name|csa
operator|.
name|event_enable
operator|=
name|AC_FOUND_DEVICE
expr_stmt|;
name|csa
operator|.
name|callback
operator|=
name|saasync
expr_stmt|;
name|csa
operator|.
name|callback_arg
operator|=
name|NULL
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|csa
argument_list|)
expr_stmt|;
name|status
operator|=
name|csa
operator|.
name|ccb_h
operator|.
name|status
expr_stmt|;
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"sa: Failed to attach master async callback "
literal|"due to status 0x%x!\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|saoninvalidate
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ccb_setasync
name|csa
decl_stmt|;
name|int
name|s
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
comment|/* 	 * De-register any async callbacks. 	 */
name|xpt_setup_ccb
argument_list|(
operator|&
name|csa
operator|.
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
comment|/* priority */
literal|5
argument_list|)
expr_stmt|;
name|csa
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SASYNC_CB
expr_stmt|;
name|csa
operator|.
name|event_enable
operator|=
literal|0
expr_stmt|;
name|csa
operator|.
name|callback
operator|=
name|saasync
expr_stmt|;
name|csa
operator|.
name|callback_arg
operator|=
name|periph
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|csa
argument_list|)
expr_stmt|;
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_INVALID
expr_stmt|;
comment|/* 	 * Although the oninvalidate() routines are always called at 	 * splsoftcam, we need to be at splbio() here to keep the buffer 	 * queue from being modified while we traverse it. 	 */
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* 	 * Return all queued I/O with ENXIO. 	 * XXX Handle any transactions queued to the card 	 *     with XPT_ABORT_CCB. 	 */
name|bioq_flush
argument_list|(
operator|&
name|softc
operator|->
name|bio_queue
argument_list|,
name|NULL
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
name|softc
operator|->
name|queue_count
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"lost device\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sacleanup
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|devstat_remove_entry
argument_list|(
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
name|destroy_dev
argument_list|(
name|softc
operator|->
name|devs
operator|.
name|ctl_dev
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SA_NUM_MODES
condition|;
name|i
operator|++
control|)
block|{
name|destroy_dev
argument_list|(
name|softc
operator|->
name|devs
operator|.
name|mode_devs
index|[
name|i
index|]
operator|.
name|r_dev
argument_list|)
expr_stmt|;
name|destroy_dev
argument_list|(
name|softc
operator|->
name|devs
operator|.
name|mode_devs
index|[
name|i
index|]
operator|.
name|nr_dev
argument_list|)
expr_stmt|;
name|destroy_dev
argument_list|(
name|softc
operator|->
name|devs
operator|.
name|mode_devs
index|[
name|i
index|]
operator|.
name|er_dev
argument_list|)
expr_stmt|;
block|}
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"removing device entry\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|softc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|saasync
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|u_int32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|periph
operator|=
operator|(
expr|struct
name|cam_periph
operator|*
operator|)
name|callback_arg
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|AC_FOUND_DEVICE
case|:
block|{
name|struct
name|ccb_getdev
modifier|*
name|cgd
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|cgd
operator|=
operator|(
expr|struct
name|ccb_getdev
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|cgd
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|SID_TYPE
argument_list|(
operator|&
name|cgd
operator|->
name|inq_data
argument_list|)
operator|!=
name|T_SEQUENTIAL
condition|)
break|break;
comment|/* 		 * Allocate a peripheral instance for 		 * this device and start the probe 		 * process. 		 */
name|status
operator|=
name|cam_periph_alloc
argument_list|(
name|saregister
argument_list|,
name|saoninvalidate
argument_list|,
name|sacleanup
argument_list|,
name|sastart
argument_list|,
literal|"sa"
argument_list|,
name|CAM_PERIPH_BIO
argument_list|,
name|cgd
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|saasync
argument_list|,
name|AC_FOUND_DEVICE
argument_list|,
name|cgd
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
operator|&&
name|status
operator|!=
name|CAM_REQ_INPROG
condition|)
name|printf
argument_list|(
literal|"saasync: Unable to probe new device "
literal|"due to status 0x%x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|cam_periph_async
argument_list|(
name|periph
argument_list|,
name|code
argument_list|,
name|path
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|cam_status
name|saregister
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ccb_setasync
name|csa
decl_stmt|;
name|struct
name|ccb_getdev
modifier|*
name|cgd
decl_stmt|;
name|caddr_t
name|match
decl_stmt|;
name|int
name|i
decl_stmt|;
name|cgd
operator|=
operator|(
expr|struct
name|ccb_getdev
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"saregister: periph was NULL!!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
if|if
condition|(
name|cgd
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"saregister: no getdev CCB, can't register device\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|softc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"saregister: Unable to probe new device. "
literal|"Unable to allocate softc\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
name|softc
operator|->
name|scsi_rev
operator|=
name|SID_ANSI_REV
argument_list|(
operator|&
name|cgd
operator|->
name|inq_data
argument_list|)
expr_stmt|;
name|softc
operator|->
name|state
operator|=
name|SA_STATE_NORMAL
expr_stmt|;
name|softc
operator|->
name|fileno
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
name|softc
operator|->
name|blkno
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
name|bioq_init
argument_list|(
operator|&
name|softc
operator|->
name|bio_queue
argument_list|)
expr_stmt|;
name|periph
operator|->
name|softc
operator|=
name|softc
expr_stmt|;
comment|/* 	 * See if this device has any quirks. 	 */
name|match
operator|=
name|cam_quirkmatch
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|cgd
operator|->
name|inq_data
argument_list|,
operator|(
name|caddr_t
operator|)
name|sa_quirk_table
argument_list|,
sizeof|sizeof
argument_list|(
name|sa_quirk_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|sa_quirk_table
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sa_quirk_table
argument_list|)
argument_list|,
name|scsi_inquiry_match
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
operator|!=
name|NULL
condition|)
block|{
name|softc
operator|->
name|quirks
operator|=
operator|(
operator|(
expr|struct
name|sa_quirk_entry
operator|*
operator|)
name|match
operator|)
operator|->
name|quirks
expr_stmt|;
name|softc
operator|->
name|last_media_blksize
operator|=
operator|(
operator|(
expr|struct
name|sa_quirk_entry
operator|*
operator|)
name|match
operator|)
operator|->
name|prefblk
expr_stmt|;
ifdef|#
directive|ifdef
name|CAMDEBUG
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"found quirk entry %d\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
expr|struct
name|sa_quirk_entry
operator|*
operator|)
name|match
operator|)
operator|-
name|sa_quirk_table
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|softc
operator|->
name|quirks
operator|=
name|SA_QUIRK_NONE
expr_stmt|;
comment|/*  	 * The SA driver supports a blocksize, but we don't know the 	 * blocksize until we media is inserted.  So, set a flag to 	 * indicate that the blocksize is unavailable right now. 	 */
name|softc
operator|->
name|device_stats
operator|=
name|devstat_new_entry
argument_list|(
literal|"sa"
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|,
literal|0
argument_list|,
name|DEVSTAT_BS_UNAVAILABLE
argument_list|,
name|SID_TYPE
argument_list|(
operator|&
name|cgd
operator|->
name|inq_data
argument_list|)
operator||
name|DEVSTAT_TYPE_IF_SCSI
argument_list|,
name|DEVSTAT_PRIORITY_TAPE
argument_list|)
expr_stmt|;
name|softc
operator|->
name|devs
operator|.
name|ctl_dev
operator|=
name|make_dev
argument_list|(
operator|&
name|sa_cdevsw
argument_list|,
name|SAMINOR
argument_list|(
name|SA_CTLDEV
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|,
literal|0
argument_list|,
name|SA_ATYPE_R
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0660
argument_list|,
literal|"%s%d.ctl"
argument_list|,
name|periph
operator|->
name|periph_name
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|)
expr_stmt|;
name|softc
operator|->
name|devs
operator|.
name|ctl_dev
operator|->
name|si_drv1
operator|=
name|periph
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SA_NUM_MODES
condition|;
name|i
operator|++
control|)
block|{
name|softc
operator|->
name|devs
operator|.
name|mode_devs
index|[
name|i
index|]
operator|.
name|r_dev
operator|=
name|make_dev
argument_list|(
operator|&
name|sa_cdevsw
argument_list|,
name|SAMINOR
argument_list|(
name|SA_NOT_CTLDEV
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|,
name|i
argument_list|,
name|SA_ATYPE_R
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0660
argument_list|,
literal|"%s%d.%d"
argument_list|,
name|periph
operator|->
name|periph_name
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|softc
operator|->
name|devs
operator|.
name|mode_devs
index|[
name|i
index|]
operator|.
name|r_dev
operator|->
name|si_drv1
operator|=
name|periph
expr_stmt|;
name|softc
operator|->
name|devs
operator|.
name|mode_devs
index|[
name|i
index|]
operator|.
name|nr_dev
operator|=
name|make_dev
argument_list|(
operator|&
name|sa_cdevsw
argument_list|,
name|SAMINOR
argument_list|(
name|SA_NOT_CTLDEV
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|,
name|i
argument_list|,
name|SA_ATYPE_NR
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0660
argument_list|,
literal|"n%s%d.%d"
argument_list|,
name|periph
operator|->
name|periph_name
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|softc
operator|->
name|devs
operator|.
name|mode_devs
index|[
name|i
index|]
operator|.
name|nr_dev
operator|->
name|si_drv1
operator|=
name|periph
expr_stmt|;
name|softc
operator|->
name|devs
operator|.
name|mode_devs
index|[
name|i
index|]
operator|.
name|er_dev
operator|=
name|make_dev
argument_list|(
operator|&
name|sa_cdevsw
argument_list|,
name|SAMINOR
argument_list|(
name|SA_NOT_CTLDEV
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|,
name|i
argument_list|,
name|SA_ATYPE_ER
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0660
argument_list|,
literal|"e%s%d.%d"
argument_list|,
name|periph
operator|->
name|periph_name
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|softc
operator|->
name|devs
operator|.
name|mode_devs
index|[
name|i
index|]
operator|.
name|er_dev
operator|->
name|si_drv1
operator|=
name|periph
expr_stmt|;
comment|/* 		 * Make the (well known) aliases for the first mode. 		 */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|struct
name|cdev
modifier|*
name|alias
decl_stmt|;
name|alias
operator|=
name|make_dev_alias
argument_list|(
name|softc
operator|->
name|devs
operator|.
name|mode_devs
index|[
name|i
index|]
operator|.
name|r_dev
argument_list|,
literal|"%s%d"
argument_list|,
name|periph
operator|->
name|periph_name
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|)
expr_stmt|;
name|alias
operator|->
name|si_drv1
operator|=
name|periph
expr_stmt|;
name|alias
operator|=
name|make_dev_alias
argument_list|(
name|softc
operator|->
name|devs
operator|.
name|mode_devs
index|[
name|i
index|]
operator|.
name|nr_dev
argument_list|,
literal|"n%s%d"
argument_list|,
name|periph
operator|->
name|periph_name
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|)
expr_stmt|;
name|alias
operator|->
name|si_drv1
operator|=
name|periph
expr_stmt|;
name|alias
operator|=
name|make_dev_alias
argument_list|(
name|softc
operator|->
name|devs
operator|.
name|mode_devs
index|[
name|i
index|]
operator|.
name|er_dev
argument_list|,
literal|"e%s%d"
argument_list|,
name|periph
operator|->
name|periph_name
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|)
expr_stmt|;
name|alias
operator|->
name|si_drv1
operator|=
name|periph
expr_stmt|;
block|}
block|}
comment|/* 	 * Add an async callback so that we get 	 * notified if this device goes away. 	 */
name|xpt_setup_ccb
argument_list|(
operator|&
name|csa
operator|.
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
comment|/* priority */
literal|5
argument_list|)
expr_stmt|;
name|csa
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SASYNC_CB
expr_stmt|;
name|csa
operator|.
name|event_enable
operator|=
name|AC_LOST_DEVICE
expr_stmt|;
name|csa
operator|.
name|callback
operator|=
name|saasync
expr_stmt|;
name|csa
operator|.
name|callback_arg
operator|=
name|periph
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|csa
argument_list|)
expr_stmt|;
name|xpt_announce_periph
argument_list|(
name|periph
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sastart
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|start_ccb
parameter_list|)
block|{
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"sastart\n"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|softc
operator|->
name|state
condition|)
block|{
case|case
name|SA_STATE_NORMAL
case|:
block|{
comment|/* Pull a buffer from the queue and get going on it */
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* 		 * See if there is a buf with work for us to do.. 		 */
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|bp
operator|=
name|bioq_first
argument_list|(
operator|&
name|softc
operator|->
name|bio_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|periph
operator|->
name|immediate_priority
operator|<=
name|periph
operator|->
name|pinfo
operator|.
name|priority
condition|)
block|{
name|CAM_DEBUG_PRINT
argument_list|(
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"queuing for immediate ccb\n"
operator|)
argument_list|)
expr_stmt|;
name|Set_CCB_Type
argument_list|(
name|start_ccb
argument_list|,
name|SA_CCB_WAITING
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|periph
operator|->
name|ccb_list
argument_list|,
operator|&
name|start_ccb
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|sle
argument_list|)
expr_stmt|;
name|periph
operator|->
name|immediate_priority
operator|=
name|CAM_PRIORITY_NONE
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|periph
operator|->
name|ccb_list
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|start_ccb
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_ERR_PENDING
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|bio
modifier|*
name|done_bp
decl_stmt|;
name|again
label|:
name|softc
operator|->
name|queue_count
operator|--
expr_stmt|;
name|bioq_remove
argument_list|(
operator|&
name|softc
operator|->
name|bio_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bio_resid
operator|=
name|bp
operator|->
name|bio_bcount
expr_stmt|;
name|done_bp
operator|=
name|bp
expr_stmt|;
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_EOM_PENDING
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * We now just clear errors in this case 				 * and let the residual be the notifier. 				 */
name|bp
operator|->
name|bio_error
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_EOF_PENDING
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * This can only happen if we're reading 				 * in fixed length mode. In this case, 				 * we dump the rest of the list the 				 * same way. 				 */
name|bp
operator|->
name|bio_error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bioq_first
argument_list|(
operator|&
name|softc
operator|->
name|bio_queue
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|biodone
argument_list|(
name|done_bp
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_EIO_PENDING
operator|)
operator|!=
literal|0
condition|)
block|{
name|bp
operator|->
name|bio_error
operator|=
name|EIO
expr_stmt|;
name|bp
operator|->
name|bio_flags
operator||=
name|BIO_ERROR
expr_stmt|;
block|}
name|bp
operator|=
name|bioq_first
argument_list|(
operator|&
name|softc
operator|->
name|bio_queue
argument_list|)
expr_stmt|;
comment|/* 			 * Only if we have no other buffers queued up 			 * do we clear the pending error flag. 			 */
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
name|softc
operator|->
name|flags
operator|&=
operator|~
name|SA_FLAG_ERR_PENDING
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_INFO
argument_list|,
operator|(
literal|"sastart- ERR_PENDING now 0x%x, bp is %sNULL, "
literal|"%d more buffers queued up\n"
operator|,
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_ERR_PENDING
operator|)
operator|,
operator|(
name|bp
operator|!=
name|NULL
operator|)
condition|?
literal|"not "
else|:
literal|" "
operator|,
name|softc
operator|->
name|queue_count
operator|)
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|start_ccb
argument_list|)
expr_stmt|;
name|biodone
argument_list|(
name|done_bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|u_int32_t
name|length
decl_stmt|;
name|bioq_remove
argument_list|(
operator|&
name|softc
operator|->
name|bio_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|softc
operator|->
name|queue_count
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_FIXED
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|softc
operator|->
name|blk_shift
operator|!=
literal|0
condition|)
block|{
name|length
operator|=
name|bp
operator|->
name|bio_bcount
operator|>>
name|softc
operator|->
name|blk_shift
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|softc
operator|->
name|media_blksize
operator|!=
literal|0
condition|)
block|{
name|length
operator|=
name|bp
operator|->
name|bio_bcount
operator|/
name|softc
operator|->
name|media_blksize
expr_stmt|;
block|}
else|else
block|{
name|bp
operator|->
name|bio_error
operator|=
name|EIO
expr_stmt|;
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"zero blocksize for "
literal|"FIXED length writes?\n"
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
break|break;
block|}
if|#
directive|if
literal|0
block|CAM_DEBUG(start_ccb->ccb_h.path, CAM_DEBUG_INFO, 				    ("issuing a %d fixed record %s\n", 				    length,  (bp->bio_cmd == BIO_READ)? "read" : 				    "write"));
endif|#
directive|endif
block|}
else|else
block|{
name|length
operator|=
name|bp
operator|->
name|bio_bcount
expr_stmt|;
if|#
directive|if
literal|0
block|CAM_DEBUG(start_ccb->ccb_h.path, CAM_DEBUG_INFO, 				    ("issuing a %d variable byte %s\n", 				    length,  (bp->bio_cmd == BIO_READ)? "read" : 				    "write"));
endif|#
directive|endif
block|}
name|devstat_start_transaction_bio
argument_list|(
name|softc
operator|->
name|device_stats
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/* 			 * Some people have theorized that we should 			 * suppress illegal length indication if we are 			 * running in variable block mode so that we don't 			 * have to request sense every time our requested 			 * block size is larger than the written block. 			 * The residual information from the ccb allows 			 * us to identify this situation anyway.  The only 			 * problem with this is that we will not get 			 * information about blocks that are larger than 			 * our read buffer unless we set the block size 			 * in the mode page to something other than 0. 			 * 			 * I believe that this is a non-issue. If user apps 			 * don't adjust their read size to match our record 			 * size, that's just life. Anyway, the typical usage 			 * would be to issue, e.g., 64KB reads and occasionally 			 * have to do deal with 512 byte or 1KB intermediate 			 * records. 			 */
name|softc
operator|->
name|dsreg
operator|=
operator|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_READ
operator|)
condition|?
name|MTIO_DSREG_RD
else|:
name|MTIO_DSREG_WR
expr_stmt|;
name|scsi_sa_read_write
argument_list|(
operator|&
name|start_ccb
operator|->
name|csio
argument_list|,
literal|0
argument_list|,
name|sadone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
operator|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_READ
operator|)
argument_list|,
name|FALSE
argument_list|,
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_FIXED
operator|)
operator|!=
literal|0
argument_list|,
name|length
argument_list|,
name|bp
operator|->
name|bio_data
argument_list|,
name|bp
operator|->
name|bio_bcount
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
name|IO_TIMEOUT
argument_list|)
expr_stmt|;
name|start_ccb
operator|->
name|ccb_h
operator|.
name|ccb_pflags
operator|&=
operator|~
name|SA_POSITION_UPDATED
expr_stmt|;
name|Set_CCB_Type
argument_list|(
name|start_ccb
argument_list|,
name|SA_CCB_BUFFER_IO
argument_list|)
expr_stmt|;
name|start_ccb
operator|->
name|ccb_h
operator|.
name|ccb_bp
operator|=
name|bp
expr_stmt|;
name|bp
operator|=
name|bioq_first
argument_list|(
operator|&
name|softc
operator|->
name|bio_queue
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|xpt_action
argument_list|(
name|start_ccb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
block|{
comment|/* Have more work to do, so ensure we stay scheduled */
name|xpt_schedule
argument_list|(
name|periph
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SA_STATE_ABNORMAL
case|:
default|default:
name|panic
argument_list|(
literal|"state 0x%x in sastart"
argument_list|,
name|softc
operator|->
name|state
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sadone
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|done_ccb
parameter_list|)
block|{
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|csio
operator|=
operator|&
name|done_ccb
operator|->
name|csio
expr_stmt|;
switch|switch
condition|(
name|CCB_Type
argument_list|(
name|csio
argument_list|)
condition|)
block|{
case|case
name|SA_CCB_BUFFER_IO
case|:
block|{
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|softc
operator|->
name|dsreg
operator|=
name|MTIO_DSREG_REST
expr_stmt|;
name|bp
operator|=
operator|(
expr|struct
name|bio
operator|*
operator|)
name|done_ccb
operator|->
name|ccb_h
operator|.
name|ccb_bp
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|saerror
argument_list|(
name|done_ccb
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|ERESTART
condition|)
block|{
comment|/* 				 * A retry was scheduled, so just return. 				 */
return|return;
block|}
block|}
if|if
condition|(
name|error
operator|==
name|EIO
condition|)
block|{
name|int
name|s
decl_stmt|;
comment|/* 			 * Catastrophic error. Mark the tape as frozen 			 * (we no longer know tape position). 			 * 			 * Return all queued I/O with EIO, and unfreeze 			 * our queue so that future transactions that 			 * attempt to fix this problem can get to the 			 * device. 			 * 			 */
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_TAPE_FROZEN
expr_stmt|;
name|bioq_flush
argument_list|(
operator|&
name|softc
operator|->
name|bio_queue
argument_list|,
name|NULL
argument_list|,
name|EIO
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|bp
operator|->
name|bio_resid
operator|=
name|bp
operator|->
name|bio_bcount
expr_stmt|;
name|bp
operator|->
name|bio_error
operator|=
name|error
expr_stmt|;
name|bp
operator|->
name|bio_flags
operator||=
name|BIO_ERROR
expr_stmt|;
comment|/* 			 * In the error case, position is updated in saerror. 			 */
block|}
else|else
block|{
name|bp
operator|->
name|bio_resid
operator|=
name|csio
operator|->
name|resid
expr_stmt|;
name|bp
operator|->
name|bio_error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|csio
operator|->
name|resid
operator|!=
literal|0
condition|)
block|{
name|bp
operator|->
name|bio_flags
operator||=
name|BIO_ERROR
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_WRITE
condition|)
block|{
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_TAPE_WRITTEN
expr_stmt|;
name|softc
operator|->
name|filemarks
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|csio
operator|->
name|ccb_h
operator|.
name|ccb_pflags
operator|&
name|SA_POSITION_UPDATED
operator|)
operator|&&
operator|(
name|softc
operator|->
name|blkno
operator|!=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_FIXED
operator|)
operator|!=
literal|0
condition|)
block|{
name|u_int32_t
name|l
decl_stmt|;
if|if
condition|(
name|softc
operator|->
name|blk_shift
operator|!=
literal|0
condition|)
block|{
name|l
operator|=
name|bp
operator|->
name|bio_bcount
operator|>>
name|softc
operator|->
name|blk_shift
expr_stmt|;
block|}
else|else
block|{
name|l
operator|=
name|bp
operator|->
name|bio_bcount
operator|/
name|softc
operator|->
name|media_blksize
expr_stmt|;
block|}
name|softc
operator|->
name|blkno
operator|+=
operator|(
name|daddr_t
operator|)
name|l
expr_stmt|;
block|}
else|else
block|{
name|softc
operator|->
name|blkno
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* 		 * If we had an error (immediate or pending), 		 * release the device queue now. 		 */
if|if
condition|(
name|error
operator|||
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_ERR_PENDING
operator|)
condition|)
name|cam_release_devq
argument_list|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CAMDEBUG
if|if
condition|(
name|error
operator|||
name|bp
operator|->
name|bio_resid
condition|)
block|{
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_INFO
argument_list|,
operator|(
literal|"error %d resid %ld count %ld\n"
operator|,
name|error
operator|,
name|bp
operator|->
name|bio_resid
operator|,
name|bp
operator|->
name|bio_bcount
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|biofinish
argument_list|(
name|bp
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SA_CCB_WAITING
case|:
block|{
comment|/* Caller will release the CCB */
name|wakeup
argument_list|(
operator|&
name|done_ccb
operator|->
name|ccb_h
operator|.
name|cbfcnp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|xpt_release_ccb
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Mount the tape (make sure it's ready for I/O).  */
end_comment

begin_function
specifier|static
name|int
name|samount
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|oflags
parameter_list|,
name|struct
name|cdev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * oflags can be checked for 'kind' of open (read-only check) - later 	 * dev can be checked for a control-mode or compression open - later 	 */
name|UNUSED_PARAMETER
argument_list|(
name|oflags
argument_list|)
expr_stmt|;
name|UNUSED_PARAMETER
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
comment|/* 	 * This should determine if something has happend since the last 	 * open/mount that would invalidate the mount. We do *not* want 	 * to retry this command- we just want the status. But we only 	 * do this if we're mounted already- if we're not mounted, 	 * we don't care about the unit read state and can instead use 	 * this opportunity to attempt to reserve the tape unit. 	 */
if|if
condition|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_TAPE_MOUNTED
condition|)
block|{
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|scsi_test_unit_ready
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
literal|0
argument_list|,
name|sadone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
name|IO_TIMEOUT
argument_list|)
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
literal|0
argument_list|,
name|SF_NO_PRINT
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
name|QFRLS
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENXIO
condition|)
block|{
name|softc
operator|->
name|flags
operator|&=
operator|~
name|SA_FLAG_TAPE_MOUNTED
expr_stmt|;
name|scsi_test_unit_ready
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
literal|0
argument_list|,
name|sadone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
name|IO_TIMEOUT
argument_list|)
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
literal|0
argument_list|,
name|SF_NO_PRINT
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
name|QFRLS
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
condition|)
block|{
comment|/* 			 * We don't need to freeze the tape because we 			 * will now attempt to rewind/load it. 			 */
name|softc
operator|->
name|flags
operator|&=
operator|~
name|SA_FLAG_TAPE_MOUNTED
expr_stmt|;
if|if
condition|(
name|CAM_DEBUGGED
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_INFO
argument_list|)
condition|)
block|{
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"error %d on TUR in samount\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|error
operator|=
name|sareservereleaseunit
argument_list|(
name|periph
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|scsi_test_unit_ready
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
literal|0
argument_list|,
name|sadone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
name|IO_TIMEOUT
argument_list|)
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
literal|0
argument_list|,
name|SF_NO_PRINT
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
name|QFRLS
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_TAPE_MOUNTED
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|scsi_read_block_limits_data
modifier|*
name|rblim
init|=
name|NULL
decl_stmt|;
name|int
name|comp_enabled
decl_stmt|,
name|comp_supported
decl_stmt|;
name|u_int8_t
name|write_protect
decl_stmt|,
name|guessing
init|=
literal|0
decl_stmt|;
comment|/* 		 * Clear out old state. 		 */
name|softc
operator|->
name|flags
operator|&=
operator|~
operator|(
name|SA_FLAG_TAPE_WP
operator||
name|SA_FLAG_TAPE_WRITTEN
operator||
name|SA_FLAG_ERR_PENDING
operator||
name|SA_FLAG_COMP_ENABLED
operator||
name|SA_FLAG_COMP_SUPP
operator||
name|SA_FLAG_COMP_UNSUPP
operator|)
expr_stmt|;
name|softc
operator|->
name|filemarks
operator|=
literal|0
expr_stmt|;
comment|/* 		 * *Very* first off, make sure we're loaded to BOT. 		 */
name|scsi_load_unload
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
literal|2
argument_list|,
name|sadone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|1
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
name|REWIND_TIMEOUT
argument_list|)
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
literal|0
argument_list|,
name|SF_NO_PRINT
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
name|QFRLS
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
comment|/* 		 * In case this doesn't work, do a REWIND instead 		 */
if|if
condition|(
name|error
condition|)
block|{
name|scsi_rewind
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
literal|2
argument_list|,
name|sadone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|FALSE
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
name|REWIND_TIMEOUT
argument_list|)
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
literal|0
argument_list|,
name|SF_NO_PRINT
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
name|QFRLS
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
comment|/* 		 * Do a dummy test read to force access to the 		 * media so that the drive will really know what's 		 * there. We actually don't really care what the 		 * blocksize on tape is and don't expect to really 		 * read a full record. 		 */
name|rblim
operator|=
operator|(
expr|struct
name|scsi_read_block_limits_data
operator|*
operator|)
name|malloc
argument_list|(
literal|8192
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|rblim
operator|==
name|NULL
condition|)
block|{
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"no memory for test read\n"
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
if|if
condition|(
operator|(
name|softc
operator|->
name|quirks
operator|&
name|SA_QUIRK_NODREAD
operator|)
operator|==
literal|0
condition|)
block|{
name|scsi_sa_read_write
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
literal|0
argument_list|,
name|sadone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
literal|1
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|8192
argument_list|,
operator|(
name|void
operator|*
operator|)
name|rblim
argument_list|,
literal|8192
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
name|IO_TIMEOUT
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
literal|0
argument_list|,
name|SF_NO_PRINT
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
name|QFRLS
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|scsi_rewind
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
literal|1
argument_list|,
name|sadone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|FALSE
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
name|REWIND_TIMEOUT
argument_list|)
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
name|CAM_RETRY_SELTO
argument_list|,
name|SF_NO_PRINT
operator||
name|SF_RETRY_UA
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
name|QFRLS
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"unable to rewind after test read\n"
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
block|}
comment|/* 		 * Next off, determine block limits. 		 */
name|scsi_read_block_limits
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
literal|5
argument_list|,
name|sadone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|rblim
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
name|SCSIOP_TIMEOUT
argument_list|)
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
name|CAM_RETRY_SELTO
argument_list|,
name|SF_NO_PRINT
operator||
name|SF_RETRY_UA
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
name|QFRLS
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * If it's less than SCSI-2, READ BLOCK LIMITS is not 			 * a MANDATORY command. Anyway- it doesn't matter- 			 * we can proceed anyway. 			 */
name|softc
operator|->
name|blk_gran
operator|=
literal|0
expr_stmt|;
name|softc
operator|->
name|max_blk
operator|=
operator|~
literal|0
expr_stmt|;
name|softc
operator|->
name|min_blk
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|softc
operator|->
name|scsi_rev
operator|>=
name|SCSI_REV_SPC
condition|)
block|{
name|softc
operator|->
name|blk_gran
operator|=
name|RBL_GRAN
argument_list|(
name|rblim
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|softc
operator|->
name|blk_gran
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 			 * We take max_blk == min_blk to mean a default to 			 * fixed mode- but note that whatever we get out of 			 * sagetparams below will actually determine whether 			 * we are actually *in* fixed mode. 			 */
name|softc
operator|->
name|max_blk
operator|=
name|scsi_3btoul
argument_list|(
name|rblim
operator|->
name|maximum
argument_list|)
expr_stmt|;
name|softc
operator|->
name|min_blk
operator|=
name|scsi_2btoul
argument_list|(
name|rblim
operator|->
name|minimum
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Next, perform a mode sense to determine 		 * current density, blocksize, compression etc. 		 */
name|error
operator|=
name|sagetparams
argument_list|(
name|periph
argument_list|,
name|SA_PARAM_ALL
argument_list|,
operator|&
name|softc
operator|->
name|media_blksize
argument_list|,
operator|&
name|softc
operator|->
name|media_density
argument_list|,
operator|&
name|softc
operator|->
name|media_numblks
argument_list|,
operator|&
name|softc
operator|->
name|buffer_mode
argument_list|,
operator|&
name|write_protect
argument_list|,
operator|&
name|softc
operator|->
name|speed
argument_list|,
operator|&
name|comp_supported
argument_list|,
operator|&
name|comp_enabled
argument_list|,
operator|&
name|softc
operator|->
name|comp_algorithm
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * We could work a little harder here. We could 			 * adjust our attempts to get information. It 			 * might be an ancient tape drive. If someone 			 * nudges us, we'll do that. 			 */
goto|goto
name|exit
goto|;
block|}
comment|/* 		 * If no quirk has determined that this is a device that is 		 * preferred to be in fixed or variable mode, now is the time 		 * to find out. 	 	 */
if|if
condition|(
operator|(
name|softc
operator|->
name|quirks
operator|&
operator|(
name|SA_QUIRK_FIXED
operator||
name|SA_QUIRK_VARIABLE
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|guessing
operator|=
literal|1
expr_stmt|;
comment|/* 			 * This could be expensive to find out. Luckily we 			 * only need to do this once. If we start out in 			 * 'default' mode, try and set ourselves to one 			 * of the densities that would determine a wad 			 * of other stuff. Go from highest to lowest. 			 */
if|if
condition|(
name|softc
operator|->
name|media_density
operator|==
name|SCSI_DEFAULT_DENSITY
condition|)
block|{
name|int
name|i
decl_stmt|;
specifier|static
name|u_int8_t
name|ctry
index|[]
init|=
block|{
name|SCSI_DENSITY_HALFINCH_PE
block|,
name|SCSI_DENSITY_HALFINCH_6250C
block|,
name|SCSI_DENSITY_HALFINCH_6250
block|,
name|SCSI_DENSITY_HALFINCH_1600
block|,
name|SCSI_DENSITY_HALFINCH_800
block|,
name|SCSI_DENSITY_QIC_4GB
block|,
name|SCSI_DENSITY_QIC_2GB
block|,
name|SCSI_DENSITY_QIC_525_320
block|,
name|SCSI_DENSITY_QIC_150
block|,
name|SCSI_DENSITY_QIC_120
block|,
name|SCSI_DENSITY_QIC_24
block|,
name|SCSI_DENSITY_QIC_11_9TRK
block|,
name|SCSI_DENSITY_QIC_11_4TRK
block|,
name|SCSI_DENSITY_QIC_1320
block|,
name|SCSI_DENSITY_QIC_3080
block|,
literal|0
block|}
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ctry
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|sasetparams
argument_list|(
name|periph
argument_list|,
name|SA_PARAM_DENSITY
argument_list|,
literal|0
argument_list|,
name|ctry
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|SF_NO_PRINT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|softc
operator|->
name|media_density
operator|=
name|ctry
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
block|}
switch|switch
condition|(
name|softc
operator|->
name|media_density
condition|)
block|{
case|case
name|SCSI_DENSITY_QIC_11_4TRK
case|:
case|case
name|SCSI_DENSITY_QIC_11_9TRK
case|:
case|case
name|SCSI_DENSITY_QIC_24
case|:
case|case
name|SCSI_DENSITY_QIC_120
case|:
case|case
name|SCSI_DENSITY_QIC_150
case|:
case|case
name|SCSI_DENSITY_QIC_525_320
case|:
case|case
name|SCSI_DENSITY_QIC_1320
case|:
case|case
name|SCSI_DENSITY_QIC_3080
case|:
name|softc
operator|->
name|quirks
operator|&=
operator|~
name|SA_QUIRK_2FM
expr_stmt|;
name|softc
operator|->
name|quirks
operator||=
name|SA_QUIRK_FIXED
operator||
name|SA_QUIRK_1FM
expr_stmt|;
name|softc
operator|->
name|last_media_blksize
operator|=
literal|512
expr_stmt|;
break|break;
case|case
name|SCSI_DENSITY_QIC_4GB
case|:
case|case
name|SCSI_DENSITY_QIC_2GB
case|:
name|softc
operator|->
name|quirks
operator|&=
operator|~
name|SA_QUIRK_2FM
expr_stmt|;
name|softc
operator|->
name|quirks
operator||=
name|SA_QUIRK_FIXED
operator||
name|SA_QUIRK_1FM
expr_stmt|;
name|softc
operator|->
name|last_media_blksize
operator|=
literal|1024
expr_stmt|;
break|break;
default|default:
name|softc
operator|->
name|last_media_blksize
operator|=
name|softc
operator|->
name|media_blksize
expr_stmt|;
name|softc
operator|->
name|quirks
operator||=
name|SA_QUIRK_VARIABLE
expr_stmt|;
break|break;
block|}
block|}
comment|/* 		 * If no quirk has determined that this is a device that needs 		 * to have 2 Filemarks at EOD, now is the time to find out. 		 */
if|if
condition|(
operator|(
name|softc
operator|->
name|quirks
operator|&
name|SA_QUIRK_2FM
operator|)
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|softc
operator|->
name|media_density
condition|)
block|{
case|case
name|SCSI_DENSITY_HALFINCH_800
case|:
case|case
name|SCSI_DENSITY_HALFINCH_1600
case|:
case|case
name|SCSI_DENSITY_HALFINCH_6250
case|:
case|case
name|SCSI_DENSITY_HALFINCH_6250C
case|:
case|case
name|SCSI_DENSITY_HALFINCH_PE
case|:
name|softc
operator|->
name|quirks
operator|&=
operator|~
name|SA_QUIRK_1FM
expr_stmt|;
name|softc
operator|->
name|quirks
operator||=
name|SA_QUIRK_2FM
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* 		 * Now validate that some info we got makes sense. 		 */
if|if
condition|(
operator|(
name|softc
operator|->
name|max_blk
operator|<
name|softc
operator|->
name|media_blksize
operator|)
operator|||
operator|(
name|softc
operator|->
name|min_blk
operator|>
name|softc
operator|->
name|media_blksize
operator|&&
name|softc
operator|->
name|media_blksize
operator|)
condition|)
block|{
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"BLOCK LIMITS (%d..%d) could not match current "
literal|"block settings (%d)- adjusting\n"
argument_list|,
name|softc
operator|->
name|min_blk
argument_list|,
name|softc
operator|->
name|max_blk
argument_list|,
name|softc
operator|->
name|media_blksize
argument_list|)
expr_stmt|;
name|softc
operator|->
name|max_blk
operator|=
name|softc
operator|->
name|min_blk
operator|=
name|softc
operator|->
name|media_blksize
expr_stmt|;
block|}
comment|/* 		 * Now put ourselves into the right frame of mind based 		 * upon quirks... 		 */
name|tryagain
label|:
comment|/* 		 * If we want to be in FIXED mode and our current blocksize 		 * is not equal to our last blocksize (if nonzero), try and 		 * set ourselves to this last blocksize (as the 'preferred' 		 * block size).  The initial quirkmatch at registry sets the 		 * initial 'last' blocksize. If, for whatever reason, this 		 * 'last' blocksize is zero, set the blocksize to 512, 		 * or min_blk if that's larger. 		 */
if|if
condition|(
operator|(
name|softc
operator|->
name|quirks
operator|&
name|SA_QUIRK_FIXED
operator|)
operator|&&
operator|(
name|softc
operator|->
name|quirks
operator|&
name|SA_QUIRK_NO_MODESEL
operator|)
operator|==
literal|0
operator|&&
operator|(
name|softc
operator|->
name|media_blksize
operator|!=
name|softc
operator|->
name|last_media_blksize
operator|)
condition|)
block|{
name|softc
operator|->
name|media_blksize
operator|=
name|softc
operator|->
name|last_media_blksize
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|media_blksize
operator|==
literal|0
condition|)
block|{
name|softc
operator|->
name|media_blksize
operator|=
literal|512
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|media_blksize
operator|<
name|softc
operator|->
name|min_blk
condition|)
block|{
name|softc
operator|->
name|media_blksize
operator|=
name|softc
operator|->
name|min_blk
expr_stmt|;
block|}
block|}
name|error
operator|=
name|sasetparams
argument_list|(
name|periph
argument_list|,
name|SA_PARAM_BLOCKSIZE
argument_list|,
name|softc
operator|->
name|media_blksize
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SF_NO_PRINT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"unable to set fixed blocksize to %d\n"
argument_list|,
name|softc
operator|->
name|media_blksize
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
block|}
if|if
condition|(
operator|(
name|softc
operator|->
name|quirks
operator|&
name|SA_QUIRK_VARIABLE
operator|)
operator|&&
operator|(
name|softc
operator|->
name|media_blksize
operator|!=
literal|0
operator|)
condition|)
block|{
name|softc
operator|->
name|last_media_blksize
operator|=
name|softc
operator|->
name|media_blksize
expr_stmt|;
name|softc
operator|->
name|media_blksize
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|sasetparams
argument_list|(
name|periph
argument_list|,
name|SA_PARAM_BLOCKSIZE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SF_NO_PRINT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* 				 * If this fails and we were guessing, just 				 * assume that we got it wrong and go try 				 * fixed block mode. Don't even check against 				 * density code at this point. 				 */
if|if
condition|(
name|guessing
condition|)
block|{
name|softc
operator|->
name|quirks
operator|&=
operator|~
name|SA_QUIRK_VARIABLE
expr_stmt|;
name|softc
operator|->
name|quirks
operator||=
name|SA_QUIRK_FIXED
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|last_media_blksize
operator|==
literal|0
condition|)
name|softc
operator|->
name|last_media_blksize
operator|=
literal|512
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"unable to set variable blocksize\n"
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
block|}
comment|/* 		 * Now that we have the current block size, 		 * set up some parameters for sastart's usage. 		 */
if|if
condition|(
name|softc
operator|->
name|media_blksize
condition|)
block|{
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_FIXED
expr_stmt|;
if|if
condition|(
name|powerof2
argument_list|(
name|softc
operator|->
name|media_blksize
argument_list|)
condition|)
block|{
name|softc
operator|->
name|blk_shift
operator|=
name|ffs
argument_list|(
name|softc
operator|->
name|media_blksize
argument_list|)
operator|-
literal|1
expr_stmt|;
name|softc
operator|->
name|blk_mask
operator|=
name|softc
operator|->
name|media_blksize
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|softc
operator|->
name|blk_mask
operator|=
operator|~
literal|0
expr_stmt|;
name|softc
operator|->
name|blk_shift
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * The SCSI-3 spec allows 0 to mean "unspecified". 			 * The SCSI-1 spec allows 0 to mean 'infinite'. 			 * 			 * Either works here. 			 */
if|if
condition|(
name|softc
operator|->
name|max_blk
operator|==
literal|0
condition|)
block|{
name|softc
operator|->
name|max_blk
operator|=
operator|~
literal|0
expr_stmt|;
block|}
name|softc
operator|->
name|blk_shift
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|blk_gran
operator|!=
literal|0
condition|)
block|{
name|softc
operator|->
name|blk_mask
operator|=
name|softc
operator|->
name|blk_gran
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|softc
operator|->
name|blk_mask
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|write_protect
condition|)
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_TAPE_WP
expr_stmt|;
if|if
condition|(
name|comp_supported
condition|)
block|{
if|if
condition|(
name|softc
operator|->
name|saved_comp_algorithm
operator|==
literal|0
condition|)
name|softc
operator|->
name|saved_comp_algorithm
operator|=
name|softc
operator|->
name|comp_algorithm
expr_stmt|;
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_COMP_SUPP
expr_stmt|;
if|if
condition|(
name|comp_enabled
condition|)
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_COMP_ENABLED
expr_stmt|;
block|}
else|else
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_COMP_UNSUPP
expr_stmt|;
if|if
condition|(
operator|(
name|softc
operator|->
name|buffer_mode
operator|==
name|SMH_SA_BUF_MODE_NOBUF
operator|)
operator|&&
operator|(
name|softc
operator|->
name|quirks
operator|&
name|SA_QUIRK_NO_MODESEL
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|sasetparams
argument_list|(
name|periph
argument_list|,
name|SA_PARAM_BUFF_MODE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SF_NO_PRINT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|softc
operator|->
name|buffer_mode
operator|=
name|SMH_SA_BUF_MODE_SIBUF
expr_stmt|;
block|}
else|else
block|{
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"unable to set buffered mode\n"
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
comment|/* not an error */
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_TAPE_MOUNTED
expr_stmt|;
block|}
name|exit
label|:
if|if
condition|(
name|rblim
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rblim
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|softc
operator|->
name|dsreg
operator|=
name|MTIO_DSREG_NIL
expr_stmt|;
block|}
else|else
block|{
name|softc
operator|->
name|fileno
operator|=
name|softc
operator|->
name|blkno
operator|=
literal|0
expr_stmt|;
name|softc
operator|->
name|dsreg
operator|=
name|MTIO_DSREG_REST
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SA_1FM_AT_EOD
if|if
condition|(
operator|(
name|softc
operator|->
name|quirks
operator|&
name|SA_QUIRK_2FM
operator|)
operator|==
literal|0
condition|)
name|softc
operator|->
name|quirks
operator||=
name|SA_QUIRK_1FM
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|(
name|softc
operator|->
name|quirks
operator|&
name|SA_QUIRK_1FM
operator|)
operator|==
literal|0
condition|)
name|softc
operator|->
name|quirks
operator||=
name|SA_QUIRK_2FM
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
comment|/* 	 * If we return an error, we're not mounted any more, 	 * so release any device reservation. 	 */
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sareservereleaseunit
argument_list|(
name|periph
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Clear I/O residual. 		 */
name|softc
operator|->
name|last_io_resid
operator|=
literal|0
expr_stmt|;
name|softc
operator|->
name|last_ctl_resid
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * How many filemarks do we need to write if we were to terminate the  * tape session right now? Note that this can be a negative number  */
end_comment

begin_function
specifier|static
name|int
name|samarkswanted
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|int
name|markswanted
decl_stmt|;
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|markswanted
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_TAPE_WRITTEN
operator|)
operator|!=
literal|0
condition|)
block|{
name|markswanted
operator|++
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|quirks
operator|&
name|SA_QUIRK_2FM
condition|)
name|markswanted
operator|++
expr_stmt|;
block|}
name|markswanted
operator|-=
name|softc
operator|->
name|filemarks
expr_stmt|;
return|return
operator|(
name|markswanted
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sacheckeod
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|markswanted
decl_stmt|;
name|markswanted
operator|=
name|samarkswanted
argument_list|(
name|periph
argument_list|)
expr_stmt|;
if|if
condition|(
name|markswanted
operator|>
literal|0
condition|)
block|{
name|error
operator|=
name|sawritefilemarks
argument_list|(
name|periph
argument_list|,
name|markswanted
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|saerror
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|u_int32_t
name|cflgs
parameter_list|,
name|u_int32_t
name|sflgs
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|toobig
init|=
literal|"%d-byte tape record bigger than supplied buffer\n"
decl_stmt|;
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|struct
name|scsi_sense_data
modifier|*
name|sense
decl_stmt|;
name|u_int32_t
name|resid
init|=
literal|0
decl_stmt|;
name|int32_t
name|info
init|=
literal|0
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|int
name|error_code
decl_stmt|,
name|sense_key
decl_stmt|,
name|asc
decl_stmt|,
name|ascq
decl_stmt|,
name|error
decl_stmt|,
name|aqvalid
decl_stmt|;
name|periph
operator|=
name|xpt_path_periph
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|csio
operator|=
operator|&
name|ccb
operator|->
name|csio
expr_stmt|;
name|sense
operator|=
operator|&
name|csio
operator|->
name|sense_data
expr_stmt|;
name|scsi_extract_sense
argument_list|(
name|sense
argument_list|,
operator|&
name|error_code
argument_list|,
operator|&
name|sense_key
argument_list|,
operator|&
name|asc
argument_list|,
operator|&
name|ascq
argument_list|)
expr_stmt|;
name|aqvalid
operator|=
name|sense
operator|->
name|extra_len
operator|>=
literal|6
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
expr_stmt|;
comment|/* 	 * Calculate/latch up, any residuals... We do this in a funny 2-step 	 * so we can print stuff here if we have CAM_DEBUG enabled for this 	 * unit. 	 */
if|if
condition|(
name|status
operator|==
name|CAM_SCSI_STATUS_ERROR
condition|)
block|{
if|if
condition|(
operator|(
name|sense
operator|->
name|error_code
operator|&
name|SSD_ERRCODE_VALID
operator|)
operator|!=
literal|0
condition|)
block|{
name|info
operator|=
operator|(
name|int32_t
operator|)
name|scsi_4btoul
argument_list|(
name|sense
operator|->
name|info
argument_list|)
expr_stmt|;
name|resid
operator|=
name|info
expr_stmt|;
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_FIXED
operator|)
operator|!=
literal|0
condition|)
name|resid
operator|*=
name|softc
operator|->
name|media_blksize
expr_stmt|;
block|}
else|else
block|{
name|resid
operator|=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
name|info
operator|=
name|resid
expr_stmt|;
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_FIXED
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|softc
operator|->
name|media_blksize
condition|)
name|info
operator|/=
name|softc
operator|->
name|media_blksize
expr_stmt|;
block|}
block|}
if|if
condition|(
name|CCB_Type
argument_list|(
name|csio
argument_list|)
operator|==
name|SA_CCB_BUFFER_IO
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|sense
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|softc
operator|->
name|last_io_sense
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|softc
operator|->
name|last_io_cdb
argument_list|,
operator|(
name|int
operator|)
name|csio
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
name|softc
operator|->
name|last_io_resid
operator|=
name|resid
expr_stmt|;
name|softc
operator|->
name|last_resid_was_io
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|sense
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|softc
operator|->
name|last_ctl_sense
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|softc
operator|->
name|last_ctl_cdb
argument_list|,
operator|(
name|int
operator|)
name|csio
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
name|softc
operator|->
name|last_ctl_resid
operator|=
name|resid
expr_stmt|;
name|softc
operator|->
name|last_resid_was_io
operator|=
literal|0
expr_stmt|;
block|}
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_INFO
argument_list|,
operator|(
literal|"CDB[0]=0x%x Key 0x%x "
literal|"ASC/ASCQ 0x%x/0x%x CAM STATUS 0x%x flags 0x%x resid %d "
literal|"dxfer_len %d\n"
operator|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
operator|&
literal|0xff
operator|,
name|sense_key
operator|,
name|asc
operator|,
name|ascq
operator|,
name|status
operator|,
name|sense
operator|->
name|flags
operator|&
operator|~
name|SSD_KEY_RESERVED
operator|,
name|resid
operator|,
name|csio
operator|->
name|dxfer_len
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_INFO
argument_list|,
operator|(
literal|"Cam Status 0x%x\n"
operator|,
name|status
operator|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|CAM_REQ_CMP
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|CAM_SCSI_STATUS_ERROR
case|:
comment|/* 		 * If a read/write command, we handle it here. 		 */
if|if
condition|(
name|CCB_Type
argument_list|(
name|csio
argument_list|)
operator|!=
name|SA_CCB_WAITING
condition|)
block|{
break|break;
block|}
comment|/* 		 * If this was just EOM/EOP, Filemark, Setmark or ILI detected 		 * on a non read/write command, we assume it's not an error 		 * and propagate the residule and return. 		 */
if|if
condition|(
operator|(
name|aqvalid
operator|&&
name|asc
operator|==
literal|0
operator|&&
name|ascq
operator|>
literal|0
operator|&&
name|ascq
operator|<=
literal|5
operator|)
operator|||
operator|(
name|aqvalid
operator|==
literal|0
operator|&&
name|sense_key
operator|==
name|SSD_KEY_NO_SENSE
operator|)
condition|)
block|{
name|csio
operator|->
name|resid
operator|=
name|resid
expr_stmt|;
name|QFRLS
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 		 * Otherwise, we let the common code handle this. 		 */
return|return
operator|(
name|cam_periph_error
argument_list|(
name|ccb
argument_list|,
name|cflgs
argument_list|,
name|sflgs
argument_list|,
operator|&
name|softc
operator|->
name|saved_ccb
argument_list|)
operator|)
return|;
comment|/* 	 * XXX: To Be Fixed 	 * We cannot depend upon CAM honoring retry counts for these. 	 */
case|case
name|CAM_SCSI_BUS_RESET
case|:
case|case
name|CAM_BDR_SENT
case|:
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|retry_count
operator|<=
literal|0
condition|)
block|{
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* FALLTHROUGH */
default|default:
return|return
operator|(
name|cam_periph_error
argument_list|(
name|ccb
argument_list|,
name|cflgs
argument_list|,
name|sflgs
argument_list|,
operator|&
name|softc
operator|->
name|saved_ccb
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * Handle filemark, end of tape, mismatched record sizes.... 	 * From this point out, we're only handling read/write cases. 	 * Handle writes&& reads differently. 	 */
if|if
condition|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
operator|==
name|SA_WRITE
condition|)
block|{
if|if
condition|(
name|sense_key
operator|==
name|SSD_KEY_VOLUME_OVERFLOW
condition|)
block|{
name|csio
operator|->
name|resid
operator|=
name|resid
expr_stmt|;
name|error
operator|=
name|ENOSPC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sense
operator|->
name|flags
operator|&
name|SSD_EOM
condition|)
block|{
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_EOM_PENDING
expr_stmt|;
comment|/* 			 * Grotesque as it seems, the few times 			 * I've actually seen a non-zero resid, 			 * the tape drive actually lied and had 			 * written all the data!. 			 */
name|csio
operator|->
name|resid
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|csio
operator|->
name|resid
operator|=
name|resid
expr_stmt|;
if|if
condition|(
name|sense_key
operator|==
name|SSD_KEY_BLANK_CHECK
condition|)
block|{
if|if
condition|(
name|softc
operator|->
name|quirks
operator|&
name|SA_QUIRK_1FM
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_EOM_PENDING
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|EIO
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sense
operator|->
name|flags
operator|&
name|SSD_FILEMARK
condition|)
block|{
if|if
condition|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_FIXED
condition|)
block|{
name|error
operator|=
operator|-
literal|1
expr_stmt|;
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_EOF_PENDING
expr_stmt|;
block|}
comment|/* 			 * Unconditionally, if we detected a filemark on a read, 			 * mark that we've run moved a file ahead. 			 */
if|if
condition|(
name|softc
operator|->
name|fileno
operator|!=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
condition|)
block|{
name|softc
operator|->
name|fileno
operator|++
expr_stmt|;
name|softc
operator|->
name|blkno
operator|=
literal|0
expr_stmt|;
name|csio
operator|->
name|ccb_h
operator|.
name|ccb_pflags
operator||=
name|SA_POSITION_UPDATED
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Incorrect Length usually applies to read, but can apply to writes. 	 */
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|(
name|sense
operator|->
name|flags
operator|&
name|SSD_ILI
operator|)
condition|)
block|{
if|if
condition|(
name|info
operator|<
literal|0
condition|)
block|{
name|xpt_print_path
argument_list|(
name|csio
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|toobig
argument_list|,
name|csio
operator|->
name|dxfer_len
operator|-
name|info
argument_list|)
expr_stmt|;
name|csio
operator|->
name|resid
operator|=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
block|}
else|else
block|{
name|csio
operator|->
name|resid
operator|=
name|resid
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_FIXED
condition|)
block|{
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_EIO_PENDING
expr_stmt|;
block|}
comment|/* 			 * Bump the block number if we hadn't seen a filemark. 			 * Do this independent of errors (we've moved anyway). 			 */
if|if
condition|(
operator|(
name|sense
operator|->
name|flags
operator|&
name|SSD_FILEMARK
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|softc
operator|->
name|blkno
operator|!=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
condition|)
block|{
name|softc
operator|->
name|blkno
operator|++
expr_stmt|;
name|csio
operator|->
name|ccb_h
operator|.
name|ccb_pflags
operator||=
name|SA_POSITION_UPDATED
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|error
operator|<=
literal|0
condition|)
block|{
comment|/* 		 * Unfreeze the queue if frozen as we're not returning anything 		 * to our waiters that would indicate an I/O error has occurred 		 * (yet). 		 */
name|QFRLS
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sagetparams
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|sa_params
name|params_to_get
parameter_list|,
name|u_int32_t
modifier|*
name|blocksize
parameter_list|,
name|u_int8_t
modifier|*
name|density
parameter_list|,
name|u_int32_t
modifier|*
name|numblocks
parameter_list|,
name|int
modifier|*
name|buff_mode
parameter_list|,
name|u_int8_t
modifier|*
name|write_protect
parameter_list|,
name|u_int8_t
modifier|*
name|speed
parameter_list|,
name|int
modifier|*
name|comp_supported
parameter_list|,
name|int
modifier|*
name|comp_enabled
parameter_list|,
name|u_int32_t
modifier|*
name|comp_algorithm
parameter_list|,
name|sa_comp_t
modifier|*
name|tcs
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|void
modifier|*
name|mode_buffer
decl_stmt|;
name|struct
name|scsi_mode_header_6
modifier|*
name|mode_hdr
decl_stmt|;
name|struct
name|scsi_mode_blk_desc
modifier|*
name|mode_blk
decl_stmt|;
name|int
name|mode_buffer_len
decl_stmt|;
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|u_int8_t
name|cpage
decl_stmt|;
name|int
name|error
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|quirks
operator|&
name|SA_QUIRK_NO_CPAGE
condition|)
name|cpage
operator|=
name|SA_DEVICE_CONFIGURATION_PAGE
expr_stmt|;
else|else
name|cpage
operator|=
name|SA_DATA_COMPRESSION_PAGE
expr_stmt|;
name|retry
label|:
name|mode_buffer_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|mode_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|mode_blk
argument_list|)
expr_stmt|;
if|if
condition|(
name|params_to_get
operator|&
name|SA_PARAM_COMPRESSION
condition|)
block|{
if|if
condition|(
name|softc
operator|->
name|quirks
operator|&
name|SA_QUIRK_NOCOMP
condition|)
block|{
operator|*
name|comp_supported
operator|=
name|FALSE
expr_stmt|;
name|params_to_get
operator|&=
operator|~
name|SA_PARAM_COMPRESSION
expr_stmt|;
block|}
else|else
name|mode_buffer_len
operator|+=
sizeof|sizeof
argument_list|(
name|sa_comp_t
argument_list|)
expr_stmt|;
block|}
name|mode_buffer
operator|=
name|malloc
argument_list|(
name|mode_buffer_len
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|mode_hdr
operator|=
operator|(
expr|struct
name|scsi_mode_header_6
operator|*
operator|)
name|mode_buffer
expr_stmt|;
name|mode_blk
operator|=
operator|(
expr|struct
name|scsi_mode_blk_desc
operator|*
operator|)
operator|&
name|mode_hdr
index|[
literal|1
index|]
expr_stmt|;
comment|/* it is safe to retry this */
name|scsi_mode_sense
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
literal|5
argument_list|,
name|sadone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|FALSE
argument_list|,
name|SMS_PAGE_CTRL_CURRENT
argument_list|,
operator|(
name|params_to_get
operator|&
name|SA_PARAM_COMPRESSION
operator|)
condition|?
name|cpage
else|:
name|SMS_VENDOR_SPECIFIC_PAGE
argument_list|,
name|mode_buffer
argument_list|,
name|mode_buffer_len
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
name|SCSIOP_TIMEOUT
argument_list|)
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
literal|0
argument_list|,
name|SF_NO_PRINT
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
name|QFRLS
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|status
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINVAL
operator|&&
operator|(
name|params_to_get
operator|&
name|SA_PARAM_COMPRESSION
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Hmm. Let's see if we can try another page... 		 * If we've already done that, give up on compression 		 * for this device and remember this for the future 		 * and attempt the request without asking for compression 		 * info. 		 */
if|if
condition|(
name|cpage
operator|==
name|SA_DATA_COMPRESSION_PAGE
condition|)
block|{
name|cpage
operator|=
name|SA_DEVICE_CONFIGURATION_PAGE
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|softc
operator|->
name|quirks
operator||=
name|SA_QUIRK_NOCOMP
expr_stmt|;
name|free
argument_list|(
name|mode_buffer
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|CAM_SCSI_STATUS_ERROR
condition|)
block|{
comment|/* Tell the user about the fatal error. */
name|scsi_sense_print
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|)
expr_stmt|;
goto|goto
name|sagetparamsexit
goto|;
block|}
comment|/* 	 * If the user only wants the compression information, and 	 * the device doesn't send back the block descriptor, it's 	 * no big deal.  If the user wants more than just 	 * compression, though, and the device doesn't pass back the 	 * block descriptor, we need to send another mode sense to 	 * get the block descriptor. 	 */
if|if
condition|(
operator|(
name|mode_hdr
operator|->
name|blk_desc_len
operator|==
literal|0
operator|)
operator|&&
operator|(
name|params_to_get
operator|&
name|SA_PARAM_COMPRESSION
operator|)
operator|&&
operator|(
name|params_to_get
operator|&
operator|~
operator|(
name|SA_PARAM_COMPRESSION
operator|)
operator|)
condition|)
block|{
comment|/* 		 * Decrease the mode buffer length by the size of 		 * the compression page, to make sure the data 		 * there doesn't get overwritten. 		 */
name|mode_buffer_len
operator|-=
sizeof|sizeof
argument_list|(
name|sa_comp_t
argument_list|)
expr_stmt|;
comment|/* 		 * Now move the compression page that we presumably 		 * got back down the memory chunk a little bit so 		 * it doesn't get spammed. 		 */
name|bcopy
argument_list|(
operator|&
name|mode_hdr
index|[
literal|0
index|]
argument_list|,
operator|&
name|mode_hdr
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|sa_comp_t
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|mode_hdr
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|mode_hdr
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Now, we issue another mode sense and just ask 		 * for the block descriptor, etc. 		 */
name|scsi_mode_sense
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
literal|2
argument_list|,
name|sadone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|FALSE
argument_list|,
name|SMS_PAGE_CTRL_CURRENT
argument_list|,
name|SMS_VENDOR_SPECIFIC_PAGE
argument_list|,
name|mode_buffer
argument_list|,
name|mode_buffer_len
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
name|SCSIOP_TIMEOUT
argument_list|)
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
literal|0
argument_list|,
name|SF_NO_PRINT
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
name|QFRLS
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|sagetparamsexit
goto|;
block|}
if|if
condition|(
name|params_to_get
operator|&
name|SA_PARAM_BLOCKSIZE
condition|)
operator|*
name|blocksize
operator|=
name|scsi_3btoul
argument_list|(
name|mode_blk
operator|->
name|blklen
argument_list|)
expr_stmt|;
if|if
condition|(
name|params_to_get
operator|&
name|SA_PARAM_NUMBLOCKS
condition|)
operator|*
name|numblocks
operator|=
name|scsi_3btoul
argument_list|(
name|mode_blk
operator|->
name|nblocks
argument_list|)
expr_stmt|;
if|if
condition|(
name|params_to_get
operator|&
name|SA_PARAM_BUFF_MODE
condition|)
operator|*
name|buff_mode
operator|=
name|mode_hdr
operator|->
name|dev_spec
operator|&
name|SMH_SA_BUF_MODE_MASK
expr_stmt|;
if|if
condition|(
name|params_to_get
operator|&
name|SA_PARAM_DENSITY
condition|)
operator|*
name|density
operator|=
name|mode_blk
operator|->
name|density
expr_stmt|;
if|if
condition|(
name|params_to_get
operator|&
name|SA_PARAM_WP
condition|)
operator|*
name|write_protect
operator|=
operator|(
name|mode_hdr
operator|->
name|dev_spec
operator|&
name|SMH_SA_WP
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
if|if
condition|(
name|params_to_get
operator|&
name|SA_PARAM_SPEED
condition|)
operator|*
name|speed
operator|=
name|mode_hdr
operator|->
name|dev_spec
operator|&
name|SMH_SA_SPEED_MASK
expr_stmt|;
if|if
condition|(
name|params_to_get
operator|&
name|SA_PARAM_COMPRESSION
condition|)
block|{
name|sa_comp_t
modifier|*
name|ntcs
init|=
operator|(
name|sa_comp_t
operator|*
operator|)
operator|&
name|mode_blk
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|cpage
operator|==
name|SA_DATA_COMPRESSION_PAGE
condition|)
block|{
name|struct
name|scsi_data_compression_page
modifier|*
name|cp
init|=
operator|&
name|ntcs
operator|->
name|dcomp
decl_stmt|;
operator|*
name|comp_supported
operator|=
operator|(
name|cp
operator|->
name|dce_and_dcc
operator|&
name|SA_DCP_DCC
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
operator|*
name|comp_enabled
operator|=
operator|(
name|cp
operator|->
name|dce_and_dcc
operator|&
name|SA_DCP_DCE
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
operator|*
name|comp_algorithm
operator|=
name|scsi_4btoul
argument_list|(
name|cp
operator|->
name|comp_algorithm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|scsi_dev_conf_page
modifier|*
name|cp
init|=
operator|&
name|ntcs
operator|->
name|dconf
decl_stmt|;
comment|/* 			 * We don't really know whether this device supports 			 * Data Compression if the the algorithm field is 			 * zero. Just say we do. 			 */
operator|*
name|comp_supported
operator|=
name|TRUE
expr_stmt|;
operator|*
name|comp_enabled
operator|=
operator|(
name|cp
operator|->
name|sel_comp_alg
operator|!=
name|SA_COMP_NONE
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
operator|*
name|comp_algorithm
operator|=
name|cp
operator|->
name|sel_comp_alg
expr_stmt|;
block|}
if|if
condition|(
name|tcs
operator|!=
name|NULL
condition|)
name|bcopy
argument_list|(
name|ntcs
argument_list|,
name|tcs
argument_list|,
sizeof|sizeof
argument_list|(
name|sa_comp_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CAM_DEBUGGED
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_INFO
argument_list|)
condition|)
block|{
name|int
name|idx
decl_stmt|;
name|char
modifier|*
name|xyz
init|=
name|mode_buffer
decl_stmt|;
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Mode Sense Data="
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|mode_buffer_len
condition|;
name|idx
operator|++
control|)
name|printf
argument_list|(
literal|" 0x%02x"
argument_list|,
name|xyz
index|[
name|idx
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|sagetparamsexit
label|:
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mode_buffer
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The purpose of this function is to set one of four different parameters  * for a tape drive:  *	- blocksize  *	- density  *	- compression / compression algorithm  *	- buffering mode  *  * The assumption is that this will be called from saioctl(), and therefore  * from a process context.  Thus the waiting malloc calls below.  If that  * assumption ever changes, the malloc calls should be changed to be  * NOWAIT mallocs.  *  * Any or all of the four parameters may be set when this function is  * called.  It should handle setting more than one parameter at once.  */
end_comment

begin_function
specifier|static
name|int
name|sasetparams
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|sa_params
name|params_to_set
parameter_list|,
name|u_int32_t
name|blocksize
parameter_list|,
name|u_int8_t
name|density
parameter_list|,
name|u_int32_t
name|calg
parameter_list|,
name|u_int32_t
name|sense_flags
parameter_list|)
block|{
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|u_int32_t
name|current_blocksize
decl_stmt|;
name|u_int32_t
name|current_calg
decl_stmt|;
name|u_int8_t
name|current_density
decl_stmt|;
name|u_int8_t
name|current_speed
decl_stmt|;
name|int
name|comp_enabled
decl_stmt|,
name|comp_supported
decl_stmt|;
name|void
modifier|*
name|mode_buffer
decl_stmt|;
name|int
name|mode_buffer_len
decl_stmt|;
name|struct
name|scsi_mode_header_6
modifier|*
name|mode_hdr
decl_stmt|;
name|struct
name|scsi_mode_blk_desc
modifier|*
name|mode_blk
decl_stmt|;
name|sa_comp_t
modifier|*
name|ccomp
decl_stmt|,
modifier|*
name|cpage
decl_stmt|;
name|int
name|buff_mode
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|ccomp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|sa_comp_t
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* 	 * Since it doesn't make sense to set the number of blocks, or 	 * write protection, we won't try to get the current value.  We 	 * always want to get the blocksize, so we can set it back to the 	 * proper value. 	 */
name|error
operator|=
name|sagetparams
argument_list|(
name|periph
argument_list|,
name|params_to_set
operator||
name|SA_PARAM_BLOCKSIZE
operator||
name|SA_PARAM_SPEED
argument_list|,
operator|&
name|current_blocksize
argument_list|,
operator|&
name|current_density
argument_list|,
name|NULL
argument_list|,
operator|&
name|buff_mode
argument_list|,
name|NULL
argument_list|,
operator|&
name|current_speed
argument_list|,
operator|&
name|comp_supported
argument_list|,
operator|&
name|comp_enabled
argument_list|,
operator|&
name|current_calg
argument_list|,
name|ccomp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|ccomp
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|mode_buffer_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|mode_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|mode_blk
argument_list|)
expr_stmt|;
if|if
condition|(
name|params_to_set
operator|&
name|SA_PARAM_COMPRESSION
condition|)
name|mode_buffer_len
operator|+=
sizeof|sizeof
argument_list|(
name|sa_comp_t
argument_list|)
expr_stmt|;
name|mode_buffer
operator|=
name|malloc
argument_list|(
name|mode_buffer_len
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|mode_hdr
operator|=
operator|(
expr|struct
name|scsi_mode_header_6
operator|*
operator|)
name|mode_buffer
expr_stmt|;
name|mode_blk
operator|=
operator|(
expr|struct
name|scsi_mode_blk_desc
operator|*
operator|)
operator|&
name|mode_hdr
index|[
literal|1
index|]
expr_stmt|;
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|retry
label|:
if|if
condition|(
name|params_to_set
operator|&
name|SA_PARAM_COMPRESSION
condition|)
block|{
if|if
condition|(
name|mode_blk
condition|)
block|{
name|cpage
operator|=
operator|(
name|sa_comp_t
operator|*
operator|)
operator|&
name|mode_blk
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|cpage
operator|=
operator|(
name|sa_comp_t
operator|*
operator|)
operator|&
name|mode_hdr
index|[
literal|1
index|]
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|ccomp
argument_list|,
name|cpage
argument_list|,
sizeof|sizeof
argument_list|(
name|sa_comp_t
argument_list|)
argument_list|)
expr_stmt|;
name|cpage
operator|->
name|hdr
operator|.
name|pagecode
operator|&=
operator|~
literal|0x80
expr_stmt|;
block|}
else|else
name|cpage
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * If the caller wants us to set the blocksize, use the one they 	 * pass in.  Otherwise, use the blocksize we got back from the 	 * mode select above. 	 */
if|if
condition|(
name|mode_blk
condition|)
block|{
if|if
condition|(
name|params_to_set
operator|&
name|SA_PARAM_BLOCKSIZE
condition|)
name|scsi_ulto3b
argument_list|(
name|blocksize
argument_list|,
name|mode_blk
operator|->
name|blklen
argument_list|)
expr_stmt|;
else|else
name|scsi_ulto3b
argument_list|(
name|current_blocksize
argument_list|,
name|mode_blk
operator|->
name|blklen
argument_list|)
expr_stmt|;
comment|/* 		 * Set density if requested, else preserve old density. 		 * SCSI_SAME_DENSITY only applies to SCSI-2 or better 		 * devices, else density we've latched up in our softc. 		 */
if|if
condition|(
name|params_to_set
operator|&
name|SA_PARAM_DENSITY
condition|)
block|{
name|mode_blk
operator|->
name|density
operator|=
name|density
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|softc
operator|->
name|scsi_rev
operator|>
name|SCSI_REV_CCS
condition|)
block|{
name|mode_blk
operator|->
name|density
operator|=
name|SCSI_SAME_DENSITY
expr_stmt|;
block|}
else|else
block|{
name|mode_blk
operator|->
name|density
operator|=
name|softc
operator|->
name|media_density
expr_stmt|;
block|}
block|}
comment|/* 	 * For mode selects, these two fields must be zero. 	 */
name|mode_hdr
operator|->
name|data_length
operator|=
literal|0
expr_stmt|;
name|mode_hdr
operator|->
name|medium_type
operator|=
literal|0
expr_stmt|;
comment|/* set the speed to the current value */
name|mode_hdr
operator|->
name|dev_spec
operator|=
name|current_speed
expr_stmt|;
comment|/* if set, set single-initiator buffering mode */
if|if
condition|(
name|softc
operator|->
name|buffer_mode
operator|==
name|SMH_SA_BUF_MODE_SIBUF
condition|)
block|{
name|mode_hdr
operator|->
name|dev_spec
operator||=
name|SMH_SA_BUF_MODE_SIBUF
expr_stmt|;
block|}
if|if
condition|(
name|mode_blk
condition|)
name|mode_hdr
operator|->
name|blk_desc_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_mode_blk_desc
argument_list|)
expr_stmt|;
else|else
name|mode_hdr
operator|->
name|blk_desc_len
operator|=
literal|0
expr_stmt|;
comment|/* 	 * First, if the user wants us to set the compression algorithm or 	 * just turn compression on, check to make sure that this drive 	 * supports compression. 	 */
if|if
condition|(
name|params_to_set
operator|&
name|SA_PARAM_COMPRESSION
condition|)
block|{
comment|/* 		 * If the compression algorithm is 0, disable compression. 		 * If the compression algorithm is non-zero, enable 		 * compression and set the compression type to the 		 * specified compression algorithm, unless the algorithm is 		 * MT_COMP_ENABLE.  In that case, we look at the 		 * compression algorithm that is currently set and if it is 		 * non-zero, we leave it as-is.  If it is zero, and we have 		 * saved a compression algorithm from a time when 		 * compression was enabled before, set the compression to 		 * the saved value. 		 */
switch|switch
condition|(
name|ccomp
operator|->
name|hdr
operator|.
name|pagecode
operator|&
operator|~
literal|0x80
condition|)
block|{
case|case
name|SA_DEVICE_CONFIGURATION_PAGE
case|:
block|{
name|struct
name|scsi_dev_conf_page
modifier|*
name|dcp
init|=
operator|&
name|cpage
operator|->
name|dconf
decl_stmt|;
if|if
condition|(
name|calg
operator|==
literal|0
condition|)
block|{
name|dcp
operator|->
name|sel_comp_alg
operator|=
name|SA_COMP_NONE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|calg
operator|!=
name|MT_COMP_ENABLE
condition|)
block|{
name|dcp
operator|->
name|sel_comp_alg
operator|=
name|calg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dcp
operator|->
name|sel_comp_alg
operator|==
name|SA_COMP_NONE
operator|&&
name|softc
operator|->
name|saved_comp_algorithm
operator|!=
literal|0
condition|)
block|{
name|dcp
operator|->
name|sel_comp_alg
operator|=
name|softc
operator|->
name|saved_comp_algorithm
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SA_DATA_COMPRESSION_PAGE
case|:
if|if
condition|(
name|ccomp
operator|->
name|dcomp
operator|.
name|dce_and_dcc
operator|&
name|SA_DCP_DCC
condition|)
block|{
name|struct
name|scsi_data_compression_page
modifier|*
name|dcp
init|=
operator|&
name|cpage
operator|->
name|dcomp
decl_stmt|;
if|if
condition|(
name|calg
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Disable compression, but leave the 				 * decompression and the capability bit 				 * alone. 				 */
name|dcp
operator|->
name|dce_and_dcc
operator|=
name|SA_DCP_DCC
expr_stmt|;
name|dcp
operator|->
name|dde_and_red
operator||=
name|SA_DCP_DDE
expr_stmt|;
break|break;
block|}
comment|/* enable compression&& decompression */
name|dcp
operator|->
name|dce_and_dcc
operator|=
name|SA_DCP_DCE
operator||
name|SA_DCP_DCC
expr_stmt|;
name|dcp
operator|->
name|dde_and_red
operator||=
name|SA_DCP_DDE
expr_stmt|;
comment|/* 			 * If there, use compression algorithm from caller. 			 * Otherwise, if there's a saved compression algorithm 			 * and there is no current algorithm, use the saved 			 * algorithm. Else parrot back what we got and hope 			 * for the best. 			 */
if|if
condition|(
name|calg
operator|!=
name|MT_COMP_ENABLE
condition|)
block|{
name|scsi_ulto4b
argument_list|(
name|calg
argument_list|,
name|dcp
operator|->
name|comp_algorithm
argument_list|)
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|calg
argument_list|,
name|dcp
operator|->
name|decomp_algorithm
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scsi_4btoul
argument_list|(
name|dcp
operator|->
name|comp_algorithm
argument_list|)
operator|==
literal|0
operator|&&
name|softc
operator|->
name|saved_comp_algorithm
operator|!=
literal|0
condition|)
block|{
name|scsi_ulto4b
argument_list|(
name|softc
operator|->
name|saved_comp_algorithm
argument_list|,
name|dcp
operator|->
name|comp_algorithm
argument_list|)
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|softc
operator|->
name|saved_comp_algorithm
argument_list|,
name|dcp
operator|->
name|decomp_algorithm
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* 		 * Compression does not appear to be supported- 		 * at least via the DATA COMPRESSION page. It 		 * would be too much to ask us to believe that 		 * the page itself is supported, but incorrectly 		 * reports an ability to manipulate data compression, 		 * so we'll assume that this device doesn't support 		 * compression. We can just fall through for that. 		 */
comment|/* FALLTHROUGH */
default|default:
comment|/* 			 * The drive doesn't seem to support compression, 			 * so turn off the set compression bit. 			 */
name|params_to_set
operator|&=
operator|~
name|SA_PARAM_COMPRESSION
expr_stmt|;
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"device does not seem to support compression\n"
argument_list|)
expr_stmt|;
comment|/* 			 * If that was the only thing the user wanted us to set, 			 * clean up allocated resources and return with 			 * 'operation not supported'. 			 */
if|if
condition|(
name|params_to_set
operator|==
name|SA_PARAM_NONE
condition|)
block|{
name|free
argument_list|(
name|mode_buffer
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
comment|/* 			 * That wasn't the only thing the user wanted us to set. 			 * So, decrease the stated mode buffer length by the 			 * size of the compression mode page. 			 */
name|mode_buffer_len
operator|-=
sizeof|sizeof
argument_list|(
name|sa_comp_t
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* It is safe to retry this operation */
name|scsi_mode_select
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
literal|5
argument_list|,
name|sadone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
operator|(
name|params_to_set
operator|&
name|SA_PARAM_COMPRESSION
operator|)
condition|?
name|TRUE
else|:
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|mode_buffer
argument_list|,
name|mode_buffer_len
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
name|SCSIOP_TIMEOUT
argument_list|)
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
literal|0
argument_list|,
name|sense_flags
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
name|QFRLS
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|CAM_DEBUGGED
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_INFO
argument_list|)
condition|)
block|{
name|int
name|idx
decl_stmt|;
name|char
modifier|*
name|xyz
init|=
name|mode_buffer
decl_stmt|;
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Err%d, Mode Select Data="
argument_list|,
name|error
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|mode_buffer_len
condition|;
name|idx
operator|++
control|)
name|printf
argument_list|(
literal|" 0x%02x"
argument_list|,
name|xyz
index|[
name|idx
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
comment|/* 		 * If we can, try without setting density/blocksize. 		 */
if|if
condition|(
name|mode_blk
condition|)
block|{
if|if
condition|(
operator|(
name|params_to_set
operator|&
operator|(
name|SA_PARAM_DENSITY
operator||
name|SA_PARAM_BLOCKSIZE
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|mode_blk
operator|=
name|NULL
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
block|}
else|else
block|{
name|mode_blk
operator|=
operator|(
expr|struct
name|scsi_mode_blk_desc
operator|*
operator|)
operator|&
name|mode_hdr
index|[
literal|1
index|]
expr_stmt|;
name|cpage
operator|=
operator|(
name|sa_comp_t
operator|*
operator|)
operator|&
name|mode_blk
index|[
literal|1
index|]
expr_stmt|;
block|}
comment|/* 		 * If we were setting the blocksize, and that failed, we 		 * want to set it to its original value.  If we weren't 		 * setting the blocksize, we don't want to change it. 		 */
name|scsi_ulto3b
argument_list|(
name|current_blocksize
argument_list|,
name|mode_blk
operator|->
name|blklen
argument_list|)
expr_stmt|;
comment|/* 		 * Set density if requested, else preserve old density. 		 * SCSI_SAME_DENSITY only applies to SCSI-2 or better 		 * devices, else density we've latched up in our softc. 		 */
if|if
condition|(
name|params_to_set
operator|&
name|SA_PARAM_DENSITY
condition|)
block|{
name|mode_blk
operator|->
name|density
operator|=
name|current_density
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|softc
operator|->
name|scsi_rev
operator|>
name|SCSI_REV_CCS
condition|)
block|{
name|mode_blk
operator|->
name|density
operator|=
name|SCSI_SAME_DENSITY
expr_stmt|;
block|}
else|else
block|{
name|mode_blk
operator|->
name|density
operator|=
name|softc
operator|->
name|media_density
expr_stmt|;
block|}
if|if
condition|(
name|params_to_set
operator|&
name|SA_PARAM_COMPRESSION
condition|)
name|bcopy
argument_list|(
name|ccomp
argument_list|,
name|cpage
argument_list|,
sizeof|sizeof
argument_list|(
name|sa_comp_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * The retry count is the only CCB field that might have been 		 * changed that we care about, so reset it back to 1. 		 */
name|ccb
operator|->
name|ccb_h
operator|.
name|retry_count
operator|=
literal|1
expr_stmt|;
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
literal|0
argument_list|,
name|sense_flags
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
name|QFRLS
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccomp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ccomp
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|params_to_set
operator|&
name|SA_PARAM_COMPRESSION
condition|)
block|{
if|if
condition|(
name|error
condition|)
block|{
name|softc
operator|->
name|flags
operator|&=
operator|~
name|SA_FLAG_COMP_ENABLED
expr_stmt|;
comment|/* 			 * Even if we get an error setting compression, 			 * do not say that we don't support it. We could 			 * have been wrong, or it may be media specific. 			 *	softc->flags&= ~SA_FLAG_COMP_SUPP; 			 */
name|softc
operator|->
name|saved_comp_algorithm
operator|=
name|softc
operator|->
name|comp_algorithm
expr_stmt|;
name|softc
operator|->
name|comp_algorithm
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_COMP_ENABLED
expr_stmt|;
name|softc
operator|->
name|comp_algorithm
operator|=
name|calg
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|mode_buffer
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|saprevent
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|action
parameter_list|)
block|{
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|error
decl_stmt|,
name|sf
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
if|if
condition|(
operator|(
name|action
operator|==
name|PR_ALLOW
operator|)
operator|&&
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_TAPE_LOCKED
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|action
operator|==
name|PR_PREVENT
operator|)
operator|&&
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_TAPE_LOCKED
operator|)
operator|!=
literal|0
condition|)
return|return;
comment|/* 	 * We can be quiet about illegal requests. 	 */
if|if
condition|(
name|CAM_DEBUGGED
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_INFO
argument_list|)
condition|)
block|{
name|sf
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|sf
operator|=
name|SF_QUIET_IR
expr_stmt|;
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* It is safe to retry this operation */
name|scsi_prevent
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
literal|5
argument_list|,
name|sadone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|action
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
name|SCSIOP_TIMEOUT
argument_list|)
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
literal|0
argument_list|,
name|sf
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
name|QFRLS
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|action
operator|==
name|PR_ALLOW
condition|)
name|softc
operator|->
name|flags
operator|&=
operator|~
name|SA_FLAG_TAPE_LOCKED
expr_stmt|;
else|else
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_TAPE_LOCKED
expr_stmt|;
block|}
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sarewind
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* It is safe to retry this operation */
name|scsi_rewind
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
literal|2
argument_list|,
name|sadone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|FALSE
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
name|REWIND_TIMEOUT
argument_list|)
expr_stmt|;
name|softc
operator|->
name|dsreg
operator|=
name|MTIO_DSREG_REW
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
name|softc
operator|->
name|dsreg
operator|=
name|MTIO_DSREG_REST
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|!=
literal|0
condition|)
name|cam_release_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|softc
operator|->
name|fileno
operator|=
name|softc
operator|->
name|blkno
operator|=
operator|(
name|daddr_t
operator|)
literal|0
expr_stmt|;
else|else
name|softc
operator|->
name|fileno
operator|=
name|softc
operator|->
name|blkno
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|saspace
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|count
parameter_list|,
name|scsi_space_code
name|code
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* This cannot be retried */
name|scsi_space
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
literal|0
argument_list|,
name|sadone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|code
argument_list|,
name|count
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
name|SPACE_TIMEOUT
argument_list|)
expr_stmt|;
comment|/* 	 * Clear residual because we will be using it. 	 */
name|softc
operator|->
name|last_ctl_resid
operator|=
literal|0
expr_stmt|;
name|softc
operator|->
name|dsreg
operator|=
operator|(
name|count
operator|<
literal|0
operator|)
condition|?
name|MTIO_DSREG_REV
else|:
name|MTIO_DSREG_FWD
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
name|softc
operator|->
name|dsreg
operator|=
name|MTIO_DSREG_REST
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|!=
literal|0
condition|)
name|cam_release_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
comment|/* 	 * If a spacing operation has failed, we need to invalidate 	 * this mount. 	 * 	 * If the spacing operation was setmarks or to end of recorded data, 	 * we no longer know our relative position. 	 * 	 * If the spacing operations was spacing files in reverse, we 	 * take account of the residual, but still check against less 	 * than zero- if we've gone negative, we must have hit BOT. 	 * 	 * If the spacing operations was spacing records in reverse and 	 * we have a residual, we've either hit BOT or hit a filemark. 	 * In the former case, we know our new record number (0). In 	 * the latter case, we have absolutely no idea what the real 	 * record number is- we've stopped between the end of the last 	 * record in the previous file and the filemark that stopped 	 * our spacing backwards. 	 */
if|if
condition|(
name|error
condition|)
block|{
name|softc
operator|->
name|fileno
operator|=
name|softc
operator|->
name|blkno
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|SS_SETMARKS
operator|||
name|code
operator|==
name|SS_EOD
condition|)
block|{
name|softc
operator|->
name|fileno
operator|=
name|softc
operator|->
name|blkno
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|SS_FILEMARKS
operator|&&
name|softc
operator|->
name|fileno
operator|!=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
condition|)
block|{
name|softc
operator|->
name|fileno
operator|+=
operator|(
name|count
operator|-
name|softc
operator|->
name|last_ctl_resid
operator|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|fileno
operator|<
literal|0
condition|)
comment|/* we must of hit BOT */
name|softc
operator|->
name|fileno
operator|=
literal|0
expr_stmt|;
name|softc
operator|->
name|blkno
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|SS_BLOCKS
operator|&&
name|softc
operator|->
name|blkno
operator|!=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
condition|)
block|{
name|softc
operator|->
name|blkno
operator|+=
operator|(
name|count
operator|-
name|softc
operator|->
name|last_ctl_resid
operator|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|softc
operator|->
name|last_ctl_resid
operator|||
name|softc
operator|->
name|blkno
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|softc
operator|->
name|fileno
operator|==
literal|0
condition|)
block|{
name|softc
operator|->
name|blkno
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|softc
operator|->
name|blkno
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sawritefilemarks
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|nmarks
parameter_list|,
name|int
name|setmarks
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|nwm
init|=
literal|0
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Clear residual because we will be using it. 	 */
name|softc
operator|->
name|last_ctl_resid
operator|=
literal|0
expr_stmt|;
name|softc
operator|->
name|dsreg
operator|=
name|MTIO_DSREG_FMK
expr_stmt|;
comment|/* this *must* not be retried */
name|scsi_write_filemarks
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
literal|0
argument_list|,
name|sadone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|FALSE
argument_list|,
name|setmarks
argument_list|,
name|nmarks
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
name|IO_TIMEOUT
argument_list|)
expr_stmt|;
name|softc
operator|->
name|dsreg
operator|=
name|MTIO_DSREG_REST
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|!=
literal|0
condition|)
name|cam_release_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|nmarks
condition|)
block|{
name|struct
name|sa_softc
modifier|*
name|softc
init|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
decl_stmt|;
name|nwm
operator|=
name|nmarks
operator|-
name|softc
operator|->
name|last_ctl_resid
expr_stmt|;
name|softc
operator|->
name|filemarks
operator|+=
name|nwm
expr_stmt|;
block|}
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
comment|/* 	 * Update relative positions (if we're doing that). 	 */
if|if
condition|(
name|error
condition|)
block|{
name|softc
operator|->
name|fileno
operator|=
name|softc
operator|->
name|blkno
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|softc
operator|->
name|fileno
operator|!=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
condition|)
block|{
name|softc
operator|->
name|fileno
operator|+=
name|nwm
expr_stmt|;
name|softc
operator|->
name|blkno
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sardpos
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|hard
parameter_list|,
name|u_int32_t
modifier|*
name|blkptr
parameter_list|)
block|{
name|struct
name|scsi_tape_position_data
name|loc
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|sa_softc
modifier|*
name|softc
init|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * We try and flush any buffered writes here if we were writing 	 * and we're trying to get hardware block position. It eats 	 * up performance substantially, but I'm wary of drive firmware. 	 * 	 * I think that *logical* block position is probably okay- 	 * but hardware block position might have to wait for data 	 * to hit media to be valid. Caveat Emptor. 	 */
if|if
condition|(
name|hard
operator|&&
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_TAPE_WRITTEN
operator|)
condition|)
block|{
name|error
operator|=
name|sawritefilemarks
argument_list|(
name|periph
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|EACCES
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|scsi_read_position
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
literal|1
argument_list|,
name|sadone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|hard
argument_list|,
operator|&
name|loc
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
name|SCSIOP_TIMEOUT
argument_list|)
expr_stmt|;
name|softc
operator|->
name|dsreg
operator|=
name|MTIO_DSREG_RBSY
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
name|softc
operator|->
name|dsreg
operator|=
name|MTIO_DSREG_REST
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|!=
literal|0
condition|)
name|cam_release_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|loc
operator|.
name|flags
operator|&
name|SA_RPOS_UNCERTAIN
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
comment|/* nothing is certain */
block|}
else|else
block|{
operator|*
name|blkptr
operator|=
name|scsi_4btoul
argument_list|(
name|loc
operator|.
name|firstblk
argument_list|)
expr_stmt|;
block|}
block|}
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sasetpos
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|hard
parameter_list|,
name|u_int32_t
modifier|*
name|blkptr
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * We used to try and flush any buffered writes here. 	 * Now we push this onto user applications to either 	 * flush the pending writes themselves (via a zero count 	 * WRITE FILEMARKS command) or they can trust their tape 	 * drive to do this correctly for them.  	 */
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|scsi_set_position
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
literal|1
argument_list|,
name|sadone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|hard
argument_list|,
operator|*
name|blkptr
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
name|SPACE_TIMEOUT
argument_list|)
expr_stmt|;
name|softc
operator|->
name|dsreg
operator|=
name|MTIO_DSREG_POS
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
name|softc
operator|->
name|dsreg
operator|=
name|MTIO_DSREG_REST
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|!=
literal|0
condition|)
name|cam_release_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
comment|/* 	 * Note relative file&& block number position as now unknown. 	 */
name|softc
operator|->
name|fileno
operator|=
name|softc
operator|->
name|blkno
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|saretension
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* It is safe to retry this operation */
name|scsi_load_unload
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
literal|5
argument_list|,
name|sadone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
name|ERASE_TIMEOUT
argument_list|)
expr_stmt|;
name|softc
operator|->
name|dsreg
operator|=
name|MTIO_DSREG_TEN
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
name|softc
operator|->
name|dsreg
operator|=
name|MTIO_DSREG_REST
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|!=
literal|0
condition|)
name|cam_release_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|softc
operator|->
name|fileno
operator|=
name|softc
operator|->
name|blkno
operator|=
operator|(
name|daddr_t
operator|)
literal|0
expr_stmt|;
else|else
name|softc
operator|->
name|fileno
operator|=
name|softc
operator|->
name|blkno
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sareservereleaseunit
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|reserve
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* It is safe to retry this operation */
name|scsi_reserve_release_unit
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
literal|2
argument_list|,
name|sadone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
name|SCSIOP_TIMEOUT
argument_list|,
name|reserve
argument_list|)
expr_stmt|;
name|softc
operator|->
name|dsreg
operator|=
name|MTIO_DSREG_RBSY
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
literal|0
argument_list|,
name|SF_RETRY_UA
operator||
name|SF_NO_PRINT
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
name|softc
operator|->
name|dsreg
operator|=
name|MTIO_DSREG_REST
expr_stmt|;
name|QFRLS
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
comment|/* 	 * If the error was Illegal Request, then the device doesn't support 	 * RESERVE/RELEASE. This is not an error. 	 */
if|if
condition|(
name|error
operator|==
name|EINVAL
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|saloadunload
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|load
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* It is safe to retry this operation */
name|scsi_load_unload
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
literal|5
argument_list|,
name|sadone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|load
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
name|REWIND_TIMEOUT
argument_list|)
expr_stmt|;
name|softc
operator|->
name|dsreg
operator|=
operator|(
name|load
operator|)
condition|?
name|MTIO_DSREG_LD
else|:
name|MTIO_DSREG_UNL
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
name|softc
operator|->
name|dsreg
operator|=
name|MTIO_DSREG_REST
expr_stmt|;
name|QFRLS
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|load
operator|==
literal|0
condition|)
name|softc
operator|->
name|fileno
operator|=
name|softc
operator|->
name|blkno
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|softc
operator|->
name|fileno
operator|=
name|softc
operator|->
name|blkno
operator|=
operator|(
name|daddr_t
operator|)
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|saerase
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|longerase
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|scsi_erase
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
literal|1
argument_list|,
name|sadone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|FALSE
argument_list|,
name|longerase
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
name|ERASE_TIMEOUT
argument_list|)
expr_stmt|;
name|softc
operator|->
name|dsreg
operator|=
name|MTIO_DSREG_ZER
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
name|softc
operator|->
name|dsreg
operator|=
name|MTIO_DSREG_REST
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|!=
literal|0
condition|)
name|cam_release_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _KERNEL */
end_comment

begin_comment
comment|/*  * Read tape block limits command.  */
end_comment

begin_function
name|void
name|scsi_read_block_limits
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|struct
name|scsi_read_block_limits_data
modifier|*
name|rlimit_buf
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_read_block_limits
modifier|*
name|scsi_cmd
decl_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
name|CAM_DIR_IN
argument_list|,
name|tag_action
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
name|rlimit_buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rlimit_buf
argument_list|)
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_read_block_limits
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|READ_BLOCK_LIMITS
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_sa_read_write
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|int
name|readop
parameter_list|,
name|int
name|sli
parameter_list|,
name|int
name|fixed
parameter_list|,
name|u_int32_t
name|length
parameter_list|,
name|u_int8_t
modifier|*
name|data_ptr
parameter_list|,
name|u_int32_t
name|dxfer_len
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_sa_rw
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_sa_rw
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|readop
condition|?
name|SA_READ
else|:
name|SA_WRITE
expr_stmt|;
name|scsi_cmd
operator|->
name|sli_fixed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sli
operator|&&
name|readop
condition|)
name|scsi_cmd
operator|->
name|sli_fixed
operator||=
name|SAR_SLI
expr_stmt|;
if|if
condition|(
name|fixed
condition|)
name|scsi_cmd
operator|->
name|sli_fixed
operator||=
name|SARW_FIXED
expr_stmt|;
name|scsi_ulto3b
argument_list|(
name|length
argument_list|,
name|scsi_cmd
operator|->
name|length
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|control
operator|=
literal|0
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
name|readop
condition|?
name|CAM_DIR_IN
else|:
name|CAM_DIR_OUT
argument_list|,
name|tag_action
argument_list|,
name|data_ptr
argument_list|,
name|dxfer_len
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_load_unload
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|int
name|immediate
parameter_list|,
name|int
name|eot
parameter_list|,
name|int
name|reten
parameter_list|,
name|int
name|load
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_load_unload
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_load_unload
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|LOAD_UNLOAD
expr_stmt|;
if|if
condition|(
name|immediate
condition|)
name|scsi_cmd
operator|->
name|immediate
operator|=
name|SLU_IMMED
expr_stmt|;
if|if
condition|(
name|eot
condition|)
name|scsi_cmd
operator|->
name|eot_reten_load
operator||=
name|SLU_EOT
expr_stmt|;
if|if
condition|(
name|reten
condition|)
name|scsi_cmd
operator|->
name|eot_reten_load
operator||=
name|SLU_RETEN
expr_stmt|;
if|if
condition|(
name|load
condition|)
name|scsi_cmd
operator|->
name|eot_reten_load
operator||=
name|SLU_LOAD
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
name|CAM_DIR_NONE
argument_list|,
name|tag_action
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_rewind
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|int
name|immediate
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_rewind
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_rewind
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|REWIND
expr_stmt|;
if|if
condition|(
name|immediate
condition|)
name|scsi_cmd
operator|->
name|immediate
operator|=
name|SREW_IMMED
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
name|CAM_DIR_NONE
argument_list|,
name|tag_action
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_space
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|scsi_space_code
name|code
parameter_list|,
name|u_int32_t
name|count
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_space
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_space
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|SPACE
expr_stmt|;
name|scsi_cmd
operator|->
name|code
operator|=
name|code
expr_stmt|;
name|scsi_ulto3b
argument_list|(
name|count
argument_list|,
name|scsi_cmd
operator|->
name|count
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|control
operator|=
literal|0
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
name|CAM_DIR_NONE
argument_list|,
name|tag_action
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_write_filemarks
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|int
name|immediate
parameter_list|,
name|int
name|setmark
parameter_list|,
name|u_int32_t
name|num_marks
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_write_filemarks
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_write_filemarks
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|WRITE_FILEMARKS
expr_stmt|;
if|if
condition|(
name|immediate
condition|)
name|scsi_cmd
operator|->
name|byte2
operator||=
name|SWFMRK_IMMED
expr_stmt|;
if|if
condition|(
name|setmark
condition|)
name|scsi_cmd
operator|->
name|byte2
operator||=
name|SWFMRK_WSMK
expr_stmt|;
name|scsi_ulto3b
argument_list|(
name|num_marks
argument_list|,
name|scsi_cmd
operator|->
name|num_marks
argument_list|)
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
name|CAM_DIR_NONE
argument_list|,
name|tag_action
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The reserve and release unit commands differ only by their opcodes.  */
end_comment

begin_function
name|void
name|scsi_reserve_release_unit
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|int
name|third_party
parameter_list|,
name|int
name|third_party_id
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|,
name|int
name|reserve
parameter_list|)
block|{
name|struct
name|scsi_reserve_release_unit
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_reserve_release_unit
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reserve
condition|)
name|scsi_cmd
operator|->
name|opcode
operator|=
name|RESERVE_UNIT
expr_stmt|;
else|else
name|scsi_cmd
operator|->
name|opcode
operator|=
name|RELEASE_UNIT
expr_stmt|;
if|if
condition|(
name|third_party
condition|)
block|{
name|scsi_cmd
operator|->
name|lun_thirdparty
operator||=
name|SRRU_3RD_PARTY
expr_stmt|;
name|scsi_cmd
operator|->
name|lun_thirdparty
operator||=
operator|(
operator|(
name|third_party_id
operator|<<
name|SRRU_3RD_SHAMT
operator|)
operator|&
name|SRRU_3RD_MASK
operator|)
expr_stmt|;
block|}
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
name|CAM_DIR_NONE
argument_list|,
name|tag_action
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_erase
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|int
name|immediate
parameter_list|,
name|int
name|long_erase
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_erase
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_erase
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|ERASE
expr_stmt|;
if|if
condition|(
name|immediate
condition|)
name|scsi_cmd
operator|->
name|lun_imm_long
operator||=
name|SE_IMMED
expr_stmt|;
if|if
condition|(
name|long_erase
condition|)
name|scsi_cmd
operator|->
name|lun_imm_long
operator||=
name|SE_LONG
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
name|CAM_DIR_NONE
argument_list|,
name|tag_action
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read Tape Position command.  */
end_comment

begin_function
name|void
name|scsi_read_position
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|int
name|hardsoft
parameter_list|,
name|struct
name|scsi_tape_position_data
modifier|*
name|sbp
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_tape_read_position
modifier|*
name|scmd
decl_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
name|CAM_DIR_IN
argument_list|,
name|tag_action
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
name|sbp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sbp
argument_list|)
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|scmd
operator|=
operator|(
expr|struct
name|scsi_tape_read_position
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scmd
argument_list|)
argument_list|)
expr_stmt|;
name|scmd
operator|->
name|opcode
operator|=
name|READ_POSITION
expr_stmt|;
name|scmd
operator|->
name|byte1
operator|=
name|hardsoft
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set Tape Position command.  */
end_comment

begin_function
name|void
name|scsi_set_position
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|int
name|hardsoft
parameter_list|,
name|u_int32_t
name|blkno
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_tape_locate
modifier|*
name|scmd
decl_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
name|CAM_DIR_NONE
argument_list|,
name|tag_action
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|scmd
operator|=
operator|(
expr|struct
name|scsi_tape_locate
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scmd
argument_list|)
argument_list|)
expr_stmt|;
name|scmd
operator|->
name|opcode
operator|=
name|LOCATE
expr_stmt|;
if|if
condition|(
name|hardsoft
condition|)
name|scmd
operator|->
name|byte1
operator||=
name|SA_SPOS_BT
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|blkno
argument_list|,
name|scmd
operator|->
name|blkaddr
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

