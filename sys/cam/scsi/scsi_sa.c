begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Implementation of SCSI Sequential Access Peripheral driver for CAM.  *  * Copyright (c) 1999, 2000 Matthew Jacob  * Copyright (c) 2013, 2014, 2015 Spectra Logic Corporation  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mtio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/devicestat.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|_KERNEL
end_ifndef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_sa.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<opt_sa.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|SA_IO_TIMEOUT
end_ifndef

begin_define
define|#
directive|define
name|SA_IO_TIMEOUT
value|32
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SA_SPACE_TIMEOUT
end_ifndef

begin_define
define|#
directive|define
name|SA_SPACE_TIMEOUT
value|1 * 60
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SA_REWIND_TIMEOUT
end_ifndef

begin_define
define|#
directive|define
name|SA_REWIND_TIMEOUT
value|2 * 60
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SA_ERASE_TIMEOUT
end_ifndef

begin_define
define|#
directive|define
name|SA_ERASE_TIMEOUT
value|4 * 60
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SA_REP_DENSITY_TIMEOUT
end_ifndef

begin_define
define|#
directive|define
name|SA_REP_DENSITY_TIMEOUT
value|90
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SCSIOP_TIMEOUT
value|(60 * 1000)
end_define

begin_comment
comment|/* not an option */
end_comment

begin_define
define|#
directive|define
name|IO_TIMEOUT
value|(SA_IO_TIMEOUT * 60 * 1000)
end_define

begin_define
define|#
directive|define
name|REWIND_TIMEOUT
value|(SA_REWIND_TIMEOUT * 60 * 1000)
end_define

begin_define
define|#
directive|define
name|ERASE_TIMEOUT
value|(SA_ERASE_TIMEOUT * 60 * 1000)
end_define

begin_define
define|#
directive|define
name|SPACE_TIMEOUT
value|(SA_SPACE_TIMEOUT * 60 * 1000)
end_define

begin_define
define|#
directive|define
name|REP_DENSITY_TIMEOUT
value|(SA_REP_DENSITY_TIMEOUT * 60 * 1000)
end_define

begin_comment
comment|/*  * Additional options that can be set for config: SA_1FM_AT_EOT  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|UNUSED_PARAMETER
end_ifndef

begin_define
define|#
directive|define
name|UNUSED_PARAMETER
parameter_list|(
name|x
parameter_list|)
value|x = x
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|QFRLS
parameter_list|(
name|ccb
parameter_list|)
define|\
value|if (((ccb)->ccb_h.status& CAM_DEV_QFRZN) != 0)	\ 		cam_release_devq((ccb)->ccb_h.path, 0, 0, 0, FALSE)
end_define

begin_comment
comment|/*  * Driver states  */
end_comment

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_SCSISA
argument_list|,
literal|"SCSI sa"
argument_list|,
literal|"SCSI sequential access buffers"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
enum|enum
block|{
name|SA_STATE_NORMAL
block|,
name|SA_STATE_ABNORMAL
block|}
name|sa_state
typedef|;
end_typedef

begin_define
define|#
directive|define
name|ccb_pflags
value|ppriv_field0
end_define

begin_define
define|#
directive|define
name|ccb_bp
value|ppriv_ptr1
end_define

begin_comment
comment|/* bits in ccb_pflags */
end_comment

begin_define
define|#
directive|define
name|SA_POSITION_UPDATED
value|0x1
end_define

begin_typedef
typedef|typedef
enum|enum
block|{
name|SA_FLAG_OPEN
init|=
literal|0x0001
block|,
name|SA_FLAG_FIXED
init|=
literal|0x0002
block|,
name|SA_FLAG_TAPE_LOCKED
init|=
literal|0x0004
block|,
name|SA_FLAG_TAPE_MOUNTED
init|=
literal|0x0008
block|,
name|SA_FLAG_TAPE_WP
init|=
literal|0x0010
block|,
name|SA_FLAG_TAPE_WRITTEN
init|=
literal|0x0020
block|,
name|SA_FLAG_EOM_PENDING
init|=
literal|0x0040
block|,
name|SA_FLAG_EIO_PENDING
init|=
literal|0x0080
block|,
name|SA_FLAG_EOF_PENDING
init|=
literal|0x0100
block|,
name|SA_FLAG_ERR_PENDING
init|=
operator|(
name|SA_FLAG_EOM_PENDING
operator||
name|SA_FLAG_EIO_PENDING
operator||
name|SA_FLAG_EOF_PENDING
operator|)
block|,
name|SA_FLAG_INVALID
init|=
literal|0x0200
block|,
name|SA_FLAG_COMP_ENABLED
init|=
literal|0x0400
block|,
name|SA_FLAG_COMP_SUPP
init|=
literal|0x0800
block|,
name|SA_FLAG_COMP_UNSUPP
init|=
literal|0x1000
block|,
name|SA_FLAG_TAPE_FROZEN
init|=
literal|0x2000
block|,
name|SA_FLAG_PROTECT_SUPP
init|=
literal|0x4000
block|,
name|SA_FLAG_COMPRESSION
init|=
operator|(
name|SA_FLAG_COMP_SUPP
operator||
name|SA_FLAG_COMP_ENABLED
operator||
name|SA_FLAG_COMP_UNSUPP
operator|)
block|,
name|SA_FLAG_SCTX_INIT
init|=
literal|0x8000
block|}
name|sa_flags
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|SA_MODE_REWIND
init|=
literal|0x00
block|,
name|SA_MODE_NOREWIND
init|=
literal|0x01
block|,
name|SA_MODE_OFFLINE
init|=
literal|0x02
block|}
name|sa_mode
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|SA_PARAM_NONE
init|=
literal|0x000
block|,
name|SA_PARAM_BLOCKSIZE
init|=
literal|0x001
block|,
name|SA_PARAM_DENSITY
init|=
literal|0x002
block|,
name|SA_PARAM_COMPRESSION
init|=
literal|0x004
block|,
name|SA_PARAM_BUFF_MODE
init|=
literal|0x008
block|,
name|SA_PARAM_NUMBLOCKS
init|=
literal|0x010
block|,
name|SA_PARAM_WP
init|=
literal|0x020
block|,
name|SA_PARAM_SPEED
init|=
literal|0x040
block|,
name|SA_PARAM_DENSITY_EXT
init|=
literal|0x080
block|,
name|SA_PARAM_LBP
init|=
literal|0x100
block|,
name|SA_PARAM_ALL
init|=
literal|0x1ff
block|}
name|sa_params
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|SA_QUIRK_NONE
init|=
literal|0x000
block|,
name|SA_QUIRK_NOCOMP
init|=
literal|0x001
block|,
comment|/* Can't deal with compression at all*/
name|SA_QUIRK_FIXED
init|=
literal|0x002
block|,
comment|/* Force fixed mode */
name|SA_QUIRK_VARIABLE
init|=
literal|0x004
block|,
comment|/* Force variable mode */
name|SA_QUIRK_2FM
init|=
literal|0x008
block|,
comment|/* Needs Two File Marks at EOD */
name|SA_QUIRK_1FM
init|=
literal|0x010
block|,
comment|/* No more than 1 File Mark at EOD */
name|SA_QUIRK_NODREAD
init|=
literal|0x020
block|,
comment|/* Don't try and dummy read density */
name|SA_QUIRK_NO_MODESEL
init|=
literal|0x040
block|,
comment|/* Don't do mode select at all */
name|SA_QUIRK_NO_CPAGE
init|=
literal|0x080
block|,
comment|/* Don't use DEVICE COMPRESSION page */
name|SA_QUIRK_NO_LONG_POS
init|=
literal|0x100
comment|/* No long position information */
block|}
name|sa_quirks
typedef|;
end_typedef

begin_define
define|#
directive|define
name|SA_QUIRK_BIT_STRING
define|\
value|"\020"			\ 	"\001NOCOMP"		\ 	"\002FIXED"		\ 	"\003VARIABLE"		\ 	"\0042FM"		\ 	"\0051FM"		\ 	"\006NODREAD"		\ 	"\007NO_MODESEL"	\ 	"\010NO_CPAGE"		\ 	"\011NO_LONG_POS"
end_define

begin_define
define|#
directive|define
name|SAMODE
parameter_list|(
name|z
parameter_list|)
value|(dev2unit(z)& 0x3)
end_define

begin_define
define|#
directive|define
name|SA_IS_CTRL
parameter_list|(
name|z
parameter_list|)
value|(dev2unit(z)& (1<< 4))
end_define

begin_define
define|#
directive|define
name|SA_NOT_CTLDEV
value|0
end_define

begin_define
define|#
directive|define
name|SA_CTLDEV
value|1
end_define

begin_define
define|#
directive|define
name|SA_ATYPE_R
value|0
end_define

begin_define
define|#
directive|define
name|SA_ATYPE_NR
value|1
end_define

begin_define
define|#
directive|define
name|SA_ATYPE_ER
value|2
end_define

begin_define
define|#
directive|define
name|SA_NUM_ATYPES
value|3
end_define

begin_define
define|#
directive|define
name|SAMINOR
parameter_list|(
name|ctl
parameter_list|,
name|access
parameter_list|)
define|\
value|((ctl<< 4) | (access& 0x3))
end_define

begin_struct
struct|struct
name|sa_devs
block|{
name|struct
name|cdev
modifier|*
name|ctl_dev
decl_stmt|;
name|struct
name|cdev
modifier|*
name|r_dev
decl_stmt|;
name|struct
name|cdev
modifier|*
name|nr_dev
decl_stmt|;
name|struct
name|cdev
modifier|*
name|er_dev
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|SASBADDBASE
parameter_list|(
name|sb
parameter_list|,
name|indent
parameter_list|,
name|data
parameter_list|,
name|xfmt
parameter_list|,
name|name
parameter_list|,
name|type
parameter_list|,
name|xsize
parameter_list|,
name|desc
parameter_list|)
define|\
value|sbuf_printf(sb, "%*s<%s type=\"%s\" size=\"%zd\" "		\ 	    "fmt=\"%s\" desc=\"%s\">" #xfmt "</%s>\n", indent, "", 	\ 	    #name, #type, xsize, #xfmt, desc ? desc : "", data, #name);
end_define

begin_define
define|#
directive|define
name|SASBADDINT
parameter_list|(
name|sb
parameter_list|,
name|indent
parameter_list|,
name|data
parameter_list|,
name|fmt
parameter_list|,
name|name
parameter_list|)
define|\
value|SASBADDBASE(sb, indent, data, fmt, name, int, sizeof(data),	\ 		    NULL)
end_define

begin_define
define|#
directive|define
name|SASBADDINTDESC
parameter_list|(
name|sb
parameter_list|,
name|indent
parameter_list|,
name|data
parameter_list|,
name|fmt
parameter_list|,
name|name
parameter_list|,
name|desc
parameter_list|)
define|\
value|SASBADDBASE(sb, indent, data, fmt, name, int, sizeof(data),	\ 		    desc)
end_define

begin_define
define|#
directive|define
name|SASBADDUINT
parameter_list|(
name|sb
parameter_list|,
name|indent
parameter_list|,
name|data
parameter_list|,
name|fmt
parameter_list|,
name|name
parameter_list|)
define|\
value|SASBADDBASE(sb, indent, data, fmt, name, uint, sizeof(data), 	\ 		    NULL)
end_define

begin_define
define|#
directive|define
name|SASBADDUINTDESC
parameter_list|(
name|sb
parameter_list|,
name|indent
parameter_list|,
name|data
parameter_list|,
name|fmt
parameter_list|,
name|name
parameter_list|,
name|desc
parameter_list|)
define|\
value|SASBADDBASE(sb, indent, data, fmt, name, uint, sizeof(data), 	\ 		    desc)
end_define

begin_define
define|#
directive|define
name|SASBADDFIXEDSTR
parameter_list|(
name|sb
parameter_list|,
name|indent
parameter_list|,
name|data
parameter_list|,
name|fmt
parameter_list|,
name|name
parameter_list|)
define|\
value|SASBADDBASE(sb, indent, data, fmt, name, str, sizeof(data),	\ 		    NULL)
end_define

begin_define
define|#
directive|define
name|SASBADDFIXEDSTRDESC
parameter_list|(
name|sb
parameter_list|,
name|indent
parameter_list|,
name|data
parameter_list|,
name|fmt
parameter_list|,
name|name
parameter_list|,
name|desc
parameter_list|)
define|\
value|SASBADDBASE(sb, indent, data, fmt, name, str, sizeof(data),	\ 		    desc)
end_define

begin_define
define|#
directive|define
name|SASBADDVARSTR
parameter_list|(
name|sb
parameter_list|,
name|indent
parameter_list|,
name|data
parameter_list|,
name|fmt
parameter_list|,
name|name
parameter_list|,
name|maxlen
parameter_list|)
define|\
value|SASBADDBASE(sb, indent, data, fmt, name, str, maxlen, NULL)
end_define

begin_define
define|#
directive|define
name|SASBADDVARSTRDESC
parameter_list|(
name|sb
parameter_list|,
name|indent
parameter_list|,
name|data
parameter_list|,
name|fmt
parameter_list|,
name|name
parameter_list|,
name|maxlen
parameter_list|,
name|desc
parameter_list|)
define|\
value|SASBADDBASE(sb, indent, data, fmt, name, str, maxlen, desc)
end_define

begin_define
define|#
directive|define
name|SASBADDNODE
parameter_list|(
name|sb
parameter_list|,
name|indent
parameter_list|,
name|name
parameter_list|)
value|{					\ 	sbuf_printf(sb, "%*s<%s type=\"%s\">\n", indent, "", #name,	\ 	    "node");							\ 	indent += 2;							\ }
end_define

begin_define
define|#
directive|define
name|SASBADDNODENUM
parameter_list|(
name|sb
parameter_list|,
name|indent
parameter_list|,
name|name
parameter_list|,
name|num
parameter_list|)
value|{				\ 	sbuf_printf(sb, "%*s<%s type=\"%s\" num=\"%d\">\n", indent, "",	\ 	    #name, "node", num);					\ 	indent += 2;							\ }
end_define

begin_define
define|#
directive|define
name|SASBENDNODE
parameter_list|(
name|sb
parameter_list|,
name|indent
parameter_list|,
name|name
parameter_list|)
value|{					\ 	indent -= 2;							\ 	sbuf_printf(sb, "%*s</%s>\n", indent, "", #name);		\ }
end_define

begin_define
define|#
directive|define
name|SA_DENSITY_TYPES
value|4
end_define

begin_struct
struct|struct
name|sa_prot_state
block|{
name|int
name|initialized
decl_stmt|;
name|uint32_t
name|prot_method
decl_stmt|;
name|uint32_t
name|pi_length
decl_stmt|;
name|uint32_t
name|lbp_w
decl_stmt|;
name|uint32_t
name|lbp_r
decl_stmt|;
name|uint32_t
name|rbdp
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sa_prot_info
block|{
name|struct
name|sa_prot_state
name|cur_prot_state
decl_stmt|;
name|struct
name|sa_prot_state
name|pending_prot_state
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * A table mapping protection parameters to their types and values.  */
end_comment

begin_struct
struct|struct
name|sa_prot_map
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|mt_param_set_type
name|param_type
decl_stmt|;
name|off_t
name|offset
decl_stmt|;
name|uint32_t
name|min_val
decl_stmt|;
name|uint32_t
name|max_val
decl_stmt|;
name|uint32_t
modifier|*
name|value
decl_stmt|;
block|}
name|sa_prot_table
index|[]
init|=
block|{
block|{
literal|"prot_method"
block|,
name|MT_PARAM_SET_UNSIGNED
block|,
name|__offsetof
argument_list|(
expr|struct
name|sa_prot_state
argument_list|,
name|prot_method
argument_list|)
block|,
comment|/*min_val*/
literal|0
block|,
comment|/*max_val*/
literal|255
block|,
name|NULL
block|}
block|,
block|{
literal|"pi_length"
block|,
name|MT_PARAM_SET_UNSIGNED
block|,
name|__offsetof
argument_list|(
expr|struct
name|sa_prot_state
argument_list|,
name|pi_length
argument_list|)
block|,
comment|/*min_val*/
literal|0
block|,
comment|/*max_val*/
name|SA_CTRL_DP_PI_LENGTH_MASK
block|,
name|NULL
block|}
block|,
block|{
literal|"lbp_w"
block|,
name|MT_PARAM_SET_UNSIGNED
block|,
name|__offsetof
argument_list|(
expr|struct
name|sa_prot_state
argument_list|,
name|lbp_w
argument_list|)
block|,
comment|/*min_val*/
literal|0
block|,
comment|/*max_val*/
literal|1
block|,
name|NULL
block|}
block|,
block|{
literal|"lbp_r"
block|,
name|MT_PARAM_SET_UNSIGNED
block|,
name|__offsetof
argument_list|(
expr|struct
name|sa_prot_state
argument_list|,
name|lbp_r
argument_list|)
block|,
comment|/*min_val*/
literal|0
block|,
comment|/*max_val*/
literal|1
block|,
name|NULL
block|}
block|,
block|{
literal|"rbdp"
block|,
name|MT_PARAM_SET_UNSIGNED
block|,
name|__offsetof
argument_list|(
expr|struct
name|sa_prot_state
argument_list|,
name|rbdp
argument_list|)
block|,
comment|/*min_val*/
literal|0
block|,
comment|/*max_val*/
literal|1
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|SA_NUM_PROT_ENTS
value|nitems(sa_prot_table)
end_define

begin_define
define|#
directive|define
name|SA_PROT_ENABLED
parameter_list|(
name|softc
parameter_list|)
value|((softc->flags& SA_FLAG_PROTECT_SUPP)	\&& (softc->prot_info.cur_prot_state.initialized != 0)		\&& (softc->prot_info.cur_prot_state.prot_method != 0))
end_define

begin_define
define|#
directive|define
name|SA_PROT_LEN
parameter_list|(
name|softc
parameter_list|)
value|softc->prot_info.cur_prot_state.pi_length
end_define

begin_struct
struct|struct
name|sa_softc
block|{
name|sa_state
name|state
decl_stmt|;
name|sa_flags
name|flags
decl_stmt|;
name|sa_quirks
name|quirks
decl_stmt|;
name|u_int
name|si_flags
decl_stmt|;
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|bio_queue_head
name|bio_queue
decl_stmt|;
name|int
name|queue_count
decl_stmt|;
name|struct
name|devstat
modifier|*
name|device_stats
decl_stmt|;
name|struct
name|sa_devs
name|devs
decl_stmt|;
name|int
name|open_count
decl_stmt|;
name|int
name|num_devs_to_destroy
decl_stmt|;
name|int
name|blk_gran
decl_stmt|;
name|int
name|blk_mask
decl_stmt|;
name|int
name|blk_shift
decl_stmt|;
name|u_int32_t
name|max_blk
decl_stmt|;
name|u_int32_t
name|min_blk
decl_stmt|;
name|u_int32_t
name|maxio
decl_stmt|;
name|u_int32_t
name|cpi_maxio
decl_stmt|;
name|int
name|allow_io_split
decl_stmt|;
name|int
name|inject_eom
decl_stmt|;
name|int
name|set_pews_status
decl_stmt|;
name|u_int32_t
name|comp_algorithm
decl_stmt|;
name|u_int32_t
name|saved_comp_algorithm
decl_stmt|;
name|u_int32_t
name|media_blksize
decl_stmt|;
name|u_int32_t
name|last_media_blksize
decl_stmt|;
name|u_int32_t
name|media_numblks
decl_stmt|;
name|u_int8_t
name|media_density
decl_stmt|;
name|u_int8_t
name|speed
decl_stmt|;
name|u_int8_t
name|scsi_rev
decl_stmt|;
name|u_int8_t
name|dsreg
decl_stmt|;
comment|/* mtio mt_dsreg, redux */
name|int
name|buffer_mode
decl_stmt|;
name|int
name|filemarks
decl_stmt|;
name|union
name|ccb
name|saved_ccb
decl_stmt|;
name|int
name|last_resid_was_io
decl_stmt|;
name|uint8_t
name|density_type_bits
index|[
name|SA_DENSITY_TYPES
index|]
decl_stmt|;
name|int
name|density_info_valid
index|[
name|SA_DENSITY_TYPES
index|]
decl_stmt|;
name|uint8_t
name|density_info
index|[
name|SA_DENSITY_TYPES
index|]
index|[
name|SRDS_MAX_LENGTH
index|]
decl_stmt|;
name|struct
name|sa_prot_info
name|prot_info
decl_stmt|;
name|int
name|sili
decl_stmt|;
name|int
name|eot_warn
decl_stmt|;
comment|/* 	 * Current position information.  -1 means that the given value is 	 * unknown.  fileno and blkno are always calculated.  blkno is 	 * relative to the previous file mark.  rep_fileno and rep_blkno 	 * are as reported by the drive, if it supports the long form 	 * report for the READ POSITION command.  rep_blkno is relative to 	 * the beginning of the partition. 	 * 	 * bop means that the drive is at the beginning of the partition. 	 * eop means that the drive is between early warning and end of 	 * partition, inside the current partition. 	 * bpew means that the position is in a PEWZ (Programmable Early 	 * Warning Zone) 	 */
name|daddr_t
name|partition
decl_stmt|;
comment|/* Absolute from BOT */
name|daddr_t
name|fileno
decl_stmt|;
comment|/* Relative to beginning of partition */
name|daddr_t
name|blkno
decl_stmt|;
comment|/* Relative to last file mark */
name|daddr_t
name|rep_blkno
decl_stmt|;
comment|/* Relative to beginning of partition */
name|daddr_t
name|rep_fileno
decl_stmt|;
comment|/* Relative to beginning of partition */
name|int
name|bop
decl_stmt|;
comment|/* Beginning of Partition */
name|int
name|eop
decl_stmt|;
comment|/* End of Partition */
name|int
name|bpew
decl_stmt|;
comment|/* Beyond Programmable Early Warning */
comment|/* 	 * Latched Error Info 	 */
struct|struct
block|{
name|struct
name|scsi_sense_data
name|_last_io_sense
decl_stmt|;
name|u_int64_t
name|_last_io_resid
decl_stmt|;
name|u_int8_t
name|_last_io_cdb
index|[
name|CAM_MAX_CDBLEN
index|]
decl_stmt|;
name|struct
name|scsi_sense_data
name|_last_ctl_sense
decl_stmt|;
name|u_int64_t
name|_last_ctl_resid
decl_stmt|;
name|u_int8_t
name|_last_ctl_cdb
index|[
name|CAM_MAX_CDBLEN
index|]
decl_stmt|;
define|#
directive|define
name|last_io_sense
value|errinfo._last_io_sense
define|#
directive|define
name|last_io_resid
value|errinfo._last_io_resid
define|#
directive|define
name|last_io_cdb
value|errinfo._last_io_cdb
define|#
directive|define
name|last_ctl_sense
value|errinfo._last_ctl_sense
define|#
directive|define
name|last_ctl_resid
value|errinfo._last_ctl_resid
define|#
directive|define
name|last_ctl_cdb
value|errinfo._last_ctl_cdb
block|}
name|errinfo
struct|;
comment|/* 	 * Misc other flags/state 	 */
name|u_int32_t
label|:
literal|29
operator|,
name|open_rdonly
operator|:
literal|1
operator|,
comment|/* open read-only */
name|open_pending_mount
operator|:
literal|1
operator|,
comment|/* open pending mount */
name|ctrl_mode
operator|:
literal|1
expr_stmt|;
comment|/* control device open */
name|struct
name|task
name|sysctl_task
decl_stmt|;
name|struct
name|sysctl_ctx_list
name|sysctl_ctx
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|sysctl_tree
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sa_quirk_entry
block|{
name|struct
name|scsi_inquiry_pattern
name|inq_pat
decl_stmt|;
comment|/* matching pattern */
name|sa_quirks
name|quirks
decl_stmt|;
comment|/* specific quirk type */
name|u_int32_t
name|prefblk
decl_stmt|;
comment|/* preferred blocksize when in fixed mode */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|sa_quirk_entry
name|sa_quirk_table
index|[]
init|=
block|{
block|{
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"OnStream"
block|,
literal|"ADR*"
block|,
literal|"*"
block|}
block|,
name|SA_QUIRK_FIXED
operator||
name|SA_QUIRK_NODREAD
operator||
name|SA_QUIRK_1FM
operator||
name|SA_QUIRK_NO_MODESEL
block|,
literal|32768
block|}
block|,
block|{
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"ARCHIVE"
block|,
literal|"Python 06408*"
block|,
literal|"*"
block|}
block|,
name|SA_QUIRK_NODREAD
block|,
literal|0
block|}
block|,
block|{
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"ARCHIVE"
block|,
literal|"Python 25601*"
block|,
literal|"*"
block|}
block|,
name|SA_QUIRK_NOCOMP
operator||
name|SA_QUIRK_NODREAD
block|,
literal|0
block|}
block|,
block|{
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"ARCHIVE"
block|,
literal|"Python*"
block|,
literal|"*"
block|}
block|,
name|SA_QUIRK_NODREAD
block|,
literal|0
block|}
block|,
block|{
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"ARCHIVE"
block|,
literal|"VIPER 150*"
block|,
literal|"*"
block|}
block|,
name|SA_QUIRK_FIXED
operator||
name|SA_QUIRK_1FM
block|,
literal|512
block|}
block|,
block|{
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"ARCHIVE"
block|,
literal|"VIPER 2525 25462"
block|,
literal|"-011"
block|}
block|,
name|SA_QUIRK_NOCOMP
operator||
name|SA_QUIRK_1FM
operator||
name|SA_QUIRK_NODREAD
block|,
literal|0
block|}
block|,
block|{
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"ARCHIVE"
block|,
literal|"VIPER 2525*"
block|,
literal|"*"
block|}
block|,
name|SA_QUIRK_FIXED
operator||
name|SA_QUIRK_1FM
block|,
literal|1024
block|}
block|,
if|#
directive|if
literal|0
block|{ 		{ T_SEQUENTIAL, SIP_MEDIA_REMOVABLE, "HP", 		  "C15*", "*"}, SA_QUIRK_VARIABLE|SA_QUIRK_NO_CPAGE, 0, 	},
endif|#
directive|endif
block|{
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"HP"
block|,
literal|"C56*"
block|,
literal|"*"
block|}
block|,
name|SA_QUIRK_VARIABLE
operator||
name|SA_QUIRK_2FM
block|,
literal|0
block|}
block|,
block|{
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"HP"
block|,
literal|"T20*"
block|,
literal|"*"
block|}
block|,
name|SA_QUIRK_FIXED
operator||
name|SA_QUIRK_1FM
block|,
literal|512
block|}
block|,
block|{
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"HP"
block|,
literal|"T4000*"
block|,
literal|"*"
block|}
block|,
name|SA_QUIRK_FIXED
operator||
name|SA_QUIRK_1FM
block|,
literal|512
block|}
block|,
block|{
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"HP"
block|,
literal|"HP-88780*"
block|,
literal|"*"
block|}
block|,
name|SA_QUIRK_VARIABLE
operator||
name|SA_QUIRK_2FM
block|,
literal|0
block|}
block|,
block|{
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"KENNEDY"
block|,
literal|"*"
block|,
literal|"*"
block|}
block|,
name|SA_QUIRK_VARIABLE
operator||
name|SA_QUIRK_2FM
block|,
literal|0
block|}
block|,
block|{
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"M4 DATA"
block|,
literal|"123107 SCSI*"
block|,
literal|"*"
block|}
block|,
name|SA_QUIRK_VARIABLE
operator||
name|SA_QUIRK_2FM
block|,
literal|0
block|}
block|,
block|{
comment|/* jreynold@primenet.com */
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"Seagate"
block|,
literal|"STT8000N*"
block|,
literal|"*"
block|}
block|,
name|SA_QUIRK_1FM
block|,
literal|0
block|}
block|,
block|{
comment|/* mike@sentex.net */
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"Seagate"
block|,
literal|"STT20000*"
block|,
literal|"*"
block|}
block|,
name|SA_QUIRK_1FM
block|,
literal|0
block|}
block|,
block|{
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"SEAGATE"
block|,
literal|"DAT    06241-XXX"
block|,
literal|"*"
block|}
block|,
name|SA_QUIRK_VARIABLE
operator||
name|SA_QUIRK_2FM
block|,
literal|0
block|}
block|,
block|{
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"TANDBERG"
block|,
literal|" TDC 3600"
block|,
literal|"U07:"
block|}
block|,
name|SA_QUIRK_NOCOMP
operator||
name|SA_QUIRK_1FM
block|,
literal|512
block|}
block|,
block|{
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"TANDBERG"
block|,
literal|" TDC 3800"
block|,
literal|"*"
block|}
block|,
name|SA_QUIRK_NOCOMP
operator||
name|SA_QUIRK_1FM
block|,
literal|512
block|}
block|,
block|{
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"TANDBERG"
block|,
literal|" TDC 4100"
block|,
literal|"*"
block|}
block|,
name|SA_QUIRK_NOCOMP
operator||
name|SA_QUIRK_1FM
block|,
literal|512
block|}
block|,
block|{
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"TANDBERG"
block|,
literal|" TDC 4200"
block|,
literal|"*"
block|}
block|,
name|SA_QUIRK_NOCOMP
operator||
name|SA_QUIRK_1FM
block|,
literal|512
block|}
block|,
block|{
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"TANDBERG"
block|,
literal|" SLR*"
block|,
literal|"*"
block|}
block|,
name|SA_QUIRK_1FM
block|,
literal|0
block|}
block|,
block|{
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"WANGTEK"
block|,
literal|"5525ES*"
block|,
literal|"*"
block|}
block|,
name|SA_QUIRK_FIXED
operator||
name|SA_QUIRK_1FM
block|,
literal|512
block|}
block|,
block|{
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"WANGTEK"
block|,
literal|"51000*"
block|,
literal|"*"
block|}
block|,
name|SA_QUIRK_FIXED
operator||
name|SA_QUIRK_1FM
block|,
literal|1024
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|saopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|saclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_strategy_t
name|sastrategy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|saioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_init_t
name|sainit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_ctor_t
name|saregister
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_oninv_t
name|saoninvalidate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_dtor_t
name|sacleanup
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_start_t
name|sastart
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|saasync
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|u_int32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sadone
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|start_ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|saerror
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|u_int32_t
name|cam_flags
parameter_list|,
name|u_int32_t
name|sense_flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|samarkswanted
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sacheckeod
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sagetparams
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|sa_params
name|params_to_get
parameter_list|,
name|u_int32_t
modifier|*
name|blocksize
parameter_list|,
name|u_int8_t
modifier|*
name|density
parameter_list|,
name|u_int32_t
modifier|*
name|numblocks
parameter_list|,
name|int
modifier|*
name|buff_mode
parameter_list|,
name|u_int8_t
modifier|*
name|write_protect
parameter_list|,
name|u_int8_t
modifier|*
name|speed
parameter_list|,
name|int
modifier|*
name|comp_supported
parameter_list|,
name|int
modifier|*
name|comp_enabled
parameter_list|,
name|u_int32_t
modifier|*
name|comp_algorithm
parameter_list|,
name|sa_comp_t
modifier|*
name|comp_page
parameter_list|,
name|struct
name|scsi_control_data_prot_subpage
modifier|*
name|prot_page
parameter_list|,
name|int
name|dp_size
parameter_list|,
name|int
name|prot_changeable
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sasetprot
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|sa_prot_state
modifier|*
name|new_prot
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sasetparams
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|sa_params
name|params_to_set
parameter_list|,
name|u_int32_t
name|blocksize
parameter_list|,
name|u_int8_t
name|density
parameter_list|,
name|u_int32_t
name|comp_algorithm
parameter_list|,
name|u_int32_t
name|sense_flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sasetsili
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|mtparamset
modifier|*
name|ps
parameter_list|,
name|int
name|num_params
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|saseteotwarn
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|mtparamset
modifier|*
name|ps
parameter_list|,
name|int
name|num_params
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|safillprot
parameter_list|(
name|struct
name|sa_softc
modifier|*
name|softc
parameter_list|,
name|int
modifier|*
name|indent
parameter_list|,
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sapopulateprots
parameter_list|(
name|struct
name|sa_prot_state
modifier|*
name|cur_state
parameter_list|,
name|struct
name|sa_prot_map
modifier|*
name|new_table
parameter_list|,
name|int
name|table_ents
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|sa_prot_map
modifier|*
name|safindprotent
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|sa_prot_map
modifier|*
name|table
parameter_list|,
name|int
name|table_ents
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sasetprotents
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|mtparamset
modifier|*
name|ps
parameter_list|,
name|int
name|num_params
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|sa_param_ent
modifier|*
name|safindparament
parameter_list|(
name|struct
name|mtparamset
modifier|*
name|ps
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|saparamsetlist
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|mtsetlist
modifier|*
name|list
parameter_list|,
name|int
name|need_copy
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|saextget
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|struct
name|mtextget
modifier|*
name|g
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|saparamget
parameter_list|(
name|struct
name|sa_softc
modifier|*
name|softc
parameter_list|,
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|saprevent
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|action
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sarewind
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|saspace
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|count
parameter_list|,
name|scsi_space_code
name|code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sadevgonecb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sasetupdev
parameter_list|(
name|struct
name|sa_softc
modifier|*
name|softc
parameter_list|,
name|struct
name|cdev
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|samount
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|cdev
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|saretension
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sareservereleaseunit
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|reserve
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|saloadunload
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|load
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|saerase
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|longerase
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sawritefilemarks
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|nmarks
parameter_list|,
name|int
name|setmarks
parameter_list|,
name|int
name|immed
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sagetpos
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sardpos
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
parameter_list|,
name|u_int32_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sasetpos
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
parameter_list|,
name|struct
name|mtlocate
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|safilldenstypesb
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|int
modifier|*
name|indent
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|int
name|buf_len
parameter_list|,
name|int
name|is_density
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|safilldensitysb
parameter_list|(
name|struct
name|sa_softc
modifier|*
name|softc
parameter_list|,
name|int
modifier|*
name|indent
parameter_list|,
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|SA_DEFAULT_IO_SPLIT
end_ifndef

begin_define
define|#
directive|define
name|SA_DEFAULT_IO_SPLIT
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|sa_allow_io_split
init|=
name|SA_DEFAULT_IO_SPLIT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Tunable to allow the user to set a global allow_io_split value.  Note  * that this WILL GO AWAY in FreeBSD 11.0.  Silently splitting the I/O up  * is bad behavior, because it hides the true tape block size from the  * application.  */
end_comment

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_kern_cam
argument_list|,
name|OID_AUTO
argument_list|,
name|sa
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"CAM Sequential Access Tape Driver"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_cam_sa
argument_list|,
name|OID_AUTO
argument_list|,
name|allow_io_split
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|sa_allow_io_split
argument_list|,
literal|0
argument_list|,
literal|"Default I/O split value"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|periph_driver
name|sadriver
init|=
block|{
name|sainit
block|,
literal|"sa"
block|,
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|sadriver
operator|.
name|units
argument_list|)
block|,
comment|/* generation */
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|PERIPHDRIVER_DECLARE
argument_list|(
name|sa
argument_list|,
name|sadriver
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* For 2.2-stable support */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|D_TAPE
end_ifndef

begin_define
define|#
directive|define
name|D_TAPE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|sa_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_open
operator|=
name|saopen
block|,
operator|.
name|d_close
operator|=
name|saclose
block|,
operator|.
name|d_read
operator|=
name|physread
block|,
operator|.
name|d_write
operator|=
name|physwrite
block|,
operator|.
name|d_ioctl
operator|=
name|saioctl
block|,
operator|.
name|d_strategy
operator|=
name|sastrategy
block|,
operator|.
name|d_name
operator|=
literal|"sa"
block|,
operator|.
name|d_flags
operator|=
name|D_TAPE
operator||
name|D_TRACKCLOSE
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|saopen
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|periph
operator|=
operator|(
expr|struct
name|cam_periph
operator|*
operator|)
name|dev
operator|->
name|si_drv1
expr_stmt|;
if|if
condition|(
name|cam_periph_acquire
argument_list|(
name|periph
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_TRACE
operator||
name|CAM_DEBUG_INFO
argument_list|,
operator|(
literal|"saopen(%s): softc=0x%x\n"
operator|,
name|devtoname
argument_list|(
name|dev
argument_list|)
operator|,
name|softc
operator|->
name|flags
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SA_IS_CTRL
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|softc
operator|->
name|ctrl_mode
operator|=
literal|1
expr_stmt|;
name|softc
operator|->
name|open_count
operator|++
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|cam_periph_hold
argument_list|(
name|periph
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|cam_periph_release
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_OPEN
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_INVALID
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Preserve whether this is a read_only open. 		 */
name|softc
operator|->
name|open_rdonly
operator|=
operator|(
name|flags
operator|&
name|O_RDWR
operator|)
operator|==
name|O_RDONLY
expr_stmt|;
comment|/* 		 * The function samount ensures media is loaded and ready. 		 * It also does a device RESERVE if the tape isn't yet mounted. 		 * 		 * If the mount fails and this was a non-blocking open, 		 * make this a 'open_pending_mount' action. 		 */
name|error
operator|=
name|samount
argument_list|(
name|periph
argument_list|,
name|flags
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
operator|(
name|flags
operator|&
name|O_NONBLOCK
operator|)
condition|)
block|{
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_OPEN
expr_stmt|;
name|softc
operator|->
name|open_pending_mount
operator|=
literal|1
expr_stmt|;
name|softc
operator|->
name|open_count
operator|++
expr_stmt|;
name|cam_periph_unhold
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|error
condition|)
block|{
name|cam_periph_unhold
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|cam_periph_release
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|saprevent
argument_list|(
name|periph
argument_list|,
name|PR_PREVENT
argument_list|)
expr_stmt|;
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_OPEN
expr_stmt|;
name|softc
operator|->
name|open_count
operator|++
expr_stmt|;
name|cam_periph_unhold
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|saclose
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|mode
decl_stmt|,
name|error
decl_stmt|,
name|writing
decl_stmt|,
name|tmp
decl_stmt|,
name|i
decl_stmt|;
name|int
name|closedbits
init|=
name|SA_FLAG_OPEN
decl_stmt|;
name|mode
operator|=
name|SAMODE
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|periph
operator|=
operator|(
expr|struct
name|cam_periph
operator|*
operator|)
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_TRACE
operator||
name|CAM_DEBUG_INFO
argument_list|,
operator|(
literal|"saclose(%s): softc=0x%x\n"
operator|,
name|devtoname
argument_list|(
name|dev
argument_list|)
operator|,
name|softc
operator|->
name|flags
operator|)
argument_list|)
expr_stmt|;
name|softc
operator|->
name|open_rdonly
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|SA_IS_CTRL
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|softc
operator|->
name|ctrl_mode
operator|=
literal|0
expr_stmt|;
name|softc
operator|->
name|open_count
operator|--
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|cam_periph_release
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|softc
operator|->
name|open_pending_mount
condition|)
block|{
name|softc
operator|->
name|flags
operator|&=
operator|~
name|SA_FLAG_OPEN
expr_stmt|;
name|softc
operator|->
name|open_pending_mount
operator|=
literal|0
expr_stmt|;
name|softc
operator|->
name|open_count
operator|--
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|cam_periph_release
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|cam_periph_hold
argument_list|(
name|periph
argument_list|,
name|PRIBIO
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Were we writing the tape? 	 */
name|writing
operator|=
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_TAPE_WRITTEN
operator|)
operator|!=
literal|0
expr_stmt|;
comment|/* 	 * See whether or not we need to write filemarks. If this 	 * fails, we probably have to assume we've lost tape 	 * position. 	 */
name|error
operator|=
name|sacheckeod
argument_list|(
name|periph
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"failed to write terminating filemark(s)\n"
argument_list|)
expr_stmt|;
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_TAPE_FROZEN
expr_stmt|;
block|}
comment|/* 	 * Whatever we end up doing, allow users to eject tapes from here on. 	 */
name|saprevent
argument_list|(
name|periph
argument_list|,
name|PR_ALLOW
argument_list|)
expr_stmt|;
comment|/* 	 * Decide how to end... 	 */
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_TAPE_MOUNTED
operator|)
operator|==
literal|0
condition|)
block|{
name|closedbits
operator||=
name|SA_FLAG_TAPE_FROZEN
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|SA_MODE_OFFLINE
case|:
comment|/* 		 * An 'offline' close is an unconditional release of 		 * frozen&& mount conditions, irrespective of whether 		 * these operations succeeded. The reason for this is 		 * to allow at least some kind of programmatic way 		 * around our state getting all fouled up. If somebody 		 * issues an 'offline' command, that will be allowed 		 * to clear state. 		 */
operator|(
name|void
operator|)
name|sarewind
argument_list|(
name|periph
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|saloadunload
argument_list|(
name|periph
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|closedbits
operator||=
name|SA_FLAG_TAPE_MOUNTED
operator||
name|SA_FLAG_TAPE_FROZEN
expr_stmt|;
break|break;
case|case
name|SA_MODE_REWIND
case|:
comment|/* 		 * If the rewind fails, return an error- if anyone cares, 		 * but not overwriting any previous error. 		 * 		 * We don't clear the notion of mounted here, but we do 		 * clear the notion of frozen if we successfully rewound. 		 */
name|tmp
operator|=
name|sarewind
argument_list|(
name|periph
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
block|{
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|error
operator|=
name|tmp
expr_stmt|;
block|}
else|else
block|{
name|closedbits
operator||=
name|SA_FLAG_TAPE_FROZEN
expr_stmt|;
block|}
break|break;
case|case
name|SA_MODE_NOREWIND
case|:
comment|/* 		 * If we're not rewinding/unloading the tape, find out 		 * whether we need to back up over one of two filemarks 		 * we wrote (if we wrote two filemarks) so that appends 		 * from this point on will be sane. 		 */
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|writing
operator|&&
operator|(
name|softc
operator|->
name|quirks
operator|&
name|SA_QUIRK_2FM
operator|)
condition|)
block|{
name|tmp
operator|=
name|saspace
argument_list|(
name|periph
argument_list|,
operator|-
literal|1
argument_list|,
name|SS_FILEMARKS
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"unable to backspace "
literal|"over one of double filemarks at end of "
literal|"tape\n"
argument_list|)
expr_stmt|;
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"it is possible that "
literal|"this device needs a SA_QUIRK_1FM quirk set"
literal|"for it\n"
argument_list|)
expr_stmt|;
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_TAPE_FROZEN
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"unknown mode 0x%x in saclose\n"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
break|break;
block|}
comment|/* 	 * We wish to note here that there are no more filemarks to be written. 	 */
name|softc
operator|->
name|filemarks
operator|=
literal|0
expr_stmt|;
name|softc
operator|->
name|flags
operator|&=
operator|~
name|SA_FLAG_TAPE_WRITTEN
expr_stmt|;
comment|/* 	 * And we are no longer open for business. 	 */
name|softc
operator|->
name|flags
operator|&=
operator|~
name|closedbits
expr_stmt|;
name|softc
operator|->
name|open_count
operator|--
expr_stmt|;
comment|/* 	 * Invalidate any density information that depends on having tape 	 * media in the drive. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SA_DENSITY_TYPES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|softc
operator|->
name|density_type_bits
index|[
name|i
index|]
operator|&
name|SRDS_MEDIA
condition|)
name|softc
operator|->
name|density_info_valid
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Inform users if tape state if frozen.... 	 */
if|if
condition|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_TAPE_FROZEN
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"tape is now frozen- use an OFFLINE, "
literal|"REWIND or MTEOM command to clear this state.\n"
argument_list|)
expr_stmt|;
block|}
comment|/* release the device if it is no longer mounted */
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_TAPE_MOUNTED
operator|)
operator|==
literal|0
condition|)
name|sareservereleaseunit
argument_list|(
name|periph
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|cam_periph_unhold
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|cam_periph_release
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Actually translate the requested transfer into one the physical driver  * can understand.  The transfer is described by a buf and will include  * only one physical transfer.  */
end_comment

begin_function
specifier|static
name|void
name|sastrategy
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|bp
operator|->
name|bio_resid
operator|=
name|bp
operator|->
name|bio_bcount
expr_stmt|;
if|if
condition|(
name|SA_IS_CTRL
argument_list|(
name|bp
operator|->
name|bio_dev
argument_list|)
condition|)
block|{
name|biofinish
argument_list|(
name|bp
argument_list|,
name|NULL
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return;
block|}
name|periph
operator|=
operator|(
expr|struct
name|cam_periph
operator|*
operator|)
name|bp
operator|->
name|bio_dev
operator|->
name|si_drv1
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_INVALID
condition|)
block|{
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|biofinish
argument_list|(
name|bp
argument_list|,
name|NULL
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_TAPE_FROZEN
condition|)
block|{
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|biofinish
argument_list|(
name|bp
argument_list|,
name|NULL
argument_list|,
name|EPERM
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * This should actually never occur as the write(2) 	 * system call traps attempts to write to a read-only 	 * file descriptor. 	 */
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_WRITE
operator|&&
name|softc
operator|->
name|open_rdonly
condition|)
block|{
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|biofinish
argument_list|(
name|bp
argument_list|,
name|NULL
argument_list|,
name|EBADF
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|softc
operator|->
name|open_pending_mount
condition|)
block|{
name|int
name|error
init|=
name|samount
argument_list|(
name|periph
argument_list|,
literal|0
argument_list|,
name|bp
operator|->
name|bio_dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|biofinish
argument_list|(
name|bp
argument_list|,
name|NULL
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
return|return;
block|}
name|saprevent
argument_list|(
name|periph
argument_list|,
name|PR_PREVENT
argument_list|)
expr_stmt|;
name|softc
operator|->
name|open_pending_mount
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * If it's a null transfer, return immediately 	 */
if|if
condition|(
name|bp
operator|->
name|bio_bcount
operator|==
literal|0
condition|)
block|{
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* valid request?  */
if|if
condition|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_FIXED
condition|)
block|{
comment|/* 		 * Fixed block device.  The byte count must 		 * be a multiple of our block size. 		 */
if|if
condition|(
operator|(
operator|(
name|softc
operator|->
name|blk_mask
operator|!=
operator|~
literal|0
operator|)
operator|&&
operator|(
operator|(
name|bp
operator|->
name|bio_bcount
operator|&
name|softc
operator|->
name|blk_mask
operator|)
operator|!=
literal|0
operator|)
operator|)
operator|||
operator|(
operator|(
name|softc
operator|->
name|blk_mask
operator|==
operator|~
literal|0
operator|)
operator|&&
operator|(
operator|(
name|bp
operator|->
name|bio_bcount
operator|%
name|softc
operator|->
name|min_blk
operator|)
operator|!=
literal|0
operator|)
operator|)
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"Invalid request.  Fixed block "
literal|"device requests must be a multiple of %d bytes\n"
argument_list|,
name|softc
operator|->
name|min_blk
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|biofinish
argument_list|(
name|bp
argument_list|,
name|NULL
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|bp
operator|->
name|bio_bcount
operator|>
name|softc
operator|->
name|max_blk
operator|)
operator|||
operator|(
name|bp
operator|->
name|bio_bcount
operator|<
name|softc
operator|->
name|min_blk
operator|)
operator|||
operator|(
name|bp
operator|->
name|bio_bcount
operator|&
name|softc
operator|->
name|blk_mask
operator|)
operator|!=
literal|0
condition|)
block|{
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Invalid request.  Variable block "
literal|"device requests must be "
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|blk_mask
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"a multiple of %d "
argument_list|,
operator|(
literal|0x1
operator|<<
name|softc
operator|->
name|blk_gran
operator|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"between %d and %d bytes\n"
argument_list|,
name|softc
operator|->
name|min_blk
argument_list|,
name|softc
operator|->
name|max_blk
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|biofinish
argument_list|(
name|bp
argument_list|,
name|NULL
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Place it at the end of the queue. 	 */
name|bioq_insert_tail
argument_list|(
operator|&
name|softc
operator|->
name|bio_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|softc
operator|->
name|queue_count
operator|++
expr_stmt|;
if|#
directive|if
literal|0
block|CAM_DEBUG(periph->path, CAM_DEBUG_INFO, 	    ("sastrategy: queuing a %ld %s byte %s\n", bp->bio_bcount,  	    (softc->flags& SA_FLAG_FIXED)?  "fixed" : "variable", 	    (bp->bio_cmd == BIO_READ)? "read" : "write"));
endif|#
directive|endif
if|if
condition|(
name|softc
operator|->
name|queue_count
operator|>
literal|1
condition|)
block|{
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_INFO
argument_list|,
operator|(
literal|"sastrategy: queue count now %d\n"
operator|,
name|softc
operator|->
name|queue_count
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Schedule ourselves for performing the work. 	 */
name|xpt_schedule
argument_list|(
name|periph
argument_list|,
name|CAM_PRIORITY_NORMAL
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|sasetsili
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|mtparamset
modifier|*
name|ps
parameter_list|,
name|int
name|num_params
parameter_list|)
block|{
name|uint32_t
name|sili_blocksize
decl_stmt|;
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|ps
operator|->
name|value_type
operator|!=
name|MT_PARAM_SET_SIGNED
condition|)
block|{
name|snprintf
argument_list|(
name|ps
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|ps
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"sili is a signed parameter"
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
operator|(
name|ps
operator|->
name|value
operator|.
name|value_signed
operator|<
literal|0
operator|)
operator|||
operator|(
name|ps
operator|->
name|value
operator|.
name|value_signed
operator|>
literal|1
operator|)
condition|)
block|{
name|snprintf
argument_list|(
name|ps
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|ps
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"invalid sili value %jd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|ps
operator|->
name|value
operator|.
name|value_signed
argument_list|)
expr_stmt|;
goto|goto
name|bailout_error
goto|;
block|}
comment|/* 	 * We only set the SILI flag in variable block 	 * mode.  You'll get a check condition in fixed 	 * block mode if things don't line up in any case. 	 */
if|if
condition|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_FIXED
condition|)
block|{
name|snprintf
argument_list|(
name|ps
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|ps
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"can't set sili bit in fixed block mode"
argument_list|)
expr_stmt|;
goto|goto
name|bailout_error
goto|;
block|}
if|if
condition|(
name|softc
operator|->
name|sili
operator|==
name|ps
operator|->
name|value
operator|.
name|value_signed
condition|)
goto|goto
name|bailout
goto|;
if|if
condition|(
name|ps
operator|->
name|value
operator|.
name|value_signed
operator|==
literal|1
condition|)
name|sili_blocksize
operator|=
literal|4
expr_stmt|;
else|else
name|sili_blocksize
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|sasetparams
argument_list|(
name|periph
argument_list|,
name|SA_PARAM_BLOCKSIZE
argument_list|,
name|sili_blocksize
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SF_QUIET_IR
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|ps
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|ps
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"sasetparams() returned error %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|bailout_error
goto|;
block|}
name|softc
operator|->
name|sili
operator|=
name|ps
operator|->
name|value
operator|.
name|value_signed
expr_stmt|;
name|bailout
label|:
name|ps
operator|->
name|status
operator|=
name|MT_PARAM_STATUS_OK
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
name|bailout_error
label|:
name|ps
operator|->
name|status
operator|=
name|MT_PARAM_STATUS_ERROR
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|saseteotwarn
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|mtparamset
modifier|*
name|ps
parameter_list|,
name|int
name|num_params
parameter_list|)
block|{
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|ps
operator|->
name|value_type
operator|!=
name|MT_PARAM_SET_SIGNED
condition|)
block|{
name|snprintf
argument_list|(
name|ps
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|ps
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"eot_warn is a signed parameter"
argument_list|)
expr_stmt|;
name|ps
operator|->
name|status
operator|=
name|MT_PARAM_STATUS_ERROR
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
operator|(
name|ps
operator|->
name|value
operator|.
name|value_signed
operator|<
literal|0
operator|)
operator|||
operator|(
name|ps
operator|->
name|value
operator|.
name|value_signed
operator|>
literal|1
operator|)
condition|)
block|{
name|snprintf
argument_list|(
name|ps
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|ps
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"invalid eot_warn value %jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|ps
operator|->
name|value
operator|.
name|value_signed
argument_list|)
expr_stmt|;
name|ps
operator|->
name|status
operator|=
name|MT_PARAM_STATUS_ERROR
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|softc
operator|->
name|eot_warn
operator|=
name|ps
operator|->
name|value
operator|.
name|value_signed
expr_stmt|;
name|ps
operator|->
name|status
operator|=
name|MT_PARAM_STATUS_OK
expr_stmt|;
name|bailout
label|:
if|if
condition|(
name|ps
operator|->
name|status
operator|!=
name|MT_PARAM_STATUS_OK
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|safillprot
parameter_list|(
name|struct
name|sa_softc
modifier|*
name|softc
parameter_list|,
name|int
modifier|*
name|indent
parameter_list|,
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|)
block|{
name|int
name|tmpint
decl_stmt|;
name|SASBADDNODE
argument_list|(
name|sb
argument_list|,
operator|*
name|indent
argument_list|,
name|protection
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_PROTECT_SUPP
condition|)
name|tmpint
operator|=
literal|1
expr_stmt|;
else|else
name|tmpint
operator|=
literal|0
expr_stmt|;
name|SASBADDINTDESC
argument_list|(
name|sb
argument_list|,
operator|*
name|indent
argument_list|,
name|tmpint
argument_list|,
operator|%
name|d
argument_list|,
name|protection_supported
argument_list|,
literal|"Set to 1 if protection information is supported"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmpint
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|softc
operator|->
name|prot_info
operator|.
name|cur_prot_state
operator|.
name|initialized
operator|!=
literal|0
operator|)
condition|)
block|{
name|struct
name|sa_prot_state
modifier|*
name|prot
decl_stmt|;
name|prot
operator|=
operator|&
name|softc
operator|->
name|prot_info
operator|.
name|cur_prot_state
expr_stmt|;
name|SASBADDUINTDESC
argument_list|(
name|sb
argument_list|,
operator|*
name|indent
argument_list|,
name|prot
operator|->
name|prot_method
argument_list|,
operator|%
name|u
argument_list|,
name|prot_method
argument_list|,
literal|"Current Protection Method"
argument_list|)
expr_stmt|;
name|SASBADDUINTDESC
argument_list|(
name|sb
argument_list|,
operator|*
name|indent
argument_list|,
name|prot
operator|->
name|pi_length
argument_list|,
operator|%
name|u
argument_list|,
name|pi_length
argument_list|,
literal|"Length of Protection Information"
argument_list|)
expr_stmt|;
name|SASBADDUINTDESC
argument_list|(
name|sb
argument_list|,
operator|*
name|indent
argument_list|,
name|prot
operator|->
name|lbp_w
argument_list|,
operator|%
name|u
argument_list|,
name|lbp_w
argument_list|,
literal|"Check Protection on Writes"
argument_list|)
expr_stmt|;
name|SASBADDUINTDESC
argument_list|(
name|sb
argument_list|,
operator|*
name|indent
argument_list|,
name|prot
operator|->
name|lbp_r
argument_list|,
operator|%
name|u
argument_list|,
name|lbp_r
argument_list|,
literal|"Check and Include Protection on Reads"
argument_list|)
expr_stmt|;
name|SASBADDUINTDESC
argument_list|(
name|sb
argument_list|,
operator|*
name|indent
argument_list|,
name|prot
operator|->
name|rbdp
argument_list|,
operator|%
name|u
argument_list|,
name|rbdp
argument_list|,
literal|"Transfer Protection Information for RECOVER "
literal|"BUFFERED DATA command"
argument_list|)
expr_stmt|;
block|}
name|SASBENDNODE
argument_list|(
name|sb
argument_list|,
operator|*
name|indent
argument_list|,
name|protection
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sapopulateprots
parameter_list|(
name|struct
name|sa_prot_state
modifier|*
name|cur_state
parameter_list|,
name|struct
name|sa_prot_map
modifier|*
name|new_table
parameter_list|,
name|int
name|table_ents
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|bcopy
argument_list|(
name|sa_prot_table
argument_list|,
name|new_table
argument_list|,
name|min
argument_list|(
name|table_ents
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|new_table
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|sa_prot_table
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|table_ents
operator|=
name|min
argument_list|(
name|table_ents
argument_list|,
name|SA_NUM_PROT_ENTS
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|table_ents
condition|;
name|i
operator|++
control|)
name|new_table
index|[
name|i
index|]
operator|.
name|value
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|cur_state
operator|+
name|new_table
index|[
name|i
index|]
operator|.
name|offset
operator|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|struct
name|sa_prot_map
modifier|*
name|safindprotent
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|sa_prot_map
modifier|*
name|table
parameter_list|,
name|int
name|table_ents
parameter_list|)
block|{
name|char
modifier|*
name|prot_name
init|=
literal|"protection."
decl_stmt|;
name|int
name|i
decl_stmt|,
name|prot_len
decl_stmt|;
name|prot_len
operator|=
name|strlen
argument_list|(
name|prot_name
argument_list|)
expr_stmt|;
comment|/* 	 * This shouldn't happen, but we check just in case. 	 */
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|prot_name
argument_list|,
name|prot_len
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|bailout
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|table_ents
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|name
index|[
name|prot_len
index|]
argument_list|,
name|table
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
return|return
operator|(
operator|&
name|table
index|[
name|i
index|]
operator|)
return|;
block|}
name|bailout
label|:
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sasetprotents
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|mtparamset
modifier|*
name|ps
parameter_list|,
name|int
name|num_params
parameter_list|)
block|{
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|sa_prot_map
name|prot_ents
index|[
name|SA_NUM_PROT_ENTS
index|]
decl_stmt|;
name|struct
name|sa_prot_state
name|new_state
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|i
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Make sure that this tape drive supports protection information. 	 * Otherwise we can't set anything. 	 */
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_PROTECT_SUPP
operator|)
operator|==
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|ps
index|[
literal|0
index|]
operator|.
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|ps
index|[
literal|0
index|]
operator|.
name|error_str
argument_list|)
argument_list|,
literal|"Protection information is not supported for this device"
argument_list|)
expr_stmt|;
name|ps
index|[
literal|0
index|]
operator|.
name|status
operator|=
name|MT_PARAM_STATUS_ERROR
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
comment|/* 	 * We can't operate with physio(9) splitting enabled, because there 	 * is no way to insure (especially in variable block mode) that 	 * what the user writes (with a checksum block at the end) will  	 * make it into the sa(4) driver intact. 	 */
if|if
condition|(
operator|(
name|softc
operator|->
name|si_flags
operator|&
name|SI_NOSPLIT
operator|)
operator|==
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|ps
index|[
literal|0
index|]
operator|.
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|ps
index|[
literal|0
index|]
operator|.
name|error_str
argument_list|)
argument_list|,
literal|"Protection information cannot be enabled with I/O "
literal|"splitting"
argument_list|)
expr_stmt|;
name|ps
index|[
literal|0
index|]
operator|.
name|status
operator|=
name|MT_PARAM_STATUS_ERROR
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
comment|/* 	 * Take the current cached protection state and use that as the 	 * basis for our new entries. 	 */
name|bcopy
argument_list|(
operator|&
name|softc
operator|->
name|prot_info
operator|.
name|cur_prot_state
argument_list|,
operator|&
name|new_state
argument_list|,
sizeof|sizeof
argument_list|(
name|new_state
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Populate the table mapping property names to pointers into the 	 * state structure. 	 */
name|sapopulateprots
argument_list|(
operator|&
name|new_state
argument_list|,
name|prot_ents
argument_list|,
name|SA_NUM_PROT_ENTS
argument_list|)
expr_stmt|;
comment|/* 	 * For each parameter the user passed in, make sure the name, type 	 * and value are valid. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_params
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|sa_prot_map
modifier|*
name|ent
decl_stmt|;
name|ent
operator|=
name|safindprotent
argument_list|(
name|ps
index|[
name|i
index|]
operator|.
name|value_name
argument_list|,
name|prot_ents
argument_list|,
name|SA_NUM_PROT_ENTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|==
name|NULL
condition|)
block|{
name|ps
index|[
name|i
index|]
operator|.
name|status
operator|=
name|MT_PARAM_STATUS_ERROR
expr_stmt|;
name|snprintf
argument_list|(
name|ps
index|[
name|i
index|]
operator|.
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|ps
index|[
name|i
index|]
operator|.
name|error_str
argument_list|)
argument_list|,
literal|"Invalid protection entry name %s"
argument_list|,
name|ps
index|[
name|i
index|]
operator|.
name|value_name
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
name|ent
operator|->
name|param_type
operator|!=
name|ps
index|[
name|i
index|]
operator|.
name|value_type
condition|)
block|{
name|ps
index|[
name|i
index|]
operator|.
name|status
operator|=
name|MT_PARAM_STATUS_ERROR
expr_stmt|;
name|snprintf
argument_list|(
name|ps
index|[
name|i
index|]
operator|.
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|ps
index|[
name|i
index|]
operator|.
name|error_str
argument_list|)
argument_list|,
literal|"Supplied type %d does not match actual type %d"
argument_list|,
name|ps
index|[
name|i
index|]
operator|.
name|value_type
argument_list|,
name|ent
operator|->
name|param_type
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
operator|(
name|ps
index|[
name|i
index|]
operator|.
name|value
operator|.
name|value_unsigned
operator|<
name|ent
operator|->
name|min_val
operator|)
operator|||
operator|(
name|ps
index|[
name|i
index|]
operator|.
name|value
operator|.
name|value_unsigned
operator|>
name|ent
operator|->
name|max_val
operator|)
condition|)
block|{
name|ps
index|[
name|i
index|]
operator|.
name|status
operator|=
name|MT_PARAM_STATUS_ERROR
expr_stmt|;
name|snprintf
argument_list|(
name|ps
index|[
name|i
index|]
operator|.
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|ps
index|[
name|i
index|]
operator|.
name|error_str
argument_list|)
argument_list|,
literal|"Value %ju is outside valid range %u - %u"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ps
index|[
name|i
index|]
operator|.
name|value
operator|.
name|value_unsigned
argument_list|,
name|ent
operator|->
name|min_val
argument_list|,
name|ent
operator|->
name|max_val
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
operator|*
operator|(
name|ent
operator|->
name|value
operator|)
operator|=
name|ps
index|[
name|i
index|]
operator|.
name|value
operator|.
name|value_unsigned
expr_stmt|;
block|}
comment|/* 	 * Actually send the protection settings to the drive. 	 */
name|error
operator|=
name|sasetprot
argument_list|(
name|periph
argument_list|,
operator|&
name|new_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_params
condition|;
name|i
operator|++
control|)
block|{
name|ps
index|[
name|i
index|]
operator|.
name|status
operator|=
name|MT_PARAM_STATUS_ERROR
expr_stmt|;
name|snprintf
argument_list|(
name|ps
index|[
name|i
index|]
operator|.
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|ps
index|[
name|i
index|]
operator|.
name|error_str
argument_list|)
argument_list|,
literal|"Unable to set parameter, see dmesg(8)"
argument_list|)
expr_stmt|;
block|}
goto|goto
name|bailout
goto|;
block|}
comment|/* 	 * Let the user know that his settings were stored successfully. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_params
condition|;
name|i
operator|++
control|)
name|ps
index|[
name|i
index|]
operator|.
name|status
operator|=
name|MT_PARAM_STATUS_OK
expr_stmt|;
name|bailout
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Entry handlers generally only handle a single entry.  Node handlers will  * handle a contiguous range of parameters to set in a single call.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|SA_PARAM_TYPE_ENTRY
block|,
name|SA_PARAM_TYPE_NODE
block|}
name|sa_param_type
typedef|;
end_typedef

begin_struct
struct|struct
name|sa_param_ent
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|sa_param_type
name|param_type
decl_stmt|;
name|int
function_decl|(
modifier|*
name|set_func
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|mtparamset
modifier|*
name|ps
parameter_list|,
name|int
name|num_params
parameter_list|)
function_decl|;
block|}
name|sa_param_table
index|[]
init|=
block|{
block|{
literal|"sili"
block|,
name|SA_PARAM_TYPE_ENTRY
block|,
name|sasetsili
block|}
block|,
block|{
literal|"eot_warn"
block|,
name|SA_PARAM_TYPE_ENTRY
block|,
name|saseteotwarn
block|}
block|,
block|{
literal|"protection."
block|,
name|SA_PARAM_TYPE_NODE
block|,
name|sasetprotents
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|struct
name|sa_param_ent
modifier|*
name|safindparament
parameter_list|(
name|struct
name|mtparamset
modifier|*
name|ps
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|sa_param_table
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * For entries, we compare all of the characters.  For 		 * nodes, we only compare the first N characters.  The node 		 * handler will decode the rest. 		 */
if|if
condition|(
name|sa_param_table
index|[
name|i
index|]
operator|.
name|param_type
operator|==
name|SA_PARAM_TYPE_ENTRY
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|ps
operator|->
name|value_name
argument_list|,
name|sa_param_table
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
block|}
else|else
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|ps
operator|->
name|value_name
argument_list|,
name|sa_param_table
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|strlen
argument_list|(
name|sa_param_table
index|[
name|i
index|]
operator|.
name|name
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
block|}
return|return
operator|(
operator|&
name|sa_param_table
index|[
name|i
index|]
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Go through a list of parameters, coalescing contiguous parameters with  * the same parent node into a single call to a set_func.  */
end_comment

begin_function
specifier|static
name|int
name|saparamsetlist
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|mtsetlist
modifier|*
name|list
parameter_list|,
name|int
name|need_copy
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|contig_ents
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|mtparamset
modifier|*
name|params
decl_stmt|,
modifier|*
name|first
decl_stmt|;
name|struct
name|sa_param_ent
modifier|*
name|first_ent
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|params
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|list
operator|->
name|num_params
operator|==
literal|0
condition|)
comment|/* Nothing to do */
goto|goto
name|bailout
goto|;
comment|/* 	 * Verify that the user has the correct structure size. 	 */
if|if
condition|(
operator|(
name|list
operator|->
name|num_params
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mtparamset
argument_list|)
operator|)
operator|!=
name|list
operator|->
name|param_len
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"%s: length of params %d != "
literal|"sizeof(struct mtparamset) %zd * num_params %d\n"
argument_list|,
name|__func__
argument_list|,
name|list
operator|->
name|param_len
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mtparamset
argument_list|)
argument_list|,
name|list
operator|->
name|num_params
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
name|need_copy
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * XXX KDM will dropping the lock cause an issue here? 		 */
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|params
operator|=
name|malloc
argument_list|(
name|list
operator|->
name|param_len
argument_list|,
name|M_SCSISA
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|list
operator|->
name|params
argument_list|,
name|params
argument_list|,
name|list
operator|->
name|param_len
argument_list|)
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|bailout
goto|;
block|}
else|else
block|{
name|params
operator|=
name|list
operator|->
name|params
expr_stmt|;
block|}
name|contig_ents
operator|=
literal|0
expr_stmt|;
name|first
operator|=
name|NULL
expr_stmt|;
name|first_ent
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|list
operator|->
name|num_params
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|sa_param_ent
modifier|*
name|ent
decl_stmt|;
name|ent
operator|=
name|safindparament
argument_list|(
operator|&
name|params
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|params
index|[
name|i
index|]
operator|.
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|params
index|[
name|i
index|]
operator|.
name|error_str
argument_list|)
argument_list|,
literal|"%s: cannot find parameter %s"
argument_list|,
name|__func__
argument_list|,
name|params
index|[
name|i
index|]
operator|.
name|value_name
argument_list|)
expr_stmt|;
name|params
index|[
name|i
index|]
operator|.
name|status
operator|=
name|MT_PARAM_STATUS_ERROR
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|first
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|first_ent
operator|==
name|ent
condition|)
block|{
comment|/* 				 * We're still in a contiguous list of 				 * parameters that can be handled by one 				 * node handler. 				 */
name|contig_ents
operator|++
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|error
operator|=
name|first_ent
operator|->
name|set_func
argument_list|(
name|periph
argument_list|,
name|first
argument_list|,
name|contig_ents
argument_list|)
expr_stmt|;
name|first
operator|=
name|NULL
expr_stmt|;
name|first_ent
operator|=
name|NULL
expr_stmt|;
name|contig_ents
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|ent
operator|->
name|param_type
operator|==
name|SA_PARAM_TYPE_NODE
condition|)
block|{
name|first
operator|=
operator|&
name|params
index|[
name|i
index|]
expr_stmt|;
name|first_ent
operator|=
name|ent
expr_stmt|;
name|contig_ents
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|ent
operator|->
name|set_func
argument_list|(
name|periph
argument_list|,
operator|&
name|params
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|first
operator|!=
name|NULL
condition|)
name|first_ent
operator|->
name|set_func
argument_list|(
name|periph
argument_list|,
name|first
argument_list|,
name|contig_ents
argument_list|)
expr_stmt|;
name|bailout
label|:
if|if
condition|(
name|need_copy
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|!=
name|EFAULT
condition|)
block|{
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|copyout
argument_list|(
name|params
argument_list|,
name|list
operator|->
name|params
argument_list|,
name|list
operator|->
name|param_len
argument_list|)
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|params
argument_list|,
name|M_SCSISA
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sagetparams_common
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|u_int8_t
name|write_protect
decl_stmt|;
name|int
name|comp_enabled
decl_stmt|,
name|comp_supported
decl_stmt|,
name|error
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|open_pending_mount
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* The control device may issue getparams() if there are no opens. */
if|if
condition|(
name|SA_IS_CTRL
argument_list|(
name|dev
argument_list|)
operator|&&
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_OPEN
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|error
operator|=
name|sagetparams
argument_list|(
name|periph
argument_list|,
name|SA_PARAM_ALL
argument_list|,
operator|&
name|softc
operator|->
name|media_blksize
argument_list|,
operator|&
name|softc
operator|->
name|media_density
argument_list|,
operator|&
name|softc
operator|->
name|media_numblks
argument_list|,
operator|&
name|softc
operator|->
name|buffer_mode
argument_list|,
operator|&
name|write_protect
argument_list|,
operator|&
name|softc
operator|->
name|speed
argument_list|,
operator|&
name|comp_supported
argument_list|,
operator|&
name|comp_enabled
argument_list|,
operator|&
name|softc
operator|->
name|comp_algorithm
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|write_protect
condition|)
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_TAPE_WP
expr_stmt|;
else|else
name|softc
operator|->
name|flags
operator|&=
operator|~
name|SA_FLAG_TAPE_WP
expr_stmt|;
name|softc
operator|->
name|flags
operator|&=
operator|~
name|SA_FLAG_COMPRESSION
expr_stmt|;
if|if
condition|(
name|comp_supported
condition|)
block|{
if|if
condition|(
name|softc
operator|->
name|saved_comp_algorithm
operator|==
literal|0
condition|)
name|softc
operator|->
name|saved_comp_algorithm
operator|=
name|softc
operator|->
name|comp_algorithm
expr_stmt|;
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_COMP_SUPP
expr_stmt|;
if|if
condition|(
name|comp_enabled
condition|)
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_COMP_ENABLED
expr_stmt|;
block|}
else|else
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_COMP_UNSUPP
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|PENDING_MOUNT_CHECK
parameter_list|(
name|softc
parameter_list|,
name|periph
parameter_list|,
name|dev
parameter_list|)
define|\
value|if (softc->open_pending_mount) {		\ 		error = samount(periph, 0, dev);	\ 		if (error) {				\ 			break;				\ 		}					\ 		saprevent(periph, PR_PREVENT);		\ 		softc->open_pending_mount = 0;		\ 	}
end_define

begin_function
specifier|static
name|int
name|saioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|scsi_space_code
name|spaceop
decl_stmt|;
name|int
name|didlockperiph
init|=
literal|0
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|mode
operator|=
name|SAMODE
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* shut up gcc */
name|spaceop
operator|=
literal|0
expr_stmt|;
comment|/* shut up gcc */
name|periph
operator|=
operator|(
expr|struct
name|cam_periph
operator|*
operator|)
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
comment|/* 	 * Check for control mode accesses. We allow MTIOCGET and 	 * MTIOCERRSTAT (but need to be the only one open in order 	 * to clear latched status), and MTSETBSIZE, MTSETDNSTY 	 * and MTCOMP (but need to be the only one accessing this 	 * device to run those). 	 */
if|if
condition|(
name|SA_IS_CTRL
argument_list|(
name|dev
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MTIOCGETEOTMODEL
case|:
case|case
name|MTIOCGET
case|:
case|case
name|MTIOCEXTGET
case|:
case|case
name|MTIOCPARAMGET
case|:
case|case
name|MTIOCRBLIM
case|:
break|break;
case|case
name|MTIOCERRSTAT
case|:
comment|/* 			 * If the periph isn't already locked, lock it 			 * so our MTIOCERRSTAT can reset latched error stats. 			 * 			 * If the periph is already locked, skip it because 			 * we're just getting status and it'll be up to the 			 * other thread that has this device open to do 			 * an MTIOCERRSTAT that would clear latched status. 			 */
if|if
condition|(
operator|(
name|periph
operator|->
name|flags
operator|&
name|CAM_PERIPH_LOCKED
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|cam_periph_hold
argument_list|(
name|periph
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|didlockperiph
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|MTIOCTOP
case|:
block|{
name|struct
name|mtop
modifier|*
name|mt
init|=
operator|(
expr|struct
name|mtop
operator|*
operator|)
name|arg
decl_stmt|;
comment|/* 			 * Check to make sure it's an OP we can perform 			 * with no media inserted. 			 */
switch|switch
condition|(
name|mt
operator|->
name|mt_op
condition|)
block|{
case|case
name|MTSETBSIZ
case|:
case|case
name|MTSETDNSTY
case|:
case|case
name|MTCOMP
case|:
name|mt
operator|=
name|NULL
expr_stmt|;
comment|/* FALLTHROUGH */
default|default:
break|break;
block|}
if|if
condition|(
name|mt
operator|!=
name|NULL
condition|)
block|{
break|break;
block|}
comment|/* FALLTHROUGH */
block|}
case|case
name|MTIOCSETEOTMODEL
case|:
comment|/* 			 * We need to acquire the peripheral here rather 			 * than at open time because we are sharing writable 			 * access to data structures. 			 */
name|error
operator|=
name|cam_periph_hold
argument_list|(
name|periph
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|didlockperiph
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
comment|/* 	 * Find the device that the user is talking about 	 */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MTIOCGET
case|:
block|{
name|struct
name|mtget
modifier|*
name|g
init|=
operator|(
expr|struct
name|mtget
operator|*
operator|)
name|arg
decl_stmt|;
name|error
operator|=
name|sagetparams_common
argument_list|(
name|dev
argument_list|,
name|periph
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|bzero
argument_list|(
name|g
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mtget
argument_list|)
argument_list|)
expr_stmt|;
name|g
operator|->
name|mt_type
operator|=
name|MT_ISAR
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_COMP_UNSUPP
condition|)
block|{
name|g
operator|->
name|mt_comp
operator|=
name|MT_COMP_UNSUPP
expr_stmt|;
name|g
operator|->
name|mt_comp0
operator|=
name|MT_COMP_UNSUPP
expr_stmt|;
name|g
operator|->
name|mt_comp1
operator|=
name|MT_COMP_UNSUPP
expr_stmt|;
name|g
operator|->
name|mt_comp2
operator|=
name|MT_COMP_UNSUPP
expr_stmt|;
name|g
operator|->
name|mt_comp3
operator|=
name|MT_COMP_UNSUPP
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_COMP_ENABLED
operator|)
operator|==
literal|0
condition|)
block|{
name|g
operator|->
name|mt_comp
operator|=
name|MT_COMP_DISABLED
expr_stmt|;
block|}
else|else
block|{
name|g
operator|->
name|mt_comp
operator|=
name|softc
operator|->
name|comp_algorithm
expr_stmt|;
block|}
name|g
operator|->
name|mt_comp0
operator|=
name|softc
operator|->
name|comp_algorithm
expr_stmt|;
name|g
operator|->
name|mt_comp1
operator|=
name|softc
operator|->
name|comp_algorithm
expr_stmt|;
name|g
operator|->
name|mt_comp2
operator|=
name|softc
operator|->
name|comp_algorithm
expr_stmt|;
name|g
operator|->
name|mt_comp3
operator|=
name|softc
operator|->
name|comp_algorithm
expr_stmt|;
block|}
name|g
operator|->
name|mt_density
operator|=
name|softc
operator|->
name|media_density
expr_stmt|;
name|g
operator|->
name|mt_density0
operator|=
name|softc
operator|->
name|media_density
expr_stmt|;
name|g
operator|->
name|mt_density1
operator|=
name|softc
operator|->
name|media_density
expr_stmt|;
name|g
operator|->
name|mt_density2
operator|=
name|softc
operator|->
name|media_density
expr_stmt|;
name|g
operator|->
name|mt_density3
operator|=
name|softc
operator|->
name|media_density
expr_stmt|;
name|g
operator|->
name|mt_blksiz
operator|=
name|softc
operator|->
name|media_blksize
expr_stmt|;
name|g
operator|->
name|mt_blksiz0
operator|=
name|softc
operator|->
name|media_blksize
expr_stmt|;
name|g
operator|->
name|mt_blksiz1
operator|=
name|softc
operator|->
name|media_blksize
expr_stmt|;
name|g
operator|->
name|mt_blksiz2
operator|=
name|softc
operator|->
name|media_blksize
expr_stmt|;
name|g
operator|->
name|mt_blksiz3
operator|=
name|softc
operator|->
name|media_blksize
expr_stmt|;
name|g
operator|->
name|mt_fileno
operator|=
name|softc
operator|->
name|fileno
expr_stmt|;
name|g
operator|->
name|mt_blkno
operator|=
name|softc
operator|->
name|blkno
expr_stmt|;
name|g
operator|->
name|mt_dsreg
operator|=
operator|(
name|short
operator|)
name|softc
operator|->
name|dsreg
expr_stmt|;
comment|/* 		 * Yes, we know that this is likely to overflow 		 */
if|if
condition|(
name|softc
operator|->
name|last_resid_was_io
condition|)
block|{
if|if
condition|(
operator|(
name|g
operator|->
name|mt_resid
operator|=
operator|(
name|short
operator|)
name|softc
operator|->
name|last_io_resid
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|SA_IS_CTRL
argument_list|(
name|dev
argument_list|)
operator|==
literal|0
operator|||
name|didlockperiph
condition|)
block|{
name|softc
operator|->
name|last_io_resid
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|g
operator|->
name|mt_resid
operator|=
operator|(
name|short
operator|)
name|softc
operator|->
name|last_ctl_resid
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|SA_IS_CTRL
argument_list|(
name|dev
argument_list|)
operator|==
literal|0
operator|||
name|didlockperiph
condition|)
block|{
name|softc
operator|->
name|last_ctl_resid
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
case|case
name|MTIOCEXTGET
case|:
case|case
name|MTIOCPARAMGET
case|:
block|{
name|struct
name|mtextget
modifier|*
name|g
init|=
operator|(
expr|struct
name|mtextget
operator|*
operator|)
name|arg
decl_stmt|;
name|char
modifier|*
name|tmpstr2
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
comment|/* 		 * Report drive status using an XML format. 		 */
comment|/* 		 * XXX KDM will dropping the lock cause any problems here? 		 */
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|sb
operator|=
name|sbuf_new
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|g
operator|->
name|alloc_len
argument_list|,
name|SBUF_FIXEDLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
block|{
name|g
operator|->
name|status
operator|=
name|MT_EXT_GET_ERROR
expr_stmt|;
name|snprintf
argument_list|(
name|g
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|g
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"Unable to allocate %d bytes for status info"
argument_list|,
name|g
operator|->
name|alloc_len
argument_list|)
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
goto|goto
name|extget_bailout
goto|;
block|}
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|MTIOCEXTGET
condition|)
name|error
operator|=
name|saextget
argument_list|(
name|dev
argument_list|,
name|periph
argument_list|,
name|sb
argument_list|,
name|g
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|saparamget
argument_list|(
name|softc
argument_list|,
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|extget_bailout
goto|;
name|error
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOMEM
condition|)
block|{
name|g
operator|->
name|status
operator|=
name|MT_EXT_GET_NEED_MORE_SPACE
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|g
operator|->
name|status
operator|=
name|MT_EXT_GET_ERROR
expr_stmt|;
name|snprintf
argument_list|(
name|g
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|g
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"Error %d returned from sbuf_finish()"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
else|else
name|g
operator|->
name|status
operator|=
name|MT_EXT_GET_OK
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|tmpstr2
operator|=
name|sbuf_data
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|g
operator|->
name|fill_len
operator|=
name|strlen
argument_list|(
name|tmpstr2
argument_list|)
operator|+
literal|1
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
name|tmpstr2
argument_list|,
name|g
operator|->
name|status_xml
argument_list|,
name|g
operator|->
name|fill_len
argument_list|)
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|extget_bailout
label|:
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MTIOCPARAMSET
case|:
block|{
name|struct
name|mtsetlist
name|list
decl_stmt|;
name|struct
name|mtparamset
modifier|*
name|ps
init|=
operator|(
expr|struct
name|mtparamset
operator|*
operator|)
name|arg
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|list
argument_list|,
sizeof|sizeof
argument_list|(
name|list
argument_list|)
argument_list|)
expr_stmt|;
name|list
operator|.
name|num_params
operator|=
literal|1
expr_stmt|;
name|list
operator|.
name|param_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ps
argument_list|)
expr_stmt|;
name|list
operator|.
name|params
operator|=
name|ps
expr_stmt|;
name|error
operator|=
name|saparamsetlist
argument_list|(
name|periph
argument_list|,
operator|&
name|list
argument_list|,
comment|/*need_copy*/
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MTIOCSETLIST
case|:
block|{
name|struct
name|mtsetlist
modifier|*
name|list
init|=
operator|(
expr|struct
name|mtsetlist
operator|*
operator|)
name|arg
decl_stmt|;
name|error
operator|=
name|saparamsetlist
argument_list|(
name|periph
argument_list|,
name|list
argument_list|,
comment|/*need_copy*/
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MTIOCERRSTAT
case|:
block|{
name|struct
name|scsi_tape_errors
modifier|*
name|sep
init|=
operator|&
operator|(
operator|(
expr|union
name|mterrstat
operator|*
operator|)
name|arg
operator|)
operator|->
name|scsi_errstat
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"saioctl: MTIOCERRSTAT\n"
operator|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sep
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sep
argument_list|)
argument_list|)
expr_stmt|;
name|sep
operator|->
name|io_resid
operator|=
name|softc
operator|->
name|last_io_resid
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|softc
operator|->
name|last_io_sense
argument_list|,
name|sep
operator|->
name|io_sense
argument_list|,
sizeof|sizeof
argument_list|(
name|sep
operator|->
name|io_sense
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|softc
operator|->
name|last_io_cdb
argument_list|,
name|sep
operator|->
name|io_cdb
argument_list|,
sizeof|sizeof
argument_list|(
name|sep
operator|->
name|io_cdb
argument_list|)
argument_list|)
expr_stmt|;
name|sep
operator|->
name|ctl_resid
operator|=
name|softc
operator|->
name|last_ctl_resid
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|softc
operator|->
name|last_ctl_sense
argument_list|,
name|sep
operator|->
name|ctl_sense
argument_list|,
sizeof|sizeof
argument_list|(
name|sep
operator|->
name|ctl_sense
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|softc
operator|->
name|last_ctl_cdb
argument_list|,
name|sep
operator|->
name|ctl_cdb
argument_list|,
sizeof|sizeof
argument_list|(
name|sep
operator|->
name|ctl_cdb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|SA_IS_CTRL
argument_list|(
name|dev
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|softc
operator|->
name|open_pending_mount
operator|)
operator|||
name|didlockperiph
condition|)
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|softc
operator|->
name|errinfo
argument_list|,
sizeof|sizeof
argument_list|(
name|softc
operator|->
name|errinfo
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
case|case
name|MTIOCTOP
case|:
block|{
name|struct
name|mtop
modifier|*
name|mt
decl_stmt|;
name|int
name|count
decl_stmt|;
name|PENDING_MOUNT_CHECK
argument_list|(
name|softc
argument_list|,
name|periph
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|mt
operator|=
operator|(
expr|struct
name|mtop
operator|*
operator|)
name|arg
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"saioctl: op=0x%x count=0x%x\n"
operator|,
name|mt
operator|->
name|mt_op
operator|,
name|mt
operator|->
name|mt_count
operator|)
argument_list|)
expr_stmt|;
name|count
operator|=
name|mt
operator|->
name|mt_count
expr_stmt|;
switch|switch
condition|(
name|mt
operator|->
name|mt_op
condition|)
block|{
case|case
name|MTWEOF
case|:
comment|/* write an end-of-file marker */
comment|/* 			 * We don't need to clear the SA_FLAG_TAPE_WRITTEN 			 * flag because by keeping track of filemarks 			 * we have last written we know whether or not 			 * we need to write more when we close the device. 			 */
name|error
operator|=
name|sawritefilemarks
argument_list|(
name|periph
argument_list|,
name|count
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|MTWEOFI
case|:
comment|/* write an end-of-file marker without waiting */
name|error
operator|=
name|sawritefilemarks
argument_list|(
name|periph
argument_list|,
name|count
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|MTWSS
case|:
comment|/* write a setmark */
name|error
operator|=
name|sawritefilemarks
argument_list|(
name|periph
argument_list|,
name|count
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|MTBSR
case|:
comment|/* backward space record */
case|case
name|MTFSR
case|:
comment|/* forward space record */
case|case
name|MTBSF
case|:
comment|/* backward space file */
case|case
name|MTFSF
case|:
comment|/* forward space file */
case|case
name|MTBSS
case|:
comment|/* backward space setmark */
case|case
name|MTFSS
case|:
comment|/* forward space setmark */
case|case
name|MTEOD
case|:
comment|/* space to end of recorded medium */
block|{
name|int
name|nmarks
decl_stmt|;
name|spaceop
operator|=
name|SS_FILEMARKS
expr_stmt|;
name|nmarks
operator|=
name|softc
operator|->
name|filemarks
expr_stmt|;
name|error
operator|=
name|sacheckeod
argument_list|(
name|periph
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"EOD check prior to spacing failed\n"
argument_list|)
expr_stmt|;
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_EIO_PENDING
expr_stmt|;
break|break;
block|}
name|nmarks
operator|-=
name|softc
operator|->
name|filemarks
expr_stmt|;
switch|switch
condition|(
name|mt
operator|->
name|mt_op
condition|)
block|{
case|case
name|MTBSR
case|:
name|count
operator|=
operator|-
name|count
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|MTFSR
case|:
name|spaceop
operator|=
name|SS_BLOCKS
expr_stmt|;
break|break;
case|case
name|MTBSF
case|:
name|count
operator|=
operator|-
name|count
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|MTFSF
case|:
break|break;
case|case
name|MTBSS
case|:
name|count
operator|=
operator|-
name|count
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|MTFSS
case|:
name|spaceop
operator|=
name|SS_SETMARKS
expr_stmt|;
break|break;
case|case
name|MTEOD
case|:
name|spaceop
operator|=
name|SS_EOD
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|nmarks
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|error
condition|)
break|break;
name|nmarks
operator|=
name|softc
operator|->
name|filemarks
expr_stmt|;
comment|/* 			 * XXX: Why are we checking again? 			 */
name|error
operator|=
name|sacheckeod
argument_list|(
name|periph
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|nmarks
operator|-=
name|softc
operator|->
name|filemarks
expr_stmt|;
name|error
operator|=
name|saspace
argument_list|(
name|periph
argument_list|,
name|count
operator|-
name|nmarks
argument_list|,
name|spaceop
argument_list|)
expr_stmt|;
comment|/* 			 * At this point, clear that we've written the tape 			 * and that we've written any filemarks. We really 			 * don't know what the applications wishes to do next- 			 * the sacheckeod's will make sure we terminated the 			 * tape correctly if we'd been writing, but the next 			 * action the user application takes will set again 			 * whether we need to write filemarks. 			 */
name|softc
operator|->
name|flags
operator|&=
operator|~
operator|(
name|SA_FLAG_TAPE_WRITTEN
operator||
name|SA_FLAG_TAPE_FROZEN
operator|)
expr_stmt|;
name|softc
operator|->
name|filemarks
operator|=
literal|0
expr_stmt|;
break|break;
block|}
case|case
name|MTREW
case|:
comment|/* rewind */
name|PENDING_MOUNT_CHECK
argument_list|(
name|softc
argument_list|,
name|periph
argument_list|,
name|dev
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sacheckeod
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|error
operator|=
name|sarewind
argument_list|(
name|periph
argument_list|)
expr_stmt|;
comment|/* see above */
name|softc
operator|->
name|flags
operator|&=
operator|~
operator|(
name|SA_FLAG_TAPE_WRITTEN
operator||
name|SA_FLAG_TAPE_FROZEN
operator|)
expr_stmt|;
name|softc
operator|->
name|flags
operator|&=
operator|~
name|SA_FLAG_ERR_PENDING
expr_stmt|;
name|softc
operator|->
name|filemarks
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MTERASE
case|:
comment|/* erase */
name|PENDING_MOUNT_CHECK
argument_list|(
name|softc
argument_list|,
name|periph
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|error
operator|=
name|saerase
argument_list|(
name|periph
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|softc
operator|->
name|flags
operator|&=
operator|~
operator|(
name|SA_FLAG_TAPE_WRITTEN
operator||
name|SA_FLAG_TAPE_FROZEN
operator|)
expr_stmt|;
name|softc
operator|->
name|flags
operator|&=
operator|~
name|SA_FLAG_ERR_PENDING
expr_stmt|;
break|break;
case|case
name|MTRETENS
case|:
comment|/* re-tension tape */
name|PENDING_MOUNT_CHECK
argument_list|(
name|softc
argument_list|,
name|periph
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|error
operator|=
name|saretension
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|softc
operator|->
name|flags
operator|&=
operator|~
operator|(
name|SA_FLAG_TAPE_WRITTEN
operator||
name|SA_FLAG_TAPE_FROZEN
operator|)
expr_stmt|;
name|softc
operator|->
name|flags
operator|&=
operator|~
name|SA_FLAG_ERR_PENDING
expr_stmt|;
break|break;
case|case
name|MTOFFL
case|:
comment|/* rewind and put the drive offline */
name|PENDING_MOUNT_CHECK
argument_list|(
name|softc
argument_list|,
name|periph
argument_list|,
name|dev
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sacheckeod
argument_list|(
name|periph
argument_list|)
expr_stmt|;
comment|/* see above */
name|softc
operator|->
name|flags
operator|&=
operator|~
name|SA_FLAG_TAPE_WRITTEN
expr_stmt|;
name|softc
operator|->
name|filemarks
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|sarewind
argument_list|(
name|periph
argument_list|)
expr_stmt|;
comment|/* clear the frozen flag anyway */
name|softc
operator|->
name|flags
operator|&=
operator|~
name|SA_FLAG_TAPE_FROZEN
expr_stmt|;
comment|/* 			 * Be sure to allow media removal before ejecting. 			 */
name|saprevent
argument_list|(
name|periph
argument_list|,
name|PR_ALLOW
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|saloadunload
argument_list|(
name|periph
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|softc
operator|->
name|flags
operator|&=
operator|~
name|SA_FLAG_TAPE_MOUNTED
expr_stmt|;
block|}
block|}
break|break;
case|case
name|MTLOAD
case|:
name|error
operator|=
name|saloadunload
argument_list|(
name|periph
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|MTNOP
case|:
comment|/* no operation, sets status only */
case|case
name|MTCACHE
case|:
comment|/* enable controller cache */
case|case
name|MTNOCACHE
case|:
comment|/* disable controller cache */
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MTSETBSIZ
case|:
comment|/* Set block size for device */
name|PENDING_MOUNT_CHECK
argument_list|(
name|softc
argument_list|,
name|periph
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|softc
operator|->
name|sili
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|count
operator|!=
literal|0
operator|)
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"Can't enter fixed "
literal|"block mode with SILI enabled\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|sasetparams
argument_list|(
name|periph
argument_list|,
name|SA_PARAM_BLOCKSIZE
argument_list|,
name|count
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|softc
operator|->
name|last_media_blksize
operator|=
name|softc
operator|->
name|media_blksize
expr_stmt|;
name|softc
operator|->
name|media_blksize
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|count
condition|)
block|{
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_FIXED
expr_stmt|;
if|if
condition|(
name|powerof2
argument_list|(
name|count
argument_list|)
condition|)
block|{
name|softc
operator|->
name|blk_shift
operator|=
name|ffs
argument_list|(
name|count
argument_list|)
operator|-
literal|1
expr_stmt|;
name|softc
operator|->
name|blk_mask
operator|=
name|count
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|softc
operator|->
name|blk_mask
operator|=
operator|~
literal|0
expr_stmt|;
name|softc
operator|->
name|blk_shift
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 					 * Make the user's desire 'persistent'. 					 */
name|softc
operator|->
name|quirks
operator|&=
operator|~
name|SA_QUIRK_VARIABLE
expr_stmt|;
name|softc
operator|->
name|quirks
operator||=
name|SA_QUIRK_FIXED
expr_stmt|;
block|}
else|else
block|{
name|softc
operator|->
name|flags
operator|&=
operator|~
name|SA_FLAG_FIXED
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|max_blk
operator|==
literal|0
condition|)
block|{
name|softc
operator|->
name|max_blk
operator|=
operator|~
literal|0
expr_stmt|;
block|}
name|softc
operator|->
name|blk_shift
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|blk_gran
operator|!=
literal|0
condition|)
block|{
name|softc
operator|->
name|blk_mask
operator|=
name|softc
operator|->
name|blk_gran
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|softc
operator|->
name|blk_mask
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 					 * Make the user's desire 'persistent'. 					 */
name|softc
operator|->
name|quirks
operator||=
name|SA_QUIRK_VARIABLE
expr_stmt|;
name|softc
operator|->
name|quirks
operator|&=
operator|~
name|SA_QUIRK_FIXED
expr_stmt|;
block|}
block|}
break|break;
case|case
name|MTSETDNSTY
case|:
comment|/* Set density for device and mode */
name|PENDING_MOUNT_CHECK
argument_list|(
name|softc
argument_list|,
name|periph
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|UCHAR_MAX
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
else|else
block|{
name|error
operator|=
name|sasetparams
argument_list|(
name|periph
argument_list|,
name|SA_PARAM_DENSITY
argument_list|,
literal|0
argument_list|,
name|count
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MTCOMP
case|:
comment|/* enable compression */
name|PENDING_MOUNT_CHECK
argument_list|(
name|softc
argument_list|,
name|periph
argument_list|,
name|dev
argument_list|)
expr_stmt|;
comment|/* 			 * Some devices don't support compression, and 			 * don't like it if you ask them for the 			 * compression page. 			 */
if|if
condition|(
operator|(
name|softc
operator|->
name|quirks
operator|&
name|SA_QUIRK_NOCOMP
operator|)
operator|||
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_COMP_UNSUPP
operator|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|sasetparams
argument_list|(
name|periph
argument_list|,
name|SA_PARAM_COMPRESSION
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|count
argument_list|,
name|SF_NO_PRINT
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
block|}
case|case
name|MTIOCIEOT
case|:
case|case
name|MTIOCEEOT
case|:
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MTIOCRDSPOS
case|:
name|PENDING_MOUNT_CHECK
argument_list|(
name|softc
argument_list|,
name|periph
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|error
operator|=
name|sardpos
argument_list|(
name|periph
argument_list|,
literal|0
argument_list|,
operator|(
name|u_int32_t
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|MTIOCRDHPOS
case|:
name|PENDING_MOUNT_CHECK
argument_list|(
name|softc
argument_list|,
name|periph
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|error
operator|=
name|sardpos
argument_list|(
name|periph
argument_list|,
literal|1
argument_list|,
operator|(
name|u_int32_t
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|MTIOCSLOCATE
case|:
case|case
name|MTIOCHLOCATE
case|:
block|{
name|struct
name|mtlocate
name|locate_info
decl_stmt|;
name|int
name|hard
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|locate_info
argument_list|,
sizeof|sizeof
argument_list|(
name|locate_info
argument_list|)
argument_list|)
expr_stmt|;
name|locate_info
operator|.
name|logical_id
operator|=
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|arg
operator|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|MTIOCSLOCATE
condition|)
name|hard
operator|=
literal|0
expr_stmt|;
else|else
name|hard
operator|=
literal|1
expr_stmt|;
name|PENDING_MOUNT_CHECK
argument_list|(
name|softc
argument_list|,
name|periph
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|error
operator|=
name|sasetpos
argument_list|(
name|periph
argument_list|,
name|hard
argument_list|,
operator|&
name|locate_info
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MTIOCEXTLOCATE
case|:
name|PENDING_MOUNT_CHECK
argument_list|(
name|softc
argument_list|,
name|periph
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|error
operator|=
name|sasetpos
argument_list|(
name|periph
argument_list|,
comment|/*hard*/
literal|0
argument_list|,
operator|(
expr|struct
name|mtlocate
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
name|softc
operator|->
name|flags
operator|&=
operator|~
operator|(
name|SA_FLAG_TAPE_WRITTEN
operator||
name|SA_FLAG_TAPE_FROZEN
operator|)
expr_stmt|;
name|softc
operator|->
name|flags
operator|&=
operator|~
name|SA_FLAG_ERR_PENDING
expr_stmt|;
name|softc
operator|->
name|filemarks
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MTIOCGETEOTMODEL
case|:
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|quirks
operator|&
name|SA_QUIRK_1FM
condition|)
name|mode
operator|=
literal|1
expr_stmt|;
else|else
name|mode
operator|=
literal|2
expr_stmt|;
operator|*
operator|(
operator|(
name|u_int32_t
operator|*
operator|)
name|arg
operator|)
operator|=
name|mode
expr_stmt|;
break|break;
case|case
name|MTIOCSETEOTMODEL
case|:
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
operator|*
operator|(
operator|(
name|u_int32_t
operator|*
operator|)
name|arg
operator|)
condition|)
block|{
case|case
literal|1
case|:
name|softc
operator|->
name|quirks
operator|&=
operator|~
name|SA_QUIRK_2FM
expr_stmt|;
name|softc
operator|->
name|quirks
operator||=
name|SA_QUIRK_1FM
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|softc
operator|->
name|quirks
operator|&=
operator|~
name|SA_QUIRK_1FM
expr_stmt|;
name|softc
operator|->
name|quirks
operator||=
name|SA_QUIRK_2FM
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|MTIOCRBLIM
case|:
block|{
name|struct
name|mtrblim
modifier|*
name|rblim
decl_stmt|;
name|rblim
operator|=
operator|(
expr|struct
name|mtrblim
operator|*
operator|)
name|arg
expr_stmt|;
name|rblim
operator|->
name|granularity
operator|=
name|softc
operator|->
name|blk_gran
expr_stmt|;
name|rblim
operator|->
name|min_block_length
operator|=
name|softc
operator|->
name|min_blk
expr_stmt|;
name|rblim
operator|->
name|max_block_length
operator|=
name|softc
operator|->
name|max_blk
expr_stmt|;
break|break;
block|}
default|default:
name|error
operator|=
name|cam_periph_ioctl
argument_list|(
name|periph
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|,
name|saerror
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	 * Check to see if we cleared a frozen state 	 */
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_TAPE_FROZEN
operator|)
condition|)
block|{
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MTIOCRDSPOS
case|:
case|case
name|MTIOCRDHPOS
case|:
case|case
name|MTIOCSLOCATE
case|:
case|case
name|MTIOCHLOCATE
case|:
comment|/* 			 * XXX KDM look at this. 			 */
name|softc
operator|->
name|fileno
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
name|softc
operator|->
name|blkno
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
name|softc
operator|->
name|rep_blkno
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
name|softc
operator|->
name|rep_fileno
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
name|softc
operator|->
name|partition
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
name|softc
operator|->
name|flags
operator|&=
operator|~
name|SA_FLAG_TAPE_FROZEN
expr_stmt|;
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"tape state now unfrozen.\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|didlockperiph
condition|)
block|{
name|cam_periph_unhold
argument_list|(
name|periph
argument_list|)
expr_stmt|;
block|}
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sainit
parameter_list|(
name|void
parameter_list|)
block|{
name|cam_status
name|status
decl_stmt|;
comment|/* 	 * Install a global async callback. 	 */
name|status
operator|=
name|xpt_register_async
argument_list|(
name|AC_FOUND_DEVICE
argument_list|,
name|saasync
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"sa: Failed to attach master async callback "
literal|"due to status 0x%x!\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sadevgonecb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|mtx
modifier|*
name|mtx
decl_stmt|;
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|periph
operator|=
operator|(
expr|struct
name|cam_periph
operator|*
operator|)
name|arg
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|mtx
operator|=
name|cam_periph_mtx
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
name|mtx
argument_list|)
expr_stmt|;
name|softc
operator|->
name|num_devs_to_destroy
operator|--
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|num_devs_to_destroy
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* 		 * When we have gotten all of our callbacks, we will get 		 * no more close calls from devfs.  So if we have any 		 * dangling opens, we need to release the reference held 		 * for that particular context. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|softc
operator|->
name|open_count
condition|;
name|i
operator|++
control|)
name|cam_periph_release_locked
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|softc
operator|->
name|open_count
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Release the reference held for devfs, all of our 		 * instances are gone now. 		 */
name|cam_periph_release_locked
argument_list|(
name|periph
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We reference the lock directly here, instead of using 	 * cam_periph_unlock().  The reason is that the final call to 	 * cam_periph_release_locked() above could result in the periph 	 * getting freed.  If that is the case, dereferencing the periph 	 * with a cam_periph_unlock() call would cause a page fault. 	 */
name|mtx_unlock
argument_list|(
name|mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|saoninvalidate
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
comment|/* 	 * De-register any async callbacks. 	 */
name|xpt_register_async
argument_list|(
literal|0
argument_list|,
name|saasync
argument_list|,
name|periph
argument_list|,
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_INVALID
expr_stmt|;
comment|/* 	 * Return all queued I/O with ENXIO. 	 * XXX Handle any transactions queued to the card 	 *     with XPT_ABORT_CCB. 	 */
name|bioq_flush
argument_list|(
operator|&
name|softc
operator|->
name|bio_queue
argument_list|,
name|NULL
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
name|softc
operator|->
name|queue_count
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Tell devfs that all of our devices have gone away, and ask for a 	 * callback when it has cleaned up its state. 	 */
name|destroy_dev_sched_cb
argument_list|(
name|softc
operator|->
name|devs
operator|.
name|ctl_dev
argument_list|,
name|sadevgonecb
argument_list|,
name|periph
argument_list|)
expr_stmt|;
name|destroy_dev_sched_cb
argument_list|(
name|softc
operator|->
name|devs
operator|.
name|r_dev
argument_list|,
name|sadevgonecb
argument_list|,
name|periph
argument_list|)
expr_stmt|;
name|destroy_dev_sched_cb
argument_list|(
name|softc
operator|->
name|devs
operator|.
name|nr_dev
argument_list|,
name|sadevgonecb
argument_list|,
name|periph
argument_list|)
expr_stmt|;
name|destroy_dev_sched_cb
argument_list|(
name|softc
operator|->
name|devs
operator|.
name|er_dev
argument_list|,
name|sadevgonecb
argument_list|,
name|periph
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sacleanup
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_SCTX_INIT
operator|)
operator|!=
literal|0
operator|&&
name|sysctl_ctx_free
argument_list|(
operator|&
name|softc
operator|->
name|sysctl_ctx
argument_list|)
operator|!=
literal|0
condition|)
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"can't remove sysctl context\n"
argument_list|)
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|devstat_remove_entry
argument_list|(
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|softc
argument_list|,
name|M_SCSISA
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|saasync
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|u_int32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|periph
operator|=
operator|(
expr|struct
name|cam_periph
operator|*
operator|)
name|callback_arg
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|AC_FOUND_DEVICE
case|:
block|{
name|struct
name|ccb_getdev
modifier|*
name|cgd
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|cgd
operator|=
operator|(
expr|struct
name|ccb_getdev
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|cgd
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|cgd
operator|->
name|protocol
operator|!=
name|PROTO_SCSI
condition|)
break|break;
if|if
condition|(
name|SID_QUAL
argument_list|(
operator|&
name|cgd
operator|->
name|inq_data
argument_list|)
operator|!=
name|SID_QUAL_LU_CONNECTED
condition|)
break|break;
if|if
condition|(
name|SID_TYPE
argument_list|(
operator|&
name|cgd
operator|->
name|inq_data
argument_list|)
operator|!=
name|T_SEQUENTIAL
condition|)
break|break;
comment|/* 		 * Allocate a peripheral instance for 		 * this device and start the probe 		 * process. 		 */
name|status
operator|=
name|cam_periph_alloc
argument_list|(
name|saregister
argument_list|,
name|saoninvalidate
argument_list|,
name|sacleanup
argument_list|,
name|sastart
argument_list|,
literal|"sa"
argument_list|,
name|CAM_PERIPH_BIO
argument_list|,
name|path
argument_list|,
name|saasync
argument_list|,
name|AC_FOUND_DEVICE
argument_list|,
name|cgd
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
operator|&&
name|status
operator|!=
name|CAM_REQ_INPROG
condition|)
name|printf
argument_list|(
literal|"saasync: Unable to probe new device "
literal|"due to status 0x%x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|cam_periph_async
argument_list|(
name|periph
argument_list|,
name|code
argument_list|,
name|path
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sasetupdev
parameter_list|(
name|struct
name|sa_softc
modifier|*
name|softc
parameter_list|,
name|struct
name|cdev
modifier|*
name|dev
parameter_list|)
block|{
name|dev
operator|->
name|si_iosize_max
operator|=
name|softc
operator|->
name|maxio
expr_stmt|;
name|dev
operator|->
name|si_flags
operator||=
name|softc
operator|->
name|si_flags
expr_stmt|;
comment|/* 	 * Keep a count of how many non-alias devices we have created, 	 * so we can make sure we clean them all up on shutdown.  Aliases 	 * are cleaned up when we destroy the device they're an alias for. 	 */
if|if
condition|(
operator|(
name|dev
operator|->
name|si_flags
operator|&
name|SI_ALIAS
operator|)
operator|==
literal|0
condition|)
name|softc
operator|->
name|num_devs_to_destroy
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sasysctlinit
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|char
name|tmpstr
index|[
literal|80
index|]
decl_stmt|,
name|tmpstr2
index|[
literal|80
index|]
decl_stmt|;
name|periph
operator|=
operator|(
expr|struct
name|cam_periph
operator|*
operator|)
name|context
expr_stmt|;
comment|/* 	 * If the periph is invalid, no need to setup the sysctls. 	 */
if|if
condition|(
name|periph
operator|->
name|flags
operator|&
name|CAM_PERIPH_INVALID
condition|)
goto|goto
name|bailout
goto|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|snprintf
argument_list|(
name|tmpstr
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
literal|"CAM SA unit %d"
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|tmpstr2
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr2
argument_list|)
argument_list|,
literal|"%u"
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|)
expr_stmt|;
name|sysctl_ctx_init
argument_list|(
operator|&
name|softc
operator|->
name|sysctl_ctx
argument_list|)
expr_stmt|;
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_SCTX_INIT
expr_stmt|;
name|softc
operator|->
name|sysctl_tree
operator|=
name|SYSCTL_ADD_NODE_WITH_LABEL
argument_list|(
operator|&
name|softc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_STATIC_CHILDREN
argument_list|(
name|_kern_cam_sa
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|tmpstr2
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
name|tmpstr
argument_list|,
literal|"device_index"
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|sysctl_tree
operator|==
name|NULL
condition|)
goto|goto
name|bailout
goto|;
name|SYSCTL_ADD_INT
argument_list|(
operator|&
name|softc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|softc
operator|->
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"allow_io_split"
argument_list|,
name|CTLFLAG_RDTUN
operator||
name|CTLFLAG_NOFETCH
argument_list|,
operator|&
name|softc
operator|->
name|allow_io_split
argument_list|,
literal|0
argument_list|,
literal|"Allow Splitting I/O"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
operator|&
name|softc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|softc
operator|->
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"maxio"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|softc
operator|->
name|maxio
argument_list|,
literal|0
argument_list|,
literal|"Maximum I/O size"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
operator|&
name|softc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|softc
operator|->
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cpi_maxio"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|softc
operator|->
name|cpi_maxio
argument_list|,
literal|0
argument_list|,
literal|"Maximum Controller I/O size"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
operator|&
name|softc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|softc
operator|->
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"inject_eom"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|softc
operator|->
name|inject_eom
argument_list|,
literal|0
argument_list|,
literal|"Queue EOM for the next write/read"
argument_list|)
expr_stmt|;
name|bailout
label|:
comment|/* 	 * Release the reference that was held when this task was enqueued. 	 */
name|cam_periph_release
argument_list|(
name|periph
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|cam_status
name|saregister
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ccb_getdev
modifier|*
name|cgd
decl_stmt|;
name|struct
name|ccb_pathinq
name|cpi
decl_stmt|;
name|struct
name|make_dev_args
name|args
decl_stmt|;
name|caddr_t
name|match
decl_stmt|;
name|char
name|tmpstr
index|[
literal|80
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|cgd
operator|=
operator|(
expr|struct
name|ccb_getdev
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|cgd
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"saregister: no getdev CCB, can't register device\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|softc
argument_list|)
argument_list|,
name|M_SCSISA
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"saregister: Unable to probe new device. "
literal|"Unable to allocate softc\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
name|softc
operator|->
name|scsi_rev
operator|=
name|SID_ANSI_REV
argument_list|(
operator|&
name|cgd
operator|->
name|inq_data
argument_list|)
expr_stmt|;
name|softc
operator|->
name|state
operator|=
name|SA_STATE_NORMAL
expr_stmt|;
name|softc
operator|->
name|fileno
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
name|softc
operator|->
name|blkno
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
name|softc
operator|->
name|rep_fileno
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
name|softc
operator|->
name|rep_blkno
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
name|softc
operator|->
name|partition
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
name|softc
operator|->
name|bop
operator|=
operator|-
literal|1
expr_stmt|;
name|softc
operator|->
name|eop
operator|=
operator|-
literal|1
expr_stmt|;
name|softc
operator|->
name|bpew
operator|=
operator|-
literal|1
expr_stmt|;
name|bioq_init
argument_list|(
operator|&
name|softc
operator|->
name|bio_queue
argument_list|)
expr_stmt|;
name|softc
operator|->
name|periph
operator|=
name|periph
expr_stmt|;
name|periph
operator|->
name|softc
operator|=
name|softc
expr_stmt|;
comment|/* 	 * See if this device has any quirks. 	 */
name|match
operator|=
name|cam_quirkmatch
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|cgd
operator|->
name|inq_data
argument_list|,
operator|(
name|caddr_t
operator|)
name|sa_quirk_table
argument_list|,
name|nitems
argument_list|(
name|sa_quirk_table
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sa_quirk_table
argument_list|)
argument_list|,
name|scsi_inquiry_match
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
operator|!=
name|NULL
condition|)
block|{
name|softc
operator|->
name|quirks
operator|=
operator|(
operator|(
expr|struct
name|sa_quirk_entry
operator|*
operator|)
name|match
operator|)
operator|->
name|quirks
expr_stmt|;
name|softc
operator|->
name|last_media_blksize
operator|=
operator|(
operator|(
expr|struct
name|sa_quirk_entry
operator|*
operator|)
name|match
operator|)
operator|->
name|prefblk
expr_stmt|;
block|}
else|else
name|softc
operator|->
name|quirks
operator|=
name|SA_QUIRK_NONE
expr_stmt|;
comment|/* 	 * Long format data for READ POSITION was introduced in SSC, which 	 * was after SCSI-2.  (Roughly equivalent to SCSI-3.)  If the drive 	 * reports that it is SCSI-2 or older, it is unlikely to support 	 * long position data, but it might.  Some drives from that era 	 * claim to be SCSI-2, but do support long position information. 	 * So, instead of immediately disabling long position information 	 * for SCSI-2 devices, we'll try one pass through sagetpos(), and  	 * then disable long position information if we get an error.    	 */
if|if
condition|(
name|cgd
operator|->
name|inq_data
operator|.
name|version
operator|<=
name|SCSI_REV_CCS
condition|)
name|softc
operator|->
name|quirks
operator||=
name|SA_QUIRK_NO_LONG_POS
expr_stmt|;
if|if
condition|(
name|cgd
operator|->
name|inq_data
operator|.
name|spc3_flags
operator|&
name|SPC3_SID_PROTECT
condition|)
block|{
name|struct
name|ccb_dev_advinfo
name|cdai
decl_stmt|;
name|struct
name|scsi_vpd_extended_inquiry_data
name|ext_inq
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|ext_inq
argument_list|,
sizeof|sizeof
argument_list|(
name|ext_inq
argument_list|)
argument_list|)
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|cdai
operator|.
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
name|CAM_PRIORITY_NORMAL
argument_list|)
expr_stmt|;
name|cdai
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_DEV_ADVINFO
expr_stmt|;
name|cdai
operator|.
name|flags
operator|=
name|CDAI_FLAG_NONE
expr_stmt|;
name|cdai
operator|.
name|buftype
operator|=
name|CDAI_TYPE_EXT_INQ
expr_stmt|;
name|cdai
operator|.
name|bufsiz
operator|=
sizeof|sizeof
argument_list|(
name|ext_inq
argument_list|)
expr_stmt|;
name|cdai
operator|.
name|buf
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|ext_inq
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|cdai
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cdai
operator|.
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|!=
literal|0
condition|)
name|cam_release_devq
argument_list|(
name|cdai
operator|.
name|ccb_h
operator|.
name|path
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cdai
operator|.
name|ccb_h
operator|.
name|status
operator|==
name|CAM_REQ_CMP
operator|)
operator|&&
operator|(
name|ext_inq
operator|.
name|flags1
operator|&
name|SVPD_EID_SA_SPT_LBP
operator|)
condition|)
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_PROTECT_SUPP
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|&
name|cpi
argument_list|,
sizeof|sizeof
argument_list|(
name|cpi
argument_list|)
argument_list|)
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|cpi
operator|.
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
name|CAM_PRIORITY_NORMAL
argument_list|)
expr_stmt|;
name|cpi
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_PATH_INQ
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|cpi
argument_list|)
expr_stmt|;
comment|/* 	 * The SA driver supports a blocksize, but we don't know the 	 * blocksize until we media is inserted.  So, set a flag to 	 * indicate that the blocksize is unavailable right now. 	 */
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|softc
operator|->
name|device_stats
operator|=
name|devstat_new_entry
argument_list|(
literal|"sa"
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|,
literal|0
argument_list|,
name|DEVSTAT_BS_UNAVAILABLE
argument_list|,
name|SID_TYPE
argument_list|(
operator|&
name|cgd
operator|->
name|inq_data
argument_list|)
operator||
name|XPORT_DEVSTAT_TYPE
argument_list|(
name|cpi
operator|.
name|transport
argument_list|)
argument_list|,
name|DEVSTAT_PRIORITY_TAPE
argument_list|)
expr_stmt|;
comment|/* 	 * Load the default value that is either compiled in, or loaded  	 * in the global kern.cam.sa.allow_io_split tunable. 	 */
name|softc
operator|->
name|allow_io_split
operator|=
name|sa_allow_io_split
expr_stmt|;
comment|/* 	 * Load a per-instance tunable, if it exists.  NOTE that this 	 * tunable WILL GO AWAY in FreeBSD 11.0. 	 */
name|snprintf
argument_list|(
name|tmpstr
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
literal|"kern.cam.sa.%u.allow_io_split"
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
name|tmpstr
argument_list|,
operator|&
name|softc
operator|->
name|allow_io_split
argument_list|)
expr_stmt|;
comment|/* 	 * If maxio isn't set, we fall back to DFLTPHYS.  Otherwise we take 	 * the smaller of cpi.maxio or MAXPHYS. 	 */
if|if
condition|(
name|cpi
operator|.
name|maxio
operator|==
literal|0
condition|)
name|softc
operator|->
name|maxio
operator|=
name|DFLTPHYS
expr_stmt|;
elseif|else
if|if
condition|(
name|cpi
operator|.
name|maxio
operator|>
name|MAXPHYS
condition|)
name|softc
operator|->
name|maxio
operator|=
name|MAXPHYS
expr_stmt|;
else|else
name|softc
operator|->
name|maxio
operator|=
name|cpi
operator|.
name|maxio
expr_stmt|;
comment|/* 	 * Record the controller's maximum I/O size so we can report it to 	 * the user later. 	 */
name|softc
operator|->
name|cpi_maxio
operator|=
name|cpi
operator|.
name|maxio
expr_stmt|;
comment|/* 	 * By default we tell physio that we do not want our I/O split. 	 * The user needs to have a 1:1 mapping between the size of his 	 * write to a tape character device and the size of the write 	 * that actually goes down to the drive. 	 */
if|if
condition|(
name|softc
operator|->
name|allow_io_split
operator|==
literal|0
condition|)
name|softc
operator|->
name|si_flags
operator|=
name|SI_NOSPLIT
expr_stmt|;
else|else
name|softc
operator|->
name|si_flags
operator|=
literal|0
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|softc
operator|->
name|sysctl_task
argument_list|,
literal|0
argument_list|,
name|sasysctlinit
argument_list|,
name|periph
argument_list|)
expr_stmt|;
comment|/* 	 * If the SIM supports unmapped I/O, let physio know that we can 	 * handle unmapped buffers. 	 */
if|if
condition|(
name|cpi
operator|.
name|hba_misc
operator|&
name|PIM_UNMAPPED
condition|)
name|softc
operator|->
name|si_flags
operator||=
name|SI_UNMAPPED
expr_stmt|;
comment|/* 	 * Acquire a reference to the periph before we create the devfs 	 * instances for it.  We'll release this reference once the devfs 	 * instances have been freed. 	 */
if|if
condition|(
name|cam_periph_acquire
argument_list|(
name|periph
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"%s: lost periph during "
literal|"registration!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
name|make_dev_args_init
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
name|args
operator|.
name|mda_devsw
operator|=
operator|&
name|sa_cdevsw
expr_stmt|;
name|args
operator|.
name|mda_si_drv1
operator|=
name|softc
operator|->
name|periph
expr_stmt|;
name|args
operator|.
name|mda_uid
operator|=
name|UID_ROOT
expr_stmt|;
name|args
operator|.
name|mda_gid
operator|=
name|GID_OPERATOR
expr_stmt|;
name|args
operator|.
name|mda_mode
operator|=
literal|0660
expr_stmt|;
name|args
operator|.
name|mda_unit
operator|=
name|SAMINOR
argument_list|(
name|SA_CTLDEV
argument_list|,
name|SA_ATYPE_R
argument_list|)
expr_stmt|;
name|error
operator|=
name|make_dev_s
argument_list|(
operator|&
name|args
argument_list|,
operator|&
name|softc
operator|->
name|devs
operator|.
name|ctl_dev
argument_list|,
literal|"%s%d.ctl"
argument_list|,
name|periph
operator|->
name|periph_name
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
name|sasetupdev
argument_list|(
name|softc
argument_list|,
name|softc
operator|->
name|devs
operator|.
name|ctl_dev
argument_list|)
expr_stmt|;
name|args
operator|.
name|mda_unit
operator|=
name|SAMINOR
argument_list|(
name|SA_NOT_CTLDEV
argument_list|,
name|SA_ATYPE_R
argument_list|)
expr_stmt|;
name|error
operator|=
name|make_dev_s
argument_list|(
operator|&
name|args
argument_list|,
operator|&
name|softc
operator|->
name|devs
operator|.
name|r_dev
argument_list|,
literal|"%s%d"
argument_list|,
name|periph
operator|->
name|periph_name
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
name|sasetupdev
argument_list|(
name|softc
argument_list|,
name|softc
operator|->
name|devs
operator|.
name|r_dev
argument_list|)
expr_stmt|;
name|args
operator|.
name|mda_unit
operator|=
name|SAMINOR
argument_list|(
name|SA_NOT_CTLDEV
argument_list|,
name|SA_ATYPE_NR
argument_list|)
expr_stmt|;
name|error
operator|=
name|make_dev_s
argument_list|(
operator|&
name|args
argument_list|,
operator|&
name|softc
operator|->
name|devs
operator|.
name|nr_dev
argument_list|,
literal|"n%s%d"
argument_list|,
name|periph
operator|->
name|periph_name
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
name|sasetupdev
argument_list|(
name|softc
argument_list|,
name|softc
operator|->
name|devs
operator|.
name|nr_dev
argument_list|)
expr_stmt|;
name|args
operator|.
name|mda_unit
operator|=
name|SAMINOR
argument_list|(
name|SA_NOT_CTLDEV
argument_list|,
name|SA_ATYPE_ER
argument_list|)
expr_stmt|;
name|error
operator|=
name|make_dev_s
argument_list|(
operator|&
name|args
argument_list|,
operator|&
name|softc
operator|->
name|devs
operator|.
name|er_dev
argument_list|,
literal|"e%s%d"
argument_list|,
name|periph
operator|->
name|periph_name
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
name|sasetupdev
argument_list|(
name|softc
argument_list|,
name|softc
operator|->
name|devs
operator|.
name|er_dev
argument_list|)
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|softc
operator|->
name|density_type_bits
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|softc
operator|->
name|density_type_bits
index|[
literal|1
index|]
operator|=
name|SRDS_MEDIA
expr_stmt|;
name|softc
operator|->
name|density_type_bits
index|[
literal|2
index|]
operator|=
name|SRDS_MEDIUM_TYPE
expr_stmt|;
name|softc
operator|->
name|density_type_bits
index|[
literal|3
index|]
operator|=
name|SRDS_MEDIUM_TYPE
operator||
name|SRDS_MEDIA
expr_stmt|;
comment|/* 	 * Bump the peripheral refcount for the sysctl thread, in case we 	 * get invalidated before the thread has a chance to run. 	 */
name|cam_periph_acquire
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|softc
operator|->
name|sysctl_task
argument_list|)
expr_stmt|;
comment|/* 	 * Add an async callback so that we get 	 * notified if this device goes away. 	 */
name|xpt_register_async
argument_list|(
name|AC_LOST_DEVICE
argument_list|,
name|saasync
argument_list|,
name|periph
argument_list|,
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|xpt_announce_periph
argument_list|(
name|periph
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xpt_announce_quirks
argument_list|(
name|periph
argument_list|,
name|softc
operator|->
name|quirks
argument_list|,
name|SA_QUIRK_BIT_STRING
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sastart
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|start_ccb
parameter_list|)
block|{
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"sastart\n"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|softc
operator|->
name|state
condition|)
block|{
case|case
name|SA_STATE_NORMAL
case|:
block|{
comment|/* Pull a buffer from the queue and get going on it */
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
comment|/* 		 * See if there is a buf with work for us to do.. 		 */
name|bp
operator|=
name|bioq_first
argument_list|(
operator|&
name|softc
operator|->
name|bio_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
name|xpt_release_ccb
argument_list|(
name|start_ccb
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_ERR_PENDING
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|softc
operator|->
name|inject_eom
operator|!=
literal|0
operator|)
condition|)
block|{
name|struct
name|bio
modifier|*
name|done_bp
decl_stmt|;
if|if
condition|(
name|softc
operator|->
name|inject_eom
operator|!=
literal|0
condition|)
block|{
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_EOM_PENDING
expr_stmt|;
name|softc
operator|->
name|inject_eom
operator|=
literal|0
expr_stmt|;
comment|/* 				 * If we're injecting EOM for writes, we 				 * need to keep PEWS set for 3 queries 				 * to cover 2 position requests from the 				 * kernel via sagetpos(), and then allow 				 * for one for the user to see the BPEW 				 * flag (e.g. via mt status).  After that, 				 * it will be cleared. 				 */
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_WRITE
condition|)
name|softc
operator|->
name|set_pews_status
operator|=
literal|3
expr_stmt|;
else|else
name|softc
operator|->
name|set_pews_status
operator|=
literal|1
expr_stmt|;
block|}
name|again
label|:
name|softc
operator|->
name|queue_count
operator|--
expr_stmt|;
name|bioq_remove
argument_list|(
operator|&
name|softc
operator|->
name|bio_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bio_resid
operator|=
name|bp
operator|->
name|bio_bcount
expr_stmt|;
name|done_bp
operator|=
name|bp
expr_stmt|;
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_EOM_PENDING
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * We have two different behaviors for 				 * writes when we hit either Early Warning 				 * or the PEWZ (Programmable Early Warning 				 * Zone).  The default behavior is that 				 * for all writes that are currently 				 * queued after the write where we saw the 				 * early warning, we will return the write 				 * with the residual equal to the count. 				 * i.e. tell the application that 0 bytes 				 * were written. 				 *  				 * The alternate behavior, which is enabled 				 * when eot_warn is set, is that in 				 * addition to setting the residual equal 				 * to the count, we will set the error 				 * to ENOSPC. 				 * 				 * In either case, once queued writes are 				 * cleared out, we clear the error flag 				 * (see below) and the application is free to 				 * attempt to write more. 				 */
if|if
condition|(
name|softc
operator|->
name|eot_warn
operator|!=
literal|0
condition|)
block|{
name|bp
operator|->
name|bio_flags
operator||=
name|BIO_ERROR
expr_stmt|;
name|bp
operator|->
name|bio_error
operator|=
name|ENOSPC
expr_stmt|;
block|}
else|else
name|bp
operator|->
name|bio_error
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_EOF_PENDING
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * This can only happen if we're reading 				 * in fixed length mode. In this case, 				 * we dump the rest of the list the 				 * same way. 				 */
name|bp
operator|->
name|bio_error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bioq_first
argument_list|(
operator|&
name|softc
operator|->
name|bio_queue
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|biodone
argument_list|(
name|done_bp
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_EIO_PENDING
operator|)
operator|!=
literal|0
condition|)
block|{
name|bp
operator|->
name|bio_error
operator|=
name|EIO
expr_stmt|;
name|bp
operator|->
name|bio_flags
operator||=
name|BIO_ERROR
expr_stmt|;
block|}
name|bp
operator|=
name|bioq_first
argument_list|(
operator|&
name|softc
operator|->
name|bio_queue
argument_list|)
expr_stmt|;
comment|/* 			 * Only if we have no other buffers queued up 			 * do we clear the pending error flag. 			 */
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
name|softc
operator|->
name|flags
operator|&=
operator|~
name|SA_FLAG_ERR_PENDING
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_INFO
argument_list|,
operator|(
literal|"sastart- ERR_PENDING now 0x%x, bp is %sNULL, "
literal|"%d more buffers queued up\n"
operator|,
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_ERR_PENDING
operator|)
operator|,
operator|(
name|bp
operator|!=
name|NULL
operator|)
condition|?
literal|"not "
else|:
literal|" "
operator|,
name|softc
operator|->
name|queue_count
operator|)
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|start_ccb
argument_list|)
expr_stmt|;
name|biodone
argument_list|(
name|done_bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|u_int32_t
name|length
decl_stmt|;
name|bioq_remove
argument_list|(
operator|&
name|softc
operator|->
name|bio_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|softc
operator|->
name|queue_count
operator|--
expr_stmt|;
name|length
operator|=
name|bp
operator|->
name|bio_bcount
expr_stmt|;
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_FIXED
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|softc
operator|->
name|blk_shift
operator|!=
literal|0
condition|)
block|{
name|length
operator|=
name|length
operator|>>
name|softc
operator|->
name|blk_shift
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|softc
operator|->
name|media_blksize
operator|!=
literal|0
condition|)
block|{
name|length
operator|=
name|length
operator|/
name|softc
operator|->
name|media_blksize
expr_stmt|;
block|}
else|else
block|{
name|bp
operator|->
name|bio_error
operator|=
name|EIO
expr_stmt|;
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"zero blocksize"
literal|" for FIXED length writes?\n"
argument_list|)
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
break|break;
block|}
if|#
directive|if
literal|0
block|CAM_DEBUG(start_ccb->ccb_h.path, CAM_DEBUG_INFO, 				    ("issuing a %d fixed record %s\n", 				    length,  (bp->bio_cmd == BIO_READ)? "read" : 				    "write"));
endif|#
directive|endif
block|}
else|else
block|{
if|#
directive|if
literal|0
block|CAM_DEBUG(start_ccb->ccb_h.path, CAM_DEBUG_INFO, 				    ("issuing a %d variable byte %s\n", 				    length,  (bp->bio_cmd == BIO_READ)? "read" : 				    "write"));
endif|#
directive|endif
block|}
name|devstat_start_transaction_bio
argument_list|(
name|softc
operator|->
name|device_stats
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/* 			 * Some people have theorized that we should 			 * suppress illegal length indication if we are 			 * running in variable block mode so that we don't 			 * have to request sense every time our requested 			 * block size is larger than the written block. 			 * The residual information from the ccb allows 			 * us to identify this situation anyway.  The only 			 * problem with this is that we will not get 			 * information about blocks that are larger than 			 * our read buffer unless we set the block size 			 * in the mode page to something other than 0. 			 * 			 * I believe that this is a non-issue. If user apps 			 * don't adjust their read size to match our record 			 * size, that's just life. Anyway, the typical usage 			 * would be to issue, e.g., 64KB reads and occasionally 			 * have to do deal with 512 byte or 1KB intermediate 			 * records. 			 * 			 * That said, though, we now support setting the 			 * SILI bit on reads, and we set the blocksize to 4 			 * bytes when we do that.  This gives us 			 * compatibility with software that wants this, 			 * although the only real difference between that 			 * and not setting the SILI bit on reads is that we 			 * won't get a check condition on reads where our 			 * request size is larger than the block on tape. 			 * That probably only makes a real difference in 			 * non-packetized SCSI, where you have to go back 			 * to the drive to request sense and thus incur 			 * more latency. 			 */
name|softc
operator|->
name|dsreg
operator|=
operator|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_READ
operator|)
condition|?
name|MTIO_DSREG_RD
else|:
name|MTIO_DSREG_WR
expr_stmt|;
name|scsi_sa_read_write
argument_list|(
operator|&
name|start_ccb
operator|->
name|csio
argument_list|,
literal|0
argument_list|,
name|sadone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
operator|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_READ
condition|?
name|SCSI_RW_READ
else|:
name|SCSI_RW_WRITE
operator|)
operator||
operator|(
operator|(
name|bp
operator|->
name|bio_flags
operator|&
name|BIO_UNMAPPED
operator|)
operator|!=
literal|0
condition|?
name|SCSI_RW_BIO
else|:
literal|0
operator|)
argument_list|,
name|softc
operator|->
name|sili
argument_list|,
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_FIXED
operator|)
operator|!=
literal|0
argument_list|,
name|length
argument_list|,
operator|(
name|bp
operator|->
name|bio_flags
operator|&
name|BIO_UNMAPPED
operator|)
operator|!=
literal|0
condition|?
operator|(
name|void
operator|*
operator|)
name|bp
else|:
name|bp
operator|->
name|bio_data
argument_list|,
name|bp
operator|->
name|bio_bcount
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
name|IO_TIMEOUT
argument_list|)
expr_stmt|;
name|start_ccb
operator|->
name|ccb_h
operator|.
name|ccb_pflags
operator|&=
operator|~
name|SA_POSITION_UPDATED
expr_stmt|;
name|start_ccb
operator|->
name|ccb_h
operator|.
name|ccb_bp
operator|=
name|bp
expr_stmt|;
name|bp
operator|=
name|bioq_first
argument_list|(
operator|&
name|softc
operator|->
name|bio_queue
argument_list|)
expr_stmt|;
name|xpt_action
argument_list|(
name|start_ccb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
block|{
comment|/* Have more work to do, so ensure we stay scheduled */
name|xpt_schedule
argument_list|(
name|periph
argument_list|,
name|CAM_PRIORITY_NORMAL
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SA_STATE_ABNORMAL
case|:
default|default:
name|panic
argument_list|(
literal|"state 0x%x in sastart"
argument_list|,
name|softc
operator|->
name|state
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sadone
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|done_ccb
parameter_list|)
block|{
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|csio
operator|=
operator|&
name|done_ccb
operator|->
name|csio
expr_stmt|;
name|softc
operator|->
name|dsreg
operator|=
name|MTIO_DSREG_REST
expr_stmt|;
name|bp
operator|=
operator|(
expr|struct
name|bio
operator|*
operator|)
name|done_ccb
operator|->
name|ccb_h
operator|.
name|ccb_bp
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|saerror
argument_list|(
name|done_ccb
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|ERESTART
condition|)
block|{
comment|/* 			 * A retry was scheduled, so just return. 			 */
return|return;
block|}
block|}
if|if
condition|(
name|error
operator|==
name|EIO
condition|)
block|{
comment|/* 		 * Catastrophic error. Mark the tape as frozen 		 * (we no longer know tape position). 		 * 		 * Return all queued I/O with EIO, and unfreeze 		 * our queue so that future transactions that 		 * attempt to fix this problem can get to the 		 * device. 		 * 		 */
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_TAPE_FROZEN
expr_stmt|;
name|bioq_flush
argument_list|(
operator|&
name|softc
operator|->
name|bio_queue
argument_list|,
name|NULL
argument_list|,
name|EIO
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|bp
operator|->
name|bio_resid
operator|=
name|bp
operator|->
name|bio_bcount
expr_stmt|;
name|bp
operator|->
name|bio_error
operator|=
name|error
expr_stmt|;
name|bp
operator|->
name|bio_flags
operator||=
name|BIO_ERROR
expr_stmt|;
comment|/* 		 * In the error case, position is updated in saerror. 		 */
block|}
else|else
block|{
name|bp
operator|->
name|bio_resid
operator|=
name|csio
operator|->
name|resid
expr_stmt|;
name|bp
operator|->
name|bio_error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|csio
operator|->
name|resid
operator|!=
literal|0
condition|)
block|{
name|bp
operator|->
name|bio_flags
operator||=
name|BIO_ERROR
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_WRITE
condition|)
block|{
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_TAPE_WRITTEN
expr_stmt|;
name|softc
operator|->
name|filemarks
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|csio
operator|->
name|ccb_h
operator|.
name|ccb_pflags
operator|&
name|SA_POSITION_UPDATED
operator|)
operator|&&
operator|(
name|softc
operator|->
name|blkno
operator|!=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_FIXED
operator|)
operator|!=
literal|0
condition|)
block|{
name|u_int32_t
name|l
decl_stmt|;
if|if
condition|(
name|softc
operator|->
name|blk_shift
operator|!=
literal|0
condition|)
block|{
name|l
operator|=
name|bp
operator|->
name|bio_bcount
operator|>>
name|softc
operator|->
name|blk_shift
expr_stmt|;
block|}
else|else
block|{
name|l
operator|=
name|bp
operator|->
name|bio_bcount
operator|/
name|softc
operator|->
name|media_blksize
expr_stmt|;
block|}
name|softc
operator|->
name|blkno
operator|+=
operator|(
name|daddr_t
operator|)
name|l
expr_stmt|;
block|}
else|else
block|{
name|softc
operator|->
name|blkno
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * If we had an error (immediate or pending), 	 * release the device queue now. 	 */
if|if
condition|(
name|error
operator|||
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_ERR_PENDING
operator|)
condition|)
name|cam_release_devq
argument_list|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|bp
operator|->
name|bio_resid
condition|)
block|{
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_INFO
argument_list|,
operator|(
literal|"error %d resid %ld count %ld\n"
operator|,
name|error
operator|,
name|bp
operator|->
name|bio_resid
operator|,
name|bp
operator|->
name|bio_bcount
operator|)
argument_list|)
expr_stmt|;
block|}
name|biofinish
argument_list|(
name|bp
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Mount the tape (make sure it's ready for I/O).  */
end_comment

begin_function
specifier|static
name|int
name|samount
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|oflags
parameter_list|,
name|struct
name|cdev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * oflags can be checked for 'kind' of open (read-only check) - later 	 * dev can be checked for a control-mode or compression open - later 	 */
name|UNUSED_PARAMETER
argument_list|(
name|oflags
argument_list|)
expr_stmt|;
name|UNUSED_PARAMETER
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
comment|/* 	 * This should determine if something has happened since the last 	 * open/mount that would invalidate the mount. We do *not* want 	 * to retry this command- we just want the status. But we only 	 * do this if we're mounted already- if we're not mounted, 	 * we don't care about the unit read state and can instead use 	 * this opportunity to attempt to reserve the tape unit. 	 */
if|if
condition|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_TAPE_MOUNTED
condition|)
block|{
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|scsi_test_unit_ready
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
literal|0
argument_list|,
name|sadone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
name|IO_TIMEOUT
argument_list|)
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
literal|0
argument_list|,
name|SF_NO_PRINT
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENXIO
condition|)
block|{
name|softc
operator|->
name|flags
operator|&=
operator|~
name|SA_FLAG_TAPE_MOUNTED
expr_stmt|;
name|scsi_test_unit_ready
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
literal|0
argument_list|,
name|sadone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
name|IO_TIMEOUT
argument_list|)
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
literal|0
argument_list|,
name|SF_NO_PRINT
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
condition|)
block|{
comment|/* 			 * We don't need to freeze the tape because we 			 * will now attempt to rewind/load it. 			 */
name|softc
operator|->
name|flags
operator|&=
operator|~
name|SA_FLAG_TAPE_MOUNTED
expr_stmt|;
if|if
condition|(
name|CAM_DEBUGGED
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_INFO
argument_list|)
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"error %d on TUR in samount\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|error
operator|=
name|sareservereleaseunit
argument_list|(
name|periph
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|scsi_test_unit_ready
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
literal|0
argument_list|,
name|sadone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
name|IO_TIMEOUT
argument_list|)
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
literal|0
argument_list|,
name|SF_NO_PRINT
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_TAPE_MOUNTED
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|scsi_read_block_limits_data
modifier|*
name|rblim
init|=
name|NULL
decl_stmt|;
name|int
name|comp_enabled
decl_stmt|,
name|comp_supported
decl_stmt|;
name|u_int8_t
name|write_protect
decl_stmt|,
name|guessing
init|=
literal|0
decl_stmt|;
comment|/* 		 * Clear out old state. 		 */
name|softc
operator|->
name|flags
operator|&=
operator|~
operator|(
name|SA_FLAG_TAPE_WP
operator||
name|SA_FLAG_TAPE_WRITTEN
operator||
name|SA_FLAG_ERR_PENDING
operator||
name|SA_FLAG_COMPRESSION
operator|)
expr_stmt|;
name|softc
operator|->
name|filemarks
operator|=
literal|0
expr_stmt|;
comment|/* 		 * *Very* first off, make sure we're loaded to BOT. 		 */
name|scsi_load_unload
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
literal|2
argument_list|,
name|sadone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|1
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
name|REWIND_TIMEOUT
argument_list|)
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
literal|0
argument_list|,
name|SF_NO_PRINT
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
comment|/* 		 * In case this doesn't work, do a REWIND instead 		 */
if|if
condition|(
name|error
condition|)
block|{
name|scsi_rewind
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
literal|2
argument_list|,
name|sadone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|FALSE
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
name|REWIND_TIMEOUT
argument_list|)
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
literal|0
argument_list|,
name|SF_NO_PRINT
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
comment|/* 		 * Do a dummy test read to force access to the 		 * media so that the drive will really know what's 		 * there. We actually don't really care what the 		 * blocksize on tape is and don't expect to really 		 * read a full record. 		 */
name|rblim
operator|=
operator|(
expr|struct
name|scsi_read_block_limits_data
operator|*
operator|)
name|malloc
argument_list|(
literal|8192
argument_list|,
name|M_SCSISA
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rblim
operator|==
name|NULL
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"no memory for test read\n"
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
if|if
condition|(
operator|(
name|softc
operator|->
name|quirks
operator|&
name|SA_QUIRK_NODREAD
operator|)
operator|==
literal|0
condition|)
block|{
name|scsi_sa_read_write
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
literal|0
argument_list|,
name|sadone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
literal|1
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|8192
argument_list|,
operator|(
name|void
operator|*
operator|)
name|rblim
argument_list|,
literal|8192
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
name|IO_TIMEOUT
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
literal|0
argument_list|,
name|SF_NO_PRINT
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
name|scsi_rewind
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
literal|1
argument_list|,
name|sadone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|FALSE
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
name|REWIND_TIMEOUT
argument_list|)
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
name|CAM_RETRY_SELTO
argument_list|,
name|SF_NO_PRINT
operator||
name|SF_RETRY_UA
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"unable to rewind after test read\n"
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
block|}
comment|/* 		 * Next off, determine block limits. 		 */
name|scsi_read_block_limits
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
literal|5
argument_list|,
name|sadone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|rblim
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
name|SCSIOP_TIMEOUT
argument_list|)
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
name|CAM_RETRY_SELTO
argument_list|,
name|SF_NO_PRINT
operator||
name|SF_RETRY_UA
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * If it's less than SCSI-2, READ BLOCK LIMITS is not 			 * a MANDATORY command. Anyway- it doesn't matter- 			 * we can proceed anyway. 			 */
name|softc
operator|->
name|blk_gran
operator|=
literal|0
expr_stmt|;
name|softc
operator|->
name|max_blk
operator|=
operator|~
literal|0
expr_stmt|;
name|softc
operator|->
name|min_blk
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|softc
operator|->
name|scsi_rev
operator|>=
name|SCSI_REV_SPC
condition|)
block|{
name|softc
operator|->
name|blk_gran
operator|=
name|RBL_GRAN
argument_list|(
name|rblim
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|softc
operator|->
name|blk_gran
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 			 * We take max_blk == min_blk to mean a default to 			 * fixed mode- but note that whatever we get out of 			 * sagetparams below will actually determine whether 			 * we are actually *in* fixed mode. 			 */
name|softc
operator|->
name|max_blk
operator|=
name|scsi_3btoul
argument_list|(
name|rblim
operator|->
name|maximum
argument_list|)
expr_stmt|;
name|softc
operator|->
name|min_blk
operator|=
name|scsi_2btoul
argument_list|(
name|rblim
operator|->
name|minimum
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Next, perform a mode sense to determine 		 * current density, blocksize, compression etc. 		 */
name|error
operator|=
name|sagetparams
argument_list|(
name|periph
argument_list|,
name|SA_PARAM_ALL
argument_list|,
operator|&
name|softc
operator|->
name|media_blksize
argument_list|,
operator|&
name|softc
operator|->
name|media_density
argument_list|,
operator|&
name|softc
operator|->
name|media_numblks
argument_list|,
operator|&
name|softc
operator|->
name|buffer_mode
argument_list|,
operator|&
name|write_protect
argument_list|,
operator|&
name|softc
operator|->
name|speed
argument_list|,
operator|&
name|comp_supported
argument_list|,
operator|&
name|comp_enabled
argument_list|,
operator|&
name|softc
operator|->
name|comp_algorithm
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * We could work a little harder here. We could 			 * adjust our attempts to get information. It 			 * might be an ancient tape drive. If someone 			 * nudges us, we'll do that. 			 */
goto|goto
name|exit
goto|;
block|}
comment|/* 		 * If no quirk has determined that this is a device that is 		 * preferred to be in fixed or variable mode, now is the time 		 * to find out. 	 	 */
if|if
condition|(
operator|(
name|softc
operator|->
name|quirks
operator|&
operator|(
name|SA_QUIRK_FIXED
operator||
name|SA_QUIRK_VARIABLE
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|guessing
operator|=
literal|1
expr_stmt|;
comment|/* 			 * This could be expensive to find out. Luckily we 			 * only need to do this once. If we start out in 			 * 'default' mode, try and set ourselves to one 			 * of the densities that would determine a wad 			 * of other stuff. Go from highest to lowest. 			 */
if|if
condition|(
name|softc
operator|->
name|media_density
operator|==
name|SCSI_DEFAULT_DENSITY
condition|)
block|{
name|int
name|i
decl_stmt|;
specifier|static
name|u_int8_t
name|ctry
index|[]
init|=
block|{
name|SCSI_DENSITY_HALFINCH_PE
block|,
name|SCSI_DENSITY_HALFINCH_6250C
block|,
name|SCSI_DENSITY_HALFINCH_6250
block|,
name|SCSI_DENSITY_HALFINCH_1600
block|,
name|SCSI_DENSITY_HALFINCH_800
block|,
name|SCSI_DENSITY_QIC_4GB
block|,
name|SCSI_DENSITY_QIC_2GB
block|,
name|SCSI_DENSITY_QIC_525_320
block|,
name|SCSI_DENSITY_QIC_150
block|,
name|SCSI_DENSITY_QIC_120
block|,
name|SCSI_DENSITY_QIC_24
block|,
name|SCSI_DENSITY_QIC_11_9TRK
block|,
name|SCSI_DENSITY_QIC_11_4TRK
block|,
name|SCSI_DENSITY_QIC_1320
block|,
name|SCSI_DENSITY_QIC_3080
block|,
literal|0
block|}
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ctry
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|sasetparams
argument_list|(
name|periph
argument_list|,
name|SA_PARAM_DENSITY
argument_list|,
literal|0
argument_list|,
name|ctry
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|SF_NO_PRINT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|softc
operator|->
name|media_density
operator|=
name|ctry
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
block|}
switch|switch
condition|(
name|softc
operator|->
name|media_density
condition|)
block|{
case|case
name|SCSI_DENSITY_QIC_11_4TRK
case|:
case|case
name|SCSI_DENSITY_QIC_11_9TRK
case|:
case|case
name|SCSI_DENSITY_QIC_24
case|:
case|case
name|SCSI_DENSITY_QIC_120
case|:
case|case
name|SCSI_DENSITY_QIC_150
case|:
case|case
name|SCSI_DENSITY_QIC_525_320
case|:
case|case
name|SCSI_DENSITY_QIC_1320
case|:
case|case
name|SCSI_DENSITY_QIC_3080
case|:
name|softc
operator|->
name|quirks
operator|&=
operator|~
name|SA_QUIRK_2FM
expr_stmt|;
name|softc
operator|->
name|quirks
operator||=
name|SA_QUIRK_FIXED
operator||
name|SA_QUIRK_1FM
expr_stmt|;
name|softc
operator|->
name|last_media_blksize
operator|=
literal|512
expr_stmt|;
break|break;
case|case
name|SCSI_DENSITY_QIC_4GB
case|:
case|case
name|SCSI_DENSITY_QIC_2GB
case|:
name|softc
operator|->
name|quirks
operator|&=
operator|~
name|SA_QUIRK_2FM
expr_stmt|;
name|softc
operator|->
name|quirks
operator||=
name|SA_QUIRK_FIXED
operator||
name|SA_QUIRK_1FM
expr_stmt|;
name|softc
operator|->
name|last_media_blksize
operator|=
literal|1024
expr_stmt|;
break|break;
default|default:
name|softc
operator|->
name|last_media_blksize
operator|=
name|softc
operator|->
name|media_blksize
expr_stmt|;
name|softc
operator|->
name|quirks
operator||=
name|SA_QUIRK_VARIABLE
expr_stmt|;
break|break;
block|}
block|}
comment|/* 		 * If no quirk has determined that this is a device that needs 		 * to have 2 Filemarks at EOD, now is the time to find out. 		 */
if|if
condition|(
operator|(
name|softc
operator|->
name|quirks
operator|&
name|SA_QUIRK_2FM
operator|)
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|softc
operator|->
name|media_density
condition|)
block|{
case|case
name|SCSI_DENSITY_HALFINCH_800
case|:
case|case
name|SCSI_DENSITY_HALFINCH_1600
case|:
case|case
name|SCSI_DENSITY_HALFINCH_6250
case|:
case|case
name|SCSI_DENSITY_HALFINCH_6250C
case|:
case|case
name|SCSI_DENSITY_HALFINCH_PE
case|:
name|softc
operator|->
name|quirks
operator|&=
operator|~
name|SA_QUIRK_1FM
expr_stmt|;
name|softc
operator|->
name|quirks
operator||=
name|SA_QUIRK_2FM
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* 		 * Now validate that some info we got makes sense. 		 */
if|if
condition|(
operator|(
name|softc
operator|->
name|max_blk
operator|<
name|softc
operator|->
name|media_blksize
operator|)
operator|||
operator|(
name|softc
operator|->
name|min_blk
operator|>
name|softc
operator|->
name|media_blksize
operator|&&
name|softc
operator|->
name|media_blksize
operator|)
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"BLOCK LIMITS (%d..%d) could not match current "
literal|"block settings (%d)- adjusting\n"
argument_list|,
name|softc
operator|->
name|min_blk
argument_list|,
name|softc
operator|->
name|max_blk
argument_list|,
name|softc
operator|->
name|media_blksize
argument_list|)
expr_stmt|;
name|softc
operator|->
name|max_blk
operator|=
name|softc
operator|->
name|min_blk
operator|=
name|softc
operator|->
name|media_blksize
expr_stmt|;
block|}
comment|/* 		 * Now put ourselves into the right frame of mind based 		 * upon quirks... 		 */
name|tryagain
label|:
comment|/* 		 * If we want to be in FIXED mode and our current blocksize 		 * is not equal to our last blocksize (if nonzero), try and 		 * set ourselves to this last blocksize (as the 'preferred' 		 * block size).  The initial quirkmatch at registry sets the 		 * initial 'last' blocksize. If, for whatever reason, this 		 * 'last' blocksize is zero, set the blocksize to 512, 		 * or min_blk if that's larger. 		 */
if|if
condition|(
operator|(
name|softc
operator|->
name|quirks
operator|&
name|SA_QUIRK_FIXED
operator|)
operator|&&
operator|(
name|softc
operator|->
name|quirks
operator|&
name|SA_QUIRK_NO_MODESEL
operator|)
operator|==
literal|0
operator|&&
operator|(
name|softc
operator|->
name|media_blksize
operator|!=
name|softc
operator|->
name|last_media_blksize
operator|)
condition|)
block|{
name|softc
operator|->
name|media_blksize
operator|=
name|softc
operator|->
name|last_media_blksize
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|media_blksize
operator|==
literal|0
condition|)
block|{
name|softc
operator|->
name|media_blksize
operator|=
literal|512
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|media_blksize
operator|<
name|softc
operator|->
name|min_blk
condition|)
block|{
name|softc
operator|->
name|media_blksize
operator|=
name|softc
operator|->
name|min_blk
expr_stmt|;
block|}
block|}
name|error
operator|=
name|sasetparams
argument_list|(
name|periph
argument_list|,
name|SA_PARAM_BLOCKSIZE
argument_list|,
name|softc
operator|->
name|media_blksize
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SF_NO_PRINT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"unable to set fixed blocksize to %d\n"
argument_list|,
name|softc
operator|->
name|media_blksize
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
block|}
if|if
condition|(
operator|(
name|softc
operator|->
name|quirks
operator|&
name|SA_QUIRK_VARIABLE
operator|)
operator|&&
operator|(
name|softc
operator|->
name|media_blksize
operator|!=
literal|0
operator|)
condition|)
block|{
name|softc
operator|->
name|last_media_blksize
operator|=
name|softc
operator|->
name|media_blksize
expr_stmt|;
name|softc
operator|->
name|media_blksize
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|sasetparams
argument_list|(
name|periph
argument_list|,
name|SA_PARAM_BLOCKSIZE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SF_NO_PRINT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* 				 * If this fails and we were guessing, just 				 * assume that we got it wrong and go try 				 * fixed block mode. Don't even check against 				 * density code at this point. 				 */
if|if
condition|(
name|guessing
condition|)
block|{
name|softc
operator|->
name|quirks
operator|&=
operator|~
name|SA_QUIRK_VARIABLE
expr_stmt|;
name|softc
operator|->
name|quirks
operator||=
name|SA_QUIRK_FIXED
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|last_media_blksize
operator|==
literal|0
condition|)
name|softc
operator|->
name|last_media_blksize
operator|=
literal|512
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"unable to set variable blocksize\n"
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
block|}
comment|/* 		 * Now that we have the current block size, 		 * set up some parameters for sastart's usage. 		 */
if|if
condition|(
name|softc
operator|->
name|media_blksize
condition|)
block|{
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_FIXED
expr_stmt|;
if|if
condition|(
name|powerof2
argument_list|(
name|softc
operator|->
name|media_blksize
argument_list|)
condition|)
block|{
name|softc
operator|->
name|blk_shift
operator|=
name|ffs
argument_list|(
name|softc
operator|->
name|media_blksize
argument_list|)
operator|-
literal|1
expr_stmt|;
name|softc
operator|->
name|blk_mask
operator|=
name|softc
operator|->
name|media_blksize
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|softc
operator|->
name|blk_mask
operator|=
operator|~
literal|0
expr_stmt|;
name|softc
operator|->
name|blk_shift
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * The SCSI-3 spec allows 0 to mean "unspecified". 			 * The SCSI-1 spec allows 0 to mean 'infinite'. 			 * 			 * Either works here. 			 */
if|if
condition|(
name|softc
operator|->
name|max_blk
operator|==
literal|0
condition|)
block|{
name|softc
operator|->
name|max_blk
operator|=
operator|~
literal|0
expr_stmt|;
block|}
name|softc
operator|->
name|blk_shift
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|blk_gran
operator|!=
literal|0
condition|)
block|{
name|softc
operator|->
name|blk_mask
operator|=
name|softc
operator|->
name|blk_gran
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|softc
operator|->
name|blk_mask
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|write_protect
condition|)
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_TAPE_WP
expr_stmt|;
if|if
condition|(
name|comp_supported
condition|)
block|{
if|if
condition|(
name|softc
operator|->
name|saved_comp_algorithm
operator|==
literal|0
condition|)
name|softc
operator|->
name|saved_comp_algorithm
operator|=
name|softc
operator|->
name|comp_algorithm
expr_stmt|;
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_COMP_SUPP
expr_stmt|;
if|if
condition|(
name|comp_enabled
condition|)
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_COMP_ENABLED
expr_stmt|;
block|}
else|else
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_COMP_UNSUPP
expr_stmt|;
if|if
condition|(
operator|(
name|softc
operator|->
name|buffer_mode
operator|==
name|SMH_SA_BUF_MODE_NOBUF
operator|)
operator|&&
operator|(
name|softc
operator|->
name|quirks
operator|&
name|SA_QUIRK_NO_MODESEL
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|sasetparams
argument_list|(
name|periph
argument_list|,
name|SA_PARAM_BUFF_MODE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SF_NO_PRINT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|softc
operator|->
name|buffer_mode
operator|=
name|SMH_SA_BUF_MODE_SIBUF
expr_stmt|;
block|}
else|else
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"unable to set buffered mode\n"
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
comment|/* not an error */
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_TAPE_MOUNTED
expr_stmt|;
block|}
name|exit
label|:
if|if
condition|(
name|rblim
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rblim
argument_list|,
name|M_SCSISA
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|softc
operator|->
name|dsreg
operator|=
name|MTIO_DSREG_NIL
expr_stmt|;
block|}
else|else
block|{
name|softc
operator|->
name|fileno
operator|=
name|softc
operator|->
name|blkno
operator|=
literal|0
expr_stmt|;
name|softc
operator|->
name|rep_fileno
operator|=
name|softc
operator|->
name|rep_blkno
operator|=
operator|-
literal|1
expr_stmt|;
name|softc
operator|->
name|partition
operator|=
literal|0
expr_stmt|;
name|softc
operator|->
name|dsreg
operator|=
name|MTIO_DSREG_REST
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SA_1FM_AT_EOD
if|if
condition|(
operator|(
name|softc
operator|->
name|quirks
operator|&
name|SA_QUIRK_2FM
operator|)
operator|==
literal|0
condition|)
name|softc
operator|->
name|quirks
operator||=
name|SA_QUIRK_1FM
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|(
name|softc
operator|->
name|quirks
operator|&
name|SA_QUIRK_1FM
operator|)
operator|==
literal|0
condition|)
name|softc
operator|->
name|quirks
operator||=
name|SA_QUIRK_2FM
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
comment|/* 	 * If we return an error, we're not mounted any more, 	 * so release any device reservation. 	 */
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sareservereleaseunit
argument_list|(
name|periph
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Clear I/O residual. 		 */
name|softc
operator|->
name|last_io_resid
operator|=
literal|0
expr_stmt|;
name|softc
operator|->
name|last_ctl_resid
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * How many filemarks do we need to write if we were to terminate the  * tape session right now? Note that this can be a negative number  */
end_comment

begin_function
specifier|static
name|int
name|samarkswanted
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|int
name|markswanted
decl_stmt|;
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|markswanted
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_TAPE_WRITTEN
operator|)
operator|!=
literal|0
condition|)
block|{
name|markswanted
operator|++
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|quirks
operator|&
name|SA_QUIRK_2FM
condition|)
name|markswanted
operator|++
expr_stmt|;
block|}
name|markswanted
operator|-=
name|softc
operator|->
name|filemarks
expr_stmt|;
return|return
operator|(
name|markswanted
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sacheckeod
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|markswanted
decl_stmt|;
name|markswanted
operator|=
name|samarkswanted
argument_list|(
name|periph
argument_list|)
expr_stmt|;
if|if
condition|(
name|markswanted
operator|>
literal|0
condition|)
block|{
name|error
operator|=
name|sawritefilemarks
argument_list|(
name|periph
argument_list|,
name|markswanted
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|saerror
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|u_int32_t
name|cflgs
parameter_list|,
name|u_int32_t
name|sflgs
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|toobig
init|=
literal|"%d-byte tape record bigger than supplied buffer\n"
decl_stmt|;
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|struct
name|scsi_sense_data
modifier|*
name|sense
decl_stmt|;
name|uint64_t
name|resid
init|=
literal|0
decl_stmt|;
name|int64_t
name|info
init|=
literal|0
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|int
name|error_code
decl_stmt|,
name|sense_key
decl_stmt|,
name|asc
decl_stmt|,
name|ascq
decl_stmt|,
name|error
decl_stmt|,
name|aqvalid
decl_stmt|,
name|stream_valid
decl_stmt|;
name|int
name|sense_len
decl_stmt|;
name|uint8_t
name|stream_bits
decl_stmt|;
name|periph
operator|=
name|xpt_path_periph
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|csio
operator|=
operator|&
name|ccb
operator|->
name|csio
expr_stmt|;
name|sense
operator|=
operator|&
name|csio
operator|->
name|sense_data
expr_stmt|;
name|sense_len
operator|=
name|csio
operator|->
name|sense_len
operator|-
name|csio
operator|->
name|sense_resid
expr_stmt|;
name|scsi_extract_sense_len
argument_list|(
name|sense
argument_list|,
name|sense_len
argument_list|,
operator|&
name|error_code
argument_list|,
operator|&
name|sense_key
argument_list|,
operator|&
name|asc
argument_list|,
operator|&
name|ascq
argument_list|,
comment|/*show_errors*/
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|asc
operator|!=
operator|-
literal|1
operator|&&
name|ascq
operator|!=
operator|-
literal|1
condition|)
name|aqvalid
operator|=
literal|1
expr_stmt|;
else|else
name|aqvalid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|scsi_get_stream_info
argument_list|(
name|sense
argument_list|,
name|sense_len
argument_list|,
name|NULL
argument_list|,
operator|&
name|stream_bits
argument_list|)
operator|==
literal|0
condition|)
name|stream_valid
operator|=
literal|1
expr_stmt|;
else|else
name|stream_valid
operator|=
literal|0
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
expr_stmt|;
comment|/* 	 * Calculate/latch up, any residuals... We do this in a funny 2-step 	 * so we can print stuff here if we have CAM_DEBUG enabled for this 	 * unit. 	 */
if|if
condition|(
name|status
operator|==
name|CAM_SCSI_STATUS_ERROR
condition|)
block|{
if|if
condition|(
name|scsi_get_sense_info
argument_list|(
name|sense
argument_list|,
name|sense_len
argument_list|,
name|SSD_DESC_INFO
argument_list|,
operator|&
name|resid
argument_list|,
operator|&
name|info
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_FIXED
operator|)
operator|!=
literal|0
condition|)
name|resid
operator|*=
name|softc
operator|->
name|media_blksize
expr_stmt|;
block|}
else|else
block|{
name|resid
operator|=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
name|info
operator|=
name|resid
expr_stmt|;
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_FIXED
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|softc
operator|->
name|media_blksize
condition|)
name|info
operator|/=
name|softc
operator|->
name|media_blksize
expr_stmt|;
block|}
block|}
if|if
condition|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
operator|==
name|SA_READ
operator|||
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
operator|==
name|SA_WRITE
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|sense
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|softc
operator|->
name|last_io_sense
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|softc
operator|->
name|last_io_cdb
argument_list|,
operator|(
name|int
operator|)
name|csio
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
name|softc
operator|->
name|last_io_resid
operator|=
name|resid
expr_stmt|;
name|softc
operator|->
name|last_resid_was_io
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|sense
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|softc
operator|->
name|last_ctl_sense
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|softc
operator|->
name|last_ctl_cdb
argument_list|,
operator|(
name|int
operator|)
name|csio
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
name|softc
operator|->
name|last_ctl_resid
operator|=
name|resid
expr_stmt|;
name|softc
operator|->
name|last_resid_was_io
operator|=
literal|0
expr_stmt|;
block|}
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_INFO
argument_list|,
operator|(
literal|"CDB[0]=0x%x Key 0x%x "
literal|"ASC/ASCQ 0x%x/0x%x CAM STATUS 0x%x flags 0x%x resid %jd "
literal|"dxfer_len %d\n"
operator|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
operator|&
literal|0xff
operator|,
name|sense_key
operator|,
name|asc
operator|,
name|ascq
operator|,
name|status
operator|,
operator|(
name|stream_valid
operator|)
condition|?
name|stream_bits
else|:
literal|0
operator|,
operator|(
name|intmax_t
operator|)
name|resid
operator|,
name|csio
operator|->
name|dxfer_len
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_INFO
argument_list|,
operator|(
literal|"Cam Status 0x%x\n"
operator|,
name|status
operator|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|CAM_REQ_CMP
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|CAM_SCSI_STATUS_ERROR
case|:
comment|/* 		 * If a read/write command, we handle it here. 		 */
if|if
condition|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
operator|==
name|SA_READ
operator|||
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
operator|==
name|SA_WRITE
condition|)
block|{
break|break;
block|}
comment|/* 		 * If this was just EOM/EOP, Filemark, Setmark or ILI detected 		 * on a non read/write command, we assume it's not an error 		 * and propagate the residule and return. 		 */
if|if
condition|(
operator|(
name|aqvalid
operator|&&
name|asc
operator|==
literal|0
operator|&&
name|ascq
operator|>
literal|0
operator|&&
name|ascq
operator|<=
literal|5
operator|)
operator|||
operator|(
name|aqvalid
operator|==
literal|0
operator|&&
name|sense_key
operator|==
name|SSD_KEY_NO_SENSE
operator|)
condition|)
block|{
name|csio
operator|->
name|resid
operator|=
name|resid
expr_stmt|;
name|QFRLS
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 		 * Otherwise, we let the common code handle this. 		 */
return|return
operator|(
name|cam_periph_error
argument_list|(
name|ccb
argument_list|,
name|cflgs
argument_list|,
name|sflgs
argument_list|,
operator|&
name|softc
operator|->
name|saved_ccb
argument_list|)
operator|)
return|;
comment|/* 	 * XXX: To Be Fixed 	 * We cannot depend upon CAM honoring retry counts for these. 	 */
case|case
name|CAM_SCSI_BUS_RESET
case|:
case|case
name|CAM_BDR_SENT
case|:
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|retry_count
operator|<=
literal|0
condition|)
block|{
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* FALLTHROUGH */
default|default:
return|return
operator|(
name|cam_periph_error
argument_list|(
name|ccb
argument_list|,
name|cflgs
argument_list|,
name|sflgs
argument_list|,
operator|&
name|softc
operator|->
name|saved_ccb
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * Handle filemark, end of tape, mismatched record sizes.... 	 * From this point out, we're only handling read/write cases. 	 * Handle writes&& reads differently. 	 */
if|if
condition|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
operator|==
name|SA_WRITE
condition|)
block|{
if|if
condition|(
name|sense_key
operator|==
name|SSD_KEY_VOLUME_OVERFLOW
condition|)
block|{
name|csio
operator|->
name|resid
operator|=
name|resid
expr_stmt|;
name|error
operator|=
name|ENOSPC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|stream_valid
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|stream_bits
operator|&
name|SSD_EOM
operator|)
condition|)
block|{
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_EOM_PENDING
expr_stmt|;
comment|/* 			 * Grotesque as it seems, the few times 			 * I've actually seen a non-zero resid, 			 * the tape drive actually lied and had 			 * written all the data!. 			 */
name|csio
operator|->
name|resid
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|csio
operator|->
name|resid
operator|=
name|resid
expr_stmt|;
if|if
condition|(
name|sense_key
operator|==
name|SSD_KEY_BLANK_CHECK
condition|)
block|{
if|if
condition|(
name|softc
operator|->
name|quirks
operator|&
name|SA_QUIRK_1FM
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_EOM_PENDING
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|EIO
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|stream_valid
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|stream_bits
operator|&
name|SSD_FILEMARK
operator|)
condition|)
block|{
if|if
condition|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_FIXED
condition|)
block|{
name|error
operator|=
operator|-
literal|1
expr_stmt|;
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_EOF_PENDING
expr_stmt|;
block|}
comment|/* 			 * Unconditionally, if we detected a filemark on a read, 			 * mark that we've run moved a file ahead. 			 */
if|if
condition|(
name|softc
operator|->
name|fileno
operator|!=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
condition|)
block|{
name|softc
operator|->
name|fileno
operator|++
expr_stmt|;
name|softc
operator|->
name|blkno
operator|=
literal|0
expr_stmt|;
name|csio
operator|->
name|ccb_h
operator|.
name|ccb_pflags
operator||=
name|SA_POSITION_UPDATED
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Incorrect Length usually applies to read, but can apply to writes. 	 */
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|(
name|stream_valid
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|stream_bits
operator|&
name|SSD_ILI
operator|)
condition|)
block|{
if|if
condition|(
name|info
operator|<
literal|0
condition|)
block|{
name|xpt_print
argument_list|(
name|csio
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|toobig
argument_list|,
name|csio
operator|->
name|dxfer_len
operator|-
name|info
argument_list|)
expr_stmt|;
name|csio
operator|->
name|resid
operator|=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
block|}
else|else
block|{
name|csio
operator|->
name|resid
operator|=
name|resid
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_FIXED
condition|)
block|{
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_EIO_PENDING
expr_stmt|;
block|}
comment|/* 			 * Bump the block number if we hadn't seen a filemark. 			 * Do this independent of errors (we've moved anyway). 			 */
if|if
condition|(
operator|(
name|stream_valid
operator|==
literal|0
operator|)
operator|||
operator|(
name|stream_bits
operator|&
name|SSD_FILEMARK
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|softc
operator|->
name|blkno
operator|!=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
condition|)
block|{
name|softc
operator|->
name|blkno
operator|++
expr_stmt|;
name|csio
operator|->
name|ccb_h
operator|.
name|ccb_pflags
operator||=
name|SA_POSITION_UPDATED
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|error
operator|<=
literal|0
condition|)
block|{
comment|/* 		 * Unfreeze the queue if frozen as we're not returning anything 		 * to our waiters that would indicate an I/O error has occurred 		 * (yet). 		 */
name|QFRLS
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sagetparams
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|sa_params
name|params_to_get
parameter_list|,
name|u_int32_t
modifier|*
name|blocksize
parameter_list|,
name|u_int8_t
modifier|*
name|density
parameter_list|,
name|u_int32_t
modifier|*
name|numblocks
parameter_list|,
name|int
modifier|*
name|buff_mode
parameter_list|,
name|u_int8_t
modifier|*
name|write_protect
parameter_list|,
name|u_int8_t
modifier|*
name|speed
parameter_list|,
name|int
modifier|*
name|comp_supported
parameter_list|,
name|int
modifier|*
name|comp_enabled
parameter_list|,
name|u_int32_t
modifier|*
name|comp_algorithm
parameter_list|,
name|sa_comp_t
modifier|*
name|tcs
parameter_list|,
name|struct
name|scsi_control_data_prot_subpage
modifier|*
name|prot_page
parameter_list|,
name|int
name|dp_size
parameter_list|,
name|int
name|prot_changeable
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|void
modifier|*
name|mode_buffer
decl_stmt|;
name|struct
name|scsi_mode_header_6
modifier|*
name|mode_hdr
decl_stmt|;
name|struct
name|scsi_mode_blk_desc
modifier|*
name|mode_blk
decl_stmt|;
name|int
name|mode_buffer_len
decl_stmt|;
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|u_int8_t
name|cpage
decl_stmt|;
name|int
name|error
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|quirks
operator|&
name|SA_QUIRK_NO_CPAGE
condition|)
name|cpage
operator|=
name|SA_DEVICE_CONFIGURATION_PAGE
expr_stmt|;
else|else
name|cpage
operator|=
name|SA_DATA_COMPRESSION_PAGE
expr_stmt|;
name|retry
label|:
name|mode_buffer_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|mode_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|mode_blk
argument_list|)
expr_stmt|;
if|if
condition|(
name|params_to_get
operator|&
name|SA_PARAM_COMPRESSION
condition|)
block|{
if|if
condition|(
name|softc
operator|->
name|quirks
operator|&
name|SA_QUIRK_NOCOMP
condition|)
block|{
operator|*
name|comp_supported
operator|=
name|FALSE
expr_stmt|;
name|params_to_get
operator|&=
operator|~
name|SA_PARAM_COMPRESSION
expr_stmt|;
block|}
else|else
name|mode_buffer_len
operator|+=
sizeof|sizeof
argument_list|(
name|sa_comp_t
argument_list|)
expr_stmt|;
block|}
comment|/* XXX Fix M_NOWAIT */
name|mode_buffer
operator|=
name|malloc
argument_list|(
name|mode_buffer_len
argument_list|,
name|M_SCSISA
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode_buffer
operator|==
name|NULL
condition|)
block|{
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|mode_hdr
operator|=
operator|(
expr|struct
name|scsi_mode_header_6
operator|*
operator|)
name|mode_buffer
expr_stmt|;
name|mode_blk
operator|=
operator|(
expr|struct
name|scsi_mode_blk_desc
operator|*
operator|)
operator|&
name|mode_hdr
index|[
literal|1
index|]
expr_stmt|;
comment|/* it is safe to retry this */
name|scsi_mode_sense
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
literal|5
argument_list|,
name|sadone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|FALSE
argument_list|,
name|SMS_PAGE_CTRL_CURRENT
argument_list|,
operator|(
name|params_to_get
operator|&
name|SA_PARAM_COMPRESSION
operator|)
condition|?
name|cpage
else|:
name|SMS_VENDOR_SPECIFIC_PAGE
argument_list|,
name|mode_buffer
argument_list|,
name|mode_buffer_len
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
name|SCSIOP_TIMEOUT
argument_list|)
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
literal|0
argument_list|,
name|SF_NO_PRINT
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
name|status
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINVAL
operator|&&
operator|(
name|params_to_get
operator|&
name|SA_PARAM_COMPRESSION
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Hmm. Let's see if we can try another page... 		 * If we've already done that, give up on compression 		 * for this device and remember this for the future 		 * and attempt the request without asking for compression 		 * info. 		 */
if|if
condition|(
name|cpage
operator|==
name|SA_DATA_COMPRESSION_PAGE
condition|)
block|{
name|cpage
operator|=
name|SA_DEVICE_CONFIGURATION_PAGE
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|softc
operator|->
name|quirks
operator||=
name|SA_QUIRK_NOCOMP
expr_stmt|;
name|free
argument_list|(
name|mode_buffer
argument_list|,
name|M_SCSISA
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|CAM_SCSI_STATUS_ERROR
condition|)
block|{
comment|/* Tell the user about the fatal error. */
name|scsi_sense_print
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|)
expr_stmt|;
goto|goto
name|sagetparamsexit
goto|;
block|}
comment|/* 	 * If the user only wants the compression information, and 	 * the device doesn't send back the block descriptor, it's 	 * no big deal.  If the user wants more than just 	 * compression, though, and the device doesn't pass back the 	 * block descriptor, we need to send another mode sense to 	 * get the block descriptor. 	 */
if|if
condition|(
operator|(
name|mode_hdr
operator|->
name|blk_desc_len
operator|==
literal|0
operator|)
operator|&&
operator|(
name|params_to_get
operator|&
name|SA_PARAM_COMPRESSION
operator|)
operator|&&
operator|(
name|params_to_get
operator|&
operator|~
operator|(
name|SA_PARAM_COMPRESSION
operator|)
operator|)
condition|)
block|{
comment|/* 		 * Decrease the mode buffer length by the size of 		 * the compression page, to make sure the data 		 * there doesn't get overwritten. 		 */
name|mode_buffer_len
operator|-=
sizeof|sizeof
argument_list|(
name|sa_comp_t
argument_list|)
expr_stmt|;
comment|/* 		 * Now move the compression page that we presumably 		 * got back down the memory chunk a little bit so 		 * it doesn't get spammed. 		 */
name|bcopy
argument_list|(
operator|&
name|mode_hdr
index|[
literal|0
index|]
argument_list|,
operator|&
name|mode_hdr
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|sa_comp_t
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|mode_hdr
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|mode_hdr
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Now, we issue another mode sense and just ask 		 * for the block descriptor, etc. 		 */
name|scsi_mode_sense
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
literal|2
argument_list|,
name|sadone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|FALSE
argument_list|,
name|SMS_PAGE_CTRL_CURRENT
argument_list|,
name|SMS_VENDOR_SPECIFIC_PAGE
argument_list|,
name|mode_buffer
argument_list|,
name|mode_buffer_len
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
name|SCSIOP_TIMEOUT
argument_list|)
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
literal|0
argument_list|,
name|SF_NO_PRINT
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|sagetparamsexit
goto|;
block|}
if|if
condition|(
name|params_to_get
operator|&
name|SA_PARAM_BLOCKSIZE
condition|)
operator|*
name|blocksize
operator|=
name|scsi_3btoul
argument_list|(
name|mode_blk
operator|->
name|blklen
argument_list|)
expr_stmt|;
if|if
condition|(
name|params_to_get
operator|&
name|SA_PARAM_NUMBLOCKS
condition|)
operator|*
name|numblocks
operator|=
name|scsi_3btoul
argument_list|(
name|mode_blk
operator|->
name|nblocks
argument_list|)
expr_stmt|;
if|if
condition|(
name|params_to_get
operator|&
name|SA_PARAM_BUFF_MODE
condition|)
operator|*
name|buff_mode
operator|=
name|mode_hdr
operator|->
name|dev_spec
operator|&
name|SMH_SA_BUF_MODE_MASK
expr_stmt|;
if|if
condition|(
name|params_to_get
operator|&
name|SA_PARAM_DENSITY
condition|)
operator|*
name|density
operator|=
name|mode_blk
operator|->
name|density
expr_stmt|;
if|if
condition|(
name|params_to_get
operator|&
name|SA_PARAM_WP
condition|)
operator|*
name|write_protect
operator|=
operator|(
name|mode_hdr
operator|->
name|dev_spec
operator|&
name|SMH_SA_WP
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
if|if
condition|(
name|params_to_get
operator|&
name|SA_PARAM_SPEED
condition|)
operator|*
name|speed
operator|=
name|mode_hdr
operator|->
name|dev_spec
operator|&
name|SMH_SA_SPEED_MASK
expr_stmt|;
if|if
condition|(
name|params_to_get
operator|&
name|SA_PARAM_COMPRESSION
condition|)
block|{
name|sa_comp_t
modifier|*
name|ntcs
init|=
operator|(
name|sa_comp_t
operator|*
operator|)
operator|&
name|mode_blk
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|cpage
operator|==
name|SA_DATA_COMPRESSION_PAGE
condition|)
block|{
name|struct
name|scsi_data_compression_page
modifier|*
name|cp
init|=
operator|&
name|ntcs
operator|->
name|dcomp
decl_stmt|;
operator|*
name|comp_supported
operator|=
operator|(
name|cp
operator|->
name|dce_and_dcc
operator|&
name|SA_DCP_DCC
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
operator|*
name|comp_enabled
operator|=
operator|(
name|cp
operator|->
name|dce_and_dcc
operator|&
name|SA_DCP_DCE
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
operator|*
name|comp_algorithm
operator|=
name|scsi_4btoul
argument_list|(
name|cp
operator|->
name|comp_algorithm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|scsi_dev_conf_page
modifier|*
name|cp
init|=
operator|&
name|ntcs
operator|->
name|dconf
decl_stmt|;
comment|/* 			 * We don't really know whether this device supports 			 * Data Compression if the algorithm field is 			 * zero. Just say we do. 			 */
operator|*
name|comp_supported
operator|=
name|TRUE
expr_stmt|;
operator|*
name|comp_enabled
operator|=
operator|(
name|cp
operator|->
name|sel_comp_alg
operator|!=
name|SA_COMP_NONE
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
operator|*
name|comp_algorithm
operator|=
name|cp
operator|->
name|sel_comp_alg
expr_stmt|;
block|}
if|if
condition|(
name|tcs
operator|!=
name|NULL
condition|)
name|bcopy
argument_list|(
name|ntcs
argument_list|,
name|tcs
argument_list|,
sizeof|sizeof
argument_list|(
name|sa_comp_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|params_to_get
operator|&
name|SA_PARAM_DENSITY_EXT
operator|)
operator|&&
operator|(
name|softc
operator|->
name|scsi_rev
operator|>=
name|SCSI_REV_SPC
operator|)
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SA_DENSITY_TYPES
condition|;
name|i
operator|++
control|)
block|{
name|scsi_report_density_support
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/*retries*/
literal|1
argument_list|,
comment|/*cbfcnp*/
name|sadone
argument_list|,
comment|/*tag_action*/
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*media*/
name|softc
operator|->
name|density_type_bits
index|[
name|i
index|]
operator|&
name|SRDS_MEDIA
argument_list|,
comment|/*medium_type*/
name|softc
operator|->
name|density_type_bits
index|[
name|i
index|]
operator|&
name|SRDS_MEDIUM_TYPE
argument_list|,
comment|/*data_ptr*/
name|softc
operator|->
name|density_info
index|[
name|i
index|]
argument_list|,
comment|/*length*/
sizeof|sizeof
argument_list|(
name|softc
operator|->
name|density_info
index|[
name|i
index|]
argument_list|)
argument_list|,
comment|/*sense_len*/
name|SSD_FULL_SIZE
argument_list|,
comment|/*timeout*/
name|REP_DENSITY_TIMEOUT
argument_list|)
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
literal|0
argument_list|,
name|SF_NO_PRINT
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
name|status
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
expr_stmt|;
comment|/* 			 * Some tape drives won't support this command at 			 * all, but hopefully we'll minimize that with the 			 * check for SPC or greater support above.  If they 			 * don't support the default report (neither the 			 * MEDIA or MEDIUM_TYPE bits set), then there is 			 * really no point in continuing on to look for 			 * other reports. 			 */
if|if
condition|(
operator|(
name|error
operator|!=
literal|0
operator|)
operator|||
operator|(
name|status
operator|!=
name|CAM_REQ_CMP
operator|)
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
name|softc
operator|->
name|density_info_valid
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|density_type_bits
index|[
name|i
index|]
operator|==
literal|0
condition|)
break|break;
else|else
continue|continue;
block|}
name|softc
operator|->
name|density_info_valid
index|[
name|i
index|]
operator|=
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
operator|-
name|ccb
operator|->
name|csio
operator|.
name|resid
expr_stmt|;
block|}
block|}
comment|/* 	 * Get logical block protection parameters if the drive supports it. 	 */
if|if
condition|(
operator|(
name|params_to_get
operator|&
name|SA_PARAM_LBP
operator|)
operator|&&
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_PROTECT_SUPP
operator|)
condition|)
block|{
name|struct
name|scsi_mode_header_10
modifier|*
name|mode10_hdr
decl_stmt|;
name|struct
name|scsi_control_data_prot_subpage
modifier|*
name|dp_page
decl_stmt|;
name|struct
name|scsi_mode_sense_10
modifier|*
name|cdb
decl_stmt|;
name|struct
name|sa_prot_state
modifier|*
name|prot
decl_stmt|;
name|int
name|dp_len
decl_stmt|,
name|returned_len
decl_stmt|;
if|if
condition|(
name|dp_size
operator|==
literal|0
condition|)
name|dp_size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|dp_page
argument_list|)
expr_stmt|;
name|dp_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|mode10_hdr
argument_list|)
operator|+
name|dp_size
expr_stmt|;
name|mode10_hdr
operator|=
name|malloc
argument_list|(
name|dp_len
argument_list|,
name|M_SCSISA
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode10_hdr
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|sagetparamsexit
goto|;
block|}
name|scsi_mode_sense_len
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/*retries*/
literal|5
argument_list|,
comment|/*cbfcnp*/
name|sadone
argument_list|,
comment|/*tag_action*/
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*dbd*/
name|TRUE
argument_list|,
comment|/*page_code*/
operator|(
name|prot_changeable
operator|==
literal|0
operator|)
condition|?
name|SMS_PAGE_CTRL_CURRENT
else|:
name|SMS_PAGE_CTRL_CHANGEABLE
argument_list|,
comment|/*page*/
name|SMS_CONTROL_MODE_PAGE
argument_list|,
comment|/*param_buf*/
operator|(
name|uint8_t
operator|*
operator|)
name|mode10_hdr
argument_list|,
comment|/*param_len*/
name|dp_len
argument_list|,
comment|/*minimum_cmd_size*/
literal|10
argument_list|,
comment|/*sense_len*/
name|SSD_FULL_SIZE
argument_list|,
comment|/*timeout*/
name|SCSIOP_TIMEOUT
argument_list|)
expr_stmt|;
comment|/* 		 * XXX KDM we need to be able to set the subpage in the 		 * fill function. 		 */
name|cdb
operator|=
operator|(
expr|struct
name|scsi_mode_sense_10
operator|*
operator|)
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|cdb
operator|->
name|subpage
operator|=
name|SA_CTRL_DP_SUBPAGE_CODE
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
literal|0
argument_list|,
name|SF_NO_PRINT
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|mode10_hdr
argument_list|,
name|M_SCSISA
argument_list|)
expr_stmt|;
goto|goto
name|sagetparamsexit
goto|;
block|}
name|status
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
name|free
argument_list|(
name|mode10_hdr
argument_list|,
name|M_SCSISA
argument_list|)
expr_stmt|;
goto|goto
name|sagetparamsexit
goto|;
block|}
comment|/* 		 * The returned data length at least has to be long enough 		 * for us to look at length in the mode page header. 		 */
name|returned_len
operator|=
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
operator|-
name|ccb
operator|->
name|csio
operator|.
name|resid
expr_stmt|;
if|if
condition|(
name|returned_len
operator|<
sizeof|sizeof
argument_list|(
name|mode10_hdr
operator|->
name|data_length
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
name|free
argument_list|(
name|mode10_hdr
argument_list|,
name|M_SCSISA
argument_list|)
expr_stmt|;
goto|goto
name|sagetparamsexit
goto|;
block|}
name|returned_len
operator|=
name|min
argument_list|(
name|returned_len
argument_list|,
sizeof|sizeof
argument_list|(
name|mode10_hdr
operator|->
name|data_length
argument_list|)
operator|+
name|scsi_2btoul
argument_list|(
name|mode10_hdr
operator|->
name|data_length
argument_list|)
argument_list|)
expr_stmt|;
name|dp_page
operator|=
operator|(
expr|struct
name|scsi_control_data_prot_subpage
operator|*
operator|)
operator|&
name|mode10_hdr
index|[
literal|1
index|]
expr_stmt|;
comment|/* 		 * We also have to have enough data to include the prot_bits 		 * in the subpage. 		 */
if|if
condition|(
name|returned_len
operator|<
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|mode10_hdr
argument_list|)
operator|+
name|__offsetof
argument_list|(
expr|struct
name|scsi_control_data_prot_subpage
argument_list|,
name|prot_bits
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|dp_page
operator|->
name|prot_bits
argument_list|)
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
name|free
argument_list|(
name|mode10_hdr
argument_list|,
name|M_SCSISA
argument_list|)
expr_stmt|;
goto|goto
name|sagetparamsexit
goto|;
block|}
name|prot
operator|=
operator|&
name|softc
operator|->
name|prot_info
operator|.
name|cur_prot_state
expr_stmt|;
name|prot
operator|->
name|prot_method
operator|=
name|dp_page
operator|->
name|prot_method
expr_stmt|;
name|prot
operator|->
name|pi_length
operator|=
name|dp_page
operator|->
name|pi_length
operator|&
name|SA_CTRL_DP_PI_LENGTH_MASK
expr_stmt|;
name|prot
operator|->
name|lbp_w
operator|=
operator|(
name|dp_page
operator|->
name|prot_bits
operator|&
name|SA_CTRL_DP_LBP_W
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|prot
operator|->
name|lbp_r
operator|=
operator|(
name|dp_page
operator|->
name|prot_bits
operator|&
name|SA_CTRL_DP_LBP_R
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|prot
operator|->
name|rbdp
operator|=
operator|(
name|dp_page
operator|->
name|prot_bits
operator|&
name|SA_CTRL_DP_RBDP
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|prot
operator|->
name|initialized
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|prot_page
operator|!=
name|NULL
condition|)
name|bcopy
argument_list|(
name|dp_page
argument_list|,
name|prot_page
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|prot_page
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dp_page
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mode10_hdr
argument_list|,
name|M_SCSISA
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CAM_DEBUGGED
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_INFO
argument_list|)
condition|)
block|{
name|int
name|idx
decl_stmt|;
name|char
modifier|*
name|xyz
init|=
name|mode_buffer
decl_stmt|;
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Mode Sense Data="
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|mode_buffer_len
condition|;
name|idx
operator|++
control|)
name|printf
argument_list|(
literal|" 0x%02x"
argument_list|,
name|xyz
index|[
name|idx
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|sagetparamsexit
label|:
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mode_buffer
argument_list|,
name|M_SCSISA
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set protection information to the pending protection information stored  * in the softc.  */
end_comment

begin_function
specifier|static
name|int
name|sasetprot
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|sa_prot_state
modifier|*
name|new_prot
parameter_list|)
block|{
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|scsi_control_data_prot_subpage
modifier|*
name|dp_page
decl_stmt|,
modifier|*
name|dp_changeable
decl_stmt|;
name|struct
name|scsi_mode_header_10
modifier|*
name|mode10_hdr
decl_stmt|,
modifier|*
name|mode10_changeable
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|uint8_t
name|current_speed
decl_stmt|;
name|size_t
name|dp_size
decl_stmt|,
name|dp_page_length
decl_stmt|;
name|int
name|dp_len
decl_stmt|,
name|buff_mode
decl_stmt|;
name|int
name|error
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|mode10_hdr
operator|=
name|NULL
expr_stmt|;
name|mode10_changeable
operator|=
name|NULL
expr_stmt|;
name|ccb
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Start off with the size set to the actual length of the page 	 * that we have defined. 	 */
name|dp_size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|dp_changeable
argument_list|)
expr_stmt|;
name|dp_page_length
operator|=
name|dp_size
operator|-
name|__offsetof
argument_list|(
expr|struct
name|scsi_control_data_prot_subpage
argument_list|,
name|prot_method
argument_list|)
expr_stmt|;
name|retry_length
label|:
name|dp_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|mode10_changeable
argument_list|)
operator|+
name|dp_size
expr_stmt|;
name|mode10_changeable
operator|=
name|malloc
argument_list|(
name|dp_len
argument_list|,
name|M_SCSISA
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode10_changeable
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|dp_changeable
operator|=
operator|(
expr|struct
name|scsi_control_data_prot_subpage
operator|*
operator|)
operator|&
name|mode10_changeable
index|[
literal|1
index|]
expr_stmt|;
comment|/* 	 * First get the data protection page changeable parameters mask. 	 * We need to know which parameters the drive supports changing. 	 * We also need to know what the drive claims that its page length 	 * is.  The reason is that IBM drives in particular are very picky 	 * about the page length.  They want it (the length set in the 	 * page structure itself) to be 28 bytes, and they want the 	 * parameter list length specified in the mode select header to be 	 * 40 bytes.  So, to work with IBM drives as well as any other tape 	 * drive, find out what the drive claims the page length is, and 	 * make sure that we match that. 	 */
name|error
operator|=
name|sagetparams
argument_list|(
name|periph
argument_list|,
name|SA_PARAM_SPEED
operator||
name|SA_PARAM_LBP
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|buff_mode
argument_list|,
name|NULL
argument_list|,
operator|&
name|current_speed
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|dp_changeable
argument_list|,
name|dp_size
argument_list|,
comment|/*prot_changeable*/
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|bailout
goto|;
if|if
condition|(
name|scsi_2btoul
argument_list|(
name|dp_changeable
operator|->
name|length
argument_list|)
operator|>
name|dp_page_length
condition|)
block|{
name|dp_page_length
operator|=
name|scsi_2btoul
argument_list|(
name|dp_changeable
operator|->
name|length
argument_list|)
expr_stmt|;
name|dp_size
operator|=
name|dp_page_length
operator|+
name|__offsetof
argument_list|(
expr|struct
name|scsi_control_data_prot_subpage
argument_list|,
name|prot_method
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mode10_changeable
argument_list|,
name|M_SCSISA
argument_list|)
expr_stmt|;
name|mode10_changeable
operator|=
name|NULL
expr_stmt|;
goto|goto
name|retry_length
goto|;
block|}
name|mode10_hdr
operator|=
name|malloc
argument_list|(
name|dp_len
argument_list|,
name|M_SCSISA
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode10_hdr
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|dp_page
operator|=
operator|(
expr|struct
name|scsi_control_data_prot_subpage
operator|*
operator|)
operator|&
name|mode10_hdr
index|[
literal|1
index|]
expr_stmt|;
comment|/* 	 * Now grab the actual current settings in the page. 	 */
name|error
operator|=
name|sagetparams
argument_list|(
name|periph
argument_list|,
name|SA_PARAM_SPEED
operator||
name|SA_PARAM_LBP
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|buff_mode
argument_list|,
name|NULL
argument_list|,
operator|&
name|current_speed
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|dp_page
argument_list|,
name|dp_size
argument_list|,
comment|/*prot_changeable*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|bailout
goto|;
comment|/* These two fields need to be 0 for MODE SELECT */
name|scsi_ulto2b
argument_list|(
literal|0
argument_list|,
name|mode10_hdr
operator|->
name|data_length
argument_list|)
expr_stmt|;
name|mode10_hdr
operator|->
name|medium_type
operator|=
literal|0
expr_stmt|;
comment|/* We are not including a block descriptor */
name|scsi_ulto2b
argument_list|(
literal|0
argument_list|,
name|mode10_hdr
operator|->
name|blk_desc_len
argument_list|)
expr_stmt|;
name|mode10_hdr
operator|->
name|dev_spec
operator|=
name|current_speed
expr_stmt|;
comment|/* if set, set single-initiator buffering mode */
if|if
condition|(
name|softc
operator|->
name|buffer_mode
operator|==
name|SMH_SA_BUF_MODE_SIBUF
condition|)
block|{
name|mode10_hdr
operator|->
name|dev_spec
operator||=
name|SMH_SA_BUF_MODE_SIBUF
expr_stmt|;
block|}
comment|/* 	 * For each field, make sure that the drive allows changing it 	 * before bringing in the user's setting. 	 */
if|if
condition|(
name|dp_changeable
operator|->
name|prot_method
operator|!=
literal|0
condition|)
name|dp_page
operator|->
name|prot_method
operator|=
name|new_prot
operator|->
name|prot_method
expr_stmt|;
if|if
condition|(
name|dp_changeable
operator|->
name|pi_length
operator|&
name|SA_CTRL_DP_PI_LENGTH_MASK
condition|)
block|{
name|dp_page
operator|->
name|pi_length
operator|&=
operator|~
name|SA_CTRL_DP_PI_LENGTH_MASK
expr_stmt|;
name|dp_page
operator|->
name|pi_length
operator||=
operator|(
name|new_prot
operator|->
name|pi_length
operator|&
name|SA_CTRL_DP_PI_LENGTH_MASK
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|dp_changeable
operator|->
name|prot_bits
operator|&
name|SA_CTRL_DP_LBP_W
condition|)
block|{
if|if
condition|(
name|new_prot
operator|->
name|lbp_w
condition|)
name|dp_page
operator|->
name|prot_bits
operator||=
name|SA_CTRL_DP_LBP_W
expr_stmt|;
else|else
name|dp_page
operator|->
name|prot_bits
operator|&=
operator|~
name|SA_CTRL_DP_LBP_W
expr_stmt|;
block|}
if|if
condition|(
name|dp_changeable
operator|->
name|prot_bits
operator|&
name|SA_CTRL_DP_LBP_R
condition|)
block|{
if|if
condition|(
name|new_prot
operator|->
name|lbp_r
condition|)
name|dp_page
operator|->
name|prot_bits
operator||=
name|SA_CTRL_DP_LBP_R
expr_stmt|;
else|else
name|dp_page
operator|->
name|prot_bits
operator|&=
operator|~
name|SA_CTRL_DP_LBP_R
expr_stmt|;
block|}
if|if
condition|(
name|dp_changeable
operator|->
name|prot_bits
operator|&
name|SA_CTRL_DP_RBDP
condition|)
block|{
if|if
condition|(
name|new_prot
operator|->
name|rbdp
condition|)
name|dp_page
operator|->
name|prot_bits
operator||=
name|SA_CTRL_DP_RBDP
expr_stmt|;
else|else
name|dp_page
operator|->
name|prot_bits
operator|&=
operator|~
name|SA_CTRL_DP_RBDP
expr_stmt|;
block|}
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|scsi_mode_select_len
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/*retries*/
literal|5
argument_list|,
comment|/*cbfcnp*/
name|sadone
argument_list|,
comment|/*tag_action*/
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*scsi_page_fmt*/
name|TRUE
argument_list|,
comment|/*save_pages*/
name|FALSE
argument_list|,
comment|/*param_buf*/
operator|(
name|uint8_t
operator|*
operator|)
name|mode10_hdr
argument_list|,
comment|/*param_len*/
name|dp_len
argument_list|,
comment|/*minimum_cmd_size*/
literal|10
argument_list|,
comment|/*sense_len*/
name|SSD_FULL_SIZE
argument_list|,
comment|/*timeout*/
name|SCSIOP_TIMEOUT
argument_list|)
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|bailout
goto|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
comment|/* 	 * The operation was successful.  We could just copy the settings 	 * the user requested, but just in case the drive ignored some of 	 * our settings, let's ask for status again. 	 */
name|error
operator|=
name|sagetparams
argument_list|(
name|periph
argument_list|,
name|SA_PARAM_SPEED
operator||
name|SA_PARAM_LBP
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|buff_mode
argument_list|,
name|NULL
argument_list|,
operator|&
name|current_speed
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|dp_page
argument_list|,
name|dp_size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bailout
label|:
if|if
condition|(
name|ccb
operator|!=
name|NULL
condition|)
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mode10_hdr
argument_list|,
name|M_SCSISA
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mode10_changeable
argument_list|,
name|M_SCSISA
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The purpose of this function is to set one of four different parameters  * for a tape drive:  *	- blocksize  *	- density  *	- compression / compression algorithm  *	- buffering mode  *  * The assumption is that this will be called from saioctl(), and therefore  * from a process context.  Thus the waiting malloc calls below.  If that  * assumption ever changes, the malloc calls should be changed to be  * NOWAIT mallocs.  *  * Any or all of the four parameters may be set when this function is  * called.  It should handle setting more than one parameter at once.  */
end_comment

begin_function
specifier|static
name|int
name|sasetparams
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|sa_params
name|params_to_set
parameter_list|,
name|u_int32_t
name|blocksize
parameter_list|,
name|u_int8_t
name|density
parameter_list|,
name|u_int32_t
name|calg
parameter_list|,
name|u_int32_t
name|sense_flags
parameter_list|)
block|{
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|u_int32_t
name|current_blocksize
decl_stmt|;
name|u_int32_t
name|current_calg
decl_stmt|;
name|u_int8_t
name|current_density
decl_stmt|;
name|u_int8_t
name|current_speed
decl_stmt|;
name|int
name|comp_enabled
decl_stmt|,
name|comp_supported
decl_stmt|;
name|void
modifier|*
name|mode_buffer
decl_stmt|;
name|int
name|mode_buffer_len
decl_stmt|;
name|struct
name|scsi_mode_header_6
modifier|*
name|mode_hdr
decl_stmt|;
name|struct
name|scsi_mode_blk_desc
modifier|*
name|mode_blk
decl_stmt|;
name|sa_comp_t
modifier|*
name|ccomp
decl_stmt|,
modifier|*
name|cpage
decl_stmt|;
name|int
name|buff_mode
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|ccomp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|sa_comp_t
argument_list|)
argument_list|,
name|M_SCSISA
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccomp
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* 	 * Since it doesn't make sense to set the number of blocks, or 	 * write protection, we won't try to get the current value.  We 	 * always want to get the blocksize, so we can set it back to the 	 * proper value. 	 */
name|error
operator|=
name|sagetparams
argument_list|(
name|periph
argument_list|,
name|params_to_set
operator||
name|SA_PARAM_BLOCKSIZE
operator||
name|SA_PARAM_SPEED
argument_list|,
operator|&
name|current_blocksize
argument_list|,
operator|&
name|current_density
argument_list|,
name|NULL
argument_list|,
operator|&
name|buff_mode
argument_list|,
name|NULL
argument_list|,
operator|&
name|current_speed
argument_list|,
operator|&
name|comp_supported
argument_list|,
operator|&
name|comp_enabled
argument_list|,
operator|&
name|current_calg
argument_list|,
name|ccomp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|ccomp
argument_list|,
name|M_SCSISA
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|mode_buffer_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|mode_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|mode_blk
argument_list|)
expr_stmt|;
if|if
condition|(
name|params_to_set
operator|&
name|SA_PARAM_COMPRESSION
condition|)
name|mode_buffer_len
operator|+=
sizeof|sizeof
argument_list|(
name|sa_comp_t
argument_list|)
expr_stmt|;
name|mode_buffer
operator|=
name|malloc
argument_list|(
name|mode_buffer_len
argument_list|,
name|M_SCSISA
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode_buffer
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ccomp
argument_list|,
name|M_SCSISA
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|mode_hdr
operator|=
operator|(
expr|struct
name|scsi_mode_header_6
operator|*
operator|)
name|mode_buffer
expr_stmt|;
name|mode_blk
operator|=
operator|(
expr|struct
name|scsi_mode_blk_desc
operator|*
operator|)
operator|&
name|mode_hdr
index|[
literal|1
index|]
expr_stmt|;
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|retry
label|:
if|if
condition|(
name|params_to_set
operator|&
name|SA_PARAM_COMPRESSION
condition|)
block|{
if|if
condition|(
name|mode_blk
condition|)
block|{
name|cpage
operator|=
operator|(
name|sa_comp_t
operator|*
operator|)
operator|&
name|mode_blk
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|cpage
operator|=
operator|(
name|sa_comp_t
operator|*
operator|)
operator|&
name|mode_hdr
index|[
literal|1
index|]
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|ccomp
argument_list|,
name|cpage
argument_list|,
sizeof|sizeof
argument_list|(
name|sa_comp_t
argument_list|)
argument_list|)
expr_stmt|;
name|cpage
operator|->
name|hdr
operator|.
name|pagecode
operator|&=
operator|~
literal|0x80
expr_stmt|;
block|}
else|else
name|cpage
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * If the caller wants us to set the blocksize, use the one they 	 * pass in.  Otherwise, use the blocksize we got back from the 	 * mode select above. 	 */
if|if
condition|(
name|mode_blk
condition|)
block|{
if|if
condition|(
name|params_to_set
operator|&
name|SA_PARAM_BLOCKSIZE
condition|)
name|scsi_ulto3b
argument_list|(
name|blocksize
argument_list|,
name|mode_blk
operator|->
name|blklen
argument_list|)
expr_stmt|;
else|else
name|scsi_ulto3b
argument_list|(
name|current_blocksize
argument_list|,
name|mode_blk
operator|->
name|blklen
argument_list|)
expr_stmt|;
comment|/* 		 * Set density if requested, else preserve old density. 		 * SCSI_SAME_DENSITY only applies to SCSI-2 or better 		 * devices, else density we've latched up in our softc. 		 */
if|if
condition|(
name|params_to_set
operator|&
name|SA_PARAM_DENSITY
condition|)
block|{
name|mode_blk
operator|->
name|density
operator|=
name|density
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|softc
operator|->
name|scsi_rev
operator|>
name|SCSI_REV_CCS
condition|)
block|{
name|mode_blk
operator|->
name|density
operator|=
name|SCSI_SAME_DENSITY
expr_stmt|;
block|}
else|else
block|{
name|mode_blk
operator|->
name|density
operator|=
name|softc
operator|->
name|media_density
expr_stmt|;
block|}
block|}
comment|/* 	 * For mode selects, these two fields must be zero. 	 */
name|mode_hdr
operator|->
name|data_length
operator|=
literal|0
expr_stmt|;
name|mode_hdr
operator|->
name|medium_type
operator|=
literal|0
expr_stmt|;
comment|/* set the speed to the current value */
name|mode_hdr
operator|->
name|dev_spec
operator|=
name|current_speed
expr_stmt|;
comment|/* if set, set single-initiator buffering mode */
if|if
condition|(
name|softc
operator|->
name|buffer_mode
operator|==
name|SMH_SA_BUF_MODE_SIBUF
condition|)
block|{
name|mode_hdr
operator|->
name|dev_spec
operator||=
name|SMH_SA_BUF_MODE_SIBUF
expr_stmt|;
block|}
if|if
condition|(
name|mode_blk
condition|)
name|mode_hdr
operator|->
name|blk_desc_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_mode_blk_desc
argument_list|)
expr_stmt|;
else|else
name|mode_hdr
operator|->
name|blk_desc_len
operator|=
literal|0
expr_stmt|;
comment|/* 	 * First, if the user wants us to set the compression algorithm or 	 * just turn compression on, check to make sure that this drive 	 * supports compression. 	 */
if|if
condition|(
name|params_to_set
operator|&
name|SA_PARAM_COMPRESSION
condition|)
block|{
comment|/* 		 * If the compression algorithm is 0, disable compression. 		 * If the compression algorithm is non-zero, enable 		 * compression and set the compression type to the 		 * specified compression algorithm, unless the algorithm is 		 * MT_COMP_ENABLE.  In that case, we look at the 		 * compression algorithm that is currently set and if it is 		 * non-zero, we leave it as-is.  If it is zero, and we have 		 * saved a compression algorithm from a time when 		 * compression was enabled before, set the compression to 		 * the saved value. 		 */
switch|switch
condition|(
name|ccomp
operator|->
name|hdr
operator|.
name|pagecode
operator|&
operator|~
literal|0x80
condition|)
block|{
case|case
name|SA_DEVICE_CONFIGURATION_PAGE
case|:
block|{
name|struct
name|scsi_dev_conf_page
modifier|*
name|dcp
init|=
operator|&
name|cpage
operator|->
name|dconf
decl_stmt|;
if|if
condition|(
name|calg
operator|==
literal|0
condition|)
block|{
name|dcp
operator|->
name|sel_comp_alg
operator|=
name|SA_COMP_NONE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|calg
operator|!=
name|MT_COMP_ENABLE
condition|)
block|{
name|dcp
operator|->
name|sel_comp_alg
operator|=
name|calg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dcp
operator|->
name|sel_comp_alg
operator|==
name|SA_COMP_NONE
operator|&&
name|softc
operator|->
name|saved_comp_algorithm
operator|!=
literal|0
condition|)
block|{
name|dcp
operator|->
name|sel_comp_alg
operator|=
name|softc
operator|->
name|saved_comp_algorithm
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SA_DATA_COMPRESSION_PAGE
case|:
if|if
condition|(
name|ccomp
operator|->
name|dcomp
operator|.
name|dce_and_dcc
operator|&
name|SA_DCP_DCC
condition|)
block|{
name|struct
name|scsi_data_compression_page
modifier|*
name|dcp
init|=
operator|&
name|cpage
operator|->
name|dcomp
decl_stmt|;
if|if
condition|(
name|calg
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Disable compression, but leave the 				 * decompression and the capability bit 				 * alone. 				 */
name|dcp
operator|->
name|dce_and_dcc
operator|=
name|SA_DCP_DCC
expr_stmt|;
name|dcp
operator|->
name|dde_and_red
operator||=
name|SA_DCP_DDE
expr_stmt|;
break|break;
block|}
comment|/* enable compression&& decompression */
name|dcp
operator|->
name|dce_and_dcc
operator|=
name|SA_DCP_DCE
operator||
name|SA_DCP_DCC
expr_stmt|;
name|dcp
operator|->
name|dde_and_red
operator||=
name|SA_DCP_DDE
expr_stmt|;
comment|/* 			 * If there, use compression algorithm from caller. 			 * Otherwise, if there's a saved compression algorithm 			 * and there is no current algorithm, use the saved 			 * algorithm. Else parrot back what we got and hope 			 * for the best. 			 */
if|if
condition|(
name|calg
operator|!=
name|MT_COMP_ENABLE
condition|)
block|{
name|scsi_ulto4b
argument_list|(
name|calg
argument_list|,
name|dcp
operator|->
name|comp_algorithm
argument_list|)
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|calg
argument_list|,
name|dcp
operator|->
name|decomp_algorithm
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scsi_4btoul
argument_list|(
name|dcp
operator|->
name|comp_algorithm
argument_list|)
operator|==
literal|0
operator|&&
name|softc
operator|->
name|saved_comp_algorithm
operator|!=
literal|0
condition|)
block|{
name|scsi_ulto4b
argument_list|(
name|softc
operator|->
name|saved_comp_algorithm
argument_list|,
name|dcp
operator|->
name|comp_algorithm
argument_list|)
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|softc
operator|->
name|saved_comp_algorithm
argument_list|,
name|dcp
operator|->
name|decomp_algorithm
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* 		 * Compression does not appear to be supported- 		 * at least via the DATA COMPRESSION page. It 		 * would be too much to ask us to believe that 		 * the page itself is supported, but incorrectly 		 * reports an ability to manipulate data compression, 		 * so we'll assume that this device doesn't support 		 * compression. We can just fall through for that. 		 */
comment|/* FALLTHROUGH */
default|default:
comment|/* 			 * The drive doesn't seem to support compression, 			 * so turn off the set compression bit. 			 */
name|params_to_set
operator|&=
operator|~
name|SA_PARAM_COMPRESSION
expr_stmt|;
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"device does not seem to support compression\n"
argument_list|)
expr_stmt|;
comment|/* 			 * If that was the only thing the user wanted us to set, 			 * clean up allocated resources and return with 			 * 'operation not supported'. 			 */
if|if
condition|(
name|params_to_set
operator|==
name|SA_PARAM_NONE
condition|)
block|{
name|free
argument_list|(
name|mode_buffer
argument_list|,
name|M_SCSISA
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
comment|/* 			 * That wasn't the only thing the user wanted us to set. 			 * So, decrease the stated mode buffer length by the 			 * size of the compression mode page. 			 */
name|mode_buffer_len
operator|-=
sizeof|sizeof
argument_list|(
name|sa_comp_t
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* It is safe to retry this operation */
name|scsi_mode_select
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
literal|5
argument_list|,
name|sadone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
operator|(
name|params_to_set
operator|&
name|SA_PARAM_COMPRESSION
operator|)
condition|?
name|TRUE
else|:
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|mode_buffer
argument_list|,
name|mode_buffer_len
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
name|SCSIOP_TIMEOUT
argument_list|)
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
literal|0
argument_list|,
name|sense_flags
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
if|if
condition|(
name|CAM_DEBUGGED
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_INFO
argument_list|)
condition|)
block|{
name|int
name|idx
decl_stmt|;
name|char
modifier|*
name|xyz
init|=
name|mode_buffer
decl_stmt|;
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Err%d, Mode Select Data="
argument_list|,
name|error
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|mode_buffer_len
condition|;
name|idx
operator|++
control|)
name|printf
argument_list|(
literal|" 0x%02x"
argument_list|,
name|xyz
index|[
name|idx
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
comment|/* 		 * If we can, try without setting density/blocksize. 		 */
if|if
condition|(
name|mode_blk
condition|)
block|{
if|if
condition|(
operator|(
name|params_to_set
operator|&
operator|(
name|SA_PARAM_DENSITY
operator||
name|SA_PARAM_BLOCKSIZE
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|mode_blk
operator|=
name|NULL
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
block|}
else|else
block|{
name|mode_blk
operator|=
operator|(
expr|struct
name|scsi_mode_blk_desc
operator|*
operator|)
operator|&
name|mode_hdr
index|[
literal|1
index|]
expr_stmt|;
name|cpage
operator|=
operator|(
name|sa_comp_t
operator|*
operator|)
operator|&
name|mode_blk
index|[
literal|1
index|]
expr_stmt|;
block|}
comment|/* 		 * If we were setting the blocksize, and that failed, we 		 * want to set it to its original value.  If we weren't 		 * setting the blocksize, we don't want to change it. 		 */
name|scsi_ulto3b
argument_list|(
name|current_blocksize
argument_list|,
name|mode_blk
operator|->
name|blklen
argument_list|)
expr_stmt|;
comment|/* 		 * Set density if requested, else preserve old density. 		 * SCSI_SAME_DENSITY only applies to SCSI-2 or better 		 * devices, else density we've latched up in our softc. 		 */
if|if
condition|(
name|params_to_set
operator|&
name|SA_PARAM_DENSITY
condition|)
block|{
name|mode_blk
operator|->
name|density
operator|=
name|current_density
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|softc
operator|->
name|scsi_rev
operator|>
name|SCSI_REV_CCS
condition|)
block|{
name|mode_blk
operator|->
name|density
operator|=
name|SCSI_SAME_DENSITY
expr_stmt|;
block|}
else|else
block|{
name|mode_blk
operator|->
name|density
operator|=
name|softc
operator|->
name|media_density
expr_stmt|;
block|}
if|if
condition|(
name|params_to_set
operator|&
name|SA_PARAM_COMPRESSION
condition|)
name|bcopy
argument_list|(
name|ccomp
argument_list|,
name|cpage
argument_list|,
sizeof|sizeof
argument_list|(
name|sa_comp_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * The retry count is the only CCB field that might have been 		 * changed that we care about, so reset it back to 1. 		 */
name|ccb
operator|->
name|ccb_h
operator|.
name|retry_count
operator|=
literal|1
expr_stmt|;
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
literal|0
argument_list|,
name|sense_flags
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
block|}
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccomp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ccomp
argument_list|,
name|M_SCSISA
argument_list|)
expr_stmt|;
if|if
condition|(
name|params_to_set
operator|&
name|SA_PARAM_COMPRESSION
condition|)
block|{
if|if
condition|(
name|error
condition|)
block|{
name|softc
operator|->
name|flags
operator|&=
operator|~
name|SA_FLAG_COMP_ENABLED
expr_stmt|;
comment|/* 			 * Even if we get an error setting compression, 			 * do not say that we don't support it. We could 			 * have been wrong, or it may be media specific. 			 *	softc->flags&= ~SA_FLAG_COMP_SUPP; 			 */
name|softc
operator|->
name|saved_comp_algorithm
operator|=
name|softc
operator|->
name|comp_algorithm
expr_stmt|;
name|softc
operator|->
name|comp_algorithm
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_COMP_ENABLED
expr_stmt|;
name|softc
operator|->
name|comp_algorithm
operator|=
name|calg
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|mode_buffer
argument_list|,
name|M_SCSISA
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|saextget
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|struct
name|mtextget
modifier|*
name|g
parameter_list|)
block|{
name|int
name|indent
decl_stmt|,
name|error
decl_stmt|;
name|char
name|tmpstr
index|[
literal|80
index|]
decl_stmt|;
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|tmpint
decl_stmt|;
name|uint32_t
name|maxio_tmp
decl_stmt|;
name|struct
name|ccb_getdev
name|cgd
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|sagetparams_common
argument_list|(
name|dev
argument_list|,
name|periph
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|extget_bailout
goto|;
if|if
condition|(
operator|!
name|SA_IS_CTRL
argument_list|(
name|dev
argument_list|)
operator|&&
operator|!
name|softc
operator|->
name|open_pending_mount
condition|)
name|sagetpos
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|indent
operator|=
literal|0
expr_stmt|;
name|SASBADDNODE
argument_list|(
name|sb
argument_list|,
name|indent
argument_list|,
name|mtextget
argument_list|)
expr_stmt|;
comment|/* 	 * Basic CAM peripheral information. 	 */
name|SASBADDVARSTR
argument_list|(
name|sb
argument_list|,
name|indent
argument_list|,
name|periph
operator|->
name|periph_name
argument_list|,
operator|%
name|s
argument_list|,
name|periph_name
argument_list|,
name|strlen
argument_list|(
name|periph
operator|->
name|periph_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|SASBADDUINT
argument_list|(
name|sb
argument_list|,
name|indent
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|,
operator|%
name|u
argument_list|,
name|unit_number
argument_list|)
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|cgd
operator|.
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
name|CAM_PRIORITY_NORMAL
argument_list|)
expr_stmt|;
name|cgd
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_GDEV_TYPE
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|cgd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cgd
operator|.
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|g
operator|->
name|status
operator|=
name|MT_EXT_GET_ERROR
expr_stmt|;
name|snprintf
argument_list|(
name|g
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|g
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"Error %#x returned for XPT_GDEV_TYPE CCB"
argument_list|,
name|cgd
operator|.
name|ccb_h
operator|.
name|status
argument_list|)
expr_stmt|;
goto|goto
name|extget_bailout
goto|;
block|}
name|cam_strvis
argument_list|(
name|tmpstr
argument_list|,
name|cgd
operator|.
name|inq_data
operator|.
name|vendor
argument_list|,
sizeof|sizeof
argument_list|(
name|cgd
operator|.
name|inq_data
operator|.
name|vendor
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|)
expr_stmt|;
name|SASBADDVARSTRDESC
argument_list|(
name|sb
argument_list|,
name|indent
argument_list|,
name|tmpstr
argument_list|,
operator|%
name|s
argument_list|,
name|vendor
argument_list|,
sizeof|sizeof
argument_list|(
name|cgd
operator|.
name|inq_data
operator|.
name|vendor
argument_list|)
operator|+
literal|1
argument_list|,
literal|"SCSI Vendor ID"
argument_list|)
expr_stmt|;
name|cam_strvis
argument_list|(
name|tmpstr
argument_list|,
name|cgd
operator|.
name|inq_data
operator|.
name|product
argument_list|,
sizeof|sizeof
argument_list|(
name|cgd
operator|.
name|inq_data
operator|.
name|product
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|)
expr_stmt|;
name|SASBADDVARSTRDESC
argument_list|(
name|sb
argument_list|,
name|indent
argument_list|,
name|tmpstr
argument_list|,
operator|%
name|s
argument_list|,
name|product
argument_list|,
sizeof|sizeof
argument_list|(
name|cgd
operator|.
name|inq_data
operator|.
name|product
argument_list|)
operator|+
literal|1
argument_list|,
literal|"SCSI Product ID"
argument_list|)
expr_stmt|;
name|cam_strvis
argument_list|(
name|tmpstr
argument_list|,
name|cgd
operator|.
name|inq_data
operator|.
name|revision
argument_list|,
sizeof|sizeof
argument_list|(
name|cgd
operator|.
name|inq_data
operator|.
name|revision
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|)
expr_stmt|;
name|SASBADDVARSTRDESC
argument_list|(
name|sb
argument_list|,
name|indent
argument_list|,
name|tmpstr
argument_list|,
operator|%
name|s
argument_list|,
name|revision
argument_list|,
sizeof|sizeof
argument_list|(
name|cgd
operator|.
name|inq_data
operator|.
name|revision
argument_list|)
operator|+
literal|1
argument_list|,
literal|"SCSI Revision"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cgd
operator|.
name|serial_num_len
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
name|tmpstr2
decl_stmt|;
name|size_t
name|ts2_len
decl_stmt|;
name|int
name|ts2_malloc
decl_stmt|;
name|ts2_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cgd
operator|.
name|serial_num_len
operator|>
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
condition|)
block|{
name|ts2_len
operator|=
name|cgd
operator|.
name|serial_num_len
operator|+
literal|1
expr_stmt|;
name|ts2_malloc
operator|=
literal|1
expr_stmt|;
name|tmpstr2
operator|=
name|malloc
argument_list|(
name|ts2_len
argument_list|,
name|M_SCSISA
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
comment|/* 			 * The 80 characters allocated on the stack above 			 * will handle the vast majority of serial numbers. 			 * If we run into one that is larger than that, and 			 * we can't malloc the length without blocking, 			 * bail out with an out of memory error. 			 */
if|if
condition|(
name|tmpstr2
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|extget_bailout
goto|;
block|}
block|}
else|else
block|{
name|ts2_len
operator|=
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
expr_stmt|;
name|ts2_malloc
operator|=
literal|0
expr_stmt|;
name|tmpstr2
operator|=
name|tmpstr
expr_stmt|;
block|}
name|cam_strvis
argument_list|(
name|tmpstr2
argument_list|,
name|cgd
operator|.
name|serial_num
argument_list|,
name|cgd
operator|.
name|serial_num_len
argument_list|,
name|ts2_len
argument_list|)
expr_stmt|;
name|SASBADDVARSTRDESC
argument_list|(
name|sb
argument_list|,
name|indent
argument_list|,
name|tmpstr2
argument_list|,
operator|%
name|s
argument_list|,
name|serial_num
argument_list|,
operator|(
name|ssize_t
operator|)
name|cgd
operator|.
name|serial_num_len
operator|+
literal|1
argument_list|,
literal|"Serial Number"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ts2_malloc
operator|!=
literal|0
condition|)
name|free
argument_list|(
name|tmpstr2
argument_list|,
name|M_SCSISA
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * We return a serial_num element in any case, but it will 		 * be empty if the device has no serial number. 		 */
name|tmpstr
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|SASBADDVARSTRDESC
argument_list|(
name|sb
argument_list|,
name|indent
argument_list|,
name|tmpstr
argument_list|,
operator|%
name|s
argument_list|,
name|serial_num
argument_list|,
operator|(
name|ssize_t
operator|)
literal|0
argument_list|,
literal|"Serial Number"
argument_list|)
expr_stmt|;
block|}
name|SASBADDUINTDESC
argument_list|(
name|sb
argument_list|,
name|indent
argument_list|,
name|softc
operator|->
name|maxio
argument_list|,
operator|%
name|u
argument_list|,
name|maxio
argument_list|,
literal|"Maximum I/O size allowed by driver and controller"
argument_list|)
expr_stmt|;
name|SASBADDUINTDESC
argument_list|(
name|sb
argument_list|,
name|indent
argument_list|,
name|softc
operator|->
name|cpi_maxio
argument_list|,
operator|%
name|u
argument_list|,
name|cpi_maxio
argument_list|,
literal|"Maximum I/O size reported by controller"
argument_list|)
expr_stmt|;
name|SASBADDUINTDESC
argument_list|(
name|sb
argument_list|,
name|indent
argument_list|,
name|softc
operator|->
name|max_blk
argument_list|,
operator|%
name|u
argument_list|,
name|max_blk
argument_list|,
literal|"Maximum block size supported by tape drive and media"
argument_list|)
expr_stmt|;
name|SASBADDUINTDESC
argument_list|(
name|sb
argument_list|,
name|indent
argument_list|,
name|softc
operator|->
name|min_blk
argument_list|,
operator|%
name|u
argument_list|,
name|min_blk
argument_list|,
literal|"Minimum block size supported by tape drive and media"
argument_list|)
expr_stmt|;
name|SASBADDUINTDESC
argument_list|(
name|sb
argument_list|,
name|indent
argument_list|,
name|softc
operator|->
name|blk_gran
argument_list|,
operator|%
name|u
argument_list|,
name|blk_gran
argument_list|,
literal|"Block granularity supported by tape drive and media"
argument_list|)
expr_stmt|;
name|maxio_tmp
operator|=
name|min
argument_list|(
name|softc
operator|->
name|max_blk
argument_list|,
name|softc
operator|->
name|maxio
argument_list|)
expr_stmt|;
name|SASBADDUINTDESC
argument_list|(
name|sb
argument_list|,
name|indent
argument_list|,
name|maxio_tmp
argument_list|,
operator|%
name|u
argument_list|,
name|max_effective_iosize
argument_list|,
literal|"Maximum possible I/O size"
argument_list|)
expr_stmt|;
name|SASBADDINTDESC
argument_list|(
name|sb
argument_list|,
name|indent
argument_list|,
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_FIXED
condition|?
literal|1
else|:
literal|0
argument_list|,
operator|%
name|d
argument_list|,
name|fixed_mode
argument_list|,
literal|"Set to 1 for fixed block mode, 0 for variable block"
argument_list|)
expr_stmt|;
comment|/* 	 * XXX KDM include SIM, bus, target, LUN? 	 */
if|if
condition|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_COMP_UNSUPP
condition|)
name|tmpint
operator|=
literal|0
expr_stmt|;
else|else
name|tmpint
operator|=
literal|1
expr_stmt|;
name|SASBADDINTDESC
argument_list|(
name|sb
argument_list|,
name|indent
argument_list|,
name|tmpint
argument_list|,
operator|%
name|d
argument_list|,
name|compression_supported
argument_list|,
literal|"Set to 1 if compression is supported, 0 if not"
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_COMP_ENABLED
condition|)
name|tmpint
operator|=
literal|1
expr_stmt|;
else|else
name|tmpint
operator|=
literal|0
expr_stmt|;
name|SASBADDINTDESC
argument_list|(
name|sb
argument_list|,
name|indent
argument_list|,
name|tmpint
argument_list|,
operator|%
name|d
argument_list|,
name|compression_enabled
argument_list|,
literal|"Set to 1 if compression is enabled, 0 if not"
argument_list|)
expr_stmt|;
name|SASBADDUINTDESC
argument_list|(
name|sb
argument_list|,
name|indent
argument_list|,
name|softc
operator|->
name|comp_algorithm
argument_list|,
operator|%
name|u
argument_list|,
name|compression_algorithm
argument_list|,
literal|"Numeric compression algorithm"
argument_list|)
expr_stmt|;
name|safillprot
argument_list|(
name|softc
argument_list|,
operator|&
name|indent
argument_list|,
name|sb
argument_list|)
expr_stmt|;
name|SASBADDUINTDESC
argument_list|(
name|sb
argument_list|,
name|indent
argument_list|,
name|softc
operator|->
name|media_blksize
argument_list|,
operator|%
name|u
argument_list|,
name|media_blocksize
argument_list|,
literal|"Block size reported by drive or set by user"
argument_list|)
expr_stmt|;
name|SASBADDINTDESC
argument_list|(
name|sb
argument_list|,
name|indent
argument_list|,
operator|(
name|intmax_t
operator|)
name|softc
operator|->
name|fileno
argument_list|,
operator|%
name|jd
argument_list|,
name|calculated_fileno
argument_list|,
literal|"Calculated file number, -1 if unknown"
argument_list|)
expr_stmt|;
name|SASBADDINTDESC
argument_list|(
name|sb
argument_list|,
name|indent
argument_list|,
operator|(
name|intmax_t
operator|)
name|softc
operator|->
name|blkno
argument_list|,
operator|%
name|jd
argument_list|,
name|calculated_rel_blkno
argument_list|,
literal|"Calculated block number relative to file, "
literal|"set to -1 if unknown"
argument_list|)
expr_stmt|;
name|SASBADDINTDESC
argument_list|(
name|sb
argument_list|,
name|indent
argument_list|,
operator|(
name|intmax_t
operator|)
name|softc
operator|->
name|rep_fileno
argument_list|,
operator|%
name|jd
argument_list|,
name|reported_fileno
argument_list|,
literal|"File number reported by drive, -1 if unknown"
argument_list|)
expr_stmt|;
name|SASBADDINTDESC
argument_list|(
name|sb
argument_list|,
name|indent
argument_list|,
operator|(
name|intmax_t
operator|)
name|softc
operator|->
name|rep_blkno
argument_list|,
operator|%
name|jd
argument_list|,
name|reported_blkno
argument_list|,
literal|"Block number relative to BOP/BOT reported by "
literal|"drive, -1 if unknown"
argument_list|)
expr_stmt|;
name|SASBADDINTDESC
argument_list|(
name|sb
argument_list|,
name|indent
argument_list|,
operator|(
name|intmax_t
operator|)
name|softc
operator|->
name|partition
argument_list|,
operator|%
name|jd
argument_list|,
name|partition
argument_list|,
literal|"Current partition number, 0 is the default"
argument_list|)
expr_stmt|;
name|SASBADDINTDESC
argument_list|(
name|sb
argument_list|,
name|indent
argument_list|,
name|softc
operator|->
name|bop
argument_list|,
operator|%
name|d
argument_list|,
name|bop
argument_list|,
literal|"Set to 1 if drive is at the beginning of partition/tape, 0 if "
literal|"not, -1 if unknown"
argument_list|)
expr_stmt|;
name|SASBADDINTDESC
argument_list|(
name|sb
argument_list|,
name|indent
argument_list|,
name|softc
operator|->
name|eop
argument_list|,
operator|%
name|d
argument_list|,
name|eop
argument_list|,
literal|"Set to 1 if drive is past early warning, 0 if not, -1 if unknown"
argument_list|)
expr_stmt|;
name|SASBADDINTDESC
argument_list|(
name|sb
argument_list|,
name|indent
argument_list|,
name|softc
operator|->
name|bpew
argument_list|,
operator|%
name|d
argument_list|,
name|bpew
argument_list|,
literal|"Set to 1 if drive is past programmable early warning, 0 if not, "
literal|"-1 if unknown"
argument_list|)
expr_stmt|;
name|SASBADDINTDESC
argument_list|(
name|sb
argument_list|,
name|indent
argument_list|,
operator|(
name|intmax_t
operator|)
name|softc
operator|->
name|last_io_resid
argument_list|,
operator|%
name|jd
argument_list|,
name|residual
argument_list|,
literal|"Residual for the last I/O"
argument_list|)
expr_stmt|;
comment|/* 	 * XXX KDM should we send a string with the current driver 	 * status already decoded instead of a numeric value? 	 */
name|SASBADDINTDESC
argument_list|(
name|sb
argument_list|,
name|indent
argument_list|,
name|softc
operator|->
name|dsreg
argument_list|,
operator|%
name|d
argument_list|,
name|dsreg
argument_list|,
literal|"Current state of the driver"
argument_list|)
expr_stmt|;
name|safilldensitysb
argument_list|(
name|softc
argument_list|,
operator|&
name|indent
argument_list|,
name|sb
argument_list|)
expr_stmt|;
name|SASBENDNODE
argument_list|(
name|sb
argument_list|,
name|indent
argument_list|,
name|mtextget
argument_list|)
expr_stmt|;
name|extget_bailout
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|saparamget
parameter_list|(
name|struct
name|sa_softc
modifier|*
name|softc
parameter_list|,
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|)
block|{
name|int
name|indent
decl_stmt|;
name|indent
operator|=
literal|0
expr_stmt|;
name|SASBADDNODE
argument_list|(
name|sb
argument_list|,
name|indent
argument_list|,
name|mtparamget
argument_list|)
expr_stmt|;
name|SASBADDINTDESC
argument_list|(
name|sb
argument_list|,
name|indent
argument_list|,
name|softc
operator|->
name|sili
argument_list|,
operator|%
name|d
argument_list|,
name|sili
argument_list|,
literal|"Suppress an error on underlength variable reads"
argument_list|)
expr_stmt|;
name|SASBADDINTDESC
argument_list|(
name|sb
argument_list|,
name|indent
argument_list|,
name|softc
operator|->
name|eot_warn
argument_list|,
operator|%
name|d
argument_list|,
name|eot_warn
argument_list|,
literal|"Return an error to warn that end of tape is approaching"
argument_list|)
expr_stmt|;
name|safillprot
argument_list|(
name|softc
argument_list|,
operator|&
name|indent
argument_list|,
name|sb
argument_list|)
expr_stmt|;
name|SASBENDNODE
argument_list|(
name|sb
argument_list|,
name|indent
argument_list|,
name|mtparamget
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|saprevent
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|action
parameter_list|)
block|{
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|error
decl_stmt|,
name|sf
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
if|if
condition|(
operator|(
name|action
operator|==
name|PR_ALLOW
operator|)
operator|&&
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_TAPE_LOCKED
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|action
operator|==
name|PR_PREVENT
operator|)
operator|&&
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_TAPE_LOCKED
operator|)
operator|!=
literal|0
condition|)
return|return;
comment|/* 	 * We can be quiet about illegal requests. 	 */
if|if
condition|(
name|CAM_DEBUGGED
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_INFO
argument_list|)
condition|)
block|{
name|sf
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|sf
operator|=
name|SF_QUIET_IR
expr_stmt|;
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* It is safe to retry this operation */
name|scsi_prevent
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
literal|5
argument_list|,
name|sadone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|action
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
name|SCSIOP_TIMEOUT
argument_list|)
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
literal|0
argument_list|,
name|sf
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|action
operator|==
name|PR_ALLOW
condition|)
name|softc
operator|->
name|flags
operator|&=
operator|~
name|SA_FLAG_TAPE_LOCKED
expr_stmt|;
else|else
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_TAPE_LOCKED
expr_stmt|;
block|}
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sarewind
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* It is safe to retry this operation */
name|scsi_rewind
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
literal|2
argument_list|,
name|sadone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|FALSE
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
name|REWIND_TIMEOUT
argument_list|)
expr_stmt|;
name|softc
operator|->
name|dsreg
operator|=
name|MTIO_DSREG_REW
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
name|softc
operator|->
name|dsreg
operator|=
name|MTIO_DSREG_REST
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|softc
operator|->
name|partition
operator|=
name|softc
operator|->
name|fileno
operator|=
name|softc
operator|->
name|blkno
operator|=
operator|(
name|daddr_t
operator|)
literal|0
expr_stmt|;
name|softc
operator|->
name|rep_fileno
operator|=
name|softc
operator|->
name|rep_blkno
operator|=
operator|(
name|daddr_t
operator|)
literal|0
expr_stmt|;
block|}
else|else
block|{
name|softc
operator|->
name|fileno
operator|=
name|softc
operator|->
name|blkno
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
name|softc
operator|->
name|partition
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
name|softc
operator|->
name|rep_fileno
operator|=
name|softc
operator|->
name|rep_blkno
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|saspace
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|count
parameter_list|,
name|scsi_space_code
name|code
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* This cannot be retried */
name|scsi_space
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
literal|0
argument_list|,
name|sadone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|code
argument_list|,
name|count
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
name|SPACE_TIMEOUT
argument_list|)
expr_stmt|;
comment|/* 	 * Clear residual because we will be using it. 	 */
name|softc
operator|->
name|last_ctl_resid
operator|=
literal|0
expr_stmt|;
name|softc
operator|->
name|dsreg
operator|=
operator|(
name|count
operator|<
literal|0
operator|)
condition|?
name|MTIO_DSREG_REV
else|:
name|MTIO_DSREG_FWD
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
name|softc
operator|->
name|dsreg
operator|=
name|MTIO_DSREG_REST
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
comment|/* 	 * If a spacing operation has failed, we need to invalidate 	 * this mount. 	 * 	 * If the spacing operation was setmarks or to end of recorded data, 	 * we no longer know our relative position. 	 * 	 * If the spacing operations was spacing files in reverse, we 	 * take account of the residual, but still check against less 	 * than zero- if we've gone negative, we must have hit BOT. 	 * 	 * If the spacing operations was spacing records in reverse and 	 * we have a residual, we've either hit BOT or hit a filemark. 	 * In the former case, we know our new record number (0). In 	 * the latter case, we have absolutely no idea what the real 	 * record number is- we've stopped between the end of the last 	 * record in the previous file and the filemark that stopped 	 * our spacing backwards. 	 */
if|if
condition|(
name|error
condition|)
block|{
name|softc
operator|->
name|fileno
operator|=
name|softc
operator|->
name|blkno
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
name|softc
operator|->
name|rep_blkno
operator|=
name|softc
operator|->
name|partition
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
name|softc
operator|->
name|rep_fileno
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|SS_SETMARKS
operator|||
name|code
operator|==
name|SS_EOD
condition|)
block|{
name|softc
operator|->
name|fileno
operator|=
name|softc
operator|->
name|blkno
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|SS_FILEMARKS
operator|&&
name|softc
operator|->
name|fileno
operator|!=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
condition|)
block|{
name|softc
operator|->
name|fileno
operator|+=
operator|(
name|count
operator|-
name|softc
operator|->
name|last_ctl_resid
operator|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|fileno
operator|<
literal|0
condition|)
comment|/* we must of hit BOT */
name|softc
operator|->
name|fileno
operator|=
literal|0
expr_stmt|;
name|softc
operator|->
name|blkno
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|SS_BLOCKS
operator|&&
name|softc
operator|->
name|blkno
operator|!=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
condition|)
block|{
name|softc
operator|->
name|blkno
operator|+=
operator|(
name|count
operator|-
name|softc
operator|->
name|last_ctl_resid
operator|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|softc
operator|->
name|last_ctl_resid
operator|||
name|softc
operator|->
name|blkno
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|softc
operator|->
name|fileno
operator|==
literal|0
condition|)
block|{
name|softc
operator|->
name|blkno
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|softc
operator|->
name|blkno
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|sagetpos
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sawritefilemarks
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|nmarks
parameter_list|,
name|int
name|setmarks
parameter_list|,
name|int
name|immed
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|nwm
init|=
literal|0
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|open_rdonly
condition|)
return|return
operator|(
name|EBADF
operator|)
return|;
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Clear residual because we will be using it. 	 */
name|softc
operator|->
name|last_ctl_resid
operator|=
literal|0
expr_stmt|;
name|softc
operator|->
name|dsreg
operator|=
name|MTIO_DSREG_FMK
expr_stmt|;
comment|/* this *must* not be retried */
name|scsi_write_filemarks
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
literal|0
argument_list|,
name|sadone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|immed
argument_list|,
name|setmarks
argument_list|,
name|nmarks
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
name|IO_TIMEOUT
argument_list|)
expr_stmt|;
name|softc
operator|->
name|dsreg
operator|=
name|MTIO_DSREG_REST
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|nmarks
condition|)
block|{
name|struct
name|sa_softc
modifier|*
name|softc
init|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
decl_stmt|;
name|nwm
operator|=
name|nmarks
operator|-
name|softc
operator|->
name|last_ctl_resid
expr_stmt|;
name|softc
operator|->
name|filemarks
operator|+=
name|nwm
expr_stmt|;
block|}
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
comment|/* 	 * Update relative positions (if we're doing that). 	 */
if|if
condition|(
name|error
condition|)
block|{
name|softc
operator|->
name|fileno
operator|=
name|softc
operator|->
name|blkno
operator|=
name|softc
operator|->
name|partition
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|softc
operator|->
name|fileno
operator|!=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
condition|)
block|{
name|softc
operator|->
name|fileno
operator|+=
name|nwm
expr_stmt|;
name|softc
operator|->
name|blkno
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Ask the tape drive for position information. 	 */
name|sagetpos
argument_list|(
name|periph
argument_list|)
expr_stmt|;
comment|/* 	 * If we got valid position information, since we just wrote a file 	 * mark, we know we're at the file mark and block 0 after that 	 * filemark. 	 */
if|if
condition|(
name|softc
operator|->
name|rep_fileno
operator|!=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
condition|)
block|{
name|softc
operator|->
name|fileno
operator|=
name|softc
operator|->
name|rep_fileno
expr_stmt|;
name|softc
operator|->
name|blkno
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sagetpos
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|scsi_tape_position_long_data
name|long_pos
decl_stmt|;
name|struct
name|sa_softc
modifier|*
name|softc
init|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|softc
operator|->
name|quirks
operator|&
name|SA_QUIRK_NO_LONG_POS
condition|)
block|{
name|softc
operator|->
name|rep_fileno
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
name|softc
operator|->
name|rep_blkno
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
name|softc
operator|->
name|bop
operator|=
name|softc
operator|->
name|eop
operator|=
name|softc
operator|->
name|bpew
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|&
name|long_pos
argument_list|,
sizeof|sizeof
argument_list|(
name|long_pos
argument_list|)
argument_list|)
expr_stmt|;
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
name|CAM_PRIORITY_NORMAL
argument_list|)
expr_stmt|;
name|scsi_read_position_10
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/*retries*/
literal|1
argument_list|,
comment|/*cbfcnp*/
name|sadone
argument_list|,
comment|/*tag_action*/
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*service_action*/
name|SA_RPOS_LONG_FORM
argument_list|,
comment|/*data_ptr*/
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|long_pos
argument_list|,
comment|/*length*/
sizeof|sizeof
argument_list|(
name|long_pos
argument_list|)
argument_list|,
comment|/*sense_len*/
name|SSD_FULL_SIZE
argument_list|,
comment|/*timeout*/
name|SCSIOP_TIMEOUT
argument_list|)
expr_stmt|;
name|softc
operator|->
name|dsreg
operator|=
name|MTIO_DSREG_RBSY
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
literal|0
argument_list|,
name|SF_QUIET_IR
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
name|softc
operator|->
name|dsreg
operator|=
name|MTIO_DSREG_REST
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|long_pos
operator|.
name|flags
operator|&
name|SA_RPOS_LONG_MPU
condition|)
block|{
comment|/* 			 * If the drive doesn't know what file mark it is 			 * on, our calculated filemark isn't going to be 			 * accurate either. 			 */
name|softc
operator|->
name|fileno
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
name|softc
operator|->
name|rep_fileno
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|softc
operator|->
name|fileno
operator|=
name|softc
operator|->
name|rep_fileno
operator|=
name|scsi_8btou64
argument_list|(
name|long_pos
operator|.
name|logical_file_num
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|long_pos
operator|.
name|flags
operator|&
name|SA_RPOS_LONG_LONU
condition|)
block|{
name|softc
operator|->
name|partition
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
name|softc
operator|->
name|rep_blkno
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* 			 * If the tape drive doesn't know its block 			 * position, we can't claim to know it either. 			 */
name|softc
operator|->
name|blkno
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|softc
operator|->
name|partition
operator|=
name|scsi_4btoul
argument_list|(
name|long_pos
operator|.
name|partition
argument_list|)
expr_stmt|;
name|softc
operator|->
name|rep_blkno
operator|=
name|scsi_8btou64
argument_list|(
name|long_pos
operator|.
name|logical_object_num
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|long_pos
operator|.
name|flags
operator|&
name|SA_RPOS_LONG_BOP
condition|)
name|softc
operator|->
name|bop
operator|=
literal|1
expr_stmt|;
else|else
name|softc
operator|->
name|bop
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|long_pos
operator|.
name|flags
operator|&
name|SA_RPOS_LONG_EOP
condition|)
name|softc
operator|->
name|eop
operator|=
literal|1
expr_stmt|;
else|else
name|softc
operator|->
name|eop
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|long_pos
operator|.
name|flags
operator|&
name|SA_RPOS_LONG_BPEW
operator|)
operator|||
operator|(
name|softc
operator|->
name|set_pews_status
operator|!=
literal|0
operator|)
condition|)
block|{
name|softc
operator|->
name|bpew
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|set_pews_status
operator|>
literal|0
condition|)
name|softc
operator|->
name|set_pews_status
operator|--
expr_stmt|;
block|}
else|else
name|softc
operator|->
name|bpew
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
name|EINVAL
condition|)
block|{
comment|/* 		 * If this drive returned an invalid-request type error, 		 * then it likely doesn't support the long form report. 		 */
name|softc
operator|->
name|quirks
operator||=
name|SA_QUIRK_NO_LONG_POS
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|softc
operator|->
name|rep_fileno
operator|=
name|softc
operator|->
name|rep_blkno
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
name|softc
operator|->
name|partition
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
name|softc
operator|->
name|bop
operator|=
name|softc
operator|->
name|eop
operator|=
name|softc
operator|->
name|bpew
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sardpos
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|hard
parameter_list|,
name|u_int32_t
modifier|*
name|blkptr
parameter_list|)
block|{
name|struct
name|scsi_tape_position_data
name|loc
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|sa_softc
modifier|*
name|softc
init|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * We try and flush any buffered writes here if we were writing 	 * and we're trying to get hardware block position. It eats 	 * up performance substantially, but I'm wary of drive firmware. 	 * 	 * I think that *logical* block position is probably okay- 	 * but hardware block position might have to wait for data 	 * to hit media to be valid. Caveat Emptor. 	 */
if|if
condition|(
name|hard
operator|&&
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_TAPE_WRITTEN
operator|)
condition|)
block|{
name|error
operator|=
name|sawritefilemarks
argument_list|(
name|periph
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|EACCES
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|scsi_read_position
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
literal|1
argument_list|,
name|sadone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|hard
argument_list|,
operator|&
name|loc
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
name|SCSIOP_TIMEOUT
argument_list|)
expr_stmt|;
name|softc
operator|->
name|dsreg
operator|=
name|MTIO_DSREG_RBSY
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
name|softc
operator|->
name|dsreg
operator|=
name|MTIO_DSREG_REST
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|loc
operator|.
name|flags
operator|&
name|SA_RPOS_UNCERTAIN
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
comment|/* nothing is certain */
block|}
else|else
block|{
operator|*
name|blkptr
operator|=
name|scsi_4btoul
argument_list|(
name|loc
operator|.
name|firstblk
argument_list|)
expr_stmt|;
block|}
block|}
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sasetpos
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|hard
parameter_list|,
name|struct
name|mtlocate
modifier|*
name|locate_info
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|locate16
decl_stmt|;
name|int
name|immed
decl_stmt|,
name|cp
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * We used to try and flush any buffered writes here. 	 * Now we push this onto user applications to either 	 * flush the pending writes themselves (via a zero count 	 * WRITE FILEMARKS command) or they can trust their tape 	 * drive to do this correctly for them.  	 */
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cp
operator|=
name|locate_info
operator|->
name|flags
operator|&
name|MT_LOCATE_FLAG_CHANGE_PART
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|immed
operator|=
name|locate_info
operator|->
name|flags
operator|&
name|MT_LOCATE_FLAG_IMMED
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* 	 * Determine whether we have to use LOCATE or LOCATE16.  The hard 	 * bit is only possible with LOCATE, but the new ioctls do not 	 * allow setting that bit.  So we can't get into the situation of 	 * having the hard bit set with a block address that is larger than 	 * 32-bits. 	 */
if|if
condition|(
name|hard
operator|!=
literal|0
condition|)
name|locate16
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|locate_info
operator|->
name|dest_type
operator|!=
name|MT_LOCATE_DEST_OBJECT
operator|)
operator|||
operator|(
name|locate_info
operator|->
name|block_address_mode
operator|!=
name|MT_LOCATE_BAM_IMPLICIT
operator|)
operator|||
operator|(
name|locate_info
operator|->
name|logical_id
operator|>
name|SA_SPOS_MAX_BLK
operator|)
condition|)
name|locate16
operator|=
literal|1
expr_stmt|;
else|else
name|locate16
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|locate16
operator|!=
literal|0
condition|)
block|{
name|scsi_locate_16
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/*retries*/
literal|1
argument_list|,
comment|/*cbfcnp*/
name|sadone
argument_list|,
comment|/*tag_action*/
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*immed*/
name|immed
argument_list|,
comment|/*cp*/
name|cp
argument_list|,
comment|/*dest_type*/
name|locate_info
operator|->
name|dest_type
argument_list|,
comment|/*bam*/
name|locate_info
operator|->
name|block_address_mode
argument_list|,
comment|/*partition*/
name|locate_info
operator|->
name|partition
argument_list|,
comment|/*logical_id*/
name|locate_info
operator|->
name|logical_id
argument_list|,
comment|/*sense_len*/
name|SSD_FULL_SIZE
argument_list|,
comment|/*timeout*/
name|SPACE_TIMEOUT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|scsi_locate_10
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/*retries*/
literal|1
argument_list|,
comment|/*cbfcnp*/
name|sadone
argument_list|,
comment|/*tag_action*/
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*immed*/
name|immed
argument_list|,
comment|/*cp*/
name|cp
argument_list|,
comment|/*hard*/
name|hard
argument_list|,
comment|/*partition*/
name|locate_info
operator|->
name|partition
argument_list|,
comment|/*block_address*/
name|locate_info
operator|->
name|logical_id
argument_list|,
comment|/*sense_len*/
name|SSD_FULL_SIZE
argument_list|,
comment|/*timeout*/
name|SPACE_TIMEOUT
argument_list|)
expr_stmt|;
block|}
name|softc
operator|->
name|dsreg
operator|=
name|MTIO_DSREG_POS
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
name|softc
operator|->
name|dsreg
operator|=
name|MTIO_DSREG_REST
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
comment|/* 	 * We assume the calculated file and block numbers are unknown 	 * unless we have enough information to populate them. 	 */
name|softc
operator|->
name|fileno
operator|=
name|softc
operator|->
name|blkno
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* 	 * If the user requested changing the partition and the request 	 * succeeded, note the partition. 	 */
if|if
condition|(
operator|(
name|error
operator|==
literal|0
operator|)
operator|&&
operator|(
name|cp
operator|!=
literal|0
operator|)
condition|)
name|softc
operator|->
name|partition
operator|=
name|locate_info
operator|->
name|partition
expr_stmt|;
else|else
name|softc
operator|->
name|partition
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|locate_info
operator|->
name|dest_type
condition|)
block|{
case|case
name|MT_LOCATE_DEST_FILE
case|:
comment|/* 			 * This is the only case where we can reliably 			 * calculate the file and block numbers. 			 */
name|softc
operator|->
name|fileno
operator|=
name|locate_info
operator|->
name|logical_id
expr_stmt|;
name|softc
operator|->
name|blkno
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MT_LOCATE_DEST_OBJECT
case|:
case|case
name|MT_LOCATE_DEST_SET
case|:
case|case
name|MT_LOCATE_DEST_EOD
case|:
default|default:
break|break;
block|}
block|}
comment|/* 	 * Ask the drive for current position information. 	 */
name|sagetpos
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|saretension
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* It is safe to retry this operation */
name|scsi_load_unload
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
literal|5
argument_list|,
name|sadone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
name|ERASE_TIMEOUT
argument_list|)
expr_stmt|;
name|softc
operator|->
name|dsreg
operator|=
name|MTIO_DSREG_TEN
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
name|softc
operator|->
name|dsreg
operator|=
name|MTIO_DSREG_REST
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|softc
operator|->
name|partition
operator|=
name|softc
operator|->
name|fileno
operator|=
name|softc
operator|->
name|blkno
operator|=
operator|(
name|daddr_t
operator|)
literal|0
expr_stmt|;
name|sagetpos
argument_list|(
name|periph
argument_list|)
expr_stmt|;
block|}
else|else
name|softc
operator|->
name|partition
operator|=
name|softc
operator|->
name|fileno
operator|=
name|softc
operator|->
name|blkno
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sareservereleaseunit
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|reserve
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* It is safe to retry this operation */
name|scsi_reserve_release_unit
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
literal|2
argument_list|,
name|sadone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
name|SCSIOP_TIMEOUT
argument_list|,
name|reserve
argument_list|)
expr_stmt|;
name|softc
operator|->
name|dsreg
operator|=
name|MTIO_DSREG_RBSY
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
literal|0
argument_list|,
name|SF_RETRY_UA
operator||
name|SF_NO_PRINT
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
name|softc
operator|->
name|dsreg
operator|=
name|MTIO_DSREG_REST
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
comment|/* 	 * If the error was Illegal Request, then the device doesn't support 	 * RESERVE/RELEASE. This is not an error. 	 */
if|if
condition|(
name|error
operator|==
name|EINVAL
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|saloadunload
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|load
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* It is safe to retry this operation */
name|scsi_load_unload
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
literal|5
argument_list|,
name|sadone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|load
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
name|REWIND_TIMEOUT
argument_list|)
expr_stmt|;
name|softc
operator|->
name|dsreg
operator|=
operator|(
name|load
operator|)
condition|?
name|MTIO_DSREG_LD
else|:
name|MTIO_DSREG_UNL
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
name|softc
operator|->
name|dsreg
operator|=
name|MTIO_DSREG_REST
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|load
operator|==
literal|0
condition|)
block|{
name|softc
operator|->
name|partition
operator|=
name|softc
operator|->
name|fileno
operator|=
name|softc
operator|->
name|blkno
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
name|softc
operator|->
name|rep_fileno
operator|=
name|softc
operator|->
name|rep_blkno
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|softc
operator|->
name|partition
operator|=
name|softc
operator|->
name|fileno
operator|=
name|softc
operator|->
name|blkno
operator|=
operator|(
name|daddr_t
operator|)
literal|0
expr_stmt|;
name|sagetpos
argument_list|(
name|periph
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|saerase
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|longerase
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|open_rdonly
condition|)
return|return
operator|(
name|EBADF
operator|)
return|;
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|scsi_erase
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
literal|1
argument_list|,
name|sadone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|FALSE
argument_list|,
name|longerase
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
name|ERASE_TIMEOUT
argument_list|)
expr_stmt|;
name|softc
operator|->
name|dsreg
operator|=
name|MTIO_DSREG_ZER
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
name|softc
operator|->
name|dsreg
operator|=
name|MTIO_DSREG_REST
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fill an sbuf with density data in XML format.  This particular macro  * works for multi-byte integer fields.  *  * Note that 1 byte fields aren't supported here.  The reason is that the  * compiler does not evaluate the sizeof(), and assumes that any of the  * sizes are possible for a given field.  So passing in a multi-byte  * field will result in a warning that the assignment makes an integer  * from a pointer without a cast, if there is an assignment in the 1 byte  * case.  */
end_comment

begin_define
define|#
directive|define
name|SAFILLDENSSB
parameter_list|(
name|dens_data
parameter_list|,
name|sb
parameter_list|,
name|indent
parameter_list|,
name|field
parameter_list|,
name|desc_remain
parameter_list|, 	\
name|len_to_go
parameter_list|,
name|cur_offset
parameter_list|,
name|desc
parameter_list|)
value|{			\ 	size_t cur_field_len;						\ 									\ 	cur_field_len = sizeof(dens_data->field);			\ 	if (desc_remain< cur_field_len) {				\ 		len_to_go -= desc_remain;				\ 		cur_offset += desc_remain;				\ 		continue;						\ 	}								\ 	len_to_go -= cur_field_len;					\ 	cur_offset += cur_field_len;					\ 	desc_remain -= cur_field_len;					\ 									\ 	switch (sizeof(dens_data->field)) {				\ 	case 1:								\ 		KASSERT(1 == 0, ("Programmer error, invalid 1 byte "	\ 			"field width for SAFILLDENSFIELD"));		\ 		break;							\ 	case 2:								\ 		SASBADDUINTDESC(sb, indent,				\ 		    scsi_2btoul(dens_data->field), %u, field, desc);	\ 		break;							\ 	case 3:								\ 		SASBADDUINTDESC(sb, indent,				\ 		    scsi_3btoul(dens_data->field), %u, field, desc);	\ 		break;							\ 	case 4:								\ 		SASBADDUINTDESC(sb, indent,				\ 		    scsi_4btoul(dens_data->field), %u, field, desc);	\ 		break;							\ 	case 8:								\ 		SASBADDUINTDESC(sb, indent, 				\ 		    (uintmax_t)scsi_8btou64(dens_data->field),	%ju, 	\ 		    field, desc);					\ 		break;							\ 	default:							\ 		break;							\ 	}								\ };
end_define

begin_comment
comment|/*  * Fill an sbuf with density data in XML format.  This particular macro  * works for strings.  */
end_comment

begin_define
define|#
directive|define
name|SAFILLDENSSBSTR
parameter_list|(
name|dens_data
parameter_list|,
name|sb
parameter_list|,
name|indent
parameter_list|,
name|field
parameter_list|,
name|desc_remain
parameter_list|, 	\
name|len_to_go
parameter_list|,
name|cur_offset
parameter_list|,
name|desc
parameter_list|)
value|{			\ 	size_t cur_field_len;						\ 	char tmpstr[32];						\ 									\ 	cur_field_len = sizeof(dens_data->field);			\ 	if (desc_remain< cur_field_len) {				\ 		len_to_go -= desc_remain;				\ 		cur_offset += desc_remain;				\ 		continue;						\ 	}								\ 	len_to_go -= cur_field_len;					\ 	cur_offset += cur_field_len;					\ 	desc_remain -= cur_field_len;					\ 									\ 	cam_strvis(tmpstr, dens_data->field,				\ 	    sizeof(dens_data->field), sizeof(tmpstr));			\ 	SASBADDVARSTRDESC(sb, indent, tmpstr, %s, field,		\ 	    strlen(tmpstr) + 1, desc);					\ };
end_define

begin_comment
comment|/*  * Fill an sbuf with density data descriptors.  */
end_comment

begin_function
specifier|static
name|void
name|safilldenstypesb
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|int
modifier|*
name|indent
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|int
name|buf_len
parameter_list|,
name|int
name|is_density
parameter_list|)
block|{
name|struct
name|scsi_density_hdr
modifier|*
name|hdr
decl_stmt|;
name|uint32_t
name|hdr_len
decl_stmt|;
name|int
name|len_to_go
decl_stmt|,
name|cur_offset
decl_stmt|;
name|int
name|length_offset
decl_stmt|;
name|int
name|num_reports
decl_stmt|,
name|need_close
decl_stmt|;
comment|/* 	 * We need at least the header length.  Note that this isn't an 	 * error, not all tape drives will have every data type. 	 */
if|if
condition|(
name|buf_len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
condition|)
goto|goto
name|bailout
goto|;
name|hdr
operator|=
operator|(
expr|struct
name|scsi_density_hdr
operator|*
operator|)
name|buf
expr_stmt|;
name|hdr_len
operator|=
name|scsi_2btoul
argument_list|(
name|hdr
operator|->
name|length
argument_list|)
expr_stmt|;
name|len_to_go
operator|=
name|min
argument_list|(
name|buf_len
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
argument_list|,
name|hdr_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_density
condition|)
block|{
name|length_offset
operator|=
name|__offsetof
argument_list|(
expr|struct
name|scsi_density_data
argument_list|,
name|bits_per_mm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|length_offset
operator|=
name|__offsetof
argument_list|(
expr|struct
name|scsi_medium_type_data
argument_list|,
name|num_density_codes
argument_list|)
expr_stmt|;
block|}
name|cur_offset
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
expr_stmt|;
name|num_reports
operator|=
literal|0
expr_stmt|;
name|need_close
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|len_to_go
operator|>
name|length_offset
condition|)
block|{
name|struct
name|scsi_density_data
modifier|*
name|dens_data
decl_stmt|;
name|struct
name|scsi_medium_type_data
modifier|*
name|type_data
decl_stmt|;
name|int
name|desc_remain
decl_stmt|;
name|size_t
name|cur_field_len
decl_stmt|;
name|dens_data
operator|=
name|NULL
expr_stmt|;
name|type_data
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|is_density
condition|)
block|{
name|dens_data
operator|=
operator|(
expr|struct
name|scsi_density_data
operator|*
operator|)
operator|&
name|buf
index|[
name|cur_offset
index|]
expr_stmt|;
if|if
condition|(
name|dens_data
operator|->
name|byte2
operator|&
name|SDD_DLV
condition|)
name|desc_remain
operator|=
name|scsi_2btoul
argument_list|(
name|dens_data
operator|->
name|length
argument_list|)
expr_stmt|;
else|else
name|desc_remain
operator|=
name|SDD_DEFAULT_LENGTH
operator|-
name|length_offset
expr_stmt|;
block|}
else|else
block|{
name|type_data
operator|=
operator|(
expr|struct
name|scsi_medium_type_data
operator|*
operator|)
operator|&
name|buf
index|[
name|cur_offset
index|]
expr_stmt|;
name|desc_remain
operator|=
name|scsi_2btoul
argument_list|(
name|type_data
operator|->
name|length
argument_list|)
expr_stmt|;
block|}
name|len_to_go
operator|-=
name|length_offset
expr_stmt|;
name|desc_remain
operator|=
name|min
argument_list|(
name|desc_remain
argument_list|,
name|len_to_go
argument_list|)
expr_stmt|;
name|cur_offset
operator|+=
name|length_offset
expr_stmt|;
if|if
condition|(
name|need_close
operator|!=
literal|0
condition|)
block|{
name|SASBENDNODE
argument_list|(
name|sb
argument_list|,
operator|*
name|indent
argument_list|,
name|density_entry
argument_list|)
expr_stmt|;
block|}
name|SASBADDNODENUM
argument_list|(
name|sb
argument_list|,
operator|*
name|indent
argument_list|,
name|density_entry
argument_list|,
name|num_reports
argument_list|)
expr_stmt|;
name|num_reports
operator|++
expr_stmt|;
name|need_close
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|is_density
condition|)
block|{
name|SASBADDUINTDESC
argument_list|(
name|sb
argument_list|,
operator|*
name|indent
argument_list|,
name|dens_data
operator|->
name|primary_density_code
argument_list|,
operator|%
name|u
argument_list|,
name|primary_density_code
argument_list|,
literal|"Primary Density Code"
argument_list|)
expr_stmt|;
name|SASBADDUINTDESC
argument_list|(
name|sb
argument_list|,
operator|*
name|indent
argument_list|,
name|dens_data
operator|->
name|secondary_density_code
argument_list|,
operator|%
name|u
argument_list|,
name|secondary_density_code
argument_list|,
literal|"Secondary Density Code"
argument_list|)
expr_stmt|;
name|SASBADDUINTDESC
argument_list|(
name|sb
argument_list|,
operator|*
name|indent
argument_list|,
name|dens_data
operator|->
name|byte2
operator|&
operator|~
name|SDD_DLV
argument_list|,
operator|%
operator|#
name|x
argument_list|,
name|density_flags
argument_list|,
literal|"Density Flags"
argument_list|)
expr_stmt|;
name|SAFILLDENSSB
argument_list|(
name|dens_data
argument_list|,
name|sb
argument_list|,
operator|*
name|indent
argument_list|,
name|bits_per_mm
argument_list|,
name|desc_remain
argument_list|,
name|len_to_go
argument_list|,
name|cur_offset
argument_list|,
literal|"Bits per mm"
argument_list|)
expr_stmt|;
name|SAFILLDENSSB
argument_list|(
name|dens_data
argument_list|,
name|sb
argument_list|,
operator|*
name|indent
argument_list|,
name|media_width
argument_list|,
name|desc_remain
argument_list|,
name|len_to_go
argument_list|,
name|cur_offset
argument_list|,
literal|"Media width"
argument_list|)
expr_stmt|;
name|SAFILLDENSSB
argument_list|(
name|dens_data
argument_list|,
name|sb
argument_list|,
operator|*
name|indent
argument_list|,
name|tracks
argument_list|,
name|desc_remain
argument_list|,
name|len_to_go
argument_list|,
name|cur_offset
argument_list|,
literal|"Number of Tracks"
argument_list|)
expr_stmt|;
name|SAFILLDENSSB
argument_list|(
name|dens_data
argument_list|,
name|sb
argument_list|,
operator|*
name|indent
argument_list|,
name|capacity
argument_list|,
name|desc_remain
argument_list|,
name|len_to_go
argument_list|,
name|cur_offset
argument_list|,
literal|"Capacity"
argument_list|)
expr_stmt|;
name|SAFILLDENSSBSTR
argument_list|(
name|dens_data
argument_list|,
name|sb
argument_list|,
operator|*
name|indent
argument_list|,
name|assigning_org
argument_list|,
name|desc_remain
argument_list|,
name|len_to_go
argument_list|,
name|cur_offset
argument_list|,
literal|"Assigning Organization"
argument_list|)
expr_stmt|;
name|SAFILLDENSSBSTR
argument_list|(
name|dens_data
argument_list|,
name|sb
argument_list|,
operator|*
name|indent
argument_list|,
name|density_name
argument_list|,
name|desc_remain
argument_list|,
name|len_to_go
argument_list|,
name|cur_offset
argument_list|,
literal|"Density Name"
argument_list|)
expr_stmt|;
name|SAFILLDENSSBSTR
argument_list|(
name|dens_data
argument_list|,
name|sb
argument_list|,
operator|*
name|indent
argument_list|,
name|description
argument_list|,
name|desc_remain
argument_list|,
name|len_to_go
argument_list|,
name|cur_offset
argument_list|,
literal|"Description"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
name|SASBADDUINTDESC
argument_list|(
name|sb
argument_list|,
operator|*
name|indent
argument_list|,
name|type_data
operator|->
name|medium_type
argument_list|,
operator|%
name|u
argument_list|,
name|medium_type
argument_list|,
literal|"Medium Type"
argument_list|)
expr_stmt|;
name|cur_field_len
operator|=
name|__offsetof
argument_list|(
expr|struct
name|scsi_medium_type_data
argument_list|,
name|media_width
argument_list|)
operator|-
name|__offsetof
argument_list|(
expr|struct
name|scsi_medium_type_data
argument_list|,
name|num_density_codes
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc_remain
operator|<
name|cur_field_len
condition|)
block|{
name|len_to_go
operator|-=
name|desc_remain
expr_stmt|;
name|cur_offset
operator|+=
name|desc_remain
expr_stmt|;
continue|continue;
block|}
name|len_to_go
operator|-=
name|cur_field_len
expr_stmt|;
name|cur_offset
operator|+=
name|cur_field_len
expr_stmt|;
name|desc_remain
operator|-=
name|cur_field_len
expr_stmt|;
name|SASBADDINTDESC
argument_list|(
name|sb
argument_list|,
operator|*
name|indent
argument_list|,
name|type_data
operator|->
name|num_density_codes
argument_list|,
operator|%
name|d
argument_list|,
name|num_density_codes
argument_list|,
literal|"Number of Density Codes"
argument_list|)
expr_stmt|;
name|SASBADDNODE
argument_list|(
name|sb
argument_list|,
operator|*
name|indent
argument_list|,
name|density_code_list
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|type_data
operator|->
name|num_density_codes
condition|;
name|i
operator|++
control|)
block|{
name|SASBADDUINTDESC
argument_list|(
name|sb
argument_list|,
operator|*
name|indent
argument_list|,
name|type_data
operator|->
name|primary_density_codes
index|[
name|i
index|]
argument_list|,
operator|%
name|u
argument_list|,
name|density_code
argument_list|,
literal|"Density Code"
argument_list|)
expr_stmt|;
block|}
name|SASBENDNODE
argument_list|(
name|sb
argument_list|,
operator|*
name|indent
argument_list|,
name|density_code_list
argument_list|)
expr_stmt|;
name|SAFILLDENSSB
argument_list|(
name|type_data
argument_list|,
name|sb
argument_list|,
operator|*
name|indent
argument_list|,
name|media_width
argument_list|,
name|desc_remain
argument_list|,
name|len_to_go
argument_list|,
name|cur_offset
argument_list|,
literal|"Media width"
argument_list|)
expr_stmt|;
name|SAFILLDENSSB
argument_list|(
name|type_data
argument_list|,
name|sb
argument_list|,
operator|*
name|indent
argument_list|,
name|medium_length
argument_list|,
name|desc_remain
argument_list|,
name|len_to_go
argument_list|,
name|cur_offset
argument_list|,
literal|"Medium length"
argument_list|)
expr_stmt|;
comment|/* 			 * Account for the two reserved bytes. 			 */
name|cur_field_len
operator|=
sizeof|sizeof
argument_list|(
name|type_data
operator|->
name|reserved2
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc_remain
operator|<
name|cur_field_len
condition|)
block|{
name|len_to_go
operator|-=
name|desc_remain
expr_stmt|;
name|cur_offset
operator|+=
name|desc_remain
expr_stmt|;
continue|continue;
block|}
name|len_to_go
operator|-=
name|cur_field_len
expr_stmt|;
name|cur_offset
operator|+=
name|cur_field_len
expr_stmt|;
name|desc_remain
operator|-=
name|cur_field_len
expr_stmt|;
name|SAFILLDENSSBSTR
argument_list|(
name|type_data
argument_list|,
name|sb
argument_list|,
operator|*
name|indent
argument_list|,
name|assigning_org
argument_list|,
name|desc_remain
argument_list|,
name|len_to_go
argument_list|,
name|cur_offset
argument_list|,
literal|"Assigning Organization"
argument_list|)
expr_stmt|;
name|SAFILLDENSSBSTR
argument_list|(
name|type_data
argument_list|,
name|sb
argument_list|,
operator|*
name|indent
argument_list|,
name|medium_type_name
argument_list|,
name|desc_remain
argument_list|,
name|len_to_go
argument_list|,
name|cur_offset
argument_list|,
literal|"Medium type name"
argument_list|)
expr_stmt|;
name|SAFILLDENSSBSTR
argument_list|(
name|type_data
argument_list|,
name|sb
argument_list|,
operator|*
name|indent
argument_list|,
name|description
argument_list|,
name|desc_remain
argument_list|,
name|len_to_go
argument_list|,
name|cur_offset
argument_list|,
literal|"Description"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|need_close
operator|!=
literal|0
condition|)
block|{
name|SASBENDNODE
argument_list|(
name|sb
argument_list|,
operator|*
name|indent
argument_list|,
name|density_entry
argument_list|)
expr_stmt|;
block|}
name|bailout
label|:
return|return;
block|}
end_function

begin_comment
comment|/*  * Fill an sbuf with density data information  */
end_comment

begin_function
specifier|static
name|void
name|safilldensitysb
parameter_list|(
name|struct
name|sa_softc
modifier|*
name|softc
parameter_list|,
name|int
modifier|*
name|indent
parameter_list|,
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|is_density
decl_stmt|;
name|SASBADDNODE
argument_list|(
name|sb
argument_list|,
operator|*
name|indent
argument_list|,
name|mtdensity
argument_list|)
expr_stmt|;
name|SASBADDUINTDESC
argument_list|(
name|sb
argument_list|,
operator|*
name|indent
argument_list|,
name|softc
operator|->
name|media_density
argument_list|,
operator|%
name|u
argument_list|,
name|media_density
argument_list|,
literal|"Current Medium Density"
argument_list|)
expr_stmt|;
name|is_density
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SA_DENSITY_TYPES
condition|;
name|i
operator|++
control|)
block|{
name|int
name|tmpint
decl_stmt|;
if|if
condition|(
name|softc
operator|->
name|density_info_valid
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
name|SASBADDNODE
argument_list|(
name|sb
argument_list|,
operator|*
name|indent
argument_list|,
name|density_report
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|density_type_bits
index|[
name|i
index|]
operator|&
name|SRDS_MEDIUM_TYPE
condition|)
block|{
name|tmpint
operator|=
literal|1
expr_stmt|;
name|is_density
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|tmpint
operator|=
literal|0
expr_stmt|;
name|is_density
operator|=
literal|1
expr_stmt|;
block|}
name|SASBADDINTDESC
argument_list|(
name|sb
argument_list|,
operator|*
name|indent
argument_list|,
name|tmpint
argument_list|,
operator|%
name|d
argument_list|,
name|medium_type_report
argument_list|,
literal|"Medium type report"
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|density_type_bits
index|[
name|i
index|]
operator|&
name|SRDS_MEDIA
condition|)
name|tmpint
operator|=
literal|1
expr_stmt|;
else|else
name|tmpint
operator|=
literal|0
expr_stmt|;
name|SASBADDINTDESC
argument_list|(
name|sb
argument_list|,
operator|*
name|indent
argument_list|,
name|tmpint
argument_list|,
operator|%
name|d
argument_list|,
name|media_report
argument_list|,
literal|"Media report"
argument_list|)
expr_stmt|;
name|safilldenstypesb
argument_list|(
name|sb
argument_list|,
name|indent
argument_list|,
name|softc
operator|->
name|density_info
index|[
name|i
index|]
argument_list|,
name|softc
operator|->
name|density_info_valid
index|[
name|i
index|]
argument_list|,
name|is_density
argument_list|)
expr_stmt|;
name|SASBENDNODE
argument_list|(
name|sb
argument_list|,
operator|*
name|indent
argument_list|,
name|density_report
argument_list|)
expr_stmt|;
block|}
name|SASBENDNODE
argument_list|(
name|sb
argument_list|,
operator|*
name|indent
argument_list|,
name|mtdensity
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _KERNEL */
end_comment

begin_comment
comment|/*  * Read tape block limits command.  */
end_comment

begin_function
name|void
name|scsi_read_block_limits
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|struct
name|scsi_read_block_limits_data
modifier|*
name|rlimit_buf
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_read_block_limits
modifier|*
name|scsi_cmd
decl_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
name|CAM_DIR_IN
argument_list|,
name|tag_action
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
name|rlimit_buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rlimit_buf
argument_list|)
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_read_block_limits
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|READ_BLOCK_LIMITS
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_sa_read_write
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|int
name|readop
parameter_list|,
name|int
name|sli
parameter_list|,
name|int
name|fixed
parameter_list|,
name|u_int32_t
name|length
parameter_list|,
name|u_int8_t
modifier|*
name|data_ptr
parameter_list|,
name|u_int32_t
name|dxfer_len
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_sa_rw
modifier|*
name|scsi_cmd
decl_stmt|;
name|int
name|read
decl_stmt|;
name|read
operator|=
operator|(
name|readop
operator|&
name|SCSI_RW_DIRMASK
operator|)
operator|==
name|SCSI_RW_READ
expr_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_sa_rw
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|read
condition|?
name|SA_READ
else|:
name|SA_WRITE
expr_stmt|;
name|scsi_cmd
operator|->
name|sli_fixed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sli
operator|&&
name|read
condition|)
name|scsi_cmd
operator|->
name|sli_fixed
operator||=
name|SAR_SLI
expr_stmt|;
if|if
condition|(
name|fixed
condition|)
name|scsi_cmd
operator|->
name|sli_fixed
operator||=
name|SARW_FIXED
expr_stmt|;
name|scsi_ulto3b
argument_list|(
name|length
argument_list|,
name|scsi_cmd
operator|->
name|length
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|control
operator|=
literal|0
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
operator|(
name|read
condition|?
name|CAM_DIR_IN
else|:
name|CAM_DIR_OUT
operator|)
operator||
operator|(
operator|(
name|readop
operator|&
name|SCSI_RW_BIO
operator|)
operator|!=
literal|0
condition|?
name|CAM_DATA_BIO
else|:
literal|0
operator|)
argument_list|,
name|tag_action
argument_list|,
name|data_ptr
argument_list|,
name|dxfer_len
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_load_unload
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|int
name|immediate
parameter_list|,
name|int
name|eot
parameter_list|,
name|int
name|reten
parameter_list|,
name|int
name|load
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_load_unload
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_load_unload
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|LOAD_UNLOAD
expr_stmt|;
if|if
condition|(
name|immediate
condition|)
name|scsi_cmd
operator|->
name|immediate
operator|=
name|SLU_IMMED
expr_stmt|;
if|if
condition|(
name|eot
condition|)
name|scsi_cmd
operator|->
name|eot_reten_load
operator||=
name|SLU_EOT
expr_stmt|;
if|if
condition|(
name|reten
condition|)
name|scsi_cmd
operator|->
name|eot_reten_load
operator||=
name|SLU_RETEN
expr_stmt|;
if|if
condition|(
name|load
condition|)
name|scsi_cmd
operator|->
name|eot_reten_load
operator||=
name|SLU_LOAD
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
name|CAM_DIR_NONE
argument_list|,
name|tag_action
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_rewind
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|int
name|immediate
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_rewind
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_rewind
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|REWIND
expr_stmt|;
if|if
condition|(
name|immediate
condition|)
name|scsi_cmd
operator|->
name|immediate
operator|=
name|SREW_IMMED
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
name|CAM_DIR_NONE
argument_list|,
name|tag_action
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_space
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|scsi_space_code
name|code
parameter_list|,
name|u_int32_t
name|count
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_space
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_space
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|SPACE
expr_stmt|;
name|scsi_cmd
operator|->
name|code
operator|=
name|code
expr_stmt|;
name|scsi_ulto3b
argument_list|(
name|count
argument_list|,
name|scsi_cmd
operator|->
name|count
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|control
operator|=
literal|0
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
name|CAM_DIR_NONE
argument_list|,
name|tag_action
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_write_filemarks
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|int
name|immediate
parameter_list|,
name|int
name|setmark
parameter_list|,
name|u_int32_t
name|num_marks
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_write_filemarks
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_write_filemarks
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|WRITE_FILEMARKS
expr_stmt|;
if|if
condition|(
name|immediate
condition|)
name|scsi_cmd
operator|->
name|byte2
operator||=
name|SWFMRK_IMMED
expr_stmt|;
if|if
condition|(
name|setmark
condition|)
name|scsi_cmd
operator|->
name|byte2
operator||=
name|SWFMRK_WSMK
expr_stmt|;
name|scsi_ulto3b
argument_list|(
name|num_marks
argument_list|,
name|scsi_cmd
operator|->
name|num_marks
argument_list|)
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
name|CAM_DIR_NONE
argument_list|,
name|tag_action
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The reserve and release unit commands differ only by their opcodes.  */
end_comment

begin_function
name|void
name|scsi_reserve_release_unit
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|int
name|third_party
parameter_list|,
name|int
name|third_party_id
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|,
name|int
name|reserve
parameter_list|)
block|{
name|struct
name|scsi_reserve_release_unit
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_reserve_release_unit
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reserve
condition|)
name|scsi_cmd
operator|->
name|opcode
operator|=
name|RESERVE_UNIT
expr_stmt|;
else|else
name|scsi_cmd
operator|->
name|opcode
operator|=
name|RELEASE_UNIT
expr_stmt|;
if|if
condition|(
name|third_party
condition|)
block|{
name|scsi_cmd
operator|->
name|lun_thirdparty
operator||=
name|SRRU_3RD_PARTY
expr_stmt|;
name|scsi_cmd
operator|->
name|lun_thirdparty
operator||=
operator|(
operator|(
name|third_party_id
operator|<<
name|SRRU_3RD_SHAMT
operator|)
operator|&
name|SRRU_3RD_MASK
operator|)
expr_stmt|;
block|}
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
name|CAM_DIR_NONE
argument_list|,
name|tag_action
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_erase
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|int
name|immediate
parameter_list|,
name|int
name|long_erase
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_erase
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_erase
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|ERASE
expr_stmt|;
if|if
condition|(
name|immediate
condition|)
name|scsi_cmd
operator|->
name|lun_imm_long
operator||=
name|SE_IMMED
expr_stmt|;
if|if
condition|(
name|long_erase
condition|)
name|scsi_cmd
operator|->
name|lun_imm_long
operator||=
name|SE_LONG
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
name|CAM_DIR_NONE
argument_list|,
name|tag_action
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read Tape Position command.  */
end_comment

begin_function
name|void
name|scsi_read_position
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|int
name|hardsoft
parameter_list|,
name|struct
name|scsi_tape_position_data
modifier|*
name|sbp
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_tape_read_position
modifier|*
name|scmd
decl_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
name|CAM_DIR_IN
argument_list|,
name|tag_action
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
name|sbp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sbp
argument_list|)
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|scmd
operator|=
operator|(
expr|struct
name|scsi_tape_read_position
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scmd
argument_list|)
argument_list|)
expr_stmt|;
name|scmd
operator|->
name|opcode
operator|=
name|READ_POSITION
expr_stmt|;
name|scmd
operator|->
name|byte1
operator|=
name|hardsoft
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read Tape Position command.  */
end_comment

begin_function
name|void
name|scsi_read_position_10
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|int
name|service_action
parameter_list|,
name|u_int8_t
modifier|*
name|data_ptr
parameter_list|,
name|u_int32_t
name|length
parameter_list|,
name|u_int32_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_tape_read_position
modifier|*
name|scmd
decl_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|CAM_DIR_IN
argument_list|,
name|tag_action
argument_list|,
comment|/*data_ptr*/
name|data_ptr
argument_list|,
comment|/*dxfer_len*/
name|length
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|scmd
operator|=
operator|(
expr|struct
name|scsi_tape_read_position
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scmd
argument_list|)
argument_list|)
expr_stmt|;
name|scmd
operator|->
name|opcode
operator|=
name|READ_POSITION
expr_stmt|;
name|scmd
operator|->
name|byte1
operator|=
name|service_action
expr_stmt|;
comment|/* 	 * The length is only currently set (as of SSC4r03) if the extended 	 * form is specified.  The other forms have fixed lengths. 	 */
if|if
condition|(
name|service_action
operator|==
name|SA_RPOS_EXTENDED_FORM
condition|)
name|scsi_ulto2b
argument_list|(
name|length
argument_list|,
name|scmd
operator|->
name|length
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set Tape Position command.  */
end_comment

begin_function
name|void
name|scsi_set_position
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|int
name|hardsoft
parameter_list|,
name|u_int32_t
name|blkno
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_tape_locate
modifier|*
name|scmd
decl_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
name|CAM_DIR_NONE
argument_list|,
name|tag_action
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|scmd
operator|=
operator|(
expr|struct
name|scsi_tape_locate
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scmd
argument_list|)
argument_list|)
expr_stmt|;
name|scmd
operator|->
name|opcode
operator|=
name|LOCATE
expr_stmt|;
if|if
condition|(
name|hardsoft
condition|)
name|scmd
operator|->
name|byte1
operator||=
name|SA_SPOS_BT
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|blkno
argument_list|,
name|scmd
operator|->
name|blkaddr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * XXX KDM figure out how to make a compatibility function.  */
end_comment

begin_function
name|void
name|scsi_locate_10
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|int
name|immed
parameter_list|,
name|int
name|cp
parameter_list|,
name|int
name|hard
parameter_list|,
name|int64_t
name|partition
parameter_list|,
name|u_int32_t
name|block_address
parameter_list|,
name|int
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_tape_locate
modifier|*
name|scmd
decl_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
name|CAM_DIR_NONE
argument_list|,
name|tag_action
argument_list|,
comment|/*data_ptr*/
name|NULL
argument_list|,
comment|/*dxfer_len*/
literal|0
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|scmd
operator|=
operator|(
expr|struct
name|scsi_tape_locate
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scmd
argument_list|)
argument_list|)
expr_stmt|;
name|scmd
operator|->
name|opcode
operator|=
name|LOCATE
expr_stmt|;
if|if
condition|(
name|immed
condition|)
name|scmd
operator|->
name|byte1
operator||=
name|SA_SPOS_IMMED
expr_stmt|;
if|if
condition|(
name|cp
condition|)
name|scmd
operator|->
name|byte1
operator||=
name|SA_SPOS_CP
expr_stmt|;
if|if
condition|(
name|hard
condition|)
name|scmd
operator|->
name|byte1
operator||=
name|SA_SPOS_BT
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|block_address
argument_list|,
name|scmd
operator|->
name|blkaddr
argument_list|)
expr_stmt|;
name|scmd
operator|->
name|partition
operator|=
name|partition
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_locate_16
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|int
name|immed
parameter_list|,
name|int
name|cp
parameter_list|,
name|u_int8_t
name|dest_type
parameter_list|,
name|int
name|bam
parameter_list|,
name|int64_t
name|partition
parameter_list|,
name|u_int64_t
name|logical_id
parameter_list|,
name|int
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_locate_16
modifier|*
name|scsi_cmd
decl_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|CAM_DIR_NONE
argument_list|,
name|tag_action
argument_list|,
comment|/*data_ptr*/
name|NULL
argument_list|,
comment|/*dxfer_len*/
literal|0
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_locate_16
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|LOCATE_16
expr_stmt|;
if|if
condition|(
name|immed
condition|)
name|scsi_cmd
operator|->
name|byte1
operator||=
name|SA_LC_IMMEDIATE
expr_stmt|;
if|if
condition|(
name|cp
condition|)
name|scsi_cmd
operator|->
name|byte1
operator||=
name|SA_LC_CP
expr_stmt|;
name|scsi_cmd
operator|->
name|byte1
operator||=
operator|(
name|dest_type
operator|<<
name|SA_LC_DEST_TYPE_SHIFT
operator|)
expr_stmt|;
name|scsi_cmd
operator|->
name|byte2
operator||=
name|bam
expr_stmt|;
name|scsi_cmd
operator|->
name|partition
operator|=
name|partition
expr_stmt|;
name|scsi_u64to8b
argument_list|(
name|logical_id
argument_list|,
name|scsi_cmd
operator|->
name|logical_id
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_report_density_support
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|int
name|media
parameter_list|,
name|int
name|medium_type
parameter_list|,
name|u_int8_t
modifier|*
name|data_ptr
parameter_list|,
name|u_int32_t
name|length
parameter_list|,
name|u_int32_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_report_density_support
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_report_density_support
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|REPORT_DENSITY_SUPPORT
expr_stmt|;
if|if
condition|(
name|media
operator|!=
literal|0
condition|)
name|scsi_cmd
operator|->
name|byte1
operator||=
name|SRDS_MEDIA
expr_stmt|;
if|if
condition|(
name|medium_type
operator|!=
literal|0
condition|)
name|scsi_cmd
operator|->
name|byte1
operator||=
name|SRDS_MEDIUM_TYPE
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|length
argument_list|,
name|scsi_cmd
operator|->
name|length
argument_list|)
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|CAM_DIR_IN
argument_list|,
name|tag_action
argument_list|,
comment|/*data_ptr*/
name|data_ptr
argument_list|,
comment|/*dxfer_len*/
name|length
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_set_capacity
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|int
name|byte1
parameter_list|,
name|u_int32_t
name|proportion
parameter_list|,
name|u_int32_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_set_capacity
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_set_capacity
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|SET_CAPACITY
expr_stmt|;
name|scsi_cmd
operator|->
name|byte1
operator|=
name|byte1
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|proportion
argument_list|,
name|scsi_cmd
operator|->
name|cap_proportion
argument_list|)
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|CAM_DIR_NONE
argument_list|,
name|tag_action
argument_list|,
comment|/*data_ptr*/
name|NULL
argument_list|,
comment|/*dxfer_len*/
literal|0
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_format_medium
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|int
name|byte1
parameter_list|,
name|int
name|byte2
parameter_list|,
name|u_int8_t
modifier|*
name|data_ptr
parameter_list|,
name|u_int32_t
name|dxfer_len
parameter_list|,
name|u_int32_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_format_medium
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_format_medium
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|FORMAT_MEDIUM
expr_stmt|;
name|scsi_cmd
operator|->
name|byte1
operator|=
name|byte1
expr_stmt|;
name|scsi_cmd
operator|->
name|byte2
operator|=
name|byte2
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|dxfer_len
argument_list|,
name|scsi_cmd
operator|->
name|length
argument_list|)
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
operator|(
name|dxfer_len
operator|>
literal|0
operator|)
condition|?
name|CAM_DIR_OUT
else|:
name|CAM_DIR_NONE
argument_list|,
name|tag_action
argument_list|,
comment|/*data_ptr*/
name|data_ptr
argument_list|,
comment|/*dxfer_len*/
name|dxfer_len
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_allow_overwrite
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|int
name|allow_overwrite
parameter_list|,
name|int
name|partition
parameter_list|,
name|u_int64_t
name|logical_id
parameter_list|,
name|u_int32_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_allow_overwrite
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_allow_overwrite
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|ALLOW_OVERWRITE
expr_stmt|;
name|scsi_cmd
operator|->
name|allow_overwrite
operator|=
name|allow_overwrite
expr_stmt|;
name|scsi_cmd
operator|->
name|partition
operator|=
name|partition
expr_stmt|;
name|scsi_u64to8b
argument_list|(
name|logical_id
argument_list|,
name|scsi_cmd
operator|->
name|logical_id
argument_list|)
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
name|CAM_DIR_NONE
argument_list|,
name|tag_action
argument_list|,
comment|/*data_ptr*/
name|NULL
argument_list|,
comment|/*dxfer_len*/
literal|0
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

