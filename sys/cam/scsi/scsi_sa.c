begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Implementation of SCSI Sequential Access Peripheral driver for CAM.  *  * Copyright (c) 1997 Justin T. Gibbs  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *      $Id: scsi_sa.c,v 1.2 1998/10/02 05:15:27 ken Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mtio.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/devicestat.h>
end_include

begin_include
include|#
directive|include
file|<machine/limits.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|KERNEL
end_ifndef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_extend.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_sa.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<opt_sa.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|SA_SPACE_TIMEOUT
end_ifndef

begin_define
define|#
directive|define
name|SA_SPACE_TIMEOUT
value|1 * 60
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SA_REWIND_TIMEOUT
end_ifndef

begin_define
define|#
directive|define
name|SA_REWIND_TIMEOUT
value|2 * 60
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SA_ERASE_TIMEOUT
end_ifndef

begin_define
define|#
directive|define
name|SA_ERASE_TIMEOUT
value|4 * 60
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SAUNIT
parameter_list|(
name|DEV
parameter_list|)
value|((minor(DEV)&0xF0)>> 4)
end_define

begin_comment
comment|/* 4 bit unit.	*/
end_comment

begin_define
define|#
directive|define
name|SASETUNIT
parameter_list|(
name|DEV
parameter_list|,
name|U
parameter_list|)
value|makedev(major(DEV), ((U)<< 4))
end_define

begin_typedef
typedef|typedef
enum|enum
block|{
name|SA_STATE_NORMAL
block|}
name|sa_state
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|SA_CCB_BUFFER_IO
block|,
name|SA_CCB_WAITING
block|}
name|sa_ccb_types
typedef|;
end_typedef

begin_define
define|#
directive|define
name|ccb_type
value|ppriv_field0
end_define

begin_define
define|#
directive|define
name|ccb_bp
value|ppriv_ptr1
end_define

begin_typedef
typedef|typedef
enum|enum
block|{
name|SA_FLAG_OPEN
init|=
literal|0x0001
block|,
name|SA_FLAG_FIXED
init|=
literal|0x0002
block|,
name|SA_FLAG_TAPE_LOCKED
init|=
literal|0x0004
block|,
name|SA_FLAG_TAPE_MOUNTED
init|=
literal|0x0008
block|,
name|SA_FLAG_TAPE_WP
init|=
literal|0x0010
block|,
name|SA_FLAG_TAPE_WRITTEN
init|=
literal|0x0020
block|,
name|SA_FLAG_2FM_AT_EOD
init|=
literal|0x0040
block|,
name|SA_FLAG_EOM_PENDING
init|=
literal|0x0080
block|,
name|SA_FLAG_EIO_PENDING
init|=
literal|0x0100
block|,
name|SA_FLAG_EOF_PENDING
init|=
literal|0x0200
block|,
name|SA_FLAG_ERR_PENDING
init|=
operator|(
name|SA_FLAG_EOM_PENDING
operator||
name|SA_FLAG_EIO_PENDING
operator||
name|SA_FLAG_EOF_PENDING
operator|)
block|,
name|SA_FLAG_INVALID
init|=
literal|0x0400
block|,
name|SA_FLAG_COMP_ENABLED
init|=
literal|0x0800
block|,
name|SA_FLAG_COMP_UNSUPP
init|=
literal|0x1000
block|}
name|sa_flags
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|SA_MODE_REWIND
init|=
literal|0x00
block|,
name|SA_MODE_NOREWIND
init|=
literal|0x01
block|,
name|SA_MODE_OFFLINE
init|=
literal|0x02
block|}
name|sa_mode
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|SA_PARAM_NONE
init|=
literal|0x00
block|,
name|SA_PARAM_BLOCKSIZE
init|=
literal|0x01
block|,
name|SA_PARAM_DENSITY
init|=
literal|0x02
block|,
name|SA_PARAM_COMPRESSION
init|=
literal|0x04
block|,
name|SA_PARAM_BUFF_MODE
init|=
literal|0x08
block|,
name|SA_PARAM_NUMBLOCKS
init|=
literal|0x10
block|,
name|SA_PARAM_WP
init|=
literal|0x20
block|,
name|SA_PARAM_SPEED
init|=
literal|0x40
block|,
name|SA_PARAM_ALL
init|=
literal|0x7f
block|}
name|sa_params
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|SA_QUIRK_NONE
init|=
literal|0x00
block|,
name|SA_QUIRK_NOCOMP
init|=
literal|0x01
block|}
name|sa_quirks
typedef|;
end_typedef

begin_struct
struct|struct
name|sa_softc
block|{
name|sa_state
name|state
decl_stmt|;
name|sa_flags
name|flags
decl_stmt|;
name|sa_quirks
name|quirks
decl_stmt|;
name|struct
name|buf_queue_head
name|buf_queue
decl_stmt|;
name|struct
name|devstat
name|device_stats
decl_stmt|;
name|int
name|blk_gran
decl_stmt|;
name|int
name|blk_mask
decl_stmt|;
name|int
name|blk_shift
decl_stmt|;
name|u_int32_t
name|max_blk
decl_stmt|;
name|u_int32_t
name|min_blk
decl_stmt|;
name|u_int8_t
name|media_density
decl_stmt|;
name|u_int32_t
name|media_blksize
decl_stmt|;
name|u_int32_t
name|media_numblks
decl_stmt|;
name|u_int32_t
name|comp_algorithm
decl_stmt|;
name|u_int32_t
name|saved_comp_algorithm
decl_stmt|;
name|u_int8_t
name|speed
decl_stmt|;
name|int
name|buffer_mode
decl_stmt|;
name|int
name|filemarks
decl_stmt|;
name|union
name|ccb
name|saved_ccb
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sa_quirk_entry
block|{
name|struct
name|scsi_inquiry_pattern
name|inq_pat
decl_stmt|;
name|sa_quirks
name|quirks
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|sa_quirk_entry
name|sa_quirk_table
index|[]
init|=
block|{
block|{
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"ARCHIVE"
block|,
literal|"Python 25601*"
block|,
literal|"*"
block|}
block|,
comment|/*quirks*/
name|SA_QUIRK_NOCOMP
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|saopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|saread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|sawrite
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|saclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_strategy_t
name|sastrategy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|saioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_init_t
name|sainit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_ctor_t
name|saregister
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_dtor_t
name|sacleanup
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_start_t
name|sastart
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|saasync
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|u_int32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sadone
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|start_ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|saerror
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|u_int32_t
name|cam_flags
parameter_list|,
name|u_int32_t
name|sense_flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sacheckeod
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sagetparams
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|sa_params
name|params_to_get
parameter_list|,
name|u_int32_t
modifier|*
name|blocksize
parameter_list|,
name|u_int8_t
modifier|*
name|density
parameter_list|,
name|u_int32_t
modifier|*
name|numblocks
parameter_list|,
name|int
modifier|*
name|buff_mode
parameter_list|,
name|u_int8_t
modifier|*
name|write_protect
parameter_list|,
name|u_int8_t
modifier|*
name|speed
parameter_list|,
name|int
modifier|*
name|comp_supported
parameter_list|,
name|int
modifier|*
name|comp_enabled
parameter_list|,
name|u_int32_t
modifier|*
name|comp_algorithm
parameter_list|,
name|struct
name|scsi_data_compression_page
modifier|*
name|comp_page
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sasetparams
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|sa_params
name|params_to_set
parameter_list|,
name|u_int32_t
name|blocksize
parameter_list|,
name|u_int8_t
name|density
parameter_list|,
name|u_int32_t
name|comp_algorithm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|saprevent
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|action
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sarewind
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|saspace
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|count
parameter_list|,
name|scsi_space_code
name|code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|samount
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|saretension
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sareservereleaseunit
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|reserve
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|saloadunload
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|load
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|saerase
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|longerase
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sawritefilemarks
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|nmarks
parameter_list|,
name|int
name|setmarks
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|periph_driver
name|sadriver
init|=
block|{
name|sainit
block|,
literal|"sa"
block|,
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|sadriver
operator|.
name|units
argument_list|)
block|,
comment|/* generation */
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DATA_SET
argument_list|(
name|periphdriver_set
argument_list|,
name|sadriver
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|SAUNIT
parameter_list|(
name|DEV
parameter_list|)
value|((minor(DEV)&0xF0)>> 4)
end_define

begin_comment
comment|/* 4 bit unit. */
end_comment

begin_define
define|#
directive|define
name|SASETUNIT
parameter_list|(
name|DEV
parameter_list|,
name|U
parameter_list|)
value|makedev(major(DEV), ((U)<< 4))
end_define

begin_define
define|#
directive|define
name|SAMODE
parameter_list|(
name|z
parameter_list|)
value|((minor(z)& 0x03))
end_define

begin_define
define|#
directive|define
name|SADENSITY
parameter_list|(
name|z
parameter_list|)
value|(((minor(z)>> 2)& 0x03))
end_define

begin_comment
comment|/* For 2.2-stable support */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|D_TAPE
end_ifndef

begin_define
define|#
directive|define
name|D_TAPE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CTLMODE
value|3
end_define

begin_define
define|#
directive|define
name|SA_CDEV_MAJOR
value|14
end_define

begin_define
define|#
directive|define
name|SA_BDEV_MAJOR
value|5
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|sa_cdevsw
init|=
block|{
comment|/*d_open*/
name|saopen
block|,
comment|/*d_close*/
name|saclose
block|,
comment|/*d_read*/
name|saread
block|,
comment|/*d_write*/
name|sawrite
block|,
comment|/*d_ioctl*/
name|saioctl
block|,
comment|/*d_stop*/
name|nostop
block|,
comment|/*d_reset*/
name|noreset
block|,
comment|/*d_devtotty*/
name|nodevtotty
block|,
comment|/*d_poll*/
name|seltrue
block|,
comment|/*d_mmap*/
name|nommap
block|,
comment|/*d_strategy*/
name|sastrategy
block|,
comment|/*d_name*/
literal|"sa"
block|,
comment|/*d_spare*/
name|NULL
block|,
comment|/*d_maj*/
operator|-
literal|1
block|,
comment|/*d_dump*/
name|nodump
block|,
comment|/*d_psize*/
name|nopsize
block|,
comment|/*d_flags*/
name|D_TAPE
block|,
comment|/*d_maxio*/
literal|0
block|,
comment|/*b_maj*/
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|extend_array
modifier|*
name|saperiphs
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|saopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
name|density
decl_stmt|;
name|int
name|error
decl_stmt|;
name|unit
operator|=
name|SAUNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mode
operator|=
name|SAMODE
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|density
operator|=
name|SADENSITY
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|periph
operator|=
name|cam_extend_get
argument_list|(
name|saperiphs
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"saaopen: dev=0x%x (unit %d , mode %d, density %d)\n"
operator|,
name|dev
operator|,
name|unit
operator|,
name|mode
operator|,
name|density
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_INVALID
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|cam_periph_lock
argument_list|(
name|periph
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
comment|/* error code from tsleep */
block|}
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_OPEN
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cam_periph_acquire
argument_list|(
name|periph
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|sareservereleaseunit
argument_list|(
name|periph
argument_list|,
name|TRUE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|cam_periph_release
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_OPEN
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|samount
argument_list|(
name|periph
argument_list|)
expr_stmt|;
block|}
comment|/* Perform other checking... */
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|saprevent
argument_list|(
name|periph
argument_list|,
name|PR_PREVENT
argument_list|)
expr_stmt|;
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_OPEN
expr_stmt|;
block|}
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|saclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
name|error
decl_stmt|;
name|unit
operator|=
name|SAUNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mode
operator|=
name|SAMODE
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|periph
operator|=
name|cam_extend_get
argument_list|(
name|saperiphs
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|cam_periph_lock
argument_list|(
name|periph
argument_list|,
name|PRIBIO
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
comment|/* error code from tsleep */
block|}
name|sacheckeod
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|saprevent
argument_list|(
name|periph
argument_list|,
name|PR_ALLOW
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|SA_MODE_REWIND
case|:
name|sarewind
argument_list|(
name|periph
argument_list|)
expr_stmt|;
break|break;
case|case
name|SA_MODE_OFFLINE
case|:
name|sarewind
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|saloadunload
argument_list|(
name|periph
argument_list|,
comment|/*load*/
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|SA_MODE_NOREWIND
case|:
default|default:
break|break;
block|}
name|softc
operator|->
name|flags
operator|&=
operator|~
name|SA_FLAG_OPEN
expr_stmt|;
comment|/* release the device */
name|sareservereleaseunit
argument_list|(
name|periph
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|cam_periph_release
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|saread
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
return|return
operator|(
name|physio
argument_list|(
name|sastrategy
argument_list|,
name|NULL
argument_list|,
name|dev
argument_list|,
literal|1
argument_list|,
name|minphys
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sawrite
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
return|return
operator|(
name|physio
argument_list|(
name|sastrategy
argument_list|,
name|NULL
argument_list|,
name|dev
argument_list|,
literal|0
argument_list|,
name|minphys
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Actually translate the requested transfer into one the physical driver  * can understand.  The transfer is described by a buf and will include  * only one physical transfer.  */
end_comment

begin_function
specifier|static
name|void
name|sastrategy
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|u_int
name|unit
decl_stmt|;
name|int
name|s
decl_stmt|;
name|unit
operator|=
name|SAUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
name|periph
operator|=
name|cam_extend_get
argument_list|(
name|saperiphs
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
comment|/* 	 * If it's a null transfer, return immediatly 	 */
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* valid request?  */
if|if
condition|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_FIXED
condition|)
block|{
comment|/* 		 * Fixed block device.  The byte count must 		 * be a multiple of our block size. 		 */
if|if
condition|(
operator|(
operator|(
name|softc
operator|->
name|blk_mask
operator|!=
operator|~
literal|0
operator|)
operator|&&
operator|(
operator|(
name|bp
operator|->
name|b_bcount
operator|&
name|softc
operator|->
name|blk_mask
operator|)
operator|!=
literal|0
operator|)
operator|)
operator|||
operator|(
operator|(
name|softc
operator|->
name|blk_mask
operator|==
operator|~
literal|0
operator|)
operator|&&
operator|(
operator|(
name|bp
operator|->
name|b_bcount
operator|%
name|softc
operator|->
name|min_blk
operator|)
operator|!=
literal|0
operator|)
operator|)
condition|)
block|{
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Invalid request.  Fixed block device "
literal|"requests must be a multiple "
literal|"of %d bytes\n"
argument_list|,
name|softc
operator|->
name|min_blk
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|bp
operator|->
name|b_bcount
operator|>
name|softc
operator|->
name|max_blk
operator|)
operator|||
operator|(
name|bp
operator|->
name|b_bcount
operator|<
name|softc
operator|->
name|min_blk
operator|)
operator|||
operator|(
name|bp
operator|->
name|b_bcount
operator|&
name|softc
operator|->
name|blk_mask
operator|)
operator|!=
literal|0
condition|)
block|{
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Invalid request.  Variable block device "
literal|"requests must be "
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|blk_mask
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"a multiple of %d "
argument_list|,
operator|(
literal|0x1
operator|<<
name|softc
operator|->
name|blk_gran
operator|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"between %d and %d bytes\n"
argument_list|,
name|softc
operator|->
name|min_blk
argument_list|,
name|softc
operator|->
name|max_blk
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Mask interrupts so that the pack cannot be invalidated until 	 * after we are in the queue.  Otherwise, we might not properly 	 * clean up one of the buffers. 	 */
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* 	 * Place it in the queue of disk activities for this disk 	 */
name|bufq_insert_tail
argument_list|(
operator|&
name|softc
operator|->
name|buf_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Schedule ourselves for performing the work. 	 */
name|xpt_schedule
argument_list|(
name|periph
argument_list|,
comment|/* XXX priority */
literal|1
argument_list|)
expr_stmt|;
return|return;
name|bad
label|:
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|done
label|:
comment|/* 	 * Correctly set the buf to indicate a completed xfer 	 */
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|saioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
name|density
decl_stmt|;
name|int
name|error
decl_stmt|;
name|unit
operator|=
name|SAUNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mode
operator|=
name|SAMODE
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|density
operator|=
name|SADENSITY
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|periph
operator|=
name|cam_extend_get
argument_list|(
name|saperiphs
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
comment|/* 	 * Find the device that the user is talking about 	 */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MTIOCGET
case|:
block|{
name|struct
name|mtget
modifier|*
name|g
init|=
operator|(
expr|struct
name|mtget
operator|*
operator|)
name|arg
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"saioctl: MTIOGET\n"
operator|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|g
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mtget
argument_list|)
argument_list|)
expr_stmt|;
name|g
operator|->
name|mt_type
operator|=
literal|0x7
expr_stmt|;
comment|/* Ultrix compat */
comment|/*? */
name|g
operator|->
name|mt_density
operator|=
name|softc
operator|->
name|media_density
expr_stmt|;
name|g
operator|->
name|mt_blksiz
operator|=
name|softc
operator|->
name|media_blksize
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_COMP_UNSUPP
condition|)
block|{
name|g
operator|->
name|mt_comp
operator|=
name|MT_COMP_UNSUPP
expr_stmt|;
name|g
operator|->
name|mt_comp0
operator|=
name|MT_COMP_UNSUPP
expr_stmt|;
name|g
operator|->
name|mt_comp1
operator|=
name|MT_COMP_UNSUPP
expr_stmt|;
name|g
operator|->
name|mt_comp2
operator|=
name|MT_COMP_UNSUPP
expr_stmt|;
name|g
operator|->
name|mt_comp3
operator|=
name|MT_COMP_UNSUPP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_COMP_ENABLED
operator|)
operator|==
literal|0
condition|)
block|{
name|g
operator|->
name|mt_comp
operator|=
name|MT_COMP_DISABLED
expr_stmt|;
name|g
operator|->
name|mt_comp0
operator|=
name|MT_COMP_DISABLED
expr_stmt|;
name|g
operator|->
name|mt_comp1
operator|=
name|MT_COMP_DISABLED
expr_stmt|;
name|g
operator|->
name|mt_comp2
operator|=
name|MT_COMP_DISABLED
expr_stmt|;
name|g
operator|->
name|mt_comp3
operator|=
name|MT_COMP_DISABLED
expr_stmt|;
block|}
else|else
block|{
name|g
operator|->
name|mt_comp
operator|=
name|softc
operator|->
name|comp_algorithm
expr_stmt|;
name|g
operator|->
name|mt_comp0
operator|=
name|softc
operator|->
name|comp_algorithm
expr_stmt|;
name|g
operator|->
name|mt_comp1
operator|=
name|softc
operator|->
name|comp_algorithm
expr_stmt|;
name|g
operator|->
name|mt_comp2
operator|=
name|softc
operator|->
name|comp_algorithm
expr_stmt|;
name|g
operator|->
name|mt_comp3
operator|=
name|softc
operator|->
name|comp_algorithm
expr_stmt|;
block|}
name|g
operator|->
name|mt_density0
operator|=
name|softc
operator|->
name|media_density
expr_stmt|;
name|g
operator|->
name|mt_density1
operator|=
name|softc
operator|->
name|media_density
expr_stmt|;
name|g
operator|->
name|mt_density2
operator|=
name|softc
operator|->
name|media_density
expr_stmt|;
name|g
operator|->
name|mt_density3
operator|=
name|softc
operator|->
name|media_density
expr_stmt|;
name|g
operator|->
name|mt_blksiz0
operator|=
name|softc
operator|->
name|media_blksize
expr_stmt|;
name|g
operator|->
name|mt_blksiz1
operator|=
name|softc
operator|->
name|media_blksize
expr_stmt|;
name|g
operator|->
name|mt_blksiz2
operator|=
name|softc
operator|->
name|media_blksize
expr_stmt|;
name|g
operator|->
name|mt_blksiz3
operator|=
name|softc
operator|->
name|media_blksize
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
case|case
name|MTIOCTOP
case|:
block|{
name|struct
name|mtop
modifier|*
name|mt
decl_stmt|;
name|int
name|count
decl_stmt|;
name|mt
operator|=
operator|(
expr|struct
name|mtop
operator|*
operator|)
name|arg
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"saioctl: op=0x%x count=0x%x\n"
operator|,
name|mt
operator|->
name|mt_op
operator|,
name|mt
operator|->
name|mt_count
operator|)
argument_list|)
expr_stmt|;
name|count
operator|=
name|mt
operator|->
name|mt_count
expr_stmt|;
switch|switch
condition|(
name|mt
operator|->
name|mt_op
condition|)
block|{
case|case
name|MTWEOF
case|:
comment|/* write an end-of-file record */
name|error
operator|=
name|sawritefilemarks
argument_list|(
name|periph
argument_list|,
name|count
argument_list|,
comment|/*setmarks*/
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|MTBSR
case|:
comment|/* backward space record */
case|case
name|MTFSR
case|:
comment|/* forward space record */
case|case
name|MTBSF
case|:
comment|/* backward space file */
case|case
name|MTFSF
case|:
comment|/* forward space file */
case|case
name|MTEOD
case|:
comment|/* space to end of recorded medium */
block|{
name|int
name|nmarks
decl_stmt|;
name|scsi_space_code
name|spaceop
decl_stmt|;
name|nmarks
operator|=
name|softc
operator|->
name|filemarks
expr_stmt|;
name|error
operator|=
name|sacheckeod
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|nmarks
operator|-=
name|softc
operator|->
name|filemarks
expr_stmt|;
if|if
condition|(
operator|(
name|mt
operator|->
name|mt_op
operator|==
name|MTBSR
operator|)
operator|||
operator|(
name|mt
operator|->
name|mt_op
operator|==
name|MTBSF
operator|)
condition|)
name|count
operator|=
operator|-
name|count
expr_stmt|;
if|if
condition|(
operator|(
name|mt
operator|->
name|mt_op
operator|==
name|MTBSF
operator|)
operator|||
operator|(
name|mt
operator|->
name|mt_op
operator|==
name|MTFSF
operator|)
condition|)
name|spaceop
operator|=
name|SS_FILEMARKS
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|mt
operator|->
name|mt_op
operator|==
name|MTBSR
operator|)
operator|||
operator|(
name|mt
operator|->
name|mt_op
operator|==
name|MTFSR
operator|)
condition|)
name|spaceop
operator|=
name|SS_BLOCKS
expr_stmt|;
else|else
block|{
name|spaceop
operator|=
name|SS_EOD
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|nmarks
operator|=
literal|0
expr_stmt|;
block|}
name|nmarks
operator|=
name|softc
operator|->
name|filemarks
expr_stmt|;
name|error
operator|=
name|sacheckeod
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|nmarks
operator|-=
name|softc
operator|->
name|filemarks
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|saspace
argument_list|(
name|periph
argument_list|,
name|count
operator|-
name|nmarks
argument_list|,
name|spaceop
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MTREW
case|:
comment|/* rewind */
name|error
operator|=
name|sarewind
argument_list|(
name|periph
argument_list|)
expr_stmt|;
break|break;
case|case
name|MTERASE
case|:
comment|/* erase */
name|error
operator|=
name|saerase
argument_list|(
name|periph
argument_list|,
name|count
argument_list|)
expr_stmt|;
break|break;
case|case
name|MTRETENS
case|:
comment|/* re-tension tape */
name|error
operator|=
name|saretension
argument_list|(
name|periph
argument_list|)
expr_stmt|;
break|break;
case|case
name|MTOFFL
case|:
comment|/* rewind and put the drive offline */
comment|/* 			 * Be sure to allow media removal before 			 * attempting the eject. 			 */
name|saprevent
argument_list|(
name|periph
argument_list|,
name|PR_ALLOW
argument_list|)
expr_stmt|;
name|error
operator|=
name|sarewind
argument_list|(
name|periph
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|saloadunload
argument_list|(
name|periph
argument_list|,
comment|/*load*/
name|FALSE
argument_list|)
expr_stmt|;
else|else
break|break;
comment|/* XXX KDM */
name|softc
operator|->
name|flags
operator|&=
operator|~
name|SA_FLAG_TAPE_LOCKED
expr_stmt|;
name|softc
operator|->
name|flags
operator|&=
operator|~
name|SA_FLAG_TAPE_MOUNTED
expr_stmt|;
break|break;
case|case
name|MTNOP
case|:
comment|/* no operation, sets status only */
case|case
name|MTCACHE
case|:
comment|/* enable controller cache */
case|case
name|MTNOCACHE
case|:
comment|/* disable controller cache */
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MTSETBSIZ
case|:
comment|/* Set block size for device */
name|error
operator|=
name|sasetparams
argument_list|(
name|periph
argument_list|,
name|SA_PARAM_BLOCKSIZE
argument_list|,
name|count
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MTSETDNSTY
case|:
comment|/* Set density for device and mode */
if|if
condition|(
name|count
operator|>
name|UCHAR_MAX
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
else|else
block|{
name|error
operator|=
name|sasetparams
argument_list|(
name|periph
argument_list|,
name|SA_PARAM_DENSITY
argument_list|,
literal|0
argument_list|,
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MTCOMP
case|:
comment|/* enable compression */
comment|/* 			 * Some devices don't support compression, and 			 * don't like it if you ask them for the 			 * compression page. 			 */
if|if
condition|(
operator|(
name|softc
operator|->
name|quirks
operator|&
name|SA_QUIRK_NOCOMP
operator|)
operator|||
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_COMP_UNSUPP
operator|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|sasetparams
argument_list|(
name|periph
argument_list|,
name|SA_PARAM_COMPRESSION
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|count
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
block|}
case|case
name|MTIOCIEOT
case|:
case|case
name|MTIOCEEOT
case|:
name|error
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|cam_periph_ioctl
argument_list|(
name|periph
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|,
name|saerror
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sainit
parameter_list|(
name|void
parameter_list|)
block|{
name|cam_status
name|status
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
comment|/* 	 * Create our extend array for storing the devices we attach to. 	 */
name|saperiphs
operator|=
name|cam_extend_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|saperiphs
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"sa: Failed to alloc extend array!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Install a global async callback. 	 */
name|status
operator|=
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
name|NULL
argument_list|,
name|CAM_XPT_PATH_ID
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|CAM_REQ_CMP
condition|)
block|{
comment|/* Register the async callbacks of interrest */
name|struct
name|ccb_setasync
name|csa
decl_stmt|;
comment|/* 					  * This is an immediate CCB, 					  * so using the stack is OK 					  */
name|xpt_setup_ccb
argument_list|(
operator|&
name|csa
operator|.
name|ccb_h
argument_list|,
name|path
argument_list|,
comment|/*priority*/
literal|5
argument_list|)
expr_stmt|;
name|csa
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SASYNC_CB
expr_stmt|;
name|csa
operator|.
name|event_enable
operator|=
name|AC_FOUND_DEVICE
expr_stmt|;
name|csa
operator|.
name|callback
operator|=
name|saasync
expr_stmt|;
name|csa
operator|.
name|callback_arg
operator|=
name|NULL
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|csa
argument_list|)
expr_stmt|;
name|status
operator|=
name|csa
operator|.
name|ccb_h
operator|.
name|status
expr_stmt|;
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"sa: Failed to attach master async callback "
literal|"due to status 0x%x!\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If we were successfull, register our devsw */
name|cdevsw_add_generic
argument_list|(
name|SA_BDEV_MAJOR
argument_list|,
name|SA_CDEV_MAJOR
argument_list|,
operator|&
name|sa_cdevsw
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sacleanup
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|cam_extend_release
argument_list|(
name|saperiphs
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|)
expr_stmt|;
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"removing device entry\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|periph
operator|->
name|softc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|saasync
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|u_int32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|periph
operator|=
operator|(
expr|struct
name|cam_periph
operator|*
operator|)
name|callback_arg
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|AC_FOUND_DEVICE
case|:
block|{
name|struct
name|ccb_getdev
modifier|*
name|cgd
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|cgd
operator|=
operator|(
expr|struct
name|ccb_getdev
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|cgd
operator|->
name|pd_type
operator|!=
name|T_SEQUENTIAL
condition|)
break|break;
comment|/* 		 * Allocate a peripheral instance for 		 * this device and start the probe 		 * process. 		 */
name|status
operator|=
name|cam_periph_alloc
argument_list|(
name|saregister
argument_list|,
name|sacleanup
argument_list|,
name|sastart
argument_list|,
literal|"sa"
argument_list|,
name|CAM_PERIPH_BIO
argument_list|,
name|cgd
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|saasync
argument_list|,
name|AC_FOUND_DEVICE
argument_list|,
name|cgd
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
operator|&&
name|status
operator|!=
name|CAM_REQ_INPROG
condition|)
name|printf
argument_list|(
literal|"saasync: Unable to probe new device "
literal|"due to status 0x%x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|AC_LOST_DEVICE
case|:
block|{
name|int
name|s
decl_stmt|;
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|buf
modifier|*
name|q_bp
decl_stmt|;
name|struct
name|ccb_setasync
name|csa
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
comment|/* 		 * Insure that no other async callbacks that 		 * might affect this peripheral can come through. 		 */
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
comment|/* 		 * De-register any async callbacks. 		 */
name|xpt_setup_ccb
argument_list|(
operator|&
name|csa
operator|.
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
comment|/* priority */
literal|5
argument_list|)
expr_stmt|;
name|csa
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SASYNC_CB
expr_stmt|;
name|csa
operator|.
name|event_enable
operator|=
literal|0
expr_stmt|;
name|csa
operator|.
name|callback
operator|=
name|saasync
expr_stmt|;
name|csa
operator|.
name|callback_arg
operator|=
name|periph
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|csa
argument_list|)
expr_stmt|;
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_INVALID
expr_stmt|;
comment|/* 		 * Return all queued I/O with ENXIO. 		 * XXX Handle any transactions queued to the card 		 *     with XPT_ABORT_CCB. 		 */
while|while
condition|(
operator|(
name|q_bp
operator|=
name|bufq_first
argument_list|(
operator|&
name|softc
operator|->
name|buf_queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|bufq_remove
argument_list|(
operator|&
name|softc
operator|->
name|buf_queue
argument_list|,
name|q_bp
argument_list|)
expr_stmt|;
name|q_bp
operator|->
name|b_resid
operator|=
name|q_bp
operator|->
name|b_bcount
expr_stmt|;
name|q_bp
operator|->
name|b_error
operator|=
name|ENXIO
expr_stmt|;
name|q_bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|biodone
argument_list|(
name|q_bp
argument_list|)
expr_stmt|;
block|}
name|devstat_remove_entry
argument_list|(
operator|&
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"lost device\n"
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|cam_periph_invalidate
argument_list|(
name|periph
argument_list|)
expr_stmt|;
block|}
case|case
name|AC_TRANSFER_NEG
case|:
case|case
name|AC_SENT_BDR
case|:
case|case
name|AC_SCSI_AEN
case|:
case|case
name|AC_UNSOL_RESEL
case|:
case|case
name|AC_BUS_RESET
case|:
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|cam_status
name|saregister
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ccb_setasync
name|csa
decl_stmt|;
name|struct
name|ccb_getdev
modifier|*
name|cgd
decl_stmt|;
name|caddr_t
name|match
decl_stmt|;
name|cgd
operator|=
operator|(
expr|struct
name|ccb_getdev
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"saregister: periph was NULL!!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
if|if
condition|(
name|cgd
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"saregister: no getdev CCB, can't register device\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|softc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"saregister: Unable to probe new device. "
literal|"Unable to allocate softc\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
name|bzero
argument_list|(
name|softc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|softc
argument_list|)
argument_list|)
expr_stmt|;
name|softc
operator|->
name|state
operator|=
name|SA_STATE_NORMAL
expr_stmt|;
name|bufq_init
argument_list|(
operator|&
name|softc
operator|->
name|buf_queue
argument_list|)
expr_stmt|;
name|periph
operator|->
name|softc
operator|=
name|softc
expr_stmt|;
name|cam_extend_set
argument_list|(
name|saperiphs
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|,
name|periph
argument_list|)
expr_stmt|;
comment|/* 	 * See if this device has any quirks. 	 */
name|match
operator|=
name|cam_quirkmatch
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|cgd
operator|->
name|inq_data
argument_list|,
operator|(
name|caddr_t
operator|)
name|sa_quirk_table
argument_list|,
sizeof|sizeof
argument_list|(
name|sa_quirk_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|sa_quirk_table
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sa_quirk_table
argument_list|)
argument_list|,
name|scsi_inquiry_match
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
operator|!=
name|NULL
condition|)
name|softc
operator|->
name|quirks
operator|=
operator|(
operator|(
expr|struct
name|sa_quirk_entry
operator|*
operator|)
name|match
operator|)
operator|->
name|quirks
expr_stmt|;
else|else
name|softc
operator|->
name|quirks
operator|=
name|SA_QUIRK_NONE
expr_stmt|;
comment|/*  	 * The SA driver supports a blocksize, but we don't know the 	 * blocksize until we sense the media.  So, set a flag to 	 * indicate that the blocksize is unavailable right now. 	 * We'll clear the flag as soon as we've done a read capacity. 	 */
name|devstat_add_entry
argument_list|(
operator|&
name|softc
operator|->
name|device_stats
argument_list|,
literal|"sa"
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|,
literal|0
argument_list|,
name|DEVSTAT_BS_UNAVAILABLE
argument_list|,
name|cgd
operator|->
name|pd_type
operator||
name|DEVSTAT_TYPE_IF_SCSI
argument_list|)
expr_stmt|;
comment|/* 	 * Add an async callback so that we get 	 * notified if this device goes away. 	 */
name|xpt_setup_ccb
argument_list|(
operator|&
name|csa
operator|.
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
comment|/* priority */
literal|5
argument_list|)
expr_stmt|;
name|csa
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SASYNC_CB
expr_stmt|;
name|csa
operator|.
name|event_enable
operator|=
name|AC_LOST_DEVICE
expr_stmt|;
name|csa
operator|.
name|callback
operator|=
name|saasync
expr_stmt|;
name|csa
operator|.
name|callback_arg
operator|=
name|periph
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|csa
argument_list|)
expr_stmt|;
name|xpt_announce_periph
argument_list|(
name|periph
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sastart
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|start_ccb
parameter_list|)
block|{
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
switch|switch
condition|(
name|softc
operator|->
name|state
condition|)
block|{
case|case
name|SA_STATE_NORMAL
case|:
block|{
comment|/* Pull a buffer from the queue and get going on it */
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* 		 * See if there is a buf with work for us to do.. 		 */
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|bp
operator|=
name|bufq_first
argument_list|(
operator|&
name|softc
operator|->
name|buf_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|periph
operator|->
name|immediate_priority
operator|<=
name|periph
operator|->
name|pinfo
operator|.
name|priority
condition|)
block|{
name|CAM_DEBUG_PRINT
argument_list|(
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"queuing for immediate ccb\n"
operator|)
argument_list|)
expr_stmt|;
name|start_ccb
operator|->
name|ccb_h
operator|.
name|ccb_type
operator|=
name|SA_CCB_WAITING
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|periph
operator|->
name|ccb_list
argument_list|,
operator|&
name|start_ccb
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|sle
argument_list|)
expr_stmt|;
name|periph
operator|->
name|immediate_priority
operator|=
name|CAM_PRIORITY_NONE
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|periph
operator|->
name|ccb_list
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|start_ccb
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_ERR_PENDING
operator|)
operator|!=
literal|0
condition|)
block|{
name|bufq_remove
argument_list|(
operator|&
name|softc
operator|->
name|buf_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_EOM_PENDING
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
literal|0
condition|)
name|bp
operator|->
name|b_error
operator|=
name|ENOSPC
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_EIO_PENDING
operator|)
operator|!=
literal|0
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
block|}
name|softc
operator|->
name|flags
operator|&=
operator|~
name|SA_FLAG_ERR_PENDING
expr_stmt|;
name|bp
operator|=
name|bufq_first
argument_list|(
operator|&
name|softc
operator|->
name|buf_queue
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|u_int32_t
name|length
decl_stmt|;
name|bufq_remove
argument_list|(
operator|&
name|softc
operator|->
name|buf_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_FIXED
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|softc
operator|->
name|blk_shift
operator|!=
literal|0
condition|)
block|{
name|length
operator|=
name|bp
operator|->
name|b_bcount
operator|>>
name|softc
operator|->
name|blk_shift
expr_stmt|;
block|}
else|else
block|{
name|length
operator|=
name|bp
operator|->
name|b_bcount
operator|/
name|softc
operator|->
name|min_blk
expr_stmt|;
block|}
block|}
else|else
block|{
name|length
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
block|}
name|devstat_start_transaction
argument_list|(
operator|&
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
comment|/* 			 * XXX - Perhaps we should... 			 * suppress illegal length indication if we are 			 * running in variable block mode so that we don't 			 * have to request sense every time our requested 			 * block size is larger than the written block. 			 * The residual information from the ccb allows 			 * us to identify this situation anyway.  The only 			 * problem with this is that we will not get 			 * information about blocks that are larger than 			 * our read buffer unless we set the block size 			 * in the mode page to something other than 0. 			 */
name|scsi_sa_read_write
argument_list|(
operator|&
name|start_ccb
operator|->
name|csio
argument_list|,
comment|/*retries*/
literal|4
argument_list|,
name|sadone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
argument_list|,
comment|/*SILI*/
name|FALSE
argument_list|,
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_FIXED
argument_list|,
name|length
argument_list|,
name|bp
operator|->
name|b_data
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
literal|120
operator|*
literal|60
operator|*
literal|1000
argument_list|)
expr_stmt|;
comment|/* 2min */
name|start_ccb
operator|->
name|ccb_h
operator|.
name|ccb_type
operator|=
name|SA_CCB_BUFFER_IO
expr_stmt|;
name|start_ccb
operator|->
name|ccb_h
operator|.
name|ccb_bp
operator|=
name|bp
expr_stmt|;
name|bp
operator|=
name|bufq_first
argument_list|(
operator|&
name|softc
operator|->
name|buf_queue
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|xpt_action
argument_list|(
name|start_ccb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
block|{
comment|/* Have more work to do, so ensure we stay scheduled */
name|xpt_schedule
argument_list|(
name|periph
argument_list|,
comment|/* XXX priority */
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sadone
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|done_ccb
parameter_list|)
block|{
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|csio
operator|=
operator|&
name|done_ccb
operator|->
name|csio
expr_stmt|;
switch|switch
condition|(
name|csio
operator|->
name|ccb_h
operator|.
name|ccb_type
condition|)
block|{
case|case
name|SA_CCB_BUFFER_IO
case|:
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bp
operator|=
operator|(
expr|struct
name|buf
operator|*
operator|)
name|done_ccb
operator|->
name|ccb_h
operator|.
name|ccb_bp
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|saerror
argument_list|(
name|done_ccb
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|ERESTART
condition|)
block|{
comment|/* 				 * A retry was scheuled, so 				 * just return. 				 */
return|return;
block|}
block|}
if|if
condition|(
name|error
operator|==
name|EIO
condition|)
block|{
name|int
name|s
decl_stmt|;
name|struct
name|buf
modifier|*
name|q_bp
decl_stmt|;
comment|/* 			 * Catastrophic error.  Mark our pack as invalid, 			 * return all queued I/O with EIO, and unfreeze 			 * our queue so that future transactions that 			 * attempt to fix this problem can get to the 			 * device. 			 * 			 */
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|softc
operator|->
name|flags
operator|&=
operator|~
name|SA_FLAG_TAPE_MOUNTED
expr_stmt|;
while|while
condition|(
operator|(
name|q_bp
operator|=
name|bufq_first
argument_list|(
operator|&
name|softc
operator|->
name|buf_queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|bufq_remove
argument_list|(
operator|&
name|softc
operator|->
name|buf_queue
argument_list|,
name|q_bp
argument_list|)
expr_stmt|;
name|q_bp
operator|->
name|b_resid
operator|=
name|q_bp
operator|->
name|b_bcount
expr_stmt|;
name|q_bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
name|q_bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|biodone
argument_list|(
name|q_bp
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|error
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|cam_release_devq
argument_list|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*relsim_flags*/
literal|0
argument_list|,
comment|/*reduction*/
literal|0
argument_list|,
comment|/*timeout*/
literal|0
argument_list|,
comment|/*getcount_only*/
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bp
operator|->
name|b_resid
operator|=
name|csio
operator|->
name|resid
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|csio
operator|->
name|resid
operator|!=
literal|0
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
literal|0
condition|)
block|{
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_TAPE_WRITTEN
expr_stmt|;
name|softc
operator|->
name|filemarks
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|devstat_end_transaction
argument_list|(
operator|&
name|softc
operator|->
name|device_stats
argument_list|,
name|bp
operator|->
name|b_bcount
operator|-
name|bp
operator|->
name|b_resid
argument_list|,
name|done_ccb
operator|->
name|csio
operator|.
name|tag_action
operator|&
literal|0xf
argument_list|,
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
name|DEVSTAT_READ
else|:
name|DEVSTAT_WRITE
argument_list|)
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SA_CCB_WAITING
case|:
block|{
comment|/* Caller will release the CCB */
name|wakeup
argument_list|(
operator|&
name|done_ccb
operator|->
name|ccb_h
operator|.
name|cbfcnp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|xpt_release_ccb
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|samount
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|int
name|error
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
comment|/* priority */
literal|1
argument_list|)
expr_stmt|;
name|csio
operator|=
operator|&
name|ccb
operator|->
name|csio
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Determine if something has happend since the last 	 * open/mount that would invalidate a mount.  This 	 * will also eat any pending UAs. 	 */
name|scsi_test_unit_ready
argument_list|(
name|csio
argument_list|,
comment|/*retries*/
literal|1
argument_list|,
name|sadone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
comment|/*timeout*/
literal|5000
argument_list|)
expr_stmt|;
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
comment|/*error handler*/
name|NULL
argument_list|,
comment|/*cam_flags*/
literal|0
argument_list|,
comment|/*sense_flags*/
literal|0
argument_list|,
operator|&
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|!=
literal|0
condition|)
block|{
name|cam_release_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*relsim_flags*/
literal|0
argument_list|,
comment|/*reduction*/
literal|0
argument_list|,
comment|/*timeout*/
literal|0
argument_list|,
comment|/*getcount_only*/
literal|0
argument_list|)
expr_stmt|;
name|softc
operator|->
name|flags
operator|&=
operator|~
name|SA_FLAG_TAPE_MOUNTED
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_TAPE_MOUNTED
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|scsi_read_block_limits_data
modifier|*
name|rblim
decl_stmt|;
name|int
name|comp_enabled
decl_stmt|,
name|comp_supported
decl_stmt|;
name|u_int8_t
name|write_protect
decl_stmt|;
comment|/* 		 * Clear out old state. 		 */
name|softc
operator|->
name|flags
operator|&=
operator|~
operator|(
name|SA_FLAG_TAPE_WP
operator||
name|SA_FLAG_TAPE_WRITTEN
operator||
name|SA_FLAG_ERR_PENDING
operator||
name|SA_FLAG_COMP_ENABLED
operator||
name|SA_FLAG_COMP_UNSUPP
operator|)
expr_stmt|;
name|softc
operator|->
name|filemarks
operator|=
literal|0
expr_stmt|;
comment|/* 		 * First off, determine block limits. 		 */
name|rblim
operator|=
operator|(
expr|struct
name|scsi_read_block_limits_data
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|rblim
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|scsi_read_block_limits
argument_list|(
name|csio
argument_list|,
comment|/*retries*/
literal|1
argument_list|,
name|sadone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|rblim
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
comment|/*timeout*/
literal|5000
argument_list|)
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
comment|/*cam_flags*/
literal|0
argument_list|,
comment|/*sense_flags*/
name|SF_RETRY_UA
argument_list|,
operator|&
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|exit
goto|;
name|softc
operator|->
name|blk_gran
operator|=
name|RBL_GRAN
argument_list|(
name|rblim
argument_list|)
expr_stmt|;
name|softc
operator|->
name|max_blk
operator|=
name|scsi_3btoul
argument_list|(
name|rblim
operator|->
name|maximum
argument_list|)
expr_stmt|;
name|softc
operator|->
name|min_blk
operator|=
name|scsi_2btoul
argument_list|(
name|rblim
operator|->
name|minimum
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|max_blk
operator|==
name|softc
operator|->
name|min_blk
condition|)
block|{
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_FIXED
expr_stmt|;
if|if
condition|(
name|powerof2
argument_list|(
name|softc
operator|->
name|min_blk
argument_list|)
condition|)
block|{
name|softc
operator|->
name|blk_mask
operator|=
name|softc
operator|->
name|min_blk
operator|-
literal|1
expr_stmt|;
name|softc
operator|->
name|blk_shift
operator|=
literal|0
expr_stmt|;
name|softc
operator|->
name|blk_shift
operator|=
name|ffs
argument_list|(
name|softc
operator|->
name|min_blk
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|softc
operator|->
name|blk_mask
operator|=
operator|~
literal|0
expr_stmt|;
name|softc
operator|->
name|blk_shift
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * SCSI-III spec allows 0 			 * to mean "unspecified" 			 */
if|if
condition|(
name|softc
operator|->
name|max_blk
operator|==
literal|0
condition|)
block|{
name|softc
operator|->
name|max_blk
operator|=
operator|~
literal|0
expr_stmt|;
block|}
name|softc
operator|->
name|blk_shift
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|blk_gran
operator|!=
literal|0
condition|)
block|{
name|softc
operator|->
name|blk_mask
operator|=
name|softc
operator|->
name|blk_gran
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|softc
operator|->
name|blk_mask
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 		 * Next, perform a mode sense to determine 		 * current density, blocksize, compression etc. 		 */
name|error
operator|=
name|sagetparams
argument_list|(
name|periph
argument_list|,
name|SA_PARAM_ALL
argument_list|,
operator|&
name|softc
operator|->
name|media_blksize
argument_list|,
operator|&
name|softc
operator|->
name|media_density
argument_list|,
operator|&
name|softc
operator|->
name|media_numblks
argument_list|,
operator|&
name|softc
operator|->
name|buffer_mode
argument_list|,
operator|&
name|write_protect
argument_list|,
operator|&
name|softc
operator|->
name|speed
argument_list|,
operator|&
name|comp_supported
argument_list|,
operator|&
name|comp_enabled
argument_list|,
operator|&
name|softc
operator|->
name|comp_algorithm
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|exit
goto|;
if|if
condition|(
name|write_protect
condition|)
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_TAPE_WP
expr_stmt|;
if|if
condition|(
name|comp_supported
condition|)
block|{
if|if
condition|(
name|comp_enabled
condition|)
block|{
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_COMP_ENABLED
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|saved_comp_algorithm
operator|==
literal|0
condition|)
name|softc
operator|->
name|saved_comp_algorithm
operator|=
name|softc
operator|->
name|comp_algorithm
expr_stmt|;
block|}
block|}
else|else
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_COMP_UNSUPP
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|buffer_mode
operator|!=
name|SMH_SA_BUF_MODE_NOBUF
condition|)
goto|goto
name|exit
goto|;
name|error
operator|=
name|sasetparams
argument_list|(
name|periph
argument_list|,
name|SA_PARAM_BUFF_MODE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|softc
operator|->
name|buffer_mode
operator|=
name|SMH_SA_BUF_MODE_SIBUF
expr_stmt|;
name|exit
label|:
if|if
condition|(
name|rblim
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rblim
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|cam_release_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*relsim_flags*/
literal|0
argument_list|,
comment|/*reduction*/
literal|0
argument_list|,
comment|/*timeout*/
literal|0
argument_list|,
comment|/*getcount_only*/
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sacheckeod
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|markswanted
decl_stmt|;
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|markswanted
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_TAPE_WRITTEN
operator|)
operator|!=
literal|0
condition|)
block|{
name|markswanted
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_2FM_AT_EOD
operator|)
operator|!=
literal|0
condition|)
name|markswanted
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|softc
operator|->
name|filemarks
operator|<
name|markswanted
condition|)
block|{
name|markswanted
operator|-=
name|softc
operator|->
name|filemarks
expr_stmt|;
name|error
operator|=
name|sawritefilemarks
argument_list|(
name|periph
argument_list|,
name|markswanted
argument_list|,
comment|/*setmarks*/
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|saerror
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|u_int32_t
name|cam_flags
parameter_list|,
name|u_int32_t
name|sense_flags
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|struct
name|scsi_sense_data
modifier|*
name|sense
decl_stmt|;
name|int
name|error_code
decl_stmt|,
name|sense_key
decl_stmt|,
name|asc
decl_stmt|,
name|ascq
decl_stmt|;
name|int
name|error
decl_stmt|;
name|periph
operator|=
name|xpt_path_periph
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|csio
operator|=
operator|&
name|ccb
operator|->
name|csio
expr_stmt|;
name|sense
operator|=
operator|&
name|csio
operator|->
name|sense_data
expr_stmt|;
name|scsi_extract_sense
argument_list|(
name|sense
argument_list|,
operator|&
name|error_code
argument_list|,
operator|&
name|sense_key
argument_list|,
operator|&
name|asc
argument_list|,
operator|&
name|ascq
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_SCSI_STATUS_ERROR
operator|)
operator|&&
operator|(
operator|(
name|sense
operator|->
name|flags
operator|&
operator|(
name|SSD_EOM
operator||
name|SSD_FILEMARK
operator||
name|SSD_ILI
operator|)
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|sense_key
operator|==
name|SSD_KEY_NO_SENSE
operator|)
operator|||
operator|(
name|sense_key
operator|==
name|SSD_KEY_BLANK_CHECK
operator|)
operator|)
condition|)
block|{
name|u_int32_t
name|info
decl_stmt|;
name|u_int32_t
name|resid
decl_stmt|;
name|int
name|defer_action
decl_stmt|;
comment|/* 		 * Filter out some sense codes of interest. 		 */
if|if
condition|(
operator|(
name|sense
operator|->
name|error_code
operator|&
name|SSD_ERRCODE_VALID
operator|)
operator|!=
literal|0
condition|)
block|{
name|info
operator|=
name|scsi_4btoul
argument_list|(
name|sense
operator|->
name|info
argument_list|)
expr_stmt|;
name|resid
operator|=
name|info
expr_stmt|;
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_FIXED
operator|)
operator|!=
literal|0
condition|)
name|resid
operator|*=
name|softc
operator|->
name|media_blksize
expr_stmt|;
block|}
else|else
block|{
name|resid
operator|=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
name|info
operator|=
name|resid
expr_stmt|;
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_FIXED
operator|)
operator|!=
literal|0
condition|)
name|info
operator|/=
name|softc
operator|->
name|media_blksize
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|resid
operator|>
literal|0
operator|&&
name|resid
operator|<
name|csio
operator|->
name|dxfer_len
operator|)
operator|&&
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_FIXED
operator|)
operator|!=
literal|0
condition|)
name|defer_action
operator|=
name|TRUE
expr_stmt|;
else|else
name|defer_action
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|sense
operator|->
name|flags
operator|&
name|SSD_EOM
operator|)
operator|!=
literal|0
operator|||
operator|(
name|sense_key
operator|==
literal|0x8
comment|/* BLANK CHECK*/
operator|)
condition|)
block|{
name|csio
operator|->
name|resid
operator|=
name|resid
expr_stmt|;
if|if
condition|(
name|defer_action
condition|)
block|{
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_EOM_PENDING
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
operator|==
name|SA_WRITE
condition|)
name|error
operator|=
name|ENOSPC
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|sense
operator|->
name|flags
operator|&
name|SSD_FILEMARK
operator|)
operator|!=
literal|0
condition|)
block|{
name|csio
operator|->
name|resid
operator|=
name|resid
expr_stmt|;
if|if
condition|(
name|defer_action
condition|)
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_EOF_PENDING
expr_stmt|;
block|}
if|if
condition|(
name|sense
operator|->
name|flags
operator|&
name|SSD_ILI
condition|)
block|{
if|if
condition|(
name|info
operator|<
literal|0
condition|)
block|{
comment|/* 				 * The record was too big. 				 */
name|xpt_print_path
argument_list|(
name|csio
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d-byte tape record bigger "
literal|"than suplied read buffer\n"
argument_list|,
name|csio
operator|->
name|dxfer_len
operator|-
name|info
argument_list|)
expr_stmt|;
name|csio
operator|->
name|resid
operator|=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
block|}
else|else
block|{
name|csio
operator|->
name|resid
operator|=
name|resid
expr_stmt|;
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_FIXED
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|defer_action
condition|)
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_EIO_PENDING
expr_stmt|;
else|else
name|error
operator|=
name|EIO
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|cam_periph_error
argument_list|(
name|ccb
argument_list|,
name|cam_flags
argument_list|,
name|sense_flags
argument_list|,
operator|&
name|softc
operator|->
name|saved_ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sagetparams
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|sa_params
name|params_to_get
parameter_list|,
name|u_int32_t
modifier|*
name|blocksize
parameter_list|,
name|u_int8_t
modifier|*
name|density
parameter_list|,
name|u_int32_t
modifier|*
name|numblocks
parameter_list|,
name|int
modifier|*
name|buff_mode
parameter_list|,
name|u_int8_t
modifier|*
name|write_protect
parameter_list|,
name|u_int8_t
modifier|*
name|speed
parameter_list|,
name|int
modifier|*
name|comp_supported
parameter_list|,
name|int
modifier|*
name|comp_enabled
parameter_list|,
name|u_int32_t
modifier|*
name|comp_algorithm
parameter_list|,
name|struct
name|scsi_data_compression_page
modifier|*
name|comp_page
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|void
modifier|*
name|mode_buffer
decl_stmt|;
name|struct
name|scsi_mode_header_6
modifier|*
name|mode_hdr
decl_stmt|;
name|struct
name|scsi_mode_blk_desc
modifier|*
name|mode_blk
decl_stmt|;
name|struct
name|scsi_data_compression_page
modifier|*
name|ncomp_page
decl_stmt|;
name|int
name|mode_buffer_len
decl_stmt|;
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|retry
label|:
name|mode_buffer_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|mode_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|mode_blk
argument_list|)
expr_stmt|;
if|if
condition|(
name|params_to_get
operator|&
name|SA_PARAM_COMPRESSION
condition|)
block|{
if|if
condition|(
name|softc
operator|->
name|quirks
operator|&
name|SA_QUIRK_NOCOMP
condition|)
block|{
operator|*
name|comp_supported
operator|=
name|FALSE
expr_stmt|;
name|params_to_get
operator|&=
operator|~
name|SA_PARAM_COMPRESSION
expr_stmt|;
block|}
else|else
name|mode_buffer_len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_data_compression_page
argument_list|)
expr_stmt|;
block|}
name|mode_buffer
operator|=
name|malloc
argument_list|(
name|mode_buffer_len
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|mode_buffer
argument_list|,
name|mode_buffer_len
argument_list|)
expr_stmt|;
name|mode_hdr
operator|=
operator|(
expr|struct
name|scsi_mode_header_6
operator|*
operator|)
name|mode_buffer
expr_stmt|;
name|mode_blk
operator|=
operator|(
expr|struct
name|scsi_mode_blk_desc
operator|*
operator|)
operator|&
name|mode_hdr
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|params_to_get
operator|&
name|SA_PARAM_COMPRESSION
condition|)
name|ncomp_page
operator|=
operator|(
expr|struct
name|scsi_data_compression_page
operator|*
operator|)
operator|&
name|mode_blk
index|[
literal|1
index|]
expr_stmt|;
else|else
name|ncomp_page
operator|=
name|NULL
expr_stmt|;
name|scsi_mode_sense
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/*retries*/
literal|1
argument_list|,
comment|/*cbfcnp*/
name|sadone
argument_list|,
comment|/*tag_action*/
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*dbd*/
name|FALSE
argument_list|,
comment|/*page_code*/
name|SMS_PAGE_CTRL_CURRENT
argument_list|,
comment|/*page*/
operator|(
name|params_to_get
operator|&
name|SA_PARAM_COMPRESSION
operator|)
condition|?
name|SA_DATA_COMPRESSION_PAGE
else|:
name|SMS_VENDOR_SPECIFIC_PAGE
argument_list|,
comment|/*param_buf*/
name|mode_buffer
argument_list|,
comment|/*param_len*/
name|mode_buffer_len
argument_list|,
comment|/*sense_len*/
name|SSD_FULL_SIZE
argument_list|,
comment|/*timeout*/
literal|5000
argument_list|)
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
comment|/*cam_flags*/
literal|0
argument_list|,
comment|/*sense_flags*/
name|SF_NO_PRINT
argument_list|,
operator|&
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|!=
literal|0
condition|)
name|cam_release_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/* relsim_flags */
literal|0
argument_list|,
comment|/* opening_reduction */
literal|0
argument_list|,
comment|/* timeout */
literal|0
argument_list|,
comment|/* getcount_only */
name|FALSE
argument_list|)
expr_stmt|;
name|status
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINVAL
operator|&&
operator|(
name|params_to_get
operator|&
name|SA_PARAM_COMPRESSION
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Most likely doesn't support the compression 		 * page.  Remeber this for the future and attempt 		 * the request without asking for compression info. 		 */
name|softc
operator|->
name|quirks
operator||=
name|SA_QUIRK_NOCOMP
expr_stmt|;
name|free
argument_list|(
name|mode_buffer
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|struct
name|scsi_data_compression_page
modifier|*
name|temp_comp_page
decl_stmt|;
name|temp_comp_page
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * If the user only wants the compression information, and 		 * the device doesn't send back the block descriptor, it's 		 * no big deal.  If the user wants more than just 		 * compression, though, and the device doesn't pass back the 		 * block descriptor, we need to send another mode sense to 		 * get the block descriptor. 		 */
if|if
condition|(
operator|(
name|mode_hdr
operator|->
name|blk_desc_len
operator|==
literal|0
operator|)
operator|&&
operator|(
name|params_to_get
operator|&
name|SA_PARAM_COMPRESSION
operator|)
operator|&&
operator|(
operator|(
name|params_to_get
operator|&
operator|~
operator|(
name|SA_PARAM_COMPRESSION
operator|)
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* 			 * Decrease the mode buffer length by the size of 			 * the compression page, to make sure the data 			 * there doesn't get overwritten. 			 */
name|mode_buffer_len
operator|-=
sizeof|sizeof
argument_list|(
operator|*
name|ncomp_page
argument_list|)
expr_stmt|;
comment|/* 			 * Now move the compression page that we presumably 			 * got back down the memory chunk a little bit so 			 * it doesn't get spammed. 			 */
name|temp_comp_page
operator|=
operator|(
expr|struct
name|scsi_data_compression_page
operator|*
operator|)
operator|&
name|mode_hdr
index|[
literal|1
index|]
expr_stmt|;
name|bcopy
argument_list|(
name|temp_comp_page
argument_list|,
name|ncomp_page
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ncomp_page
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * Now, we issue another mode sense and just ask 			 * for the block descriptor, etc. 			 */
name|scsi_mode_sense
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/*retries*/
literal|1
argument_list|,
comment|/*cbfcnp*/
name|sadone
argument_list|,
comment|/*tag_action*/
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*dbd*/
name|FALSE
argument_list|,
comment|/*page_code*/
name|SMS_PAGE_CTRL_CURRENT
argument_list|,
comment|/*page*/
name|SMS_VENDOR_SPECIFIC_PAGE
argument_list|,
comment|/*param_buf*/
name|mode_buffer
argument_list|,
comment|/*param_len*/
name|mode_buffer_len
argument_list|,
comment|/*sense_len*/
name|SSD_FULL_SIZE
argument_list|,
comment|/*timeout*/
literal|5000
argument_list|)
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
comment|/*cam_flags*/
literal|0
argument_list|,
comment|/*sense_flags*/
literal|0
argument_list|,
operator|&
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|sagetparamsexit
goto|;
block|}
if|if
condition|(
name|params_to_get
operator|&
name|SA_PARAM_BLOCKSIZE
condition|)
operator|*
name|blocksize
operator|=
name|scsi_3btoul
argument_list|(
name|mode_blk
operator|->
name|blklen
argument_list|)
expr_stmt|;
if|if
condition|(
name|params_to_get
operator|&
name|SA_PARAM_NUMBLOCKS
condition|)
operator|*
name|numblocks
operator|=
name|scsi_3btoul
argument_list|(
name|mode_blk
operator|->
name|nblocks
argument_list|)
expr_stmt|;
if|if
condition|(
name|params_to_get
operator|&
name|SA_PARAM_BUFF_MODE
condition|)
operator|*
name|buff_mode
operator|=
name|mode_hdr
operator|->
name|dev_spec
operator|&
name|SMH_SA_BUF_MODE_MASK
expr_stmt|;
if|if
condition|(
name|params_to_get
operator|&
name|SA_PARAM_DENSITY
condition|)
operator|*
name|density
operator|=
name|mode_blk
operator|->
name|density
expr_stmt|;
if|if
condition|(
name|params_to_get
operator|&
name|SA_PARAM_WP
condition|)
operator|*
name|write_protect
operator|=
operator|(
name|mode_hdr
operator|->
name|dev_spec
operator|&
name|SMH_SA_WP
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
if|if
condition|(
name|params_to_get
operator|&
name|SA_PARAM_SPEED
condition|)
operator|*
name|speed
operator|=
name|mode_hdr
operator|->
name|dev_spec
operator|&
name|SMH_SA_SPEED_MASK
expr_stmt|;
if|if
condition|(
name|params_to_get
operator|&
name|SA_PARAM_COMPRESSION
condition|)
block|{
operator|*
name|comp_supported
operator|=
operator|(
name|ncomp_page
operator|->
name|dce_and_dcc
operator|&
name|SA_DCP_DCC
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
operator|*
name|comp_enabled
operator|=
operator|(
name|ncomp_page
operator|->
name|dce_and_dcc
operator|&
name|SA_DCP_DCE
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
operator|*
name|comp_algorithm
operator|=
name|scsi_4btoul
argument_list|(
name|ncomp_page
operator|->
name|comp_algorithm
argument_list|)
expr_stmt|;
if|if
condition|(
name|comp_page
operator|!=
name|NULL
condition|)
name|bcopy
argument_list|(
name|ncomp_page
argument_list|,
name|comp_page
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|comp_page
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|CAM_SCSI_STATUS_ERROR
condition|)
block|{
comment|/* Tell the user about the fatal error. */
name|scsi_sense_print
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|)
expr_stmt|;
block|}
name|sagetparamsexit
label|:
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mode_buffer
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The purpose of this function is to set one of four different parameters  * for a tape drive:  *	- blocksize  *	- density  *	- compression / compression algorithm  *	- buffering mode  *  * The assumption is that this will be called from saioctl(), and therefore  * from a process context.  Thus the waiting malloc calls below.  If that  * assumption ever changes, the malloc calls should be changed to be  * NOWAIT mallocs.  *  * Any or all of the four parameters may be set when this function is  * called.  It should handle setting more than one parameter at once.  */
end_comment

begin_function
specifier|static
name|int
name|sasetparams
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|sa_params
name|params_to_set
parameter_list|,
name|u_int32_t
name|blocksize
parameter_list|,
name|u_int8_t
name|density
parameter_list|,
name|u_int32_t
name|comp_algorithm
parameter_list|)
block|{
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|u_int32_t
name|current_blocksize
decl_stmt|;
name|u_int32_t
name|current_comp_algorithm
decl_stmt|;
name|u_int8_t
name|current_density
decl_stmt|;
name|u_int8_t
name|current_speed
decl_stmt|;
name|int
name|comp_enabled
decl_stmt|,
name|comp_supported
decl_stmt|;
name|void
modifier|*
name|mode_buffer
decl_stmt|;
name|int
name|mode_buffer_len
decl_stmt|;
name|struct
name|scsi_mode_header_6
modifier|*
name|mode_hdr
decl_stmt|;
name|struct
name|scsi_mode_blk_desc
modifier|*
name|mode_blk
decl_stmt|;
name|struct
name|scsi_data_compression_page
modifier|*
name|comp_page
decl_stmt|;
name|struct
name|scsi_data_compression_page
modifier|*
name|current_comp_page
decl_stmt|;
name|int
name|buff_mode
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
comment|/* silence the compiler */
name|ccb
operator|=
name|NULL
expr_stmt|;
name|current_comp_page
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|current_comp_page
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* 	 * Since it doesn't make sense to set the number of blocks, or 	 * write protection, we won't try to get the current value.  We 	 * always want to get the blocksize, so we can set it back to the 	 * proper value. 	 */
name|error
operator|=
name|sagetparams
argument_list|(
name|periph
argument_list|,
name|params_to_set
operator||
name|SA_PARAM_BLOCKSIZE
operator||
name|SA_PARAM_SPEED
argument_list|,
operator|&
name|current_blocksize
argument_list|,
operator|&
name|current_density
argument_list|,
name|NULL
argument_list|,
operator|&
name|buff_mode
argument_list|,
name|NULL
argument_list|,
operator|&
name|current_speed
argument_list|,
operator|&
name|comp_supported
argument_list|,
operator|&
name|comp_enabled
argument_list|,
operator|&
name|current_comp_algorithm
argument_list|,
name|current_comp_page
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|current_comp_page
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|mode_buffer_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|mode_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|mode_blk
argument_list|)
expr_stmt|;
if|if
condition|(
name|params_to_set
operator|&
name|SA_PARAM_COMPRESSION
condition|)
name|mode_buffer_len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_data_compression_page
argument_list|)
expr_stmt|;
name|mode_buffer
operator|=
name|malloc
argument_list|(
name|mode_buffer_len
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|mode_buffer
argument_list|,
name|mode_buffer_len
argument_list|)
expr_stmt|;
name|mode_hdr
operator|=
operator|(
expr|struct
name|scsi_mode_header_6
operator|*
operator|)
name|mode_buffer
expr_stmt|;
name|mode_blk
operator|=
operator|(
expr|struct
name|scsi_mode_blk_desc
operator|*
operator|)
operator|&
name|mode_hdr
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|params_to_set
operator|&
name|SA_PARAM_COMPRESSION
condition|)
block|{
name|comp_page
operator|=
operator|(
expr|struct
name|scsi_data_compression_page
operator|*
operator|)
operator|&
name|mode_blk
index|[
literal|1
index|]
expr_stmt|;
name|bcopy
argument_list|(
name|current_comp_page
argument_list|,
name|comp_page
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|comp_page
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|comp_page
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * If the caller wants us to set the blocksize, use the one they 	 * pass in.  Otherwise, use the blocksize we got back from the 	 * mode select above. 	 */
if|if
condition|(
name|params_to_set
operator|&
name|SA_PARAM_BLOCKSIZE
condition|)
name|scsi_ulto3b
argument_list|(
name|blocksize
argument_list|,
name|mode_blk
operator|->
name|blklen
argument_list|)
expr_stmt|;
else|else
name|scsi_ulto3b
argument_list|(
name|current_blocksize
argument_list|,
name|mode_blk
operator|->
name|blklen
argument_list|)
expr_stmt|;
comment|/* 	 * 0x7f means "same as before" 	 */
if|if
condition|(
name|params_to_set
operator|&
name|SA_PARAM_DENSITY
condition|)
name|mode_blk
operator|->
name|density
operator|=
name|density
expr_stmt|;
else|else
name|mode_blk
operator|->
name|density
operator|=
literal|0x7f
expr_stmt|;
comment|/* 	 * For mode selects, these two fields must be zero. 	 */
name|mode_hdr
operator|->
name|data_length
operator|=
literal|0
expr_stmt|;
name|mode_hdr
operator|->
name|medium_type
operator|=
literal|0
expr_stmt|;
comment|/* set the speed to the current value */
name|mode_hdr
operator|->
name|dev_spec
operator|=
name|current_speed
expr_stmt|;
comment|/* set single-initiator buffering mode */
name|mode_hdr
operator|->
name|dev_spec
operator||=
name|SMH_SA_BUF_MODE_SIBUF
expr_stmt|;
name|mode_hdr
operator|->
name|blk_desc_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_mode_blk_desc
argument_list|)
expr_stmt|;
comment|/* 	 * First, if the user wants us to set the compression algorithm or 	 * just turn compression on, check to make sure that this drive 	 * supports compression. 	 */
if|if
condition|(
operator|(
name|params_to_set
operator|&
name|SA_PARAM_COMPRESSION
operator|)
operator|&&
operator|(
name|current_comp_page
operator|->
name|dce_and_dcc
operator|&
name|SA_DCP_DCC
operator|)
condition|)
block|{
comment|/* 		 * If the compression algorithm is 0, disable compression. 		 * If the compression algorithm is non-zero, enable 		 * compression and set the compression type to the 		 * specified compression algorithm, unless the algorithm is 		 * MT_COMP_ENABLE.  In that case, we look at the 		 * compression algorithm that is currently set and if it is 		 * non-zero, we leave it as-is.  If it is zero, and we have 		 * saved a compression algorithm from a time when 		 * compression was enabled before, set the compression to 		 * the saved value. 		 */
if|if
condition|(
name|comp_algorithm
operator|==
literal|0
condition|)
block|{
comment|/* disable compression */
name|comp_page
operator|->
name|dce_and_dcc
operator|&=
operator|~
name|SA_DCP_DCE
expr_stmt|;
block|}
else|else
block|{
comment|/* enable compression */
name|comp_page
operator|->
name|dce_and_dcc
operator||=
name|SA_DCP_DCE
expr_stmt|;
comment|/* enable decompression */
name|comp_page
operator|->
name|dde_and_red
operator||=
name|SA_DCP_DDE
expr_stmt|;
if|if
condition|(
name|comp_algorithm
operator|!=
name|MT_COMP_ENABLE
condition|)
block|{
comment|/* set the compression algorithm */
name|scsi_ulto4b
argument_list|(
name|comp_algorithm
argument_list|,
name|comp_page
operator|->
name|comp_algorithm
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|scsi_4btoul
argument_list|(
name|comp_page
operator|->
name|comp_algorithm
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|softc
operator|->
name|saved_comp_algorithm
operator|!=
literal|0
operator|)
condition|)
block|{
name|scsi_ulto4b
argument_list|(
name|softc
operator|->
name|saved_comp_algorithm
argument_list|,
name|comp_page
operator|->
name|comp_algorithm
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|params_to_set
operator|&
name|SA_PARAM_COMPRESSION
condition|)
block|{
comment|/* 		 * The drive doesn't support compression, so turn off the 		 * set compression bit. 		 */
name|params_to_set
operator|&=
operator|~
name|SA_PARAM_COMPRESSION
expr_stmt|;
comment|/* 		 * Should probably do something other than a printf...like 		 * set a flag in the softc saying that this drive doesn't 		 * support compression. 		 */
name|xpt_print_path
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sasetparams: device does not support compression\n"
argument_list|)
expr_stmt|;
comment|/* 		 * If that was the only thing the user wanted us to set, 		 * clean up allocated resources and return with 'operation 		 * not supported'. 		 */
if|if
condition|(
name|params_to_set
operator|==
name|SA_PARAM_NONE
condition|)
block|{
name|free
argument_list|(
name|mode_buffer
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
comment|/* 		 * That wasn't the only thing the user wanted us to set. 		 * So, decrease the stated mode buffer length by the size 		 * of the compression mode page. 		 */
name|mode_buffer_len
operator|-=
sizeof|sizeof
argument_list|(
operator|*
name|comp_page
argument_list|)
expr_stmt|;
block|}
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|scsi_mode_select
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/*retries*/
literal|1
argument_list|,
comment|/*cbfcnp*/
name|sadone
argument_list|,
comment|/*tag_action*/
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*scsi_page_fmt*/
operator|(
name|params_to_set
operator|&
name|SA_PARAM_COMPRESSION
operator|)
condition|?
name|TRUE
else|:
name|FALSE
argument_list|,
comment|/*save_pages*/
name|FALSE
argument_list|,
comment|/*param_buf*/
name|mode_buffer
argument_list|,
comment|/*param_len*/
name|mode_buffer_len
argument_list|,
comment|/*sense_len*/
name|SSD_FULL_SIZE
argument_list|,
comment|/*timeout*/
literal|5000
argument_list|)
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
comment|/*cam_flags*/
literal|0
argument_list|,
comment|/*sense_flags*/
literal|0
argument_list|,
operator|&
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|!=
literal|0
condition|)
name|cam_release_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*relsim_flags*/
literal|0
argument_list|,
comment|/*reduction*/
literal|0
argument_list|,
comment|/*timeout*/
literal|0
argument_list|,
comment|/*getcount_only*/
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * If we were setting the blocksize, and that failed, we 		 * want to set it to its original value.  If we weren't 		 * setting the blocksize, we don't want to change it. 		 */
name|scsi_ulto3b
argument_list|(
name|current_blocksize
argument_list|,
name|mode_blk
operator|->
name|blklen
argument_list|)
expr_stmt|;
comment|/* 		 * 0x7f means "same as before". 		 */
if|if
condition|(
name|params_to_set
operator|&
name|SA_PARAM_DENSITY
condition|)
name|mode_blk
operator|->
name|density
operator|=
name|current_density
expr_stmt|;
else|else
name|mode_blk
operator|->
name|density
operator|=
literal|0x7f
expr_stmt|;
if|if
condition|(
name|params_to_set
operator|&
name|SA_PARAM_COMPRESSION
condition|)
name|bcopy
argument_list|(
name|current_comp_page
argument_list|,
name|comp_page
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_data_compression_page
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * The retry count is the only CCB field that might have been 		 * changed that we care about, so reset it back to 1. 		 */
name|ccb
operator|->
name|ccb_h
operator|.
name|retry_count
operator|=
literal|1
expr_stmt|;
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
comment|/*cam_flags*/
literal|0
argument_list|,
comment|/*sense_flags*/
literal|0
argument_list|,
operator|&
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|!=
literal|0
condition|)
name|cam_release_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*relsim_flags*/
literal|0
argument_list|,
comment|/*reduction*/
literal|0
argument_list|,
comment|/*timeout*/
literal|0
argument_list|,
comment|/*getcount_only*/
literal|0
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|params_to_set
operator|&
name|SA_PARAM_COMPRESSION
condition|)
name|free
argument_list|(
name|current_comp_page
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mode_buffer
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|saprevent
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|action
parameter_list|)
block|{
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|action
operator|==
name|PR_ALLOW
operator|)
operator|&&
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_TAPE_LOCKED
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|action
operator|==
name|PR_PREVENT
operator|)
operator|&&
operator|(
name|softc
operator|->
name|flags
operator|&
name|SA_FLAG_TAPE_LOCKED
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
return|return;
block|}
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|scsi_prevent
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/*retries*/
literal|0
argument_list|,
comment|/*cbcfp*/
name|sadone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|action
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
literal|60000
argument_list|)
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
comment|/*cam_flags*/
literal|0
argument_list|,
comment|/*sense_flags*/
literal|0
argument_list|,
operator|&
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|!=
literal|0
condition|)
name|cam_release_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*relsim_flags*/
literal|0
argument_list|,
comment|/*reduction*/
literal|0
argument_list|,
comment|/*timeout*/
literal|0
argument_list|,
comment|/*getcount_only*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|action
operator|==
name|PR_ALLOW
condition|)
name|softc
operator|->
name|flags
operator|&=
operator|~
name|SA_FLAG_TAPE_LOCKED
expr_stmt|;
else|else
name|softc
operator|->
name|flags
operator||=
name|SA_FLAG_TAPE_LOCKED
expr_stmt|;
block|}
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sarewind
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|scsi_rewind
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/*retries*/
literal|1
argument_list|,
comment|/*cbcfp*/
name|sadone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*immediate*/
name|FALSE
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
operator|(
name|SA_REWIND_TIMEOUT
operator|)
operator|*
literal|60
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
comment|/*cam_flags*/
literal|0
argument_list|,
comment|/*sense_flags*/
literal|0
argument_list|,
operator|&
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|!=
literal|0
condition|)
name|cam_release_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*relsim_flags*/
literal|0
argument_list|,
comment|/*reduction*/
literal|0
argument_list|,
comment|/*timeout*/
literal|0
argument_list|,
comment|/*getcount_only*/
literal|0
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|saspace
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|count
parameter_list|,
name|scsi_space_code
name|code
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|scsi_space
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/*retries*/
literal|1
argument_list|,
comment|/*cbcfp*/
name|sadone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|code
argument_list|,
name|count
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
operator|(
name|SA_SPACE_TIMEOUT
operator|)
operator|*
literal|60
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
comment|/*cam_flags*/
literal|0
argument_list|,
comment|/*sense_flags*/
literal|0
argument_list|,
operator|&
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|!=
literal|0
condition|)
name|cam_release_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*relsim_flags*/
literal|0
argument_list|,
comment|/*reduction*/
literal|0
argument_list|,
comment|/*timeout*/
literal|0
argument_list|,
comment|/*getcount_only*/
literal|0
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sawritefilemarks
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|nmarks
parameter_list|,
name|int
name|setmarks
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|scsi_write_filemarks
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/*retries*/
literal|1
argument_list|,
comment|/*cbcfp*/
name|sadone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*immediate*/
name|FALSE
argument_list|,
name|setmarks
argument_list|,
name|nmarks
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
literal|60000
argument_list|)
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
comment|/*cam_flags*/
literal|0
argument_list|,
comment|/*sense_flags*/
literal|0
argument_list|,
operator|&
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|!=
literal|0
condition|)
name|cam_release_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*relsim_flags*/
literal|0
argument_list|,
comment|/*reduction*/
literal|0
argument_list|,
comment|/*timeout*/
literal|0
argument_list|,
comment|/*getcount_only*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|softc
operator|->
name|filemarks
operator|+=
name|nmarks
expr_stmt|;
block|}
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|saretension
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|scsi_load_unload
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/*retries*/
literal|1
argument_list|,
comment|/*cbfcnp*/
name|sadone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*immediate*/
name|FALSE
argument_list|,
comment|/*eot*/
name|FALSE
argument_list|,
comment|/*reten*/
name|TRUE
argument_list|,
comment|/*load*/
name|TRUE
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
literal|60000
argument_list|)
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
comment|/*cam_flags*/
literal|0
argument_list|,
comment|/*sense_flags*/
literal|0
argument_list|,
operator|&
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|!=
literal|0
condition|)
name|cam_release_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*relsim_flags*/
literal|0
argument_list|,
comment|/*reduction*/
literal|0
argument_list|,
comment|/*timeout*/
literal|0
argument_list|,
comment|/*getcount_only*/
literal|0
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sareservereleaseunit
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|reserve
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|scsi_reserve_release_unit
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/*retries*/
literal|1
argument_list|,
comment|/*cbfcnp*/
name|sadone
argument_list|,
comment|/*tag_action*/
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*third_party*/
name|FALSE
argument_list|,
comment|/*third_party_id*/
literal|0
argument_list|,
comment|/*sense_len*/
name|SSD_FULL_SIZE
argument_list|,
comment|/*timeout*/
literal|5000
argument_list|,
name|reserve
argument_list|)
expr_stmt|;
comment|/* 	 * We set SF_RETRY_UA, since this is often the first command run 	 * when a tape device is opened, and there may be a unit attention 	 * condition pending. 	 */
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
comment|/*cam_flags*/
literal|0
argument_list|,
comment|/*sense_flags*/
name|SF_RETRY_UA
argument_list|,
operator|&
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|!=
literal|0
condition|)
name|cam_release_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*relsim_flags*/
literal|0
argument_list|,
comment|/*reduction*/
literal|0
argument_list|,
comment|/*timeout*/
literal|0
argument_list|,
comment|/*getcount_only*/
literal|0
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|saloadunload
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|load
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|scsi_load_unload
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/*retries*/
literal|1
argument_list|,
comment|/*cbfcnp*/
name|sadone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*immediate*/
name|FALSE
argument_list|,
comment|/*eot*/
name|FALSE
argument_list|,
comment|/*reten*/
name|FALSE
argument_list|,
name|load
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
literal|60000
argument_list|)
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
comment|/*cam_flags*/
literal|0
argument_list|,
comment|/*sense_flags*/
literal|0
argument_list|,
operator|&
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|!=
literal|0
condition|)
name|cam_release_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*relsim_flags*/
literal|0
argument_list|,
comment|/*reduction*/
literal|0
argument_list|,
comment|/*timeout*/
literal|0
argument_list|,
comment|/*getcount_only*/
literal|0
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|saerase
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|longerase
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|sa_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|sa_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|ccb
operator|=
name|cam_periph_getccb
argument_list|(
name|periph
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|scsi_erase
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/*retries*/
literal|1
argument_list|,
comment|/*cbfcnp*/
name|sadone
argument_list|,
comment|/*tag_action*/
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*immediate*/
name|FALSE
argument_list|,
comment|/*long_erase*/
name|longerase
argument_list|,
comment|/*sense_len*/
name|SSD_FULL_SIZE
argument_list|,
comment|/*timeout*/
operator|(
name|SA_ERASE_TIMEOUT
operator|)
operator|*
literal|60
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|saerror
argument_list|,
comment|/*cam_flags*/
literal|0
argument_list|,
comment|/*sense_flags*/
literal|0
argument_list|,
operator|&
name|softc
operator|->
name|device_stats
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|!=
literal|0
condition|)
name|cam_release_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*relsim_flags*/
literal|0
argument_list|,
comment|/*reduction*/
literal|0
argument_list|,
comment|/*timeout*/
literal|0
argument_list|,
comment|/*getcount_only*/
literal|0
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KERNEL */
end_comment

begin_comment
comment|/*  * Read tape block limits command.  */
end_comment

begin_function
name|void
name|scsi_read_block_limits
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|struct
name|scsi_read_block_limits_data
modifier|*
name|rlimit_buf
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_read_block_limits
modifier|*
name|scsi_cmd
decl_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|CAM_DIR_IN
argument_list|,
name|tag_action
argument_list|,
comment|/*data_ptr*/
operator|(
name|u_int8_t
operator|*
operator|)
name|rlimit_buf
argument_list|,
comment|/*dxfer_len*/
sizeof|sizeof
argument_list|(
operator|*
name|rlimit_buf
argument_list|)
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_read_block_limits
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|READ_BLOCK_LIMITS
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_sa_read_write
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|int
name|readop
parameter_list|,
name|int
name|sli
parameter_list|,
name|int
name|fixed
parameter_list|,
name|u_int32_t
name|length
parameter_list|,
name|u_int8_t
modifier|*
name|data_ptr
parameter_list|,
name|u_int32_t
name|dxfer_len
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_sa_rw
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_sa_rw
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|readop
condition|?
name|SA_READ
else|:
name|SA_WRITE
expr_stmt|;
name|scsi_cmd
operator|->
name|sli_fixed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sli
operator|&&
name|readop
condition|)
name|scsi_cmd
operator|->
name|sli_fixed
operator||=
name|SAR_SLI
expr_stmt|;
if|if
condition|(
name|fixed
condition|)
name|scsi_cmd
operator|->
name|sli_fixed
operator||=
name|SARW_FIXED
expr_stmt|;
name|scsi_ulto3b
argument_list|(
name|length
argument_list|,
name|scsi_cmd
operator|->
name|length
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|control
operator|=
literal|0
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|readop
condition|?
name|CAM_DIR_IN
else|:
name|CAM_DIR_OUT
argument_list|,
name|tag_action
argument_list|,
name|data_ptr
argument_list|,
name|dxfer_len
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_load_unload
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|int
name|immediate
parameter_list|,
name|int
name|eot
parameter_list|,
name|int
name|reten
parameter_list|,
name|int
name|load
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_load_unload
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_load_unload
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|LOAD_UNLOAD
expr_stmt|;
if|if
condition|(
name|immediate
condition|)
name|scsi_cmd
operator|->
name|immediate
operator|=
name|SLU_IMMED
expr_stmt|;
if|if
condition|(
name|eot
condition|)
name|scsi_cmd
operator|->
name|eot_reten_load
operator||=
name|SLU_EOT
expr_stmt|;
if|if
condition|(
name|reten
condition|)
name|scsi_cmd
operator|->
name|eot_reten_load
operator||=
name|SLU_RETEN
expr_stmt|;
if|if
condition|(
name|load
condition|)
name|scsi_cmd
operator|->
name|eot_reten_load
operator||=
name|SLU_LOAD
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|CAM_DIR_NONE
argument_list|,
name|tag_action
argument_list|,
comment|/*data_ptr*/
name|NULL
argument_list|,
comment|/*dxfer_len*/
literal|0
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_rewind
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|int
name|immediate
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_rewind
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_rewind
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|REWIND
expr_stmt|;
if|if
condition|(
name|immediate
condition|)
name|scsi_cmd
operator|->
name|immediate
operator|=
name|SREW_IMMED
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|CAM_DIR_NONE
argument_list|,
name|tag_action
argument_list|,
comment|/*data_ptr*/
name|NULL
argument_list|,
comment|/*dxfer_len*/
literal|0
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_space
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|scsi_space_code
name|code
parameter_list|,
name|u_int32_t
name|count
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_space
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_space
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|SPACE
expr_stmt|;
name|scsi_cmd
operator|->
name|code
operator|=
name|code
expr_stmt|;
name|scsi_ulto3b
argument_list|(
name|count
argument_list|,
name|scsi_cmd
operator|->
name|count
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|control
operator|=
literal|0
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|CAM_DIR_NONE
argument_list|,
name|tag_action
argument_list|,
comment|/*data_ptr*/
name|NULL
argument_list|,
comment|/*dxfer_len*/
literal|0
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_write_filemarks
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|int
name|immediate
parameter_list|,
name|int
name|setmark
parameter_list|,
name|u_int32_t
name|num_marks
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_write_filemarks
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_write_filemarks
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|WRITE_FILEMARKS
expr_stmt|;
if|if
condition|(
name|immediate
condition|)
name|scsi_cmd
operator|->
name|byte2
operator||=
name|SWFMRK_IMMED
expr_stmt|;
if|if
condition|(
name|setmark
condition|)
name|scsi_cmd
operator|->
name|byte2
operator||=
name|SWFMRK_WSMK
expr_stmt|;
name|scsi_ulto3b
argument_list|(
name|num_marks
argument_list|,
name|scsi_cmd
operator|->
name|num_marks
argument_list|)
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|CAM_DIR_NONE
argument_list|,
name|tag_action
argument_list|,
comment|/*data_ptr*/
name|NULL
argument_list|,
comment|/*dxfer_len*/
literal|0
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The reserve and release unit commands differ only by their opcodes.  */
end_comment

begin_function
name|void
name|scsi_reserve_release_unit
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|int
name|third_party
parameter_list|,
name|int
name|third_party_id
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|,
name|int
name|reserve
parameter_list|)
block|{
name|struct
name|scsi_reserve_release_unit
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_reserve_release_unit
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reserve
condition|)
name|scsi_cmd
operator|->
name|opcode
operator|=
name|RESERVE_UNIT
expr_stmt|;
else|else
name|scsi_cmd
operator|->
name|opcode
operator|=
name|RELEASE_UNIT
expr_stmt|;
if|if
condition|(
name|third_party
condition|)
block|{
name|scsi_cmd
operator|->
name|lun_thirdparty
operator||=
name|SRRU_3RD_PARTY
expr_stmt|;
name|scsi_cmd
operator|->
name|lun_thirdparty
operator||=
operator|(
operator|(
name|third_party_id
operator|<<
name|SRRU_3RD_SHAMT
operator|)
operator|&
name|SRRU_3RD_MASK
operator|)
expr_stmt|;
block|}
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|CAM_DIR_NONE
argument_list|,
name|tag_action
argument_list|,
comment|/*data_ptr*/
name|NULL
argument_list|,
comment|/*dxfer_len*/
literal|0
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_erase
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int32_t
name|retries
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbfcnp
function_decl|)
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|int
name|immediate
parameter_list|,
name|int
name|long_erase
parameter_list|,
name|u_int8_t
name|sense_len
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_erase
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_erase
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|ERASE
expr_stmt|;
if|if
condition|(
name|immediate
condition|)
name|scsi_cmd
operator|->
name|lun_imm_long
operator||=
name|SE_IMMED
expr_stmt|;
if|if
condition|(
name|long_erase
condition|)
name|scsi_cmd
operator|->
name|lun_imm_long
operator||=
name|SE_LONG
expr_stmt|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
name|retries
argument_list|,
name|cbfcnp
argument_list|,
comment|/*flags*/
name|CAM_DIR_NONE
argument_list|,
name|tag_action
argument_list|,
comment|/*data_ptr*/
name|NULL
argument_list|,
comment|/*dxfer_len*/
literal|0
argument_list|,
name|sense_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

