begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Written by Julian Elischer (julian@tfs.com)  * for TRW Financial Systems for use under the MACH(2.5) operating system.  *  * TRW Financial Systems, in accordance with their agreement with Carnegie  * Mellon University, makes this software available to CMU to distribute  * or use in any manner that they see fit as long as this message is kept with  * the software. For this reason TFS also grants any other persons or  * organisations permission to use or modify this software.  *  * TFS supplies this software to be publicly redistributed  * on the understanding that TFS is not responsible for the correct  * functioning of this software in any circumstances.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * XXX XXX XXX XXX  We should get DEVFS working so that we  * don't have to do this, possibly sparse, array based junk.  * XXX: We can do this now with dev_t, that's even better.  */
end_comment

begin_comment
comment|/*  * Extensible arrays: Use a realloc like implementation to permit  * the arrays to be extend.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_extend.h>
end_include

begin_struct
struct|struct
name|extend_array
block|{
name|int
name|nelem
decl_stmt|;
name|void
modifier|*
modifier|*
name|ps
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
modifier|*
name|cam_extend_alloc
parameter_list|(
name|size_t
name|s
parameter_list|)
block|{
name|void
modifier|*
name|p
init|=
name|malloc
argument_list|(
name|s
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|panic
argument_list|(
literal|"extend_alloc: malloc failed."
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cam_extend_free
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|free
argument_list|(
name|p
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* EXTEND_CHUNK: Number of extend slots to allocate whenever we need a new  * one.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|EXTEND_CHUNK
end_ifndef

begin_define
define|#
directive|define
name|EXTEND_CHUNK
value|8
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|struct
name|extend_array
modifier|*
name|cam_extend_new
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|extend_array
modifier|*
name|p
init|=
name|cam_extend_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|p
operator|->
name|nelem
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|ps
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|cam_extend_set
parameter_list|(
name|struct
name|extend_array
modifier|*
name|ea
parameter_list|,
name|int
name|index
parameter_list|,
name|void
modifier|*
name|value
parameter_list|)
block|{
if|if
condition|(
name|index
operator|>=
name|ea
operator|->
name|nelem
condition|)
block|{
name|void
modifier|*
modifier|*
name|space
decl_stmt|;
name|space
operator|=
name|cam_extend_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|*
operator|(
name|index
operator|+
name|EXTEND_CHUNK
operator|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|space
argument_list|,
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|*
operator|(
name|index
operator|+
name|EXTEND_CHUNK
operator|)
argument_list|)
expr_stmt|;
comment|/* Make sure we have something to copy before we copy it */
if|if
condition|(
name|ea
operator|->
name|nelem
condition|)
block|{
name|bcopy
argument_list|(
name|ea
operator|->
name|ps
argument_list|,
name|space
argument_list|,
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|*
name|ea
operator|->
name|nelem
argument_list|)
expr_stmt|;
name|cam_extend_free
argument_list|(
name|ea
operator|->
name|ps
argument_list|)
expr_stmt|;
block|}
name|ea
operator|->
name|ps
operator|=
name|space
expr_stmt|;
name|ea
operator|->
name|nelem
operator|=
name|index
operator|+
name|EXTEND_CHUNK
expr_stmt|;
block|}
if|if
condition|(
name|ea
operator|->
name|ps
index|[
name|index
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"extend_set: entry %d already has storage.\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
name|ea
operator|->
name|ps
index|[
name|index
index|]
operator|=
name|value
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|cam_extend_get
parameter_list|(
name|struct
name|extend_array
modifier|*
name|ea
parameter_list|,
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
name|ea
operator|==
name|NULL
operator|||
name|index
operator|>=
name|ea
operator|->
name|nelem
operator|||
name|index
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
return|return
name|ea
operator|->
name|ps
index|[
name|index
index|]
return|;
block|}
end_function

begin_function
name|void
name|cam_extend_release
parameter_list|(
name|struct
name|extend_array
modifier|*
name|ea
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|void
modifier|*
name|p
init|=
name|cam_extend_get
argument_list|(
name|ea
argument_list|,
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|ea
operator|->
name|ps
index|[
name|index
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

end_unit

