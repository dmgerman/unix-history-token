begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * CAM IO Scheduler Interface  *  * Copyright (c) 2015 Netflix, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opt_cam.h"
end_include

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_internal.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_iosched.h>
end_include

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_CAMSCHED
argument_list|,
literal|"CAM I/O Scheduler"
argument_list|,
literal|"CAM I/O Scheduler buffers"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Default I/O scheduler for FreeBSD. This implementation is just a thin-vineer  * over the bioq_* interface, with notions of separate calls for normal I/O and  * for trims.  *  * When CAM_IOSCHED_DYNAMIC is defined, the scheduler is enhanced to dynamically  * steer the rate of one type of traffic to help other types of traffic (eg  * limit writes when read latency deteriorates on SSDs).  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CAM_IOSCHED_DYNAMIC
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|do_dynamic_iosched
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"kern.cam.do_dynamic_iosched"
argument_list|,
operator|&
name|do_dynamic_iosched
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_cam
argument_list|,
name|OID_AUTO
argument_list|,
name|do_dynamic_iosched
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|do_dynamic_iosched
argument_list|,
literal|1
argument_list|,
literal|"Enable Dynamic I/O scheduler optimizations."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * For an EMA, with an alpha of alpha, we know  * 	alpha = 2 / (N + 1)  * or  * 	N = 1 + (2 / alpha)  * where N is the number of samples that 86% of the current  * EMA is derived from.  *  * So we invent[*] alpha_bits:  *	alpha_bits = -log_2(alpha)  *	alpha = 2^-alpha_bits  * So  *	N = 1 + 2^(alpha_bits + 1)  *  * The default 9 gives a 1025 lookback for 86% of the data.  * For a brief intro: https://en.wikipedia.org/wiki/Moving_average  *  * [*] Steal from the load average code and many other places.  * Note: See computation of EMA and EMVAR for acceptable ranges of alpha.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|alpha_bits
init|=
literal|9
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"kern.cam.iosched_alpha_bits"
argument_list|,
operator|&
name|alpha_bits
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_cam
argument_list|,
name|OID_AUTO
argument_list|,
name|iosched_alpha_bits
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|alpha_bits
argument_list|,
literal|1
argument_list|,
literal|"Bits in EMA's alpha."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct_decl
struct_decl|struct
name|iop_stats
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|cam_iosched_softc
struct_decl|;
end_struct_decl

begin_decl_stmt
name|int
name|iosched_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
enum|enum
block|{
name|none
init|=
literal|0
block|,
comment|/* No limits */
name|queue_depth
block|,
comment|/* Limit how many ops we queue to SIM */
name|iops
block|,
comment|/* Limit # of IOPS to the drive */
name|bandwidth
block|,
comment|/* Limit bandwidth to the drive */
name|limiter_max
block|}
name|io_limiter
typedef|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|cam_iosched_limiter_names
index|[]
init|=
block|{
literal|"none"
block|,
literal|"queue_depth"
block|,
literal|"iops"
block|,
literal|"bandwidth"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Called to initialize the bits of the iop_stats structure relevant to the  * limiter. Called just after the limiter is set.  */
end_comment

begin_typedef
typedef|typedef
name|int
name|l_init_t
parameter_list|(
name|struct
name|iop_stats
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/*  * Called every tick.  */
end_comment

begin_typedef
typedef|typedef
name|int
name|l_tick_t
parameter_list|(
name|struct
name|iop_stats
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/*  * Called to see if the limiter thinks this IOP can be allowed to  * proceed. If so, the limiter assumes that the IOP proceeded  * and makes any accounting of it that's needed.  */
end_comment

begin_typedef
typedef|typedef
name|int
name|l_iop_t
parameter_list|(
name|struct
name|iop_stats
modifier|*
parameter_list|,
name|struct
name|bio
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/*  * Called when an I/O completes so the limiter can update its  * accounting. Pending I/Os may complete in any order (even when  * sent to the hardware at the same time), so the limiter may not  * make any assumptions other than this I/O has completed. If it  * returns 1, then xpt_schedule() needs to be called again.  */
end_comment

begin_typedef
typedef|typedef
name|int
name|l_iodone_t
parameter_list|(
name|struct
name|iop_stats
modifier|*
parameter_list|,
name|struct
name|bio
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_decl_stmt
specifier|static
name|l_iop_t
name|cam_iosched_qd_iop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|l_iop_t
name|cam_iosched_qd_caniop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|l_iodone_t
name|cam_iosched_qd_iodone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|l_init_t
name|cam_iosched_iops_init
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|l_tick_t
name|cam_iosched_iops_tick
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|l_iop_t
name|cam_iosched_iops_caniop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|l_iop_t
name|cam_iosched_iops_iop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|l_init_t
name|cam_iosched_bw_init
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|l_tick_t
name|cam_iosched_bw_tick
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|l_iop_t
name|cam_iosched_bw_caniop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|l_iop_t
name|cam_iosched_bw_iop
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|limswitch
block|{
name|l_init_t
modifier|*
name|l_init
decl_stmt|;
name|l_tick_t
modifier|*
name|l_tick
decl_stmt|;
name|l_iop_t
modifier|*
name|l_iop
decl_stmt|;
name|l_iop_t
modifier|*
name|l_caniop
decl_stmt|;
name|l_iodone_t
modifier|*
name|l_iodone
decl_stmt|;
block|}
name|limsw
index|[]
init|=
block|{
block|{
comment|/* none */
operator|.
name|l_init
operator|=
name|NULL
block|,
operator|.
name|l_tick
operator|=
name|NULL
block|,
operator|.
name|l_iop
operator|=
name|NULL
block|,
operator|.
name|l_iodone
operator|=
name|NULL
block|, 	}
block|,
block|{
comment|/* queue_depth */
operator|.
name|l_init
operator|=
name|NULL
block|,
operator|.
name|l_tick
operator|=
name|NULL
block|,
operator|.
name|l_caniop
operator|=
name|cam_iosched_qd_caniop
block|,
operator|.
name|l_iop
operator|=
name|cam_iosched_qd_iop
block|,
operator|.
name|l_iodone
operator|=
name|cam_iosched_qd_iodone
block|, 	}
block|,
block|{
comment|/* iops */
operator|.
name|l_init
operator|=
name|cam_iosched_iops_init
block|,
operator|.
name|l_tick
operator|=
name|cam_iosched_iops_tick
block|,
operator|.
name|l_caniop
operator|=
name|cam_iosched_iops_caniop
block|,
operator|.
name|l_iop
operator|=
name|cam_iosched_iops_iop
block|,
operator|.
name|l_iodone
operator|=
name|NULL
block|, 	}
block|,
block|{
comment|/* bandwidth */
operator|.
name|l_init
operator|=
name|cam_iosched_bw_init
block|,
operator|.
name|l_tick
operator|=
name|cam_iosched_bw_tick
block|,
operator|.
name|l_caniop
operator|=
name|cam_iosched_bw_caniop
block|,
operator|.
name|l_iop
operator|=
name|cam_iosched_bw_iop
block|,
operator|.
name|l_iodone
operator|=
name|NULL
block|, 	}
block|, }
struct|;
end_struct

begin_struct
struct|struct
name|iop_stats
block|{
comment|/* 	 * sysctl state for this subnode. 	 */
name|struct
name|sysctl_ctx_list
name|sysctl_ctx
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|sysctl_tree
decl_stmt|;
comment|/* 	 * Information about the current rate limiters, if any 	 */
name|io_limiter
name|limiter
decl_stmt|;
comment|/* How are I/Os being limited */
name|int
name|min
decl_stmt|;
comment|/* Low range of limit */
name|int
name|max
decl_stmt|;
comment|/* High range of limit */
name|int
name|current
decl_stmt|;
comment|/* Current rate limiter */
name|int
name|l_value1
decl_stmt|;
comment|/* per-limiter scratch value 1. */
name|int
name|l_value2
decl_stmt|;
comment|/* per-limiter scratch value 2. */
comment|/* 	 * Debug information about counts of I/Os that have gone through the 	 * scheduler. 	 */
name|int
name|pending
decl_stmt|;
comment|/* I/Os pending in the hardware */
name|int
name|queued
decl_stmt|;
comment|/* number currently in the queue */
name|int
name|total
decl_stmt|;
comment|/* Total for all time -- wraps */
name|int
name|in
decl_stmt|;
comment|/* number queued all time -- wraps */
name|int
name|out
decl_stmt|;
comment|/* number completed all time -- wraps */
comment|/* 	 * Statistics on different bits of the process. 	 */
comment|/* Exp Moving Average, see alpha_bits for more details */
name|sbintime_t
name|ema
decl_stmt|;
name|sbintime_t
name|emvar
decl_stmt|;
name|sbintime_t
name|sd
decl_stmt|;
comment|/* Last computed sd */
name|uint32_t
name|state_flags
decl_stmt|;
define|#
directive|define
name|IOP_RATE_LIMITED
value|1u
define|#
directive|define
name|LAT_BUCKETS
value|12
comment|/*< 1ms< 2ms ... 512ms< 1024ms> 1024ms */
name|uint64_t
name|latencies
index|[
name|LAT_BUCKETS
index|]
decl_stmt|;
name|struct
name|cam_iosched_softc
modifier|*
name|softc
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
enum|enum
block|{
name|set_max
init|=
literal|0
block|,
comment|/* current = max */
name|read_latency
block|,
comment|/* Steer read latency by throttling writes */
name|cl_max
comment|/* Keep last */
block|}
name|control_type
typedef|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|cam_iosched_control_type_names
index|[]
init|=
block|{
literal|"set_max"
block|,
literal|"read_latency"
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|control_loop
block|{
comment|/* 	 * sysctl state for this subnode. 	 */
name|struct
name|sysctl_ctx_list
name|sysctl_ctx
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|sysctl_tree
decl_stmt|;
name|sbintime_t
name|next_steer
decl_stmt|;
comment|/* Time of next steer */
name|sbintime_t
name|steer_interval
decl_stmt|;
comment|/* How often do we steer? */
name|sbintime_t
name|lolat
decl_stmt|;
name|sbintime_t
name|hilat
decl_stmt|;
name|int
name|alpha
decl_stmt|;
name|control_type
name|type
decl_stmt|;
comment|/* What type of control? */
name|int
name|last_count
decl_stmt|;
comment|/* Last I/O count */
name|struct
name|cam_iosched_softc
modifier|*
name|softc
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|cam_iosched_softc
block|{
name|struct
name|bio_queue_head
name|bio_queue
decl_stmt|;
name|struct
name|bio_queue_head
name|trim_queue
decl_stmt|;
comment|/* scheduler flags< 16, user flags>= 16 */
name|uint32_t
name|flags
decl_stmt|;
name|int
name|sort_io_queue
decl_stmt|;
ifdef|#
directive|ifdef
name|CAM_IOSCHED_DYNAMIC
name|int
name|read_bias
decl_stmt|;
comment|/* Read bias setting */
name|int
name|current_read_bias
decl_stmt|;
comment|/* Current read bias state */
name|int
name|total_ticks
decl_stmt|;
name|int
name|load
decl_stmt|;
comment|/* EMA of 'load average' of disk / 2^16 */
name|struct
name|bio_queue_head
name|write_queue
decl_stmt|;
name|struct
name|iop_stats
name|read_stats
decl_stmt|,
name|write_stats
decl_stmt|,
name|trim_stats
decl_stmt|;
name|struct
name|sysctl_ctx_list
name|sysctl_ctx
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|sysctl_tree
decl_stmt|;
name|int
name|quanta
decl_stmt|;
comment|/* Number of quanta per second */
name|struct
name|callout
name|ticker
decl_stmt|;
comment|/* Callout for our quota system */
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
comment|/* cam periph associated with this device */
name|uint32_t
name|this_frac
decl_stmt|;
comment|/* Fraction of a second (1024ths) for this tick */
name|sbintime_t
name|last_time
decl_stmt|;
comment|/* Last time we ticked */
name|struct
name|control_loop
name|cl
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|CAM_IOSCHED_DYNAMIC
end_ifdef

begin_comment
comment|/*  * helper functions to call the limsw functions.  */
end_comment

begin_function
specifier|static
name|int
name|cam_iosched_limiter_init
parameter_list|(
name|struct
name|iop_stats
modifier|*
name|ios
parameter_list|)
block|{
name|int
name|lim
init|=
name|ios
operator|->
name|limiter
decl_stmt|;
comment|/* maybe this should be a kassert */
if|if
condition|(
name|lim
operator|<
name|none
operator|||
name|lim
operator|>=
name|limiter_max
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|limsw
index|[
name|lim
index|]
operator|.
name|l_init
condition|)
return|return
name|limsw
index|[
name|lim
index|]
operator|.
name|l_init
argument_list|(
name|ios
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cam_iosched_limiter_tick
parameter_list|(
name|struct
name|iop_stats
modifier|*
name|ios
parameter_list|)
block|{
name|int
name|lim
init|=
name|ios
operator|->
name|limiter
decl_stmt|;
comment|/* maybe this should be a kassert */
if|if
condition|(
name|lim
operator|<
name|none
operator|||
name|lim
operator|>=
name|limiter_max
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|limsw
index|[
name|lim
index|]
operator|.
name|l_tick
condition|)
return|return
name|limsw
index|[
name|lim
index|]
operator|.
name|l_tick
argument_list|(
name|ios
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cam_iosched_limiter_iop
parameter_list|(
name|struct
name|iop_stats
modifier|*
name|ios
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|lim
init|=
name|ios
operator|->
name|limiter
decl_stmt|;
comment|/* maybe this should be a kassert */
if|if
condition|(
name|lim
operator|<
name|none
operator|||
name|lim
operator|>=
name|limiter_max
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|limsw
index|[
name|lim
index|]
operator|.
name|l_iop
condition|)
return|return
name|limsw
index|[
name|lim
index|]
operator|.
name|l_iop
argument_list|(
name|ios
argument_list|,
name|bp
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cam_iosched_limiter_caniop
parameter_list|(
name|struct
name|iop_stats
modifier|*
name|ios
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|lim
init|=
name|ios
operator|->
name|limiter
decl_stmt|;
comment|/* maybe this should be a kassert */
if|if
condition|(
name|lim
operator|<
name|none
operator|||
name|lim
operator|>=
name|limiter_max
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|limsw
index|[
name|lim
index|]
operator|.
name|l_caniop
condition|)
return|return
name|limsw
index|[
name|lim
index|]
operator|.
name|l_caniop
argument_list|(
name|ios
argument_list|,
name|bp
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cam_iosched_limiter_iodone
parameter_list|(
name|struct
name|iop_stats
modifier|*
name|ios
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|lim
init|=
name|ios
operator|->
name|limiter
decl_stmt|;
comment|/* maybe this should be a kassert */
if|if
condition|(
name|lim
operator|<
name|none
operator|||
name|lim
operator|>=
name|limiter_max
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|limsw
index|[
name|lim
index|]
operator|.
name|l_iodone
condition|)
return|return
name|limsw
index|[
name|lim
index|]
operator|.
name|l_iodone
argument_list|(
name|ios
argument_list|,
name|bp
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Functions to implement the different kinds of limiters  */
end_comment

begin_function
specifier|static
name|int
name|cam_iosched_qd_iop
parameter_list|(
name|struct
name|iop_stats
modifier|*
name|ios
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
if|if
condition|(
name|ios
operator|->
name|current
operator|<=
literal|0
operator|||
name|ios
operator|->
name|pending
operator|<
name|ios
operator|->
name|current
condition|)
return|return
literal|0
return|;
return|return
name|EAGAIN
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cam_iosched_qd_caniop
parameter_list|(
name|struct
name|iop_stats
modifier|*
name|ios
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
if|if
condition|(
name|ios
operator|->
name|current
operator|<=
literal|0
operator|||
name|ios
operator|->
name|pending
operator|<
name|ios
operator|->
name|current
condition|)
return|return
literal|0
return|;
return|return
name|EAGAIN
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cam_iosched_qd_iodone
parameter_list|(
name|struct
name|iop_stats
modifier|*
name|ios
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
if|if
condition|(
name|ios
operator|->
name|current
operator|<=
literal|0
operator|||
name|ios
operator|->
name|pending
operator|!=
name|ios
operator|->
name|current
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cam_iosched_iops_init
parameter_list|(
name|struct
name|iop_stats
modifier|*
name|ios
parameter_list|)
block|{
name|ios
operator|->
name|l_value1
operator|=
name|ios
operator|->
name|current
operator|/
name|ios
operator|->
name|softc
operator|->
name|quanta
expr_stmt|;
if|if
condition|(
name|ios
operator|->
name|l_value1
operator|<=
literal|0
condition|)
name|ios
operator|->
name|l_value1
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cam_iosched_iops_tick
parameter_list|(
name|struct
name|iop_stats
modifier|*
name|ios
parameter_list|)
block|{
name|ios
operator|->
name|l_value1
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|ios
operator|->
name|current
operator|*
operator|(
name|uint64_t
operator|)
name|ios
operator|->
name|softc
operator|->
name|this_frac
operator|)
operator|>>
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|ios
operator|->
name|l_value1
operator|<=
literal|0
condition|)
name|ios
operator|->
name|l_value1
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cam_iosched_iops_caniop
parameter_list|(
name|struct
name|iop_stats
modifier|*
name|ios
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
comment|/* 	 * So if we have any more IOPs left, allow it, 	 * otherwise wait. 	 */
if|if
condition|(
name|ios
operator|->
name|l_value1
operator|<=
literal|0
condition|)
return|return
name|EAGAIN
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cam_iosched_iops_iop
parameter_list|(
name|struct
name|iop_stats
modifier|*
name|ios
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|rv
decl_stmt|;
name|rv
operator|=
name|cam_iosched_limiter_caniop
argument_list|(
name|ios
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
literal|0
condition|)
name|ios
operator|->
name|l_value1
operator|--
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cam_iosched_bw_init
parameter_list|(
name|struct
name|iop_stats
modifier|*
name|ios
parameter_list|)
block|{
comment|/* ios->current is in kB/s, so scale to bytes */
name|ios
operator|->
name|l_value1
operator|=
name|ios
operator|->
name|current
operator|*
literal|1000
operator|/
name|ios
operator|->
name|softc
operator|->
name|quanta
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cam_iosched_bw_tick
parameter_list|(
name|struct
name|iop_stats
modifier|*
name|ios
parameter_list|)
block|{
name|int
name|bw
decl_stmt|;
comment|/* 	 * If we're in the hole for available quota from 	 * the last time, then add the quantum for this. 	 * If we have any left over from last quantum, 	 * then too bad, that's lost. Also, ios->current 	 * is in kB/s, so scale. 	 * 	 * We also allow up to 4 quanta of credits to 	 * accumulate to deal with burstiness. 4 is extremely 	 * arbitrary. 	 */
name|bw
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|ios
operator|->
name|current
operator|*
literal|1000ull
operator|*
operator|(
name|uint64_t
operator|)
name|ios
operator|->
name|softc
operator|->
name|this_frac
operator|)
operator|>>
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|ios
operator|->
name|l_value1
operator|<
name|bw
operator|*
literal|4
condition|)
name|ios
operator|->
name|l_value1
operator|+=
name|bw
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cam_iosched_bw_caniop
parameter_list|(
name|struct
name|iop_stats
modifier|*
name|ios
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
comment|/* 	 * So if we have any more bw quota left, allow it, 	 * otherwise wait. Note, we'll go negative and that's 	 * OK. We'll just get a little less next quota. 	 * 	 * Note on going negative: that allows us to process 	 * requests in order better, since we won't allow 	 * shorter reads to get around the long one that we 	 * don't have the quota to do just yet. It also prevents 	 * starvation by being a little more permissive about 	 * what we let through this quantum (to prevent the 	 * starvation), at the cost of getting a little less 	 * next quantum. 	 */
if|if
condition|(
name|ios
operator|->
name|l_value1
operator|<=
literal|0
condition|)
return|return
name|EAGAIN
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cam_iosched_bw_iop
parameter_list|(
name|struct
name|iop_stats
modifier|*
name|ios
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|rv
decl_stmt|;
name|rv
operator|=
name|cam_iosched_limiter_caniop
argument_list|(
name|ios
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
literal|0
condition|)
name|ios
operator|->
name|l_value1
operator|-=
name|bp
operator|->
name|bio_length
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|cam_iosched_cl_maybe_steer
parameter_list|(
name|struct
name|control_loop
modifier|*
name|clp
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|cam_iosched_ticker
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cam_iosched_softc
modifier|*
name|isc
init|=
name|arg
decl_stmt|;
name|sbintime_t
name|now
decl_stmt|,
name|delta
decl_stmt|;
name|int
name|pending
decl_stmt|;
name|callout_reset
argument_list|(
operator|&
name|isc
operator|->
name|ticker
argument_list|,
name|hz
operator|/
name|isc
operator|->
name|quanta
operator|-
literal|1
argument_list|,
name|cam_iosched_ticker
argument_list|,
name|isc
argument_list|)
expr_stmt|;
name|now
operator|=
name|sbinuptime
argument_list|()
expr_stmt|;
name|delta
operator|=
name|now
operator|-
name|isc
operator|->
name|last_time
expr_stmt|;
name|isc
operator|->
name|this_frac
operator|=
operator|(
name|uint32_t
operator|)
name|delta
operator|>>
literal|16
expr_stmt|;
comment|/* Note: discards seconds -- should be 0 harmless if not */
name|isc
operator|->
name|last_time
operator|=
name|now
expr_stmt|;
name|cam_iosched_cl_maybe_steer
argument_list|(
operator|&
name|isc
operator|->
name|cl
argument_list|)
expr_stmt|;
name|cam_iosched_limiter_tick
argument_list|(
operator|&
name|isc
operator|->
name|read_stats
argument_list|)
expr_stmt|;
name|cam_iosched_limiter_tick
argument_list|(
operator|&
name|isc
operator|->
name|write_stats
argument_list|)
expr_stmt|;
name|cam_iosched_limiter_tick
argument_list|(
operator|&
name|isc
operator|->
name|trim_stats
argument_list|)
expr_stmt|;
name|cam_iosched_schedule
argument_list|(
name|isc
argument_list|,
name|isc
operator|->
name|periph
argument_list|)
expr_stmt|;
comment|/* 	 * isc->load is an EMA of the pending I/Os at each tick. The number of 	 * pending I/Os is the sum of the I/Os queued to the hardware, and those 	 * in the software queue that could be queued to the hardware if there 	 * were slots. 	 * 	 * ios_stats.pending is a count of requests in the SIM right now for 	 * each of these types of I/O. So the total pending count is the sum of 	 * these I/Os and the sum of the queued I/Os still in the software queue 	 * for those operations that aren't being rate limited at the moment. 	 * 	 * The reason for the rate limiting bit is because those I/Os 	 * aren't part of the software queued load (since we could 	 * give them to hardware, but choose not to). 	 * 	 * Note: due to a bug in counting pending TRIM in the device, we 	 * don't include them in this count. We count each BIO_DELETE in 	 * the pending count, but the periph drivers collapse them down 	 * into one TRIM command. That one trim command gets the completion 	 * so the counts get off. 	 */
name|pending
operator|=
name|isc
operator|->
name|read_stats
operator|.
name|pending
operator|+
name|isc
operator|->
name|write_stats
operator|.
name|pending
comment|/* + isc->trim_stats.pending */
expr_stmt|;
name|pending
operator|+=
operator|!
operator|!
operator|(
name|isc
operator|->
name|read_stats
operator|.
name|state_flags
operator|&
name|IOP_RATE_LIMITED
operator|)
operator|*
name|isc
operator|->
name|read_stats
operator|.
name|queued
operator|+
operator|!
operator|!
operator|(
name|isc
operator|->
name|write_stats
operator|.
name|state_flags
operator|&
name|IOP_RATE_LIMITED
operator|)
operator|*
name|isc
operator|->
name|write_stats
operator|.
name|queued
comment|/* + 	    !!(isc->trim_stats.state_flags& IOP_RATE_LIMITED) * isc->trim_stats.queued */
expr_stmt|;
name|pending
operator|<<=
literal|16
expr_stmt|;
name|pending
operator|/=
name|isc
operator|->
name|periph
operator|->
name|path
operator|->
name|device
operator|->
name|ccbq
operator|.
name|total_openings
expr_stmt|;
name|isc
operator|->
name|load
operator|=
operator|(
name|pending
operator|+
operator|(
name|isc
operator|->
name|load
operator|<<
literal|13
operator|)
operator|-
name|isc
operator|->
name|load
operator|)
operator|>>
literal|13
expr_stmt|;
comment|/* see above: 13 -> 16139 / 200/s = ~81s ~1 minute */
name|isc
operator|->
name|total_ticks
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cam_iosched_cl_init
parameter_list|(
name|struct
name|control_loop
modifier|*
name|clp
parameter_list|,
name|struct
name|cam_iosched_softc
modifier|*
name|isc
parameter_list|)
block|{
name|clp
operator|->
name|next_steer
operator|=
name|sbinuptime
argument_list|()
expr_stmt|;
name|clp
operator|->
name|softc
operator|=
name|isc
expr_stmt|;
name|clp
operator|->
name|steer_interval
operator|=
name|SBT_1S
operator|*
literal|5
expr_stmt|;
comment|/* Let's start out steering every 5s */
name|clp
operator|->
name|lolat
operator|=
literal|5
operator|*
name|SBT_1MS
expr_stmt|;
name|clp
operator|->
name|hilat
operator|=
literal|15
operator|*
name|SBT_1MS
expr_stmt|;
name|clp
operator|->
name|alpha
operator|=
literal|20
expr_stmt|;
comment|/* Alpha == gain. 20 = .2 */
name|clp
operator|->
name|type
operator|=
name|set_max
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cam_iosched_cl_maybe_steer
parameter_list|(
name|struct
name|control_loop
modifier|*
name|clp
parameter_list|)
block|{
name|struct
name|cam_iosched_softc
modifier|*
name|isc
decl_stmt|;
name|sbintime_t
name|now
decl_stmt|,
name|lat
decl_stmt|;
name|int
name|old
decl_stmt|;
name|isc
operator|=
name|clp
operator|->
name|softc
expr_stmt|;
name|now
operator|=
name|isc
operator|->
name|last_time
expr_stmt|;
if|if
condition|(
name|now
operator|<
name|clp
operator|->
name|next_steer
condition|)
return|return;
name|clp
operator|->
name|next_steer
operator|=
name|now
operator|+
name|clp
operator|->
name|steer_interval
expr_stmt|;
switch|switch
condition|(
name|clp
operator|->
name|type
condition|)
block|{
case|case
name|set_max
case|:
if|if
condition|(
name|isc
operator|->
name|write_stats
operator|.
name|current
operator|!=
name|isc
operator|->
name|write_stats
operator|.
name|max
condition|)
name|printf
argument_list|(
literal|"Steering write from %d kBps to %d kBps\n"
argument_list|,
name|isc
operator|->
name|write_stats
operator|.
name|current
argument_list|,
name|isc
operator|->
name|write_stats
operator|.
name|max
argument_list|)
expr_stmt|;
name|isc
operator|->
name|read_stats
operator|.
name|current
operator|=
name|isc
operator|->
name|read_stats
operator|.
name|max
expr_stmt|;
name|isc
operator|->
name|write_stats
operator|.
name|current
operator|=
name|isc
operator|->
name|write_stats
operator|.
name|max
expr_stmt|;
name|isc
operator|->
name|trim_stats
operator|.
name|current
operator|=
name|isc
operator|->
name|trim_stats
operator|.
name|max
expr_stmt|;
break|break;
case|case
name|read_latency
case|:
name|old
operator|=
name|isc
operator|->
name|write_stats
operator|.
name|current
expr_stmt|;
name|lat
operator|=
name|isc
operator|->
name|read_stats
operator|.
name|ema
expr_stmt|;
comment|/* 		 * Simple PLL-like engine. Since we're steering to a range for 		 * the SP (set point) that makes things a little more 		 * complicated. In addition, we're not directly controlling our 		 * PV (process variable), the read latency, but instead are 		 * manipulating the write bandwidth limit for our MV 		 * (manipulation variable), analysis of this code gets a bit 		 * messy. Also, the MV is a very noisy control surface for read 		 * latency since it is affected by many hidden processes inside 		 * the device which change how responsive read latency will be 		 * in reaction to changes in write bandwidth. Unlike the classic 		 * boiler control PLL. this may result in over-steering while 		 * the SSD takes its time to react to the new, lower load. This 		 * is why we use a relatively low alpha of between .1 and .25 to 		 * compensate for this effect. At .1, it takes ~22 steering 		 * intervals to back off by a factor of 10. At .2 it only takes 		 * ~10. At .25 it only takes ~8. However some preliminary data 		 * from the SSD drives suggests a reasponse time in 10's of 		 * seconds before latency drops regardless of the new write 		 * rate. Careful observation will be required to tune this 		 * effectively. 		 * 		 * Also, when there's no read traffic, we jack up the write 		 * limit too regardless of the last read latency.  10 is 		 * somewhat arbitrary. 		 */
if|if
condition|(
name|lat
operator|<
name|clp
operator|->
name|lolat
operator|||
name|isc
operator|->
name|read_stats
operator|.
name|total
operator|-
name|clp
operator|->
name|last_count
operator|<
literal|10
condition|)
name|isc
operator|->
name|write_stats
operator|.
name|current
operator|=
name|isc
operator|->
name|write_stats
operator|.
name|current
operator|*
operator|(
literal|100
operator|+
name|clp
operator|->
name|alpha
operator|)
operator|/
literal|100
expr_stmt|;
comment|/* Scale up */
elseif|else
if|if
condition|(
name|lat
operator|>
name|clp
operator|->
name|hilat
condition|)
name|isc
operator|->
name|write_stats
operator|.
name|current
operator|=
name|isc
operator|->
name|write_stats
operator|.
name|current
operator|*
operator|(
literal|100
operator|-
name|clp
operator|->
name|alpha
operator|)
operator|/
literal|100
expr_stmt|;
comment|/* Scale down */
name|clp
operator|->
name|last_count
operator|=
name|isc
operator|->
name|read_stats
operator|.
name|total
expr_stmt|;
comment|/* 		 * Even if we don't steer, per se, enforce the min/max limits as 		 * those may have changed. 		 */
if|if
condition|(
name|isc
operator|->
name|write_stats
operator|.
name|current
operator|<
name|isc
operator|->
name|write_stats
operator|.
name|min
condition|)
name|isc
operator|->
name|write_stats
operator|.
name|current
operator|=
name|isc
operator|->
name|write_stats
operator|.
name|min
expr_stmt|;
if|if
condition|(
name|isc
operator|->
name|write_stats
operator|.
name|current
operator|>
name|isc
operator|->
name|write_stats
operator|.
name|max
condition|)
name|isc
operator|->
name|write_stats
operator|.
name|current
operator|=
name|isc
operator|->
name|write_stats
operator|.
name|max
expr_stmt|;
if|if
condition|(
name|old
operator|!=
name|isc
operator|->
name|write_stats
operator|.
name|current
operator|&&
name|iosched_debug
condition|)
name|printf
argument_list|(
literal|"Steering write from %d kBps to %d kBps due to latency of %jdus\n"
argument_list|,
name|old
argument_list|,
name|isc
operator|->
name|write_stats
operator|.
name|current
argument_list|,
call|(
name|uintmax_t
call|)
argument_list|(
operator|(
name|uint64_t
operator|)
literal|1000000
operator|*
operator|(
name|uint32_t
operator|)
name|lat
argument_list|)
operator|>>
literal|32
argument_list|)
expr_stmt|;
break|break;
case|case
name|cl_max
case|:
break|break;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Trim or similar currently pending completion */
end_comment

begin_define
define|#
directive|define
name|CAM_IOSCHED_FLAG_TRIM_ACTIVE
value|(1ul<< 0)
end_define

begin_comment
comment|/* Callout active, and needs to be torn down */
end_comment

begin_define
define|#
directive|define
name|CAM_IOSCHED_FLAG_CALLOUT_ACTIVE
value|(1ul<< 1)
end_define

begin_comment
comment|/* Periph drivers set these flags to indicate work */
end_comment

begin_define
define|#
directive|define
name|CAM_IOSCHED_FLAG_WORK_FLAGS
value|((0xffffu)<< 16)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|CAM_IOSCHED_DYNAMIC
end_ifdef

begin_function_decl
specifier|static
name|void
name|cam_iosched_io_metric_update
parameter_list|(
name|struct
name|cam_iosched_softc
modifier|*
name|isc
parameter_list|,
name|sbintime_t
name|sim_latency
parameter_list|,
name|int
name|cmd
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|inline
name|int
name|cam_iosched_has_flagged_work
parameter_list|(
name|struct
name|cam_iosched_softc
modifier|*
name|isc
parameter_list|)
block|{
return|return
operator|!
operator|!
operator|(
name|isc
operator|->
name|flags
operator|&
name|CAM_IOSCHED_FLAG_WORK_FLAGS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|cam_iosched_has_io
parameter_list|(
name|struct
name|cam_iosched_softc
modifier|*
name|isc
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|CAM_IOSCHED_DYNAMIC
if|if
condition|(
name|do_dynamic_iosched
condition|)
block|{
name|struct
name|bio
modifier|*
name|rbp
init|=
name|bioq_first
argument_list|(
operator|&
name|isc
operator|->
name|bio_queue
argument_list|)
decl_stmt|;
name|struct
name|bio
modifier|*
name|wbp
init|=
name|bioq_first
argument_list|(
operator|&
name|isc
operator|->
name|write_queue
argument_list|)
decl_stmt|;
name|int
name|can_write
init|=
name|wbp
operator|!=
name|NULL
operator|&&
name|cam_iosched_limiter_caniop
argument_list|(
operator|&
name|isc
operator|->
name|write_stats
argument_list|,
name|wbp
argument_list|)
operator|==
literal|0
decl_stmt|;
name|int
name|can_read
init|=
name|rbp
operator|!=
name|NULL
operator|&&
name|cam_iosched_limiter_caniop
argument_list|(
operator|&
name|isc
operator|->
name|read_stats
argument_list|,
name|rbp
argument_list|)
operator|==
literal|0
decl_stmt|;
if|if
condition|(
name|iosched_debug
operator|>
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"can write %d: pending_writes %d max_writes %d\n"
argument_list|,
name|can_write
argument_list|,
name|isc
operator|->
name|write_stats
operator|.
name|pending
argument_list|,
name|isc
operator|->
name|write_stats
operator|.
name|max
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"can read %d: read_stats.pending %d max_reads %d\n"
argument_list|,
name|can_read
argument_list|,
name|isc
operator|->
name|read_stats
operator|.
name|pending
argument_list|,
name|isc
operator|->
name|read_stats
operator|.
name|max
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Queued reads %d writes %d\n"
argument_list|,
name|isc
operator|->
name|read_stats
operator|.
name|queued
argument_list|,
name|isc
operator|->
name|write_stats
operator|.
name|queued
argument_list|)
expr_stmt|;
block|}
return|return
name|can_read
operator|||
name|can_write
return|;
block|}
endif|#
directive|endif
return|return
name|bioq_first
argument_list|(
operator|&
name|isc
operator|->
name|bio_queue
argument_list|)
operator|!=
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|cam_iosched_has_more_trim
parameter_list|(
name|struct
name|cam_iosched_softc
modifier|*
name|isc
parameter_list|)
block|{
return|return
operator|!
operator|(
name|isc
operator|->
name|flags
operator|&
name|CAM_IOSCHED_FLAG_TRIM_ACTIVE
operator|)
operator|&&
name|bioq_first
argument_list|(
operator|&
name|isc
operator|->
name|trim_queue
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|cam_iosched_sort_queue
parameter_list|(
name|isc
parameter_list|)
value|((isc)->sort_io_queue>= 0 ?	\     (isc)->sort_io_queue : cam_sort_io_queues)
end_define

begin_function
specifier|static
specifier|inline
name|int
name|cam_iosched_has_work
parameter_list|(
name|struct
name|cam_iosched_softc
modifier|*
name|isc
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|CAM_IOSCHED_DYNAMIC
if|if
condition|(
name|iosched_debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"has work: %d %d %d\n"
argument_list|,
name|cam_iosched_has_io
argument_list|(
name|isc
argument_list|)
argument_list|,
name|cam_iosched_has_more_trim
argument_list|(
name|isc
argument_list|)
argument_list|,
name|cam_iosched_has_flagged_work
argument_list|(
name|isc
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|cam_iosched_has_io
argument_list|(
name|isc
argument_list|)
operator|||
name|cam_iosched_has_more_trim
argument_list|(
name|isc
argument_list|)
operator|||
name|cam_iosched_has_flagged_work
argument_list|(
name|isc
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CAM_IOSCHED_DYNAMIC
end_ifdef

begin_function
specifier|static
name|void
name|cam_iosched_iop_stats_init
parameter_list|(
name|struct
name|cam_iosched_softc
modifier|*
name|isc
parameter_list|,
name|struct
name|iop_stats
modifier|*
name|ios
parameter_list|)
block|{
name|ios
operator|->
name|limiter
operator|=
name|none
expr_stmt|;
name|cam_iosched_limiter_init
argument_list|(
name|ios
argument_list|)
expr_stmt|;
name|ios
operator|->
name|in
operator|=
literal|0
expr_stmt|;
name|ios
operator|->
name|max
operator|=
literal|300000
expr_stmt|;
name|ios
operator|->
name|min
operator|=
literal|1
expr_stmt|;
name|ios
operator|->
name|out
operator|=
literal|0
expr_stmt|;
name|ios
operator|->
name|pending
operator|=
literal|0
expr_stmt|;
name|ios
operator|->
name|queued
operator|=
literal|0
expr_stmt|;
name|ios
operator|->
name|total
operator|=
literal|0
expr_stmt|;
name|ios
operator|->
name|ema
operator|=
literal|0
expr_stmt|;
name|ios
operator|->
name|emvar
operator|=
literal|0
expr_stmt|;
name|ios
operator|->
name|softc
operator|=
name|isc
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cam_iosched_limiter_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
name|struct
name|iop_stats
modifier|*
name|ios
decl_stmt|;
name|struct
name|cam_iosched_softc
modifier|*
name|isc
decl_stmt|;
name|int
name|value
decl_stmt|,
name|i
decl_stmt|,
name|error
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|ios
operator|=
name|arg1
expr_stmt|;
name|isc
operator|=
name|ios
operator|->
name|softc
expr_stmt|;
name|value
operator|=
name|ios
operator|->
name|limiter
expr_stmt|;
if|if
condition|(
name|value
operator|<
name|none
operator|||
name|value
operator|>=
name|limiter_max
condition|)
name|p
operator|=
literal|"UNKNOWN"
expr_stmt|;
else|else
name|p
operator|=
name|cam_iosched_limiter_names
index|[
name|value
index|]
expr_stmt|;
name|strlcpy
argument_list|(
name|buf
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
name|error
return|;
name|cam_periph_lock
argument_list|(
name|isc
operator|->
name|periph
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|none
init|;
name|i
operator|<
name|limiter_max
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|buf
argument_list|,
name|cam_iosched_limiter_names
index|[
name|i
index|]
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|ios
operator|->
name|limiter
operator|=
name|i
expr_stmt|;
name|error
operator|=
name|cam_iosched_limiter_init
argument_list|(
name|ios
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|ios
operator|->
name|limiter
operator|=
name|value
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|isc
operator|->
name|periph
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Note: disk load averate requires ticker to be always running */
name|callout_reset
argument_list|(
operator|&
name|isc
operator|->
name|ticker
argument_list|,
name|hz
operator|/
name|isc
operator|->
name|quanta
operator|-
literal|1
argument_list|,
name|cam_iosched_ticker
argument_list|,
name|isc
argument_list|)
expr_stmt|;
name|isc
operator|->
name|flags
operator||=
name|CAM_IOSCHED_FLAG_CALLOUT_ACTIVE
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|isc
operator|->
name|periph
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|cam_periph_unlock
argument_list|(
name|isc
operator|->
name|periph
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cam_iosched_control_type_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
name|struct
name|control_loop
modifier|*
name|clp
decl_stmt|;
name|struct
name|cam_iosched_softc
modifier|*
name|isc
decl_stmt|;
name|int
name|value
decl_stmt|,
name|i
decl_stmt|,
name|error
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|clp
operator|=
name|arg1
expr_stmt|;
name|isc
operator|=
name|clp
operator|->
name|softc
expr_stmt|;
name|value
operator|=
name|clp
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|value
operator|<
name|none
operator|||
name|value
operator|>=
name|cl_max
condition|)
name|p
operator|=
literal|"UNKNOWN"
expr_stmt|;
else|else
name|p
operator|=
name|cam_iosched_control_type_names
index|[
name|value
index|]
expr_stmt|;
name|strlcpy
argument_list|(
name|buf
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
name|error
return|;
for|for
control|(
name|i
operator|=
name|set_max
init|;
name|i
operator|<
name|cl_max
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|buf
argument_list|,
name|cam_iosched_control_type_names
index|[
name|i
index|]
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|cam_periph_lock
argument_list|(
name|isc
operator|->
name|periph
argument_list|)
expr_stmt|;
name|clp
operator|->
name|type
operator|=
name|i
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|isc
operator|->
name|periph
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|EINVAL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cam_iosched_sbintime_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
name|sbintime_t
name|value
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint64_t
name|us
decl_stmt|;
name|value
operator|=
operator|*
operator|(
name|sbintime_t
operator|*
operator|)
name|arg1
expr_stmt|;
name|us
operator|=
operator|(
name|uint64_t
operator|)
name|value
operator|/
name|SBT_1US
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%ju"
argument_list|,
operator|(
name|intmax_t
operator|)
name|us
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
name|error
return|;
name|us
operator|=
name|strtoul
argument_list|(
name|buf
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|us
operator|==
literal|0
condition|)
return|return
name|EINVAL
return|;
operator|*
operator|(
name|sbintime_t
operator|*
operator|)
name|arg1
operator|=
name|us
operator|*
name|SBT_1US
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cam_iosched_sysctl_latencies
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|sbuf
name|sb
decl_stmt|;
name|uint64_t
modifier|*
name|latencies
decl_stmt|;
name|latencies
operator|=
name|arg1
expr_stmt|;
name|sbuf_new_for_sysctl
argument_list|(
operator|&
name|sb
argument_list|,
name|NULL
argument_list|,
name|LAT_BUCKETS
operator|*
literal|16
argument_list|,
name|req
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LAT_BUCKETS
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"%jd,"
argument_list|,
operator|(
name|intmax_t
operator|)
name|latencies
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"%jd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|latencies
index|[
name|LAT_BUCKETS
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|error
operator|=
name|sbuf_finish
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cam_iosched_iop_stats_sysctl_init
parameter_list|(
name|struct
name|cam_iosched_softc
modifier|*
name|isc
parameter_list|,
name|struct
name|iop_stats
modifier|*
name|ios
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|sysctl_oid_list
modifier|*
name|n
decl_stmt|;
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|ios
operator|->
name|sysctl_tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
operator|&
name|isc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|isc
operator|->
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|name
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|n
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|ios
operator|->
name|sysctl_tree
argument_list|)
expr_stmt|;
name|ctx
operator|=
operator|&
name|ios
operator|->
name|sysctl_ctx
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|n
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ema"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ios
operator|->
name|ema
argument_list|,
literal|"Fast Exponentially Weighted Moving Average"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|n
argument_list|,
name|OID_AUTO
argument_list|,
literal|"emvar"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ios
operator|->
name|emvar
argument_list|,
literal|"Fast Exponentially Weighted Moving Variance"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|n
argument_list|,
name|OID_AUTO
argument_list|,
literal|"pending"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ios
operator|->
name|pending
argument_list|,
literal|0
argument_list|,
literal|"Instantaneous # of pending transactions"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|n
argument_list|,
name|OID_AUTO
argument_list|,
literal|"count"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ios
operator|->
name|total
argument_list|,
literal|0
argument_list|,
literal|"# of transactions submitted to hardware"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|n
argument_list|,
name|OID_AUTO
argument_list|,
literal|"queued"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ios
operator|->
name|queued
argument_list|,
literal|0
argument_list|,
literal|"# of transactions in the queue"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|n
argument_list|,
name|OID_AUTO
argument_list|,
literal|"in"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ios
operator|->
name|in
argument_list|,
literal|0
argument_list|,
literal|"# of transactions queued to driver"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|n
argument_list|,
name|OID_AUTO
argument_list|,
literal|"out"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ios
operator|->
name|out
argument_list|,
literal|0
argument_list|,
literal|"# of transactions completed"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|n
argument_list|,
name|OID_AUTO
argument_list|,
literal|"limiter"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
argument_list|,
name|ios
argument_list|,
literal|0
argument_list|,
name|cam_iosched_limiter_sysctl
argument_list|,
literal|"A"
argument_list|,
literal|"Current limiting type."
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|n
argument_list|,
name|OID_AUTO
argument_list|,
literal|"min"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ios
operator|->
name|min
argument_list|,
literal|0
argument_list|,
literal|"min resource"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|n
argument_list|,
name|OID_AUTO
argument_list|,
literal|"max"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ios
operator|->
name|max
argument_list|,
literal|0
argument_list|,
literal|"max resource"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|n
argument_list|,
name|OID_AUTO
argument_list|,
literal|"current"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ios
operator|->
name|current
argument_list|,
literal|0
argument_list|,
literal|"current resource"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|n
argument_list|,
name|OID_AUTO
argument_list|,
literal|"latencies"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|ios
operator|->
name|latencies
argument_list|,
literal|0
argument_list|,
name|cam_iosched_sysctl_latencies
argument_list|,
literal|"A"
argument_list|,
literal|"Array of power of 2 latency from 1ms to 1.024s"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cam_iosched_iop_stats_fini
parameter_list|(
name|struct
name|iop_stats
modifier|*
name|ios
parameter_list|)
block|{
if|if
condition|(
name|ios
operator|->
name|sysctl_tree
condition|)
if|if
condition|(
name|sysctl_ctx_free
argument_list|(
operator|&
name|ios
operator|->
name|sysctl_ctx
argument_list|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"can't remove iosched sysctl stats context\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cam_iosched_cl_sysctl_init
parameter_list|(
name|struct
name|cam_iosched_softc
modifier|*
name|isc
parameter_list|)
block|{
name|struct
name|sysctl_oid_list
modifier|*
name|n
decl_stmt|;
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|struct
name|control_loop
modifier|*
name|clp
decl_stmt|;
name|clp
operator|=
operator|&
name|isc
operator|->
name|cl
expr_stmt|;
name|clp
operator|->
name|sysctl_tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
operator|&
name|isc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|isc
operator|->
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"control"
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"Control loop info"
argument_list|)
expr_stmt|;
name|n
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|clp
operator|->
name|sysctl_tree
argument_list|)
expr_stmt|;
name|ctx
operator|=
operator|&
name|clp
operator|->
name|sysctl_ctx
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|n
argument_list|,
name|OID_AUTO
argument_list|,
literal|"type"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
argument_list|,
name|clp
argument_list|,
literal|0
argument_list|,
name|cam_iosched_control_type_sysctl
argument_list|,
literal|"A"
argument_list|,
literal|"Control loop algorithm"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|n
argument_list|,
name|OID_AUTO
argument_list|,
literal|"steer_interval"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|clp
operator|->
name|steer_interval
argument_list|,
literal|0
argument_list|,
name|cam_iosched_sbintime_sysctl
argument_list|,
literal|"A"
argument_list|,
literal|"How often to steer (in us)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|n
argument_list|,
name|OID_AUTO
argument_list|,
literal|"lolat"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|clp
operator|->
name|lolat
argument_list|,
literal|0
argument_list|,
name|cam_iosched_sbintime_sysctl
argument_list|,
literal|"A"
argument_list|,
literal|"Low water mark for Latency (in us)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|n
argument_list|,
name|OID_AUTO
argument_list|,
literal|"hilat"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|clp
operator|->
name|hilat
argument_list|,
literal|0
argument_list|,
name|cam_iosched_sbintime_sysctl
argument_list|,
literal|"A"
argument_list|,
literal|"Hi water mark for Latency (in us)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|n
argument_list|,
name|OID_AUTO
argument_list|,
literal|"alpha"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|clp
operator|->
name|alpha
argument_list|,
literal|0
argument_list|,
literal|"Alpha for PLL (x100) aka gain"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cam_iosched_cl_sysctl_fini
parameter_list|(
name|struct
name|control_loop
modifier|*
name|clp
parameter_list|)
block|{
if|if
condition|(
name|clp
operator|->
name|sysctl_tree
condition|)
if|if
condition|(
name|sysctl_ctx_free
argument_list|(
operator|&
name|clp
operator|->
name|sysctl_ctx
argument_list|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"can't remove iosched sysctl control loop context\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Allocate the iosched structure. This also insulates callers from knowing  * sizeof struct cam_iosched_softc.  */
end_comment

begin_function
name|int
name|cam_iosched_init
parameter_list|(
name|struct
name|cam_iosched_softc
modifier|*
modifier|*
name|iscp
parameter_list|,
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
operator|*
name|iscp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|iscp
argument_list|)
argument_list|,
name|M_CAMSCHED
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|iscp
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
ifdef|#
directive|ifdef
name|CAM_IOSCHED_DYNAMIC
if|if
condition|(
name|iosched_debug
condition|)
name|printf
argument_list|(
literal|"CAM IOSCHEDULER Allocating entry at %p\n"
argument_list|,
operator|*
name|iscp
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
operator|*
name|iscp
operator|)
operator|->
name|sort_io_queue
operator|=
operator|-
literal|1
expr_stmt|;
name|bioq_init
argument_list|(
operator|&
operator|(
operator|*
name|iscp
operator|)
operator|->
name|bio_queue
argument_list|)
expr_stmt|;
name|bioq_init
argument_list|(
operator|&
operator|(
operator|*
name|iscp
operator|)
operator|->
name|trim_queue
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CAM_IOSCHED_DYNAMIC
if|if
condition|(
name|do_dynamic_iosched
condition|)
block|{
name|bioq_init
argument_list|(
operator|&
operator|(
operator|*
name|iscp
operator|)
operator|->
name|write_queue
argument_list|)
expr_stmt|;
operator|(
operator|*
name|iscp
operator|)
operator|->
name|read_bias
operator|=
literal|100
expr_stmt|;
operator|(
operator|*
name|iscp
operator|)
operator|->
name|current_read_bias
operator|=
literal|100
expr_stmt|;
operator|(
operator|*
name|iscp
operator|)
operator|->
name|quanta
operator|=
literal|200
expr_stmt|;
name|cam_iosched_iop_stats_init
argument_list|(
operator|*
name|iscp
argument_list|,
operator|&
operator|(
operator|*
name|iscp
operator|)
operator|->
name|read_stats
argument_list|)
expr_stmt|;
name|cam_iosched_iop_stats_init
argument_list|(
operator|*
name|iscp
argument_list|,
operator|&
operator|(
operator|*
name|iscp
operator|)
operator|->
name|write_stats
argument_list|)
expr_stmt|;
name|cam_iosched_iop_stats_init
argument_list|(
operator|*
name|iscp
argument_list|,
operator|&
operator|(
operator|*
name|iscp
operator|)
operator|->
name|trim_stats
argument_list|)
expr_stmt|;
operator|(
operator|*
name|iscp
operator|)
operator|->
name|trim_stats
operator|.
name|max
operator|=
literal|1
expr_stmt|;
comment|/* Trims are special: one at a time for now */
operator|(
operator|*
name|iscp
operator|)
operator|->
name|last_time
operator|=
name|sbinuptime
argument_list|()
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
operator|(
operator|*
name|iscp
operator|)
operator|->
name|ticker
argument_list|,
name|cam_periph_mtx
argument_list|(
name|periph
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
operator|*
name|iscp
operator|)
operator|->
name|periph
operator|=
name|periph
expr_stmt|;
name|cam_iosched_cl_init
argument_list|(
operator|&
operator|(
operator|*
name|iscp
operator|)
operator|->
name|cl
argument_list|,
operator|*
name|iscp
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
operator|(
operator|*
name|iscp
operator|)
operator|->
name|ticker
argument_list|,
name|hz
operator|/
operator|(
operator|*
name|iscp
operator|)
operator|->
name|quanta
operator|-
literal|1
argument_list|,
name|cam_iosched_ticker
argument_list|,
operator|*
name|iscp
argument_list|)
expr_stmt|;
operator|(
operator|*
name|iscp
operator|)
operator|->
name|flags
operator||=
name|CAM_IOSCHED_FLAG_CALLOUT_ACTIVE
expr_stmt|;
block|}
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Reclaim all used resources. This assumes that other folks have  * drained the requests in the hardware. Maybe an unwise assumption.  */
end_comment

begin_function
name|void
name|cam_iosched_fini
parameter_list|(
name|struct
name|cam_iosched_softc
modifier|*
name|isc
parameter_list|)
block|{
if|if
condition|(
name|isc
condition|)
block|{
name|cam_iosched_flush
argument_list|(
name|isc
argument_list|,
name|NULL
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CAM_IOSCHED_DYNAMIC
name|cam_iosched_iop_stats_fini
argument_list|(
operator|&
name|isc
operator|->
name|read_stats
argument_list|)
expr_stmt|;
name|cam_iosched_iop_stats_fini
argument_list|(
operator|&
name|isc
operator|->
name|write_stats
argument_list|)
expr_stmt|;
name|cam_iosched_iop_stats_fini
argument_list|(
operator|&
name|isc
operator|->
name|trim_stats
argument_list|)
expr_stmt|;
name|cam_iosched_cl_sysctl_fini
argument_list|(
operator|&
name|isc
operator|->
name|cl
argument_list|)
expr_stmt|;
if|if
condition|(
name|isc
operator|->
name|sysctl_tree
condition|)
if|if
condition|(
name|sysctl_ctx_free
argument_list|(
operator|&
name|isc
operator|->
name|sysctl_ctx
argument_list|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"can't remove iosched sysctl stats context\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|isc
operator|->
name|flags
operator|&
name|CAM_IOSCHED_FLAG_CALLOUT_ACTIVE
condition|)
block|{
name|callout_drain
argument_list|(
operator|&
name|isc
operator|->
name|ticker
argument_list|)
expr_stmt|;
name|isc
operator|->
name|flags
operator|&=
operator|~
name|CAM_IOSCHED_FLAG_CALLOUT_ACTIVE
expr_stmt|;
block|}
endif|#
directive|endif
name|free
argument_list|(
name|isc
argument_list|,
name|M_CAMSCHED
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * After we're sure we're attaching a device, go ahead and add  * hooks for any sysctl we may wish to honor.  */
end_comment

begin_function
name|void
name|cam_iosched_sysctl_init
parameter_list|(
name|struct
name|cam_iosched_softc
modifier|*
name|isc
parameter_list|,
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
parameter_list|,
name|struct
name|sysctl_oid
modifier|*
name|node
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|CAM_IOSCHED_DYNAMIC
name|struct
name|sysctl_oid_list
modifier|*
name|n
decl_stmt|;
endif|#
directive|endif
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|node
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"sort_io_queue"
argument_list|,
name|CTLFLAG_RW
operator||
name|CTLFLAG_MPSAFE
argument_list|,
operator|&
name|isc
operator|->
name|sort_io_queue
argument_list|,
literal|0
argument_list|,
literal|"Sort IO queue to try and optimise disk access patterns"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CAM_IOSCHED_DYNAMIC
if|if
condition|(
operator|!
name|do_dynamic_iosched
condition|)
return|return;
name|isc
operator|->
name|sysctl_tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
operator|&
name|isc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|node
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"iosched"
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"I/O scheduler statistics"
argument_list|)
expr_stmt|;
name|n
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|isc
operator|->
name|sysctl_tree
argument_list|)
expr_stmt|;
name|ctx
operator|=
operator|&
name|isc
operator|->
name|sysctl_ctx
expr_stmt|;
name|cam_iosched_iop_stats_sysctl_init
argument_list|(
name|isc
argument_list|,
operator|&
name|isc
operator|->
name|read_stats
argument_list|,
literal|"read"
argument_list|)
expr_stmt|;
name|cam_iosched_iop_stats_sysctl_init
argument_list|(
name|isc
argument_list|,
operator|&
name|isc
operator|->
name|write_stats
argument_list|,
literal|"write"
argument_list|)
expr_stmt|;
name|cam_iosched_iop_stats_sysctl_init
argument_list|(
name|isc
argument_list|,
operator|&
name|isc
operator|->
name|trim_stats
argument_list|,
literal|"trim"
argument_list|)
expr_stmt|;
name|cam_iosched_cl_sysctl_init
argument_list|(
name|isc
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|n
argument_list|,
name|OID_AUTO
argument_list|,
literal|"read_bias"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|isc
operator|->
name|read_bias
argument_list|,
literal|100
argument_list|,
literal|"How biased towards read should we be independent of limits"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|n
argument_list|,
name|OID_AUTO
argument_list|,
literal|"quanta"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|isc
operator|->
name|quanta
argument_list|,
literal|200
argument_list|,
literal|"How many quanta per second do we slice the I/O up into"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|n
argument_list|,
name|OID_AUTO
argument_list|,
literal|"total_ticks"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|isc
operator|->
name|total_ticks
argument_list|,
literal|0
argument_list|,
literal|"Total number of ticks we've done"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|n
argument_list|,
name|OID_AUTO
argument_list|,
literal|"load"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|isc
operator|->
name|load
argument_list|,
literal|0
argument_list|,
literal|"scaled load average / 100"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Flush outstanding I/O. Consumers of this library don't know all the  * queues we may keep, so this allows all I/O to be flushed in one  * convenient call.  */
end_comment

begin_function
name|void
name|cam_iosched_flush
parameter_list|(
name|struct
name|cam_iosched_softc
modifier|*
name|isc
parameter_list|,
name|struct
name|devstat
modifier|*
name|stp
parameter_list|,
name|int
name|err
parameter_list|)
block|{
name|bioq_flush
argument_list|(
operator|&
name|isc
operator|->
name|bio_queue
argument_list|,
name|stp
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|bioq_flush
argument_list|(
operator|&
name|isc
operator|->
name|trim_queue
argument_list|,
name|stp
argument_list|,
name|err
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CAM_IOSCHED_DYNAMIC
if|if
condition|(
name|do_dynamic_iosched
condition|)
name|bioq_flush
argument_list|(
operator|&
name|isc
operator|->
name|write_queue
argument_list|,
name|stp
argument_list|,
name|err
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CAM_IOSCHED_DYNAMIC
end_ifdef

begin_function
specifier|static
name|struct
name|bio
modifier|*
name|cam_iosched_get_write
parameter_list|(
name|struct
name|cam_iosched_softc
modifier|*
name|isc
parameter_list|)
block|{
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
comment|/* 	 * We control the write rate by controlling how many requests we send 	 * down to the drive at any one time. Fewer requests limits the 	 * effects of both starvation when the requests take a while and write 	 * amplification when each request is causing more than one write to 	 * the NAND media. Limiting the queue depth like this will also limit 	 * the write throughput and give and reads that want to compete to 	 * compete unfairly. 	 */
name|bp
operator|=
name|bioq_first
argument_list|(
operator|&
name|isc
operator|->
name|write_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|iosched_debug
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"No writes present in write_queue\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* 	 * If pending read, prefer that based on current read bias 	 * setting. 	 */
if|if
condition|(
name|bioq_first
argument_list|(
operator|&
name|isc
operator|->
name|bio_queue
argument_list|)
operator|&&
name|isc
operator|->
name|current_read_bias
condition|)
block|{
if|if
condition|(
name|iosched_debug
condition|)
name|printf
argument_list|(
literal|"Reads present and current_read_bias is %d queued writes %d queued reads %d\n"
argument_list|,
name|isc
operator|->
name|current_read_bias
argument_list|,
name|isc
operator|->
name|write_stats
operator|.
name|queued
argument_list|,
name|isc
operator|->
name|read_stats
operator|.
name|queued
argument_list|)
expr_stmt|;
name|isc
operator|->
name|current_read_bias
operator|--
expr_stmt|;
comment|/* We're not limiting writes, per se, just doing reads first */
return|return
name|NULL
return|;
block|}
comment|/* 	 * See if our current limiter allows this I/O. 	 */
if|if
condition|(
name|cam_iosched_limiter_iop
argument_list|(
operator|&
name|isc
operator|->
name|write_stats
argument_list|,
name|bp
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|iosched_debug
condition|)
name|printf
argument_list|(
literal|"Can't write because limiter says no.\n"
argument_list|)
expr_stmt|;
name|isc
operator|->
name|write_stats
operator|.
name|state_flags
operator||=
name|IOP_RATE_LIMITED
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* 	 * Let's do this: We've passed all the gates and we're a go 	 * to schedule the I/O in the SIM. 	 */
name|isc
operator|->
name|current_read_bias
operator|=
name|isc
operator|->
name|read_bias
expr_stmt|;
name|bioq_remove
argument_list|(
operator|&
name|isc
operator|->
name|write_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_WRITE
condition|)
block|{
name|isc
operator|->
name|write_stats
operator|.
name|queued
operator|--
expr_stmt|;
name|isc
operator|->
name|write_stats
operator|.
name|total
operator|++
expr_stmt|;
name|isc
operator|->
name|write_stats
operator|.
name|pending
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|iosched_debug
operator|>
literal|9
condition|)
name|printf
argument_list|(
literal|"HWQ : %p %#x\n"
argument_list|,
name|bp
argument_list|,
name|bp
operator|->
name|bio_cmd
argument_list|)
expr_stmt|;
name|isc
operator|->
name|write_stats
operator|.
name|state_flags
operator|&=
operator|~
name|IOP_RATE_LIMITED
expr_stmt|;
return|return
name|bp
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Put back a trim that you weren't able to actually schedule this time.  */
end_comment

begin_function
name|void
name|cam_iosched_put_back_trim
parameter_list|(
name|struct
name|cam_iosched_softc
modifier|*
name|isc
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|bioq_insert_head
argument_list|(
operator|&
name|isc
operator|->
name|trim_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CAM_IOSCHED_DYNAMIC
name|isc
operator|->
name|trim_stats
operator|.
name|queued
operator|++
expr_stmt|;
name|isc
operator|->
name|trim_stats
operator|.
name|total
operator|--
expr_stmt|;
comment|/* since we put it back, don't double count */
name|isc
operator|->
name|trim_stats
operator|.
name|pending
operator|--
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * gets the next trim from the trim queue.  *  * Assumes we're called with the periph lock held.  It removes this  * trim from the queue and the device must explicitly reinsert it  * should the need arise.  */
end_comment

begin_function
name|struct
name|bio
modifier|*
name|cam_iosched_next_trim
parameter_list|(
name|struct
name|cam_iosched_softc
modifier|*
name|isc
parameter_list|)
block|{
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|bp
operator|=
name|bioq_first
argument_list|(
operator|&
name|isc
operator|->
name|trim_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|bioq_remove
argument_list|(
operator|&
name|isc
operator|->
name|trim_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CAM_IOSCHED_DYNAMIC
name|isc
operator|->
name|trim_stats
operator|.
name|queued
operator|--
expr_stmt|;
name|isc
operator|->
name|trim_stats
operator|.
name|total
operator|++
expr_stmt|;
name|isc
operator|->
name|trim_stats
operator|.
name|pending
operator|++
expr_stmt|;
endif|#
directive|endif
return|return
name|bp
return|;
block|}
end_function

begin_comment
comment|/*  * gets an available trim from the trim queue, if there's no trim  * already pending. It removes this trim from the queue and the device  * must explicitly reinsert it should the need arise.  *  * Assumes we're called with the periph lock held.  */
end_comment

begin_function
name|struct
name|bio
modifier|*
name|cam_iosched_get_trim
parameter_list|(
name|struct
name|cam_iosched_softc
modifier|*
name|isc
parameter_list|)
block|{
if|if
condition|(
operator|!
name|cam_iosched_has_more_trim
argument_list|(
name|isc
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|cam_iosched_next_trim
argument_list|(
name|isc
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine what the next bit of work to do is for the periph. The  * default implementation looks to see if we have trims to do, but no  * trims outstanding. If so, we do that. Otherwise we see if we have  * other work. If we do, then we do that. Otherwise why were we called?  */
end_comment

begin_function
name|struct
name|bio
modifier|*
name|cam_iosched_next_bio
parameter_list|(
name|struct
name|cam_iosched_softc
modifier|*
name|isc
parameter_list|)
block|{
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
comment|/* 	 * See if we have a trim that can be scheduled. We can only send one 	 * at a time down, so this takes that into account. 	 * 	 * XXX newer TRIM commands are queueable. Revisit this when we 	 * implement them. 	 */
if|if
condition|(
operator|(
name|bp
operator|=
name|cam_iosched_get_trim
argument_list|(
name|isc
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|bp
return|;
ifdef|#
directive|ifdef
name|CAM_IOSCHED_DYNAMIC
comment|/* 	 * See if we have any pending writes, and room in the queue for them, 	 * and if so, those are next. 	 */
if|if
condition|(
name|do_dynamic_iosched
condition|)
block|{
if|if
condition|(
operator|(
name|bp
operator|=
name|cam_iosched_get_write
argument_list|(
name|isc
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|bp
return|;
block|}
endif|#
directive|endif
comment|/* 	 * next, see if there's other, normal I/O waiting. If so return that. 	 */
if|if
condition|(
operator|(
name|bp
operator|=
name|bioq_first
argument_list|(
operator|&
name|isc
operator|->
name|bio_queue
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
ifdef|#
directive|ifdef
name|CAM_IOSCHED_DYNAMIC
comment|/* 	 * For the dynamic scheduler, bio_queue is only for reads, so enforce 	 * the limits here. Enforce only for reads. 	 */
if|if
condition|(
name|do_dynamic_iosched
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_READ
operator|&&
name|cam_iosched_limiter_iop
argument_list|(
operator|&
name|isc
operator|->
name|read_stats
argument_list|,
name|bp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|isc
operator|->
name|read_stats
operator|.
name|state_flags
operator||=
name|IOP_RATE_LIMITED
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|isc
operator|->
name|read_stats
operator|.
name|state_flags
operator|&=
operator|~
name|IOP_RATE_LIMITED
expr_stmt|;
endif|#
directive|endif
name|bioq_remove
argument_list|(
operator|&
name|isc
operator|->
name|bio_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CAM_IOSCHED_DYNAMIC
if|if
condition|(
name|do_dynamic_iosched
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_READ
condition|)
block|{
name|isc
operator|->
name|read_stats
operator|.
name|queued
operator|--
expr_stmt|;
name|isc
operator|->
name|read_stats
operator|.
name|total
operator|++
expr_stmt|;
name|isc
operator|->
name|read_stats
operator|.
name|pending
operator|++
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"Found bio_cmd = %#x\n"
argument_list|,
name|bp
operator|->
name|bio_cmd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|iosched_debug
operator|>
literal|9
condition|)
name|printf
argument_list|(
literal|"HWQ : %p %#x\n"
argument_list|,
name|bp
argument_list|,
name|bp
operator|->
name|bio_cmd
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|bp
return|;
block|}
end_function

begin_comment
comment|/*  * Driver has been given some work to do by the block layer. Tell the  * scheduler about it and have it queue the work up. The scheduler module  * will then return the currently most useful bit of work later, possibly  * deferring work for various reasons.  */
end_comment

begin_function
name|void
name|cam_iosched_queue_work
parameter_list|(
name|struct
name|cam_iosched_softc
modifier|*
name|isc
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
comment|/* 	 * Put all trims on the trim queue sorted, since we know 	 * that the collapsing code requires this. Otherwise put 	 * the work on the bio queue. 	 */
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_DELETE
condition|)
block|{
name|bioq_disksort
argument_list|(
operator|&
name|isc
operator|->
name|trim_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CAM_IOSCHED_DYNAMIC
name|isc
operator|->
name|trim_stats
operator|.
name|in
operator|++
expr_stmt|;
name|isc
operator|->
name|trim_stats
operator|.
name|queued
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|CAM_IOSCHED_DYNAMIC
elseif|else
if|if
condition|(
name|do_dynamic_iosched
operator|&&
operator|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_WRITE
operator|||
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_FLUSH
operator|)
condition|)
block|{
if|if
condition|(
name|cam_iosched_sort_queue
argument_list|(
name|isc
argument_list|)
condition|)
name|bioq_disksort
argument_list|(
operator|&
name|isc
operator|->
name|write_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
else|else
name|bioq_insert_tail
argument_list|(
operator|&
name|isc
operator|->
name|write_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|iosched_debug
operator|>
literal|9
condition|)
name|printf
argument_list|(
literal|"Qw  : %p %#x\n"
argument_list|,
name|bp
argument_list|,
name|bp
operator|->
name|bio_cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_WRITE
condition|)
block|{
name|isc
operator|->
name|write_stats
operator|.
name|in
operator|++
expr_stmt|;
name|isc
operator|->
name|write_stats
operator|.
name|queued
operator|++
expr_stmt|;
block|}
block|}
endif|#
directive|endif
else|else
block|{
if|if
condition|(
name|cam_iosched_sort_queue
argument_list|(
name|isc
argument_list|)
condition|)
name|bioq_disksort
argument_list|(
operator|&
name|isc
operator|->
name|bio_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
else|else
name|bioq_insert_tail
argument_list|(
operator|&
name|isc
operator|->
name|bio_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CAM_IOSCHED_DYNAMIC
if|if
condition|(
name|iosched_debug
operator|>
literal|9
condition|)
name|printf
argument_list|(
literal|"Qr  : %p %#x\n"
argument_list|,
name|bp
argument_list|,
name|bp
operator|->
name|bio_cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_READ
condition|)
block|{
name|isc
operator|->
name|read_stats
operator|.
name|in
operator|++
expr_stmt|;
name|isc
operator|->
name|read_stats
operator|.
name|queued
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_WRITE
condition|)
block|{
name|isc
operator|->
name|write_stats
operator|.
name|in
operator|++
expr_stmt|;
name|isc
operator|->
name|write_stats
operator|.
name|queued
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/*  * If we have work, get it scheduled. Called with the periph lock held.  */
end_comment

begin_function
name|void
name|cam_iosched_schedule
parameter_list|(
name|struct
name|cam_iosched_softc
modifier|*
name|isc
parameter_list|,
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
if|if
condition|(
name|cam_iosched_has_work
argument_list|(
name|isc
argument_list|)
condition|)
name|xpt_schedule
argument_list|(
name|periph
argument_list|,
name|CAM_PRIORITY_NORMAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Complete a trim request  */
end_comment

begin_function
name|void
name|cam_iosched_trim_done
parameter_list|(
name|struct
name|cam_iosched_softc
modifier|*
name|isc
parameter_list|)
block|{
name|isc
operator|->
name|flags
operator|&=
operator|~
name|CAM_IOSCHED_FLAG_TRIM_ACTIVE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Complete a bio. Called before we release the ccb with xpt_release_ccb so we  * might use notes in the ccb for statistics.  */
end_comment

begin_function
name|int
name|cam_iosched_bio_complete
parameter_list|(
name|struct
name|cam_iosched_softc
modifier|*
name|isc
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|,
name|union
name|ccb
modifier|*
name|done_ccb
parameter_list|)
block|{
name|int
name|retval
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|CAM_IOSCHED_DYNAMIC
if|if
condition|(
operator|!
name|do_dynamic_iosched
condition|)
return|return
name|retval
return|;
if|if
condition|(
name|iosched_debug
operator|>
literal|10
condition|)
name|printf
argument_list|(
literal|"done: %p %#x\n"
argument_list|,
name|bp
argument_list|,
name|bp
operator|->
name|bio_cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_WRITE
condition|)
block|{
name|retval
operator|=
name|cam_iosched_limiter_iodone
argument_list|(
operator|&
name|isc
operator|->
name|write_stats
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|isc
operator|->
name|write_stats
operator|.
name|out
operator|++
expr_stmt|;
name|isc
operator|->
name|write_stats
operator|.
name|pending
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_READ
condition|)
block|{
name|retval
operator|=
name|cam_iosched_limiter_iodone
argument_list|(
operator|&
name|isc
operator|->
name|read_stats
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|isc
operator|->
name|read_stats
operator|.
name|out
operator|++
expr_stmt|;
name|isc
operator|->
name|read_stats
operator|.
name|pending
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_DELETE
condition|)
block|{
name|isc
operator|->
name|trim_stats
operator|.
name|out
operator|++
expr_stmt|;
name|isc
operator|->
name|trim_stats
operator|.
name|pending
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|!=
name|BIO_FLUSH
condition|)
block|{
if|if
condition|(
name|iosched_debug
condition|)
name|printf
argument_list|(
literal|"Completing command with bio_cmd == %#x\n"
argument_list|,
name|bp
operator|->
name|bio_cmd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|bp
operator|->
name|bio_flags
operator|&
name|BIO_ERROR
operator|)
condition|)
name|cam_iosched_io_metric_update
argument_list|(
name|isc
argument_list|,
name|cam_iosched_sbintime_t
argument_list|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|qos
operator|.
name|periph_data
argument_list|)
argument_list|,
name|bp
operator|->
name|bio_cmd
argument_list|,
name|bp
operator|->
name|bio_bcount
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * Tell the io scheduler that you've pushed a trim down into the sim.  * xxx better place for this?  */
end_comment

begin_function
name|void
name|cam_iosched_submit_trim
parameter_list|(
name|struct
name|cam_iosched_softc
modifier|*
name|isc
parameter_list|)
block|{
name|isc
operator|->
name|flags
operator||=
name|CAM_IOSCHED_FLAG_TRIM_ACTIVE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Change the sorting policy hint for I/O transactions for this device.  */
end_comment

begin_function
name|void
name|cam_iosched_set_sort_queue
parameter_list|(
name|struct
name|cam_iosched_softc
modifier|*
name|isc
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|isc
operator|->
name|sort_io_queue
operator|=
name|val
expr_stmt|;
block|}
end_function

begin_function
name|int
name|cam_iosched_has_work_flags
parameter_list|(
name|struct
name|cam_iosched_softc
modifier|*
name|isc
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
return|return
name|isc
operator|->
name|flags
operator|&
name|flags
return|;
block|}
end_function

begin_function
name|void
name|cam_iosched_set_work_flags
parameter_list|(
name|struct
name|cam_iosched_softc
modifier|*
name|isc
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|isc
operator|->
name|flags
operator||=
name|flags
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cam_iosched_clr_work_flags
parameter_list|(
name|struct
name|cam_iosched_softc
modifier|*
name|isc
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|isc
operator|->
name|flags
operator|&=
operator|~
name|flags
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CAM_IOSCHED_DYNAMIC
end_ifdef

begin_comment
comment|/*  * After the method presented in Jack Crenshaw's 1998 article "Integer  * Square Roots," reprinted at  * http://www.embedded.com/electronics-blogs/programmer-s-toolbox/4219659/Integer-Square-Roots  * and well worth the read. Briefly, we find the power of 4 that's the  * largest smaller than val. We then check each smaller power of 4 to  * see if val is still bigger. The right shifts at each step divide  * the result by 2 which after successive application winds up  * accumulating the right answer. It could also have been accumulated  * using a separate root counter, but this code is smaller and faster  * than that method. This method is also integer size invariant.  * It returns floor(sqrt((float)val)), or the largest integer less than  * or equal to the square root.  */
end_comment

begin_function
specifier|static
name|uint64_t
name|isqrt64
parameter_list|(
name|uint64_t
name|val
parameter_list|)
block|{
name|uint64_t
name|res
init|=
literal|0
decl_stmt|;
name|uint64_t
name|bit
init|=
literal|1ULL
operator|<<
operator|(
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|*
name|NBBY
operator|-
literal|2
operator|)
decl_stmt|;
comment|/* 	 * Find the largest power of 4 smaller than val. 	 */
while|while
condition|(
name|bit
operator|>
name|val
condition|)
name|bit
operator|>>=
literal|2
expr_stmt|;
comment|/* 	 * Accumulate the answer, one bit at a time (we keep moving 	 * them over since 2 is the square root of 4 and we test 	 * powers of 4). We accumulate where we find the bit, but 	 * the successive shifts land the bit in the right place 	 * by the end. 	 */
while|while
condition|(
name|bit
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|val
operator|>=
name|res
operator|+
name|bit
condition|)
block|{
name|val
operator|-=
name|res
operator|+
name|bit
expr_stmt|;
name|res
operator|=
operator|(
name|res
operator|>>
literal|1
operator|)
operator|+
name|bit
expr_stmt|;
block|}
else|else
name|res
operator|>>=
literal|1
expr_stmt|;
name|bit
operator|>>=
literal|2
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|sbintime_t
name|latencies
index|[]
init|=
block|{
name|SBT_1MS
operator|<<
literal|0
block|,
name|SBT_1MS
operator|<<
literal|1
block|,
name|SBT_1MS
operator|<<
literal|2
block|,
name|SBT_1MS
operator|<<
literal|3
block|,
name|SBT_1MS
operator|<<
literal|4
block|,
name|SBT_1MS
operator|<<
literal|5
block|,
name|SBT_1MS
operator|<<
literal|6
block|,
name|SBT_1MS
operator|<<
literal|7
block|,
name|SBT_1MS
operator|<<
literal|8
block|,
name|SBT_1MS
operator|<<
literal|9
block|,
name|SBT_1MS
operator|<<
literal|10
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|cam_iosched_update
parameter_list|(
name|struct
name|iop_stats
modifier|*
name|iop
parameter_list|,
name|sbintime_t
name|sim_latency
parameter_list|)
block|{
name|sbintime_t
name|y
decl_stmt|,
name|deltasq
decl_stmt|,
name|delta
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Keep counts for latency. We do it by power of two buckets. 	 * This helps us spot outlier behavior obscured by averages. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LAT_BUCKETS
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sim_latency
operator|<
name|latencies
index|[
name|i
index|]
condition|)
block|{
name|iop
operator|->
name|latencies
index|[
name|i
index|]
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|LAT_BUCKETS
operator|-
literal|1
condition|)
name|iop
operator|->
name|latencies
index|[
name|i
index|]
operator|++
expr_stmt|;
comment|/* Put all> 1024ms values into the last bucket. */
comment|/* 	 * Classic exponentially decaying average with a tiny alpha 	 * (2 ^ -alpha_bits). For more info see the NIST statistical 	 * handbook. 	 * 	 * ema_t = y_t * alpha + ema_t-1 * (1 - alpha)		[nist] 	 * ema_t = y_t * alpha + ema_t-1 - alpha * ema_t-1 	 * ema_t = alpha * y_t - alpha * ema_t-1 + ema_t-1 	 * alpha = 1 / (1<< alpha_bits) 	 * sub e == ema_t-1, b == 1/alpha (== 1<< alpha_bits), d == y_t - ema_t-1 	 *	= y_t/b - e/b + be/b 	 *      = (y_t - e + be) / b 	 *	= (e + d) / b 	 * 	 * Since alpha is a power of two, we can compute this w/o any mult or 	 * division. 	 * 	 * Variance can also be computed. Usually, it would be expressed as follows: 	 *	diff_t = y_t - ema_t-1 	 *	emvar_t = (1 - alpha) * (emavar_t-1 + diff_t^2 * alpha) 	 *	  = emavar_t-1 - alpha * emavar_t-1 + delta_t^2 * alpha - (delta_t * alpha)^2 	 * sub b == 1/alpha (== 1<< alpha_bits), e == emavar_t-1, d = delta_t^2 	 *	  = e - e/b + dd/b + dd/bb 	 *	  = (bbe - be + bdd + dd) / bb 	 *	  = (bbe + b(dd-e) + dd) / bb (which is expanded below bb = 1<<(2*alpha_bits)) 	 */
comment|/* 	 * XXX possible numeric issues 	 *	o We assume right shifted integers do the right thing, since that's 	 *	  implementation defined. You can change the right shifts to / (1LL<< alpha). 	 *	o alpha_bits = 9 gives ema ceiling of 23 bits of seconds for ema and 14 bits 	 *	  for emvar. This puts a ceiling of 13 bits on alpha since we need a 	 *	  few tens of seconds of representation. 	 *	o We mitigate alpha issues by never setting it too high. 	 */
name|y
operator|=
name|sim_latency
expr_stmt|;
name|delta
operator|=
operator|(
name|y
operator|-
name|iop
operator|->
name|ema
operator|)
expr_stmt|;
comment|/* d */
name|iop
operator|->
name|ema
operator|=
operator|(
operator|(
name|iop
operator|->
name|ema
operator|<<
name|alpha_bits
operator|)
operator|+
name|delta
operator|)
operator|>>
name|alpha_bits
expr_stmt|;
comment|/* 	 * Were we to naively plow ahead at this point, we wind up with many numerical 	 * issues making any SD> ~3ms unreliable. So, we shift right by 12. This leaves 	 * us with microsecond level precision in the input, so the same in the 	 * output. It means we can't overflow deltasq unless delta> 4k seconds. It 	 * also means that emvar can be up 46 bits 40 of which are fraction, which 	 * gives us a way to measure up to ~8s in the SD before the computation goes 	 * unstable. Even the worst hard disk rarely has> 1s service time in the 	 * drive. It does mean we have to shift left 12 bits after taking the 	 * square root to compute the actual standard deviation estimate. This loss of 	 * precision is preferable to needing int128 types to work. The above numbers 	 * assume alpha=9. 10 or 11 are ok, but we start to run into issues at 12, 	 * so 12 or 13 is OK for EMA, EMVAR and SD will be wrong in those cases. 	 */
name|delta
operator|>>=
literal|12
expr_stmt|;
name|deltasq
operator|=
name|delta
operator|*
name|delta
expr_stmt|;
comment|/* dd */
name|iop
operator|->
name|emvar
operator|=
operator|(
operator|(
name|iop
operator|->
name|emvar
operator|<<
operator|(
literal|2
operator|*
name|alpha_bits
operator|)
operator|)
operator|+
comment|/* bbe */
operator|(
operator|(
name|deltasq
operator|-
name|iop
operator|->
name|emvar
operator|)
operator|<<
name|alpha_bits
operator|)
operator|+
comment|/* b(dd-e) */
name|deltasq
operator|)
comment|/* dd */
operator|>>
operator|(
literal|2
operator|*
name|alpha_bits
operator|)
expr_stmt|;
comment|/* div bb */
name|iop
operator|->
name|sd
operator|=
operator|(
name|sbintime_t
operator|)
name|isqrt64
argument_list|(
operator|(
name|uint64_t
operator|)
name|iop
operator|->
name|emvar
argument_list|)
operator|<<
literal|12
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cam_iosched_io_metric_update
parameter_list|(
name|struct
name|cam_iosched_softc
modifier|*
name|isc
parameter_list|,
name|sbintime_t
name|sim_latency
parameter_list|,
name|int
name|cmd
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
comment|/* xxx Do we need to scale based on the size of the I/O ? */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|BIO_READ
case|:
name|cam_iosched_update
argument_list|(
operator|&
name|isc
operator|->
name|read_stats
argument_list|,
name|sim_latency
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIO_WRITE
case|:
name|cam_iosched_update
argument_list|(
operator|&
name|isc
operator|->
name|write_stats
argument_list|,
name|sim_latency
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIO_DELETE
case|:
name|cam_iosched_update
argument_list|(
operator|&
name|isc
operator|->
name|trim_stats
argument_list|,
name|sim_latency
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_function
specifier|static
name|int
name|biolen
parameter_list|(
name|struct
name|bio_queue_head
modifier|*
name|bq
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|bp
argument_list|,
argument|&bq->queue
argument_list|,
argument|bio_queue
argument_list|)
block|{
name|i
operator|++
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/*  * Show the internal state of the I/O scheduler.  */
end_comment

begin_macro
name|DB_SHOW_COMMAND
argument_list|(
argument|iosched
argument_list|,
argument|cam_iosched_db_show
argument_list|)
end_macro

begin_block
block|{
name|struct
name|cam_iosched_softc
modifier|*
name|isc
decl_stmt|;
if|if
condition|(
operator|!
name|have_addr
condition|)
block|{
name|db_printf
argument_list|(
literal|"Need addr\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|isc
operator|=
operator|(
expr|struct
name|cam_iosched_softc
operator|*
operator|)
name|addr
expr_stmt|;
name|db_printf
argument_list|(
literal|"pending_reads:     %d\n"
argument_list|,
name|isc
operator|->
name|read_stats
operator|.
name|pending
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"min_reads:         %d\n"
argument_list|,
name|isc
operator|->
name|read_stats
operator|.
name|min
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"max_reads:         %d\n"
argument_list|,
name|isc
operator|->
name|read_stats
operator|.
name|max
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"reads:             %d\n"
argument_list|,
name|isc
operator|->
name|read_stats
operator|.
name|total
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"in_reads:          %d\n"
argument_list|,
name|isc
operator|->
name|read_stats
operator|.
name|in
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"out_reads:         %d\n"
argument_list|,
name|isc
operator|->
name|read_stats
operator|.
name|out
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"queued_reads:      %d\n"
argument_list|,
name|isc
operator|->
name|read_stats
operator|.
name|queued
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"Current Q len      %d\n"
argument_list|,
name|biolen
argument_list|(
operator|&
name|isc
operator|->
name|bio_queue
argument_list|)
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"pending_writes:    %d\n"
argument_list|,
name|isc
operator|->
name|write_stats
operator|.
name|pending
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"min_writes:        %d\n"
argument_list|,
name|isc
operator|->
name|write_stats
operator|.
name|min
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"max_writes:        %d\n"
argument_list|,
name|isc
operator|->
name|write_stats
operator|.
name|max
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"writes:            %d\n"
argument_list|,
name|isc
operator|->
name|write_stats
operator|.
name|total
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"in_writes:         %d\n"
argument_list|,
name|isc
operator|->
name|write_stats
operator|.
name|in
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"out_writes:        %d\n"
argument_list|,
name|isc
operator|->
name|write_stats
operator|.
name|out
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"queued_writes:     %d\n"
argument_list|,
name|isc
operator|->
name|write_stats
operator|.
name|queued
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"Current Q len      %d\n"
argument_list|,
name|biolen
argument_list|(
operator|&
name|isc
operator|->
name|write_queue
argument_list|)
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"pending_trims:     %d\n"
argument_list|,
name|isc
operator|->
name|trim_stats
operator|.
name|pending
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"min_trims:         %d\n"
argument_list|,
name|isc
operator|->
name|trim_stats
operator|.
name|min
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"max_trims:         %d\n"
argument_list|,
name|isc
operator|->
name|trim_stats
operator|.
name|max
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"trims:             %d\n"
argument_list|,
name|isc
operator|->
name|trim_stats
operator|.
name|total
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"in_trims:          %d\n"
argument_list|,
name|isc
operator|->
name|trim_stats
operator|.
name|in
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"out_trims:         %d\n"
argument_list|,
name|isc
operator|->
name|trim_stats
operator|.
name|out
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"queued_trims:      %d\n"
argument_list|,
name|isc
operator|->
name|trim_stats
operator|.
name|queued
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"Current Q len      %d\n"
argument_list|,
name|biolen
argument_list|(
operator|&
name|isc
operator|->
name|trim_queue
argument_list|)
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"read_bias:         %d\n"
argument_list|,
name|isc
operator|->
name|read_bias
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"current_read_bias: %d\n"
argument_list|,
name|isc
operator|->
name|current_read_bias
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"Trim active?       %s\n"
argument_list|,
operator|(
name|isc
operator|->
name|flags
operator|&
name|CAM_IOSCHED_FLAG_TRIM_ACTIVE
operator|)
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

