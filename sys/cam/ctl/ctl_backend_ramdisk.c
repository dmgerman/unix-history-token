begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003, 2008 Silicon Graphics International Corp.  * Copyright (c) 2012 The FreeBSD Foundation  * All rights reserved.  *  * Portions of this software were developed by Edward Tomasz Napierala  * under sponsorship from the FreeBSD Foundation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    substantially similar to the "NO WARRANTY" disclaimer below  *    ("Disclaimer") and any redistribution must be conditioned upon  *    including a substantially similar Disclaimer requirement for further  *    binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGES.  *  * $Id: //depot/users/kenm/FreeBSD-test2/sys/cam/ctl/ctl_backend_ramdisk.c#3 $  */
end_comment

begin_comment
comment|/*  * CAM Target Layer backend for a "fake" ramdisk.  *  * Author: Ken Merry<ken@FreeBSD.org>  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_io.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_util.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_backend.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_frontend_internal.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_error.h>
end_include

begin_typedef
typedef|typedef
enum|enum
block|{
name|CTL_BE_RAMDISK_LUN_UNCONFIGURED
init|=
literal|0x01
block|,
name|CTL_BE_RAMDISK_LUN_CONFIG_ERR
init|=
literal|0x02
block|,
name|CTL_BE_RAMDISK_LUN_WAITING
init|=
literal|0x04
block|}
name|ctl_be_ramdisk_lun_flags
typedef|;
end_typedef

begin_struct
struct|struct
name|ctl_be_ramdisk_lun
block|{
name|char
name|lunname
index|[
literal|32
index|]
decl_stmt|;
name|uint64_t
name|size_bytes
decl_stmt|;
name|uint64_t
name|size_blocks
decl_stmt|;
name|struct
name|ctl_be_ramdisk_softc
modifier|*
name|softc
decl_stmt|;
name|ctl_be_ramdisk_lun_flags
name|flags
decl_stmt|;
name|STAILQ_ENTRY
argument_list|(
argument|ctl_be_ramdisk_lun
argument_list|)
name|links
expr_stmt|;
name|struct
name|ctl_be_lun
name|ctl_be_lun
decl_stmt|;
name|struct
name|taskqueue
modifier|*
name|io_taskqueue
decl_stmt|;
name|struct
name|task
name|io_task
decl_stmt|;
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|ctl_io_hdr
argument_list|)
name|cont_queue
expr_stmt|;
name|struct
name|mtx_padalign
name|queue_lock
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ctl_be_ramdisk_softc
block|{
name|struct
name|mtx
name|lock
decl_stmt|;
name|int
name|rd_size
decl_stmt|;
ifdef|#
directive|ifdef
name|CTL_RAMDISK_PAGES
name|uint8_t
modifier|*
modifier|*
name|ramdisk_pages
decl_stmt|;
name|int
name|num_pages
decl_stmt|;
else|#
directive|else
name|uint8_t
modifier|*
name|ramdisk_buffer
decl_stmt|;
endif|#
directive|endif
name|int
name|num_luns
decl_stmt|;
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|ctl_be_ramdisk_lun
argument_list|)
name|lun_list
expr_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|ctl_be_ramdisk_softc
name|rd_softc
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|ctl_backend_ramdisk_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ctl_backend_ramdisk_shutdown
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_backend_ramdisk_move_done
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_backend_ramdisk_submit
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_backend_ramdisk_continue
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_backend_ramdisk_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_backend_ramdisk_rm
parameter_list|(
name|struct
name|ctl_be_ramdisk_softc
modifier|*
name|softc
parameter_list|,
name|struct
name|ctl_lun_req
modifier|*
name|req
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_backend_ramdisk_create
parameter_list|(
name|struct
name|ctl_be_ramdisk_softc
modifier|*
name|softc
parameter_list|,
name|struct
name|ctl_lun_req
modifier|*
name|req
parameter_list|,
name|int
name|do_wait
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_backend_ramdisk_modify
parameter_list|(
name|struct
name|ctl_be_ramdisk_softc
modifier|*
name|softc
parameter_list|,
name|struct
name|ctl_lun_req
modifier|*
name|req
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_backend_ramdisk_worker
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_backend_ramdisk_lun_shutdown
parameter_list|(
name|void
modifier|*
name|be_lun
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_backend_ramdisk_lun_config_status
parameter_list|(
name|void
modifier|*
name|be_lun
parameter_list|,
name|ctl_lun_config_status
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_backend_ramdisk_config_write
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_backend_ramdisk_config_read
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|ctl_backend_driver
name|ctl_be_ramdisk_driver
init|=
block|{
operator|.
name|name
operator|=
literal|"ramdisk"
block|,
operator|.
name|flags
operator|=
name|CTL_BE_FLAG_HAS_CONFIG
block|,
operator|.
name|init
operator|=
name|ctl_backend_ramdisk_init
block|,
operator|.
name|data_submit
operator|=
name|ctl_backend_ramdisk_submit
block|,
operator|.
name|data_move_done
operator|=
name|ctl_backend_ramdisk_move_done
block|,
operator|.
name|config_read
operator|=
name|ctl_backend_ramdisk_config_read
block|,
operator|.
name|config_write
operator|=
name|ctl_backend_ramdisk_config_write
block|,
operator|.
name|ioctl
operator|=
name|ctl_backend_ramdisk_ioctl
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_RAMDISK
argument_list|,
literal|"ramdisk"
argument_list|,
literal|"Memory used for CTL RAMdisk"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTL_BACKEND_DECLARE
argument_list|(
name|cbr
argument_list|,
name|ctl_be_ramdisk_driver
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|ctl_backend_ramdisk_init
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ctl_be_ramdisk_softc
modifier|*
name|softc
decl_stmt|;
ifdef|#
directive|ifdef
name|CTL_RAMDISK_PAGES
name|int
name|i
decl_stmt|;
endif|#
directive|endif
name|softc
operator|=
operator|&
name|rd_softc
expr_stmt|;
name|memset
argument_list|(
name|softc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|softc
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|,
literal|"ctlramdisk"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|softc
operator|->
name|lun_list
argument_list|)
expr_stmt|;
name|softc
operator|->
name|rd_size
operator|=
literal|1024
operator|*
literal|1024
expr_stmt|;
ifdef|#
directive|ifdef
name|CTL_RAMDISK_PAGES
name|softc
operator|->
name|num_pages
operator|=
name|softc
operator|->
name|rd_size
operator|/
name|PAGE_SIZE
expr_stmt|;
name|softc
operator|->
name|ramdisk_pages
operator|=
operator|(
name|uint8_t
operator|*
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|uint8_t
operator|*
argument_list|)
operator|*
name|softc
operator|->
name|num_pages
argument_list|,
name|M_RAMDISK
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|softc
operator|->
name|num_pages
condition|;
name|i
operator|++
control|)
name|softc
operator|->
name|ramdisk_pages
index|[
name|i
index|]
operator|=
name|malloc
argument_list|(
name|PAGE_SIZE
argument_list|,
name|M_RAMDISK
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
else|#
directive|else
name|softc
operator|->
name|ramdisk_buffer
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|malloc
argument_list|(
name|softc
operator|->
name|rd_size
argument_list|,
name|M_RAMDISK
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ctl_backend_ramdisk_shutdown
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ctl_be_ramdisk_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ctl_be_ramdisk_lun
modifier|*
name|lun
decl_stmt|,
modifier|*
name|next_lun
decl_stmt|;
ifdef|#
directive|ifdef
name|CTL_RAMDISK_PAGES
name|int
name|i
decl_stmt|;
endif|#
directive|endif
name|softc
operator|=
operator|&
name|rd_softc
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|lun
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|softc
operator|->
name|lun_list
argument_list|)
init|;
name|lun
operator|!=
name|NULL
condition|;
name|lun
operator|=
name|next_lun
control|)
block|{
comment|/* 		 * Grab the next LUN.  The current LUN may get removed by 		 * ctl_invalidate_lun(), which will call our LUN shutdown 		 * routine, if there is no outstanding I/O for this LUN. 		 */
name|next_lun
operator|=
name|STAILQ_NEXT
argument_list|(
name|lun
argument_list|,
name|links
argument_list|)
expr_stmt|;
comment|/* 		 * Drop our lock here.  Since ctl_invalidate_lun() can call 		 * back into us, this could potentially lead to a recursive 		 * lock of the same mutex, which would cause a hang. 		 */
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ctl_disable_lun
argument_list|(
operator|&
name|lun
operator|->
name|ctl_be_lun
argument_list|)
expr_stmt|;
name|ctl_invalidate_lun
argument_list|(
operator|&
name|lun
operator|->
name|ctl_be_lun
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CTL_RAMDISK_PAGES
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|softc
operator|->
name|num_pages
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|softc
operator|->
name|ramdisk_pages
index|[
name|i
index|]
argument_list|,
name|M_RAMDISK
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|softc
operator|->
name|ramdisk_pages
argument_list|,
name|M_RAMDISK
argument_list|)
expr_stmt|;
else|#
directive|else
name|free
argument_list|(
name|softc
operator|->
name|ramdisk_buffer
argument_list|,
name|M_RAMDISK
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ctl_backend_deregister
argument_list|(
operator|&
name|ctl_be_ramdisk_driver
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ctl_backend_ramdisk_shutdown: "
literal|"ctl_backend_deregister() failed!\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_backend_ramdisk_move_done
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_be_lun
modifier|*
name|ctl_be_lun
decl_stmt|;
name|struct
name|ctl_be_ramdisk_lun
modifier|*
name|be_lun
decl_stmt|;
ifdef|#
directive|ifdef
name|CTL_TIME_IO
name|struct
name|bintime
name|cur_bt
decl_stmt|;
endif|#
directive|endif
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_backend_ramdisk_move_done\n"
operator|)
argument_list|)
expr_stmt|;
name|ctl_be_lun
operator|=
operator|(
expr|struct
name|ctl_be_lun
operator|*
operator|)
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_BACKEND_LUN
index|]
operator|.
name|ptr
expr_stmt|;
name|be_lun
operator|=
operator|(
expr|struct
name|ctl_be_ramdisk_lun
operator|*
operator|)
name|ctl_be_lun
operator|->
name|be_lun
expr_stmt|;
ifdef|#
directive|ifdef
name|CTL_TIME_IO
name|getbintime
argument_list|(
operator|&
name|cur_bt
argument_list|)
expr_stmt|;
name|bintime_sub
argument_list|(
operator|&
name|cur_bt
argument_list|,
operator|&
name|io
operator|->
name|io_hdr
operator|.
name|dma_start_bt
argument_list|)
expr_stmt|;
name|bintime_add
argument_list|(
operator|&
name|io
operator|->
name|io_hdr
operator|.
name|dma_bt
argument_list|,
operator|&
name|cur_bt
argument_list|)
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|num_dmas
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|io
operator|->
name|scsiio
operator|.
name|kern_sg_entries
operator|>
literal|0
condition|)
name|free
argument_list|(
name|io
operator|->
name|scsiio
operator|.
name|kern_data_ptr
argument_list|,
name|M_RAMDISK
argument_list|)
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|kern_rel_offset
operator|+=
name|io
operator|->
name|scsiio
operator|.
name|kern_data_len
expr_stmt|;
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|port_status
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ABORT
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|==
name|CTL_STATUS_NONE
operator|)
condition|)
block|{
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_BACKEND
index|]
operator|.
name|integer
operator|>
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|be_lun
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|be_lun
operator|->
name|cont_queue
argument_list|,
operator|&
name|io
operator|->
name|io_hdr
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|be_lun
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|be_lun
operator|->
name|io_taskqueue
argument_list|,
operator|&
name|be_lun
operator|->
name|io_task
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|=
name|CTL_SUCCESS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|port_status
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ABORT
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|==
name|CTL_STATUS_NONE
operator|)
condition|)
block|{
comment|/* 		 * For hardware error sense keys, the sense key 		 * specific value is defined to be a retry count, 		 * but we use it to pass back an internal FETD 		 * error code.  XXX KDM  Hopefully the FETD is only 		 * using 16 bits for an error code, since that's 		 * all the space we have in the sks field. 		 */
name|ctl_set_internal_failure
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*retry_count*/
name|io
operator|->
name|io_hdr
operator|.
name|port_status
argument_list|)
expr_stmt|;
block|}
name|ctl_data_submit_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_backend_ramdisk_submit
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_be_lun
modifier|*
name|ctl_be_lun
decl_stmt|;
name|struct
name|ctl_lba_len_flags
modifier|*
name|lbalen
decl_stmt|;
name|ctl_be_lun
operator|=
operator|(
expr|struct
name|ctl_be_lun
operator|*
operator|)
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_BACKEND_LUN
index|]
operator|.
name|ptr
expr_stmt|;
name|lbalen
operator|=
operator|(
expr|struct
name|ctl_lba_len_flags
operator|*
operator|)
operator|&
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LBA_LEN
index|]
expr_stmt|;
if|if
condition|(
name|lbalen
operator|->
name|flags
operator|&
name|CTL_LLF_VERIFY
condition|)
block|{
name|ctl_set_success
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
name|ctl_data_submit_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_BACKEND
index|]
operator|.
name|integer
operator|=
name|lbalen
operator|->
name|len
operator|*
name|ctl_be_lun
operator|->
name|blocksize
expr_stmt|;
name|ctl_backend_ramdisk_continue
argument_list|(
name|io
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_backend_ramdisk_continue
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_be_ramdisk_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|len
decl_stmt|,
name|len_filled
decl_stmt|,
name|sg_filled
decl_stmt|;
ifdef|#
directive|ifdef
name|CTL_RAMDISK_PAGES
name|struct
name|ctl_sg_entry
modifier|*
name|sg_entries
decl_stmt|;
name|int
name|i
decl_stmt|;
endif|#
directive|endif
name|softc
operator|=
operator|&
name|rd_softc
expr_stmt|;
name|len
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_BACKEND
index|]
operator|.
name|integer
expr_stmt|;
ifdef|#
directive|ifdef
name|CTL_RAMDISK_PAGES
name|sg_filled
operator|=
name|min
argument_list|(
name|btoc
argument_list|(
name|len
argument_list|)
argument_list|,
name|softc
operator|->
name|num_pages
argument_list|)
expr_stmt|;
if|if
condition|(
name|sg_filled
operator|>
literal|1
condition|)
block|{
name|io
operator|->
name|scsiio
operator|.
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ctl_sg_entry
argument_list|)
operator|*
name|sg_filled
argument_list|,
name|M_RAMDISK
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sg_entries
operator|=
operator|(
expr|struct
name|ctl_sg_entry
operator|*
operator|)
name|io
operator|->
name|scsiio
operator|.
name|kern_data_ptr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|len_filled
operator|=
literal|0
init|;
name|i
operator|<
name|sg_filled
condition|;
name|i
operator|++
control|)
block|{
name|sg_entries
index|[
name|i
index|]
operator|.
name|addr
operator|=
name|softc
operator|->
name|ramdisk_pages
index|[
name|i
index|]
expr_stmt|;
name|sg_entries
index|[
name|i
index|]
operator|.
name|len
operator|=
name|ctl_min
argument_list|(
name|PAGE_SIZE
argument_list|,
name|len
operator|-
name|len_filled
argument_list|)
expr_stmt|;
name|len_filled
operator|+=
name|sg_entries
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
block|}
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_KDPTR_SGLIST
expr_stmt|;
block|}
else|else
block|{
name|sg_filled
operator|=
literal|0
expr_stmt|;
name|len_filled
operator|=
name|len
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|kern_data_ptr
operator|=
name|softc
operator|->
name|ramdisk_pages
index|[
literal|0
index|]
expr_stmt|;
block|}
else|#
directive|else
name|sg_filled
operator|=
literal|0
expr_stmt|;
name|len_filled
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|softc
operator|->
name|rd_size
argument_list|)
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|kern_data_ptr
operator|=
name|softc
operator|->
name|ramdisk_buffer
expr_stmt|;
endif|#
directive|endif
comment|/* CTL_RAMDISK_PAGES */
name|io
operator|->
name|scsiio
operator|.
name|be_move_done
operator|=
name|ctl_backend_ramdisk_move_done
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|kern_data_resid
operator|=
literal|0
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|kern_data_len
operator|=
name|len_filled
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|kern_sg_entries
operator|=
name|sg_filled
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_BACKEND
index|]
operator|.
name|integer
operator|-=
name|len_filled
expr_stmt|;
ifdef|#
directive|ifdef
name|CTL_TIME_IO
name|getbintime
argument_list|(
operator|&
name|io
operator|->
name|io_hdr
operator|.
name|dma_start_bt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ctl_datamove
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_backend_ramdisk_worker
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ctl_be_ramdisk_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ctl_be_ramdisk_lun
modifier|*
name|be_lun
decl_stmt|;
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|be_lun
operator|=
operator|(
expr|struct
name|ctl_be_ramdisk_lun
operator|*
operator|)
name|context
expr_stmt|;
name|softc
operator|=
name|be_lun
operator|->
name|softc
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|be_lun
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|STAILQ_FIRST
argument_list|(
operator|&
name|be_lun
operator|->
name|cont_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_REMOVE
argument_list|(
operator|&
name|be_lun
operator|->
name|cont_queue
argument_list|,
operator|&
name|io
operator|->
name|io_hdr
argument_list|,
name|ctl_io_hdr
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|be_lun
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
name|ctl_backend_ramdisk_continue
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|be_lun
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * If we get here, there is no work left in the queues, so 		 * just break out and let the task queue go to sleep. 		 */
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|be_lun
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_backend_ramdisk_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|ctl_be_ramdisk_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|softc
operator|=
operator|&
name|rd_softc
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|CTL_LUN_REQ
case|:
block|{
name|struct
name|ctl_lun_req
modifier|*
name|lun_req
decl_stmt|;
name|lun_req
operator|=
operator|(
expr|struct
name|ctl_lun_req
operator|*
operator|)
name|addr
expr_stmt|;
switch|switch
condition|(
name|lun_req
operator|->
name|reqtype
condition|)
block|{
case|case
name|CTL_LUNREQ_CREATE
case|:
name|retval
operator|=
name|ctl_backend_ramdisk_create
argument_list|(
name|softc
argument_list|,
name|lun_req
argument_list|,
comment|/*do_wait*/
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_LUNREQ_RM
case|:
name|retval
operator|=
name|ctl_backend_ramdisk_rm
argument_list|(
name|softc
argument_list|,
name|lun_req
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_LUNREQ_MODIFY
case|:
name|retval
operator|=
name|ctl_backend_ramdisk_modify
argument_list|(
name|softc
argument_list|,
name|lun_req
argument_list|)
expr_stmt|;
break|break;
default|default:
name|lun_req
operator|->
name|status
operator|=
name|CTL_LUN_ERROR
expr_stmt|;
name|snprintf
argument_list|(
name|lun_req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|lun_req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"%s: invalid LUN request type %d"
argument_list|,
name|__func__
argument_list|,
name|lun_req
operator|->
name|reqtype
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
default|default:
name|retval
operator|=
name|ENOTTY
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_backend_ramdisk_rm
parameter_list|(
name|struct
name|ctl_be_ramdisk_softc
modifier|*
name|softc
parameter_list|,
name|struct
name|ctl_lun_req
modifier|*
name|req
parameter_list|)
block|{
name|struct
name|ctl_be_ramdisk_lun
modifier|*
name|be_lun
decl_stmt|;
name|struct
name|ctl_lun_rm_params
modifier|*
name|params
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|params
operator|=
operator|&
name|req
operator|->
name|reqdata
operator|.
name|rm
expr_stmt|;
name|be_lun
operator|=
name|NULL
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|be_lun
argument_list|,
argument|&softc->lun_list
argument_list|,
argument|links
argument_list|)
block|{
if|if
condition|(
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|lun_id
operator|==
name|params
operator|->
name|lun_id
condition|)
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|be_lun
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"%s: LUN %u is not managed by the ramdisk backend"
argument_list|,
name|__func__
argument_list|,
name|params
operator|->
name|lun_id
argument_list|)
expr_stmt|;
goto|goto
name|bailout_error
goto|;
block|}
name|retval
operator|=
name|ctl_disable_lun
argument_list|(
operator|&
name|be_lun
operator|->
name|ctl_be_lun
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"%s: error %d returned from ctl_disable_lun() for "
literal|"LUN %d"
argument_list|,
name|__func__
argument_list|,
name|retval
argument_list|,
name|params
operator|->
name|lun_id
argument_list|)
expr_stmt|;
goto|goto
name|bailout_error
goto|;
block|}
comment|/* 	 * Set the waiting flag before we invalidate the LUN.  Our shutdown 	 * routine can be called any time after we invalidate the LUN, 	 * and can be called from our context. 	 * 	 * This tells the shutdown routine that we're waiting, or we're 	 * going to wait for the shutdown to happen. 	 */
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|be_lun
operator|->
name|flags
operator||=
name|CTL_BE_RAMDISK_LUN_WAITING
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|retval
operator|=
name|ctl_invalidate_lun
argument_list|(
operator|&
name|be_lun
operator|->
name|ctl_be_lun
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"%s: error %d returned from ctl_invalidate_lun() for "
literal|"LUN %d"
argument_list|,
name|__func__
argument_list|,
name|retval
argument_list|,
name|params
operator|->
name|lun_id
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|be_lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_BE_RAMDISK_LUN_WAITING
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
goto|goto
name|bailout_error
goto|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|be_lun
operator|->
name|flags
operator|&
name|CTL_BE_RAMDISK_LUN_UNCONFIGURED
operator|)
operator|==
literal|0
condition|)
block|{
name|retval
operator|=
name|msleep
argument_list|(
name|be_lun
argument_list|,
operator|&
name|softc
operator|->
name|lock
argument_list|,
name|PCATCH
argument_list|,
literal|"ctlram"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|EINTR
condition|)
break|break;
block|}
name|be_lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_BE_RAMDISK_LUN_WAITING
expr_stmt|;
comment|/* 	 * We only remove this LUN from the list and free it (below) if 	 * retval == 0.  If the user interrupted the wait, we just bail out 	 * without actually freeing the LUN.  We let the shutdown routine 	 * free the LUN if that happens. 	 */
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
block|{
name|STAILQ_REMOVE
argument_list|(
operator|&
name|softc
operator|->
name|lun_list
argument_list|,
name|be_lun
argument_list|,
name|ctl_be_ramdisk_lun
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|softc
operator|->
name|num_luns
operator|--
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
block|{
name|taskqueue_drain
argument_list|(
name|be_lun
operator|->
name|io_taskqueue
argument_list|,
operator|&
name|be_lun
operator|->
name|io_task
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|be_lun
operator|->
name|io_taskqueue
argument_list|)
expr_stmt|;
name|ctl_free_opts
argument_list|(
operator|&
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|options
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|be_lun
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|be_lun
argument_list|,
name|M_RAMDISK
argument_list|)
expr_stmt|;
block|}
name|req
operator|->
name|status
operator|=
name|CTL_LUN_OK
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
name|bailout_error
label|:
name|req
operator|->
name|status
operator|=
name|CTL_LUN_ERROR
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_backend_ramdisk_create
parameter_list|(
name|struct
name|ctl_be_ramdisk_softc
modifier|*
name|softc
parameter_list|,
name|struct
name|ctl_lun_req
modifier|*
name|req
parameter_list|,
name|int
name|do_wait
parameter_list|)
block|{
name|struct
name|ctl_be_ramdisk_lun
modifier|*
name|be_lun
decl_stmt|;
name|struct
name|ctl_lun_create_params
modifier|*
name|params
decl_stmt|;
name|uint32_t
name|blocksize
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|char
name|tmpstr
index|[
literal|32
index|]
decl_stmt|;
name|int
name|retval
decl_stmt|,
name|unmap
decl_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|params
operator|=
operator|&
name|req
operator|->
name|reqdata
operator|.
name|create
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|blocksize_bytes
operator|!=
literal|0
condition|)
name|blocksize
operator|=
name|params
operator|->
name|blocksize_bytes
expr_stmt|;
else|else
name|blocksize
operator|=
literal|512
expr_stmt|;
name|be_lun
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|be_lun
argument_list|)
argument_list|,
name|M_RAMDISK
argument_list|,
name|M_ZERO
operator||
operator|(
name|do_wait
condition|?
name|M_WAITOK
else|:
name|M_NOWAIT
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|be_lun
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"%s: error allocating %zd bytes"
argument_list|,
name|__func__
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|be_lun
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|bailout_error
goto|;
block|}
name|sprintf
argument_list|(
name|be_lun
operator|->
name|lunname
argument_list|,
literal|"cram%d"
argument_list|,
name|softc
operator|->
name|num_luns
argument_list|)
expr_stmt|;
name|ctl_init_opts
argument_list|(
operator|&
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|options
argument_list|,
name|req
operator|->
name|num_be_args
argument_list|,
name|req
operator|->
name|kern_be_args
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|flags
operator|&
name|CTL_LUN_FLAG_DEV_TYPE
condition|)
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|lun_type
operator|=
name|params
operator|->
name|device_type
expr_stmt|;
else|else
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|lun_type
operator|=
name|T_DIRECT
expr_stmt|;
if|if
condition|(
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|lun_type
operator|==
name|T_DIRECT
condition|)
block|{
if|if
condition|(
name|params
operator|->
name|lun_size_bytes
operator|<
name|blocksize
condition|)
block|{
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"%s: LUN size %ju< blocksize %u"
argument_list|,
name|__func__
argument_list|,
name|params
operator|->
name|lun_size_bytes
argument_list|,
name|blocksize
argument_list|)
expr_stmt|;
goto|goto
name|bailout_error
goto|;
block|}
name|be_lun
operator|->
name|size_blocks
operator|=
name|params
operator|->
name|lun_size_bytes
operator|/
name|blocksize
expr_stmt|;
name|be_lun
operator|->
name|size_bytes
operator|=
name|be_lun
operator|->
name|size_blocks
operator|*
name|blocksize
expr_stmt|;
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|maxlba
operator|=
name|be_lun
operator|->
name|size_blocks
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|maxlba
operator|=
literal|0
expr_stmt|;
name|blocksize
operator|=
literal|0
expr_stmt|;
name|be_lun
operator|->
name|size_bytes
operator|=
literal|0
expr_stmt|;
name|be_lun
operator|->
name|size_blocks
operator|=
literal|0
expr_stmt|;
block|}
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|blocksize
operator|=
name|blocksize
expr_stmt|;
comment|/* Tell the user the blocksize we ended up using */
name|params
operator|->
name|blocksize_bytes
operator|=
name|blocksize
expr_stmt|;
comment|/* Tell the user the exact size we ended up using */
name|params
operator|->
name|lun_size_bytes
operator|=
name|be_lun
operator|->
name|size_bytes
expr_stmt|;
name|be_lun
operator|->
name|softc
operator|=
name|softc
expr_stmt|;
name|unmap
operator|=
literal|0
expr_stmt|;
name|value
operator|=
name|ctl_get_opt
argument_list|(
operator|&
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|options
argument_list|,
literal|"unmap"
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"on"
argument_list|)
operator|==
literal|0
condition|)
name|unmap
operator|=
literal|1
expr_stmt|;
name|be_lun
operator|->
name|flags
operator|=
name|CTL_BE_RAMDISK_LUN_UNCONFIGURED
expr_stmt|;
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|flags
operator|=
name|CTL_LUN_FLAG_PRIMARY
expr_stmt|;
if|if
condition|(
name|unmap
condition|)
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|flags
operator||=
name|CTL_LUN_FLAG_UNMAP
expr_stmt|;
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|atomicblock
operator|=
name|UINT32_MAX
expr_stmt|;
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|be_lun
operator|=
name|be_lun
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|flags
operator|&
name|CTL_LUN_FLAG_ID_REQ
condition|)
block|{
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|req_lun_id
operator|=
name|params
operator|->
name|req_lun_id
expr_stmt|;
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|flags
operator||=
name|CTL_LUN_FLAG_ID_REQ
expr_stmt|;
block|}
else|else
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|req_lun_id
operator|=
literal|0
expr_stmt|;
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|lun_shutdown
operator|=
name|ctl_backend_ramdisk_lun_shutdown
expr_stmt|;
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|lun_config_status
operator|=
name|ctl_backend_ramdisk_lun_config_status
expr_stmt|;
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|be
operator|=
operator|&
name|ctl_be_ramdisk_driver
expr_stmt|;
if|if
condition|(
operator|(
name|params
operator|->
name|flags
operator|&
name|CTL_LUN_FLAG_SERIAL_NUM
operator|)
operator|==
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|tmpstr
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
literal|"MYSERIAL%4d"
argument_list|,
name|softc
operator|->
name|num_luns
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|serial_num
argument_list|,
name|tmpstr
argument_list|,
name|ctl_min
argument_list|(
sizeof|sizeof
argument_list|(
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|serial_num
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Tell the user what we used for a serial number */
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|params
operator|->
name|serial_num
argument_list|,
name|tmpstr
argument_list|,
name|ctl_min
argument_list|(
sizeof|sizeof
argument_list|(
name|params
operator|->
name|serial_num
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|serial_num
argument_list|,
name|params
operator|->
name|serial_num
argument_list|,
name|ctl_min
argument_list|(
sizeof|sizeof
argument_list|(
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|serial_num
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|params
operator|->
name|serial_num
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|params
operator|->
name|flags
operator|&
name|CTL_LUN_FLAG_DEVID
operator|)
operator|==
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|tmpstr
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
literal|"MYDEVID%4d"
argument_list|,
name|softc
operator|->
name|num_luns
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|device_id
argument_list|,
name|tmpstr
argument_list|,
name|ctl_min
argument_list|(
sizeof|sizeof
argument_list|(
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|device_id
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Tell the user what we used for a device ID */
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|params
operator|->
name|device_id
argument_list|,
name|tmpstr
argument_list|,
name|ctl_min
argument_list|(
sizeof|sizeof
argument_list|(
name|params
operator|->
name|device_id
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|device_id
argument_list|,
name|params
operator|->
name|device_id
argument_list|,
name|ctl_min
argument_list|(
sizeof|sizeof
argument_list|(
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|device_id
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|params
operator|->
name|device_id
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|STAILQ_INIT
argument_list|(
operator|&
name|be_lun
operator|->
name|cont_queue
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|be_lun
operator|->
name|queue_lock
argument_list|,
literal|"cram queue lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|be_lun
operator|->
name|io_task
argument_list|,
comment|/*priority*/
literal|0
argument_list|,
name|ctl_backend_ramdisk_worker
argument_list|,
name|be_lun
argument_list|)
expr_stmt|;
name|be_lun
operator|->
name|io_taskqueue
operator|=
name|taskqueue_create
argument_list|(
name|be_lun
operator|->
name|lunname
argument_list|,
name|M_WAITOK
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
comment|/*context*/
operator|&
name|be_lun
operator|->
name|io_taskqueue
argument_list|)
expr_stmt|;
if|if
condition|(
name|be_lun
operator|->
name|io_taskqueue
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"%s: Unable to create taskqueue"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|bailout_error
goto|;
block|}
name|retval
operator|=
name|taskqueue_start_threads
argument_list|(
operator|&
name|be_lun
operator|->
name|io_taskqueue
argument_list|,
comment|/*num threads*/
literal|1
argument_list|,
comment|/*priority*/
name|PWAIT
argument_list|,
comment|/*thread name*/
literal|"%s taskq"
argument_list|,
name|be_lun
operator|->
name|lunname
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
goto|goto
name|bailout_error
goto|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|softc
operator|->
name|num_luns
operator|++
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|softc
operator|->
name|lun_list
argument_list|,
name|be_lun
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|retval
operator|=
name|ctl_add_lun
argument_list|(
operator|&
name|be_lun
operator|->
name|ctl_be_lun
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE
argument_list|(
operator|&
name|softc
operator|->
name|lun_list
argument_list|,
name|be_lun
argument_list|,
name|ctl_be_ramdisk_lun
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|softc
operator|->
name|num_luns
operator|--
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"%s: ctl_add_lun() returned error %d, see dmesg for "
literal|"details"
argument_list|,
name|__func__
argument_list|,
name|retval
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
goto|goto
name|bailout_error
goto|;
block|}
if|if
condition|(
name|do_wait
operator|==
literal|0
condition|)
return|return
operator|(
name|retval
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * Tell the config_status routine that we're waiting so it won't 	 * clean up the LUN in the event of an error. 	 */
name|be_lun
operator|->
name|flags
operator||=
name|CTL_BE_RAMDISK_LUN_WAITING
expr_stmt|;
while|while
condition|(
name|be_lun
operator|->
name|flags
operator|&
name|CTL_BE_RAMDISK_LUN_UNCONFIGURED
condition|)
block|{
name|retval
operator|=
name|msleep
argument_list|(
name|be_lun
argument_list|,
operator|&
name|softc
operator|->
name|lock
argument_list|,
name|PCATCH
argument_list|,
literal|"ctlram"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|EINTR
condition|)
break|break;
block|}
name|be_lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_BE_RAMDISK_LUN_WAITING
expr_stmt|;
if|if
condition|(
name|be_lun
operator|->
name|flags
operator|&
name|CTL_BE_RAMDISK_LUN_CONFIG_ERR
condition|)
block|{
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"%s: LUN configuration error, see dmesg for details"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE
argument_list|(
operator|&
name|softc
operator|->
name|lun_list
argument_list|,
name|be_lun
argument_list|,
name|ctl_be_ramdisk_lun
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|softc
operator|->
name|num_luns
operator|--
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
goto|goto
name|bailout_error
goto|;
block|}
else|else
block|{
name|params
operator|->
name|req_lun_id
operator|=
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|lun_id
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|req
operator|->
name|status
operator|=
name|CTL_LUN_OK
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
name|bailout_error
label|:
name|req
operator|->
name|status
operator|=
name|CTL_LUN_ERROR
expr_stmt|;
if|if
condition|(
name|be_lun
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|be_lun
operator|->
name|io_taskqueue
operator|!=
name|NULL
condition|)
block|{
name|taskqueue_free
argument_list|(
name|be_lun
operator|->
name|io_taskqueue
argument_list|)
expr_stmt|;
block|}
name|ctl_free_opts
argument_list|(
operator|&
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|options
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|be_lun
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|be_lun
argument_list|,
name|M_RAMDISK
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_backend_ramdisk_modify
parameter_list|(
name|struct
name|ctl_be_ramdisk_softc
modifier|*
name|softc
parameter_list|,
name|struct
name|ctl_lun_req
modifier|*
name|req
parameter_list|)
block|{
name|struct
name|ctl_be_ramdisk_lun
modifier|*
name|be_lun
decl_stmt|;
name|struct
name|ctl_lun_modify_params
modifier|*
name|params
decl_stmt|;
name|uint32_t
name|blocksize
decl_stmt|;
name|params
operator|=
operator|&
name|req
operator|->
name|reqdata
operator|.
name|modify
expr_stmt|;
name|be_lun
operator|=
name|NULL
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|be_lun
argument_list|,
argument|&softc->lun_list
argument_list|,
argument|links
argument_list|)
block|{
if|if
condition|(
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|lun_id
operator|==
name|params
operator|->
name|lun_id
condition|)
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|be_lun
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"%s: LUN %u is not managed by the ramdisk backend"
argument_list|,
name|__func__
argument_list|,
name|params
operator|->
name|lun_id
argument_list|)
expr_stmt|;
goto|goto
name|bailout_error
goto|;
block|}
if|if
condition|(
name|params
operator|->
name|lun_size_bytes
operator|==
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"%s: LUN size \"auto\" not supported "
literal|"by the ramdisk backend"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|bailout_error
goto|;
block|}
name|blocksize
operator|=
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|blocksize
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|lun_size_bytes
operator|<
name|blocksize
condition|)
block|{
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"%s: LUN size %ju< blocksize %u"
argument_list|,
name|__func__
argument_list|,
name|params
operator|->
name|lun_size_bytes
argument_list|,
name|blocksize
argument_list|)
expr_stmt|;
goto|goto
name|bailout_error
goto|;
block|}
name|be_lun
operator|->
name|size_blocks
operator|=
name|params
operator|->
name|lun_size_bytes
operator|/
name|blocksize
expr_stmt|;
name|be_lun
operator|->
name|size_bytes
operator|=
name|be_lun
operator|->
name|size_blocks
operator|*
name|blocksize
expr_stmt|;
comment|/* 	 * The maximum LBA is the size - 1. 	 * 	 * XXX: Note that this field is being updated without locking, 	 * 	which might cause problems on 32-bit architectures. 	 */
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|maxlba
operator|=
name|be_lun
operator|->
name|size_blocks
operator|-
literal|1
expr_stmt|;
name|ctl_lun_capacity_changed
argument_list|(
operator|&
name|be_lun
operator|->
name|ctl_be_lun
argument_list|)
expr_stmt|;
comment|/* Tell the user the exact size we ended up using */
name|params
operator|->
name|lun_size_bytes
operator|=
name|be_lun
operator|->
name|size_bytes
expr_stmt|;
name|req
operator|->
name|status
operator|=
name|CTL_LUN_OK
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|bailout_error
label|:
name|req
operator|->
name|status
operator|=
name|CTL_LUN_ERROR
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_backend_ramdisk_lun_shutdown
parameter_list|(
name|void
modifier|*
name|be_lun
parameter_list|)
block|{
name|struct
name|ctl_be_ramdisk_lun
modifier|*
name|lun
decl_stmt|;
name|struct
name|ctl_be_ramdisk_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|do_free
decl_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_be_ramdisk_lun
operator|*
operator|)
name|be_lun
expr_stmt|;
name|softc
operator|=
name|lun
operator|->
name|softc
expr_stmt|;
name|do_free
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|lun
operator|->
name|flags
operator||=
name|CTL_BE_RAMDISK_LUN_UNCONFIGURED
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|flags
operator|&
name|CTL_BE_RAMDISK_LUN_WAITING
condition|)
block|{
name|wakeup
argument_list|(
name|lun
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|STAILQ_REMOVE
argument_list|(
operator|&
name|softc
operator|->
name|lun_list
argument_list|,
name|lun
argument_list|,
name|ctl_be_ramdisk_lun
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|softc
operator|->
name|num_luns
operator|--
expr_stmt|;
name|do_free
operator|=
literal|1
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_free
operator|!=
literal|0
condition|)
name|free
argument_list|(
name|be_lun
argument_list|,
name|M_RAMDISK
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_backend_ramdisk_lun_config_status
parameter_list|(
name|void
modifier|*
name|be_lun
parameter_list|,
name|ctl_lun_config_status
name|status
parameter_list|)
block|{
name|struct
name|ctl_be_ramdisk_lun
modifier|*
name|lun
decl_stmt|;
name|struct
name|ctl_be_ramdisk_softc
modifier|*
name|softc
decl_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_be_ramdisk_lun
operator|*
operator|)
name|be_lun
expr_stmt|;
name|softc
operator|=
name|lun
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|CTL_LUN_CONFIG_OK
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_BE_RAMDISK_LUN_UNCONFIGURED
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|flags
operator|&
name|CTL_BE_RAMDISK_LUN_WAITING
condition|)
name|wakeup
argument_list|(
name|lun
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 		 * We successfully added the LUN, attempt to enable it. 		 */
if|if
condition|(
name|ctl_enable_lun
argument_list|(
operator|&
name|lun
operator|->
name|ctl_be_lun
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ctl_enable_lun() failed!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl_invalidate_lun
argument_list|(
operator|&
name|lun
operator|->
name|ctl_be_lun
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ctl_invalidate_lun() failed!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_BE_RAMDISK_LUN_UNCONFIGURED
expr_stmt|;
comment|/* 	 * If we have a user waiting, let him handle the cleanup.  If not, 	 * clean things up here. 	 */
if|if
condition|(
name|lun
operator|->
name|flags
operator|&
name|CTL_BE_RAMDISK_LUN_WAITING
condition|)
block|{
name|lun
operator|->
name|flags
operator||=
name|CTL_BE_RAMDISK_LUN_CONFIG_ERR
expr_stmt|;
name|wakeup
argument_list|(
name|lun
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|STAILQ_REMOVE
argument_list|(
operator|&
name|softc
operator|->
name|lun_list
argument_list|,
name|lun
argument_list|,
name|ctl_be_ramdisk_lun
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|softc
operator|->
name|num_luns
operator|--
expr_stmt|;
name|free
argument_list|(
name|lun
argument_list|,
name|M_RAMDISK
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_backend_ramdisk_config_write
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_be_ramdisk_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|softc
operator|=
operator|&
name|rd_softc
expr_stmt|;
switch|switch
condition|(
name|io
operator|->
name|scsiio
operator|.
name|cdb
index|[
literal|0
index|]
condition|)
block|{
case|case
name|SYNCHRONIZE_CACHE
case|:
case|case
name|SYNCHRONIZE_CACHE_16
case|:
comment|/* 		 * The upper level CTL code will filter out any CDBs with 		 * the immediate bit set and return the proper error.  It 		 * will also not allow a sync cache command to go to a LUN 		 * that is powered down. 		 * 		 * We don't really need to worry about what LBA range the 		 * user asked to be synced out.  When they issue a sync 		 * cache command, we'll sync out the whole thing. 		 * 		 * This is obviously just a stubbed out implementation. 		 * The real implementation will be in the RAIDCore/CTL 		 * interface, and can only really happen when RAIDCore 		 * implements a per-array cache sync. 		 */
name|ctl_set_success
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
name|ctl_config_write_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
case|case
name|START_STOP_UNIT
case|:
block|{
name|struct
name|scsi_start_stop_unit
modifier|*
name|cdb
decl_stmt|;
name|struct
name|ctl_be_lun
modifier|*
name|ctl_be_lun
decl_stmt|;
name|struct
name|ctl_be_ramdisk_lun
modifier|*
name|be_lun
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_start_stop_unit
operator|*
operator|)
name|io
operator|->
name|scsiio
operator|.
name|cdb
expr_stmt|;
name|ctl_be_lun
operator|=
operator|(
expr|struct
name|ctl_be_lun
operator|*
operator|)
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_BACKEND_LUN
index|]
operator|.
name|ptr
expr_stmt|;
name|be_lun
operator|=
operator|(
expr|struct
name|ctl_be_ramdisk_lun
operator|*
operator|)
name|ctl_be_lun
operator|->
name|be_lun
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|how
operator|&
name|SSS_START
condition|)
name|retval
operator|=
name|ctl_start_lun
argument_list|(
name|ctl_be_lun
argument_list|)
expr_stmt|;
else|else
block|{
name|retval
operator|=
name|ctl_stop_lun
argument_list|(
name|ctl_be_lun
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NEEDTOPORT
if|if
condition|(
operator|(
name|retval
operator|==
literal|0
operator|)
operator|&&
operator|(
name|cdb
operator|->
name|byte2
operator|&
name|SSS_ONOFFLINE
operator|)
condition|)
name|retval
operator|=
name|ctl_lun_offline
argument_list|(
name|ctl_be_lun
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 		 * In general, the above routines should not fail.  They 		 * just set state for the LUN.  So we've got something 		 * pretty wrong here if we can't start or stop the LUN. 		 */
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|ctl_set_internal_failure
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*retry_count*/
literal|0xf051
argument_list|)
expr_stmt|;
name|retval
operator|=
name|CTL_RETVAL_COMPLETE
expr_stmt|;
block|}
else|else
block|{
name|ctl_set_success
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
block|}
name|ctl_config_write_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|WRITE_SAME_10
case|:
case|case
name|WRITE_SAME_16
case|:
case|case
name|UNMAP
case|:
name|ctl_set_success
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
name|ctl_config_write_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ctl_set_invalid_opcode
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
name|ctl_config_write_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|retval
operator|=
name|CTL_RETVAL_COMPLETE
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_backend_ramdisk_config_read
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
comment|/* 	 * XXX KDM need to implement!! 	 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

