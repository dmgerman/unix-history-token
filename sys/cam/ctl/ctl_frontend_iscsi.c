begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2012 The FreeBSD Foundation  * All rights reserved.  *  * This software was developed by Edward Tomasz Napierala under sponsorship  * from the FreeBSD Foundation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * CTL frontend for the iSCSI protocol.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/capsicum.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_da.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_io.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_backend.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_error.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_frontend.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_frontend_internal.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_ha.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_private.h>
end_include

begin_include
include|#
directive|include
file|"../../dev/iscsi/icl.h"
end_include

begin_include
include|#
directive|include
file|"../../dev/iscsi/iscsi_proto.h"
end_include

begin_include
include|#
directive|include
file|"ctl_frontend_iscsi.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ICL_KERNEL_PROXY
end_ifdef

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ICL_KERNEL_PROXY
end_ifdef

begin_expr_stmt
name|FEATURE
argument_list|(
name|cfiscsi_kernel_proxy
argument_list|,
literal|"iSCSI target built with ICL_KERNEL_PROXY"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_CFISCSI
argument_list|,
literal|"cfiscsi"
argument_list|,
literal|"Memory used for CTL iSCSI frontend"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|uma_zone_t
name|cfiscsi_data_wait_zone
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_kern_cam_ctl
argument_list|,
name|OID_AUTO
argument_list|,
name|iscsi
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"CAM Target Layer iSCSI Frontend"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|debug
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_cam_ctl_iscsi
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|debug
argument_list|,
literal|1
argument_list|,
literal|"Enable debug messages"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ping_timeout
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_cam_ctl_iscsi
argument_list|,
name|OID_AUTO
argument_list|,
name|ping_timeout
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|ping_timeout
argument_list|,
literal|5
argument_list|,
literal|"Interval between ping (NOP-Out) requests, in seconds"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|login_timeout
init|=
literal|60
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_cam_ctl_iscsi
argument_list|,
name|OID_AUTO
argument_list|,
name|login_timeout
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|login_timeout
argument_list|,
literal|60
argument_list|,
literal|"Time to wait for ctld(8) to finish Login Phase, in seconds"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|maxcmdsn_delta
init|=
literal|256
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_cam_ctl_iscsi
argument_list|,
name|OID_AUTO
argument_list|,
name|maxcmdsn_delta
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|maxcmdsn_delta
argument_list|,
literal|256
argument_list|,
literal|"Number of commands the initiator can send "
literal|"without confirmation"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|CFISCSI_DEBUG
parameter_list|(
name|X
parameter_list|,
modifier|...
parameter_list|)
define|\
value|do {								\ 		if (debug> 1) {					\ 			printf("%s: " X "\n",				\ 			    __func__, ## __VA_ARGS__);			\ 		}							\ 	} while (0)
end_define

begin_define
define|#
directive|define
name|CFISCSI_WARN
parameter_list|(
name|X
parameter_list|,
modifier|...
parameter_list|)
define|\
value|do {								\ 		if (debug> 0) {					\ 			printf("WARNING: %s: " X "\n",			\ 			    __func__, ## __VA_ARGS__);			\ 		}							\ 	} while (0)
end_define

begin_define
define|#
directive|define
name|CFISCSI_SESSION_DEBUG
parameter_list|(
name|S
parameter_list|,
name|X
parameter_list|,
modifier|...
parameter_list|)
define|\
value|do {								\ 		if (debug> 1) {					\ 			printf("%s: %s (%s): " X "\n",			\ 			    __func__, S->cs_initiator_addr,		\ 			    S->cs_initiator_name, ## __VA_ARGS__);	\ 		}							\ 	} while (0)
end_define

begin_define
define|#
directive|define
name|CFISCSI_SESSION_WARN
parameter_list|(
name|S
parameter_list|,
name|X
parameter_list|,
modifier|...
parameter_list|)
define|\
value|do  {								\ 		if (debug> 0) {					\ 			printf("WARNING: %s (%s): " X "\n",		\ 			    S->cs_initiator_addr,			\ 			    S->cs_initiator_name, ## __VA_ARGS__);	\ 		}							\ 	} while (0)
end_define

begin_define
define|#
directive|define
name|CFISCSI_SESSION_LOCK
parameter_list|(
name|X
parameter_list|)
value|mtx_lock(&X->cs_lock)
end_define

begin_define
define|#
directive|define
name|CFISCSI_SESSION_UNLOCK
parameter_list|(
name|X
parameter_list|)
value|mtx_unlock(&X->cs_lock)
end_define

begin_define
define|#
directive|define
name|CFISCSI_SESSION_LOCK_ASSERT
parameter_list|(
name|X
parameter_list|)
value|mtx_assert(&X->cs_lock, MA_OWNED)
end_define

begin_define
define|#
directive|define
name|CONN_SESSION
parameter_list|(
name|X
parameter_list|)
value|((struct cfiscsi_session *)(X)->ic_prv0)
end_define

begin_define
define|#
directive|define
name|PDU_SESSION
parameter_list|(
name|X
parameter_list|)
value|CONN_SESSION((X)->ip_conn)
end_define

begin_define
define|#
directive|define
name|PDU_EXPDATASN
parameter_list|(
name|X
parameter_list|)
value|(X)->ip_prv0
end_define

begin_define
define|#
directive|define
name|PDU_TOTAL_TRANSFER_LEN
parameter_list|(
name|X
parameter_list|)
value|(X)->ip_prv1
end_define

begin_define
define|#
directive|define
name|PDU_R2TSN
parameter_list|(
name|X
parameter_list|)
value|(X)->ip_prv2
end_define

begin_function_decl
name|int
name|cfiscsi_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cfiscsi_online
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cfiscsi_offline
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cfiscsi_lun_enable
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ctl_id
name|target_id
parameter_list|,
name|int
name|lun_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cfiscsi_lun_disable
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ctl_id
name|target_id
parameter_list|,
name|int
name|lun_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cfiscsi_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cfiscsi_devid
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|int
name|alloc_len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cfiscsi_datamove
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cfiscsi_done
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|cfiscsi_map_lun
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint32_t
name|lun
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cfiscsi_pdu_update_cmdsn
parameter_list|(
specifier|const
name|struct
name|icl_pdu
modifier|*
name|request
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cfiscsi_pdu_handle_nop_out
parameter_list|(
name|struct
name|icl_pdu
modifier|*
name|request
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cfiscsi_pdu_handle_scsi_command
parameter_list|(
name|struct
name|icl_pdu
modifier|*
name|request
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cfiscsi_pdu_handle_task_request
parameter_list|(
name|struct
name|icl_pdu
modifier|*
name|request
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cfiscsi_pdu_handle_data_out
parameter_list|(
name|struct
name|icl_pdu
modifier|*
name|request
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cfiscsi_pdu_handle_logout_request
parameter_list|(
name|struct
name|icl_pdu
modifier|*
name|request
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cfiscsi_session_terminate
parameter_list|(
name|struct
name|cfiscsi_session
modifier|*
name|cs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|cfiscsi_target
modifier|*
name|cfiscsi_target_find
parameter_list|(
name|struct
name|cfiscsi_softc
modifier|*
name|softc
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cfiscsi_target_release
parameter_list|(
name|struct
name|cfiscsi_target
modifier|*
name|ct
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cfiscsi_session_delete
parameter_list|(
name|struct
name|cfiscsi_session
modifier|*
name|cs
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|cfiscsi_softc
name|cfiscsi_softc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|ctl_softc
modifier|*
name|control_softc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ctl_frontend
name|cfiscsi_frontend
init|=
block|{
operator|.
name|name
operator|=
literal|"iscsi"
block|,
operator|.
name|init
operator|=
name|cfiscsi_init
block|,
operator|.
name|ioctl
operator|=
name|cfiscsi_ioctl
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|CTL_FRONTEND_DECLARE
argument_list|(
name|ctlcfiscsi
argument_list|,
name|cfiscsi_frontend
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|struct
name|icl_pdu
modifier|*
name|cfiscsi_pdu_new_response
parameter_list|(
name|struct
name|icl_pdu
modifier|*
name|request
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
return|return
operator|(
name|icl_pdu_new_bhs
argument_list|(
name|request
operator|->
name|ip_conn
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|cfiscsi_pdu_update_cmdsn
parameter_list|(
specifier|const
name|struct
name|icl_pdu
modifier|*
name|request
parameter_list|)
block|{
specifier|const
name|struct
name|iscsi_bhs_scsi_command
modifier|*
name|bhssc
decl_stmt|;
name|struct
name|cfiscsi_session
modifier|*
name|cs
decl_stmt|;
name|uint32_t
name|cmdsn
decl_stmt|,
name|expstatsn
decl_stmt|;
name|cs
operator|=
name|PDU_SESSION
argument_list|(
name|request
argument_list|)
expr_stmt|;
comment|/* 	 * Every incoming PDU - not just NOP-Out - resets the ping timer. 	 * The purpose of the timeout is to reset the connection when it stalls; 	 * we don't want this to happen when NOP-In or NOP-Out ends up delayed 	 * in some queue. 	 * 	 * XXX: Locking? 	 */
name|cs
operator|->
name|cs_timeout
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Data-Out PDUs don't contain CmdSN. 	 */
if|if
condition|(
operator|(
name|request
operator|->
name|ip_bhs
operator|->
name|bhs_opcode
operator|&
operator|~
name|ISCSI_BHS_OPCODE_IMMEDIATE
operator|)
operator|==
name|ISCSI_BHS_OPCODE_SCSI_DATA_OUT
condition|)
return|return
operator|(
name|false
operator|)
return|;
comment|/* 	 * We're only using fields common for all the request 	 * (initiator -> target) PDUs. 	 */
name|bhssc
operator|=
operator|(
specifier|const
expr|struct
name|iscsi_bhs_scsi_command
operator|*
operator|)
name|request
operator|->
name|ip_bhs
expr_stmt|;
name|cmdsn
operator|=
name|ntohl
argument_list|(
name|bhssc
operator|->
name|bhssc_cmdsn
argument_list|)
expr_stmt|;
name|expstatsn
operator|=
name|ntohl
argument_list|(
name|bhssc
operator|->
name|bhssc_expstatsn
argument_list|)
expr_stmt|;
name|CFISCSI_SESSION_LOCK
argument_list|(
name|cs
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (expstatsn != cs->cs_statsn) { 		CFISCSI_SESSION_DEBUG(cs, "received PDU with ExpStatSN %d, " 		    "while current StatSN is %d", expstatsn, 		    cs->cs_statsn); 	}
endif|#
directive|endif
comment|/* 	 * The target MUST silently ignore any non-immediate command outside 	 * of this range. 	 */
if|if
condition|(
name|cmdsn
operator|<
name|cs
operator|->
name|cs_cmdsn
operator|||
name|cmdsn
operator|>
name|cs
operator|->
name|cs_cmdsn
operator|+
name|maxcmdsn_delta
condition|)
block|{
name|CFISCSI_SESSION_UNLOCK
argument_list|(
name|cs
argument_list|)
expr_stmt|;
name|CFISCSI_SESSION_WARN
argument_list|(
name|cs
argument_list|,
literal|"received PDU with CmdSN %d, "
literal|"while expected CmdSN was %d"
argument_list|,
name|cmdsn
argument_list|,
name|cs
operator|->
name|cs_cmdsn
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|request
operator|->
name|ip_bhs
operator|->
name|bhs_opcode
operator|&
name|ISCSI_BHS_OPCODE_IMMEDIATE
operator|)
operator|==
literal|0
condition|)
name|cs
operator|->
name|cs_cmdsn
operator|++
expr_stmt|;
name|CFISCSI_SESSION_UNLOCK
argument_list|(
name|cs
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cfiscsi_pdu_handle
parameter_list|(
name|struct
name|icl_pdu
modifier|*
name|request
parameter_list|)
block|{
name|struct
name|cfiscsi_session
modifier|*
name|cs
decl_stmt|;
name|bool
name|ignore
decl_stmt|;
name|cs
operator|=
name|PDU_SESSION
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|ignore
operator|=
name|cfiscsi_pdu_update_cmdsn
argument_list|(
name|request
argument_list|)
expr_stmt|;
if|if
condition|(
name|ignore
condition|)
block|{
name|icl_pdu_free
argument_list|(
name|request
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Handle the PDU; this includes e.g. receiving the remaining 	 * part of PDU and submitting the SCSI command to CTL 	 * or queueing a reply.  The handling routine is responsible 	 * for freeing the PDU when it's no longer needed. 	 */
switch|switch
condition|(
name|request
operator|->
name|ip_bhs
operator|->
name|bhs_opcode
operator|&
operator|~
name|ISCSI_BHS_OPCODE_IMMEDIATE
condition|)
block|{
case|case
name|ISCSI_BHS_OPCODE_NOP_OUT
case|:
name|cfiscsi_pdu_handle_nop_out
argument_list|(
name|request
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISCSI_BHS_OPCODE_SCSI_COMMAND
case|:
name|cfiscsi_pdu_handle_scsi_command
argument_list|(
name|request
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISCSI_BHS_OPCODE_TASK_REQUEST
case|:
name|cfiscsi_pdu_handle_task_request
argument_list|(
name|request
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISCSI_BHS_OPCODE_SCSI_DATA_OUT
case|:
name|cfiscsi_pdu_handle_data_out
argument_list|(
name|request
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISCSI_BHS_OPCODE_LOGOUT_REQUEST
case|:
name|cfiscsi_pdu_handle_logout_request
argument_list|(
name|request
argument_list|)
expr_stmt|;
break|break;
default|default:
name|CFISCSI_SESSION_WARN
argument_list|(
name|cs
argument_list|,
literal|"received PDU with unsupported "
literal|"opcode 0x%x; dropping connection"
argument_list|,
name|request
operator|->
name|ip_bhs
operator|->
name|bhs_opcode
argument_list|)
expr_stmt|;
name|icl_pdu_free
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|cfiscsi_session_terminate
argument_list|(
name|cs
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cfiscsi_receive_callback
parameter_list|(
name|struct
name|icl_pdu
modifier|*
name|request
parameter_list|)
block|{
name|struct
name|cfiscsi_session
modifier|*
name|cs
decl_stmt|;
name|cs
operator|=
name|PDU_SESSION
argument_list|(
name|request
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ICL_KERNEL_PROXY
if|if
condition|(
name|cs
operator|->
name|cs_waiting_for_ctld
operator|||
name|cs
operator|->
name|cs_login_phase
condition|)
block|{
if|if
condition|(
name|cs
operator|->
name|cs_login_pdu
operator|==
name|NULL
condition|)
name|cs
operator|->
name|cs_login_pdu
operator|=
name|request
expr_stmt|;
else|else
name|icl_pdu_free
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|cv_signal
argument_list|(
operator|&
name|cs
operator|->
name|cs_login_cv
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|cfiscsi_pdu_handle
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cfiscsi_error_callback
parameter_list|(
name|struct
name|icl_conn
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|cfiscsi_session
modifier|*
name|cs
decl_stmt|;
name|cs
operator|=
name|CONN_SESSION
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|CFISCSI_SESSION_WARN
argument_list|(
name|cs
argument_list|,
literal|"connection error; dropping connection"
argument_list|)
expr_stmt|;
name|cfiscsi_session_terminate
argument_list|(
name|cs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cfiscsi_pdu_prepare
parameter_list|(
name|struct
name|icl_pdu
modifier|*
name|response
parameter_list|)
block|{
name|struct
name|cfiscsi_session
modifier|*
name|cs
decl_stmt|;
name|struct
name|iscsi_bhs_scsi_response
modifier|*
name|bhssr
decl_stmt|;
name|bool
name|advance_statsn
init|=
name|true
decl_stmt|;
name|cs
operator|=
name|PDU_SESSION
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|CFISCSI_SESSION_LOCK_ASSERT
argument_list|(
name|cs
argument_list|)
expr_stmt|;
comment|/* 	 * We're only using fields common for all the response 	 * (target -> initiator) PDUs. 	 */
name|bhssr
operator|=
operator|(
expr|struct
name|iscsi_bhs_scsi_response
operator|*
operator|)
name|response
operator|->
name|ip_bhs
expr_stmt|;
comment|/* 	 * 10.8.3: "The StatSN for this connection is not advanced 	 * after this PDU is sent." 	 */
if|if
condition|(
name|bhssr
operator|->
name|bhssr_opcode
operator|==
name|ISCSI_BHS_OPCODE_R2T
condition|)
name|advance_statsn
operator|=
name|false
expr_stmt|;
comment|/* 	 * 10.19.2: "However, when the Initiator Task Tag is set to 0xffffffff, 	 * StatSN for the connection is not advanced after this PDU is sent." 	 */
if|if
condition|(
name|bhssr
operator|->
name|bhssr_opcode
operator|==
name|ISCSI_BHS_OPCODE_NOP_IN
operator|&&
name|bhssr
operator|->
name|bhssr_initiator_task_tag
operator|==
literal|0xffffffff
condition|)
name|advance_statsn
operator|=
name|false
expr_stmt|;
comment|/* 	 * See the comment below - StatSN is not meaningful and must 	 * not be advanced. 	 */
if|if
condition|(
name|bhssr
operator|->
name|bhssr_opcode
operator|==
name|ISCSI_BHS_OPCODE_SCSI_DATA_IN
condition|)
name|advance_statsn
operator|=
name|false
expr_stmt|;
comment|/* 	 * 10.7.3: "The fields StatSN, Status, and Residual Count 	 * only have meaningful content if the S bit is set to 1." 	 */
if|if
condition|(
name|bhssr
operator|->
name|bhssr_opcode
operator|!=
name|ISCSI_BHS_OPCODE_SCSI_DATA_IN
condition|)
name|bhssr
operator|->
name|bhssr_statsn
operator|=
name|htonl
argument_list|(
name|cs
operator|->
name|cs_statsn
argument_list|)
expr_stmt|;
name|bhssr
operator|->
name|bhssr_expcmdsn
operator|=
name|htonl
argument_list|(
name|cs
operator|->
name|cs_cmdsn
argument_list|)
expr_stmt|;
name|bhssr
operator|->
name|bhssr_maxcmdsn
operator|=
name|htonl
argument_list|(
name|cs
operator|->
name|cs_cmdsn
operator|+
name|maxcmdsn_delta
argument_list|)
expr_stmt|;
if|if
condition|(
name|advance_statsn
condition|)
name|cs
operator|->
name|cs_statsn
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cfiscsi_pdu_queue
parameter_list|(
name|struct
name|icl_pdu
modifier|*
name|response
parameter_list|)
block|{
name|struct
name|cfiscsi_session
modifier|*
name|cs
decl_stmt|;
name|cs
operator|=
name|PDU_SESSION
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|CFISCSI_SESSION_LOCK
argument_list|(
name|cs
argument_list|)
expr_stmt|;
name|cfiscsi_pdu_prepare
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|icl_pdu_queue
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|CFISCSI_SESSION_UNLOCK
argument_list|(
name|cs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|cfiscsi_decode_lun
parameter_list|(
name|uint64_t
name|encoded
parameter_list|)
block|{
name|uint8_t
name|lun
index|[
literal|8
index|]
decl_stmt|;
name|uint32_t
name|result
decl_stmt|;
comment|/* 	 * The LUN field in iSCSI PDUs may look like an ordinary 64 bit number, 	 * but is in fact an evil, multidimensional structure defined 	 * in SCSI Architecture Model 5 (SAM-5), section 4.6. 	 */
name|memcpy
argument_list|(
name|lun
argument_list|,
operator|&
name|encoded
argument_list|,
sizeof|sizeof
argument_list|(
name|lun
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|lun
index|[
literal|0
index|]
operator|&
literal|0xC0
condition|)
block|{
case|case
literal|0x00
case|:
if|if
condition|(
operator|(
name|lun
index|[
literal|0
index|]
operator|&
literal|0x3f
operator|)
operator|!=
literal|0
operator|||
name|lun
index|[
literal|2
index|]
operator|!=
literal|0
operator|||
name|lun
index|[
literal|3
index|]
operator|!=
literal|0
operator|||
name|lun
index|[
literal|4
index|]
operator|!=
literal|0
operator|||
name|lun
index|[
literal|5
index|]
operator|!=
literal|0
operator|||
name|lun
index|[
literal|6
index|]
operator|!=
literal|0
operator|||
name|lun
index|[
literal|7
index|]
operator|!=
literal|0
condition|)
block|{
name|CFISCSI_WARN
argument_list|(
literal|"malformed LUN "
literal|"(peripheral device addressing method): 0x%jx"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|encoded
argument_list|)
expr_stmt|;
name|result
operator|=
literal|0xffffffff
expr_stmt|;
break|break;
block|}
name|result
operator|=
name|lun
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
literal|0x40
case|:
if|if
condition|(
name|lun
index|[
literal|2
index|]
operator|!=
literal|0
operator|||
name|lun
index|[
literal|3
index|]
operator|!=
literal|0
operator|||
name|lun
index|[
literal|4
index|]
operator|!=
literal|0
operator|||
name|lun
index|[
literal|5
index|]
operator|!=
literal|0
operator|||
name|lun
index|[
literal|6
index|]
operator|!=
literal|0
operator|||
name|lun
index|[
literal|7
index|]
operator|!=
literal|0
condition|)
block|{
name|CFISCSI_WARN
argument_list|(
literal|"malformed LUN "
literal|"(flat address space addressing method): 0x%jx"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|encoded
argument_list|)
expr_stmt|;
name|result
operator|=
literal|0xffffffff
expr_stmt|;
break|break;
block|}
name|result
operator|=
operator|(
operator|(
name|lun
index|[
literal|0
index|]
operator|&
literal|0x3f
operator|)
operator|<<
literal|8
operator|)
operator|+
name|lun
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
literal|0xC0
case|:
if|if
condition|(
name|lun
index|[
literal|0
index|]
operator|!=
literal|0xD2
operator|||
name|lun
index|[
literal|4
index|]
operator|!=
literal|0
operator|||
name|lun
index|[
literal|5
index|]
operator|!=
literal|0
operator|||
name|lun
index|[
literal|6
index|]
operator|!=
literal|0
operator|||
name|lun
index|[
literal|7
index|]
operator|!=
literal|0
condition|)
block|{
name|CFISCSI_WARN
argument_list|(
literal|"malformed LUN (extended flat "
literal|"address space addressing method): 0x%jx"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|encoded
argument_list|)
expr_stmt|;
name|result
operator|=
literal|0xffffffff
expr_stmt|;
break|break;
block|}
name|result
operator|=
operator|(
name|lun
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|lun
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator|+
name|lun
index|[
literal|3
index|]
expr_stmt|;
default|default:
name|CFISCSI_WARN
argument_list|(
literal|"unsupported LUN format 0x%jx"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|encoded
argument_list|)
expr_stmt|;
name|result
operator|=
literal|0xffffffff
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cfiscsi_pdu_handle_nop_out
parameter_list|(
name|struct
name|icl_pdu
modifier|*
name|request
parameter_list|)
block|{
name|struct
name|cfiscsi_session
modifier|*
name|cs
decl_stmt|;
name|struct
name|iscsi_bhs_nop_out
modifier|*
name|bhsno
decl_stmt|;
name|struct
name|iscsi_bhs_nop_in
modifier|*
name|bhsni
decl_stmt|;
name|struct
name|icl_pdu
modifier|*
name|response
decl_stmt|;
name|void
modifier|*
name|data
init|=
name|NULL
decl_stmt|;
name|size_t
name|datasize
decl_stmt|;
name|int
name|error
decl_stmt|;
name|cs
operator|=
name|PDU_SESSION
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|bhsno
operator|=
operator|(
expr|struct
name|iscsi_bhs_nop_out
operator|*
operator|)
name|request
operator|->
name|ip_bhs
expr_stmt|;
if|if
condition|(
name|bhsno
operator|->
name|bhsno_initiator_task_tag
operator|==
literal|0xffffffff
condition|)
block|{
comment|/* 		 * Nothing to do, iscsi_pdu_update_statsn() already 		 * zeroed the timeout. 		 */
name|icl_pdu_free
argument_list|(
name|request
argument_list|)
expr_stmt|;
return|return;
block|}
name|datasize
operator|=
name|icl_pdu_data_segment_length
argument_list|(
name|request
argument_list|)
expr_stmt|;
if|if
condition|(
name|datasize
operator|>
literal|0
condition|)
block|{
name|data
operator|=
name|malloc
argument_list|(
name|datasize
argument_list|,
name|M_CFISCSI
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
block|{
name|CFISCSI_SESSION_WARN
argument_list|(
name|cs
argument_list|,
literal|"failed to allocate memory; "
literal|"dropping connection"
argument_list|)
expr_stmt|;
name|icl_pdu_free
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|cfiscsi_session_terminate
argument_list|(
name|cs
argument_list|)
expr_stmt|;
return|return;
block|}
name|icl_pdu_get_data
argument_list|(
name|request
argument_list|,
literal|0
argument_list|,
name|data
argument_list|,
name|datasize
argument_list|)
expr_stmt|;
block|}
name|response
operator|=
name|cfiscsi_pdu_new_response
argument_list|(
name|request
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|response
operator|==
name|NULL
condition|)
block|{
name|CFISCSI_SESSION_WARN
argument_list|(
name|cs
argument_list|,
literal|"failed to allocate memory; "
literal|"droppping connection"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|,
name|M_CFISCSI
argument_list|)
expr_stmt|;
name|icl_pdu_free
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|cfiscsi_session_terminate
argument_list|(
name|cs
argument_list|)
expr_stmt|;
return|return;
block|}
name|bhsni
operator|=
operator|(
expr|struct
name|iscsi_bhs_nop_in
operator|*
operator|)
name|response
operator|->
name|ip_bhs
expr_stmt|;
name|bhsni
operator|->
name|bhsni_opcode
operator|=
name|ISCSI_BHS_OPCODE_NOP_IN
expr_stmt|;
name|bhsni
operator|->
name|bhsni_flags
operator|=
literal|0x80
expr_stmt|;
name|bhsni
operator|->
name|bhsni_initiator_task_tag
operator|=
name|bhsno
operator|->
name|bhsno_initiator_task_tag
expr_stmt|;
name|bhsni
operator|->
name|bhsni_target_transfer_tag
operator|=
literal|0xffffffff
expr_stmt|;
if|if
condition|(
name|datasize
operator|>
literal|0
condition|)
block|{
name|error
operator|=
name|icl_pdu_append_data
argument_list|(
name|response
argument_list|,
name|data
argument_list|,
name|datasize
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|CFISCSI_SESSION_WARN
argument_list|(
name|cs
argument_list|,
literal|"failed to allocate memory; "
literal|"dropping connection"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|,
name|M_CFISCSI
argument_list|)
expr_stmt|;
name|icl_pdu_free
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|icl_pdu_free
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|cfiscsi_session_terminate
argument_list|(
name|cs
argument_list|)
expr_stmt|;
return|return;
block|}
name|free
argument_list|(
name|data
argument_list|,
name|M_CFISCSI
argument_list|)
expr_stmt|;
block|}
name|icl_pdu_free
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|cfiscsi_pdu_queue
argument_list|(
name|response
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cfiscsi_pdu_handle_scsi_command
parameter_list|(
name|struct
name|icl_pdu
modifier|*
name|request
parameter_list|)
block|{
name|struct
name|iscsi_bhs_scsi_command
modifier|*
name|bhssc
decl_stmt|;
name|struct
name|cfiscsi_session
modifier|*
name|cs
decl_stmt|;
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|int
name|error
decl_stmt|;
name|cs
operator|=
name|PDU_SESSION
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|bhssc
operator|=
operator|(
expr|struct
name|iscsi_bhs_scsi_command
operator|*
operator|)
name|request
operator|->
name|ip_bhs
expr_stmt|;
comment|//CFISCSI_SESSION_DEBUG(cs, "initiator task tag 0x%x",
comment|//    bhssc->bhssc_initiator_task_tag);
if|if
condition|(
name|request
operator|->
name|ip_data_len
operator|>
literal|0
operator|&&
name|cs
operator|->
name|cs_immediate_data
operator|==
name|false
condition|)
block|{
name|CFISCSI_SESSION_WARN
argument_list|(
name|cs
argument_list|,
literal|"unsolicited data with "
literal|"ImmediateData=No; dropping connection"
argument_list|)
expr_stmt|;
name|icl_pdu_free
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|cfiscsi_session_terminate
argument_list|(
name|cs
argument_list|)
expr_stmt|;
return|return;
block|}
name|io
operator|=
name|ctl_alloc_io
argument_list|(
name|cs
operator|->
name|cs_target
operator|->
name|ct_softc
operator|->
name|port
operator|.
name|ctl_pool_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|==
name|NULL
condition|)
block|{
name|CFISCSI_SESSION_WARN
argument_list|(
name|cs
argument_list|,
literal|"can't allocate ctl_io; "
literal|"dropping connection"
argument_list|)
expr_stmt|;
name|icl_pdu_free
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|cfiscsi_session_terminate
argument_list|(
name|cs
argument_list|)
expr_stmt|;
return|return;
block|}
name|ctl_zero_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_FRONTEND
index|]
operator|.
name|ptr
operator|=
name|request
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|io_type
operator|=
name|CTL_IO_SCSI
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|initid
operator|.
name|id
operator|=
name|cs
operator|->
name|cs_ctl_initid
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
operator|=
name|cs
operator|->
name|cs_target
operator|->
name|ct_softc
operator|->
name|port
operator|.
name|targ_port
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_target
operator|.
name|id
operator|=
literal|0
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_lun
operator|=
name|cfiscsi_decode_lun
argument_list|(
name|bhssc
operator|->
name|bhssc_lun
argument_list|)
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|lun_map_fn
operator|=
name|cfiscsi_map_lun
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|lun_map_arg
operator|=
name|cs
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|tag_num
operator|=
name|bhssc
operator|->
name|bhssc_initiator_task_tag
expr_stmt|;
switch|switch
condition|(
operator|(
name|bhssc
operator|->
name|bhssc_flags
operator|&
name|BHSSC_FLAGS_ATTR
operator|)
condition|)
block|{
case|case
name|BHSSC_FLAGS_ATTR_UNTAGGED
case|:
name|io
operator|->
name|scsiio
operator|.
name|tag_type
operator|=
name|CTL_TAG_UNTAGGED
expr_stmt|;
break|break;
case|case
name|BHSSC_FLAGS_ATTR_SIMPLE
case|:
name|io
operator|->
name|scsiio
operator|.
name|tag_type
operator|=
name|CTL_TAG_SIMPLE
expr_stmt|;
break|break;
case|case
name|BHSSC_FLAGS_ATTR_ORDERED
case|:
name|io
operator|->
name|scsiio
operator|.
name|tag_type
operator|=
name|CTL_TAG_ORDERED
expr_stmt|;
break|break;
case|case
name|BHSSC_FLAGS_ATTR_HOQ
case|:
name|io
operator|->
name|scsiio
operator|.
name|tag_type
operator|=
name|CTL_TAG_HEAD_OF_QUEUE
expr_stmt|;
break|break;
case|case
name|BHSSC_FLAGS_ATTR_ACA
case|:
name|io
operator|->
name|scsiio
operator|.
name|tag_type
operator|=
name|CTL_TAG_ACA
expr_stmt|;
break|break;
default|default:
name|io
operator|->
name|scsiio
operator|.
name|tag_type
operator|=
name|CTL_TAG_UNTAGGED
expr_stmt|;
name|CFISCSI_SESSION_WARN
argument_list|(
name|cs
argument_list|,
literal|"unhandled tag type %d"
argument_list|,
name|bhssc
operator|->
name|bhssc_flags
operator|&
name|BHSSC_FLAGS_ATTR
argument_list|)
expr_stmt|;
break|break;
block|}
name|io
operator|->
name|scsiio
operator|.
name|cdb_len
operator|=
sizeof|sizeof
argument_list|(
name|bhssc
operator|->
name|bhssc_cdb
argument_list|)
expr_stmt|;
comment|/* Which is 16. */
name|memcpy
argument_list|(
name|io
operator|->
name|scsiio
operator|.
name|cdb
argument_list|,
name|bhssc
operator|->
name|bhssc_cdb
argument_list|,
sizeof|sizeof
argument_list|(
name|bhssc
operator|->
name|bhssc_cdb
argument_list|)
argument_list|)
expr_stmt|;
name|refcount_acquire
argument_list|(
operator|&
name|cs
operator|->
name|cs_outstanding_ctl_pdus
argument_list|)
expr_stmt|;
name|error
operator|=
name|ctl_queue
argument_list|(
name|io
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|CTL_RETVAL_COMPLETE
condition|)
block|{
name|CFISCSI_SESSION_WARN
argument_list|(
name|cs
argument_list|,
literal|"ctl_queue() failed; error %d; "
literal|"dropping connection"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ctl_free_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|refcount_release
argument_list|(
operator|&
name|cs
operator|->
name|cs_outstanding_ctl_pdus
argument_list|)
expr_stmt|;
name|icl_pdu_free
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|cfiscsi_session_terminate
argument_list|(
name|cs
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cfiscsi_pdu_handle_task_request
parameter_list|(
name|struct
name|icl_pdu
modifier|*
name|request
parameter_list|)
block|{
name|struct
name|iscsi_bhs_task_management_request
modifier|*
name|bhstmr
decl_stmt|;
name|struct
name|iscsi_bhs_task_management_response
modifier|*
name|bhstmr2
decl_stmt|;
name|struct
name|icl_pdu
modifier|*
name|response
decl_stmt|;
name|struct
name|cfiscsi_session
modifier|*
name|cs
decl_stmt|;
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|int
name|error
decl_stmt|;
name|cs
operator|=
name|PDU_SESSION
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|bhstmr
operator|=
operator|(
expr|struct
name|iscsi_bhs_task_management_request
operator|*
operator|)
name|request
operator|->
name|ip_bhs
expr_stmt|;
name|io
operator|=
name|ctl_alloc_io
argument_list|(
name|cs
operator|->
name|cs_target
operator|->
name|ct_softc
operator|->
name|port
operator|.
name|ctl_pool_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|==
name|NULL
condition|)
block|{
name|CFISCSI_SESSION_WARN
argument_list|(
name|cs
argument_list|,
literal|"can't allocate ctl_io;"
literal|"dropping connection"
argument_list|)
expr_stmt|;
name|icl_pdu_free
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|cfiscsi_session_terminate
argument_list|(
name|cs
argument_list|)
expr_stmt|;
return|return;
block|}
name|ctl_zero_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_FRONTEND
index|]
operator|.
name|ptr
operator|=
name|request
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|io_type
operator|=
name|CTL_IO_TASK
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|initid
operator|.
name|id
operator|=
name|cs
operator|->
name|cs_ctl_initid
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
operator|=
name|cs
operator|->
name|cs_target
operator|->
name|ct_softc
operator|->
name|port
operator|.
name|targ_port
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_target
operator|.
name|id
operator|=
literal|0
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_lun
operator|=
name|cfiscsi_decode_lun
argument_list|(
name|bhstmr
operator|->
name|bhstmr_lun
argument_list|)
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|lun_map_fn
operator|=
name|cfiscsi_map_lun
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|lun_map_arg
operator|=
name|cs
expr_stmt|;
name|io
operator|->
name|taskio
operator|.
name|tag_type
operator|=
name|CTL_TAG_SIMPLE
expr_stmt|;
comment|/* XXX */
switch|switch
condition|(
name|bhstmr
operator|->
name|bhstmr_function
operator|&
operator|~
literal|0x80
condition|)
block|{
case|case
name|BHSTMR_FUNCTION_ABORT_TASK
case|:
if|#
directive|if
literal|0
block|CFISCSI_SESSION_DEBUG(cs, "BHSTMR_FUNCTION_ABORT_TASK");
endif|#
directive|endif
name|io
operator|->
name|taskio
operator|.
name|task_action
operator|=
name|CTL_TASK_ABORT_TASK
expr_stmt|;
name|io
operator|->
name|taskio
operator|.
name|tag_num
operator|=
name|bhstmr
operator|->
name|bhstmr_referenced_task_tag
expr_stmt|;
break|break;
case|case
name|BHSTMR_FUNCTION_LOGICAL_UNIT_RESET
case|:
if|#
directive|if
literal|0
block|CFISCSI_SESSION_DEBUG(cs, "BHSTMR_FUNCTION_LOGICAL_UNIT_RESET");
endif|#
directive|endif
name|io
operator|->
name|taskio
operator|.
name|task_action
operator|=
name|CTL_TASK_LUN_RESET
expr_stmt|;
break|break;
case|case
name|BHSTMR_FUNCTION_TARGET_WARM_RESET
case|:
if|#
directive|if
literal|0
block|CFISCSI_SESSION_DEBUG(cs, "BHSTMR_FUNCTION_TARGET_WARM_RESET");
endif|#
directive|endif
name|io
operator|->
name|taskio
operator|.
name|task_action
operator|=
name|CTL_TASK_TARGET_RESET
expr_stmt|;
break|break;
default|default:
name|CFISCSI_SESSION_DEBUG
argument_list|(
name|cs
argument_list|,
literal|"unsupported function 0x%x"
argument_list|,
name|bhstmr
operator|->
name|bhstmr_function
operator|&
operator|~
literal|0x80
argument_list|)
expr_stmt|;
name|ctl_free_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|response
operator|=
name|cfiscsi_pdu_new_response
argument_list|(
name|request
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|response
operator|==
name|NULL
condition|)
block|{
name|CFISCSI_SESSION_WARN
argument_list|(
name|cs
argument_list|,
literal|"failed to allocate memory; "
literal|"dropping connection"
argument_list|)
expr_stmt|;
name|icl_pdu_free
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|cfiscsi_session_terminate
argument_list|(
name|cs
argument_list|)
expr_stmt|;
return|return;
block|}
name|bhstmr2
operator|=
operator|(
expr|struct
name|iscsi_bhs_task_management_response
operator|*
operator|)
name|response
operator|->
name|ip_bhs
expr_stmt|;
name|bhstmr2
operator|->
name|bhstmr_opcode
operator|=
name|ISCSI_BHS_OPCODE_TASK_RESPONSE
expr_stmt|;
name|bhstmr2
operator|->
name|bhstmr_flags
operator|=
literal|0x80
expr_stmt|;
name|bhstmr2
operator|->
name|bhstmr_response
operator|=
name|BHSTMR_RESPONSE_FUNCTION_NOT_SUPPORTED
expr_stmt|;
name|bhstmr2
operator|->
name|bhstmr_initiator_task_tag
operator|=
name|bhstmr
operator|->
name|bhstmr_initiator_task_tag
expr_stmt|;
name|icl_pdu_free
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|cfiscsi_pdu_queue
argument_list|(
name|response
argument_list|)
expr_stmt|;
return|return;
block|}
name|refcount_acquire
argument_list|(
operator|&
name|cs
operator|->
name|cs_outstanding_ctl_pdus
argument_list|)
expr_stmt|;
name|error
operator|=
name|ctl_queue
argument_list|(
name|io
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|CTL_RETVAL_COMPLETE
condition|)
block|{
name|CFISCSI_SESSION_WARN
argument_list|(
name|cs
argument_list|,
literal|"ctl_queue() failed; error %d; "
literal|"dropping connection"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ctl_free_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|refcount_release
argument_list|(
operator|&
name|cs
operator|->
name|cs_outstanding_ctl_pdus
argument_list|)
expr_stmt|;
name|icl_pdu_free
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|cfiscsi_session_terminate
argument_list|(
name|cs
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bool
name|cfiscsi_handle_data_segment
parameter_list|(
name|struct
name|icl_pdu
modifier|*
name|request
parameter_list|,
name|struct
name|cfiscsi_data_wait
modifier|*
name|cdw
parameter_list|)
block|{
name|struct
name|iscsi_bhs_data_out
modifier|*
name|bhsdo
decl_stmt|;
name|struct
name|cfiscsi_session
modifier|*
name|cs
decl_stmt|;
name|struct
name|ctl_sg_entry
name|ctl_sg_entry
decl_stmt|,
modifier|*
name|ctl_sglist
decl_stmt|;
name|size_t
name|copy_len
decl_stmt|,
name|len
decl_stmt|,
name|off
decl_stmt|,
name|buffer_offset
decl_stmt|;
name|int
name|ctl_sg_count
decl_stmt|;
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|cs
operator|=
name|PDU_SESSION
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|request
operator|->
name|ip_bhs
operator|->
name|bhs_opcode
operator|&
operator|~
name|ISCSI_BHS_OPCODE_IMMEDIATE
operator|)
operator|==
name|ISCSI_BHS_OPCODE_SCSI_DATA_OUT
operator|||
operator|(
name|request
operator|->
name|ip_bhs
operator|->
name|bhs_opcode
operator|&
operator|~
name|ISCSI_BHS_OPCODE_IMMEDIATE
operator|)
operator|==
name|ISCSI_BHS_OPCODE_SCSI_COMMAND
argument_list|,
operator|(
literal|"bad opcode 0x%x"
operator|,
name|request
operator|->
name|ip_bhs
operator|->
name|bhs_opcode
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * We're only using fields common for Data-Out and SCSI Command PDUs. 	 */
name|bhsdo
operator|=
operator|(
expr|struct
name|iscsi_bhs_data_out
operator|*
operator|)
name|request
operator|->
name|ip_bhs
expr_stmt|;
name|io
operator|=
name|cdw
operator|->
name|cdw_ctl_io
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_DATA_MASK
operator|)
operator|!=
name|CTL_FLAG_DATA_IN
argument_list|,
operator|(
literal|"CTL_FLAG_DATA_IN"
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|CFISCSI_SESSION_DEBUG(cs, "received %zd bytes out of %d", 	    request->ip_data_len, io->scsiio.kern_total_len);
endif|#
directive|endif
if|if
condition|(
name|io
operator|->
name|scsiio
operator|.
name|kern_sg_entries
operator|>
literal|0
condition|)
block|{
name|ctl_sglist
operator|=
operator|(
expr|struct
name|ctl_sg_entry
operator|*
operator|)
name|io
operator|->
name|scsiio
operator|.
name|kern_data_ptr
expr_stmt|;
name|ctl_sg_count
operator|=
name|io
operator|->
name|scsiio
operator|.
name|kern_sg_entries
expr_stmt|;
block|}
else|else
block|{
name|ctl_sglist
operator|=
operator|&
name|ctl_sg_entry
expr_stmt|;
name|ctl_sglist
operator|->
name|addr
operator|=
name|io
operator|->
name|scsiio
operator|.
name|kern_data_ptr
expr_stmt|;
name|ctl_sglist
operator|->
name|len
operator|=
name|io
operator|->
name|scsiio
operator|.
name|kern_data_len
expr_stmt|;
name|ctl_sg_count
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|request
operator|->
name|ip_bhs
operator|->
name|bhs_opcode
operator|&
operator|~
name|ISCSI_BHS_OPCODE_IMMEDIATE
operator|)
operator|==
name|ISCSI_BHS_OPCODE_SCSI_DATA_OUT
condition|)
name|buffer_offset
operator|=
name|ntohl
argument_list|(
name|bhsdo
operator|->
name|bhsdo_buffer_offset
argument_list|)
expr_stmt|;
else|else
name|buffer_offset
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|icl_pdu_data_segment_length
argument_list|(
name|request
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure the offset, as sent by the initiator, matches the offset 	 * we're supposed to be at in the scatter-gather list. 	 */
if|if
condition|(
name|buffer_offset
operator|>
name|io
operator|->
name|scsiio
operator|.
name|kern_rel_offset
operator|+
name|io
operator|->
name|scsiio
operator|.
name|ext_data_filled
operator|||
name|buffer_offset
operator|+
name|len
operator|<=
name|io
operator|->
name|scsiio
operator|.
name|kern_rel_offset
operator|+
name|io
operator|->
name|scsiio
operator|.
name|ext_data_filled
condition|)
block|{
name|CFISCSI_SESSION_WARN
argument_list|(
name|cs
argument_list|,
literal|"received bad buffer offset %zd, "
literal|"expected %zd; dropping connection"
argument_list|,
name|buffer_offset
argument_list|,
operator|(
name|size_t
operator|)
name|io
operator|->
name|scsiio
operator|.
name|kern_rel_offset
operator|+
operator|(
name|size_t
operator|)
name|io
operator|->
name|scsiio
operator|.
name|ext_data_filled
argument_list|)
expr_stmt|;
name|ctl_set_data_phase_error
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
name|cfiscsi_session_terminate
argument_list|(
name|cs
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
comment|/* 	 * This is the offset within the PDU data segment, as opposed 	 * to buffer_offset, which is the offset within the task (SCSI 	 * command). 	 */
name|off
operator|=
name|io
operator|->
name|scsiio
operator|.
name|kern_rel_offset
operator|+
name|io
operator|->
name|scsiio
operator|.
name|ext_data_filled
operator|-
name|buffer_offset
expr_stmt|;
comment|/* 	 * Iterate over the scatter/gather segments, filling them with data 	 * from the PDU data segment.  Note that this can get called multiple 	 * times for one SCSI command; the cdw structure holds state for the 	 * scatter/gather list. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|KASSERT
argument_list|(
name|cdw
operator|->
name|cdw_sg_index
operator|<
name|ctl_sg_count
argument_list|,
operator|(
literal|"cdw->cdw_sg_index>= ctl_sg_count"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdw
operator|->
name|cdw_sg_len
operator|==
literal|0
condition|)
block|{
name|cdw
operator|->
name|cdw_sg_addr
operator|=
name|ctl_sglist
index|[
name|cdw
operator|->
name|cdw_sg_index
index|]
operator|.
name|addr
expr_stmt|;
name|cdw
operator|->
name|cdw_sg_len
operator|=
name|ctl_sglist
index|[
name|cdw
operator|->
name|cdw_sg_index
index|]
operator|.
name|len
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|off
operator|<=
name|len
argument_list|,
operator|(
literal|"len> off"
operator|)
argument_list|)
expr_stmt|;
name|copy_len
operator|=
name|len
operator|-
name|off
expr_stmt|;
if|if
condition|(
name|copy_len
operator|>
name|cdw
operator|->
name|cdw_sg_len
condition|)
name|copy_len
operator|=
name|cdw
operator|->
name|cdw_sg_len
expr_stmt|;
name|icl_pdu_get_data
argument_list|(
name|request
argument_list|,
name|off
argument_list|,
name|cdw
operator|->
name|cdw_sg_addr
argument_list|,
name|copy_len
argument_list|)
expr_stmt|;
name|cdw
operator|->
name|cdw_sg_addr
operator|+=
name|copy_len
expr_stmt|;
name|cdw
operator|->
name|cdw_sg_len
operator|-=
name|copy_len
expr_stmt|;
name|off
operator|+=
name|copy_len
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|ext_data_filled
operator|+=
name|copy_len
expr_stmt|;
if|if
condition|(
name|cdw
operator|->
name|cdw_sg_len
operator|==
literal|0
condition|)
block|{
comment|/* 			 * End of current segment. 			 */
if|if
condition|(
name|cdw
operator|->
name|cdw_sg_index
operator|==
name|ctl_sg_count
operator|-
literal|1
condition|)
block|{
comment|/* 				 * Last segment in scatter/gather list. 				 */
break|break;
block|}
name|cdw
operator|->
name|cdw_sg_index
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|off
operator|==
name|len
condition|)
block|{
comment|/* 			 * End of PDU payload. 			 */
break|break;
block|}
block|}
if|if
condition|(
name|len
operator|>
name|off
condition|)
block|{
comment|/* 		 * In case of unsolicited data, it's possible that the buffer 		 * provided by CTL is smaller than negotiated FirstBurstLength. 		 * Just ignore the superfluous data; will ask for them with R2T 		 * on next call to cfiscsi_datamove(). 		 * 		 * This obviously can only happen with SCSI Command PDU.  		 */
if|if
condition|(
operator|(
name|request
operator|->
name|ip_bhs
operator|->
name|bhs_opcode
operator|&
operator|~
name|ISCSI_BHS_OPCODE_IMMEDIATE
operator|)
operator|==
name|ISCSI_BHS_OPCODE_SCSI_COMMAND
condition|)
return|return
operator|(
name|true
operator|)
return|;
name|CFISCSI_SESSION_WARN
argument_list|(
name|cs
argument_list|,
literal|"received too much data: got %zd bytes, "
literal|"expected %zd; dropping connection"
argument_list|,
name|icl_pdu_data_segment_length
argument_list|(
name|request
argument_list|)
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|ctl_set_data_phase_error
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
name|cfiscsi_session_terminate
argument_list|(
name|cs
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
if|if
condition|(
name|io
operator|->
name|scsiio
operator|.
name|ext_data_filled
operator|==
name|io
operator|->
name|scsiio
operator|.
name|kern_data_len
operator|&&
operator|(
name|bhsdo
operator|->
name|bhsdo_flags
operator|&
name|BHSDO_FLAGS_F
operator|)
operator|==
literal|0
condition|)
block|{
name|CFISCSI_SESSION_WARN
argument_list|(
name|cs
argument_list|,
literal|"got the final packet without "
literal|"the F flag; flags = 0x%x; dropping connection"
argument_list|,
name|bhsdo
operator|->
name|bhsdo_flags
argument_list|)
expr_stmt|;
name|ctl_set_data_phase_error
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
name|cfiscsi_session_terminate
argument_list|(
name|cs
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
if|if
condition|(
name|io
operator|->
name|scsiio
operator|.
name|ext_data_filled
operator|!=
name|io
operator|->
name|scsiio
operator|.
name|kern_data_len
operator|&&
operator|(
name|bhsdo
operator|->
name|bhsdo_flags
operator|&
name|BHSDO_FLAGS_F
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|request
operator|->
name|ip_bhs
operator|->
name|bhs_opcode
operator|&
operator|~
name|ISCSI_BHS_OPCODE_IMMEDIATE
operator|)
operator|==
name|ISCSI_BHS_OPCODE_SCSI_DATA_OUT
condition|)
block|{
name|CFISCSI_SESSION_WARN
argument_list|(
name|cs
argument_list|,
literal|"got the final packet, but the "
literal|"transmitted size was %zd bytes instead of %d; "
literal|"dropping connection"
argument_list|,
operator|(
name|size_t
operator|)
name|io
operator|->
name|scsiio
operator|.
name|ext_data_filled
argument_list|,
name|io
operator|->
name|scsiio
operator|.
name|kern_data_len
argument_list|)
expr_stmt|;
name|ctl_set_data_phase_error
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
name|cfiscsi_session_terminate
argument_list|(
name|cs
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
else|else
block|{
comment|/* 			 * For SCSI Command PDU, this just means we need to 			 * solicit more data by sending R2T. 			 */
return|return
operator|(
name|false
operator|)
return|;
block|}
block|}
if|if
condition|(
name|io
operator|->
name|scsiio
operator|.
name|ext_data_filled
operator|==
name|io
operator|->
name|scsiio
operator|.
name|kern_data_len
condition|)
block|{
if|#
directive|if
literal|0
block|CFISCSI_SESSION_DEBUG(cs, "no longer expecting Data-Out with target " 		    "transfer tag 0x%x", cdw->cdw_target_transfer_tag);
endif|#
directive|endif
return|return
operator|(
name|true
operator|)
return|;
block|}
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cfiscsi_pdu_handle_data_out
parameter_list|(
name|struct
name|icl_pdu
modifier|*
name|request
parameter_list|)
block|{
name|struct
name|iscsi_bhs_data_out
modifier|*
name|bhsdo
decl_stmt|;
name|struct
name|cfiscsi_session
modifier|*
name|cs
decl_stmt|;
name|struct
name|cfiscsi_data_wait
modifier|*
name|cdw
init|=
name|NULL
decl_stmt|;
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|bool
name|done
decl_stmt|;
name|cs
operator|=
name|PDU_SESSION
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|bhsdo
operator|=
operator|(
expr|struct
name|iscsi_bhs_data_out
operator|*
operator|)
name|request
operator|->
name|ip_bhs
expr_stmt|;
name|CFISCSI_SESSION_LOCK
argument_list|(
name|cs
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|cdw
argument_list|,
argument|&cs->cs_waiting_for_data_out
argument_list|,
argument|cdw_next
argument_list|)
block|{
if|#
directive|if
literal|0
block|CFISCSI_SESSION_DEBUG(cs, "have ttt 0x%x, itt 0x%x; looking for " 		    "ttt 0x%x, itt 0x%x", 		    bhsdo->bhsdo_target_transfer_tag, 		    bhsdo->bhsdo_initiator_task_tag, 		    cdw->cdw_target_transfer_tag, cdw->cdw_initiator_task_tag));
endif|#
directive|endif
if|if
condition|(
name|bhsdo
operator|->
name|bhsdo_target_transfer_tag
operator|==
name|cdw
operator|->
name|cdw_target_transfer_tag
condition|)
break|break;
block|}
name|CFISCSI_SESSION_UNLOCK
argument_list|(
name|cs
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdw
operator|==
name|NULL
condition|)
block|{
name|CFISCSI_SESSION_WARN
argument_list|(
name|cs
argument_list|,
literal|"data transfer tag 0x%x, initiator task tag "
literal|"0x%x, not found; dropping connection"
argument_list|,
name|bhsdo
operator|->
name|bhsdo_target_transfer_tag
argument_list|,
name|bhsdo
operator|->
name|bhsdo_initiator_task_tag
argument_list|)
expr_stmt|;
name|icl_pdu_free
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|cfiscsi_session_terminate
argument_list|(
name|cs
argument_list|)
expr_stmt|;
return|return;
block|}
name|io
operator|=
name|cdw
operator|->
name|cdw_ctl_io
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_DATA_MASK
operator|)
operator|!=
name|CTL_FLAG_DATA_IN
argument_list|,
operator|(
literal|"CTL_FLAG_DATA_IN"
operator|)
argument_list|)
expr_stmt|;
name|done
operator|=
name|cfiscsi_handle_data_segment
argument_list|(
name|request
argument_list|,
name|cdw
argument_list|)
expr_stmt|;
if|if
condition|(
name|done
condition|)
block|{
name|CFISCSI_SESSION_LOCK
argument_list|(
name|cs
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|cs
operator|->
name|cs_waiting_for_data_out
argument_list|,
name|cdw
argument_list|,
name|cdw_next
argument_list|)
expr_stmt|;
name|CFISCSI_SESSION_UNLOCK
argument_list|(
name|cs
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|cfiscsi_data_wait_zone
argument_list|,
name|cdw
argument_list|)
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|be_move_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
name|icl_pdu_free
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cfiscsi_pdu_handle_logout_request
parameter_list|(
name|struct
name|icl_pdu
modifier|*
name|request
parameter_list|)
block|{
name|struct
name|iscsi_bhs_logout_request
modifier|*
name|bhslr
decl_stmt|;
name|struct
name|iscsi_bhs_logout_response
modifier|*
name|bhslr2
decl_stmt|;
name|struct
name|icl_pdu
modifier|*
name|response
decl_stmt|;
name|struct
name|cfiscsi_session
modifier|*
name|cs
decl_stmt|;
name|cs
operator|=
name|PDU_SESSION
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|bhslr
operator|=
operator|(
expr|struct
name|iscsi_bhs_logout_request
operator|*
operator|)
name|request
operator|->
name|ip_bhs
expr_stmt|;
switch|switch
condition|(
name|bhslr
operator|->
name|bhslr_reason
operator|&
literal|0x7f
condition|)
block|{
case|case
name|BHSLR_REASON_CLOSE_SESSION
case|:
case|case
name|BHSLR_REASON_CLOSE_CONNECTION
case|:
name|response
operator|=
name|cfiscsi_pdu_new_response
argument_list|(
name|request
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|response
operator|==
name|NULL
condition|)
block|{
name|CFISCSI_SESSION_DEBUG
argument_list|(
name|cs
argument_list|,
literal|"failed to allocate memory"
argument_list|)
expr_stmt|;
name|icl_pdu_free
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|cfiscsi_session_terminate
argument_list|(
name|cs
argument_list|)
expr_stmt|;
return|return;
block|}
name|bhslr2
operator|=
operator|(
expr|struct
name|iscsi_bhs_logout_response
operator|*
operator|)
name|response
operator|->
name|ip_bhs
expr_stmt|;
name|bhslr2
operator|->
name|bhslr_opcode
operator|=
name|ISCSI_BHS_OPCODE_LOGOUT_RESPONSE
expr_stmt|;
name|bhslr2
operator|->
name|bhslr_flags
operator|=
literal|0x80
expr_stmt|;
name|bhslr2
operator|->
name|bhslr_response
operator|=
name|BHSLR_RESPONSE_CLOSED_SUCCESSFULLY
expr_stmt|;
name|bhslr2
operator|->
name|bhslr_initiator_task_tag
operator|=
name|bhslr
operator|->
name|bhslr_initiator_task_tag
expr_stmt|;
name|icl_pdu_free
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|cfiscsi_pdu_queue
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|cfiscsi_session_terminate
argument_list|(
name|cs
argument_list|)
expr_stmt|;
break|break;
case|case
name|BHSLR_REASON_REMOVE_FOR_RECOVERY
case|:
name|response
operator|=
name|cfiscsi_pdu_new_response
argument_list|(
name|request
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|response
operator|==
name|NULL
condition|)
block|{
name|CFISCSI_SESSION_WARN
argument_list|(
name|cs
argument_list|,
literal|"failed to allocate memory; dropping connection"
argument_list|)
expr_stmt|;
name|icl_pdu_free
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|cfiscsi_session_terminate
argument_list|(
name|cs
argument_list|)
expr_stmt|;
return|return;
block|}
name|bhslr2
operator|=
operator|(
expr|struct
name|iscsi_bhs_logout_response
operator|*
operator|)
name|response
operator|->
name|ip_bhs
expr_stmt|;
name|bhslr2
operator|->
name|bhslr_opcode
operator|=
name|ISCSI_BHS_OPCODE_LOGOUT_RESPONSE
expr_stmt|;
name|bhslr2
operator|->
name|bhslr_flags
operator|=
literal|0x80
expr_stmt|;
name|bhslr2
operator|->
name|bhslr_response
operator|=
name|BHSLR_RESPONSE_RECOVERY_NOT_SUPPORTED
expr_stmt|;
name|bhslr2
operator|->
name|bhslr_initiator_task_tag
operator|=
name|bhslr
operator|->
name|bhslr_initiator_task_tag
expr_stmt|;
name|icl_pdu_free
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|cfiscsi_pdu_queue
argument_list|(
name|response
argument_list|)
expr_stmt|;
break|break;
default|default:
name|CFISCSI_SESSION_WARN
argument_list|(
name|cs
argument_list|,
literal|"invalid reason 0%x; dropping connection"
argument_list|,
name|bhslr
operator|->
name|bhslr_reason
argument_list|)
expr_stmt|;
name|icl_pdu_free
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|cfiscsi_session_terminate
argument_list|(
name|cs
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cfiscsi_callout
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|icl_pdu
modifier|*
name|cp
decl_stmt|;
name|struct
name|iscsi_bhs_nop_in
modifier|*
name|bhsni
decl_stmt|;
name|struct
name|cfiscsi_session
modifier|*
name|cs
decl_stmt|;
name|cs
operator|=
name|context
expr_stmt|;
if|if
condition|(
name|cs
operator|->
name|cs_terminating
condition|)
return|return;
name|callout_schedule
argument_list|(
operator|&
name|cs
operator|->
name|cs_callout
argument_list|,
literal|1
operator|*
name|hz
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|cs
operator|->
name|cs_timeout
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ICL_KERNEL_PROXY
if|if
condition|(
name|cs
operator|->
name|cs_waiting_for_ctld
operator|||
name|cs
operator|->
name|cs_login_phase
condition|)
block|{
if|if
condition|(
name|cs
operator|->
name|cs_timeout
operator|>
name|login_timeout
condition|)
block|{
name|CFISCSI_SESSION_WARN
argument_list|(
name|cs
argument_list|,
literal|"login timed out after "
literal|"%d seconds; dropping connection"
argument_list|,
name|cs
operator|->
name|cs_timeout
argument_list|)
expr_stmt|;
name|cfiscsi_session_terminate
argument_list|(
name|cs
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
name|cs
operator|->
name|cs_timeout
operator|>=
name|ping_timeout
condition|)
block|{
name|CFISCSI_SESSION_WARN
argument_list|(
name|cs
argument_list|,
literal|"no ping reply (NOP-Out) after %d seconds; "
literal|"dropping connection"
argument_list|,
name|ping_timeout
argument_list|)
expr_stmt|;
name|cfiscsi_session_terminate
argument_list|(
name|cs
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If the ping was reset less than one second ago - which means 	 * that we've received some PDU during the last second - assume 	 * the traffic flows correctly and don't bother sending a NOP-Out. 	 * 	 * (It's 2 - one for one second, and one for incrementing is_timeout 	 * earlier in this routine.) 	 */
if|if
condition|(
name|cs
operator|->
name|cs_timeout
operator|<
literal|2
condition|)
return|return;
name|cp
operator|=
name|icl_pdu_new_bhs
argument_list|(
name|cs
operator|->
name|cs_conn
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|CFISCSI_SESSION_WARN
argument_list|(
name|cs
argument_list|,
literal|"failed to allocate memory"
argument_list|)
expr_stmt|;
return|return;
block|}
name|bhsni
operator|=
operator|(
expr|struct
name|iscsi_bhs_nop_in
operator|*
operator|)
name|cp
operator|->
name|ip_bhs
expr_stmt|;
name|bhsni
operator|->
name|bhsni_opcode
operator|=
name|ISCSI_BHS_OPCODE_NOP_IN
expr_stmt|;
name|bhsni
operator|->
name|bhsni_flags
operator|=
literal|0x80
expr_stmt|;
name|bhsni
operator|->
name|bhsni_initiator_task_tag
operator|=
literal|0xffffffff
expr_stmt|;
name|cfiscsi_pdu_queue
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cfiscsi_session_terminate_tasks
parameter_list|(
name|struct
name|cfiscsi_session
modifier|*
name|cs
parameter_list|)
block|{
name|struct
name|cfiscsi_data_wait
modifier|*
name|cdw
decl_stmt|,
modifier|*
name|tmpcdw
decl_stmt|;
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|int
name|error
decl_stmt|,
name|last
decl_stmt|;
ifdef|#
directive|ifdef
name|notyet
name|io
operator|=
name|ctl_alloc_io
argument_list|(
name|cs
operator|->
name|cs_target
operator|->
name|ct_softc
operator|->
name|port
operator|.
name|ctl_pool_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|==
name|NULL
condition|)
block|{
name|CFISCSI_SESSION_WARN
argument_list|(
name|cs
argument_list|,
literal|"can't allocate ctl_io"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ctl_zero_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_FRONTEND
index|]
operator|.
name|ptr
operator|=
name|NULL
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|io_type
operator|=
name|CTL_IO_TASK
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|initid
operator|.
name|id
operator|=
name|cs
operator|->
name|cs_ctl_initid
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
operator|=
name|cs
operator|->
name|cs_target
operator|->
name|ct_softc
operator|->
name|port
operator|.
name|targ_port
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_target
operator|.
name|id
operator|=
literal|0
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_lun
operator|=
name|lun
expr_stmt|;
name|io
operator|->
name|taskio
operator|.
name|tag_type
operator|=
name|CTL_TAG_SIMPLE
expr_stmt|;
comment|/* XXX */
name|io
operator|->
name|taskio
operator|.
name|task_action
operator|=
name|CTL_TASK_ABORT_TASK_SET
expr_stmt|;
name|error
operator|=
name|ctl_queue
argument_list|(
name|io
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|CTL_RETVAL_COMPLETE
condition|)
block|{
name|CFISCSI_SESSION_WARN
argument_list|(
name|cs
argument_list|,
literal|"ctl_queue() failed; error %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ctl_free_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* 	 * CTL doesn't currently support CTL_TASK_ABORT_TASK_SET, so instead 	 * just iterate over tasks that are waiting for something - data - and 	 * terminate those. 	 */
name|CFISCSI_SESSION_LOCK
argument_list|(
name|cs
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|cdw
argument_list|,
argument|&cs->cs_waiting_for_data_out
argument_list|,
argument|cdw_next
argument_list|,
argument|tmpcdw
argument_list|)
block|{
name|io
operator|=
name|ctl_alloc_io
argument_list|(
name|cs
operator|->
name|cs_target
operator|->
name|ct_softc
operator|->
name|port
operator|.
name|ctl_pool_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|==
name|NULL
condition|)
block|{
name|CFISCSI_SESSION_WARN
argument_list|(
name|cs
argument_list|,
literal|"can't allocate ctl_io"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ctl_zero_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_FRONTEND
index|]
operator|.
name|ptr
operator|=
name|NULL
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|io_type
operator|=
name|CTL_IO_TASK
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|initid
operator|.
name|id
operator|=
name|cs
operator|->
name|cs_ctl_initid
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
operator|=
name|cs
operator|->
name|cs_target
operator|->
name|ct_softc
operator|->
name|port
operator|.
name|targ_port
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_target
operator|.
name|id
operator|=
literal|0
expr_stmt|;
comment|//io->io_hdr.nexus.targ_lun = lun; /* Not needed? */
name|io
operator|->
name|taskio
operator|.
name|tag_type
operator|=
name|CTL_TAG_SIMPLE
expr_stmt|;
comment|/* XXX */
name|io
operator|->
name|taskio
operator|.
name|task_action
operator|=
name|CTL_TASK_ABORT_TASK
expr_stmt|;
name|io
operator|->
name|taskio
operator|.
name|tag_num
operator|=
name|cdw
operator|->
name|cdw_initiator_task_tag
expr_stmt|;
name|error
operator|=
name|ctl_queue
argument_list|(
name|io
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|CTL_RETVAL_COMPLETE
condition|)
block|{
name|CFISCSI_SESSION_WARN
argument_list|(
name|cs
argument_list|,
literal|"ctl_queue() failed; error %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ctl_free_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
literal|0
block|CFISCSI_SESSION_DEBUG(cs, "removing csw for initiator task tag " 		    "0x%x", cdw->cdw_initiator_task_tag);
endif|#
directive|endif
comment|/* 		 * Set nonzero port status; this prevents backends from 		 * assuming that the data transfer actually succeeded 		 * and writing uninitialized data to disk. 		 */
name|cdw
operator|->
name|cdw_ctl_io
operator|->
name|scsiio
operator|.
name|io_hdr
operator|.
name|port_status
operator|=
literal|42
expr_stmt|;
name|cdw
operator|->
name|cdw_ctl_io
operator|->
name|scsiio
operator|.
name|be_move_done
argument_list|(
name|cdw
operator|->
name|cdw_ctl_io
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|cs
operator|->
name|cs_waiting_for_data_out
argument_list|,
name|cdw
argument_list|,
name|cdw_next
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|cfiscsi_data_wait_zone
argument_list|,
name|cdw
argument_list|)
expr_stmt|;
block|}
name|CFISCSI_SESSION_UNLOCK
argument_list|(
name|cs
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Wait for CTL to terminate all the tasks. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|refcount_acquire
argument_list|(
operator|&
name|cs
operator|->
name|cs_outstanding_ctl_pdus
argument_list|)
expr_stmt|;
name|last
operator|=
name|refcount_release
argument_list|(
operator|&
name|cs
operator|->
name|cs_outstanding_ctl_pdus
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
operator|!=
literal|0
condition|)
break|break;
name|CFISCSI_SESSION_WARN
argument_list|(
name|cs
argument_list|,
literal|"waiting for CTL to terminate tasks, "
literal|"%d remaining"
argument_list|,
name|cs
operator|->
name|cs_outstanding_ctl_pdus
argument_list|)
expr_stmt|;
name|pause
argument_list|(
literal|"cfiscsi_terminate"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cfiscsi_maintenance_thread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cfiscsi_session
modifier|*
name|cs
decl_stmt|;
name|cs
operator|=
name|arg
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|CFISCSI_SESSION_LOCK
argument_list|(
name|cs
argument_list|)
expr_stmt|;
if|if
condition|(
name|cs
operator|->
name|cs_terminating
operator|==
name|false
condition|)
name|cv_wait
argument_list|(
operator|&
name|cs
operator|->
name|cs_maintenance_cv
argument_list|,
operator|&
name|cs
operator|->
name|cs_lock
argument_list|)
expr_stmt|;
name|CFISCSI_SESSION_UNLOCK
argument_list|(
name|cs
argument_list|)
expr_stmt|;
if|if
condition|(
name|cs
operator|->
name|cs_terminating
condition|)
block|{
comment|/* 			 * We used to wait up to 30 seconds to deliver queued 			 * PDUs to the initiator.  We also tried hard to deliver 			 * SCSI Responses for the aborted PDUs.  We don't do 			 * that anymore.  We might need to revisit that. 			 */
name|callout_drain
argument_list|(
operator|&
name|cs
operator|->
name|cs_callout
argument_list|)
expr_stmt|;
name|icl_conn_shutdown
argument_list|(
name|cs
operator|->
name|cs_conn
argument_list|)
expr_stmt|;
name|icl_conn_close
argument_list|(
name|cs
operator|->
name|cs_conn
argument_list|)
expr_stmt|;
comment|/* 			 * At this point ICL receive thread is no longer 			 * running; no new tasks can be queued. 			 */
name|cfiscsi_session_terminate_tasks
argument_list|(
name|cs
argument_list|)
expr_stmt|;
name|cfiscsi_session_delete
argument_list|(
name|cs
argument_list|)
expr_stmt|;
name|kthread_exit
argument_list|()
expr_stmt|;
return|return;
block|}
name|CFISCSI_SESSION_DEBUG
argument_list|(
name|cs
argument_list|,
literal|"nothing to do"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cfiscsi_session_terminate
parameter_list|(
name|struct
name|cfiscsi_session
modifier|*
name|cs
parameter_list|)
block|{
if|if
condition|(
name|cs
operator|->
name|cs_terminating
condition|)
return|return;
name|cs
operator|->
name|cs_terminating
operator|=
name|true
expr_stmt|;
name|cv_signal
argument_list|(
operator|&
name|cs
operator|->
name|cs_maintenance_cv
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ICL_KERNEL_PROXY
name|cv_signal
argument_list|(
operator|&
name|cs
operator|->
name|cs_login_cv
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|cfiscsi_session_register_initiator
parameter_list|(
name|struct
name|cfiscsi_session
modifier|*
name|cs
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|cfiscsi_softc
modifier|*
name|softc
decl_stmt|;
name|KASSERT
argument_list|(
name|cs
operator|->
name|cs_ctl_initid
operator|==
operator|-
literal|1
argument_list|,
operator|(
literal|"already registered"
operator|)
argument_list|)
expr_stmt|;
name|softc
operator|=
operator|&
name|cfiscsi_softc
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|softc
operator|->
name|max_initiators
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|softc
operator|->
name|ctl_initids
index|[
name|i
index|]
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|softc
operator|->
name|max_initiators
condition|)
block|{
name|CFISCSI_SESSION_WARN
argument_list|(
name|cs
argument_list|,
literal|"too many concurrent sessions (%d)"
argument_list|,
name|softc
operator|->
name|max_initiators
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|softc
operator|->
name|ctl_initids
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|CFISCSI_SESSION_DEBUG(cs, "adding initiator id %d, max %d", 	    i, softc->max_initiators);
endif|#
directive|endif
name|cs
operator|->
name|cs_ctl_initid
operator|=
name|i
expr_stmt|;
name|error
operator|=
name|ctl_add_initiator
argument_list|(
literal|0x0
argument_list|,
name|softc
operator|->
name|port
operator|.
name|targ_port
argument_list|,
name|cs
operator|->
name|cs_ctl_initid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|CFISCSI_SESSION_WARN
argument_list|(
name|cs
argument_list|,
literal|"ctl_add_initiator failed with error %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|softc
operator|->
name|ctl_initids
index|[
name|cs
operator|->
name|cs_ctl_initid
index|]
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|cs
operator|->
name|cs_ctl_initid
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cfiscsi_session_unregister_initiator
parameter_list|(
name|struct
name|cfiscsi_session
modifier|*
name|cs
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|cfiscsi_softc
modifier|*
name|softc
decl_stmt|;
if|if
condition|(
name|cs
operator|->
name|cs_ctl_initid
operator|==
operator|-
literal|1
condition|)
return|return;
name|softc
operator|=
operator|&
name|cfiscsi_softc
expr_stmt|;
name|error
operator|=
name|ctl_remove_initiator
argument_list|(
name|softc
operator|->
name|port
operator|.
name|targ_port
argument_list|,
name|cs
operator|->
name|cs_ctl_initid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|CFISCSI_SESSION_WARN
argument_list|(
name|cs
argument_list|,
literal|"ctl_remove_initiator failed with error %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|softc
operator|->
name|ctl_initids
index|[
name|cs
operator|->
name|cs_ctl_initid
index|]
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|cs
operator|->
name|cs_ctl_initid
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|cfiscsi_session
modifier|*
name|cfiscsi_session_new
parameter_list|(
name|struct
name|cfiscsi_softc
modifier|*
name|softc
parameter_list|)
block|{
name|struct
name|cfiscsi_session
modifier|*
name|cs
decl_stmt|;
name|int
name|error
decl_stmt|;
name|cs
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cs
argument_list|)
argument_list|,
name|M_CFISCSI
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|cs
operator|==
name|NULL
condition|)
block|{
name|CFISCSI_WARN
argument_list|(
literal|"malloc failed"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|cs
operator|->
name|cs_ctl_initid
operator|=
operator|-
literal|1
expr_stmt|;
name|refcount_init
argument_list|(
operator|&
name|cs
operator|->
name|cs_outstanding_ctl_pdus
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|cs
operator|->
name|cs_waiting_for_data_out
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|cs
operator|->
name|cs_lock
argument_list|,
literal|"cfiscsi_lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|cs
operator|->
name|cs_maintenance_cv
argument_list|,
literal|"cfiscsi_mt"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ICL_KERNEL_PROXY
name|cv_init
argument_list|(
operator|&
name|cs
operator|->
name|cs_login_cv
argument_list|,
literal|"cfiscsi_login"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cs
operator|->
name|cs_conn
operator|=
name|icl_conn_new
argument_list|(
literal|"cfiscsi"
argument_list|,
operator|&
name|cs
operator|->
name|cs_lock
argument_list|)
expr_stmt|;
name|cs
operator|->
name|cs_conn
operator|->
name|ic_receive
operator|=
name|cfiscsi_receive_callback
expr_stmt|;
name|cs
operator|->
name|cs_conn
operator|->
name|ic_error
operator|=
name|cfiscsi_error_callback
expr_stmt|;
name|cs
operator|->
name|cs_conn
operator|->
name|ic_prv0
operator|=
name|cs
expr_stmt|;
name|error
operator|=
name|kthread_add
argument_list|(
name|cfiscsi_maintenance_thread
argument_list|,
name|cs
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cfiscsimt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|CFISCSI_SESSION_WARN
argument_list|(
name|cs
argument_list|,
literal|"kthread_add(9) failed with error %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cs
argument_list|,
name|M_CFISCSI
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|cs
operator|->
name|cs_id
operator|=
name|softc
operator|->
name|last_session_id
operator|+
literal|1
expr_stmt|;
name|softc
operator|->
name|last_session_id
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|softc
operator|->
name|sessions
argument_list|,
name|cs
argument_list|,
name|cs_next
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * Start pinging the initiator. 	 */
name|callout_init
argument_list|(
operator|&
name|cs
operator|->
name|cs_callout
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|cs
operator|->
name|cs_callout
argument_list|,
literal|1
operator|*
name|hz
argument_list|,
name|cfiscsi_callout
argument_list|,
name|cs
argument_list|)
expr_stmt|;
return|return
operator|(
name|cs
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cfiscsi_session_delete
parameter_list|(
name|struct
name|cfiscsi_session
modifier|*
name|cs
parameter_list|)
block|{
name|struct
name|cfiscsi_softc
modifier|*
name|softc
decl_stmt|;
name|softc
operator|=
operator|&
name|cfiscsi_softc
expr_stmt|;
name|KASSERT
argument_list|(
name|cs
operator|->
name|cs_outstanding_ctl_pdus
operator|==
literal|0
argument_list|,
operator|(
literal|"destroying session with outstanding CTL pdus"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|cs
operator|->
name|cs_waiting_for_data_out
argument_list|)
argument_list|,
operator|(
literal|"destroying session with non-empty queue"
operator|)
argument_list|)
expr_stmt|;
name|cfiscsi_session_unregister_initiator
argument_list|(
name|cs
argument_list|)
expr_stmt|;
if|if
condition|(
name|cs
operator|->
name|cs_target
operator|!=
name|NULL
condition|)
name|cfiscsi_target_release
argument_list|(
name|cs
operator|->
name|cs_target
argument_list|)
expr_stmt|;
name|icl_conn_close
argument_list|(
name|cs
operator|->
name|cs_conn
argument_list|)
expr_stmt|;
name|icl_conn_free
argument_list|(
name|cs
operator|->
name|cs_conn
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|softc
operator|->
name|sessions
argument_list|,
name|cs
argument_list|,
name|cs_next
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cs
argument_list|,
name|M_CFISCSI
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|cfiscsi_init
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cfiscsi_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ctl_port
modifier|*
name|port
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|softc
operator|=
operator|&
name|cfiscsi_softc
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|softc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|softc
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|,
literal|"cfiscsi"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ICL_KERNEL_PROXY
name|cv_init
argument_list|(
operator|&
name|softc
operator|->
name|accept_cv
argument_list|,
literal|"cfiscsi_accept"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TAILQ_INIT
argument_list|(
operator|&
name|softc
operator|->
name|sessions
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|softc
operator|->
name|targets
argument_list|)
expr_stmt|;
name|port
operator|=
operator|&
name|softc
operator|->
name|port
expr_stmt|;
name|port
operator|->
name|frontend
operator|=
operator|&
name|cfiscsi_frontend
expr_stmt|;
name|port
operator|->
name|port_type
operator|=
name|CTL_PORT_ISCSI
expr_stmt|;
comment|/* XXX KDM what should the real number be here? */
name|port
operator|->
name|num_requested_ctl_io
operator|=
literal|4096
expr_stmt|;
name|snprintf
argument_list|(
name|softc
operator|->
name|port_name
argument_list|,
sizeof|sizeof
argument_list|(
name|softc
operator|->
name|port_name
argument_list|)
argument_list|,
literal|"iscsi"
argument_list|)
expr_stmt|;
name|port
operator|->
name|port_name
operator|=
name|softc
operator|->
name|port_name
expr_stmt|;
name|port
operator|->
name|port_online
operator|=
name|cfiscsi_online
expr_stmt|;
name|port
operator|->
name|port_offline
operator|=
name|cfiscsi_offline
expr_stmt|;
name|port
operator|->
name|onoff_arg
operator|=
name|softc
expr_stmt|;
name|port
operator|->
name|lun_enable
operator|=
name|cfiscsi_lun_enable
expr_stmt|;
name|port
operator|->
name|lun_disable
operator|=
name|cfiscsi_lun_disable
expr_stmt|;
name|port
operator|->
name|targ_lun_arg
operator|=
name|softc
expr_stmt|;
name|port
operator|->
name|devid
operator|=
name|cfiscsi_devid
expr_stmt|;
name|port
operator|->
name|fe_datamove
operator|=
name|cfiscsi_datamove
expr_stmt|;
name|port
operator|->
name|fe_done
operator|=
name|cfiscsi_done
expr_stmt|;
comment|/* XXX KDM what should we report here? */
comment|/* XXX These should probably be fetched from CTL. */
name|port
operator|->
name|max_targets
operator|=
literal|1
expr_stmt|;
name|port
operator|->
name|max_target_id
operator|=
literal|15
expr_stmt|;
name|retval
operator|=
name|ctl_port_register
argument_list|(
name|port
argument_list|,
comment|/*master_SC*/
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|CFISCSI_WARN
argument_list|(
literal|"ctl_frontend_register() failed with error %d"
argument_list|,
name|retval
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|softc
operator|->
name|max_initiators
operator|=
name|port
operator|->
name|max_initiators
expr_stmt|;
name|cfiscsi_data_wait_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"cfiscsi_data_wait"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cfiscsi_data_wait
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|bailout
label|:
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ICL_KERNEL_PROXY
end_ifdef

begin_function
specifier|static
name|void
name|cfiscsi_accept
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|int
name|portal_id
parameter_list|)
block|{
name|struct
name|cfiscsi_session
modifier|*
name|cs
decl_stmt|;
name|cs
operator|=
name|cfiscsi_session_new
argument_list|(
operator|&
name|cfiscsi_softc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cs
operator|==
name|NULL
condition|)
block|{
name|CFISCSI_WARN
argument_list|(
literal|"failed to create session"
argument_list|)
expr_stmt|;
return|return;
block|}
name|icl_conn_handoff_sock
argument_list|(
name|cs
operator|->
name|cs_conn
argument_list|,
name|so
argument_list|)
expr_stmt|;
name|cs
operator|->
name|cs_initiator_sa
operator|=
name|sa
expr_stmt|;
name|cs
operator|->
name|cs_portal_id
operator|=
name|portal_id
expr_stmt|;
name|cs
operator|->
name|cs_waiting_for_ctld
operator|=
name|true
expr_stmt|;
name|cv_signal
argument_list|(
operator|&
name|cfiscsi_softc
operator|.
name|accept_cv
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|cfiscsi_online
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cfiscsi_softc
modifier|*
name|softc
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|cfiscsi_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|softc
operator|->
name|online
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|ICL_KERNEL_PROXY
if|if
condition|(
name|softc
operator|->
name|listener
operator|!=
name|NULL
condition|)
name|icl_listen_free
argument_list|(
name|softc
operator|->
name|listener
argument_list|)
expr_stmt|;
name|softc
operator|->
name|listener
operator|=
name|icl_listen_new
argument_list|(
name|cfiscsi_accept
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|cfiscsi_offline
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cfiscsi_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|cfiscsi_session
modifier|*
name|cs
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|cfiscsi_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|softc
operator|->
name|online
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|cs
argument_list|,
argument|&softc->sessions
argument_list|,
argument|cs_next
argument_list|)
name|cfiscsi_session_terminate
argument_list|(
name|cs
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ICL_KERNEL_PROXY
name|icl_listen_free
argument_list|(
name|softc
operator|->
name|listener
argument_list|)
expr_stmt|;
name|softc
operator|->
name|listener
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|cfiscsi_ioctl_handoff
parameter_list|(
name|struct
name|ctl_iscsi
modifier|*
name|ci
parameter_list|)
block|{
name|struct
name|cfiscsi_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|cfiscsi_session
modifier|*
name|cs
decl_stmt|;
name|struct
name|cfiscsi_target
modifier|*
name|ct
decl_stmt|;
name|struct
name|ctl_iscsi_handoff_params
modifier|*
name|cihp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|cihp
operator|=
operator|(
expr|struct
name|ctl_iscsi_handoff_params
operator|*
operator|)
operator|&
operator|(
name|ci
operator|->
name|data
operator|)
expr_stmt|;
name|softc
operator|=
operator|&
name|cfiscsi_softc
expr_stmt|;
name|CFISCSI_DEBUG
argument_list|(
literal|"new connection from %s (%s) to %s"
argument_list|,
name|cihp
operator|->
name|initiator_name
argument_list|,
name|cihp
operator|->
name|initiator_addr
argument_list|,
name|cihp
operator|->
name|target_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|online
operator|==
literal|0
condition|)
block|{
name|ci
operator|->
name|status
operator|=
name|CTL_ISCSI_ERROR
expr_stmt|;
name|snprintf
argument_list|(
name|ci
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|ci
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"%s: port offline"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|ct
operator|=
name|cfiscsi_target_find
argument_list|(
name|softc
argument_list|,
name|cihp
operator|->
name|target_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|==
name|NULL
condition|)
block|{
name|ci
operator|->
name|status
operator|=
name|CTL_ISCSI_ERROR
expr_stmt|;
name|snprintf
argument_list|(
name|ci
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|ci
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"%s: target not found"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|ICL_KERNEL_PROXY
if|if
condition|(
name|cihp
operator|->
name|socket
operator|>
literal|0
operator|&&
name|cihp
operator|->
name|connection_id
operator|>
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|ci
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|ci
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"both socket and connection_id set"
argument_list|)
expr_stmt|;
name|ci
operator|->
name|status
operator|=
name|CTL_ISCSI_ERROR
expr_stmt|;
name|cfiscsi_target_release
argument_list|(
name|ct
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cihp
operator|->
name|socket
operator|==
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|cfiscsi_softc
operator|.
name|lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|cs
argument_list|,
argument|&cfiscsi_softc.sessions
argument_list|,
argument|cs_next
argument_list|)
block|{
if|if
condition|(
name|cs
operator|->
name|cs_id
operator|==
name|cihp
operator|->
name|socket
condition|)
break|break;
block|}
if|if
condition|(
name|cs
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|cfiscsi_softc
operator|.
name|lock
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|ci
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|ci
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"connection not found"
argument_list|)
expr_stmt|;
name|ci
operator|->
name|status
operator|=
name|CTL_ISCSI_ERROR
expr_stmt|;
name|cfiscsi_target_release
argument_list|(
name|ct
argument_list|)
expr_stmt|;
return|return;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|cfiscsi_softc
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
name|cs
operator|=
name|cfiscsi_session_new
argument_list|(
name|softc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cs
operator|==
name|NULL
condition|)
block|{
name|ci
operator|->
name|status
operator|=
name|CTL_ISCSI_ERROR
expr_stmt|;
name|snprintf
argument_list|(
name|ci
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|ci
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"%s: cfiscsi_session_new failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|cfiscsi_target_release
argument_list|(
name|ct
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|ICL_KERNEL_PROXY
block|}
endif|#
directive|endif
name|cs
operator|->
name|cs_target
operator|=
name|ct
expr_stmt|;
comment|/* 	 * First PDU of Full Feature phase has the same CmdSN as the last 	 * PDU from the Login Phase received from the initiator.  Thus, 	 * the -1 below. 	 */
name|cs
operator|->
name|cs_portal_group_tag
operator|=
name|cihp
operator|->
name|portal_group_tag
expr_stmt|;
name|cs
operator|->
name|cs_cmdsn
operator|=
name|cihp
operator|->
name|cmdsn
expr_stmt|;
name|cs
operator|->
name|cs_statsn
operator|=
name|cihp
operator|->
name|statsn
expr_stmt|;
name|cs
operator|->
name|cs_max_data_segment_length
operator|=
name|cihp
operator|->
name|max_recv_data_segment_length
expr_stmt|;
name|cs
operator|->
name|cs_max_burst_length
operator|=
name|cihp
operator|->
name|max_burst_length
expr_stmt|;
name|cs
operator|->
name|cs_immediate_data
operator|=
operator|!
operator|!
name|cihp
operator|->
name|immediate_data
expr_stmt|;
if|if
condition|(
name|cihp
operator|->
name|header_digest
operator|==
name|CTL_ISCSI_DIGEST_CRC32C
condition|)
name|cs
operator|->
name|cs_conn
operator|->
name|ic_header_crc32c
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|cihp
operator|->
name|data_digest
operator|==
name|CTL_ISCSI_DIGEST_CRC32C
condition|)
name|cs
operator|->
name|cs_conn
operator|->
name|ic_data_crc32c
operator|=
name|true
expr_stmt|;
name|strlcpy
argument_list|(
name|cs
operator|->
name|cs_initiator_name
argument_list|,
name|cihp
operator|->
name|initiator_name
argument_list|,
sizeof|sizeof
argument_list|(
name|cs
operator|->
name|cs_initiator_name
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|cs
operator|->
name|cs_initiator_addr
argument_list|,
name|cihp
operator|->
name|initiator_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|cs
operator|->
name|cs_initiator_addr
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|cs
operator|->
name|cs_initiator_alias
argument_list|,
name|cihp
operator|->
name|initiator_alias
argument_list|,
sizeof|sizeof
argument_list|(
name|cs
operator|->
name|cs_initiator_alias
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ICL_KERNEL_PROXY
if|if
condition|(
name|cihp
operator|->
name|socket
operator|>
literal|0
condition|)
block|{
endif|#
directive|endif
name|error
operator|=
name|icl_conn_handoff
argument_list|(
name|cs
operator|->
name|cs_conn
argument_list|,
name|cihp
operator|->
name|socket
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|cfiscsi_session_delete
argument_list|(
name|cs
argument_list|)
expr_stmt|;
name|ci
operator|->
name|status
operator|=
name|CTL_ISCSI_ERROR
expr_stmt|;
name|snprintf
argument_list|(
name|ci
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|ci
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"%s: icl_conn_handoff failed with error %d"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|ICL_KERNEL_PROXY
block|}
endif|#
directive|endif
comment|/* 	 * Register initiator with CTL. 	 */
name|cfiscsi_session_register_initiator
argument_list|(
name|cs
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ICL_KERNEL_PROXY
name|cs
operator|->
name|cs_login_phase
operator|=
name|false
expr_stmt|;
comment|/* 	 * First PDU of the Full Feature phase has likely already arrived. 	 * We have to pick it up and execute properly. 	 */
if|if
condition|(
name|cs
operator|->
name|cs_login_pdu
operator|!=
name|NULL
condition|)
block|{
name|CFISCSI_SESSION_DEBUG
argument_list|(
name|cs
argument_list|,
literal|"picking up first PDU"
argument_list|)
expr_stmt|;
name|cfiscsi_pdu_handle
argument_list|(
name|cs
operator|->
name|cs_login_pdu
argument_list|)
expr_stmt|;
name|cs
operator|->
name|cs_login_pdu
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
name|ci
operator|->
name|status
operator|=
name|CTL_ISCSI_OK
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cfiscsi_ioctl_list
parameter_list|(
name|struct
name|ctl_iscsi
modifier|*
name|ci
parameter_list|)
block|{
name|struct
name|ctl_iscsi_list_params
modifier|*
name|cilp
decl_stmt|;
name|struct
name|cfiscsi_session
modifier|*
name|cs
decl_stmt|;
name|struct
name|cfiscsi_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|cilp
operator|=
operator|(
expr|struct
name|ctl_iscsi_list_params
operator|*
operator|)
operator|&
operator|(
name|ci
operator|->
name|data
operator|)
expr_stmt|;
name|softc
operator|=
operator|&
name|cfiscsi_softc
expr_stmt|;
name|sb
operator|=
name|sbuf_new
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|cilp
operator|->
name|alloc_len
argument_list|,
name|SBUF_FIXEDLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
block|{
name|ci
operator|->
name|status
operator|=
name|CTL_ISCSI_ERROR
expr_stmt|;
name|snprintf
argument_list|(
name|ci
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|ci
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"Unable to allocate %d bytes for iSCSI session list"
argument_list|,
name|cilp
operator|->
name|alloc_len
argument_list|)
expr_stmt|;
return|return;
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"<ctlislist>\n"
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|cs
argument_list|,
argument|&softc->sessions
argument_list|,
argument|cs_next
argument_list|)
block|{
ifdef|#
directive|ifdef
name|ICL_KERNEL_PROXY
if|if
condition|(
name|cs
operator|->
name|cs_target
operator|==
name|NULL
condition|)
continue|continue;
endif|#
directive|endif
name|error
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"<connection id=\"%d\">"
literal|"<initiator>%s</initiator>"
literal|"<initiator_addr>%s</initiator_addr>"
literal|"<initiator_alias>%s</initiator_alias>"
literal|"<target>%s</target>"
literal|"<target_alias>%s</target_alias>"
literal|"<header_digest>%s</header_digest>"
literal|"<data_digest>%s</data_digest>"
literal|"<max_data_segment_length>%zd</max_data_segment_length>"
literal|"<immediate_data>%d</immediate_data>"
literal|"<iser>%d</iser>"
literal|"</connection>\n"
argument_list|,
name|cs
operator|->
name|cs_id
argument_list|,
name|cs
operator|->
name|cs_initiator_name
argument_list|,
name|cs
operator|->
name|cs_initiator_addr
argument_list|,
name|cs
operator|->
name|cs_initiator_alias
argument_list|,
name|cs
operator|->
name|cs_target
operator|->
name|ct_name
argument_list|,
name|cs
operator|->
name|cs_target
operator|->
name|ct_alias
argument_list|,
name|cs
operator|->
name|cs_conn
operator|->
name|ic_header_crc32c
condition|?
literal|"CRC32C"
else|:
literal|"None"
argument_list|,
name|cs
operator|->
name|cs_conn
operator|->
name|ic_data_crc32c
condition|?
literal|"CRC32C"
else|:
literal|"None"
argument_list|,
name|cs
operator|->
name|cs_max_data_segment_length
argument_list|,
name|cs
operator|->
name|cs_immediate_data
argument_list|,
name|cs
operator|->
name|cs_conn
operator|->
name|ic_iser
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"</ctlislist>\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|ci
operator|->
name|status
operator|=
name|CTL_ISCSI_LIST_NEED_MORE_SPACE
expr_stmt|;
name|snprintf
argument_list|(
name|ci
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|ci
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"Out of space, %d bytes is too small"
argument_list|,
name|cilp
operator|->
name|alloc_len
argument_list|)
expr_stmt|;
return|return;
block|}
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
name|sbuf_data
argument_list|(
name|sb
argument_list|)
argument_list|,
name|cilp
operator|->
name|conn_xml
argument_list|,
name|sbuf_len
argument_list|(
name|sb
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cilp
operator|->
name|fill_len
operator|=
name|sbuf_len
argument_list|(
name|sb
argument_list|)
operator|+
literal|1
expr_stmt|;
name|ci
operator|->
name|status
operator|=
name|CTL_ISCSI_OK
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cfiscsi_ioctl_terminate
parameter_list|(
name|struct
name|ctl_iscsi
modifier|*
name|ci
parameter_list|)
block|{
name|struct
name|icl_pdu
modifier|*
name|response
decl_stmt|;
name|struct
name|iscsi_bhs_asynchronous_message
modifier|*
name|bhsam
decl_stmt|;
name|struct
name|ctl_iscsi_terminate_params
modifier|*
name|citp
decl_stmt|;
name|struct
name|cfiscsi_session
modifier|*
name|cs
decl_stmt|;
name|struct
name|cfiscsi_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
name|citp
operator|=
operator|(
expr|struct
name|ctl_iscsi_terminate_params
operator|*
operator|)
operator|&
operator|(
name|ci
operator|->
name|data
operator|)
expr_stmt|;
name|softc
operator|=
operator|&
name|cfiscsi_softc
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|cs
argument_list|,
argument|&softc->sessions
argument_list|,
argument|cs_next
argument_list|)
block|{
if|if
condition|(
name|citp
operator|->
name|all
operator|==
literal|0
operator|&&
name|cs
operator|->
name|cs_id
operator|!=
name|citp
operator|->
name|connection_id
operator|&&
name|strcmp
argument_list|(
name|cs
operator|->
name|cs_initiator_name
argument_list|,
name|citp
operator|->
name|initiator_name
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|cs
operator|->
name|cs_initiator_addr
argument_list|,
name|citp
operator|->
name|initiator_addr
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|response
operator|=
name|icl_pdu_new_bhs
argument_list|(
name|cs
operator|->
name|cs_conn
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|response
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Oh well.  Just terminate the connection. 			 */
block|}
else|else
block|{
name|bhsam
operator|=
operator|(
expr|struct
name|iscsi_bhs_asynchronous_message
operator|*
operator|)
name|response
operator|->
name|ip_bhs
expr_stmt|;
name|bhsam
operator|->
name|bhsam_opcode
operator|=
name|ISCSI_BHS_OPCODE_ASYNC_MESSAGE
expr_stmt|;
name|bhsam
operator|->
name|bhsam_flags
operator|=
literal|0x80
expr_stmt|;
name|bhsam
operator|->
name|bhsam_0xffffffff
operator|=
literal|0xffffffff
expr_stmt|;
name|bhsam
operator|->
name|bhsam_async_event
operator|=
name|BHSAM_EVENT_TARGET_TERMINATES_SESSION
expr_stmt|;
name|cfiscsi_pdu_queue
argument_list|(
name|response
argument_list|)
expr_stmt|;
block|}
name|cfiscsi_session_terminate
argument_list|(
name|cs
argument_list|)
expr_stmt|;
name|found
operator|++
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|==
literal|0
condition|)
block|{
name|ci
operator|->
name|status
operator|=
name|CTL_ISCSI_SESSION_NOT_FOUND
expr_stmt|;
name|snprintf
argument_list|(
name|ci
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|ci
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"No matching connections found"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ci
operator|->
name|status
operator|=
name|CTL_ISCSI_OK
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cfiscsi_ioctl_logout
parameter_list|(
name|struct
name|ctl_iscsi
modifier|*
name|ci
parameter_list|)
block|{
name|struct
name|icl_pdu
modifier|*
name|response
decl_stmt|;
name|struct
name|iscsi_bhs_asynchronous_message
modifier|*
name|bhsam
decl_stmt|;
name|struct
name|ctl_iscsi_logout_params
modifier|*
name|cilp
decl_stmt|;
name|struct
name|cfiscsi_session
modifier|*
name|cs
decl_stmt|;
name|struct
name|cfiscsi_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
name|cilp
operator|=
operator|(
expr|struct
name|ctl_iscsi_logout_params
operator|*
operator|)
operator|&
operator|(
name|ci
operator|->
name|data
operator|)
expr_stmt|;
name|softc
operator|=
operator|&
name|cfiscsi_softc
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|cs
argument_list|,
argument|&softc->sessions
argument_list|,
argument|cs_next
argument_list|)
block|{
if|if
condition|(
name|cilp
operator|->
name|all
operator|==
literal|0
operator|&&
name|cs
operator|->
name|cs_id
operator|!=
name|cilp
operator|->
name|connection_id
operator|&&
name|strcmp
argument_list|(
name|cs
operator|->
name|cs_initiator_name
argument_list|,
name|cilp
operator|->
name|initiator_name
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|cs
operator|->
name|cs_initiator_addr
argument_list|,
name|cilp
operator|->
name|initiator_addr
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|response
operator|=
name|icl_pdu_new_bhs
argument_list|(
name|cs
operator|->
name|cs_conn
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|response
operator|==
name|NULL
condition|)
block|{
name|ci
operator|->
name|status
operator|=
name|CTL_ISCSI_ERROR
expr_stmt|;
name|snprintf
argument_list|(
name|ci
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|ci
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"Unable to allocate memory"
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|bhsam
operator|=
operator|(
expr|struct
name|iscsi_bhs_asynchronous_message
operator|*
operator|)
name|response
operator|->
name|ip_bhs
expr_stmt|;
name|bhsam
operator|->
name|bhsam_opcode
operator|=
name|ISCSI_BHS_OPCODE_ASYNC_MESSAGE
expr_stmt|;
name|bhsam
operator|->
name|bhsam_flags
operator|=
literal|0x80
expr_stmt|;
name|bhsam
operator|->
name|bhsam_async_event
operator|=
name|BHSAM_EVENT_TARGET_REQUESTS_LOGOUT
expr_stmt|;
name|bhsam
operator|->
name|bhsam_parameter3
operator|=
name|htons
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|cfiscsi_pdu_queue
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|found
operator|++
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|==
literal|0
condition|)
block|{
name|ci
operator|->
name|status
operator|=
name|CTL_ISCSI_SESSION_NOT_FOUND
expr_stmt|;
name|snprintf
argument_list|(
name|ci
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|ci
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"No matching connections found"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ci
operator|->
name|status
operator|=
name|CTL_ISCSI_OK
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ICL_KERNEL_PROXY
end_ifdef

begin_function
specifier|static
name|void
name|cfiscsi_ioctl_listen
parameter_list|(
name|struct
name|ctl_iscsi
modifier|*
name|ci
parameter_list|)
block|{
name|struct
name|ctl_iscsi_listen_params
modifier|*
name|cilp
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|int
name|error
decl_stmt|;
name|cilp
operator|=
operator|(
expr|struct
name|ctl_iscsi_listen_params
operator|*
operator|)
operator|&
operator|(
name|ci
operator|->
name|data
operator|)
expr_stmt|;
if|if
condition|(
name|cfiscsi_softc
operator|.
name|listener
operator|==
name|NULL
condition|)
block|{
name|CFISCSI_DEBUG
argument_list|(
literal|"no listener"
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|ci
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|ci
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"no listener"
argument_list|)
expr_stmt|;
name|ci
operator|->
name|status
operator|=
name|CTL_ISCSI_ERROR
expr_stmt|;
return|return;
block|}
name|error
operator|=
name|getsockaddr
argument_list|(
operator|&
name|sa
argument_list|,
operator|(
name|void
operator|*
operator|)
name|cilp
operator|->
name|addr
argument_list|,
name|cilp
operator|->
name|addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|CFISCSI_DEBUG
argument_list|(
literal|"getsockaddr, error %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|ci
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|ci
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"getsockaddr failed"
argument_list|)
expr_stmt|;
name|ci
operator|->
name|status
operator|=
name|CTL_ISCSI_ERROR
expr_stmt|;
return|return;
block|}
name|error
operator|=
name|icl_listen_add
argument_list|(
name|cfiscsi_softc
operator|.
name|listener
argument_list|,
name|cilp
operator|->
name|iser
argument_list|,
name|cilp
operator|->
name|domain
argument_list|,
name|cilp
operator|->
name|socktype
argument_list|,
name|cilp
operator|->
name|protocol
argument_list|,
name|sa
argument_list|,
name|cilp
operator|->
name|portal_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|sa
argument_list|,
name|M_SONAME
argument_list|)
expr_stmt|;
name|CFISCSI_DEBUG
argument_list|(
literal|"icl_listen_add, error %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|ci
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|ci
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"icl_listen_add failed, error %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ci
operator|->
name|status
operator|=
name|CTL_ISCSI_ERROR
expr_stmt|;
return|return;
block|}
name|ci
operator|->
name|status
operator|=
name|CTL_ISCSI_OK
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cfiscsi_ioctl_accept
parameter_list|(
name|struct
name|ctl_iscsi
modifier|*
name|ci
parameter_list|)
block|{
name|struct
name|ctl_iscsi_accept_params
modifier|*
name|ciap
decl_stmt|;
name|struct
name|cfiscsi_session
modifier|*
name|cs
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ciap
operator|=
operator|(
expr|struct
name|ctl_iscsi_accept_params
operator|*
operator|)
operator|&
operator|(
name|ci
operator|->
name|data
operator|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|cfiscsi_softc
operator|.
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|cs
argument_list|,
argument|&cfiscsi_softc.sessions
argument_list|,
argument|cs_next
argument_list|)
block|{
if|if
condition|(
name|cs
operator|->
name|cs_waiting_for_ctld
condition|)
break|break;
block|}
if|if
condition|(
name|cs
operator|!=
name|NULL
condition|)
break|break;
name|error
operator|=
name|cv_wait_sig
argument_list|(
operator|&
name|cfiscsi_softc
operator|.
name|accept_cv
argument_list|,
operator|&
name|cfiscsi_softc
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|cfiscsi_softc
operator|.
name|lock
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|ci
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|ci
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"interrupted"
argument_list|)
expr_stmt|;
name|ci
operator|->
name|status
operator|=
name|CTL_ISCSI_ERROR
expr_stmt|;
return|return;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|cfiscsi_softc
operator|.
name|lock
argument_list|)
expr_stmt|;
name|cs
operator|->
name|cs_waiting_for_ctld
operator|=
name|false
expr_stmt|;
name|cs
operator|->
name|cs_login_phase
operator|=
name|true
expr_stmt|;
name|ciap
operator|->
name|connection_id
operator|=
name|cs
operator|->
name|cs_id
expr_stmt|;
name|ciap
operator|->
name|portal_id
operator|=
name|cs
operator|->
name|cs_portal_id
expr_stmt|;
name|ciap
operator|->
name|initiator_addrlen
operator|=
name|cs
operator|->
name|cs_initiator_sa
operator|->
name|sa_len
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
name|cs
operator|->
name|cs_initiator_sa
argument_list|,
name|ciap
operator|->
name|initiator_addr
argument_list|,
name|cs
operator|->
name|cs_initiator_sa
operator|->
name|sa_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|ci
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|ci
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"copyout failed with error %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ci
operator|->
name|status
operator|=
name|CTL_ISCSI_ERROR
expr_stmt|;
return|return;
block|}
name|ci
operator|->
name|status
operator|=
name|CTL_ISCSI_OK
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cfiscsi_ioctl_send
parameter_list|(
name|struct
name|ctl_iscsi
modifier|*
name|ci
parameter_list|)
block|{
name|struct
name|ctl_iscsi_send_params
modifier|*
name|cisp
decl_stmt|;
name|struct
name|cfiscsi_session
modifier|*
name|cs
decl_stmt|;
name|struct
name|icl_pdu
modifier|*
name|ip
decl_stmt|;
name|size_t
name|datalen
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|int
name|error
decl_stmt|;
name|cisp
operator|=
operator|(
expr|struct
name|ctl_iscsi_send_params
operator|*
operator|)
operator|&
operator|(
name|ci
operator|->
name|data
operator|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|cfiscsi_softc
operator|.
name|lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|cs
argument_list|,
argument|&cfiscsi_softc.sessions
argument_list|,
argument|cs_next
argument_list|)
block|{
if|if
condition|(
name|cs
operator|->
name|cs_id
operator|==
name|cisp
operator|->
name|connection_id
condition|)
break|break;
block|}
if|if
condition|(
name|cs
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|cfiscsi_softc
operator|.
name|lock
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|ci
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|ci
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"connection not found"
argument_list|)
expr_stmt|;
name|ci
operator|->
name|status
operator|=
name|CTL_ISCSI_ERROR
expr_stmt|;
return|return;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|cfiscsi_softc
operator|.
name|lock
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (cs->cs_login_phase == false) 		return (EBUSY);
endif|#
directive|endif
if|if
condition|(
name|cs
operator|->
name|cs_terminating
condition|)
block|{
name|snprintf
argument_list|(
name|ci
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|ci
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"connection is terminating"
argument_list|)
expr_stmt|;
name|ci
operator|->
name|status
operator|=
name|CTL_ISCSI_ERROR
expr_stmt|;
return|return;
block|}
name|datalen
operator|=
name|cisp
operator|->
name|data_segment_len
expr_stmt|;
comment|/* 	 * XXX 	 */
comment|//if (datalen> CFISCSI_MAX_DATA_SEGMENT_LENGTH) {
if|if
condition|(
name|datalen
operator|>
literal|65535
condition|)
block|{
name|snprintf
argument_list|(
name|ci
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|ci
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"data segment too big"
argument_list|)
expr_stmt|;
name|ci
operator|->
name|status
operator|=
name|CTL_ISCSI_ERROR
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|datalen
operator|>
literal|0
condition|)
block|{
name|data
operator|=
name|malloc
argument_list|(
name|datalen
argument_list|,
name|M_CFISCSI
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|cisp
operator|->
name|data_segment
argument_list|,
name|data
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|data
argument_list|,
name|M_CFISCSI
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|ci
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|ci
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"copyin error %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ci
operator|->
name|status
operator|=
name|CTL_ISCSI_ERROR
expr_stmt|;
return|return;
block|}
block|}
name|ip
operator|=
name|icl_pdu_new_bhs
argument_list|(
name|cs
operator|->
name|cs_conn
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ip
operator|->
name|ip_bhs
argument_list|,
name|cisp
operator|->
name|bhs
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ip
operator|->
name|ip_bhs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|datalen
operator|>
literal|0
condition|)
block|{
name|icl_pdu_append_data
argument_list|(
name|ip
argument_list|,
name|data
argument_list|,
name|datalen
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|,
name|M_CFISCSI
argument_list|)
expr_stmt|;
block|}
name|CFISCSI_SESSION_LOCK
argument_list|(
name|cs
argument_list|)
expr_stmt|;
name|icl_pdu_queue
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|CFISCSI_SESSION_UNLOCK
argument_list|(
name|cs
argument_list|)
expr_stmt|;
name|ci
operator|->
name|status
operator|=
name|CTL_ISCSI_OK
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cfiscsi_ioctl_receive
parameter_list|(
name|struct
name|ctl_iscsi
modifier|*
name|ci
parameter_list|)
block|{
name|struct
name|ctl_iscsi_receive_params
modifier|*
name|cirp
decl_stmt|;
name|struct
name|cfiscsi_session
modifier|*
name|cs
decl_stmt|;
name|struct
name|icl_pdu
modifier|*
name|ip
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|int
name|error
decl_stmt|;
name|cirp
operator|=
operator|(
expr|struct
name|ctl_iscsi_receive_params
operator|*
operator|)
operator|&
operator|(
name|ci
operator|->
name|data
operator|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|cfiscsi_softc
operator|.
name|lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|cs
argument_list|,
argument|&cfiscsi_softc.sessions
argument_list|,
argument|cs_next
argument_list|)
block|{
if|if
condition|(
name|cs
operator|->
name|cs_id
operator|==
name|cirp
operator|->
name|connection_id
condition|)
break|break;
block|}
if|if
condition|(
name|cs
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|cfiscsi_softc
operator|.
name|lock
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|ci
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|ci
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"connection not found"
argument_list|)
expr_stmt|;
name|ci
operator|->
name|status
operator|=
name|CTL_ISCSI_ERROR
expr_stmt|;
return|return;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|cfiscsi_softc
operator|.
name|lock
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (is->is_login_phase == false) 		return (EBUSY);
endif|#
directive|endif
name|CFISCSI_SESSION_LOCK
argument_list|(
name|cs
argument_list|)
expr_stmt|;
while|while
condition|(
name|cs
operator|->
name|cs_login_pdu
operator|==
name|NULL
operator|&&
name|cs
operator|->
name|cs_terminating
operator|==
name|false
condition|)
block|{
name|error
operator|=
name|cv_wait_sig
argument_list|(
operator|&
name|cs
operator|->
name|cs_login_cv
argument_list|,
operator|&
name|cs
operator|->
name|cs_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|CFISCSI_SESSION_UNLOCK
argument_list|(
name|cs
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|ci
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|ci
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"interrupted by signal"
argument_list|)
expr_stmt|;
name|ci
operator|->
name|status
operator|=
name|CTL_ISCSI_ERROR
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|cs
operator|->
name|cs_terminating
condition|)
block|{
name|CFISCSI_SESSION_UNLOCK
argument_list|(
name|cs
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|ci
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|ci
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"connection terminating"
argument_list|)
expr_stmt|;
name|ci
operator|->
name|status
operator|=
name|CTL_ISCSI_ERROR
expr_stmt|;
return|return;
block|}
name|ip
operator|=
name|cs
operator|->
name|cs_login_pdu
expr_stmt|;
name|cs
operator|->
name|cs_login_pdu
operator|=
name|NULL
expr_stmt|;
name|CFISCSI_SESSION_UNLOCK
argument_list|(
name|cs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_data_len
operator|>
name|cirp
operator|->
name|data_segment_len
condition|)
block|{
name|icl_pdu_free
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|ci
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|ci
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"data segment too big"
argument_list|)
expr_stmt|;
name|ci
operator|->
name|status
operator|=
name|CTL_ISCSI_ERROR
expr_stmt|;
return|return;
block|}
name|copyout
argument_list|(
name|ip
operator|->
name|ip_bhs
argument_list|,
name|cirp
operator|->
name|bhs
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ip
operator|->
name|ip_bhs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_data_len
operator|>
literal|0
condition|)
block|{
name|data
operator|=
name|malloc
argument_list|(
name|ip
operator|->
name|ip_data_len
argument_list|,
name|M_CFISCSI
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|icl_pdu_get_data
argument_list|(
name|ip
argument_list|,
literal|0
argument_list|,
name|data
argument_list|,
name|ip
operator|->
name|ip_data_len
argument_list|)
expr_stmt|;
name|copyout
argument_list|(
name|data
argument_list|,
name|cirp
operator|->
name|data_segment
argument_list|,
name|ip
operator|->
name|ip_data_len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|,
name|M_CFISCSI
argument_list|)
expr_stmt|;
block|}
name|icl_pdu_free
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|ci
operator|->
name|status
operator|=
name|CTL_ISCSI_OK
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !ICL_KERNEL_PROXY */
end_comment

begin_function
specifier|static
name|int
name|cfiscsi_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|ctl_iscsi
modifier|*
name|ci
decl_stmt|;
if|if
condition|(
name|cmd
operator|!=
name|CTL_ISCSI
condition|)
return|return
operator|(
name|ENOTTY
operator|)
return|;
name|ci
operator|=
operator|(
expr|struct
name|ctl_iscsi
operator|*
operator|)
name|addr
expr_stmt|;
switch|switch
condition|(
name|ci
operator|->
name|type
condition|)
block|{
case|case
name|CTL_ISCSI_HANDOFF
case|:
name|cfiscsi_ioctl_handoff
argument_list|(
name|ci
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_ISCSI_LIST
case|:
name|cfiscsi_ioctl_list
argument_list|(
name|ci
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_ISCSI_TERMINATE
case|:
name|cfiscsi_ioctl_terminate
argument_list|(
name|ci
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_ISCSI_LOGOUT
case|:
name|cfiscsi_ioctl_logout
argument_list|(
name|ci
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|ICL_KERNEL_PROXY
case|case
name|CTL_ISCSI_LISTEN
case|:
name|cfiscsi_ioctl_listen
argument_list|(
name|ci
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_ISCSI_ACCEPT
case|:
name|cfiscsi_ioctl_accept
argument_list|(
name|ci
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_ISCSI_SEND
case|:
name|cfiscsi_ioctl_send
argument_list|(
name|ci
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_ISCSI_RECEIVE
case|:
name|cfiscsi_ioctl_receive
argument_list|(
name|ci
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
case|case
name|CTL_ISCSI_LISTEN
case|:
case|case
name|CTL_ISCSI_ACCEPT
case|:
case|case
name|CTL_ISCSI_SEND
case|:
case|case
name|CTL_ISCSI_RECEIVE
case|:
name|ci
operator|->
name|status
operator|=
name|CTL_ISCSI_ERROR
expr_stmt|;
name|snprintf
argument_list|(
name|ci
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|ci
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"%s: CTL compiled without ICL_KERNEL_PROXY"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* !ICL_KERNEL_PROXY */
default|default:
name|ci
operator|->
name|status
operator|=
name|CTL_ISCSI_ERROR
expr_stmt|;
name|snprintf
argument_list|(
name|ci
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|ci
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"%s: invalid iSCSI request type %d"
argument_list|,
name|__func__
argument_list|,
name|ci
operator|->
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cfiscsi_devid
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|int
name|alloc_len
parameter_list|)
block|{
name|struct
name|cfiscsi_session
modifier|*
name|cs
decl_stmt|;
name|struct
name|scsi_vpd_device_id
modifier|*
name|devid_ptr
decl_stmt|;
name|struct
name|scsi_vpd_id_descriptor
modifier|*
name|desc
decl_stmt|,
modifier|*
name|desc1
decl_stmt|,
modifier|*
name|desc2
decl_stmt|,
modifier|*
name|desc3
decl_stmt|,
modifier|*
name|desc4
decl_stmt|;
name|struct
name|scsi_vpd_id_descriptor
modifier|*
name|desc5
decl_stmt|;
name|struct
name|scsi_vpd_id_t10
modifier|*
name|t10id
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
specifier|const
name|struct
name|icl_pdu
modifier|*
name|request
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|size_t
name|data_len
decl_stmt|,
name|devid_len
decl_stmt|,
name|wwnn_len
decl_stmt|,
name|wwpn_len
decl_stmt|,
name|lun_name_len
decl_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LUN
index|]
operator|.
name|ptr
expr_stmt|;
name|request
operator|=
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_FRONTEND
index|]
operator|.
name|ptr
expr_stmt|;
name|cs
operator|=
name|PDU_SESSION
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|wwpn_len
operator|=
name|strlen
argument_list|(
name|cs
operator|->
name|cs_target
operator|->
name|ct_name
argument_list|)
expr_stmt|;
name|wwpn_len
operator|+=
name|strlen
argument_list|(
literal|",t,0x0001"
argument_list|)
expr_stmt|;
name|wwpn_len
operator|+=
literal|1
expr_stmt|;
comment|/* '\0' */
if|if
condition|(
operator|(
name|wwpn_len
operator|%
literal|4
operator|)
operator|!=
literal|0
condition|)
name|wwpn_len
operator|+=
operator|(
literal|4
operator|-
operator|(
name|wwpn_len
operator|%
literal|4
operator|)
operator|)
expr_stmt|;
name|wwnn_len
operator|=
name|strlen
argument_list|(
name|cs
operator|->
name|cs_target
operator|->
name|ct_name
argument_list|)
expr_stmt|;
name|wwnn_len
operator|+=
literal|1
expr_stmt|;
comment|/* '\0' */
if|if
condition|(
operator|(
name|wwnn_len
operator|%
literal|4
operator|)
operator|!=
literal|0
condition|)
name|wwnn_len
operator|+=
operator|(
literal|4
operator|-
operator|(
name|wwnn_len
operator|%
literal|4
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|lun
operator|==
name|NULL
condition|)
block|{
name|devid_len
operator|=
name|CTL_DEVID_MIN_LEN
expr_stmt|;
name|lun_name_len
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|devid_len
operator|=
name|max
argument_list|(
name|CTL_DEVID_MIN_LEN
argument_list|,
name|strnlen
argument_list|(
name|lun
operator|->
name|be_lun
operator|->
name|device_id
argument_list|,
name|CTL_DEVID_LEN
argument_list|)
argument_list|)
expr_stmt|;
name|lun_name_len
operator|=
name|strlen
argument_list|(
name|cs
operator|->
name|cs_target
operator|->
name|ct_name
argument_list|)
expr_stmt|;
name|lun_name_len
operator|+=
name|strlen
argument_list|(
literal|",lun,XXXXXXXX"
argument_list|)
expr_stmt|;
name|lun_name_len
operator|+=
literal|1
expr_stmt|;
comment|/* '\0' */
if|if
condition|(
operator|(
name|lun_name_len
operator|%
literal|4
operator|)
operator|!=
literal|0
condition|)
name|lun_name_len
operator|+=
operator|(
literal|4
operator|-
operator|(
name|lun_name_len
operator|%
literal|4
operator|)
operator|)
expr_stmt|;
block|}
name|data_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_device_id
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_id_descriptor
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_id_t10
argument_list|)
operator|+
name|devid_len
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_id_descriptor
argument_list|)
operator|+
name|lun_name_len
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_id_descriptor
argument_list|)
operator|+
name|wwnn_len
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_id_descriptor
argument_list|)
operator|+
name|wwpn_len
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_id_descriptor
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_id_rel_trgt_port_id
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_id_descriptor
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_id_trgt_port_grp_id
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
name|data_len
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|devid_ptr
operator|=
operator|(
expr|struct
name|scsi_vpd_device_id
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|data_len
operator|<
name|alloc_len
condition|)
block|{
name|ctsio
operator|->
name|residual
operator|=
name|alloc_len
operator|-
name|data_len
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|data_len
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|data_len
expr_stmt|;
block|}
else|else
block|{
name|ctsio
operator|->
name|residual
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|alloc_len
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|alloc_len
expr_stmt|;
block|}
name|ctsio
operator|->
name|kern_data_resid
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
name|desc
operator|=
operator|(
expr|struct
name|scsi_vpd_id_descriptor
operator|*
operator|)
name|devid_ptr
operator|->
name|desc_list
expr_stmt|;
name|t10id
operator|=
operator|(
expr|struct
name|scsi_vpd_id_t10
operator|*
operator|)
operator|&
name|desc
operator|->
name|identifier
index|[
literal|0
index|]
expr_stmt|;
name|desc1
operator|=
operator|(
expr|struct
name|scsi_vpd_id_descriptor
operator|*
operator|)
operator|(
operator|&
name|desc
operator|->
name|identifier
index|[
literal|0
index|]
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_id_t10
argument_list|)
operator|+
name|devid_len
operator|)
expr_stmt|;
name|desc2
operator|=
operator|(
expr|struct
name|scsi_vpd_id_descriptor
operator|*
operator|)
operator|(
operator|&
name|desc1
operator|->
name|identifier
index|[
literal|0
index|]
operator|+
name|lun_name_len
operator|)
expr_stmt|;
name|desc3
operator|=
operator|(
expr|struct
name|scsi_vpd_id_descriptor
operator|*
operator|)
operator|(
operator|&
name|desc2
operator|->
name|identifier
index|[
literal|0
index|]
operator|+
name|wwnn_len
operator|)
expr_stmt|;
name|desc4
operator|=
operator|(
expr|struct
name|scsi_vpd_id_descriptor
operator|*
operator|)
operator|(
operator|&
name|desc3
operator|->
name|identifier
index|[
literal|0
index|]
operator|+
name|wwpn_len
operator|)
expr_stmt|;
name|desc5
operator|=
operator|(
expr|struct
name|scsi_vpd_id_descriptor
operator|*
operator|)
operator|(
operator|&
name|desc4
operator|->
name|identifier
index|[
literal|0
index|]
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_id_rel_trgt_port_id
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|lun
operator|!=
name|NULL
condition|)
name|devid_ptr
operator|->
name|device
operator|=
operator|(
name|SID_QUAL_LU_CONNECTED
operator|<<
literal|5
operator|)
operator||
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
expr_stmt|;
else|else
name|devid_ptr
operator|->
name|device
operator|=
operator|(
name|SID_QUAL_LU_OFFLINE
operator|<<
literal|5
operator|)
operator||
name|T_DIRECT
expr_stmt|;
name|devid_ptr
operator|->
name|page_code
operator|=
name|SVPD_DEVICE_ID
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|data_len
operator|-
literal|4
argument_list|,
name|devid_ptr
operator|->
name|length
argument_list|)
expr_stmt|;
comment|/* 	 * We're using a LUN association here.  i.e., this device ID is a 	 * per-LUN identifier. 	 */
name|desc
operator|->
name|proto_codeset
operator|=
operator|(
name|SCSI_PROTO_ISCSI
operator|<<
literal|4
operator|)
operator||
name|SVPD_ID_CODESET_ASCII
expr_stmt|;
name|desc
operator|->
name|id_type
operator|=
name|SVPD_ID_PIV
operator||
name|SVPD_ID_ASSOC_LUN
operator||
name|SVPD_ID_TYPE_T10
expr_stmt|;
name|desc
operator|->
name|length
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|t10id
argument_list|)
operator|+
name|devid_len
expr_stmt|;
if|if
condition|(
name|lun
operator|==
name|NULL
operator|||
operator|(
name|val
operator|=
name|ctl_get_opt
argument_list|(
name|lun
operator|->
name|be_lun
argument_list|,
literal|"vendor"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t10id
operator|->
name|vendor
argument_list|,
name|CTL_VENDOR
argument_list|,
sizeof|sizeof
argument_list|(
name|t10id
operator|->
name|vendor
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memset
argument_list|(
name|t10id
operator|->
name|vendor
argument_list|,
literal|' '
argument_list|,
sizeof|sizeof
argument_list|(
name|t10id
operator|->
name|vendor
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|t10id
operator|->
name|vendor
argument_list|,
name|val
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|t10id
operator|->
name|vendor
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we've actually got a backend, copy the device id from the 	 * per-LUN data.  Otherwise, set it to all spaces. 	 */
if|if
condition|(
name|lun
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Copy the backend's LUN ID. 		 */
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t10id
operator|->
name|vendor_spec_id
argument_list|,
operator|(
name|char
operator|*
operator|)
name|lun
operator|->
name|be_lun
operator|->
name|device_id
argument_list|,
name|devid_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * No backend, set this to spaces. 		 */
name|memset
argument_list|(
name|t10id
operator|->
name|vendor_spec_id
argument_list|,
literal|0x20
argument_list|,
name|devid_len
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * desc1 is for the unique LUN name. 	 * 	 * XXX: According to SPC-3, LUN must report the same ID through 	 *      all the ports.  The code below, however, reports the 	 *      ID only via iSCSI. 	 */
name|desc1
operator|->
name|proto_codeset
operator|=
operator|(
name|SCSI_PROTO_ISCSI
operator|<<
literal|4
operator|)
operator||
name|SVPD_ID_CODESET_UTF8
expr_stmt|;
name|desc1
operator|->
name|id_type
operator|=
name|SVPD_ID_PIV
operator||
name|SVPD_ID_ASSOC_LUN
operator||
name|SVPD_ID_TYPE_SCSI_NAME
expr_stmt|;
name|desc1
operator|->
name|length
operator|=
name|lun_name_len
expr_stmt|;
if|if
condition|(
name|lun
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Find the per-target LUN number. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_MAX_LUNS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cs
operator|->
name|cs_target
operator|->
name|ct_luns
index|[
name|i
index|]
operator|==
name|lun
operator|->
name|lun
condition|)
break|break;
block|}
name|KASSERT
argument_list|(
name|i
operator|<
name|CTL_MAX_LUNS
argument_list|,
operator|(
literal|"lun %jd not found"
operator|,
operator|(
name|uintmax_t
operator|)
name|lun
operator|->
name|lun
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|snprintf
argument_list|(
name|desc1
operator|->
name|identifier
argument_list|,
name|lun_name_len
argument_list|,
literal|"%s,lun,%d"
argument_list|,
name|cs
operator|->
name|cs_target
operator|->
name|ct_name
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ret
operator|>
literal|0
operator|&&
name|ret
operator|<=
name|lun_name_len
argument_list|,
operator|(
literal|"bad snprintf"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
name|lun_name_len
operator|==
literal|0
argument_list|,
operator|(
literal|"no lun, but lun_name_len != 0"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * desc2 is for the Target Name. 	 */
name|desc2
operator|->
name|proto_codeset
operator|=
operator|(
name|SCSI_PROTO_ISCSI
operator|<<
literal|4
operator|)
operator||
name|SVPD_ID_CODESET_UTF8
expr_stmt|;
name|desc2
operator|->
name|id_type
operator|=
name|SVPD_ID_PIV
operator||
name|SVPD_ID_ASSOC_TARGET
operator||
name|SVPD_ID_TYPE_SCSI_NAME
expr_stmt|;
name|desc2
operator|->
name|length
operator|=
name|wwnn_len
expr_stmt|;
name|snprintf
argument_list|(
name|desc2
operator|->
name|identifier
argument_list|,
name|wwnn_len
argument_list|,
literal|"%s"
argument_list|,
name|cs
operator|->
name|cs_target
operator|->
name|ct_name
argument_list|)
expr_stmt|;
comment|/* 	 * desc3 is for the WWPN which is a port asscociation. 	 */
name|desc3
operator|->
name|proto_codeset
operator|=
operator|(
name|SCSI_PROTO_ISCSI
operator|<<
literal|4
operator|)
operator||
name|SVPD_ID_CODESET_UTF8
expr_stmt|;
name|desc3
operator|->
name|id_type
operator|=
name|SVPD_ID_PIV
operator||
name|SVPD_ID_ASSOC_PORT
operator||
name|SVPD_ID_TYPE_SCSI_NAME
expr_stmt|;
name|desc3
operator|->
name|length
operator|=
name|wwpn_len
expr_stmt|;
name|snprintf
argument_list|(
name|desc3
operator|->
name|identifier
argument_list|,
name|wwpn_len
argument_list|,
literal|"%s,t,0x%4.4x"
argument_list|,
name|cs
operator|->
name|cs_target
operator|->
name|ct_name
argument_list|,
name|cs
operator|->
name|cs_portal_group_tag
argument_list|)
expr_stmt|;
comment|/* 	 * desc3 is for the Relative Target Port(type 4h) identifier 	 */
name|desc4
operator|->
name|proto_codeset
operator|=
operator|(
name|SCSI_PROTO_ISCSI
operator|<<
literal|4
operator|)
operator||
name|SVPD_ID_CODESET_BINARY
expr_stmt|;
name|desc4
operator|->
name|id_type
operator|=
name|SVPD_ID_PIV
operator||
name|SVPD_ID_ASSOC_PORT
operator||
name|SVPD_ID_TYPE_RELTARG
expr_stmt|;
name|desc4
operator|->
name|length
operator|=
literal|4
expr_stmt|;
name|desc4
operator|->
name|identifier
index|[
literal|3
index|]
operator|=
literal|1
expr_stmt|;
comment|/* 	 * desc4 is for the Target Port Group(type 5h) identifier 	 */
name|desc5
operator|->
name|proto_codeset
operator|=
operator|(
name|SCSI_PROTO_ISCSI
operator|<<
literal|4
operator|)
operator||
name|SVPD_ID_CODESET_BINARY
expr_stmt|;
name|desc5
operator|->
name|id_type
operator|=
name|SVPD_ID_PIV
operator||
name|SVPD_ID_ASSOC_PORT
operator||
name|SVPD_ID_TYPE_TPORTGRP
expr_stmt|;
name|desc5
operator|->
name|length
operator|=
literal|4
expr_stmt|;
name|desc5
operator|->
name|identifier
index|[
literal|3
index|]
operator|=
literal|1
expr_stmt|;
name|ctsio
operator|->
name|scsi_status
operator|=
name|SCSI_STATUS_OK
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cfiscsi_target_hold
parameter_list|(
name|struct
name|cfiscsi_target
modifier|*
name|ct
parameter_list|)
block|{
name|refcount_acquire
argument_list|(
operator|&
name|ct
operator|->
name|ct_refcount
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cfiscsi_target_release
parameter_list|(
name|struct
name|cfiscsi_target
modifier|*
name|ct
parameter_list|)
block|{
name|struct
name|cfiscsi_softc
modifier|*
name|softc
decl_stmt|;
name|softc
operator|=
name|ct
operator|->
name|ct_softc
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|refcount_release
argument_list|(
operator|&
name|ct
operator|->
name|ct_refcount
argument_list|)
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|softc
operator|->
name|targets
argument_list|,
name|ct
argument_list|,
name|ct_next
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ct
argument_list|,
name|M_CFISCSI
argument_list|)
expr_stmt|;
return|return;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|cfiscsi_target
modifier|*
name|cfiscsi_target_find
parameter_list|(
name|struct
name|cfiscsi_softc
modifier|*
name|softc
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|cfiscsi_target
modifier|*
name|ct
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ct
argument_list|,
argument|&softc->targets
argument_list|,
argument|ct_next
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|ct
operator|->
name|ct_name
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|cfiscsi_target_hold
argument_list|(
name|ct
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ct
operator|)
return|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|cfiscsi_target
modifier|*
name|cfiscsi_target_find_or_create
parameter_list|(
name|struct
name|cfiscsi_softc
modifier|*
name|softc
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|alias
parameter_list|)
block|{
name|struct
name|cfiscsi_target
modifier|*
name|ct
decl_stmt|,
modifier|*
name|newct
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|strlen
argument_list|(
name|name
argument_list|)
operator|>=
name|CTL_ISCSI_NAME_LEN
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|newct
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|newct
argument_list|)
argument_list|,
name|M_CFISCSI
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ct
argument_list|,
argument|&softc->targets
argument_list|,
argument|ct_next
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|ct
operator|->
name|ct_name
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|cfiscsi_target_hold
argument_list|(
name|ct
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newct
argument_list|,
name|M_CFISCSI
argument_list|)
expr_stmt|;
return|return
operator|(
name|ct
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_MAX_LUNS
condition|;
name|i
operator|++
control|)
name|newct
operator|->
name|ct_luns
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|strlcpy
argument_list|(
name|newct
operator|->
name|ct_name
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|newct
operator|->
name|ct_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|alias
operator|!=
name|NULL
condition|)
name|strlcpy
argument_list|(
name|newct
operator|->
name|ct_alias
argument_list|,
name|alias
argument_list|,
sizeof|sizeof
argument_list|(
name|newct
operator|->
name|ct_alias
argument_list|)
argument_list|)
expr_stmt|;
name|refcount_init
argument_list|(
operator|&
name|newct
operator|->
name|ct_refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|newct
operator|->
name|ct_softc
operator|=
name|softc
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|softc
operator|->
name|targets
argument_list|,
name|newct
argument_list|,
name|ct_next
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|newct
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Takes LUN from the target space and returns LUN from the CTL space.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|cfiscsi_map_lun
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint32_t
name|lun
parameter_list|)
block|{
name|struct
name|cfiscsi_session
modifier|*
name|cs
decl_stmt|;
name|cs
operator|=
name|arg
expr_stmt|;
if|if
condition|(
name|lun
operator|>=
name|CTL_MAX_LUNS
condition|)
block|{
name|CFISCSI_DEBUG
argument_list|(
literal|"requested lun number %d is higher "
literal|"than maximum %d"
argument_list|,
name|lun
argument_list|,
name|CTL_MAX_LUNS
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0xffffffff
operator|)
return|;
block|}
if|if
condition|(
name|cs
operator|->
name|cs_target
operator|->
name|ct_luns
index|[
name|lun
index|]
operator|<
literal|0
condition|)
return|return
operator|(
literal|0xffffffff
operator|)
return|;
return|return
operator|(
name|cs
operator|->
name|cs_target
operator|->
name|ct_luns
index|[
name|lun
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cfiscsi_target_set_lun
parameter_list|(
name|struct
name|cfiscsi_target
modifier|*
name|ct
parameter_list|,
name|unsigned
name|long
name|lun_id
parameter_list|,
name|unsigned
name|long
name|ctl_lun_id
parameter_list|)
block|{
if|if
condition|(
name|lun_id
operator|>=
name|CTL_MAX_LUNS
condition|)
block|{
name|CFISCSI_WARN
argument_list|(
literal|"requested lun number %ld is higher "
literal|"than maximum %d"
argument_list|,
name|lun_id
argument_list|,
name|CTL_MAX_LUNS
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ct
operator|->
name|ct_luns
index|[
name|lun_id
index|]
operator|>=
literal|0
condition|)
block|{
comment|/* 		 * CTL calls cfiscsi_lun_enable() twice for each LUN - once 		 * when the LUN is created, and a second time just before 		 * the port is brought online; don't emit warnings 		 * for that case. 		 */
if|if
condition|(
name|ct
operator|->
name|ct_luns
index|[
name|lun_id
index|]
operator|==
name|ctl_lun_id
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|CFISCSI_WARN
argument_list|(
literal|"lun %ld already allocated"
argument_list|,
name|lun_id
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|#
directive|if
literal|0
block|CFISCSI_DEBUG("adding mapping for lun %ld, target %s " 	    "to ctl lun %ld", lun_id, ct->ct_name, ctl_lun_id);
endif|#
directive|endif
name|ct
operator|->
name|ct_luns
index|[
name|lun_id
index|]
operator|=
name|ctl_lun_id
expr_stmt|;
name|cfiscsi_target_hold
argument_list|(
name|ct
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cfiscsi_target_unset_lun
parameter_list|(
name|struct
name|cfiscsi_target
modifier|*
name|ct
parameter_list|,
name|unsigned
name|long
name|lun_id
parameter_list|)
block|{
if|if
condition|(
name|ct
operator|->
name|ct_luns
index|[
name|lun_id
index|]
operator|<
literal|0
condition|)
block|{
name|CFISCSI_WARN
argument_list|(
literal|"lun %ld not allocated"
argument_list|,
name|lun_id
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ct
operator|->
name|ct_luns
index|[
name|lun_id
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|cfiscsi_target_release
argument_list|(
name|ct
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cfiscsi_lun_enable
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ctl_id
name|target_id
parameter_list|,
name|int
name|lun_id
parameter_list|)
block|{
name|struct
name|cfiscsi_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|cfiscsi_target
modifier|*
name|ct
decl_stmt|;
specifier|const
name|char
modifier|*
name|target
init|=
name|NULL
decl_stmt|,
modifier|*
name|target_alias
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|lun
init|=
name|NULL
decl_stmt|;
name|unsigned
name|long
name|tmp
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|cfiscsi_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|target
operator|=
name|ctl_get_opt
argument_list|(
name|control_softc
operator|->
name|ctl_luns
index|[
name|lun_id
index|]
operator|->
name|be_lun
argument_list|,
literal|"cfiscsi_target"
argument_list|)
expr_stmt|;
name|target_alias
operator|=
name|ctl_get_opt
argument_list|(
name|control_softc
operator|->
name|ctl_luns
index|[
name|lun_id
index|]
operator|->
name|be_lun
argument_list|,
literal|"cfiscsi_target_alias"
argument_list|)
expr_stmt|;
name|lun
operator|=
name|ctl_get_opt
argument_list|(
name|control_softc
operator|->
name|ctl_luns
index|[
name|lun_id
index|]
operator|->
name|be_lun
argument_list|,
literal|"cfiscsi_lun"
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
name|NULL
operator|&&
name|lun
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|target
operator|==
name|NULL
operator|||
name|lun
operator|==
name|NULL
condition|)
block|{
name|CFISCSI_WARN
argument_list|(
literal|"lun added with cfiscsi_target, but without "
literal|"cfiscsi_lun, or the other way around; ignoring"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ct
operator|=
name|cfiscsi_target_find_or_create
argument_list|(
name|softc
argument_list|,
name|target
argument_list|,
name|target_alias
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|==
name|NULL
condition|)
block|{
name|CFISCSI_WARN
argument_list|(
literal|"failed to create target \"%s\""
argument_list|,
name|target
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|tmp
operator|=
name|strtoul
argument_list|(
name|lun
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|cfiscsi_target_set_lun
argument_list|(
name|ct
argument_list|,
name|tmp
argument_list|,
name|lun_id
argument_list|)
expr_stmt|;
name|cfiscsi_target_release
argument_list|(
name|ct
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cfiscsi_lun_disable
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ctl_id
name|target_id
parameter_list|,
name|int
name|lun_id
parameter_list|)
block|{
name|struct
name|cfiscsi_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|cfiscsi_target
modifier|*
name|ct
decl_stmt|;
name|int
name|i
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|cfiscsi_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ct
argument_list|,
argument|&softc->targets
argument_list|,
argument|ct_next
argument_list|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_MAX_LUNS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ct
operator|->
name|ct_luns
index|[
name|i
index|]
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|ct
operator|->
name|ct_luns
index|[
name|i
index|]
operator|!=
name|lun_id
condition|)
continue|continue;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|cfiscsi_target_unset_lun
argument_list|(
name|ct
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cfiscsi_datamove_in
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|cfiscsi_session
modifier|*
name|cs
decl_stmt|;
name|struct
name|icl_pdu
modifier|*
name|request
decl_stmt|,
modifier|*
name|response
decl_stmt|;
specifier|const
name|struct
name|iscsi_bhs_scsi_command
modifier|*
name|bhssc
decl_stmt|;
name|struct
name|iscsi_bhs_data_in
modifier|*
name|bhsdi
decl_stmt|;
name|struct
name|ctl_sg_entry
name|ctl_sg_entry
decl_stmt|,
modifier|*
name|ctl_sglist
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|expected_len
decl_stmt|,
name|sg_len
decl_stmt|,
name|buffer_offset
decl_stmt|;
specifier|const
name|char
modifier|*
name|sg_addr
decl_stmt|;
name|int
name|ctl_sg_count
decl_stmt|,
name|error
decl_stmt|,
name|i
decl_stmt|;
name|request
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_FRONTEND
index|]
operator|.
name|ptr
expr_stmt|;
name|cs
operator|=
name|PDU_SESSION
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|bhssc
operator|=
operator|(
specifier|const
expr|struct
name|iscsi_bhs_scsi_command
operator|*
operator|)
name|request
operator|->
name|ip_bhs
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|bhssc
operator|->
name|bhssc_opcode
operator|&
operator|~
name|ISCSI_BHS_OPCODE_IMMEDIATE
operator|)
operator|==
name|ISCSI_BHS_OPCODE_SCSI_COMMAND
argument_list|,
operator|(
literal|"bhssc->bhssc_opcode != ISCSI_BHS_OPCODE_SCSI_COMMAND"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|scsiio
operator|.
name|kern_sg_entries
operator|>
literal|0
condition|)
block|{
name|ctl_sglist
operator|=
operator|(
expr|struct
name|ctl_sg_entry
operator|*
operator|)
name|io
operator|->
name|scsiio
operator|.
name|kern_data_ptr
expr_stmt|;
name|ctl_sg_count
operator|=
name|io
operator|->
name|scsiio
operator|.
name|kern_sg_entries
expr_stmt|;
block|}
else|else
block|{
name|ctl_sglist
operator|=
operator|&
name|ctl_sg_entry
expr_stmt|;
name|ctl_sglist
operator|->
name|addr
operator|=
name|io
operator|->
name|scsiio
operator|.
name|kern_data_ptr
expr_stmt|;
name|ctl_sglist
operator|->
name|len
operator|=
name|io
operator|->
name|scsiio
operator|.
name|kern_data_len
expr_stmt|;
name|ctl_sg_count
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * This is the total amount of data to be transferred within the current 	 * SCSI command.  We need to record it so that we can properly report 	 * underflow/underflow. 	 */
name|PDU_TOTAL_TRANSFER_LEN
argument_list|(
name|request
argument_list|)
operator|=
name|io
operator|->
name|scsiio
operator|.
name|kern_total_len
expr_stmt|;
comment|/* 	 * This is the offset within the current SCSI command; for the first 	 * call to cfiscsi_datamove() it will be 0, and for subsequent ones 	 * it will be the sum of lengths of previous ones. 	 */
name|buffer_offset
operator|=
name|io
operator|->
name|scsiio
operator|.
name|kern_rel_offset
expr_stmt|;
comment|/* 	 * This is the transfer length expected by the initiator.  In theory, 	 * it could be different from the correct amount of data from the SCSI 	 * point of view, even if that doesn't make any sense. 	 */
name|expected_len
operator|=
name|ntohl
argument_list|(
name|bhssc
operator|->
name|bhssc_expected_data_transfer_length
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (expected_len != io->scsiio.kern_total_len) { 		CFISCSI_SESSION_DEBUG(cs, "expected transfer length %zd, " 		    "actual length %zd", expected_len, 		    (size_t)io->scsiio.kern_total_len); 	}
endif|#
directive|endif
if|if
condition|(
name|buffer_offset
operator|>=
name|expected_len
condition|)
block|{
if|#
directive|if
literal|0
block|CFISCSI_SESSION_DEBUG(cs, "buffer_offset = %zd, " 		    "already sent the expected len", buffer_offset);
endif|#
directive|endif
name|io
operator|->
name|scsiio
operator|.
name|be_move_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
return|return;
block|}
name|i
operator|=
literal|0
expr_stmt|;
name|sg_addr
operator|=
name|NULL
expr_stmt|;
name|sg_len
operator|=
literal|0
expr_stmt|;
name|response
operator|=
name|NULL
expr_stmt|;
name|bhsdi
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|response
operator|==
name|NULL
condition|)
block|{
name|response
operator|=
name|cfiscsi_pdu_new_response
argument_list|(
name|request
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|response
operator|==
name|NULL
condition|)
block|{
name|CFISCSI_SESSION_WARN
argument_list|(
name|cs
argument_list|,
literal|"failed to "
literal|"allocate memory; dropping connection"
argument_list|)
expr_stmt|;
name|ctl_set_busy
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|be_move_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|cfiscsi_session_terminate
argument_list|(
name|cs
argument_list|)
expr_stmt|;
return|return;
block|}
name|bhsdi
operator|=
operator|(
expr|struct
name|iscsi_bhs_data_in
operator|*
operator|)
name|response
operator|->
name|ip_bhs
expr_stmt|;
name|bhsdi
operator|->
name|bhsdi_opcode
operator|=
name|ISCSI_BHS_OPCODE_SCSI_DATA_IN
expr_stmt|;
name|bhsdi
operator|->
name|bhsdi_initiator_task_tag
operator|=
name|bhssc
operator|->
name|bhssc_initiator_task_tag
expr_stmt|;
name|bhsdi
operator|->
name|bhsdi_datasn
operator|=
name|htonl
argument_list|(
name|PDU_EXPDATASN
argument_list|(
name|request
argument_list|)
argument_list|)
expr_stmt|;
name|PDU_EXPDATASN
argument_list|(
name|request
argument_list|)
operator|++
expr_stmt|;
name|bhsdi
operator|->
name|bhsdi_buffer_offset
operator|=
name|htonl
argument_list|(
name|buffer_offset
argument_list|)
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|i
operator|<
name|ctl_sg_count
argument_list|,
operator|(
literal|"i>= ctl_sg_count"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sg_len
operator|==
literal|0
condition|)
block|{
name|sg_addr
operator|=
name|ctl_sglist
index|[
name|i
index|]
operator|.
name|addr
expr_stmt|;
name|sg_len
operator|=
name|ctl_sglist
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
name|KASSERT
argument_list|(
name|sg_len
operator|>
literal|0
argument_list|,
operator|(
literal|"sg_len<= 0"
operator|)
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
name|sg_len
expr_stmt|;
comment|/* 		 * Truncate to maximum data segment length. 		 */
name|KASSERT
argument_list|(
name|response
operator|->
name|ip_data_len
operator|<
name|cs
operator|->
name|cs_max_data_segment_length
argument_list|,
operator|(
literal|"ip_data_len %zd>= max_data_segment_length %zd"
operator|,
name|response
operator|->
name|ip_data_len
operator|,
name|cs
operator|->
name|cs_max_data_segment_length
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|response
operator|->
name|ip_data_len
operator|+
name|len
operator|>
name|cs
operator|->
name|cs_max_data_segment_length
condition|)
block|{
name|len
operator|=
name|cs
operator|->
name|cs_max_data_segment_length
operator|-
name|response
operator|->
name|ip_data_len
expr_stmt|;
name|KASSERT
argument_list|(
name|len
operator|<=
name|sg_len
argument_list|,
operator|(
literal|"len %zd> sg_len %zd"
operator|,
name|len
operator|,
name|sg_len
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Truncate to expected data transfer length. 		 */
name|KASSERT
argument_list|(
name|buffer_offset
operator|+
name|response
operator|->
name|ip_data_len
operator|<
name|expected_len
argument_list|,
operator|(
literal|"buffer_offset %zd + ip_data_len %zd>= expected_len %zd"
operator|,
name|buffer_offset
operator|,
name|response
operator|->
name|ip_data_len
operator|,
name|expected_len
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer_offset
operator|+
name|response
operator|->
name|ip_data_len
operator|+
name|len
operator|>
name|expected_len
condition|)
block|{
name|CFISCSI_SESSION_DEBUG
argument_list|(
name|cs
argument_list|,
literal|"truncating from %zd "
literal|"to expected data transfer length %zd"
argument_list|,
name|buffer_offset
operator|+
name|response
operator|->
name|ip_data_len
operator|+
name|len
argument_list|,
name|expected_len
argument_list|)
expr_stmt|;
name|len
operator|=
name|expected_len
operator|-
operator|(
name|buffer_offset
operator|+
name|response
operator|->
name|ip_data_len
operator|)
expr_stmt|;
name|KASSERT
argument_list|(
name|len
operator|<=
name|sg_len
argument_list|,
operator|(
literal|"len %zd> sg_len %zd"
operator|,
name|len
operator|,
name|sg_len
operator|)
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|icl_pdu_append_data
argument_list|(
name|response
argument_list|,
name|sg_addr
argument_list|,
name|len
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|CFISCSI_SESSION_WARN
argument_list|(
name|cs
argument_list|,
literal|"failed to "
literal|"allocate memory; dropping connection"
argument_list|)
expr_stmt|;
name|icl_pdu_free
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|ctl_set_busy
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|be_move_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|cfiscsi_session_terminate
argument_list|(
name|cs
argument_list|)
expr_stmt|;
return|return;
block|}
name|sg_addr
operator|+=
name|len
expr_stmt|;
name|sg_len
operator|-=
name|len
expr_stmt|;
name|KASSERT
argument_list|(
name|buffer_offset
operator|+
name|request
operator|->
name|ip_data_len
operator|<=
name|expected_len
argument_list|,
operator|(
literal|"buffer_offset %zd + ip_data_len %zd> expected_len %zd"
operator|,
name|buffer_offset
operator|,
name|request
operator|->
name|ip_data_len
operator|,
name|expected_len
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer_offset
operator|+
name|request
operator|->
name|ip_data_len
operator|==
name|expected_len
condition|)
block|{
comment|/* 			 * Already have the amount of data the initiator wanted. 			 */
break|break;
block|}
if|if
condition|(
name|sg_len
operator|==
literal|0
condition|)
block|{
comment|/* 			 * End of scatter-gather segment; 			 * proceed to the next one... 			 */
if|if
condition|(
name|i
operator|==
name|ctl_sg_count
operator|-
literal|1
condition|)
block|{
comment|/* 				 * ... unless this was the last one. 				 */
break|break;
block|}
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|response
operator|->
name|ip_data_len
operator|==
name|cs
operator|->
name|cs_max_data_segment_length
condition|)
block|{
comment|/* 			 * Can't stuff more data into the current PDU; 			 * queue it.  Note that's not enough to check 			 * for kern_data_resid == 0 instead; there 			 * may be several Data-In PDUs for the final 			 * call to cfiscsi_datamove(), and we want 			 * to set the F flag only on the last of them. 			 */
name|buffer_offset
operator|+=
name|response
operator|->
name|ip_data_len
expr_stmt|;
if|if
condition|(
name|buffer_offset
operator|==
name|io
operator|->
name|scsiio
operator|.
name|kern_total_len
operator|||
name|buffer_offset
operator|==
name|expected_len
condition|)
name|bhsdi
operator|->
name|bhsdi_flags
operator||=
name|BHSDI_FLAGS_F
expr_stmt|;
name|cfiscsi_pdu_queue
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|response
operator|=
name|NULL
expr_stmt|;
name|bhsdi
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|response
operator|!=
name|NULL
condition|)
block|{
name|buffer_offset
operator|+=
name|response
operator|->
name|ip_data_len
expr_stmt|;
if|if
condition|(
name|buffer_offset
operator|==
name|io
operator|->
name|scsiio
operator|.
name|kern_total_len
operator|||
name|buffer_offset
operator|==
name|expected_len
condition|)
name|bhsdi
operator|->
name|bhsdi_flags
operator||=
name|BHSDI_FLAGS_F
expr_stmt|;
name|KASSERT
argument_list|(
name|response
operator|->
name|ip_data_len
operator|>
literal|0
argument_list|,
operator|(
literal|"sending empty Data-In"
operator|)
argument_list|)
expr_stmt|;
name|cfiscsi_pdu_queue
argument_list|(
name|response
argument_list|)
expr_stmt|;
block|}
name|io
operator|->
name|scsiio
operator|.
name|be_move_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cfiscsi_datamove_out
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|cfiscsi_session
modifier|*
name|cs
decl_stmt|;
name|struct
name|icl_pdu
modifier|*
name|request
decl_stmt|,
modifier|*
name|response
decl_stmt|;
specifier|const
name|struct
name|iscsi_bhs_scsi_command
modifier|*
name|bhssc
decl_stmt|;
name|struct
name|iscsi_bhs_r2t
modifier|*
name|bhsr2t
decl_stmt|;
name|struct
name|cfiscsi_data_wait
modifier|*
name|cdw
decl_stmt|;
name|uint32_t
name|target_transfer_tag
decl_stmt|;
name|bool
name|done
decl_stmt|;
name|request
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_FRONTEND
index|]
operator|.
name|ptr
expr_stmt|;
name|cs
operator|=
name|PDU_SESSION
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|bhssc
operator|=
operator|(
specifier|const
expr|struct
name|iscsi_bhs_scsi_command
operator|*
operator|)
name|request
operator|->
name|ip_bhs
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|bhssc
operator|->
name|bhssc_opcode
operator|&
operator|~
name|ISCSI_BHS_OPCODE_IMMEDIATE
operator|)
operator|==
name|ISCSI_BHS_OPCODE_SCSI_COMMAND
argument_list|,
operator|(
literal|"bhssc->bhssc_opcode != ISCSI_BHS_OPCODE_SCSI_COMMAND"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * We need to record it so that we can properly report 	 * underflow/underflow. 	 */
name|PDU_TOTAL_TRANSFER_LEN
argument_list|(
name|request
argument_list|)
operator|=
name|io
operator|->
name|scsiio
operator|.
name|kern_total_len
expr_stmt|;
comment|/* 	 * We hadn't received anything during this datamove yet. 	 */
name|io
operator|->
name|scsiio
operator|.
name|ext_data_filled
operator|=
literal|0
expr_stmt|;
name|target_transfer_tag
operator|=
name|atomic_fetchadd_32
argument_list|(
operator|&
name|cs
operator|->
name|cs_target_transfer_tag
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|CFISCSI_SESSION_DEBUG(cs, "expecting Data-Out with initiator " 	    "task tag 0x%x, target transfer tag 0x%x", 	    bhssc->bhssc_initiator_task_tag, target_transfer_tag);
endif|#
directive|endif
name|cdw
operator|=
name|uma_zalloc
argument_list|(
name|cfiscsi_data_wait_zone
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdw
operator|==
name|NULL
condition|)
block|{
name|CFISCSI_SESSION_WARN
argument_list|(
name|cs
argument_list|,
literal|"failed to "
literal|"allocate memory; dropping connection"
argument_list|)
expr_stmt|;
name|ctl_set_busy
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|be_move_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|cfiscsi_session_terminate
argument_list|(
name|cs
argument_list|)
expr_stmt|;
return|return;
block|}
name|cdw
operator|->
name|cdw_ctl_io
operator|=
name|io
expr_stmt|;
name|cdw
operator|->
name|cdw_target_transfer_tag
operator|=
name|target_transfer_tag
expr_stmt|;
name|cdw
operator|->
name|cdw_initiator_task_tag
operator|=
name|bhssc
operator|->
name|bhssc_initiator_task_tag
expr_stmt|;
if|if
condition|(
name|cs
operator|->
name|cs_immediate_data
operator|&&
name|io
operator|->
name|scsiio
operator|.
name|kern_rel_offset
operator|<
name|icl_pdu_data_segment_length
argument_list|(
name|request
argument_list|)
condition|)
block|{
name|done
operator|=
name|cfiscsi_handle_data_segment
argument_list|(
name|request
argument_list|,
name|cdw
argument_list|)
expr_stmt|;
if|if
condition|(
name|done
condition|)
block|{
name|uma_zfree
argument_list|(
name|cfiscsi_data_wait_zone
argument_list|,
name|cdw
argument_list|)
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|be_move_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|CFISCSI_SESSION_LOCK
argument_list|(
name|cs
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|cs
operator|->
name|cs_waiting_for_data_out
argument_list|,
name|cdw
argument_list|,
name|cdw_next
argument_list|)
expr_stmt|;
name|CFISCSI_SESSION_UNLOCK
argument_list|(
name|cs
argument_list|)
expr_stmt|;
comment|/* 	 * XXX: We should limit the number of outstanding R2T PDUs 	 * 	per task to MaxOutstandingR2T. 	 */
name|response
operator|=
name|cfiscsi_pdu_new_response
argument_list|(
name|request
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|response
operator|==
name|NULL
condition|)
block|{
name|CFISCSI_SESSION_WARN
argument_list|(
name|cs
argument_list|,
literal|"failed to "
literal|"allocate memory; dropping connection"
argument_list|)
expr_stmt|;
name|ctl_set_busy
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|be_move_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|cfiscsi_session_terminate
argument_list|(
name|cs
argument_list|)
expr_stmt|;
return|return;
block|}
name|bhsr2t
operator|=
operator|(
expr|struct
name|iscsi_bhs_r2t
operator|*
operator|)
name|response
operator|->
name|ip_bhs
expr_stmt|;
name|bhsr2t
operator|->
name|bhsr2t_opcode
operator|=
name|ISCSI_BHS_OPCODE_R2T
expr_stmt|;
name|bhsr2t
operator|->
name|bhsr2t_flags
operator|=
literal|0x80
expr_stmt|;
name|bhsr2t
operator|->
name|bhsr2t_lun
operator|=
name|bhssc
operator|->
name|bhssc_lun
expr_stmt|;
name|bhsr2t
operator|->
name|bhsr2t_initiator_task_tag
operator|=
name|bhssc
operator|->
name|bhssc_initiator_task_tag
expr_stmt|;
name|bhsr2t
operator|->
name|bhsr2t_target_transfer_tag
operator|=
name|target_transfer_tag
expr_stmt|;
comment|/* 	 * XXX: Here we assume that cfiscsi_datamove() won't ever 	 *	be running concurrently on several CPUs for a given 	 *	command. 	 */
name|bhsr2t
operator|->
name|bhsr2t_r2tsn
operator|=
name|htonl
argument_list|(
name|PDU_R2TSN
argument_list|(
name|request
argument_list|)
argument_list|)
expr_stmt|;
name|PDU_R2TSN
argument_list|(
name|request
argument_list|)
operator|++
expr_stmt|;
comment|/* 	 * This is the offset within the current SCSI command; 	 * i.e. for the first call of datamove(), it will be 0, 	 * and for subsequent ones it will be the sum of lengths 	 * of previous ones. 	 * 	 * The ext_data_filled is to account for unsolicited 	 * (immediate) data that might have already arrived. 	 */
name|bhsr2t
operator|->
name|bhsr2t_buffer_offset
operator|=
name|htonl
argument_list|(
name|io
operator|->
name|scsiio
operator|.
name|kern_rel_offset
operator|+
name|io
operator|->
name|scsiio
operator|.
name|ext_data_filled
argument_list|)
expr_stmt|;
comment|/* 	 * This is the total length (sum of S/G lengths) this call 	 * to cfiscsi_datamove() is supposed to handle. 	 * 	 * XXX: Limit it to MaxBurstLength. 	 */
name|bhsr2t
operator|->
name|bhsr2t_desired_data_transfer_length
operator|=
name|htonl
argument_list|(
name|io
operator|->
name|scsiio
operator|.
name|kern_data_len
operator|-
name|io
operator|->
name|scsiio
operator|.
name|ext_data_filled
argument_list|)
expr_stmt|;
name|cfiscsi_pdu_queue
argument_list|(
name|response
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cfiscsi_datamove
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_DATA_MASK
operator|)
operator|==
name|CTL_FLAG_DATA_IN
condition|)
name|cfiscsi_datamove_in
argument_list|(
name|io
argument_list|)
expr_stmt|;
else|else
name|cfiscsi_datamove_out
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cfiscsi_scsi_command_done
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|icl_pdu
modifier|*
name|request
decl_stmt|,
modifier|*
name|response
decl_stmt|;
name|struct
name|iscsi_bhs_scsi_command
modifier|*
name|bhssc
decl_stmt|;
name|struct
name|iscsi_bhs_scsi_response
modifier|*
name|bhssr
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|struct
name|cfiscsi_data_wait
modifier|*
name|cdw
decl_stmt|;
endif|#
directive|endif
name|struct
name|cfiscsi_session
modifier|*
name|cs
decl_stmt|;
name|uint16_t
name|sense_length
decl_stmt|;
name|request
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_FRONTEND
index|]
operator|.
name|ptr
expr_stmt|;
name|cs
operator|=
name|PDU_SESSION
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|bhssc
operator|=
operator|(
expr|struct
name|iscsi_bhs_scsi_command
operator|*
operator|)
name|request
operator|->
name|ip_bhs
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|bhssc
operator|->
name|bhssc_opcode
operator|&
operator|~
name|ISCSI_BHS_OPCODE_IMMEDIATE
operator|)
operator|==
name|ISCSI_BHS_OPCODE_SCSI_COMMAND
argument_list|,
operator|(
literal|"replying to wrong opcode 0x%x"
operator|,
name|bhssc
operator|->
name|bhssc_opcode
operator|)
argument_list|)
expr_stmt|;
comment|//CFISCSI_SESSION_DEBUG(cs, "initiator task tag 0x%x",
comment|//    bhssc->bhssc_initiator_task_tag);
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|CFISCSI_SESSION_LOCK
argument_list|(
name|cs
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|cdw
argument_list|,
argument|&cs->cs_waiting_for_data_out
argument_list|,
argument|cdw_next
argument_list|)
name|KASSERT
argument_list|(
name|bhssc
operator|->
name|bhssc_initiator_task_tag
operator|!=
name|cdw
operator|->
name|cdw_initiator_task_tag
argument_list|,
operator|(
literal|"dangling cdw"
operator|)
argument_list|)
expr_stmt|;
name|CFISCSI_SESSION_UNLOCK
argument_list|(
name|cs
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|response
operator|=
name|cfiscsi_pdu_new_response
argument_list|(
name|request
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bhssr
operator|=
operator|(
expr|struct
name|iscsi_bhs_scsi_response
operator|*
operator|)
name|response
operator|->
name|ip_bhs
expr_stmt|;
name|bhssr
operator|->
name|bhssr_opcode
operator|=
name|ISCSI_BHS_OPCODE_SCSI_RESPONSE
expr_stmt|;
name|bhssr
operator|->
name|bhssr_flags
operator|=
literal|0x80
expr_stmt|;
comment|/* 	 * XXX: We don't deal with bidirectional under/overflows; 	 *	does anything actually support those? 	 */
if|if
condition|(
name|PDU_TOTAL_TRANSFER_LEN
argument_list|(
name|request
argument_list|)
operator|<
name|ntohl
argument_list|(
name|bhssc
operator|->
name|bhssc_expected_data_transfer_length
argument_list|)
condition|)
block|{
name|bhssr
operator|->
name|bhssr_flags
operator||=
name|BHSSR_FLAGS_RESIDUAL_UNDERFLOW
expr_stmt|;
name|bhssr
operator|->
name|bhssr_residual_count
operator|=
name|htonl
argument_list|(
name|ntohl
argument_list|(
name|bhssc
operator|->
name|bhssc_expected_data_transfer_length
argument_list|)
operator|-
name|PDU_TOTAL_TRANSFER_LEN
argument_list|(
name|request
argument_list|)
argument_list|)
expr_stmt|;
comment|//CFISCSI_SESSION_DEBUG(cs, "underflow; residual count %d",
comment|//    ntohl(bhssr->bhssr_residual_count));
block|}
elseif|else
if|if
condition|(
name|PDU_TOTAL_TRANSFER_LEN
argument_list|(
name|request
argument_list|)
operator|>
name|ntohl
argument_list|(
name|bhssc
operator|->
name|bhssc_expected_data_transfer_length
argument_list|)
condition|)
block|{
name|bhssr
operator|->
name|bhssr_flags
operator||=
name|BHSSR_FLAGS_RESIDUAL_OVERFLOW
expr_stmt|;
name|bhssr
operator|->
name|bhssr_residual_count
operator|=
name|htonl
argument_list|(
name|PDU_TOTAL_TRANSFER_LEN
argument_list|(
name|request
argument_list|)
operator|-
name|ntohl
argument_list|(
name|bhssc
operator|->
name|bhssc_expected_data_transfer_length
argument_list|)
argument_list|)
expr_stmt|;
comment|//CFISCSI_SESSION_DEBUG(cs, "overflow; residual count %d",
comment|//    ntohl(bhssr->bhssr_residual_count));
block|}
name|bhssr
operator|->
name|bhssr_response
operator|=
name|BHSSR_RESPONSE_COMMAND_COMPLETED
expr_stmt|;
name|bhssr
operator|->
name|bhssr_status
operator|=
name|io
operator|->
name|scsiio
operator|.
name|scsi_status
expr_stmt|;
name|bhssr
operator|->
name|bhssr_initiator_task_tag
operator|=
name|bhssc
operator|->
name|bhssc_initiator_task_tag
expr_stmt|;
name|bhssr
operator|->
name|bhssr_expdatasn
operator|=
name|htonl
argument_list|(
name|PDU_EXPDATASN
argument_list|(
name|request
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|scsiio
operator|.
name|sense_len
operator|>
literal|0
condition|)
block|{
if|#
directive|if
literal|0
block|CFISCSI_SESSION_DEBUG(cs, "returning %d bytes of sense data", 		    io->scsiio.sense_len);
endif|#
directive|endif
name|sense_length
operator|=
name|htons
argument_list|(
name|io
operator|->
name|scsiio
operator|.
name|sense_len
argument_list|)
expr_stmt|;
name|icl_pdu_append_data
argument_list|(
name|response
argument_list|,
operator|&
name|sense_length
argument_list|,
sizeof|sizeof
argument_list|(
name|sense_length
argument_list|)
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|icl_pdu_append_data
argument_list|(
name|response
argument_list|,
operator|&
name|io
operator|->
name|scsiio
operator|.
name|sense_data
argument_list|,
name|io
operator|->
name|scsiio
operator|.
name|sense_len
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
name|ctl_free_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|icl_pdu_free
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|cfiscsi_pdu_queue
argument_list|(
name|response
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cfiscsi_task_management_done
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|icl_pdu
modifier|*
name|request
decl_stmt|,
modifier|*
name|response
decl_stmt|;
name|struct
name|iscsi_bhs_task_management_request
modifier|*
name|bhstmr
decl_stmt|;
name|struct
name|iscsi_bhs_task_management_response
modifier|*
name|bhstmr2
decl_stmt|;
name|struct
name|cfiscsi_data_wait
modifier|*
name|cdw
decl_stmt|,
modifier|*
name|tmpcdw
decl_stmt|;
name|struct
name|cfiscsi_session
modifier|*
name|cs
decl_stmt|;
name|request
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_FRONTEND
index|]
operator|.
name|ptr
expr_stmt|;
name|cs
operator|=
name|PDU_SESSION
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|bhstmr
operator|=
operator|(
expr|struct
name|iscsi_bhs_task_management_request
operator|*
operator|)
name|request
operator|->
name|ip_bhs
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|bhstmr
operator|->
name|bhstmr_opcode
operator|&
operator|~
name|ISCSI_BHS_OPCODE_IMMEDIATE
operator|)
operator|==
name|ISCSI_BHS_OPCODE_TASK_REQUEST
argument_list|,
operator|(
literal|"replying to wrong opcode 0x%x"
operator|,
name|bhstmr
operator|->
name|bhstmr_opcode
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|CFISCSI_SESSION_DEBUG(cs, "initiator task tag 0x%x; referenced task tag 0x%x", 	    bhstmr->bhstmr_initiator_task_tag, 	    bhstmr->bhstmr_referenced_task_tag);
endif|#
directive|endif
if|if
condition|(
operator|(
name|bhstmr
operator|->
name|bhstmr_function
operator|&
operator|~
literal|0x80
operator|)
operator|==
name|BHSTMR_FUNCTION_ABORT_TASK
condition|)
block|{
comment|/* 		 * Make sure we no longer wait for Data-Out for this command. 		 */
name|CFISCSI_SESSION_LOCK
argument_list|(
name|cs
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|cdw
argument_list|,
argument|&cs->cs_waiting_for_data_out
argument_list|,
argument|cdw_next
argument_list|,
argument|tmpcdw
argument_list|)
block|{
if|if
condition|(
name|bhstmr
operator|->
name|bhstmr_referenced_task_tag
operator|!=
name|cdw
operator|->
name|cdw_initiator_task_tag
condition|)
continue|continue;
if|#
directive|if
literal|0
block|CFISCSI_SESSION_DEBUG(cs, "removing csw for initiator task " 			    "tag 0x%x", bhstmr->bhstmr_initiator_task_tag);
endif|#
directive|endif
name|TAILQ_REMOVE
argument_list|(
operator|&
name|cs
operator|->
name|cs_waiting_for_data_out
argument_list|,
name|cdw
argument_list|,
name|cdw_next
argument_list|)
expr_stmt|;
name|cdw
operator|->
name|cdw_ctl_io
operator|->
name|scsiio
operator|.
name|be_move_done
argument_list|(
name|cdw
operator|->
name|cdw_ctl_io
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|cfiscsi_data_wait_zone
argument_list|,
name|cdw
argument_list|)
expr_stmt|;
block|}
name|CFISCSI_SESSION_UNLOCK
argument_list|(
name|cs
argument_list|)
expr_stmt|;
block|}
name|response
operator|=
name|cfiscsi_pdu_new_response
argument_list|(
name|request
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bhstmr2
operator|=
operator|(
expr|struct
name|iscsi_bhs_task_management_response
operator|*
operator|)
name|response
operator|->
name|ip_bhs
expr_stmt|;
name|bhstmr2
operator|->
name|bhstmr_opcode
operator|=
name|ISCSI_BHS_OPCODE_TASK_RESPONSE
expr_stmt|;
name|bhstmr2
operator|->
name|bhstmr_flags
operator|=
literal|0x80
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|==
name|CTL_SUCCESS
condition|)
block|{
name|bhstmr2
operator|->
name|bhstmr_response
operator|=
name|BHSTMR_RESPONSE_FUNCTION_COMPLETE
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * XXX: How to figure out what exactly went wrong?  iSCSI spec 		 * 	expects us to provide detailed error, e.g. "Task does 		 * 	not exist" or "LUN does not exist". 		 */
name|CFISCSI_SESSION_DEBUG
argument_list|(
name|cs
argument_list|,
literal|"BHSTMR_RESPONSE_FUNCTION_NOT_SUPPORTED"
argument_list|)
expr_stmt|;
name|bhstmr2
operator|->
name|bhstmr_response
operator|=
name|BHSTMR_RESPONSE_FUNCTION_NOT_SUPPORTED
expr_stmt|;
block|}
name|bhstmr2
operator|->
name|bhstmr_initiator_task_tag
operator|=
name|bhstmr
operator|->
name|bhstmr_initiator_task_tag
expr_stmt|;
name|ctl_free_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|icl_pdu_free
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|cfiscsi_pdu_queue
argument_list|(
name|response
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cfiscsi_done
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|icl_pdu
modifier|*
name|request
decl_stmt|;
name|struct
name|cfiscsi_session
modifier|*
name|cs
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|!=
name|CTL_STATUS_NONE
operator|)
argument_list|,
operator|(
literal|"invalid CTL status %#x"
operator|,
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|)
argument_list|)
expr_stmt|;
name|request
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_FRONTEND
index|]
operator|.
name|ptr
expr_stmt|;
if|if
condition|(
name|request
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Implicit task termination has just completed; nothing to do. 		 */
return|return;
block|}
name|cs
operator|=
name|PDU_SESSION
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|refcount_release
argument_list|(
operator|&
name|cs
operator|->
name|cs_outstanding_ctl_pdus
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|request
operator|->
name|ip_bhs
operator|->
name|bhs_opcode
operator|&
operator|~
name|ISCSI_BHS_OPCODE_IMMEDIATE
condition|)
block|{
case|case
name|ISCSI_BHS_OPCODE_SCSI_COMMAND
case|:
name|cfiscsi_scsi_command_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISCSI_BHS_OPCODE_TASK_REQUEST
case|:
name|cfiscsi_task_management_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"cfiscsi_done called with wrong opcode 0x%x"
argument_list|,
name|request
operator|->
name|ip_bhs
operator|->
name|bhs_opcode
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

