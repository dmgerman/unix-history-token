begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2009 Silicon Graphics International Corp.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    substantially similar to the "NO WARRANTY" disclaimer below  *    ("Disclaimer") and any redistribution must be conditioned upon  *    including a substantially similar Disclaimer requirement for further  *    binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGES.  *  * $Id: //depot/users/kenm/FreeBSD-test2/sys/cam/ctl/ctl_frontend_cam_sim.c#4 $  */
end_comment

begin_comment
comment|/*  * CTL frontend to CAM SIM interface.  This allows access to CTL LUNs via  * the da(4) and pass(4) drivers from inside the system.  *  * Author: Ken Merry<ken@FreeBSD.org>  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_io.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_frontend.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_debug.h>
end_include

begin_define
define|#
directive|define
name|io_ptr
value|spriv_ptr1
end_define

begin_struct
struct|struct
name|cfcs_io
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|cfcs_softc
block|{
name|struct
name|ctl_port
name|port
decl_stmt|;
name|char
name|port_name
index|[
literal|32
index|]
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|struct
name|mtx
name|lock
decl_stmt|;
name|uint64_t
name|wwnn
decl_stmt|;
name|uint64_t
name|wwpn
decl_stmt|;
name|uint32_t
name|cur_tag_num
decl_stmt|;
name|int
name|online
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * We can't handle CCBs with these flags.  For the most part, we just don't  * handle physical addresses yet.  That would require mapping things in  * order to do the copy.  */
end_comment

begin_define
define|#
directive|define
name|CFCS_BAD_CCB_FLAGS
value|(CAM_DATA_ISPHYS | CAM_MSG_BUF_PHYS |	\ 	CAM_SNS_BUF_PHYS | CAM_CDB_PHYS | CAM_SENSE_PTR |		\ 	CAM_SENSE_PHYS)
end_define

begin_function_decl
name|int
name|cfcs_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cfcs_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cfcs_online
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cfcs_offline
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cfcs_datamove
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cfcs_done
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|cfcs_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cfcs_async
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|uint32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|cfcs_softc
name|cfcs_softc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This is primarly intended to allow for error injection to test the CAM  * sense data and sense residual handling code.  This sets the maximum  * amount of SCSI sense data that we will report to CAM.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cfcs_max_sense
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_kern_cam
argument_list|,
name|OID_AUTO
argument_list|,
name|ctl2cam
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"CAM Target Layer SIM frontend"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_cam_ctl2cam
argument_list|,
name|OID_AUTO
argument_list|,
name|max_sense
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|cfcs_max_sense
argument_list|,
literal|0
argument_list|,
literal|"Maximum sense data size"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|ctl_frontend
name|cfcs_frontend
init|=
block|{
operator|.
name|name
operator|=
literal|"camsim"
block|,
operator|.
name|init
operator|=
name|cfcs_init
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|CTL_FRONTEND_DECLARE
argument_list|(
name|ctlcfcs
argument_list|,
name|cfcs_frontend
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|cfcs_init
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cfcs_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ccb_setasync
name|csa
decl_stmt|;
name|struct
name|ctl_port
modifier|*
name|port
decl_stmt|;
ifdef|#
directive|ifdef
name|NEEDTOPORT
name|char
name|wwnn
index|[
literal|8
index|]
decl_stmt|;
endif|#
directive|endif
name|int
name|retval
decl_stmt|;
name|softc
operator|=
operator|&
name|cfcs_softc
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|softc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|softc
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|,
literal|"ctl2cam"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|port
operator|=
operator|&
name|softc
operator|->
name|port
expr_stmt|;
name|port
operator|->
name|frontend
operator|=
operator|&
name|cfcs_frontend
expr_stmt|;
name|port
operator|->
name|port_type
operator|=
name|CTL_PORT_INTERNAL
expr_stmt|;
comment|/* XXX KDM what should the real number be here? */
name|port
operator|->
name|num_requested_ctl_io
operator|=
literal|4096
expr_stmt|;
name|snprintf
argument_list|(
name|softc
operator|->
name|port_name
argument_list|,
sizeof|sizeof
argument_list|(
name|softc
operator|->
name|port_name
argument_list|)
argument_list|,
literal|"camsim"
argument_list|)
expr_stmt|;
name|port
operator|->
name|port_name
operator|=
name|softc
operator|->
name|port_name
expr_stmt|;
name|port
operator|->
name|port_online
operator|=
name|cfcs_online
expr_stmt|;
name|port
operator|->
name|port_offline
operator|=
name|cfcs_offline
expr_stmt|;
name|port
operator|->
name|onoff_arg
operator|=
name|softc
expr_stmt|;
name|port
operator|->
name|fe_datamove
operator|=
name|cfcs_datamove
expr_stmt|;
name|port
operator|->
name|fe_done
operator|=
name|cfcs_done
expr_stmt|;
comment|/* XXX KDM what should we report here? */
comment|/* XXX These should probably be fetched from CTL. */
name|port
operator|->
name|max_targets
operator|=
literal|1
expr_stmt|;
name|port
operator|->
name|max_target_id
operator|=
literal|15
expr_stmt|;
name|retval
operator|=
name|ctl_port_register
argument_list|(
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ctl_port_register() failed with error %d!\n"
argument_list|,
name|__func__
argument_list|,
name|retval
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
comment|/* 	 * Get the WWNN out of the database, and create a WWPN as well. 	 */
ifdef|#
directive|ifdef
name|NEEDTOPORT
name|ddb_GetWWNN
argument_list|(
operator|(
name|char
operator|*
operator|)
name|wwnn
argument_list|)
expr_stmt|;
name|softc
operator|->
name|wwnn
operator|=
name|be64dec
argument_list|(
name|wwnn
argument_list|)
expr_stmt|;
name|softc
operator|->
name|wwpn
operator|=
name|softc
operator|->
name|wwnn
operator|+
operator|(
name|softc
operator|->
name|port
operator|.
name|targ_port
operator|&
literal|0xff
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * If the CTL frontend didn't tell us what our WWNN/WWPN is, go 	 * ahead and set something random. 	 */
if|if
condition|(
name|port
operator|->
name|wwnn
operator|==
literal|0
condition|)
block|{
name|uint64_t
name|random_bits
decl_stmt|;
name|arc4rand
argument_list|(
operator|&
name|random_bits
argument_list|,
sizeof|sizeof
argument_list|(
name|random_bits
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|softc
operator|->
name|wwnn
operator|=
operator|(
name|random_bits
operator|&
literal|0x0000000fffffff00ULL
operator|)
operator||
comment|/* Company ID */
literal|0x5000000000000000ULL
operator||
comment|/* NL-Port */
literal|0x0300
expr_stmt|;
name|softc
operator|->
name|wwpn
operator|=
name|softc
operator|->
name|wwnn
operator|+
name|port
operator|->
name|targ_port
operator|+
literal|1
expr_stmt|;
name|ctl_port_set_wwns
argument_list|(
name|port
argument_list|,
name|true
argument_list|,
name|softc
operator|->
name|wwnn
argument_list|,
name|true
argument_list|,
name|softc
operator|->
name|wwpn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|softc
operator|->
name|wwnn
operator|=
name|port
operator|->
name|wwnn
expr_stmt|;
name|softc
operator|->
name|wwpn
operator|=
name|port
operator|->
name|wwpn
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|softc
operator|->
name|devq
operator|=
name|cam_simq_alloc
argument_list|(
name|port
operator|->
name|num_requested_ctl_io
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|devq
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: error allocating devq\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|retval
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|softc
operator|->
name|sim
operator|=
name|cam_sim_alloc
argument_list|(
name|cfcs_action
argument_list|,
name|cfcs_poll
argument_list|,
name|softc
operator|->
name|port_name
argument_list|,
name|softc
argument_list|,
comment|/*unit*/
literal|0
argument_list|,
operator|&
name|softc
operator|->
name|lock
argument_list|,
literal|1
argument_list|,
name|port
operator|->
name|num_requested_ctl_io
argument_list|,
name|softc
operator|->
name|devq
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|sim
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: error allocating SIM\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|retval
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|softc
operator|->
name|sim
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"%s: error registering SIM\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|retval
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|softc
operator|->
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|softc
operator|->
name|sim
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"%s: error creating path\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|softc
operator|->
name|sim
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|xpt_setup_ccb
argument_list|(
operator|&
name|csa
operator|.
name|ccb_h
argument_list|,
name|softc
operator|->
name|path
argument_list|,
name|CAM_PRIORITY_NONE
argument_list|)
expr_stmt|;
name|csa
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SASYNC_CB
expr_stmt|;
name|csa
operator|.
name|event_enable
operator|=
name|AC_LOST_DEVICE
expr_stmt|;
name|csa
operator|.
name|callback
operator|=
name|cfcs_async
expr_stmt|;
name|csa
operator|.
name|callback_arg
operator|=
name|softc
operator|->
name|sim
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|csa
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
name|bailout
label|:
if|if
condition|(
name|softc
operator|->
name|sim
condition|)
name|cam_sim_free
argument_list|(
name|softc
operator|->
name|sim
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|softc
operator|->
name|devq
condition|)
name|cam_simq_free
argument_list|(
name|softc
operator|->
name|devq
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cfcs_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
block|{  }
end_function

begin_function
specifier|static
name|void
name|cfcs_onoffline
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|online
parameter_list|)
block|{
name|struct
name|cfcs_softc
modifier|*
name|softc
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|cfcs_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|softc
operator|->
name|online
operator|=
name|online
expr_stmt|;
name|ccb
operator|=
name|xpt_alloc_ccb_nowait
argument_list|()
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unable to allocate CCB for rescan\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|softc
operator|->
name|sim
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"%s: can't allocate path for rescan\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|xpt_free_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|xpt_rescan
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|bailout
label|:
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cfcs_online
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|cfcs_onoffline
argument_list|(
name|arg
argument_list|,
comment|/*online*/
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cfcs_offline
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|cfcs_onoffline
argument_list|(
name|arg
argument_list|,
comment|/*online*/
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function is very similar to ctl_ioctl_do_datamove().  Is there a  * way to combine the functionality?  *  * XXX KDM may need to move this into a thread.  We're doing a bcopy in the  * caller's context, which will usually be the backend.  That may not be a  * good thing.  */
end_comment

begin_function
specifier|static
name|void
name|cfcs_datamove
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|bus_dma_segment_t
name|cam_sg_entry
decl_stmt|,
modifier|*
name|cam_sglist
decl_stmt|;
name|struct
name|ctl_sg_entry
name|ctl_sg_entry
decl_stmt|,
modifier|*
name|ctl_sglist
decl_stmt|;
name|int
name|cam_sg_count
decl_stmt|,
name|ctl_sg_count
decl_stmt|,
name|cam_sg_start
decl_stmt|;
name|int
name|cam_sg_offset
decl_stmt|;
name|int
name|len_to_copy
decl_stmt|,
name|len_copied
decl_stmt|;
name|int
name|ctl_watermark
decl_stmt|,
name|cam_watermark
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|cam_sg_offset
operator|=
literal|0
expr_stmt|;
name|cam_sg_start
operator|=
literal|0
expr_stmt|;
name|ccb
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_FRONTEND
index|]
operator|.
name|ptr
expr_stmt|;
comment|/* 	 * Note that we have a check in cfcs_action() to make sure that any 	 * CCBs with "bad" flags are returned with CAM_REQ_INVALID.  This 	 * is just to make sure no one removes that check without updating 	 * this code to provide the additional functionality necessary to 	 * support those modes of operation. 	 */
name|KASSERT
argument_list|(
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CFCS_BAD_CCB_FLAGS
operator|)
operator|==
literal|0
operator|)
argument_list|,
operator|(
literal|"invalid "
literal|"CAM flags %#x"
operator|,
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CFCS_BAD_CCB_FLAGS
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Simplify things on both sides by putting single buffers into a 	 * single entry S/G list. 	 */
switch|switch
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DATA_MASK
operator|)
condition|)
block|{
case|case
name|CAM_DATA_SG
case|:
block|{
name|int
name|len_seen
decl_stmt|;
name|cam_sglist
operator|=
operator|(
name|bus_dma_segment_t
operator|*
operator|)
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
expr_stmt|;
name|cam_sg_count
operator|=
name|ccb
operator|->
name|csio
operator|.
name|sglist_cnt
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|len_seen
operator|=
literal|0
init|;
name|i
operator|<
name|cam_sg_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|len_seen
operator|+
name|cam_sglist
index|[
name|i
index|]
operator|.
name|ds_len
operator|)
operator|>=
name|io
operator|->
name|scsiio
operator|.
name|kern_rel_offset
condition|)
block|{
name|cam_sg_start
operator|=
name|i
expr_stmt|;
name|cam_sg_offset
operator|=
name|io
operator|->
name|scsiio
operator|.
name|kern_rel_offset
operator|-
name|len_seen
expr_stmt|;
break|break;
block|}
name|len_seen
operator|+=
name|cam_sglist
index|[
name|i
index|]
operator|.
name|ds_len
expr_stmt|;
block|}
break|break;
block|}
case|case
name|CAM_DATA_VADDR
case|:
name|cam_sglist
operator|=
operator|&
name|cam_sg_entry
expr_stmt|;
name|cam_sglist
index|[
literal|0
index|]
operator|.
name|ds_len
operator|=
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
expr_stmt|;
name|cam_sglist
index|[
literal|0
index|]
operator|.
name|ds_addr
operator|=
operator|(
name|bus_addr_t
operator|)
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
expr_stmt|;
name|cam_sg_count
operator|=
literal|1
expr_stmt|;
name|cam_sg_start
operator|=
literal|0
expr_stmt|;
name|cam_sg_offset
operator|=
name|io
operator|->
name|scsiio
operator|.
name|kern_rel_offset
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"Invalid CAM flags %#x"
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|io
operator|->
name|scsiio
operator|.
name|kern_sg_entries
operator|>
literal|0
condition|)
block|{
name|ctl_sglist
operator|=
operator|(
expr|struct
name|ctl_sg_entry
operator|*
operator|)
name|io
operator|->
name|scsiio
operator|.
name|kern_data_ptr
expr_stmt|;
name|ctl_sg_count
operator|=
name|io
operator|->
name|scsiio
operator|.
name|kern_sg_entries
expr_stmt|;
block|}
else|else
block|{
name|ctl_sglist
operator|=
operator|&
name|ctl_sg_entry
expr_stmt|;
name|ctl_sglist
operator|->
name|addr
operator|=
name|io
operator|->
name|scsiio
operator|.
name|kern_data_ptr
expr_stmt|;
name|ctl_sglist
operator|->
name|len
operator|=
name|io
operator|->
name|scsiio
operator|.
name|kern_data_len
expr_stmt|;
name|ctl_sg_count
operator|=
literal|1
expr_stmt|;
block|}
name|ctl_watermark
operator|=
literal|0
expr_stmt|;
name|cam_watermark
operator|=
name|cam_sg_offset
expr_stmt|;
name|len_copied
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|cam_sg_start
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|cam_sg_count
operator|&&
name|j
operator|<
name|ctl_sg_count
condition|;
control|)
block|{
name|uint8_t
modifier|*
name|cam_ptr
decl_stmt|,
modifier|*
name|ctl_ptr
decl_stmt|;
name|len_to_copy
operator|=
name|MIN
argument_list|(
name|cam_sglist
index|[
name|i
index|]
operator|.
name|ds_len
operator|-
name|cam_watermark
argument_list|,
name|ctl_sglist
index|[
name|j
index|]
operator|.
name|len
operator|-
name|ctl_watermark
argument_list|)
expr_stmt|;
name|cam_ptr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|cam_sglist
index|[
name|i
index|]
operator|.
name|ds_addr
expr_stmt|;
name|cam_ptr
operator|=
name|cam_ptr
operator|+
name|cam_watermark
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_BUS_ADDR
condition|)
block|{
comment|/* 			 * XXX KDM fix this! 			 */
name|panic
argument_list|(
literal|"need to implement bus address support"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|kern_ptr = bus_to_virt(kern_sglist[j].addr);
endif|#
directive|endif
block|}
else|else
name|ctl_ptr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|ctl_sglist
index|[
name|j
index|]
operator|.
name|addr
expr_stmt|;
name|ctl_ptr
operator|=
name|ctl_ptr
operator|+
name|ctl_watermark
expr_stmt|;
name|ctl_watermark
operator|+=
name|len_to_copy
expr_stmt|;
name|cam_watermark
operator|+=
name|len_to_copy
expr_stmt|;
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_DATA_MASK
operator|)
operator|==
name|CTL_FLAG_DATA_IN
condition|)
block|{
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"%s: copying %d bytes to CAM\n"
operator|,
name|__func__
operator|,
name|len_to_copy
operator|)
argument_list|)
expr_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"%s: from %p to %p\n"
operator|,
name|ctl_ptr
operator|,
name|__func__
operator|,
name|cam_ptr
operator|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|ctl_ptr
argument_list|,
name|cam_ptr
argument_list|,
name|len_to_copy
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"%s: copying %d bytes from CAM\n"
operator|,
name|__func__
operator|,
name|len_to_copy
operator|)
argument_list|)
expr_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"%s: from %p to %p\n"
operator|,
name|cam_ptr
operator|,
name|__func__
operator|,
name|ctl_ptr
operator|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|cam_ptr
argument_list|,
name|ctl_ptr
argument_list|,
name|len_to_copy
argument_list|)
expr_stmt|;
block|}
name|len_copied
operator|+=
name|len_to_copy
expr_stmt|;
if|if
condition|(
name|cam_sglist
index|[
name|i
index|]
operator|.
name|ds_len
operator|==
name|cam_watermark
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|cam_watermark
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ctl_sglist
index|[
name|j
index|]
operator|.
name|len
operator|==
name|ctl_watermark
condition|)
block|{
name|j
operator|++
expr_stmt|;
name|ctl_watermark
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|io
operator|->
name|scsiio
operator|.
name|ext_data_filled
operator|+=
name|len_copied
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|be_move_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cfcs_done
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|ccb
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_FRONTEND
index|]
operator|.
name|ptr
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|ctl_free_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * At this point we should have status.  If we don't, that's a bug. 	 */
name|KASSERT
argument_list|(
operator|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|!=
name|CTL_STATUS_NONE
operator|)
argument_list|,
operator|(
literal|"invalid CTL status %#x"
operator|,
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Translate CTL status to CAM status. 	 */
switch|switch
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
condition|)
block|{
case|case
name|CTL_SUCCESS
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
case|case
name|CTL_SCSI_ERROR
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SCSI_STATUS_ERROR
operator||
name|CAM_AUTOSNS_VALID
expr_stmt|;
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
operator|=
name|io
operator|->
name|scsiio
operator|.
name|scsi_status
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|io
operator|->
name|scsiio
operator|.
name|sense_data
argument_list|,
operator|&
name|ccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|,
name|min
argument_list|(
name|io
operator|->
name|scsiio
operator|.
name|sense_len
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|sense_len
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|csio
operator|.
name|sense_len
operator|>
name|io
operator|->
name|scsiio
operator|.
name|sense_len
condition|)
name|ccb
operator|->
name|csio
operator|.
name|sense_resid
operator|=
name|ccb
operator|->
name|csio
operator|.
name|sense_len
operator|-
name|io
operator|->
name|scsiio
operator|.
name|sense_len
expr_stmt|;
else|else
name|ccb
operator|->
name|csio
operator|.
name|sense_resid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|csio
operator|.
name|sense_len
operator|-
name|ccb
operator|->
name|csio
operator|.
name|sense_resid
operator|)
operator|>
name|cfcs_max_sense
condition|)
block|{
name|ccb
operator|->
name|csio
operator|.
name|sense_resid
operator|=
name|ccb
operator|->
name|csio
operator|.
name|sense_len
operator|-
name|cfcs_max_sense
expr_stmt|;
block|}
break|break;
case|case
name|CTL_CMD_ABORTED
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_ABORTED
expr_stmt|;
break|break;
case|case
name|CTL_ERROR
case|:
default|default:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP_ERR
expr_stmt|;
break|break;
block|}
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|ctl_free_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cfcs_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|cfcs_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|err
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|cfcs_softc
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_SCSI_IO
case|:
block|{
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|csio
operator|=
operator|&
name|ccb
operator|->
name|csio
expr_stmt|;
comment|/* 		 * Catch CCB flags, like physical address flags, that 	 	 * indicate situations we currently can't handle. 		 */
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CFCS_BAD_CCB_FLAGS
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|printf
argument_list|(
literal|"%s: bad CCB flags %#x (all flags %#x)\n"
argument_list|,
name|__func__
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CFCS_BAD_CCB_FLAGS
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * If we aren't online, there are no devices to see. 		 */
if|if
condition|(
name|softc
operator|->
name|online
operator|==
literal|0
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_DEV_NOT_THERE
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|io
operator|=
name|ctl_alloc_io_nowait
argument_list|(
name|softc
operator|->
name|port
operator|.
name|ctl_pool_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: can't allocate ctl_io\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_BUSY
operator||
name|CAM_DEV_QFRZN
expr_stmt|;
name|xpt_freeze_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|ctl_zero_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
comment|/* Save pointers on both sides */
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_FRONTEND
index|]
operator|.
name|ptr
operator|=
name|ccb
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|io_ptr
operator|=
name|io
expr_stmt|;
comment|/* 		 * Only SCSI I/O comes down this path, resets, etc. come 		 * down via the XPT_RESET_BUS/LUN CCBs below. 		 */
name|io
operator|->
name|io_hdr
operator|.
name|io_type
operator|=
name|CTL_IO_SCSI
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|initid
operator|.
name|id
operator|=
literal|1
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
operator|=
name|softc
operator|->
name|port
operator|.
name|targ_port
expr_stmt|;
comment|/* 		 * XXX KDM how do we handle target IDs? 		 */
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_target
operator|.
name|id
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_lun
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
comment|/* 		 * This tag scheme isn't the best, since we could in theory 		 * have a very long-lived I/O and tag collision, especially 		 * in a high I/O environment.  But it should work well 		 * enough for now.  Since we're using unsigned ints, 		 * they'll just wrap around. 		 */
name|io
operator|->
name|scsiio
operator|.
name|tag_num
operator|=
name|softc
operator|->
name|cur_tag_num
operator|++
expr_stmt|;
name|csio
operator|->
name|tag_id
operator|=
name|io
operator|->
name|scsiio
operator|.
name|tag_num
expr_stmt|;
switch|switch
condition|(
name|csio
operator|->
name|tag_action
condition|)
block|{
case|case
name|CAM_TAG_ACTION_NONE
case|:
name|io
operator|->
name|scsiio
operator|.
name|tag_type
operator|=
name|CTL_TAG_UNTAGGED
expr_stmt|;
break|break;
case|case
name|MSG_SIMPLE_TASK
case|:
name|io
operator|->
name|scsiio
operator|.
name|tag_type
operator|=
name|CTL_TAG_SIMPLE
expr_stmt|;
break|break;
case|case
name|MSG_HEAD_OF_QUEUE_TASK
case|:
name|io
operator|->
name|scsiio
operator|.
name|tag_type
operator|=
name|CTL_TAG_HEAD_OF_QUEUE
expr_stmt|;
break|break;
case|case
name|MSG_ORDERED_TASK
case|:
name|io
operator|->
name|scsiio
operator|.
name|tag_type
operator|=
name|CTL_TAG_ORDERED
expr_stmt|;
break|break;
case|case
name|MSG_ACA_TASK
case|:
name|io
operator|->
name|scsiio
operator|.
name|tag_type
operator|=
name|CTL_TAG_ACA
expr_stmt|;
break|break;
default|default:
name|io
operator|->
name|scsiio
operator|.
name|tag_type
operator|=
name|CTL_TAG_UNTAGGED
expr_stmt|;
name|printf
argument_list|(
literal|"%s: unhandled tag type %#x!!\n"
argument_list|,
name|__func__
argument_list|,
name|csio
operator|->
name|tag_action
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|csio
operator|->
name|cdb_len
operator|>
sizeof|sizeof
argument_list|(
name|io
operator|->
name|scsiio
operator|.
name|cdb
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: WARNING: CDB len %d> ctl_io space %zd\n"
argument_list|,
name|__func__
argument_list|,
name|csio
operator|->
name|cdb_len
argument_list|,
sizeof|sizeof
argument_list|(
name|io
operator|->
name|scsiio
operator|.
name|cdb
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|io
operator|->
name|scsiio
operator|.
name|cdb_len
operator|=
name|min
argument_list|(
name|csio
operator|->
name|cdb_len
argument_list|,
sizeof|sizeof
argument_list|(
name|io
operator|->
name|scsiio
operator|.
name|cdb
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|io
operator|->
name|scsiio
operator|.
name|cdb
argument_list|,
name|io
operator|->
name|scsiio
operator|.
name|cdb_len
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SIM_QUEUED
expr_stmt|;
name|err
operator|=
name|ctl_queue
argument_list|(
name|io
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|CTL_RETVAL_COMPLETE
condition|)
block|{
name|printf
argument_list|(
literal|"%s: func %d: error %d returned by "
literal|"ctl_queue()!\n"
argument_list|,
name|__func__
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|ctl_free_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
block|}
case|case
name|XPT_ABORT
case|:
block|{
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|union
name|ccb
modifier|*
name|abort_ccb
decl_stmt|;
name|abort_ccb
operator|=
name|ccb
operator|->
name|cab
operator|.
name|abort_ccb
expr_stmt|;
if|if
condition|(
name|abort_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|!=
name|XPT_SCSI_IO
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If we aren't online, there are no devices to talk to. 		 */
if|if
condition|(
name|softc
operator|->
name|online
operator|==
literal|0
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_DEV_NOT_THERE
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|io
operator|=
name|ctl_alloc_io_nowait
argument_list|(
name|softc
operator|->
name|port
operator|.
name|ctl_pool_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|==
name|NULL
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_BUSY
operator||
name|CAM_DEV_QFRZN
expr_stmt|;
name|xpt_freeze_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|ctl_zero_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
comment|/* Save pointers on both sides */
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_FRONTEND
index|]
operator|.
name|ptr
operator|=
name|ccb
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|io_ptr
operator|=
name|io
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|io_type
operator|=
name|CTL_IO_TASK
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|initid
operator|.
name|id
operator|=
literal|1
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
operator|=
name|softc
operator|->
name|port
operator|.
name|targ_port
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_target
operator|.
name|id
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_lun
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
name|io
operator|->
name|taskio
operator|.
name|task_action
operator|=
name|CTL_TASK_ABORT_TASK
expr_stmt|;
name|io
operator|->
name|taskio
operator|.
name|tag_num
operator|=
name|abort_ccb
operator|->
name|csio
operator|.
name|tag_id
expr_stmt|;
switch|switch
condition|(
name|abort_ccb
operator|->
name|csio
operator|.
name|tag_action
condition|)
block|{
case|case
name|CAM_TAG_ACTION_NONE
case|:
name|io
operator|->
name|taskio
operator|.
name|tag_type
operator|=
name|CTL_TAG_UNTAGGED
expr_stmt|;
break|break;
case|case
name|MSG_SIMPLE_TASK
case|:
name|io
operator|->
name|taskio
operator|.
name|tag_type
operator|=
name|CTL_TAG_SIMPLE
expr_stmt|;
break|break;
case|case
name|MSG_HEAD_OF_QUEUE_TASK
case|:
name|io
operator|->
name|taskio
operator|.
name|tag_type
operator|=
name|CTL_TAG_HEAD_OF_QUEUE
expr_stmt|;
break|break;
case|case
name|MSG_ORDERED_TASK
case|:
name|io
operator|->
name|taskio
operator|.
name|tag_type
operator|=
name|CTL_TAG_ORDERED
expr_stmt|;
break|break;
case|case
name|MSG_ACA_TASK
case|:
name|io
operator|->
name|taskio
operator|.
name|tag_type
operator|=
name|CTL_TAG_ACA
expr_stmt|;
break|break;
default|default:
name|io
operator|->
name|taskio
operator|.
name|tag_type
operator|=
name|CTL_TAG_UNTAGGED
expr_stmt|;
name|printf
argument_list|(
literal|"%s: unhandled tag type %#x!!\n"
argument_list|,
name|__func__
argument_list|,
name|abort_ccb
operator|->
name|csio
operator|.
name|tag_action
argument_list|)
expr_stmt|;
break|break;
block|}
name|err
operator|=
name|ctl_queue
argument_list|(
name|io
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|CTL_RETVAL_COMPLETE
condition|)
block|{
name|printf
argument_list|(
literal|"%s func %d: error %d returned by "
literal|"ctl_queue()!\n"
argument_list|,
name|__func__
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|ctl_free_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|XPT_GET_TRAN_SETTINGS
case|:
block|{
name|struct
name|ccb_trans_settings
modifier|*
name|cts
decl_stmt|;
name|struct
name|ccb_trans_settings_scsi
modifier|*
name|scsi
decl_stmt|;
name|struct
name|ccb_trans_settings_fc
modifier|*
name|fc
decl_stmt|;
name|cts
operator|=
operator|&
name|ccb
operator|->
name|cts
expr_stmt|;
name|scsi
operator|=
operator|&
name|cts
operator|->
name|proto_specific
operator|.
name|scsi
expr_stmt|;
name|fc
operator|=
operator|&
name|cts
operator|->
name|xport_specific
operator|.
name|fc
expr_stmt|;
name|cts
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cts
operator|->
name|protocol_version
operator|=
name|SCSI_REV_SPC2
expr_stmt|;
name|cts
operator|->
name|transport
operator|=
name|XPORT_FC
expr_stmt|;
name|cts
operator|->
name|transport_version
operator|=
literal|0
expr_stmt|;
name|scsi
operator|->
name|valid
operator|=
name|CTS_SCSI_VALID_TQ
expr_stmt|;
name|scsi
operator|->
name|flags
operator|=
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
name|fc
operator|->
name|valid
operator|=
name|CTS_FC_VALID_SPEED
expr_stmt|;
name|fc
operator|->
name|bitrate
operator|=
literal|800000
expr_stmt|;
name|fc
operator|->
name|wwnn
operator|=
name|softc
operator|->
name|wwnn
expr_stmt|;
name|fc
operator|->
name|wwpn
operator|=
name|softc
operator|->
name|wwpn
expr_stmt|;
name|fc
operator|->
name|port
operator|=
name|softc
operator|->
name|port
operator|.
name|targ_port
expr_stmt|;
name|fc
operator|->
name|valid
operator||=
name|CTS_FC_VALID_WWNN
operator||
name|CTS_FC_VALID_WWPN
operator||
name|CTS_FC_VALID_PORT
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
block|}
case|case
name|XPT_SET_TRAN_SETTINGS
case|:
comment|/* XXX KDM should we actually do something here? */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
case|case
name|XPT_RESET_BUS
case|:
case|case
name|XPT_RESET_DEV
case|:
block|{
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
comment|/* 		 * If we aren't online, there are no devices to talk to. 		 */
if|if
condition|(
name|softc
operator|->
name|online
operator|==
literal|0
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_DEV_NOT_THERE
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|io
operator|=
name|ctl_alloc_io_nowait
argument_list|(
name|softc
operator|->
name|port
operator|.
name|ctl_pool_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|==
name|NULL
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_BUSY
operator||
name|CAM_DEV_QFRZN
expr_stmt|;
name|xpt_freeze_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|ctl_zero_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
comment|/* Save pointers on both sides */
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_RESET_DEV
condition|)
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_FRONTEND
index|]
operator|.
name|ptr
operator|=
name|ccb
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|io_ptr
operator|=
name|io
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|io_type
operator|=
name|CTL_IO_TASK
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|initid
operator|.
name|id
operator|=
literal|0
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
operator|=
name|softc
operator|->
name|port
operator|.
name|targ_port
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_target
operator|.
name|id
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_lun
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_RESET_BUS
condition|)
name|io
operator|->
name|taskio
operator|.
name|task_action
operator|=
name|CTL_TASK_BUS_RESET
expr_stmt|;
else|else
name|io
operator|->
name|taskio
operator|.
name|task_action
operator|=
name|CTL_TASK_LUN_RESET
expr_stmt|;
name|err
operator|=
name|ctl_queue
argument_list|(
name|io
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|CTL_RETVAL_COMPLETE
condition|)
block|{
name|printf
argument_list|(
literal|"%s func %d: error %d returned by "
literal|"ctl_queue()!\n"
argument_list|,
name|__func__
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|ctl_free_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|XPT_CALC_GEOMETRY
case|:
name|cam_calc_geometry
argument_list|(
operator|&
name|ccb
operator|->
name|ccg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_PATH_INQ
case|:
block|{
name|struct
name|ccb_pathinq
modifier|*
name|cpi
decl_stmt|;
name|cpi
operator|=
operator|&
name|ccb
operator|->
name|cpi
expr_stmt|;
name|cpi
operator|->
name|version_num
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_inquiry
operator|=
name|PI_TAG_ABLE
expr_stmt|;
name|cpi
operator|->
name|target_sprt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_misc
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_eng_cnt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|max_target
operator|=
literal|1
expr_stmt|;
name|cpi
operator|->
name|max_lun
operator|=
literal|1024
expr_stmt|;
comment|/* Do we really have a limit? */
name|cpi
operator|->
name|maxio
operator|=
literal|1024
operator|*
literal|1024
expr_stmt|;
name|cpi
operator|->
name|async_flags
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hpath_id
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|initiator_id
operator|=
literal|0
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|sim_vid
argument_list|,
literal|"FreeBSD"
argument_list|,
name|SIM_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|hba_vid
argument_list|,
literal|"FreeBSD"
argument_list|,
name|HBA_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|dev_name
argument_list|,
name|cam_sim_name
argument_list|(
name|sim
argument_list|)
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|unit_number
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|bus_id
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|base_transfer_speed
operator|=
literal|800000
expr_stmt|;
name|cpi
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cpi
operator|->
name|protocol_version
operator|=
name|SCSI_REV_SPC2
expr_stmt|;
comment|/* 		 * Pretend to be Fibre Channel. 		 */
name|cpi
operator|->
name|transport
operator|=
name|XPORT_FC
expr_stmt|;
name|cpi
operator|->
name|transport_version
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|xport_specific
operator|.
name|fc
operator|.
name|wwnn
operator|=
name|softc
operator|->
name|wwnn
expr_stmt|;
name|cpi
operator|->
name|xport_specific
operator|.
name|fc
operator|.
name|wwpn
operator|=
name|softc
operator|->
name|wwpn
expr_stmt|;
name|cpi
operator|->
name|xport_specific
operator|.
name|fc
operator|.
name|port
operator|=
name|softc
operator|->
name|port
operator|.
name|targ_port
expr_stmt|;
name|cpi
operator|->
name|xport_specific
operator|.
name|fc
operator|.
name|bitrate
operator|=
literal|8
operator|*
literal|1000
operator|*
literal|1000
expr_stmt|;
name|cpi
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
block|}
default|default:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_PROVIDE_FAIL
expr_stmt|;
name|printf
argument_list|(
literal|"%s: unsupported CCB type %#x\n"
argument_list|,
name|__func__
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cfcs_async
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|uint32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{  }
end_function

end_unit

