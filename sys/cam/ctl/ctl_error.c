begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003-2009 Silicon Graphics International Corp.  * Copyright (c) 2011 Spectra Logic Corporation  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    substantially similar to the "NO WARRANTY" disclaimer below  *    ("Disclaimer") and any redistribution must be conditioned upon  *    including a substantially similar Disclaimer requirement for further  *    binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGES.  *  * $Id: //depot/users/kenm/FreeBSD-test2/sys/cam/ctl/ctl_error.c#2 $  */
end_comment

begin_comment
comment|/*  * CAM Target Layer error reporting routines.  *  * Author: Ken Merry<ken@FreeBSD.org>  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/stddef.h>
end_include

begin_include
include|#
directive|include
file|<sys/ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_da.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_io.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_frontend.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_frontend_internal.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_backend.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_error.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_ha.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_private.h>
end_include

begin_function
name|void
name|ctl_set_sense_data_va
parameter_list|(
name|struct
name|scsi_sense_data
modifier|*
name|sense_data
parameter_list|,
name|void
modifier|*
name|lunptr
parameter_list|,
name|scsi_sense_data_type
name|sense_format
parameter_list|,
name|int
name|current_error
parameter_list|,
name|int
name|sense_key
parameter_list|,
name|int
name|asc
parameter_list|,
name|int
name|ascq
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|lunptr
expr_stmt|;
comment|/* 	 * Determine whether to return fixed or descriptor format sense 	 * data. 	 */
if|if
condition|(
name|sense_format
operator|==
name|SSD_TYPE_NONE
condition|)
block|{
comment|/* 		 * If the format isn't specified, we only return descriptor 		 * sense if the LUN exists and descriptor sense is turned 		 * on for that LUN. 		 */
if|if
condition|(
operator|(
name|lun
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_SENSE_DESC
operator|)
condition|)
name|sense_format
operator|=
name|SSD_TYPE_DESC
expr_stmt|;
else|else
name|sense_format
operator|=
name|SSD_TYPE_FIXED
expr_stmt|;
block|}
name|scsi_set_sense_data_va
argument_list|(
name|sense_data
argument_list|,
name|sense_format
argument_list|,
name|current_error
argument_list|,
name|sense_key
argument_list|,
name|asc
argument_list|,
name|ascq
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ctl_set_sense_data
parameter_list|(
name|struct
name|scsi_sense_data
modifier|*
name|sense_data
parameter_list|,
name|void
modifier|*
name|lunptr
parameter_list|,
name|scsi_sense_data_type
name|sense_format
parameter_list|,
name|int
name|current_error
parameter_list|,
name|int
name|sense_key
parameter_list|,
name|int
name|asc
parameter_list|,
name|int
name|ascq
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|ascq
argument_list|)
expr_stmt|;
name|ctl_set_sense_data_va
argument_list|(
name|sense_data
argument_list|,
name|lunptr
argument_list|,
name|sense_format
argument_list|,
name|current_error
argument_list|,
name|sense_key
argument_list|,
name|asc
argument_list|,
name|ascq
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ctl_set_sense
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|int
name|current_error
parameter_list|,
name|int
name|sense_key
parameter_list|,
name|int
name|asc
parameter_list|,
name|int
name|ascq
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
comment|/* 	 * The LUN can't go away until all of the commands have been 	 * completed.  Therefore we can safely access the LUN structure and 	 * flags without the lock. 	 */
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LUN
index|]
operator|.
name|ptr
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|ascq
argument_list|)
expr_stmt|;
name|ctl_set_sense_data_va
argument_list|(
operator|&
name|ctsio
operator|->
name|sense_data
argument_list|,
name|lun
argument_list|,
name|SSD_TYPE_NONE
argument_list|,
name|current_error
argument_list|,
name|sense_key
argument_list|,
name|asc
argument_list|,
name|ascq
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|scsi_status
operator|=
name|SCSI_STATUS_CHECK_COND
expr_stmt|;
name|ctsio
operator|->
name|sense_len
operator|=
name|SSD_FULL_SIZE
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|status
operator|=
name|CTL_SCSI_ERROR
operator||
name|CTL_AUTOSENSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Transform fixed sense data into descriptor sense data.  *   * For simplicity's sake, we assume that both sense structures are  * SSD_FULL_SIZE.  Otherwise, the logic gets more complicated.  */
end_comment

begin_function
name|void
name|ctl_sense_to_desc
parameter_list|(
name|struct
name|scsi_sense_data_fixed
modifier|*
name|sense_src
parameter_list|,
name|struct
name|scsi_sense_data_desc
modifier|*
name|sense_dest
parameter_list|)
block|{
name|struct
name|scsi_sense_stream
name|stream_sense
decl_stmt|;
name|int
name|current_error
decl_stmt|;
name|uint8_t
name|stream_bits
decl_stmt|;
name|bzero
argument_list|(
name|sense_dest
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sense_dest
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sense_src
operator|->
name|error_code
operator|&
name|SSD_ERRCODE
operator|)
operator|==
name|SSD_DEFERRED_ERROR
condition|)
name|current_error
operator|=
literal|0
expr_stmt|;
else|else
name|current_error
operator|=
literal|1
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|stream_sense
argument_list|,
sizeof|sizeof
argument_list|(
name|stream_sense
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Check to see whether any of the tape-specific bits are set.  If 	 * so, we'll need a stream sense descriptor. 	 */
if|if
condition|(
name|sense_src
operator|->
name|flags
operator|&
operator|(
name|SSD_ILI
operator||
name|SSD_EOM
operator||
name|SSD_FILEMARK
operator|)
condition|)
name|stream_bits
operator|=
name|sense_src
operator|->
name|flags
operator|&
operator|~
name|SSD_KEY
expr_stmt|;
else|else
name|stream_bits
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Utilize our sense setting routine to do the transform.  If a 	 * value is set in the fixed sense data, set it in the descriptor 	 * data.  Otherwise, skip it. 	 */
name|ctl_set_sense_data
argument_list|(
operator|(
expr|struct
name|scsi_sense_data
operator|*
operator|)
name|sense_dest
argument_list|,
comment|/*lun*/
name|NULL
argument_list|,
comment|/*sense_format*/
name|SSD_TYPE_DESC
argument_list|,
name|current_error
argument_list|,
comment|/*sense_key*/
name|sense_src
operator|->
name|flags
operator|&
name|SSD_KEY
argument_list|,
comment|/*asc*/
name|sense_src
operator|->
name|add_sense_code
argument_list|,
comment|/*ascq*/
name|sense_src
operator|->
name|add_sense_code_qual
argument_list|,
comment|/* Information Bytes */
operator|(
name|scsi_4btoul
argument_list|(
name|sense_src
operator|->
name|info
argument_list|)
operator|!=
literal|0
operator|)
condition|?
name|SSD_ELEM_INFO
else|:
name|SSD_ELEM_SKIP
argument_list|,
sizeof|sizeof
argument_list|(
name|sense_src
operator|->
name|info
argument_list|)
argument_list|,
name|sense_src
operator|->
name|info
argument_list|,
comment|/* Command specific bytes */
operator|(
name|scsi_4btoul
argument_list|(
name|sense_src
operator|->
name|cmd_spec_info
argument_list|)
operator|!=
literal|0
operator|)
condition|?
name|SSD_ELEM_COMMAND
else|:
name|SSD_ELEM_SKIP
argument_list|,
sizeof|sizeof
argument_list|(
name|sense_src
operator|->
name|cmd_spec_info
argument_list|)
argument_list|,
name|sense_src
operator|->
name|cmd_spec_info
argument_list|,
comment|/* FRU */
operator|(
name|sense_src
operator|->
name|fru
operator|!=
literal|0
operator|)
condition|?
name|SSD_ELEM_FRU
else|:
name|SSD_ELEM_SKIP
argument_list|,
sizeof|sizeof
argument_list|(
name|sense_src
operator|->
name|fru
argument_list|)
argument_list|,
operator|&
name|sense_src
operator|->
name|fru
argument_list|,
comment|/* Sense Key Specific */
operator|(
name|sense_src
operator|->
name|sense_key_spec
index|[
literal|0
index|]
operator|&
name|SSD_SCS_VALID
operator|)
condition|?
name|SSD_ELEM_SKS
else|:
name|SSD_ELEM_SKIP
argument_list|,
sizeof|sizeof
argument_list|(
name|sense_src
operator|->
name|sense_key_spec
argument_list|)
argument_list|,
name|sense_src
operator|->
name|sense_key_spec
argument_list|,
comment|/* Tape bits */
operator|(
name|stream_bits
operator|!=
literal|0
operator|)
condition|?
name|SSD_ELEM_STREAM
else|:
name|SSD_ELEM_SKIP
argument_list|,
sizeof|sizeof
argument_list|(
name|stream_bits
argument_list|)
argument_list|,
operator|&
name|stream_bits
argument_list|,
name|SSD_ELEM_NONE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Transform descriptor format sense data into fixed sense data.  *  * Some data may be lost in translation, because there are descriptors  * thant can't be represented as fixed sense data.  *  * For simplicity's sake, we assume that both sense structures are  * SSD_FULL_SIZE.  Otherwise, the logic gets more complicated.  */
end_comment

begin_function
name|void
name|ctl_sense_to_fixed
parameter_list|(
name|struct
name|scsi_sense_data_desc
modifier|*
name|sense_src
parameter_list|,
name|struct
name|scsi_sense_data_fixed
modifier|*
name|sense_dest
parameter_list|)
block|{
name|int
name|current_error
decl_stmt|;
name|uint8_t
modifier|*
name|info_ptr
init|=
name|NULL
decl_stmt|,
modifier|*
name|cmd_ptr
init|=
name|NULL
decl_stmt|,
modifier|*
name|fru_ptr
init|=
name|NULL
decl_stmt|;
name|uint8_t
modifier|*
name|sks_ptr
init|=
name|NULL
decl_stmt|,
modifier|*
name|stream_ptr
init|=
name|NULL
decl_stmt|;
name|int
name|info_size
init|=
literal|0
decl_stmt|,
name|cmd_size
init|=
literal|0
decl_stmt|,
name|fru_size
init|=
literal|0
decl_stmt|;
name|int
name|sks_size
init|=
literal|0
decl_stmt|,
name|stream_size
init|=
literal|0
decl_stmt|;
name|int
name|pos
decl_stmt|;
if|if
condition|(
operator|(
name|sense_src
operator|->
name|error_code
operator|&
name|SSD_ERRCODE
operator|)
operator|==
name|SSD_DESC_CURRENT_ERROR
condition|)
name|current_error
operator|=
literal|1
expr_stmt|;
else|else
name|current_error
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pos
operator|=
literal|0
init|;
name|pos
operator|<
call|(
name|int
call|)
argument_list|(
name|sense_src
operator|->
name|extra_len
operator|-
literal|1
argument_list|)
condition|;
control|)
block|{
name|struct
name|scsi_sense_desc_header
modifier|*
name|header
decl_stmt|;
name|header
operator|=
operator|(
expr|struct
name|scsi_sense_desc_header
operator|*
operator|)
operator|&
name|sense_src
operator|->
name|sense_desc
index|[
name|pos
index|]
expr_stmt|;
comment|/* 		 * See if this record goes past the end of the sense data. 		 * It shouldn't, but check just in case. 		 */
if|if
condition|(
operator|(
name|pos
operator|+
name|header
operator|->
name|length
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|header
argument_list|)
operator|)
operator|>
name|sense_src
operator|->
name|extra_len
condition|)
break|break;
switch|switch
condition|(
name|sense_src
operator|->
name|sense_desc
index|[
name|pos
index|]
condition|)
block|{
case|case
name|SSD_DESC_INFO
case|:
block|{
name|struct
name|scsi_sense_info
modifier|*
name|info
decl_stmt|;
name|info
operator|=
operator|(
expr|struct
name|scsi_sense_info
operator|*
operator|)
name|header
expr_stmt|;
name|info_ptr
operator|=
name|info
operator|->
name|info
expr_stmt|;
name|info_size
operator|=
sizeof|sizeof
argument_list|(
name|info
operator|->
name|info
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|info
operator|->
name|length
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_desc_header
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SSD_DESC_COMMAND
case|:
block|{
name|struct
name|scsi_sense_command
modifier|*
name|cmd
decl_stmt|;
name|cmd
operator|=
operator|(
expr|struct
name|scsi_sense_command
operator|*
operator|)
name|header
expr_stmt|;
name|cmd_ptr
operator|=
name|cmd
operator|->
name|command_info
expr_stmt|;
name|cmd_size
operator|=
sizeof|sizeof
argument_list|(
name|cmd
operator|->
name|command_info
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|cmd
operator|->
name|length
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_desc_header
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SSD_DESC_FRU
case|:
block|{
name|struct
name|scsi_sense_fru
modifier|*
name|fru
decl_stmt|;
name|fru
operator|=
operator|(
expr|struct
name|scsi_sense_fru
operator|*
operator|)
name|header
expr_stmt|;
name|fru_ptr
operator|=
operator|&
name|fru
operator|->
name|fru
expr_stmt|;
name|fru_size
operator|=
sizeof|sizeof
argument_list|(
name|fru
operator|->
name|fru
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|fru
operator|->
name|length
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_desc_header
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SSD_DESC_SKS
case|:
block|{
name|struct
name|scsi_sense_sks
modifier|*
name|sks
decl_stmt|;
name|sks
operator|=
operator|(
expr|struct
name|scsi_sense_sks
operator|*
operator|)
name|header
expr_stmt|;
name|sks_ptr
operator|=
name|sks
operator|->
name|sense_key_spec
expr_stmt|;
name|sks_size
operator|=
sizeof|sizeof
argument_list|(
name|sks
operator|->
name|sense_key_spec
argument_list|)
expr_stmt|;
name|pos
operator|=
name|sks
operator|->
name|length
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_desc_header
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SSD_DESC_STREAM
case|:
block|{
name|struct
name|scsi_sense_stream
modifier|*
name|stream_sense
decl_stmt|;
name|stream_sense
operator|=
operator|(
expr|struct
name|scsi_sense_stream
operator|*
operator|)
name|header
expr_stmt|;
name|stream_ptr
operator|=
operator|&
name|stream_sense
operator|->
name|byte3
expr_stmt|;
name|stream_size
operator|=
sizeof|sizeof
argument_list|(
name|stream_sense
operator|->
name|byte3
argument_list|)
expr_stmt|;
name|pos
operator|=
name|stream_sense
operator|->
name|length
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_desc_header
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
comment|/* 			 * We don't recognize this particular sense 			 * descriptor type, so just skip it. 			 */
name|pos
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|header
argument_list|)
operator|+
name|header
operator|->
name|length
expr_stmt|;
break|break;
block|}
block|}
name|ctl_set_sense_data
argument_list|(
operator|(
expr|struct
name|scsi_sense_data
operator|*
operator|)
name|sense_dest
argument_list|,
comment|/*lun*/
name|NULL
argument_list|,
comment|/*sense_format*/
name|SSD_TYPE_FIXED
argument_list|,
name|current_error
argument_list|,
comment|/*sense_key*/
name|sense_src
operator|->
name|sense_key
operator|&
name|SSD_KEY
argument_list|,
comment|/*asc*/
name|sense_src
operator|->
name|add_sense_code
argument_list|,
comment|/*ascq*/
name|sense_src
operator|->
name|add_sense_code_qual
argument_list|,
comment|/* Information Bytes */
operator|(
name|info_ptr
operator|!=
name|NULL
operator|)
condition|?
name|SSD_ELEM_INFO
else|:
name|SSD_ELEM_SKIP
argument_list|,
name|info_size
argument_list|,
name|info_ptr
argument_list|,
comment|/* Command specific bytes */
operator|(
name|cmd_ptr
operator|!=
name|NULL
operator|)
condition|?
name|SSD_ELEM_COMMAND
else|:
name|SSD_ELEM_SKIP
argument_list|,
name|cmd_size
argument_list|,
name|cmd_ptr
argument_list|,
comment|/* FRU */
operator|(
name|fru_ptr
operator|!=
name|NULL
operator|)
condition|?
name|SSD_ELEM_FRU
else|:
name|SSD_ELEM_SKIP
argument_list|,
name|fru_size
argument_list|,
name|fru_ptr
argument_list|,
comment|/* Sense Key Specific */
operator|(
name|sks_ptr
operator|!=
name|NULL
operator|)
condition|?
name|SSD_ELEM_SKS
else|:
name|SSD_ELEM_SKIP
argument_list|,
name|sks_size
argument_list|,
name|sks_ptr
argument_list|,
comment|/* Tape bits */
operator|(
name|stream_ptr
operator|!=
name|NULL
operator|)
condition|?
name|SSD_ELEM_STREAM
else|:
name|SSD_ELEM_SKIP
argument_list|,
name|stream_size
argument_list|,
name|stream_ptr
argument_list|,
name|SSD_ELEM_NONE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ctl_set_ua
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|int
name|asc
parameter_list|,
name|int
name|ascq
parameter_list|)
block|{
name|ctl_set_sense
argument_list|(
name|ctsio
argument_list|,
comment|/*current_error*/
literal|1
argument_list|,
comment|/*sense_key*/
name|SSD_KEY_UNIT_ATTENTION
argument_list|,
name|asc
argument_list|,
name|ascq
argument_list|,
name|SSD_ELEM_NONE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|ctl_ua_type
name|ctl_build_ua
parameter_list|(
name|ctl_ua_type
modifier|*
name|ua_type
parameter_list|,
name|struct
name|scsi_sense_data
modifier|*
name|sense
parameter_list|,
name|scsi_sense_data_type
name|sense_format
parameter_list|)
block|{
name|ctl_ua_type
name|ua_to_build
decl_stmt|,
name|ua_to_clear
decl_stmt|;
name|int
name|asc
decl_stmt|,
name|ascq
decl_stmt|;
if|if
condition|(
operator|*
name|ua_type
operator|==
name|CTL_UA_NONE
condition|)
return|return
operator|(
name|CTL_UA_NONE
operator|)
return|;
name|ua_to_build
operator|=
operator|(
literal|1
operator|<<
operator|(
name|ffs
argument_list|(
operator|*
name|ua_type
argument_list|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|ua_to_clear
operator|=
name|ua_to_build
expr_stmt|;
switch|switch
condition|(
name|ua_to_build
condition|)
block|{
case|case
name|CTL_UA_POWERON
case|:
comment|/* 29h/01h  POWER ON OCCURRED */
name|asc
operator|=
literal|0x29
expr_stmt|;
name|ascq
operator|=
literal|0x01
expr_stmt|;
name|ua_to_clear
operator|=
operator|~
literal|0
expr_stmt|;
break|break;
case|case
name|CTL_UA_BUS_RESET
case|:
comment|/* 29h/02h  SCSI BUS RESET OCCURRED */
name|asc
operator|=
literal|0x29
expr_stmt|;
name|ascq
operator|=
literal|0x02
expr_stmt|;
name|ua_to_clear
operator|=
operator|~
literal|0
expr_stmt|;
break|break;
case|case
name|CTL_UA_TARG_RESET
case|:
comment|/* 29h/03h  BUS DEVICE RESET FUNCTION OCCURRED*/
name|asc
operator|=
literal|0x29
expr_stmt|;
name|ascq
operator|=
literal|0x03
expr_stmt|;
name|ua_to_clear
operator|=
operator|~
literal|0
expr_stmt|;
break|break;
case|case
name|CTL_UA_I_T_NEXUS_LOSS
case|:
comment|/* 29h/07h  I_T NEXUS LOSS OCCURRED */
name|asc
operator|=
literal|0x29
expr_stmt|;
name|ascq
operator|=
literal|0x07
expr_stmt|;
name|ua_to_clear
operator|=
operator|~
literal|0
expr_stmt|;
break|break;
case|case
name|CTL_UA_LUN_RESET
case|:
comment|/* 29h/00h  POWER ON, RESET, OR BUS DEVICE RESET OCCURRED */
comment|/* 		 * Since we don't have a specific ASC/ASCQ pair for a LUN 		 * reset, just return the generic reset code. 		 */
name|asc
operator|=
literal|0x29
expr_stmt|;
name|ascq
operator|=
literal|0x00
expr_stmt|;
break|break;
case|case
name|CTL_UA_LUN_CHANGE
case|:
comment|/* 3Fh/0Eh  REPORTED LUNS DATA HAS CHANGED */
name|asc
operator|=
literal|0x3F
expr_stmt|;
name|ascq
operator|=
literal|0x0E
expr_stmt|;
break|break;
case|case
name|CTL_UA_MODE_CHANGE
case|:
comment|/* 2Ah/01h  MODE PARAMETERS CHANGED */
name|asc
operator|=
literal|0x2A
expr_stmt|;
name|ascq
operator|=
literal|0x01
expr_stmt|;
break|break;
case|case
name|CTL_UA_LOG_CHANGE
case|:
comment|/* 2Ah/02h  LOG PARAMETERS CHANGED */
name|asc
operator|=
literal|0x2A
expr_stmt|;
name|ascq
operator|=
literal|0x02
expr_stmt|;
break|break;
case|case
name|CTL_UA_LVD
case|:
comment|/* 29h/06h  TRANSCEIVER MODE CHANGED TO LVD */
name|asc
operator|=
literal|0x29
expr_stmt|;
name|ascq
operator|=
literal|0x06
expr_stmt|;
break|break;
case|case
name|CTL_UA_SE
case|:
comment|/* 29h/05h  TRANSCEIVER MODE CHANGED TO SINGLE-ENDED */
name|asc
operator|=
literal|0x29
expr_stmt|;
name|ascq
operator|=
literal|0x05
expr_stmt|;
break|break;
case|case
name|CTL_UA_RES_PREEMPT
case|:
comment|/* 2Ah/03h  RESERVATIONS PREEMPTED */
name|asc
operator|=
literal|0x2A
expr_stmt|;
name|ascq
operator|=
literal|0x03
expr_stmt|;
break|break;
case|case
name|CTL_UA_RES_RELEASE
case|:
comment|/* 2Ah/04h  RESERVATIONS RELEASED */
name|asc
operator|=
literal|0x2A
expr_stmt|;
name|ascq
operator|=
literal|0x04
expr_stmt|;
break|break;
case|case
name|CTL_UA_REG_PREEMPT
case|:
comment|/* 2Ah/05h  REGISTRATIONS PREEMPTED */
name|asc
operator|=
literal|0x2A
expr_stmt|;
name|ascq
operator|=
literal|0x05
expr_stmt|;
break|break;
case|case
name|CTL_UA_ASYM_ACC_CHANGE
case|:
comment|/* 2Ah/06n  ASYMMETRIC ACCESS STATE CHANGED */
name|asc
operator|=
literal|0x2A
expr_stmt|;
name|ascq
operator|=
literal|0x06
expr_stmt|;
break|break;
case|case
name|CTL_UA_CAPACITY_CHANGED
case|:
comment|/* 2Ah/09n  CAPACITY DATA HAS CHANGED */
name|asc
operator|=
literal|0x2A
expr_stmt|;
name|ascq
operator|=
literal|0x09
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"ctl_build_ua: Unknown UA %x"
argument_list|,
name|ua_to_build
argument_list|)
expr_stmt|;
block|}
name|ctl_set_sense_data
argument_list|(
name|sense
argument_list|,
comment|/*lun*/
name|NULL
argument_list|,
name|sense_format
argument_list|,
comment|/*current_error*/
literal|1
argument_list|,
comment|/*sense_key*/
name|SSD_KEY_UNIT_ATTENTION
argument_list|,
name|asc
argument_list|,
name|ascq
argument_list|,
name|SSD_ELEM_NONE
argument_list|)
expr_stmt|;
comment|/* We're reporting this UA, so clear it */
operator|*
name|ua_type
operator|&=
operator|~
name|ua_to_clear
expr_stmt|;
return|return
operator|(
name|ua_to_build
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ctl_set_overlapped_cmd
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
comment|/* OVERLAPPED COMMANDS ATTEMPTED */
name|ctl_set_sense
argument_list|(
name|ctsio
argument_list|,
comment|/*current_error*/
literal|1
argument_list|,
comment|/*sense_key*/
name|SSD_KEY_ILLEGAL_REQUEST
argument_list|,
comment|/*asc*/
literal|0x4E
argument_list|,
comment|/*ascq*/
literal|0x00
argument_list|,
name|SSD_ELEM_NONE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ctl_set_overlapped_tag
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|uint8_t
name|tag
parameter_list|)
block|{
comment|/* TAGGED OVERLAPPED COMMANDS (NN = QUEUE TAG) */
name|ctl_set_sense
argument_list|(
name|ctsio
argument_list|,
comment|/*current_error*/
literal|1
argument_list|,
comment|/*sense_key*/
name|SSD_KEY_ILLEGAL_REQUEST
argument_list|,
comment|/*asc*/
literal|0x4D
argument_list|,
comment|/*ascq*/
name|tag
argument_list|,
name|SSD_ELEM_NONE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Tell the user that there was a problem with the command or data he sent.  */
end_comment

begin_function
name|void
name|ctl_set_invalid_field
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|int
name|sks_valid
parameter_list|,
name|int
name|command
parameter_list|,
name|int
name|field
parameter_list|,
name|int
name|bit_valid
parameter_list|,
name|int
name|bit
parameter_list|)
block|{
name|uint8_t
name|sks
index|[
literal|3
index|]
decl_stmt|;
name|int
name|asc
decl_stmt|;
if|if
condition|(
name|command
operator|!=
literal|0
condition|)
block|{
comment|/* "Invalid field in CDB" */
name|asc
operator|=
literal|0x24
expr_stmt|;
block|}
else|else
block|{
comment|/* "Invalid field in parameter list" */
name|asc
operator|=
literal|0x26
expr_stmt|;
block|}
if|if
condition|(
name|sks_valid
condition|)
block|{
name|sks
index|[
literal|0
index|]
operator|=
name|SSD_SCS_VALID
expr_stmt|;
if|if
condition|(
name|command
condition|)
name|sks
index|[
literal|0
index|]
operator||=
name|SSD_FIELDPTR_CMD
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|field
argument_list|,
operator|&
name|sks
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|bit_valid
condition|)
name|sks
index|[
literal|0
index|]
operator||=
name|SSD_BITPTR_VALID
operator||
name|bit
expr_stmt|;
block|}
name|ctl_set_sense
argument_list|(
name|ctsio
argument_list|,
comment|/*current_error*/
literal|1
argument_list|,
comment|/*sense_key*/
name|SSD_KEY_ILLEGAL_REQUEST
argument_list|,
name|asc
argument_list|,
comment|/*ascq*/
literal|0x00
argument_list|,
comment|/*type*/
operator|(
name|sks_valid
operator|!=
literal|0
operator|)
condition|?
name|SSD_ELEM_SKS
else|:
name|SSD_ELEM_SKIP
argument_list|,
comment|/*size*/
sizeof|sizeof
argument_list|(
name|sks
argument_list|)
argument_list|,
comment|/*data*/
name|sks
argument_list|,
name|SSD_ELEM_NONE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ctl_set_invalid_opcode
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|scsi_sense_data
modifier|*
name|sense
decl_stmt|;
name|uint8_t
name|sks
index|[
literal|3
index|]
decl_stmt|;
name|sense
operator|=
operator|&
name|ctsio
operator|->
name|sense_data
expr_stmt|;
name|sks
index|[
literal|0
index|]
operator|=
name|SSD_SCS_VALID
operator||
name|SSD_FIELDPTR_CMD
expr_stmt|;
name|scsi_ulto2b
argument_list|(
literal|0
argument_list|,
operator|&
name|sks
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* "Invalid command operation code" */
name|ctl_set_sense
argument_list|(
name|ctsio
argument_list|,
comment|/*current_error*/
literal|1
argument_list|,
comment|/*sense_key*/
name|SSD_KEY_ILLEGAL_REQUEST
argument_list|,
comment|/*asc*/
literal|0x20
argument_list|,
comment|/*ascq*/
literal|0x00
argument_list|,
comment|/*type*/
name|SSD_ELEM_SKS
argument_list|,
comment|/*size*/
sizeof|sizeof
argument_list|(
name|sks
argument_list|)
argument_list|,
comment|/*data*/
name|sks
argument_list|,
name|SSD_ELEM_NONE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ctl_set_param_len_error
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
comment|/* "Parameter list length error" */
name|ctl_set_sense
argument_list|(
name|ctsio
argument_list|,
comment|/*current_error*/
literal|1
argument_list|,
comment|/*sense_key*/
name|SSD_KEY_ILLEGAL_REQUEST
argument_list|,
comment|/*asc*/
literal|0x1a
argument_list|,
comment|/*ascq*/
literal|0x00
argument_list|,
name|SSD_ELEM_NONE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ctl_set_already_locked
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
comment|/* Vendor unique "Somebody already is locked" */
name|ctl_set_sense
argument_list|(
name|ctsio
argument_list|,
comment|/*current_error*/
literal|1
argument_list|,
comment|/*sense_key*/
name|SSD_KEY_ILLEGAL_REQUEST
argument_list|,
comment|/*asc*/
literal|0x81
argument_list|,
comment|/*ascq*/
literal|0x00
argument_list|,
name|SSD_ELEM_NONE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ctl_set_unsupported_lun
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
comment|/* "Logical unit not supported" */
name|ctl_set_sense
argument_list|(
name|ctsio
argument_list|,
comment|/*current_error*/
literal|1
argument_list|,
comment|/*sense_key*/
name|SSD_KEY_ILLEGAL_REQUEST
argument_list|,
comment|/*asc*/
literal|0x25
argument_list|,
comment|/*ascq*/
literal|0x00
argument_list|,
name|SSD_ELEM_NONE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ctl_set_internal_failure
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|int
name|sks_valid
parameter_list|,
name|uint16_t
name|retry_count
parameter_list|)
block|{
name|uint8_t
name|sks
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
name|sks_valid
condition|)
block|{
name|sks
index|[
literal|0
index|]
operator|=
name|SSD_SCS_VALID
expr_stmt|;
name|sks
index|[
literal|1
index|]
operator|=
operator|(
name|retry_count
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|sks
index|[
literal|2
index|]
operator|=
name|retry_count
operator|&
literal|0xff
expr_stmt|;
block|}
comment|/* "Internal target failure" */
name|ctl_set_sense
argument_list|(
name|ctsio
argument_list|,
comment|/*current_error*/
literal|1
argument_list|,
comment|/*sense_key*/
name|SSD_KEY_HARDWARE_ERROR
argument_list|,
comment|/*asc*/
literal|0x44
argument_list|,
comment|/*ascq*/
literal|0x00
argument_list|,
comment|/*type*/
operator|(
name|sks_valid
operator|!=
literal|0
operator|)
condition|?
name|SSD_ELEM_SKS
else|:
name|SSD_ELEM_SKIP
argument_list|,
comment|/*size*/
sizeof|sizeof
argument_list|(
name|sks
argument_list|)
argument_list|,
comment|/*data*/
name|sks
argument_list|,
name|SSD_ELEM_NONE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ctl_set_medium_error
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
if|if
condition|(
operator|(
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_DATA_MASK
operator|)
operator|==
name|CTL_FLAG_DATA_IN
condition|)
block|{
comment|/* "Unrecovered read error" */
name|ctl_set_sense
argument_list|(
name|ctsio
argument_list|,
comment|/*current_error*/
literal|1
argument_list|,
comment|/*sense_key*/
name|SSD_KEY_MEDIUM_ERROR
argument_list|,
comment|/*asc*/
literal|0x11
argument_list|,
comment|/*ascq*/
literal|0x00
argument_list|,
name|SSD_ELEM_NONE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* "Write error - auto reallocation failed" */
name|ctl_set_sense
argument_list|(
name|ctsio
argument_list|,
comment|/*current_error*/
literal|1
argument_list|,
comment|/*sense_key*/
name|SSD_KEY_MEDIUM_ERROR
argument_list|,
comment|/*asc*/
literal|0x0C
argument_list|,
comment|/*ascq*/
literal|0x02
argument_list|,
name|SSD_ELEM_NONE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ctl_set_aborted
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|ctl_set_sense
argument_list|(
name|ctsio
argument_list|,
comment|/*current_error*/
literal|1
argument_list|,
comment|/*sense_key*/
name|SSD_KEY_ABORTED_COMMAND
argument_list|,
comment|/*asc*/
literal|0x45
argument_list|,
comment|/*ascq*/
literal|0x00
argument_list|,
name|SSD_ELEM_NONE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ctl_set_lba_out_of_range
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
comment|/* "Logical block address out of range" */
name|ctl_set_sense
argument_list|(
name|ctsio
argument_list|,
comment|/*current_error*/
literal|1
argument_list|,
comment|/*sense_key*/
name|SSD_KEY_ILLEGAL_REQUEST
argument_list|,
comment|/*asc*/
literal|0x21
argument_list|,
comment|/*ascq*/
literal|0x00
argument_list|,
name|SSD_ELEM_NONE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ctl_set_lun_stopped
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
comment|/* "Logical unit not ready, initializing cmd. required" */
name|ctl_set_sense
argument_list|(
name|ctsio
argument_list|,
comment|/*current_error*/
literal|1
argument_list|,
comment|/*sense_key*/
name|SSD_KEY_NOT_READY
argument_list|,
comment|/*asc*/
literal|0x04
argument_list|,
comment|/*ascq*/
literal|0x02
argument_list|,
name|SSD_ELEM_NONE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ctl_set_lun_not_ready
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
comment|/* "Logical unit not ready, manual intervention required" */
name|ctl_set_sense
argument_list|(
name|ctsio
argument_list|,
comment|/*current_error*/
literal|1
argument_list|,
comment|/*sense_key*/
name|SSD_KEY_NOT_READY
argument_list|,
comment|/*asc*/
literal|0x04
argument_list|,
comment|/*ascq*/
literal|0x03
argument_list|,
name|SSD_ELEM_NONE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ctl_set_illegal_pr_release
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
comment|/* "Invalid release of persistent reservation" */
name|ctl_set_sense
argument_list|(
name|ctsio
argument_list|,
comment|/*current_error*/
literal|1
argument_list|,
comment|/*sense_key*/
name|SSD_KEY_ILLEGAL_REQUEST
argument_list|,
comment|/*asc*/
literal|0x26
argument_list|,
comment|/*ascq*/
literal|0x04
argument_list|,
name|SSD_ELEM_NONE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ctl_set_lun_standby
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
comment|/* "Logical unit not ready, target port in standby state" */
name|ctl_set_sense
argument_list|(
name|ctsio
argument_list|,
comment|/*current_error*/
literal|1
argument_list|,
comment|/*sense_key*/
name|SSD_KEY_NOT_READY
argument_list|,
comment|/*asc*/
literal|0x04
argument_list|,
comment|/*ascq*/
literal|0x0b
argument_list|,
name|SSD_ELEM_NONE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ctl_set_medium_format_corrupted
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
comment|/* "Medium format corrupted" */
name|ctl_set_sense
argument_list|(
name|ctsio
argument_list|,
comment|/*current_error*/
literal|1
argument_list|,
comment|/*sense_key*/
name|SSD_KEY_MEDIUM_ERROR
argument_list|,
comment|/*asc*/
literal|0x31
argument_list|,
comment|/*ascq*/
literal|0x00
argument_list|,
name|SSD_ELEM_NONE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ctl_set_medium_magazine_inaccessible
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
comment|/* "Medium magazine not accessible" */
name|ctl_set_sense
argument_list|(
name|ctsio
argument_list|,
comment|/*current_error*/
literal|1
argument_list|,
comment|/*sense_key*/
name|SSD_KEY_NOT_READY
argument_list|,
comment|/*asc*/
literal|0x3b
argument_list|,
comment|/*ascq*/
literal|0x11
argument_list|,
name|SSD_ELEM_NONE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ctl_set_data_phase_error
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
comment|/* "Data phase error" */
name|ctl_set_sense
argument_list|(
name|ctsio
argument_list|,
comment|/*current_error*/
literal|1
argument_list|,
comment|/*sense_key*/
name|SSD_KEY_NOT_READY
argument_list|,
comment|/*asc*/
literal|0x4b
argument_list|,
comment|/*ascq*/
literal|0x00
argument_list|,
name|SSD_ELEM_NONE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ctl_set_reservation_conflict
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|scsi_sense_data
modifier|*
name|sense
decl_stmt|;
name|sense
operator|=
operator|&
name|ctsio
operator|->
name|sense_data
expr_stmt|;
name|memset
argument_list|(
name|sense
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sense
argument_list|)
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|scsi_status
operator|=
name|SCSI_STATUS_RESERV_CONFLICT
expr_stmt|;
name|ctsio
operator|->
name|sense_len
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|status
operator|=
name|CTL_SCSI_ERROR
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ctl_set_queue_full
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|scsi_sense_data
modifier|*
name|sense
decl_stmt|;
name|sense
operator|=
operator|&
name|ctsio
operator|->
name|sense_data
expr_stmt|;
name|memset
argument_list|(
name|sense
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sense
argument_list|)
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|scsi_status
operator|=
name|SCSI_STATUS_QUEUE_FULL
expr_stmt|;
name|ctsio
operator|->
name|sense_len
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|status
operator|=
name|CTL_SCSI_ERROR
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ctl_set_busy
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|scsi_sense_data
modifier|*
name|sense
decl_stmt|;
name|sense
operator|=
operator|&
name|ctsio
operator|->
name|sense_data
expr_stmt|;
name|memset
argument_list|(
name|sense
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sense
argument_list|)
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|scsi_status
operator|=
name|SCSI_STATUS_BUSY
expr_stmt|;
name|ctsio
operator|->
name|sense_len
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|status
operator|=
name|CTL_SCSI_ERROR
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ctl_set_task_aborted
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|scsi_sense_data
modifier|*
name|sense
decl_stmt|;
name|sense
operator|=
operator|&
name|ctsio
operator|->
name|sense_data
expr_stmt|;
name|memset
argument_list|(
name|sense
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sense
argument_list|)
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|scsi_status
operator|=
name|SCSI_STATUS_TASK_ABORTED
expr_stmt|;
name|ctsio
operator|->
name|sense_len
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|status
operator|=
name|CTL_CMD_ABORTED
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ctl_set_success
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|scsi_sense_data
modifier|*
name|sense
decl_stmt|;
name|sense
operator|=
operator|&
name|ctsio
operator|->
name|sense_data
expr_stmt|;
name|memset
argument_list|(
name|sense
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sense
argument_list|)
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|scsi_status
operator|=
name|SCSI_STATUS_OK
expr_stmt|;
name|ctsio
operator|->
name|sense_len
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|status
operator|=
name|CTL_SUCCESS
expr_stmt|;
block|}
end_function

end_unit

