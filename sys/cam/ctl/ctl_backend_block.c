begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003 Silicon Graphics International Corp.  * Copyright (c) 2009-2011 Spectra Logic Corporation  * Copyright (c) 2012 The FreeBSD Foundation  * All rights reserved.  *  * Portions of this software were developed by Edward Tomasz Napierala  * under sponsorship from the FreeBSD Foundation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    substantially similar to the "NO WARRANTY" disclaimer below  *    ("Disclaimer") and any redistribution must be conditioned upon  *    including a substantially similar Disclaimer requirement for further  *    binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGES.  *  * $Id: //depot/users/kenm/FreeBSD-test2/sys/cam/ctl/ctl_backend_block.c#5 $  */
end_comment

begin_comment
comment|/*  * CAM Target Layer driver backend for block devices.  *  * Author: Ken Merry<ken@FreeBSD.org>  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/disk.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/pcpu.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/sdt.h>
end_include

begin_include
include|#
directive|include
file|<sys/devicestat.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_da.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_io.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_backend.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_frontend_internal.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_error.h>
end_include

begin_comment
comment|/*  * The idea here is that we'll allocate enough S/G space to hold a 16MB  * I/O.  If we get an I/O larger than that, we'll reject it.  */
end_comment

begin_define
define|#
directive|define
name|CTLBLK_MAX_IO_SIZE
value|(16 * 1024 * 1024)
end_define

begin_define
define|#
directive|define
name|CTLBLK_MAX_SEGS
value|(CTLBLK_MAX_IO_SIZE / MAXPHYS) + 1
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|CTLBLK_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
define|\
value|printf("cbb(%s:%d): " fmt, __FUNCTION__, __LINE__, ##args)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
value|do {} while(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|SDT_PROVIDER_DEFINE
argument_list|(
name|cbb
argument_list|)
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
enum|enum
block|{
name|CTL_BE_BLOCK_LUN_UNCONFIGURED
init|=
literal|0x01
block|,
name|CTL_BE_BLOCK_LUN_CONFIG_ERR
init|=
literal|0x02
block|,
name|CTL_BE_BLOCK_LUN_WAITING
init|=
literal|0x04
block|,
name|CTL_BE_BLOCK_LUN_MULTI_THREAD
init|=
literal|0x08
block|}
name|ctl_be_block_lun_flags
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|CTL_BE_BLOCK_NONE
block|,
name|CTL_BE_BLOCK_DEV
block|,
name|CTL_BE_BLOCK_FILE
block|}
name|ctl_be_block_type
typedef|;
end_typedef

begin_struct
struct|struct
name|ctl_be_block_devdata
block|{
name|struct
name|cdev
modifier|*
name|cdev
decl_stmt|;
name|struct
name|cdevsw
modifier|*
name|csw
decl_stmt|;
name|int
name|dev_ref
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ctl_be_block_filedata
block|{
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
block|}
struct|;
end_struct

begin_union
union|union
name|ctl_be_block_bedata
block|{
name|struct
name|ctl_be_block_devdata
name|dev
decl_stmt|;
name|struct
name|ctl_be_block_filedata
name|file
decl_stmt|;
block|}
union|;
end_union

begin_struct_decl
struct_decl|struct
name|ctl_be_block_io
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|ctl_be_block_lun
struct_decl|;
end_struct_decl

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|cbb_dispatch_t
function_decl|)
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|struct
name|ctl_be_block_io
modifier|*
name|beio
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/*  * Backend LUN structure.  There is a 1:1 mapping between a block device  * and a backend block LUN, and between a backend block LUN and a CTL LUN.  */
end_comment

begin_struct
struct|struct
name|ctl_be_block_lun
block|{
name|struct
name|ctl_block_disk
modifier|*
name|disk
decl_stmt|;
name|char
name|lunname
index|[
literal|32
index|]
decl_stmt|;
name|char
modifier|*
name|dev_path
decl_stmt|;
name|ctl_be_block_type
name|dev_type
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vn
decl_stmt|;
name|union
name|ctl_be_block_bedata
name|backend
decl_stmt|;
name|cbb_dispatch_t
name|dispatch
decl_stmt|;
name|cbb_dispatch_t
name|lun_flush
decl_stmt|;
name|cbb_dispatch_t
name|unmap
decl_stmt|;
name|struct
name|mtx
name|lock
decl_stmt|;
name|uma_zone_t
name|lun_zone
decl_stmt|;
name|uint64_t
name|size_blocks
decl_stmt|;
name|uint64_t
name|size_bytes
decl_stmt|;
name|uint32_t
name|blocksize
decl_stmt|;
name|int
name|blocksize_shift
decl_stmt|;
name|uint16_t
name|pblockexp
decl_stmt|;
name|uint16_t
name|pblockoff
decl_stmt|;
name|struct
name|ctl_be_block_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|devstat
modifier|*
name|disk_stats
decl_stmt|;
name|ctl_be_block_lun_flags
name|flags
decl_stmt|;
name|STAILQ_ENTRY
argument_list|(
argument|ctl_be_block_lun
argument_list|)
name|links
expr_stmt|;
name|struct
name|ctl_be_lun
name|ctl_be_lun
decl_stmt|;
name|struct
name|taskqueue
modifier|*
name|io_taskqueue
decl_stmt|;
name|struct
name|task
name|io_task
decl_stmt|;
name|int
name|num_threads
decl_stmt|;
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|ctl_io_hdr
argument_list|)
name|input_queue
expr_stmt|;
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|ctl_io_hdr
argument_list|)
name|config_write_queue
expr_stmt|;
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|ctl_io_hdr
argument_list|)
name|datamove_queue
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Overall softc structure for the block backend module.  */
end_comment

begin_struct
struct|struct
name|ctl_be_block_softc
block|{
name|struct
name|mtx
name|lock
decl_stmt|;
name|int
name|num_disks
decl_stmt|;
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|ctl_block_disk
argument_list|)
name|disk_list
expr_stmt|;
name|int
name|num_luns
decl_stmt|;
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|ctl_be_block_lun
argument_list|)
name|lun_list
expr_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|ctl_be_block_softc
name|backend_block_softc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Per-I/O information.  */
end_comment

begin_struct
struct|struct
name|ctl_be_block_io
block|{
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|struct
name|ctl_sg_entry
name|sg_segs
index|[
name|CTLBLK_MAX_SEGS
index|]
decl_stmt|;
name|struct
name|iovec
name|xiovecs
index|[
name|CTLBLK_MAX_SEGS
index|]
decl_stmt|;
name|int
name|bio_cmd
decl_stmt|;
name|int
name|bio_flags
decl_stmt|;
name|int
name|num_segs
decl_stmt|;
name|int
name|num_bios_sent
decl_stmt|;
name|int
name|num_bios_done
decl_stmt|;
name|int
name|send_complete
decl_stmt|;
name|int
name|num_errors
decl_stmt|;
name|struct
name|bintime
name|ds_t0
decl_stmt|;
name|devstat_tag_type
name|ds_tag_type
decl_stmt|;
name|devstat_trans_flags
name|ds_trans_type
decl_stmt|;
name|uint64_t
name|io_len
decl_stmt|;
name|uint64_t
name|io_offset
decl_stmt|;
name|struct
name|ctl_be_block_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ctl_be_block_lun
modifier|*
name|lun
decl_stmt|;
name|void
function_decl|(
modifier|*
name|beio_cont
function_decl|)
parameter_list|(
name|struct
name|ctl_be_block_io
modifier|*
name|beio
parameter_list|)
function_decl|;
comment|/* to continue processing */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|cbb_num_threads
init|=
literal|14
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"kern.cam.ctl.block.num_threads"
argument_list|,
operator|&
name|cbb_num_threads
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_kern_cam_ctl
argument_list|,
name|OID_AUTO
argument_list|,
name|block
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"CAM Target Layer Block Backend"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_cam_ctl_block
argument_list|,
name|OID_AUTO
argument_list|,
name|num_threads
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|cbb_num_threads
argument_list|,
literal|0
argument_list|,
literal|"Number of threads per backing file"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|struct
name|ctl_be_block_io
modifier|*
name|ctl_alloc_beio
parameter_list|(
name|struct
name|ctl_be_block_softc
modifier|*
name|softc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_free_beio
parameter_list|(
name|struct
name|ctl_be_block_io
modifier|*
name|beio
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_complete_beio
parameter_list|(
name|struct
name|ctl_be_block_io
modifier|*
name|beio
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_be_block_move_done
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_be_block_biodone
parameter_list|(
name|struct
name|bio
modifier|*
name|bio
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_be_block_flush_file
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|struct
name|ctl_be_block_io
modifier|*
name|beio
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_be_block_dispatch_file
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|struct
name|ctl_be_block_io
modifier|*
name|beio
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_be_block_flush_dev
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|struct
name|ctl_be_block_io
modifier|*
name|beio
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_be_block_unmap_dev
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|struct
name|ctl_be_block_io
modifier|*
name|beio
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_be_block_dispatch_dev
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|struct
name|ctl_be_block_io
modifier|*
name|beio
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_be_block_cw_dispatch
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_be_block_dispatch
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_be_block_worker
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_be_block_submit
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_be_block_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_be_block_open_file
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|struct
name|ctl_lun_req
modifier|*
name|req
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_be_block_open_dev
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|struct
name|ctl_lun_req
modifier|*
name|req
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_be_block_close
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_be_block_open
parameter_list|(
name|struct
name|ctl_be_block_softc
modifier|*
name|softc
parameter_list|,
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|struct
name|ctl_lun_req
modifier|*
name|req
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_be_block_create
parameter_list|(
name|struct
name|ctl_be_block_softc
modifier|*
name|softc
parameter_list|,
name|struct
name|ctl_lun_req
modifier|*
name|req
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_be_block_rm
parameter_list|(
name|struct
name|ctl_be_block_softc
modifier|*
name|softc
parameter_list|,
name|struct
name|ctl_lun_req
modifier|*
name|req
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_be_block_modify_file
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|struct
name|ctl_lun_req
modifier|*
name|req
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_be_block_modify_dev
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|struct
name|ctl_lun_req
modifier|*
name|req
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_be_block_modify
parameter_list|(
name|struct
name|ctl_be_block_softc
modifier|*
name|softc
parameter_list|,
name|struct
name|ctl_lun_req
modifier|*
name|req
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_be_block_lun_shutdown
parameter_list|(
name|void
modifier|*
name|be_lun
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_be_block_lun_config_status
parameter_list|(
name|void
modifier|*
name|be_lun
parameter_list|,
name|ctl_lun_config_status
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_be_block_config_write
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_be_block_config_read
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_be_block_lun_info
parameter_list|(
name|void
modifier|*
name|be_lun
parameter_list|,
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ctl_be_block_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|ctl_backend_driver
name|ctl_be_block_driver
init|=
block|{
operator|.
name|name
operator|=
literal|"block"
block|,
operator|.
name|flags
operator|=
name|CTL_BE_FLAG_HAS_CONFIG
block|,
operator|.
name|init
operator|=
name|ctl_be_block_init
block|,
operator|.
name|data_submit
operator|=
name|ctl_be_block_submit
block|,
operator|.
name|data_move_done
operator|=
name|ctl_be_block_move_done
block|,
operator|.
name|config_read
operator|=
name|ctl_be_block_config_read
block|,
operator|.
name|config_write
operator|=
name|ctl_be_block_config_write
block|,
operator|.
name|ioctl
operator|=
name|ctl_be_block_ioctl
block|,
operator|.
name|lun_info
operator|=
name|ctl_be_block_lun_info
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_CTLBLK
argument_list|,
literal|"ctlblk"
argument_list|,
literal|"Memory used for CTL block backend"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTL_BACKEND_DECLARE
argument_list|(
name|cbb
argument_list|,
name|ctl_be_block_driver
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|uma_zone_t
name|beio_zone
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|ctl_be_block_io
modifier|*
name|ctl_alloc_beio
parameter_list|(
name|struct
name|ctl_be_block_softc
modifier|*
name|softc
parameter_list|)
block|{
name|struct
name|ctl_be_block_io
modifier|*
name|beio
decl_stmt|;
name|beio
operator|=
name|uma_zalloc
argument_list|(
name|beio_zone
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|beio
operator|->
name|softc
operator|=
name|softc
expr_stmt|;
return|return
operator|(
name|beio
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_free_beio
parameter_list|(
name|struct
name|ctl_be_block_io
modifier|*
name|beio
parameter_list|)
block|{
name|int
name|duplicate_free
decl_stmt|;
name|int
name|i
decl_stmt|;
name|duplicate_free
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|beio
operator|->
name|num_segs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|beio
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|addr
operator|==
name|NULL
condition|)
name|duplicate_free
operator|++
expr_stmt|;
name|uma_zfree
argument_list|(
name|beio
operator|->
name|lun
operator|->
name|lun_zone
argument_list|,
name|beio
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|addr
argument_list|)
expr_stmt|;
name|beio
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|addr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|duplicate_free
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: %d duplicate frees out of %d segments\n"
argument_list|,
name|__func__
argument_list|,
name|duplicate_free
argument_list|,
name|beio
operator|->
name|num_segs
argument_list|)
expr_stmt|;
block|}
name|uma_zfree
argument_list|(
name|beio_zone
argument_list|,
name|beio
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_complete_beio
parameter_list|(
name|struct
name|ctl_be_block_io
modifier|*
name|beio
parameter_list|)
block|{
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|int
name|io_len
decl_stmt|;
name|io
operator|=
name|beio
operator|->
name|io
expr_stmt|;
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|==
name|CTL_SUCCESS
condition|)
name|io_len
operator|=
name|beio
operator|->
name|io_len
expr_stmt|;
else|else
name|io_len
operator|=
literal|0
expr_stmt|;
name|devstat_end_transaction
argument_list|(
name|beio
operator|->
name|lun
operator|->
name|disk_stats
argument_list|,
comment|/*bytes*/
name|io_len
argument_list|,
name|beio
operator|->
name|ds_tag_type
argument_list|,
name|beio
operator|->
name|ds_trans_type
argument_list|,
comment|/*now*/
name|NULL
argument_list|,
comment|/*then*/
operator|&
name|beio
operator|->
name|ds_t0
argument_list|)
expr_stmt|;
if|if
condition|(
name|beio
operator|->
name|beio_cont
operator|!=
name|NULL
condition|)
block|{
name|beio
operator|->
name|beio_cont
argument_list|(
name|beio
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctl_free_beio
argument_list|(
name|beio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_be_block_move_done
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_be_block_io
modifier|*
name|beio
decl_stmt|;
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
decl_stmt|;
ifdef|#
directive|ifdef
name|CTL_TIME_IO
name|struct
name|bintime
name|cur_bt
decl_stmt|;
endif|#
directive|endif
name|beio
operator|=
operator|(
expr|struct
name|ctl_be_block_io
operator|*
operator|)
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_BACKEND
index|]
operator|.
name|ptr
expr_stmt|;
name|be_lun
operator|=
name|beio
operator|->
name|lun
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"entered\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CTL_TIME_IO
name|getbintime
argument_list|(
operator|&
name|cur_bt
argument_list|)
expr_stmt|;
name|bintime_sub
argument_list|(
operator|&
name|cur_bt
argument_list|,
operator|&
name|io
operator|->
name|io_hdr
operator|.
name|dma_start_bt
argument_list|)
expr_stmt|;
name|bintime_add
argument_list|(
operator|&
name|io
operator|->
name|io_hdr
operator|.
name|dma_bt
argument_list|,
operator|&
name|cur_bt
argument_list|)
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|num_dmas
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * We set status at this point for read commands, and write 	 * commands with errors. 	 */
if|if
condition|(
operator|(
name|beio
operator|->
name|bio_cmd
operator|==
name|BIO_READ
operator|)
operator|&&
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|port_status
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ABORT
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|==
name|CTL_STATUS_NONE
operator|)
condition|)
name|ctl_set_success
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|port_status
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ABORT
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|==
name|CTL_STATUS_NONE
operator|)
condition|)
block|{
comment|/* 		 * For hardware error sense keys, the sense key 		 * specific value is defined to be a retry count, 		 * but we use it to pass back an internal FETD 		 * error code.  XXX KDM  Hopefully the FETD is only 		 * using 16 bits for an error code, since that's 		 * all the space we have in the sks field. 		 */
name|ctl_set_internal_failure
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*retry_count*/
name|io
operator|->
name|io_hdr
operator|.
name|port_status
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If this is a read, or a write with errors, it is done. 	 */
if|if
condition|(
operator|(
name|beio
operator|->
name|bio_cmd
operator|==
name|BIO_READ
operator|)
operator|||
operator|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ABORT
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|!=
name|CTL_STATUS_NONE
operator|)
condition|)
block|{
name|ctl_complete_beio
argument_list|(
name|beio
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * At this point, we have a write and the DMA completed 	 * successfully.  We now have to queue it to the task queue to 	 * execute the backend I/O.  That is because we do blocking 	 * memory allocations, and in the file backing case, blocking I/O. 	 * This move done routine is generally called in the SIM's 	 * interrupt context, and therefore we cannot block. 	 */
name|mtx_lock
argument_list|(
operator|&
name|be_lun
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * XXX KDM make sure that links is okay to use at this point. 	 * Otherwise, we either need to add another field to ctl_io_hdr, 	 * or deal with resource allocation here. 	 */
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|be_lun
operator|->
name|datamove_queue
argument_list|,
operator|&
name|io
operator|->
name|io_hdr
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|be_lun
operator|->
name|lock
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|be_lun
operator|->
name|io_taskqueue
argument_list|,
operator|&
name|be_lun
operator|->
name|io_task
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_be_block_biodone
parameter_list|(
name|struct
name|bio
modifier|*
name|bio
parameter_list|)
block|{
name|struct
name|ctl_be_block_io
modifier|*
name|beio
decl_stmt|;
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
decl_stmt|;
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|int
name|error
decl_stmt|;
name|beio
operator|=
name|bio
operator|->
name|bio_caller1
expr_stmt|;
name|be_lun
operator|=
name|beio
operator|->
name|lun
expr_stmt|;
name|io
operator|=
name|beio
operator|->
name|io
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"entered\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|bio
operator|->
name|bio_error
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|be_lun
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|beio
operator|->
name|num_errors
operator|++
expr_stmt|;
name|beio
operator|->
name|num_bios_done
operator|++
expr_stmt|;
comment|/* 	 * XXX KDM will this cause WITNESS to complain?  Holding a lock 	 * during the free might cause it to complain. 	 */
name|g_destroy_bio
argument_list|(
name|bio
argument_list|)
expr_stmt|;
comment|/* 	 * If the send complete bit isn't set, or we aren't the last I/O to 	 * complete, then we're done. 	 */
if|if
condition|(
operator|(
name|beio
operator|->
name|send_complete
operator|==
literal|0
operator|)
operator|||
operator|(
name|beio
operator|->
name|num_bios_done
operator|<
name|beio
operator|->
name|num_bios_sent
operator|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|be_lun
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * At this point, we've verified that we are the last I/O to 	 * complete, so it's safe to drop the lock. 	 */
name|mtx_unlock
argument_list|(
operator|&
name|be_lun
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * If there are any errors from the backing device, we fail the 	 * entire I/O with a medium error. 	 */
if|if
condition|(
name|beio
operator|->
name|num_errors
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|EOPNOTSUPP
condition|)
block|{
name|ctl_set_invalid_opcode
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|beio
operator|->
name|bio_cmd
operator|==
name|BIO_FLUSH
condition|)
block|{
comment|/* XXX KDM is there is a better error here? */
name|ctl_set_internal_failure
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*retry_count*/
literal|0xbad2
argument_list|)
expr_stmt|;
block|}
else|else
name|ctl_set_medium_error
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
name|ctl_complete_beio
argument_list|(
name|beio
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If this is a write, a flush or a delete, we're all done. 	 * If this is a read, we can now send the data to the user. 	 */
if|if
condition|(
operator|(
name|beio
operator|->
name|bio_cmd
operator|==
name|BIO_WRITE
operator|)
operator|||
operator|(
name|beio
operator|->
name|bio_cmd
operator|==
name|BIO_FLUSH
operator|)
operator|||
operator|(
name|beio
operator|->
name|bio_cmd
operator|==
name|BIO_DELETE
operator|)
condition|)
block|{
name|ctl_set_success
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
name|ctl_complete_beio
argument_list|(
name|beio
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|io
operator|->
name|scsiio
operator|.
name|be_move_done
operator|=
name|ctl_be_block_move_done
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|kern_data_ptr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|beio
operator|->
name|sg_segs
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|kern_data_len
operator|=
name|beio
operator|->
name|io_len
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|kern_total_len
operator|=
name|beio
operator|->
name|io_len
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|kern_data_resid
operator|=
literal|0
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|kern_sg_entries
operator|=
name|beio
operator|->
name|num_segs
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
operator||
name|CTL_FLAG_KDPTR_SGLIST
expr_stmt|;
ifdef|#
directive|ifdef
name|CTL_TIME_IO
name|getbintime
argument_list|(
operator|&
name|io
operator|->
name|io_hdr
operator|.
name|dma_start_bt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ctl_datamove
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_be_block_flush_file
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|struct
name|ctl_be_block_io
modifier|*
name|beio
parameter_list|)
block|{
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|struct
name|mount
modifier|*
name|mountpoint
decl_stmt|;
name|int
name|error
decl_stmt|,
name|lock_flags
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"entered\n"
argument_list|)
expr_stmt|;
name|io
operator|=
name|beio
operator|->
name|io
expr_stmt|;
operator|(
name|void
operator|)
name|vn_start_write
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|,
operator|&
name|mountpoint
argument_list|,
name|V_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|MNT_SHARED_WRITES
argument_list|(
name|mountpoint
argument_list|)
operator|||
operator|(
operator|(
name|mountpoint
operator|==
name|NULL
operator|)
operator|&&
name|MNT_SHARED_WRITES
argument_list|(
name|be_lun
operator|->
name|vn
operator|->
name|v_mount
argument_list|)
operator|)
condition|)
name|lock_flags
operator|=
name|LK_SHARED
expr_stmt|;
else|else
name|lock_flags
operator|=
name|LK_EXCLUSIVE
expr_stmt|;
name|vn_lock
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|,
name|lock_flags
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
name|binuptime
argument_list|(
operator|&
name|beio
operator|->
name|ds_t0
argument_list|)
expr_stmt|;
name|devstat_start_transaction
argument_list|(
name|beio
operator|->
name|lun
operator|->
name|disk_stats
argument_list|,
operator|&
name|beio
operator|->
name|ds_t0
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_FSYNC
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|,
name|MNT_WAIT
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vn_finished_write
argument_list|(
name|mountpoint
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|ctl_set_success
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* XXX KDM is there is a better error here? */
name|ctl_set_internal_failure
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*retry_count*/
literal|0xbad1
argument_list|)
expr_stmt|;
block|}
name|ctl_complete_beio
argument_list|(
name|beio
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SDT_PROBE_DEFINE1
argument_list|(
name|cbb
argument_list|,
name|kernel
argument_list|,
name|read
argument_list|,
name|file_start
argument_list|,
literal|"uint64_t"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SDT_PROBE_DEFINE1
argument_list|(
name|cbb
argument_list|,
name|kernel
argument_list|,
name|write
argument_list|,
name|file_start
argument_list|,
literal|"uint64_t"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SDT_PROBE_DEFINE1
argument_list|(
name|cbb
argument_list|,
name|kernel
argument_list|,
name|read
argument_list|,
name|file_done
argument_list|,
literal|"uint64_t"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SDT_PROBE_DEFINE1
argument_list|(
name|cbb
argument_list|,
name|kernel
argument_list|,
name|write
argument_list|,
name|file_done
argument_list|,
literal|"uint64_t"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|ctl_be_block_dispatch_file
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|struct
name|ctl_be_block_io
modifier|*
name|beio
parameter_list|)
block|{
name|struct
name|ctl_be_block_filedata
modifier|*
name|file_data
decl_stmt|;
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|struct
name|uio
name|xuio
decl_stmt|;
name|struct
name|iovec
modifier|*
name|xiovec
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"entered\n"
argument_list|)
expr_stmt|;
name|file_data
operator|=
operator|&
name|be_lun
operator|->
name|backend
operator|.
name|file
expr_stmt|;
name|io
operator|=
name|beio
operator|->
name|io
expr_stmt|;
name|flags
operator|=
name|beio
operator|->
name|bio_flags
expr_stmt|;
if|if
condition|(
name|beio
operator|->
name|bio_cmd
operator|==
name|BIO_READ
condition|)
block|{
name|SDT_PROBE
argument_list|(
name|cbb
argument_list|,
name|kernel
argument_list|,
name|read
argument_list|,
name|file_start
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SDT_PROBE
argument_list|(
name|cbb
argument_list|,
name|kernel
argument_list|,
name|write
argument_list|,
name|file_start
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|&
name|xuio
argument_list|,
sizeof|sizeof
argument_list|(
name|xuio
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|beio
operator|->
name|bio_cmd
operator|==
name|BIO_READ
condition|)
name|xuio
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
else|else
name|xuio
operator|.
name|uio_rw
operator|=
name|UIO_WRITE
expr_stmt|;
name|xuio
operator|.
name|uio_offset
operator|=
name|beio
operator|->
name|io_offset
expr_stmt|;
name|xuio
operator|.
name|uio_resid
operator|=
name|beio
operator|->
name|io_len
expr_stmt|;
name|xuio
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|xuio
operator|.
name|uio_iov
operator|=
name|beio
operator|->
name|xiovecs
expr_stmt|;
name|xuio
operator|.
name|uio_iovcnt
operator|=
name|beio
operator|->
name|num_segs
expr_stmt|;
name|xuio
operator|.
name|uio_td
operator|=
name|curthread
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|xiovec
operator|=
name|xuio
operator|.
name|uio_iov
init|;
name|i
operator|<
name|xuio
operator|.
name|uio_iovcnt
condition|;
name|i
operator|++
operator|,
name|xiovec
operator|++
control|)
block|{
name|xiovec
operator|->
name|iov_base
operator|=
name|beio
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|addr
expr_stmt|;
name|xiovec
operator|->
name|iov_len
operator|=
name|beio
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
block|}
if|if
condition|(
name|beio
operator|->
name|bio_cmd
operator|==
name|BIO_READ
condition|)
block|{
name|vn_lock
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|,
name|LK_SHARED
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
name|binuptime
argument_list|(
operator|&
name|beio
operator|->
name|ds_t0
argument_list|)
expr_stmt|;
name|devstat_start_transaction
argument_list|(
name|beio
operator|->
name|lun
operator|->
name|disk_stats
argument_list|,
operator|&
name|beio
operator|->
name|ds_t0
argument_list|)
expr_stmt|;
comment|/* 		 * UFS pays attention to IO_DIRECT for reads.  If the 		 * DIRECTIO option is configured into the kernel, it calls 		 * ffs_rawread().  But that only works for single-segment 		 * uios with user space addresses.  In our case, with a 		 * kernel uio, it still reads into the buffer cache, but it 		 * will just try to release the buffer from the cache later 		 * on in ffs_read(). 		 * 		 * ZFS does not pay attention to IO_DIRECT for reads. 		 * 		 * UFS does not pay attention to IO_SYNC for reads. 		 * 		 * ZFS pays attention to IO_SYNC (which translates into the 		 * Solaris define FRSYNC for zfs_read()) for reads.  It 		 * attempts to sync the file before reading. 		 * 		 * So, to attempt to provide some barrier semantics in the 		 * BIO_ORDERED case, set both IO_DIRECT and IO_SYNC. 		 */
name|error
operator|=
name|VOP_READ
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|,
operator|&
name|xuio
argument_list|,
operator|(
name|flags
operator|&
name|BIO_ORDERED
operator|)
condition|?
operator|(
name|IO_DIRECT
operator||
name|IO_SYNC
operator|)
else|:
literal|0
argument_list|,
name|file_data
operator|->
name|cred
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|mount
modifier|*
name|mountpoint
decl_stmt|;
name|int
name|lock_flags
decl_stmt|;
operator|(
name|void
operator|)
name|vn_start_write
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|,
operator|&
name|mountpoint
argument_list|,
name|V_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|MNT_SHARED_WRITES
argument_list|(
name|mountpoint
argument_list|)
operator|||
operator|(
operator|(
name|mountpoint
operator|==
name|NULL
operator|)
operator|&&
name|MNT_SHARED_WRITES
argument_list|(
name|be_lun
operator|->
name|vn
operator|->
name|v_mount
argument_list|)
operator|)
condition|)
name|lock_flags
operator|=
name|LK_SHARED
expr_stmt|;
else|else
name|lock_flags
operator|=
name|LK_EXCLUSIVE
expr_stmt|;
name|vn_lock
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|,
name|lock_flags
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
name|binuptime
argument_list|(
operator|&
name|beio
operator|->
name|ds_t0
argument_list|)
expr_stmt|;
name|devstat_start_transaction
argument_list|(
name|beio
operator|->
name|lun
operator|->
name|disk_stats
argument_list|,
operator|&
name|beio
operator|->
name|ds_t0
argument_list|)
expr_stmt|;
comment|/* 		 * UFS pays attention to IO_DIRECT for writes.  The write 		 * is done asynchronously.  (Normally the write would just 		 * get put into cache. 		 * 		 * UFS pays attention to IO_SYNC for writes.  It will 		 * attempt to write the buffer out synchronously if that 		 * flag is set. 		 * 		 * ZFS does not pay attention to IO_DIRECT for writes. 		 * 		 * ZFS pays attention to IO_SYNC (a.k.a. FSYNC or FRSYNC) 		 * for writes.  It will flush the transaction from the 		 * cache before returning. 		 * 		 * So if we've got the BIO_ORDERED flag set, we want 		 * IO_SYNC in either the UFS or ZFS case. 		 */
name|error
operator|=
name|VOP_WRITE
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|,
operator|&
name|xuio
argument_list|,
operator|(
name|flags
operator|&
name|BIO_ORDERED
operator|)
condition|?
name|IO_SYNC
else|:
literal|0
argument_list|,
name|file_data
operator|->
name|cred
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vn_finished_write
argument_list|(
name|mountpoint
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we got an error, set the sense data to "MEDIUM ERROR" and 	 * return the I/O to the user. 	 */
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|char
name|path_str
index|[
literal|32
index|]
decl_stmt|;
name|ctl_scsi_path_string
argument_list|(
name|io
argument_list|,
name|path_str
argument_list|,
sizeof|sizeof
argument_list|(
name|path_str
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * XXX KDM ZFS returns ENOSPC when the underlying 		 * filesystem fills up.  What kind of SCSI error should we 		 * return for that? 		 */
name|printf
argument_list|(
literal|"%s%s command returned errno %d\n"
argument_list|,
name|path_str
argument_list|,
operator|(
name|beio
operator|->
name|bio_cmd
operator|==
name|BIO_READ
operator|)
condition|?
literal|"READ"
else|:
literal|"WRITE"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ctl_set_medium_error
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
name|ctl_complete_beio
argument_list|(
name|beio
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If this is a write, we're all done. 	 * If this is a read, we can now send the data to the user. 	 */
if|if
condition|(
name|beio
operator|->
name|bio_cmd
operator|==
name|BIO_WRITE
condition|)
block|{
name|ctl_set_success
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
name|SDT_PROBE
argument_list|(
name|cbb
argument_list|,
name|kernel
argument_list|,
name|write
argument_list|,
name|file_done
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ctl_complete_beio
argument_list|(
name|beio
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SDT_PROBE
argument_list|(
name|cbb
argument_list|,
name|kernel
argument_list|,
name|read
argument_list|,
name|file_done
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|be_move_done
operator|=
name|ctl_be_block_move_done
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|kern_data_ptr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|beio
operator|->
name|sg_segs
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|kern_data_len
operator|=
name|beio
operator|->
name|io_len
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|kern_total_len
operator|=
name|beio
operator|->
name|io_len
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|kern_data_resid
operator|=
literal|0
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|kern_sg_entries
operator|=
name|beio
operator|->
name|num_segs
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
operator||
name|CTL_FLAG_KDPTR_SGLIST
expr_stmt|;
ifdef|#
directive|ifdef
name|CTL_TIME_IO
name|getbintime
argument_list|(
operator|&
name|io
operator|->
name|io_hdr
operator|.
name|dma_start_bt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ctl_datamove
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_be_block_flush_dev
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|struct
name|ctl_be_block_io
modifier|*
name|beio
parameter_list|)
block|{
name|struct
name|bio
modifier|*
name|bio
decl_stmt|;
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|struct
name|ctl_be_block_devdata
modifier|*
name|dev_data
decl_stmt|;
name|dev_data
operator|=
operator|&
name|be_lun
operator|->
name|backend
operator|.
name|dev
expr_stmt|;
name|io
operator|=
name|beio
operator|->
name|io
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"entered\n"
argument_list|)
expr_stmt|;
comment|/* This can't fail, it's a blocking allocation. */
name|bio
operator|=
name|g_alloc_bio
argument_list|()
expr_stmt|;
name|bio
operator|->
name|bio_cmd
operator|=
name|BIO_FLUSH
expr_stmt|;
name|bio
operator|->
name|bio_flags
operator||=
name|BIO_ORDERED
expr_stmt|;
name|bio
operator|->
name|bio_dev
operator|=
name|dev_data
operator|->
name|cdev
expr_stmt|;
name|bio
operator|->
name|bio_offset
operator|=
literal|0
expr_stmt|;
name|bio
operator|->
name|bio_data
operator|=
literal|0
expr_stmt|;
name|bio
operator|->
name|bio_done
operator|=
name|ctl_be_block_biodone
expr_stmt|;
name|bio
operator|->
name|bio_caller1
operator|=
name|beio
expr_stmt|;
name|bio
operator|->
name|bio_pblkno
operator|=
literal|0
expr_stmt|;
comment|/* 	 * We don't need to acquire the LUN lock here, because we are only 	 * sending one bio, and so there is no other context to synchronize 	 * with. 	 */
name|beio
operator|->
name|num_bios_sent
operator|=
literal|1
expr_stmt|;
name|beio
operator|->
name|send_complete
operator|=
literal|1
expr_stmt|;
name|binuptime
argument_list|(
operator|&
name|beio
operator|->
name|ds_t0
argument_list|)
expr_stmt|;
name|devstat_start_transaction
argument_list|(
name|be_lun
operator|->
name|disk_stats
argument_list|,
operator|&
name|beio
operator|->
name|ds_t0
argument_list|)
expr_stmt|;
call|(
modifier|*
name|dev_data
operator|->
name|csw
operator|->
name|d_strategy
call|)
argument_list|(
name|bio
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_be_block_unmap_dev_range
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|struct
name|ctl_be_block_io
modifier|*
name|beio
parameter_list|,
name|uint64_t
name|off
parameter_list|,
name|uint64_t
name|len
parameter_list|,
name|int
name|last
parameter_list|)
block|{
name|struct
name|bio
modifier|*
name|bio
decl_stmt|;
name|struct
name|ctl_be_block_devdata
modifier|*
name|dev_data
decl_stmt|;
name|dev_data
operator|=
operator|&
name|be_lun
operator|->
name|backend
operator|.
name|dev
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|bio
operator|=
name|g_alloc_bio
argument_list|()
expr_stmt|;
name|bio
operator|->
name|bio_cmd
operator|=
name|BIO_DELETE
expr_stmt|;
name|bio
operator|->
name|bio_flags
operator||=
name|beio
operator|->
name|bio_flags
expr_stmt|;
name|bio
operator|->
name|bio_dev
operator|=
name|dev_data
operator|->
name|cdev
expr_stmt|;
name|bio
operator|->
name|bio_offset
operator|=
name|off
expr_stmt|;
name|bio
operator|->
name|bio_length
operator|=
name|MIN
argument_list|(
name|len
argument_list|,
name|LONG_MAX
argument_list|)
expr_stmt|;
name|bio
operator|->
name|bio_data
operator|=
literal|0
expr_stmt|;
name|bio
operator|->
name|bio_done
operator|=
name|ctl_be_block_biodone
expr_stmt|;
name|bio
operator|->
name|bio_caller1
operator|=
name|beio
expr_stmt|;
name|bio
operator|->
name|bio_pblkno
operator|=
name|beio
operator|->
name|io_offset
operator|/
name|be_lun
operator|->
name|blocksize
expr_stmt|;
name|off
operator|+=
name|bio
operator|->
name|bio_length
expr_stmt|;
name|len
operator|-=
name|bio
operator|->
name|bio_length
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|be_lun
operator|->
name|lock
argument_list|)
expr_stmt|;
name|beio
operator|->
name|num_bios_sent
operator|++
expr_stmt|;
if|if
condition|(
name|last
operator|&&
name|len
operator|==
literal|0
condition|)
name|beio
operator|->
name|send_complete
operator|=
literal|1
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|be_lun
operator|->
name|lock
argument_list|)
expr_stmt|;
call|(
modifier|*
name|dev_data
operator|->
name|csw
operator|->
name|d_strategy
call|)
argument_list|(
name|bio
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_be_block_unmap_dev
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|struct
name|ctl_be_block_io
modifier|*
name|beio
parameter_list|)
block|{
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|struct
name|ctl_be_block_devdata
modifier|*
name|dev_data
decl_stmt|;
name|struct
name|ctl_ptr_len_flags
name|ptrlen
decl_stmt|;
name|struct
name|scsi_unmap_desc
modifier|*
name|buf
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|uint64_t
name|len
decl_stmt|;
name|dev_data
operator|=
operator|&
name|be_lun
operator|->
name|backend
operator|.
name|dev
expr_stmt|;
name|io
operator|=
name|beio
operator|->
name|io
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"entered\n"
argument_list|)
expr_stmt|;
name|binuptime
argument_list|(
operator|&
name|beio
operator|->
name|ds_t0
argument_list|)
expr_stmt|;
name|devstat_start_transaction
argument_list|(
name|be_lun
operator|->
name|disk_stats
argument_list|,
operator|&
name|beio
operator|->
name|ds_t0
argument_list|)
expr_stmt|;
if|if
condition|(
name|beio
operator|->
name|io_offset
operator|==
operator|-
literal|1
condition|)
block|{
name|beio
operator|->
name|io_len
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ptrlen
argument_list|,
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LBA_LEN
index|]
operator|.
name|bytes
argument_list|,
sizeof|sizeof
argument_list|(
name|ptrlen
argument_list|)
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
expr|struct
name|scsi_unmap_desc
operator|*
operator|)
name|ptrlen
operator|.
name|ptr
expr_stmt|;
name|end
operator|=
name|buf
operator|+
name|ptrlen
operator|.
name|len
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|buf
operator|<
name|end
condition|;
name|buf
operator|++
control|)
block|{
name|len
operator|=
operator|(
name|uint64_t
operator|)
name|scsi_4btoul
argument_list|(
name|buf
operator|->
name|length
argument_list|)
operator|*
name|be_lun
operator|->
name|blocksize
expr_stmt|;
name|beio
operator|->
name|io_len
operator|+=
name|len
expr_stmt|;
name|ctl_be_block_unmap_dev_range
argument_list|(
name|be_lun
argument_list|,
name|beio
argument_list|,
name|scsi_8btou64
argument_list|(
name|buf
operator|->
name|lba
argument_list|)
operator|*
name|be_lun
operator|->
name|blocksize
argument_list|,
name|len
argument_list|,
operator|(
name|end
operator|-
name|buf
operator|<
literal|2
operator|)
condition|?
name|TRUE
else|:
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|ctl_be_block_unmap_dev_range
argument_list|(
name|be_lun
argument_list|,
name|beio
argument_list|,
name|beio
operator|->
name|io_offset
argument_list|,
name|beio
operator|->
name|io_len
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_be_block_dispatch_dev
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|struct
name|ctl_be_block_io
modifier|*
name|beio
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|bio
modifier|*
name|bio
decl_stmt|;
name|struct
name|ctl_be_block_devdata
modifier|*
name|dev_data
decl_stmt|;
name|off_t
name|cur_offset
decl_stmt|;
name|int
name|max_iosize
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"entered\n"
argument_list|)
expr_stmt|;
name|dev_data
operator|=
operator|&
name|be_lun
operator|->
name|backend
operator|.
name|dev
expr_stmt|;
comment|/* 	 * We have to limit our I/O size to the maximum supported by the 	 * backend device.  Hopefully it is MAXPHYS.  If the driver doesn't 	 * set it properly, use DFLTPHYS. 	 */
name|max_iosize
operator|=
name|dev_data
operator|->
name|cdev
operator|->
name|si_iosize_max
expr_stmt|;
if|if
condition|(
name|max_iosize
operator|<
name|PAGE_SIZE
condition|)
name|max_iosize
operator|=
name|DFLTPHYS
expr_stmt|;
name|cur_offset
operator|=
name|beio
operator|->
name|io_offset
expr_stmt|;
comment|/* 	 * XXX KDM need to accurately reflect the number of I/Os outstanding 	 * to a device. 	 */
name|binuptime
argument_list|(
operator|&
name|beio
operator|->
name|ds_t0
argument_list|)
expr_stmt|;
name|devstat_start_transaction
argument_list|(
name|be_lun
operator|->
name|disk_stats
argument_list|,
operator|&
name|beio
operator|->
name|ds_t0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|beio
operator|->
name|num_segs
condition|;
name|i
operator|++
control|)
block|{
name|size_t
name|cur_size
decl_stmt|;
name|uint8_t
modifier|*
name|cur_ptr
decl_stmt|;
name|cur_size
operator|=
name|beio
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
name|cur_ptr
operator|=
name|beio
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|addr
expr_stmt|;
while|while
condition|(
name|cur_size
operator|>
literal|0
condition|)
block|{
comment|/* This can't fail, it's a blocking allocation. */
name|bio
operator|=
name|g_alloc_bio
argument_list|()
expr_stmt|;
name|KASSERT
argument_list|(
name|bio
operator|!=
name|NULL
argument_list|,
operator|(
literal|"g_alloc_bio() failed!\n"
operator|)
argument_list|)
expr_stmt|;
name|bio
operator|->
name|bio_cmd
operator|=
name|beio
operator|->
name|bio_cmd
expr_stmt|;
name|bio
operator|->
name|bio_flags
operator||=
name|beio
operator|->
name|bio_flags
expr_stmt|;
name|bio
operator|->
name|bio_dev
operator|=
name|dev_data
operator|->
name|cdev
expr_stmt|;
name|bio
operator|->
name|bio_caller1
operator|=
name|beio
expr_stmt|;
name|bio
operator|->
name|bio_length
operator|=
name|min
argument_list|(
name|cur_size
argument_list|,
name|max_iosize
argument_list|)
expr_stmt|;
name|bio
operator|->
name|bio_offset
operator|=
name|cur_offset
expr_stmt|;
name|bio
operator|->
name|bio_data
operator|=
name|cur_ptr
expr_stmt|;
name|bio
operator|->
name|bio_done
operator|=
name|ctl_be_block_biodone
expr_stmt|;
name|bio
operator|->
name|bio_pblkno
operator|=
name|cur_offset
operator|/
name|be_lun
operator|->
name|blocksize
expr_stmt|;
name|cur_offset
operator|+=
name|bio
operator|->
name|bio_length
expr_stmt|;
name|cur_ptr
operator|+=
name|bio
operator|->
name|bio_length
expr_stmt|;
name|cur_size
operator|-=
name|bio
operator|->
name|bio_length
expr_stmt|;
comment|/* 			 * Make sure we set the complete bit just before we 			 * issue the last bio so we don't wind up with a 			 * race. 			 * 			 * Use the LUN mutex here instead of a combination 			 * of atomic variables for simplicity. 			 * 			 * XXX KDM we could have a per-IO lock, but that 			 * would cause additional per-IO setup and teardown 			 * overhead.  Hopefully there won't be too much 			 * contention on the LUN lock. 			 */
name|mtx_lock
argument_list|(
operator|&
name|be_lun
operator|->
name|lock
argument_list|)
expr_stmt|;
name|beio
operator|->
name|num_bios_sent
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|==
name|beio
operator|->
name|num_segs
operator|-
literal|1
operator|)
operator|&&
operator|(
name|cur_size
operator|==
literal|0
operator|)
condition|)
name|beio
operator|->
name|send_complete
operator|=
literal|1
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|be_lun
operator|->
name|lock
argument_list|)
expr_stmt|;
call|(
modifier|*
name|dev_data
operator|->
name|csw
operator|->
name|d_strategy
call|)
argument_list|(
name|bio
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_be_block_cw_done_ws
parameter_list|(
name|struct
name|ctl_be_block_io
modifier|*
name|beio
parameter_list|)
block|{
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|io
operator|=
name|beio
operator|->
name|io
expr_stmt|;
name|ctl_free_beio
argument_list|(
name|beio
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|!=
name|CTL_STATUS_NONE
operator|)
operator|&&
operator|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|!=
name|CTL_SUCCESS
operator|)
condition|)
block|{
name|ctl_config_write_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
return|return;
block|}
name|ctl_be_block_config_write
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_be_block_cw_dispatch_ws
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_be_block_io
modifier|*
name|beio
decl_stmt|;
name|struct
name|ctl_be_block_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ctl_lba_len_flags
name|lbalen
decl_stmt|;
name|uint64_t
name|len_left
decl_stmt|,
name|lba
decl_stmt|;
name|int
name|i
decl_stmt|,
name|seglen
decl_stmt|;
name|uint8_t
modifier|*
name|buf
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"entered\n"
argument_list|)
expr_stmt|;
name|beio
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_BACKEND
index|]
operator|.
name|ptr
expr_stmt|;
name|softc
operator|=
name|be_lun
operator|->
name|softc
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lbalen
argument_list|,
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LBA_LEN
index|]
operator|.
name|bytes
argument_list|,
sizeof|sizeof
argument_list|(
name|lbalen
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lbalen
operator|.
name|flags
operator|&
operator|~
operator|(
name|SWS_LBDATA
operator||
name|SWS_UNMAP
operator|)
operator|||
operator|(
name|lbalen
operator|.
name|flags
operator|&
name|SWS_UNMAP
operator|&&
name|be_lun
operator|->
name|unmap
operator|==
name|NULL
operator|)
condition|)
block|{
name|ctl_free_beio
argument_list|(
name|beio
argument_list|)
expr_stmt|;
name|ctl_set_invalid_field
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|1
argument_list|,
comment|/*bit_valid*/
literal|0
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
name|ctl_config_write_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If the I/O came down with an ordered or head of queue tag, set 	 * the BIO_ORDERED attribute.  For head of queue tags, that's 	 * pretty much the best we can do. 	 */
if|if
condition|(
operator|(
name|io
operator|->
name|scsiio
operator|.
name|tag_type
operator|==
name|CTL_TAG_ORDERED
operator|)
operator|||
operator|(
name|io
operator|->
name|scsiio
operator|.
name|tag_type
operator|==
name|CTL_TAG_HEAD_OF_QUEUE
operator|)
condition|)
name|beio
operator|->
name|bio_flags
operator|=
name|BIO_ORDERED
expr_stmt|;
switch|switch
condition|(
name|io
operator|->
name|scsiio
operator|.
name|tag_type
condition|)
block|{
case|case
name|CTL_TAG_ORDERED
case|:
name|beio
operator|->
name|ds_tag_type
operator|=
name|DEVSTAT_TAG_ORDERED
expr_stmt|;
break|break;
case|case
name|CTL_TAG_HEAD_OF_QUEUE
case|:
name|beio
operator|->
name|ds_tag_type
operator|=
name|DEVSTAT_TAG_HEAD
expr_stmt|;
break|break;
case|case
name|CTL_TAG_UNTAGGED
case|:
case|case
name|CTL_TAG_SIMPLE
case|:
case|case
name|CTL_TAG_ACA
case|:
default|default:
name|beio
operator|->
name|ds_tag_type
operator|=
name|DEVSTAT_TAG_SIMPLE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|lbalen
operator|.
name|flags
operator|&
name|SWS_UNMAP
condition|)
block|{
name|beio
operator|->
name|io_offset
operator|=
name|lbalen
operator|.
name|lba
operator|*
name|be_lun
operator|->
name|blocksize
expr_stmt|;
name|beio
operator|->
name|io_len
operator|=
operator|(
name|uint64_t
operator|)
name|lbalen
operator|.
name|len
operator|*
name|be_lun
operator|->
name|blocksize
expr_stmt|;
name|beio
operator|->
name|bio_cmd
operator|=
name|BIO_DELETE
expr_stmt|;
name|beio
operator|->
name|ds_trans_type
operator|=
name|DEVSTAT_FREE
expr_stmt|;
name|be_lun
operator|->
name|unmap
argument_list|(
name|be_lun
argument_list|,
name|beio
argument_list|)
expr_stmt|;
return|return;
block|}
name|beio
operator|->
name|bio_cmd
operator|=
name|BIO_WRITE
expr_stmt|;
name|beio
operator|->
name|ds_trans_type
operator|=
name|DEVSTAT_WRITE
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"WRITE SAME at LBA %jx len %u\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|lbalen
operator|.
name|lba
argument_list|,
name|lbalen
operator|.
name|len
argument_list|)
expr_stmt|;
name|len_left
operator|=
operator|(
name|uint64_t
operator|)
name|lbalen
operator|.
name|len
operator|*
name|be_lun
operator|->
name|blocksize
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|lba
operator|=
literal|0
init|;
name|i
operator|<
name|CTLBLK_MAX_SEGS
operator|&&
name|len_left
operator|>
literal|0
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * Setup the S/G entry for this chunk. 		 */
name|seglen
operator|=
name|MIN
argument_list|(
name|MAXPHYS
argument_list|,
name|len_left
argument_list|)
expr_stmt|;
name|seglen
operator|-=
name|seglen
operator|%
name|be_lun
operator|->
name|blocksize
expr_stmt|;
name|beio
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|len
operator|=
name|seglen
expr_stmt|;
name|beio
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|addr
operator|=
name|uma_zalloc
argument_list|(
name|be_lun
operator|->
name|lun_zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"segment %d addr %p len %zd\n"
argument_list|,
name|i
argument_list|,
name|beio
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|addr
argument_list|,
name|beio
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
name|beio
operator|->
name|num_segs
operator|++
expr_stmt|;
name|len_left
operator|-=
name|seglen
expr_stmt|;
name|buf
operator|=
name|beio
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|addr
expr_stmt|;
name|end
operator|=
name|buf
operator|+
name|seglen
expr_stmt|;
for|for
control|(
init|;
name|buf
operator|<
name|end
condition|;
name|buf
operator|+=
name|be_lun
operator|->
name|blocksize
control|)
block|{
name|memcpy
argument_list|(
name|buf
argument_list|,
name|io
operator|->
name|scsiio
operator|.
name|kern_data_ptr
argument_list|,
name|be_lun
operator|->
name|blocksize
argument_list|)
expr_stmt|;
if|if
condition|(
name|lbalen
operator|.
name|flags
operator|&
name|SWS_LBDATA
condition|)
name|scsi_ulto4b
argument_list|(
name|lbalen
operator|.
name|lba
operator|+
name|lba
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|lba
operator|++
expr_stmt|;
block|}
block|}
name|beio
operator|->
name|io_offset
operator|=
name|lbalen
operator|.
name|lba
operator|*
name|be_lun
operator|->
name|blocksize
expr_stmt|;
name|beio
operator|->
name|io_len
operator|=
name|lba
operator|*
name|be_lun
operator|->
name|blocksize
expr_stmt|;
comment|/* We can not do all in one run. Correct and schedule rerun. */
if|if
condition|(
name|len_left
operator|>
literal|0
condition|)
block|{
name|lbalen
operator|.
name|lba
operator|+=
name|lba
expr_stmt|;
name|lbalen
operator|.
name|len
operator|-=
name|lba
expr_stmt|;
name|memcpy
argument_list|(
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LBA_LEN
index|]
operator|.
name|bytes
argument_list|,
operator|&
name|lbalen
argument_list|,
sizeof|sizeof
argument_list|(
name|lbalen
argument_list|)
argument_list|)
expr_stmt|;
name|beio
operator|->
name|beio_cont
operator|=
name|ctl_be_block_cw_done_ws
expr_stmt|;
block|}
name|be_lun
operator|->
name|dispatch
argument_list|(
name|be_lun
argument_list|,
name|beio
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_be_block_cw_dispatch_unmap
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_be_block_io
modifier|*
name|beio
decl_stmt|;
name|struct
name|ctl_be_block_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ctl_ptr_len_flags
name|ptrlen
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"entered\n"
argument_list|)
expr_stmt|;
name|beio
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_BACKEND
index|]
operator|.
name|ptr
expr_stmt|;
name|softc
operator|=
name|be_lun
operator|->
name|softc
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ptrlen
argument_list|,
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LBA_LEN
index|]
operator|.
name|bytes
argument_list|,
sizeof|sizeof
argument_list|(
name|ptrlen
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptrlen
operator|.
name|flags
operator|!=
literal|0
operator|||
name|be_lun
operator|->
name|unmap
operator|==
name|NULL
condition|)
block|{
name|ctl_free_beio
argument_list|(
name|beio
argument_list|)
expr_stmt|;
name|ctl_set_invalid_field
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|,
comment|/*sks_valid*/
literal|0
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|0
argument_list|,
comment|/*bit_valid*/
literal|0
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
name|ctl_config_write_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If the I/O came down with an ordered or head of queue tag, set 	 * the BIO_ORDERED attribute.  For head of queue tags, that's 	 * pretty much the best we can do. 	 */
if|if
condition|(
operator|(
name|io
operator|->
name|scsiio
operator|.
name|tag_type
operator|==
name|CTL_TAG_ORDERED
operator|)
operator|||
operator|(
name|io
operator|->
name|scsiio
operator|.
name|tag_type
operator|==
name|CTL_TAG_HEAD_OF_QUEUE
operator|)
condition|)
name|beio
operator|->
name|bio_flags
operator|=
name|BIO_ORDERED
expr_stmt|;
switch|switch
condition|(
name|io
operator|->
name|scsiio
operator|.
name|tag_type
condition|)
block|{
case|case
name|CTL_TAG_ORDERED
case|:
name|beio
operator|->
name|ds_tag_type
operator|=
name|DEVSTAT_TAG_ORDERED
expr_stmt|;
break|break;
case|case
name|CTL_TAG_HEAD_OF_QUEUE
case|:
name|beio
operator|->
name|ds_tag_type
operator|=
name|DEVSTAT_TAG_HEAD
expr_stmt|;
break|break;
case|case
name|CTL_TAG_UNTAGGED
case|:
case|case
name|CTL_TAG_SIMPLE
case|:
case|case
name|CTL_TAG_ACA
case|:
default|default:
name|beio
operator|->
name|ds_tag_type
operator|=
name|DEVSTAT_TAG_SIMPLE
expr_stmt|;
break|break;
block|}
name|beio
operator|->
name|io_len
operator|=
literal|0
expr_stmt|;
name|beio
operator|->
name|io_offset
operator|=
operator|-
literal|1
expr_stmt|;
name|beio
operator|->
name|bio_cmd
operator|=
name|BIO_DELETE
expr_stmt|;
name|beio
operator|->
name|ds_trans_type
operator|=
name|DEVSTAT_FREE
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"WRITE SAME at LBA %jx len %u\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|lbalen
operator|.
name|lba
argument_list|,
name|lbalen
operator|.
name|len
argument_list|)
expr_stmt|;
name|be_lun
operator|->
name|unmap
argument_list|(
name|be_lun
argument_list|,
name|beio
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_be_block_cw_done
parameter_list|(
name|struct
name|ctl_be_block_io
modifier|*
name|beio
parameter_list|)
block|{
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|io
operator|=
name|beio
operator|->
name|io
expr_stmt|;
name|ctl_free_beio
argument_list|(
name|beio
argument_list|)
expr_stmt|;
name|ctl_config_write_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_be_block_cw_dispatch
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_be_block_io
modifier|*
name|beio
decl_stmt|;
name|struct
name|ctl_be_block_softc
modifier|*
name|softc
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"entered\n"
argument_list|)
expr_stmt|;
name|softc
operator|=
name|be_lun
operator|->
name|softc
expr_stmt|;
name|beio
operator|=
name|ctl_alloc_beio
argument_list|(
name|softc
argument_list|)
expr_stmt|;
name|beio
operator|->
name|io
operator|=
name|io
expr_stmt|;
name|beio
operator|->
name|lun
operator|=
name|be_lun
expr_stmt|;
name|beio
operator|->
name|beio_cont
operator|=
name|ctl_be_block_cw_done
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_BACKEND
index|]
operator|.
name|ptr
operator|=
name|beio
expr_stmt|;
switch|switch
condition|(
name|io
operator|->
name|scsiio
operator|.
name|cdb
index|[
literal|0
index|]
condition|)
block|{
case|case
name|SYNCHRONIZE_CACHE
case|:
case|case
name|SYNCHRONIZE_CACHE_16
case|:
name|beio
operator|->
name|bio_cmd
operator|=
name|BIO_FLUSH
expr_stmt|;
name|beio
operator|->
name|ds_trans_type
operator|=
name|DEVSTAT_NO_DATA
expr_stmt|;
name|beio
operator|->
name|ds_tag_type
operator|=
name|DEVSTAT_TAG_ORDERED
expr_stmt|;
name|beio
operator|->
name|io_len
operator|=
literal|0
expr_stmt|;
name|be_lun
operator|->
name|lun_flush
argument_list|(
name|be_lun
argument_list|,
name|beio
argument_list|)
expr_stmt|;
break|break;
case|case
name|WRITE_SAME_10
case|:
case|case
name|WRITE_SAME_16
case|:
name|ctl_be_block_cw_dispatch_ws
argument_list|(
name|be_lun
argument_list|,
name|io
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNMAP
case|:
name|ctl_be_block_cw_dispatch_unmap
argument_list|(
name|be_lun
argument_list|,
name|io
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"Unhandled CDB type %#x"
argument_list|,
name|io
operator|->
name|scsiio
operator|.
name|cdb
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_expr_stmt
name|SDT_PROBE_DEFINE1
argument_list|(
name|cbb
argument_list|,
name|kernel
argument_list|,
name|read
argument_list|,
name|start
argument_list|,
literal|"uint64_t"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SDT_PROBE_DEFINE1
argument_list|(
name|cbb
argument_list|,
name|kernel
argument_list|,
name|write
argument_list|,
name|start
argument_list|,
literal|"uint64_t"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SDT_PROBE_DEFINE1
argument_list|(
name|cbb
argument_list|,
name|kernel
argument_list|,
name|read
argument_list|,
name|alloc_done
argument_list|,
literal|"uint64_t"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SDT_PROBE_DEFINE1
argument_list|(
name|cbb
argument_list|,
name|kernel
argument_list|,
name|write
argument_list|,
name|alloc_done
argument_list|,
literal|"uint64_t"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|ctl_be_block_dispatch
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_be_block_io
modifier|*
name|beio
decl_stmt|;
name|struct
name|ctl_be_block_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ctl_lba_len
name|lbalen
decl_stmt|;
name|uint64_t
name|len_left
decl_stmt|,
name|io_size_bytes
decl_stmt|;
name|int
name|i
decl_stmt|;
name|softc
operator|=
name|be_lun
operator|->
name|softc
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"entered\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_DATA_MASK
operator|)
operator|==
name|CTL_FLAG_DATA_IN
condition|)
block|{
name|SDT_PROBE
argument_list|(
name|cbb
argument_list|,
name|kernel
argument_list|,
name|read
argument_list|,
name|start
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SDT_PROBE
argument_list|(
name|cbb
argument_list|,
name|kernel
argument_list|,
name|write
argument_list|,
name|start
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
operator|&
name|lbalen
argument_list|,
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LBA_LEN
index|]
operator|.
name|bytes
argument_list|,
sizeof|sizeof
argument_list|(
name|lbalen
argument_list|)
argument_list|)
expr_stmt|;
name|io_size_bytes
operator|=
name|lbalen
operator|.
name|len
operator|*
name|be_lun
operator|->
name|blocksize
expr_stmt|;
comment|/* 	 * XXX KDM this is temporary, until we implement chaining of beio 	 * structures and multiple datamove calls to move all the data in 	 * or out. 	 */
if|if
condition|(
name|io_size_bytes
operator|>
name|CTLBLK_MAX_IO_SIZE
condition|)
block|{
name|printf
argument_list|(
literal|"%s: IO length %ju> max io size %u\n"
argument_list|,
name|__func__
argument_list|,
name|io_size_bytes
argument_list|,
name|CTLBLK_MAX_IO_SIZE
argument_list|)
expr_stmt|;
name|ctl_set_invalid_field
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|,
comment|/*sks_valid*/
literal|0
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|0
argument_list|,
comment|/*bit_valid*/
literal|0
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
return|return;
block|}
name|beio
operator|=
name|ctl_alloc_beio
argument_list|(
name|softc
argument_list|)
expr_stmt|;
name|beio
operator|->
name|io
operator|=
name|io
expr_stmt|;
name|beio
operator|->
name|lun
operator|=
name|be_lun
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_BACKEND
index|]
operator|.
name|ptr
operator|=
name|beio
expr_stmt|;
comment|/* 	 * If the I/O came down with an ordered or head of queue tag, set 	 * the BIO_ORDERED attribute.  For head of queue tags, that's 	 * pretty much the best we can do. 	 * 	 * XXX KDM we don't have a great way to easily know about the FUA 	 * bit right now (it is decoded in ctl_read_write(), but we don't 	 * pass that knowledge to the backend), and in any case we would 	 * need to determine how to handle it.   	 */
if|if
condition|(
operator|(
name|io
operator|->
name|scsiio
operator|.
name|tag_type
operator|==
name|CTL_TAG_ORDERED
operator|)
operator|||
operator|(
name|io
operator|->
name|scsiio
operator|.
name|tag_type
operator|==
name|CTL_TAG_HEAD_OF_QUEUE
operator|)
condition|)
name|beio
operator|->
name|bio_flags
operator|=
name|BIO_ORDERED
expr_stmt|;
switch|switch
condition|(
name|io
operator|->
name|scsiio
operator|.
name|tag_type
condition|)
block|{
case|case
name|CTL_TAG_ORDERED
case|:
name|beio
operator|->
name|ds_tag_type
operator|=
name|DEVSTAT_TAG_ORDERED
expr_stmt|;
break|break;
case|case
name|CTL_TAG_HEAD_OF_QUEUE
case|:
name|beio
operator|->
name|ds_tag_type
operator|=
name|DEVSTAT_TAG_HEAD
expr_stmt|;
break|break;
case|case
name|CTL_TAG_UNTAGGED
case|:
case|case
name|CTL_TAG_SIMPLE
case|:
case|case
name|CTL_TAG_ACA
case|:
default|default:
name|beio
operator|->
name|ds_tag_type
operator|=
name|DEVSTAT_TAG_SIMPLE
expr_stmt|;
break|break;
block|}
comment|/* 	 * This path handles read and write only.  The config write path 	 * handles flush operations. 	 */
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_DATA_MASK
operator|)
operator|==
name|CTL_FLAG_DATA_IN
condition|)
block|{
name|beio
operator|->
name|bio_cmd
operator|=
name|BIO_READ
expr_stmt|;
name|beio
operator|->
name|ds_trans_type
operator|=
name|DEVSTAT_READ
expr_stmt|;
block|}
else|else
block|{
name|beio
operator|->
name|bio_cmd
operator|=
name|BIO_WRITE
expr_stmt|;
name|beio
operator|->
name|ds_trans_type
operator|=
name|DEVSTAT_WRITE
expr_stmt|;
block|}
name|beio
operator|->
name|io_len
operator|=
name|lbalen
operator|.
name|len
operator|*
name|be_lun
operator|->
name|blocksize
expr_stmt|;
name|beio
operator|->
name|io_offset
operator|=
name|lbalen
operator|.
name|lba
operator|*
name|be_lun
operator|->
name|blocksize
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"%s at LBA %jx len %u\n"
argument_list|,
operator|(
name|beio
operator|->
name|bio_cmd
operator|==
name|BIO_READ
operator|)
condition|?
literal|"READ"
else|:
literal|"WRITE"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|lbalen
operator|.
name|lba
argument_list|,
name|lbalen
operator|.
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|len_left
operator|=
name|io_size_bytes
init|;
name|i
operator|<
name|CTLBLK_MAX_SEGS
operator|&&
name|len_left
operator|>
literal|0
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * Setup the S/G entry for this chunk. 		 */
name|beio
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|len
operator|=
name|min
argument_list|(
name|MAXPHYS
argument_list|,
name|len_left
argument_list|)
expr_stmt|;
name|beio
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|addr
operator|=
name|uma_zalloc
argument_list|(
name|be_lun
operator|->
name|lun_zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"segment %d addr %p len %zd\n"
argument_list|,
name|i
argument_list|,
name|beio
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|addr
argument_list|,
name|beio
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
name|beio
operator|->
name|num_segs
operator|++
expr_stmt|;
name|len_left
operator|-=
name|beio
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
block|}
comment|/* 	 * For the read case, we need to read the data into our buffers and 	 * then we can send it back to the user.  For the write case, we 	 * need to get the data from the user first. 	 */
if|if
condition|(
name|beio
operator|->
name|bio_cmd
operator|==
name|BIO_READ
condition|)
block|{
name|SDT_PROBE
argument_list|(
name|cbb
argument_list|,
name|kernel
argument_list|,
name|read
argument_list|,
name|alloc_done
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|be_lun
operator|->
name|dispatch
argument_list|(
name|be_lun
argument_list|,
name|beio
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SDT_PROBE
argument_list|(
name|cbb
argument_list|,
name|kernel
argument_list|,
name|write
argument_list|,
name|alloc_done
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|be_move_done
operator|=
name|ctl_be_block_move_done
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|kern_data_ptr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|beio
operator|->
name|sg_segs
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|kern_data_len
operator|=
name|beio
operator|->
name|io_len
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|kern_total_len
operator|=
name|beio
operator|->
name|io_len
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|kern_data_resid
operator|=
literal|0
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|kern_sg_entries
operator|=
name|beio
operator|->
name|num_segs
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
operator||
name|CTL_FLAG_KDPTR_SGLIST
expr_stmt|;
ifdef|#
directive|ifdef
name|CTL_TIME_IO
name|getbintime
argument_list|(
operator|&
name|io
operator|->
name|io_hdr
operator|.
name|dma_start_bt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ctl_datamove
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_be_block_worker
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
decl_stmt|;
name|struct
name|ctl_be_block_softc
modifier|*
name|softc
decl_stmt|;
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|be_lun
operator|=
operator|(
expr|struct
name|ctl_be_block_lun
operator|*
operator|)
name|context
expr_stmt|;
name|softc
operator|=
name|be_lun
operator|->
name|softc
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"entered\n"
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|be_lun
operator|->
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|STAILQ_FIRST
argument_list|(
operator|&
name|be_lun
operator|->
name|datamove_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ctl_be_block_io
modifier|*
name|beio
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"datamove queue\n"
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE
argument_list|(
operator|&
name|be_lun
operator|->
name|datamove_queue
argument_list|,
operator|&
name|io
operator|->
name|io_hdr
argument_list|,
name|ctl_io_hdr
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|be_lun
operator|->
name|lock
argument_list|)
expr_stmt|;
name|beio
operator|=
operator|(
expr|struct
name|ctl_be_block_io
operator|*
operator|)
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_BACKEND
index|]
operator|.
name|ptr
expr_stmt|;
name|be_lun
operator|->
name|dispatch
argument_list|(
name|be_lun
argument_list|,
name|beio
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|be_lun
operator|->
name|lock
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|STAILQ_FIRST
argument_list|(
operator|&
name|be_lun
operator|->
name|config_write_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|!=
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"config write queue\n"
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE
argument_list|(
operator|&
name|be_lun
operator|->
name|config_write_queue
argument_list|,
operator|&
name|io
operator|->
name|io_hdr
argument_list|,
name|ctl_io_hdr
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|be_lun
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ctl_be_block_cw_dispatch
argument_list|(
name|be_lun
argument_list|,
name|io
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|be_lun
operator|->
name|lock
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|STAILQ_FIRST
argument_list|(
operator|&
name|be_lun
operator|->
name|input_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|!=
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"input queue\n"
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE
argument_list|(
operator|&
name|be_lun
operator|->
name|input_queue
argument_list|,
operator|&
name|io
operator|->
name|io_hdr
argument_list|,
name|ctl_io_hdr
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|be_lun
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 			 * We must drop the lock, since this routine and 			 * its children may sleep. 			 */
name|ctl_be_block_dispatch
argument_list|(
name|be_lun
argument_list|,
name|io
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|be_lun
operator|->
name|lock
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * If we get here, there is no work left in the queues, so 		 * just break out and let the task queue go to sleep. 		 */
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|be_lun
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Entry point from CTL to the backend for I/O.  We queue everything to a  * work thread, so this just puts the I/O on a queue and wakes up the  * thread.  */
end_comment

begin_function
specifier|static
name|int
name|ctl_be_block_submit
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
decl_stmt|;
name|struct
name|ctl_be_lun
modifier|*
name|ctl_be_lun
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"entered\n"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|CTL_RETVAL_COMPLETE
expr_stmt|;
name|ctl_be_lun
operator|=
operator|(
expr|struct
name|ctl_be_lun
operator|*
operator|)
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_BACKEND_LUN
index|]
operator|.
name|ptr
expr_stmt|;
name|be_lun
operator|=
operator|(
expr|struct
name|ctl_be_block_lun
operator|*
operator|)
name|ctl_be_lun
operator|->
name|be_lun
expr_stmt|;
comment|/* 	 * Make sure we only get SCSI I/O. 	 */
name|KASSERT
argument_list|(
name|io
operator|->
name|io_hdr
operator|.
name|io_type
operator|==
name|CTL_IO_SCSI
argument_list|,
operator|(
literal|"Non-SCSI I/O (type "
literal|"%#x) encountered"
operator|,
name|io
operator|->
name|io_hdr
operator|.
name|io_type
operator|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|be_lun
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * XXX KDM make sure that links is okay to use at this point. 	 * Otherwise, we either need to add another field to ctl_io_hdr, 	 * or deal with resource allocation here. 	 */
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|be_lun
operator|->
name|input_queue
argument_list|,
operator|&
name|io
operator|->
name|io_hdr
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|be_lun
operator|->
name|lock
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|be_lun
operator|->
name|io_taskqueue
argument_list|,
operator|&
name|be_lun
operator|->
name|io_task
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_be_block_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|ctl_be_block_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|softc
operator|=
operator|&
name|backend_block_softc
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|CTL_LUN_REQ
case|:
block|{
name|struct
name|ctl_lun_req
modifier|*
name|lun_req
decl_stmt|;
name|lun_req
operator|=
operator|(
expr|struct
name|ctl_lun_req
operator|*
operator|)
name|addr
expr_stmt|;
switch|switch
condition|(
name|lun_req
operator|->
name|reqtype
condition|)
block|{
case|case
name|CTL_LUNREQ_CREATE
case|:
name|error
operator|=
name|ctl_be_block_create
argument_list|(
name|softc
argument_list|,
name|lun_req
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_LUNREQ_RM
case|:
name|error
operator|=
name|ctl_be_block_rm
argument_list|(
name|softc
argument_list|,
name|lun_req
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_LUNREQ_MODIFY
case|:
name|error
operator|=
name|ctl_be_block_modify
argument_list|(
name|softc
argument_list|,
name|lun_req
argument_list|)
expr_stmt|;
break|break;
default|default:
name|lun_req
operator|->
name|status
operator|=
name|CTL_LUN_ERROR
expr_stmt|;
name|snprintf
argument_list|(
name|lun_req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|lun_req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"%s: invalid LUN request type %d"
argument_list|,
name|__func__
argument_list|,
name|lun_req
operator|->
name|reqtype
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
default|default:
name|error
operator|=
name|ENOTTY
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_be_block_open_file
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|struct
name|ctl_lun_req
modifier|*
name|req
parameter_list|)
block|{
name|struct
name|ctl_be_block_filedata
modifier|*
name|file_data
decl_stmt|;
name|struct
name|ctl_lun_create_params
modifier|*
name|params
decl_stmt|;
name|struct
name|vattr
name|vattr
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|file_data
operator|=
operator|&
name|be_lun
operator|->
name|backend
operator|.
name|file
expr_stmt|;
name|params
operator|=
operator|&
name|req
operator|->
name|reqdata
operator|.
name|create
expr_stmt|;
name|be_lun
operator|->
name|dev_type
operator|=
name|CTL_BE_BLOCK_FILE
expr_stmt|;
name|be_lun
operator|->
name|dispatch
operator|=
name|ctl_be_block_dispatch_file
expr_stmt|;
name|be_lun
operator|->
name|lun_flush
operator|=
name|ctl_be_block_flush_file
expr_stmt|;
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|,
operator|&
name|vattr
argument_list|,
name|curthread
operator|->
name|td_ucred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"error calling VOP_GETATTR() for file %s"
argument_list|,
name|be_lun
operator|->
name|dev_path
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Verify that we have the ability to upgrade to exclusive 	 * access on this file so we can trap errors at open instead 	 * of reporting them during first access. 	 */
if|if
condition|(
name|VOP_ISLOCKED
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|)
operator|!=
name|LK_EXCLUSIVE
condition|)
block|{
name|vn_lock
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|,
name|LK_UPGRADE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
if|if
condition|(
name|be_lun
operator|->
name|vn
operator|->
name|v_iflag
operator|&
name|VI_DOOMED
condition|)
block|{
name|error
operator|=
name|EBADF
expr_stmt|;
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"error locking file %s"
argument_list|,
name|be_lun
operator|->
name|dev_path
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|file_data
operator|->
name|cred
operator|=
name|crhold
argument_list|(
name|curthread
operator|->
name|td_ucred
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|lun_size_bytes
operator|!=
literal|0
condition|)
name|be_lun
operator|->
name|size_bytes
operator|=
name|params
operator|->
name|lun_size_bytes
expr_stmt|;
else|else
name|be_lun
operator|->
name|size_bytes
operator|=
name|vattr
operator|.
name|va_size
expr_stmt|;
comment|/* 	 * We set the multi thread flag for file operations because all 	 * filesystems (in theory) are capable of allowing multiple readers 	 * of a file at once.  So we want to get the maximum possible 	 * concurrency. 	 */
name|be_lun
operator|->
name|flags
operator||=
name|CTL_BE_BLOCK_LUN_MULTI_THREAD
expr_stmt|;
comment|/* 	 * XXX KDM vattr.va_blocksize may be larger than 512 bytes here. 	 * With ZFS, it is 131072 bytes.  Block sizes that large don't work 	 * with disklabel and UFS on FreeBSD at least.  Large block sizes 	 * may not work with other OSes as well.  So just export a sector 	 * size of 512 bytes, which should work with any OS or 	 * application.  Since our backing is a file, any block size will 	 * work fine for the backing store. 	 */
if|#
directive|if
literal|0
block|be_lun->blocksize= vattr.va_blocksize;
endif|#
directive|endif
if|if
condition|(
name|params
operator|->
name|blocksize_bytes
operator|!=
literal|0
condition|)
name|be_lun
operator|->
name|blocksize
operator|=
name|params
operator|->
name|blocksize_bytes
expr_stmt|;
else|else
name|be_lun
operator|->
name|blocksize
operator|=
literal|512
expr_stmt|;
comment|/* 	 * Sanity check.  The media size has to be at least one 	 * sector long. 	 */
if|if
condition|(
name|be_lun
operator|->
name|size_bytes
operator|<
name|be_lun
operator|->
name|blocksize
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"file %s size %ju< block size %u"
argument_list|,
name|be_lun
operator|->
name|dev_path
argument_list|,
operator|(
name|uintmax_t
operator|)
name|be_lun
operator|->
name|size_bytes
argument_list|,
name|be_lun
operator|->
name|blocksize
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_be_block_open_dev
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|struct
name|ctl_lun_req
modifier|*
name|req
parameter_list|)
block|{
name|struct
name|ctl_lun_create_params
modifier|*
name|params
decl_stmt|;
name|struct
name|vattr
name|vattr
decl_stmt|;
name|struct
name|cdev
modifier|*
name|dev
decl_stmt|;
name|struct
name|cdevsw
modifier|*
name|devsw
decl_stmt|;
name|int
name|error
decl_stmt|;
name|off_t
name|ps
decl_stmt|,
name|pss
decl_stmt|,
name|po
decl_stmt|,
name|pos
decl_stmt|;
name|params
operator|=
operator|&
name|req
operator|->
name|reqdata
operator|.
name|create
expr_stmt|;
name|be_lun
operator|->
name|dev_type
operator|=
name|CTL_BE_BLOCK_DEV
expr_stmt|;
name|be_lun
operator|->
name|dispatch
operator|=
name|ctl_be_block_dispatch_dev
expr_stmt|;
name|be_lun
operator|->
name|lun_flush
operator|=
name|ctl_be_block_flush_dev
expr_stmt|;
name|be_lun
operator|->
name|unmap
operator|=
name|ctl_be_block_unmap_dev
expr_stmt|;
name|be_lun
operator|->
name|backend
operator|.
name|dev
operator|.
name|cdev
operator|=
name|be_lun
operator|->
name|vn
operator|->
name|v_rdev
expr_stmt|;
name|be_lun
operator|->
name|backend
operator|.
name|dev
operator|.
name|csw
operator|=
name|dev_refthread
argument_list|(
name|be_lun
operator|->
name|backend
operator|.
name|dev
operator|.
name|cdev
argument_list|,
operator|&
name|be_lun
operator|->
name|backend
operator|.
name|dev
operator|.
name|dev_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|be_lun
operator|->
name|backend
operator|.
name|dev
operator|.
name|csw
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"Unable to retrieve device switch"
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|,
operator|&
name|vattr
argument_list|,
name|NOCRED
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"%s: error getting vnode attributes for device %s"
argument_list|,
name|__func__
argument_list|,
name|be_lun
operator|->
name|dev_path
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|dev
operator|=
name|be_lun
operator|->
name|vn
operator|->
name|v_rdev
expr_stmt|;
name|devsw
operator|=
name|dev
operator|->
name|si_devsw
expr_stmt|;
if|if
condition|(
operator|!
name|devsw
operator|->
name|d_ioctl
condition|)
block|{
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"%s: no d_ioctl for device %s!"
argument_list|,
name|__func__
argument_list|,
name|be_lun
operator|->
name|dev_path
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
name|error
operator|=
name|devsw
operator|->
name|d_ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGSECTORSIZE
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|be_lun
operator|->
name|blocksize
argument_list|,
name|FREAD
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"%s: error %d returned for DIOCGSECTORSIZE ioctl "
literal|"on %s!"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|,
name|be_lun
operator|->
name|dev_path
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * If the user has asked for a blocksize that is greater than the 	 * backing device's blocksize, we can do it only if the blocksize 	 * the user is asking for is an even multiple of the underlying  	 * device's blocksize. 	 */
if|if
condition|(
operator|(
name|params
operator|->
name|blocksize_bytes
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|params
operator|->
name|blocksize_bytes
operator|>
name|be_lun
operator|->
name|blocksize
operator|)
condition|)
block|{
name|uint32_t
name|bs_multiple
decl_stmt|,
name|tmp_blocksize
decl_stmt|;
name|bs_multiple
operator|=
name|params
operator|->
name|blocksize_bytes
operator|/
name|be_lun
operator|->
name|blocksize
expr_stmt|;
name|tmp_blocksize
operator|=
name|bs_multiple
operator|*
name|be_lun
operator|->
name|blocksize
expr_stmt|;
if|if
condition|(
name|tmp_blocksize
operator|==
name|params
operator|->
name|blocksize_bytes
condition|)
block|{
name|be_lun
operator|->
name|blocksize
operator|=
name|params
operator|->
name|blocksize_bytes
expr_stmt|;
block|}
else|else
block|{
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"%s: requested blocksize %u is not an even "
literal|"multiple of backing device blocksize %u"
argument_list|,
name|__func__
argument_list|,
name|params
operator|->
name|blocksize_bytes
argument_list|,
name|be_lun
operator|->
name|blocksize
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|params
operator|->
name|blocksize_bytes
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|params
operator|->
name|blocksize_bytes
operator|!=
name|be_lun
operator|->
name|blocksize
operator|)
condition|)
block|{
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"%s: requested blocksize %u< backing device "
literal|"blocksize %u"
argument_list|,
name|__func__
argument_list|,
name|params
operator|->
name|blocksize_bytes
argument_list|,
name|be_lun
operator|->
name|blocksize
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|error
operator|=
name|devsw
operator|->
name|d_ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGMEDIASIZE
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|be_lun
operator|->
name|size_bytes
argument_list|,
name|FREAD
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"%s: error %d returned for DIOCGMEDIASIZE "
literal|" ioctl on %s!"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|,
name|be_lun
operator|->
name|dev_path
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|params
operator|->
name|lun_size_bytes
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|params
operator|->
name|lun_size_bytes
operator|>
name|be_lun
operator|->
name|size_bytes
condition|)
block|{
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"%s: requested LUN size %ju> backing device "
literal|"size %ju"
argument_list|,
name|__func__
argument_list|,
operator|(
name|uintmax_t
operator|)
name|params
operator|->
name|lun_size_bytes
argument_list|,
operator|(
name|uintmax_t
operator|)
name|be_lun
operator|->
name|size_bytes
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|be_lun
operator|->
name|size_bytes
operator|=
name|params
operator|->
name|lun_size_bytes
expr_stmt|;
block|}
name|error
operator|=
name|devsw
operator|->
name|d_ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGSTRIPESIZE
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ps
argument_list|,
name|FREAD
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|ps
operator|=
name|po
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|error
operator|=
name|devsw
operator|->
name|d_ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGSTRIPEOFFSET
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|po
argument_list|,
name|FREAD
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|po
operator|=
literal|0
expr_stmt|;
block|}
name|pss
operator|=
name|ps
operator|/
name|be_lun
operator|->
name|blocksize
expr_stmt|;
name|pos
operator|=
name|po
operator|/
name|be_lun
operator|->
name|blocksize
expr_stmt|;
if|if
condition|(
operator|(
name|pss
operator|>
literal|0
operator|)
operator|&&
operator|(
name|pss
operator|*
name|be_lun
operator|->
name|blocksize
operator|==
name|ps
operator|)
operator|&&
operator|(
name|pss
operator|>=
name|pos
operator|)
operator|&&
operator|(
operator|(
name|pss
operator|&
operator|(
name|pss
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|pos
operator|*
name|be_lun
operator|->
name|blocksize
operator|==
name|po
operator|)
condition|)
block|{
name|be_lun
operator|->
name|pblockexp
operator|=
name|fls
argument_list|(
name|pss
argument_list|)
operator|-
literal|1
expr_stmt|;
name|be_lun
operator|->
name|pblockoff
operator|=
operator|(
name|pss
operator|-
name|pos
operator|)
operator|%
name|pss
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_be_block_close
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|)
block|{
name|DROP_GIANT
argument_list|()
expr_stmt|;
if|if
condition|(
name|be_lun
operator|->
name|vn
condition|)
block|{
name|int
name|flags
init|=
name|FREAD
operator||
name|FWRITE
decl_stmt|;
switch|switch
condition|(
name|be_lun
operator|->
name|dev_type
condition|)
block|{
case|case
name|CTL_BE_BLOCK_DEV
case|:
if|if
condition|(
name|be_lun
operator|->
name|backend
operator|.
name|dev
operator|.
name|csw
condition|)
block|{
name|dev_relthread
argument_list|(
name|be_lun
operator|->
name|backend
operator|.
name|dev
operator|.
name|cdev
argument_list|,
name|be_lun
operator|->
name|backend
operator|.
name|dev
operator|.
name|dev_ref
argument_list|)
expr_stmt|;
name|be_lun
operator|->
name|backend
operator|.
name|dev
operator|.
name|csw
operator|=
name|NULL
expr_stmt|;
name|be_lun
operator|->
name|backend
operator|.
name|dev
operator|.
name|cdev
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
case|case
name|CTL_BE_BLOCK_FILE
case|:
break|break;
case|case
name|CTL_BE_BLOCK_NONE
case|:
break|break;
default|default:
name|panic
argument_list|(
literal|"Unexpected backend type."
argument_list|)
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|vn_close
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|,
name|flags
argument_list|,
name|NOCRED
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|be_lun
operator|->
name|vn
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|be_lun
operator|->
name|dev_type
condition|)
block|{
case|case
name|CTL_BE_BLOCK_DEV
case|:
break|break;
case|case
name|CTL_BE_BLOCK_FILE
case|:
if|if
condition|(
name|be_lun
operator|->
name|backend
operator|.
name|file
operator|.
name|cred
operator|!=
name|NULL
condition|)
block|{
name|crfree
argument_list|(
name|be_lun
operator|->
name|backend
operator|.
name|file
operator|.
name|cred
argument_list|)
expr_stmt|;
name|be_lun
operator|->
name|backend
operator|.
name|file
operator|.
name|cred
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
case|case
name|CTL_BE_BLOCK_NONE
case|:
break|break;
default|default:
name|panic
argument_list|(
literal|"Unexpected backend type."
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_be_block_open
parameter_list|(
name|struct
name|ctl_be_block_softc
modifier|*
name|softc
parameter_list|,
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|struct
name|ctl_lun_req
modifier|*
name|req
parameter_list|)
block|{
name|struct
name|nameidata
name|nd
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * XXX KDM allow a read-only option? 	 */
name|flags
operator|=
name|FREAD
operator||
name|FWRITE
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rootvnode
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"%s: Root filesystem is not mounted"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|curthread
operator|->
name|td_proc
operator|->
name|p_fd
operator|->
name|fd_cdir
condition|)
block|{
name|curthread
operator|->
name|td_proc
operator|->
name|p_fd
operator|->
name|fd_cdir
operator|=
name|rootvnode
expr_stmt|;
name|VREF
argument_list|(
name|rootvnode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|curthread
operator|->
name|td_proc
operator|->
name|p_fd
operator|->
name|fd_rdir
condition|)
block|{
name|curthread
operator|->
name|td_proc
operator|->
name|p_fd
operator|->
name|fd_rdir
operator|=
name|rootvnode
expr_stmt|;
name|VREF
argument_list|(
name|rootvnode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|curthread
operator|->
name|td_proc
operator|->
name|p_fd
operator|->
name|fd_jdir
condition|)
block|{
name|curthread
operator|->
name|td_proc
operator|->
name|p_fd
operator|->
name|fd_jdir
operator|=
name|rootvnode
expr_stmt|;
name|VREF
argument_list|(
name|rootvnode
argument_list|)
expr_stmt|;
block|}
name|again
label|:
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|FOLLOW
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|be_lun
operator|->
name|dev_path
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|error
operator|=
name|vn_open
argument_list|(
operator|&
name|nd
argument_list|,
operator|&
name|flags
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* 		 * This is the only reasonable guess we can make as far as 		 * path if the user doesn't give us a fully qualified path. 		 * If they want to specify a file, they need to specify the 		 * full path. 		 */
if|if
condition|(
name|be_lun
operator|->
name|dev_path
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
block|{
name|char
modifier|*
name|dev_path
init|=
literal|"/dev/"
decl_stmt|;
name|char
modifier|*
name|dev_name
decl_stmt|;
comment|/* Try adding device path at beginning of name */
name|dev_name
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|be_lun
operator|->
name|dev_path
argument_list|)
operator|+
name|strlen
argument_list|(
name|dev_path
argument_list|)
operator|+
literal|1
argument_list|,
name|M_CTLBLK
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_name
condition|)
block|{
name|sprintf
argument_list|(
name|dev_name
argument_list|,
literal|"%s%s"
argument_list|,
name|dev_path
argument_list|,
name|be_lun
operator|->
name|dev_path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|be_lun
operator|->
name|dev_path
argument_list|,
name|M_CTLBLK
argument_list|)
expr_stmt|;
name|be_lun
operator|->
name|dev_path
operator|=
name|dev_name
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"%s: error opening %s"
argument_list|,
name|__func__
argument_list|,
name|be_lun
operator|->
name|dev_path
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
name|be_lun
operator|->
name|vn
operator|=
name|nd
operator|.
name|ni_vp
expr_stmt|;
comment|/* We only support disks and files. */
if|if
condition|(
name|vn_isdisk
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|,
operator|&
name|error
argument_list|)
condition|)
block|{
name|error
operator|=
name|ctl_be_block_open_dev
argument_list|(
name|be_lun
argument_list|,
name|req
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|be_lun
operator|->
name|vn
operator|->
name|v_type
operator|==
name|VREG
condition|)
block|{
name|error
operator|=
name|ctl_be_block_open_file
argument_list|(
name|be_lun
argument_list|,
name|req
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"%s is not a disk or plain file"
argument_list|,
name|be_lun
operator|->
name|dev_path
argument_list|)
expr_stmt|;
block|}
name|VOP_UNLOCK
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|ctl_be_block_close
argument_list|(
name|be_lun
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|be_lun
operator|->
name|blocksize_shift
operator|=
name|fls
argument_list|(
name|be_lun
operator|->
name|blocksize
argument_list|)
operator|-
literal|1
expr_stmt|;
name|be_lun
operator|->
name|size_blocks
operator|=
name|be_lun
operator|->
name|size_bytes
operator|>>
name|be_lun
operator|->
name|blocksize_shift
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_be_block_create
parameter_list|(
name|struct
name|ctl_be_block_softc
modifier|*
name|softc
parameter_list|,
name|struct
name|ctl_lun_req
modifier|*
name|req
parameter_list|)
block|{
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
decl_stmt|;
name|struct
name|ctl_lun_create_params
modifier|*
name|params
decl_stmt|;
name|struct
name|ctl_be_arg
modifier|*
name|file_arg
decl_stmt|;
name|char
name|tmpstr
index|[
literal|32
index|]
decl_stmt|;
name|int
name|retval
decl_stmt|,
name|num_threads
decl_stmt|,
name|unmap
decl_stmt|;
name|int
name|i
decl_stmt|;
name|params
operator|=
operator|&
name|req
operator|->
name|reqdata
operator|.
name|create
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|num_threads
operator|=
name|cbb_num_threads
expr_stmt|;
name|file_arg
operator|=
name|NULL
expr_stmt|;
name|be_lun
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|be_lun
argument_list|)
argument_list|,
name|M_CTLBLK
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|be_lun
operator|->
name|softc
operator|=
name|softc
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|be_lun
operator|->
name|input_queue
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|be_lun
operator|->
name|config_write_queue
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|be_lun
operator|->
name|datamove_queue
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|options
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|be_lun
operator|->
name|lunname
argument_list|,
literal|"cblk%d"
argument_list|,
name|softc
operator|->
name|num_luns
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|be_lun
operator|->
name|lock
argument_list|,
name|be_lun
operator|->
name|lunname
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|be_lun
operator|->
name|lun_zone
operator|=
name|uma_zcreate
argument_list|(
name|be_lun
operator|->
name|lunname
argument_list|,
name|MAXPHYS
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/*align*/
literal|0
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|be_lun
operator|->
name|lun_zone
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"%s: error allocating UMA zone"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|bailout_error
goto|;
block|}
if|if
condition|(
name|params
operator|->
name|flags
operator|&
name|CTL_LUN_FLAG_DEV_TYPE
condition|)
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|lun_type
operator|=
name|params
operator|->
name|device_type
expr_stmt|;
else|else
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|lun_type
operator|=
name|T_DIRECT
expr_stmt|;
if|if
condition|(
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|lun_type
operator|==
name|T_DIRECT
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|req
operator|->
name|num_be_args
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|req
operator|->
name|kern_be_args
index|[
name|i
index|]
operator|.
name|kname
argument_list|,
literal|"file"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|file_arg
operator|=
operator|&
name|req
operator|->
name|kern_be_args
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|file_arg
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"%s: no file argument specified"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|bailout_error
goto|;
block|}
name|be_lun
operator|->
name|dev_path
operator|=
name|malloc
argument_list|(
name|file_arg
operator|->
name|vallen
argument_list|,
name|M_CTLBLK
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|be_lun
operator|->
name|dev_path
argument_list|,
operator|(
name|char
operator|*
operator|)
name|file_arg
operator|->
name|kvalue
argument_list|,
name|file_arg
operator|->
name|vallen
argument_list|)
expr_stmt|;
name|retval
operator|=
name|ctl_be_block_open
argument_list|(
name|softc
argument_list|,
name|be_lun
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|retval
operator|=
literal|0
expr_stmt|;
goto|goto
name|bailout_error
goto|;
block|}
comment|/* 		 * Tell the user the size of the file/device. 		 */
name|params
operator|->
name|lun_size_bytes
operator|=
name|be_lun
operator|->
name|size_bytes
expr_stmt|;
comment|/* 		 * The maximum LBA is the size - 1. 		 */
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|maxlba
operator|=
name|be_lun
operator|->
name|size_blocks
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * For processor devices, we don't have any size. 		 */
name|be_lun
operator|->
name|blocksize
operator|=
literal|0
expr_stmt|;
name|be_lun
operator|->
name|pblockexp
operator|=
literal|0
expr_stmt|;
name|be_lun
operator|->
name|pblockoff
operator|=
literal|0
expr_stmt|;
name|be_lun
operator|->
name|size_blocks
operator|=
literal|0
expr_stmt|;
name|be_lun
operator|->
name|size_bytes
operator|=
literal|0
expr_stmt|;
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|maxlba
operator|=
literal|0
expr_stmt|;
name|params
operator|->
name|lun_size_bytes
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Default to just 1 thread for processor devices. 		 */
name|num_threads
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * XXX This searching loop might be refactored to be combined with 	 * the loop above, 	 */
name|unmap
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|req
operator|->
name|num_be_args
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|req
operator|->
name|kern_be_args
index|[
name|i
index|]
operator|.
name|kname
argument_list|,
literal|"num_threads"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|ctl_be_arg
modifier|*
name|thread_arg
decl_stmt|;
name|char
name|num_thread_str
index|[
literal|16
index|]
decl_stmt|;
name|int
name|tmp_num_threads
decl_stmt|;
name|thread_arg
operator|=
operator|&
name|req
operator|->
name|kern_be_args
index|[
name|i
index|]
expr_stmt|;
name|strlcpy
argument_list|(
name|num_thread_str
argument_list|,
operator|(
name|char
operator|*
operator|)
name|thread_arg
operator|->
name|kvalue
argument_list|,
name|min
argument_list|(
name|thread_arg
operator|->
name|vallen
argument_list|,
sizeof|sizeof
argument_list|(
name|num_thread_str
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tmp_num_threads
operator|=
name|strtol
argument_list|(
name|num_thread_str
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 			 * We don't let the user specify less than one 			 * thread, but hope he's clueful enough not to 			 * specify 1000 threads. 			 */
if|if
condition|(
name|tmp_num_threads
operator|<
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"%s: invalid number of threads %s"
argument_list|,
name|__func__
argument_list|,
name|num_thread_str
argument_list|)
expr_stmt|;
goto|goto
name|bailout_error
goto|;
block|}
name|num_threads
operator|=
name|tmp_num_threads
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|req
operator|->
name|kern_be_args
index|[
name|i
index|]
operator|.
name|kname
argument_list|,
literal|"unmap"
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|req
operator|->
name|kern_be_args
index|[
name|i
index|]
operator|.
name|kvalue
argument_list|,
literal|"on"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|unmap
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|req
operator|->
name|kern_be_args
index|[
name|i
index|]
operator|.
name|kname
argument_list|,
literal|"file"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|req
operator|->
name|kern_be_args
index|[
name|i
index|]
operator|.
name|kname
argument_list|,
literal|"dev"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|ctl_be_lun_option
modifier|*
name|opt
decl_stmt|;
name|opt
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|opt
argument_list|)
argument_list|,
name|M_CTLBLK
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|opt
operator|->
name|name
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|req
operator|->
name|kern_be_args
index|[
name|i
index|]
operator|.
name|kname
argument_list|)
operator|+
literal|1
argument_list|,
name|M_CTLBLK
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|opt
operator|->
name|name
argument_list|,
name|req
operator|->
name|kern_be_args
index|[
name|i
index|]
operator|.
name|kname
argument_list|)
expr_stmt|;
name|opt
operator|->
name|value
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|req
operator|->
name|kern_be_args
index|[
name|i
index|]
operator|.
name|kvalue
argument_list|)
operator|+
literal|1
argument_list|,
name|M_CTLBLK
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|opt
operator|->
name|value
argument_list|,
name|req
operator|->
name|kern_be_args
index|[
name|i
index|]
operator|.
name|kvalue
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|options
argument_list|,
name|opt
argument_list|,
name|links
argument_list|)
expr_stmt|;
block|}
block|}
name|be_lun
operator|->
name|flags
operator|=
name|CTL_BE_BLOCK_LUN_UNCONFIGURED
expr_stmt|;
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|flags
operator|=
name|CTL_LUN_FLAG_PRIMARY
expr_stmt|;
if|if
condition|(
name|unmap
condition|)
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|flags
operator||=
name|CTL_LUN_FLAG_UNMAP
expr_stmt|;
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|be_lun
operator|=
name|be_lun
expr_stmt|;
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|blocksize
operator|=
name|be_lun
operator|->
name|blocksize
expr_stmt|;
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|pblockexp
operator|=
name|be_lun
operator|->
name|pblockexp
expr_stmt|;
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|pblockoff
operator|=
name|be_lun
operator|->
name|pblockoff
expr_stmt|;
comment|/* Tell the user the blocksize we ended up using */
name|params
operator|->
name|blocksize_bytes
operator|=
name|be_lun
operator|->
name|blocksize
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|flags
operator|&
name|CTL_LUN_FLAG_ID_REQ
condition|)
block|{
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|req_lun_id
operator|=
name|params
operator|->
name|req_lun_id
expr_stmt|;
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|flags
operator||=
name|CTL_LUN_FLAG_ID_REQ
expr_stmt|;
block|}
else|else
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|req_lun_id
operator|=
literal|0
expr_stmt|;
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|lun_shutdown
operator|=
name|ctl_be_block_lun_shutdown
expr_stmt|;
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|lun_config_status
operator|=
name|ctl_be_block_lun_config_status
expr_stmt|;
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|be
operator|=
operator|&
name|ctl_be_block_driver
expr_stmt|;
if|if
condition|(
operator|(
name|params
operator|->
name|flags
operator|&
name|CTL_LUN_FLAG_SERIAL_NUM
operator|)
operator|==
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|tmpstr
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
literal|"MYSERIAL%4d"
argument_list|,
name|softc
operator|->
name|num_luns
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|serial_num
argument_list|,
name|tmpstr
argument_list|,
name|ctl_min
argument_list|(
sizeof|sizeof
argument_list|(
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|serial_num
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Tell the user what we used for a serial number */
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|params
operator|->
name|serial_num
argument_list|,
name|tmpstr
argument_list|,
name|ctl_min
argument_list|(
sizeof|sizeof
argument_list|(
name|params
operator|->
name|serial_num
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|serial_num
argument_list|,
name|params
operator|->
name|serial_num
argument_list|,
name|ctl_min
argument_list|(
sizeof|sizeof
argument_list|(
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|serial_num
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|params
operator|->
name|serial_num
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|params
operator|->
name|flags
operator|&
name|CTL_LUN_FLAG_DEVID
operator|)
operator|==
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|tmpstr
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
literal|"MYDEVID%4d"
argument_list|,
name|softc
operator|->
name|num_luns
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|device_id
argument_list|,
name|tmpstr
argument_list|,
name|ctl_min
argument_list|(
sizeof|sizeof
argument_list|(
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|device_id
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Tell the user what we used for a device ID */
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|params
operator|->
name|device_id
argument_list|,
name|tmpstr
argument_list|,
name|ctl_min
argument_list|(
sizeof|sizeof
argument_list|(
name|params
operator|->
name|device_id
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|device_id
argument_list|,
name|params
operator|->
name|device_id
argument_list|,
name|ctl_min
argument_list|(
sizeof|sizeof
argument_list|(
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|device_id
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|params
operator|->
name|device_id
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|TASK_INIT
argument_list|(
operator|&
name|be_lun
operator|->
name|io_task
argument_list|,
comment|/*priority*/
literal|0
argument_list|,
name|ctl_be_block_worker
argument_list|,
name|be_lun
argument_list|)
expr_stmt|;
name|be_lun
operator|->
name|io_taskqueue
operator|=
name|taskqueue_create
argument_list|(
name|be_lun
operator|->
name|lunname
argument_list|,
name|M_WAITOK
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
comment|/*context*/
operator|&
name|be_lun
operator|->
name|io_taskqueue
argument_list|)
expr_stmt|;
if|if
condition|(
name|be_lun
operator|->
name|io_taskqueue
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"%s: Unable to create taskqueue"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|bailout_error
goto|;
block|}
comment|/* 	 * Note that we start the same number of threads by default for 	 * both the file case and the block device case.  For the file 	 * case, we need multiple threads to allow concurrency, because the 	 * vnode interface is designed to be a blocking interface.  For the 	 * block device case, ZFS zvols at least will block the caller's 	 * context in many instances, and so we need multiple threads to 	 * overcome that problem.  Other block devices don't need as many 	 * threads, but they shouldn't cause too many problems. 	 * 	 * If the user wants to just have a single thread for a block 	 * device, he can specify that when the LUN is created, or change 	 * the tunable/sysctl to alter the default number of threads. 	 */
name|retval
operator|=
name|taskqueue_start_threads
argument_list|(
operator|&
name|be_lun
operator|->
name|io_taskqueue
argument_list|,
comment|/*num threads*/
name|num_threads
argument_list|,
comment|/*priority*/
name|PWAIT
argument_list|,
comment|/*thread name*/
literal|"%s taskq"
argument_list|,
name|be_lun
operator|->
name|lunname
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
goto|goto
name|bailout_error
goto|;
name|be_lun
operator|->
name|num_threads
operator|=
name|num_threads
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|softc
operator|->
name|num_luns
operator|++
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|softc
operator|->
name|lun_list
argument_list|,
name|be_lun
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|retval
operator|=
name|ctl_add_lun
argument_list|(
operator|&
name|be_lun
operator|->
name|ctl_be_lun
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE
argument_list|(
operator|&
name|softc
operator|->
name|lun_list
argument_list|,
name|be_lun
argument_list|,
name|ctl_be_block_lun
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|softc
operator|->
name|num_luns
operator|--
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"%s: ctl_add_lun() returned error %d, see dmesg for "
literal|"details"
argument_list|,
name|__func__
argument_list|,
name|retval
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
goto|goto
name|bailout_error
goto|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * Tell the config_status routine that we're waiting so it won't 	 * clean up the LUN in the event of an error. 	 */
name|be_lun
operator|->
name|flags
operator||=
name|CTL_BE_BLOCK_LUN_WAITING
expr_stmt|;
while|while
condition|(
name|be_lun
operator|->
name|flags
operator|&
name|CTL_BE_BLOCK_LUN_UNCONFIGURED
condition|)
block|{
name|retval
operator|=
name|msleep
argument_list|(
name|be_lun
argument_list|,
operator|&
name|softc
operator|->
name|lock
argument_list|,
name|PCATCH
argument_list|,
literal|"ctlblk"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|EINTR
condition|)
break|break;
block|}
name|be_lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_BE_BLOCK_LUN_WAITING
expr_stmt|;
if|if
condition|(
name|be_lun
operator|->
name|flags
operator|&
name|CTL_BE_BLOCK_LUN_CONFIG_ERR
condition|)
block|{
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"%s: LUN configuration error, see dmesg for details"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE
argument_list|(
operator|&
name|softc
operator|->
name|lun_list
argument_list|,
name|be_lun
argument_list|,
name|ctl_be_block_lun
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|softc
operator|->
name|num_luns
operator|--
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
goto|goto
name|bailout_error
goto|;
block|}
else|else
block|{
name|params
operator|->
name|req_lun_id
operator|=
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|lun_id
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|be_lun
operator|->
name|disk_stats
operator|=
name|devstat_new_entry
argument_list|(
literal|"cbb"
argument_list|,
name|params
operator|->
name|req_lun_id
argument_list|,
name|be_lun
operator|->
name|blocksize
argument_list|,
name|DEVSTAT_ALL_SUPPORTED
argument_list|,
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|lun_type
operator||
name|DEVSTAT_TYPE_IF_OTHER
argument_list|,
name|DEVSTAT_PRIORITY_OTHER
argument_list|)
expr_stmt|;
name|req
operator|->
name|status
operator|=
name|CTL_LUN_OK
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
name|bailout_error
label|:
name|req
operator|->
name|status
operator|=
name|CTL_LUN_ERROR
expr_stmt|;
name|ctl_be_block_close
argument_list|(
name|be_lun
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|be_lun
operator|->
name|dev_path
argument_list|,
name|M_CTLBLK
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|be_lun
argument_list|,
name|M_CTLBLK
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_be_block_rm
parameter_list|(
name|struct
name|ctl_be_block_softc
modifier|*
name|softc
parameter_list|,
name|struct
name|ctl_lun_req
modifier|*
name|req
parameter_list|)
block|{
name|struct
name|ctl_lun_rm_params
modifier|*
name|params
decl_stmt|;
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|params
operator|=
operator|&
name|req
operator|->
name|reqdata
operator|.
name|rm
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|be_lun
operator|=
name|NULL
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|be_lun
argument_list|,
argument|&softc->lun_list
argument_list|,
argument|links
argument_list|)
block|{
if|if
condition|(
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|lun_id
operator|==
name|params
operator|->
name|lun_id
condition|)
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|be_lun
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"%s: LUN %u is not managed by the block backend"
argument_list|,
name|__func__
argument_list|,
name|params
operator|->
name|lun_id
argument_list|)
expr_stmt|;
goto|goto
name|bailout_error
goto|;
block|}
name|retval
operator|=
name|ctl_disable_lun
argument_list|(
operator|&
name|be_lun
operator|->
name|ctl_be_lun
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"%s: error %d returned from ctl_disable_lun() for "
literal|"LUN %d"
argument_list|,
name|__func__
argument_list|,
name|retval
argument_list|,
name|params
operator|->
name|lun_id
argument_list|)
expr_stmt|;
goto|goto
name|bailout_error
goto|;
block|}
name|retval
operator|=
name|ctl_invalidate_lun
argument_list|(
operator|&
name|be_lun
operator|->
name|ctl_be_lun
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"%s: error %d returned from ctl_invalidate_lun() for "
literal|"LUN %d"
argument_list|,
name|__func__
argument_list|,
name|retval
argument_list|,
name|params
operator|->
name|lun_id
argument_list|)
expr_stmt|;
goto|goto
name|bailout_error
goto|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|be_lun
operator|->
name|flags
operator||=
name|CTL_BE_BLOCK_LUN_WAITING
expr_stmt|;
while|while
condition|(
operator|(
name|be_lun
operator|->
name|flags
operator|&
name|CTL_BE_BLOCK_LUN_UNCONFIGURED
operator|)
operator|==
literal|0
condition|)
block|{
name|retval
operator|=
name|msleep
argument_list|(
name|be_lun
argument_list|,
operator|&
name|softc
operator|->
name|lock
argument_list|,
name|PCATCH
argument_list|,
literal|"ctlblk"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|EINTR
condition|)
break|break;
block|}
name|be_lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_BE_BLOCK_LUN_WAITING
expr_stmt|;
if|if
condition|(
operator|(
name|be_lun
operator|->
name|flags
operator|&
name|CTL_BE_BLOCK_LUN_UNCONFIGURED
operator|)
operator|==
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"%s: interrupted waiting for LUN to be freed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
goto|goto
name|bailout_error
goto|;
block|}
name|STAILQ_REMOVE
argument_list|(
operator|&
name|softc
operator|->
name|lun_list
argument_list|,
name|be_lun
argument_list|,
name|ctl_be_block_lun
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|softc
operator|->
name|num_luns
operator|--
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|be_lun
operator|->
name|io_taskqueue
argument_list|,
operator|&
name|be_lun
operator|->
name|io_task
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|be_lun
operator|->
name|io_taskqueue
argument_list|)
expr_stmt|;
name|ctl_be_block_close
argument_list|(
name|be_lun
argument_list|)
expr_stmt|;
if|if
condition|(
name|be_lun
operator|->
name|disk_stats
operator|!=
name|NULL
condition|)
name|devstat_remove_entry
argument_list|(
name|be_lun
operator|->
name|disk_stats
argument_list|)
expr_stmt|;
name|uma_zdestroy
argument_list|(
name|be_lun
operator|->
name|lun_zone
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|be_lun
operator|->
name|dev_path
argument_list|,
name|M_CTLBLK
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|be_lun
argument_list|,
name|M_CTLBLK
argument_list|)
expr_stmt|;
name|req
operator|->
name|status
operator|=
name|CTL_LUN_OK
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|bailout_error
label|:
name|req
operator|->
name|status
operator|=
name|CTL_LUN_ERROR
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_be_block_modify_file
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|struct
name|ctl_lun_req
modifier|*
name|req
parameter_list|)
block|{
name|struct
name|vattr
name|vattr
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|ctl_lun_modify_params
modifier|*
name|params
decl_stmt|;
name|params
operator|=
operator|&
name|req
operator|->
name|reqdata
operator|.
name|modify
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|lun_size_bytes
operator|!=
literal|0
condition|)
block|{
name|be_lun
operator|->
name|size_bytes
operator|=
name|params
operator|->
name|lun_size_bytes
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|,
operator|&
name|vattr
argument_list|,
name|curthread
operator|->
name|td_ucred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"error calling VOP_GETATTR() for file %s"
argument_list|,
name|be_lun
operator|->
name|dev_path
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|be_lun
operator|->
name|size_bytes
operator|=
name|vattr
operator|.
name|va_size
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_be_block_modify_dev
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|struct
name|ctl_lun_req
modifier|*
name|req
parameter_list|)
block|{
name|struct
name|cdev
modifier|*
name|dev
decl_stmt|;
name|struct
name|cdevsw
modifier|*
name|devsw
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|ctl_lun_modify_params
modifier|*
name|params
decl_stmt|;
name|uint64_t
name|size_bytes
decl_stmt|;
name|params
operator|=
operator|&
name|req
operator|->
name|reqdata
operator|.
name|modify
expr_stmt|;
name|dev
operator|=
name|be_lun
operator|->
name|vn
operator|->
name|v_rdev
expr_stmt|;
name|devsw
operator|=
name|dev
operator|->
name|si_devsw
expr_stmt|;
if|if
condition|(
operator|!
name|devsw
operator|->
name|d_ioctl
condition|)
block|{
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"%s: no d_ioctl for device %s!"
argument_list|,
name|__func__
argument_list|,
name|be_lun
operator|->
name|dev_path
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
name|error
operator|=
name|devsw
operator|->
name|d_ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGMEDIASIZE
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|size_bytes
argument_list|,
name|FREAD
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"%s: error %d returned for DIOCGMEDIASIZE ioctl "
literal|"on %s!"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|,
name|be_lun
operator|->
name|dev_path
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|params
operator|->
name|lun_size_bytes
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|params
operator|->
name|lun_size_bytes
operator|>
name|size_bytes
condition|)
block|{
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"%s: requested LUN size %ju> backing device "
literal|"size %ju"
argument_list|,
name|__func__
argument_list|,
operator|(
name|uintmax_t
operator|)
name|params
operator|->
name|lun_size_bytes
argument_list|,
operator|(
name|uintmax_t
operator|)
name|size_bytes
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|be_lun
operator|->
name|size_bytes
operator|=
name|params
operator|->
name|lun_size_bytes
expr_stmt|;
block|}
else|else
block|{
name|be_lun
operator|->
name|size_bytes
operator|=
name|size_bytes
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_be_block_modify
parameter_list|(
name|struct
name|ctl_be_block_softc
modifier|*
name|softc
parameter_list|,
name|struct
name|ctl_lun_req
modifier|*
name|req
parameter_list|)
block|{
name|struct
name|ctl_lun_modify_params
modifier|*
name|params
decl_stmt|;
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
decl_stmt|;
name|int
name|error
decl_stmt|;
name|params
operator|=
operator|&
name|req
operator|->
name|reqdata
operator|.
name|modify
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|be_lun
operator|=
name|NULL
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|be_lun
argument_list|,
argument|&softc->lun_list
argument_list|,
argument|links
argument_list|)
block|{
if|if
condition|(
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|lun_id
operator|==
name|params
operator|->
name|lun_id
condition|)
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|be_lun
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"%s: LUN %u is not managed by the block backend"
argument_list|,
name|__func__
argument_list|,
name|params
operator|->
name|lun_id
argument_list|)
expr_stmt|;
goto|goto
name|bailout_error
goto|;
block|}
if|if
condition|(
name|params
operator|->
name|lun_size_bytes
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|params
operator|->
name|lun_size_bytes
operator|<
name|be_lun
operator|->
name|blocksize
condition|)
block|{
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"%s: LUN size %ju< blocksize %u"
argument_list|,
name|__func__
argument_list|,
name|params
operator|->
name|lun_size_bytes
argument_list|,
name|be_lun
operator|->
name|blocksize
argument_list|)
expr_stmt|;
goto|goto
name|bailout_error
goto|;
block|}
block|}
name|vn_lock
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|,
name|LK_SHARED
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
if|if
condition|(
name|be_lun
operator|->
name|vn
operator|->
name|v_type
operator|==
name|VREG
condition|)
name|error
operator|=
name|ctl_be_block_modify_file
argument_list|(
name|be_lun
argument_list|,
name|req
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|ctl_be_block_modify_dev
argument_list|(
name|be_lun
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|bailout_error
goto|;
name|be_lun
operator|->
name|size_blocks
operator|=
name|be_lun
operator|->
name|size_bytes
operator|>>
name|be_lun
operator|->
name|blocksize_shift
expr_stmt|;
comment|/* 	 * The maximum LBA is the size - 1. 	 * 	 * XXX: Note that this field is being updated without locking, 	 * 	which might cause problems on 32-bit architectures. 	 */
name|be_lun
operator|->
name|ctl_be_lun
operator|.
name|maxlba
operator|=
name|be_lun
operator|->
name|size_blocks
operator|-
literal|1
expr_stmt|;
name|ctl_lun_capacity_changed
argument_list|(
operator|&
name|be_lun
operator|->
name|ctl_be_lun
argument_list|)
expr_stmt|;
comment|/* Tell the user the exact size we ended up using */
name|params
operator|->
name|lun_size_bytes
operator|=
name|be_lun
operator|->
name|size_bytes
expr_stmt|;
name|req
operator|->
name|status
operator|=
name|CTL_LUN_OK
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|bailout_error
label|:
name|req
operator|->
name|status
operator|=
name|CTL_LUN_ERROR
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_be_block_lun_shutdown
parameter_list|(
name|void
modifier|*
name|be_lun
parameter_list|)
block|{
name|struct
name|ctl_be_block_lun
modifier|*
name|lun
decl_stmt|;
name|struct
name|ctl_be_block_softc
modifier|*
name|softc
decl_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_be_block_lun
operator|*
operator|)
name|be_lun
expr_stmt|;
name|softc
operator|=
name|lun
operator|->
name|softc
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|lun
operator|->
name|flags
operator||=
name|CTL_BE_BLOCK_LUN_UNCONFIGURED
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|flags
operator|&
name|CTL_BE_BLOCK_LUN_WAITING
condition|)
name|wakeup
argument_list|(
name|lun
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_be_block_lun_config_status
parameter_list|(
name|void
modifier|*
name|be_lun
parameter_list|,
name|ctl_lun_config_status
name|status
parameter_list|)
block|{
name|struct
name|ctl_be_block_lun
modifier|*
name|lun
decl_stmt|;
name|struct
name|ctl_be_block_softc
modifier|*
name|softc
decl_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_be_block_lun
operator|*
operator|)
name|be_lun
expr_stmt|;
name|softc
operator|=
name|lun
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|CTL_LUN_CONFIG_OK
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_BE_BLOCK_LUN_UNCONFIGURED
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|flags
operator|&
name|CTL_BE_BLOCK_LUN_WAITING
condition|)
name|wakeup
argument_list|(
name|lun
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 		 * We successfully added the LUN, attempt to enable it. 		 */
if|if
condition|(
name|ctl_enable_lun
argument_list|(
operator|&
name|lun
operator|->
name|ctl_be_lun
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ctl_enable_lun() failed!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl_invalidate_lun
argument_list|(
operator|&
name|lun
operator|->
name|ctl_be_lun
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ctl_invalidate_lun() failed!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_BE_BLOCK_LUN_UNCONFIGURED
expr_stmt|;
name|lun
operator|->
name|flags
operator||=
name|CTL_BE_BLOCK_LUN_CONFIG_ERR
expr_stmt|;
name|wakeup
argument_list|(
name|lun
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_be_block_config_write
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
decl_stmt|;
name|struct
name|ctl_be_lun
modifier|*
name|ctl_be_lun
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"entered\n"
argument_list|)
expr_stmt|;
name|ctl_be_lun
operator|=
operator|(
expr|struct
name|ctl_be_lun
operator|*
operator|)
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_BACKEND_LUN
index|]
operator|.
name|ptr
expr_stmt|;
name|be_lun
operator|=
operator|(
expr|struct
name|ctl_be_block_lun
operator|*
operator|)
name|ctl_be_lun
operator|->
name|be_lun
expr_stmt|;
switch|switch
condition|(
name|io
operator|->
name|scsiio
operator|.
name|cdb
index|[
literal|0
index|]
condition|)
block|{
case|case
name|SYNCHRONIZE_CACHE
case|:
case|case
name|SYNCHRONIZE_CACHE_16
case|:
case|case
name|WRITE_SAME_10
case|:
case|case
name|WRITE_SAME_16
case|:
case|case
name|UNMAP
case|:
comment|/* 		 * The upper level CTL code will filter out any CDBs with 		 * the immediate bit set and return the proper error. 		 * 		 * We don't really need to worry about what LBA range the 		 * user asked to be synced out.  When they issue a sync 		 * cache command, we'll sync out the whole thing. 		 */
name|mtx_lock
argument_list|(
operator|&
name|be_lun
operator|->
name|lock
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|be_lun
operator|->
name|config_write_queue
argument_list|,
operator|&
name|io
operator|->
name|io_hdr
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|be_lun
operator|->
name|lock
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|be_lun
operator|->
name|io_taskqueue
argument_list|,
operator|&
name|be_lun
operator|->
name|io_task
argument_list|)
expr_stmt|;
break|break;
case|case
name|START_STOP_UNIT
case|:
block|{
name|struct
name|scsi_start_stop_unit
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_start_stop_unit
operator|*
operator|)
name|io
operator|->
name|scsiio
operator|.
name|cdb
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|how
operator|&
name|SSS_START
condition|)
name|retval
operator|=
name|ctl_start_lun
argument_list|(
name|ctl_be_lun
argument_list|)
expr_stmt|;
else|else
block|{
name|retval
operator|=
name|ctl_stop_lun
argument_list|(
name|ctl_be_lun
argument_list|)
expr_stmt|;
comment|/* 			 * XXX KDM Copan-specific offline behavior. 			 * Figure out a reasonable way to port this? 			 */
ifdef|#
directive|ifdef
name|NEEDTOPORT
if|if
condition|(
operator|(
name|retval
operator|==
literal|0
operator|)
operator|&&
operator|(
name|cdb
operator|->
name|byte2
operator|&
name|SSS_ONOFFLINE
operator|)
condition|)
name|retval
operator|=
name|ctl_lun_offline
argument_list|(
name|ctl_be_lun
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 		 * In general, the above routines should not fail.  They 		 * just set state for the LUN.  So we've got something 		 * pretty wrong here if we can't start or stop the LUN. 		 */
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|ctl_set_internal_failure
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*retry_count*/
literal|0xf051
argument_list|)
expr_stmt|;
name|retval
operator|=
name|CTL_RETVAL_COMPLETE
expr_stmt|;
block|}
else|else
block|{
name|ctl_set_success
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
block|}
name|ctl_config_write_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|ctl_set_invalid_opcode
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
name|ctl_config_write_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|retval
operator|=
name|CTL_RETVAL_COMPLETE
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_be_block_config_read
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_be_block_lun_info
parameter_list|(
name|void
modifier|*
name|be_lun
parameter_list|,
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|)
block|{
name|struct
name|ctl_be_block_lun
modifier|*
name|lun
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_be_block_lun
operator|*
operator|)
name|be_lun
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"<num_threads>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
goto|goto
name|bailout
goto|;
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%d"
argument_list|,
name|lun
operator|->
name|num_threads
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
goto|goto
name|bailout
goto|;
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"</num_threads>"
argument_list|)
expr_stmt|;
comment|/* 	 * For processor devices, we don't have a path variable. 	 */
if|if
condition|(
operator|(
name|retval
operator|!=
literal|0
operator|)
operator|||
operator|(
name|lun
operator|->
name|dev_path
operator|==
name|NULL
operator|)
condition|)
goto|goto
name|bailout
goto|;
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"<file>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
goto|goto
name|bailout
goto|;
name|retval
operator|=
name|ctl_sbuf_printf_esc
argument_list|(
name|sb
argument_list|,
name|lun
operator|->
name|dev_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
goto|goto
name|bailout
goto|;
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"</file>\n"
argument_list|)
expr_stmt|;
name|bailout
label|:
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_be_block_init
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ctl_be_block_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|softc
operator|=
operator|&
name|backend_block_softc
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|,
literal|"ctlblk"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|beio_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"beio"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ctl_be_block_io
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|softc
operator|->
name|disk_list
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|softc
operator|->
name|lun_list
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

end_unit

