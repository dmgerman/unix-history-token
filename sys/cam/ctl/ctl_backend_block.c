begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003 Silicon Graphics International Corp.  * Copyright (c) 2009-2011 Spectra Logic Corporation  * Copyright (c) 2012 The FreeBSD Foundation  * Copyright (c) 2014-2015 Alexander Motin<mav@FreeBSD.org>  * All rights reserved.  *  * Portions of this software were developed by Edward Tomasz Napierala  * under sponsorship from the FreeBSD Foundation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    substantially similar to the "NO WARRANTY" disclaimer below  *    ("Disclaimer") and any redistribution must be conditioned upon  *    including a substantially similar Disclaimer requirement for further  *    binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGES.  *  * $Id: //depot/users/kenm/FreeBSD-test2/sys/cam/ctl/ctl_backend_block.c#5 $  */
end_comment

begin_comment
comment|/*  * CAM Target Layer driver backend for block devices.  *  * Author: Ken Merry<ken@FreeBSD.org>  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/disk.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/pcpu.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/sdt.h>
end_include

begin_include
include|#
directive|include
file|<sys/devicestat.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_da.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_io.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_backend.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_ha.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_private.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_error.h>
end_include

begin_comment
comment|/*  * The idea here is that we'll allocate enough S/G space to hold a 1MB  * I/O.  If we get an I/O larger than that, we'll split it.  */
end_comment

begin_define
define|#
directive|define
name|CTLBLK_HALF_IO_SIZE
value|(512 * 1024)
end_define

begin_define
define|#
directive|define
name|CTLBLK_MAX_IO_SIZE
value|(CTLBLK_HALF_IO_SIZE * 2)
end_define

begin_define
define|#
directive|define
name|CTLBLK_MAX_SEG
value|MAXPHYS
end_define

begin_define
define|#
directive|define
name|CTLBLK_HALF_SEGS
value|MAX(CTLBLK_HALF_IO_SIZE / CTLBLK_MAX_SEG, 1)
end_define

begin_define
define|#
directive|define
name|CTLBLK_MAX_SEGS
value|(CTLBLK_HALF_SEGS * 2)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|CTLBLK_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
define|\
value|printf("cbb(%s:%d): " fmt, __FUNCTION__, __LINE__, ##args)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
value|do {} while(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PRIV
parameter_list|(
name|io
parameter_list|)
define|\
value|((struct ctl_ptr_len_flags *)&(io)->io_hdr.ctl_private[CTL_PRIV_BACKEND])
end_define

begin_define
define|#
directive|define
name|ARGS
parameter_list|(
name|io
parameter_list|)
define|\
value|((struct ctl_lba_len_flags *)&(io)->io_hdr.ctl_private[CTL_PRIV_LBA_LEN])
end_define

begin_expr_stmt
name|SDT_PROVIDER_DEFINE
argument_list|(
name|cbb
argument_list|)
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
enum|enum
block|{
name|CTL_BE_BLOCK_LUN_UNCONFIGURED
init|=
literal|0x01
block|,
name|CTL_BE_BLOCK_LUN_CONFIG_ERR
init|=
literal|0x02
block|,
name|CTL_BE_BLOCK_LUN_WAITING
init|=
literal|0x04
block|, }
name|ctl_be_block_lun_flags
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|CTL_BE_BLOCK_NONE
block|,
name|CTL_BE_BLOCK_DEV
block|,
name|CTL_BE_BLOCK_FILE
block|}
name|ctl_be_block_type
typedef|;
end_typedef

begin_struct
struct|struct
name|ctl_be_block_filedata
block|{
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
block|}
struct|;
end_struct

begin_union
union|union
name|ctl_be_block_bedata
block|{
name|struct
name|ctl_be_block_filedata
name|file
decl_stmt|;
block|}
union|;
end_union

begin_struct_decl
struct_decl|struct
name|ctl_be_block_io
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|ctl_be_block_lun
struct_decl|;
end_struct_decl

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|cbb_dispatch_t
function_decl|)
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|struct
name|ctl_be_block_io
modifier|*
name|beio
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|uint64_t
function_decl|(
modifier|*
name|cbb_getattr_t
function_decl|)
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
specifier|const
name|char
modifier|*
name|attrname
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/*  * Backend LUN structure.  There is a 1:1 mapping between a block device  * and a backend block LUN, and between a backend block LUN and a CTL LUN.  */
end_comment

begin_struct
struct|struct
name|ctl_be_block_lun
block|{
name|struct
name|ctl_lun_create_params
name|params
decl_stmt|;
name|char
name|lunname
index|[
literal|32
index|]
decl_stmt|;
name|char
modifier|*
name|dev_path
decl_stmt|;
name|ctl_be_block_type
name|dev_type
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vn
decl_stmt|;
name|union
name|ctl_be_block_bedata
name|backend
decl_stmt|;
name|cbb_dispatch_t
name|dispatch
decl_stmt|;
name|cbb_dispatch_t
name|lun_flush
decl_stmt|;
name|cbb_dispatch_t
name|unmap
decl_stmt|;
name|cbb_dispatch_t
name|get_lba_status
decl_stmt|;
name|cbb_getattr_t
name|getattr
decl_stmt|;
name|uma_zone_t
name|lun_zone
decl_stmt|;
name|uint64_t
name|size_blocks
decl_stmt|;
name|uint64_t
name|size_bytes
decl_stmt|;
name|struct
name|ctl_be_block_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|devstat
modifier|*
name|disk_stats
decl_stmt|;
name|ctl_be_block_lun_flags
name|flags
decl_stmt|;
name|STAILQ_ENTRY
argument_list|(
argument|ctl_be_block_lun
argument_list|)
name|links
expr_stmt|;
name|struct
name|ctl_be_lun
name|cbe_lun
decl_stmt|;
name|struct
name|taskqueue
modifier|*
name|io_taskqueue
decl_stmt|;
name|struct
name|task
name|io_task
decl_stmt|;
name|int
name|num_threads
decl_stmt|;
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|ctl_io_hdr
argument_list|)
name|input_queue
expr_stmt|;
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|ctl_io_hdr
argument_list|)
name|config_read_queue
expr_stmt|;
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|ctl_io_hdr
argument_list|)
name|config_write_queue
expr_stmt|;
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|ctl_io_hdr
argument_list|)
name|datamove_queue
expr_stmt|;
name|struct
name|mtx_padalign
name|io_lock
decl_stmt|;
name|struct
name|mtx_padalign
name|queue_lock
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Overall softc structure for the block backend module.  */
end_comment

begin_struct
struct|struct
name|ctl_be_block_softc
block|{
name|struct
name|mtx
name|lock
decl_stmt|;
name|uma_zone_t
name|beio_zone
decl_stmt|;
name|int
name|num_luns
decl_stmt|;
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|ctl_be_block_lun
argument_list|)
name|lun_list
expr_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|ctl_be_block_softc
name|backend_block_softc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Per-I/O information.  */
end_comment

begin_struct
struct|struct
name|ctl_be_block_io
block|{
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|struct
name|ctl_sg_entry
name|sg_segs
index|[
name|CTLBLK_MAX_SEGS
index|]
decl_stmt|;
name|struct
name|iovec
name|xiovecs
index|[
name|CTLBLK_MAX_SEGS
index|]
decl_stmt|;
name|int
name|bio_cmd
decl_stmt|;
name|int
name|num_segs
decl_stmt|;
name|int
name|num_bios_sent
decl_stmt|;
name|int
name|num_bios_done
decl_stmt|;
name|int
name|send_complete
decl_stmt|;
name|int
name|first_error
decl_stmt|;
name|uint64_t
name|first_error_offset
decl_stmt|;
name|struct
name|bintime
name|ds_t0
decl_stmt|;
name|devstat_tag_type
name|ds_tag_type
decl_stmt|;
name|devstat_trans_flags
name|ds_trans_type
decl_stmt|;
name|uint64_t
name|io_len
decl_stmt|;
name|uint64_t
name|io_offset
decl_stmt|;
name|int
name|io_arg
decl_stmt|;
name|struct
name|ctl_be_block_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ctl_be_block_lun
modifier|*
name|lun
decl_stmt|;
name|void
function_decl|(
modifier|*
name|beio_cont
function_decl|)
parameter_list|(
name|struct
name|ctl_be_block_io
modifier|*
name|beio
parameter_list|)
function_decl|;
comment|/* to continue processing */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|struct
name|ctl_softc
modifier|*
name|control_softc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cbb_num_threads
init|=
literal|14
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_kern_cam_ctl
argument_list|,
name|OID_AUTO
argument_list|,
name|block
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"CAM Target Layer Block Backend"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_cam_ctl_block
argument_list|,
name|OID_AUTO
argument_list|,
name|num_threads
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|cbb_num_threads
argument_list|,
literal|0
argument_list|,
literal|"Number of threads per backing file"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|struct
name|ctl_be_block_io
modifier|*
name|ctl_alloc_beio
parameter_list|(
name|struct
name|ctl_be_block_softc
modifier|*
name|softc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_free_beio
parameter_list|(
name|struct
name|ctl_be_block_io
modifier|*
name|beio
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_complete_beio
parameter_list|(
name|struct
name|ctl_be_block_io
modifier|*
name|beio
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_be_block_move_done
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_be_block_biodone
parameter_list|(
name|struct
name|bio
modifier|*
name|bio
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_be_block_flush_file
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|struct
name|ctl_be_block_io
modifier|*
name|beio
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_be_block_dispatch_file
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|struct
name|ctl_be_block_io
modifier|*
name|beio
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_be_block_gls_file
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|struct
name|ctl_be_block_io
modifier|*
name|beio
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint64_t
name|ctl_be_block_getattr_file
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
specifier|const
name|char
modifier|*
name|attrname
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_be_block_flush_dev
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|struct
name|ctl_be_block_io
modifier|*
name|beio
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_be_block_unmap_dev
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|struct
name|ctl_be_block_io
modifier|*
name|beio
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_be_block_dispatch_dev
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|struct
name|ctl_be_block_io
modifier|*
name|beio
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint64_t
name|ctl_be_block_getattr_dev
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
specifier|const
name|char
modifier|*
name|attrname
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_be_block_cr_dispatch
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_be_block_cw_dispatch
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_be_block_dispatch
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_be_block_worker
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_be_block_submit
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_be_block_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_be_block_open_file
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|struct
name|ctl_lun_req
modifier|*
name|req
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_be_block_open_dev
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|struct
name|ctl_lun_req
modifier|*
name|req
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_be_block_close
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_be_block_open
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|struct
name|ctl_lun_req
modifier|*
name|req
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_be_block_create
parameter_list|(
name|struct
name|ctl_be_block_softc
modifier|*
name|softc
parameter_list|,
name|struct
name|ctl_lun_req
modifier|*
name|req
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_be_block_rm
parameter_list|(
name|struct
name|ctl_be_block_softc
modifier|*
name|softc
parameter_list|,
name|struct
name|ctl_lun_req
modifier|*
name|req
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_be_block_modify
parameter_list|(
name|struct
name|ctl_be_block_softc
modifier|*
name|softc
parameter_list|,
name|struct
name|ctl_lun_req
modifier|*
name|req
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_be_block_lun_shutdown
parameter_list|(
name|void
modifier|*
name|be_lun
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_be_block_lun_config_status
parameter_list|(
name|void
modifier|*
name|be_lun
parameter_list|,
name|ctl_lun_config_status
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_be_block_config_write
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_be_block_config_read
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_be_block_lun_info
parameter_list|(
name|void
modifier|*
name|be_lun
parameter_list|,
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint64_t
name|ctl_be_block_lun_attr
parameter_list|(
name|void
modifier|*
name|be_lun
parameter_list|,
specifier|const
name|char
modifier|*
name|attrname
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_be_block_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_be_block_shutdown
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|ctl_backend_driver
name|ctl_be_block_driver
init|=
block|{
operator|.
name|name
operator|=
literal|"block"
block|,
operator|.
name|flags
operator|=
name|CTL_BE_FLAG_HAS_CONFIG
block|,
operator|.
name|init
operator|=
name|ctl_be_block_init
block|,
operator|.
name|shutdown
operator|=
name|ctl_be_block_shutdown
block|,
operator|.
name|data_submit
operator|=
name|ctl_be_block_submit
block|,
operator|.
name|data_move_done
operator|=
name|ctl_be_block_move_done
block|,
operator|.
name|config_read
operator|=
name|ctl_be_block_config_read
block|,
operator|.
name|config_write
operator|=
name|ctl_be_block_config_write
block|,
operator|.
name|ioctl
operator|=
name|ctl_be_block_ioctl
block|,
operator|.
name|lun_info
operator|=
name|ctl_be_block_lun_info
block|,
operator|.
name|lun_attr
operator|=
name|ctl_be_block_lun_attr
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_CTLBLK
argument_list|,
literal|"ctlblk"
argument_list|,
literal|"Memory used for CTL block backend"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTL_BACKEND_DECLARE
argument_list|(
name|cbb
argument_list|,
name|ctl_be_block_driver
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|struct
name|ctl_be_block_io
modifier|*
name|ctl_alloc_beio
parameter_list|(
name|struct
name|ctl_be_block_softc
modifier|*
name|softc
parameter_list|)
block|{
name|struct
name|ctl_be_block_io
modifier|*
name|beio
decl_stmt|;
name|beio
operator|=
name|uma_zalloc
argument_list|(
name|softc
operator|->
name|beio_zone
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|beio
operator|->
name|softc
operator|=
name|softc
expr_stmt|;
return|return
operator|(
name|beio
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_free_beio
parameter_list|(
name|struct
name|ctl_be_block_io
modifier|*
name|beio
parameter_list|)
block|{
name|int
name|duplicate_free
decl_stmt|;
name|int
name|i
decl_stmt|;
name|duplicate_free
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|beio
operator|->
name|num_segs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|beio
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|addr
operator|==
name|NULL
condition|)
name|duplicate_free
operator|++
expr_stmt|;
name|uma_zfree
argument_list|(
name|beio
operator|->
name|lun
operator|->
name|lun_zone
argument_list|,
name|beio
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|addr
argument_list|)
expr_stmt|;
name|beio
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|addr
operator|=
name|NULL
expr_stmt|;
comment|/* For compare we had two equal S/G lists. */
if|if
condition|(
name|ARGS
argument_list|(
name|beio
operator|->
name|io
argument_list|)
operator|->
name|flags
operator|&
name|CTL_LLF_COMPARE
condition|)
block|{
name|uma_zfree
argument_list|(
name|beio
operator|->
name|lun
operator|->
name|lun_zone
argument_list|,
name|beio
operator|->
name|sg_segs
index|[
name|i
operator|+
name|CTLBLK_HALF_SEGS
index|]
operator|.
name|addr
argument_list|)
expr_stmt|;
name|beio
operator|->
name|sg_segs
index|[
name|i
operator|+
name|CTLBLK_HALF_SEGS
index|]
operator|.
name|addr
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|duplicate_free
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: %d duplicate frees out of %d segments\n"
argument_list|,
name|__func__
argument_list|,
name|duplicate_free
argument_list|,
name|beio
operator|->
name|num_segs
argument_list|)
expr_stmt|;
block|}
name|uma_zfree
argument_list|(
name|beio
operator|->
name|softc
operator|->
name|beio_zone
argument_list|,
name|beio
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_complete_beio
parameter_list|(
name|struct
name|ctl_be_block_io
modifier|*
name|beio
parameter_list|)
block|{
name|union
name|ctl_io
modifier|*
name|io
init|=
name|beio
operator|->
name|io
decl_stmt|;
if|if
condition|(
name|beio
operator|->
name|beio_cont
operator|!=
name|NULL
condition|)
block|{
name|beio
operator|->
name|beio_cont
argument_list|(
name|beio
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctl_free_beio
argument_list|(
name|beio
argument_list|)
expr_stmt|;
name|ctl_data_submit_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|size_t
name|cmp
parameter_list|(
name|uint8_t
modifier|*
name|a
parameter_list|,
name|uint8_t
modifier|*
name|b
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|a
index|[
name|i
index|]
operator|!=
name|b
index|[
name|i
index|]
condition|)
break|break;
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_be_block_compare
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_be_block_io
modifier|*
name|beio
decl_stmt|;
name|uint64_t
name|off
decl_stmt|,
name|res
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint8_t
name|info
index|[
literal|8
index|]
decl_stmt|;
name|beio
operator|=
operator|(
expr|struct
name|ctl_be_block_io
operator|*
operator|)
name|PRIV
argument_list|(
name|io
argument_list|)
operator|->
name|ptr
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|beio
operator|->
name|num_segs
condition|;
name|i
operator|++
control|)
block|{
name|res
operator|=
name|cmp
argument_list|(
name|beio
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|addr
argument_list|,
name|beio
operator|->
name|sg_segs
index|[
name|i
operator|+
name|CTLBLK_HALF_SEGS
index|]
operator|.
name|addr
argument_list|,
name|beio
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
name|off
operator|+=
name|res
expr_stmt|;
if|if
condition|(
name|res
operator|<
name|beio
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|len
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|<
name|beio
operator|->
name|num_segs
condition|)
block|{
name|scsi_u64to8b
argument_list|(
name|off
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|ctl_set_sense
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|,
comment|/*current_error*/
literal|1
argument_list|,
comment|/*sense_key*/
name|SSD_KEY_MISCOMPARE
argument_list|,
comment|/*asc*/
literal|0x1D
argument_list|,
comment|/*ascq*/
literal|0x00
argument_list|,
comment|/*type*/
name|SSD_ELEM_INFO
argument_list|,
comment|/*size*/
sizeof|sizeof
argument_list|(
name|info
argument_list|)
argument_list|,
comment|/*data*/
operator|&
name|info
argument_list|,
comment|/*type*/
name|SSD_ELEM_NONE
argument_list|)
expr_stmt|;
block|}
else|else
name|ctl_set_success
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_be_block_move_done
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_be_block_io
modifier|*
name|beio
decl_stmt|;
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
decl_stmt|;
name|struct
name|ctl_lba_len_flags
modifier|*
name|lbalen
decl_stmt|;
ifdef|#
directive|ifdef
name|CTL_TIME_IO
name|struct
name|bintime
name|cur_bt
decl_stmt|;
endif|#
directive|endif
name|beio
operator|=
operator|(
expr|struct
name|ctl_be_block_io
operator|*
operator|)
name|PRIV
argument_list|(
name|io
argument_list|)
operator|->
name|ptr
expr_stmt|;
name|be_lun
operator|=
name|beio
operator|->
name|lun
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"entered\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CTL_TIME_IO
name|getbinuptime
argument_list|(
operator|&
name|cur_bt
argument_list|)
expr_stmt|;
name|bintime_sub
argument_list|(
operator|&
name|cur_bt
argument_list|,
operator|&
name|io
operator|->
name|io_hdr
operator|.
name|dma_start_bt
argument_list|)
expr_stmt|;
name|bintime_add
argument_list|(
operator|&
name|io
operator|->
name|io_hdr
operator|.
name|dma_bt
argument_list|,
operator|&
name|cur_bt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|io
operator|->
name|io_hdr
operator|.
name|num_dmas
operator|++
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|kern_rel_offset
operator|+=
name|io
operator|->
name|scsiio
operator|.
name|kern_data_len
expr_stmt|;
comment|/* 	 * We set status at this point for read commands, and write 	 * commands with errors. 	 */
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ABORT
condition|)
block|{
empty_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|port_status
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|==
name|CTL_STATUS_NONE
operator|||
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|==
name|CTL_SUCCESS
operator|)
condition|)
block|{
name|ctl_set_internal_failure
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*retry_count*/
name|io
operator|->
name|io_hdr
operator|.
name|port_status
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|io
operator|->
name|scsiio
operator|.
name|kern_data_resid
operator|!=
literal|0
operator|&&
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_DATA_MASK
operator|)
operator|==
name|CTL_FLAG_DATA_OUT
operator|&&
operator|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|==
name|CTL_STATUS_NONE
operator|||
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|==
name|CTL_SUCCESS
operator|)
condition|)
block|{
name|ctl_set_invalid_field_ciu
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|port_status
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|==
name|CTL_STATUS_NONE
operator|)
condition|)
block|{
name|lbalen
operator|=
name|ARGS
argument_list|(
name|beio
operator|->
name|io
argument_list|)
expr_stmt|;
if|if
condition|(
name|lbalen
operator|->
name|flags
operator|&
name|CTL_LLF_READ
condition|)
block|{
name|ctl_set_success
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lbalen
operator|->
name|flags
operator|&
name|CTL_LLF_COMPARE
condition|)
block|{
comment|/* We have two data blocks ready for comparison. */
name|ctl_be_block_compare
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * If this is a read, or a write with errors, it is done. 	 */
if|if
condition|(
operator|(
name|beio
operator|->
name|bio_cmd
operator|==
name|BIO_READ
operator|)
operator|||
operator|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ABORT
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|!=
name|CTL_STATUS_NONE
operator|)
condition|)
block|{
name|ctl_complete_beio
argument_list|(
name|beio
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * At this point, we have a write and the DMA completed 	 * successfully.  We now have to queue it to the task queue to 	 * execute the backend I/O.  That is because we do blocking 	 * memory allocations, and in the file backing case, blocking I/O. 	 * This move done routine is generally called in the SIM's 	 * interrupt context, and therefore we cannot block. 	 */
name|mtx_lock
argument_list|(
operator|&
name|be_lun
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|be_lun
operator|->
name|datamove_queue
argument_list|,
operator|&
name|io
operator|->
name|io_hdr
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|be_lun
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|be_lun
operator|->
name|io_taskqueue
argument_list|,
operator|&
name|be_lun
operator|->
name|io_task
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_be_block_biodone
parameter_list|(
name|struct
name|bio
modifier|*
name|bio
parameter_list|)
block|{
name|struct
name|ctl_be_block_io
modifier|*
name|beio
decl_stmt|;
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
decl_stmt|;
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|int
name|error
decl_stmt|;
name|beio
operator|=
name|bio
operator|->
name|bio_caller1
expr_stmt|;
name|be_lun
operator|=
name|beio
operator|->
name|lun
expr_stmt|;
name|io
operator|=
name|beio
operator|->
name|io
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"entered\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|bio
operator|->
name|bio_error
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|be_lun
operator|->
name|io_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
operator|(
name|beio
operator|->
name|first_error
operator|==
literal|0
operator|||
name|bio
operator|->
name|bio_offset
operator|<
name|beio
operator|->
name|first_error_offset
operator|)
condition|)
block|{
name|beio
operator|->
name|first_error
operator|=
name|error
expr_stmt|;
name|beio
operator|->
name|first_error_offset
operator|=
name|bio
operator|->
name|bio_offset
expr_stmt|;
block|}
name|beio
operator|->
name|num_bios_done
operator|++
expr_stmt|;
comment|/* 	 * XXX KDM will this cause WITNESS to complain?  Holding a lock 	 * during the free might cause it to complain. 	 */
name|g_destroy_bio
argument_list|(
name|bio
argument_list|)
expr_stmt|;
comment|/* 	 * If the send complete bit isn't set, or we aren't the last I/O to 	 * complete, then we're done. 	 */
if|if
condition|(
operator|(
name|beio
operator|->
name|send_complete
operator|==
literal|0
operator|)
operator|||
operator|(
name|beio
operator|->
name|num_bios_done
operator|<
name|beio
operator|->
name|num_bios_sent
operator|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|be_lun
operator|->
name|io_lock
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * At this point, we've verified that we are the last I/O to 	 * complete, so it's safe to drop the lock. 	 */
name|devstat_end_transaction
argument_list|(
name|beio
operator|->
name|lun
operator|->
name|disk_stats
argument_list|,
name|beio
operator|->
name|io_len
argument_list|,
name|beio
operator|->
name|ds_tag_type
argument_list|,
name|beio
operator|->
name|ds_trans_type
argument_list|,
comment|/*now*/
name|NULL
argument_list|,
comment|/*then*/
operator|&
name|beio
operator|->
name|ds_t0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|be_lun
operator|->
name|io_lock
argument_list|)
expr_stmt|;
comment|/* 	 * If there are any errors from the backing device, we fail the 	 * entire I/O with a medium error. 	 */
name|error
operator|=
name|beio
operator|->
name|first_error
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|EOPNOTSUPP
condition|)
block|{
name|ctl_set_invalid_opcode
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
name|ENOSPC
operator|||
name|error
operator|==
name|EDQUOT
condition|)
block|{
name|ctl_set_space_alloc_fail
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
name|EROFS
operator|||
name|error
operator|==
name|EACCES
condition|)
block|{
name|ctl_set_hw_write_protected
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|beio
operator|->
name|bio_cmd
operator|==
name|BIO_FLUSH
condition|)
block|{
comment|/* XXX KDM is there is a better error here? */
name|ctl_set_internal_failure
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*retry_count*/
literal|0xbad2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctl_set_medium_error
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|,
name|beio
operator|->
name|bio_cmd
operator|==
name|BIO_READ
argument_list|)
expr_stmt|;
block|}
name|ctl_complete_beio
argument_list|(
name|beio
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If this is a write, a flush, a delete or verify, we're all done. 	 * If this is a read, we can now send the data to the user. 	 */
if|if
condition|(
operator|(
name|beio
operator|->
name|bio_cmd
operator|==
name|BIO_WRITE
operator|)
operator|||
operator|(
name|beio
operator|->
name|bio_cmd
operator|==
name|BIO_FLUSH
operator|)
operator|||
operator|(
name|beio
operator|->
name|bio_cmd
operator|==
name|BIO_DELETE
operator|)
operator|||
operator|(
name|ARGS
argument_list|(
name|io
argument_list|)
operator|->
name|flags
operator|&
name|CTL_LLF_VERIFY
operator|)
condition|)
block|{
name|ctl_set_success
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
name|ctl_complete_beio
argument_list|(
name|beio
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ARGS
argument_list|(
name|io
argument_list|)
operator|->
name|flags
operator|&
name|CTL_LLF_READ
operator|)
operator|&&
name|beio
operator|->
name|beio_cont
operator|==
name|NULL
condition|)
block|{
name|ctl_set_success
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
name|ctl_serseq_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CTL_TIME_IO
name|getbinuptime
argument_list|(
operator|&
name|io
operator|->
name|io_hdr
operator|.
name|dma_start_bt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ctl_datamove
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_be_block_flush_file
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|struct
name|ctl_be_block_io
modifier|*
name|beio
parameter_list|)
block|{
name|union
name|ctl_io
modifier|*
name|io
init|=
name|beio
operator|->
name|io
decl_stmt|;
name|struct
name|mount
modifier|*
name|mountpoint
decl_stmt|;
name|int
name|error
decl_stmt|,
name|lock_flags
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"entered\n"
argument_list|)
expr_stmt|;
name|binuptime
argument_list|(
operator|&
name|beio
operator|->
name|ds_t0
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|be_lun
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|devstat_start_transaction
argument_list|(
name|beio
operator|->
name|lun
operator|->
name|disk_stats
argument_list|,
operator|&
name|beio
operator|->
name|ds_t0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|be_lun
operator|->
name|io_lock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vn_start_write
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|,
operator|&
name|mountpoint
argument_list|,
name|V_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|MNT_SHARED_WRITES
argument_list|(
name|mountpoint
argument_list|)
operator|||
operator|(
operator|(
name|mountpoint
operator|==
name|NULL
operator|)
operator|&&
name|MNT_SHARED_WRITES
argument_list|(
name|be_lun
operator|->
name|vn
operator|->
name|v_mount
argument_list|)
operator|)
condition|)
name|lock_flags
operator|=
name|LK_SHARED
expr_stmt|;
else|else
name|lock_flags
operator|=
name|LK_EXCLUSIVE
expr_stmt|;
name|vn_lock
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|,
name|lock_flags
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_FSYNC
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|,
name|beio
operator|->
name|io_arg
condition|?
name|MNT_NOWAIT
else|:
name|MNT_WAIT
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vn_finished_write
argument_list|(
name|mountpoint
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|be_lun
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|devstat_end_transaction
argument_list|(
name|beio
operator|->
name|lun
operator|->
name|disk_stats
argument_list|,
name|beio
operator|->
name|io_len
argument_list|,
name|beio
operator|->
name|ds_tag_type
argument_list|,
name|beio
operator|->
name|ds_trans_type
argument_list|,
comment|/*now*/
name|NULL
argument_list|,
comment|/*then*/
operator|&
name|beio
operator|->
name|ds_t0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|be_lun
operator|->
name|io_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|ctl_set_success
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* XXX KDM is there is a better error here? */
name|ctl_set_internal_failure
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*retry_count*/
literal|0xbad1
argument_list|)
expr_stmt|;
block|}
name|ctl_complete_beio
argument_list|(
name|beio
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SDT_PROBE_DEFINE1
argument_list|(
name|cbb
argument_list|, ,
name|read
argument_list|,
name|file_start
argument_list|,
literal|"uint64_t"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SDT_PROBE_DEFINE1
argument_list|(
name|cbb
argument_list|, ,
name|write
argument_list|,
name|file_start
argument_list|,
literal|"uint64_t"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SDT_PROBE_DEFINE1
argument_list|(
name|cbb
argument_list|, ,
name|read
argument_list|,
name|file_done
argument_list|,
literal|"uint64_t"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SDT_PROBE_DEFINE1
argument_list|(
name|cbb
argument_list|, ,
name|write
argument_list|,
name|file_done
argument_list|,
literal|"uint64_t"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|ctl_be_block_dispatch_file
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|struct
name|ctl_be_block_io
modifier|*
name|beio
parameter_list|)
block|{
name|struct
name|ctl_be_block_filedata
modifier|*
name|file_data
decl_stmt|;
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|struct
name|uio
name|xuio
decl_stmt|;
name|struct
name|iovec
modifier|*
name|xiovec
decl_stmt|;
name|size_t
name|s
decl_stmt|;
name|int
name|error
decl_stmt|,
name|flags
decl_stmt|,
name|i
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"entered\n"
argument_list|)
expr_stmt|;
name|file_data
operator|=
operator|&
name|be_lun
operator|->
name|backend
operator|.
name|file
expr_stmt|;
name|io
operator|=
name|beio
operator|->
name|io
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ARGS
argument_list|(
name|io
argument_list|)
operator|->
name|flags
operator|&
name|CTL_LLF_DPO
condition|)
name|flags
operator||=
name|IO_DIRECT
expr_stmt|;
if|if
condition|(
name|beio
operator|->
name|bio_cmd
operator|==
name|BIO_WRITE
operator|&&
name|ARGS
argument_list|(
name|io
argument_list|)
operator|->
name|flags
operator|&
name|CTL_LLF_FUA
condition|)
name|flags
operator||=
name|IO_SYNC
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|xuio
argument_list|,
sizeof|sizeof
argument_list|(
name|xuio
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|beio
operator|->
name|bio_cmd
operator|==
name|BIO_READ
condition|)
block|{
name|SDT_PROBE0
argument_list|(
name|cbb
argument_list|, ,
name|read
argument_list|,
name|file_start
argument_list|)
expr_stmt|;
name|xuio
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
block|}
else|else
block|{
name|SDT_PROBE0
argument_list|(
name|cbb
argument_list|, ,
name|write
argument_list|,
name|file_start
argument_list|)
expr_stmt|;
name|xuio
operator|.
name|uio_rw
operator|=
name|UIO_WRITE
expr_stmt|;
block|}
name|xuio
operator|.
name|uio_offset
operator|=
name|beio
operator|->
name|io_offset
expr_stmt|;
name|xuio
operator|.
name|uio_resid
operator|=
name|beio
operator|->
name|io_len
expr_stmt|;
name|xuio
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|xuio
operator|.
name|uio_iov
operator|=
name|beio
operator|->
name|xiovecs
expr_stmt|;
name|xuio
operator|.
name|uio_iovcnt
operator|=
name|beio
operator|->
name|num_segs
expr_stmt|;
name|xuio
operator|.
name|uio_td
operator|=
name|curthread
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|xiovec
operator|=
name|xuio
operator|.
name|uio_iov
init|;
name|i
operator|<
name|xuio
operator|.
name|uio_iovcnt
condition|;
name|i
operator|++
operator|,
name|xiovec
operator|++
control|)
block|{
name|xiovec
operator|->
name|iov_base
operator|=
name|beio
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|addr
expr_stmt|;
name|xiovec
operator|->
name|iov_len
operator|=
name|beio
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
block|}
name|binuptime
argument_list|(
operator|&
name|beio
operator|->
name|ds_t0
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|be_lun
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|devstat_start_transaction
argument_list|(
name|beio
operator|->
name|lun
operator|->
name|disk_stats
argument_list|,
operator|&
name|beio
operator|->
name|ds_t0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|be_lun
operator|->
name|io_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|beio
operator|->
name|bio_cmd
operator|==
name|BIO_READ
condition|)
block|{
name|vn_lock
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|,
name|LK_SHARED
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
comment|/* 		 * UFS pays attention to IO_DIRECT for reads.  If the 		 * DIRECTIO option is configured into the kernel, it calls 		 * ffs_rawread().  But that only works for single-segment 		 * uios with user space addresses.  In our case, with a 		 * kernel uio, it still reads into the buffer cache, but it 		 * will just try to release the buffer from the cache later 		 * on in ffs_read(). 		 * 		 * ZFS does not pay attention to IO_DIRECT for reads. 		 * 		 * UFS does not pay attention to IO_SYNC for reads. 		 * 		 * ZFS pays attention to IO_SYNC (which translates into the 		 * Solaris define FRSYNC for zfs_read()) for reads.  It 		 * attempts to sync the file before reading. 		 */
name|error
operator|=
name|VOP_READ
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|,
operator|&
name|xuio
argument_list|,
name|flags
argument_list|,
name|file_data
operator|->
name|cred
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SDT_PROBE0
argument_list|(
name|cbb
argument_list|, ,
name|read
argument_list|,
name|file_done
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|xuio
operator|.
name|uio_resid
operator|>
literal|0
condition|)
block|{
comment|/* 			 * If we red less then requested (EOF), then 			 * we should clean the rest of the buffer. 			 */
name|s
operator|=
name|beio
operator|->
name|io_len
operator|-
name|xuio
operator|.
name|uio_resid
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|beio
operator|->
name|num_segs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|s
operator|>=
name|beio
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|len
condition|)
block|{
name|s
operator|-=
name|beio
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
continue|continue;
block|}
name|bzero
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|beio
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|addr
operator|+
name|s
argument_list|,
name|beio
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|len
operator|-
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|struct
name|mount
modifier|*
name|mountpoint
decl_stmt|;
name|int
name|lock_flags
decl_stmt|;
operator|(
name|void
operator|)
name|vn_start_write
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|,
operator|&
name|mountpoint
argument_list|,
name|V_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|MNT_SHARED_WRITES
argument_list|(
name|mountpoint
argument_list|)
operator|||
operator|(
operator|(
name|mountpoint
operator|==
name|NULL
operator|)
operator|&&
name|MNT_SHARED_WRITES
argument_list|(
name|be_lun
operator|->
name|vn
operator|->
name|v_mount
argument_list|)
operator|)
condition|)
name|lock_flags
operator|=
name|LK_SHARED
expr_stmt|;
else|else
name|lock_flags
operator|=
name|LK_EXCLUSIVE
expr_stmt|;
name|vn_lock
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|,
name|lock_flags
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
comment|/* 		 * UFS pays attention to IO_DIRECT for writes.  The write 		 * is done asynchronously.  (Normally the write would just 		 * get put into cache. 		 * 		 * UFS pays attention to IO_SYNC for writes.  It will 		 * attempt to write the buffer out synchronously if that 		 * flag is set. 		 * 		 * ZFS does not pay attention to IO_DIRECT for writes. 		 * 		 * ZFS pays attention to IO_SYNC (a.k.a. FSYNC or FRSYNC) 		 * for writes.  It will flush the transaction from the 		 * cache before returning. 		 */
name|error
operator|=
name|VOP_WRITE
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|,
operator|&
name|xuio
argument_list|,
name|flags
argument_list|,
name|file_data
operator|->
name|cred
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vn_finished_write
argument_list|(
name|mountpoint
argument_list|)
expr_stmt|;
name|SDT_PROBE0
argument_list|(
name|cbb
argument_list|, ,
name|write
argument_list|,
name|file_done
argument_list|)
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|be_lun
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|devstat_end_transaction
argument_list|(
name|beio
operator|->
name|lun
operator|->
name|disk_stats
argument_list|,
name|beio
operator|->
name|io_len
argument_list|,
name|beio
operator|->
name|ds_tag_type
argument_list|,
name|beio
operator|->
name|ds_trans_type
argument_list|,
comment|/*now*/
name|NULL
argument_list|,
comment|/*then*/
operator|&
name|beio
operator|->
name|ds_t0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|be_lun
operator|->
name|io_lock
argument_list|)
expr_stmt|;
comment|/* 	 * If we got an error, set the sense data to "MEDIUM ERROR" and 	 * return the I/O to the user. 	 */
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|ENOSPC
operator|||
name|error
operator|==
name|EDQUOT
condition|)
block|{
name|ctl_set_space_alloc_fail
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
name|EROFS
operator|||
name|error
operator|==
name|EACCES
condition|)
block|{
name|ctl_set_hw_write_protected
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctl_set_medium_error
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|,
name|beio
operator|->
name|bio_cmd
operator|==
name|BIO_READ
argument_list|)
expr_stmt|;
block|}
name|ctl_complete_beio
argument_list|(
name|beio
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If this is a write or a verify, we're all done. 	 * If this is a read, we can now send the data to the user. 	 */
if|if
condition|(
operator|(
name|beio
operator|->
name|bio_cmd
operator|==
name|BIO_WRITE
operator|)
operator|||
operator|(
name|ARGS
argument_list|(
name|io
argument_list|)
operator|->
name|flags
operator|&
name|CTL_LLF_VERIFY
operator|)
condition|)
block|{
name|ctl_set_success
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
name|ctl_complete_beio
argument_list|(
name|beio
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ARGS
argument_list|(
name|io
argument_list|)
operator|->
name|flags
operator|&
name|CTL_LLF_READ
operator|)
operator|&&
name|beio
operator|->
name|beio_cont
operator|==
name|NULL
condition|)
block|{
name|ctl_set_success
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
name|ctl_serseq_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CTL_TIME_IO
name|getbinuptime
argument_list|(
operator|&
name|io
operator|->
name|io_hdr
operator|.
name|dma_start_bt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ctl_datamove
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_be_block_gls_file
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|struct
name|ctl_be_block_io
modifier|*
name|beio
parameter_list|)
block|{
name|union
name|ctl_io
modifier|*
name|io
init|=
name|beio
operator|->
name|io
decl_stmt|;
name|struct
name|ctl_lba_len_flags
modifier|*
name|lbalen
init|=
name|ARGS
argument_list|(
name|io
argument_list|)
decl_stmt|;
name|struct
name|scsi_get_lba_status_data
modifier|*
name|data
decl_stmt|;
name|off_t
name|roff
decl_stmt|,
name|off
decl_stmt|;
name|int
name|error
decl_stmt|,
name|status
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"entered\n"
argument_list|)
expr_stmt|;
name|off
operator|=
name|roff
operator|=
operator|(
operator|(
name|off_t
operator|)
name|lbalen
operator|->
name|lba
operator|)
operator|*
name|be_lun
operator|->
name|cbe_lun
operator|.
name|blocksize
expr_stmt|;
name|vn_lock
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|,
name|LK_SHARED
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_IOCTL
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|,
name|FIOSEEKHOLE
argument_list|,
operator|&
name|off
argument_list|,
literal|0
argument_list|,
name|curthread
operator|->
name|td_ucred
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|off
operator|>
name|roff
condition|)
name|status
operator|=
literal|0
expr_stmt|;
comment|/* mapped up to off */
else|else
block|{
name|error
operator|=
name|VOP_IOCTL
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|,
name|FIOSEEKDATA
argument_list|,
operator|&
name|off
argument_list|,
literal|0
argument_list|,
name|curthread
operator|->
name|td_ucred
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|off
operator|>
name|roff
condition|)
name|status
operator|=
literal|1
expr_stmt|;
comment|/* deallocated up to off */
else|else
block|{
name|status
operator|=
literal|0
expr_stmt|;
comment|/* unknown up to the end */
name|off
operator|=
name|be_lun
operator|->
name|size_bytes
expr_stmt|;
block|}
block|}
name|VOP_UNLOCK
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
expr|struct
name|scsi_get_lba_status_data
operator|*
operator|)
name|io
operator|->
name|scsiio
operator|.
name|kern_data_ptr
expr_stmt|;
name|scsi_u64to8b
argument_list|(
name|lbalen
operator|->
name|lba
argument_list|,
name|data
operator|->
name|descr
index|[
literal|0
index|]
operator|.
name|addr
argument_list|)
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|MIN
argument_list|(
name|UINT32_MAX
argument_list|,
name|off
operator|/
name|be_lun
operator|->
name|cbe_lun
operator|.
name|blocksize
operator|-
name|lbalen
operator|->
name|lba
argument_list|)
argument_list|,
name|data
operator|->
name|descr
index|[
literal|0
index|]
operator|.
name|length
argument_list|)
expr_stmt|;
name|data
operator|->
name|descr
index|[
literal|0
index|]
operator|.
name|status
operator|=
name|status
expr_stmt|;
name|ctl_complete_beio
argument_list|(
name|beio
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|ctl_be_block_getattr_file
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
specifier|const
name|char
modifier|*
name|attrname
parameter_list|)
block|{
name|struct
name|vattr
name|vattr
decl_stmt|;
name|struct
name|statfs
name|statfs
decl_stmt|;
name|uint64_t
name|val
decl_stmt|;
name|int
name|error
decl_stmt|;
name|val
operator|=
name|UINT64_MAX
expr_stmt|;
if|if
condition|(
name|be_lun
operator|->
name|vn
operator|==
name|NULL
condition|)
return|return
operator|(
name|val
operator|)
return|;
name|vn_lock
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|,
name|LK_SHARED
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|attrname
argument_list|,
literal|"blocksused"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|,
operator|&
name|vattr
argument_list|,
name|curthread
operator|->
name|td_ucred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|val
operator|=
name|vattr
operator|.
name|va_bytes
operator|/
name|be_lun
operator|->
name|cbe_lun
operator|.
name|blocksize
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|attrname
argument_list|,
literal|"blocksavail"
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|be_lun
operator|->
name|vn
operator|->
name|v_iflag
operator|&
name|VI_DOOMED
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|VFS_STATFS
argument_list|(
name|be_lun
operator|->
name|vn
operator|->
name|v_mount
argument_list|,
operator|&
name|statfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|val
operator|=
name|statfs
operator|.
name|f_bavail
operator|*
name|statfs
operator|.
name|f_bsize
operator|/
name|be_lun
operator|->
name|cbe_lun
operator|.
name|blocksize
expr_stmt|;
block|}
name|VOP_UNLOCK
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_be_block_dispatch_zvol
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|struct
name|ctl_be_block_io
modifier|*
name|beio
parameter_list|)
block|{
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|struct
name|cdevsw
modifier|*
name|csw
decl_stmt|;
name|struct
name|cdev
modifier|*
name|dev
decl_stmt|;
name|struct
name|uio
name|xuio
decl_stmt|;
name|struct
name|iovec
modifier|*
name|xiovec
decl_stmt|;
name|int
name|error
decl_stmt|,
name|flags
decl_stmt|,
name|i
decl_stmt|,
name|ref
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"entered\n"
argument_list|)
expr_stmt|;
name|io
operator|=
name|beio
operator|->
name|io
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ARGS
argument_list|(
name|io
argument_list|)
operator|->
name|flags
operator|&
name|CTL_LLF_DPO
condition|)
name|flags
operator||=
name|IO_DIRECT
expr_stmt|;
if|if
condition|(
name|beio
operator|->
name|bio_cmd
operator|==
name|BIO_WRITE
operator|&&
name|ARGS
argument_list|(
name|io
argument_list|)
operator|->
name|flags
operator|&
name|CTL_LLF_FUA
condition|)
name|flags
operator||=
name|IO_SYNC
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|xuio
argument_list|,
sizeof|sizeof
argument_list|(
name|xuio
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|beio
operator|->
name|bio_cmd
operator|==
name|BIO_READ
condition|)
block|{
name|SDT_PROBE0
argument_list|(
name|cbb
argument_list|, ,
name|read
argument_list|,
name|file_start
argument_list|)
expr_stmt|;
name|xuio
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
block|}
else|else
block|{
name|SDT_PROBE0
argument_list|(
name|cbb
argument_list|, ,
name|write
argument_list|,
name|file_start
argument_list|)
expr_stmt|;
name|xuio
operator|.
name|uio_rw
operator|=
name|UIO_WRITE
expr_stmt|;
block|}
name|xuio
operator|.
name|uio_offset
operator|=
name|beio
operator|->
name|io_offset
expr_stmt|;
name|xuio
operator|.
name|uio_resid
operator|=
name|beio
operator|->
name|io_len
expr_stmt|;
name|xuio
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|xuio
operator|.
name|uio_iov
operator|=
name|beio
operator|->
name|xiovecs
expr_stmt|;
name|xuio
operator|.
name|uio_iovcnt
operator|=
name|beio
operator|->
name|num_segs
expr_stmt|;
name|xuio
operator|.
name|uio_td
operator|=
name|curthread
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|xiovec
operator|=
name|xuio
operator|.
name|uio_iov
init|;
name|i
operator|<
name|xuio
operator|.
name|uio_iovcnt
condition|;
name|i
operator|++
operator|,
name|xiovec
operator|++
control|)
block|{
name|xiovec
operator|->
name|iov_base
operator|=
name|beio
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|addr
expr_stmt|;
name|xiovec
operator|->
name|iov_len
operator|=
name|beio
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
block|}
name|binuptime
argument_list|(
operator|&
name|beio
operator|->
name|ds_t0
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|be_lun
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|devstat_start_transaction
argument_list|(
name|beio
operator|->
name|lun
operator|->
name|disk_stats
argument_list|,
operator|&
name|beio
operator|->
name|ds_t0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|be_lun
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|csw
operator|=
name|devvn_refthread
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|,
operator|&
name|dev
argument_list|,
operator|&
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|csw
condition|)
block|{
if|if
condition|(
name|beio
operator|->
name|bio_cmd
operator|==
name|BIO_READ
condition|)
name|error
operator|=
name|csw
operator|->
name|d_read
argument_list|(
name|dev
argument_list|,
operator|&
name|xuio
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|csw
operator|->
name|d_write
argument_list|(
name|dev
argument_list|,
operator|&
name|xuio
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|dev_relthread
argument_list|(
name|dev
argument_list|,
name|ref
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|ENXIO
expr_stmt|;
if|if
condition|(
name|beio
operator|->
name|bio_cmd
operator|==
name|BIO_READ
condition|)
name|SDT_PROBE0
argument_list|(
name|cbb
argument_list|, ,
name|read
argument_list|,
name|file_done
argument_list|)
expr_stmt|;
else|else
name|SDT_PROBE0
argument_list|(
name|cbb
argument_list|, ,
name|write
argument_list|,
name|file_done
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|be_lun
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|devstat_end_transaction
argument_list|(
name|beio
operator|->
name|lun
operator|->
name|disk_stats
argument_list|,
name|beio
operator|->
name|io_len
argument_list|,
name|beio
operator|->
name|ds_tag_type
argument_list|,
name|beio
operator|->
name|ds_trans_type
argument_list|,
comment|/*now*/
name|NULL
argument_list|,
comment|/*then*/
operator|&
name|beio
operator|->
name|ds_t0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|be_lun
operator|->
name|io_lock
argument_list|)
expr_stmt|;
comment|/* 	 * If we got an error, set the sense data to "MEDIUM ERROR" and 	 * return the I/O to the user. 	 */
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|ENOSPC
operator|||
name|error
operator|==
name|EDQUOT
condition|)
block|{
name|ctl_set_space_alloc_fail
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
name|EROFS
operator|||
name|error
operator|==
name|EACCES
condition|)
block|{
name|ctl_set_hw_write_protected
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctl_set_medium_error
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|,
name|beio
operator|->
name|bio_cmd
operator|==
name|BIO_READ
argument_list|)
expr_stmt|;
block|}
name|ctl_complete_beio
argument_list|(
name|beio
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If this is a write or a verify, we're all done. 	 * If this is a read, we can now send the data to the user. 	 */
if|if
condition|(
operator|(
name|beio
operator|->
name|bio_cmd
operator|==
name|BIO_WRITE
operator|)
operator|||
operator|(
name|ARGS
argument_list|(
name|io
argument_list|)
operator|->
name|flags
operator|&
name|CTL_LLF_VERIFY
operator|)
condition|)
block|{
name|ctl_set_success
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
name|ctl_complete_beio
argument_list|(
name|beio
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ARGS
argument_list|(
name|io
argument_list|)
operator|->
name|flags
operator|&
name|CTL_LLF_READ
operator|)
operator|&&
name|beio
operator|->
name|beio_cont
operator|==
name|NULL
condition|)
block|{
name|ctl_set_success
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
name|ctl_serseq_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CTL_TIME_IO
name|getbinuptime
argument_list|(
operator|&
name|io
operator|->
name|io_hdr
operator|.
name|dma_start_bt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ctl_datamove
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_be_block_gls_zvol
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|struct
name|ctl_be_block_io
modifier|*
name|beio
parameter_list|)
block|{
name|union
name|ctl_io
modifier|*
name|io
init|=
name|beio
operator|->
name|io
decl_stmt|;
name|struct
name|cdevsw
modifier|*
name|csw
decl_stmt|;
name|struct
name|cdev
modifier|*
name|dev
decl_stmt|;
name|struct
name|ctl_lba_len_flags
modifier|*
name|lbalen
init|=
name|ARGS
argument_list|(
name|io
argument_list|)
decl_stmt|;
name|struct
name|scsi_get_lba_status_data
modifier|*
name|data
decl_stmt|;
name|off_t
name|roff
decl_stmt|,
name|off
decl_stmt|;
name|int
name|error
decl_stmt|,
name|ref
decl_stmt|,
name|status
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"entered\n"
argument_list|)
expr_stmt|;
name|csw
operator|=
name|devvn_refthread
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|,
operator|&
name|dev
argument_list|,
operator|&
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|csw
operator|==
name|NULL
condition|)
block|{
name|status
operator|=
literal|0
expr_stmt|;
comment|/* unknown up to the end */
name|off
operator|=
name|be_lun
operator|->
name|size_bytes
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|off
operator|=
name|roff
operator|=
operator|(
operator|(
name|off_t
operator|)
name|lbalen
operator|->
name|lba
operator|)
operator|*
name|be_lun
operator|->
name|cbe_lun
operator|.
name|blocksize
expr_stmt|;
name|error
operator|=
name|csw
operator|->
name|d_ioctl
argument_list|(
name|dev
argument_list|,
name|FIOSEEKHOLE
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|off
argument_list|,
name|FREAD
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|off
operator|>
name|roff
condition|)
name|status
operator|=
literal|0
expr_stmt|;
comment|/* mapped up to off */
else|else
block|{
name|error
operator|=
name|csw
operator|->
name|d_ioctl
argument_list|(
name|dev
argument_list|,
name|FIOSEEKDATA
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|off
argument_list|,
name|FREAD
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|off
operator|>
name|roff
condition|)
name|status
operator|=
literal|1
expr_stmt|;
comment|/* deallocated up to off */
else|else
block|{
name|status
operator|=
literal|0
expr_stmt|;
comment|/* unknown up to the end */
name|off
operator|=
name|be_lun
operator|->
name|size_bytes
expr_stmt|;
block|}
block|}
name|dev_relthread
argument_list|(
name|dev
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|done
label|:
name|data
operator|=
operator|(
expr|struct
name|scsi_get_lba_status_data
operator|*
operator|)
name|io
operator|->
name|scsiio
operator|.
name|kern_data_ptr
expr_stmt|;
name|scsi_u64to8b
argument_list|(
name|lbalen
operator|->
name|lba
argument_list|,
name|data
operator|->
name|descr
index|[
literal|0
index|]
operator|.
name|addr
argument_list|)
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|MIN
argument_list|(
name|UINT32_MAX
argument_list|,
name|off
operator|/
name|be_lun
operator|->
name|cbe_lun
operator|.
name|blocksize
operator|-
name|lbalen
operator|->
name|lba
argument_list|)
argument_list|,
name|data
operator|->
name|descr
index|[
literal|0
index|]
operator|.
name|length
argument_list|)
expr_stmt|;
name|data
operator|->
name|descr
index|[
literal|0
index|]
operator|.
name|status
operator|=
name|status
expr_stmt|;
name|ctl_complete_beio
argument_list|(
name|beio
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_be_block_flush_dev
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|struct
name|ctl_be_block_io
modifier|*
name|beio
parameter_list|)
block|{
name|struct
name|bio
modifier|*
name|bio
decl_stmt|;
name|struct
name|cdevsw
modifier|*
name|csw
decl_stmt|;
name|struct
name|cdev
modifier|*
name|dev
decl_stmt|;
name|int
name|ref
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"entered\n"
argument_list|)
expr_stmt|;
comment|/* This can't fail, it's a blocking allocation. */
name|bio
operator|=
name|g_alloc_bio
argument_list|()
expr_stmt|;
name|bio
operator|->
name|bio_cmd
operator|=
name|BIO_FLUSH
expr_stmt|;
name|bio
operator|->
name|bio_offset
operator|=
literal|0
expr_stmt|;
name|bio
operator|->
name|bio_data
operator|=
literal|0
expr_stmt|;
name|bio
operator|->
name|bio_done
operator|=
name|ctl_be_block_biodone
expr_stmt|;
name|bio
operator|->
name|bio_caller1
operator|=
name|beio
expr_stmt|;
name|bio
operator|->
name|bio_pblkno
operator|=
literal|0
expr_stmt|;
comment|/* 	 * We don't need to acquire the LUN lock here, because we are only 	 * sending one bio, and so there is no other context to synchronize 	 * with. 	 */
name|beio
operator|->
name|num_bios_sent
operator|=
literal|1
expr_stmt|;
name|beio
operator|->
name|send_complete
operator|=
literal|1
expr_stmt|;
name|binuptime
argument_list|(
operator|&
name|beio
operator|->
name|ds_t0
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|be_lun
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|devstat_start_transaction
argument_list|(
name|be_lun
operator|->
name|disk_stats
argument_list|,
operator|&
name|beio
operator|->
name|ds_t0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|be_lun
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|csw
operator|=
name|devvn_refthread
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|,
operator|&
name|dev
argument_list|,
operator|&
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|csw
condition|)
block|{
name|bio
operator|->
name|bio_dev
operator|=
name|dev
expr_stmt|;
name|csw
operator|->
name|d_strategy
argument_list|(
name|bio
argument_list|)
expr_stmt|;
name|dev_relthread
argument_list|(
name|dev
argument_list|,
name|ref
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bio
operator|->
name|bio_error
operator|=
name|ENXIO
expr_stmt|;
name|ctl_be_block_biodone
argument_list|(
name|bio
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_be_block_unmap_dev_range
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|struct
name|ctl_be_block_io
modifier|*
name|beio
parameter_list|,
name|uint64_t
name|off
parameter_list|,
name|uint64_t
name|len
parameter_list|,
name|int
name|last
parameter_list|)
block|{
name|struct
name|bio
modifier|*
name|bio
decl_stmt|;
name|uint64_t
name|maxlen
decl_stmt|;
name|struct
name|cdevsw
modifier|*
name|csw
decl_stmt|;
name|struct
name|cdev
modifier|*
name|dev
decl_stmt|;
name|int
name|ref
decl_stmt|;
name|csw
operator|=
name|devvn_refthread
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|,
operator|&
name|dev
argument_list|,
operator|&
name|ref
argument_list|)
expr_stmt|;
name|maxlen
operator|=
name|LONG_MAX
operator|-
operator|(
name|LONG_MAX
operator|%
name|be_lun
operator|->
name|cbe_lun
operator|.
name|blocksize
operator|)
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|bio
operator|=
name|g_alloc_bio
argument_list|()
expr_stmt|;
name|bio
operator|->
name|bio_cmd
operator|=
name|BIO_DELETE
expr_stmt|;
name|bio
operator|->
name|bio_dev
operator|=
name|dev
expr_stmt|;
name|bio
operator|->
name|bio_offset
operator|=
name|off
expr_stmt|;
name|bio
operator|->
name|bio_length
operator|=
name|MIN
argument_list|(
name|len
argument_list|,
name|maxlen
argument_list|)
expr_stmt|;
name|bio
operator|->
name|bio_data
operator|=
literal|0
expr_stmt|;
name|bio
operator|->
name|bio_done
operator|=
name|ctl_be_block_biodone
expr_stmt|;
name|bio
operator|->
name|bio_caller1
operator|=
name|beio
expr_stmt|;
name|bio
operator|->
name|bio_pblkno
operator|=
name|off
operator|/
name|be_lun
operator|->
name|cbe_lun
operator|.
name|blocksize
expr_stmt|;
name|off
operator|+=
name|bio
operator|->
name|bio_length
expr_stmt|;
name|len
operator|-=
name|bio
operator|->
name|bio_length
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|be_lun
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|beio
operator|->
name|num_bios_sent
operator|++
expr_stmt|;
if|if
condition|(
name|last
operator|&&
name|len
operator|==
literal|0
condition|)
name|beio
operator|->
name|send_complete
operator|=
literal|1
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|be_lun
operator|->
name|io_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|csw
condition|)
block|{
name|csw
operator|->
name|d_strategy
argument_list|(
name|bio
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bio
operator|->
name|bio_error
operator|=
name|ENXIO
expr_stmt|;
name|ctl_be_block_biodone
argument_list|(
name|bio
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|csw
condition|)
name|dev_relthread
argument_list|(
name|dev
argument_list|,
name|ref
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_be_block_unmap_dev
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|struct
name|ctl_be_block_io
modifier|*
name|beio
parameter_list|)
block|{
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|struct
name|ctl_ptr_len_flags
modifier|*
name|ptrlen
decl_stmt|;
name|struct
name|scsi_unmap_desc
modifier|*
name|buf
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|uint64_t
name|len
decl_stmt|;
name|io
operator|=
name|beio
operator|->
name|io
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"entered\n"
argument_list|)
expr_stmt|;
name|binuptime
argument_list|(
operator|&
name|beio
operator|->
name|ds_t0
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|be_lun
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|devstat_start_transaction
argument_list|(
name|be_lun
operator|->
name|disk_stats
argument_list|,
operator|&
name|beio
operator|->
name|ds_t0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|be_lun
operator|->
name|io_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|beio
operator|->
name|io_offset
operator|==
operator|-
literal|1
condition|)
block|{
name|beio
operator|->
name|io_len
operator|=
literal|0
expr_stmt|;
name|ptrlen
operator|=
operator|(
expr|struct
name|ctl_ptr_len_flags
operator|*
operator|)
operator|&
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LBA_LEN
index|]
expr_stmt|;
name|buf
operator|=
operator|(
expr|struct
name|scsi_unmap_desc
operator|*
operator|)
name|ptrlen
operator|->
name|ptr
expr_stmt|;
name|end
operator|=
name|buf
operator|+
name|ptrlen
operator|->
name|len
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|buf
operator|<
name|end
condition|;
name|buf
operator|++
control|)
block|{
name|len
operator|=
operator|(
name|uint64_t
operator|)
name|scsi_4btoul
argument_list|(
name|buf
operator|->
name|length
argument_list|)
operator|*
name|be_lun
operator|->
name|cbe_lun
operator|.
name|blocksize
expr_stmt|;
name|beio
operator|->
name|io_len
operator|+=
name|len
expr_stmt|;
name|ctl_be_block_unmap_dev_range
argument_list|(
name|be_lun
argument_list|,
name|beio
argument_list|,
name|scsi_8btou64
argument_list|(
name|buf
operator|->
name|lba
argument_list|)
operator|*
name|be_lun
operator|->
name|cbe_lun
operator|.
name|blocksize
argument_list|,
name|len
argument_list|,
operator|(
name|end
operator|-
name|buf
operator|<
literal|2
operator|)
condition|?
name|TRUE
else|:
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|ctl_be_block_unmap_dev_range
argument_list|(
name|be_lun
argument_list|,
name|beio
argument_list|,
name|beio
operator|->
name|io_offset
argument_list|,
name|beio
operator|->
name|io_len
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_be_block_dispatch_dev
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|struct
name|ctl_be_block_io
modifier|*
name|beio
parameter_list|)
block|{
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|bio
argument_list|)
name|queue
operator|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|queue
argument_list|)
expr_stmt|;
name|struct
name|bio
modifier|*
name|bio
decl_stmt|;
name|struct
name|cdevsw
modifier|*
name|csw
decl_stmt|;
name|struct
name|cdev
modifier|*
name|dev
decl_stmt|;
name|off_t
name|cur_offset
decl_stmt|;
name|int
name|i
decl_stmt|,
name|max_iosize
decl_stmt|,
name|ref
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"entered\n"
argument_list|)
expr_stmt|;
name|csw
operator|=
name|devvn_refthread
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|,
operator|&
name|dev
argument_list|,
operator|&
name|ref
argument_list|)
expr_stmt|;
comment|/* 	 * We have to limit our I/O size to the maximum supported by the 	 * backend device.  Hopefully it is MAXPHYS.  If the driver doesn't 	 * set it properly, use DFLTPHYS. 	 */
if|if
condition|(
name|csw
condition|)
block|{
name|max_iosize
operator|=
name|dev
operator|->
name|si_iosize_max
expr_stmt|;
if|if
condition|(
name|max_iosize
operator|<
name|PAGE_SIZE
condition|)
name|max_iosize
operator|=
name|DFLTPHYS
expr_stmt|;
block|}
else|else
name|max_iosize
operator|=
name|DFLTPHYS
expr_stmt|;
name|cur_offset
operator|=
name|beio
operator|->
name|io_offset
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|beio
operator|->
name|num_segs
condition|;
name|i
operator|++
control|)
block|{
name|size_t
name|cur_size
decl_stmt|;
name|uint8_t
modifier|*
name|cur_ptr
decl_stmt|;
name|cur_size
operator|=
name|beio
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
name|cur_ptr
operator|=
name|beio
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|addr
expr_stmt|;
while|while
condition|(
name|cur_size
operator|>
literal|0
condition|)
block|{
comment|/* This can't fail, it's a blocking allocation. */
name|bio
operator|=
name|g_alloc_bio
argument_list|()
expr_stmt|;
name|KASSERT
argument_list|(
name|bio
operator|!=
name|NULL
argument_list|,
operator|(
literal|"g_alloc_bio() failed!\n"
operator|)
argument_list|)
expr_stmt|;
name|bio
operator|->
name|bio_cmd
operator|=
name|beio
operator|->
name|bio_cmd
expr_stmt|;
name|bio
operator|->
name|bio_dev
operator|=
name|dev
expr_stmt|;
name|bio
operator|->
name|bio_caller1
operator|=
name|beio
expr_stmt|;
name|bio
operator|->
name|bio_length
operator|=
name|min
argument_list|(
name|cur_size
argument_list|,
name|max_iosize
argument_list|)
expr_stmt|;
name|bio
operator|->
name|bio_offset
operator|=
name|cur_offset
expr_stmt|;
name|bio
operator|->
name|bio_data
operator|=
name|cur_ptr
expr_stmt|;
name|bio
operator|->
name|bio_done
operator|=
name|ctl_be_block_biodone
expr_stmt|;
name|bio
operator|->
name|bio_pblkno
operator|=
name|cur_offset
operator|/
name|be_lun
operator|->
name|cbe_lun
operator|.
name|blocksize
expr_stmt|;
name|cur_offset
operator|+=
name|bio
operator|->
name|bio_length
expr_stmt|;
name|cur_ptr
operator|+=
name|bio
operator|->
name|bio_length
expr_stmt|;
name|cur_size
operator|-=
name|bio
operator|->
name|bio_length
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|queue
argument_list|,
name|bio
argument_list|,
name|bio_queue
argument_list|)
expr_stmt|;
name|beio
operator|->
name|num_bios_sent
operator|++
expr_stmt|;
block|}
block|}
name|binuptime
argument_list|(
operator|&
name|beio
operator|->
name|ds_t0
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|be_lun
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|devstat_start_transaction
argument_list|(
name|be_lun
operator|->
name|disk_stats
argument_list|,
operator|&
name|beio
operator|->
name|ds_t0
argument_list|)
expr_stmt|;
name|beio
operator|->
name|send_complete
operator|=
literal|1
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|be_lun
operator|->
name|io_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Fire off all allocated requests! 	 */
while|while
condition|(
operator|(
name|bio
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|queue
argument_list|,
name|bio
argument_list|,
name|bio_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|csw
condition|)
name|csw
operator|->
name|d_strategy
argument_list|(
name|bio
argument_list|)
expr_stmt|;
else|else
block|{
name|bio
operator|->
name|bio_error
operator|=
name|ENXIO
expr_stmt|;
name|ctl_be_block_biodone
argument_list|(
name|bio
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|csw
condition|)
name|dev_relthread
argument_list|(
name|dev
argument_list|,
name|ref
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|ctl_be_block_getattr_dev
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
specifier|const
name|char
modifier|*
name|attrname
parameter_list|)
block|{
name|struct
name|diocgattr_arg
name|arg
decl_stmt|;
name|struct
name|cdevsw
modifier|*
name|csw
decl_stmt|;
name|struct
name|cdev
modifier|*
name|dev
decl_stmt|;
name|int
name|error
decl_stmt|,
name|ref
decl_stmt|;
name|csw
operator|=
name|devvn_refthread
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|,
operator|&
name|dev
argument_list|,
operator|&
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|csw
operator|==
name|NULL
condition|)
return|return
operator|(
name|UINT64_MAX
operator|)
return|;
name|strlcpy
argument_list|(
name|arg
operator|.
name|name
argument_list|,
name|attrname
argument_list|,
sizeof|sizeof
argument_list|(
name|arg
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|arg
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
name|arg
operator|.
name|value
operator|.
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|csw
operator|->
name|d_ioctl
condition|)
block|{
name|error
operator|=
name|csw
operator|->
name|d_ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGATTR
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|arg
argument_list|,
name|FREAD
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|ENODEV
expr_stmt|;
name|dev_relthread
argument_list|(
name|dev
argument_list|,
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|UINT64_MAX
operator|)
return|;
return|return
operator|(
name|arg
operator|.
name|value
operator|.
name|off
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_be_block_cw_dispatch_sync
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_be_lun
modifier|*
name|cbe_lun
init|=
operator|&
name|be_lun
operator|->
name|cbe_lun
decl_stmt|;
name|struct
name|ctl_be_block_io
modifier|*
name|beio
decl_stmt|;
name|struct
name|ctl_lba_len_flags
modifier|*
name|lbalen
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"entered\n"
argument_list|)
expr_stmt|;
name|beio
operator|=
operator|(
expr|struct
name|ctl_be_block_io
operator|*
operator|)
name|PRIV
argument_list|(
name|io
argument_list|)
operator|->
name|ptr
expr_stmt|;
name|lbalen
operator|=
operator|(
expr|struct
name|ctl_lba_len_flags
operator|*
operator|)
operator|&
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LBA_LEN
index|]
expr_stmt|;
name|beio
operator|->
name|io_len
operator|=
name|lbalen
operator|->
name|len
operator|*
name|cbe_lun
operator|->
name|blocksize
expr_stmt|;
name|beio
operator|->
name|io_offset
operator|=
name|lbalen
operator|->
name|lba
operator|*
name|cbe_lun
operator|->
name|blocksize
expr_stmt|;
name|beio
operator|->
name|io_arg
operator|=
operator|(
name|lbalen
operator|->
name|flags
operator|&
name|SSC_IMMED
operator|)
operator|!=
literal|0
expr_stmt|;
name|beio
operator|->
name|bio_cmd
operator|=
name|BIO_FLUSH
expr_stmt|;
name|beio
operator|->
name|ds_trans_type
operator|=
name|DEVSTAT_NO_DATA
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"SYNC\n"
argument_list|)
expr_stmt|;
name|be_lun
operator|->
name|lun_flush
argument_list|(
name|be_lun
argument_list|,
name|beio
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_be_block_cw_done_ws
parameter_list|(
name|struct
name|ctl_be_block_io
modifier|*
name|beio
parameter_list|)
block|{
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|io
operator|=
name|beio
operator|->
name|io
expr_stmt|;
name|ctl_free_beio
argument_list|(
name|beio
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ABORT
operator|)
operator|||
operator|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|!=
name|CTL_STATUS_NONE
operator|&&
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|!=
name|CTL_SUCCESS
operator|)
condition|)
block|{
name|ctl_config_write_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
return|return;
block|}
name|ctl_be_block_config_write
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_be_block_cw_dispatch_ws
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_be_lun
modifier|*
name|cbe_lun
init|=
operator|&
name|be_lun
operator|->
name|cbe_lun
decl_stmt|;
name|struct
name|ctl_be_block_io
modifier|*
name|beio
decl_stmt|;
name|struct
name|ctl_lba_len_flags
modifier|*
name|lbalen
decl_stmt|;
name|uint64_t
name|len_left
decl_stmt|,
name|lba
decl_stmt|;
name|uint32_t
name|pb
decl_stmt|,
name|pbo
decl_stmt|,
name|adj
decl_stmt|;
name|int
name|i
decl_stmt|,
name|seglen
decl_stmt|;
name|uint8_t
modifier|*
name|buf
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"entered\n"
argument_list|)
expr_stmt|;
name|beio
operator|=
operator|(
expr|struct
name|ctl_be_block_io
operator|*
operator|)
name|PRIV
argument_list|(
name|io
argument_list|)
operator|->
name|ptr
expr_stmt|;
name|lbalen
operator|=
name|ARGS
argument_list|(
name|beio
operator|->
name|io
argument_list|)
expr_stmt|;
if|if
condition|(
name|lbalen
operator|->
name|flags
operator|&
operator|~
operator|(
name|SWS_LBDATA
operator||
name|SWS_UNMAP
operator||
name|SWS_ANCHOR
operator||
name|SWS_NDOB
operator|)
operator|||
operator|(
name|lbalen
operator|->
name|flags
operator|&
operator|(
name|SWS_UNMAP
operator||
name|SWS_ANCHOR
operator|)
operator|&&
name|be_lun
operator|->
name|unmap
operator|==
name|NULL
operator|)
condition|)
block|{
name|ctl_free_beio
argument_list|(
name|beio
argument_list|)
expr_stmt|;
name|ctl_set_invalid_field
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|1
argument_list|,
comment|/*bit_valid*/
literal|0
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
name|ctl_config_write_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|lbalen
operator|->
name|flags
operator|&
operator|(
name|SWS_UNMAP
operator||
name|SWS_ANCHOR
operator|)
condition|)
block|{
name|beio
operator|->
name|io_offset
operator|=
name|lbalen
operator|->
name|lba
operator|*
name|cbe_lun
operator|->
name|blocksize
expr_stmt|;
name|beio
operator|->
name|io_len
operator|=
operator|(
name|uint64_t
operator|)
name|lbalen
operator|->
name|len
operator|*
name|cbe_lun
operator|->
name|blocksize
expr_stmt|;
name|beio
operator|->
name|bio_cmd
operator|=
name|BIO_DELETE
expr_stmt|;
name|beio
operator|->
name|ds_trans_type
operator|=
name|DEVSTAT_FREE
expr_stmt|;
name|be_lun
operator|->
name|unmap
argument_list|(
name|be_lun
argument_list|,
name|beio
argument_list|)
expr_stmt|;
return|return;
block|}
name|beio
operator|->
name|bio_cmd
operator|=
name|BIO_WRITE
expr_stmt|;
name|beio
operator|->
name|ds_trans_type
operator|=
name|DEVSTAT_WRITE
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"WRITE SAME at LBA %jx len %u\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|lbalen
operator|->
name|lba
argument_list|,
name|lbalen
operator|->
name|len
argument_list|)
expr_stmt|;
name|pb
operator|=
name|cbe_lun
operator|->
name|blocksize
operator|<<
name|be_lun
operator|->
name|cbe_lun
operator|.
name|pblockexp
expr_stmt|;
if|if
condition|(
name|be_lun
operator|->
name|cbe_lun
operator|.
name|pblockoff
operator|>
literal|0
condition|)
name|pbo
operator|=
name|pb
operator|-
name|cbe_lun
operator|->
name|blocksize
operator|*
name|be_lun
operator|->
name|cbe_lun
operator|.
name|pblockoff
expr_stmt|;
else|else
name|pbo
operator|=
literal|0
expr_stmt|;
name|len_left
operator|=
operator|(
name|uint64_t
operator|)
name|lbalen
operator|->
name|len
operator|*
name|cbe_lun
operator|->
name|blocksize
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|lba
operator|=
literal|0
init|;
name|i
operator|<
name|CTLBLK_MAX_SEGS
operator|&&
name|len_left
operator|>
literal|0
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * Setup the S/G entry for this chunk. 		 */
name|seglen
operator|=
name|MIN
argument_list|(
name|CTLBLK_MAX_SEG
argument_list|,
name|len_left
argument_list|)
expr_stmt|;
if|if
condition|(
name|pb
operator|>
name|cbe_lun
operator|->
name|blocksize
condition|)
block|{
name|adj
operator|=
operator|(
operator|(
name|lbalen
operator|->
name|lba
operator|+
name|lba
operator|)
operator|*
name|cbe_lun
operator|->
name|blocksize
operator|+
name|seglen
operator|-
name|pbo
operator|)
operator|%
name|pb
expr_stmt|;
if|if
condition|(
name|seglen
operator|>
name|adj
condition|)
name|seglen
operator|-=
name|adj
expr_stmt|;
else|else
name|seglen
operator|-=
name|seglen
operator|%
name|cbe_lun
operator|->
name|blocksize
expr_stmt|;
block|}
else|else
name|seglen
operator|-=
name|seglen
operator|%
name|cbe_lun
operator|->
name|blocksize
expr_stmt|;
name|beio
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|len
operator|=
name|seglen
expr_stmt|;
name|beio
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|addr
operator|=
name|uma_zalloc
argument_list|(
name|be_lun
operator|->
name|lun_zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"segment %d addr %p len %zd\n"
argument_list|,
name|i
argument_list|,
name|beio
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|addr
argument_list|,
name|beio
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
name|beio
operator|->
name|num_segs
operator|++
expr_stmt|;
name|len_left
operator|-=
name|seglen
expr_stmt|;
name|buf
operator|=
name|beio
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|addr
expr_stmt|;
name|end
operator|=
name|buf
operator|+
name|seglen
expr_stmt|;
for|for
control|(
init|;
name|buf
operator|<
name|end
condition|;
name|buf
operator|+=
name|cbe_lun
operator|->
name|blocksize
control|)
block|{
if|if
condition|(
name|lbalen
operator|->
name|flags
operator|&
name|SWS_NDOB
condition|)
block|{
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|cbe_lun
operator|->
name|blocksize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|buf
argument_list|,
name|io
operator|->
name|scsiio
operator|.
name|kern_data_ptr
argument_list|,
name|cbe_lun
operator|->
name|blocksize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lbalen
operator|->
name|flags
operator|&
name|SWS_LBDATA
condition|)
name|scsi_ulto4b
argument_list|(
name|lbalen
operator|->
name|lba
operator|+
name|lba
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|lba
operator|++
expr_stmt|;
block|}
block|}
name|beio
operator|->
name|io_offset
operator|=
name|lbalen
operator|->
name|lba
operator|*
name|cbe_lun
operator|->
name|blocksize
expr_stmt|;
name|beio
operator|->
name|io_len
operator|=
name|lba
operator|*
name|cbe_lun
operator|->
name|blocksize
expr_stmt|;
comment|/* We can not do all in one run. Correct and schedule rerun. */
if|if
condition|(
name|len_left
operator|>
literal|0
condition|)
block|{
name|lbalen
operator|->
name|lba
operator|+=
name|lba
expr_stmt|;
name|lbalen
operator|->
name|len
operator|-=
name|lba
expr_stmt|;
name|beio
operator|->
name|beio_cont
operator|=
name|ctl_be_block_cw_done_ws
expr_stmt|;
block|}
name|be_lun
operator|->
name|dispatch
argument_list|(
name|be_lun
argument_list|,
name|beio
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_be_block_cw_dispatch_unmap
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_be_block_io
modifier|*
name|beio
decl_stmt|;
name|struct
name|ctl_ptr_len_flags
modifier|*
name|ptrlen
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"entered\n"
argument_list|)
expr_stmt|;
name|beio
operator|=
operator|(
expr|struct
name|ctl_be_block_io
operator|*
operator|)
name|PRIV
argument_list|(
name|io
argument_list|)
operator|->
name|ptr
expr_stmt|;
name|ptrlen
operator|=
operator|(
expr|struct
name|ctl_ptr_len_flags
operator|*
operator|)
operator|&
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LBA_LEN
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|ptrlen
operator|->
name|flags
operator|&
operator|~
name|SU_ANCHOR
operator|)
operator|!=
literal|0
operator|||
name|be_lun
operator|->
name|unmap
operator|==
name|NULL
condition|)
block|{
name|ctl_free_beio
argument_list|(
name|beio
argument_list|)
expr_stmt|;
name|ctl_set_invalid_field
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|,
comment|/*sks_valid*/
literal|0
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|0
argument_list|,
comment|/*bit_valid*/
literal|0
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
name|ctl_config_write_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
return|return;
block|}
name|beio
operator|->
name|io_len
operator|=
literal|0
expr_stmt|;
name|beio
operator|->
name|io_offset
operator|=
operator|-
literal|1
expr_stmt|;
name|beio
operator|->
name|bio_cmd
operator|=
name|BIO_DELETE
expr_stmt|;
name|beio
operator|->
name|ds_trans_type
operator|=
name|DEVSTAT_FREE
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"UNMAP\n"
argument_list|)
expr_stmt|;
name|be_lun
operator|->
name|unmap
argument_list|(
name|be_lun
argument_list|,
name|beio
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_be_block_cr_done
parameter_list|(
name|struct
name|ctl_be_block_io
modifier|*
name|beio
parameter_list|)
block|{
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|io
operator|=
name|beio
operator|->
name|io
expr_stmt|;
name|ctl_free_beio
argument_list|(
name|beio
argument_list|)
expr_stmt|;
name|ctl_config_read_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_be_block_cr_dispatch
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_be_block_io
modifier|*
name|beio
decl_stmt|;
name|struct
name|ctl_be_block_softc
modifier|*
name|softc
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"entered\n"
argument_list|)
expr_stmt|;
name|softc
operator|=
name|be_lun
operator|->
name|softc
expr_stmt|;
name|beio
operator|=
name|ctl_alloc_beio
argument_list|(
name|softc
argument_list|)
expr_stmt|;
name|beio
operator|->
name|io
operator|=
name|io
expr_stmt|;
name|beio
operator|->
name|lun
operator|=
name|be_lun
expr_stmt|;
name|beio
operator|->
name|beio_cont
operator|=
name|ctl_be_block_cr_done
expr_stmt|;
name|PRIV
argument_list|(
name|io
argument_list|)
operator|->
name|ptr
operator|=
operator|(
name|void
operator|*
operator|)
name|beio
expr_stmt|;
switch|switch
condition|(
name|io
operator|->
name|scsiio
operator|.
name|cdb
index|[
literal|0
index|]
condition|)
block|{
case|case
name|SERVICE_ACTION_IN
case|:
comment|/* GET LBA STATUS */
name|beio
operator|->
name|bio_cmd
operator|=
operator|-
literal|1
expr_stmt|;
name|beio
operator|->
name|ds_trans_type
operator|=
name|DEVSTAT_NO_DATA
expr_stmt|;
name|beio
operator|->
name|ds_tag_type
operator|=
name|DEVSTAT_TAG_ORDERED
expr_stmt|;
name|beio
operator|->
name|io_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|be_lun
operator|->
name|get_lba_status
condition|)
name|be_lun
operator|->
name|get_lba_status
argument_list|(
name|be_lun
argument_list|,
name|beio
argument_list|)
expr_stmt|;
else|else
name|ctl_be_block_cr_done
argument_list|(
name|beio
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"Unhandled CDB type %#x"
argument_list|,
name|io
operator|->
name|scsiio
operator|.
name|cdb
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_be_block_cw_done
parameter_list|(
name|struct
name|ctl_be_block_io
modifier|*
name|beio
parameter_list|)
block|{
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|io
operator|=
name|beio
operator|->
name|io
expr_stmt|;
name|ctl_free_beio
argument_list|(
name|beio
argument_list|)
expr_stmt|;
name|ctl_config_write_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_be_block_cw_dispatch
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_be_block_io
modifier|*
name|beio
decl_stmt|;
name|struct
name|ctl_be_block_softc
modifier|*
name|softc
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"entered\n"
argument_list|)
expr_stmt|;
name|softc
operator|=
name|be_lun
operator|->
name|softc
expr_stmt|;
name|beio
operator|=
name|ctl_alloc_beio
argument_list|(
name|softc
argument_list|)
expr_stmt|;
name|beio
operator|->
name|io
operator|=
name|io
expr_stmt|;
name|beio
operator|->
name|lun
operator|=
name|be_lun
expr_stmt|;
name|beio
operator|->
name|beio_cont
operator|=
name|ctl_be_block_cw_done
expr_stmt|;
switch|switch
condition|(
name|io
operator|->
name|scsiio
operator|.
name|tag_type
condition|)
block|{
case|case
name|CTL_TAG_ORDERED
case|:
name|beio
operator|->
name|ds_tag_type
operator|=
name|DEVSTAT_TAG_ORDERED
expr_stmt|;
break|break;
case|case
name|CTL_TAG_HEAD_OF_QUEUE
case|:
name|beio
operator|->
name|ds_tag_type
operator|=
name|DEVSTAT_TAG_HEAD
expr_stmt|;
break|break;
case|case
name|CTL_TAG_UNTAGGED
case|:
case|case
name|CTL_TAG_SIMPLE
case|:
case|case
name|CTL_TAG_ACA
case|:
default|default:
name|beio
operator|->
name|ds_tag_type
operator|=
name|DEVSTAT_TAG_SIMPLE
expr_stmt|;
break|break;
block|}
name|PRIV
argument_list|(
name|io
argument_list|)
operator|->
name|ptr
operator|=
operator|(
name|void
operator|*
operator|)
name|beio
expr_stmt|;
switch|switch
condition|(
name|io
operator|->
name|scsiio
operator|.
name|cdb
index|[
literal|0
index|]
condition|)
block|{
case|case
name|SYNCHRONIZE_CACHE
case|:
case|case
name|SYNCHRONIZE_CACHE_16
case|:
name|ctl_be_block_cw_dispatch_sync
argument_list|(
name|be_lun
argument_list|,
name|io
argument_list|)
expr_stmt|;
break|break;
case|case
name|WRITE_SAME_10
case|:
case|case
name|WRITE_SAME_16
case|:
name|ctl_be_block_cw_dispatch_ws
argument_list|(
name|be_lun
argument_list|,
name|io
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNMAP
case|:
name|ctl_be_block_cw_dispatch_unmap
argument_list|(
name|be_lun
argument_list|,
name|io
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"Unhandled CDB type %#x"
argument_list|,
name|io
operator|->
name|scsiio
operator|.
name|cdb
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_expr_stmt
name|SDT_PROBE_DEFINE1
argument_list|(
name|cbb
argument_list|, ,
name|read
argument_list|,
name|start
argument_list|,
literal|"uint64_t"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SDT_PROBE_DEFINE1
argument_list|(
name|cbb
argument_list|, ,
name|write
argument_list|,
name|start
argument_list|,
literal|"uint64_t"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SDT_PROBE_DEFINE1
argument_list|(
name|cbb
argument_list|, ,
name|read
argument_list|,
name|alloc_done
argument_list|,
literal|"uint64_t"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SDT_PROBE_DEFINE1
argument_list|(
name|cbb
argument_list|, ,
name|write
argument_list|,
name|alloc_done
argument_list|,
literal|"uint64_t"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|ctl_be_block_next
parameter_list|(
name|struct
name|ctl_be_block_io
modifier|*
name|beio
parameter_list|)
block|{
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
decl_stmt|;
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|io
operator|=
name|beio
operator|->
name|io
expr_stmt|;
name|be_lun
operator|=
name|beio
operator|->
name|lun
expr_stmt|;
name|ctl_free_beio
argument_list|(
name|beio
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ABORT
operator|)
operator|||
operator|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|!=
name|CTL_STATUS_NONE
operator|&&
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|!=
name|CTL_SUCCESS
operator|)
condition|)
block|{
name|ctl_data_submit_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
return|return;
block|}
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&=
operator|~
name|CTL_STATUS_MASK
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|status
operator||=
name|CTL_STATUS_NONE
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|be_lun
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|be_lun
operator|->
name|input_queue
argument_list|,
operator|&
name|io
operator|->
name|io_hdr
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|be_lun
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|be_lun
operator|->
name|io_taskqueue
argument_list|,
operator|&
name|be_lun
operator|->
name|io_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_be_block_dispatch
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_be_lun
modifier|*
name|cbe_lun
init|=
operator|&
name|be_lun
operator|->
name|cbe_lun
decl_stmt|;
name|struct
name|ctl_be_block_io
modifier|*
name|beio
decl_stmt|;
name|struct
name|ctl_be_block_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ctl_lba_len_flags
modifier|*
name|lbalen
decl_stmt|;
name|struct
name|ctl_ptr_len_flags
modifier|*
name|bptrlen
decl_stmt|;
name|uint64_t
name|len_left
decl_stmt|,
name|lbas
decl_stmt|;
name|int
name|i
decl_stmt|;
name|softc
operator|=
name|be_lun
operator|->
name|softc
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"entered\n"
argument_list|)
expr_stmt|;
name|lbalen
operator|=
name|ARGS
argument_list|(
name|io
argument_list|)
expr_stmt|;
if|if
condition|(
name|lbalen
operator|->
name|flags
operator|&
name|CTL_LLF_WRITE
condition|)
block|{
name|SDT_PROBE0
argument_list|(
name|cbb
argument_list|, ,
name|write
argument_list|,
name|start
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SDT_PROBE0
argument_list|(
name|cbb
argument_list|, ,
name|read
argument_list|,
name|start
argument_list|)
expr_stmt|;
block|}
name|beio
operator|=
name|ctl_alloc_beio
argument_list|(
name|softc
argument_list|)
expr_stmt|;
name|beio
operator|->
name|io
operator|=
name|io
expr_stmt|;
name|beio
operator|->
name|lun
operator|=
name|be_lun
expr_stmt|;
name|bptrlen
operator|=
name|PRIV
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|bptrlen
operator|->
name|ptr
operator|=
operator|(
name|void
operator|*
operator|)
name|beio
expr_stmt|;
switch|switch
condition|(
name|io
operator|->
name|scsiio
operator|.
name|tag_type
condition|)
block|{
case|case
name|CTL_TAG_ORDERED
case|:
name|beio
operator|->
name|ds_tag_type
operator|=
name|DEVSTAT_TAG_ORDERED
expr_stmt|;
break|break;
case|case
name|CTL_TAG_HEAD_OF_QUEUE
case|:
name|beio
operator|->
name|ds_tag_type
operator|=
name|DEVSTAT_TAG_HEAD
expr_stmt|;
break|break;
case|case
name|CTL_TAG_UNTAGGED
case|:
case|case
name|CTL_TAG_SIMPLE
case|:
case|case
name|CTL_TAG_ACA
case|:
default|default:
name|beio
operator|->
name|ds_tag_type
operator|=
name|DEVSTAT_TAG_SIMPLE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|lbalen
operator|->
name|flags
operator|&
name|CTL_LLF_WRITE
condition|)
block|{
name|beio
operator|->
name|bio_cmd
operator|=
name|BIO_WRITE
expr_stmt|;
name|beio
operator|->
name|ds_trans_type
operator|=
name|DEVSTAT_WRITE
expr_stmt|;
block|}
else|else
block|{
name|beio
operator|->
name|bio_cmd
operator|=
name|BIO_READ
expr_stmt|;
name|beio
operator|->
name|ds_trans_type
operator|=
name|DEVSTAT_READ
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|"%s at LBA %jx len %u @%ju\n"
argument_list|,
operator|(
name|beio
operator|->
name|bio_cmd
operator|==
name|BIO_READ
operator|)
condition|?
literal|"READ"
else|:
literal|"WRITE"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|lbalen
operator|->
name|lba
argument_list|,
name|lbalen
operator|->
name|len
argument_list|,
name|bptrlen
operator|->
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|lbalen
operator|->
name|flags
operator|&
name|CTL_LLF_COMPARE
condition|)
name|lbas
operator|=
name|CTLBLK_HALF_IO_SIZE
expr_stmt|;
else|else
name|lbas
operator|=
name|CTLBLK_MAX_IO_SIZE
expr_stmt|;
name|lbas
operator|=
name|MIN
argument_list|(
name|lbalen
operator|->
name|len
operator|-
name|bptrlen
operator|->
name|len
argument_list|,
name|lbas
operator|/
name|cbe_lun
operator|->
name|blocksize
argument_list|)
expr_stmt|;
name|beio
operator|->
name|io_offset
operator|=
operator|(
name|lbalen
operator|->
name|lba
operator|+
name|bptrlen
operator|->
name|len
operator|)
operator|*
name|cbe_lun
operator|->
name|blocksize
expr_stmt|;
name|beio
operator|->
name|io_len
operator|=
name|lbas
operator|*
name|cbe_lun
operator|->
name|blocksize
expr_stmt|;
name|bptrlen
operator|->
name|len
operator|+=
name|lbas
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|len_left
operator|=
name|beio
operator|->
name|io_len
init|;
name|len_left
operator|>
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|KASSERT
argument_list|(
name|i
operator|<
name|CTLBLK_MAX_SEGS
argument_list|,
operator|(
literal|"Too many segs (%d>= %d)"
operator|,
name|i
operator|,
name|CTLBLK_MAX_SEGS
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Setup the S/G entry for this chunk. 		 */
name|beio
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|len
operator|=
name|min
argument_list|(
name|CTLBLK_MAX_SEG
argument_list|,
name|len_left
argument_list|)
expr_stmt|;
name|beio
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|addr
operator|=
name|uma_zalloc
argument_list|(
name|be_lun
operator|->
name|lun_zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"segment %d addr %p len %zd\n"
argument_list|,
name|i
argument_list|,
name|beio
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|addr
argument_list|,
name|beio
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
comment|/* Set up second segment for compare operation. */
if|if
condition|(
name|lbalen
operator|->
name|flags
operator|&
name|CTL_LLF_COMPARE
condition|)
block|{
name|beio
operator|->
name|sg_segs
index|[
name|i
operator|+
name|CTLBLK_HALF_SEGS
index|]
operator|.
name|len
operator|=
name|beio
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
name|beio
operator|->
name|sg_segs
index|[
name|i
operator|+
name|CTLBLK_HALF_SEGS
index|]
operator|.
name|addr
operator|=
name|uma_zalloc
argument_list|(
name|be_lun
operator|->
name|lun_zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
name|beio
operator|->
name|num_segs
operator|++
expr_stmt|;
name|len_left
operator|-=
name|beio
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
block|}
if|if
condition|(
name|bptrlen
operator|->
name|len
operator|<
name|lbalen
operator|->
name|len
condition|)
name|beio
operator|->
name|beio_cont
operator|=
name|ctl_be_block_next
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|be_move_done
operator|=
name|ctl_be_block_move_done
expr_stmt|;
comment|/* For compare we have separate S/G lists for read and datamove. */
if|if
condition|(
name|lbalen
operator|->
name|flags
operator|&
name|CTL_LLF_COMPARE
condition|)
name|io
operator|->
name|scsiio
operator|.
name|kern_data_ptr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|beio
operator|->
name|sg_segs
index|[
name|CTLBLK_HALF_SEGS
index|]
expr_stmt|;
else|else
name|io
operator|->
name|scsiio
operator|.
name|kern_data_ptr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|beio
operator|->
name|sg_segs
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|kern_data_len
operator|=
name|beio
operator|->
name|io_len
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|kern_sg_entries
operator|=
name|beio
operator|->
name|num_segs
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
comment|/* 	 * For the read case, we need to read the data into our buffers and 	 * then we can send it back to the user.  For the write case, we 	 * need to get the data from the user first. 	 */
if|if
condition|(
name|beio
operator|->
name|bio_cmd
operator|==
name|BIO_READ
condition|)
block|{
name|SDT_PROBE0
argument_list|(
name|cbb
argument_list|, ,
name|read
argument_list|,
name|alloc_done
argument_list|)
expr_stmt|;
name|be_lun
operator|->
name|dispatch
argument_list|(
name|be_lun
argument_list|,
name|beio
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SDT_PROBE0
argument_list|(
name|cbb
argument_list|, ,
name|write
argument_list|,
name|alloc_done
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CTL_TIME_IO
name|getbinuptime
argument_list|(
operator|&
name|io
operator|->
name|io_hdr
operator|.
name|dma_start_bt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ctl_datamove
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_be_block_worker
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
init|=
operator|(
expr|struct
name|ctl_be_block_lun
operator|*
operator|)
name|context
decl_stmt|;
name|struct
name|ctl_be_lun
modifier|*
name|cbe_lun
init|=
operator|&
name|be_lun
operator|->
name|cbe_lun
decl_stmt|;
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|struct
name|ctl_be_block_io
modifier|*
name|beio
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"entered\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Fetch and process I/Os from all queues.  If we detect LUN 	 * CTL_LUN_FLAG_NO_MEDIA status here -- it is result of a race, 	 * so make response maximally opaque to not confuse initiator. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|be_lun
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
name|io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|STAILQ_FIRST
argument_list|(
operator|&
name|be_lun
operator|->
name|datamove_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|!=
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"datamove queue\n"
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE
argument_list|(
operator|&
name|be_lun
operator|->
name|datamove_queue
argument_list|,
operator|&
name|io
operator|->
name|io_hdr
argument_list|,
name|ctl_io_hdr
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|be_lun
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
name|beio
operator|=
operator|(
expr|struct
name|ctl_be_block_io
operator|*
operator|)
name|PRIV
argument_list|(
name|io
argument_list|)
operator|->
name|ptr
expr_stmt|;
if|if
condition|(
name|cbe_lun
operator|->
name|flags
operator|&
name|CTL_LUN_FLAG_NO_MEDIA
condition|)
block|{
name|ctl_set_busy
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
name|ctl_complete_beio
argument_list|(
name|beio
argument_list|)
expr_stmt|;
return|return;
block|}
name|be_lun
operator|->
name|dispatch
argument_list|(
name|be_lun
argument_list|,
name|beio
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|STAILQ_FIRST
argument_list|(
operator|&
name|be_lun
operator|->
name|config_write_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|!=
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"config write queue\n"
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE
argument_list|(
operator|&
name|be_lun
operator|->
name|config_write_queue
argument_list|,
operator|&
name|io
operator|->
name|io_hdr
argument_list|,
name|ctl_io_hdr
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|be_lun
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbe_lun
operator|->
name|flags
operator|&
name|CTL_LUN_FLAG_NO_MEDIA
condition|)
block|{
name|ctl_set_busy
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
name|ctl_config_write_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
return|return;
block|}
name|ctl_be_block_cw_dispatch
argument_list|(
name|be_lun
argument_list|,
name|io
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|STAILQ_FIRST
argument_list|(
operator|&
name|be_lun
operator|->
name|config_read_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|!=
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"config read queue\n"
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE
argument_list|(
operator|&
name|be_lun
operator|->
name|config_read_queue
argument_list|,
operator|&
name|io
operator|->
name|io_hdr
argument_list|,
name|ctl_io_hdr
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|be_lun
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbe_lun
operator|->
name|flags
operator|&
name|CTL_LUN_FLAG_NO_MEDIA
condition|)
block|{
name|ctl_set_busy
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
name|ctl_config_read_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
return|return;
block|}
name|ctl_be_block_cr_dispatch
argument_list|(
name|be_lun
argument_list|,
name|io
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|STAILQ_FIRST
argument_list|(
operator|&
name|be_lun
operator|->
name|input_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|!=
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"input queue\n"
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE
argument_list|(
operator|&
name|be_lun
operator|->
name|input_queue
argument_list|,
operator|&
name|io
operator|->
name|io_hdr
argument_list|,
name|ctl_io_hdr
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|be_lun
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbe_lun
operator|->
name|flags
operator|&
name|CTL_LUN_FLAG_NO_MEDIA
condition|)
block|{
name|ctl_set_busy
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
name|ctl_data_submit_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
return|return;
block|}
name|ctl_be_block_dispatch
argument_list|(
name|be_lun
argument_list|,
name|io
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * If we get here, there is no work left in the queues, so 		 * just break out and let the task queue go to sleep. 		 */
name|mtx_unlock
argument_list|(
operator|&
name|be_lun
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Entry point from CTL to the backend for I/O.  We queue everything to a  * work thread, so this just puts the I/O on a queue and wakes up the  * thread.  */
end_comment

begin_function
specifier|static
name|int
name|ctl_be_block_submit
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
decl_stmt|;
name|struct
name|ctl_be_lun
modifier|*
name|cbe_lun
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"entered\n"
argument_list|)
expr_stmt|;
name|cbe_lun
operator|=
name|CTL_BACKEND_LUN
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|be_lun
operator|=
operator|(
expr|struct
name|ctl_be_block_lun
operator|*
operator|)
name|cbe_lun
operator|->
name|be_lun
expr_stmt|;
comment|/* 	 * Make sure we only get SCSI I/O. 	 */
name|KASSERT
argument_list|(
name|io
operator|->
name|io_hdr
operator|.
name|io_type
operator|==
name|CTL_IO_SCSI
argument_list|,
operator|(
literal|"Non-SCSI I/O (type "
literal|"%#x) encountered"
operator|,
name|io
operator|->
name|io_hdr
operator|.
name|io_type
operator|)
argument_list|)
expr_stmt|;
name|PRIV
argument_list|(
name|io
argument_list|)
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|be_lun
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|be_lun
operator|->
name|input_queue
argument_list|,
operator|&
name|io
operator|->
name|io_hdr
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|be_lun
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|be_lun
operator|->
name|io_taskqueue
argument_list|,
operator|&
name|be_lun
operator|->
name|io_task
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_be_block_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|ctl_be_block_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|softc
operator|=
operator|&
name|backend_block_softc
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|CTL_LUN_REQ
case|:
block|{
name|struct
name|ctl_lun_req
modifier|*
name|lun_req
decl_stmt|;
name|lun_req
operator|=
operator|(
expr|struct
name|ctl_lun_req
operator|*
operator|)
name|addr
expr_stmt|;
switch|switch
condition|(
name|lun_req
operator|->
name|reqtype
condition|)
block|{
case|case
name|CTL_LUNREQ_CREATE
case|:
name|error
operator|=
name|ctl_be_block_create
argument_list|(
name|softc
argument_list|,
name|lun_req
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_LUNREQ_RM
case|:
name|error
operator|=
name|ctl_be_block_rm
argument_list|(
name|softc
argument_list|,
name|lun_req
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_LUNREQ_MODIFY
case|:
name|error
operator|=
name|ctl_be_block_modify
argument_list|(
name|softc
argument_list|,
name|lun_req
argument_list|)
expr_stmt|;
break|break;
default|default:
name|lun_req
operator|->
name|status
operator|=
name|CTL_LUN_ERROR
expr_stmt|;
name|snprintf
argument_list|(
name|lun_req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|lun_req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"invalid LUN request type %d"
argument_list|,
name|lun_req
operator|->
name|reqtype
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
default|default:
name|error
operator|=
name|ENOTTY
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_be_block_open_file
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|struct
name|ctl_lun_req
modifier|*
name|req
parameter_list|)
block|{
name|struct
name|ctl_be_lun
modifier|*
name|cbe_lun
decl_stmt|;
name|struct
name|ctl_be_block_filedata
modifier|*
name|file_data
decl_stmt|;
name|struct
name|ctl_lun_create_params
modifier|*
name|params
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|struct
name|vattr
name|vattr
decl_stmt|;
name|off_t
name|ps
decl_stmt|,
name|pss
decl_stmt|,
name|po
decl_stmt|,
name|pos
decl_stmt|,
name|us
decl_stmt|,
name|uss
decl_stmt|,
name|uo
decl_stmt|,
name|uos
decl_stmt|;
name|int
name|error
decl_stmt|;
name|cbe_lun
operator|=
operator|&
name|be_lun
operator|->
name|cbe_lun
expr_stmt|;
name|file_data
operator|=
operator|&
name|be_lun
operator|->
name|backend
operator|.
name|file
expr_stmt|;
name|params
operator|=
operator|&
name|be_lun
operator|->
name|params
expr_stmt|;
name|be_lun
operator|->
name|dev_type
operator|=
name|CTL_BE_BLOCK_FILE
expr_stmt|;
name|be_lun
operator|->
name|dispatch
operator|=
name|ctl_be_block_dispatch_file
expr_stmt|;
name|be_lun
operator|->
name|lun_flush
operator|=
name|ctl_be_block_flush_file
expr_stmt|;
name|be_lun
operator|->
name|get_lba_status
operator|=
name|ctl_be_block_gls_file
expr_stmt|;
name|be_lun
operator|->
name|getattr
operator|=
name|ctl_be_block_getattr_file
expr_stmt|;
name|be_lun
operator|->
name|unmap
operator|=
name|NULL
expr_stmt|;
name|cbe_lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_LUN_FLAG_UNMAP
expr_stmt|;
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|,
operator|&
name|vattr
argument_list|,
name|curthread
operator|->
name|td_ucred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"error calling VOP_GETATTR() for file %s"
argument_list|,
name|be_lun
operator|->
name|dev_path
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|file_data
operator|->
name|cred
operator|=
name|crhold
argument_list|(
name|curthread
operator|->
name|td_ucred
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|lun_size_bytes
operator|!=
literal|0
condition|)
name|be_lun
operator|->
name|size_bytes
operator|=
name|params
operator|->
name|lun_size_bytes
expr_stmt|;
else|else
name|be_lun
operator|->
name|size_bytes
operator|=
name|vattr
operator|.
name|va_size
expr_stmt|;
comment|/* 	 * For files we can use any logical block size.  Prefer 512 bytes 	 * for compatibility reasons.  If file's vattr.va_blocksize 	 * (preferred I/O block size) is bigger and multiple to chosen 	 * logical block size -- report it as physical block size. 	 */
if|if
condition|(
name|params
operator|->
name|blocksize_bytes
operator|!=
literal|0
condition|)
name|cbe_lun
operator|->
name|blocksize
operator|=
name|params
operator|->
name|blocksize_bytes
expr_stmt|;
elseif|else
if|if
condition|(
name|cbe_lun
operator|->
name|lun_type
operator|==
name|T_CDROM
condition|)
name|cbe_lun
operator|->
name|blocksize
operator|=
literal|2048
expr_stmt|;
else|else
name|cbe_lun
operator|->
name|blocksize
operator|=
literal|512
expr_stmt|;
name|be_lun
operator|->
name|size_blocks
operator|=
name|be_lun
operator|->
name|size_bytes
operator|/
name|cbe_lun
operator|->
name|blocksize
expr_stmt|;
name|cbe_lun
operator|->
name|maxlba
operator|=
operator|(
name|be_lun
operator|->
name|size_blocks
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
operator|(
name|be_lun
operator|->
name|size_blocks
operator|-
literal|1
operator|)
expr_stmt|;
name|us
operator|=
name|ps
operator|=
name|vattr
operator|.
name|va_blocksize
expr_stmt|;
name|uo
operator|=
name|po
operator|=
literal|0
expr_stmt|;
name|value
operator|=
name|ctl_get_opt
argument_list|(
operator|&
name|cbe_lun
operator|->
name|options
argument_list|,
literal|"pblocksize"
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
name|ctl_expand_number
argument_list|(
name|value
argument_list|,
operator|&
name|ps
argument_list|)
expr_stmt|;
name|value
operator|=
name|ctl_get_opt
argument_list|(
operator|&
name|cbe_lun
operator|->
name|options
argument_list|,
literal|"pblockoffset"
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
name|ctl_expand_number
argument_list|(
name|value
argument_list|,
operator|&
name|po
argument_list|)
expr_stmt|;
name|pss
operator|=
name|ps
operator|/
name|cbe_lun
operator|->
name|blocksize
expr_stmt|;
name|pos
operator|=
name|po
operator|/
name|cbe_lun
operator|->
name|blocksize
expr_stmt|;
if|if
condition|(
operator|(
name|pss
operator|>
literal|0
operator|)
operator|&&
operator|(
name|pss
operator|*
name|cbe_lun
operator|->
name|blocksize
operator|==
name|ps
operator|)
operator|&&
operator|(
name|pss
operator|>=
name|pos
operator|)
operator|&&
operator|(
operator|(
name|pss
operator|&
operator|(
name|pss
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|pos
operator|*
name|cbe_lun
operator|->
name|blocksize
operator|==
name|po
operator|)
condition|)
block|{
name|cbe_lun
operator|->
name|pblockexp
operator|=
name|fls
argument_list|(
name|pss
argument_list|)
operator|-
literal|1
expr_stmt|;
name|cbe_lun
operator|->
name|pblockoff
operator|=
operator|(
name|pss
operator|-
name|pos
operator|)
operator|%
name|pss
expr_stmt|;
block|}
name|value
operator|=
name|ctl_get_opt
argument_list|(
operator|&
name|cbe_lun
operator|->
name|options
argument_list|,
literal|"ublocksize"
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
name|ctl_expand_number
argument_list|(
name|value
argument_list|,
operator|&
name|us
argument_list|)
expr_stmt|;
name|value
operator|=
name|ctl_get_opt
argument_list|(
operator|&
name|cbe_lun
operator|->
name|options
argument_list|,
literal|"ublockoffset"
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
name|ctl_expand_number
argument_list|(
name|value
argument_list|,
operator|&
name|uo
argument_list|)
expr_stmt|;
name|uss
operator|=
name|us
operator|/
name|cbe_lun
operator|->
name|blocksize
expr_stmt|;
name|uos
operator|=
name|uo
operator|/
name|cbe_lun
operator|->
name|blocksize
expr_stmt|;
if|if
condition|(
operator|(
name|uss
operator|>
literal|0
operator|)
operator|&&
operator|(
name|uss
operator|*
name|cbe_lun
operator|->
name|blocksize
operator|==
name|us
operator|)
operator|&&
operator|(
name|uss
operator|>=
name|uos
operator|)
operator|&&
operator|(
operator|(
name|uss
operator|&
operator|(
name|uss
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|uos
operator|*
name|cbe_lun
operator|->
name|blocksize
operator|==
name|uo
operator|)
condition|)
block|{
name|cbe_lun
operator|->
name|ublockexp
operator|=
name|fls
argument_list|(
name|uss
argument_list|)
operator|-
literal|1
expr_stmt|;
name|cbe_lun
operator|->
name|ublockoff
operator|=
operator|(
name|uss
operator|-
name|uos
operator|)
operator|%
name|uss
expr_stmt|;
block|}
comment|/* 	 * Sanity check.  The media size has to be at least one 	 * sector long. 	 */
if|if
condition|(
name|be_lun
operator|->
name|size_bytes
operator|<
name|cbe_lun
operator|->
name|blocksize
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"file %s size %ju< block size %u"
argument_list|,
name|be_lun
operator|->
name|dev_path
argument_list|,
operator|(
name|uintmax_t
operator|)
name|be_lun
operator|->
name|size_bytes
argument_list|,
name|cbe_lun
operator|->
name|blocksize
argument_list|)
expr_stmt|;
block|}
name|cbe_lun
operator|->
name|opttxferlen
operator|=
name|CTLBLK_MAX_IO_SIZE
operator|/
name|cbe_lun
operator|->
name|blocksize
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_be_block_open_dev
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|struct
name|ctl_lun_req
modifier|*
name|req
parameter_list|)
block|{
name|struct
name|ctl_be_lun
modifier|*
name|cbe_lun
init|=
operator|&
name|be_lun
operator|->
name|cbe_lun
decl_stmt|;
name|struct
name|ctl_lun_create_params
modifier|*
name|params
decl_stmt|;
name|struct
name|cdevsw
modifier|*
name|csw
decl_stmt|;
name|struct
name|cdev
modifier|*
name|dev
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|int
name|error
decl_stmt|,
name|atomic
decl_stmt|,
name|maxio
decl_stmt|,
name|ref
decl_stmt|,
name|unmap
decl_stmt|,
name|tmp
decl_stmt|;
name|off_t
name|ps
decl_stmt|,
name|pss
decl_stmt|,
name|po
decl_stmt|,
name|pos
decl_stmt|,
name|us
decl_stmt|,
name|uss
decl_stmt|,
name|uo
decl_stmt|,
name|uos
decl_stmt|,
name|otmp
decl_stmt|;
name|params
operator|=
operator|&
name|be_lun
operator|->
name|params
expr_stmt|;
name|be_lun
operator|->
name|dev_type
operator|=
name|CTL_BE_BLOCK_DEV
expr_stmt|;
name|csw
operator|=
name|devvn_refthread
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|,
operator|&
name|dev
argument_list|,
operator|&
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|csw
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|csw
operator|->
name|d_name
argument_list|,
literal|"zvol"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|be_lun
operator|->
name|dispatch
operator|=
name|ctl_be_block_dispatch_zvol
expr_stmt|;
name|be_lun
operator|->
name|get_lba_status
operator|=
name|ctl_be_block_gls_zvol
expr_stmt|;
name|atomic
operator|=
name|maxio
operator|=
name|CTLBLK_MAX_IO_SIZE
expr_stmt|;
block|}
else|else
block|{
name|be_lun
operator|->
name|dispatch
operator|=
name|ctl_be_block_dispatch_dev
expr_stmt|;
name|be_lun
operator|->
name|get_lba_status
operator|=
name|NULL
expr_stmt|;
name|atomic
operator|=
literal|0
expr_stmt|;
name|maxio
operator|=
name|dev
operator|->
name|si_iosize_max
expr_stmt|;
if|if
condition|(
name|maxio
operator|<=
literal|0
condition|)
name|maxio
operator|=
name|DFLTPHYS
expr_stmt|;
if|if
condition|(
name|maxio
operator|>
name|CTLBLK_MAX_IO_SIZE
condition|)
name|maxio
operator|=
name|CTLBLK_MAX_IO_SIZE
expr_stmt|;
block|}
name|be_lun
operator|->
name|lun_flush
operator|=
name|ctl_be_block_flush_dev
expr_stmt|;
name|be_lun
operator|->
name|getattr
operator|=
name|ctl_be_block_getattr_dev
expr_stmt|;
name|be_lun
operator|->
name|unmap
operator|=
name|ctl_be_block_unmap_dev
expr_stmt|;
if|if
condition|(
operator|!
name|csw
operator|->
name|d_ioctl
condition|)
block|{
name|dev_relthread
argument_list|(
name|dev
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"no d_ioctl for device %s!"
argument_list|,
name|be_lun
operator|->
name|dev_path
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
name|error
operator|=
name|csw
operator|->
name|d_ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGSECTORSIZE
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|tmp
argument_list|,
name|FREAD
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dev_relthread
argument_list|(
name|dev
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"error %d returned for DIOCGSECTORSIZE ioctl "
literal|"on %s!"
argument_list|,
name|error
argument_list|,
name|be_lun
operator|->
name|dev_path
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * If the user has asked for a blocksize that is greater than the 	 * backing device's blocksize, we can do it only if the blocksize 	 * the user is asking for is an even multiple of the underlying  	 * device's blocksize. 	 */
if|if
condition|(
operator|(
name|params
operator|->
name|blocksize_bytes
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|params
operator|->
name|blocksize_bytes
operator|>=
name|tmp
operator|)
condition|)
block|{
if|if
condition|(
name|params
operator|->
name|blocksize_bytes
operator|%
name|tmp
operator|==
literal|0
condition|)
block|{
name|cbe_lun
operator|->
name|blocksize
operator|=
name|params
operator|->
name|blocksize_bytes
expr_stmt|;
block|}
else|else
block|{
name|dev_relthread
argument_list|(
name|dev
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"requested blocksize %u is not an even "
literal|"multiple of backing device blocksize %u"
argument_list|,
name|params
operator|->
name|blocksize_bytes
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|params
operator|->
name|blocksize_bytes
operator|!=
literal|0
condition|)
block|{
name|dev_relthread
argument_list|(
name|dev
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"requested blocksize %u< backing device "
literal|"blocksize %u"
argument_list|,
name|params
operator|->
name|blocksize_bytes
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|cbe_lun
operator|->
name|lun_type
operator|==
name|T_CDROM
condition|)
name|cbe_lun
operator|->
name|blocksize
operator|=
name|MAX
argument_list|(
name|tmp
argument_list|,
literal|2048
argument_list|)
expr_stmt|;
else|else
name|cbe_lun
operator|->
name|blocksize
operator|=
name|tmp
expr_stmt|;
name|error
operator|=
name|csw
operator|->
name|d_ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGMEDIASIZE
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|otmp
argument_list|,
name|FREAD
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dev_relthread
argument_list|(
name|dev
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"error %d returned for DIOCGMEDIASIZE "
literal|" ioctl on %s!"
argument_list|,
name|error
argument_list|,
name|be_lun
operator|->
name|dev_path
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|params
operator|->
name|lun_size_bytes
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|params
operator|->
name|lun_size_bytes
operator|>
name|otmp
condition|)
block|{
name|dev_relthread
argument_list|(
name|dev
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"requested LUN size %ju> backing device "
literal|"size %ju"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|params
operator|->
name|lun_size_bytes
argument_list|,
operator|(
name|uintmax_t
operator|)
name|otmp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|be_lun
operator|->
name|size_bytes
operator|=
name|params
operator|->
name|lun_size_bytes
expr_stmt|;
block|}
else|else
name|be_lun
operator|->
name|size_bytes
operator|=
name|otmp
expr_stmt|;
name|be_lun
operator|->
name|size_blocks
operator|=
name|be_lun
operator|->
name|size_bytes
operator|/
name|cbe_lun
operator|->
name|blocksize
expr_stmt|;
name|cbe_lun
operator|->
name|maxlba
operator|=
operator|(
name|be_lun
operator|->
name|size_blocks
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
operator|(
name|be_lun
operator|->
name|size_blocks
operator|-
literal|1
operator|)
expr_stmt|;
name|error
operator|=
name|csw
operator|->
name|d_ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGSTRIPESIZE
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ps
argument_list|,
name|FREAD
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|ps
operator|=
name|po
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|error
operator|=
name|csw
operator|->
name|d_ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGSTRIPEOFFSET
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|po
argument_list|,
name|FREAD
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|po
operator|=
literal|0
expr_stmt|;
block|}
name|us
operator|=
name|ps
expr_stmt|;
name|uo
operator|=
name|po
expr_stmt|;
name|value
operator|=
name|ctl_get_opt
argument_list|(
operator|&
name|cbe_lun
operator|->
name|options
argument_list|,
literal|"pblocksize"
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
name|ctl_expand_number
argument_list|(
name|value
argument_list|,
operator|&
name|ps
argument_list|)
expr_stmt|;
name|value
operator|=
name|ctl_get_opt
argument_list|(
operator|&
name|cbe_lun
operator|->
name|options
argument_list|,
literal|"pblockoffset"
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
name|ctl_expand_number
argument_list|(
name|value
argument_list|,
operator|&
name|po
argument_list|)
expr_stmt|;
name|pss
operator|=
name|ps
operator|/
name|cbe_lun
operator|->
name|blocksize
expr_stmt|;
name|pos
operator|=
name|po
operator|/
name|cbe_lun
operator|->
name|blocksize
expr_stmt|;
if|if
condition|(
operator|(
name|pss
operator|>
literal|0
operator|)
operator|&&
operator|(
name|pss
operator|*
name|cbe_lun
operator|->
name|blocksize
operator|==
name|ps
operator|)
operator|&&
operator|(
name|pss
operator|>=
name|pos
operator|)
operator|&&
operator|(
operator|(
name|pss
operator|&
operator|(
name|pss
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|pos
operator|*
name|cbe_lun
operator|->
name|blocksize
operator|==
name|po
operator|)
condition|)
block|{
name|cbe_lun
operator|->
name|pblockexp
operator|=
name|fls
argument_list|(
name|pss
argument_list|)
operator|-
literal|1
expr_stmt|;
name|cbe_lun
operator|->
name|pblockoff
operator|=
operator|(
name|pss
operator|-
name|pos
operator|)
operator|%
name|pss
expr_stmt|;
block|}
name|value
operator|=
name|ctl_get_opt
argument_list|(
operator|&
name|cbe_lun
operator|->
name|options
argument_list|,
literal|"ublocksize"
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
name|ctl_expand_number
argument_list|(
name|value
argument_list|,
operator|&
name|us
argument_list|)
expr_stmt|;
name|value
operator|=
name|ctl_get_opt
argument_list|(
operator|&
name|cbe_lun
operator|->
name|options
argument_list|,
literal|"ublockoffset"
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
name|ctl_expand_number
argument_list|(
name|value
argument_list|,
operator|&
name|uo
argument_list|)
expr_stmt|;
name|uss
operator|=
name|us
operator|/
name|cbe_lun
operator|->
name|blocksize
expr_stmt|;
name|uos
operator|=
name|uo
operator|/
name|cbe_lun
operator|->
name|blocksize
expr_stmt|;
if|if
condition|(
operator|(
name|uss
operator|>
literal|0
operator|)
operator|&&
operator|(
name|uss
operator|*
name|cbe_lun
operator|->
name|blocksize
operator|==
name|us
operator|)
operator|&&
operator|(
name|uss
operator|>=
name|uos
operator|)
operator|&&
operator|(
operator|(
name|uss
operator|&
operator|(
name|uss
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|uos
operator|*
name|cbe_lun
operator|->
name|blocksize
operator|==
name|uo
operator|)
condition|)
block|{
name|cbe_lun
operator|->
name|ublockexp
operator|=
name|fls
argument_list|(
name|uss
argument_list|)
operator|-
literal|1
expr_stmt|;
name|cbe_lun
operator|->
name|ublockoff
operator|=
operator|(
name|uss
operator|-
name|uos
operator|)
operator|%
name|uss
expr_stmt|;
block|}
name|cbe_lun
operator|->
name|atomicblock
operator|=
name|atomic
operator|/
name|cbe_lun
operator|->
name|blocksize
expr_stmt|;
name|cbe_lun
operator|->
name|opttxferlen
operator|=
name|maxio
operator|/
name|cbe_lun
operator|->
name|blocksize
expr_stmt|;
if|if
condition|(
name|be_lun
operator|->
name|dispatch
operator|==
name|ctl_be_block_dispatch_zvol
condition|)
block|{
name|unmap
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|struct
name|diocgattr_arg
name|arg
decl_stmt|;
name|strlcpy
argument_list|(
name|arg
operator|.
name|name
argument_list|,
literal|"GEOM::candelete"
argument_list|,
sizeof|sizeof
argument_list|(
name|arg
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|arg
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
name|arg
operator|.
name|value
operator|.
name|i
argument_list|)
expr_stmt|;
name|error
operator|=
name|csw
operator|->
name|d_ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGATTR
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|arg
argument_list|,
name|FREAD
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|unmap
operator|=
operator|(
name|error
operator|==
literal|0
operator|)
condition|?
name|arg
operator|.
name|value
operator|.
name|i
else|:
literal|0
expr_stmt|;
block|}
name|value
operator|=
name|ctl_get_opt
argument_list|(
operator|&
name|cbe_lun
operator|->
name|options
argument_list|,
literal|"unmap"
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
name|unmap
operator|=
operator|(
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"on"
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|unmap
condition|)
name|cbe_lun
operator|->
name|flags
operator||=
name|CTL_LUN_FLAG_UNMAP
expr_stmt|;
else|else
name|cbe_lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_LUN_FLAG_UNMAP
expr_stmt|;
name|dev_relthread
argument_list|(
name|dev
argument_list|,
name|ref
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_be_block_close
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|)
block|{
name|struct
name|ctl_be_lun
modifier|*
name|cbe_lun
init|=
operator|&
name|be_lun
operator|->
name|cbe_lun
decl_stmt|;
name|int
name|flags
decl_stmt|;
if|if
condition|(
name|be_lun
operator|->
name|vn
condition|)
block|{
name|flags
operator|=
name|FREAD
expr_stmt|;
if|if
condition|(
operator|(
name|cbe_lun
operator|->
name|flags
operator|&
name|CTL_LUN_FLAG_READONLY
operator|)
operator|==
literal|0
condition|)
name|flags
operator||=
name|FWRITE
expr_stmt|;
operator|(
name|void
operator|)
name|vn_close
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|,
name|flags
argument_list|,
name|NOCRED
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|be_lun
operator|->
name|vn
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|be_lun
operator|->
name|dev_type
condition|)
block|{
case|case
name|CTL_BE_BLOCK_DEV
case|:
break|break;
case|case
name|CTL_BE_BLOCK_FILE
case|:
if|if
condition|(
name|be_lun
operator|->
name|backend
operator|.
name|file
operator|.
name|cred
operator|!=
name|NULL
condition|)
block|{
name|crfree
argument_list|(
name|be_lun
operator|->
name|backend
operator|.
name|file
operator|.
name|cred
argument_list|)
expr_stmt|;
name|be_lun
operator|->
name|backend
operator|.
name|file
operator|.
name|cred
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
case|case
name|CTL_BE_BLOCK_NONE
case|:
break|break;
default|default:
name|panic
argument_list|(
literal|"Unexpected backend type %d"
argument_list|,
name|be_lun
operator|->
name|dev_type
argument_list|)
expr_stmt|;
break|break;
block|}
name|be_lun
operator|->
name|dev_type
operator|=
name|CTL_BE_BLOCK_NONE
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_be_block_open
parameter_list|(
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
parameter_list|,
name|struct
name|ctl_lun_req
modifier|*
name|req
parameter_list|)
block|{
name|struct
name|ctl_be_lun
modifier|*
name|cbe_lun
init|=
operator|&
name|be_lun
operator|->
name|cbe_lun
decl_stmt|;
name|struct
name|nameidata
name|nd
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|int
name|error
decl_stmt|,
name|flags
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rootvnode
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"Root filesystem is not mounted"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|pwd_ensure_dirs
argument_list|()
expr_stmt|;
name|value
operator|=
name|ctl_get_opt
argument_list|(
operator|&
name|cbe_lun
operator|->
name|options
argument_list|,
literal|"file"
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"no file argument specified"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|free
argument_list|(
name|be_lun
operator|->
name|dev_path
argument_list|,
name|M_CTLBLK
argument_list|)
expr_stmt|;
name|be_lun
operator|->
name|dev_path
operator|=
name|strdup
argument_list|(
name|value
argument_list|,
name|M_CTLBLK
argument_list|)
expr_stmt|;
name|flags
operator|=
name|FREAD
expr_stmt|;
name|value
operator|=
name|ctl_get_opt
argument_list|(
operator|&
name|cbe_lun
operator|->
name|options
argument_list|,
literal|"readonly"
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"on"
argument_list|)
operator|!=
literal|0
condition|)
name|flags
operator||=
name|FWRITE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cbe_lun
operator|->
name|lun_type
operator|==
name|T_DIRECT
condition|)
name|flags
operator||=
name|FWRITE
expr_stmt|;
name|again
label|:
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|FOLLOW
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|be_lun
operator|->
name|dev_path
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|error
operator|=
name|vn_open
argument_list|(
operator|&
name|nd
argument_list|,
operator|&
name|flags
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|==
name|EROFS
operator|||
name|error
operator|==
name|EACCES
operator|)
operator|&&
operator|(
name|flags
operator|&
name|FWRITE
operator|)
condition|)
block|{
name|flags
operator|&=
operator|~
name|FWRITE
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|error
condition|)
block|{
comment|/* 		 * This is the only reasonable guess we can make as far as 		 * path if the user doesn't give us a fully qualified path. 		 * If they want to specify a file, they need to specify the 		 * full path. 		 */
if|if
condition|(
name|be_lun
operator|->
name|dev_path
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
block|{
name|char
modifier|*
name|dev_name
decl_stmt|;
name|asprintf
argument_list|(
operator|&
name|dev_name
argument_list|,
name|M_CTLBLK
argument_list|,
literal|"/dev/%s"
argument_list|,
name|be_lun
operator|->
name|dev_path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|be_lun
operator|->
name|dev_path
argument_list|,
name|M_CTLBLK
argument_list|)
expr_stmt|;
name|be_lun
operator|->
name|dev_path
operator|=
name|dev_name
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"error opening %s: %d"
argument_list|,
name|be_lun
operator|->
name|dev_path
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|flags
operator|&
name|FWRITE
condition|)
name|cbe_lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_LUN_FLAG_READONLY
expr_stmt|;
else|else
name|cbe_lun
operator|->
name|flags
operator||=
name|CTL_LUN_FLAG_READONLY
expr_stmt|;
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
name|be_lun
operator|->
name|vn
operator|=
name|nd
operator|.
name|ni_vp
expr_stmt|;
comment|/* We only support disks and files. */
if|if
condition|(
name|vn_isdisk
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|,
operator|&
name|error
argument_list|)
condition|)
block|{
name|error
operator|=
name|ctl_be_block_open_dev
argument_list|(
name|be_lun
argument_list|,
name|req
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|be_lun
operator|->
name|vn
operator|->
name|v_type
operator|==
name|VREG
condition|)
block|{
name|error
operator|=
name|ctl_be_block_open_file
argument_list|(
name|be_lun
argument_list|,
name|req
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"%s is not a disk or plain file"
argument_list|,
name|be_lun
operator|->
name|dev_path
argument_list|)
expr_stmt|;
block|}
name|VOP_UNLOCK
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|ctl_be_block_close
argument_list|(
name|be_lun
argument_list|)
expr_stmt|;
name|cbe_lun
operator|->
name|serseq
operator|=
name|CTL_LUN_SERSEQ_OFF
expr_stmt|;
if|if
condition|(
name|be_lun
operator|->
name|dispatch
operator|!=
name|ctl_be_block_dispatch_dev
condition|)
name|cbe_lun
operator|->
name|serseq
operator|=
name|CTL_LUN_SERSEQ_READ
expr_stmt|;
name|value
operator|=
name|ctl_get_opt
argument_list|(
operator|&
name|cbe_lun
operator|->
name|options
argument_list|,
literal|"serseq"
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"on"
argument_list|)
operator|==
literal|0
condition|)
name|cbe_lun
operator|->
name|serseq
operator|=
name|CTL_LUN_SERSEQ_ON
expr_stmt|;
elseif|else
if|if
condition|(
name|value
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"read"
argument_list|)
operator|==
literal|0
condition|)
name|cbe_lun
operator|->
name|serseq
operator|=
name|CTL_LUN_SERSEQ_READ
expr_stmt|;
elseif|else
if|if
condition|(
name|value
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
condition|)
name|cbe_lun
operator|->
name|serseq
operator|=
name|CTL_LUN_SERSEQ_OFF
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_be_block_create
parameter_list|(
name|struct
name|ctl_be_block_softc
modifier|*
name|softc
parameter_list|,
name|struct
name|ctl_lun_req
modifier|*
name|req
parameter_list|)
block|{
name|struct
name|ctl_be_lun
modifier|*
name|cbe_lun
decl_stmt|;
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
decl_stmt|;
name|struct
name|ctl_lun_create_params
modifier|*
name|params
decl_stmt|;
name|char
name|num_thread_str
index|[
literal|16
index|]
decl_stmt|;
name|char
name|tmpstr
index|[
literal|32
index|]
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|int
name|retval
decl_stmt|,
name|num_threads
decl_stmt|;
name|int
name|tmp_num_threads
decl_stmt|;
name|params
operator|=
operator|&
name|req
operator|->
name|reqdata
operator|.
name|create
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|status
operator|=
name|CTL_LUN_OK
expr_stmt|;
name|be_lun
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|be_lun
argument_list|)
argument_list|,
name|M_CTLBLK
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|cbe_lun
operator|=
operator|&
name|be_lun
operator|->
name|cbe_lun
expr_stmt|;
name|cbe_lun
operator|->
name|be_lun
operator|=
name|be_lun
expr_stmt|;
name|be_lun
operator|->
name|params
operator|=
name|req
operator|->
name|reqdata
operator|.
name|create
expr_stmt|;
name|be_lun
operator|->
name|softc
operator|=
name|softc
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|be_lun
operator|->
name|input_queue
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|be_lun
operator|->
name|config_read_queue
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|be_lun
operator|->
name|config_write_queue
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|be_lun
operator|->
name|datamove_queue
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|be_lun
operator|->
name|lunname
argument_list|,
literal|"cblk%d"
argument_list|,
name|softc
operator|->
name|num_luns
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|be_lun
operator|->
name|io_lock
argument_list|,
literal|"cblk io lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|be_lun
operator|->
name|queue_lock
argument_list|,
literal|"cblk queue lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|ctl_init_opts
argument_list|(
operator|&
name|cbe_lun
operator|->
name|options
argument_list|,
name|req
operator|->
name|num_be_args
argument_list|,
name|req
operator|->
name|kern_be_args
argument_list|)
expr_stmt|;
name|be_lun
operator|->
name|lun_zone
operator|=
name|uma_zcreate
argument_list|(
name|be_lun
operator|->
name|lunname
argument_list|,
name|CTLBLK_MAX_SEG
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/*align*/
literal|0
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|be_lun
operator|->
name|lun_zone
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"error allocating UMA zone"
argument_list|)
expr_stmt|;
goto|goto
name|bailout_error
goto|;
block|}
if|if
condition|(
name|params
operator|->
name|flags
operator|&
name|CTL_LUN_FLAG_DEV_TYPE
condition|)
name|cbe_lun
operator|->
name|lun_type
operator|=
name|params
operator|->
name|device_type
expr_stmt|;
else|else
name|cbe_lun
operator|->
name|lun_type
operator|=
name|T_DIRECT
expr_stmt|;
name|be_lun
operator|->
name|flags
operator|=
name|CTL_BE_BLOCK_LUN_UNCONFIGURED
expr_stmt|;
name|cbe_lun
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|value
operator|=
name|ctl_get_opt
argument_list|(
operator|&
name|cbe_lun
operator|->
name|options
argument_list|,
literal|"ha_role"
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"primary"
argument_list|)
operator|==
literal|0
condition|)
name|cbe_lun
operator|->
name|flags
operator||=
name|CTL_LUN_FLAG_PRIMARY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|control_softc
operator|->
name|flags
operator|&
name|CTL_FLAG_ACTIVE_SHELF
condition|)
name|cbe_lun
operator|->
name|flags
operator||=
name|CTL_LUN_FLAG_PRIMARY
expr_stmt|;
if|if
condition|(
name|cbe_lun
operator|->
name|lun_type
operator|==
name|T_DIRECT
operator|||
name|cbe_lun
operator|->
name|lun_type
operator|==
name|T_CDROM
condition|)
block|{
name|be_lun
operator|->
name|size_bytes
operator|=
name|params
operator|->
name|lun_size_bytes
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|blocksize_bytes
operator|!=
literal|0
condition|)
name|cbe_lun
operator|->
name|blocksize
operator|=
name|params
operator|->
name|blocksize_bytes
expr_stmt|;
elseif|else
if|if
condition|(
name|cbe_lun
operator|->
name|lun_type
operator|==
name|T_CDROM
condition|)
name|cbe_lun
operator|->
name|blocksize
operator|=
literal|2048
expr_stmt|;
else|else
name|cbe_lun
operator|->
name|blocksize
operator|=
literal|512
expr_stmt|;
name|be_lun
operator|->
name|size_blocks
operator|=
name|be_lun
operator|->
name|size_bytes
operator|/
name|cbe_lun
operator|->
name|blocksize
expr_stmt|;
name|cbe_lun
operator|->
name|maxlba
operator|=
operator|(
name|be_lun
operator|->
name|size_blocks
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
operator|(
name|be_lun
operator|->
name|size_blocks
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|cbe_lun
operator|->
name|flags
operator|&
name|CTL_LUN_FLAG_PRIMARY
operator|)
operator|||
name|control_softc
operator|->
name|ha_mode
operator|==
name|CTL_HA_MODE_SER_ONLY
condition|)
block|{
name|retval
operator|=
name|ctl_be_block_open
argument_list|(
name|be_lun
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|retval
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|status
operator|=
name|CTL_LUN_WARNING
expr_stmt|;
block|}
block|}
name|num_threads
operator|=
name|cbb_num_threads
expr_stmt|;
block|}
else|else
block|{
name|num_threads
operator|=
literal|1
expr_stmt|;
block|}
name|value
operator|=
name|ctl_get_opt
argument_list|(
operator|&
name|cbe_lun
operator|->
name|options
argument_list|,
literal|"num_threads"
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
block|{
name|tmp_num_threads
operator|=
name|strtol
argument_list|(
name|value
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * We don't let the user specify less than one 		 * thread, but hope he's clueful enough not to 		 * specify 1000 threads. 		 */
if|if
condition|(
name|tmp_num_threads
operator|<
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"invalid number of threads %s"
argument_list|,
name|num_thread_str
argument_list|)
expr_stmt|;
goto|goto
name|bailout_error
goto|;
block|}
name|num_threads
operator|=
name|tmp_num_threads
expr_stmt|;
block|}
if|if
condition|(
name|be_lun
operator|->
name|vn
operator|==
name|NULL
condition|)
name|cbe_lun
operator|->
name|flags
operator||=
name|CTL_LUN_FLAG_NO_MEDIA
expr_stmt|;
comment|/* Tell the user the blocksize we ended up using */
name|params
operator|->
name|lun_size_bytes
operator|=
name|be_lun
operator|->
name|size_bytes
expr_stmt|;
name|params
operator|->
name|blocksize_bytes
operator|=
name|cbe_lun
operator|->
name|blocksize
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|flags
operator|&
name|CTL_LUN_FLAG_ID_REQ
condition|)
block|{
name|cbe_lun
operator|->
name|req_lun_id
operator|=
name|params
operator|->
name|req_lun_id
expr_stmt|;
name|cbe_lun
operator|->
name|flags
operator||=
name|CTL_LUN_FLAG_ID_REQ
expr_stmt|;
block|}
else|else
name|cbe_lun
operator|->
name|req_lun_id
operator|=
literal|0
expr_stmt|;
name|cbe_lun
operator|->
name|lun_shutdown
operator|=
name|ctl_be_block_lun_shutdown
expr_stmt|;
name|cbe_lun
operator|->
name|lun_config_status
operator|=
name|ctl_be_block_lun_config_status
expr_stmt|;
name|cbe_lun
operator|->
name|be
operator|=
operator|&
name|ctl_be_block_driver
expr_stmt|;
if|if
condition|(
operator|(
name|params
operator|->
name|flags
operator|&
name|CTL_LUN_FLAG_SERIAL_NUM
operator|)
operator|==
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|tmpstr
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
literal|"MYSERIAL%4d"
argument_list|,
name|softc
operator|->
name|num_luns
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cbe_lun
operator|->
name|serial_num
argument_list|,
name|tmpstr
argument_list|,
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
name|cbe_lun
operator|->
name|serial_num
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Tell the user what we used for a serial number */
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|params
operator|->
name|serial_num
argument_list|,
name|tmpstr
argument_list|,
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
name|params
operator|->
name|serial_num
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cbe_lun
operator|->
name|serial_num
argument_list|,
name|params
operator|->
name|serial_num
argument_list|,
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
name|cbe_lun
operator|->
name|serial_num
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|params
operator|->
name|serial_num
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|params
operator|->
name|flags
operator|&
name|CTL_LUN_FLAG_DEVID
operator|)
operator|==
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|tmpstr
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
literal|"MYDEVID%4d"
argument_list|,
name|softc
operator|->
name|num_luns
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cbe_lun
operator|->
name|device_id
argument_list|,
name|tmpstr
argument_list|,
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
name|cbe_lun
operator|->
name|device_id
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Tell the user what we used for a device ID */
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|params
operator|->
name|device_id
argument_list|,
name|tmpstr
argument_list|,
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
name|params
operator|->
name|device_id
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cbe_lun
operator|->
name|device_id
argument_list|,
name|params
operator|->
name|device_id
argument_list|,
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
name|cbe_lun
operator|->
name|device_id
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|params
operator|->
name|device_id
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|TASK_INIT
argument_list|(
operator|&
name|be_lun
operator|->
name|io_task
argument_list|,
comment|/*priority*/
literal|0
argument_list|,
name|ctl_be_block_worker
argument_list|,
name|be_lun
argument_list|)
expr_stmt|;
name|be_lun
operator|->
name|io_taskqueue
operator|=
name|taskqueue_create
argument_list|(
name|be_lun
operator|->
name|lunname
argument_list|,
name|M_WAITOK
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
comment|/*context*/
operator|&
name|be_lun
operator|->
name|io_taskqueue
argument_list|)
expr_stmt|;
if|if
condition|(
name|be_lun
operator|->
name|io_taskqueue
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"unable to create taskqueue"
argument_list|)
expr_stmt|;
goto|goto
name|bailout_error
goto|;
block|}
comment|/* 	 * Note that we start the same number of threads by default for 	 * both the file case and the block device case.  For the file 	 * case, we need multiple threads to allow concurrency, because the 	 * vnode interface is designed to be a blocking interface.  For the 	 * block device case, ZFS zvols at least will block the caller's 	 * context in many instances, and so we need multiple threads to 	 * overcome that problem.  Other block devices don't need as many 	 * threads, but they shouldn't cause too many problems. 	 * 	 * If the user wants to just have a single thread for a block 	 * device, he can specify that when the LUN is created, or change 	 * the tunable/sysctl to alter the default number of threads. 	 */
name|retval
operator|=
name|taskqueue_start_threads
argument_list|(
operator|&
name|be_lun
operator|->
name|io_taskqueue
argument_list|,
comment|/*num threads*/
name|num_threads
argument_list|,
comment|/*priority*/
name|PWAIT
argument_list|,
comment|/*thread name*/
literal|"%s taskq"
argument_list|,
name|be_lun
operator|->
name|lunname
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
goto|goto
name|bailout_error
goto|;
name|be_lun
operator|->
name|num_threads
operator|=
name|num_threads
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|softc
operator|->
name|num_luns
operator|++
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|softc
operator|->
name|lun_list
argument_list|,
name|be_lun
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|retval
operator|=
name|ctl_add_lun
argument_list|(
operator|&
name|be_lun
operator|->
name|cbe_lun
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE
argument_list|(
operator|&
name|softc
operator|->
name|lun_list
argument_list|,
name|be_lun
argument_list|,
name|ctl_be_block_lun
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|softc
operator|->
name|num_luns
operator|--
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"ctl_add_lun() returned error %d, see dmesg for "
literal|"details"
argument_list|,
name|retval
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
goto|goto
name|bailout_error
goto|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * Tell the config_status routine that we're waiting so it won't 	 * clean up the LUN in the event of an error. 	 */
name|be_lun
operator|->
name|flags
operator||=
name|CTL_BE_BLOCK_LUN_WAITING
expr_stmt|;
while|while
condition|(
name|be_lun
operator|->
name|flags
operator|&
name|CTL_BE_BLOCK_LUN_UNCONFIGURED
condition|)
block|{
name|retval
operator|=
name|msleep
argument_list|(
name|be_lun
argument_list|,
operator|&
name|softc
operator|->
name|lock
argument_list|,
name|PCATCH
argument_list|,
literal|"ctlblk"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|EINTR
condition|)
break|break;
block|}
name|be_lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_BE_BLOCK_LUN_WAITING
expr_stmt|;
if|if
condition|(
name|be_lun
operator|->
name|flags
operator|&
name|CTL_BE_BLOCK_LUN_CONFIG_ERR
condition|)
block|{
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"LUN configuration error, see dmesg for details"
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE
argument_list|(
operator|&
name|softc
operator|->
name|lun_list
argument_list|,
name|be_lun
argument_list|,
name|ctl_be_block_lun
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|softc
operator|->
name|num_luns
operator|--
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
goto|goto
name|bailout_error
goto|;
block|}
else|else
block|{
name|params
operator|->
name|req_lun_id
operator|=
name|cbe_lun
operator|->
name|lun_id
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|be_lun
operator|->
name|disk_stats
operator|=
name|devstat_new_entry
argument_list|(
literal|"cbb"
argument_list|,
name|params
operator|->
name|req_lun_id
argument_list|,
name|cbe_lun
operator|->
name|blocksize
argument_list|,
name|DEVSTAT_ALL_SUPPORTED
argument_list|,
name|cbe_lun
operator|->
name|lun_type
operator||
name|DEVSTAT_TYPE_IF_OTHER
argument_list|,
name|DEVSTAT_PRIORITY_OTHER
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
name|bailout_error
label|:
name|req
operator|->
name|status
operator|=
name|CTL_LUN_ERROR
expr_stmt|;
if|if
condition|(
name|be_lun
operator|->
name|io_taskqueue
operator|!=
name|NULL
condition|)
name|taskqueue_free
argument_list|(
name|be_lun
operator|->
name|io_taskqueue
argument_list|)
expr_stmt|;
name|ctl_be_block_close
argument_list|(
name|be_lun
argument_list|)
expr_stmt|;
if|if
condition|(
name|be_lun
operator|->
name|dev_path
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|be_lun
operator|->
name|dev_path
argument_list|,
name|M_CTLBLK
argument_list|)
expr_stmt|;
if|if
condition|(
name|be_lun
operator|->
name|lun_zone
operator|!=
name|NULL
condition|)
name|uma_zdestroy
argument_list|(
name|be_lun
operator|->
name|lun_zone
argument_list|)
expr_stmt|;
name|ctl_free_opts
argument_list|(
operator|&
name|cbe_lun
operator|->
name|options
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|be_lun
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|be_lun
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|be_lun
argument_list|,
name|M_CTLBLK
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_be_block_rm
parameter_list|(
name|struct
name|ctl_be_block_softc
modifier|*
name|softc
parameter_list|,
name|struct
name|ctl_lun_req
modifier|*
name|req
parameter_list|)
block|{
name|struct
name|ctl_lun_rm_params
modifier|*
name|params
decl_stmt|;
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
decl_stmt|;
name|struct
name|ctl_be_lun
modifier|*
name|cbe_lun
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|params
operator|=
operator|&
name|req
operator|->
name|reqdata
operator|.
name|rm
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|be_lun
argument_list|,
argument|&softc->lun_list
argument_list|,
argument|links
argument_list|)
block|{
if|if
condition|(
name|be_lun
operator|->
name|cbe_lun
operator|.
name|lun_id
operator|==
name|params
operator|->
name|lun_id
condition|)
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|be_lun
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"LUN %u is not managed by the block backend"
argument_list|,
name|params
operator|->
name|lun_id
argument_list|)
expr_stmt|;
goto|goto
name|bailout_error
goto|;
block|}
name|cbe_lun
operator|=
operator|&
name|be_lun
operator|->
name|cbe_lun
expr_stmt|;
name|retval
operator|=
name|ctl_disable_lun
argument_list|(
name|cbe_lun
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"error %d returned from ctl_disable_lun() for "
literal|"LUN %d"
argument_list|,
name|retval
argument_list|,
name|params
operator|->
name|lun_id
argument_list|)
expr_stmt|;
goto|goto
name|bailout_error
goto|;
block|}
if|if
condition|(
name|be_lun
operator|->
name|vn
operator|!=
name|NULL
condition|)
block|{
name|cbe_lun
operator|->
name|flags
operator||=
name|CTL_LUN_FLAG_NO_MEDIA
expr_stmt|;
name|ctl_lun_no_media
argument_list|(
name|cbe_lun
argument_list|)
expr_stmt|;
name|taskqueue_drain_all
argument_list|(
name|be_lun
operator|->
name|io_taskqueue
argument_list|)
expr_stmt|;
name|ctl_be_block_close
argument_list|(
name|be_lun
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
name|ctl_invalidate_lun
argument_list|(
name|cbe_lun
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"error %d returned from ctl_invalidate_lun() for "
literal|"LUN %d"
argument_list|,
name|retval
argument_list|,
name|params
operator|->
name|lun_id
argument_list|)
expr_stmt|;
goto|goto
name|bailout_error
goto|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|be_lun
operator|->
name|flags
operator||=
name|CTL_BE_BLOCK_LUN_WAITING
expr_stmt|;
while|while
condition|(
operator|(
name|be_lun
operator|->
name|flags
operator|&
name|CTL_BE_BLOCK_LUN_UNCONFIGURED
operator|)
operator|==
literal|0
condition|)
block|{
name|retval
operator|=
name|msleep
argument_list|(
name|be_lun
argument_list|,
operator|&
name|softc
operator|->
name|lock
argument_list|,
name|PCATCH
argument_list|,
literal|"ctlblk"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|EINTR
condition|)
break|break;
block|}
name|be_lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_BE_BLOCK_LUN_WAITING
expr_stmt|;
if|if
condition|(
operator|(
name|be_lun
operator|->
name|flags
operator|&
name|CTL_BE_BLOCK_LUN_UNCONFIGURED
operator|)
operator|==
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"interrupted waiting for LUN to be freed"
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
goto|goto
name|bailout_error
goto|;
block|}
name|STAILQ_REMOVE
argument_list|(
operator|&
name|softc
operator|->
name|lun_list
argument_list|,
name|be_lun
argument_list|,
name|ctl_be_block_lun
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|softc
operator|->
name|num_luns
operator|--
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|taskqueue_drain_all
argument_list|(
name|be_lun
operator|->
name|io_taskqueue
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|be_lun
operator|->
name|io_taskqueue
argument_list|)
expr_stmt|;
if|if
condition|(
name|be_lun
operator|->
name|disk_stats
operator|!=
name|NULL
condition|)
name|devstat_remove_entry
argument_list|(
name|be_lun
operator|->
name|disk_stats
argument_list|)
expr_stmt|;
name|uma_zdestroy
argument_list|(
name|be_lun
operator|->
name|lun_zone
argument_list|)
expr_stmt|;
name|ctl_free_opts
argument_list|(
operator|&
name|cbe_lun
operator|->
name|options
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|be_lun
operator|->
name|dev_path
argument_list|,
name|M_CTLBLK
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|be_lun
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|be_lun
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|be_lun
argument_list|,
name|M_CTLBLK
argument_list|)
expr_stmt|;
name|req
operator|->
name|status
operator|=
name|CTL_LUN_OK
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|bailout_error
label|:
name|req
operator|->
name|status
operator|=
name|CTL_LUN_ERROR
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_be_block_modify
parameter_list|(
name|struct
name|ctl_be_block_softc
modifier|*
name|softc
parameter_list|,
name|struct
name|ctl_lun_req
modifier|*
name|req
parameter_list|)
block|{
name|struct
name|ctl_lun_modify_params
modifier|*
name|params
decl_stmt|;
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
decl_stmt|;
name|struct
name|ctl_be_lun
modifier|*
name|cbe_lun
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|uint64_t
name|oldsize
decl_stmt|;
name|int
name|error
decl_stmt|,
name|wasprim
decl_stmt|;
name|params
operator|=
operator|&
name|req
operator|->
name|reqdata
operator|.
name|modify
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|be_lun
argument_list|,
argument|&softc->lun_list
argument_list|,
argument|links
argument_list|)
block|{
if|if
condition|(
name|be_lun
operator|->
name|cbe_lun
operator|.
name|lun_id
operator|==
name|params
operator|->
name|lun_id
condition|)
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|be_lun
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"LUN %u is not managed by the block backend"
argument_list|,
name|params
operator|->
name|lun_id
argument_list|)
expr_stmt|;
goto|goto
name|bailout_error
goto|;
block|}
name|cbe_lun
operator|=
operator|&
name|be_lun
operator|->
name|cbe_lun
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|lun_size_bytes
operator|!=
literal|0
condition|)
name|be_lun
operator|->
name|params
operator|.
name|lun_size_bytes
operator|=
name|params
operator|->
name|lun_size_bytes
expr_stmt|;
name|ctl_update_opts
argument_list|(
operator|&
name|cbe_lun
operator|->
name|options
argument_list|,
name|req
operator|->
name|num_be_args
argument_list|,
name|req
operator|->
name|kern_be_args
argument_list|)
expr_stmt|;
name|wasprim
operator|=
operator|(
name|cbe_lun
operator|->
name|flags
operator|&
name|CTL_LUN_FLAG_PRIMARY
operator|)
expr_stmt|;
name|value
operator|=
name|ctl_get_opt
argument_list|(
operator|&
name|cbe_lun
operator|->
name|options
argument_list|,
literal|"ha_role"
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"primary"
argument_list|)
operator|==
literal|0
condition|)
name|cbe_lun
operator|->
name|flags
operator||=
name|CTL_LUN_FLAG_PRIMARY
expr_stmt|;
else|else
name|cbe_lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_LUN_FLAG_PRIMARY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|control_softc
operator|->
name|flags
operator|&
name|CTL_FLAG_ACTIVE_SHELF
condition|)
name|cbe_lun
operator|->
name|flags
operator||=
name|CTL_LUN_FLAG_PRIMARY
expr_stmt|;
else|else
name|cbe_lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_LUN_FLAG_PRIMARY
expr_stmt|;
if|if
condition|(
name|wasprim
operator|!=
operator|(
name|cbe_lun
operator|->
name|flags
operator|&
name|CTL_LUN_FLAG_PRIMARY
operator|)
condition|)
block|{
if|if
condition|(
name|cbe_lun
operator|->
name|flags
operator|&
name|CTL_LUN_FLAG_PRIMARY
condition|)
name|ctl_lun_primary
argument_list|(
name|cbe_lun
argument_list|)
expr_stmt|;
else|else
name|ctl_lun_secondary
argument_list|(
name|cbe_lun
argument_list|)
expr_stmt|;
block|}
name|oldsize
operator|=
name|be_lun
operator|->
name|size_blocks
expr_stmt|;
if|if
condition|(
operator|(
name|cbe_lun
operator|->
name|flags
operator|&
name|CTL_LUN_FLAG_PRIMARY
operator|)
operator|||
name|control_softc
operator|->
name|ha_mode
operator|==
name|CTL_HA_MODE_SER_ONLY
condition|)
block|{
if|if
condition|(
name|be_lun
operator|->
name|vn
operator|==
name|NULL
condition|)
name|error
operator|=
name|ctl_be_block_open
argument_list|(
name|be_lun
argument_list|,
name|req
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|vn_isdisk
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|,
operator|&
name|error
argument_list|)
condition|)
name|error
operator|=
name|ctl_be_block_open_dev
argument_list|(
name|be_lun
argument_list|,
name|req
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|be_lun
operator|->
name|vn
operator|->
name|v_type
operator|==
name|VREG
condition|)
block|{
name|vn_lock
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|,
name|LK_SHARED
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
name|error
operator|=
name|ctl_be_block_open_file
argument_list|(
name|be_lun
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|be_lun
operator|->
name|vn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
operator|(
name|cbe_lun
operator|->
name|flags
operator|&
name|CTL_LUN_FLAG_NO_MEDIA
operator|)
operator|&&
name|be_lun
operator|->
name|vn
operator|!=
name|NULL
condition|)
block|{
name|cbe_lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_LUN_FLAG_NO_MEDIA
expr_stmt|;
name|ctl_lun_has_media
argument_list|(
name|cbe_lun
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|cbe_lun
operator|->
name|flags
operator|&
name|CTL_LUN_FLAG_NO_MEDIA
operator|)
operator|==
literal|0
operator|&&
name|be_lun
operator|->
name|vn
operator|==
name|NULL
condition|)
block|{
name|cbe_lun
operator|->
name|flags
operator||=
name|CTL_LUN_FLAG_NO_MEDIA
expr_stmt|;
name|ctl_lun_no_media
argument_list|(
name|cbe_lun
argument_list|)
expr_stmt|;
block|}
name|cbe_lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_LUN_FLAG_EJECTED
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|be_lun
operator|->
name|vn
operator|!=
name|NULL
condition|)
block|{
name|cbe_lun
operator|->
name|flags
operator||=
name|CTL_LUN_FLAG_NO_MEDIA
expr_stmt|;
name|ctl_lun_no_media
argument_list|(
name|cbe_lun
argument_list|)
expr_stmt|;
name|taskqueue_drain_all
argument_list|(
name|be_lun
operator|->
name|io_taskqueue
argument_list|)
expr_stmt|;
name|error
operator|=
name|ctl_be_block_close
argument_list|(
name|be_lun
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|be_lun
operator|->
name|size_blocks
operator|!=
name|oldsize
condition|)
name|ctl_lun_capacity_changed
argument_list|(
name|cbe_lun
argument_list|)
expr_stmt|;
comment|/* Tell the user the exact size we ended up using */
name|params
operator|->
name|lun_size_bytes
operator|=
name|be_lun
operator|->
name|size_bytes
expr_stmt|;
name|req
operator|->
name|status
operator|=
name|error
condition|?
name|CTL_LUN_WARNING
else|:
name|CTL_LUN_OK
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|bailout_error
label|:
name|req
operator|->
name|status
operator|=
name|CTL_LUN_ERROR
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_be_block_lun_shutdown
parameter_list|(
name|void
modifier|*
name|be_lun
parameter_list|)
block|{
name|struct
name|ctl_be_block_lun
modifier|*
name|lun
init|=
name|be_lun
decl_stmt|;
name|struct
name|ctl_be_block_softc
modifier|*
name|softc
init|=
name|lun
operator|->
name|softc
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|lun
operator|->
name|flags
operator||=
name|CTL_BE_BLOCK_LUN_UNCONFIGURED
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|flags
operator|&
name|CTL_BE_BLOCK_LUN_WAITING
condition|)
name|wakeup
argument_list|(
name|lun
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_be_block_lun_config_status
parameter_list|(
name|void
modifier|*
name|be_lun
parameter_list|,
name|ctl_lun_config_status
name|status
parameter_list|)
block|{
name|struct
name|ctl_be_block_lun
modifier|*
name|lun
decl_stmt|;
name|struct
name|ctl_be_block_softc
modifier|*
name|softc
decl_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_be_block_lun
operator|*
operator|)
name|be_lun
expr_stmt|;
name|softc
operator|=
name|lun
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|CTL_LUN_CONFIG_OK
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_BE_BLOCK_LUN_UNCONFIGURED
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|flags
operator|&
name|CTL_BE_BLOCK_LUN_WAITING
condition|)
name|wakeup
argument_list|(
name|lun
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 		 * We successfully added the LUN, attempt to enable it. 		 */
if|if
condition|(
name|ctl_enable_lun
argument_list|(
operator|&
name|lun
operator|->
name|cbe_lun
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ctl_enable_lun() failed!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl_invalidate_lun
argument_list|(
operator|&
name|lun
operator|->
name|cbe_lun
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ctl_invalidate_lun() failed!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_BE_BLOCK_LUN_UNCONFIGURED
expr_stmt|;
name|lun
operator|->
name|flags
operator||=
name|CTL_BE_BLOCK_LUN_CONFIG_ERR
expr_stmt|;
name|wakeup
argument_list|(
name|lun
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_be_block_config_write
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
decl_stmt|;
name|struct
name|ctl_be_lun
modifier|*
name|cbe_lun
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"entered\n"
argument_list|)
expr_stmt|;
name|cbe_lun
operator|=
name|CTL_BACKEND_LUN
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|be_lun
operator|=
operator|(
expr|struct
name|ctl_be_block_lun
operator|*
operator|)
name|cbe_lun
operator|->
name|be_lun
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|io
operator|->
name|scsiio
operator|.
name|cdb
index|[
literal|0
index|]
condition|)
block|{
case|case
name|SYNCHRONIZE_CACHE
case|:
case|case
name|SYNCHRONIZE_CACHE_16
case|:
case|case
name|WRITE_SAME_10
case|:
case|case
name|WRITE_SAME_16
case|:
case|case
name|UNMAP
case|:
comment|/* 		 * The upper level CTL code will filter out any CDBs with 		 * the immediate bit set and return the proper error. 		 * 		 * We don't really need to worry about what LBA range the 		 * user asked to be synced out.  When they issue a sync 		 * cache command, we'll sync out the whole thing. 		 */
name|mtx_lock
argument_list|(
operator|&
name|be_lun
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|be_lun
operator|->
name|config_write_queue
argument_list|,
operator|&
name|io
operator|->
name|io_hdr
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|be_lun
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|be_lun
operator|->
name|io_taskqueue
argument_list|,
operator|&
name|be_lun
operator|->
name|io_task
argument_list|)
expr_stmt|;
break|break;
case|case
name|START_STOP_UNIT
case|:
block|{
name|struct
name|scsi_start_stop_unit
modifier|*
name|cdb
decl_stmt|;
name|struct
name|ctl_lun_req
name|req
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_start_stop_unit
operator|*
operator|)
name|io
operator|->
name|scsiio
operator|.
name|cdb
expr_stmt|;
if|if
condition|(
operator|(
name|cdb
operator|->
name|how
operator|&
name|SSS_PC_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
name|ctl_set_success
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
name|ctl_config_write_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cdb
operator|->
name|how
operator|&
name|SSS_START
condition|)
block|{
if|if
condition|(
operator|(
name|cdb
operator|->
name|how
operator|&
name|SSS_LOEJ
operator|)
operator|&&
name|be_lun
operator|->
name|vn
operator|==
name|NULL
condition|)
block|{
name|retval
operator|=
name|ctl_be_block_open
argument_list|(
name|be_lun
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
name|cbe_lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_LUN_FLAG_EJECTED
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
block|{
name|cbe_lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_LUN_FLAG_NO_MEDIA
expr_stmt|;
name|ctl_lun_has_media
argument_list|(
name|cbe_lun
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cbe_lun
operator|->
name|flags
operator||=
name|CTL_LUN_FLAG_NO_MEDIA
expr_stmt|;
name|ctl_lun_no_media
argument_list|(
name|cbe_lun
argument_list|)
expr_stmt|;
block|}
block|}
name|ctl_start_lun
argument_list|(
name|cbe_lun
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctl_stop_lun
argument_list|(
name|cbe_lun
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|how
operator|&
name|SSS_LOEJ
condition|)
block|{
name|cbe_lun
operator|->
name|flags
operator||=
name|CTL_LUN_FLAG_NO_MEDIA
expr_stmt|;
name|cbe_lun
operator|->
name|flags
operator||=
name|CTL_LUN_FLAG_EJECTED
expr_stmt|;
name|ctl_lun_ejected
argument_list|(
name|cbe_lun
argument_list|)
expr_stmt|;
if|if
condition|(
name|be_lun
operator|->
name|vn
operator|!=
name|NULL
condition|)
name|ctl_be_block_close
argument_list|(
name|be_lun
argument_list|)
expr_stmt|;
block|}
block|}
name|ctl_set_success
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
name|ctl_config_write_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|PREVENT_ALLOW
case|:
name|ctl_set_success
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
name|ctl_config_write_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ctl_set_invalid_opcode
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
name|ctl_config_write_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|retval
operator|=
name|CTL_RETVAL_COMPLETE
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_be_block_config_read
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_be_block_lun
modifier|*
name|be_lun
decl_stmt|;
name|struct
name|ctl_be_lun
modifier|*
name|cbe_lun
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"entered\n"
argument_list|)
expr_stmt|;
name|cbe_lun
operator|=
name|CTL_BACKEND_LUN
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|be_lun
operator|=
operator|(
expr|struct
name|ctl_be_block_lun
operator|*
operator|)
name|cbe_lun
operator|->
name|be_lun
expr_stmt|;
switch|switch
condition|(
name|io
operator|->
name|scsiio
operator|.
name|cdb
index|[
literal|0
index|]
condition|)
block|{
case|case
name|SERVICE_ACTION_IN
case|:
if|if
condition|(
name|io
operator|->
name|scsiio
operator|.
name|cdb
index|[
literal|1
index|]
operator|==
name|SGLS_SERVICE_ACTION
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|be_lun
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|be_lun
operator|->
name|config_read_queue
argument_list|,
operator|&
name|io
operator|->
name|io_hdr
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|be_lun
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|be_lun
operator|->
name|io_taskqueue
argument_list|,
operator|&
name|be_lun
operator|->
name|io_task
argument_list|)
expr_stmt|;
name|retval
operator|=
name|CTL_RETVAL_QUEUED
expr_stmt|;
break|break;
block|}
name|ctl_set_invalid_field
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|1
argument_list|,
comment|/*bit_valid*/
literal|1
argument_list|,
comment|/*bit*/
literal|4
argument_list|)
expr_stmt|;
name|ctl_config_read_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|retval
operator|=
name|CTL_RETVAL_COMPLETE
expr_stmt|;
break|break;
default|default:
name|ctl_set_invalid_opcode
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
name|ctl_config_read_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|retval
operator|=
name|CTL_RETVAL_COMPLETE
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_be_block_lun_info
parameter_list|(
name|void
modifier|*
name|be_lun
parameter_list|,
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|)
block|{
name|struct
name|ctl_be_block_lun
modifier|*
name|lun
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_be_block_lun
operator|*
operator|)
name|be_lun
expr_stmt|;
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\t<num_threads>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
goto|goto
name|bailout
goto|;
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%d"
argument_list|,
name|lun
operator|->
name|num_threads
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
goto|goto
name|bailout
goto|;
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"</num_threads>\n"
argument_list|)
expr_stmt|;
name|bailout
label|:
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|ctl_be_block_lun_attr
parameter_list|(
name|void
modifier|*
name|be_lun
parameter_list|,
specifier|const
name|char
modifier|*
name|attrname
parameter_list|)
block|{
name|struct
name|ctl_be_block_lun
modifier|*
name|lun
init|=
operator|(
expr|struct
name|ctl_be_block_lun
operator|*
operator|)
name|be_lun
decl_stmt|;
if|if
condition|(
name|lun
operator|->
name|getattr
operator|==
name|NULL
condition|)
return|return
operator|(
name|UINT64_MAX
operator|)
return|;
return|return
operator|(
name|lun
operator|->
name|getattr
argument_list|(
name|lun
argument_list|,
name|attrname
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_be_block_init
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ctl_be_block_softc
modifier|*
name|softc
init|=
operator|&
name|backend_block_softc
decl_stmt|;
name|mtx_init
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|,
literal|"ctlblock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|softc
operator|->
name|beio_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"beio"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ctl_be_block_io
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|softc
operator|->
name|lun_list
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_be_block_shutdown
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ctl_be_block_softc
modifier|*
name|softc
init|=
operator|&
name|backend_block_softc
decl_stmt|;
name|struct
name|ctl_be_block_lun
modifier|*
name|lun
decl_stmt|,
modifier|*
name|next_lun
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|lun
argument_list|,
argument|&softc->lun_list
argument_list|,
argument|links
argument_list|,
argument|next_lun
argument_list|)
block|{
comment|/* 		 * Drop our lock here.  Since ctl_invalidate_lun() can call 		 * back into us, this could potentially lead to a recursive 		 * lock of the same mutex, which would cause a hang. 		 */
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ctl_disable_lun
argument_list|(
operator|&
name|lun
operator|->
name|cbe_lun
argument_list|)
expr_stmt|;
name|ctl_invalidate_lun
argument_list|(
operator|&
name|lun
operator|->
name|cbe_lun
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|uma_zdestroy
argument_list|(
name|softc
operator|->
name|beio_zone
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|softc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

