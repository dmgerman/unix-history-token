begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2008, 2009 Silicon Graphics International Corp.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    substantially similar to the "NO WARRANTY" disclaimer below  *    ("Disclaimer") and any redistribution must be conditioned upon  *    including a substantially similar Disclaimer requirement for further  *    binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGES.  *  * $Id: //depot/users/kenm/FreeBSD-test2/sys/cam/ctl/scsi_ctl.c#4 $  */
end_comment

begin_comment
comment|/*  * Peripheral driver interface between CAM and CTL (CAM Target Layer).  *  * Author: Ken Merry<ken@FreeBSD.org>  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_queue.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_io.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_frontend.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_util.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_error.h>
end_include

begin_typedef
typedef|typedef
enum|enum
block|{
name|CTLFE_CCB_DEFAULT
init|=
literal|0x00
block|}
name|ctlfe_ccb_types
typedef|;
end_typedef

begin_struct
struct|struct
name|ctlfe_softc
block|{
name|struct
name|ctl_port
name|port
decl_stmt|;
name|path_id_t
name|path_id
decl_stmt|;
name|u_int
name|maxio
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|char
name|port_name
index|[
name|DEV_IDLEN
index|]
decl_stmt|;
name|struct
name|mtx
name|lun_softc_mtx
decl_stmt|;
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|ctlfe_lun_softc
argument_list|)
name|lun_softc_list
expr_stmt|;
name|STAILQ_ENTRY
argument_list|(
argument|ctlfe_softc
argument_list|)
name|links
expr_stmt|;
block|}
struct|;
end_struct

begin_macro
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|ctlfe_softc
argument_list|)
end_macro

begin_expr_stmt
name|ctlfe_softc_list
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|mtx
name|ctlfe_list_mtx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|ctlfe_mtx_desc
index|[]
init|=
literal|"ctlfelist"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ctlfe_dma_enabled
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|CTLFE_INIT_ENABLE
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|ctlfe_max_targets
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ctlfe_num_targets
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
enum|enum
block|{
name|CTLFE_LUN_NONE
init|=
literal|0x00
block|,
name|CTLFE_LUN_WILDCARD
init|=
literal|0x01
block|}
name|ctlfe_lun_flags
typedef|;
end_typedef

begin_struct
struct|struct
name|ctlfe_lun_softc
block|{
name|struct
name|ctlfe_softc
modifier|*
name|parent_softc
decl_stmt|;
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|ctlfe_lun_flags
name|flags
decl_stmt|;
name|struct
name|callout
name|dma_callout
decl_stmt|;
name|uint64_t
name|ccbs_alloced
decl_stmt|;
name|uint64_t
name|ccbs_freed
decl_stmt|;
name|uint64_t
name|ctios_sent
decl_stmt|;
name|uint64_t
name|ctios_returned
decl_stmt|;
name|uint64_t
name|atios_sent
decl_stmt|;
name|uint64_t
name|atios_returned
decl_stmt|;
name|uint64_t
name|inots_sent
decl_stmt|;
name|uint64_t
name|inots_returned
decl_stmt|;
comment|/* bus_dma_tag_t dma_tag; */
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|ccb_hdr
argument_list|)
name|work_queue
expr_stmt|;
name|STAILQ_ENTRY
argument_list|(
argument|ctlfe_lun_softc
argument_list|)
name|links
expr_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
enum|enum
block|{
name|CTLFE_CMD_NONE
init|=
literal|0x00
block|,
name|CTLFE_CMD_PIECEWISE
init|=
literal|0x01
block|}
name|ctlfe_cmd_flags
typedef|;
end_typedef

begin_comment
comment|/*  * The size limit of this structure is CTL_PORT_PRIV_SIZE, from ctl_io.h.  * Currently that is 600 bytes.  */
end_comment

begin_struct
struct|struct
name|ctlfe_lun_cmd_info
block|{
name|int
name|cur_transfer_index
decl_stmt|;
name|size_t
name|cur_transfer_off
decl_stmt|;
name|ctlfe_cmd_flags
name|flags
decl_stmt|;
comment|/* 	 * XXX KDM struct bus_dma_segment is 8 bytes on i386, and 16 	 * bytes on amd64.  So with 32 elements, this is 256 bytes on 	 * i386 and 512 bytes on amd64. 	 */
define|#
directive|define
name|CTLFE_MAX_SEGS
value|32
name|bus_dma_segment_t
name|cam_sglist
index|[
name|CTLFE_MAX_SEGS
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * When we register the adapter/bus, request that this many ctl_ios be  * allocated.  This should be the maximum supported by the adapter, but we  * currently don't have a way to get that back from the path inquiry.  * XXX KDM add that to the path inquiry.  */
end_comment

begin_define
define|#
directive|define
name|CTLFE_REQ_CTL_IO
value|4096
end_define

begin_comment
comment|/*  * Number of Accept Target I/O CCBs to allocate and queue down to the  * adapter per LUN.  * XXX KDM should this be controlled by CTL?  */
end_comment

begin_define
define|#
directive|define
name|CTLFE_ATIO_PER_LUN
value|1024
end_define

begin_comment
comment|/*  * Number of Immediate Notify CCBs (used for aborts, resets, etc.) to  * allocate and queue down to the adapter per LUN.  * XXX KDM should this be controlled by CTL?  */
end_comment

begin_define
define|#
directive|define
name|CTLFE_IN_PER_LUN
value|1024
end_define

begin_comment
comment|/*  * Timeout (in seconds) on CTIO CCB allocation for doing a DMA or sending  * status to the initiator.  The SIM is expected to have its own timeouts,  * so we're not putting this timeout around the CCB execution time.  The  * SIM should timeout and let us know if it has an issue.  */
end_comment

begin_define
define|#
directive|define
name|CTLFE_DMA_TIMEOUT
value|60
end_define

begin_comment
comment|/*  * Turn this on to enable extra debugging prints.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|CTLFE_DEBUG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Use randomly assigned WWNN/WWPN values.  This is to work around an issue  * in the FreeBSD initiator that makes it unable to rescan the target if  * the target gets rebooted and the WWNN/WWPN stay the same.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|RANDOM_WWNN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_cam_ctl
argument_list|,
name|OID_AUTO
argument_list|,
name|dma_enabled
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ctlfe_dma_enabled
argument_list|,
literal|0
argument_list|,
literal|"DMA enabled"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_CTLFE
argument_list|,
literal|"CAM CTL FE"
argument_list|,
literal|"CAM CTL FE interface"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|ccb_type
value|ppriv_field0
end_define

begin_comment
comment|/* This is only used in the ATIO */
end_comment

begin_define
define|#
directive|define
name|io_ptr
value|ppriv_ptr1
end_define

begin_comment
comment|/* This is only used in the CTIO */
end_comment

begin_define
define|#
directive|define
name|ccb_atio
value|ppriv_ptr1
end_define

begin_function_decl
name|int
name|ctlfeinitialize
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ctlfeshutdown
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|periph_init_t
name|ctlfeperiphinit
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|ctlfeasync
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|uint32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|periph_ctor_t
name|ctlferegister
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_oninv_t
name|ctlfeoninvalidate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_dtor_t
name|ctlfecleanup
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_start_t
name|ctlfestart
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|ctlfedone
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|done_ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctlfe_onoffline
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|online
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctlfe_online
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctlfe_offline
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctlfe_lun_enable
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ctl_id
name|targ_id
parameter_list|,
name|int
name|lun_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctlfe_lun_disable
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ctl_id
name|targ_id
parameter_list|,
name|int
name|lun_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctlfe_dump_sim
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctlfe_dump_queue
parameter_list|(
name|struct
name|ctlfe_lun_softc
modifier|*
name|softc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctlfe_dma_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctlfe_datamove_done
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctlfe_dump
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|periph_driver
name|ctlfe_driver
init|=
block|{
name|ctlfeperiphinit
block|,
literal|"ctl"
block|,
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|ctlfe_driver
operator|.
name|units
argument_list|)
block|,
comment|/*generation*/
literal|0
block|,
name|CAM_PERIPH_DRV_EARLY
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ctl_frontend
name|ctlfe_frontend
init|=
block|{
operator|.
name|name
operator|=
literal|"camtgt"
block|,
operator|.
name|init
operator|=
name|ctlfeinitialize
block|,
operator|.
name|fe_dump
operator|=
name|ctlfe_dump
block|,
operator|.
name|shutdown
operator|=
name|ctlfeshutdown
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|CTL_FRONTEND_DECLARE
argument_list|(
name|ctlfe
argument_list|,
name|ctlfe_frontend
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|extern
name|struct
name|ctl_softc
modifier|*
name|control_softc
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|ctlfeshutdown
parameter_list|(
name|void
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
name|int
name|ctlfeinitialize
parameter_list|(
name|void
parameter_list|)
block|{
name|STAILQ_INIT
argument_list|(
operator|&
name|ctlfe_softc_list
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|ctlfe_list_mtx
argument_list|,
name|ctlfe_mtx_desc
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|periphdriver_register
argument_list|(
operator|&
name|ctlfe_driver
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ctlfeperiphinit
parameter_list|(
name|void
parameter_list|)
block|{
name|cam_status
name|status
decl_stmt|;
name|status
operator|=
name|xpt_register_async
argument_list|(
name|AC_PATH_REGISTERED
operator||
name|AC_PATH_DEREGISTERED
operator||
name|AC_CONTRACT
argument_list|,
name|ctlfeasync
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"ctl: Failed to attach async callback due to CAM "
literal|"status 0x%x!\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ctlfeasync
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|uint32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ctlfe_softc
modifier|*
name|softc
decl_stmt|;
ifdef|#
directive|ifdef
name|CTLFEDEBUG
name|printf
argument_list|(
literal|"%s: entered\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mtx_lock
argument_list|(
operator|&
name|ctlfe_list_mtx
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|softc
argument_list|,
argument|&ctlfe_softc_list
argument_list|,
argument|links
argument_list|)
block|{
if|if
condition|(
name|softc
operator|->
name|path_id
operator|==
name|xpt_path_path_id
argument_list|(
name|path
argument_list|)
condition|)
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|ctlfe_list_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * When a new path gets registered, and it is capable of target 	 * mode, go ahead and attach.  Later on, we may need to be more 	 * selective, but for now this will be sufficient.  	 */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|AC_PATH_REGISTERED
case|:
block|{
name|struct
name|ctl_port
modifier|*
name|port
decl_stmt|;
name|struct
name|ccb_pathinq
modifier|*
name|cpi
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|cpi
operator|=
operator|(
expr|struct
name|ccb_pathinq
operator|*
operator|)
name|arg
expr_stmt|;
comment|/* Don't attach if it doesn't support target mode */
if|if
condition|(
operator|(
name|cpi
operator|->
name|target_sprt
operator|&
name|PIT_PROCESSOR
operator|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|CTLFEDEBUG
name|printf
argument_list|(
literal|"%s: SIM %s%d doesn't support target mode\n"
argument_list|,
name|__func__
argument_list|,
name|cpi
operator|->
name|dev_name
argument_list|,
name|cpi
operator|->
name|unit_number
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
if|if
condition|(
name|softc
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|CTLFEDEBUG
name|printf
argument_list|(
literal|"%s: CTL port for CAM path %u already exists\n"
argument_list|,
name|__func__
argument_list|,
name|xpt_path_path_id
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
ifdef|#
directive|ifdef
name|CTLFE_INIT_ENABLE
if|if
condition|(
name|ctlfe_num_targets
operator|>=
name|ctlfe_max_targets
condition|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|ccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ccb
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unable to malloc CCB!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|xpt_setup_ccb
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|path
argument_list|,
name|CAM_PRIORITY_NONE
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SET_SIM_KNOB
expr_stmt|;
name|ccb
operator|->
name|knob
operator|.
name|xport_specific
operator|.
name|valid
operator|=
name|KNOB_VALID_ROLE
expr_stmt|;
name|ccb
operator|->
name|knob
operator|.
name|xport_specific
operator|.
name|fc
operator|.
name|role
operator|=
name|KNOB_ROLE_INITIATOR
expr_stmt|;
name|xpt_action
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"%s: SIM %s%d (path id %d) initiator "
literal|"enable failed with status %#x\n"
argument_list|,
name|__func__
argument_list|,
name|cpi
operator|->
name|dev_name
argument_list|,
name|cpi
operator|->
name|unit_number
argument_list|,
name|cpi
operator|->
name|ccb_h
operator|.
name|path_id
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|status
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s: SIM %s%d (path id %d) initiator "
literal|"enable succeeded\n"
argument_list|,
name|__func__
argument_list|,
name|cpi
operator|->
name|dev_name
argument_list|,
name|cpi
operator|->
name|unit_number
argument_list|,
name|cpi
operator|->
name|ccb_h
operator|.
name|path_id
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|ccb
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|ctlfe_num_targets
operator|++
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s: ctlfe_num_targets = %d\n"
argument_list|,
name|__func__
argument_list|,
name|ctlfe_num_targets
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CTLFE_INIT_ENABLE */
comment|/* 		 * We're in an interrupt context here, so we have to 		 * use M_NOWAIT.  Of course this means trouble if we 		 * can't allocate memory. 		 */
name|softc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|softc
argument_list|)
argument_list|,
name|M_CTLFE
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unable to malloc %zd bytes for softc\n"
argument_list|,
name|__func__
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|softc
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|softc
operator|->
name|path_id
operator|=
name|cpi
operator|->
name|ccb_h
operator|.
name|path_id
expr_stmt|;
name|softc
operator|->
name|sim
operator|=
name|xpt_path_sim
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpi
operator|->
name|maxio
operator|!=
literal|0
condition|)
name|softc
operator|->
name|maxio
operator|=
name|cpi
operator|->
name|maxio
expr_stmt|;
else|else
name|softc
operator|->
name|maxio
operator|=
name|DFLTPHYS
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|softc
operator|->
name|lun_softc_mtx
argument_list|,
literal|"LUN softc mtx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|softc
operator|->
name|lun_softc_list
argument_list|)
expr_stmt|;
name|port
operator|=
operator|&
name|softc
operator|->
name|port
expr_stmt|;
name|port
operator|->
name|frontend
operator|=
operator|&
name|ctlfe_frontend
expr_stmt|;
comment|/* 		 * XXX KDM should we be more accurate here ? 		 */
if|if
condition|(
name|cpi
operator|->
name|transport
operator|==
name|XPORT_FC
condition|)
name|port
operator|->
name|port_type
operator|=
name|CTL_PORT_FC
expr_stmt|;
elseif|else
if|if
condition|(
name|cpi
operator|->
name|transport
operator|==
name|XPORT_SAS
condition|)
name|port
operator|->
name|port_type
operator|=
name|CTL_PORT_SAS
expr_stmt|;
else|else
name|port
operator|->
name|port_type
operator|=
name|CTL_PORT_SCSI
expr_stmt|;
comment|/* XXX KDM what should the real number be here? */
name|port
operator|->
name|num_requested_ctl_io
operator|=
literal|4096
expr_stmt|;
name|snprintf
argument_list|(
name|softc
operator|->
name|port_name
argument_list|,
sizeof|sizeof
argument_list|(
name|softc
operator|->
name|port_name
argument_list|)
argument_list|,
literal|"%s%d"
argument_list|,
name|cpi
operator|->
name|dev_name
argument_list|,
name|cpi
operator|->
name|unit_number
argument_list|)
expr_stmt|;
comment|/* 		 * XXX KDM it would be nice to allocate storage in the 		 * frontend structure itself. 	 	 */
name|port
operator|->
name|port_name
operator|=
name|softc
operator|->
name|port_name
expr_stmt|;
name|port
operator|->
name|physical_port
operator|=
name|cpi
operator|->
name|bus_id
expr_stmt|;
name|port
operator|->
name|virtual_port
operator|=
literal|0
expr_stmt|;
name|port
operator|->
name|port_online
operator|=
name|ctlfe_online
expr_stmt|;
name|port
operator|->
name|port_offline
operator|=
name|ctlfe_offline
expr_stmt|;
name|port
operator|->
name|onoff_arg
operator|=
name|softc
expr_stmt|;
name|port
operator|->
name|lun_enable
operator|=
name|ctlfe_lun_enable
expr_stmt|;
name|port
operator|->
name|lun_disable
operator|=
name|ctlfe_lun_disable
expr_stmt|;
name|port
operator|->
name|targ_lun_arg
operator|=
name|softc
expr_stmt|;
name|port
operator|->
name|fe_datamove
operator|=
name|ctlfe_datamove_done
expr_stmt|;
name|port
operator|->
name|fe_done
operator|=
name|ctlfe_datamove_done
expr_stmt|;
comment|/* 		 * XXX KDM the path inquiry doesn't give us the maximum 		 * number of targets supported. 		 */
name|port
operator|->
name|max_targets
operator|=
name|cpi
operator|->
name|max_target
expr_stmt|;
name|port
operator|->
name|max_target_id
operator|=
name|cpi
operator|->
name|max_target
expr_stmt|;
comment|/* 		 * XXX KDM need to figure out whether we're the master or 		 * slave. 		 */
ifdef|#
directive|ifdef
name|CTLFEDEBUG
name|printf
argument_list|(
literal|"%s: calling ctl_port_register() for %s%d\n"
argument_list|,
name|__func__
argument_list|,
name|cpi
operator|->
name|dev_name
argument_list|,
name|cpi
operator|->
name|unit_number
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|retval
operator|=
name|ctl_port_register
argument_list|(
name|port
argument_list|,
comment|/*master_SC*/
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ctl_port_register() failed with "
literal|"error %d!\n"
argument_list|,
name|__func__
argument_list|,
name|retval
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|softc
operator|->
name|lun_softc_mtx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|softc
argument_list|,
name|M_CTLFE
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|mtx_lock
argument_list|(
operator|&
name|ctlfe_list_mtx
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ctlfe_softc_list
argument_list|,
name|softc
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ctlfe_list_mtx
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|AC_PATH_DEREGISTERED
case|:
block|{
if|if
condition|(
name|softc
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * XXX KDM are we certain at this point that there 			 * are no outstanding commands for this frontend? 			 */
name|mtx_lock
argument_list|(
operator|&
name|ctlfe_list_mtx
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE
argument_list|(
operator|&
name|ctlfe_softc_list
argument_list|,
name|softc
argument_list|,
name|ctlfe_softc
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ctlfe_list_mtx
argument_list|)
expr_stmt|;
name|ctl_port_deregister
argument_list|(
operator|&
name|softc
operator|->
name|port
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|softc
operator|->
name|lun_softc_mtx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|softc
argument_list|,
name|M_CTLFE
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|AC_CONTRACT
case|:
block|{
name|struct
name|ac_contract
modifier|*
name|ac
decl_stmt|;
name|ac
operator|=
operator|(
expr|struct
name|ac_contract
operator|*
operator|)
name|arg
expr_stmt|;
switch|switch
condition|(
name|ac
operator|->
name|contract_number
condition|)
block|{
case|case
name|AC_CONTRACT_DEV_CHG
case|:
block|{
name|struct
name|ac_device_changed
modifier|*
name|dev_chg
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|dev_chg
operator|=
operator|(
expr|struct
name|ac_device_changed
operator|*
operator|)
name|ac
operator|->
name|contract_data
expr_stmt|;
name|printf
argument_list|(
literal|"%s: WWPN %#jx port 0x%06x path %u target %u %s\n"
argument_list|,
name|__func__
argument_list|,
name|dev_chg
operator|->
name|wwpn
argument_list|,
name|dev_chg
operator|->
name|port
argument_list|,
name|xpt_path_path_id
argument_list|(
name|path
argument_list|)
argument_list|,
name|dev_chg
operator|->
name|target
argument_list|,
operator|(
name|dev_chg
operator|->
name|arrived
operator|==
literal|0
operator|)
condition|?
literal|"left"
else|:
literal|"arrived"
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: CTL port for CAM path %u not "
literal|"found!\n"
argument_list|,
name|__func__
argument_list|,
name|xpt_path_path_id
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dev_chg
operator|->
name|arrived
operator|!=
literal|0
condition|)
block|{
name|retval
operator|=
name|ctl_add_initiator
argument_list|(
operator|&
name|softc
operator|->
name|port
argument_list|,
name|dev_chg
operator|->
name|target
argument_list|,
name|dev_chg
operator|->
name|wwpn
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
name|ctl_remove_initiator
argument_list|(
operator|&
name|softc
operator|->
name|port
argument_list|,
name|dev_chg
operator|->
name|target
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: could not %s port %d iid %u "
literal|"WWPN %#jx!\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|dev_chg
operator|->
name|arrived
operator|!=
literal|0
operator|)
condition|?
literal|"add"
else|:
literal|"remove"
argument_list|,
name|softc
operator|->
name|port
operator|.
name|targ_port
argument_list|,
name|dev_chg
operator|->
name|target
argument_list|,
operator|(
name|uintmax_t
operator|)
name|dev_chg
operator|->
name|wwpn
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
name|printf
argument_list|(
literal|"%s: unsupported contract number %ju\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ac
operator|->
name|contract_number
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|cam_status
name|ctlferegister
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ctlfe_softc
modifier|*
name|bus_softc
decl_stmt|;
name|struct
name|ctlfe_lun_softc
modifier|*
name|softc
decl_stmt|;
name|union
name|ccb
name|en_lun_ccb
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|int
name|i
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|ctlfe_lun_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|bus_softc
operator|=
name|softc
operator|->
name|parent_softc
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|softc
operator|->
name|work_queue
argument_list|)
expr_stmt|;
name|softc
operator|->
name|periph
operator|=
name|periph
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|softc
operator|->
name|dma_callout
argument_list|,
name|xpt_path_mtx
argument_list|(
name|periph
operator|->
name|path
argument_list|)
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
name|periph
operator|->
name|softc
operator|=
name|softc
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|en_lun_ccb
operator|.
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
name|CAM_PRIORITY_NONE
argument_list|)
expr_stmt|;
name|en_lun_ccb
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_EN_LUN
expr_stmt|;
name|en_lun_ccb
operator|.
name|cel
operator|.
name|grp6_len
operator|=
literal|0
expr_stmt|;
name|en_lun_ccb
operator|.
name|cel
operator|.
name|grp7_len
operator|=
literal|0
expr_stmt|;
name|en_lun_ccb
operator|.
name|cel
operator|.
name|enable
operator|=
literal|1
expr_stmt|;
name|xpt_action
argument_list|(
operator|&
name|en_lun_ccb
argument_list|)
expr_stmt|;
name|status
operator|=
operator|(
name|en_lun_ccb
operator|.
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"%s: Enable LUN failed, status 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|en_lun_ccb
operator|.
name|ccb_h
operator|.
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTLFE_ATIO_PER_LUN
condition|;
name|i
operator|++
control|)
block|{
name|union
name|ccb
modifier|*
name|new_ccb
decl_stmt|;
name|new_ccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new_ccb
argument_list|)
argument_list|,
name|M_CTLFE
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_ccb
operator|==
name|NULL
condition|)
block|{
name|status
operator|=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
break|break;
block|}
name|xpt_setup_ccb
argument_list|(
operator|&
name|new_ccb
operator|->
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|new_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_ACCEPT_TARGET_IO
expr_stmt|;
name|new_ccb
operator|->
name|ccb_h
operator|.
name|cbfcnp
operator|=
name|ctlfedone
expr_stmt|;
name|new_ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_UNLOCKED
expr_stmt|;
name|xpt_action
argument_list|(
name|new_ccb
argument_list|)
expr_stmt|;
name|softc
operator|->
name|atios_sent
operator|++
expr_stmt|;
name|status
operator|=
name|new_ccb
operator|->
name|ccb_h
operator|.
name|status
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_INPROG
condition|)
block|{
name|free
argument_list|(
name|new_ccb
argument_list|,
name|M_CTLFE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|status
operator|=
name|cam_periph_acquire
argument_list|(
name|periph
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"%s: could not acquire reference "
literal|"count, status = %#x\n"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"%s: could not allocate ATIO CCBs, "
literal|"status 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTLFE_IN_PER_LUN
condition|;
name|i
operator|++
control|)
block|{
name|union
name|ccb
modifier|*
name|new_ccb
decl_stmt|;
name|new_ccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new_ccb
argument_list|)
argument_list|,
name|M_CTLFE
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_ccb
operator|==
name|NULL
condition|)
block|{
name|status
operator|=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
break|break;
block|}
name|xpt_setup_ccb
argument_list|(
operator|&
name|new_ccb
operator|->
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|new_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_IMMEDIATE_NOTIFY
expr_stmt|;
name|new_ccb
operator|->
name|ccb_h
operator|.
name|cbfcnp
operator|=
name|ctlfedone
expr_stmt|;
name|new_ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_UNLOCKED
expr_stmt|;
name|xpt_action
argument_list|(
name|new_ccb
argument_list|)
expr_stmt|;
name|softc
operator|->
name|inots_sent
operator|++
expr_stmt|;
name|status
operator|=
name|new_ccb
operator|->
name|ccb_h
operator|.
name|status
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_INPROG
condition|)
block|{
comment|/* 			 * Note that we don't free the CCB here.  If the 			 * status is not CAM_REQ_INPROG, then we're 			 * probably talking to a SIM that says it is 			 * target-capable but doesn't support the  			 * XPT_IMMEDIATE_NOTIFY CCB.  i.e. it supports the 			 * older API.  In that case, it'll call xpt_done() 			 * on the CCB, and we need to free it in our done 			 * routine as a result. 			 */
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|i
operator|==
literal|0
operator|)
operator|||
operator|(
name|status
operator|!=
name|CAM_REQ_INPROG
operator|)
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"%s: could not allocate immediate "
literal|"notify CCBs, status 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
return|return
operator|(
name|CAM_REQ_CMP
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctlfeoninvalidate
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|union
name|ccb
name|en_lun_ccb
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|struct
name|ctlfe_softc
modifier|*
name|bus_softc
decl_stmt|;
name|struct
name|ctlfe_lun_softc
modifier|*
name|softc
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|ctlfe_lun_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|en_lun_ccb
operator|.
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
name|CAM_PRIORITY_NONE
argument_list|)
expr_stmt|;
name|en_lun_ccb
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_EN_LUN
expr_stmt|;
name|en_lun_ccb
operator|.
name|cel
operator|.
name|grp6_len
operator|=
literal|0
expr_stmt|;
name|en_lun_ccb
operator|.
name|cel
operator|.
name|grp7_len
operator|=
literal|0
expr_stmt|;
name|en_lun_ccb
operator|.
name|cel
operator|.
name|enable
operator|=
literal|0
expr_stmt|;
name|xpt_action
argument_list|(
operator|&
name|en_lun_ccb
argument_list|)
expr_stmt|;
name|status
operator|=
operator|(
name|en_lun_ccb
operator|.
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"%s: Disable LUN failed, status 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|en_lun_ccb
operator|.
name|ccb_h
operator|.
name|status
argument_list|)
expr_stmt|;
comment|/* 		 * XXX KDM what do we do now? 		 */
block|}
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"LUN removed, %ju ATIOs outstanding, %ju "
literal|"INOTs outstanding, %d refs\n"
argument_list|,
name|softc
operator|->
name|atios_sent
operator|-
name|softc
operator|->
name|atios_returned
argument_list|,
name|softc
operator|->
name|inots_sent
operator|-
name|softc
operator|->
name|inots_returned
argument_list|,
name|periph
operator|->
name|refcount
argument_list|)
expr_stmt|;
name|bus_softc
operator|=
name|softc
operator|->
name|parent_softc
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|bus_softc
operator|->
name|lun_softc_mtx
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE
argument_list|(
operator|&
name|bus_softc
operator|->
name|lun_softc_list
argument_list|,
name|softc
argument_list|,
name|ctlfe_lun_softc
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|bus_softc
operator|->
name|lun_softc_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctlfecleanup
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|struct
name|ctlfe_lun_softc
modifier|*
name|softc
decl_stmt|;
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"%s: Called\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|ctlfe_lun_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
comment|/* 	 * XXX KDM is there anything else that needs to be done here? 	 */
name|callout_stop
argument_list|(
operator|&
name|softc
operator|->
name|dma_callout
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|softc
argument_list|,
name|M_CTLFE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctlfedata
parameter_list|(
name|struct
name|ctlfe_lun_softc
modifier|*
name|softc
parameter_list|,
name|union
name|ctl_io
modifier|*
name|io
parameter_list|,
name|ccb_flags
modifier|*
name|flags
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|data_ptr
parameter_list|,
name|uint32_t
modifier|*
name|dxfer_len
parameter_list|,
name|u_int16_t
modifier|*
name|sglist_cnt
parameter_list|)
block|{
name|struct
name|ctlfe_softc
modifier|*
name|bus_softc
decl_stmt|;
name|struct
name|ctlfe_lun_cmd_info
modifier|*
name|cmd_info
decl_stmt|;
name|struct
name|ctl_sg_entry
modifier|*
name|ctl_sglist
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|cam_sglist
decl_stmt|;
name|size_t
name|off
decl_stmt|;
name|int
name|i
decl_stmt|,
name|idx
decl_stmt|;
name|cmd_info
operator|=
operator|(
expr|struct
name|ctlfe_lun_cmd_info
operator|*
operator|)
name|io
operator|->
name|io_hdr
operator|.
name|port_priv
expr_stmt|;
name|bus_softc
operator|=
name|softc
operator|->
name|parent_softc
expr_stmt|;
comment|/* 	 * Set the direction, relative to the initiator. 	 */
operator|*
name|flags
operator|&=
operator|~
name|CAM_DIR_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_DATA_MASK
operator|)
operator|==
name|CTL_FLAG_DATA_IN
condition|)
operator|*
name|flags
operator||=
name|CAM_DIR_IN
expr_stmt|;
else|else
operator|*
name|flags
operator||=
name|CAM_DIR_OUT
expr_stmt|;
operator|*
name|flags
operator|&=
operator|~
name|CAM_DATA_MASK
expr_stmt|;
name|idx
operator|=
name|cmd_info
operator|->
name|cur_transfer_index
expr_stmt|;
name|off
operator|=
name|cmd_info
operator|->
name|cur_transfer_off
expr_stmt|;
name|cmd_info
operator|->
name|flags
operator|&=
operator|~
name|CTLFE_CMD_PIECEWISE
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|scsiio
operator|.
name|kern_sg_entries
operator|==
literal|0
condition|)
block|{
comment|/* No S/G list. */
operator|*
name|data_ptr
operator|=
name|io
operator|->
name|scsiio
operator|.
name|kern_data_ptr
operator|+
name|off
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|scsiio
operator|.
name|kern_data_len
operator|-
name|off
operator|<=
name|bus_softc
operator|->
name|maxio
condition|)
block|{
operator|*
name|dxfer_len
operator|=
name|io
operator|->
name|scsiio
operator|.
name|kern_data_len
operator|-
name|off
expr_stmt|;
block|}
else|else
block|{
operator|*
name|dxfer_len
operator|=
name|bus_softc
operator|->
name|maxio
expr_stmt|;
name|cmd_info
operator|->
name|cur_transfer_index
operator|=
operator|-
literal|1
expr_stmt|;
name|cmd_info
operator|->
name|cur_transfer_off
operator|=
name|bus_softc
operator|->
name|maxio
expr_stmt|;
name|cmd_info
operator|->
name|flags
operator||=
name|CTLFE_CMD_PIECEWISE
expr_stmt|;
block|}
operator|*
name|sglist_cnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_BUS_ADDR
condition|)
operator|*
name|flags
operator||=
name|CAM_DATA_PADDR
expr_stmt|;
else|else
operator|*
name|flags
operator||=
name|CAM_DATA_VADDR
expr_stmt|;
block|}
else|else
block|{
comment|/* S/G list with physical or virtual pointers. */
name|ctl_sglist
operator|=
operator|(
expr|struct
name|ctl_sg_entry
operator|*
operator|)
name|io
operator|->
name|scsiio
operator|.
name|kern_data_ptr
expr_stmt|;
name|cam_sglist
operator|=
name|cmd_info
operator|->
name|cam_sglist
expr_stmt|;
operator|*
name|dxfer_len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|io
operator|->
name|scsiio
operator|.
name|kern_sg_entries
operator|-
name|idx
condition|;
name|i
operator|++
control|)
block|{
name|cam_sglist
index|[
name|i
index|]
operator|.
name|ds_addr
operator|=
operator|(
name|bus_addr_t
operator|)
name|ctl_sglist
index|[
name|i
operator|+
name|idx
index|]
operator|.
name|addr
operator|+
name|off
expr_stmt|;
if|if
condition|(
name|ctl_sglist
index|[
name|i
operator|+
name|idx
index|]
operator|.
name|len
operator|-
name|off
operator|<=
name|bus_softc
operator|->
name|maxio
operator|-
operator|*
name|dxfer_len
condition|)
block|{
name|cam_sglist
index|[
name|i
index|]
operator|.
name|ds_len
operator|=
name|ctl_sglist
index|[
name|idx
operator|+
name|i
index|]
operator|.
name|len
operator|-
name|off
expr_stmt|;
operator|*
name|dxfer_len
operator|+=
name|cam_sglist
index|[
name|i
index|]
operator|.
name|ds_len
expr_stmt|;
block|}
else|else
block|{
name|cam_sglist
index|[
name|i
index|]
operator|.
name|ds_len
operator|=
name|bus_softc
operator|->
name|maxio
operator|-
operator|*
name|dxfer_len
expr_stmt|;
name|cmd_info
operator|->
name|cur_transfer_index
operator|=
name|idx
operator|+
name|i
expr_stmt|;
name|cmd_info
operator|->
name|cur_transfer_off
operator|=
name|cam_sglist
index|[
name|i
index|]
operator|.
name|ds_len
operator|+
name|off
expr_stmt|;
name|cmd_info
operator|->
name|flags
operator||=
name|CTLFE_CMD_PIECEWISE
expr_stmt|;
operator|*
name|dxfer_len
operator|+=
name|cam_sglist
index|[
name|i
index|]
operator|.
name|ds_len
expr_stmt|;
if|if
condition|(
name|ctl_sglist
index|[
name|i
index|]
operator|.
name|len
operator|!=
literal|0
condition|)
name|i
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
operator|(
name|CTLFE_MAX_SEGS
operator|-
literal|1
operator|)
operator|&&
name|idx
operator|+
name|i
operator|<
operator|(
name|io
operator|->
name|scsiio
operator|.
name|kern_sg_entries
operator|-
literal|1
operator|)
condition|)
block|{
name|cmd_info
operator|->
name|cur_transfer_index
operator|=
name|idx
operator|+
name|i
operator|+
literal|1
expr_stmt|;
name|cmd_info
operator|->
name|cur_transfer_off
operator|=
literal|0
expr_stmt|;
name|cmd_info
operator|->
name|flags
operator||=
name|CTLFE_CMD_PIECEWISE
expr_stmt|;
name|i
operator|++
expr_stmt|;
break|break;
block|}
name|off
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|sglist_cnt
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_BUS_ADDR
condition|)
operator|*
name|flags
operator||=
name|CAM_DATA_SG_PADDR
expr_stmt|;
else|else
operator|*
name|flags
operator||=
name|CAM_DATA_SG
expr_stmt|;
operator|*
name|data_ptr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|cam_sglist
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ctlfestart
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|start_ccb
parameter_list|)
block|{
name|struct
name|ctlfe_lun_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|ctlfe_lun_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|softc
operator|->
name|ccbs_alloced
operator|++
expr_stmt|;
name|start_ccb
operator|->
name|ccb_h
operator|.
name|ccb_type
operator|=
name|CTLFE_CCB_DEFAULT
expr_stmt|;
name|ccb_h
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|softc
operator|->
name|work_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb_h
operator|==
name|NULL
condition|)
block|{
name|softc
operator|->
name|ccbs_freed
operator|++
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|start_ccb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|ccb_accept_tio
modifier|*
name|atio
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|uint8_t
modifier|*
name|data_ptr
decl_stmt|;
name|uint32_t
name|dxfer_len
decl_stmt|;
name|ccb_flags
name|flags
decl_stmt|;
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|uint8_t
name|scsi_status
decl_stmt|;
comment|/* Take the ATIO off the work queue */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|softc
operator|->
name|work_queue
argument_list|,
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|atio
operator|=
operator|(
expr|struct
name|ccb_accept_tio
operator|*
operator|)
name|ccb_h
expr_stmt|;
name|io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ccb_h
operator|->
name|io_ptr
expr_stmt|;
name|csio
operator|=
operator|&
name|start_ccb
operator|->
name|csio
expr_stmt|;
name|flags
operator|=
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
operator|(
name|CAM_DIS_DISCONNECT
operator||
name|CAM_TAG_ACTION_VALID
operator||
name|CAM_DIR_MASK
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|io
operator|==
name|NULL
operator|)
operator|||
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|!=
name|CTL_STATUS_NONE
condition|)
block|{
comment|/* 			 * We're done, send status back. 			 */
name|flags
operator||=
name|CAM_SEND_STATUS
expr_stmt|;
if|if
condition|(
name|io
operator|==
name|NULL
condition|)
block|{
name|scsi_status
operator|=
name|SCSI_STATUS_BUSY
expr_stmt|;
name|csio
operator|->
name|sense_len
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ABORT
operator|)
operator|&&
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ABORT_STATUS
operator|)
operator|==
literal|0
condition|)
block|{
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&=
operator|~
name|CTL_FLAG_STATUS_QUEUED
expr_stmt|;
comment|/* 				 * If this command was aborted, we don't 				 * need to send status back to the SIM. 				 * Just free the CTIO and ctl_io, and 				 * recycle the ATIO back to the SIM. 				 */
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"%s: aborted "
literal|"command 0x%04x discarded\n"
argument_list|,
name|__func__
argument_list|,
name|io
operator|->
name|scsiio
operator|.
name|tag_num
argument_list|)
expr_stmt|;
name|ctl_free_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
comment|/* 				 * For a wildcard attachment, commands can 				 * come in with a specific target/lun.  Reset 				 * the target and LUN fields back to the 				 * wildcard values before we send them back 				 * down to the SIM.  The SIM has a wildcard 				 * LUN enabled, not whatever target/lun  				 * these happened to be. 				 */
if|if
condition|(
name|softc
operator|->
name|flags
operator|&
name|CTLFE_LUN_WILDCARD
condition|)
block|{
name|atio
operator|->
name|ccb_h
operator|.
name|target_id
operator|=
name|CAM_TARGET_WILDCARD
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|target_lun
operator|=
name|CAM_LUN_WILDCARD
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|atio
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|!=
literal|0
condition|)
block|{
name|cam_release_devq
argument_list|(
name|periph
operator|->
name|path
argument_list|,
comment|/*relsim_flags*/
literal|0
argument_list|,
comment|/*reduction*/
literal|0
argument_list|,
comment|/*timeout*/
literal|0
argument_list|,
comment|/*getcount_only*/
literal|0
argument_list|)
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_DEV_QFRZN
expr_stmt|;
block|}
name|ccb_h
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|softc
operator|->
name|work_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|atio
operator|->
name|ccb_h
operator|.
name|func_code
operator|!=
name|XPT_ACCEPT_TARGET_IO
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"%s: func_code "
literal|"is %#x\n"
argument_list|,
name|__func__
argument_list|,
name|atio
operator|->
name|ccb_h
operator|.
name|func_code
argument_list|)
expr_stmt|;
block|}
name|start_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_ABORT
expr_stmt|;
name|start_ccb
operator|->
name|cab
operator|.
name|abort_ccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|atio
expr_stmt|;
comment|/* Tell the SIM that we've aborted this ATIO */
name|xpt_action
argument_list|(
name|start_ccb
argument_list|)
expr_stmt|;
name|softc
operator|->
name|ccbs_freed
operator|++
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|start_ccb
argument_list|)
expr_stmt|;
comment|/* 				 * Send the ATIO back down to the SIM. 				 */
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|atio
argument_list|)
expr_stmt|;
name|softc
operator|->
name|atios_sent
operator|++
expr_stmt|;
comment|/* 				 * If we still have work to do, ask for 				 * another CCB.  Otherwise, deactivate our 				 * callout. 				 */
if|if
condition|(
name|ccb_h
operator|!=
name|NULL
condition|)
name|xpt_schedule
argument_list|(
name|periph
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
else|else
name|callout_stop
argument_list|(
operator|&
name|softc
operator|->
name|dma_callout
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&=
operator|~
name|CTL_FLAG_STATUS_QUEUED
expr_stmt|;
name|scsi_status
operator|=
name|io
operator|->
name|scsiio
operator|.
name|scsi_status
expr_stmt|;
name|csio
operator|->
name|sense_len
operator|=
name|io
operator|->
name|scsiio
operator|.
name|sense_len
expr_stmt|;
block|}
name|data_ptr
operator|=
name|NULL
expr_stmt|;
name|dxfer_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|io
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: tag %04x io is NULL\n"
argument_list|,
name|__func__
argument_list|,
name|atio
operator|->
name|tag_id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|CTLFEDEBUG
name|printf
argument_list|(
literal|"%s: tag %04x status %x\n"
argument_list|,
name|__func__
argument_list|,
name|atio
operator|->
name|tag_id
argument_list|,
name|io
operator|->
name|io_hdr
operator|.
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|csio
operator|->
name|sglist_cnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|csio
operator|->
name|sense_len
operator|!=
literal|0
condition|)
block|{
name|csio
operator|->
name|sense_data
operator|=
name|io
operator|->
name|scsiio
operator|.
name|sense_data
expr_stmt|;
name|flags
operator||=
name|CAM_SEND_SENSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scsi_status
operator|==
name|SCSI_STATUS_CHECK_COND
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"%s: check condition "
literal|"with no sense\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|struct
name|ctlfe_lun_cmd_info
modifier|*
name|cmd_info
decl_stmt|;
comment|/* 			 * Datamove call, we need to setup the S/G list.  			 */
name|cmd_info
operator|=
operator|(
expr|struct
name|ctlfe_lun_cmd_info
operator|*
operator|)
name|io
operator|->
name|io_hdr
operator|.
name|port_priv
expr_stmt|;
name|KASSERT
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cmd_info
argument_list|)
operator|<
name|CTL_PORT_PRIV_SIZE
argument_list|,
operator|(
literal|"%s: sizeof(struct ctlfe_lun_cmd_info) %zd< "
literal|"CTL_PORT_PRIV_SIZE %d"
operator|,
name|__func__
operator|,
sizeof|sizeof
argument_list|(
operator|*
name|cmd_info
argument_list|)
operator|,
name|CTL_PORT_PRIV_SIZE
operator|)
argument_list|)
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&=
operator|~
name|CTL_FLAG_DMA_QUEUED
expr_stmt|;
comment|/* 			 * Need to zero this, in case it has been used for 			 * a previous datamove for this particular I/O. 			 */
name|bzero
argument_list|(
name|cmd_info
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cmd_info
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_status
operator|=
literal|0
expr_stmt|;
name|csio
operator|->
name|cdb_len
operator|=
name|atio
operator|->
name|cdb_len
expr_stmt|;
name|ctlfedata
argument_list|(
name|softc
argument_list|,
name|io
argument_list|,
operator|&
name|flags
argument_list|,
operator|&
name|data_ptr
argument_list|,
operator|&
name|dxfer_len
argument_list|,
operator|&
name|csio
operator|->
name|sglist_cnt
argument_list|)
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|ext_data_filled
operator|+=
name|dxfer_len
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|scsiio
operator|.
name|ext_data_filled
operator|>
name|io
operator|->
name|scsiio
operator|.
name|kern_total_len
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"%s: tag 0x%04x "
literal|"fill len %u> total %u\n"
argument_list|,
name|__func__
argument_list|,
name|io
operator|->
name|scsiio
operator|.
name|tag_num
argument_list|,
name|io
operator|->
name|scsiio
operator|.
name|ext_data_filled
argument_list|,
name|io
operator|->
name|scsiio
operator|.
name|kern_total_len
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|CTLFEDEBUG
name|printf
argument_list|(
literal|"%s: %s: tag %04x flags %x ptr %p len %u\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|flags
operator|&
name|CAM_SEND_STATUS
operator|)
condition|?
literal|"done"
else|:
literal|"datamove"
argument_list|,
name|atio
operator|->
name|tag_id
argument_list|,
name|flags
argument_list|,
name|data_ptr
argument_list|,
name|dxfer_len
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * Valid combinations: 		 *  - CAM_SEND_STATUS, CAM_DATA_SG = 0, dxfer_len = 0, 		 *    sglist_cnt = 0 		 *  - CAM_SEND_STATUS = 0, CAM_DATA_SG = 0, dxfer_len != 0, 		 *    sglist_cnt = 0  		 *  - CAM_SEND_STATUS = 0, CAM_DATA_SG, dxfer_len != 0, 		 *    sglist_cnt != 0 		 */
ifdef|#
directive|ifdef
name|CTLFEDEBUG
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
name|CAM_SEND_STATUS
operator|)
operator|&&
operator|(
operator|(
operator|(
name|flags
operator|&
name|CAM_DATA_SG
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|dxfer_len
operator|!=
literal|0
operator|)
operator|||
operator|(
name|csio
operator|->
name|sglist_cnt
operator|!=
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
operator|(
operator|(
name|flags
operator|&
name|CAM_SEND_STATUS
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|dxfer_len
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
operator|(
name|flags
operator|&
name|CAM_DATA_SG
operator|)
operator|&&
operator|(
name|csio
operator|->
name|sglist_cnt
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
operator|(
operator|(
name|flags
operator|&
name|CAM_DATA_SG
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|csio
operator|->
name|sglist_cnt
operator|!=
literal|0
operator|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: tag %04x cdb %02x flags %#x dxfer_len "
literal|"%d sg %u\n"
argument_list|,
name|__func__
argument_list|,
name|atio
operator|->
name|tag_id
argument_list|,
name|atio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
argument_list|,
name|flags
argument_list|,
name|dxfer_len
argument_list|,
name|csio
operator|->
name|sglist_cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: tag %04x io status %#x\n"
argument_list|,
name|__func__
argument_list|,
name|atio
operator|->
name|tag_id
argument_list|,
name|io
operator|->
name|io_hdr
operator|.
name|status
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s: tag %04x no associated io\n"
argument_list|,
name|__func__
argument_list|,
name|atio
operator|->
name|tag_id
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|cam_fill_ctio
argument_list|(
name|csio
argument_list|,
comment|/*retries*/
literal|2
argument_list|,
name|ctlfedone
argument_list|,
name|flags
argument_list|,
operator|(
name|flags
operator|&
name|CAM_TAG_ACTION_VALID
operator|)
condition|?
name|MSG_SIMPLE_Q_TAG
else|:
literal|0
argument_list|,
name|atio
operator|->
name|tag_id
argument_list|,
name|atio
operator|->
name|init_id
argument_list|,
name|scsi_status
argument_list|,
comment|/*data_ptr*/
name|data_ptr
argument_list|,
comment|/*dxfer_len*/
name|dxfer_len
argument_list|,
comment|/*timeout*/
literal|5
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|start_ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_UNLOCKED
expr_stmt|;
name|start_ccb
operator|->
name|ccb_h
operator|.
name|ccb_atio
operator|=
name|atio
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
name|CAM_SEND_STATUS
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|io
operator|!=
name|NULL
operator|)
condition|)
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_DMA_INPROG
expr_stmt|;
name|softc
operator|->
name|ctios_sent
operator|++
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|xpt_action
argument_list|(
name|start_ccb
argument_list|)
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|atio
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|!=
literal|0
condition|)
block|{
name|cam_release_devq
argument_list|(
name|periph
operator|->
name|path
argument_list|,
comment|/*relsim_flags*/
literal|0
argument_list|,
comment|/*reduction*/
literal|0
argument_list|,
comment|/*timeout*/
literal|0
argument_list|,
comment|/*getcount_only*/
literal|0
argument_list|)
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_DEV_QFRZN
expr_stmt|;
block|}
name|ccb_h
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|softc
operator|->
name|work_queue
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we still have work to do, ask for another CCB.  Otherwise, 	 * deactivate our callout. 	 */
if|if
condition|(
name|ccb_h
operator|!=
name|NULL
condition|)
name|xpt_schedule
argument_list|(
name|periph
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
else|else
name|callout_stop
argument_list|(
operator|&
name|softc
operator|->
name|dma_callout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctlfe_free_ccb
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|ctlfe_lun_softc
modifier|*
name|softc
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|ctlfe_lun_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_ACCEPT_TARGET_IO
case|:
name|softc
operator|->
name|atios_returned
operator|++
expr_stmt|;
break|break;
case|case
name|XPT_IMMEDIATE_NOTIFY
case|:
case|case
name|XPT_NOTIFY_ACKNOWLEDGE
case|:
name|softc
operator|->
name|inots_returned
operator|++
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|free
argument_list|(
name|ccb
argument_list|,
name|M_CTLFE
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|softc
operator|->
name|atios_returned
operator|<=
name|softc
operator|->
name|atios_sent
argument_list|,
operator|(
literal|"%s: "
literal|"atios_returned %ju> atios_sent %ju"
operator|,
name|__func__
operator|,
name|softc
operator|->
name|atios_returned
operator|,
name|softc
operator|->
name|atios_sent
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|softc
operator|->
name|inots_returned
operator|<=
name|softc
operator|->
name|inots_sent
argument_list|,
operator|(
literal|"%s: "
literal|"inots_returned %ju> inots_sent %ju"
operator|,
name|__func__
operator|,
name|softc
operator|->
name|inots_returned
operator|,
name|softc
operator|->
name|inots_sent
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If we have received all of our CCBs, we can release our 	 * reference on the peripheral driver.  It will probably go away 	 * now. 	 */
if|if
condition|(
operator|(
name|softc
operator|->
name|atios_returned
operator|==
name|softc
operator|->
name|atios_sent
operator|)
operator|&&
operator|(
name|softc
operator|->
name|inots_returned
operator|==
name|softc
operator|->
name|inots_sent
operator|)
condition|)
block|{
name|cam_periph_release_locked
argument_list|(
name|periph
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ctlfe_adjust_cdb
parameter_list|(
name|struct
name|ccb_accept_tio
modifier|*
name|atio
parameter_list|,
name|uint32_t
name|offset
parameter_list|)
block|{
name|uint64_t
name|lba
decl_stmt|;
name|uint32_t
name|num_blocks
decl_stmt|,
name|nbc
decl_stmt|;
name|uint8_t
modifier|*
name|cmdbyt
init|=
operator|(
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_POINTER
operator|)
condition|?
name|atio
operator|->
name|cdb_io
operator|.
name|cdb_ptr
else|:
name|atio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
decl_stmt|;
name|nbc
operator|=
name|offset
operator|>>
literal|9
expr_stmt|;
comment|/* ASSUMING 512 BYTE BLOCKS */
switch|switch
condition|(
name|cmdbyt
index|[
literal|0
index|]
condition|)
block|{
case|case
name|READ_6
case|:
case|case
name|WRITE_6
case|:
block|{
name|struct
name|scsi_rw_6
modifier|*
name|cdb
init|=
operator|(
expr|struct
name|scsi_rw_6
operator|*
operator|)
name|cmdbyt
decl_stmt|;
name|lba
operator|=
name|scsi_3btoul
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
name|lba
operator|&=
literal|0x1fffff
expr_stmt|;
name|num_blocks
operator|=
name|cdb
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|num_blocks
operator|==
literal|0
condition|)
name|num_blocks
operator|=
literal|256
expr_stmt|;
name|lba
operator|+=
name|nbc
expr_stmt|;
name|num_blocks
operator|-=
name|nbc
expr_stmt|;
name|scsi_ulto3b
argument_list|(
name|lba
argument_list|,
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
name|cdb
operator|->
name|length
operator|=
name|num_blocks
expr_stmt|;
break|break;
block|}
case|case
name|READ_10
case|:
case|case
name|WRITE_10
case|:
block|{
name|struct
name|scsi_rw_10
modifier|*
name|cdb
init|=
operator|(
expr|struct
name|scsi_rw_10
operator|*
operator|)
name|cmdbyt
decl_stmt|;
name|lba
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
name|num_blocks
operator|=
name|scsi_2btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
name|lba
operator|+=
name|nbc
expr_stmt|;
name|num_blocks
operator|-=
name|nbc
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|lba
argument_list|,
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|num_blocks
argument_list|,
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|READ_12
case|:
case|case
name|WRITE_12
case|:
block|{
name|struct
name|scsi_rw_12
modifier|*
name|cdb
init|=
operator|(
expr|struct
name|scsi_rw_12
operator|*
operator|)
name|cmdbyt
decl_stmt|;
name|lba
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
name|num_blocks
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
name|lba
operator|+=
name|nbc
expr_stmt|;
name|num_blocks
operator|-=
name|nbc
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|lba
argument_list|,
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|num_blocks
argument_list|,
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|READ_16
case|:
case|case
name|WRITE_16
case|:
case|case
name|WRITE_ATOMIC_16
case|:
block|{
name|struct
name|scsi_rw_16
modifier|*
name|cdb
init|=
operator|(
expr|struct
name|scsi_rw_16
operator|*
operator|)
name|cmdbyt
decl_stmt|;
name|lba
operator|=
name|scsi_8btou64
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
name|num_blocks
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
name|lba
operator|+=
name|nbc
expr_stmt|;
name|num_blocks
operator|-=
name|nbc
expr_stmt|;
name|scsi_u64to8b
argument_list|(
name|lba
argument_list|,
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|num_blocks
argument_list|,
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
return|return
operator|-
literal|1
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctlfedone
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|done_ccb
parameter_list|)
block|{
name|struct
name|ctlfe_lun_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ctlfe_softc
modifier|*
name|bus_softc
decl_stmt|;
name|struct
name|ccb_accept_tio
modifier|*
name|atio
init|=
name|NULL
decl_stmt|;
name|union
name|ctl_io
modifier|*
name|io
init|=
name|NULL
decl_stmt|;
name|struct
name|mtx
modifier|*
name|mtx
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_UNLOCKED
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"CCB in ctlfedone() without CAM_UNLOCKED flag"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CTLFE_DEBUG
name|printf
argument_list|(
literal|"%s: entered, func_code = %#x, type = %#lx\n"
argument_list|,
name|__func__
argument_list|,
name|done_ccb
operator|->
name|ccb_h
operator|.
name|func_code
argument_list|,
name|done_ccb
operator|->
name|ccb_h
operator|.
name|ccb_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|softc
operator|=
operator|(
expr|struct
name|ctlfe_lun_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|bus_softc
operator|=
name|softc
operator|->
name|parent_softc
expr_stmt|;
name|mtx
operator|=
name|cam_periph_mtx
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
name|mtx
argument_list|)
expr_stmt|;
comment|/* 	 * If the peripheral is invalid, ATIOs and immediate notify CCBs 	 * need to be freed.  Most of the ATIOs and INOTs that come back 	 * will be CCBs that are being returned from the SIM as a result of 	 * our disabling the LUN. 	 * 	 * Other CCB types are handled in their respective cases below. 	 */
if|if
condition|(
name|periph
operator|->
name|flags
operator|&
name|CAM_PERIPH_INVALID
condition|)
block|{
switch|switch
condition|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_ACCEPT_TARGET_IO
case|:
case|case
name|XPT_IMMEDIATE_NOTIFY
case|:
case|case
name|XPT_NOTIFY_ACKNOWLEDGE
case|:
name|ctlfe_free_ccb
argument_list|(
name|periph
argument_list|,
name|done_ccb
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
default|default:
break|break;
block|}
block|}
switch|switch
condition|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_ACCEPT_TARGET_IO
case|:
block|{
name|atio
operator|=
operator|&
name|done_ccb
operator|->
name|atio
expr_stmt|;
name|softc
operator|->
name|atios_returned
operator|++
expr_stmt|;
name|resubmit
label|:
comment|/* 		 * Allocate a ctl_io, pass it to CTL, and wait for the 		 * datamove or done. 		 */
name|io
operator|=
name|ctl_alloc_io
argument_list|(
name|bus_softc
operator|->
name|port
operator|.
name|ctl_pool_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|==
name|NULL
condition|)
block|{
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator|&=
operator|~
name|CAM_DIR_MASK
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DIR_NONE
expr_stmt|;
name|printf
argument_list|(
literal|"%s: ctl_alloc_io failed!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* 			 * XXX KDM need to set SCSI_STATUS_BUSY, but there 			 * is no field in the ATIO structure to do that, 			 * and we aren't able to allocate a ctl_io here. 			 * What to do? 			 */
name|atio
operator|->
name|sense_len
operator|=
literal|0
expr_stmt|;
name|done_ccb
operator|->
name|ccb_h
operator|.
name|io_ptr
operator|=
name|NULL
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|softc
operator|->
name|work_queue
argument_list|,
operator|&
name|atio
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|xpt_schedule
argument_list|(
name|periph
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
name|mtx_unlock
argument_list|(
name|mtx
argument_list|)
expr_stmt|;
name|ctl_zero_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
comment|/* Save pointers on both sides */
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_FRONTEND
index|]
operator|.
name|ptr
operator|=
name|done_ccb
expr_stmt|;
name|done_ccb
operator|->
name|ccb_h
operator|.
name|io_ptr
operator|=
name|io
expr_stmt|;
comment|/* 		 * Only SCSI I/O comes down this path, resets, etc. come 		 * down the immediate notify path below. 		 */
name|io
operator|->
name|io_hdr
operator|.
name|io_type
operator|=
name|CTL_IO_SCSI
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|initid
operator|.
name|id
operator|=
name|atio
operator|->
name|init_id
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
operator|=
name|bus_softc
operator|->
name|port
operator|.
name|targ_port
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_target
operator|.
name|id
operator|=
name|atio
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_lun
operator|=
name|atio
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|tag_num
operator|=
name|atio
operator|->
name|tag_id
expr_stmt|;
switch|switch
condition|(
name|atio
operator|->
name|tag_action
condition|)
block|{
case|case
name|CAM_TAG_ACTION_NONE
case|:
name|io
operator|->
name|scsiio
operator|.
name|tag_type
operator|=
name|CTL_TAG_UNTAGGED
expr_stmt|;
break|break;
case|case
name|MSG_SIMPLE_TASK
case|:
name|io
operator|->
name|scsiio
operator|.
name|tag_type
operator|=
name|CTL_TAG_SIMPLE
expr_stmt|;
break|break;
case|case
name|MSG_HEAD_OF_QUEUE_TASK
case|:
name|io
operator|->
name|scsiio
operator|.
name|tag_type
operator|=
name|CTL_TAG_HEAD_OF_QUEUE
expr_stmt|;
break|break;
case|case
name|MSG_ORDERED_TASK
case|:
name|io
operator|->
name|scsiio
operator|.
name|tag_type
operator|=
name|CTL_TAG_ORDERED
expr_stmt|;
break|break;
case|case
name|MSG_ACA_TASK
case|:
name|io
operator|->
name|scsiio
operator|.
name|tag_type
operator|=
name|CTL_TAG_ACA
expr_stmt|;
break|break;
default|default:
name|io
operator|->
name|scsiio
operator|.
name|tag_type
operator|=
name|CTL_TAG_UNTAGGED
expr_stmt|;
name|printf
argument_list|(
literal|"%s: unhandled tag type %#x!!\n"
argument_list|,
name|__func__
argument_list|,
name|atio
operator|->
name|tag_action
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|atio
operator|->
name|cdb_len
operator|>
sizeof|sizeof
argument_list|(
name|io
operator|->
name|scsiio
operator|.
name|cdb
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: WARNING: CDB len %d> ctl_io space %zd\n"
argument_list|,
name|__func__
argument_list|,
name|atio
operator|->
name|cdb_len
argument_list|,
sizeof|sizeof
argument_list|(
name|io
operator|->
name|scsiio
operator|.
name|cdb
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|io
operator|->
name|scsiio
operator|.
name|cdb_len
operator|=
name|min
argument_list|(
name|atio
operator|->
name|cdb_len
argument_list|,
sizeof|sizeof
argument_list|(
name|io
operator|->
name|scsiio
operator|.
name|cdb
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|atio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|io
operator|->
name|scsiio
operator|.
name|cdb
argument_list|,
name|io
operator|->
name|scsiio
operator|.
name|cdb_len
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CTLFEDEBUG
name|printf
argument_list|(
literal|"%s: %ju:%d:%ju:%d: tag %04x CDB %02x\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|uintmax_t
operator|)
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|initid
operator|.
name|id
argument_list|,
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
argument_list|,
operator|(
name|uintmax_t
operator|)
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_target
operator|.
name|id
argument_list|,
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_lun
argument_list|,
name|io
operator|->
name|scsiio
operator|.
name|tag_num
argument_list|,
name|io
operator|->
name|scsiio
operator|.
name|cdb
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ctl_queue
argument_list|(
name|io
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|XPT_CONT_TARGET_IO
case|:
block|{
name|int
name|srr
init|=
literal|0
decl_stmt|;
name|uint32_t
name|srr_off
init|=
literal|0
decl_stmt|;
name|atio
operator|=
operator|(
expr|struct
name|ccb_accept_tio
operator|*
operator|)
name|done_ccb
operator|->
name|ccb_h
operator|.
name|ccb_atio
expr_stmt|;
name|io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|atio
operator|->
name|ccb_h
operator|.
name|io_ptr
expr_stmt|;
name|softc
operator|->
name|ctios_returned
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|CTLFEDEBUG
name|printf
argument_list|(
literal|"%s: got XPT_CONT_TARGET_IO tag %#x flags %#x\n"
argument_list|,
name|__func__
argument_list|,
name|atio
operator|->
name|tag_id
argument_list|,
name|done_ccb
operator|->
name|ccb_h
operator|.
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * Handle SRR case were the data pointer is pushed back hack 		 */
if|if
condition|(
operator|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_MESSAGE_RECV
operator|&&
name|done_ccb
operator|->
name|csio
operator|.
name|msg_ptr
operator|!=
name|NULL
operator|&&
name|done_ccb
operator|->
name|csio
operator|.
name|msg_ptr
index|[
literal|0
index|]
operator|==
name|MSG_EXTENDED
operator|&&
name|done_ccb
operator|->
name|csio
operator|.
name|msg_ptr
index|[
literal|1
index|]
operator|==
literal|5
operator|&&
name|done_ccb
operator|->
name|csio
operator|.
name|msg_ptr
index|[
literal|2
index|]
operator|==
literal|0
condition|)
block|{
name|srr
operator|=
literal|1
expr_stmt|;
name|srr_off
operator|=
operator|(
name|done_ccb
operator|->
name|csio
operator|.
name|msg_ptr
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|done_ccb
operator|->
name|csio
operator|.
name|msg_ptr
index|[
literal|4
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|done_ccb
operator|->
name|csio
operator|.
name|msg_ptr
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|done_ccb
operator|->
name|csio
operator|.
name|msg_ptr
index|[
literal|6
index|]
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|srr
operator|&&
operator|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SEND_STATUS
operator|)
condition|)
block|{
comment|/* 			 * If status was being sent, the back end data is now 			 * history. Hack it up and resubmit a new command with 			 * the CDB adjusted. If the SIM does the right thing, 			 * all of the resid math should work. 			 */
name|softc
operator|->
name|ccbs_freed
operator|++
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
name|ctl_free_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctlfe_adjust_cdb
argument_list|(
name|atio
argument_list|,
name|srr_off
argument_list|)
operator|==
literal|0
condition|)
block|{
name|done_ccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|atio
expr_stmt|;
goto|goto
name|resubmit
goto|;
block|}
comment|/* 			 * Fall through to doom.... 			 */
block|}
elseif|else
if|if
condition|(
name|srr
condition|)
block|{
comment|/* 			 * If we have an srr and we're still sending data, we 			 * should be able to adjust offsets and cycle again. 			 */
name|io
operator|->
name|scsiio
operator|.
name|kern_rel_offset
operator|=
name|io
operator|->
name|scsiio
operator|.
name|ext_data_filled
operator|=
name|srr_off
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|ext_data_len
operator|=
name|io
operator|->
name|scsiio
operator|.
name|kern_total_len
operator|-
name|io
operator|->
name|scsiio
operator|.
name|kern_rel_offset
expr_stmt|;
name|softc
operator|->
name|ccbs_freed
operator|++
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|io_hdr
operator|.
name|status
operator|=
name|CTL_STATUS_NONE
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|softc
operator|->
name|work_queue
argument_list|,
operator|&
name|atio
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|xpt_schedule
argument_list|(
name|periph
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * If we were sending status back to the initiator, free up 		 * resources.  If we were doing a datamove, call the 		 * datamove done routine. 		 */
if|if
condition|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SEND_STATUS
condition|)
block|{
name|softc
operator|->
name|ccbs_freed
operator|++
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
name|ctl_free_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
comment|/* 			 * For a wildcard attachment, commands can come in 			 * with a specific target/lun.  Reset the target 			 * and LUN fields back to the wildcard values before 			 * we send them back down to the SIM.  The SIM has 			 * a wildcard LUN enabled, not whatever target/lun 			 * these happened to be. 			 */
if|if
condition|(
name|softc
operator|->
name|flags
operator|&
name|CTLFE_LUN_WILDCARD
condition|)
block|{
name|atio
operator|->
name|ccb_h
operator|.
name|target_id
operator|=
name|CAM_TARGET_WILDCARD
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|target_lun
operator|=
name|CAM_LUN_WILDCARD
expr_stmt|;
block|}
if|if
condition|(
name|periph
operator|->
name|flags
operator|&
name|CAM_PERIPH_INVALID
condition|)
block|{
name|ctlfe_free_ccb
argument_list|(
name|periph
argument_list|,
operator|(
expr|union
name|ccb
operator|*
operator|)
name|atio
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|softc
operator|->
name|atios_sent
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
name|mtx
argument_list|)
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|atio
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|struct
name|ctlfe_lun_cmd_info
modifier|*
name|cmd_info
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|csio
operator|=
operator|&
name|done_ccb
operator|->
name|csio
expr_stmt|;
name|cmd_info
operator|=
operator|(
expr|struct
name|ctlfe_lun_cmd_info
operator|*
operator|)
name|io
operator|->
name|io_hdr
operator|.
name|port_priv
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&=
operator|~
name|CTL_FLAG_DMA_INPROG
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|ext_data_len
operator|+=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|scsiio
operator|.
name|ext_data_len
operator|>
name|io
operator|->
name|scsiio
operator|.
name|kern_total_len
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"%s: tag 0x%04x "
literal|"done len %u> total %u sent %u\n"
argument_list|,
name|__func__
argument_list|,
name|io
operator|->
name|scsiio
operator|.
name|tag_num
argument_list|,
name|io
operator|->
name|scsiio
operator|.
name|ext_data_len
argument_list|,
name|io
operator|->
name|scsiio
operator|.
name|kern_total_len
argument_list|,
name|io
operator|->
name|scsiio
operator|.
name|ext_data_filled
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Translate CAM status to CTL status.  Success 			 * does not change the overall, ctl_io status.  In 			 * that case we just set port_status to 0.  If we 			 * have a failure, though, set a data phase error 			 * for the overall ctl_io. 			 */
switch|switch
condition|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
condition|)
block|{
case|case
name|CAM_REQ_CMP
case|:
name|io
operator|->
name|io_hdr
operator|.
name|port_status
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
comment|/* 				 * XXX KDM we probably need to figure out a 				 * standard set of errors that the SIM 				 * drivers should return in the event of a 				 * data transfer failure.  A data phase 				 * error will at least point the user to a 				 * data transfer error of some sort. 				 * Hopefully the SIM printed out some 				 * additional information to give the user 				 * a clue what happened. 				 */
name|io
operator|->
name|io_hdr
operator|.
name|port_status
operator|=
literal|0xbad1
expr_stmt|;
name|ctl_set_data_phase_error
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
comment|/* 				 * XXX KDM figure out residual. 				 */
break|break;
block|}
comment|/* 			 * If we had to break this S/G list into multiple 			 * pieces, figure out where we are in the list, and 			 * continue sending pieces if necessary. 			 */
if|if
condition|(
operator|(
name|cmd_info
operator|->
name|flags
operator|&
name|CTLFE_CMD_PIECEWISE
operator|)
operator|&&
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|port_status
operator|==
literal|0
operator|)
condition|)
block|{
name|ccb_flags
name|flags
decl_stmt|;
name|uint8_t
name|scsi_status
decl_stmt|;
name|uint8_t
modifier|*
name|data_ptr
decl_stmt|;
name|uint32_t
name|dxfer_len
decl_stmt|;
name|flags
operator|=
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
operator|(
name|CAM_DIS_DISCONNECT
operator||
name|CAM_TAG_ACTION_VALID
operator|)
expr_stmt|;
name|ctlfedata
argument_list|(
name|softc
argument_list|,
name|io
argument_list|,
operator|&
name|flags
argument_list|,
operator|&
name|data_ptr
argument_list|,
operator|&
name|dxfer_len
argument_list|,
operator|&
name|csio
operator|->
name|sglist_cnt
argument_list|)
expr_stmt|;
name|scsi_status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
name|CAM_SEND_STATUS
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|dxfer_len
operator|==
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: tag %04x no status or "
literal|"len cdb = %02x\n"
argument_list|,
name|__func__
argument_list|,
name|atio
operator|->
name|tag_id
argument_list|,
name|atio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: tag %04x io status %#x\n"
argument_list|,
name|__func__
argument_list|,
name|atio
operator|->
name|tag_id
argument_list|,
name|io
operator|->
name|io_hdr
operator|.
name|status
argument_list|)
expr_stmt|;
block|}
name|cam_fill_ctio
argument_list|(
name|csio
argument_list|,
comment|/*retries*/
literal|2
argument_list|,
name|ctlfedone
argument_list|,
name|flags
argument_list|,
operator|(
name|flags
operator|&
name|CAM_TAG_ACTION_VALID
operator|)
condition|?
name|MSG_SIMPLE_Q_TAG
else|:
literal|0
argument_list|,
name|atio
operator|->
name|tag_id
argument_list|,
name|atio
operator|->
name|init_id
argument_list|,
name|scsi_status
argument_list|,
comment|/*data_ptr*/
name|data_ptr
argument_list|,
comment|/*dxfer_len*/
name|dxfer_len
argument_list|,
comment|/*timeout*/
literal|5
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_UNLOCKED
expr_stmt|;
name|csio
operator|->
name|resid
operator|=
literal|0
expr_stmt|;
name|csio
operator|->
name|ccb_h
operator|.
name|ccb_atio
operator|=
name|atio
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_DMA_INPROG
expr_stmt|;
name|softc
operator|->
name|ctios_sent
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
name|mtx
argument_list|)
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|csio
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Release the CTIO.  The ATIO will be sent back 				 * down to the SIM once we send status. 				 */
name|softc
operator|->
name|ccbs_freed
operator|++
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
name|mtx
argument_list|)
expr_stmt|;
comment|/* Call the backend move done callback */
name|io
operator|->
name|scsiio
operator|.
name|be_move_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
break|break;
block|}
case|case
name|XPT_IMMEDIATE_NOTIFY
case|:
block|{
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|struct
name|ccb_immediate_notify
modifier|*
name|inot
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|int
name|frozen
decl_stmt|;
name|inot
operator|=
operator|&
name|done_ccb
operator|->
name|cin1
expr_stmt|;
name|softc
operator|->
name|inots_returned
operator|++
expr_stmt|;
name|frozen
operator|=
operator|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|!=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"%s: got XPT_IMMEDIATE_NOTIFY status %#x tag %#x "
literal|"seq %#x\n"
argument_list|,
name|__func__
argument_list|,
name|inot
operator|->
name|ccb_h
operator|.
name|status
argument_list|,
name|inot
operator|->
name|tag_id
argument_list|,
name|inot
operator|->
name|seq_id
argument_list|)
expr_stmt|;
name|io
operator|=
name|ctl_alloc_io
argument_list|(
name|bus_softc
operator|->
name|port
operator|.
name|ctl_pool_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|!=
name|NULL
condition|)
block|{
name|int
name|send_ctl_io
decl_stmt|;
name|send_ctl_io
operator|=
literal|1
expr_stmt|;
name|ctl_zero_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|io_type
operator|=
name|CTL_IO_TASK
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_FRONTEND
index|]
operator|.
name|ptr
operator|=
name|done_ccb
expr_stmt|;
name|inot
operator|->
name|ccb_h
operator|.
name|io_ptr
operator|=
name|io
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|initid
operator|.
name|id
operator|=
name|inot
operator|->
name|initiator_id
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
operator|=
name|bus_softc
operator|->
name|port
operator|.
name|targ_port
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_target
operator|.
name|id
operator|=
name|inot
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_lun
operator|=
name|inot
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
comment|/* XXX KDM should this be the tag_id? */
name|io
operator|->
name|taskio
operator|.
name|tag_num
operator|=
name|inot
operator|->
name|seq_id
expr_stmt|;
name|status
operator|=
name|inot
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
expr_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|CAM_SCSI_BUS_RESET
case|:
name|io
operator|->
name|taskio
operator|.
name|task_action
operator|=
name|CTL_TASK_BUS_RESET
expr_stmt|;
break|break;
case|case
name|CAM_BDR_SENT
case|:
name|io
operator|->
name|taskio
operator|.
name|task_action
operator|=
name|CTL_TASK_TARGET_RESET
expr_stmt|;
break|break;
case|case
name|CAM_MESSAGE_RECV
case|:
switch|switch
condition|(
name|inot
operator|->
name|arg
condition|)
block|{
case|case
name|MSG_ABORT_TASK_SET
case|:
comment|/* 					 * XXX KDM this isn't currently 					 * supported by CTL.  It ends up 					 * being a no-op. 					 */
name|io
operator|->
name|taskio
operator|.
name|task_action
operator|=
name|CTL_TASK_ABORT_TASK_SET
expr_stmt|;
break|break;
case|case
name|MSG_TARGET_RESET
case|:
name|io
operator|->
name|taskio
operator|.
name|task_action
operator|=
name|CTL_TASK_TARGET_RESET
expr_stmt|;
break|break;
case|case
name|MSG_ABORT_TASK
case|:
name|io
operator|->
name|taskio
operator|.
name|task_action
operator|=
name|CTL_TASK_ABORT_TASK
expr_stmt|;
break|break;
case|case
name|MSG_LOGICAL_UNIT_RESET
case|:
name|io
operator|->
name|taskio
operator|.
name|task_action
operator|=
name|CTL_TASK_LUN_RESET
expr_stmt|;
break|break;
case|case
name|MSG_CLEAR_TASK_SET
case|:
comment|/* 					 * XXX KDM this isn't currently 					 * supported by CTL.  It ends up 					 * being a no-op. 					 */
name|io
operator|->
name|taskio
operator|.
name|task_action
operator|=
name|CTL_TASK_CLEAR_TASK_SET
expr_stmt|;
break|break;
case|case
name|MSG_CLEAR_ACA
case|:
name|io
operator|->
name|taskio
operator|.
name|task_action
operator|=
name|CTL_TASK_CLEAR_ACA
expr_stmt|;
break|break;
case|case
name|MSG_NOOP
case|:
name|send_ctl_io
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"%s: "
literal|"unsupported message 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|inot
operator|->
name|arg
argument_list|)
expr_stmt|;
name|send_ctl_io
operator|=
literal|0
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|CAM_REQ_ABORTED
case|:
comment|/* 				 * This request was sent back by the driver. 				 * XXX KDM what do we do here? 				 */
name|send_ctl_io
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CAM_REQ_INVALID
case|:
case|case
name|CAM_PROVIDE_FAIL
case|:
default|default:
comment|/* 				 * We should only get here if we're talking 				 * to a talking to a SIM that is target 				 * capable but supports the old API.  In 				 * that case, we need to just free the CCB. 				 * If we actually send a notify acknowledge, 				 * it will send that back with an error as 				 * well. 				 */
if|if
condition|(
operator|(
name|status
operator|!=
name|CAM_REQ_INVALID
operator|)
operator|&&
operator|(
name|status
operator|!=
name|CAM_PROVIDE_FAIL
operator|)
condition|)
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"%s: "
literal|"unsupported CAM status "
literal|"0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|ctl_free_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|ctlfe_free_ccb
argument_list|(
name|periph
argument_list|,
name|done_ccb
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|send_ctl_io
operator|!=
literal|0
condition|)
block|{
name|ctl_queue
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctl_free_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INPROG
expr_stmt|;
name|done_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_NOTIFY_ACKNOWLEDGE
expr_stmt|;
name|xpt_action
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"%s: could not allocate "
literal|"ctl_io for immediate notify!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* requeue this to the adapter */
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INPROG
expr_stmt|;
name|done_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_NOTIFY_ACKNOWLEDGE
expr_stmt|;
name|xpt_action
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|frozen
operator|!=
literal|0
condition|)
block|{
name|cam_release_devq
argument_list|(
name|periph
operator|->
name|path
argument_list|,
comment|/*relsim_flags*/
literal|0
argument_list|,
comment|/*opening reduction*/
literal|0
argument_list|,
comment|/*timeout*/
literal|0
argument_list|,
comment|/*getcount_only*/
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|XPT_NOTIFY_ACKNOWLEDGE
case|:
comment|/* 		 * Queue this back down to the SIM as an immediate notify. 		 */
name|done_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_IMMEDIATE_NOTIFY
expr_stmt|;
name|xpt_action
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
name|softc
operator|->
name|inots_sent
operator|++
expr_stmt|;
break|break;
case|case
name|XPT_SET_SIM_KNOB
case|:
case|case
name|XPT_GET_SIM_KNOB
case|:
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: unexpected CCB type %#x"
argument_list|,
name|__func__
argument_list|,
name|done_ccb
operator|->
name|ccb_h
operator|.
name|func_code
argument_list|)
expr_stmt|;
break|break;
block|}
name|out
label|:
name|mtx_unlock
argument_list|(
name|mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctlfe_onoffline
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|online
parameter_list|)
block|{
name|struct
name|ctlfe_softc
modifier|*
name|bus_softc
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|int
name|set_wwnn
decl_stmt|;
name|bus_softc
operator|=
operator|(
expr|struct
name|ctlfe_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|set_wwnn
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|bus_softc
operator|->
name|path_id
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unable to create path!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|ccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ccb
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unable to malloc CCB!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return;
block|}
name|xpt_setup_ccb
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|path
argument_list|,
name|CAM_PRIORITY_NONE
argument_list|)
expr_stmt|;
comment|/* 	 * Copan WWN format: 	 * 	 * Bits 63-60:	0x5		NAA, IEEE registered name 	 * Bits 59-36:	0x000ED5	IEEE Company name assigned to Copan 	 * Bits 35-12:			Copan SSN (Sequential Serial Number) 	 * Bits 11-8:			Type of port: 	 *					1 == N-Port 	 *					2 == F-Port 	 *					3 == NL-Port 	 * Bits 7-0:			0 == Node Name,>0 == Port Number 	 */
if|if
condition|(
name|online
operator|!=
literal|0
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_GET_SIM_KNOB
expr_stmt|;
name|xpt_action
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|knob
operator|.
name|xport_specific
operator|.
name|valid
operator|&
name|KNOB_VALID_ADDRESS
operator|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|RANDOM_WWNN
name|uint64_t
name|random_bits
decl_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"%s: %s current WWNN %#jx\n"
argument_list|,
name|__func__
argument_list|,
name|bus_softc
operator|->
name|port_name
argument_list|,
name|ccb
operator|->
name|knob
operator|.
name|xport_specific
operator|.
name|fc
operator|.
name|wwnn
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: %s current WWPN %#jx\n"
argument_list|,
name|__func__
argument_list|,
name|bus_softc
operator|->
name|port_name
argument_list|,
name|ccb
operator|->
name|knob
operator|.
name|xport_specific
operator|.
name|fc
operator|.
name|wwpn
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RANDOM_WWNN
name|arc4rand
argument_list|(
operator|&
name|random_bits
argument_list|,
sizeof|sizeof
argument_list|(
name|random_bits
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 			 * XXX KDM this is a bit of a kludge for now.  We 			 * take the current WWNN/WWPN from the card, and 			 * replace the company identifier and the NL-Port 			 * indicator and the port number (for the WWPN). 			 * This should be replaced later with ddb_GetWWNN, 			 * or possibly a more centralized scheme.  (It 			 * would be nice to have the WWNN/WWPN for each 			 * port stored in the ctl_port structure.) 			 */
ifdef|#
directive|ifdef
name|RANDOM_WWNN
name|ccb
operator|->
name|knob
operator|.
name|xport_specific
operator|.
name|fc
operator|.
name|wwnn
operator|=
operator|(
name|random_bits
operator|&
literal|0x0000000fffffff00ULL
operator|)
operator||
comment|/* Company ID */
literal|0x5000ED5000000000ULL
operator||
comment|/* NL-Port */
literal|0x0300
expr_stmt|;
name|ccb
operator|->
name|knob
operator|.
name|xport_specific
operator|.
name|fc
operator|.
name|wwpn
operator|=
operator|(
name|random_bits
operator|&
literal|0x0000000fffffff00ULL
operator|)
operator||
comment|/* Company ID */
literal|0x5000ED5000000000ULL
operator||
comment|/* NL-Port */
literal|0x3000
operator||
comment|/* Port Num */
operator|(
name|bus_softc
operator|->
name|port
operator|.
name|targ_port
operator|&
literal|0xff
operator|)
expr_stmt|;
comment|/* 			 * This is a bit of an API break/reversal, but if 			 * we're doing the random WWNN that's a little 			 * different anyway.  So record what we're actually 			 * using with the frontend code so it's reported 			 * accurately. 			 */
name|ctl_port_set_wwns
argument_list|(
operator|&
name|bus_softc
operator|->
name|port
argument_list|,
name|true
argument_list|,
name|ccb
operator|->
name|knob
operator|.
name|xport_specific
operator|.
name|fc
operator|.
name|wwnn
argument_list|,
name|true
argument_list|,
name|ccb
operator|->
name|knob
operator|.
name|xport_specific
operator|.
name|fc
operator|.
name|wwpn
argument_list|)
expr_stmt|;
name|set_wwnn
operator|=
literal|1
expr_stmt|;
else|#
directive|else
comment|/* RANDOM_WWNN */
comment|/* 			 * If the user has specified a WWNN/WWPN, send them 			 * down to the SIM.  Otherwise, record what the SIM 			 * has reported. 			 */
if|if
condition|(
operator|(
name|bus_softc
operator|->
name|port
operator|.
name|wwnn
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|bus_softc
operator|->
name|port
operator|.
name|wwpn
operator|!=
literal|0
operator|)
condition|)
block|{
name|ccb
operator|->
name|knob
operator|.
name|xport_specific
operator|.
name|fc
operator|.
name|wwnn
operator|=
name|bus_softc
operator|->
name|port
operator|.
name|wwnn
expr_stmt|;
name|ccb
operator|->
name|knob
operator|.
name|xport_specific
operator|.
name|fc
operator|.
name|wwpn
operator|=
name|bus_softc
operator|->
name|port
operator|.
name|wwpn
expr_stmt|;
name|set_wwnn
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ctl_port_set_wwns
argument_list|(
operator|&
name|bus_softc
operator|->
name|port
argument_list|,
name|true
argument_list|,
name|ccb
operator|->
name|knob
operator|.
name|xport_specific
operator|.
name|fc
operator|.
name|wwnn
argument_list|,
name|true
argument_list|,
name|ccb
operator|->
name|knob
operator|.
name|xport_specific
operator|.
name|fc
operator|.
name|wwpn
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* RANDOM_WWNN */
if|if
condition|(
name|set_wwnn
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: %s new WWNN %#jx\n"
argument_list|,
name|__func__
argument_list|,
name|bus_softc
operator|->
name|port_name
argument_list|,
name|ccb
operator|->
name|knob
operator|.
name|xport_specific
operator|.
name|fc
operator|.
name|wwnn
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: %s new WWPN %#jx\n"
argument_list|,
name|__func__
argument_list|,
name|bus_softc
operator|->
name|port_name
argument_list|,
name|ccb
operator|->
name|knob
operator|.
name|xport_specific
operator|.
name|fc
operator|.
name|wwpn
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s: %s has no valid WWNN/WWPN\n"
argument_list|,
name|__func__
argument_list|,
name|bus_softc
operator|->
name|port_name
argument_list|)
expr_stmt|;
block|}
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SET_SIM_KNOB
expr_stmt|;
name|ccb
operator|->
name|knob
operator|.
name|xport_specific
operator|.
name|valid
operator|=
name|KNOB_VALID_ROLE
expr_stmt|;
if|if
condition|(
name|set_wwnn
operator|!=
literal|0
condition|)
name|ccb
operator|->
name|knob
operator|.
name|xport_specific
operator|.
name|valid
operator||=
name|KNOB_VALID_ADDRESS
expr_stmt|;
if|if
condition|(
name|online
operator|!=
literal|0
condition|)
name|ccb
operator|->
name|knob
operator|.
name|xport_specific
operator|.
name|fc
operator|.
name|role
operator|=
name|KNOB_ROLE_TARGET
expr_stmt|;
else|else
name|ccb
operator|->
name|knob
operator|.
name|xport_specific
operator|.
name|fc
operator|.
name|role
operator|=
name|KNOB_ROLE_NONE
expr_stmt|;
name|xpt_action
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"%s: SIM %s (path id %d) target %s failed with "
literal|"status %#x\n"
argument_list|,
name|__func__
argument_list|,
name|bus_softc
operator|->
name|port_name
argument_list|,
name|bus_softc
operator|->
name|path_id
argument_list|,
operator|(
name|online
operator|!=
literal|0
operator|)
condition|?
literal|"enable"
else|:
literal|"disable"
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|status
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s: SIM %s (path id %d) target %s succeeded\n"
argument_list|,
name|__func__
argument_list|,
name|bus_softc
operator|->
name|port_name
argument_list|,
name|bus_softc
operator|->
name|path_id
argument_list|,
operator|(
name|online
operator|!=
literal|0
operator|)
condition|?
literal|"enable"
else|:
literal|"disable"
argument_list|)
expr_stmt|;
block|}
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ccb
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ctlfe_online
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ctlfe_softc
modifier|*
name|bus_softc
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|struct
name|ctlfe_lun_softc
modifier|*
name|lun_softc
decl_stmt|;
name|bus_softc
operator|=
operator|(
expr|struct
name|ctlfe_softc
operator|*
operator|)
name|arg
expr_stmt|;
comment|/* 	 * Create the wildcard LUN before bringing the port online. 	 */
name|status
operator|=
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|bus_softc
operator|->
name|path_id
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unable to create path for wildcard periph\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|lun_softc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|lun_softc
argument_list|)
argument_list|,
name|M_CTLFE
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun_softc
operator|==
name|NULL
condition|)
block|{
name|xpt_print
argument_list|(
name|path
argument_list|,
literal|"%s: unable to allocate softc for "
literal|"wildcard periph\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return;
block|}
name|xpt_path_lock
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|lun_softc
operator|->
name|parent_softc
operator|=
name|bus_softc
expr_stmt|;
name|lun_softc
operator|->
name|flags
operator||=
name|CTLFE_LUN_WILDCARD
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|bus_softc
operator|->
name|lun_softc_mtx
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|bus_softc
operator|->
name|lun_softc_list
argument_list|,
name|lun_softc
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|bus_softc
operator|->
name|lun_softc_mtx
argument_list|)
expr_stmt|;
name|status
operator|=
name|cam_periph_alloc
argument_list|(
name|ctlferegister
argument_list|,
name|ctlfeoninvalidate
argument_list|,
name|ctlfecleanup
argument_list|,
name|ctlfestart
argument_list|,
literal|"ctl"
argument_list|,
name|CAM_PERIPH_BIO
argument_list|,
name|path
argument_list|,
name|ctlfeasync
argument_list|,
literal|0
argument_list|,
name|lun_softc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
specifier|const
name|struct
name|cam_status_entry
modifier|*
name|entry
decl_stmt|;
name|entry
operator|=
name|cam_fetch_status_entry
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: CAM error %s (%#x) returned from "
literal|"cam_periph_alloc()\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|entry
operator|!=
name|NULL
operator|)
condition|?
name|entry
operator|->
name|status_text
else|:
literal|"Unknown"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
name|ctlfe_onoffline
argument_list|(
name|arg
argument_list|,
comment|/*online*/
literal|1
argument_list|)
expr_stmt|;
name|xpt_path_unlock
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctlfe_offline
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ctlfe_softc
modifier|*
name|bus_softc
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|bus_softc
operator|=
operator|(
expr|struct
name|ctlfe_softc
operator|*
operator|)
name|arg
expr_stmt|;
comment|/* 	 * Disable the wildcard LUN for this port now that we have taken 	 * the port offline. 	 */
name|status
operator|=
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|bus_softc
operator|->
name|path_id
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unable to create path for wildcard periph\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|xpt_path_lock
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|ctlfe_onoffline
argument_list|(
name|arg
argument_list|,
comment|/*online*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|periph
operator|=
name|cam_periph_find
argument_list|(
name|path
argument_list|,
literal|"ctl"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|cam_periph_invalidate
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|xpt_path_unlock
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This will get called to enable a LUN on every bus that is attached to  * CTL.  So we only need to create a path/periph for this particular bus.  */
end_comment

begin_function
specifier|static
name|int
name|ctlfe_lun_enable
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ctl_id
name|targ_id
parameter_list|,
name|int
name|lun_id
parameter_list|)
block|{
name|struct
name|ctlfe_softc
modifier|*
name|bus_softc
decl_stmt|;
name|struct
name|ctlfe_lun_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|bus_softc
operator|=
operator|(
expr|struct
name|ctlfe_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|status
operator|=
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|bus_softc
operator|->
name|path_id
argument_list|,
name|targ_id
operator|.
name|id
argument_list|,
name|lun_id
argument_list|)
expr_stmt|;
comment|/* XXX KDM need some way to return status to CTL here? */
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"%s: could not create path, status %#x\n"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|softc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|softc
argument_list|)
argument_list|,
name|M_CTLFE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|xpt_path_lock
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|periph
operator|=
name|cam_periph_find
argument_list|(
name|path
argument_list|,
literal|"ctl"
argument_list|)
expr_stmt|;
if|if
condition|(
name|periph
operator|!=
name|NULL
condition|)
block|{
comment|/* We've already got a periph, no need to alloc a new one. */
name|xpt_path_unlock
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|softc
argument_list|,
name|M_CTLFE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|softc
operator|->
name|parent_softc
operator|=
name|bus_softc
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|bus_softc
operator|->
name|lun_softc_mtx
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|bus_softc
operator|->
name|lun_softc_list
argument_list|,
name|softc
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|bus_softc
operator|->
name|lun_softc_mtx
argument_list|)
expr_stmt|;
name|status
operator|=
name|cam_periph_alloc
argument_list|(
name|ctlferegister
argument_list|,
name|ctlfeoninvalidate
argument_list|,
name|ctlfecleanup
argument_list|,
name|ctlfestart
argument_list|,
literal|"ctl"
argument_list|,
name|CAM_PERIPH_BIO
argument_list|,
name|path
argument_list|,
name|ctlfeasync
argument_list|,
literal|0
argument_list|,
name|softc
argument_list|)
expr_stmt|;
name|xpt_path_unlock
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This will get called when the user removes a LUN to disable that LUN  * on every bus that is attached to CTL.    */
end_comment

begin_function
specifier|static
name|int
name|ctlfe_lun_disable
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ctl_id
name|targ_id
parameter_list|,
name|int
name|lun_id
parameter_list|)
block|{
name|struct
name|ctlfe_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ctlfe_lun_softc
modifier|*
name|lun_softc
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|ctlfe_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|lun_softc_mtx
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|lun_softc
argument_list|,
argument|&softc->lun_softc_list
argument_list|,
argument|links
argument_list|)
block|{
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|path
operator|=
name|lun_softc
operator|->
name|periph
operator|->
name|path
expr_stmt|;
if|if
condition|(
operator|(
name|xpt_path_target_id
argument_list|(
name|path
argument_list|)
operator|==
name|targ_id
operator|.
name|id
operator|)
operator|&&
operator|(
name|xpt_path_lun_id
argument_list|(
name|path
argument_list|)
operator|==
name|lun_id
operator|)
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|lun_softc
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lun_softc_mtx
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: can't find target %d lun %d\n"
argument_list|,
name|__func__
argument_list|,
name|targ_id
operator|.
name|id
argument_list|,
name|lun_id
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|cam_periph_acquire
argument_list|(
name|lun_softc
operator|->
name|periph
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lun_softc_mtx
argument_list|)
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|lun_softc
operator|->
name|periph
argument_list|)
expr_stmt|;
name|cam_periph_invalidate
argument_list|(
name|lun_softc
operator|->
name|periph
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|lun_softc
operator|->
name|periph
argument_list|)
expr_stmt|;
name|cam_periph_release
argument_list|(
name|lun_softc
operator|->
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctlfe_dump_sim
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
block|{
name|printf
argument_list|(
literal|"%s%d: max tagged openings: %d, max dev openings: %d\n"
argument_list|,
name|sim
operator|->
name|sim_name
argument_list|,
name|sim
operator|->
name|unit_number
argument_list|,
name|sim
operator|->
name|max_tagged_dev_openings
argument_list|,
name|sim
operator|->
name|max_dev_openings
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Assumes that the SIM lock is held.  */
end_comment

begin_function
specifier|static
name|void
name|ctlfe_dump_queue
parameter_list|(
name|struct
name|ctlfe_lun_softc
modifier|*
name|softc
parameter_list|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|hdr
decl_stmt|;
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|int
name|num_items
decl_stmt|;
name|periph
operator|=
name|softc
operator|->
name|periph
expr_stmt|;
name|num_items
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|hdr
argument_list|,
argument|&softc->work_queue
argument_list|,
argument|periph_links.tqe
argument_list|)
block|{
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|io
operator|=
name|hdr
operator|->
name|io_ptr
expr_stmt|;
name|num_items
operator|++
expr_stmt|;
comment|/* 		 * This can happen when we get an ATIO but can't allocate 		 * a ctl_io.  See the XPT_ACCEPT_TARGET_IO case in ctlfedone(). 		 */
if|if
condition|(
name|io
operator|==
name|NULL
condition|)
block|{
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|csio
operator|=
operator|(
expr|struct
name|ccb_scsiio
operator|*
operator|)
name|hdr
expr_stmt|;
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"CCB %#x ctl_io allocation "
literal|"failed\n"
argument_list|,
name|csio
operator|->
name|tag_id
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Only regular SCSI I/O is put on the work 		 * queue, so we can print sense here.  There may be no 		 * sense if it's no the queue for a DMA, but this serves to 		 * print out the CCB as well. 		 * 		 * XXX KDM switch this over to scsi_sense_print() when 		 * CTL is merged in with CAM. 		 */
name|ctl_io_error_print
argument_list|(
name|io
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 		 * We're sending status back to the 		 * initiator, so we're on the queue waiting 		 * for a CTIO to do that. 		 */
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|!=
name|CTL_STATUS_NONE
condition|)
continue|continue;
comment|/* 		 * Otherwise, we're on the queue waiting to 		 * do a data transfer. 		 */
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"Total %u, Current %u, Resid %u\n"
argument_list|,
name|io
operator|->
name|scsiio
operator|.
name|kern_total_len
argument_list|,
name|io
operator|->
name|scsiio
operator|.
name|kern_data_len
argument_list|,
name|io
operator|->
name|scsiio
operator|.
name|kern_data_resid
argument_list|)
expr_stmt|;
block|}
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"%d requests total waiting for CCBs\n"
argument_list|,
name|num_items
argument_list|)
expr_stmt|;
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"%ju CCBs outstanding (%ju allocated, %ju "
literal|"freed)\n"
argument_list|,
call|(
name|uintmax_t
call|)
argument_list|(
name|softc
operator|->
name|ccbs_alloced
operator|-
name|softc
operator|->
name|ccbs_freed
argument_list|)
argument_list|,
operator|(
name|uintmax_t
operator|)
name|softc
operator|->
name|ccbs_alloced
argument_list|,
operator|(
name|uintmax_t
operator|)
name|softc
operator|->
name|ccbs_freed
argument_list|)
expr_stmt|;
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"%ju CTIOs outstanding (%ju sent, %ju "
literal|"returned\n"
argument_list|,
call|(
name|uintmax_t
call|)
argument_list|(
name|softc
operator|->
name|ctios_sent
operator|-
name|softc
operator|->
name|ctios_returned
argument_list|)
argument_list|,
name|softc
operator|->
name|ctios_sent
argument_list|,
name|softc
operator|->
name|ctios_returned
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function is called when we fail to get a CCB for a DMA or status return  * to the initiator within the specified time period.  *  * The callout code should insure that we hold the sim mutex here.  */
end_comment

begin_function
specifier|static
name|void
name|ctlfe_dma_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ctlfe_lun_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|int
name|num_queued
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|ctlfe_lun_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|periph
operator|=
name|softc
operator|->
name|periph
expr_stmt|;
name|sim
operator|=
name|xpt_path_sim
argument_list|(
name|periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|num_queued
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Nothing to do... 	 */
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|softc
operator|->
name|work_queue
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"TIMEOUT triggered after %d "
literal|"seconds, but nothing on work queue??\n"
argument_list|,
name|CTLFE_DMA_TIMEOUT
argument_list|)
expr_stmt|;
return|return;
block|}
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"TIMEOUT (%d seconds) waiting for DMA to "
literal|"start\n"
argument_list|,
name|CTLFE_DMA_TIMEOUT
argument_list|)
expr_stmt|;
name|ctlfe_dump_queue
argument_list|(
name|softc
argument_list|)
expr_stmt|;
name|ctlfe_dump_sim
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"calling xpt_schedule() to attempt to "
literal|"unstick our queue\n"
argument_list|)
expr_stmt|;
name|xpt_schedule
argument_list|(
name|periph
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"xpt_schedule() call complete\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Datamove/done routine called by CTL.  Put ourselves on the queue to  * receive a CCB from CAM so we can queue the continue I/O request down  * to the adapter.  */
end_comment

begin_function
specifier|static
name|void
name|ctlfe_datamove_done
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|ctlfe_lun_softc
modifier|*
name|softc
decl_stmt|;
name|ccb
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_FRONTEND
index|]
operator|.
name|ptr
expr_stmt|;
name|periph
operator|=
name|xpt_path_periph
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|ctlfe_lun_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|io_type
operator|==
name|CTL_IO_TASK
condition|)
block|{
comment|/* 		 * Task management commands don't require any further 		 * communication back to the adapter.  Requeue the CCB 		 * to the adapter, and free the CTL I/O. 		 */
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"%s: returning task I/O "
literal|"tag %#x seq %#x\n"
argument_list|,
name|__func__
argument_list|,
name|ccb
operator|->
name|cin1
operator|.
name|tag_id
argument_list|,
name|ccb
operator|->
name|cin1
operator|.
name|seq_id
argument_list|)
expr_stmt|;
comment|/* 		 * Send the notify acknowledge down to the SIM, to let it 		 * know we processed the task management command. 		 */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INPROG
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_NOTIFY_ACKNOWLEDGE
expr_stmt|;
name|xpt_action
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|ctl_free_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|!=
name|CTL_STATUS_NONE
condition|)
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_STATUS_QUEUED
expr_stmt|;
else|else
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_DMA_QUEUED
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|softc
operator|->
name|work_queue
argument_list|,
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
comment|/* 		 * Reset the timeout for our latest active DMA. 		 */
name|callout_reset
argument_list|(
operator|&
name|softc
operator|->
name|dma_callout
argument_list|,
name|CTLFE_DMA_TIMEOUT
operator|*
name|hz
argument_list|,
name|ctlfe_dma_timeout
argument_list|,
name|softc
argument_list|)
expr_stmt|;
comment|/* 		 * Ask for the CAM transport layer to send us a CCB to do 		 * the DMA or send status, unless ctlfe_dma_enabled is set 		 * to 0. 		 */
if|if
condition|(
name|ctlfe_dma_enabled
operator|!=
literal|0
condition|)
name|xpt_schedule
argument_list|(
name|periph
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
block|}
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctlfe_dump
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ctlfe_softc
modifier|*
name|bus_softc
decl_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|bus_softc
argument_list|,
argument|&ctlfe_softc_list
argument_list|,
argument|links
argument_list|)
block|{
name|struct
name|ctlfe_lun_softc
modifier|*
name|lun_softc
decl_stmt|;
name|ctlfe_dump_sim
argument_list|(
name|bus_softc
operator|->
name|sim
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|lun_softc
argument_list|,
argument|&bus_softc->lun_softc_list
argument_list|,
argument|links
argument_list|)
block|{
name|ctlfe_dump_queue
argument_list|(
name|lun_softc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

