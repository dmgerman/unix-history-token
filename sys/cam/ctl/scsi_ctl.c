begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2008, 2009 Silicon Graphics International Corp.  * Copyright (c) 2014-2015 Alexander Motin<mav@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    substantially similar to the "NO WARRANTY" disclaimer below  *    ("Disclaimer") and any redistribution must be conditioned upon  *    including a substantially similar Disclaimer requirement for further  *    binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGES.  *  * $Id: //depot/users/kenm/FreeBSD-test2/sys/cam/ctl/scsi_ctl.c#4 $  */
end_comment

begin_comment
comment|/*  * Peripheral driver interface between CAM and CTL (CAM Target Layer).  *  * Author: Ken Merry<ken@FreeBSD.org>  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_queue.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_io.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_frontend.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_util.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_error.h>
end_include

begin_struct
struct|struct
name|ctlfe_softc
block|{
name|struct
name|ctl_port
name|port
decl_stmt|;
name|path_id_t
name|path_id
decl_stmt|;
name|target_id_t
name|target_id
decl_stmt|;
name|uint32_t
name|hba_misc
decl_stmt|;
name|u_int
name|maxio
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|char
name|port_name
index|[
name|DEV_IDLEN
index|]
decl_stmt|;
name|struct
name|mtx
name|lun_softc_mtx
decl_stmt|;
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|ctlfe_lun_softc
argument_list|)
name|lun_softc_list
expr_stmt|;
name|STAILQ_ENTRY
argument_list|(
argument|ctlfe_softc
argument_list|)
name|links
expr_stmt|;
block|}
struct|;
end_struct

begin_macro
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|ctlfe_softc
argument_list|)
end_macro

begin_expr_stmt
name|ctlfe_softc_list
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|mtx
name|ctlfe_list_mtx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|ctlfe_mtx_desc
index|[]
init|=
literal|"ctlfelist"
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
enum|enum
block|{
name|CTLFE_LUN_NONE
init|=
literal|0x00
block|,
name|CTLFE_LUN_WILDCARD
init|=
literal|0x01
block|}
name|ctlfe_lun_flags
typedef|;
end_typedef

begin_struct
struct|struct
name|ctlfe_lun_softc
block|{
name|struct
name|ctlfe_softc
modifier|*
name|parent_softc
decl_stmt|;
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|ctlfe_lun_flags
name|flags
decl_stmt|;
name|int
name|ctios_sent
decl_stmt|;
comment|/* Number of active CTIOs */
name|int
name|refcount
decl_stmt|;
comment|/* Number of active xpt_action() */
name|int
name|atios_alloced
decl_stmt|;
comment|/* Number of ATIOs not freed */
name|int
name|inots_alloced
decl_stmt|;
comment|/* Number of INOTs not freed */
name|struct
name|task
name|refdrain_task
decl_stmt|;
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|ccb_hdr
argument_list|)
name|work_queue
expr_stmt|;
name|LIST_HEAD
argument_list|(
argument_list|,
argument|ccb_hdr
argument_list|)
name|atio_list
expr_stmt|;
comment|/* List of ATIOs queued to SIM. */
name|LIST_HEAD
argument_list|(
argument_list|,
argument|ccb_hdr
argument_list|)
name|inot_list
expr_stmt|;
comment|/* List of INOTs queued to SIM. */
name|STAILQ_ENTRY
argument_list|(
argument|ctlfe_lun_softc
argument_list|)
name|links
expr_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
enum|enum
block|{
name|CTLFE_CMD_NONE
init|=
literal|0x00
block|,
name|CTLFE_CMD_PIECEWISE
init|=
literal|0x01
block|}
name|ctlfe_cmd_flags
typedef|;
end_typedef

begin_struct
struct|struct
name|ctlfe_cmd_info
block|{
name|int
name|cur_transfer_index
decl_stmt|;
name|size_t
name|cur_transfer_off
decl_stmt|;
name|ctlfe_cmd_flags
name|flags
decl_stmt|;
comment|/* 	 * XXX KDM struct bus_dma_segment is 8 bytes on i386, and 16 	 * bytes on amd64.  So with 32 elements, this is 256 bytes on 	 * i386 and 512 bytes on amd64. 	 */
define|#
directive|define
name|CTLFE_MAX_SEGS
value|32
name|bus_dma_segment_t
name|cam_sglist
index|[
name|CTLFE_MAX_SEGS
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * When we register the adapter/bus, request that this many ctl_ios be  * allocated.  This should be the maximum supported by the adapter, but we  * currently don't have a way to get that back from the path inquiry.  * XXX KDM add that to the path inquiry.  */
end_comment

begin_define
define|#
directive|define
name|CTLFE_REQ_CTL_IO
value|4096
end_define

begin_comment
comment|/*  * Number of Accept Target I/O CCBs to allocate and queue down to the  * adapter per LUN.  * XXX KDM should this be controlled by CTL?  */
end_comment

begin_define
define|#
directive|define
name|CTLFE_ATIO_PER_LUN
value|1024
end_define

begin_comment
comment|/*  * Number of Immediate Notify CCBs (used for aborts, resets, etc.) to  * allocate and queue down to the adapter per LUN.  * XXX KDM should this be controlled by CTL?  */
end_comment

begin_define
define|#
directive|define
name|CTLFE_IN_PER_LUN
value|1024
end_define

begin_comment
comment|/*  * Timeout (in seconds) on CTIO CCB doing DMA or sending status  */
end_comment

begin_define
define|#
directive|define
name|CTLFE_TIMEOUT
value|5
end_define

begin_comment
comment|/*  * Turn this on to enable extra debugging prints.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|CTLFE_DEBUG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_CTLFE
argument_list|,
literal|"CAM CTL FE"
argument_list|,
literal|"CAM CTL FE interface"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|io_ptr
value|ppriv_ptr0
end_define

begin_comment
comment|/* This is only used in the CTIO */
end_comment

begin_define
define|#
directive|define
name|ccb_atio
value|ppriv_ptr1
end_define

begin_define
define|#
directive|define
name|PRIV_CCB
parameter_list|(
name|io
parameter_list|)
value|((io)->io_hdr.ctl_private[CTL_PRIV_FRONTEND].ptrs[0])
end_define

begin_define
define|#
directive|define
name|PRIV_INFO
parameter_list|(
name|io
parameter_list|)
value|((io)->io_hdr.ctl_private[CTL_PRIV_FRONTEND].ptrs[1])
end_define

begin_function_decl
specifier|static
name|int
name|ctlfeinitialize
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctlfeshutdown
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|periph_init_t
name|ctlfeperiphinit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_deinit_t
name|ctlfeperiphdeinit
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|ctlfeasync
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|uint32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|periph_ctor_t
name|ctlferegister
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_oninv_t
name|ctlfeoninvalidate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_dtor_t
name|ctlfecleanup
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_start_t
name|ctlfestart
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|ctlfedone
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|done_ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctlfe_onoffline
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|online
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctlfe_online
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctlfe_offline
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctlfe_lun_enable
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|lun_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctlfe_lun_disable
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|lun_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctlfe_dump_sim
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctlfe_dump_queue
parameter_list|(
name|struct
name|ctlfe_lun_softc
modifier|*
name|softc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctlfe_datamove
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctlfe_done
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctlfe_dump
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctlfe_free_ccb
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctlfe_requeue_ccb
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|int
name|unlock
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|periph_driver
name|ctlfe_driver
init|=
block|{
name|ctlfeperiphinit
block|,
literal|"ctl"
block|,
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|ctlfe_driver
operator|.
name|units
argument_list|)
block|,
comment|/*generation*/
literal|0
block|,
name|CAM_PERIPH_DRV_EARLY
block|,
name|ctlfeperiphdeinit
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ctl_frontend
name|ctlfe_frontend
init|=
block|{
operator|.
name|name
operator|=
literal|"camtgt"
block|,
operator|.
name|init
operator|=
name|ctlfeinitialize
block|,
operator|.
name|fe_dump
operator|=
name|ctlfe_dump
block|,
operator|.
name|shutdown
operator|=
name|ctlfeshutdown
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|CTL_FRONTEND_DECLARE
argument_list|(
name|ctlfe
argument_list|,
name|ctlfe_frontend
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|ctlfeinitialize
parameter_list|(
name|void
parameter_list|)
block|{
name|STAILQ_INIT
argument_list|(
operator|&
name|ctlfe_softc_list
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|ctlfe_list_mtx
argument_list|,
name|ctlfe_mtx_desc
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|periphdriver_register
argument_list|(
operator|&
name|ctlfe_driver
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctlfeshutdown
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|periphdriver_unregister
argument_list|(
operator|&
name|ctlfe_driver
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|mtx_destroy
argument_list|(
operator|&
name|ctlfe_list_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctlfeperiphinit
parameter_list|(
name|void
parameter_list|)
block|{
name|cam_status
name|status
decl_stmt|;
name|status
operator|=
name|xpt_register_async
argument_list|(
name|AC_PATH_REGISTERED
operator||
name|AC_PATH_DEREGISTERED
operator||
name|AC_CONTRACT
argument_list|,
name|ctlfeasync
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"ctl: Failed to attach async callback due to CAM "
literal|"status 0x%x!\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ctlfeperiphdeinit
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* XXX: It would be good to tear down active ports here. */
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ctlfe_driver
operator|.
name|units
argument_list|)
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|xpt_register_async
argument_list|(
literal|0
argument_list|,
name|ctlfeasync
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctlfeasync
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|uint32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ctlfe_softc
modifier|*
name|softc
decl_stmt|;
ifdef|#
directive|ifdef
name|CTLFEDEBUG
name|printf
argument_list|(
literal|"%s: entered\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mtx_lock
argument_list|(
operator|&
name|ctlfe_list_mtx
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|softc
argument_list|,
argument|&ctlfe_softc_list
argument_list|,
argument|links
argument_list|)
block|{
if|if
condition|(
name|softc
operator|->
name|path_id
operator|==
name|xpt_path_path_id
argument_list|(
name|path
argument_list|)
condition|)
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|ctlfe_list_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * When a new path gets registered, and it is capable of target 	 * mode, go ahead and attach.  Later on, we may need to be more 	 * selective, but for now this will be sufficient.  	 */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|AC_PATH_REGISTERED
case|:
block|{
name|struct
name|ctl_port
modifier|*
name|port
decl_stmt|;
name|struct
name|ccb_pathinq
modifier|*
name|cpi
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|cpi
operator|=
operator|(
expr|struct
name|ccb_pathinq
operator|*
operator|)
name|arg
expr_stmt|;
comment|/* Don't attach if it doesn't support target mode */
if|if
condition|(
operator|(
name|cpi
operator|->
name|target_sprt
operator|&
name|PIT_PROCESSOR
operator|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|CTLFEDEBUG
name|printf
argument_list|(
literal|"%s: SIM %s%d doesn't support target mode\n"
argument_list|,
name|__func__
argument_list|,
name|cpi
operator|->
name|dev_name
argument_list|,
name|cpi
operator|->
name|unit_number
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
if|if
condition|(
name|softc
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|CTLFEDEBUG
name|printf
argument_list|(
literal|"%s: CTL port for CAM path %u already exists\n"
argument_list|,
name|__func__
argument_list|,
name|xpt_path_path_id
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
comment|/* 		 * We're in an interrupt context here, so we have to 		 * use M_NOWAIT.  Of course this means trouble if we 		 * can't allocate memory. 		 */
name|softc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|softc
argument_list|)
argument_list|,
name|M_CTLFE
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unable to malloc %zd bytes for softc\n"
argument_list|,
name|__func__
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|softc
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|softc
operator|->
name|path_id
operator|=
name|cpi
operator|->
name|ccb_h
operator|.
name|path_id
expr_stmt|;
name|softc
operator|->
name|target_id
operator|=
name|cpi
operator|->
name|initiator_id
expr_stmt|;
name|softc
operator|->
name|sim
operator|=
name|xpt_path_sim
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|softc
operator|->
name|hba_misc
operator|=
name|cpi
operator|->
name|hba_misc
expr_stmt|;
if|if
condition|(
name|cpi
operator|->
name|maxio
operator|!=
literal|0
condition|)
name|softc
operator|->
name|maxio
operator|=
name|cpi
operator|->
name|maxio
expr_stmt|;
else|else
name|softc
operator|->
name|maxio
operator|=
name|DFLTPHYS
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|softc
operator|->
name|lun_softc_mtx
argument_list|,
literal|"LUN softc mtx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|softc
operator|->
name|lun_softc_list
argument_list|)
expr_stmt|;
name|port
operator|=
operator|&
name|softc
operator|->
name|port
expr_stmt|;
name|port
operator|->
name|frontend
operator|=
operator|&
name|ctlfe_frontend
expr_stmt|;
comment|/* 		 * XXX KDM should we be more accurate here ? 		 */
if|if
condition|(
name|cpi
operator|->
name|transport
operator|==
name|XPORT_FC
condition|)
name|port
operator|->
name|port_type
operator|=
name|CTL_PORT_FC
expr_stmt|;
elseif|else
if|if
condition|(
name|cpi
operator|->
name|transport
operator|==
name|XPORT_SAS
condition|)
name|port
operator|->
name|port_type
operator|=
name|CTL_PORT_SAS
expr_stmt|;
else|else
name|port
operator|->
name|port_type
operator|=
name|CTL_PORT_SCSI
expr_stmt|;
comment|/* XXX KDM what should the real number be here? */
name|port
operator|->
name|num_requested_ctl_io
operator|=
name|CTLFE_REQ_CTL_IO
expr_stmt|;
name|snprintf
argument_list|(
name|softc
operator|->
name|port_name
argument_list|,
sizeof|sizeof
argument_list|(
name|softc
operator|->
name|port_name
argument_list|)
argument_list|,
literal|"%s%d"
argument_list|,
name|cpi
operator|->
name|dev_name
argument_list|,
name|cpi
operator|->
name|unit_number
argument_list|)
expr_stmt|;
comment|/* 		 * XXX KDM it would be nice to allocate storage in the 		 * frontend structure itself. 	 	 */
name|port
operator|->
name|port_name
operator|=
name|softc
operator|->
name|port_name
expr_stmt|;
name|port
operator|->
name|physical_port
operator|=
name|cpi
operator|->
name|bus_id
expr_stmt|;
name|port
operator|->
name|virtual_port
operator|=
literal|0
expr_stmt|;
name|port
operator|->
name|port_online
operator|=
name|ctlfe_online
expr_stmt|;
name|port
operator|->
name|port_offline
operator|=
name|ctlfe_offline
expr_stmt|;
name|port
operator|->
name|onoff_arg
operator|=
name|softc
expr_stmt|;
name|port
operator|->
name|lun_enable
operator|=
name|ctlfe_lun_enable
expr_stmt|;
name|port
operator|->
name|lun_disable
operator|=
name|ctlfe_lun_disable
expr_stmt|;
name|port
operator|->
name|targ_lun_arg
operator|=
name|softc
expr_stmt|;
name|port
operator|->
name|fe_datamove
operator|=
name|ctlfe_datamove
expr_stmt|;
name|port
operator|->
name|fe_done
operator|=
name|ctlfe_done
expr_stmt|;
name|port
operator|->
name|targ_port
operator|=
operator|-
literal|1
expr_stmt|;
name|retval
operator|=
name|ctl_port_register
argument_list|(
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ctl_port_register() failed with "
literal|"error %d!\n"
argument_list|,
name|__func__
argument_list|,
name|retval
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|softc
operator|->
name|lun_softc_mtx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|softc
argument_list|,
name|M_CTLFE
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|mtx_lock
argument_list|(
operator|&
name|ctlfe_list_mtx
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ctlfe_softc_list
argument_list|,
name|softc
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ctlfe_list_mtx
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|AC_PATH_DEREGISTERED
case|:
block|{
if|if
condition|(
name|softc
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * XXX KDM are we certain at this point that there 			 * are no outstanding commands for this frontend? 			 */
name|mtx_lock
argument_list|(
operator|&
name|ctlfe_list_mtx
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE
argument_list|(
operator|&
name|ctlfe_softc_list
argument_list|,
name|softc
argument_list|,
name|ctlfe_softc
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ctlfe_list_mtx
argument_list|)
expr_stmt|;
name|ctl_port_deregister
argument_list|(
operator|&
name|softc
operator|->
name|port
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|softc
operator|->
name|lun_softc_mtx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|softc
argument_list|,
name|M_CTLFE
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|AC_CONTRACT
case|:
block|{
name|struct
name|ac_contract
modifier|*
name|ac
decl_stmt|;
name|ac
operator|=
operator|(
expr|struct
name|ac_contract
operator|*
operator|)
name|arg
expr_stmt|;
switch|switch
condition|(
name|ac
operator|->
name|contract_number
condition|)
block|{
case|case
name|AC_CONTRACT_DEV_CHG
case|:
block|{
name|struct
name|ac_device_changed
modifier|*
name|dev_chg
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|dev_chg
operator|=
operator|(
expr|struct
name|ac_device_changed
operator|*
operator|)
name|ac
operator|->
name|contract_data
expr_stmt|;
name|printf
argument_list|(
literal|"%s: WWPN %#jx port 0x%06x path %u target %u %s\n"
argument_list|,
name|__func__
argument_list|,
name|dev_chg
operator|->
name|wwpn
argument_list|,
name|dev_chg
operator|->
name|port
argument_list|,
name|xpt_path_path_id
argument_list|(
name|path
argument_list|)
argument_list|,
name|dev_chg
operator|->
name|target
argument_list|,
operator|(
name|dev_chg
operator|->
name|arrived
operator|==
literal|0
operator|)
condition|?
literal|"left"
else|:
literal|"arrived"
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: CTL port for CAM path %u not "
literal|"found!\n"
argument_list|,
name|__func__
argument_list|,
name|xpt_path_path_id
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dev_chg
operator|->
name|arrived
operator|!=
literal|0
condition|)
block|{
name|retval
operator|=
name|ctl_add_initiator
argument_list|(
operator|&
name|softc
operator|->
name|port
argument_list|,
name|dev_chg
operator|->
name|target
argument_list|,
name|dev_chg
operator|->
name|wwpn
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
name|ctl_remove_initiator
argument_list|(
operator|&
name|softc
operator|->
name|port
argument_list|,
name|dev_chg
operator|->
name|target
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: could not %s port %d iid %u "
literal|"WWPN %#jx!\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|dev_chg
operator|->
name|arrived
operator|!=
literal|0
operator|)
condition|?
literal|"add"
else|:
literal|"remove"
argument_list|,
name|softc
operator|->
name|port
operator|.
name|targ_port
argument_list|,
name|dev_chg
operator|->
name|target
argument_list|,
operator|(
name|uintmax_t
operator|)
name|dev_chg
operator|->
name|wwpn
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
name|printf
argument_list|(
literal|"%s: unsupported contract number %ju\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ac
operator|->
name|contract_number
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|cam_status
name|ctlferegister
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ctlfe_softc
modifier|*
name|bus_softc
decl_stmt|;
name|struct
name|ctlfe_lun_softc
modifier|*
name|softc
decl_stmt|;
name|union
name|ccb
name|ccb
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|int
name|i
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|ctlfe_lun_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|bus_softc
operator|=
name|softc
operator|->
name|parent_softc
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|softc
operator|->
name|work_queue
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|softc
operator|->
name|atio_list
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|softc
operator|->
name|inot_list
argument_list|)
expr_stmt|;
name|softc
operator|->
name|periph
operator|=
name|periph
expr_stmt|;
name|periph
operator|->
name|softc
operator|=
name|softc
expr_stmt|;
comment|/* Increase device openings to maximum for the SIM. */
if|if
condition|(
name|bus_softc
operator|->
name|sim
operator|->
name|max_tagged_dev_openings
operator|>
name|bus_softc
operator|->
name|sim
operator|->
name|max_dev_openings
condition|)
block|{
name|cam_release_devq
argument_list|(
name|periph
operator|->
name|path
argument_list|,
comment|/*relsim_flags*/
name|RELSIM_ADJUST_OPENINGS
argument_list|,
comment|/*openings*/
name|bus_softc
operator|->
name|sim
operator|->
name|max_tagged_dev_openings
argument_list|,
comment|/*timeout*/
literal|0
argument_list|,
comment|/*getcount_only*/
literal|1
argument_list|)
expr_stmt|;
block|}
name|xpt_setup_ccb
argument_list|(
operator|&
name|ccb
operator|.
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
name|CAM_PRIORITY_NONE
argument_list|)
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_EN_LUN
expr_stmt|;
name|ccb
operator|.
name|cel
operator|.
name|grp6_len
operator|=
literal|0
expr_stmt|;
name|ccb
operator|.
name|cel
operator|.
name|grp7_len
operator|=
literal|0
expr_stmt|;
name|ccb
operator|.
name|cel
operator|.
name|enable
operator|=
literal|1
expr_stmt|;
name|xpt_action
argument_list|(
operator|&
name|ccb
argument_list|)
expr_stmt|;
name|status
operator|=
operator|(
name|ccb
operator|.
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"%s: Enable LUN failed, status 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|ccb
operator|.
name|ccb_h
operator|.
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTLFE_ATIO_PER_LUN
condition|;
name|i
operator|++
control|)
block|{
name|union
name|ccb
modifier|*
name|new_ccb
decl_stmt|;
name|union
name|ctl_io
modifier|*
name|new_io
decl_stmt|;
name|struct
name|ctlfe_cmd_info
modifier|*
name|cmd_info
decl_stmt|;
name|new_ccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new_ccb
argument_list|)
argument_list|,
name|M_CTLFE
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_ccb
operator|==
name|NULL
condition|)
block|{
name|status
operator|=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
break|break;
block|}
name|new_io
operator|=
name|ctl_alloc_io_nowait
argument_list|(
name|bus_softc
operator|->
name|port
operator|.
name|ctl_pool_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_io
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|new_ccb
argument_list|,
name|M_CTLFE
argument_list|)
expr_stmt|;
name|status
operator|=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
break|break;
block|}
name|cmd_info
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cmd_info
argument_list|)
argument_list|,
name|M_CTLFE
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd_info
operator|==
name|NULL
condition|)
block|{
name|ctl_free_io
argument_list|(
name|new_io
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new_ccb
argument_list|,
name|M_CTLFE
argument_list|)
expr_stmt|;
name|status
operator|=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
break|break;
block|}
name|PRIV_INFO
argument_list|(
name|new_io
argument_list|)
operator|=
name|cmd_info
expr_stmt|;
name|softc
operator|->
name|atios_alloced
operator|++
expr_stmt|;
name|new_ccb
operator|->
name|ccb_h
operator|.
name|io_ptr
operator|=
name|new_io
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|softc
operator|->
name|atio_list
argument_list|,
operator|&
name|new_ccb
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|le
argument_list|)
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|new_ccb
operator|->
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
name|CAM_PRIORITY_NONE
argument_list|)
expr_stmt|;
name|new_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_ACCEPT_TARGET_IO
expr_stmt|;
name|new_ccb
operator|->
name|ccb_h
operator|.
name|cbfcnp
operator|=
name|ctlfedone
expr_stmt|;
name|new_ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_UNLOCKED
expr_stmt|;
name|xpt_action
argument_list|(
name|new_ccb
argument_list|)
expr_stmt|;
name|status
operator|=
name|new_ccb
operator|->
name|ccb_h
operator|.
name|status
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_INPROG
condition|)
block|{
name|free
argument_list|(
name|cmd_info
argument_list|,
name|M_CTLFE
argument_list|)
expr_stmt|;
name|ctl_free_io
argument_list|(
name|new_io
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new_ccb
argument_list|,
name|M_CTLFE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|status
operator|=
name|cam_periph_acquire
argument_list|(
name|periph
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"%s: could not acquire reference "
literal|"count, status = %#x\n"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"%s: could not allocate ATIO CCBs, "
literal|"status 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTLFE_IN_PER_LUN
condition|;
name|i
operator|++
control|)
block|{
name|union
name|ccb
modifier|*
name|new_ccb
decl_stmt|;
name|union
name|ctl_io
modifier|*
name|new_io
decl_stmt|;
name|new_ccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new_ccb
argument_list|)
argument_list|,
name|M_CTLFE
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_ccb
operator|==
name|NULL
condition|)
block|{
name|status
operator|=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
break|break;
block|}
name|new_io
operator|=
name|ctl_alloc_io_nowait
argument_list|(
name|bus_softc
operator|->
name|port
operator|.
name|ctl_pool_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_io
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|new_ccb
argument_list|,
name|M_CTLFE
argument_list|)
expr_stmt|;
name|status
operator|=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
break|break;
block|}
name|softc
operator|->
name|inots_alloced
operator|++
expr_stmt|;
name|new_ccb
operator|->
name|ccb_h
operator|.
name|io_ptr
operator|=
name|new_io
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|softc
operator|->
name|inot_list
argument_list|,
operator|&
name|new_ccb
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|le
argument_list|)
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|new_ccb
operator|->
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
name|CAM_PRIORITY_NONE
argument_list|)
expr_stmt|;
name|new_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_IMMEDIATE_NOTIFY
expr_stmt|;
name|new_ccb
operator|->
name|ccb_h
operator|.
name|cbfcnp
operator|=
name|ctlfedone
expr_stmt|;
name|new_ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_UNLOCKED
expr_stmt|;
name|xpt_action
argument_list|(
name|new_ccb
argument_list|)
expr_stmt|;
name|status
operator|=
name|new_ccb
operator|->
name|ccb_h
operator|.
name|status
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_INPROG
condition|)
block|{
comment|/* 			 * Note that we don't free the CCB here.  If the 			 * status is not CAM_REQ_INPROG, then we're 			 * probably talking to a SIM that says it is 			 * target-capable but doesn't support the  			 * XPT_IMMEDIATE_NOTIFY CCB.  i.e. it supports the 			 * older API.  In that case, it'll call xpt_done() 			 * on the CCB, and we need to free it in our done 			 * routine as a result. 			 */
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|i
operator|==
literal|0
operator|)
operator|||
operator|(
name|status
operator|!=
name|CAM_REQ_INPROG
operator|)
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"%s: could not allocate immediate "
literal|"notify CCBs, status 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|bus_softc
operator|->
name|lun_softc_mtx
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|bus_softc
operator|->
name|lun_softc_list
argument_list|,
name|softc
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|bus_softc
operator|->
name|lun_softc_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctlfeoninvalidate
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|struct
name|ctlfe_lun_softc
modifier|*
name|softc
init|=
operator|(
expr|struct
name|ctlfe_lun_softc
operator|*
operator|)
name|periph
operator|->
name|softc
decl_stmt|;
name|struct
name|ctlfe_softc
modifier|*
name|bus_softc
decl_stmt|;
name|union
name|ccb
name|ccb
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|hdr
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
comment|/* Abort all ATIOs and INOTs queued to SIM. */
name|xpt_setup_ccb
argument_list|(
operator|&
name|ccb
operator|.
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
name|CAM_PRIORITY_NONE
argument_list|)
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_ABORT
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|hdr
argument_list|,
argument|&softc->atio_list
argument_list|,
argument|periph_links.le
argument_list|)
block|{
name|ccb
operator|.
name|cab
operator|.
name|abort_ccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|hdr
expr_stmt|;
name|xpt_action
argument_list|(
operator|&
name|ccb
argument_list|)
expr_stmt|;
block|}
name|LIST_FOREACH
argument_list|(
argument|hdr
argument_list|,
argument|&softc->inot_list
argument_list|,
argument|periph_links.le
argument_list|)
block|{
name|ccb
operator|.
name|cab
operator|.
name|abort_ccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|hdr
expr_stmt|;
name|xpt_action
argument_list|(
operator|&
name|ccb
argument_list|)
expr_stmt|;
block|}
comment|/* Disable the LUN in SIM. */
name|ccb
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_EN_LUN
expr_stmt|;
name|ccb
operator|.
name|cel
operator|.
name|grp6_len
operator|=
literal|0
expr_stmt|;
name|ccb
operator|.
name|cel
operator|.
name|grp7_len
operator|=
literal|0
expr_stmt|;
name|ccb
operator|.
name|cel
operator|.
name|enable
operator|=
literal|0
expr_stmt|;
name|xpt_action
argument_list|(
operator|&
name|ccb
argument_list|)
expr_stmt|;
name|status
operator|=
operator|(
name|ccb
operator|.
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"%s: Disable LUN failed, status 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|ccb
operator|.
name|ccb_h
operator|.
name|status
argument_list|)
expr_stmt|;
comment|/* 		 * XXX KDM what do we do now? 		 */
block|}
name|bus_softc
operator|=
name|softc
operator|->
name|parent_softc
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|bus_softc
operator|->
name|lun_softc_mtx
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE
argument_list|(
operator|&
name|bus_softc
operator|->
name|lun_softc_list
argument_list|,
name|softc
argument_list|,
name|ctlfe_lun_softc
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|bus_softc
operator|->
name|lun_softc_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctlfecleanup
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|struct
name|ctlfe_lun_softc
modifier|*
name|softc
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|ctlfe_lun_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|KASSERT
argument_list|(
name|softc
operator|->
name|ctios_sent
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: ctios_sent %d != 0"
operator|,
name|__func__
operator|,
name|softc
operator|->
name|ctios_sent
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|softc
operator|->
name|refcount
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: refcount %d != 0"
operator|,
name|__func__
operator|,
name|softc
operator|->
name|refcount
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|softc
operator|->
name|atios_alloced
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: atios_alloced %d != 0"
operator|,
name|__func__
operator|,
name|softc
operator|->
name|atios_alloced
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|softc
operator|->
name|inots_alloced
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: inots_alloced %d != 0"
operator|,
name|__func__
operator|,
name|softc
operator|->
name|inots_alloced
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|softc
argument_list|,
name|M_CTLFE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctlfedata
parameter_list|(
name|struct
name|ctlfe_lun_softc
modifier|*
name|softc
parameter_list|,
name|union
name|ctl_io
modifier|*
name|io
parameter_list|,
name|ccb_flags
modifier|*
name|flags
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|data_ptr
parameter_list|,
name|uint32_t
modifier|*
name|dxfer_len
parameter_list|,
name|u_int16_t
modifier|*
name|sglist_cnt
parameter_list|)
block|{
name|struct
name|ctlfe_softc
modifier|*
name|bus_softc
decl_stmt|;
name|struct
name|ctlfe_cmd_info
modifier|*
name|cmd_info
decl_stmt|;
name|struct
name|ctl_sg_entry
modifier|*
name|ctl_sglist
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|cam_sglist
decl_stmt|;
name|size_t
name|off
decl_stmt|;
name|int
name|i
decl_stmt|,
name|idx
decl_stmt|;
name|cmd_info
operator|=
name|PRIV_INFO
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|bus_softc
operator|=
name|softc
operator|->
name|parent_softc
expr_stmt|;
comment|/* 	 * Set the direction, relative to the initiator. 	 */
operator|*
name|flags
operator|&=
operator|~
name|CAM_DIR_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_DATA_MASK
operator|)
operator|==
name|CTL_FLAG_DATA_IN
condition|)
operator|*
name|flags
operator||=
name|CAM_DIR_IN
expr_stmt|;
else|else
operator|*
name|flags
operator||=
name|CAM_DIR_OUT
expr_stmt|;
operator|*
name|flags
operator|&=
operator|~
name|CAM_DATA_MASK
expr_stmt|;
name|idx
operator|=
name|cmd_info
operator|->
name|cur_transfer_index
expr_stmt|;
name|off
operator|=
name|cmd_info
operator|->
name|cur_transfer_off
expr_stmt|;
name|cmd_info
operator|->
name|flags
operator|&=
operator|~
name|CTLFE_CMD_PIECEWISE
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|scsiio
operator|.
name|kern_sg_entries
operator|==
literal|0
condition|)
block|{
comment|/* No S/G list. */
comment|/* One time shift for SRR offset. */
name|off
operator|+=
name|io
operator|->
name|scsiio
operator|.
name|ext_data_filled
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|ext_data_filled
operator|=
literal|0
expr_stmt|;
operator|*
name|data_ptr
operator|=
name|io
operator|->
name|scsiio
operator|.
name|kern_data_ptr
operator|+
name|off
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|scsiio
operator|.
name|kern_data_len
operator|-
name|off
operator|<=
name|bus_softc
operator|->
name|maxio
condition|)
block|{
operator|*
name|dxfer_len
operator|=
name|io
operator|->
name|scsiio
operator|.
name|kern_data_len
operator|-
name|off
expr_stmt|;
block|}
else|else
block|{
operator|*
name|dxfer_len
operator|=
name|bus_softc
operator|->
name|maxio
expr_stmt|;
name|cmd_info
operator|->
name|cur_transfer_off
operator|+=
name|bus_softc
operator|->
name|maxio
expr_stmt|;
name|cmd_info
operator|->
name|flags
operator||=
name|CTLFE_CMD_PIECEWISE
expr_stmt|;
block|}
operator|*
name|sglist_cnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_BUS_ADDR
condition|)
operator|*
name|flags
operator||=
name|CAM_DATA_PADDR
expr_stmt|;
else|else
operator|*
name|flags
operator||=
name|CAM_DATA_VADDR
expr_stmt|;
block|}
else|else
block|{
comment|/* S/G list with physical or virtual pointers. */
name|ctl_sglist
operator|=
operator|(
expr|struct
name|ctl_sg_entry
operator|*
operator|)
name|io
operator|->
name|scsiio
operator|.
name|kern_data_ptr
expr_stmt|;
comment|/* One time shift for SRR offset. */
while|while
condition|(
name|io
operator|->
name|scsiio
operator|.
name|ext_data_filled
operator|>=
name|ctl_sglist
index|[
name|idx
index|]
operator|.
name|len
operator|-
name|off
condition|)
block|{
name|io
operator|->
name|scsiio
operator|.
name|ext_data_filled
operator|-=
name|ctl_sglist
index|[
name|idx
index|]
operator|.
name|len
operator|-
name|off
expr_stmt|;
name|idx
operator|++
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
block|}
name|off
operator|+=
name|io
operator|->
name|scsiio
operator|.
name|ext_data_filled
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|ext_data_filled
operator|=
literal|0
expr_stmt|;
name|cam_sglist
operator|=
name|cmd_info
operator|->
name|cam_sglist
expr_stmt|;
operator|*
name|dxfer_len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|io
operator|->
name|scsiio
operator|.
name|kern_sg_entries
operator|-
name|idx
condition|;
name|i
operator|++
control|)
block|{
name|cam_sglist
index|[
name|i
index|]
operator|.
name|ds_addr
operator|=
operator|(
name|bus_addr_t
operator|)
name|ctl_sglist
index|[
name|i
operator|+
name|idx
index|]
operator|.
name|addr
operator|+
name|off
expr_stmt|;
if|if
condition|(
name|ctl_sglist
index|[
name|i
operator|+
name|idx
index|]
operator|.
name|len
operator|-
name|off
operator|<=
name|bus_softc
operator|->
name|maxio
operator|-
operator|*
name|dxfer_len
condition|)
block|{
name|cam_sglist
index|[
name|i
index|]
operator|.
name|ds_len
operator|=
name|ctl_sglist
index|[
name|idx
operator|+
name|i
index|]
operator|.
name|len
operator|-
name|off
expr_stmt|;
operator|*
name|dxfer_len
operator|+=
name|cam_sglist
index|[
name|i
index|]
operator|.
name|ds_len
expr_stmt|;
block|}
else|else
block|{
name|cam_sglist
index|[
name|i
index|]
operator|.
name|ds_len
operator|=
name|bus_softc
operator|->
name|maxio
operator|-
operator|*
name|dxfer_len
expr_stmt|;
name|cmd_info
operator|->
name|cur_transfer_index
operator|=
name|idx
operator|+
name|i
expr_stmt|;
name|cmd_info
operator|->
name|cur_transfer_off
operator|=
name|cam_sglist
index|[
name|i
index|]
operator|.
name|ds_len
operator|+
name|off
expr_stmt|;
name|cmd_info
operator|->
name|flags
operator||=
name|CTLFE_CMD_PIECEWISE
expr_stmt|;
operator|*
name|dxfer_len
operator|+=
name|cam_sglist
index|[
name|i
index|]
operator|.
name|ds_len
expr_stmt|;
if|if
condition|(
name|ctl_sglist
index|[
name|i
index|]
operator|.
name|len
operator|!=
literal|0
condition|)
name|i
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
operator|(
name|CTLFE_MAX_SEGS
operator|-
literal|1
operator|)
operator|&&
name|idx
operator|+
name|i
operator|<
operator|(
name|io
operator|->
name|scsiio
operator|.
name|kern_sg_entries
operator|-
literal|1
operator|)
condition|)
block|{
name|cmd_info
operator|->
name|cur_transfer_index
operator|=
name|idx
operator|+
name|i
operator|+
literal|1
expr_stmt|;
name|cmd_info
operator|->
name|cur_transfer_off
operator|=
literal|0
expr_stmt|;
name|cmd_info
operator|->
name|flags
operator||=
name|CTLFE_CMD_PIECEWISE
expr_stmt|;
name|i
operator|++
expr_stmt|;
break|break;
block|}
name|off
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|sglist_cnt
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_BUS_ADDR
condition|)
operator|*
name|flags
operator||=
name|CAM_DATA_SG_PADDR
expr_stmt|;
else|else
operator|*
name|flags
operator||=
name|CAM_DATA_SG
expr_stmt|;
operator|*
name|data_ptr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|cam_sglist
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ctlfestart
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|start_ccb
parameter_list|)
block|{
name|struct
name|ctlfe_lun_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ctlfe_cmd_info
modifier|*
name|cmd_info
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
name|struct
name|ccb_accept_tio
modifier|*
name|atio
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|uint8_t
modifier|*
name|data_ptr
decl_stmt|;
name|uint32_t
name|dxfer_len
decl_stmt|;
name|ccb_flags
name|flags
decl_stmt|;
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|uint8_t
name|scsi_status
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|ctlfe_lun_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|next
label|:
comment|/* Take the ATIO off the work queue */
name|ccb_h
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|softc
operator|->
name|work_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb_h
operator|==
name|NULL
condition|)
block|{
name|xpt_release_ccb
argument_list|(
name|start_ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|softc
operator|->
name|work_queue
argument_list|,
name|periph_links
operator|.
name|stqe
argument_list|)
expr_stmt|;
name|atio
operator|=
operator|(
expr|struct
name|ccb_accept_tio
operator|*
operator|)
name|ccb_h
expr_stmt|;
name|io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ccb_h
operator|->
name|io_ptr
expr_stmt|;
name|csio
operator|=
operator|&
name|start_ccb
operator|->
name|csio
expr_stmt|;
name|flags
operator|=
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
operator|(
name|CAM_DIS_DISCONNECT
operator||
name|CAM_TAG_ACTION_VALID
operator||
name|CAM_DIR_MASK
operator|)
expr_stmt|;
name|cmd_info
operator|=
name|PRIV_INFO
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|cmd_info
operator|->
name|cur_transfer_index
operator|=
literal|0
expr_stmt|;
name|cmd_info
operator|->
name|cur_transfer_off
operator|=
literal|0
expr_stmt|;
name|cmd_info
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_DMA_QUEUED
condition|)
block|{
comment|/* 		 * Datamove call, we need to setup the S/G list. 		 */
name|ctlfedata
argument_list|(
name|softc
argument_list|,
name|io
argument_list|,
operator|&
name|flags
argument_list|,
operator|&
name|data_ptr
argument_list|,
operator|&
name|dxfer_len
argument_list|,
operator|&
name|csio
operator|->
name|sglist_cnt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * We're done, send status back. 		 */
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ABORT
operator|)
operator|&&
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ABORT_STATUS
operator|)
operator|==
literal|0
condition|)
block|{
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&=
operator|~
name|CTL_FLAG_STATUS_QUEUED
expr_stmt|;
comment|/* Tell the SIM that we've aborted this ATIO */
ifdef|#
directive|ifdef
name|CTLFEDEBUG
name|printf
argument_list|(
literal|"%s: tag %04x abort\n"
argument_list|,
name|__func__
argument_list|,
name|atio
operator|->
name|tag_id
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|atio
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ACCEPT_TARGET_IO
argument_list|,
operator|(
literal|"func_code %#x is not ATIO"
operator|,
name|atio
operator|->
name|ccb_h
operator|.
name|func_code
operator|)
argument_list|)
expr_stmt|;
name|start_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_ABORT
expr_stmt|;
name|start_ccb
operator|->
name|cab
operator|.
name|abort_ccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|atio
expr_stmt|;
name|xpt_action
argument_list|(
name|start_ccb
argument_list|)
expr_stmt|;
name|ctlfe_requeue_ccb
argument_list|(
name|periph
argument_list|,
operator|(
expr|union
name|ccb
operator|*
operator|)
name|atio
argument_list|,
comment|/* unlock */
literal|0
argument_list|)
expr_stmt|;
comment|/* XPT_ABORT is not queued, so we can take next I/O. */
goto|goto
name|next
goto|;
block|}
name|data_ptr
operator|=
name|NULL
expr_stmt|;
name|dxfer_len
operator|=
literal|0
expr_stmt|;
name|csio
operator|->
name|sglist_cnt
operator|=
literal|0
expr_stmt|;
block|}
name|scsi_status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_STATUS_QUEUED
operator|)
operator|&&
operator|(
name|cmd_info
operator|->
name|flags
operator|&
name|CTLFE_CMD_PIECEWISE
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_DMA_QUEUED
operator|)
operator|==
literal|0
operator|||
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|==
name|CTL_SUCCESS
operator|)
condition|)
block|{
name|flags
operator||=
name|CAM_SEND_STATUS
expr_stmt|;
name|scsi_status
operator|=
name|io
operator|->
name|scsiio
operator|.
name|scsi_status
expr_stmt|;
name|csio
operator|->
name|sense_len
operator|=
name|io
operator|->
name|scsiio
operator|.
name|sense_len
expr_stmt|;
ifdef|#
directive|ifdef
name|CTLFEDEBUG
name|printf
argument_list|(
literal|"%s: tag %04x status %x\n"
argument_list|,
name|__func__
argument_list|,
name|atio
operator|->
name|tag_id
argument_list|,
name|io
operator|->
name|io_hdr
operator|.
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|csio
operator|->
name|sense_len
operator|!=
literal|0
condition|)
block|{
name|csio
operator|->
name|sense_data
operator|=
name|io
operator|->
name|scsiio
operator|.
name|sense_data
expr_stmt|;
name|flags
operator||=
name|CAM_SEND_SENSE
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|CTLFEDEBUG
name|printf
argument_list|(
literal|"%s: %s: tag %04x flags %x ptr %p len %u\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|flags
operator|&
name|CAM_SEND_STATUS
operator|)
condition|?
literal|"done"
else|:
literal|"datamove"
argument_list|,
name|atio
operator|->
name|tag_id
argument_list|,
name|flags
argument_list|,
name|data_ptr
argument_list|,
name|dxfer_len
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Valid combinations: 	 *  - CAM_SEND_STATUS, CAM_DATA_SG = 0, dxfer_len = 0, 	 *    sglist_cnt = 0 	 *  - CAM_SEND_STATUS = 0, CAM_DATA_SG = 0, dxfer_len != 0, 	 *    sglist_cnt = 0 	 *  - CAM_SEND_STATUS = 0, CAM_DATA_SG, dxfer_len != 0, 	 *    sglist_cnt != 0 	 */
ifdef|#
directive|ifdef
name|CTLFEDEBUG
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
name|CAM_SEND_STATUS
operator|)
operator|&&
operator|(
operator|(
operator|(
name|flags
operator|&
name|CAM_DATA_SG
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|dxfer_len
operator|!=
literal|0
operator|)
operator|||
operator|(
name|csio
operator|->
name|sglist_cnt
operator|!=
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
operator|(
operator|(
name|flags
operator|&
name|CAM_SEND_STATUS
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|dxfer_len
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
operator|(
name|flags
operator|&
name|CAM_DATA_SG
operator|)
operator|&&
operator|(
name|csio
operator|->
name|sglist_cnt
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
operator|(
operator|(
name|flags
operator|&
name|CAM_DATA_SG
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|csio
operator|->
name|sglist_cnt
operator|!=
literal|0
operator|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: tag %04x cdb %02x flags %#x dxfer_len "
literal|"%d sg %u\n"
argument_list|,
name|__func__
argument_list|,
name|atio
operator|->
name|tag_id
argument_list|,
name|atio_cdb_ptr
argument_list|(
name|atio
argument_list|)
index|[
literal|0
index|]
argument_list|,
name|flags
argument_list|,
name|dxfer_len
argument_list|,
name|csio
operator|->
name|sglist_cnt
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: tag %04x io status %#x\n"
argument_list|,
name|__func__
argument_list|,
name|atio
operator|->
name|tag_id
argument_list|,
name|io
operator|->
name|io_hdr
operator|.
name|status
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|cam_fill_ctio
argument_list|(
name|csio
argument_list|,
comment|/*retries*/
literal|2
argument_list|,
name|ctlfedone
argument_list|,
name|flags
argument_list|,
operator|(
name|flags
operator|&
name|CAM_TAG_ACTION_VALID
operator|)
condition|?
name|MSG_SIMPLE_Q_TAG
else|:
literal|0
argument_list|,
name|atio
operator|->
name|tag_id
argument_list|,
name|atio
operator|->
name|init_id
argument_list|,
name|scsi_status
argument_list|,
comment|/*data_ptr*/
name|data_ptr
argument_list|,
comment|/*dxfer_len*/
name|dxfer_len
argument_list|,
comment|/*timeout*/
name|CTLFE_TIMEOUT
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|start_ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_UNLOCKED
expr_stmt|;
name|start_ccb
operator|->
name|ccb_h
operator|.
name|ccb_atio
operator|=
name|atio
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_DMA_QUEUED
condition|)
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_DMA_INPROG
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&=
operator|~
operator|(
name|CTL_FLAG_DMA_QUEUED
operator||
name|CTL_FLAG_STATUS_QUEUED
operator|)
expr_stmt|;
name|softc
operator|->
name|ctios_sent
operator|++
expr_stmt|;
name|softc
operator|->
name|refcount
operator|++
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|xpt_action
argument_list|(
name|start_ccb
argument_list|)
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|softc
operator|->
name|refcount
operator|--
expr_stmt|;
comment|/* 	 * If we still have work to do, ask for another CCB. 	 */
if|if
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|softc
operator|->
name|work_queue
argument_list|)
condition|)
name|xpt_schedule
argument_list|(
name|periph
argument_list|,
name|CAM_PRIORITY_NORMAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctlfe_drain
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
init|=
name|context
decl_stmt|;
name|struct
name|ctlfe_lun_softc
modifier|*
name|softc
init|=
name|periph
operator|->
name|softc
decl_stmt|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
while|while
condition|(
name|softc
operator|->
name|refcount
operator|!=
literal|0
condition|)
block|{
name|cam_periph_sleep
argument_list|(
name|periph
argument_list|,
operator|&
name|softc
operator|->
name|refcount
argument_list|,
name|PRIBIO
argument_list|,
literal|"ctlfe_drain"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|cam_periph_release
argument_list|(
name|periph
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctlfe_free_ccb
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|ctlfe_lun_softc
modifier|*
name|softc
decl_stmt|;
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|struct
name|ctlfe_cmd_info
modifier|*
name|cmd_info
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|ctlfe_lun_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|io
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|io_ptr
expr_stmt|;
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_ACCEPT_TARGET_IO
case|:
name|softc
operator|->
name|atios_alloced
operator|--
expr_stmt|;
name|cmd_info
operator|=
name|PRIV_INFO
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cmd_info
argument_list|,
name|M_CTLFE
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_IMMEDIATE_NOTIFY
case|:
case|case
name|XPT_NOTIFY_ACKNOWLEDGE
case|:
name|softc
operator|->
name|inots_alloced
operator|--
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|ctl_free_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ccb
argument_list|,
name|M_CTLFE
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|softc
operator|->
name|atios_alloced
operator|>=
literal|0
argument_list|,
operator|(
literal|"%s: atios_alloced %d< 0"
operator|,
name|__func__
operator|,
name|softc
operator|->
name|atios_alloced
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|softc
operator|->
name|inots_alloced
operator|>=
literal|0
argument_list|,
operator|(
literal|"%s: inots_alloced %d< 0"
operator|,
name|__func__
operator|,
name|softc
operator|->
name|inots_alloced
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If we have received all of our CCBs, we can release our 	 * reference on the peripheral driver.  It will probably go away 	 * now. 	 */
if|if
condition|(
name|softc
operator|->
name|atios_alloced
operator|==
literal|0
operator|&&
name|softc
operator|->
name|inots_alloced
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|softc
operator|->
name|refcount
operator|==
literal|0
condition|)
block|{
name|cam_periph_release_locked
argument_list|(
name|periph
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TASK_INIT
argument_list|(
operator|&
name|softc
operator|->
name|refdrain_task
argument_list|,
literal|0
argument_list|,
name|ctlfe_drain
argument_list|,
name|periph
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|softc
operator|->
name|refdrain_task
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Send the ATIO/INOT back to the SIM, or free it if periph was invalidated.  */
end_comment

begin_function
specifier|static
name|void
name|ctlfe_requeue_ccb
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|int
name|unlock
parameter_list|)
block|{
name|struct
name|ctlfe_lun_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|mtx
modifier|*
name|mtx
decl_stmt|;
if|if
condition|(
name|periph
operator|->
name|flags
operator|&
name|CAM_PERIPH_INVALID
condition|)
block|{
name|mtx
operator|=
name|cam_periph_mtx
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|ctlfe_free_ccb
argument_list|(
name|periph
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlock
condition|)
name|mtx_unlock
argument_list|(
name|mtx
argument_list|)
expr_stmt|;
return|return;
block|}
name|softc
operator|=
operator|(
expr|struct
name|ctlfe_lun_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ACCEPT_TARGET_IO
condition|)
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|softc
operator|->
name|atio_list
argument_list|,
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|le
argument_list|)
expr_stmt|;
else|else
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|softc
operator|->
name|inot_list
argument_list|,
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|le
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlock
condition|)
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
comment|/* 	 * For a wildcard attachment, commands can come in with a specific 	 * target/lun.  Reset the target and LUN fields back to the wildcard 	 * values before we send them back down to the SIM. 	 */
name|xpt_setup_ccb
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
name|CAM_PRIORITY_NONE
argument_list|)
expr_stmt|;
name|xpt_action
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctlfe_adjust_cdb
parameter_list|(
name|struct
name|ccb_accept_tio
modifier|*
name|atio
parameter_list|,
name|uint32_t
name|offset
parameter_list|)
block|{
name|uint64_t
name|lba
decl_stmt|;
name|uint32_t
name|num_blocks
decl_stmt|,
name|nbc
decl_stmt|;
name|uint8_t
modifier|*
name|cmdbyt
init|=
name|atio_cdb_ptr
argument_list|(
name|atio
argument_list|)
decl_stmt|;
name|nbc
operator|=
name|offset
operator|>>
literal|9
expr_stmt|;
comment|/* ASSUMING 512 BYTE BLOCKS */
switch|switch
condition|(
name|cmdbyt
index|[
literal|0
index|]
condition|)
block|{
case|case
name|READ_6
case|:
case|case
name|WRITE_6
case|:
block|{
name|struct
name|scsi_rw_6
modifier|*
name|cdb
init|=
operator|(
expr|struct
name|scsi_rw_6
operator|*
operator|)
name|cmdbyt
decl_stmt|;
name|lba
operator|=
name|scsi_3btoul
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
name|lba
operator|&=
literal|0x1fffff
expr_stmt|;
name|num_blocks
operator|=
name|cdb
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|num_blocks
operator|==
literal|0
condition|)
name|num_blocks
operator|=
literal|256
expr_stmt|;
name|lba
operator|+=
name|nbc
expr_stmt|;
name|num_blocks
operator|-=
name|nbc
expr_stmt|;
name|scsi_ulto3b
argument_list|(
name|lba
argument_list|,
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
name|cdb
operator|->
name|length
operator|=
name|num_blocks
expr_stmt|;
break|break;
block|}
case|case
name|READ_10
case|:
case|case
name|WRITE_10
case|:
block|{
name|struct
name|scsi_rw_10
modifier|*
name|cdb
init|=
operator|(
expr|struct
name|scsi_rw_10
operator|*
operator|)
name|cmdbyt
decl_stmt|;
name|lba
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
name|num_blocks
operator|=
name|scsi_2btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
name|lba
operator|+=
name|nbc
expr_stmt|;
name|num_blocks
operator|-=
name|nbc
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|lba
argument_list|,
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|num_blocks
argument_list|,
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|READ_12
case|:
case|case
name|WRITE_12
case|:
block|{
name|struct
name|scsi_rw_12
modifier|*
name|cdb
init|=
operator|(
expr|struct
name|scsi_rw_12
operator|*
operator|)
name|cmdbyt
decl_stmt|;
name|lba
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
name|num_blocks
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
name|lba
operator|+=
name|nbc
expr_stmt|;
name|num_blocks
operator|-=
name|nbc
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|lba
argument_list|,
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|num_blocks
argument_list|,
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|READ_16
case|:
case|case
name|WRITE_16
case|:
block|{
name|struct
name|scsi_rw_16
modifier|*
name|cdb
init|=
operator|(
expr|struct
name|scsi_rw_16
operator|*
operator|)
name|cmdbyt
decl_stmt|;
name|lba
operator|=
name|scsi_8btou64
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
name|num_blocks
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
name|lba
operator|+=
name|nbc
expr_stmt|;
name|num_blocks
operator|-=
name|nbc
expr_stmt|;
name|scsi_u64to8b
argument_list|(
name|lba
argument_list|,
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|num_blocks
argument_list|,
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
return|return
operator|-
literal|1
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctlfedone
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|done_ccb
parameter_list|)
block|{
name|struct
name|ctlfe_lun_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ctlfe_softc
modifier|*
name|bus_softc
decl_stmt|;
name|struct
name|ctlfe_cmd_info
modifier|*
name|cmd_info
decl_stmt|;
name|struct
name|ccb_accept_tio
modifier|*
name|atio
init|=
name|NULL
decl_stmt|;
name|union
name|ctl_io
modifier|*
name|io
init|=
name|NULL
decl_stmt|;
name|struct
name|mtx
modifier|*
name|mtx
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_UNLOCKED
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"CCB in ctlfedone() without CAM_UNLOCKED flag"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CTLFE_DEBUG
name|printf
argument_list|(
literal|"%s: entered, func_code = %#x\n"
argument_list|,
name|__func__
argument_list|,
name|done_ccb
operator|->
name|ccb_h
operator|.
name|func_code
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * At this point CTL has no known use case for device queue freezes. 	 * In case some SIM think different -- drop its freeze right here. 	 */
if|if
condition|(
operator|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|!=
literal|0
condition|)
block|{
name|cam_release_devq
argument_list|(
name|periph
operator|->
name|path
argument_list|,
comment|/*relsim_flags*/
literal|0
argument_list|,
comment|/*reduction*/
literal|0
argument_list|,
comment|/*timeout*/
literal|0
argument_list|,
comment|/*getcount_only*/
literal|0
argument_list|)
expr_stmt|;
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_DEV_QFRZN
expr_stmt|;
block|}
name|softc
operator|=
operator|(
expr|struct
name|ctlfe_lun_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|bus_softc
operator|=
name|softc
operator|->
name|parent_softc
expr_stmt|;
name|mtx
operator|=
name|cam_periph_mtx
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
name|mtx
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_ACCEPT_TARGET_IO
case|:
block|{
name|LIST_REMOVE
argument_list|(
operator|&
name|done_ccb
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|le
argument_list|)
expr_stmt|;
name|atio
operator|=
operator|&
name|done_ccb
operator|->
name|atio
expr_stmt|;
name|status
operator|=
name|atio
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_CDB_RECVD
condition|)
block|{
name|ctlfe_free_ccb
argument_list|(
name|periph
argument_list|,
name|done_ccb
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|resubmit
label|:
comment|/* 		 * Allocate a ctl_io, pass it to CTL, and wait for the 		 * datamove or done. 		 */
name|mtx_unlock
argument_list|(
name|mtx
argument_list|)
expr_stmt|;
name|io
operator|=
name|done_ccb
operator|->
name|ccb_h
operator|.
name|io_ptr
expr_stmt|;
name|cmd_info
operator|=
name|PRIV_INFO
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|ctl_zero_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
comment|/* Save pointers on both sides */
name|PRIV_CCB
argument_list|(
name|io
argument_list|)
operator|=
name|done_ccb
expr_stmt|;
name|PRIV_INFO
argument_list|(
name|io
argument_list|)
operator|=
name|cmd_info
expr_stmt|;
name|done_ccb
operator|->
name|ccb_h
operator|.
name|io_ptr
operator|=
name|io
expr_stmt|;
comment|/* 		 * Only SCSI I/O comes down this path, resets, etc. come 		 * down the immediate notify path below. 		 */
name|io
operator|->
name|io_hdr
operator|.
name|io_type
operator|=
name|CTL_IO_SCSI
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|initid
operator|=
name|atio
operator|->
name|init_id
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
operator|=
name|bus_softc
operator|->
name|port
operator|.
name|targ_port
expr_stmt|;
if|if
condition|(
name|bus_softc
operator|->
name|hba_misc
operator|&
name|PIM_EXTLUNS
condition|)
block|{
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_lun
operator|=
name|ctl_decode_lun
argument_list|(
name|CAM_EXTLUN_BYTE_SWIZZLE
argument_list|(
name|atio
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_lun
operator|=
name|atio
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
block|}
name|io
operator|->
name|scsiio
operator|.
name|tag_num
operator|=
name|atio
operator|->
name|tag_id
expr_stmt|;
switch|switch
condition|(
name|atio
operator|->
name|tag_action
condition|)
block|{
case|case
name|CAM_TAG_ACTION_NONE
case|:
name|io
operator|->
name|scsiio
operator|.
name|tag_type
operator|=
name|CTL_TAG_UNTAGGED
expr_stmt|;
break|break;
case|case
name|MSG_SIMPLE_TASK
case|:
name|io
operator|->
name|scsiio
operator|.
name|tag_type
operator|=
name|CTL_TAG_SIMPLE
expr_stmt|;
break|break;
case|case
name|MSG_HEAD_OF_QUEUE_TASK
case|:
name|io
operator|->
name|scsiio
operator|.
name|tag_type
operator|=
name|CTL_TAG_HEAD_OF_QUEUE
expr_stmt|;
break|break;
case|case
name|MSG_ORDERED_TASK
case|:
name|io
operator|->
name|scsiio
operator|.
name|tag_type
operator|=
name|CTL_TAG_ORDERED
expr_stmt|;
break|break;
case|case
name|MSG_ACA_TASK
case|:
name|io
operator|->
name|scsiio
operator|.
name|tag_type
operator|=
name|CTL_TAG_ACA
expr_stmt|;
break|break;
default|default:
name|io
operator|->
name|scsiio
operator|.
name|tag_type
operator|=
name|CTL_TAG_UNTAGGED
expr_stmt|;
name|printf
argument_list|(
literal|"%s: unhandled tag type %#x!!\n"
argument_list|,
name|__func__
argument_list|,
name|atio
operator|->
name|tag_action
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|atio
operator|->
name|cdb_len
operator|>
sizeof|sizeof
argument_list|(
name|io
operator|->
name|scsiio
operator|.
name|cdb
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: WARNING: CDB len %d> ctl_io space %zd\n"
argument_list|,
name|__func__
argument_list|,
name|atio
operator|->
name|cdb_len
argument_list|,
sizeof|sizeof
argument_list|(
name|io
operator|->
name|scsiio
operator|.
name|cdb
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|io
operator|->
name|scsiio
operator|.
name|cdb_len
operator|=
name|min
argument_list|(
name|atio
operator|->
name|cdb_len
argument_list|,
sizeof|sizeof
argument_list|(
name|io
operator|->
name|scsiio
operator|.
name|cdb
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|atio_cdb_ptr
argument_list|(
name|atio
argument_list|)
argument_list|,
name|io
operator|->
name|scsiio
operator|.
name|cdb
argument_list|,
name|io
operator|->
name|scsiio
operator|.
name|cdb_len
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CTLFEDEBUG
name|printf
argument_list|(
literal|"%s: %u:%u:%u: tag %04x CDB %02x\n"
argument_list|,
name|__func__
argument_list|,
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|initid
argument_list|,
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
argument_list|,
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_lun
argument_list|,
name|io
operator|->
name|scsiio
operator|.
name|tag_num
argument_list|,
name|io
operator|->
name|scsiio
operator|.
name|cdb
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ctl_queue
argument_list|(
name|io
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|XPT_CONT_TARGET_IO
case|:
block|{
name|int
name|srr
init|=
literal|0
decl_stmt|;
name|uint32_t
name|srr_off
init|=
literal|0
decl_stmt|;
name|atio
operator|=
operator|(
expr|struct
name|ccb_accept_tio
operator|*
operator|)
name|done_ccb
operator|->
name|ccb_h
operator|.
name|ccb_atio
expr_stmt|;
name|io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|atio
operator|->
name|ccb_h
operator|.
name|io_ptr
expr_stmt|;
name|softc
operator|->
name|ctios_sent
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|CTLFEDEBUG
name|printf
argument_list|(
literal|"%s: got XPT_CONT_TARGET_IO tag %#x flags %#x\n"
argument_list|,
name|__func__
argument_list|,
name|atio
operator|->
name|tag_id
argument_list|,
name|done_ccb
operator|->
name|ccb_h
operator|.
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * Handle SRR case were the data pointer is pushed back hack 		 */
if|if
condition|(
operator|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_MESSAGE_RECV
operator|&&
name|done_ccb
operator|->
name|csio
operator|.
name|msg_ptr
operator|!=
name|NULL
operator|&&
name|done_ccb
operator|->
name|csio
operator|.
name|msg_ptr
index|[
literal|0
index|]
operator|==
name|MSG_EXTENDED
operator|&&
name|done_ccb
operator|->
name|csio
operator|.
name|msg_ptr
index|[
literal|1
index|]
operator|==
literal|5
operator|&&
name|done_ccb
operator|->
name|csio
operator|.
name|msg_ptr
index|[
literal|2
index|]
operator|==
literal|0
condition|)
block|{
name|srr
operator|=
literal|1
expr_stmt|;
name|srr_off
operator|=
operator|(
name|done_ccb
operator|->
name|csio
operator|.
name|msg_ptr
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|done_ccb
operator|->
name|csio
operator|.
name|msg_ptr
index|[
literal|4
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|done_ccb
operator|->
name|csio
operator|.
name|msg_ptr
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|done_ccb
operator|->
name|csio
operator|.
name|msg_ptr
index|[
literal|6
index|]
operator|)
expr_stmt|;
block|}
comment|/* 		 * If we have an SRR and we're still sending data, we 		 * should be able to adjust offsets and cycle again. 		 * It is possible only if offset is from this datamove. 		 */
if|if
condition|(
name|srr
operator|&&
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_DMA_INPROG
operator|)
operator|&&
name|srr_off
operator|>=
name|io
operator|->
name|scsiio
operator|.
name|kern_rel_offset
operator|&&
name|srr_off
operator|<
name|io
operator|->
name|scsiio
operator|.
name|kern_rel_offset
operator|+
name|io
operator|->
name|scsiio
operator|.
name|kern_data_len
condition|)
block|{
name|io
operator|->
name|scsiio
operator|.
name|kern_data_resid
operator|=
name|io
operator|->
name|scsiio
operator|.
name|kern_rel_offset
operator|+
name|io
operator|->
name|scsiio
operator|.
name|kern_data_len
operator|-
name|srr_off
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|ext_data_filled
operator|=
name|srr_off
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|io_hdr
operator|.
name|status
operator|=
name|CTL_STATUS_NONE
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_DMA_QUEUED
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|softc
operator|->
name|work_queue
argument_list|,
operator|&
name|atio
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|stqe
argument_list|)
expr_stmt|;
name|xpt_schedule
argument_list|(
name|periph
argument_list|,
name|CAM_PRIORITY_NORMAL
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * If status was being sent, the back end data is now history. 		 * Hack it up and resubmit a new command with the CDB adjusted. 		 * If the SIM does the right thing, all of the resid math 		 * should work. 		 */
if|if
condition|(
name|srr
operator|&&
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_DMA_INPROG
operator|)
operator|==
literal|0
condition|)
block|{
name|xpt_release_ccb
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctlfe_adjust_cdb
argument_list|(
name|atio
argument_list|,
name|srr_off
argument_list|)
operator|==
literal|0
condition|)
block|{
name|done_ccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|atio
expr_stmt|;
goto|goto
name|resubmit
goto|;
block|}
comment|/* 			 * Fall through to doom.... 			 */
block|}
if|if
condition|(
operator|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SEND_STATUS
operator|)
operator|&&
operator|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_CMP
condition|)
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_STATUS_SENT
expr_stmt|;
comment|/* 		 * If we were sending status back to the initiator, free up 		 * resources.  If we were doing a datamove, call the 		 * datamove done routine. 		 */
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_DMA_INPROG
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * If we asked to send sense data but it wasn't sent, 			 * queue the I/O back to CTL for later REQUEST SENSE. 			 */
if|if
condition|(
operator|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SEND_SENSE
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_CMP
operator|&&
operator|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_SENT_SENSE
operator|)
operator|==
literal|0
operator|&&
operator|(
name|io
operator|=
name|ctl_alloc_io_nowait
argument_list|(
name|bus_softc
operator|->
name|port
operator|.
name|ctl_pool_ref
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|PRIV_INFO
argument_list|(
name|io
argument_list|)
operator|=
name|PRIV_INFO
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|atio
operator|->
name|ccb_h
operator|.
name|io_ptr
argument_list|)
expr_stmt|;
name|ctl_queue_sense
argument_list|(
name|atio
operator|->
name|ccb_h
operator|.
name|io_ptr
argument_list|)
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|io_ptr
operator|=
name|io
expr_stmt|;
block|}
comment|/* Abort ATIO if CTIO sending status has failed. */
if|if
condition|(
operator|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|done_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_ABORT
expr_stmt|;
name|done_ccb
operator|->
name|cab
operator|.
name|abort_ccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|atio
expr_stmt|;
name|xpt_action
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
block|}
name|xpt_release_ccb
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
name|ctlfe_requeue_ccb
argument_list|(
name|periph
argument_list|,
operator|(
expr|union
name|ccb
operator|*
operator|)
name|atio
argument_list|,
comment|/* unlock */
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|struct
name|ctlfe_cmd_info
modifier|*
name|cmd_info
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|csio
operator|=
operator|&
name|done_ccb
operator|->
name|csio
expr_stmt|;
name|cmd_info
operator|=
name|PRIV_INFO
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&=
operator|~
name|CTL_FLAG_DMA_INPROG
expr_stmt|;
comment|/* 			 * Translate CAM status to CTL status.  Success 			 * does not change the overall, ctl_io status.  In 			 * that case we just set port_status to 0.  If we 			 * have a failure, though, set a data phase error 			 * for the overall ctl_io. 			 */
switch|switch
condition|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
condition|)
block|{
case|case
name|CAM_REQ_CMP
case|:
name|io
operator|->
name|scsiio
operator|.
name|kern_data_resid
operator|-=
name|csio
operator|->
name|dxfer_len
operator|-
name|csio
operator|->
name|resid
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|port_status
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
comment|/* 				 * XXX KDM we probably need to figure out a 				 * standard set of errors that the SIM 				 * drivers should return in the event of a 				 * data transfer failure.  A data phase 				 * error will at least point the user to a 				 * data transfer error of some sort. 				 * Hopefully the SIM printed out some 				 * additional information to give the user 				 * a clue what happened. 				 */
name|io
operator|->
name|io_hdr
operator|.
name|port_status
operator|=
literal|0xbad1
expr_stmt|;
name|ctl_set_data_phase_error
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
comment|/* 				 * XXX KDM figure out residual. 				 */
break|break;
block|}
comment|/* 			 * If we had to break this S/G list into multiple 			 * pieces, figure out where we are in the list, and 			 * continue sending pieces if necessary. 			 */
if|if
condition|(
operator|(
name|cmd_info
operator|->
name|flags
operator|&
name|CTLFE_CMD_PIECEWISE
operator|)
operator|&&
name|io
operator|->
name|io_hdr
operator|.
name|port_status
operator|==
literal|0
operator|&&
name|csio
operator|->
name|resid
operator|==
literal|0
condition|)
block|{
name|ccb_flags
name|flags
decl_stmt|;
name|uint8_t
modifier|*
name|data_ptr
decl_stmt|;
name|uint32_t
name|dxfer_len
decl_stmt|;
name|flags
operator|=
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
operator|(
name|CAM_DIS_DISCONNECT
operator||
name|CAM_TAG_ACTION_VALID
operator|)
expr_stmt|;
name|ctlfedata
argument_list|(
name|softc
argument_list|,
name|io
argument_list|,
operator|&
name|flags
argument_list|,
operator|&
name|data_ptr
argument_list|,
operator|&
name|dxfer_len
argument_list|,
operator|&
name|csio
operator|->
name|sglist_cnt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
name|CAM_SEND_STATUS
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|dxfer_len
operator|==
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: tag %04x no status or "
literal|"len cdb = %02x\n"
argument_list|,
name|__func__
argument_list|,
name|atio
operator|->
name|tag_id
argument_list|,
name|atio_cdb_ptr
argument_list|(
name|atio
argument_list|)
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: tag %04x io status %#x\n"
argument_list|,
name|__func__
argument_list|,
name|atio
operator|->
name|tag_id
argument_list|,
name|io
operator|->
name|io_hdr
operator|.
name|status
argument_list|)
expr_stmt|;
block|}
name|cam_fill_ctio
argument_list|(
name|csio
argument_list|,
comment|/*retries*/
literal|2
argument_list|,
name|ctlfedone
argument_list|,
name|flags
argument_list|,
operator|(
name|flags
operator|&
name|CAM_TAG_ACTION_VALID
operator|)
condition|?
name|MSG_SIMPLE_Q_TAG
else|:
literal|0
argument_list|,
name|atio
operator|->
name|tag_id
argument_list|,
name|atio
operator|->
name|init_id
argument_list|,
literal|0
argument_list|,
comment|/*data_ptr*/
name|data_ptr
argument_list|,
comment|/*dxfer_len*/
name|dxfer_len
argument_list|,
name|CTLFE_TIMEOUT
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_UNLOCKED
expr_stmt|;
name|csio
operator|->
name|resid
operator|=
literal|0
expr_stmt|;
name|csio
operator|->
name|ccb_h
operator|.
name|ccb_atio
operator|=
name|atio
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_DMA_INPROG
expr_stmt|;
name|softc
operator|->
name|ctios_sent
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
name|mtx
argument_list|)
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|csio
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Release the CTIO.  The ATIO will be sent back 				 * down to the SIM once we send status. 				 */
name|xpt_release_ccb
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
name|mtx
argument_list|)
expr_stmt|;
comment|/* Call the backend move done callback */
name|io
operator|->
name|scsiio
operator|.
name|be_move_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
break|break;
block|}
case|case
name|XPT_IMMEDIATE_NOTIFY
case|:
block|{
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|struct
name|ccb_immediate_notify
modifier|*
name|inot
decl_stmt|;
name|int
name|send_ctl_io
decl_stmt|;
name|LIST_REMOVE
argument_list|(
operator|&
name|done_ccb
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|le
argument_list|)
expr_stmt|;
name|inot
operator|=
operator|&
name|done_ccb
operator|->
name|cin1
expr_stmt|;
name|io
operator|=
name|done_ccb
operator|->
name|ccb_h
operator|.
name|io_ptr
expr_stmt|;
name|ctl_zero_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|send_ctl_io
operator|=
literal|1
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|io_type
operator|=
name|CTL_IO_TASK
expr_stmt|;
name|PRIV_CCB
argument_list|(
name|io
argument_list|)
operator|=
name|done_ccb
expr_stmt|;
name|inot
operator|->
name|ccb_h
operator|.
name|io_ptr
operator|=
name|io
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|initid
operator|=
name|inot
operator|->
name|initiator_id
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
operator|=
name|bus_softc
operator|->
name|port
operator|.
name|targ_port
expr_stmt|;
if|if
condition|(
name|bus_softc
operator|->
name|hba_misc
operator|&
name|PIM_EXTLUNS
condition|)
block|{
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_lun
operator|=
name|ctl_decode_lun
argument_list|(
name|CAM_EXTLUN_BYTE_SWIZZLE
argument_list|(
name|inot
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_lun
operator|=
name|inot
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
block|}
comment|/* XXX KDM should this be the tag_id? */
name|io
operator|->
name|taskio
operator|.
name|tag_num
operator|=
name|inot
operator|->
name|seq_id
expr_stmt|;
name|status
operator|=
name|inot
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
expr_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|CAM_SCSI_BUS_RESET
case|:
name|io
operator|->
name|taskio
operator|.
name|task_action
operator|=
name|CTL_TASK_BUS_RESET
expr_stmt|;
break|break;
case|case
name|CAM_BDR_SENT
case|:
name|io
operator|->
name|taskio
operator|.
name|task_action
operator|=
name|CTL_TASK_TARGET_RESET
expr_stmt|;
break|break;
case|case
name|CAM_MESSAGE_RECV
case|:
switch|switch
condition|(
name|inot
operator|->
name|arg
condition|)
block|{
case|case
name|MSG_ABORT_TASK_SET
case|:
name|io
operator|->
name|taskio
operator|.
name|task_action
operator|=
name|CTL_TASK_ABORT_TASK_SET
expr_stmt|;
break|break;
case|case
name|MSG_TARGET_RESET
case|:
name|io
operator|->
name|taskio
operator|.
name|task_action
operator|=
name|CTL_TASK_TARGET_RESET
expr_stmt|;
break|break;
case|case
name|MSG_ABORT_TASK
case|:
name|io
operator|->
name|taskio
operator|.
name|task_action
operator|=
name|CTL_TASK_ABORT_TASK
expr_stmt|;
break|break;
case|case
name|MSG_LOGICAL_UNIT_RESET
case|:
name|io
operator|->
name|taskio
operator|.
name|task_action
operator|=
name|CTL_TASK_LUN_RESET
expr_stmt|;
break|break;
case|case
name|MSG_CLEAR_TASK_SET
case|:
name|io
operator|->
name|taskio
operator|.
name|task_action
operator|=
name|CTL_TASK_CLEAR_TASK_SET
expr_stmt|;
break|break;
case|case
name|MSG_CLEAR_ACA
case|:
name|io
operator|->
name|taskio
operator|.
name|task_action
operator|=
name|CTL_TASK_CLEAR_ACA
expr_stmt|;
break|break;
case|case
name|MSG_QUERY_TASK
case|:
name|io
operator|->
name|taskio
operator|.
name|task_action
operator|=
name|CTL_TASK_QUERY_TASK
expr_stmt|;
break|break;
case|case
name|MSG_QUERY_TASK_SET
case|:
name|io
operator|->
name|taskio
operator|.
name|task_action
operator|=
name|CTL_TASK_QUERY_TASK_SET
expr_stmt|;
break|break;
case|case
name|MSG_QUERY_ASYNC_EVENT
case|:
name|io
operator|->
name|taskio
operator|.
name|task_action
operator|=
name|CTL_TASK_QUERY_ASYNC_EVENT
expr_stmt|;
break|break;
case|case
name|MSG_NOOP
case|:
name|send_ctl_io
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"%s: unsupported INOT message 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|inot
operator|->
name|arg
argument_list|)
expr_stmt|;
name|send_ctl_io
operator|=
literal|0
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"%s: unsupported INOT status 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|CAM_REQ_ABORTED
case|:
case|case
name|CAM_REQ_INVALID
case|:
case|case
name|CAM_DEV_NOT_THERE
case|:
case|case
name|CAM_PROVIDE_FAIL
case|:
name|ctlfe_free_ccb
argument_list|(
name|periph
argument_list|,
name|done_ccb
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|send_ctl_io
operator|!=
literal|0
condition|)
block|{
name|ctl_queue
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INPROG
expr_stmt|;
name|done_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_NOTIFY_ACKNOWLEDGE
expr_stmt|;
name|xpt_action
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|XPT_NOTIFY_ACKNOWLEDGE
case|:
comment|/* Queue this back down to the SIM as an immediate notify. */
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INPROG
expr_stmt|;
name|done_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_IMMEDIATE_NOTIFY
expr_stmt|;
name|ctlfe_requeue_ccb
argument_list|(
name|periph
argument_list|,
name|done_ccb
argument_list|,
comment|/* unlock */
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
name|XPT_SET_SIM_KNOB
case|:
case|case
name|XPT_GET_SIM_KNOB
case|:
case|case
name|XPT_GET_SIM_KNOB_OLD
case|:
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: unexpected CCB type %#x"
argument_list|,
name|__func__
argument_list|,
name|done_ccb
operator|->
name|ccb_h
operator|.
name|func_code
argument_list|)
expr_stmt|;
break|break;
block|}
name|out
label|:
name|mtx_unlock
argument_list|(
name|mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctlfe_onoffline
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|online
parameter_list|)
block|{
name|struct
name|ctlfe_softc
modifier|*
name|bus_softc
init|=
name|arg
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|int
name|set_wwnn
init|=
literal|0
decl_stmt|;
name|status
operator|=
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|bus_softc
operator|->
name|path_id
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unable to create path!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|ccb
operator|=
name|xpt_alloc_ccb
argument_list|()
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|path
argument_list|,
name|CAM_PRIORITY_NONE
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_GET_SIM_KNOB
expr_stmt|;
name|xpt_action
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
comment|/* Check whether we should change WWNs. */
if|if
condition|(
name|online
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ccb
operator|->
name|knob
operator|.
name|xport_specific
operator|.
name|valid
operator|&
name|KNOB_VALID_ADDRESS
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: %s current WWNN %#jx\n"
argument_list|,
name|__func__
argument_list|,
name|bus_softc
operator|->
name|port_name
argument_list|,
name|ccb
operator|->
name|knob
operator|.
name|xport_specific
operator|.
name|fc
operator|.
name|wwnn
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: %s current WWPN %#jx\n"
argument_list|,
name|__func__
argument_list|,
name|bus_softc
operator|->
name|port_name
argument_list|,
name|ccb
operator|->
name|knob
operator|.
name|xport_specific
operator|.
name|fc
operator|.
name|wwpn
argument_list|)
expr_stmt|;
comment|/* 			 * If the user has specified a WWNN/WWPN, send them 			 * down to the SIM.  Otherwise, record what the SIM 			 * has reported. 			 */
if|if
condition|(
name|bus_softc
operator|->
name|port
operator|.
name|wwnn
operator|!=
literal|0
operator|&&
name|bus_softc
operator|->
name|port
operator|.
name|wwnn
operator|!=
name|ccb
operator|->
name|knob
operator|.
name|xport_specific
operator|.
name|fc
operator|.
name|wwnn
condition|)
block|{
name|ccb
operator|->
name|knob
operator|.
name|xport_specific
operator|.
name|fc
operator|.
name|wwnn
operator|=
name|bus_softc
operator|->
name|port
operator|.
name|wwnn
expr_stmt|;
name|set_wwnn
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ctl_port_set_wwns
argument_list|(
operator|&
name|bus_softc
operator|->
name|port
argument_list|,
name|true
argument_list|,
name|ccb
operator|->
name|knob
operator|.
name|xport_specific
operator|.
name|fc
operator|.
name|wwnn
argument_list|,
name|false
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bus_softc
operator|->
name|port
operator|.
name|wwpn
operator|!=
literal|0
operator|&&
name|bus_softc
operator|->
name|port
operator|.
name|wwpn
operator|!=
name|ccb
operator|->
name|knob
operator|.
name|xport_specific
operator|.
name|fc
operator|.
name|wwpn
condition|)
block|{
name|ccb
operator|->
name|knob
operator|.
name|xport_specific
operator|.
name|fc
operator|.
name|wwpn
operator|=
name|bus_softc
operator|->
name|port
operator|.
name|wwpn
expr_stmt|;
name|set_wwnn
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ctl_port_set_wwns
argument_list|(
operator|&
name|bus_softc
operator|->
name|port
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|true
argument_list|,
name|ccb
operator|->
name|knob
operator|.
name|xport_specific
operator|.
name|fc
operator|.
name|wwpn
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s: %s has no valid WWNN/WWPN\n"
argument_list|,
name|__func__
argument_list|,
name|bus_softc
operator|->
name|port_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_softc
operator|->
name|port
operator|.
name|wwnn
operator|!=
literal|0
condition|)
block|{
name|ccb
operator|->
name|knob
operator|.
name|xport_specific
operator|.
name|fc
operator|.
name|wwnn
operator|=
name|bus_softc
operator|->
name|port
operator|.
name|wwnn
expr_stmt|;
name|set_wwnn
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bus_softc
operator|->
name|port
operator|.
name|wwpn
operator|!=
literal|0
condition|)
block|{
name|ccb
operator|->
name|knob
operator|.
name|xport_specific
operator|.
name|fc
operator|.
name|wwpn
operator|=
name|bus_softc
operator|->
name|port
operator|.
name|wwpn
expr_stmt|;
name|set_wwnn
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|set_wwnn
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SET_SIM_KNOB
expr_stmt|;
name|ccb
operator|->
name|knob
operator|.
name|xport_specific
operator|.
name|valid
operator|=
name|KNOB_VALID_ADDRESS
expr_stmt|;
name|xpt_action
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"%s: %s (path id %d) failed set WWNs: %#x\n"
argument_list|,
name|__func__
argument_list|,
name|bus_softc
operator|->
name|port_name
argument_list|,
name|bus_softc
operator|->
name|path_id
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|status
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s: %s new WWNN %#jx\n"
argument_list|,
name|__func__
argument_list|,
name|bus_softc
operator|->
name|port_name
argument_list|,
name|ccb
operator|->
name|knob
operator|.
name|xport_specific
operator|.
name|fc
operator|.
name|wwnn
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: %s new WWPN %#jx\n"
argument_list|,
name|__func__
argument_list|,
name|bus_softc
operator|->
name|port_name
argument_list|,
name|ccb
operator|->
name|knob
operator|.
name|xport_specific
operator|.
name|fc
operator|.
name|wwpn
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Check whether we should change role. */
if|if
condition|(
operator|(
name|ccb
operator|->
name|knob
operator|.
name|xport_specific
operator|.
name|valid
operator|&
name|KNOB_VALID_ROLE
operator|)
operator|==
literal|0
operator|||
operator|(
operator|(
name|online
operator|!=
literal|0
operator|)
operator|^
operator|(
operator|(
name|ccb
operator|->
name|knob
operator|.
name|xport_specific
operator|.
name|fc
operator|.
name|role
operator|&
name|KNOB_ROLE_TARGET
operator|)
operator|!=
literal|0
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SET_SIM_KNOB
expr_stmt|;
name|ccb
operator|->
name|knob
operator|.
name|xport_specific
operator|.
name|valid
operator|=
name|KNOB_VALID_ROLE
expr_stmt|;
if|if
condition|(
name|online
condition|)
name|ccb
operator|->
name|knob
operator|.
name|xport_specific
operator|.
name|fc
operator|.
name|role
operator||=
name|KNOB_ROLE_TARGET
expr_stmt|;
else|else
name|ccb
operator|->
name|knob
operator|.
name|xport_specific
operator|.
name|fc
operator|.
name|role
operator|&=
operator|~
name|KNOB_ROLE_TARGET
expr_stmt|;
name|xpt_action
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"%s: %s (path id %d) failed %s target role: %#x\n"
argument_list|,
name|__func__
argument_list|,
name|bus_softc
operator|->
name|port_name
argument_list|,
name|bus_softc
operator|->
name|path_id
argument_list|,
name|online
condition|?
literal|"enable"
else|:
literal|"disable"
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|status
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s: %s (path id %d) target role %s succeeded\n"
argument_list|,
name|__func__
argument_list|,
name|bus_softc
operator|->
name|port_name
argument_list|,
name|bus_softc
operator|->
name|path_id
argument_list|,
name|online
condition|?
literal|"enable"
else|:
literal|"disable"
argument_list|)
expr_stmt|;
block|}
block|}
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|xpt_free_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctlfe_online
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ctlfe_softc
modifier|*
name|bus_softc
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|struct
name|ctlfe_lun_softc
modifier|*
name|lun_softc
decl_stmt|;
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|bus_softc
operator|=
operator|(
expr|struct
name|ctlfe_softc
operator|*
operator|)
name|arg
expr_stmt|;
comment|/* 	 * Create the wildcard LUN before bringing the port online. 	 */
name|status
operator|=
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|bus_softc
operator|->
name|path_id
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unable to create path for wildcard periph\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|lun_softc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|lun_softc
argument_list|)
argument_list|,
name|M_CTLFE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|xpt_path_lock
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|periph
operator|=
name|cam_periph_find
argument_list|(
name|path
argument_list|,
literal|"ctl"
argument_list|)
expr_stmt|;
if|if
condition|(
name|periph
operator|!=
name|NULL
condition|)
block|{
comment|/* We've already got a periph, no need to alloc a new one. */
name|xpt_path_unlock
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lun_softc
argument_list|,
name|M_CTLFE
argument_list|)
expr_stmt|;
return|return;
block|}
name|lun_softc
operator|->
name|parent_softc
operator|=
name|bus_softc
expr_stmt|;
name|lun_softc
operator|->
name|flags
operator||=
name|CTLFE_LUN_WILDCARD
expr_stmt|;
name|status
operator|=
name|cam_periph_alloc
argument_list|(
name|ctlferegister
argument_list|,
name|ctlfeoninvalidate
argument_list|,
name|ctlfecleanup
argument_list|,
name|ctlfestart
argument_list|,
literal|"ctl"
argument_list|,
name|CAM_PERIPH_BIO
argument_list|,
name|path
argument_list|,
name|ctlfeasync
argument_list|,
literal|0
argument_list|,
name|lun_softc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
specifier|const
name|struct
name|cam_status_entry
modifier|*
name|entry
decl_stmt|;
name|entry
operator|=
name|cam_fetch_status_entry
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: CAM error %s (%#x) returned from "
literal|"cam_periph_alloc()\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|entry
operator|!=
name|NULL
operator|)
condition|?
name|entry
operator|->
name|status_text
else|:
literal|"Unknown"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lun_softc
argument_list|,
name|M_CTLFE
argument_list|)
expr_stmt|;
block|}
name|xpt_path_unlock
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|ctlfe_onoffline
argument_list|(
name|arg
argument_list|,
comment|/*online*/
literal|1
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctlfe_offline
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ctlfe_softc
modifier|*
name|bus_softc
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|bus_softc
operator|=
operator|(
expr|struct
name|ctlfe_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|ctlfe_onoffline
argument_list|(
name|arg
argument_list|,
comment|/*online*/
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Disable the wildcard LUN for this port now that we have taken 	 * the port offline. 	 */
name|status
operator|=
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|bus_softc
operator|->
name|path_id
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unable to create path for wildcard periph\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|xpt_path_lock
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|periph
operator|=
name|cam_periph_find
argument_list|(
name|path
argument_list|,
literal|"ctl"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|cam_periph_invalidate
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|xpt_path_unlock
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This will get called to enable a LUN on every bus that is attached to  * CTL.  So we only need to create a path/periph for this particular bus.  */
end_comment

begin_function
specifier|static
name|int
name|ctlfe_lun_enable
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|lun_id
parameter_list|)
block|{
name|struct
name|ctlfe_softc
modifier|*
name|bus_softc
decl_stmt|;
name|struct
name|ctlfe_lun_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|bus_softc
operator|=
operator|(
expr|struct
name|ctlfe_softc
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|bus_softc
operator|->
name|hba_misc
operator|&
name|PIM_EXTLUNS
condition|)
name|lun_id
operator|=
name|CAM_EXTLUN_BYTE_SWIZZLE
argument_list|(
name|ctl_encode_lun
argument_list|(
name|lun_id
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|bus_softc
operator|->
name|path_id
argument_list|,
name|bus_softc
operator|->
name|target_id
argument_list|,
name|lun_id
argument_list|)
expr_stmt|;
comment|/* XXX KDM need some way to return status to CTL here? */
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"%s: could not create path, status %#x\n"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|softc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|softc
argument_list|)
argument_list|,
name|M_CTLFE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|xpt_path_lock
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|periph
operator|=
name|cam_periph_find
argument_list|(
name|path
argument_list|,
literal|"ctl"
argument_list|)
expr_stmt|;
if|if
condition|(
name|periph
operator|!=
name|NULL
condition|)
block|{
comment|/* We've already got a periph, no need to alloc a new one. */
name|xpt_path_unlock
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|softc
argument_list|,
name|M_CTLFE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|softc
operator|->
name|parent_softc
operator|=
name|bus_softc
expr_stmt|;
name|status
operator|=
name|cam_periph_alloc
argument_list|(
name|ctlferegister
argument_list|,
name|ctlfeoninvalidate
argument_list|,
name|ctlfecleanup
argument_list|,
name|ctlfestart
argument_list|,
literal|"ctl"
argument_list|,
name|CAM_PERIPH_BIO
argument_list|,
name|path
argument_list|,
name|ctlfeasync
argument_list|,
literal|0
argument_list|,
name|softc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
specifier|const
name|struct
name|cam_status_entry
modifier|*
name|entry
decl_stmt|;
name|entry
operator|=
name|cam_fetch_status_entry
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: CAM error %s (%#x) returned from "
literal|"cam_periph_alloc()\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|entry
operator|!=
name|NULL
operator|)
condition|?
name|entry
operator|->
name|status_text
else|:
literal|"Unknown"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|softc
argument_list|,
name|M_CTLFE
argument_list|)
expr_stmt|;
block|}
name|xpt_path_unlock
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This will get called when the user removes a LUN to disable that LUN  * on every bus that is attached to CTL.    */
end_comment

begin_function
specifier|static
name|int
name|ctlfe_lun_disable
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|lun_id
parameter_list|)
block|{
name|struct
name|ctlfe_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ctlfe_lun_softc
modifier|*
name|lun_softc
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|ctlfe_softc
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|hba_misc
operator|&
name|PIM_EXTLUNS
condition|)
name|lun_id
operator|=
name|CAM_EXTLUN_BYTE_SWIZZLE
argument_list|(
name|ctl_encode_lun
argument_list|(
name|lun_id
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|lun_softc_mtx
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|lun_softc
argument_list|,
argument|&softc->lun_softc_list
argument_list|,
argument|links
argument_list|)
block|{
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|path
operator|=
name|lun_softc
operator|->
name|periph
operator|->
name|path
expr_stmt|;
if|if
condition|(
operator|(
name|xpt_path_target_id
argument_list|(
name|path
argument_list|)
operator|==
name|softc
operator|->
name|target_id
operator|)
operator|&&
operator|(
name|xpt_path_lun_id
argument_list|(
name|path
argument_list|)
operator|==
name|lun_id
operator|)
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|lun_softc
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lun_softc_mtx
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: can't find lun %d\n"
argument_list|,
name|__func__
argument_list|,
name|lun_id
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|cam_periph_acquire
argument_list|(
name|lun_softc
operator|->
name|periph
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|lun_softc_mtx
argument_list|)
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|lun_softc
operator|->
name|periph
argument_list|)
expr_stmt|;
name|cam_periph_invalidate
argument_list|(
name|lun_softc
operator|->
name|periph
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|lun_softc
operator|->
name|periph
argument_list|)
expr_stmt|;
name|cam_periph_release
argument_list|(
name|lun_softc
operator|->
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctlfe_dump_sim
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
block|{
name|printf
argument_list|(
literal|"%s%d: max dev openings: %d, max tagged dev openings: %d\n"
argument_list|,
name|sim
operator|->
name|sim_name
argument_list|,
name|sim
operator|->
name|unit_number
argument_list|,
name|sim
operator|->
name|max_dev_openings
argument_list|,
name|sim
operator|->
name|max_tagged_dev_openings
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Assumes that the SIM lock is held.  */
end_comment

begin_function
specifier|static
name|void
name|ctlfe_dump_queue
parameter_list|(
name|struct
name|ctlfe_lun_softc
modifier|*
name|softc
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
init|=
name|softc
operator|->
name|periph
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|hdr
decl_stmt|;
name|struct
name|ccb_getdevstats
name|cgds
decl_stmt|;
name|int
name|num_items
decl_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|cgds
operator|.
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
name|CAM_PRIORITY_NORMAL
argument_list|)
expr_stmt|;
name|cgds
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_GDEV_STATS
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|cgds
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cgds
operator|.
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"devq: openings %d, active %d, "
literal|"allocated %d, queued %d, held %d\n"
argument_list|,
name|cgds
operator|.
name|dev_openings
argument_list|,
name|cgds
operator|.
name|dev_active
argument_list|,
name|cgds
operator|.
name|allocated
argument_list|,
name|cgds
operator|.
name|queued
argument_list|,
name|cgds
operator|.
name|held
argument_list|)
expr_stmt|;
block|}
name|num_items
operator|=
literal|0
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|hdr
argument_list|,
argument|&softc->work_queue
argument_list|,
argument|periph_links.stqe
argument_list|)
block|{
name|union
name|ctl_io
modifier|*
name|io
init|=
name|hdr
operator|->
name|io_ptr
decl_stmt|;
name|num_items
operator|++
expr_stmt|;
comment|/* 		 * Only regular SCSI I/O is put on the work 		 * queue, so we can print sense here.  There may be no 		 * sense if it's no the queue for a DMA, but this serves to 		 * print out the CCB as well. 		 * 		 * XXX KDM switch this over to scsi_sense_print() when 		 * CTL is merged in with CAM. 		 */
name|ctl_io_error_print
argument_list|(
name|io
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 		 * Print DMA status if we are DMA_QUEUED. 		 */
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_DMA_QUEUED
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"Total %u, Current %u, Resid %u\n"
argument_list|,
name|io
operator|->
name|scsiio
operator|.
name|kern_total_len
argument_list|,
name|io
operator|->
name|scsiio
operator|.
name|kern_data_len
argument_list|,
name|io
operator|->
name|scsiio
operator|.
name|kern_data_resid
argument_list|)
expr_stmt|;
block|}
block|}
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"%d requests waiting for CCBs\n"
argument_list|,
name|num_items
argument_list|)
expr_stmt|;
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"%d CTIOs outstanding\n"
argument_list|,
name|softc
operator|->
name|ctios_sent
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Datamove/done routine called by CTL.  Put ourselves on the queue to  * receive a CCB from CAM so we can queue the continue I/O request down  * to the adapter.  */
end_comment

begin_function
specifier|static
name|void
name|ctlfe_datamove
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|ctlfe_lun_softc
modifier|*
name|softc
decl_stmt|;
name|KASSERT
argument_list|(
name|io
operator|->
name|io_hdr
operator|.
name|io_type
operator|==
name|CTL_IO_SCSI
argument_list|,
operator|(
literal|"Unexpected io_type (%d) in ctlfe_datamove"
operator|,
name|io
operator|->
name|io_hdr
operator|.
name|io_type
operator|)
argument_list|)
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|ext_data_filled
operator|=
literal|0
expr_stmt|;
name|ccb
operator|=
name|PRIV_CCB
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|periph
operator|=
name|xpt_path_periph
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|ctlfe_lun_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_DMA_QUEUED
expr_stmt|;
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|!=
name|CTL_STATUS_NONE
condition|)
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_STATUS_QUEUED
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|softc
operator|->
name|work_queue
argument_list|,
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|stqe
argument_list|)
expr_stmt|;
name|xpt_schedule
argument_list|(
name|periph
argument_list|,
name|CAM_PRIORITY_NORMAL
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctlfe_done
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|ctlfe_lun_softc
modifier|*
name|softc
decl_stmt|;
name|ccb
operator|=
name|PRIV_CCB
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|periph
operator|=
name|xpt_path_periph
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|ctlfe_lun_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|io_type
operator|==
name|CTL_IO_TASK
condition|)
block|{
comment|/* 		 * Send the notify acknowledge down to the SIM, to let it 		 * know we processed the task management command. 		 */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INPROG
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_NOTIFY_ACKNOWLEDGE
expr_stmt|;
switch|switch
condition|(
name|io
operator|->
name|taskio
operator|.
name|task_status
condition|)
block|{
case|case
name|CTL_TASK_FUNCTION_COMPLETE
case|:
name|ccb
operator|->
name|cna2
operator|.
name|arg
operator|=
name|CAM_RSP_TMF_COMPLETE
expr_stmt|;
break|break;
case|case
name|CTL_TASK_FUNCTION_SUCCEEDED
case|:
name|ccb
operator|->
name|cna2
operator|.
name|arg
operator|=
name|CAM_RSP_TMF_SUCCEEDED
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_SEND_STATUS
expr_stmt|;
break|break;
case|case
name|CTL_TASK_FUNCTION_REJECTED
case|:
name|ccb
operator|->
name|cna2
operator|.
name|arg
operator|=
name|CAM_RSP_TMF_REJECTED
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_SEND_STATUS
expr_stmt|;
break|break;
case|case
name|CTL_TASK_LUN_DOES_NOT_EXIST
case|:
name|ccb
operator|->
name|cna2
operator|.
name|arg
operator|=
name|CAM_RSP_TMF_INCORRECT_LUN
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_SEND_STATUS
expr_stmt|;
break|break;
case|case
name|CTL_TASK_FUNCTION_NOT_SUPPORTED
case|:
name|ccb
operator|->
name|cna2
operator|.
name|arg
operator|=
name|CAM_RSP_TMF_FAILED
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_SEND_STATUS
expr_stmt|;
break|break;
block|}
name|ccb
operator|->
name|cna2
operator|.
name|arg
operator||=
name|scsi_3btoul
argument_list|(
name|io
operator|->
name|taskio
operator|.
name|task_resp
argument_list|)
operator|<<
literal|8
expr_stmt|;
name|xpt_action
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_STATUS_SENT
condition|)
block|{
name|ctlfe_requeue_ccb
argument_list|(
name|periph
argument_list|,
name|ccb
argument_list|,
comment|/* unlock */
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_STATUS_QUEUED
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|softc
operator|->
name|work_queue
argument_list|,
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|stqe
argument_list|)
expr_stmt|;
name|xpt_schedule
argument_list|(
name|periph
argument_list|,
name|CAM_PRIORITY_NORMAL
argument_list|)
expr_stmt|;
block|}
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctlfe_dump
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ctlfe_softc
modifier|*
name|bus_softc
decl_stmt|;
name|struct
name|ctlfe_lun_softc
modifier|*
name|lun_softc
decl_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|bus_softc
argument_list|,
argument|&ctlfe_softc_list
argument_list|,
argument|links
argument_list|)
block|{
name|ctlfe_dump_sim
argument_list|(
name|bus_softc
operator|->
name|sim
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|lun_softc
argument_list|,
argument|&bus_softc->lun_softc_list
argument_list|,
argument|links
argument_list|)
name|ctlfe_dump_queue
argument_list|(
name|lun_softc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

