begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003-2009 Silicon Graphics International Corp.  * Copyright (c) 2012 The FreeBSD Foundation  * Copyright (c) 2014-2017 Alexander Motin<mav@FreeBSD.org>  * All rights reserved.  *  * Portions of this software were developed by Edward Tomasz Napierala  * under sponsorship from the FreeBSD Foundation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    substantially similar to the "NO WARRANTY" disclaimer below  *    ("Disclaimer") and any redistribution must be conditioned upon  *    including a substantially similar Disclaimer requirement for further  *    binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGES.  *  * $Id$  */
end_comment

begin_comment
comment|/*  * CAM Target Layer, a SCSI device emulation subsystem.  *  * Author: Ken Merry<ken@FreeBSD.org>  */
end_comment

begin_define
define|#
directive|define
name|_CTL_C
end_define

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_cd.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_da.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_io.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_frontend.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_util.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_backend.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_ha.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_private.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_error.h>
end_include

begin_decl_stmt
name|struct
name|ctl_softc
modifier|*
name|control_softc
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Template mode pages.  */
end_comment

begin_comment
comment|/*  * Note that these are default values only.  The actual values will be  * filled in when the user does a mode sense.  */
end_comment

begin_decl_stmt
specifier|const
specifier|static
name|struct
name|scsi_da_rw_recovery_page
name|rw_er_page_default
init|=
block|{
comment|/*page_code*/
name|SMS_RW_ERROR_RECOVERY_PAGE
block|,
comment|/*page_length*/
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_da_rw_recovery_page
argument_list|)
operator|-
literal|2
block|,
comment|/*byte3*/
name|SMS_RWER_AWRE
operator||
name|SMS_RWER_ARRE
block|,
comment|/*read_retry_count*/
literal|0
block|,
comment|/*correction_span*/
literal|0
block|,
comment|/*head_offset_count*/
literal|0
block|,
comment|/*data_strobe_offset_cnt*/
literal|0
block|,
comment|/*byte8*/
name|SMS_RWER_LBPERE
block|,
comment|/*write_retry_count*/
literal|0
block|,
comment|/*reserved2*/
literal|0
block|,
comment|/*recovery_time_limit*/
block|{
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
specifier|static
name|struct
name|scsi_da_rw_recovery_page
name|rw_er_page_changeable
init|=
block|{
comment|/*page_code*/
name|SMS_RW_ERROR_RECOVERY_PAGE
block|,
comment|/*page_length*/
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_da_rw_recovery_page
argument_list|)
operator|-
literal|2
block|,
comment|/*byte3*/
name|SMS_RWER_PER
block|,
comment|/*read_retry_count*/
literal|0
block|,
comment|/*correction_span*/
literal|0
block|,
comment|/*head_offset_count*/
literal|0
block|,
comment|/*data_strobe_offset_cnt*/
literal|0
block|,
comment|/*byte8*/
name|SMS_RWER_LBPERE
block|,
comment|/*write_retry_count*/
literal|0
block|,
comment|/*reserved2*/
literal|0
block|,
comment|/*recovery_time_limit*/
block|{
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
specifier|static
name|struct
name|scsi_format_page
name|format_page_default
init|=
block|{
comment|/*page_code*/
name|SMS_FORMAT_DEVICE_PAGE
block|,
comment|/*page_length*/
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_format_page
argument_list|)
operator|-
literal|2
block|,
comment|/*tracks_per_zone*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*alt_sectors_per_zone*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*alt_tracks_per_zone*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*alt_tracks_per_lun*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*sectors_per_track*/
block|{
operator|(
name|CTL_DEFAULT_SECTORS_PER_TRACK
operator|>>
literal|8
operator|)
operator|&
literal|0xff
block|,
name|CTL_DEFAULT_SECTORS_PER_TRACK
operator|&
literal|0xff
block|}
block|,
comment|/*bytes_per_sector*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*interleave*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*track_skew*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*cylinder_skew*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*flags*/
name|SFP_HSEC
block|,
comment|/*reserved*/
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
specifier|static
name|struct
name|scsi_format_page
name|format_page_changeable
init|=
block|{
comment|/*page_code*/
name|SMS_FORMAT_DEVICE_PAGE
block|,
comment|/*page_length*/
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_format_page
argument_list|)
operator|-
literal|2
block|,
comment|/*tracks_per_zone*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*alt_sectors_per_zone*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*alt_tracks_per_zone*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*alt_tracks_per_lun*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*sectors_per_track*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*bytes_per_sector*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*interleave*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*track_skew*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*cylinder_skew*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*flags*/
literal|0
block|,
comment|/*reserved*/
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
specifier|static
name|struct
name|scsi_rigid_disk_page
name|rigid_disk_page_default
init|=
block|{
comment|/*page_code*/
name|SMS_RIGID_DISK_PAGE
block|,
comment|/*page_length*/
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_rigid_disk_page
argument_list|)
operator|-
literal|2
block|,
comment|/*cylinders*/
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/*heads*/
name|CTL_DEFAULT_HEADS
block|,
comment|/*start_write_precomp*/
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/*start_reduced_current*/
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/*step_rate*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*landing_zone_cylinder*/
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/*rpl*/
name|SRDP_RPL_DISABLED
block|,
comment|/*rotational_offset*/
literal|0
block|,
comment|/*reserved1*/
literal|0
block|,
comment|/*rotation_rate*/
block|{
operator|(
name|CTL_DEFAULT_ROTATION_RATE
operator|>>
literal|8
operator|)
operator|&
literal|0xff
block|,
name|CTL_DEFAULT_ROTATION_RATE
operator|&
literal|0xff
block|}
block|,
comment|/*reserved2*/
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
specifier|static
name|struct
name|scsi_rigid_disk_page
name|rigid_disk_page_changeable
init|=
block|{
comment|/*page_code*/
name|SMS_RIGID_DISK_PAGE
block|,
comment|/*page_length*/
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_rigid_disk_page
argument_list|)
operator|-
literal|2
block|,
comment|/*cylinders*/
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/*heads*/
literal|0
block|,
comment|/*start_write_precomp*/
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/*start_reduced_current*/
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/*step_rate*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*landing_zone_cylinder*/
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/*rpl*/
literal|0
block|,
comment|/*rotational_offset*/
literal|0
block|,
comment|/*reserved1*/
literal|0
block|,
comment|/*rotation_rate*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*reserved2*/
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
specifier|static
name|struct
name|scsi_da_verify_recovery_page
name|verify_er_page_default
init|=
block|{
comment|/*page_code*/
name|SMS_VERIFY_ERROR_RECOVERY_PAGE
block|,
comment|/*page_length*/
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_da_verify_recovery_page
argument_list|)
operator|-
literal|2
block|,
comment|/*byte3*/
literal|0
block|,
comment|/*read_retry_count*/
literal|0
block|,
comment|/*reserved*/
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/*recovery_time_limit*/
block|{
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
specifier|static
name|struct
name|scsi_da_verify_recovery_page
name|verify_er_page_changeable
init|=
block|{
comment|/*page_code*/
name|SMS_VERIFY_ERROR_RECOVERY_PAGE
block|,
comment|/*page_length*/
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_da_verify_recovery_page
argument_list|)
operator|-
literal|2
block|,
comment|/*byte3*/
name|SMS_VER_PER
block|,
comment|/*read_retry_count*/
literal|0
block|,
comment|/*reserved*/
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/*recovery_time_limit*/
block|{
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
specifier|static
name|struct
name|scsi_caching_page
name|caching_page_default
init|=
block|{
comment|/*page_code*/
name|SMS_CACHING_PAGE
block|,
comment|/*page_length*/
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_caching_page
argument_list|)
operator|-
literal|2
block|,
comment|/*flags1*/
name|SCP_DISC
operator||
name|SCP_WCE
block|,
comment|/*ret_priority*/
literal|0
block|,
comment|/*disable_pf_transfer_len*/
block|{
literal|0xff
block|,
literal|0xff
block|}
block|,
comment|/*min_prefetch*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*max_prefetch*/
block|{
literal|0xff
block|,
literal|0xff
block|}
block|,
comment|/*max_pf_ceiling*/
block|{
literal|0xff
block|,
literal|0xff
block|}
block|,
comment|/*flags2*/
literal|0
block|,
comment|/*cache_segments*/
literal|0
block|,
comment|/*cache_seg_size*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*reserved*/
literal|0
block|,
comment|/*non_cache_seg_size*/
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
specifier|static
name|struct
name|scsi_caching_page
name|caching_page_changeable
init|=
block|{
comment|/*page_code*/
name|SMS_CACHING_PAGE
block|,
comment|/*page_length*/
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_caching_page
argument_list|)
operator|-
literal|2
block|,
comment|/*flags1*/
name|SCP_WCE
operator||
name|SCP_RCD
block|,
comment|/*ret_priority*/
literal|0
block|,
comment|/*disable_pf_transfer_len*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*min_prefetch*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*max_prefetch*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*max_pf_ceiling*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*flags2*/
literal|0
block|,
comment|/*cache_segments*/
literal|0
block|,
comment|/*cache_seg_size*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*reserved*/
literal|0
block|,
comment|/*non_cache_seg_size*/
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
specifier|static
name|struct
name|scsi_control_page
name|control_page_default
init|=
block|{
comment|/*page_code*/
name|SMS_CONTROL_MODE_PAGE
block|,
comment|/*page_length*/
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_control_page
argument_list|)
operator|-
literal|2
block|,
comment|/*rlec*/
literal|0
block|,
comment|/*queue_flags*/
name|SCP_QUEUE_ALG_RESTRICTED
block|,
comment|/*eca_and_aen*/
literal|0
block|,
comment|/*flags4*/
name|SCP_TAS
block|,
comment|/*aen_holdoff_period*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*busy_timeout_period*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*extended_selftest_completion_time*/
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
specifier|static
name|struct
name|scsi_control_page
name|control_page_changeable
init|=
block|{
comment|/*page_code*/
name|SMS_CONTROL_MODE_PAGE
block|,
comment|/*page_length*/
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_control_page
argument_list|)
operator|-
literal|2
block|,
comment|/*rlec*/
name|SCP_DSENSE
block|,
comment|/*queue_flags*/
name|SCP_QUEUE_ALG_MASK
operator||
name|SCP_NUAR
block|,
comment|/*eca_and_aen*/
name|SCP_SWP
block|,
comment|/*flags4*/
literal|0
block|,
comment|/*aen_holdoff_period*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*busy_timeout_period*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*extended_selftest_completion_time*/
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CTL_CEM_LEN
value|(sizeof(struct scsi_control_ext_page) - 4)
end_define

begin_decl_stmt
specifier|const
specifier|static
name|struct
name|scsi_control_ext_page
name|control_ext_page_default
init|=
block|{
comment|/*page_code*/
name|SMS_CONTROL_MODE_PAGE
operator||
name|SMPH_SPF
block|,
comment|/*subpage_code*/
literal|0x01
block|,
comment|/*page_length*/
block|{
name|CTL_CEM_LEN
operator|>>
literal|8
block|,
name|CTL_CEM_LEN
block|}
block|,
comment|/*flags*/
literal|0
block|,
comment|/*prio*/
literal|0
block|,
comment|/*max_sense*/
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
specifier|static
name|struct
name|scsi_control_ext_page
name|control_ext_page_changeable
init|=
block|{
comment|/*page_code*/
name|SMS_CONTROL_MODE_PAGE
operator||
name|SMPH_SPF
block|,
comment|/*subpage_code*/
literal|0x01
block|,
comment|/*page_length*/
block|{
name|CTL_CEM_LEN
operator|>>
literal|8
block|,
name|CTL_CEM_LEN
block|}
block|,
comment|/*flags*/
literal|0
block|,
comment|/*prio*/
literal|0
block|,
comment|/*max_sense*/
literal|0xff
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
specifier|static
name|struct
name|scsi_info_exceptions_page
name|ie_page_default
init|=
block|{
comment|/*page_code*/
name|SMS_INFO_EXCEPTIONS_PAGE
block|,
comment|/*page_length*/
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_info_exceptions_page
argument_list|)
operator|-
literal|2
block|,
comment|/*info_flags*/
name|SIEP_FLAGS_EWASC
block|,
comment|/*mrie*/
name|SIEP_MRIE_NO
block|,
comment|/*interval_timer*/
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/*report_count*/
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
specifier|static
name|struct
name|scsi_info_exceptions_page
name|ie_page_changeable
init|=
block|{
comment|/*page_code*/
name|SMS_INFO_EXCEPTIONS_PAGE
block|,
comment|/*page_length*/
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_info_exceptions_page
argument_list|)
operator|-
literal|2
block|,
comment|/*info_flags*/
name|SIEP_FLAGS_EWASC
operator||
name|SIEP_FLAGS_DEXCPT
operator||
name|SIEP_FLAGS_TEST
operator||
name|SIEP_FLAGS_LOGERR
block|,
comment|/*mrie*/
literal|0x0f
block|,
comment|/*interval_timer*/
block|{
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|}
block|,
comment|/*report_count*/
block|{
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CTL_LBPM_LEN
value|(sizeof(struct ctl_logical_block_provisioning_page) - 4)
end_define

begin_decl_stmt
specifier|const
specifier|static
name|struct
name|ctl_logical_block_provisioning_page
name|lbp_page_default
init|=
block|{
block|{
comment|/*page_code*/
name|SMS_INFO_EXCEPTIONS_PAGE
operator||
name|SMPH_SPF
block|,
comment|/*subpage_code*/
literal|0x02
block|,
comment|/*page_length*/
block|{
name|CTL_LBPM_LEN
operator|>>
literal|8
block|,
name|CTL_LBPM_LEN
block|}
block|,
comment|/*flags*/
literal|0
block|,
comment|/*reserved*/
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/*descr*/
block|{}
block|}
block|,
block|{
block|{
comment|/*flags*/
literal|0
block|,
comment|/*resource*/
literal|0x01
block|,
comment|/*reserved*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*count*/
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
comment|/*flags*/
literal|0
block|,
comment|/*resource*/
literal|0x02
block|,
comment|/*reserved*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*count*/
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
comment|/*flags*/
literal|0
block|,
comment|/*resource*/
literal|0xf1
block|,
comment|/*reserved*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*count*/
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
comment|/*flags*/
literal|0
block|,
comment|/*resource*/
literal|0xf2
block|,
comment|/*reserved*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*count*/
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
specifier|static
name|struct
name|ctl_logical_block_provisioning_page
name|lbp_page_changeable
init|=
block|{
block|{
comment|/*page_code*/
name|SMS_INFO_EXCEPTIONS_PAGE
operator||
name|SMPH_SPF
block|,
comment|/*subpage_code*/
literal|0x02
block|,
comment|/*page_length*/
block|{
name|CTL_LBPM_LEN
operator|>>
literal|8
block|,
name|CTL_LBPM_LEN
block|}
block|,
comment|/*flags*/
name|SLBPP_SITUA
block|,
comment|/*reserved*/
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/*descr*/
block|{}
block|}
block|,
block|{
block|{
comment|/*flags*/
literal|0
block|,
comment|/*resource*/
literal|0
block|,
comment|/*reserved*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*count*/
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
comment|/*flags*/
literal|0
block|,
comment|/*resource*/
literal|0
block|,
comment|/*reserved*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*count*/
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
comment|/*flags*/
literal|0
block|,
comment|/*resource*/
literal|0
block|,
comment|/*reserved*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*count*/
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
comment|/*flags*/
literal|0
block|,
comment|/*resource*/
literal|0
block|,
comment|/*reserved*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*count*/
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
specifier|static
name|struct
name|scsi_cddvd_capabilities_page
name|cddvd_page_default
init|=
block|{
comment|/*page_code*/
name|SMS_CDDVD_CAPS_PAGE
block|,
comment|/*page_length*/
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_cddvd_capabilities_page
argument_list|)
operator|-
literal|2
block|,
comment|/*caps1*/
literal|0x3f
block|,
comment|/*caps2*/
literal|0x00
block|,
comment|/*caps3*/
literal|0xf0
block|,
comment|/*caps4*/
literal|0x00
block|,
comment|/*caps5*/
literal|0x29
block|,
comment|/*caps6*/
literal|0x00
block|,
comment|/*obsolete*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*nvol_levels*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*buffer_size*/
block|{
literal|8
block|,
literal|0
block|}
block|,
comment|/*obsolete2*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*reserved*/
literal|0
block|,
comment|/*digital*/
literal|0
block|,
comment|/*obsolete3*/
literal|0
block|,
comment|/*copy_management*/
literal|0
block|,
comment|/*reserved2*/
literal|0
block|,
comment|/*rotation_control*/
literal|0
block|,
comment|/*cur_write_speed*/
literal|0
block|,
comment|/*num_speed_descr*/
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
specifier|static
name|struct
name|scsi_cddvd_capabilities_page
name|cddvd_page_changeable
init|=
block|{
comment|/*page_code*/
name|SMS_CDDVD_CAPS_PAGE
block|,
comment|/*page_length*/
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_cddvd_capabilities_page
argument_list|)
operator|-
literal|2
block|,
comment|/*caps1*/
literal|0
block|,
comment|/*caps2*/
literal|0
block|,
comment|/*caps3*/
literal|0
block|,
comment|/*caps4*/
literal|0
block|,
comment|/*caps5*/
literal|0
block|,
comment|/*caps6*/
literal|0
block|,
comment|/*obsolete*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*nvol_levels*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*buffer_size*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*obsolete2*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*reserved*/
literal|0
block|,
comment|/*digital*/
literal|0
block|,
comment|/*obsolete3*/
literal|0
block|,
comment|/*copy_management*/
literal|0
block|,
comment|/*reserved2*/
literal|0
block|,
comment|/*rotation_control*/
literal|0
block|,
comment|/*cur_write_speed*/
literal|0
block|,
comment|/*num_speed_descr*/
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_kern_cam
argument_list|,
name|OID_AUTO
argument_list|,
name|ctl
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"CAM Target Layer"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|worker_threads
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"kern.cam.ctl.worker_threads"
argument_list|,
operator|&
name|worker_threads
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_cam_ctl
argument_list|,
name|OID_AUTO
argument_list|,
name|worker_threads
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|worker_threads
argument_list|,
literal|1
argument_list|,
literal|"Number of worker threads"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ctl_debug
init|=
name|CTL_DEBUG_NONE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"kern.cam.ctl.debug"
argument_list|,
operator|&
name|ctl_debug
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_cam_ctl
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|ctl_debug
argument_list|,
literal|0
argument_list|,
literal|"Enabled debug flags"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ctl_lun_map_size
init|=
literal|1024
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_cam_ctl
argument_list|,
name|OID_AUTO
argument_list|,
name|lun_map_size
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|ctl_lun_map_size
argument_list|,
literal|0
argument_list|,
literal|"Size of per-port LUN map (max LUN + 1)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Supported pages (0x00), Serial number (0x80), Device ID (0x83),  * Extended INQUIRY Data (0x86), Mode Page Policy (0x87),  * SCSI Ports (0x88), Third-party Copy (0x8F), Block limits (0xB0),  * Block Device Characteristics (0xB1) and Logical Block Provisioning (0xB2)  */
end_comment

begin_define
define|#
directive|define
name|SCSI_EVPD_NUM_SUPPORTED_PAGES
value|10
end_define

begin_function_decl
specifier|static
name|void
name|ctl_isc_event_handler
parameter_list|(
name|ctl_ha_channel
name|chanel
parameter_list|,
name|ctl_ha_event
name|event
parameter_list|,
name|int
name|param
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_copy_sense_data
parameter_list|(
name|union
name|ctl_ha_msg
modifier|*
name|src
parameter_list|,
name|union
name|ctl_io
modifier|*
name|dest
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_copy_sense_data_back
parameter_list|(
name|union
name|ctl_io
modifier|*
name|src
parameter_list|,
name|union
name|ctl_ha_msg
modifier|*
name|dest
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_shutdown
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_serialize_other_sc_cmd
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_ioctl_fill_ooa
parameter_list|(
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|,
name|uint32_t
modifier|*
name|cur_fill_num
parameter_list|,
name|struct
name|ctl_ooa
modifier|*
name|ooa_hdr
parameter_list|,
name|struct
name|ctl_ooa_entry
modifier|*
name|kern_entries
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_alloc_lun
parameter_list|(
name|struct
name|ctl_softc
modifier|*
name|ctl_softc
parameter_list|,
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|,
name|struct
name|ctl_be_lun
modifier|*
name|be_lun
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_free_lun
parameter_list|(
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_create_lun
parameter_list|(
name|struct
name|ctl_be_lun
modifier|*
name|be_lun
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_do_mode_select
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_pro_preempt
parameter_list|(
name|struct
name|ctl_softc
modifier|*
name|softc
parameter_list|,
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|,
name|uint64_t
name|res_key
parameter_list|,
name|uint64_t
name|sa_res_key
parameter_list|,
name|uint8_t
name|type
parameter_list|,
name|uint32_t
name|residx
parameter_list|,
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|struct
name|scsi_per_res_out
modifier|*
name|cdb
parameter_list|,
name|struct
name|scsi_per_res_out_parms
modifier|*
name|param
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_pro_preempt_other
parameter_list|(
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|,
name|union
name|ctl_ha_msg
modifier|*
name|msg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_hndl_per_res_out_on_other_sc
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_inquiry_evpd_supported
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|int
name|alloc_len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_inquiry_evpd_serial
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|int
name|alloc_len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_inquiry_evpd_devid
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|int
name|alloc_len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_inquiry_evpd_eid
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|int
name|alloc_len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_inquiry_evpd_mpp
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|int
name|alloc_len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_inquiry_evpd_scsi_ports
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|int
name|alloc_len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_inquiry_evpd_block_limits
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|int
name|alloc_len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_inquiry_evpd_bdc
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|int
name|alloc_len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_inquiry_evpd_lbp
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|int
name|alloc_len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_inquiry_evpd
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_inquiry_std
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_get_lba_len
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|,
name|uint64_t
modifier|*
name|lba
parameter_list|,
name|uint64_t
modifier|*
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ctl_action
name|ctl_extent_check
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io1
parameter_list|,
name|union
name|ctl_io
modifier|*
name|io2
parameter_list|,
name|bool
name|seq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ctl_action
name|ctl_extent_check_seq
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io1
parameter_list|,
name|union
name|ctl_io
modifier|*
name|io2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ctl_action
name|ctl_check_for_blockage
parameter_list|(
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|,
name|union
name|ctl_io
modifier|*
name|pending_io
parameter_list|,
name|union
name|ctl_io
modifier|*
name|ooa_io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ctl_action
name|ctl_check_ooa
parameter_list|(
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|,
name|union
name|ctl_io
modifier|*
name|pending_io
parameter_list|,
name|union
name|ctl_io
modifier|*
name|starting_io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_check_blocked
parameter_list|(
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_scsiio_lun_check
parameter_list|(
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|,
specifier|const
name|struct
name|ctl_cmd_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_failover_lun
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_scsiio_precheck
parameter_list|(
name|struct
name|ctl_softc
modifier|*
name|ctl_softc
parameter_list|,
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_scsiio
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_target_reset
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_do_lun_reset
parameter_list|(
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|,
name|uint32_t
name|initidx
parameter_list|,
name|ctl_ua_type
name|ua_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_lun_reset
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_abort_task
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_abort_task_set
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_query_task
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|,
name|int
name|task_set
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_i_t_nexus_loss
parameter_list|(
name|struct
name|ctl_softc
modifier|*
name|softc
parameter_list|,
name|uint32_t
name|initidx
parameter_list|,
name|ctl_ua_type
name|ua_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_i_t_nexus_reset
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_query_async_event
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_run_task
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|CTL_IO_DELAY
end_ifdef

begin_function_decl
specifier|static
name|void
name|ctl_datamove_timer_wakeup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_done_timer_wakeup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CTL_IO_DELAY */
end_comment

begin_function_decl
specifier|static
name|void
name|ctl_send_datamove_done
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|,
name|int
name|have_lock
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_datamove_remote_write_cb
parameter_list|(
name|struct
name|ctl_ha_dt_req
modifier|*
name|rq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_datamove_remote_dm_write_cb
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_datamove_remote_write
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_datamove_remote_dm_read_cb
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_datamove_remote_read_cb
parameter_list|(
name|struct
name|ctl_ha_dt_req
modifier|*
name|rq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_datamove_remote_sgl_setup
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_datamove_remote_xfer
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|,
name|unsigned
name|command
parameter_list|,
name|ctl_ha_dt_cb
name|callback
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_datamove_remote_read
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_datamove_remote
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_process_done
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_lun_thread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_thresh_thread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_work_thread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_enqueue_incoming
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_enqueue_rtr
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_enqueue_done
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_enqueue_isc
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|struct
name|ctl_cmd_entry
modifier|*
name|ctl_get_cmd_entry
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|int
modifier|*
name|sa
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|struct
name|ctl_cmd_entry
modifier|*
name|ctl_validate_command
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_cmd_applicable
parameter_list|(
name|uint8_t
name|lun_type
parameter_list|,
specifier|const
name|struct
name|ctl_cmd_entry
modifier|*
name|entry
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_ha_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_ha_shutdown
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint64_t
name|ctl_get_prkey
parameter_list|(
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|,
name|uint32_t
name|residx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_clr_prkey
parameter_list|(
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|,
name|uint32_t
name|residx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_alloc_prkey
parameter_list|(
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|,
name|uint32_t
name|residx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_set_prkey
parameter_list|(
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|,
name|uint32_t
name|residx
parameter_list|,
name|uint64_t
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Load the serialization table.  This isn't very pretty, but is probably  * the easiest way to do it.  */
end_comment

begin_include
include|#
directive|include
file|"ctl_ser_table.c"
end_include

begin_comment
comment|/*  * We only need to define open, close and ioctl routines for this driver.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|ctl_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_flags
operator|=
literal|0
block|,
operator|.
name|d_open
operator|=
name|ctl_open
block|,
operator|.
name|d_close
operator|=
name|ctl_close
block|,
operator|.
name|d_ioctl
operator|=
name|ctl_ioctl
block|,
operator|.
name|d_name
operator|=
literal|"ctl"
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_CTL
argument_list|,
literal|"ctlmem"
argument_list|,
literal|"Memory used for CTL"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|ctl_module_event_handler
parameter_list|(
name|module_t
parameter_list|,
name|int
comment|/*modeventtype_t*/
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|moduledata_t
name|ctl_moduledata
init|=
block|{
literal|"ctl"
block|,
name|ctl_module_event_handler
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|ctl
argument_list|,
name|ctl_moduledata
argument_list|,
name|SI_SUB_CONFIGURE
argument_list|,
name|SI_ORDER_THIRD
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|ctl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|ctl_frontend
name|ha_frontend
init|=
block|{
operator|.
name|name
operator|=
literal|"ha"
block|,
operator|.
name|init
operator|=
name|ctl_ha_init
block|,
operator|.
name|shutdown
operator|=
name|ctl_ha_shutdown
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|ctl_ha_init
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|control_softc
decl_stmt|;
if|if
condition|(
name|ctl_pool_create
argument_list|(
name|softc
argument_list|,
literal|"othersc"
argument_list|,
name|CTL_POOL_ENTRIES_OTHER_SC
argument_list|,
operator|&
name|softc
operator|->
name|othersc_pool
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
if|if
condition|(
name|ctl_ha_msg_init
argument_list|(
name|softc
argument_list|)
operator|!=
name|CTL_HA_STATUS_SUCCESS
condition|)
block|{
name|ctl_pool_free
argument_list|(
name|softc
operator|->
name|othersc_pool
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
name|ctl_ha_msg_register
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
name|ctl_isc_event_handler
argument_list|)
operator|!=
name|CTL_HA_STATUS_SUCCESS
condition|)
block|{
name|ctl_ha_msg_destroy
argument_list|(
name|softc
argument_list|)
expr_stmt|;
name|ctl_pool_free
argument_list|(
name|softc
operator|->
name|othersc_pool
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_function
specifier|static
name|int
name|ctl_ha_shutdown
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|control_softc
decl_stmt|;
name|struct
name|ctl_port
modifier|*
name|port
decl_stmt|;
name|ctl_ha_msg_shutdown
argument_list|(
name|softc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl_ha_msg_deregister
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|)
operator|!=
name|CTL_HA_STATUS_SUCCESS
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
name|ctl_ha_msg_destroy
argument_list|(
name|softc
argument_list|)
operator|!=
name|CTL_HA_STATUS_SUCCESS
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|ctl_pool_free
argument_list|(
name|softc
operator|->
name|othersc_pool
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|port
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|ha_frontend
operator|.
name|port_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ctl_port_deregister
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|port
operator|->
name|port_name
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|port
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_function
specifier|static
name|void
name|ctl_ha_datamove
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
name|CTL_LUN
argument_list|(
name|io
argument_list|)
decl_stmt|;
name|struct
name|ctl_sg_entry
modifier|*
name|sgl
decl_stmt|;
name|union
name|ctl_ha_msg
name|msg
decl_stmt|;
name|uint32_t
name|sg_entries_sent
decl_stmt|;
name|int
name|do_sg_copy
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|memset
argument_list|(
operator|&
name|msg
operator|.
name|dt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
operator|.
name|dt
argument_list|)
argument_list|)
expr_stmt|;
name|msg
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_DATAMOVE
expr_stmt|;
name|msg
operator|.
name|hdr
operator|.
name|original_sc
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|original_sc
expr_stmt|;
name|msg
operator|.
name|hdr
operator|.
name|serializing_sc
operator|=
name|io
expr_stmt|;
name|msg
operator|.
name|hdr
operator|.
name|nexus
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|nexus
expr_stmt|;
name|msg
operator|.
name|hdr
operator|.
name|status
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|status
expr_stmt|;
name|msg
operator|.
name|dt
operator|.
name|flags
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|flags
expr_stmt|;
comment|/* 	 * We convert everything into a S/G list here.  We can't 	 * pass by reference, only by value between controllers. 	 * So we can't pass a pointer to the S/G list, only as many 	 * S/G entries as we can fit in here.  If it's possible for 	 * us to get more than CTL_HA_MAX_SG_ENTRIES S/G entries, 	 * then we need to break this up into multiple transfers. 	 */
if|if
condition|(
name|io
operator|->
name|scsiio
operator|.
name|kern_sg_entries
operator|==
literal|0
condition|)
block|{
name|msg
operator|.
name|dt
operator|.
name|kern_sg_entries
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
block|if (io->io_hdr.flags& CTL_FLAG_BUS_ADDR) { 			msg.dt.sg_list[0].addr = io->scsiio.kern_data_ptr; 		} else {
comment|/* XXX KDM use busdma here! */
block|msg.dt.sg_list[0].addr = 			    (void *)vtophys(io->scsiio.kern_data_ptr); 		}
else|#
directive|else
name|KASSERT
argument_list|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_BUS_ADDR
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"HA does not support BUS_ADDR"
operator|)
argument_list|)
expr_stmt|;
name|msg
operator|.
name|dt
operator|.
name|sg_list
index|[
literal|0
index|]
operator|.
name|addr
operator|=
name|io
operator|->
name|scsiio
operator|.
name|kern_data_ptr
expr_stmt|;
endif|#
directive|endif
name|msg
operator|.
name|dt
operator|.
name|sg_list
index|[
literal|0
index|]
operator|.
name|len
operator|=
name|io
operator|->
name|scsiio
operator|.
name|kern_data_len
expr_stmt|;
name|do_sg_copy
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|msg
operator|.
name|dt
operator|.
name|kern_sg_entries
operator|=
name|io
operator|->
name|scsiio
operator|.
name|kern_sg_entries
expr_stmt|;
name|do_sg_copy
operator|=
literal|1
expr_stmt|;
block|}
name|msg
operator|.
name|dt
operator|.
name|kern_data_len
operator|=
name|io
operator|->
name|scsiio
operator|.
name|kern_data_len
expr_stmt|;
name|msg
operator|.
name|dt
operator|.
name|kern_total_len
operator|=
name|io
operator|->
name|scsiio
operator|.
name|kern_total_len
expr_stmt|;
name|msg
operator|.
name|dt
operator|.
name|kern_data_resid
operator|=
name|io
operator|->
name|scsiio
operator|.
name|kern_data_resid
expr_stmt|;
name|msg
operator|.
name|dt
operator|.
name|kern_rel_offset
operator|=
name|io
operator|->
name|scsiio
operator|.
name|kern_rel_offset
expr_stmt|;
name|msg
operator|.
name|dt
operator|.
name|sg_sequence
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Loop until we've sent all of the S/G entries.  On the 	 * other end, we'll recompose these S/G entries into one 	 * contiguous list before processing. 	 */
for|for
control|(
name|sg_entries_sent
operator|=
literal|0
init|;
name|sg_entries_sent
operator|<
name|msg
operator|.
name|dt
operator|.
name|kern_sg_entries
condition|;
name|msg
operator|.
name|dt
operator|.
name|sg_sequence
operator|++
control|)
block|{
name|msg
operator|.
name|dt
operator|.
name|cur_sg_entries
operator|=
name|MIN
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
name|msg
operator|.
name|dt
operator|.
name|sg_list
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|msg
operator|.
name|dt
operator|.
name|sg_list
index|[
literal|0
index|]
argument_list|)
operator|)
argument_list|,
name|msg
operator|.
name|dt
operator|.
name|kern_sg_entries
operator|-
name|sg_entries_sent
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_sg_copy
operator|!=
literal|0
condition|)
block|{
name|sgl
operator|=
operator|(
expr|struct
name|ctl_sg_entry
operator|*
operator|)
name|io
operator|->
name|scsiio
operator|.
name|kern_data_ptr
expr_stmt|;
for|for
control|(
name|i
operator|=
name|sg_entries_sent
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|msg
operator|.
name|dt
operator|.
name|cur_sg_entries
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
if|#
directive|if
literal|0
block|if (io->io_hdr.flags& CTL_FLAG_BUS_ADDR) { 					msg.dt.sg_list[j].addr = sgl[i].addr; 				} else {
comment|/* XXX KDM use busdma here! */
block|msg.dt.sg_list[j].addr = 					    (void *)vtophys(sgl[i].addr); 				}
else|#
directive|else
name|KASSERT
argument_list|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_BUS_ADDR
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"HA does not support BUS_ADDR"
operator|)
argument_list|)
expr_stmt|;
name|msg
operator|.
name|dt
operator|.
name|sg_list
index|[
name|j
index|]
operator|.
name|addr
operator|=
name|sgl
index|[
name|i
index|]
operator|.
name|addr
expr_stmt|;
endif|#
directive|endif
name|msg
operator|.
name|dt
operator|.
name|sg_list
index|[
name|j
index|]
operator|.
name|len
operator|=
name|sgl
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
block|}
block|}
name|sg_entries_sent
operator|+=
name|msg
operator|.
name|dt
operator|.
name|cur_sg_entries
expr_stmt|;
name|msg
operator|.
name|dt
operator|.
name|sg_last
operator|=
operator|(
name|sg_entries_sent
operator|>=
name|msg
operator|.
name|dt
operator|.
name|kern_sg_entries
operator|)
expr_stmt|;
if|if
condition|(
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
operator|.
name|dt
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|msg
operator|.
name|dt
operator|.
name|sg_list
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ctl_sg_entry
argument_list|)
operator|*
name|msg
operator|.
name|dt
operator|.
name|cur_sg_entries
argument_list|,
name|M_WAITOK
argument_list|)
operator|>
name|CTL_HA_STATUS_SUCCESS
condition|)
block|{
name|io
operator|->
name|io_hdr
operator|.
name|port_status
operator|=
literal|31341
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|be_move_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
return|return;
block|}
name|msg
operator|.
name|dt
operator|.
name|sent_sg_entries
operator|=
name|sg_entries_sent
expr_stmt|;
block|}
comment|/* 	 * Officially handover the request from us to peer. 	 * If failover has just happened, then we must return error. 	 * If failover happen just after, then it is not our problem. 	 */
if|if
condition|(
name|lun
condition|)
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_FAILOVER
condition|)
block|{
if|if
condition|(
name|lun
condition|)
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|port_status
operator|=
literal|31342
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|be_move_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
return|return;
block|}
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&=
operator|~
name|CTL_FLAG_IO_ACTIVE
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_DMA_INPROG
expr_stmt|;
if|if
condition|(
name|lun
condition|)
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_ha_done
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|union
name|ctl_ha_msg
name|msg
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|io_type
operator|==
name|CTL_IO_SCSI
condition|)
block|{
name|memset
argument_list|(
operator|&
name|msg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|msg
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_FINISH_IO
expr_stmt|;
name|msg
operator|.
name|hdr
operator|.
name|original_sc
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|original_sc
expr_stmt|;
name|msg
operator|.
name|hdr
operator|.
name|nexus
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|nexus
expr_stmt|;
name|msg
operator|.
name|hdr
operator|.
name|status
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|status
expr_stmt|;
name|msg
operator|.
name|scsi
operator|.
name|scsi_status
operator|=
name|io
operator|->
name|scsiio
operator|.
name|scsi_status
expr_stmt|;
name|msg
operator|.
name|scsi
operator|.
name|tag_num
operator|=
name|io
operator|->
name|scsiio
operator|.
name|tag_num
expr_stmt|;
name|msg
operator|.
name|scsi
operator|.
name|tag_type
operator|=
name|io
operator|->
name|scsiio
operator|.
name|tag_type
expr_stmt|;
name|msg
operator|.
name|scsi
operator|.
name|sense_len
operator|=
name|io
operator|->
name|scsiio
operator|.
name|sense_len
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|msg
operator|.
name|scsi
operator|.
name|sense_data
argument_list|,
operator|&
name|io
operator|->
name|scsiio
operator|.
name|sense_data
argument_list|,
name|io
operator|->
name|scsiio
operator|.
name|sense_len
argument_list|)
expr_stmt|;
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
operator|.
name|scsi
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|msg
operator|.
name|scsi
operator|.
name|sense_data
argument_list|)
operator|+
name|msg
operator|.
name|scsi
operator|.
name|sense_len
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
name|ctl_free_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_isc_handler_finish_xfer
parameter_list|(
name|struct
name|ctl_softc
modifier|*
name|ctl_softc
parameter_list|,
name|union
name|ctl_ha_msg
modifier|*
name|msg_info
parameter_list|)
block|{
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
decl_stmt|;
if|if
condition|(
name|msg_info
operator|->
name|hdr
operator|.
name|original_sc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: original_sc == NULL!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* XXX KDM now what? */
return|return;
block|}
name|ctsio
operator|=
operator|&
name|msg_info
operator|->
name|hdr
operator|.
name|original_sc
operator|->
name|scsiio
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_IO_ACTIVE
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_FINISH_IO
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|status
operator|=
name|msg_info
operator|->
name|hdr
operator|.
name|status
expr_stmt|;
name|ctsio
operator|->
name|scsi_status
operator|=
name|msg_info
operator|->
name|scsi
operator|.
name|scsi_status
expr_stmt|;
name|ctsio
operator|->
name|sense_len
operator|=
name|msg_info
operator|->
name|scsi
operator|.
name|sense_len
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ctsio
operator|->
name|sense_data
argument_list|,
operator|&
name|msg_info
operator|->
name|scsi
operator|.
name|sense_data
argument_list|,
name|msg_info
operator|->
name|scsi
operator|.
name|sense_len
argument_list|)
expr_stmt|;
name|ctl_enqueue_isc
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_isc_handler_finish_ser_only
parameter_list|(
name|struct
name|ctl_softc
modifier|*
name|ctl_softc
parameter_list|,
name|union
name|ctl_ha_msg
modifier|*
name|msg_info
parameter_list|)
block|{
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
decl_stmt|;
if|if
condition|(
name|msg_info
operator|->
name|hdr
operator|.
name|serializing_sc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: serializing_sc == NULL!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* XXX KDM now what? */
return|return;
block|}
name|ctsio
operator|=
operator|&
name|msg_info
operator|->
name|hdr
operator|.
name|serializing_sc
operator|->
name|scsiio
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_FINISH_IO
expr_stmt|;
name|ctl_enqueue_isc
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ctl_isc_announce_lun
parameter_list|(
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|lun
operator|->
name|ctl_softc
decl_stmt|;
name|union
name|ctl_ha_msg
modifier|*
name|msg
decl_stmt|;
name|struct
name|ctl_ha_msg_lun_pr_key
name|pr_key
decl_stmt|;
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
if|if
condition|(
name|softc
operator|->
name|ha_link
operator|!=
name|CTL_HA_LINK_ONLINE
condition|)
return|return;
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|i
operator|=
sizeof|sizeof
argument_list|(
name|msg
operator|->
name|lun
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|lun_devid
condition|)
name|i
operator|+=
name|lun
operator|->
name|lun_devid
operator|->
name|len
expr_stmt|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|pr_key
argument_list|)
operator|*
name|lun
operator|->
name|pr_key_count
expr_stmt|;
name|alloc
label|:
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|msg
operator|=
name|malloc
argument_list|(
name|i
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|k
operator|=
sizeof|sizeof
argument_list|(
name|msg
operator|->
name|lun
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|lun_devid
condition|)
name|k
operator|+=
name|lun
operator|->
name|lun_devid
operator|->
name|len
expr_stmt|;
name|k
operator|+=
sizeof|sizeof
argument_list|(
name|pr_key
argument_list|)
operator|*
name|lun
operator|->
name|pr_key_count
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|k
condition|)
block|{
name|free
argument_list|(
name|msg
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|i
operator|=
name|k
expr_stmt|;
goto|goto
name|alloc
goto|;
block|}
name|bzero
argument_list|(
operator|&
name|msg
operator|->
name|lun
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
operator|->
name|lun
argument_list|)
argument_list|)
expr_stmt|;
name|msg
operator|->
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_LUN_SYNC
expr_stmt|;
name|msg
operator|->
name|hdr
operator|.
name|nexus
operator|.
name|targ_lun
operator|=
name|lun
operator|->
name|lun
expr_stmt|;
name|msg
operator|->
name|hdr
operator|.
name|nexus
operator|.
name|targ_mapped_lun
operator|=
name|lun
operator|->
name|lun
expr_stmt|;
name|msg
operator|->
name|lun
operator|.
name|flags
operator|=
name|lun
operator|->
name|flags
expr_stmt|;
name|msg
operator|->
name|lun
operator|.
name|pr_generation
operator|=
name|lun
operator|->
name|pr_generation
expr_stmt|;
name|msg
operator|->
name|lun
operator|.
name|pr_res_idx
operator|=
name|lun
operator|->
name|pr_res_idx
expr_stmt|;
name|msg
operator|->
name|lun
operator|.
name|pr_res_type
operator|=
name|lun
operator|->
name|pr_res_type
expr_stmt|;
name|msg
operator|->
name|lun
operator|.
name|pr_key_count
operator|=
name|lun
operator|->
name|pr_key_count
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|lun_devid
condition|)
block|{
name|msg
operator|->
name|lun
operator|.
name|lun_devid_len
operator|=
name|lun
operator|->
name|lun_devid
operator|->
name|len
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|msg
operator|->
name|lun
operator|.
name|data
index|[
name|i
index|]
argument_list|,
name|lun
operator|->
name|lun_devid
operator|->
name|data
argument_list|,
name|msg
operator|->
name|lun
operator|.
name|lun_devid_len
argument_list|)
expr_stmt|;
name|i
operator|+=
name|msg
operator|->
name|lun
operator|.
name|lun_devid_len
expr_stmt|;
block|}
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|CTL_MAX_INITIATORS
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|pr_key
operator|.
name|pr_key
operator|=
name|ctl_get_prkey
argument_list|(
name|lun
argument_list|,
name|k
argument_list|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|pr_key
operator|.
name|pr_iid
operator|=
name|k
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|msg
operator|->
name|lun
operator|.
name|data
index|[
name|i
index|]
argument_list|,
operator|&
name|pr_key
argument_list|,
sizeof|sizeof
argument_list|(
name|pr_key
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|pr_key
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|msg
operator|->
name|port
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
operator|->
name|port
argument_list|)
operator|+
name|i
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|msg
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_PRIMARY_SC
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_NUM_MODE_PAGES
condition|;
name|i
operator|++
control|)
block|{
name|ctl_isc_announce_mode
argument_list|(
name|lun
argument_list|,
operator|-
literal|1
argument_list|,
name|lun
operator|->
name|mode_pages
operator|.
name|index
index|[
name|i
index|]
operator|.
name|page_code
operator|&
name|SMPH_PC_MASK
argument_list|,
name|lun
operator|->
name|mode_pages
operator|.
name|index
index|[
name|i
index|]
operator|.
name|subpage
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|ctl_isc_announce_port
parameter_list|(
name|struct
name|ctl_port
modifier|*
name|port
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|port
operator|->
name|ctl_softc
decl_stmt|;
name|union
name|ctl_ha_msg
modifier|*
name|msg
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|port
operator|->
name|targ_port
operator|<
name|softc
operator|->
name|port_min
operator|||
name|port
operator|->
name|targ_port
operator|>=
name|softc
operator|->
name|port_max
operator|||
name|softc
operator|->
name|ha_link
operator|!=
name|CTL_HA_LINK_ONLINE
condition|)
return|return;
name|i
operator|=
sizeof|sizeof
argument_list|(
name|msg
operator|->
name|port
argument_list|)
operator|+
name|strlen
argument_list|(
name|port
operator|->
name|port_name
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|lun_map
condition|)
name|i
operator|+=
name|port
operator|->
name|lun_map_size
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|port_devid
condition|)
name|i
operator|+=
name|port
operator|->
name|port_devid
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|target_devid
condition|)
name|i
operator|+=
name|port
operator|->
name|target_devid
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|init_devid
condition|)
name|i
operator|+=
name|port
operator|->
name|init_devid
operator|->
name|len
expr_stmt|;
name|msg
operator|=
name|malloc
argument_list|(
name|i
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|msg
operator|->
name|port
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
operator|->
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|msg
operator|->
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_PORT_SYNC
expr_stmt|;
name|msg
operator|->
name|hdr
operator|.
name|nexus
operator|.
name|targ_port
operator|=
name|port
operator|->
name|targ_port
expr_stmt|;
name|msg
operator|->
name|port
operator|.
name|port_type
operator|=
name|port
operator|->
name|port_type
expr_stmt|;
name|msg
operator|->
name|port
operator|.
name|physical_port
operator|=
name|port
operator|->
name|physical_port
expr_stmt|;
name|msg
operator|->
name|port
operator|.
name|virtual_port
operator|=
name|port
operator|->
name|virtual_port
expr_stmt|;
name|msg
operator|->
name|port
operator|.
name|status
operator|=
name|port
operator|->
name|status
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|msg
operator|->
name|port
operator|.
name|name_len
operator|=
name|sprintf
argument_list|(
operator|&
name|msg
operator|->
name|port
operator|.
name|data
index|[
name|i
index|]
argument_list|,
literal|"%d:%s"
argument_list|,
name|softc
operator|->
name|ha_id
argument_list|,
name|port
operator|->
name|port_name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|i
operator|+=
name|msg
operator|->
name|port
operator|.
name|name_len
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|lun_map
condition|)
block|{
name|msg
operator|->
name|port
operator|.
name|lun_map_len
operator|=
name|port
operator|->
name|lun_map_size
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|msg
operator|->
name|port
operator|.
name|data
index|[
name|i
index|]
argument_list|,
name|port
operator|->
name|lun_map
argument_list|,
name|msg
operator|->
name|port
operator|.
name|lun_map_len
argument_list|)
expr_stmt|;
name|i
operator|+=
name|msg
operator|->
name|port
operator|.
name|lun_map_len
expr_stmt|;
block|}
if|if
condition|(
name|port
operator|->
name|port_devid
condition|)
block|{
name|msg
operator|->
name|port
operator|.
name|port_devid_len
operator|=
name|port
operator|->
name|port_devid
operator|->
name|len
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|msg
operator|->
name|port
operator|.
name|data
index|[
name|i
index|]
argument_list|,
name|port
operator|->
name|port_devid
operator|->
name|data
argument_list|,
name|msg
operator|->
name|port
operator|.
name|port_devid_len
argument_list|)
expr_stmt|;
name|i
operator|+=
name|msg
operator|->
name|port
operator|.
name|port_devid_len
expr_stmt|;
block|}
if|if
condition|(
name|port
operator|->
name|target_devid
condition|)
block|{
name|msg
operator|->
name|port
operator|.
name|target_devid_len
operator|=
name|port
operator|->
name|target_devid
operator|->
name|len
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|msg
operator|->
name|port
operator|.
name|data
index|[
name|i
index|]
argument_list|,
name|port
operator|->
name|target_devid
operator|->
name|data
argument_list|,
name|msg
operator|->
name|port
operator|.
name|target_devid_len
argument_list|)
expr_stmt|;
name|i
operator|+=
name|msg
operator|->
name|port
operator|.
name|target_devid_len
expr_stmt|;
block|}
if|if
condition|(
name|port
operator|->
name|init_devid
condition|)
block|{
name|msg
operator|->
name|port
operator|.
name|init_devid_len
operator|=
name|port
operator|->
name|init_devid
operator|->
name|len
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|msg
operator|->
name|port
operator|.
name|data
index|[
name|i
index|]
argument_list|,
name|port
operator|->
name|init_devid
operator|->
name|data
argument_list|,
name|msg
operator|->
name|port
operator|.
name|init_devid_len
argument_list|)
expr_stmt|;
name|i
operator|+=
name|msg
operator|->
name|port
operator|.
name|init_devid_len
expr_stmt|;
block|}
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|msg
operator|->
name|port
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
operator|->
name|port
argument_list|)
operator|+
name|i
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|msg
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ctl_isc_announce_iid
parameter_list|(
name|struct
name|ctl_port
modifier|*
name|port
parameter_list|,
name|int
name|iid
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|port
operator|->
name|ctl_softc
decl_stmt|;
name|union
name|ctl_ha_msg
modifier|*
name|msg
decl_stmt|;
name|int
name|i
decl_stmt|,
name|l
decl_stmt|;
if|if
condition|(
name|port
operator|->
name|targ_port
operator|<
name|softc
operator|->
name|port_min
operator|||
name|port
operator|->
name|targ_port
operator|>=
name|softc
operator|->
name|port_max
operator|||
name|softc
operator|->
name|ha_link
operator|!=
name|CTL_HA_LINK_ONLINE
condition|)
return|return;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|i
operator|=
sizeof|sizeof
argument_list|(
name|msg
operator|->
name|iid
argument_list|)
expr_stmt|;
name|l
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|wwpn_iid
index|[
name|iid
index|]
operator|.
name|name
condition|)
name|l
operator|=
name|strlen
argument_list|(
name|port
operator|->
name|wwpn_iid
index|[
name|iid
index|]
operator|.
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|i
operator|+=
name|l
expr_stmt|;
name|msg
operator|=
name|malloc
argument_list|(
name|i
argument_list|,
name|M_CTL
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|bzero
argument_list|(
operator|&
name|msg
operator|->
name|iid
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
operator|->
name|iid
argument_list|)
argument_list|)
expr_stmt|;
name|msg
operator|->
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_IID_SYNC
expr_stmt|;
name|msg
operator|->
name|hdr
operator|.
name|nexus
operator|.
name|targ_port
operator|=
name|port
operator|->
name|targ_port
expr_stmt|;
name|msg
operator|->
name|hdr
operator|.
name|nexus
operator|.
name|initid
operator|=
name|iid
expr_stmt|;
name|msg
operator|->
name|iid
operator|.
name|in_use
operator|=
name|port
operator|->
name|wwpn_iid
index|[
name|iid
index|]
operator|.
name|in_use
expr_stmt|;
name|msg
operator|->
name|iid
operator|.
name|name_len
operator|=
name|l
expr_stmt|;
name|msg
operator|->
name|iid
operator|.
name|wwpn
operator|=
name|port
operator|->
name|wwpn_iid
index|[
name|iid
index|]
operator|.
name|wwpn
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|wwpn_iid
index|[
name|iid
index|]
operator|.
name|name
condition|)
name|strlcpy
argument_list|(
name|msg
operator|->
name|iid
operator|.
name|data
argument_list|,
name|port
operator|->
name|wwpn_iid
index|[
name|iid
index|]
operator|.
name|name
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|msg
operator|->
name|iid
argument_list|,
name|i
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|msg
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ctl_isc_announce_mode
parameter_list|(
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|,
name|uint32_t
name|initidx
parameter_list|,
name|uint8_t
name|page
parameter_list|,
name|uint8_t
name|subpage
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|lun
operator|->
name|ctl_softc
decl_stmt|;
name|union
name|ctl_ha_msg
name|msg
decl_stmt|;
name|u_int
name|i
decl_stmt|;
if|if
condition|(
name|softc
operator|->
name|ha_link
operator|!=
name|CTL_HA_LINK_ONLINE
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_NUM_MODE_PAGES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|lun
operator|->
name|mode_pages
operator|.
name|index
index|[
name|i
index|]
operator|.
name|page_code
operator|&
name|SMPH_PC_MASK
operator|)
operator|==
name|page
operator|&&
name|lun
operator|->
name|mode_pages
operator|.
name|index
index|[
name|i
index|]
operator|.
name|subpage
operator|==
name|subpage
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|CTL_NUM_MODE_PAGES
condition|)
return|return;
comment|/* Don't try to replicate pages not present on this device. */
if|if
condition|(
name|lun
operator|->
name|mode_pages
operator|.
name|index
index|[
name|i
index|]
operator|.
name|page_data
operator|==
name|NULL
condition|)
return|return;
name|bzero
argument_list|(
operator|&
name|msg
operator|.
name|mode
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
operator|.
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|msg
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_MODE_SYNC
expr_stmt|;
name|msg
operator|.
name|hdr
operator|.
name|nexus
operator|.
name|targ_port
operator|=
name|initidx
operator|/
name|CTL_MAX_INIT_PER_PORT
expr_stmt|;
name|msg
operator|.
name|hdr
operator|.
name|nexus
operator|.
name|initid
operator|=
name|initidx
operator|%
name|CTL_MAX_INIT_PER_PORT
expr_stmt|;
name|msg
operator|.
name|hdr
operator|.
name|nexus
operator|.
name|targ_lun
operator|=
name|lun
operator|->
name|lun
expr_stmt|;
name|msg
operator|.
name|hdr
operator|.
name|nexus
operator|.
name|targ_mapped_lun
operator|=
name|lun
operator|->
name|lun
expr_stmt|;
name|msg
operator|.
name|mode
operator|.
name|page_code
operator|=
name|page
expr_stmt|;
name|msg
operator|.
name|mode
operator|.
name|subpage
operator|=
name|subpage
expr_stmt|;
name|msg
operator|.
name|mode
operator|.
name|page_len
operator|=
name|lun
operator|->
name|mode_pages
operator|.
name|index
index|[
name|i
index|]
operator|.
name|page_len
expr_stmt|;
name|memcpy
argument_list|(
name|msg
operator|.
name|mode
operator|.
name|data
argument_list|,
name|lun
operator|->
name|mode_pages
operator|.
name|index
index|[
name|i
index|]
operator|.
name|page_data
argument_list|,
name|msg
operator|.
name|mode
operator|.
name|page_len
argument_list|)
expr_stmt|;
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|msg
operator|.
name|mode
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
operator|.
name|mode
argument_list|)
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_isc_ha_link_up
parameter_list|(
name|struct
name|ctl_softc
modifier|*
name|softc
parameter_list|)
block|{
name|struct
name|ctl_port
modifier|*
name|port
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|union
name|ctl_ha_msg
name|msg
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Announce this node parameters to peer for validation. */
name|msg
operator|.
name|login
operator|.
name|msg_type
operator|=
name|CTL_MSG_LOGIN
expr_stmt|;
name|msg
operator|.
name|login
operator|.
name|version
operator|=
name|CTL_HA_VERSION
expr_stmt|;
name|msg
operator|.
name|login
operator|.
name|ha_mode
operator|=
name|softc
operator|->
name|ha_mode
expr_stmt|;
name|msg
operator|.
name|login
operator|.
name|ha_id
operator|=
name|softc
operator|->
name|ha_id
expr_stmt|;
name|msg
operator|.
name|login
operator|.
name|max_luns
operator|=
name|CTL_MAX_LUNS
expr_stmt|;
name|msg
operator|.
name|login
operator|.
name|max_ports
operator|=
name|CTL_MAX_PORTS
expr_stmt|;
name|msg
operator|.
name|login
operator|.
name|max_init_per_port
operator|=
name|CTL_MAX_INIT_PER_PORT
expr_stmt|;
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|msg
operator|.
name|login
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
operator|.
name|login
argument_list|)
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|port
argument_list|,
argument|&softc->port_list
argument_list|,
argument|links
argument_list|)
block|{
name|ctl_isc_announce_port
argument_list|(
name|port
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_MAX_INIT_PER_PORT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|port
operator|->
name|wwpn_iid
index|[
name|i
index|]
operator|.
name|in_use
condition|)
name|ctl_isc_announce_iid
argument_list|(
name|port
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|STAILQ_FOREACH
argument_list|(
argument|lun
argument_list|,
argument|&softc->lun_list
argument_list|,
argument|links
argument_list|)
name|ctl_isc_announce_lun
argument_list|(
name|lun
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_isc_ha_link_down
parameter_list|(
name|struct
name|ctl_softc
modifier|*
name|softc
parameter_list|)
block|{
name|struct
name|ctl_port
modifier|*
name|port
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|lun
argument_list|,
argument|&softc->lun_list
argument_list|,
argument|links
argument_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_PEER_SC_PRIMARY
condition|)
block|{
name|lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_LUN_PEER_SC_PRIMARY
expr_stmt|;
name|ctl_est_ua_all
argument_list|(
name|lun
argument_list|,
operator|-
literal|1
argument_list|,
name|CTL_UA_ASYM_ACC_CHANGE
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|io
operator|=
name|ctl_alloc_io
argument_list|(
name|softc
operator|->
name|othersc_pool
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|ctl_zero_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_FAILOVER
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_mapped_lun
operator|=
name|lun
operator|->
name|lun
expr_stmt|;
name|ctl_enqueue_isc
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
name|STAILQ_FOREACH
argument_list|(
argument|port
argument_list|,
argument|&softc->port_list
argument_list|,
argument|links
argument_list|)
block|{
if|if
condition|(
name|port
operator|->
name|targ_port
operator|>=
name|softc
operator|->
name|port_min
operator|&&
name|port
operator|->
name|targ_port
operator|<
name|softc
operator|->
name|port_max
condition|)
continue|continue;
name|port
operator|->
name|status
operator|&=
operator|~
name|CTL_PORT_STATUS_ONLINE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_MAX_INIT_PER_PORT
condition|;
name|i
operator|++
control|)
block|{
name|port
operator|->
name|wwpn_iid
index|[
name|i
index|]
operator|.
name|in_use
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|port
operator|->
name|wwpn_iid
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|port
operator|->
name|wwpn_iid
index|[
name|i
index|]
operator|.
name|name
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_isc_ua
parameter_list|(
name|struct
name|ctl_softc
modifier|*
name|softc
parameter_list|,
name|union
name|ctl_ha_msg
modifier|*
name|msg
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|uint32_t
name|iid
init|=
name|ctl_get_initindex
argument_list|(
operator|&
name|msg
operator|->
name|hdr
operator|.
name|nexus
argument_list|)
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|hdr
operator|.
name|nexus
operator|.
name|targ_mapped_lun
operator|>=
name|CTL_MAX_LUNS
operator|||
operator|(
name|lun
operator|=
name|softc
operator|->
name|ctl_luns
index|[
name|msg
operator|->
name|hdr
operator|.
name|nexus
operator|.
name|targ_mapped_lun
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|ua
operator|.
name|ua_type
operator|==
name|CTL_UA_THIN_PROV_THRES
operator|&&
name|msg
operator|->
name|ua
operator|.
name|ua_set
condition|)
name|memcpy
argument_list|(
name|lun
operator|->
name|ua_tpt_info
argument_list|,
name|msg
operator|->
name|ua
operator|.
name|ua_info
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|ua
operator|.
name|ua_all
condition|)
block|{
if|if
condition|(
name|msg
operator|->
name|ua
operator|.
name|ua_set
condition|)
name|ctl_est_ua_all
argument_list|(
name|lun
argument_list|,
name|iid
argument_list|,
name|msg
operator|->
name|ua
operator|.
name|ua_type
argument_list|)
expr_stmt|;
else|else
name|ctl_clr_ua_all
argument_list|(
name|lun
argument_list|,
name|iid
argument_list|,
name|msg
operator|->
name|ua
operator|.
name|ua_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|msg
operator|->
name|ua
operator|.
name|ua_set
condition|)
name|ctl_est_ua
argument_list|(
name|lun
argument_list|,
name|iid
argument_list|,
name|msg
operator|->
name|ua
operator|.
name|ua_type
argument_list|)
expr_stmt|;
else|else
name|ctl_clr_ua
argument_list|(
name|lun
argument_list|,
name|iid
argument_list|,
name|msg
operator|->
name|ua
operator|.
name|ua_type
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_isc_lun_sync
parameter_list|(
name|struct
name|ctl_softc
modifier|*
name|softc
parameter_list|,
name|union
name|ctl_ha_msg
modifier|*
name|msg
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|struct
name|ctl_ha_msg_lun_pr_key
name|pr_key
decl_stmt|;
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
name|ctl_lun_flags
name|oflags
decl_stmt|;
name|uint32_t
name|targ_lun
decl_stmt|;
name|targ_lun
operator|=
name|msg
operator|->
name|hdr
operator|.
name|nexus
operator|.
name|targ_mapped_lun
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|targ_lun
operator|>=
name|CTL_MAX_LUNS
operator|||
operator|(
name|lun
operator|=
name|softc
operator|->
name|ctl_luns
index|[
name|targ_lun
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_DISABLED
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|i
operator|=
operator|(
name|lun
operator|->
name|lun_devid
operator|!=
name|NULL
operator|)
condition|?
name|lun
operator|->
name|lun_devid
operator|->
name|len
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|lun
operator|.
name|lun_devid_len
operator|!=
name|i
operator|||
operator|(
name|i
operator|>
literal|0
operator|&&
name|memcmp
argument_list|(
operator|&
name|msg
operator|->
name|lun
operator|.
name|data
index|[
literal|0
index|]
argument_list|,
name|lun
operator|->
name|lun_devid
operator|->
name|data
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Received conflicting HA LUN %d\n"
argument_list|,
name|__func__
argument_list|,
name|targ_lun
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* Record whether peer is primary. */
name|oflags
operator|=
name|lun
operator|->
name|flags
expr_stmt|;
if|if
condition|(
operator|(
name|msg
operator|->
name|lun
operator|.
name|flags
operator|&
name|CTL_LUN_PRIMARY_SC
operator|)
operator|&&
operator|(
name|msg
operator|->
name|lun
operator|.
name|flags
operator|&
name|CTL_LUN_DISABLED
operator|)
operator|==
literal|0
condition|)
name|lun
operator|->
name|flags
operator||=
name|CTL_LUN_PEER_SC_PRIMARY
expr_stmt|;
else|else
name|lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_LUN_PEER_SC_PRIMARY
expr_stmt|;
if|if
condition|(
name|oflags
operator|!=
name|lun
operator|->
name|flags
condition|)
name|ctl_est_ua_all
argument_list|(
name|lun
argument_list|,
operator|-
literal|1
argument_list|,
name|CTL_UA_ASYM_ACC_CHANGE
argument_list|)
expr_stmt|;
comment|/* If peer is primary and we are not -- use data */
if|if
condition|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_PRIMARY_SC
operator|)
operator|==
literal|0
operator|&&
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_PEER_SC_PRIMARY
operator|)
condition|)
block|{
name|lun
operator|->
name|pr_generation
operator|=
name|msg
operator|->
name|lun
operator|.
name|pr_generation
expr_stmt|;
name|lun
operator|->
name|pr_res_idx
operator|=
name|msg
operator|->
name|lun
operator|.
name|pr_res_idx
expr_stmt|;
name|lun
operator|->
name|pr_res_type
operator|=
name|msg
operator|->
name|lun
operator|.
name|pr_res_type
expr_stmt|;
name|lun
operator|->
name|pr_key_count
operator|=
name|msg
operator|->
name|lun
operator|.
name|pr_key_count
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|CTL_MAX_INITIATORS
condition|;
name|k
operator|++
control|)
name|ctl_clr_prkey
argument_list|(
name|lun
argument_list|,
name|k
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|msg
operator|->
name|lun
operator|.
name|pr_key_count
condition|;
name|k
operator|++
control|)
block|{
name|memcpy
argument_list|(
operator|&
name|pr_key
argument_list|,
operator|&
name|msg
operator|->
name|lun
operator|.
name|data
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|pr_key
argument_list|)
argument_list|)
expr_stmt|;
name|ctl_alloc_prkey
argument_list|(
name|lun
argument_list|,
name|pr_key
operator|.
name|pr_iid
argument_list|)
expr_stmt|;
name|ctl_set_prkey
argument_list|(
name|lun
argument_list|,
name|pr_key
operator|.
name|pr_iid
argument_list|,
name|pr_key
operator|.
name|pr_key
argument_list|)
expr_stmt|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|pr_key
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"%s: Known LUN %d, peer is %s\n"
operator|,
name|__func__
operator|,
name|targ_lun
operator|,
operator|(
name|msg
operator|->
name|lun
operator|.
name|flags
operator|&
name|CTL_LUN_PRIMARY_SC
operator|)
condition|?
literal|"primary"
else|:
literal|"secondary"
operator|)
argument_list|)
expr_stmt|;
comment|/* If we are primary but peer doesn't know -- notify */
if|if
condition|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_PRIMARY_SC
operator|)
operator|&&
operator|(
name|msg
operator|->
name|lun
operator|.
name|flags
operator|&
name|CTL_LUN_PEER_SC_PRIMARY
operator|)
operator|==
literal|0
condition|)
name|ctl_isc_announce_lun
argument_list|(
name|lun
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_isc_port_sync
parameter_list|(
name|struct
name|ctl_softc
modifier|*
name|softc
parameter_list|,
name|union
name|ctl_ha_msg
modifier|*
name|msg
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|ctl_port
modifier|*
name|port
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|int
name|i
decl_stmt|,
name|new
decl_stmt|;
name|port
operator|=
name|softc
operator|->
name|ctl_ports
index|[
name|msg
operator|->
name|hdr
operator|.
name|nexus
operator|.
name|targ_port
index|]
expr_stmt|;
if|if
condition|(
name|port
operator|==
name|NULL
condition|)
block|{
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"%s: New port %d\n"
operator|,
name|__func__
operator|,
name|msg
operator|->
name|hdr
operator|.
name|nexus
operator|.
name|targ_port
operator|)
argument_list|)
expr_stmt|;
name|new
operator|=
literal|1
expr_stmt|;
name|port
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|port
argument_list|)
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|port
operator|->
name|frontend
operator|=
operator|&
name|ha_frontend
expr_stmt|;
name|port
operator|->
name|targ_port
operator|=
name|msg
operator|->
name|hdr
operator|.
name|nexus
operator|.
name|targ_port
expr_stmt|;
name|port
operator|->
name|fe_datamove
operator|=
name|ctl_ha_datamove
expr_stmt|;
name|port
operator|->
name|fe_done
operator|=
name|ctl_ha_done
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|port
operator|->
name|frontend
operator|==
operator|&
name|ha_frontend
condition|)
block|{
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"%s: Updated port %d\n"
operator|,
name|__func__
operator|,
name|msg
operator|->
name|hdr
operator|.
name|nexus
operator|.
name|targ_port
operator|)
argument_list|)
expr_stmt|;
name|new
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s: Received conflicting HA port %d\n"
argument_list|,
name|__func__
argument_list|,
name|msg
operator|->
name|hdr
operator|.
name|nexus
operator|.
name|targ_port
argument_list|)
expr_stmt|;
return|return;
block|}
name|port
operator|->
name|port_type
operator|=
name|msg
operator|->
name|port
operator|.
name|port_type
expr_stmt|;
name|port
operator|->
name|physical_port
operator|=
name|msg
operator|->
name|port
operator|.
name|physical_port
expr_stmt|;
name|port
operator|->
name|virtual_port
operator|=
name|msg
operator|->
name|port
operator|.
name|virtual_port
expr_stmt|;
name|port
operator|->
name|status
operator|=
name|msg
operator|->
name|port
operator|.
name|status
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|port
operator|->
name|port_name
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|port
operator|->
name|port_name
operator|=
name|strndup
argument_list|(
operator|&
name|msg
operator|->
name|port
operator|.
name|data
index|[
name|i
index|]
argument_list|,
name|msg
operator|->
name|port
operator|.
name|name_len
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|i
operator|+=
name|msg
operator|->
name|port
operator|.
name|name_len
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|port
operator|.
name|lun_map_len
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|port
operator|->
name|lun_map
operator|==
name|NULL
operator|||
name|port
operator|->
name|lun_map_size
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|<
name|msg
operator|->
name|port
operator|.
name|lun_map_len
condition|)
block|{
name|port
operator|->
name|lun_map_size
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|port
operator|->
name|lun_map
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|port
operator|->
name|lun_map
operator|=
name|malloc
argument_list|(
name|msg
operator|->
name|port
operator|.
name|lun_map_len
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|port
operator|->
name|lun_map
argument_list|,
operator|&
name|msg
operator|->
name|port
operator|.
name|data
index|[
name|i
index|]
argument_list|,
name|msg
operator|->
name|port
operator|.
name|lun_map_len
argument_list|)
expr_stmt|;
name|port
operator|->
name|lun_map_size
operator|=
name|msg
operator|->
name|port
operator|.
name|lun_map_len
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|i
operator|+=
name|msg
operator|->
name|port
operator|.
name|lun_map_len
expr_stmt|;
block|}
else|else
block|{
name|port
operator|->
name|lun_map_size
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|port
operator|->
name|lun_map
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|port
operator|->
name|lun_map
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|msg
operator|->
name|port
operator|.
name|port_devid_len
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|port
operator|->
name|port_devid
operator|==
name|NULL
operator|||
name|port
operator|->
name|port_devid
operator|->
name|len
operator|<
name|msg
operator|->
name|port
operator|.
name|port_devid_len
condition|)
block|{
name|free
argument_list|(
name|port
operator|->
name|port_devid
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|port
operator|->
name|port_devid
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ctl_devid
argument_list|)
operator|+
name|msg
operator|->
name|port
operator|.
name|port_devid_len
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|port
operator|->
name|port_devid
operator|->
name|data
argument_list|,
operator|&
name|msg
operator|->
name|port
operator|.
name|data
index|[
name|i
index|]
argument_list|,
name|msg
operator|->
name|port
operator|.
name|port_devid_len
argument_list|)
expr_stmt|;
name|port
operator|->
name|port_devid
operator|->
name|len
operator|=
name|msg
operator|->
name|port
operator|.
name|port_devid_len
expr_stmt|;
name|i
operator|+=
name|msg
operator|->
name|port
operator|.
name|port_devid_len
expr_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
name|port
operator|->
name|port_devid
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|port
operator|->
name|port_devid
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|msg
operator|->
name|port
operator|.
name|target_devid_len
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|port
operator|->
name|target_devid
operator|==
name|NULL
operator|||
name|port
operator|->
name|target_devid
operator|->
name|len
operator|<
name|msg
operator|->
name|port
operator|.
name|target_devid_len
condition|)
block|{
name|free
argument_list|(
name|port
operator|->
name|target_devid
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|port
operator|->
name|target_devid
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ctl_devid
argument_list|)
operator|+
name|msg
operator|->
name|port
operator|.
name|target_devid_len
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|port
operator|->
name|target_devid
operator|->
name|data
argument_list|,
operator|&
name|msg
operator|->
name|port
operator|.
name|data
index|[
name|i
index|]
argument_list|,
name|msg
operator|->
name|port
operator|.
name|target_devid_len
argument_list|)
expr_stmt|;
name|port
operator|->
name|target_devid
operator|->
name|len
operator|=
name|msg
operator|->
name|port
operator|.
name|target_devid_len
expr_stmt|;
name|i
operator|+=
name|msg
operator|->
name|port
operator|.
name|target_devid_len
expr_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
name|port
operator|->
name|target_devid
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|port
operator|->
name|target_devid
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|msg
operator|->
name|port
operator|.
name|init_devid_len
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|port
operator|->
name|init_devid
operator|==
name|NULL
operator|||
name|port
operator|->
name|init_devid
operator|->
name|len
operator|<
name|msg
operator|->
name|port
operator|.
name|init_devid_len
condition|)
block|{
name|free
argument_list|(
name|port
operator|->
name|init_devid
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|port
operator|->
name|init_devid
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ctl_devid
argument_list|)
operator|+
name|msg
operator|->
name|port
operator|.
name|init_devid_len
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|port
operator|->
name|init_devid
operator|->
name|data
argument_list|,
operator|&
name|msg
operator|->
name|port
operator|.
name|data
index|[
name|i
index|]
argument_list|,
name|msg
operator|->
name|port
operator|.
name|init_devid_len
argument_list|)
expr_stmt|;
name|port
operator|->
name|init_devid
operator|->
name|len
operator|=
name|msg
operator|->
name|port
operator|.
name|init_devid_len
expr_stmt|;
name|i
operator|+=
name|msg
operator|->
name|port
operator|.
name|init_devid_len
expr_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
name|port
operator|->
name|init_devid
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|port
operator|->
name|init_devid
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|new
condition|)
block|{
if|if
condition|(
name|ctl_port_register
argument_list|(
name|port
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ctl_port_register() failed with error\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|lun
argument_list|,
argument|&softc->lun_list
argument_list|,
argument|links
argument_list|)
block|{
if|if
condition|(
name|ctl_lun_map_to_port
argument_list|(
name|port
argument_list|,
name|lun
operator|->
name|lun
argument_list|)
operator|==
name|UINT32_MAX
condition|)
continue|continue;
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctl_est_ua_all
argument_list|(
name|lun
argument_list|,
operator|-
literal|1
argument_list|,
name|CTL_UA_INQ_CHANGE
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_isc_iid_sync
parameter_list|(
name|struct
name|ctl_softc
modifier|*
name|softc
parameter_list|,
name|union
name|ctl_ha_msg
modifier|*
name|msg
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|ctl_port
modifier|*
name|port
decl_stmt|;
name|int
name|iid
decl_stmt|;
name|port
operator|=
name|softc
operator|->
name|ctl_ports
index|[
name|msg
operator|->
name|hdr
operator|.
name|nexus
operator|.
name|targ_port
index|]
expr_stmt|;
if|if
condition|(
name|port
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Received IID for unknown port %d\n"
argument_list|,
name|__func__
argument_list|,
name|msg
operator|->
name|hdr
operator|.
name|nexus
operator|.
name|targ_port
argument_list|)
expr_stmt|;
return|return;
block|}
name|iid
operator|=
name|msg
operator|->
name|hdr
operator|.
name|nexus
operator|.
name|initid
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|wwpn_iid
index|[
name|iid
index|]
operator|.
name|in_use
operator|!=
literal|0
operator|&&
name|msg
operator|->
name|iid
operator|.
name|in_use
operator|==
literal|0
condition|)
name|ctl_i_t_nexus_loss
argument_list|(
name|softc
argument_list|,
name|iid
argument_list|,
name|CTL_UA_POWERON
argument_list|)
expr_stmt|;
name|port
operator|->
name|wwpn_iid
index|[
name|iid
index|]
operator|.
name|in_use
operator|=
name|msg
operator|->
name|iid
operator|.
name|in_use
expr_stmt|;
name|port
operator|->
name|wwpn_iid
index|[
name|iid
index|]
operator|.
name|wwpn
operator|=
name|msg
operator|->
name|iid
operator|.
name|wwpn
expr_stmt|;
name|free
argument_list|(
name|port
operator|->
name|wwpn_iid
index|[
name|iid
index|]
operator|.
name|name
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|iid
operator|.
name|name_len
condition|)
block|{
name|port
operator|->
name|wwpn_iid
index|[
name|iid
index|]
operator|.
name|name
operator|=
name|strndup
argument_list|(
operator|&
name|msg
operator|->
name|iid
operator|.
name|data
index|[
literal|0
index|]
argument_list|,
name|msg
operator|->
name|iid
operator|.
name|name_len
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
block|}
else|else
name|port
operator|->
name|wwpn_iid
index|[
name|iid
index|]
operator|.
name|name
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_isc_login
parameter_list|(
name|struct
name|ctl_softc
modifier|*
name|softc
parameter_list|,
name|union
name|ctl_ha_msg
modifier|*
name|msg
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|msg
operator|->
name|login
operator|.
name|version
operator|!=
name|CTL_HA_VERSION
condition|)
block|{
name|printf
argument_list|(
literal|"CTL HA peers have different versions %d != %d\n"
argument_list|,
name|msg
operator|->
name|login
operator|.
name|version
argument_list|,
name|CTL_HA_VERSION
argument_list|)
expr_stmt|;
name|ctl_ha_msg_abort
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|msg
operator|->
name|login
operator|.
name|ha_mode
operator|!=
name|softc
operator|->
name|ha_mode
condition|)
block|{
name|printf
argument_list|(
literal|"CTL HA peers have different ha_mode %d != %d\n"
argument_list|,
name|msg
operator|->
name|login
operator|.
name|ha_mode
argument_list|,
name|softc
operator|->
name|ha_mode
argument_list|)
expr_stmt|;
name|ctl_ha_msg_abort
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|msg
operator|->
name|login
operator|.
name|ha_id
operator|==
name|softc
operator|->
name|ha_id
condition|)
block|{
name|printf
argument_list|(
literal|"CTL HA peers have same ha_id %d\n"
argument_list|,
name|msg
operator|->
name|login
operator|.
name|ha_id
argument_list|)
expr_stmt|;
name|ctl_ha_msg_abort
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|msg
operator|->
name|login
operator|.
name|max_luns
operator|!=
name|CTL_MAX_LUNS
operator|||
name|msg
operator|->
name|login
operator|.
name|max_ports
operator|!=
name|CTL_MAX_PORTS
operator|||
name|msg
operator|->
name|login
operator|.
name|max_init_per_port
operator|!=
name|CTL_MAX_INIT_PER_PORT
condition|)
block|{
name|printf
argument_list|(
literal|"CTL HA peers have different limits\n"
argument_list|)
expr_stmt|;
name|ctl_ha_msg_abort
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_isc_mode_sync
parameter_list|(
name|struct
name|ctl_softc
modifier|*
name|softc
parameter_list|,
name|union
name|ctl_ha_msg
modifier|*
name|msg
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|uint32_t
name|initidx
decl_stmt|,
name|targ_lun
decl_stmt|;
name|targ_lun
operator|=
name|msg
operator|->
name|hdr
operator|.
name|nexus
operator|.
name|targ_mapped_lun
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|targ_lun
operator|>=
name|CTL_MAX_LUNS
operator|||
operator|(
name|lun
operator|=
name|softc
operator|->
name|ctl_luns
index|[
name|targ_lun
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_DISABLED
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_NUM_MODE_PAGES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|lun
operator|->
name|mode_pages
operator|.
name|index
index|[
name|i
index|]
operator|.
name|page_code
operator|&
name|SMPH_PC_MASK
operator|)
operator|==
name|msg
operator|->
name|mode
operator|.
name|page_code
operator|&&
name|lun
operator|->
name|mode_pages
operator|.
name|index
index|[
name|i
index|]
operator|.
name|subpage
operator|==
name|msg
operator|->
name|mode
operator|.
name|subpage
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|CTL_NUM_MODE_PAGES
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|memcpy
argument_list|(
name|lun
operator|->
name|mode_pages
operator|.
name|index
index|[
name|i
index|]
operator|.
name|page_data
argument_list|,
name|msg
operator|->
name|mode
operator|.
name|data
argument_list|,
name|lun
operator|->
name|mode_pages
operator|.
name|index
index|[
name|i
index|]
operator|.
name|page_len
argument_list|)
expr_stmt|;
name|initidx
operator|=
name|ctl_get_initindex
argument_list|(
operator|&
name|msg
operator|->
name|hdr
operator|.
name|nexus
argument_list|)
expr_stmt|;
if|if
condition|(
name|initidx
operator|!=
operator|-
literal|1
condition|)
name|ctl_est_ua_all
argument_list|(
name|lun
argument_list|,
name|initidx
argument_list|,
name|CTL_UA_MODE_CHANGE
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ISC (Inter Shelf Communication) event handler.  Events from the HA  * subsystem come in here.  */
end_comment

begin_function
specifier|static
name|void
name|ctl_isc_event_handler
parameter_list|(
name|ctl_ha_channel
name|channel
parameter_list|,
name|ctl_ha_event
name|event
parameter_list|,
name|int
name|param
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|control_softc
decl_stmt|;
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|struct
name|ctl_prio
modifier|*
name|presio
decl_stmt|;
name|ctl_ha_status
name|isc_status
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"CTL: Isc Msg event %d\n"
operator|,
name|event
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|==
name|CTL_HA_EVT_MSG_RECV
condition|)
block|{
name|union
name|ctl_ha_msg
modifier|*
name|msg
decl_stmt|,
name|msgbuf
decl_stmt|;
if|if
condition|(
name|param
operator|>
sizeof|sizeof
argument_list|(
name|msgbuf
argument_list|)
condition|)
name|msg
operator|=
name|malloc
argument_list|(
name|param
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
else|else
name|msg
operator|=
operator|&
name|msgbuf
expr_stmt|;
name|isc_status
operator|=
name|ctl_ha_msg_recv
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
name|msg
argument_list|,
name|param
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|isc_status
operator|!=
name|CTL_HA_STATUS_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Error receiving message: %d\n"
argument_list|,
name|__func__
argument_list|,
name|isc_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|!=
operator|&
name|msgbuf
condition|)
name|free
argument_list|(
name|msg
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
return|return;
block|}
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"CTL: msg_type %d\n"
operator|,
name|msg
operator|->
name|msg_type
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|msg
operator|->
name|hdr
operator|.
name|msg_type
condition|)
block|{
case|case
name|CTL_MSG_SERIALIZE
case|:
name|io
operator|=
name|ctl_alloc_io
argument_list|(
name|softc
operator|->
name|othersc_pool
argument_list|)
expr_stmt|;
name|ctl_zero_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
comment|// populate ctsio from msg
name|io
operator|->
name|io_hdr
operator|.
name|io_type
operator|=
name|CTL_IO_SCSI
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_SERIALIZE
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|original_sc
operator|=
name|msg
operator|->
name|hdr
operator|.
name|original_sc
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_FROM_OTHER_SC
operator||
name|CTL_FLAG_IO_ACTIVE
expr_stmt|;
comment|/* 			 * If we're in serialization-only mode, we don't 			 * want to go through full done processing.  Thus 			 * the COPY flag. 			 * 			 * XXX KDM add another flag that is more specific. 			 */
if|if
condition|(
name|softc
operator|->
name|ha_mode
operator|!=
name|CTL_HA_MODE_XFER
condition|)
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_INT_COPY
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|=
name|msg
operator|->
name|hdr
operator|.
name|nexus
expr_stmt|;
if|#
directive|if
literal|0
block|printf("port %u, iid %u, lun %u\n", 			       io->io_hdr.nexus.targ_port, 			       io->io_hdr.nexus.initid, 			       io->io_hdr.nexus.targ_lun);
endif|#
directive|endif
name|io
operator|->
name|scsiio
operator|.
name|tag_num
operator|=
name|msg
operator|->
name|scsi
operator|.
name|tag_num
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|tag_type
operator|=
name|msg
operator|->
name|scsi
operator|.
name|tag_type
expr_stmt|;
ifdef|#
directive|ifdef
name|CTL_TIME_IO
name|io
operator|->
name|io_hdr
operator|.
name|start_time
operator|=
name|time_uptime
expr_stmt|;
name|getbinuptime
argument_list|(
operator|&
name|io
operator|->
name|io_hdr
operator|.
name|start_bt
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CTL_TIME_IO */
name|io
operator|->
name|scsiio
operator|.
name|cdb_len
operator|=
name|msg
operator|->
name|scsi
operator|.
name|cdb_len
expr_stmt|;
name|memcpy
argument_list|(
name|io
operator|->
name|scsiio
operator|.
name|cdb
argument_list|,
name|msg
operator|->
name|scsi
operator|.
name|cdb
argument_list|,
name|CTL_MAX_CDBLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|ha_mode
operator|==
name|CTL_HA_MODE_XFER
condition|)
block|{
specifier|const
name|struct
name|ctl_cmd_entry
modifier|*
name|entry
decl_stmt|;
name|entry
operator|=
name|ctl_get_cmd_entry
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&=
operator|~
name|CTL_FLAG_DATA_MASK
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|entry
operator|->
name|flags
operator|&
name|CTL_FLAG_DATA_MASK
expr_stmt|;
block|}
name|ctl_enqueue_isc
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
comment|/* Performed on the Originating SC, XFER mode only */
case|case
name|CTL_MSG_DATAMOVE
case|:
block|{
name|struct
name|ctl_sg_entry
modifier|*
name|sgl
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|io
operator|=
name|msg
operator|->
name|hdr
operator|.
name|original_sc
expr_stmt|;
if|if
condition|(
name|io
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: original_sc == NULL!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* XXX KDM do something here */
break|break;
block|}
name|io
operator|->
name|io_hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_DATAMOVE
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_IO_ACTIVE
expr_stmt|;
comment|/* 			 * Keep track of this, we need to send it back over 			 * when the datamove is complete. 			 */
name|io
operator|->
name|io_hdr
operator|.
name|serializing_sc
operator|=
name|msg
operator|->
name|hdr
operator|.
name|serializing_sc
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|hdr
operator|.
name|status
operator|==
name|CTL_SUCCESS
condition|)
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|=
name|msg
operator|->
name|hdr
operator|.
name|status
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|dt
operator|.
name|sg_sequence
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|CTL_TIME_IO
name|getbinuptime
argument_list|(
operator|&
name|io
operator|->
name|io_hdr
operator|.
name|dma_start_bt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
name|msg
operator|->
name|dt
operator|.
name|kern_sg_entries
operator|+
name|msg
operator|->
name|dt
operator|.
name|kern_data_len
operator|/
name|CTL_HA_DATAMOVE_SEGMENT
operator|+
literal|1
expr_stmt|;
name|sgl
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sgl
argument_list|)
operator|*
name|i
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|remote_sglist
operator|=
name|sgl
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|local_sglist
operator|=
operator|&
name|sgl
index|[
name|msg
operator|->
name|dt
operator|.
name|kern_sg_entries
index|]
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|kern_data_ptr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|sgl
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|kern_sg_entries
operator|=
name|msg
operator|->
name|dt
operator|.
name|kern_sg_entries
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|rem_sg_entries
operator|=
name|msg
operator|->
name|dt
operator|.
name|kern_sg_entries
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|kern_data_len
operator|=
name|msg
operator|->
name|dt
operator|.
name|kern_data_len
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|kern_total_len
operator|=
name|msg
operator|->
name|dt
operator|.
name|kern_total_len
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|kern_data_resid
operator|=
name|msg
operator|->
name|dt
operator|.
name|kern_data_resid
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|kern_rel_offset
operator|=
name|msg
operator|->
name|dt
operator|.
name|kern_rel_offset
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&=
operator|~
name|CTL_FLAG_BUS_ADDR
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|msg
operator|->
name|dt
operator|.
name|flags
operator|&
name|CTL_FLAG_BUS_ADDR
expr_stmt|;
block|}
else|else
name|sgl
operator|=
operator|(
expr|struct
name|ctl_sg_entry
operator|*
operator|)
name|io
operator|->
name|scsiio
operator|.
name|kern_data_ptr
expr_stmt|;
for|for
control|(
name|i
operator|=
name|msg
operator|->
name|dt
operator|.
name|sent_sg_entries
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|msg
operator|->
name|dt
operator|.
name|sent_sg_entries
operator|+
name|msg
operator|->
name|dt
operator|.
name|cur_sg_entries
operator|)
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
name|sgl
index|[
name|i
index|]
operator|.
name|addr
operator|=
name|msg
operator|->
name|dt
operator|.
name|sg_list
index|[
name|j
index|]
operator|.
name|addr
expr_stmt|;
name|sgl
index|[
name|i
index|]
operator|.
name|len
operator|=
name|msg
operator|->
name|dt
operator|.
name|sg_list
index|[
name|j
index|]
operator|.
name|len
expr_stmt|;
if|#
directive|if
literal|0
block|printf("%s: DATAMOVE: %p,%lu j=%d, i=%d\n", 				    __func__, sgl[i].addr, sgl[i].len, j, i);
endif|#
directive|endif
block|}
comment|/* 			 * If this is the last piece of the I/O, we've got 			 * the full S/G list.  Queue processing in the thread. 			 * Otherwise wait for the next piece. 			 */
if|if
condition|(
name|msg
operator|->
name|dt
operator|.
name|sg_last
operator|!=
literal|0
condition|)
name|ctl_enqueue_isc
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Performed on the Serializing (primary) SC, XFER mode only */
case|case
name|CTL_MSG_DATAMOVE_DONE
case|:
block|{
if|if
condition|(
name|msg
operator|->
name|hdr
operator|.
name|serializing_sc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: serializing_sc == NULL!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* XXX KDM now what? */
break|break;
block|}
comment|/* 			 * We grab the sense information here in case 			 * there was a failure, so we can return status 			 * back to the initiator. 			 */
name|io
operator|=
name|msg
operator|->
name|hdr
operator|.
name|serializing_sc
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_DATAMOVE_DONE
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&=
operator|~
name|CTL_FLAG_DMA_INPROG
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_IO_ACTIVE
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|port_status
operator|=
name|msg
operator|->
name|scsi
operator|.
name|port_status
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|kern_data_resid
operator|=
name|msg
operator|->
name|scsi
operator|.
name|kern_data_resid
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|hdr
operator|.
name|status
operator|!=
name|CTL_STATUS_NONE
condition|)
block|{
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|=
name|msg
operator|->
name|hdr
operator|.
name|status
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|scsi_status
operator|=
name|msg
operator|->
name|scsi
operator|.
name|scsi_status
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|sense_len
operator|=
name|msg
operator|->
name|scsi
operator|.
name|sense_len
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|io
operator|->
name|scsiio
operator|.
name|sense_data
argument_list|,
operator|&
name|msg
operator|->
name|scsi
operator|.
name|sense_data
argument_list|,
name|msg
operator|->
name|scsi
operator|.
name|sense_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|hdr
operator|.
name|status
operator|==
name|CTL_SUCCESS
condition|)
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_STATUS_SENT
expr_stmt|;
block|}
name|ctl_enqueue_isc
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Preformed on Originating SC, SER_ONLY mode */
case|case
name|CTL_MSG_R2R
case|:
name|io
operator|=
name|msg
operator|->
name|hdr
operator|.
name|original_sc
expr_stmt|;
if|if
condition|(
name|io
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: original_sc == NULL!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
break|break;
block|}
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_IO_ACTIVE
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_R2R
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|serializing_sc
operator|=
name|msg
operator|->
name|hdr
operator|.
name|serializing_sc
expr_stmt|;
name|ctl_enqueue_isc
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * Performed on Serializing(i.e. primary SC) SC in SER_ONLY 		 * mode. 		 * Performed on the Originating (i.e. secondary) SC in XFER 		 * mode 		 */
case|case
name|CTL_MSG_FINISH_IO
case|:
if|if
condition|(
name|softc
operator|->
name|ha_mode
operator|==
name|CTL_HA_MODE_XFER
condition|)
name|ctl_isc_handler_finish_xfer
argument_list|(
name|softc
argument_list|,
name|msg
argument_list|)
expr_stmt|;
else|else
name|ctl_isc_handler_finish_ser_only
argument_list|(
name|softc
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
comment|/* Preformed on Originating SC */
case|case
name|CTL_MSG_BAD_JUJU
case|:
name|io
operator|=
name|msg
operator|->
name|hdr
operator|.
name|original_sc
expr_stmt|;
if|if
condition|(
name|io
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Bad JUJU!, original_sc is NULL!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
break|break;
block|}
name|ctl_copy_sense_data
argument_list|(
name|msg
argument_list|,
name|io
argument_list|)
expr_stmt|;
comment|/* 			 * IO should have already been cleaned up on other 			 * SC so clear this flag so we won't send a message 			 * back to finish the IO there. 			 */
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&=
operator|~
name|CTL_FLAG_SENT_2OTHER_SC
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_IO_ACTIVE
expr_stmt|;
comment|/* io = msg->hdr.serializing_sc; */
name|io
operator|->
name|io_hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_BAD_JUJU
expr_stmt|;
name|ctl_enqueue_isc
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
comment|/* Handle resets sent from the other side */
case|case
name|CTL_MSG_MANAGE_TASKS
case|:
block|{
name|struct
name|ctl_taskio
modifier|*
name|taskio
decl_stmt|;
name|taskio
operator|=
operator|(
expr|struct
name|ctl_taskio
operator|*
operator|)
name|ctl_alloc_io
argument_list|(
name|softc
operator|->
name|othersc_pool
argument_list|)
expr_stmt|;
name|ctl_zero_io
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|taskio
argument_list|)
expr_stmt|;
name|taskio
operator|->
name|io_hdr
operator|.
name|io_type
operator|=
name|CTL_IO_TASK
expr_stmt|;
name|taskio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_FROM_OTHER_SC
expr_stmt|;
name|taskio
operator|->
name|io_hdr
operator|.
name|nexus
operator|=
name|msg
operator|->
name|hdr
operator|.
name|nexus
expr_stmt|;
name|taskio
operator|->
name|task_action
operator|=
name|msg
operator|->
name|task
operator|.
name|task_action
expr_stmt|;
name|taskio
operator|->
name|tag_num
operator|=
name|msg
operator|->
name|task
operator|.
name|tag_num
expr_stmt|;
name|taskio
operator|->
name|tag_type
operator|=
name|msg
operator|->
name|task
operator|.
name|tag_type
expr_stmt|;
ifdef|#
directive|ifdef
name|CTL_TIME_IO
name|taskio
operator|->
name|io_hdr
operator|.
name|start_time
operator|=
name|time_uptime
expr_stmt|;
name|getbinuptime
argument_list|(
operator|&
name|taskio
operator|->
name|io_hdr
operator|.
name|start_bt
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CTL_TIME_IO */
name|ctl_run_task
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|taskio
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Persistent Reserve action which needs attention */
case|case
name|CTL_MSG_PERS_ACTION
case|:
name|presio
operator|=
operator|(
expr|struct
name|ctl_prio
operator|*
operator|)
name|ctl_alloc_io
argument_list|(
name|softc
operator|->
name|othersc_pool
argument_list|)
expr_stmt|;
name|ctl_zero_io
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|presio
argument_list|)
expr_stmt|;
name|presio
operator|->
name|io_hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_PERS_ACTION
expr_stmt|;
name|presio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_FROM_OTHER_SC
expr_stmt|;
name|presio
operator|->
name|io_hdr
operator|.
name|nexus
operator|=
name|msg
operator|->
name|hdr
operator|.
name|nexus
expr_stmt|;
name|presio
operator|->
name|pr_msg
operator|=
name|msg
operator|->
name|pr
expr_stmt|;
name|ctl_enqueue_isc
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|presio
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_MSG_UA
case|:
name|ctl_isc_ua
argument_list|(
name|softc
argument_list|,
name|msg
argument_list|,
name|param
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_MSG_PORT_SYNC
case|:
name|ctl_isc_port_sync
argument_list|(
name|softc
argument_list|,
name|msg
argument_list|,
name|param
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_MSG_LUN_SYNC
case|:
name|ctl_isc_lun_sync
argument_list|(
name|softc
argument_list|,
name|msg
argument_list|,
name|param
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_MSG_IID_SYNC
case|:
name|ctl_isc_iid_sync
argument_list|(
name|softc
argument_list|,
name|msg
argument_list|,
name|param
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_MSG_LOGIN
case|:
name|ctl_isc_login
argument_list|(
name|softc
argument_list|,
name|msg
argument_list|,
name|param
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_MSG_MODE_SYNC
case|:
name|ctl_isc_mode_sync
argument_list|(
name|softc
argument_list|,
name|msg
argument_list|,
name|param
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Received HA message of unknown type %d\n"
argument_list|,
name|msg
operator|->
name|hdr
operator|.
name|msg_type
argument_list|)
expr_stmt|;
name|ctl_ha_msg_abort
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|msg
operator|!=
operator|&
name|msgbuf
condition|)
name|free
argument_list|(
name|msg
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|event
operator|==
name|CTL_HA_EVT_LINK_CHANGE
condition|)
block|{
name|printf
argument_list|(
literal|"CTL: HA link status changed from %d to %d\n"
argument_list|,
name|softc
operator|->
name|ha_link
argument_list|,
name|param
argument_list|)
expr_stmt|;
if|if
condition|(
name|param
operator|==
name|softc
operator|->
name|ha_link
condition|)
return|return;
if|if
condition|(
name|softc
operator|->
name|ha_link
operator|==
name|CTL_HA_LINK_ONLINE
condition|)
block|{
name|softc
operator|->
name|ha_link
operator|=
name|param
expr_stmt|;
name|ctl_isc_ha_link_down
argument_list|(
name|softc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|softc
operator|->
name|ha_link
operator|=
name|param
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|ha_link
operator|==
name|CTL_HA_LINK_ONLINE
condition|)
name|ctl_isc_ha_link_up
argument_list|(
name|softc
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"ctl_isc_event_handler: Unknown event %d\n"
argument_list|,
name|event
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_copy_sense_data
parameter_list|(
name|union
name|ctl_ha_msg
modifier|*
name|src
parameter_list|,
name|union
name|ctl_io
modifier|*
name|dest
parameter_list|)
block|{
name|memcpy
argument_list|(
operator|&
name|dest
operator|->
name|scsiio
operator|.
name|sense_data
argument_list|,
operator|&
name|src
operator|->
name|scsi
operator|.
name|sense_data
argument_list|,
name|src
operator|->
name|scsi
operator|.
name|sense_len
argument_list|)
expr_stmt|;
name|dest
operator|->
name|scsiio
operator|.
name|scsi_status
operator|=
name|src
operator|->
name|scsi
operator|.
name|scsi_status
expr_stmt|;
name|dest
operator|->
name|scsiio
operator|.
name|sense_len
operator|=
name|src
operator|->
name|scsi
operator|.
name|sense_len
expr_stmt|;
name|dest
operator|->
name|io_hdr
operator|.
name|status
operator|=
name|src
operator|->
name|hdr
operator|.
name|status
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_copy_sense_data_back
parameter_list|(
name|union
name|ctl_io
modifier|*
name|src
parameter_list|,
name|union
name|ctl_ha_msg
modifier|*
name|dest
parameter_list|)
block|{
name|memcpy
argument_list|(
operator|&
name|dest
operator|->
name|scsi
operator|.
name|sense_data
argument_list|,
operator|&
name|src
operator|->
name|scsiio
operator|.
name|sense_data
argument_list|,
name|src
operator|->
name|scsiio
operator|.
name|sense_len
argument_list|)
expr_stmt|;
name|dest
operator|->
name|scsi
operator|.
name|scsi_status
operator|=
name|src
operator|->
name|scsiio
operator|.
name|scsi_status
expr_stmt|;
name|dest
operator|->
name|scsi
operator|.
name|sense_len
operator|=
name|src
operator|->
name|scsiio
operator|.
name|sense_len
expr_stmt|;
name|dest
operator|->
name|hdr
operator|.
name|status
operator|=
name|src
operator|->
name|io_hdr
operator|.
name|status
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ctl_est_ua
parameter_list|(
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|,
name|uint32_t
name|initidx
parameter_list|,
name|ctl_ua_type
name|ua
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|lun
operator|->
name|ctl_softc
decl_stmt|;
name|ctl_ua_type
modifier|*
name|pu
decl_stmt|;
if|if
condition|(
name|initidx
operator|<
name|softc
operator|->
name|init_min
operator|||
name|initidx
operator|>=
name|softc
operator|->
name|init_max
condition|)
return|return;
name|mtx_assert
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|pu
operator|=
name|lun
operator|->
name|pending_ua
index|[
name|initidx
operator|/
name|CTL_MAX_INIT_PER_PORT
index|]
expr_stmt|;
if|if
condition|(
name|pu
operator|==
name|NULL
condition|)
return|return;
name|pu
index|[
name|initidx
operator|%
name|CTL_MAX_INIT_PER_PORT
index|]
operator||=
name|ua
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ctl_est_ua_port
parameter_list|(
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|,
name|int
name|port
parameter_list|,
name|uint32_t
name|except
parameter_list|,
name|ctl_ua_type
name|ua
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|pending_ua
index|[
name|port
index|]
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_MAX_INIT_PER_PORT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|port
operator|*
name|CTL_MAX_INIT_PER_PORT
operator|+
name|i
operator|==
name|except
condition|)
continue|continue;
name|lun
operator|->
name|pending_ua
index|[
name|port
index|]
index|[
name|i
index|]
operator||=
name|ua
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ctl_est_ua_all
parameter_list|(
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|,
name|uint32_t
name|except
parameter_list|,
name|ctl_ua_type
name|ua
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|lun
operator|->
name|ctl_softc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|softc
operator|->
name|port_min
init|;
name|i
operator|<
name|softc
operator|->
name|port_max
condition|;
name|i
operator|++
control|)
name|ctl_est_ua_port
argument_list|(
name|lun
argument_list|,
name|i
argument_list|,
name|except
argument_list|,
name|ua
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ctl_clr_ua
parameter_list|(
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|,
name|uint32_t
name|initidx
parameter_list|,
name|ctl_ua_type
name|ua
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|lun
operator|->
name|ctl_softc
decl_stmt|;
name|ctl_ua_type
modifier|*
name|pu
decl_stmt|;
if|if
condition|(
name|initidx
operator|<
name|softc
operator|->
name|init_min
operator|||
name|initidx
operator|>=
name|softc
operator|->
name|init_max
condition|)
return|return;
name|mtx_assert
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|pu
operator|=
name|lun
operator|->
name|pending_ua
index|[
name|initidx
operator|/
name|CTL_MAX_INIT_PER_PORT
index|]
expr_stmt|;
if|if
condition|(
name|pu
operator|==
name|NULL
condition|)
return|return;
name|pu
index|[
name|initidx
operator|%
name|CTL_MAX_INIT_PER_PORT
index|]
operator|&=
operator|~
name|ua
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ctl_clr_ua_all
parameter_list|(
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|,
name|uint32_t
name|except
parameter_list|,
name|ctl_ua_type
name|ua
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|lun
operator|->
name|ctl_softc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|softc
operator|->
name|port_min
init|;
name|i
operator|<
name|softc
operator|->
name|port_max
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|lun
operator|->
name|pending_ua
index|[
name|i
index|]
operator|==
name|NULL
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|CTL_MAX_INIT_PER_PORT
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|*
name|CTL_MAX_INIT_PER_PORT
operator|+
name|j
operator|==
name|except
condition|)
continue|continue;
name|lun
operator|->
name|pending_ua
index|[
name|i
index|]
index|[
name|j
index|]
operator|&=
operator|~
name|ua
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|ctl_clr_ua_allluns
parameter_list|(
name|struct
name|ctl_softc
modifier|*
name|ctl_softc
parameter_list|,
name|uint32_t
name|initidx
parameter_list|,
name|ctl_ua_type
name|ua_type
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|ctl_softc
operator|->
name|ctl_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|lun
argument_list|,
argument|&ctl_softc->lun_list
argument_list|,
argument|links
argument_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctl_clr_ua
argument_list|(
name|lun
argument_list|,
name|initidx
argument_list|,
name|ua_type
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_ha_role_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
operator|(
expr|struct
name|ctl_softc
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|struct
name|ctl_lun_req
name|ireq
decl_stmt|;
name|int
name|error
decl_stmt|,
name|value
decl_stmt|;
name|value
operator|=
operator|(
name|softc
operator|->
name|flags
operator|&
name|CTL_FLAG_ACTIVE_SHELF
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|value
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|!=
literal|0
operator|)
operator|||
operator|(
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|softc
operator|->
name|flags
operator||=
name|CTL_FLAG_ACTIVE_SHELF
expr_stmt|;
else|else
name|softc
operator|->
name|flags
operator|&=
operator|~
name|CTL_FLAG_ACTIVE_SHELF
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|lun
argument_list|,
argument|&softc->lun_list
argument_list|,
argument|links
argument_list|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|ireq
argument_list|,
sizeof|sizeof
argument_list|(
name|ireq
argument_list|)
argument_list|)
expr_stmt|;
name|ireq
operator|.
name|reqtype
operator|=
name|CTL_LUNREQ_MODIFY
expr_stmt|;
name|ireq
operator|.
name|reqdata
operator|.
name|modify
operator|.
name|lun_id
operator|=
name|lun
operator|->
name|lun
expr_stmt|;
name|lun
operator|->
name|backend
operator|->
name|ioctl
argument_list|(
name|NULL
argument_list|,
name|CTL_LUN_REQ
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ireq
argument_list|,
literal|0
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|ireq
operator|.
name|status
operator|!=
name|CTL_LUN_OK
condition|)
block|{
name|printf
argument_list|(
literal|"%s: CTL_LUNREQ_MODIFY returned %d '%s'\n"
argument_list|,
name|__func__
argument_list|,
name|ireq
operator|.
name|status
argument_list|,
name|ireq
operator|.
name|error_str
argument_list|)
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_init
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|make_dev_args
name|args
decl_stmt|;
name|struct
name|ctl_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|softc
operator|=
name|control_softc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|control_softc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|make_dev_args_init
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
name|args
operator|.
name|mda_devsw
operator|=
operator|&
name|ctl_cdevsw
expr_stmt|;
name|args
operator|.
name|mda_uid
operator|=
name|UID_ROOT
expr_stmt|;
name|args
operator|.
name|mda_gid
operator|=
name|GID_OPERATOR
expr_stmt|;
name|args
operator|.
name|mda_mode
operator|=
literal|0600
expr_stmt|;
name|args
operator|.
name|mda_si_drv1
operator|=
name|softc
expr_stmt|;
name|error
operator|=
name|make_dev_s
argument_list|(
operator|&
name|args
argument_list|,
operator|&
name|softc
operator|->
name|dev
argument_list|,
literal|"cam/ctl"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|softc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|control_softc
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|sysctl_ctx_init
argument_list|(
operator|&
name|softc
operator|->
name|sysctl_ctx
argument_list|)
expr_stmt|;
name|softc
operator|->
name|sysctl_tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
operator|&
name|softc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_STATIC_CHILDREN
argument_list|(
name|_kern_cam
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ctl"
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"CAM Target Layer"
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|sysctl_tree
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unable to allocate sysctl tree\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|destroy_dev
argument_list|(
name|softc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|softc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|control_softc
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|mtx_init
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|,
literal|"CTL mutex"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|softc
operator|->
name|io_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"CTL IO"
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|ctl_io
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|softc
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"kern.cam.ctl.ha_mode"
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|&
name|softc
operator|->
name|ha_mode
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
operator|&
name|softc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|softc
operator|->
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ha_mode"
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|&
name|softc
operator|->
name|ha_mode
argument_list|,
literal|0
argument_list|,
literal|"HA mode (0 - act/stby, 1 - serialize only, 2 - xfer)"
argument_list|)
expr_stmt|;
comment|/* 	 * In Copan's HA scheme, the "master" and "slave" roles are 	 * figured out through the slot the controller is in.  Although it 	 * is an active/active system, someone has to be in charge. 	 */
name|TUNABLE_INT_FETCH
argument_list|(
literal|"kern.cam.ctl.ha_id"
argument_list|,
operator|&
name|softc
operator|->
name|ha_id
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
operator|&
name|softc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|softc
operator|->
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ha_id"
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|softc
operator|->
name|ha_id
argument_list|,
literal|0
argument_list|,
literal|"HA head ID (0 - no HA)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|ha_id
operator|==
literal|0
operator|||
name|softc
operator|->
name|ha_id
operator|>
name|NUM_HA_SHELVES
condition|)
block|{
name|softc
operator|->
name|flags
operator||=
name|CTL_FLAG_ACTIVE_SHELF
expr_stmt|;
name|softc
operator|->
name|is_single
operator|=
literal|1
expr_stmt|;
name|softc
operator|->
name|port_cnt
operator|=
name|CTL_MAX_PORTS
expr_stmt|;
name|softc
operator|->
name|port_min
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|softc
operator|->
name|port_cnt
operator|=
name|CTL_MAX_PORTS
operator|/
name|NUM_HA_SHELVES
expr_stmt|;
name|softc
operator|->
name|port_min
operator|=
operator|(
name|softc
operator|->
name|ha_id
operator|-
literal|1
operator|)
operator|*
name|softc
operator|->
name|port_cnt
expr_stmt|;
block|}
name|softc
operator|->
name|port_max
operator|=
name|softc
operator|->
name|port_min
operator|+
name|softc
operator|->
name|port_cnt
expr_stmt|;
name|softc
operator|->
name|init_min
operator|=
name|softc
operator|->
name|port_min
operator|*
name|CTL_MAX_INIT_PER_PORT
expr_stmt|;
name|softc
operator|->
name|init_max
operator|=
name|softc
operator|->
name|port_max
operator|*
name|CTL_MAX_INIT_PER_PORT
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
operator|&
name|softc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|softc
operator|->
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ha_link"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|&
name|softc
operator|->
name|ha_link
argument_list|,
literal|0
argument_list|,
literal|"HA link state (0 - offline, 1 - unknown, 2 - online)"
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|softc
operator|->
name|lun_list
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|softc
operator|->
name|pending_lun_queue
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|softc
operator|->
name|fe_list
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|softc
operator|->
name|port_list
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|softc
operator|->
name|be_list
argument_list|)
expr_stmt|;
name|ctl_tpc_init
argument_list|(
name|softc
argument_list|)
expr_stmt|;
if|if
condition|(
name|worker_threads
operator|<=
literal|0
condition|)
name|worker_threads
operator|=
name|max
argument_list|(
literal|1
argument_list|,
name|mp_ncpus
operator|/
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|worker_threads
operator|>
name|CTL_MAX_THREADS
condition|)
name|worker_threads
operator|=
name|CTL_MAX_THREADS
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|worker_threads
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ctl_thread
modifier|*
name|thr
init|=
operator|&
name|softc
operator|->
name|threads
index|[
name|i
index|]
decl_stmt|;
name|mtx_init
argument_list|(
operator|&
name|thr
operator|->
name|queue_lock
argument_list|,
literal|"CTL queue mutex"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|thr
operator|->
name|ctl_softc
operator|=
name|softc
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|thr
operator|->
name|incoming_queue
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|thr
operator|->
name|rtr_queue
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|thr
operator|->
name|done_queue
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|thr
operator|->
name|isc_queue
argument_list|)
expr_stmt|;
name|error
operator|=
name|kproc_kthread_add
argument_list|(
name|ctl_work_thread
argument_list|,
name|thr
argument_list|,
operator|&
name|softc
operator|->
name|ctl_proc
argument_list|,
operator|&
name|thr
operator|->
name|thread
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"ctl"
argument_list|,
literal|"work%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"error creating CTL work thread!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|error
operator|=
name|kproc_kthread_add
argument_list|(
name|ctl_lun_thread
argument_list|,
name|softc
argument_list|,
operator|&
name|softc
operator|->
name|ctl_proc
argument_list|,
operator|&
name|softc
operator|->
name|lun_thread
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"ctl"
argument_list|,
literal|"lun"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"error creating CTL lun thread!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|kproc_kthread_add
argument_list|(
name|ctl_thresh_thread
argument_list|,
name|softc
argument_list|,
operator|&
name|softc
operator|->
name|ctl_proc
argument_list|,
operator|&
name|softc
operator|->
name|thresh_thread
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"ctl"
argument_list|,
literal|"thresh"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"error creating CTL threshold thread!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|softc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|softc
operator|->
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ha_role"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RWTUN
argument_list|,
name|softc
argument_list|,
literal|0
argument_list|,
name|ctl_ha_role_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"HA role for this head"
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|is_single
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ctl_frontend_register
argument_list|(
operator|&
name|ha_frontend
argument_list|)
operator|!=
literal|0
condition|)
name|softc
operator|->
name|is_single
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_shutdown
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|control_softc
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|softc
operator|->
name|is_single
operator|==
literal|0
condition|)
name|ctl_frontend_deregister
argument_list|(
operator|&
name|ha_frontend
argument_list|)
expr_stmt|;
name|destroy_dev
argument_list|(
name|softc
operator|->
name|dev
argument_list|)
expr_stmt|;
comment|/* Shutdown CTL threads. */
name|softc
operator|->
name|shutdown
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|worker_threads
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ctl_thread
modifier|*
name|thr
init|=
operator|&
name|softc
operator|->
name|threads
index|[
name|i
index|]
decl_stmt|;
while|while
condition|(
name|thr
operator|->
name|thread
operator|!=
name|NULL
condition|)
block|{
name|wakeup
argument_list|(
name|thr
argument_list|)
expr_stmt|;
if|if
condition|(
name|thr
operator|->
name|thread
operator|!=
name|NULL
condition|)
name|pause
argument_list|(
literal|"CTL thr shutdown"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|mtx_destroy
argument_list|(
operator|&
name|thr
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|softc
operator|->
name|lun_thread
operator|!=
name|NULL
condition|)
block|{
name|wakeup
argument_list|(
operator|&
name|softc
operator|->
name|pending_lun_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|lun_thread
operator|!=
name|NULL
condition|)
name|pause
argument_list|(
literal|"CTL thr shutdown"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|softc
operator|->
name|thresh_thread
operator|!=
name|NULL
condition|)
block|{
name|wakeup
argument_list|(
name|softc
operator|->
name|thresh_thread
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|thresh_thread
operator|!=
name|NULL
condition|)
name|pause
argument_list|(
literal|"CTL thr shutdown"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|ctl_tpc_shutdown
argument_list|(
name|softc
argument_list|)
expr_stmt|;
name|uma_zdestroy
argument_list|(
name|softc
operator|->
name|io_zone
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|sysctl_ctx_free
argument_list|(
operator|&
name|softc
operator|->
name|sysctl_ctx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|softc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|control_softc
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_module_event_handler
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|MOD_LOAD
case|:
return|return
operator|(
name|ctl_init
argument_list|()
operator|)
return|;
case|case
name|MOD_UNLOAD
case|:
return|return
operator|(
name|ctl_shutdown
argument_list|()
operator|)
return|;
default|default:
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * XXX KDM should we do some access checks here?  Bump a reference count to  * prevent a CTL module from being unloaded while someone has it open?  */
end_comment

begin_function
specifier|static
name|int
name|ctl_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove an initiator by port number and initiator ID.  * Returns 0 for success, -1 for failure.  */
end_comment

begin_function
name|int
name|ctl_remove_initiator
parameter_list|(
name|struct
name|ctl_port
modifier|*
name|port
parameter_list|,
name|int
name|iid
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|port
operator|->
name|ctl_softc
decl_stmt|;
name|int
name|last
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|iid
operator|>
name|CTL_MAX_INIT_PER_PORT
condition|)
block|{
name|printf
argument_list|(
literal|"%s: initiator ID %u> maximun %u!\n"
argument_list|,
name|__func__
argument_list|,
name|iid
argument_list|,
name|CTL_MAX_INIT_PER_PORT
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|last
operator|=
operator|(
operator|--
name|port
operator|->
name|wwpn_iid
index|[
name|iid
index|]
operator|.
name|in_use
operator|==
literal|0
operator|)
expr_stmt|;
name|port
operator|->
name|wwpn_iid
index|[
name|iid
index|]
operator|.
name|last_use
operator|=
name|time_uptime
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
condition|)
name|ctl_i_t_nexus_loss
argument_list|(
name|softc
argument_list|,
name|iid
argument_list|,
name|CTL_UA_POWERON
argument_list|)
expr_stmt|;
name|ctl_isc_announce_iid
argument_list|(
name|port
argument_list|,
name|iid
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add an initiator to the initiator map.  * Returns iid for success,< 0 for failure.  */
end_comment

begin_function
name|int
name|ctl_add_initiator
parameter_list|(
name|struct
name|ctl_port
modifier|*
name|port
parameter_list|,
name|int
name|iid
parameter_list|,
name|uint64_t
name|wwpn
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|port
operator|->
name|ctl_softc
decl_stmt|;
name|time_t
name|best_time
decl_stmt|;
name|int
name|i
decl_stmt|,
name|best
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|iid
operator|>=
name|CTL_MAX_INIT_PER_PORT
condition|)
block|{
name|printf
argument_list|(
literal|"%s: WWPN %#jx initiator ID %u> maximum %u!\n"
argument_list|,
name|__func__
argument_list|,
name|wwpn
argument_list|,
name|iid
argument_list|,
name|CTL_MAX_INIT_PER_PORT
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|iid
operator|<
literal|0
operator|&&
operator|(
name|wwpn
operator|!=
literal|0
operator|||
name|name
operator|!=
name|NULL
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_MAX_INIT_PER_PORT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|wwpn
operator|!=
literal|0
operator|&&
name|wwpn
operator|==
name|port
operator|->
name|wwpn_iid
index|[
name|i
index|]
operator|.
name|wwpn
condition|)
block|{
name|iid
operator|=
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|name
operator|!=
name|NULL
operator|&&
name|port
operator|->
name|wwpn_iid
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|port
operator|->
name|wwpn_iid
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|iid
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|iid
operator|<
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_MAX_INIT_PER_PORT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|port
operator|->
name|wwpn_iid
index|[
name|i
index|]
operator|.
name|in_use
operator|==
literal|0
operator|&&
name|port
operator|->
name|wwpn_iid
index|[
name|i
index|]
operator|.
name|wwpn
operator|==
literal|0
operator|&&
name|port
operator|->
name|wwpn_iid
index|[
name|i
index|]
operator|.
name|name
operator|==
name|NULL
condition|)
block|{
name|iid
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|iid
operator|<
literal|0
condition|)
block|{
name|best
operator|=
operator|-
literal|1
expr_stmt|;
name|best_time
operator|=
name|INT32_MAX
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_MAX_INIT_PER_PORT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|port
operator|->
name|wwpn_iid
index|[
name|i
index|]
operator|.
name|in_use
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|port
operator|->
name|wwpn_iid
index|[
name|i
index|]
operator|.
name|last_use
operator|<
name|best_time
condition|)
block|{
name|best
operator|=
name|i
expr_stmt|;
name|best_time
operator|=
name|port
operator|->
name|wwpn_iid
index|[
name|i
index|]
operator|.
name|last_use
expr_stmt|;
block|}
block|}
block|}
name|iid
operator|=
name|best
expr_stmt|;
block|}
if|if
condition|(
name|iid
operator|<
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
if|if
condition|(
name|port
operator|->
name|wwpn_iid
index|[
name|iid
index|]
operator|.
name|in_use
operator|>
literal|0
operator|&&
operator|(
name|wwpn
operator|!=
literal|0
operator|||
name|name
operator|!=
name|NULL
operator|)
condition|)
block|{
comment|/* 		 * This is not an error yet. 		 */
if|if
condition|(
name|wwpn
operator|!=
literal|0
operator|&&
name|wwpn
operator|==
name|port
operator|->
name|wwpn_iid
index|[
name|iid
index|]
operator|.
name|wwpn
condition|)
block|{
if|#
directive|if
literal|0
block|printf("%s: port %d iid %u WWPN %#jx arrived" 			    " again\n", __func__, port->targ_port, 			    iid, (uintmax_t)wwpn);
endif|#
directive|endif
goto|goto
name|take
goto|;
block|}
if|if
condition|(
name|name
operator|!=
name|NULL
operator|&&
name|port
operator|->
name|wwpn_iid
index|[
name|iid
index|]
operator|.
name|name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|port
operator|->
name|wwpn_iid
index|[
name|iid
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
literal|0
block|printf("%s: port %d iid %u name '%s' arrived" 			    " again\n", __func__, port->targ_port, 			    iid, name);
endif|#
directive|endif
goto|goto
name|take
goto|;
block|}
comment|/* 		 * This is an error, but what do we do about it?  The 		 * driver is telling us we have a new WWPN for this 		 * initiator ID, so we pretty much need to use it. 		 */
name|printf
argument_list|(
literal|"%s: port %d iid %u WWPN %#jx '%s' arrived,"
literal|" but WWPN %#jx '%s' is still at that address\n"
argument_list|,
name|__func__
argument_list|,
name|port
operator|->
name|targ_port
argument_list|,
name|iid
argument_list|,
name|wwpn
argument_list|,
name|name
argument_list|,
operator|(
name|uintmax_t
operator|)
name|port
operator|->
name|wwpn_iid
index|[
name|iid
index|]
operator|.
name|wwpn
argument_list|,
name|port
operator|->
name|wwpn_iid
index|[
name|iid
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
name|take
label|:
name|free
argument_list|(
name|port
operator|->
name|wwpn_iid
index|[
name|iid
index|]
operator|.
name|name
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|port
operator|->
name|wwpn_iid
index|[
name|iid
index|]
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|port
operator|->
name|wwpn_iid
index|[
name|iid
index|]
operator|.
name|wwpn
operator|=
name|wwpn
expr_stmt|;
name|port
operator|->
name|wwpn_iid
index|[
name|iid
index|]
operator|.
name|in_use
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|ctl_isc_announce_iid
argument_list|(
name|port
argument_list|,
name|iid
argument_list|)
expr_stmt|;
return|return
operator|(
name|iid
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_create_iid
parameter_list|(
name|struct
name|ctl_port
modifier|*
name|port
parameter_list|,
name|int
name|iid
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
switch|switch
condition|(
name|port
operator|->
name|port_type
condition|)
block|{
case|case
name|CTL_PORT_FC
case|:
block|{
name|struct
name|scsi_transportid_fcp
modifier|*
name|id
init|=
operator|(
expr|struct
name|scsi_transportid_fcp
operator|*
operator|)
name|buf
decl_stmt|;
if|if
condition|(
name|port
operator|->
name|wwpn_iid
index|[
name|iid
index|]
operator|.
name|wwpn
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|memset
argument_list|(
name|id
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|id
operator|->
name|format_protocol
operator|=
name|SCSI_PROTO_FC
expr_stmt|;
name|scsi_u64to8b
argument_list|(
name|port
operator|->
name|wwpn_iid
index|[
name|iid
index|]
operator|.
name|wwpn
argument_list|,
name|id
operator|->
name|n_port_name
argument_list|)
expr_stmt|;
return|return
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|id
argument_list|)
operator|)
return|;
block|}
case|case
name|CTL_PORT_ISCSI
case|:
block|{
name|struct
name|scsi_transportid_iscsi_port
modifier|*
name|id
init|=
operator|(
expr|struct
name|scsi_transportid_iscsi_port
operator|*
operator|)
name|buf
decl_stmt|;
if|if
condition|(
name|port
operator|->
name|wwpn_iid
index|[
name|iid
index|]
operator|.
name|name
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|memset
argument_list|(
name|id
argument_list|,
literal|0
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|id
operator|->
name|format_protocol
operator|=
name|SCSI_TRN_ISCSI_FORMAT_PORT
operator||
name|SCSI_PROTO_ISCSI
expr_stmt|;
name|len
operator|=
name|strlcpy
argument_list|(
name|id
operator|->
name|iscsi_name
argument_list|,
name|port
operator|->
name|wwpn_iid
index|[
name|iid
index|]
operator|.
name|name
argument_list|,
literal|252
argument_list|)
operator|+
literal|1
expr_stmt|;
name|len
operator|=
name|roundup2
argument_list|(
name|min
argument_list|(
name|len
argument_list|,
literal|252
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|len
argument_list|,
name|id
operator|->
name|additional_length
argument_list|)
expr_stmt|;
return|return
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|id
argument_list|)
operator|+
name|len
operator|)
return|;
block|}
case|case
name|CTL_PORT_SAS
case|:
block|{
name|struct
name|scsi_transportid_sas
modifier|*
name|id
init|=
operator|(
expr|struct
name|scsi_transportid_sas
operator|*
operator|)
name|buf
decl_stmt|;
if|if
condition|(
name|port
operator|->
name|wwpn_iid
index|[
name|iid
index|]
operator|.
name|wwpn
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|memset
argument_list|(
name|id
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|id
operator|->
name|format_protocol
operator|=
name|SCSI_PROTO_SAS
expr_stmt|;
name|scsi_u64to8b
argument_list|(
name|port
operator|->
name|wwpn_iid
index|[
name|iid
index|]
operator|.
name|wwpn
argument_list|,
name|id
operator|->
name|sas_address
argument_list|)
expr_stmt|;
return|return
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|id
argument_list|)
operator|)
return|;
block|}
default|default:
block|{
name|struct
name|scsi_transportid_spi
modifier|*
name|id
init|=
operator|(
expr|struct
name|scsi_transportid_spi
operator|*
operator|)
name|buf
decl_stmt|;
name|memset
argument_list|(
name|id
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|id
operator|->
name|format_protocol
operator|=
name|SCSI_PROTO_SPI
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|iid
argument_list|,
name|id
operator|->
name|scsi_addr
argument_list|)
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|port
operator|->
name|targ_port
argument_list|,
name|id
operator|->
name|rel_trgt_port_id
argument_list|)
expr_stmt|;
return|return
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|id
argument_list|)
operator|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Serialize a command that went down the "wrong" side, and so was sent to  * this controller for execution.  The logic is a little different than the  * standard case in ctl_scsiio_precheck().  Errors in this case need to get  * sent back to the other side, but in the success case, we execute the  * command on this side (XFER mode) or tell the other side to execute it  * (SER_ONLY mode).  */
end_comment

begin_function
specifier|static
name|void
name|ctl_serialize_other_sc_cmd
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|CTL_SOFTC
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|struct
name|ctl_port
modifier|*
name|port
init|=
name|CTL_PORT
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|union
name|ctl_ha_msg
name|msg_info
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
specifier|const
name|struct
name|ctl_cmd_entry
modifier|*
name|entry
decl_stmt|;
name|uint32_t
name|targ_lun
decl_stmt|;
name|targ_lun
operator|=
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_mapped_lun
expr_stmt|;
comment|/* Make sure that we know about this port. */
if|if
condition|(
name|port
operator|==
name|NULL
operator|||
operator|(
name|port
operator|->
name|status
operator|&
name|CTL_PORT_STATUS_ONLINE
operator|)
operator|==
literal|0
condition|)
block|{
name|ctl_set_internal_failure
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|0
argument_list|,
comment|/*retry_count*/
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|badjuju
goto|;
block|}
comment|/* Make sure that we know about this LUN. */
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|targ_lun
operator|>=
name|CTL_MAX_LUNS
operator|||
operator|(
name|lun
operator|=
name|softc
operator|->
name|ctl_luns
index|[
name|targ_lun
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
comment|/* 		 * The other node would not send this request to us unless 		 * received announce that we are primary node for this LUN. 		 * If this LUN does not exist now, it is probably result of 		 * a race, so respond to initiator in the most opaque way. 		 */
name|ctl_set_busy
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
goto|goto
name|badjuju
goto|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
comment|/* 	 * If the LUN is invalid, pretend that it doesn't exist. 	 * It will go away as soon as all pending I/Os completed. 	 */
if|if
condition|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_DISABLED
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctl_set_busy
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
goto|goto
name|badjuju
goto|;
block|}
name|entry
operator|=
name|ctl_get_cmd_entry
argument_list|(
name|ctsio
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl_scsiio_lun_check
argument_list|(
name|lun
argument_list|,
name|entry
argument_list|,
name|ctsio
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
goto|goto
name|badjuju
goto|;
block|}
name|CTL_LUN
argument_list|(
name|ctsio
argument_list|)
operator|=
name|lun
expr_stmt|;
name|CTL_BACKEND_LUN
argument_list|(
name|ctsio
argument_list|)
operator|=
name|lun
operator|->
name|be_lun
expr_stmt|;
comment|/* 	 * Every I/O goes into the OOA queue for a 	 * particular LUN, and stays there until completion. 	 */
ifdef|#
directive|ifdef
name|CTL_TIME_IO
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|lun
operator|->
name|ooa_queue
argument_list|)
condition|)
name|lun
operator|->
name|idle_time
operator|+=
name|getsbinuptime
argument_list|()
operator|-
name|lun
operator|->
name|last_busy
expr_stmt|;
endif|#
directive|endif
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|lun
operator|->
name|ooa_queue
argument_list|,
operator|&
name|ctsio
operator|->
name|io_hdr
argument_list|,
name|ooa_links
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ctl_check_ooa
argument_list|(
name|lun
argument_list|,
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|,
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|TAILQ_PREV
argument_list|(
operator|&
name|ctsio
operator|->
name|io_hdr
argument_list|,
name|ctl_ooaq
argument_list|,
name|ooa_links
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|CTL_ACTION_BLOCK
case|:
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_BLOCKED
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|lun
operator|->
name|blocked_queue
argument_list|,
operator|&
name|ctsio
operator|->
name|io_hdr
argument_list|,
name|blocked_links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_ACTION_PASS
case|:
case|case
name|CTL_ACTION_SKIP
case|:
if|if
condition|(
name|softc
operator|->
name|ha_mode
operator|==
name|CTL_HA_MODE_XFER
condition|)
block|{
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_IS_WAS_ON_RTR
expr_stmt|;
name|ctl_enqueue_rtr
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator|&=
operator|~
name|CTL_FLAG_IO_ACTIVE
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
comment|/* send msg back to other side */
name|msg_info
operator|.
name|hdr
operator|.
name|original_sc
operator|=
name|ctsio
operator|->
name|io_hdr
operator|.
name|original_sc
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|serializing_sc
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_R2R
expr_stmt|;
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|msg_info
argument_list|,
sizeof|sizeof
argument_list|(
name|msg_info
operator|.
name|hdr
argument_list|)
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CTL_ACTION_OVERLAP
case|:
name|TAILQ_REMOVE
argument_list|(
operator|&
name|lun
operator|->
name|ooa_queue
argument_list|,
operator|&
name|ctsio
operator|->
name|io_hdr
argument_list|,
name|ooa_links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctl_set_overlapped_cmd
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
goto|goto
name|badjuju
goto|;
case|case
name|CTL_ACTION_OVERLAP_TAG
case|:
name|TAILQ_REMOVE
argument_list|(
operator|&
name|lun
operator|->
name|ooa_queue
argument_list|,
operator|&
name|ctsio
operator|->
name|io_hdr
argument_list|,
name|ooa_links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctl_set_overlapped_tag
argument_list|(
name|ctsio
argument_list|,
name|ctsio
operator|->
name|tag_num
argument_list|)
expr_stmt|;
goto|goto
name|badjuju
goto|;
case|case
name|CTL_ACTION_ERROR
case|:
default|default:
name|TAILQ_REMOVE
argument_list|(
operator|&
name|lun
operator|->
name|ooa_queue
argument_list|,
operator|&
name|ctsio
operator|->
name|io_hdr
argument_list|,
name|ooa_links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctl_set_internal_failure
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|0
argument_list|,
comment|/*retry_count*/
literal|0
argument_list|)
expr_stmt|;
name|badjuju
label|:
name|ctl_copy_sense_data_back
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|,
operator|&
name|msg_info
argument_list|)
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|original_sc
operator|=
name|ctsio
operator|->
name|io_hdr
operator|.
name|original_sc
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|serializing_sc
operator|=
name|NULL
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_BAD_JUJU
expr_stmt|;
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|msg_info
argument_list|,
sizeof|sizeof
argument_list|(
name|msg_info
operator|.
name|scsi
argument_list|)
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|ctl_free_io
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Returns 0 for success, errno for failure.  */
end_comment

begin_function
specifier|static
name|void
name|ctl_ioctl_fill_ooa
parameter_list|(
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|,
name|uint32_t
modifier|*
name|cur_fill_num
parameter_list|,
name|struct
name|ctl_ooa
modifier|*
name|ooa_hdr
parameter_list|,
name|struct
name|ctl_ooa_entry
modifier|*
name|kern_entries
parameter_list|)
block|{
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|TAILQ_FIRST
argument_list|(
operator|&
name|lun
operator|->
name|ooa_queue
argument_list|)
init|;
operator|(
name|io
operator|!=
name|NULL
operator|)
condition|;
operator|(
operator|*
name|cur_fill_num
operator|)
operator|++
operator|,
name|io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|TAILQ_NEXT
argument_list|(
operator|&
name|io
operator|->
name|io_hdr
argument_list|,
name|ooa_links
argument_list|)
control|)
block|{
name|struct
name|ctl_ooa_entry
modifier|*
name|entry
decl_stmt|;
comment|/* 		 * If we've got more than we can fit, just count the 		 * remaining entries. 		 */
if|if
condition|(
operator|*
name|cur_fill_num
operator|>=
name|ooa_hdr
operator|->
name|alloc_num
condition|)
continue|continue;
name|entry
operator|=
operator|&
name|kern_entries
index|[
operator|*
name|cur_fill_num
index|]
expr_stmt|;
name|entry
operator|->
name|tag_num
operator|=
name|io
operator|->
name|scsiio
operator|.
name|tag_num
expr_stmt|;
name|entry
operator|->
name|lun_num
operator|=
name|lun
operator|->
name|lun
expr_stmt|;
ifdef|#
directive|ifdef
name|CTL_TIME_IO
name|entry
operator|->
name|start_bt
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|start_bt
expr_stmt|;
endif|#
directive|endif
name|bcopy
argument_list|(
name|io
operator|->
name|scsiio
operator|.
name|cdb
argument_list|,
name|entry
operator|->
name|cdb
argument_list|,
name|io
operator|->
name|scsiio
operator|.
name|cdb_len
argument_list|)
expr_stmt|;
name|entry
operator|->
name|cdb_len
operator|=
name|io
operator|->
name|scsiio
operator|.
name|cdb_len
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_BLOCKED
condition|)
name|entry
operator|->
name|cmd_flags
operator||=
name|CTL_OOACMD_FLAG_BLOCKED
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_DMA_INPROG
condition|)
name|entry
operator|->
name|cmd_flags
operator||=
name|CTL_OOACMD_FLAG_DMA
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ABORT
condition|)
name|entry
operator|->
name|cmd_flags
operator||=
name|CTL_OOACMD_FLAG_ABORT
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_IS_WAS_ON_RTR
condition|)
name|entry
operator|->
name|cmd_flags
operator||=
name|CTL_OOACMD_FLAG_RTR
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_DMA_QUEUED
condition|)
name|entry
operator|->
name|cmd_flags
operator||=
name|CTL_OOACMD_FLAG_DMA_QUEUED
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|ctl_copyin_alloc
parameter_list|(
name|void
modifier|*
name|user_addr
parameter_list|,
name|int
name|len
parameter_list|,
name|char
modifier|*
name|error_str
parameter_list|,
name|size_t
name|error_str_len
parameter_list|)
block|{
name|void
modifier|*
name|kptr
decl_stmt|;
name|kptr
operator|=
name|malloc
argument_list|(
name|len
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyin
argument_list|(
name|user_addr
argument_list|,
name|kptr
argument_list|,
name|len
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|error_str
argument_list|,
name|error_str_len
argument_list|,
literal|"Error copying %d bytes "
literal|"from user address %p to kernel address %p"
argument_list|,
name|len
argument_list|,
name|user_addr
argument_list|,
name|kptr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|kptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|kptr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_free_args
parameter_list|(
name|int
name|num_args
parameter_list|,
name|struct
name|ctl_be_arg
modifier|*
name|args
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|args
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_args
condition|;
name|i
operator|++
control|)
block|{
name|free
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|kname
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|kvalue
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|args
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ctl_be_arg
modifier|*
name|ctl_copyin_args
parameter_list|(
name|int
name|num_args
parameter_list|,
name|struct
name|ctl_be_arg
modifier|*
name|uargs
parameter_list|,
name|char
modifier|*
name|error_str
parameter_list|,
name|size_t
name|error_str_len
parameter_list|)
block|{
name|struct
name|ctl_be_arg
modifier|*
name|args
decl_stmt|;
name|int
name|i
decl_stmt|;
name|args
operator|=
name|ctl_copyin_alloc
argument_list|(
name|uargs
argument_list|,
name|num_args
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|args
argument_list|)
argument_list|,
name|error_str
argument_list|,
name|error_str_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|==
name|NULL
condition|)
goto|goto
name|bailout
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_args
condition|;
name|i
operator|++
control|)
block|{
name|args
index|[
name|i
index|]
operator|.
name|kname
operator|=
name|NULL
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|kvalue
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_args
condition|;
name|i
operator|++
control|)
block|{
name|uint8_t
modifier|*
name|tmpptr
decl_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|kname
operator|=
name|ctl_copyin_alloc
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|namelen
argument_list|,
name|error_str
argument_list|,
name|error_str_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|kname
operator|==
name|NULL
condition|)
goto|goto
name|bailout
goto|;
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|kname
index|[
name|args
index|[
name|i
index|]
operator|.
name|namelen
operator|-
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|snprintf
argument_list|(
name|error_str
argument_list|,
name|error_str_len
argument_list|,
literal|"Argument %d "
literal|"name is not NUL-terminated"
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|CTL_BEARG_RD
condition|)
block|{
name|tmpptr
operator|=
name|ctl_copyin_alloc
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|vallen
argument_list|,
name|error_str
argument_list|,
name|error_str_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpptr
operator|==
name|NULL
condition|)
goto|goto
name|bailout
goto|;
if|if
condition|(
operator|(
name|args
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|CTL_BEARG_ASCII
operator|)
operator|&&
operator|(
name|tmpptr
index|[
name|args
index|[
name|i
index|]
operator|.
name|vallen
operator|-
literal|1
index|]
operator|!=
literal|'\0'
operator|)
condition|)
block|{
name|snprintf
argument_list|(
name|error_str
argument_list|,
name|error_str_len
argument_list|,
literal|"Argument "
literal|"%d value is not NUL-terminated"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmpptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|args
index|[
name|i
index|]
operator|.
name|kvalue
operator|=
name|tmpptr
expr_stmt|;
block|}
else|else
block|{
name|args
index|[
name|i
index|]
operator|.
name|kvalue
operator|=
name|malloc
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|vallen
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|args
operator|)
return|;
name|bailout
label|:
name|ctl_free_args
argument_list|(
name|num_args
argument_list|,
name|args
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_copyout_args
parameter_list|(
name|int
name|num_args
parameter_list|,
name|struct
name|ctl_be_arg
modifier|*
name|args
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_args
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|CTL_BEARG_WR
condition|)
name|copyout
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|kvalue
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|vallen
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Escape characters that are illegal or not recommended in XML.  */
end_comment

begin_function
name|int
name|ctl_sbuf_printf_esc
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|char
modifier|*
name|str
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|char
modifier|*
name|end
init|=
name|str
operator|+
name|size
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
operator|*
name|str
operator|&&
name|str
operator|<
name|end
condition|;
name|str
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|str
condition|)
block|{
case|case
literal|'&'
case|:
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"&amp;"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"&gt;"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"&lt;"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|retval
operator|=
name|sbuf_putc
argument_list|(
name|sb
argument_list|,
operator|*
name|str
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_id_sbuf
parameter_list|(
name|struct
name|ctl_devid
modifier|*
name|id
parameter_list|,
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|)
block|{
name|struct
name|scsi_vpd_id_descriptor
modifier|*
name|desc
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|id
operator|==
name|NULL
operator|||
name|id
operator|->
name|len
operator|<
literal|4
condition|)
return|return;
name|desc
operator|=
operator|(
expr|struct
name|scsi_vpd_id_descriptor
operator|*
operator|)
name|id
operator|->
name|data
expr_stmt|;
switch|switch
condition|(
name|desc
operator|->
name|id_type
operator|&
name|SVPD_ID_TYPE_MASK
condition|)
block|{
case|case
name|SVPD_ID_TYPE_T10
case|:
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"t10."
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVPD_ID_TYPE_EUI64
case|:
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"eui."
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVPD_ID_TYPE_NAA
case|:
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"naa."
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVPD_ID_TYPE_SCSI_NAME
case|:
break|break;
block|}
switch|switch
condition|(
name|desc
operator|->
name|proto_codeset
operator|&
name|SVPD_ID_CODESET_MASK
condition|)
block|{
case|case
name|SVPD_ID_CODESET_BINARY
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|desc
operator|->
name|length
condition|;
name|i
operator|++
control|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%02x"
argument_list|,
name|desc
operator|->
name|identifier
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVPD_ID_CODESET_ASCII
case|:
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%.*s"
argument_list|,
operator|(
name|int
operator|)
name|desc
operator|->
name|length
argument_list|,
operator|(
name|char
operator|*
operator|)
name|desc
operator|->
name|identifier
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVPD_ID_CODESET_UTF8
case|:
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|desc
operator|->
name|identifier
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
name|struct
name|ctl_port
modifier|*
name|port
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|CTL_IO
case|:
name|retval
operator|=
name|ctl_ioctl_io
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|addr
argument_list|,
name|flag
argument_list|,
name|td
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_ENABLE_PORT
case|:
case|case
name|CTL_DISABLE_PORT
case|:
case|case
name|CTL_SET_PORT_WWNS
case|:
block|{
name|struct
name|ctl_port
modifier|*
name|port
decl_stmt|;
name|struct
name|ctl_port_entry
modifier|*
name|entry
decl_stmt|;
name|entry
operator|=
operator|(
expr|struct
name|ctl_port_entry
operator|*
operator|)
name|addr
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|port
argument_list|,
argument|&softc->port_list
argument_list|,
argument|links
argument_list|)
block|{
name|int
name|action
decl_stmt|,
name|done
decl_stmt|;
if|if
condition|(
name|port
operator|->
name|targ_port
operator|<
name|softc
operator|->
name|port_min
operator|||
name|port
operator|->
name|targ_port
operator|>=
name|softc
operator|->
name|port_max
condition|)
continue|continue;
name|action
operator|=
literal|0
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|entry
operator|->
name|port_type
operator|==
name|CTL_PORT_NONE
operator|)
operator|&&
operator|(
name|entry
operator|->
name|targ_port
operator|==
name|port
operator|->
name|targ_port
operator|)
condition|)
block|{
comment|/* 				 * If the user only wants to enable or 				 * disable or set WWNs on a specific port, 				 * do the operation and we're done. 				 */
name|action
operator|=
literal|1
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|->
name|port_type
operator|&
name|port
operator|->
name|port_type
condition|)
block|{
comment|/* 				 * Compare the user's type mask with the 				 * particular frontend type to see if we 				 * have a match. 				 */
name|action
operator|=
literal|1
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
comment|/* 				 * Make sure the user isn't trying to set 				 * WWNs on multiple ports at the same time. 				 */
if|if
condition|(
name|cmd
operator|==
name|CTL_SET_PORT_WWNS
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Can't set WWNs on "
literal|"multiple ports\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|retval
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|action
operator|==
literal|0
condition|)
continue|continue;
comment|/* 			 * XXX KDM we have to drop the lock here, because 			 * the online/offline operations can potentially 			 * block.  We need to reference count the frontends 			 * so they can't go away, 			 */
if|if
condition|(
name|cmd
operator|==
name|CTL_ENABLE_PORT
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|ctl_port_online
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|==
name|CTL_DISABLE_PORT
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|ctl_port_offline
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|==
name|CTL_SET_PORT_WWNS
condition|)
block|{
name|ctl_port_set_wwns
argument_list|(
name|port
argument_list|,
operator|(
name|entry
operator|->
name|flags
operator|&
name|CTL_PORT_WWNN_VALID
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|,
name|entry
operator|->
name|wwnn
argument_list|,
operator|(
name|entry
operator|->
name|flags
operator|&
name|CTL_PORT_WWPN_VALID
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|,
name|entry
operator|->
name|wwpn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|done
operator|!=
literal|0
condition|)
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CTL_GET_OOA
case|:
block|{
name|struct
name|ctl_ooa
modifier|*
name|ooa_hdr
decl_stmt|;
name|struct
name|ctl_ooa_entry
modifier|*
name|entries
decl_stmt|;
name|uint32_t
name|cur_fill_num
decl_stmt|;
name|ooa_hdr
operator|=
operator|(
expr|struct
name|ctl_ooa
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
operator|(
name|ooa_hdr
operator|->
name|alloc_len
operator|==
literal|0
operator|)
operator|||
operator|(
name|ooa_hdr
operator|->
name|alloc_num
operator|==
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: CTL_GET_OOA: alloc len %u and alloc num %u "
literal|"must be non-zero\n"
argument_list|,
name|__func__
argument_list|,
name|ooa_hdr
operator|->
name|alloc_len
argument_list|,
name|ooa_hdr
operator|->
name|alloc_num
argument_list|)
expr_stmt|;
name|retval
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ooa_hdr
operator|->
name|alloc_len
operator|!=
operator|(
name|ooa_hdr
operator|->
name|alloc_num
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ctl_ooa_entry
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: CTL_GET_OOA: alloc len %u must be alloc "
literal|"num %d * sizeof(struct ctl_ooa_entry) %zd\n"
argument_list|,
name|__func__
argument_list|,
name|ooa_hdr
operator|->
name|alloc_len
argument_list|,
name|ooa_hdr
operator|->
name|alloc_num
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ctl_ooa_entry
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|entries
operator|=
name|malloc
argument_list|(
name|ooa_hdr
operator|->
name|alloc_len
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|entries
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: could not allocate %d bytes for OOA "
literal|"dump\n"
argument_list|,
name|__func__
argument_list|,
name|ooa_hdr
operator|->
name|alloc_len
argument_list|)
expr_stmt|;
name|retval
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ooa_hdr
operator|->
name|flags
operator|&
name|CTL_OOA_FLAG_ALL_LUNS
operator|)
operator|==
literal|0
operator|&&
operator|(
name|ooa_hdr
operator|->
name|lun_num
operator|>=
name|CTL_MAX_LUNS
operator|||
name|softc
operator|->
name|ctl_luns
index|[
name|ooa_hdr
operator|->
name|lun_num
index|]
operator|==
name|NULL
operator|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|entries
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: CTL_GET_OOA: invalid LUN %ju\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ooa_hdr
operator|->
name|lun_num
argument_list|)
expr_stmt|;
name|retval
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|cur_fill_num
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ooa_hdr
operator|->
name|flags
operator|&
name|CTL_OOA_FLAG_ALL_LUNS
condition|)
block|{
name|STAILQ_FOREACH
argument_list|(
argument|lun
argument_list|,
argument|&softc->lun_list
argument_list|,
argument|links
argument_list|)
block|{
name|ctl_ioctl_fill_ooa
argument_list|(
name|lun
argument_list|,
operator|&
name|cur_fill_num
argument_list|,
name|ooa_hdr
argument_list|,
name|entries
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|lun
operator|=
name|softc
operator|->
name|ctl_luns
index|[
name|ooa_hdr
operator|->
name|lun_num
index|]
expr_stmt|;
name|ctl_ioctl_fill_ooa
argument_list|(
name|lun
argument_list|,
operator|&
name|cur_fill_num
argument_list|,
name|ooa_hdr
argument_list|,
name|entries
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|ooa_hdr
operator|->
name|fill_num
operator|=
name|min
argument_list|(
name|cur_fill_num
argument_list|,
name|ooa_hdr
operator|->
name|alloc_num
argument_list|)
expr_stmt|;
name|ooa_hdr
operator|->
name|fill_len
operator|=
name|ooa_hdr
operator|->
name|fill_num
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ctl_ooa_entry
argument_list|)
expr_stmt|;
name|retval
operator|=
name|copyout
argument_list|(
name|entries
argument_list|,
name|ooa_hdr
operator|->
name|entries
argument_list|,
name|ooa_hdr
operator|->
name|fill_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: error copying out %d bytes for OOA dump\n"
argument_list|,
name|__func__
argument_list|,
name|ooa_hdr
operator|->
name|fill_len
argument_list|)
expr_stmt|;
block|}
name|getbinuptime
argument_list|(
operator|&
name|ooa_hdr
operator|->
name|cur_bt
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_fill_num
operator|>
name|ooa_hdr
operator|->
name|alloc_num
condition|)
block|{
name|ooa_hdr
operator|->
name|dropped_num
operator|=
name|cur_fill_num
operator|-
name|ooa_hdr
operator|->
name|alloc_num
expr_stmt|;
name|ooa_hdr
operator|->
name|status
operator|=
name|CTL_OOA_NEED_MORE_SPACE
expr_stmt|;
block|}
else|else
block|{
name|ooa_hdr
operator|->
name|dropped_num
operator|=
literal|0
expr_stmt|;
name|ooa_hdr
operator|->
name|status
operator|=
name|CTL_OOA_OK
expr_stmt|;
block|}
name|free
argument_list|(
name|entries
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CTL_DELAY_IO
case|:
block|{
name|struct
name|ctl_io_delay_info
modifier|*
name|delay_info
decl_stmt|;
name|delay_info
operator|=
operator|(
expr|struct
name|ctl_io_delay_info
operator|*
operator|)
name|addr
expr_stmt|;
ifdef|#
directive|ifdef
name|CTL_IO_DELAY
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|delay_info
operator|->
name|lun_id
operator|>=
name|CTL_MAX_LUNS
operator|||
operator|(
name|lun
operator|=
name|softc
operator|->
name|ctl_luns
index|[
name|delay_info
operator|->
name|lun_id
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|delay_info
operator|->
name|status
operator|=
name|CTL_DELAY_STATUS_INVALID_LUN
expr_stmt|;
break|break;
block|}
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|delay_info
operator|->
name|status
operator|=
name|CTL_DELAY_STATUS_OK
expr_stmt|;
switch|switch
condition|(
name|delay_info
operator|->
name|delay_type
condition|)
block|{
case|case
name|CTL_DELAY_TYPE_CONT
case|:
case|case
name|CTL_DELAY_TYPE_ONESHOT
case|:
break|break;
default|default:
name|delay_info
operator|->
name|status
operator|=
name|CTL_DELAY_STATUS_INVALID_TYPE
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|delay_info
operator|->
name|delay_loc
condition|)
block|{
case|case
name|CTL_DELAY_LOC_DATAMOVE
case|:
name|lun
operator|->
name|delay_info
operator|.
name|datamove_type
operator|=
name|delay_info
operator|->
name|delay_type
expr_stmt|;
name|lun
operator|->
name|delay_info
operator|.
name|datamove_delay
operator|=
name|delay_info
operator|->
name|delay_secs
expr_stmt|;
break|break;
case|case
name|CTL_DELAY_LOC_DONE
case|:
name|lun
operator|->
name|delay_info
operator|.
name|done_type
operator|=
name|delay_info
operator|->
name|delay_type
expr_stmt|;
name|lun
operator|->
name|delay_info
operator|.
name|done_delay
operator|=
name|delay_info
operator|->
name|delay_secs
expr_stmt|;
break|break;
default|default:
name|delay_info
operator|->
name|status
operator|=
name|CTL_DELAY_STATUS_INVALID_LOC
expr_stmt|;
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
else|#
directive|else
name|delay_info
operator|->
name|status
operator|=
name|CTL_DELAY_STATUS_NOT_IMPLEMENTED
expr_stmt|;
endif|#
directive|endif
comment|/* CTL_IO_DELAY */
break|break;
block|}
ifdef|#
directive|ifdef
name|CTL_LEGACY_STATS
case|case
name|CTL_GETSTATS
case|:
block|{
name|struct
name|ctl_stats
modifier|*
name|stats
init|=
operator|(
expr|struct
name|ctl_stats
operator|*
operator|)
name|addr
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 		 * XXX KDM no locking here.  If the LUN list changes, 		 * things can blow up. 		 */
name|i
operator|=
literal|0
expr_stmt|;
name|stats
operator|->
name|status
operator|=
name|CTL_SS_OK
expr_stmt|;
name|stats
operator|->
name|fill_len
operator|=
literal|0
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|lun
argument_list|,
argument|&softc->lun_list
argument_list|,
argument|links
argument_list|)
block|{
if|if
condition|(
name|stats
operator|->
name|fill_len
operator|+
sizeof|sizeof
argument_list|(
name|lun
operator|->
name|legacy_stats
argument_list|)
operator|>
name|stats
operator|->
name|alloc_len
condition|)
block|{
name|stats
operator|->
name|status
operator|=
name|CTL_SS_NEED_MORE_SPACE
expr_stmt|;
break|break;
block|}
name|retval
operator|=
name|copyout
argument_list|(
operator|&
name|lun
operator|->
name|legacy_stats
argument_list|,
operator|&
name|stats
operator|->
name|lun_stats
index|[
name|i
operator|++
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|lun
operator|->
name|legacy_stats
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
name|stats
operator|->
name|fill_len
operator|+=
sizeof|sizeof
argument_list|(
name|lun
operator|->
name|legacy_stats
argument_list|)
expr_stmt|;
block|}
name|stats
operator|->
name|num_luns
operator|=
name|softc
operator|->
name|num_luns
expr_stmt|;
name|stats
operator|->
name|flags
operator|=
name|CTL_STATS_FLAG_NONE
expr_stmt|;
ifdef|#
directive|ifdef
name|CTL_TIME_IO
name|stats
operator|->
name|flags
operator||=
name|CTL_STATS_FLAG_TIME_VALID
expr_stmt|;
endif|#
directive|endif
name|getnanouptime
argument_list|(
operator|&
name|stats
operator|->
name|timestamp
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* CTL_LEGACY_STATS */
case|case
name|CTL_ERROR_INJECT
case|:
block|{
name|struct
name|ctl_error_desc
modifier|*
name|err_desc
decl_stmt|,
modifier|*
name|new_err_desc
decl_stmt|;
name|err_desc
operator|=
operator|(
expr|struct
name|ctl_error_desc
operator|*
operator|)
name|addr
expr_stmt|;
name|new_err_desc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new_err_desc
argument_list|)
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|err_desc
argument_list|,
name|new_err_desc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_err_desc
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|err_desc
operator|->
name|lun_id
operator|>=
name|CTL_MAX_LUNS
operator|||
operator|(
name|lun
operator|=
name|softc
operator|->
name|ctl_luns
index|[
name|err_desc
operator|->
name|lun_id
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new_err_desc
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: CTL_ERROR_INJECT: invalid LUN %ju\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|uintmax_t
operator|)
name|err_desc
operator|->
name|lun_id
argument_list|)
expr_stmt|;
name|retval
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
comment|/* 		 * We could do some checking here to verify the validity 		 * of the request, but given the complexity of error 		 * injection requests, the checking logic would be fairly 		 * complex. 		 * 		 * For now, if the request is invalid, it just won't get 		 * executed and might get deleted. 		 */
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|lun
operator|->
name|error_list
argument_list|,
name|new_err_desc
argument_list|,
name|links
argument_list|)
expr_stmt|;
comment|/* 		 * XXX KDM check to make sure the serial number is unique, 		 * in case we somehow manage to wrap.  That shouldn't 		 * happen for a very long time, but it's the right thing to 		 * do. 		 */
name|new_err_desc
operator|->
name|serial
operator|=
name|lun
operator|->
name|error_serial
expr_stmt|;
name|err_desc
operator|->
name|serial
operator|=
name|lun
operator|->
name|error_serial
expr_stmt|;
name|lun
operator|->
name|error_serial
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CTL_ERROR_INJECT_DELETE
case|:
block|{
name|struct
name|ctl_error_desc
modifier|*
name|delete_desc
decl_stmt|,
modifier|*
name|desc
decl_stmt|,
modifier|*
name|desc2
decl_stmt|;
name|int
name|delete_done
decl_stmt|;
name|delete_desc
operator|=
operator|(
expr|struct
name|ctl_error_desc
operator|*
operator|)
name|addr
expr_stmt|;
name|delete_done
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|delete_desc
operator|->
name|lun_id
operator|>=
name|CTL_MAX_LUNS
operator|||
operator|(
name|lun
operator|=
name|softc
operator|->
name|ctl_luns
index|[
name|delete_desc
operator|->
name|lun_id
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: CTL_ERROR_INJECT_DELETE: invalid LUN %ju\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|uintmax_t
operator|)
name|delete_desc
operator|->
name|lun_id
argument_list|)
expr_stmt|;
name|retval
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|desc
argument_list|,
argument|&lun->error_list
argument_list|,
argument|links
argument_list|,
argument|desc2
argument_list|)
block|{
if|if
condition|(
name|desc
operator|->
name|serial
operator|!=
name|delete_desc
operator|->
name|serial
condition|)
continue|continue;
name|STAILQ_REMOVE
argument_list|(
operator|&
name|lun
operator|->
name|error_list
argument_list|,
name|desc
argument_list|,
name|ctl_error_desc
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|desc
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|delete_done
operator|=
literal|1
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|delete_done
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: CTL_ERROR_INJECT_DELETE: can't find "
literal|"error serial %ju on LUN %u\n"
argument_list|,
name|__func__
argument_list|,
name|delete_desc
operator|->
name|serial
argument_list|,
name|delete_desc
operator|->
name|lun_id
argument_list|)
expr_stmt|;
name|retval
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
break|break;
block|}
case|case
name|CTL_DUMP_STRUCTS
case|:
block|{
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
name|struct
name|ctl_port
modifier|*
name|port
decl_stmt|;
name|struct
name|ctl_frontend
modifier|*
name|fe
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"CTL Persistent Reservation information start:\n"
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|lun
argument_list|,
argument|&softc->lun_list
argument_list|,
argument|links
argument_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_DISABLED
operator|)
operator|!=
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|CTL_MAX_PORTS
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|lun
operator|->
name|pr_keys
index|[
name|j
index|]
operator|==
name|NULL
condition|)
continue|continue;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|CTL_MAX_INIT_PER_PORT
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|lun
operator|->
name|pr_keys
index|[
name|j
index|]
index|[
name|k
index|]
operator|==
literal|0
condition|)
continue|continue;
name|printf
argument_list|(
literal|"  LUN %ju port %d iid %d key "
literal|"%#jx\n"
argument_list|,
name|lun
operator|->
name|lun
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
operator|(
name|uintmax_t
operator|)
name|lun
operator|->
name|pr_keys
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"CTL Persistent Reservation information end\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"CTL Ports:\n"
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|port
argument_list|,
argument|&softc->port_list
argument_list|,
argument|links
argument_list|)
block|{
name|printf
argument_list|(
literal|"  Port %d '%s' Frontend '%s' Type %u pp %d vp %d WWNN "
literal|"%#jx WWPN %#jx\n"
argument_list|,
name|port
operator|->
name|targ_port
argument_list|,
name|port
operator|->
name|port_name
argument_list|,
name|port
operator|->
name|frontend
operator|->
name|name
argument_list|,
name|port
operator|->
name|port_type
argument_list|,
name|port
operator|->
name|physical_port
argument_list|,
name|port
operator|->
name|virtual_port
argument_list|,
operator|(
name|uintmax_t
operator|)
name|port
operator|->
name|wwnn
argument_list|,
operator|(
name|uintmax_t
operator|)
name|port
operator|->
name|wwpn
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|CTL_MAX_INIT_PER_PORT
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|port
operator|->
name|wwpn_iid
index|[
name|j
index|]
operator|.
name|in_use
operator|==
literal|0
operator|&&
name|port
operator|->
name|wwpn_iid
index|[
name|j
index|]
operator|.
name|wwpn
operator|==
literal|0
operator|&&
name|port
operator|->
name|wwpn_iid
index|[
name|j
index|]
operator|.
name|name
operator|==
name|NULL
condition|)
continue|continue;
name|printf
argument_list|(
literal|"    iid %u use %d WWPN %#jx '%s'\n"
argument_list|,
name|j
argument_list|,
name|port
operator|->
name|wwpn_iid
index|[
name|j
index|]
operator|.
name|in_use
argument_list|,
operator|(
name|uintmax_t
operator|)
name|port
operator|->
name|wwpn_iid
index|[
name|j
index|]
operator|.
name|wwpn
argument_list|,
name|port
operator|->
name|wwpn_iid
index|[
name|j
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"CTL Port information end\n"
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
comment|/* 		 * XXX KDM calling this without a lock.  We'd likely want 		 * to drop the lock before calling the frontend's dump 		 * routine anyway. 		 */
name|printf
argument_list|(
literal|"CTL Frontends:\n"
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|fe
argument_list|,
argument|&softc->fe_list
argument_list|,
argument|links
argument_list|)
block|{
name|printf
argument_list|(
literal|"  Frontend '%s'\n"
argument_list|,
name|fe
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|fe
operator|->
name|fe_dump
operator|!=
name|NULL
condition|)
name|fe
operator|->
name|fe_dump
argument_list|()
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"CTL Frontend information end\n"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CTL_LUN_REQ
case|:
block|{
name|struct
name|ctl_lun_req
modifier|*
name|lun_req
decl_stmt|;
name|struct
name|ctl_backend_driver
modifier|*
name|backend
decl_stmt|;
name|lun_req
operator|=
operator|(
expr|struct
name|ctl_lun_req
operator|*
operator|)
name|addr
expr_stmt|;
name|backend
operator|=
name|ctl_backend_find
argument_list|(
name|lun_req
operator|->
name|backend
argument_list|)
expr_stmt|;
if|if
condition|(
name|backend
operator|==
name|NULL
condition|)
block|{
name|lun_req
operator|->
name|status
operator|=
name|CTL_LUN_ERROR
expr_stmt|;
name|snprintf
argument_list|(
name|lun_req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|lun_req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"Backend \"%s\" not found."
argument_list|,
name|lun_req
operator|->
name|backend
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|lun_req
operator|->
name|num_be_args
operator|>
literal|0
condition|)
block|{
name|lun_req
operator|->
name|kern_be_args
operator|=
name|ctl_copyin_args
argument_list|(
name|lun_req
operator|->
name|num_be_args
argument_list|,
name|lun_req
operator|->
name|be_args
argument_list|,
name|lun_req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|lun_req
operator|->
name|error_str
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun_req
operator|->
name|kern_be_args
operator|==
name|NULL
condition|)
block|{
name|lun_req
operator|->
name|status
operator|=
name|CTL_LUN_ERROR
expr_stmt|;
break|break;
block|}
block|}
name|retval
operator|=
name|backend
operator|->
name|ioctl
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|addr
argument_list|,
name|flag
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun_req
operator|->
name|num_be_args
operator|>
literal|0
condition|)
block|{
name|ctl_copyout_args
argument_list|(
name|lun_req
operator|->
name|num_be_args
argument_list|,
name|lun_req
operator|->
name|kern_be_args
argument_list|)
expr_stmt|;
name|ctl_free_args
argument_list|(
name|lun_req
operator|->
name|num_be_args
argument_list|,
name|lun_req
operator|->
name|kern_be_args
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|CTL_LUN_LIST
case|:
block|{
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|struct
name|ctl_lun_list
modifier|*
name|list
decl_stmt|;
name|struct
name|ctl_option
modifier|*
name|opt
decl_stmt|;
name|list
operator|=
operator|(
expr|struct
name|ctl_lun_list
operator|*
operator|)
name|addr
expr_stmt|;
comment|/* 		 * Allocate a fixed length sbuf here, based on the length 		 * of the user's buffer.  We could allocate an auto-extending 		 * buffer, and then tell the user how much larger our 		 * amount of data is than his buffer, but that presents 		 * some problems: 		 * 		 * 1.  The sbuf(9) routines use a blocking malloc, and so 		 *     we can't hold a lock while calling them with an 		 *     auto-extending buffer.  		 * 		 * 2.  There is not currently a LUN reference counting 		 *     mechanism, outside of outstanding transactions on 		 *     the LUN's OOA queue.  So a LUN could go away on us 		 *     while we're getting the LUN number, backend-specific 		 *     information, etc.  Thus, given the way things 		 *     currently work, we need to hold the CTL lock while 		 *     grabbing LUN information. 		 * 		 * So, from the user's standpoint, the best thing to do is 		 * allocate what he thinks is a reasonable buffer length, 		 * and then if he gets a CTL_LUN_LIST_NEED_MORE_SPACE error, 		 * double the buffer length and try again.  (And repeat 		 * that until he succeeds.) 		 */
name|sb
operator|=
name|sbuf_new
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|list
operator|->
name|alloc_len
argument_list|,
name|SBUF_FIXEDLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
block|{
name|list
operator|->
name|status
operator|=
name|CTL_LUN_LIST_ERROR
expr_stmt|;
name|snprintf
argument_list|(
name|list
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|list
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"Unable to allocate %d bytes for LUN list"
argument_list|,
name|list
operator|->
name|alloc_len
argument_list|)
expr_stmt|;
break|break;
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"<ctllunlist>\n"
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|lun
argument_list|,
argument|&softc->lun_list
argument_list|,
argument|links
argument_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"<lun id=\"%ju\">\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|lun
operator|->
name|lun
argument_list|)
expr_stmt|;
comment|/* 			 * Bail out as soon as we see that we've overfilled 			 * the buffer. 			 */
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\t<backend_type>%s"
literal|"</backend_type>\n"
argument_list|,
operator|(
name|lun
operator|->
name|backend
operator|==
name|NULL
operator|)
condition|?
literal|"none"
else|:
name|lun
operator|->
name|backend
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\t<lun_type>%d</lun_type>\n"
argument_list|,
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|lun
operator|->
name|backend
operator|==
name|NULL
condition|)
block|{
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"</lun>\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
continue|continue;
block|}
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\t<size>%ju</size>\n"
argument_list|,
operator|(
name|lun
operator|->
name|be_lun
operator|->
name|maxlba
operator|>
literal|0
operator|)
condition|?
name|lun
operator|->
name|be_lun
operator|->
name|maxlba
operator|+
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\t<blocksize>%u</blocksize>\n"
argument_list|,
name|lun
operator|->
name|be_lun
operator|->
name|blocksize
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\t<serial_number>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
name|retval
operator|=
name|ctl_sbuf_printf_esc
argument_list|(
name|sb
argument_list|,
name|lun
operator|->
name|be_lun
operator|->
name|serial_num
argument_list|,
sizeof|sizeof
argument_list|(
name|lun
operator|->
name|be_lun
operator|->
name|serial_num
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"</serial_number>\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\t<device_id>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
name|retval
operator|=
name|ctl_sbuf_printf_esc
argument_list|(
name|sb
argument_list|,
name|lun
operator|->
name|be_lun
operator|->
name|device_id
argument_list|,
sizeof|sizeof
argument_list|(
name|lun
operator|->
name|be_lun
operator|->
name|device_id
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"</device_id>\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|lun
operator|->
name|backend
operator|->
name|lun_info
operator|!=
name|NULL
condition|)
block|{
name|retval
operator|=
name|lun
operator|->
name|backend
operator|->
name|lun_info
argument_list|(
name|lun
operator|->
name|be_lun
operator|->
name|be_lun
argument_list|,
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
block|}
name|STAILQ_FOREACH
argument_list|(
argument|opt
argument_list|,
argument|&lun->be_lun->options
argument_list|,
argument|links
argument_list|)
block|{
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\t<%s>%s</%s>\n"
argument_list|,
name|opt
operator|->
name|name
argument_list|,
name|opt
operator|->
name|value
argument_list|,
name|opt
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
block|}
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"</lun>\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lun
operator|!=
name|NULL
condition|)
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|retval
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"</ctllunlist>\n"
argument_list|)
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|retval
operator|=
literal|0
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|list
operator|->
name|status
operator|=
name|CTL_LUN_LIST_NEED_MORE_SPACE
expr_stmt|;
name|snprintf
argument_list|(
name|list
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|list
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"Out of space, %d bytes is too small"
argument_list|,
name|list
operator|->
name|alloc_len
argument_list|)
expr_stmt|;
break|break;
block|}
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|retval
operator|=
name|copyout
argument_list|(
name|sbuf_data
argument_list|(
name|sb
argument_list|)
argument_list|,
name|list
operator|->
name|lun_xml
argument_list|,
name|sbuf_len
argument_list|(
name|sb
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|list
operator|->
name|fill_len
operator|=
name|sbuf_len
argument_list|(
name|sb
argument_list|)
operator|+
literal|1
expr_stmt|;
name|list
operator|->
name|status
operator|=
name|CTL_LUN_LIST_OK
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CTL_ISCSI
case|:
block|{
name|struct
name|ctl_iscsi
modifier|*
name|ci
decl_stmt|;
name|struct
name|ctl_frontend
modifier|*
name|fe
decl_stmt|;
name|ci
operator|=
operator|(
expr|struct
name|ctl_iscsi
operator|*
operator|)
name|addr
expr_stmt|;
name|fe
operator|=
name|ctl_frontend_find
argument_list|(
literal|"iscsi"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fe
operator|==
name|NULL
condition|)
block|{
name|ci
operator|->
name|status
operator|=
name|CTL_ISCSI_ERROR
expr_stmt|;
name|snprintf
argument_list|(
name|ci
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|ci
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"Frontend \"iscsi\" not found."
argument_list|)
expr_stmt|;
break|break;
block|}
name|retval
operator|=
name|fe
operator|->
name|ioctl
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|addr
argument_list|,
name|flag
argument_list|,
name|td
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CTL_PORT_REQ
case|:
block|{
name|struct
name|ctl_req
modifier|*
name|req
decl_stmt|;
name|struct
name|ctl_frontend
modifier|*
name|fe
decl_stmt|;
name|req
operator|=
operator|(
expr|struct
name|ctl_req
operator|*
operator|)
name|addr
expr_stmt|;
name|fe
operator|=
name|ctl_frontend_find
argument_list|(
name|req
operator|->
name|driver
argument_list|)
expr_stmt|;
if|if
condition|(
name|fe
operator|==
name|NULL
condition|)
block|{
name|req
operator|->
name|status
operator|=
name|CTL_LUN_ERROR
expr_stmt|;
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"Frontend \"%s\" not found."
argument_list|,
name|req
operator|->
name|driver
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|req
operator|->
name|num_args
operator|>
literal|0
condition|)
block|{
name|req
operator|->
name|kern_args
operator|=
name|ctl_copyin_args
argument_list|(
name|req
operator|->
name|num_args
argument_list|,
name|req
operator|->
name|args
argument_list|,
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|kern_args
operator|==
name|NULL
condition|)
block|{
name|req
operator|->
name|status
operator|=
name|CTL_LUN_ERROR
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|fe
operator|->
name|ioctl
condition|)
name|retval
operator|=
name|fe
operator|->
name|ioctl
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|addr
argument_list|,
name|flag
argument_list|,
name|td
argument_list|)
expr_stmt|;
else|else
name|retval
operator|=
name|ENODEV
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|num_args
operator|>
literal|0
condition|)
block|{
name|ctl_copyout_args
argument_list|(
name|req
operator|->
name|num_args
argument_list|,
name|req
operator|->
name|kern_args
argument_list|)
expr_stmt|;
name|ctl_free_args
argument_list|(
name|req
operator|->
name|num_args
argument_list|,
name|req
operator|->
name|kern_args
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|CTL_PORT_LIST
case|:
block|{
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|struct
name|ctl_port
modifier|*
name|port
decl_stmt|;
name|struct
name|ctl_lun_list
modifier|*
name|list
decl_stmt|;
name|struct
name|ctl_option
modifier|*
name|opt
decl_stmt|;
name|int
name|j
decl_stmt|;
name|uint32_t
name|plun
decl_stmt|;
name|list
operator|=
operator|(
expr|struct
name|ctl_lun_list
operator|*
operator|)
name|addr
expr_stmt|;
name|sb
operator|=
name|sbuf_new
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|list
operator|->
name|alloc_len
argument_list|,
name|SBUF_FIXEDLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
block|{
name|list
operator|->
name|status
operator|=
name|CTL_LUN_LIST_ERROR
expr_stmt|;
name|snprintf
argument_list|(
name|list
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|list
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"Unable to allocate %d bytes for LUN list"
argument_list|,
name|list
operator|->
name|alloc_len
argument_list|)
expr_stmt|;
break|break;
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"<ctlportlist>\n"
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|port
argument_list|,
argument|&softc->port_list
argument_list|,
argument|links
argument_list|)
block|{
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"<targ_port id=\"%ju\">\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|port
operator|->
name|targ_port
argument_list|)
expr_stmt|;
comment|/* 			 * Bail out as soon as we see that we've overfilled 			 * the buffer. 			 */
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\t<frontend_type>%s"
literal|"</frontend_type>\n"
argument_list|,
name|port
operator|->
name|frontend
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\t<port_type>%d</port_type>\n"
argument_list|,
name|port
operator|->
name|port_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\t<online>%s</online>\n"
argument_list|,
operator|(
name|port
operator|->
name|status
operator|&
name|CTL_PORT_STATUS_ONLINE
operator|)
condition|?
literal|"YES"
else|:
literal|"NO"
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\t<port_name>%s</port_name>\n"
argument_list|,
name|port
operator|->
name|port_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\t<physical_port>%d</physical_port>\n"
argument_list|,
name|port
operator|->
name|physical_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\t<virtual_port>%d</virtual_port>\n"
argument_list|,
name|port
operator|->
name|virtual_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|port
operator|->
name|target_devid
operator|!=
name|NULL
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\t<target>"
argument_list|)
expr_stmt|;
name|ctl_id_sbuf
argument_list|(
name|port
operator|->
name|target_devid
argument_list|,
name|sb
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"</target>\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|port
operator|->
name|port_devid
operator|!=
name|NULL
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\t<port>"
argument_list|)
expr_stmt|;
name|ctl_id_sbuf
argument_list|(
name|port
operator|->
name|port_devid
argument_list|,
name|sb
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"</port>\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|port
operator|->
name|port_info
operator|!=
name|NULL
condition|)
block|{
name|retval
operator|=
name|port
operator|->
name|port_info
argument_list|(
name|port
operator|->
name|onoff_arg
argument_list|,
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
block|}
name|STAILQ_FOREACH
argument_list|(
argument|opt
argument_list|,
argument|&port->options
argument_list|,
argument|links
argument_list|)
block|{
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\t<%s>%s</%s>\n"
argument_list|,
name|opt
operator|->
name|name
argument_list|,
name|opt
operator|->
name|value
argument_list|,
name|opt
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|port
operator|->
name|lun_map
operator|!=
name|NULL
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\t<lun_map>on</lun_map>\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|port
operator|->
name|lun_map_size
condition|;
name|j
operator|++
control|)
block|{
name|plun
operator|=
name|ctl_lun_map_from_port
argument_list|(
name|port
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|plun
operator|==
name|UINT32_MAX
condition|)
continue|continue;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\t<lun id=\"%u\">%u</lun>\n"
argument_list|,
name|j
argument_list|,
name|plun
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|CTL_MAX_INIT_PER_PORT
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|port
operator|->
name|wwpn_iid
index|[
name|j
index|]
operator|.
name|in_use
operator|==
literal|0
operator|||
operator|(
name|port
operator|->
name|wwpn_iid
index|[
name|j
index|]
operator|.
name|wwpn
operator|==
literal|0
operator|&&
name|port
operator|->
name|wwpn_iid
index|[
name|j
index|]
operator|.
name|name
operator|==
name|NULL
operator|)
condition|)
continue|continue;
if|if
condition|(
name|port
operator|->
name|wwpn_iid
index|[
name|j
index|]
operator|.
name|name
operator|!=
name|NULL
condition|)
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\t<initiator id=\"%u\">%s</initiator>\n"
argument_list|,
name|j
argument_list|,
name|port
operator|->
name|wwpn_iid
index|[
name|j
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
else|else
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\t<initiator id=\"%u\">naa.%08jx</initiator>\n"
argument_list|,
name|j
argument_list|,
name|port
operator|->
name|wwpn_iid
index|[
name|j
index|]
operator|.
name|wwpn
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"</targ_port>\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|retval
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"</ctlportlist>\n"
argument_list|)
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|retval
operator|=
literal|0
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|list
operator|->
name|status
operator|=
name|CTL_LUN_LIST_NEED_MORE_SPACE
expr_stmt|;
name|snprintf
argument_list|(
name|list
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|list
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"Out of space, %d bytes is too small"
argument_list|,
name|list
operator|->
name|alloc_len
argument_list|)
expr_stmt|;
break|break;
block|}
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|retval
operator|=
name|copyout
argument_list|(
name|sbuf_data
argument_list|(
name|sb
argument_list|)
argument_list|,
name|list
operator|->
name|lun_xml
argument_list|,
name|sbuf_len
argument_list|(
name|sb
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|list
operator|->
name|fill_len
operator|=
name|sbuf_len
argument_list|(
name|sb
argument_list|)
operator|+
literal|1
expr_stmt|;
name|list
operator|->
name|status
operator|=
name|CTL_LUN_LIST_OK
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CTL_LUN_MAP
case|:
block|{
name|struct
name|ctl_lun_map
modifier|*
name|lm
init|=
operator|(
expr|struct
name|ctl_lun_map
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|ctl_port
modifier|*
name|port
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|lm
operator|->
name|port
operator|<
name|softc
operator|->
name|port_min
operator|||
name|lm
operator|->
name|port
operator|>=
name|softc
operator|->
name|port_max
operator|||
operator|(
name|port
operator|=
name|softc
operator|->
name|ctl_ports
index|[
name|lm
operator|->
name|port
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|port
operator|->
name|status
operator|&
name|CTL_PORT_STATUS_ONLINE
condition|)
block|{
name|STAILQ_FOREACH
argument_list|(
argument|lun
argument_list|,
argument|&softc->lun_list
argument_list|,
argument|links
argument_list|)
block|{
if|if
condition|(
name|ctl_lun_map_to_port
argument_list|(
name|port
argument_list|,
name|lun
operator|->
name|lun
argument_list|)
operator|==
name|UINT32_MAX
condition|)
continue|continue;
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctl_est_ua_port
argument_list|(
name|lun
argument_list|,
name|lm
operator|->
name|port
argument_list|,
operator|-
literal|1
argument_list|,
name|CTL_UA_LUN_CHANGE
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
comment|// XXX: port_enable sleeps
if|if
condition|(
name|lm
operator|->
name|plun
operator|!=
name|UINT32_MAX
condition|)
block|{
if|if
condition|(
name|lm
operator|->
name|lun
operator|==
name|UINT32_MAX
condition|)
name|retval
operator|=
name|ctl_lun_map_unset
argument_list|(
name|port
argument_list|,
name|lm
operator|->
name|plun
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lm
operator|->
name|lun
operator|<
name|CTL_MAX_LUNS
operator|&&
name|softc
operator|->
name|ctl_luns
index|[
name|lm
operator|->
name|lun
index|]
operator|!=
name|NULL
condition|)
name|retval
operator|=
name|ctl_lun_map_set
argument_list|(
name|port
argument_list|,
name|lm
operator|->
name|plun
argument_list|,
name|lm
operator|->
name|lun
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|lm
operator|->
name|lun
operator|==
name|UINT32_MAX
condition|)
name|retval
operator|=
name|ctl_lun_map_deinit
argument_list|(
name|port
argument_list|)
expr_stmt|;
else|else
name|retval
operator|=
name|ctl_lun_map_init
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|port
operator|->
name|status
operator|&
name|CTL_PORT_STATUS_ONLINE
condition|)
name|ctl_isc_announce_port
argument_list|(
name|port
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CTL_GET_LUN_STATS
case|:
block|{
name|struct
name|ctl_get_io_stats
modifier|*
name|stats
init|=
operator|(
expr|struct
name|ctl_get_io_stats
operator|*
operator|)
name|addr
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 		 * XXX KDM no locking here.  If the LUN list changes, 		 * things can blow up. 		 */
name|i
operator|=
literal|0
expr_stmt|;
name|stats
operator|->
name|status
operator|=
name|CTL_SS_OK
expr_stmt|;
name|stats
operator|->
name|fill_len
operator|=
literal|0
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|lun
argument_list|,
argument|&softc->lun_list
argument_list|,
argument|links
argument_list|)
block|{
if|if
condition|(
name|lun
operator|->
name|lun
operator|<
name|stats
operator|->
name|first_item
condition|)
continue|continue;
if|if
condition|(
name|stats
operator|->
name|fill_len
operator|+
sizeof|sizeof
argument_list|(
name|lun
operator|->
name|stats
argument_list|)
operator|>
name|stats
operator|->
name|alloc_len
condition|)
block|{
name|stats
operator|->
name|status
operator|=
name|CTL_SS_NEED_MORE_SPACE
expr_stmt|;
break|break;
block|}
name|retval
operator|=
name|copyout
argument_list|(
operator|&
name|lun
operator|->
name|stats
argument_list|,
operator|&
name|stats
operator|->
name|stats
index|[
name|i
operator|++
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|lun
operator|->
name|stats
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
name|stats
operator|->
name|fill_len
operator|+=
sizeof|sizeof
argument_list|(
name|lun
operator|->
name|stats
argument_list|)
expr_stmt|;
block|}
name|stats
operator|->
name|num_items
operator|=
name|softc
operator|->
name|num_luns
expr_stmt|;
name|stats
operator|->
name|flags
operator|=
name|CTL_STATS_FLAG_NONE
expr_stmt|;
ifdef|#
directive|ifdef
name|CTL_TIME_IO
name|stats
operator|->
name|flags
operator||=
name|CTL_STATS_FLAG_TIME_VALID
expr_stmt|;
endif|#
directive|endif
name|getnanouptime
argument_list|(
operator|&
name|stats
operator|->
name|timestamp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CTL_GET_PORT_STATS
case|:
block|{
name|struct
name|ctl_get_io_stats
modifier|*
name|stats
init|=
operator|(
expr|struct
name|ctl_get_io_stats
operator|*
operator|)
name|addr
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 		 * XXX KDM no locking here.  If the LUN list changes, 		 * things can blow up. 		 */
name|i
operator|=
literal|0
expr_stmt|;
name|stats
operator|->
name|status
operator|=
name|CTL_SS_OK
expr_stmt|;
name|stats
operator|->
name|fill_len
operator|=
literal|0
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|port
argument_list|,
argument|&softc->port_list
argument_list|,
argument|links
argument_list|)
block|{
if|if
condition|(
name|port
operator|->
name|targ_port
operator|<
name|stats
operator|->
name|first_item
condition|)
continue|continue;
if|if
condition|(
name|stats
operator|->
name|fill_len
operator|+
sizeof|sizeof
argument_list|(
name|port
operator|->
name|stats
argument_list|)
operator|>
name|stats
operator|->
name|alloc_len
condition|)
block|{
name|stats
operator|->
name|status
operator|=
name|CTL_SS_NEED_MORE_SPACE
expr_stmt|;
break|break;
block|}
name|retval
operator|=
name|copyout
argument_list|(
operator|&
name|port
operator|->
name|stats
argument_list|,
operator|&
name|stats
operator|->
name|stats
index|[
name|i
operator|++
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|port
operator|->
name|stats
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
name|stats
operator|->
name|fill_len
operator|+=
sizeof|sizeof
argument_list|(
name|port
operator|->
name|stats
argument_list|)
expr_stmt|;
block|}
name|stats
operator|->
name|num_items
operator|=
name|softc
operator|->
name|num_ports
expr_stmt|;
name|stats
operator|->
name|flags
operator|=
name|CTL_STATS_FLAG_NONE
expr_stmt|;
ifdef|#
directive|ifdef
name|CTL_TIME_IO
name|stats
operator|->
name|flags
operator||=
name|CTL_STATS_FLAG_TIME_VALID
expr_stmt|;
endif|#
directive|endif
name|getnanouptime
argument_list|(
operator|&
name|stats
operator|->
name|timestamp
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
block|{
comment|/* XXX KDM should we fix this? */
if|#
directive|if
literal|0
block|struct ctl_backend_driver *backend; 		unsigned int type; 		int found;  		found = 0;
comment|/* 		 * We encode the backend type as the ioctl type for backend 		 * ioctls.  So parse it out here, and then search for a 		 * backend of this type. 		 */
block|type = _IOC_TYPE(cmd);  		STAILQ_FOREACH(backend,&softc->be_list, links) { 			if (backend->type == type) { 				found = 1; 				break; 			} 		} 		if (found == 0) { 			printf("ctl: unknown ioctl command %#lx or backend " 			       "%d\n", cmd, type); 			retval = EINVAL; 			break; 		} 		retval = backend->ioctl(dev, cmd, addr, flag, td);
endif|#
directive|endif
name|retval
operator|=
name|ENOTTY
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|ctl_get_initindex
parameter_list|(
name|struct
name|ctl_nexus
modifier|*
name|nexus
parameter_list|)
block|{
return|return
operator|(
name|nexus
operator|->
name|initid
operator|+
operator|(
name|nexus
operator|->
name|targ_port
operator|*
name|CTL_MAX_INIT_PER_PORT
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_lun_map_init
parameter_list|(
name|struct
name|ctl_port
modifier|*
name|port
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|port
operator|->
name|ctl_softc
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|int
name|size
init|=
name|ctl_lun_map_size
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
if|if
condition|(
name|port
operator|->
name|lun_map
operator|==
name|NULL
operator|||
name|port
operator|->
name|lun_map_size
operator|<
name|size
condition|)
block|{
name|port
operator|->
name|lun_map_size
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|port
operator|->
name|lun_map
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|port
operator|->
name|lun_map
operator|=
name|malloc
argument_list|(
name|size
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|M_CTL
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|port
operator|->
name|lun_map
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
name|port
operator|->
name|lun_map
index|[
name|i
index|]
operator|=
name|UINT32_MAX
expr_stmt|;
name|port
operator|->
name|lun_map_size
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|status
operator|&
name|CTL_PORT_STATUS_ONLINE
condition|)
block|{
if|if
condition|(
name|port
operator|->
name|lun_disable
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_FOREACH
argument_list|(
argument|lun
argument_list|,
argument|&softc->lun_list
argument_list|,
argument|links
argument_list|)
name|port
operator|->
name|lun_disable
argument_list|(
name|port
operator|->
name|targ_lun_arg
argument_list|,
name|lun
operator|->
name|lun
argument_list|)
expr_stmt|;
block|}
name|ctl_isc_announce_port
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_lun_map_deinit
parameter_list|(
name|struct
name|ctl_port
modifier|*
name|port
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|port
operator|->
name|ctl_softc
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
if|if
condition|(
name|port
operator|->
name|lun_map
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|port
operator|->
name|lun_map_size
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|port
operator|->
name|lun_map
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|port
operator|->
name|lun_map
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|status
operator|&
name|CTL_PORT_STATUS_ONLINE
condition|)
block|{
if|if
condition|(
name|port
operator|->
name|lun_enable
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_FOREACH
argument_list|(
argument|lun
argument_list|,
argument|&softc->lun_list
argument_list|,
argument|links
argument_list|)
name|port
operator|->
name|lun_enable
argument_list|(
name|port
operator|->
name|targ_lun_arg
argument_list|,
name|lun
operator|->
name|lun
argument_list|)
expr_stmt|;
block|}
name|ctl_isc_announce_port
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_lun_map_set
parameter_list|(
name|struct
name|ctl_port
modifier|*
name|port
parameter_list|,
name|uint32_t
name|plun
parameter_list|,
name|uint32_t
name|glun
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|uint32_t
name|old
decl_stmt|;
if|if
condition|(
name|port
operator|->
name|lun_map
operator|==
name|NULL
condition|)
block|{
name|status
operator|=
name|ctl_lun_map_init
argument_list|(
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return
operator|(
name|status
operator|)
return|;
block|}
if|if
condition|(
name|plun
operator|>=
name|port
operator|->
name|lun_map_size
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|old
operator|=
name|port
operator|->
name|lun_map
index|[
name|plun
index|]
expr_stmt|;
name|port
operator|->
name|lun_map
index|[
name|plun
index|]
operator|=
name|glun
expr_stmt|;
if|if
condition|(
operator|(
name|port
operator|->
name|status
operator|&
name|CTL_PORT_STATUS_ONLINE
operator|)
operator|&&
name|old
operator|==
name|UINT32_MAX
condition|)
block|{
if|if
condition|(
name|port
operator|->
name|lun_enable
operator|!=
name|NULL
condition|)
name|port
operator|->
name|lun_enable
argument_list|(
name|port
operator|->
name|targ_lun_arg
argument_list|,
name|plun
argument_list|)
expr_stmt|;
name|ctl_isc_announce_port
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_lun_map_unset
parameter_list|(
name|struct
name|ctl_port
modifier|*
name|port
parameter_list|,
name|uint32_t
name|plun
parameter_list|)
block|{
name|uint32_t
name|old
decl_stmt|;
if|if
condition|(
name|port
operator|->
name|lun_map
operator|==
name|NULL
operator|||
name|plun
operator|>=
name|port
operator|->
name|lun_map_size
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|old
operator|=
name|port
operator|->
name|lun_map
index|[
name|plun
index|]
expr_stmt|;
name|port
operator|->
name|lun_map
index|[
name|plun
index|]
operator|=
name|UINT32_MAX
expr_stmt|;
if|if
condition|(
operator|(
name|port
operator|->
name|status
operator|&
name|CTL_PORT_STATUS_ONLINE
operator|)
operator|&&
name|old
operator|!=
name|UINT32_MAX
condition|)
block|{
if|if
condition|(
name|port
operator|->
name|lun_disable
operator|!=
name|NULL
condition|)
name|port
operator|->
name|lun_disable
argument_list|(
name|port
operator|->
name|targ_lun_arg
argument_list|,
name|plun
argument_list|)
expr_stmt|;
name|ctl_isc_announce_port
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|ctl_lun_map_from_port
parameter_list|(
name|struct
name|ctl_port
modifier|*
name|port
parameter_list|,
name|uint32_t
name|lun_id
parameter_list|)
block|{
if|if
condition|(
name|port
operator|==
name|NULL
condition|)
return|return
operator|(
name|UINT32_MAX
operator|)
return|;
if|if
condition|(
name|port
operator|->
name|lun_map
operator|==
name|NULL
condition|)
return|return
operator|(
name|lun_id
operator|)
return|;
if|if
condition|(
name|lun_id
operator|>
name|port
operator|->
name|lun_map_size
condition|)
return|return
operator|(
name|UINT32_MAX
operator|)
return|;
return|return
operator|(
name|port
operator|->
name|lun_map
index|[
name|lun_id
index|]
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|ctl_lun_map_to_port
parameter_list|(
name|struct
name|ctl_port
modifier|*
name|port
parameter_list|,
name|uint32_t
name|lun_id
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
if|if
condition|(
name|port
operator|==
name|NULL
condition|)
return|return
operator|(
name|UINT32_MAX
operator|)
return|;
if|if
condition|(
name|port
operator|->
name|lun_map
operator|==
name|NULL
condition|)
return|return
operator|(
name|lun_id
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|port
operator|->
name|lun_map_size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|port
operator|->
name|lun_map
index|[
name|i
index|]
operator|==
name|lun_id
condition|)
return|return
operator|(
name|i
operator|)
return|;
block|}
return|return
operator|(
name|UINT32_MAX
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|ctl_decode_lun
parameter_list|(
name|uint64_t
name|encoded
parameter_list|)
block|{
name|uint8_t
name|lun
index|[
literal|8
index|]
decl_stmt|;
name|uint32_t
name|result
init|=
literal|0xffffffff
decl_stmt|;
name|be64enc
argument_list|(
name|lun
argument_list|,
name|encoded
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|lun
index|[
literal|0
index|]
operator|&
name|RPL_LUNDATA_ATYP_MASK
condition|)
block|{
case|case
name|RPL_LUNDATA_ATYP_PERIPH
case|:
if|if
condition|(
operator|(
name|lun
index|[
literal|0
index|]
operator|&
literal|0x3f
operator|)
operator|==
literal|0
operator|&&
name|lun
index|[
literal|2
index|]
operator|==
literal|0
operator|&&
name|lun
index|[
literal|3
index|]
operator|==
literal|0
operator|&&
name|lun
index|[
literal|4
index|]
operator|==
literal|0
operator|&&
name|lun
index|[
literal|5
index|]
operator|==
literal|0
operator|&&
name|lun
index|[
literal|6
index|]
operator|==
literal|0
operator|&&
name|lun
index|[
literal|7
index|]
operator|==
literal|0
condition|)
name|result
operator|=
name|lun
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|RPL_LUNDATA_ATYP_FLAT
case|:
if|if
condition|(
name|lun
index|[
literal|2
index|]
operator|==
literal|0
operator|&&
name|lun
index|[
literal|3
index|]
operator|==
literal|0
operator|&&
name|lun
index|[
literal|4
index|]
operator|==
literal|0
operator|&&
name|lun
index|[
literal|5
index|]
operator|==
literal|0
operator|&&
name|lun
index|[
literal|6
index|]
operator|==
literal|0
operator|&&
name|lun
index|[
literal|7
index|]
operator|==
literal|0
condition|)
name|result
operator|=
operator|(
operator|(
name|lun
index|[
literal|0
index|]
operator|&
literal|0x3f
operator|)
operator|<<
literal|8
operator|)
operator|+
name|lun
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|RPL_LUNDATA_ATYP_EXTLUN
case|:
switch|switch
condition|(
name|lun
index|[
literal|0
index|]
operator|&
name|RPL_LUNDATA_EXT_EAM_MASK
condition|)
block|{
case|case
literal|0x02
case|:
switch|switch
condition|(
name|lun
index|[
literal|0
index|]
operator|&
name|RPL_LUNDATA_EXT_LEN_MASK
condition|)
block|{
case|case
literal|0x00
case|:
name|result
operator|=
name|lun
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
literal|0x10
case|:
name|result
operator|=
operator|(
name|lun
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|lun
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator|+
name|lun
index|[
literal|3
index|]
expr_stmt|;
break|break;
case|case
literal|0x20
case|:
if|if
condition|(
name|lun
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|lun
index|[
literal|6
index|]
operator|==
literal|0
operator|&&
name|lun
index|[
literal|7
index|]
operator|==
literal|0
condition|)
name|result
operator|=
operator|(
name|lun
index|[
literal|2
index|]
operator|<<
literal|24
operator|)
operator|+
operator|(
name|lun
index|[
literal|3
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|lun
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator|+
name|lun
index|[
literal|5
index|]
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|RPL_LUNDATA_EXT_EAM_NOT_SPEC
case|:
name|result
operator|=
literal|0xffffffff
expr_stmt|;
break|break;
block|}
break|break;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|ctl_encode_lun
parameter_list|(
name|uint32_t
name|decoded
parameter_list|)
block|{
name|uint64_t
name|l
init|=
name|decoded
decl_stmt|;
if|if
condition|(
name|l
operator|<=
literal|0xff
condition|)
return|return
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|RPL_LUNDATA_ATYP_PERIPH
operator|<<
literal|56
operator|)
operator||
operator|(
name|l
operator|<<
literal|48
operator|)
operator|)
return|;
if|if
condition|(
name|l
operator|<=
literal|0x3fff
condition|)
return|return
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|RPL_LUNDATA_ATYP_FLAT
operator|<<
literal|56
operator|)
operator||
operator|(
name|l
operator|<<
literal|48
operator|)
operator|)
return|;
if|if
condition|(
name|l
operator|<=
literal|0xffffff
condition|)
return|return
operator|(
operator|(
call|(
name|uint64_t
call|)
argument_list|(
name|RPL_LUNDATA_ATYP_EXTLUN
operator||
literal|0x12
argument_list|)
operator|<<
literal|56
operator|)
operator||
operator|(
name|l
operator|<<
literal|32
operator|)
operator|)
return|;
return|return
operator|(
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|RPL_LUNDATA_ATYP_EXTLUN
operator||
literal|0x22
operator|)
operator|<<
literal|56
operator|)
operator||
operator|(
name|l
operator|<<
literal|16
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_ffz
parameter_list|(
name|uint32_t
modifier|*
name|mask
parameter_list|,
name|uint32_t
name|first
parameter_list|,
name|uint32_t
name|last
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|first
init|;
name|i
operator|<
name|last
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|mask
index|[
name|i
operator|/
literal|32
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|i
operator|%
literal|32
operator|)
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|i
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_set_mask
parameter_list|(
name|uint32_t
modifier|*
name|mask
parameter_list|,
name|uint32_t
name|bit
parameter_list|)
block|{
name|uint32_t
name|chunk
decl_stmt|,
name|piece
decl_stmt|;
name|chunk
operator|=
name|bit
operator|>>
literal|5
expr_stmt|;
name|piece
operator|=
name|bit
operator|%
operator|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
literal|8
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|mask
index|[
name|chunk
index|]
operator|&
operator|(
literal|1
operator|<<
name|piece
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|else
name|mask
index|[
name|chunk
index|]
operator||=
operator|(
literal|1
operator|<<
name|piece
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_clear_mask
parameter_list|(
name|uint32_t
modifier|*
name|mask
parameter_list|,
name|uint32_t
name|bit
parameter_list|)
block|{
name|uint32_t
name|chunk
decl_stmt|,
name|piece
decl_stmt|;
name|chunk
operator|=
name|bit
operator|>>
literal|5
expr_stmt|;
name|piece
operator|=
name|bit
operator|%
operator|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
literal|8
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|mask
index|[
name|chunk
index|]
operator|&
operator|(
literal|1
operator|<<
name|piece
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|else
name|mask
index|[
name|chunk
index|]
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|piece
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_is_set
parameter_list|(
name|uint32_t
modifier|*
name|mask
parameter_list|,
name|uint32_t
name|bit
parameter_list|)
block|{
name|uint32_t
name|chunk
decl_stmt|,
name|piece
decl_stmt|;
name|chunk
operator|=
name|bit
operator|>>
literal|5
expr_stmt|;
name|piece
operator|=
name|bit
operator|%
operator|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
literal|8
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|mask
index|[
name|chunk
index|]
operator|&
operator|(
literal|1
operator|<<
name|piece
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|ctl_get_prkey
parameter_list|(
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|,
name|uint32_t
name|residx
parameter_list|)
block|{
name|uint64_t
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|lun
operator|->
name|pr_keys
index|[
name|residx
operator|/
name|CTL_MAX_INIT_PER_PORT
index|]
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|t
index|[
name|residx
operator|%
name|CTL_MAX_INIT_PER_PORT
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_clr_prkey
parameter_list|(
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|,
name|uint32_t
name|residx
parameter_list|)
block|{
name|uint64_t
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|lun
operator|->
name|pr_keys
index|[
name|residx
operator|/
name|CTL_MAX_INIT_PER_PORT
index|]
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
return|return;
name|t
index|[
name|residx
operator|%
name|CTL_MAX_INIT_PER_PORT
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_alloc_prkey
parameter_list|(
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|,
name|uint32_t
name|residx
parameter_list|)
block|{
name|uint64_t
modifier|*
name|p
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|i
operator|=
name|residx
operator|/
name|CTL_MAX_INIT_PER_PORT
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|pr_keys
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
return|return;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|p
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|*
name|CTL_MAX_INIT_PER_PORT
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|pr_keys
index|[
name|i
index|]
operator|==
name|NULL
condition|)
name|lun
operator|->
name|pr_keys
index|[
name|i
index|]
operator|=
name|p
expr_stmt|;
else|else
name|free
argument_list|(
name|p
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_set_prkey
parameter_list|(
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|,
name|uint32_t
name|residx
parameter_list|,
name|uint64_t
name|key
parameter_list|)
block|{
name|uint64_t
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|lun
operator|->
name|pr_keys
index|[
name|residx
operator|/
name|CTL_MAX_INIT_PER_PORT
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|t
operator|!=
name|NULL
argument_list|,
operator|(
literal|"prkey %d is not allocated"
operator|,
name|residx
operator|)
argument_list|)
expr_stmt|;
name|t
index|[
name|residx
operator|%
name|CTL_MAX_INIT_PER_PORT
index|]
operator|=
name|key
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ctl_softc, pool_name, total_ctl_io are passed in.  * npool is passed out.  */
end_comment

begin_function
name|int
name|ctl_pool_create
parameter_list|(
name|struct
name|ctl_softc
modifier|*
name|ctl_softc
parameter_list|,
specifier|const
name|char
modifier|*
name|pool_name
parameter_list|,
name|uint32_t
name|total_ctl_io
parameter_list|,
name|void
modifier|*
modifier|*
name|npool
parameter_list|)
block|{
name|struct
name|ctl_io_pool
modifier|*
name|pool
decl_stmt|;
name|pool
operator|=
operator|(
expr|struct
name|ctl_io_pool
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pool
argument_list|)
argument_list|,
name|M_CTL
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|pool
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|snprintf
argument_list|(
name|pool
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|pool
operator|->
name|name
argument_list|)
argument_list|,
literal|"CTL IO %s"
argument_list|,
name|pool_name
argument_list|)
expr_stmt|;
name|pool
operator|->
name|ctl_softc
operator|=
name|ctl_softc
expr_stmt|;
ifdef|#
directive|ifdef
name|IO_POOLS
name|pool
operator|->
name|zone
operator|=
name|uma_zsecond_create
argument_list|(
name|pool
operator|->
name|name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ctl_softc
operator|->
name|io_zone
argument_list|)
expr_stmt|;
comment|/* uma_prealloc(pool->zone, total_ctl_io); */
else|#
directive|else
name|pool
operator|->
name|zone
operator|=
name|ctl_softc
operator|->
name|io_zone
expr_stmt|;
endif|#
directive|endif
operator|*
name|npool
operator|=
name|pool
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ctl_pool_free
parameter_list|(
name|struct
name|ctl_io_pool
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|pool
operator|==
name|NULL
condition|)
return|return;
ifdef|#
directive|ifdef
name|IO_POOLS
name|uma_zdestroy
argument_list|(
name|pool
operator|->
name|zone
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|pool
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|union
name|ctl_io
modifier|*
name|ctl_alloc_io
parameter_list|(
name|void
modifier|*
name|pool_ref
parameter_list|)
block|{
name|struct
name|ctl_io_pool
modifier|*
name|pool
init|=
operator|(
expr|struct
name|ctl_io_pool
operator|*
operator|)
name|pool_ref
decl_stmt|;
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|io
operator|=
name|uma_zalloc
argument_list|(
name|pool
operator|->
name|zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|!=
name|NULL
condition|)
block|{
name|io
operator|->
name|io_hdr
operator|.
name|pool
operator|=
name|pool_ref
expr_stmt|;
name|CTL_SOFTC
argument_list|(
name|io
argument_list|)
operator|=
name|pool
operator|->
name|ctl_softc
expr_stmt|;
block|}
return|return
operator|(
name|io
operator|)
return|;
block|}
end_function

begin_function
name|union
name|ctl_io
modifier|*
name|ctl_alloc_io_nowait
parameter_list|(
name|void
modifier|*
name|pool_ref
parameter_list|)
block|{
name|struct
name|ctl_io_pool
modifier|*
name|pool
init|=
operator|(
expr|struct
name|ctl_io_pool
operator|*
operator|)
name|pool_ref
decl_stmt|;
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|io
operator|=
name|uma_zalloc
argument_list|(
name|pool
operator|->
name|zone
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|!=
name|NULL
condition|)
block|{
name|io
operator|->
name|io_hdr
operator|.
name|pool
operator|=
name|pool_ref
expr_stmt|;
name|CTL_SOFTC
argument_list|(
name|io
argument_list|)
operator|=
name|pool
operator|->
name|ctl_softc
expr_stmt|;
block|}
return|return
operator|(
name|io
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ctl_free_io
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_io_pool
modifier|*
name|pool
decl_stmt|;
if|if
condition|(
name|io
operator|==
name|NULL
condition|)
return|return;
name|pool
operator|=
operator|(
expr|struct
name|ctl_io_pool
operator|*
operator|)
name|io
operator|->
name|io_hdr
operator|.
name|pool
expr_stmt|;
name|uma_zfree
argument_list|(
name|pool
operator|->
name|zone
argument_list|,
name|io
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ctl_zero_io
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_io_pool
modifier|*
name|pool
decl_stmt|;
if|if
condition|(
name|io
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * May need to preserve linked list pointers at some point too. 	 */
name|pool
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|pool
expr_stmt|;
name|memset
argument_list|(
name|io
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|io
argument_list|)
argument_list|)
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
name|CTL_SOFTC
argument_list|(
name|io
argument_list|)
operator|=
name|pool
operator|->
name|ctl_softc
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ctl_expand_number
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|uint64_t
modifier|*
name|num
parameter_list|)
block|{
name|char
modifier|*
name|endptr
decl_stmt|;
name|uint64_t
name|number
decl_stmt|;
name|unsigned
name|shift
decl_stmt|;
name|number
operator|=
name|strtoq
argument_list|(
name|buf
argument_list|,
operator|&
name|endptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tolower
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|endptr
argument_list|)
condition|)
block|{
case|case
literal|'e'
case|:
name|shift
operator|=
literal|60
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|shift
operator|=
literal|50
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|shift
operator|=
literal|40
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|shift
operator|=
literal|30
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|shift
operator|=
literal|20
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|shift
operator|=
literal|10
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
case|case
literal|'\0'
case|:
comment|/* No unit. */
operator|*
name|num
operator|=
name|number
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
comment|/* Unrecognized unit. */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|number
operator|<<
name|shift
operator|)
operator|>>
name|shift
operator|!=
name|number
condition|)
block|{
comment|/* Overflow */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|num
operator|=
name|number
operator|<<
name|shift
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This routine could be used in the future to load default and/or saved  * mode page parameters for a particuar lun.  */
end_comment

begin_function
specifier|static
name|int
name|ctl_init_page_index
parameter_list|(
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|page_code
decl_stmt|;
name|struct
name|ctl_page_index
modifier|*
name|page_index
decl_stmt|;
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
name|uint64_t
name|ival
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|index
argument_list|,
name|page_index_template
argument_list|,
sizeof|sizeof
argument_list|(
name|page_index_template
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_NUM_MODE_PAGES
condition|;
name|i
operator|++
control|)
block|{
name|page_index
operator|=
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|index
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
operator|==
name|T_DIRECT
operator|&&
operator|(
name|page_index
operator|->
name|page_flags
operator|&
name|CTL_PAGE_FLAG_DIRECT
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
operator|==
name|T_PROCESSOR
operator|&&
operator|(
name|page_index
operator|->
name|page_flags
operator|&
name|CTL_PAGE_FLAG_PROC
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
operator|==
name|T_CDROM
operator|&&
operator|(
name|page_index
operator|->
name|page_flags
operator|&
name|CTL_PAGE_FLAG_CDROM
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|page_code
operator|=
name|page_index
operator|->
name|page_code
operator|&
name|SMPH_PC_MASK
expr_stmt|;
switch|switch
condition|(
name|page_code
condition|)
block|{
case|case
name|SMS_RW_ERROR_RECOVERY_PAGE
case|:
block|{
name|KASSERT
argument_list|(
name|page_index
operator|->
name|subpage
operator|==
name|SMS_SUBPAGE_PAGE_0
argument_list|,
operator|(
literal|"subpage %#x for page %#x is incorrect!"
operator|,
name|page_index
operator|->
name|subpage
operator|,
name|page_code
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|rw_er_page
index|[
name|CTL_PAGE_CURRENT
index|]
argument_list|,
operator|&
name|rw_er_page_default
argument_list|,
sizeof|sizeof
argument_list|(
name|rw_er_page_default
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|rw_er_page
index|[
name|CTL_PAGE_CHANGEABLE
index|]
argument_list|,
operator|&
name|rw_er_page_changeable
argument_list|,
sizeof|sizeof
argument_list|(
name|rw_er_page_changeable
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|rw_er_page
index|[
name|CTL_PAGE_DEFAULT
index|]
argument_list|,
operator|&
name|rw_er_page_default
argument_list|,
sizeof|sizeof
argument_list|(
name|rw_er_page_default
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|rw_er_page
index|[
name|CTL_PAGE_SAVED
index|]
argument_list|,
operator|&
name|rw_er_page_default
argument_list|,
sizeof|sizeof
argument_list|(
name|rw_er_page_default
argument_list|)
argument_list|)
expr_stmt|;
name|page_index
operator|->
name|page_data
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|lun
operator|->
name|mode_pages
operator|.
name|rw_er_page
expr_stmt|;
break|break;
block|}
case|case
name|SMS_FORMAT_DEVICE_PAGE
case|:
block|{
name|struct
name|scsi_format_page
modifier|*
name|format_page
decl_stmt|;
name|KASSERT
argument_list|(
name|page_index
operator|->
name|subpage
operator|==
name|SMS_SUBPAGE_PAGE_0
argument_list|,
operator|(
literal|"subpage %#x for page %#x is incorrect!"
operator|,
name|page_index
operator|->
name|subpage
operator|,
name|page_code
operator|)
argument_list|)
expr_stmt|;
comment|/* 			 * Sectors per track are set above.  Bytes per 			 * sector need to be set here on a per-LUN basis. 			 */
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|format_page
index|[
name|CTL_PAGE_CURRENT
index|]
argument_list|,
operator|&
name|format_page_default
argument_list|,
sizeof|sizeof
argument_list|(
name|format_page_default
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|format_page
index|[
name|CTL_PAGE_CHANGEABLE
index|]
argument_list|,
operator|&
name|format_page_changeable
argument_list|,
sizeof|sizeof
argument_list|(
name|format_page_changeable
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|format_page
index|[
name|CTL_PAGE_DEFAULT
index|]
argument_list|,
operator|&
name|format_page_default
argument_list|,
sizeof|sizeof
argument_list|(
name|format_page_default
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|format_page
index|[
name|CTL_PAGE_SAVED
index|]
argument_list|,
operator|&
name|format_page_default
argument_list|,
sizeof|sizeof
argument_list|(
name|format_page_default
argument_list|)
argument_list|)
expr_stmt|;
name|format_page
operator|=
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|format_page
index|[
name|CTL_PAGE_CURRENT
index|]
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|lun
operator|->
name|be_lun
operator|->
name|blocksize
argument_list|,
name|format_page
operator|->
name|bytes_per_sector
argument_list|)
expr_stmt|;
name|format_page
operator|=
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|format_page
index|[
name|CTL_PAGE_DEFAULT
index|]
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|lun
operator|->
name|be_lun
operator|->
name|blocksize
argument_list|,
name|format_page
operator|->
name|bytes_per_sector
argument_list|)
expr_stmt|;
name|format_page
operator|=
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|format_page
index|[
name|CTL_PAGE_SAVED
index|]
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|lun
operator|->
name|be_lun
operator|->
name|blocksize
argument_list|,
name|format_page
operator|->
name|bytes_per_sector
argument_list|)
expr_stmt|;
name|page_index
operator|->
name|page_data
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|lun
operator|->
name|mode_pages
operator|.
name|format_page
expr_stmt|;
break|break;
block|}
case|case
name|SMS_RIGID_DISK_PAGE
case|:
block|{
name|struct
name|scsi_rigid_disk_page
modifier|*
name|rigid_disk_page
decl_stmt|;
name|uint32_t
name|sectors_per_cylinder
decl_stmt|;
name|uint64_t
name|cylinders
decl_stmt|;
ifndef|#
directive|ifndef
name|__XSCALE__
name|int
name|shift
decl_stmt|;
endif|#
directive|endif
comment|/* !__XSCALE__ */
name|KASSERT
argument_list|(
name|page_index
operator|->
name|subpage
operator|==
name|SMS_SUBPAGE_PAGE_0
argument_list|,
operator|(
literal|"subpage %#x for page %#x is incorrect!"
operator|,
name|page_index
operator|->
name|subpage
operator|,
name|page_code
operator|)
argument_list|)
expr_stmt|;
comment|/* 			 * Rotation rate and sectors per track are set 			 * above.  We calculate the cylinders here based on 			 * capacity.  Due to the number of heads and 			 * sectors per track we're using, smaller arrays 			 * may turn out to have 0 cylinders.  Linux and 			 * FreeBSD don't pay attention to these mode pages 			 * to figure out capacity, but Solaris does.  It 			 * seems to deal with 0 cylinders just fine, and 			 * works out a fake geometry based on the capacity. 			 */
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|rigid_disk_page
index|[
name|CTL_PAGE_DEFAULT
index|]
argument_list|,
operator|&
name|rigid_disk_page_default
argument_list|,
sizeof|sizeof
argument_list|(
name|rigid_disk_page_default
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|rigid_disk_page
index|[
name|CTL_PAGE_CHANGEABLE
index|]
argument_list|,
operator|&
name|rigid_disk_page_changeable
argument_list|,
sizeof|sizeof
argument_list|(
name|rigid_disk_page_changeable
argument_list|)
argument_list|)
expr_stmt|;
name|sectors_per_cylinder
operator|=
name|CTL_DEFAULT_SECTORS_PER_TRACK
operator|*
name|CTL_DEFAULT_HEADS
expr_stmt|;
comment|/* 			 * The divide method here will be more accurate, 			 * probably, but results in floating point being 			 * used in the kernel on i386 (__udivdi3()).  On the 			 * XScale, though, __udivdi3() is implemented in 			 * software. 			 * 			 * The shift method for cylinder calculation is 			 * accurate if sectors_per_cylinder is a power of 			 * 2.  Otherwise it might be slightly off -- you 			 * might have a bit of a truncation problem. 			 */
ifdef|#
directive|ifdef
name|__XSCALE__
name|cylinders
operator|=
operator|(
name|lun
operator|->
name|be_lun
operator|->
name|maxlba
operator|+
literal|1
operator|)
operator|/
name|sectors_per_cylinder
expr_stmt|;
else|#
directive|else
for|for
control|(
name|shift
operator|=
literal|31
init|;
name|shift
operator|>
literal|0
condition|;
name|shift
operator|--
control|)
block|{
if|if
condition|(
name|sectors_per_cylinder
operator|&
operator|(
literal|1
operator|<<
name|shift
operator|)
condition|)
break|break;
block|}
name|cylinders
operator|=
operator|(
name|lun
operator|->
name|be_lun
operator|->
name|maxlba
operator|+
literal|1
operator|)
operator|>>
name|shift
expr_stmt|;
endif|#
directive|endif
comment|/* 			 * We've basically got 3 bytes, or 24 bits for the 			 * cylinder size in the mode page.  If we're over, 			 * just round down to 2^24. 			 */
if|if
condition|(
name|cylinders
operator|>
literal|0xffffff
condition|)
name|cylinders
operator|=
literal|0xffffff
expr_stmt|;
name|rigid_disk_page
operator|=
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|rigid_disk_page
index|[
name|CTL_PAGE_DEFAULT
index|]
expr_stmt|;
name|scsi_ulto3b
argument_list|(
name|cylinders
argument_list|,
name|rigid_disk_page
operator|->
name|cylinders
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|value
operator|=
name|ctl_get_opt
argument_list|(
operator|&
name|lun
operator|->
name|be_lun
operator|->
name|options
argument_list|,
literal|"rpm"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|scsi_ulto2b
argument_list|(
name|strtol
argument_list|(
name|value
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
argument_list|,
name|rigid_disk_page
operator|->
name|rotation_rate
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|rigid_disk_page
index|[
name|CTL_PAGE_CURRENT
index|]
argument_list|,
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|rigid_disk_page
index|[
name|CTL_PAGE_DEFAULT
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|rigid_disk_page_default
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|rigid_disk_page
index|[
name|CTL_PAGE_SAVED
index|]
argument_list|,
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|rigid_disk_page
index|[
name|CTL_PAGE_DEFAULT
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|rigid_disk_page_default
argument_list|)
argument_list|)
expr_stmt|;
name|page_index
operator|->
name|page_data
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|lun
operator|->
name|mode_pages
operator|.
name|rigid_disk_page
expr_stmt|;
break|break;
block|}
case|case
name|SMS_VERIFY_ERROR_RECOVERY_PAGE
case|:
block|{
name|KASSERT
argument_list|(
name|page_index
operator|->
name|subpage
operator|==
name|SMS_SUBPAGE_PAGE_0
argument_list|,
operator|(
literal|"subpage %#x for page %#x is incorrect!"
operator|,
name|page_index
operator|->
name|subpage
operator|,
name|page_code
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|verify_er_page
index|[
name|CTL_PAGE_CURRENT
index|]
argument_list|,
operator|&
name|verify_er_page_default
argument_list|,
sizeof|sizeof
argument_list|(
name|verify_er_page_default
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|verify_er_page
index|[
name|CTL_PAGE_CHANGEABLE
index|]
argument_list|,
operator|&
name|verify_er_page_changeable
argument_list|,
sizeof|sizeof
argument_list|(
name|verify_er_page_changeable
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|verify_er_page
index|[
name|CTL_PAGE_DEFAULT
index|]
argument_list|,
operator|&
name|verify_er_page_default
argument_list|,
sizeof|sizeof
argument_list|(
name|verify_er_page_default
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|verify_er_page
index|[
name|CTL_PAGE_SAVED
index|]
argument_list|,
operator|&
name|verify_er_page_default
argument_list|,
sizeof|sizeof
argument_list|(
name|verify_er_page_default
argument_list|)
argument_list|)
expr_stmt|;
name|page_index
operator|->
name|page_data
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|lun
operator|->
name|mode_pages
operator|.
name|verify_er_page
expr_stmt|;
break|break;
block|}
case|case
name|SMS_CACHING_PAGE
case|:
block|{
name|struct
name|scsi_caching_page
modifier|*
name|caching_page
decl_stmt|;
name|KASSERT
argument_list|(
name|page_index
operator|->
name|subpage
operator|==
name|SMS_SUBPAGE_PAGE_0
argument_list|,
operator|(
literal|"subpage %#x for page %#x is incorrect!"
operator|,
name|page_index
operator|->
name|subpage
operator|,
name|page_code
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|caching_page
index|[
name|CTL_PAGE_DEFAULT
index|]
argument_list|,
operator|&
name|caching_page_default
argument_list|,
sizeof|sizeof
argument_list|(
name|caching_page_default
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|caching_page
index|[
name|CTL_PAGE_CHANGEABLE
index|]
argument_list|,
operator|&
name|caching_page_changeable
argument_list|,
sizeof|sizeof
argument_list|(
name|caching_page_changeable
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|caching_page
index|[
name|CTL_PAGE_SAVED
index|]
argument_list|,
operator|&
name|caching_page_default
argument_list|,
sizeof|sizeof
argument_list|(
name|caching_page_default
argument_list|)
argument_list|)
expr_stmt|;
name|caching_page
operator|=
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|caching_page
index|[
name|CTL_PAGE_SAVED
index|]
expr_stmt|;
name|value
operator|=
name|ctl_get_opt
argument_list|(
operator|&
name|lun
operator|->
name|be_lun
operator|->
name|options
argument_list|,
literal|"writecache"
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
condition|)
name|caching_page
operator|->
name|flags1
operator|&=
operator|~
name|SCP_WCE
expr_stmt|;
name|value
operator|=
name|ctl_get_opt
argument_list|(
operator|&
name|lun
operator|->
name|be_lun
operator|->
name|options
argument_list|,
literal|"readcache"
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
condition|)
name|caching_page
operator|->
name|flags1
operator||=
name|SCP_RCD
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|caching_page
index|[
name|CTL_PAGE_CURRENT
index|]
argument_list|,
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|caching_page
index|[
name|CTL_PAGE_SAVED
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|caching_page_default
argument_list|)
argument_list|)
expr_stmt|;
name|page_index
operator|->
name|page_data
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|lun
operator|->
name|mode_pages
operator|.
name|caching_page
expr_stmt|;
break|break;
block|}
case|case
name|SMS_CONTROL_MODE_PAGE
case|:
block|{
switch|switch
condition|(
name|page_index
operator|->
name|subpage
condition|)
block|{
case|case
name|SMS_SUBPAGE_PAGE_0
case|:
block|{
name|struct
name|scsi_control_page
modifier|*
name|control_page
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|control_page
index|[
name|CTL_PAGE_DEFAULT
index|]
argument_list|,
operator|&
name|control_page_default
argument_list|,
sizeof|sizeof
argument_list|(
name|control_page_default
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|control_page
index|[
name|CTL_PAGE_CHANGEABLE
index|]
argument_list|,
operator|&
name|control_page_changeable
argument_list|,
sizeof|sizeof
argument_list|(
name|control_page_changeable
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|control_page
index|[
name|CTL_PAGE_SAVED
index|]
argument_list|,
operator|&
name|control_page_default
argument_list|,
sizeof|sizeof
argument_list|(
name|control_page_default
argument_list|)
argument_list|)
expr_stmt|;
name|control_page
operator|=
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|control_page
index|[
name|CTL_PAGE_SAVED
index|]
expr_stmt|;
name|value
operator|=
name|ctl_get_opt
argument_list|(
operator|&
name|lun
operator|->
name|be_lun
operator|->
name|options
argument_list|,
literal|"reordering"
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"unrestricted"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|control_page
operator|->
name|queue_flags
operator|&=
operator|~
name|SCP_QUEUE_ALG_MASK
expr_stmt|;
name|control_page
operator|->
name|queue_flags
operator||=
name|SCP_QUEUE_ALG_UNRESTRICTED
expr_stmt|;
block|}
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|control_page
index|[
name|CTL_PAGE_CURRENT
index|]
argument_list|,
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|control_page
index|[
name|CTL_PAGE_SAVED
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|control_page_default
argument_list|)
argument_list|)
expr_stmt|;
name|page_index
operator|->
name|page_data
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|lun
operator|->
name|mode_pages
operator|.
name|control_page
expr_stmt|;
break|break;
block|}
case|case
literal|0x01
case|:
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|control_ext_page
index|[
name|CTL_PAGE_DEFAULT
index|]
argument_list|,
operator|&
name|control_ext_page_default
argument_list|,
sizeof|sizeof
argument_list|(
name|control_ext_page_default
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|control_ext_page
index|[
name|CTL_PAGE_CHANGEABLE
index|]
argument_list|,
operator|&
name|control_ext_page_changeable
argument_list|,
sizeof|sizeof
argument_list|(
name|control_ext_page_changeable
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|control_ext_page
index|[
name|CTL_PAGE_SAVED
index|]
argument_list|,
operator|&
name|control_ext_page_default
argument_list|,
sizeof|sizeof
argument_list|(
name|control_ext_page_default
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|control_ext_page
index|[
name|CTL_PAGE_CURRENT
index|]
argument_list|,
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|control_ext_page
index|[
name|CTL_PAGE_SAVED
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|control_ext_page_default
argument_list|)
argument_list|)
expr_stmt|;
name|page_index
operator|->
name|page_data
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|lun
operator|->
name|mode_pages
operator|.
name|control_ext_page
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"subpage %#x for page %#x is incorrect!"
argument_list|,
name|page_index
operator|->
name|subpage
argument_list|,
name|page_code
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SMS_INFO_EXCEPTIONS_PAGE
case|:
block|{
switch|switch
condition|(
name|page_index
operator|->
name|subpage
condition|)
block|{
case|case
name|SMS_SUBPAGE_PAGE_0
case|:
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|ie_page
index|[
name|CTL_PAGE_CURRENT
index|]
argument_list|,
operator|&
name|ie_page_default
argument_list|,
sizeof|sizeof
argument_list|(
name|ie_page_default
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|ie_page
index|[
name|CTL_PAGE_CHANGEABLE
index|]
argument_list|,
operator|&
name|ie_page_changeable
argument_list|,
sizeof|sizeof
argument_list|(
name|ie_page_changeable
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|ie_page
index|[
name|CTL_PAGE_DEFAULT
index|]
argument_list|,
operator|&
name|ie_page_default
argument_list|,
sizeof|sizeof
argument_list|(
name|ie_page_default
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|ie_page
index|[
name|CTL_PAGE_SAVED
index|]
argument_list|,
operator|&
name|ie_page_default
argument_list|,
sizeof|sizeof
argument_list|(
name|ie_page_default
argument_list|)
argument_list|)
expr_stmt|;
name|page_index
operator|->
name|page_data
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|lun
operator|->
name|mode_pages
operator|.
name|ie_page
expr_stmt|;
break|break;
case|case
literal|0x02
case|:
block|{
name|struct
name|ctl_logical_block_provisioning_page
modifier|*
name|page
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|lbp_page
index|[
name|CTL_PAGE_DEFAULT
index|]
argument_list|,
operator|&
name|lbp_page_default
argument_list|,
sizeof|sizeof
argument_list|(
name|lbp_page_default
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|lbp_page
index|[
name|CTL_PAGE_CHANGEABLE
index|]
argument_list|,
operator|&
name|lbp_page_changeable
argument_list|,
sizeof|sizeof
argument_list|(
name|lbp_page_changeable
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|lbp_page
index|[
name|CTL_PAGE_SAVED
index|]
argument_list|,
operator|&
name|lbp_page_default
argument_list|,
sizeof|sizeof
argument_list|(
name|lbp_page_default
argument_list|)
argument_list|)
expr_stmt|;
name|page
operator|=
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|lbp_page
index|[
name|CTL_PAGE_SAVED
index|]
expr_stmt|;
name|value
operator|=
name|ctl_get_opt
argument_list|(
operator|&
name|lun
operator|->
name|be_lun
operator|->
name|options
argument_list|,
literal|"avail-threshold"
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|NULL
operator|&&
name|ctl_expand_number
argument_list|(
name|value
argument_list|,
operator|&
name|ival
argument_list|)
operator|==
literal|0
condition|)
block|{
name|page
operator|->
name|descr
index|[
literal|0
index|]
operator|.
name|flags
operator||=
name|SLBPPD_ENABLED
operator||
name|SLBPPD_ARMING_DEC
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|be_lun
operator|->
name|blocksize
condition|)
name|ival
operator|/=
name|lun
operator|->
name|be_lun
operator|->
name|blocksize
expr_stmt|;
else|else
name|ival
operator|/=
literal|512
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|ival
operator|>>
name|CTL_LBP_EXPONENT
argument_list|,
name|page
operator|->
name|descr
index|[
literal|0
index|]
operator|.
name|count
argument_list|)
expr_stmt|;
block|}
name|value
operator|=
name|ctl_get_opt
argument_list|(
operator|&
name|lun
operator|->
name|be_lun
operator|->
name|options
argument_list|,
literal|"used-threshold"
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|NULL
operator|&&
name|ctl_expand_number
argument_list|(
name|value
argument_list|,
operator|&
name|ival
argument_list|)
operator|==
literal|0
condition|)
block|{
name|page
operator|->
name|descr
index|[
literal|1
index|]
operator|.
name|flags
operator||=
name|SLBPPD_ENABLED
operator||
name|SLBPPD_ARMING_INC
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|be_lun
operator|->
name|blocksize
condition|)
name|ival
operator|/=
name|lun
operator|->
name|be_lun
operator|->
name|blocksize
expr_stmt|;
else|else
name|ival
operator|/=
literal|512
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|ival
operator|>>
name|CTL_LBP_EXPONENT
argument_list|,
name|page
operator|->
name|descr
index|[
literal|1
index|]
operator|.
name|count
argument_list|)
expr_stmt|;
block|}
name|value
operator|=
name|ctl_get_opt
argument_list|(
operator|&
name|lun
operator|->
name|be_lun
operator|->
name|options
argument_list|,
literal|"pool-avail-threshold"
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|NULL
operator|&&
name|ctl_expand_number
argument_list|(
name|value
argument_list|,
operator|&
name|ival
argument_list|)
operator|==
literal|0
condition|)
block|{
name|page
operator|->
name|descr
index|[
literal|2
index|]
operator|.
name|flags
operator||=
name|SLBPPD_ENABLED
operator||
name|SLBPPD_ARMING_DEC
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|be_lun
operator|->
name|blocksize
condition|)
name|ival
operator|/=
name|lun
operator|->
name|be_lun
operator|->
name|blocksize
expr_stmt|;
else|else
name|ival
operator|/=
literal|512
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|ival
operator|>>
name|CTL_LBP_EXPONENT
argument_list|,
name|page
operator|->
name|descr
index|[
literal|2
index|]
operator|.
name|count
argument_list|)
expr_stmt|;
block|}
name|value
operator|=
name|ctl_get_opt
argument_list|(
operator|&
name|lun
operator|->
name|be_lun
operator|->
name|options
argument_list|,
literal|"pool-used-threshold"
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|NULL
operator|&&
name|ctl_expand_number
argument_list|(
name|value
argument_list|,
operator|&
name|ival
argument_list|)
operator|==
literal|0
condition|)
block|{
name|page
operator|->
name|descr
index|[
literal|3
index|]
operator|.
name|flags
operator||=
name|SLBPPD_ENABLED
operator||
name|SLBPPD_ARMING_INC
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|be_lun
operator|->
name|blocksize
condition|)
name|ival
operator|/=
name|lun
operator|->
name|be_lun
operator|->
name|blocksize
expr_stmt|;
else|else
name|ival
operator|/=
literal|512
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|ival
operator|>>
name|CTL_LBP_EXPONENT
argument_list|,
name|page
operator|->
name|descr
index|[
literal|3
index|]
operator|.
name|count
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|lbp_page
index|[
name|CTL_PAGE_CURRENT
index|]
argument_list|,
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|lbp_page
index|[
name|CTL_PAGE_SAVED
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|lbp_page_default
argument_list|)
argument_list|)
expr_stmt|;
name|page_index
operator|->
name|page_data
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|lun
operator|->
name|mode_pages
operator|.
name|lbp_page
expr_stmt|;
break|break;
block|}
default|default:
name|panic
argument_list|(
literal|"subpage %#x for page %#x is incorrect!"
argument_list|,
name|page_index
operator|->
name|subpage
argument_list|,
name|page_code
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SMS_CDDVD_CAPS_PAGE
case|:
block|{
name|KASSERT
argument_list|(
name|page_index
operator|->
name|subpage
operator|==
name|SMS_SUBPAGE_PAGE_0
argument_list|,
operator|(
literal|"subpage %#x for page %#x is incorrect!"
operator|,
name|page_index
operator|->
name|subpage
operator|,
name|page_code
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|cddvd_page
index|[
name|CTL_PAGE_DEFAULT
index|]
argument_list|,
operator|&
name|cddvd_page_default
argument_list|,
sizeof|sizeof
argument_list|(
name|cddvd_page_default
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|cddvd_page
index|[
name|CTL_PAGE_CHANGEABLE
index|]
argument_list|,
operator|&
name|cddvd_page_changeable
argument_list|,
sizeof|sizeof
argument_list|(
name|cddvd_page_changeable
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|cddvd_page
index|[
name|CTL_PAGE_SAVED
index|]
argument_list|,
operator|&
name|cddvd_page_default
argument_list|,
sizeof|sizeof
argument_list|(
name|cddvd_page_default
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|cddvd_page
index|[
name|CTL_PAGE_CURRENT
index|]
argument_list|,
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|cddvd_page
index|[
name|CTL_PAGE_SAVED
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|cddvd_page_default
argument_list|)
argument_list|)
expr_stmt|;
name|page_index
operator|->
name|page_data
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|lun
operator|->
name|mode_pages
operator|.
name|cddvd_page
expr_stmt|;
break|break;
block|}
default|default:
name|panic
argument_list|(
literal|"invalid page code value %#x"
argument_list|,
name|page_code
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_init_log_page_index
parameter_list|(
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|)
block|{
name|struct
name|ctl_page_index
modifier|*
name|page_index
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|prev
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|log_pages
operator|.
name|index
argument_list|,
name|log_page_index_template
argument_list|,
sizeof|sizeof
argument_list|(
name|log_page_index_template
argument_list|)
argument_list|)
expr_stmt|;
name|prev
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
operator|,
name|k
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_NUM_LOG_PAGES
condition|;
name|i
operator|++
control|)
block|{
name|page_index
operator|=
operator|&
name|lun
operator|->
name|log_pages
operator|.
name|index
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
operator|==
name|T_DIRECT
operator|&&
operator|(
name|page_index
operator|->
name|page_flags
operator|&
name|CTL_PAGE_FLAG_DIRECT
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
operator|==
name|T_PROCESSOR
operator|&&
operator|(
name|page_index
operator|->
name|page_flags
operator|&
name|CTL_PAGE_FLAG_PROC
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
operator|==
name|T_CDROM
operator|&&
operator|(
name|page_index
operator|->
name|page_flags
operator|&
name|CTL_PAGE_FLAG_CDROM
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|page_index
operator|->
name|page_code
operator|==
name|SLS_LOGICAL_BLOCK_PROVISIONING
operator|&&
name|lun
operator|->
name|backend
operator|->
name|lun_attr
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|page_index
operator|->
name|page_code
operator|!=
name|prev
condition|)
block|{
name|lun
operator|->
name|log_pages
operator|.
name|pages_page
index|[
name|j
index|]
operator|=
name|page_index
operator|->
name|page_code
expr_stmt|;
name|prev
operator|=
name|page_index
operator|->
name|page_code
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
name|lun
operator|->
name|log_pages
operator|.
name|subpages_page
index|[
name|k
operator|*
literal|2
index|]
operator|=
name|page_index
operator|->
name|page_code
expr_stmt|;
name|lun
operator|->
name|log_pages
operator|.
name|subpages_page
index|[
name|k
operator|*
literal|2
operator|+
literal|1
index|]
operator|=
name|page_index
operator|->
name|subpage
expr_stmt|;
name|k
operator|++
expr_stmt|;
block|}
name|lun
operator|->
name|log_pages
operator|.
name|index
index|[
literal|0
index|]
operator|.
name|page_data
operator|=
operator|&
name|lun
operator|->
name|log_pages
operator|.
name|pages_page
index|[
literal|0
index|]
expr_stmt|;
name|lun
operator|->
name|log_pages
operator|.
name|index
index|[
literal|0
index|]
operator|.
name|page_len
operator|=
name|j
expr_stmt|;
name|lun
operator|->
name|log_pages
operator|.
name|index
index|[
literal|1
index|]
operator|.
name|page_data
operator|=
operator|&
name|lun
operator|->
name|log_pages
operator|.
name|subpages_page
index|[
literal|0
index|]
expr_stmt|;
name|lun
operator|->
name|log_pages
operator|.
name|index
index|[
literal|1
index|]
operator|.
name|page_len
operator|=
name|k
operator|*
literal|2
expr_stmt|;
name|lun
operator|->
name|log_pages
operator|.
name|index
index|[
literal|2
index|]
operator|.
name|page_data
operator|=
operator|&
name|lun
operator|->
name|log_pages
operator|.
name|lbp_page
index|[
literal|0
index|]
expr_stmt|;
name|lun
operator|->
name|log_pages
operator|.
name|index
index|[
literal|2
index|]
operator|.
name|page_len
operator|=
literal|12
operator|*
name|CTL_NUM_LBP_PARAMS
expr_stmt|;
name|lun
operator|->
name|log_pages
operator|.
name|index
index|[
literal|3
index|]
operator|.
name|page_data
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|lun
operator|->
name|log_pages
operator|.
name|stat_page
expr_stmt|;
name|lun
operator|->
name|log_pages
operator|.
name|index
index|[
literal|3
index|]
operator|.
name|page_len
operator|=
sizeof|sizeof
argument_list|(
name|lun
operator|->
name|log_pages
operator|.
name|stat_page
argument_list|)
expr_stmt|;
name|lun
operator|->
name|log_pages
operator|.
name|index
index|[
literal|4
index|]
operator|.
name|page_data
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|lun
operator|->
name|log_pages
operator|.
name|ie_page
expr_stmt|;
name|lun
operator|->
name|log_pages
operator|.
name|index
index|[
literal|4
index|]
operator|.
name|page_len
operator|=
sizeof|sizeof
argument_list|(
name|lun
operator|->
name|log_pages
operator|.
name|ie_page
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hex2bin
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|int
name|buf_size
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_char
name|c
decl_stmt|;
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|buf_size
argument_list|)
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
name|str
index|[
literal|0
index|]
argument_list|)
condition|)
name|str
operator|++
expr_stmt|;
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
operator|(
name|str
index|[
literal|1
index|]
operator|==
literal|'x'
operator|||
name|str
index|[
literal|1
index|]
operator|==
literal|'X'
operator|)
condition|)
name|str
operator|+=
literal|2
expr_stmt|;
name|buf_size
operator|*=
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|str
index|[
name|i
index|]
operator|!=
literal|0
operator|&&
name|i
operator|<
name|buf_size
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
name|str
index|[
name|i
index|]
operator|==
literal|'-'
condition|)
comment|/* Skip dashes in UUIDs. */
name|str
operator|++
expr_stmt|;
name|c
operator|=
name|str
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|-=
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|-=
name|isupper
argument_list|(
name|c
argument_list|)
condition|?
literal|'A'
operator|-
literal|10
else|:
literal|'a'
operator|-
literal|10
expr_stmt|;
else|else
break|break;
if|if
condition|(
name|c
operator|>=
literal|16
condition|)
break|break;
if|if
condition|(
operator|(
name|i
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|buf
index|[
name|i
operator|/
literal|2
index|]
operator||=
operator|(
name|c
operator|<<
literal|4
operator|)
expr_stmt|;
else|else
name|buf
index|[
name|i
operator|/
literal|2
index|]
operator||=
name|c
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|/
literal|2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * LUN allocation.  *  * Requirements:  * - caller allocates and zeros LUN storage, or passes in a NULL LUN if he  *   wants us to allocate the LUN and he can block.  * - ctl_softc is always set  * - be_lun is set if the LUN has a backend (needed for disk LUNs)  *  * Returns 0 for success, non-zero (errno) for failure.  */
end_comment

begin_function
specifier|static
name|int
name|ctl_alloc_lun
parameter_list|(
name|struct
name|ctl_softc
modifier|*
name|ctl_softc
parameter_list|,
name|struct
name|ctl_lun
modifier|*
name|ctl_lun
parameter_list|,
name|struct
name|ctl_be_lun
modifier|*
specifier|const
name|be_lun
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|nlun
decl_stmt|,
modifier|*
name|lun
decl_stmt|;
name|struct
name|scsi_vpd_id_descriptor
modifier|*
name|desc
decl_stmt|;
name|struct
name|scsi_vpd_id_t10
modifier|*
name|t10id
decl_stmt|;
specifier|const
name|char
modifier|*
name|eui
decl_stmt|,
modifier|*
name|naa
decl_stmt|,
modifier|*
name|scsiname
decl_stmt|,
modifier|*
name|uuid
decl_stmt|,
modifier|*
name|vendor
decl_stmt|,
modifier|*
name|value
decl_stmt|;
name|int
name|lun_number
decl_stmt|,
name|lun_malloced
decl_stmt|;
name|int
name|devidlen
decl_stmt|,
name|idlen1
decl_stmt|,
name|idlen2
init|=
literal|0
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
name|be_lun
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * We currently only support Direct Access or Processor LUN types. 	 */
switch|switch
condition|(
name|be_lun
operator|->
name|lun_type
condition|)
block|{
case|case
name|T_DIRECT
case|:
case|case
name|T_PROCESSOR
case|:
case|case
name|T_CDROM
case|:
break|break;
case|case
name|T_SEQUENTIAL
case|:
case|case
name|T_CHANGER
case|:
default|default:
name|be_lun
operator|->
name|lun_config_status
argument_list|(
name|be_lun
operator|->
name|be_lun
argument_list|,
name|CTL_LUN_CONFIG_FAILURE
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ctl_lun
operator|==
name|NULL
condition|)
block|{
name|lun
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|lun
argument_list|)
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|lun_malloced
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|lun_malloced
operator|=
literal|0
expr_stmt|;
name|lun
operator|=
name|ctl_lun
expr_stmt|;
block|}
name|memset
argument_list|(
name|lun
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lun
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun_malloced
condition|)
name|lun
operator|->
name|flags
operator|=
name|CTL_LUN_MALLOCED
expr_stmt|;
comment|/* Generate LUN ID. */
name|devidlen
operator|=
name|max
argument_list|(
name|CTL_DEVID_MIN_LEN
argument_list|,
name|strnlen
argument_list|(
name|be_lun
operator|->
name|device_id
argument_list|,
name|CTL_DEVID_LEN
argument_list|)
argument_list|)
expr_stmt|;
name|idlen1
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|t10id
argument_list|)
operator|+
name|devidlen
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_id_descriptor
argument_list|)
operator|+
name|idlen1
expr_stmt|;
name|scsiname
operator|=
name|ctl_get_opt
argument_list|(
operator|&
name|be_lun
operator|->
name|options
argument_list|,
literal|"scsiname"
argument_list|)
expr_stmt|;
if|if
condition|(
name|scsiname
operator|!=
name|NULL
condition|)
block|{
name|idlen2
operator|=
name|roundup2
argument_list|(
name|strlen
argument_list|(
name|scsiname
argument_list|)
operator|+
literal|1
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_id_descriptor
argument_list|)
operator|+
name|idlen2
expr_stmt|;
block|}
name|eui
operator|=
name|ctl_get_opt
argument_list|(
operator|&
name|be_lun
operator|->
name|options
argument_list|,
literal|"eui"
argument_list|)
expr_stmt|;
if|if
condition|(
name|eui
operator|!=
name|NULL
condition|)
block|{
name|len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_id_descriptor
argument_list|)
operator|+
literal|16
expr_stmt|;
block|}
name|naa
operator|=
name|ctl_get_opt
argument_list|(
operator|&
name|be_lun
operator|->
name|options
argument_list|,
literal|"naa"
argument_list|)
expr_stmt|;
if|if
condition|(
name|naa
operator|!=
name|NULL
condition|)
block|{
name|len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_id_descriptor
argument_list|)
operator|+
literal|16
expr_stmt|;
block|}
name|uuid
operator|=
name|ctl_get_opt
argument_list|(
operator|&
name|be_lun
operator|->
name|options
argument_list|,
literal|"uuid"
argument_list|)
expr_stmt|;
if|if
condition|(
name|uuid
operator|!=
name|NULL
condition|)
block|{
name|len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_id_descriptor
argument_list|)
operator|+
literal|18
expr_stmt|;
block|}
name|lun
operator|->
name|lun_devid
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ctl_devid
argument_list|)
operator|+
name|len
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|desc
operator|=
operator|(
expr|struct
name|scsi_vpd_id_descriptor
operator|*
operator|)
name|lun
operator|->
name|lun_devid
operator|->
name|data
expr_stmt|;
name|desc
operator|->
name|proto_codeset
operator|=
name|SVPD_ID_CODESET_ASCII
expr_stmt|;
name|desc
operator|->
name|id_type
operator|=
name|SVPD_ID_PIV
operator||
name|SVPD_ID_ASSOC_LUN
operator||
name|SVPD_ID_TYPE_T10
expr_stmt|;
name|desc
operator|->
name|length
operator|=
name|idlen1
expr_stmt|;
name|t10id
operator|=
operator|(
expr|struct
name|scsi_vpd_id_t10
operator|*
operator|)
operator|&
name|desc
operator|->
name|identifier
index|[
literal|0
index|]
expr_stmt|;
name|memset
argument_list|(
name|t10id
operator|->
name|vendor
argument_list|,
literal|' '
argument_list|,
sizeof|sizeof
argument_list|(
name|t10id
operator|->
name|vendor
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vendor
operator|=
name|ctl_get_opt
argument_list|(
operator|&
name|be_lun
operator|->
name|options
argument_list|,
literal|"vendor"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t10id
operator|->
name|vendor
argument_list|,
name|CTL_VENDOR
argument_list|,
sizeof|sizeof
argument_list|(
name|t10id
operator|->
name|vendor
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strncpy
argument_list|(
name|t10id
operator|->
name|vendor
argument_list|,
name|vendor
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|t10id
operator|->
name|vendor
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|vendor
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t10id
operator|->
name|vendor_spec_id
argument_list|,
operator|(
name|char
operator|*
operator|)
name|be_lun
operator|->
name|device_id
argument_list|,
name|devidlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|scsiname
operator|!=
name|NULL
condition|)
block|{
name|desc
operator|=
operator|(
expr|struct
name|scsi_vpd_id_descriptor
operator|*
operator|)
operator|(
operator|&
name|desc
operator|->
name|identifier
index|[
literal|0
index|]
operator|+
name|desc
operator|->
name|length
operator|)
expr_stmt|;
name|desc
operator|->
name|proto_codeset
operator|=
name|SVPD_ID_CODESET_UTF8
expr_stmt|;
name|desc
operator|->
name|id_type
operator|=
name|SVPD_ID_PIV
operator||
name|SVPD_ID_ASSOC_LUN
operator||
name|SVPD_ID_TYPE_SCSI_NAME
expr_stmt|;
name|desc
operator|->
name|length
operator|=
name|idlen2
expr_stmt|;
name|strlcpy
argument_list|(
name|desc
operator|->
name|identifier
argument_list|,
name|scsiname
argument_list|,
name|idlen2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|eui
operator|!=
name|NULL
condition|)
block|{
name|desc
operator|=
operator|(
expr|struct
name|scsi_vpd_id_descriptor
operator|*
operator|)
operator|(
operator|&
name|desc
operator|->
name|identifier
index|[
literal|0
index|]
operator|+
name|desc
operator|->
name|length
operator|)
expr_stmt|;
name|desc
operator|->
name|proto_codeset
operator|=
name|SVPD_ID_CODESET_BINARY
expr_stmt|;
name|desc
operator|->
name|id_type
operator|=
name|SVPD_ID_PIV
operator||
name|SVPD_ID_ASSOC_LUN
operator||
name|SVPD_ID_TYPE_EUI64
expr_stmt|;
name|desc
operator|->
name|length
operator|=
name|hex2bin
argument_list|(
name|eui
argument_list|,
name|desc
operator|->
name|identifier
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|desc
operator|->
name|length
operator|=
name|desc
operator|->
name|length
operator|>
literal|12
condition|?
literal|16
else|:
operator|(
name|desc
operator|->
name|length
operator|>
literal|8
condition|?
literal|12
else|:
literal|8
operator|)
expr_stmt|;
name|len
operator|-=
literal|16
operator|-
name|desc
operator|->
name|length
expr_stmt|;
block|}
if|if
condition|(
name|naa
operator|!=
name|NULL
condition|)
block|{
name|desc
operator|=
operator|(
expr|struct
name|scsi_vpd_id_descriptor
operator|*
operator|)
operator|(
operator|&
name|desc
operator|->
name|identifier
index|[
literal|0
index|]
operator|+
name|desc
operator|->
name|length
operator|)
expr_stmt|;
name|desc
operator|->
name|proto_codeset
operator|=
name|SVPD_ID_CODESET_BINARY
expr_stmt|;
name|desc
operator|->
name|id_type
operator|=
name|SVPD_ID_PIV
operator||
name|SVPD_ID_ASSOC_LUN
operator||
name|SVPD_ID_TYPE_NAA
expr_stmt|;
name|desc
operator|->
name|length
operator|=
name|hex2bin
argument_list|(
name|naa
argument_list|,
name|desc
operator|->
name|identifier
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|desc
operator|->
name|length
operator|=
name|desc
operator|->
name|length
operator|>
literal|8
condition|?
literal|16
else|:
literal|8
expr_stmt|;
name|len
operator|-=
literal|16
operator|-
name|desc
operator|->
name|length
expr_stmt|;
block|}
if|if
condition|(
name|uuid
operator|!=
name|NULL
condition|)
block|{
name|desc
operator|=
operator|(
expr|struct
name|scsi_vpd_id_descriptor
operator|*
operator|)
operator|(
operator|&
name|desc
operator|->
name|identifier
index|[
literal|0
index|]
operator|+
name|desc
operator|->
name|length
operator|)
expr_stmt|;
name|desc
operator|->
name|proto_codeset
operator|=
name|SVPD_ID_CODESET_BINARY
expr_stmt|;
name|desc
operator|->
name|id_type
operator|=
name|SVPD_ID_PIV
operator||
name|SVPD_ID_ASSOC_LUN
operator||
name|SVPD_ID_TYPE_UUID
expr_stmt|;
name|desc
operator|->
name|identifier
index|[
literal|0
index|]
operator|=
literal|0x10
expr_stmt|;
name|hex2bin
argument_list|(
name|uuid
argument_list|,
operator|&
name|desc
operator|->
name|identifier
index|[
literal|2
index|]
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|desc
operator|->
name|length
operator|=
literal|18
expr_stmt|;
block|}
name|lun
operator|->
name|lun_devid
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ctl_softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
comment|/* 	 * See if the caller requested a particular LUN number.  If so, see 	 * if it is available.  Otherwise, allocate the first available LUN. 	 */
if|if
condition|(
name|be_lun
operator|->
name|flags
operator|&
name|CTL_LUN_FLAG_ID_REQ
condition|)
block|{
if|if
condition|(
operator|(
name|be_lun
operator|->
name|req_lun_id
operator|>
operator|(
name|CTL_MAX_LUNS
operator|-
literal|1
operator|)
operator|)
operator|||
operator|(
name|ctl_is_set
argument_list|(
name|ctl_softc
operator|->
name|ctl_lun_mask
argument_list|,
name|be_lun
operator|->
name|req_lun_id
argument_list|)
operator|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|ctl_softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|be_lun
operator|->
name|req_lun_id
operator|>
operator|(
name|CTL_MAX_LUNS
operator|-
literal|1
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ctl: requested LUN ID %d is higher "
literal|"than CTL_MAX_LUNS - 1 (%d)\n"
argument_list|,
name|be_lun
operator|->
name|req_lun_id
argument_list|,
name|CTL_MAX_LUNS
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * XXX KDM return an error, or just assign 				 * another LUN ID in this case?? 				 */
name|printf
argument_list|(
literal|"ctl: requested LUN ID %d is already "
literal|"in use\n"
argument_list|,
name|be_lun
operator|->
name|req_lun_id
argument_list|)
expr_stmt|;
block|}
name|fail
label|:
name|free
argument_list|(
name|lun
operator|->
name|lun_devid
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_MALLOCED
condition|)
name|free
argument_list|(
name|lun
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|be_lun
operator|->
name|lun_config_status
argument_list|(
name|be_lun
operator|->
name|be_lun
argument_list|,
name|CTL_LUN_CONFIG_FAILURE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
name|lun_number
operator|=
name|be_lun
operator|->
name|req_lun_id
expr_stmt|;
block|}
else|else
block|{
name|lun_number
operator|=
name|ctl_ffz
argument_list|(
name|ctl_softc
operator|->
name|ctl_lun_mask
argument_list|,
literal|0
argument_list|,
name|CTL_MAX_LUNS
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun_number
operator|==
operator|-
literal|1
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|ctl_softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ctl: can't allocate LUN, out of LUNs\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
name|ctl_set_mask
argument_list|(
name|ctl_softc
operator|->
name|ctl_lun_mask
argument_list|,
name|lun_number
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ctl_softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|,
literal|"CTL LUN"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|lun
operator|->
name|lun
operator|=
name|lun_number
expr_stmt|;
name|lun
operator|->
name|be_lun
operator|=
name|be_lun
expr_stmt|;
comment|/* 	 * The processor LUN is always enabled.  Disk LUNs come on line 	 * disabled, and must be enabled by the backend. 	 */
name|lun
operator|->
name|flags
operator||=
name|CTL_LUN_DISABLED
expr_stmt|;
name|lun
operator|->
name|backend
operator|=
name|be_lun
operator|->
name|be
expr_stmt|;
name|be_lun
operator|->
name|ctl_lun
operator|=
name|lun
expr_stmt|;
name|be_lun
operator|->
name|lun_id
operator|=
name|lun_number
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|be_lun
operator|->
name|be
operator|->
name|num_luns
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|be_lun
operator|->
name|flags
operator|&
name|CTL_LUN_FLAG_EJECTED
condition|)
name|lun
operator|->
name|flags
operator||=
name|CTL_LUN_EJECTED
expr_stmt|;
if|if
condition|(
name|be_lun
operator|->
name|flags
operator|&
name|CTL_LUN_FLAG_NO_MEDIA
condition|)
name|lun
operator|->
name|flags
operator||=
name|CTL_LUN_NO_MEDIA
expr_stmt|;
if|if
condition|(
name|be_lun
operator|->
name|flags
operator|&
name|CTL_LUN_FLAG_STOPPED
condition|)
name|lun
operator|->
name|flags
operator||=
name|CTL_LUN_STOPPED
expr_stmt|;
if|if
condition|(
name|be_lun
operator|->
name|flags
operator|&
name|CTL_LUN_FLAG_PRIMARY
condition|)
name|lun
operator|->
name|flags
operator||=
name|CTL_LUN_PRIMARY_SC
expr_stmt|;
name|value
operator|=
name|ctl_get_opt
argument_list|(
operator|&
name|be_lun
operator|->
name|options
argument_list|,
literal|"removable"
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"on"
argument_list|)
operator|==
literal|0
condition|)
name|lun
operator|->
name|flags
operator||=
name|CTL_LUN_REMOVABLE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|be_lun
operator|->
name|lun_type
operator|==
name|T_CDROM
condition|)
name|lun
operator|->
name|flags
operator||=
name|CTL_LUN_REMOVABLE
expr_stmt|;
name|lun
operator|->
name|ctl_softc
operator|=
name|ctl_softc
expr_stmt|;
ifdef|#
directive|ifdef
name|CTL_TIME_IO
name|lun
operator|->
name|last_busy
operator|=
name|getsbinuptime
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|TAILQ_INIT
argument_list|(
operator|&
name|lun
operator|->
name|ooa_queue
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|lun
operator|->
name|blocked_queue
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|lun
operator|->
name|error_list
argument_list|)
expr_stmt|;
name|lun
operator|->
name|ie_reported
operator|=
literal|1
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|lun
operator|->
name|ie_callout
argument_list|,
operator|&
name|lun
operator|->
name|lun_lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ctl_tpc_lun_init
argument_list|(
name|lun
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_REMOVABLE
condition|)
block|{
name|lun
operator|->
name|prevent
operator|=
name|malloc
argument_list|(
operator|(
name|CTL_MAX_INITIATORS
operator|+
literal|31
operator|)
operator|/
literal|32
operator|*
literal|4
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Initialize the mode and log page index. 	 */
name|ctl_init_page_index
argument_list|(
name|lun
argument_list|)
expr_stmt|;
name|ctl_init_log_page_index
argument_list|(
name|lun
argument_list|)
expr_stmt|;
comment|/* Setup statistics gathering */
ifdef|#
directive|ifdef
name|CTL_LEGACY_STATS
name|lun
operator|->
name|legacy_stats
operator|.
name|device_type
operator|=
name|be_lun
operator|->
name|lun_type
expr_stmt|;
name|lun
operator|->
name|legacy_stats
operator|.
name|lun_number
operator|=
name|lun_number
expr_stmt|;
name|lun
operator|->
name|legacy_stats
operator|.
name|blocksize
operator|=
name|be_lun
operator|->
name|blocksize
expr_stmt|;
if|if
condition|(
name|be_lun
operator|->
name|blocksize
operator|==
literal|0
condition|)
name|lun
operator|->
name|legacy_stats
operator|.
name|flags
operator|=
name|CTL_LUN_STATS_NO_BLOCKSIZE
expr_stmt|;
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|<
name|CTL_MAX_PORTS
condition|;
name|len
operator|++
control|)
name|lun
operator|->
name|legacy_stats
operator|.
name|ports
index|[
name|len
index|]
operator|.
name|targ_port
operator|=
name|len
expr_stmt|;
endif|#
directive|endif
comment|/* CTL_LEGACY_STATS */
name|lun
operator|->
name|stats
operator|.
name|item
operator|=
name|lun_number
expr_stmt|;
comment|/* 	 * Now, before we insert this lun on the lun list, set the lun 	 * inventory changed UA for all other luns. 	 */
name|mtx_lock
argument_list|(
operator|&
name|ctl_softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|nlun
argument_list|,
argument|&ctl_softc->lun_list
argument_list|,
argument|links
argument_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|nlun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctl_est_ua_all
argument_list|(
name|nlun
argument_list|,
operator|-
literal|1
argument_list|,
name|CTL_UA_LUN_CHANGE
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nlun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
block|}
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ctl_softc
operator|->
name|lun_list
argument_list|,
name|lun
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|ctl_softc
operator|->
name|ctl_luns
index|[
name|lun_number
index|]
operator|=
name|lun
expr_stmt|;
name|ctl_softc
operator|->
name|num_luns
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ctl_softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|lun
operator|->
name|be_lun
operator|->
name|lun_config_status
argument_list|(
name|lun
operator|->
name|be_lun
operator|->
name|be_lun
argument_list|,
name|CTL_LUN_CONFIG_OK
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Delete a LUN.  * Assumptions:  * - LUN has already been marked invalid and any pending I/O has been taken  *   care of.  */
end_comment

begin_function
specifier|static
name|int
name|ctl_free_lun
parameter_list|(
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|lun
operator|->
name|ctl_softc
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|nlun
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE
argument_list|(
operator|&
name|softc
operator|->
name|lun_list
argument_list|,
name|lun
argument_list|,
name|ctl_lun
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|ctl_clear_mask
argument_list|(
name|softc
operator|->
name|ctl_lun_mask
argument_list|,
name|lun
operator|->
name|lun
argument_list|)
expr_stmt|;
name|softc
operator|->
name|ctl_luns
index|[
name|lun
operator|->
name|lun
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|lun
operator|->
name|ooa_queue
argument_list|)
condition|)
name|panic
argument_list|(
literal|"Freeing a LUN %p with outstanding I/O!!\n"
argument_list|,
name|lun
argument_list|)
expr_stmt|;
name|softc
operator|->
name|num_luns
operator|--
expr_stmt|;
comment|/* 	 * Tell the backend to free resources, if this LUN has a backend. 	 */
name|atomic_subtract_int
argument_list|(
operator|&
name|lun
operator|->
name|be_lun
operator|->
name|be
operator|->
name|num_luns
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lun
operator|->
name|be_lun
operator|->
name|lun_shutdown
argument_list|(
name|lun
operator|->
name|be_lun
operator|->
name|be_lun
argument_list|)
expr_stmt|;
name|lun
operator|->
name|ie_reportcnt
operator|=
name|UINT32_MAX
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|lun
operator|->
name|ie_callout
argument_list|)
expr_stmt|;
name|ctl_tpc_lun_shutdown
argument_list|(
name|lun
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lun
operator|->
name|lun_devid
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_MAX_PORTS
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|lun
operator|->
name|pending_ua
index|[
name|i
index|]
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_MAX_PORTS
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|lun
operator|->
name|pr_keys
index|[
name|i
index|]
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lun
operator|->
name|write_buffer
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lun
operator|->
name|prevent
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_MALLOCED
condition|)
name|free
argument_list|(
name|lun
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|nlun
argument_list|,
argument|&softc->lun_list
argument_list|,
argument|links
argument_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|nlun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctl_est_ua_all
argument_list|(
name|nlun
argument_list|,
operator|-
literal|1
argument_list|,
name|CTL_UA_LUN_CHANGE
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nlun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_create_lun
parameter_list|(
name|struct
name|ctl_be_lun
modifier|*
name|be_lun
parameter_list|)
block|{
comment|/* 	 * ctl_alloc_lun() should handle all potential failure cases. 	 */
name|ctl_alloc_lun
argument_list|(
name|control_softc
argument_list|,
name|NULL
argument_list|,
name|be_lun
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ctl_add_lun
parameter_list|(
name|struct
name|ctl_be_lun
modifier|*
name|be_lun
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|control_softc
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|softc
operator|->
name|pending_lun_queue
argument_list|,
name|be_lun
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|softc
operator|->
name|pending_lun_queue
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_enable_lun
parameter_list|(
name|struct
name|ctl_be_lun
modifier|*
name|be_lun
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ctl_port
modifier|*
name|port
decl_stmt|,
modifier|*
name|nport
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|be_lun
operator|->
name|ctl_lun
expr_stmt|;
name|softc
operator|=
name|lun
operator|->
name|ctl_softc
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_DISABLED
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * eh?  Why did we get called if the LUN is already 		 * enabled? 		 */
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_LUN_DISABLED
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|port
argument_list|,
argument|&softc->port_list
argument_list|,
argument|links
argument_list|,
argument|nport
argument_list|)
block|{
if|if
condition|(
operator|(
name|port
operator|->
name|status
operator|&
name|CTL_PORT_STATUS_ONLINE
operator|)
operator|==
literal|0
operator|||
name|port
operator|->
name|lun_map
operator|!=
name|NULL
operator|||
name|port
operator|->
name|lun_enable
operator|==
name|NULL
condition|)
continue|continue;
comment|/* 		 * Drop the lock while we call the FETD's enable routine. 		 * This can lead to a callback into CTL (at least in the 		 * case of the internal initiator frontend. 		 */
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|retval
operator|=
name|port
operator|->
name|lun_enable
argument_list|(
name|port
operator|->
name|targ_lun_arg
argument_list|,
name|lun
operator|->
name|lun
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: FETD %s port %d returned error "
literal|"%d for lun_enable on lun %jd\n"
argument_list|,
name|__func__
argument_list|,
name|port
operator|->
name|port_name
argument_list|,
name|port
operator|->
name|targ_port
argument_list|,
name|retval
argument_list|,
operator|(
name|intmax_t
operator|)
name|lun
operator|->
name|lun
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|ctl_isc_announce_lun
argument_list|(
name|lun
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_disable_lun
parameter_list|(
name|struct
name|ctl_be_lun
modifier|*
name|be_lun
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ctl_port
modifier|*
name|port
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|be_lun
operator|->
name|ctl_lun
expr_stmt|;
name|softc
operator|=
name|lun
operator|->
name|ctl_softc
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_DISABLED
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|lun
operator|->
name|flags
operator||=
name|CTL_LUN_DISABLED
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|port
argument_list|,
argument|&softc->port_list
argument_list|,
argument|links
argument_list|)
block|{
if|if
condition|(
operator|(
name|port
operator|->
name|status
operator|&
name|CTL_PORT_STATUS_ONLINE
operator|)
operator|==
literal|0
operator|||
name|port
operator|->
name|lun_map
operator|!=
name|NULL
operator|||
name|port
operator|->
name|lun_disable
operator|==
name|NULL
condition|)
continue|continue;
comment|/* 		 * Drop the lock before we call the frontend's disable 		 * routine, to avoid lock order reversals. 		 * 		 * XXX KDM what happens if the frontend list changes while 		 * we're traversing it?  It's unlikely, but should be handled. 		 */
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|retval
operator|=
name|port
operator|->
name|lun_disable
argument_list|(
name|port
operator|->
name|targ_lun_arg
argument_list|,
name|lun
operator|->
name|lun
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: FETD %s port %d returned error "
literal|"%d for lun_disable on lun %jd\n"
argument_list|,
name|__func__
argument_list|,
name|port
operator|->
name|port_name
argument_list|,
name|port
operator|->
name|targ_port
argument_list|,
name|retval
argument_list|,
operator|(
name|intmax_t
operator|)
name|lun
operator|->
name|lun
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|ctl_isc_announce_lun
argument_list|(
name|lun
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_start_lun
parameter_list|(
name|struct
name|ctl_be_lun
modifier|*
name|be_lun
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|be_lun
operator|->
name|ctl_lun
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_LUN_STOPPED
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_stop_lun
parameter_list|(
name|struct
name|ctl_be_lun
modifier|*
name|be_lun
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|be_lun
operator|->
name|ctl_lun
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|lun
operator|->
name|flags
operator||=
name|CTL_LUN_STOPPED
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_lun_no_media
parameter_list|(
name|struct
name|ctl_be_lun
modifier|*
name|be_lun
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|be_lun
operator|->
name|ctl_lun
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|lun
operator|->
name|flags
operator||=
name|CTL_LUN_NO_MEDIA
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_lun_has_media
parameter_list|(
name|struct
name|ctl_be_lun
modifier|*
name|be_lun
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|be_lun
operator|->
name|ctl_lun
decl_stmt|;
name|union
name|ctl_ha_msg
name|msg
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|lun
operator|->
name|flags
operator|&=
operator|~
operator|(
name|CTL_LUN_NO_MEDIA
operator||
name|CTL_LUN_EJECTED
operator|)
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_REMOVABLE
condition|)
name|ctl_est_ua_all
argument_list|(
name|lun
argument_list|,
operator|-
literal|1
argument_list|,
name|CTL_UA_MEDIUM_CHANGE
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_REMOVABLE
operator|)
operator|&&
name|lun
operator|->
name|ctl_softc
operator|->
name|ha_mode
operator|==
name|CTL_HA_MODE_XFER
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|msg
operator|.
name|ua
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
operator|.
name|ua
argument_list|)
argument_list|)
expr_stmt|;
name|msg
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_UA
expr_stmt|;
name|msg
operator|.
name|hdr
operator|.
name|nexus
operator|.
name|initid
operator|=
operator|-
literal|1
expr_stmt|;
name|msg
operator|.
name|hdr
operator|.
name|nexus
operator|.
name|targ_port
operator|=
operator|-
literal|1
expr_stmt|;
name|msg
operator|.
name|hdr
operator|.
name|nexus
operator|.
name|targ_lun
operator|=
name|lun
operator|->
name|lun
expr_stmt|;
name|msg
operator|.
name|hdr
operator|.
name|nexus
operator|.
name|targ_mapped_lun
operator|=
name|lun
operator|->
name|lun
expr_stmt|;
name|msg
operator|.
name|ua
operator|.
name|ua_all
operator|=
literal|1
expr_stmt|;
name|msg
operator|.
name|ua
operator|.
name|ua_set
operator|=
literal|1
expr_stmt|;
name|msg
operator|.
name|ua
operator|.
name|ua_type
operator|=
name|CTL_UA_MEDIUM_CHANGE
expr_stmt|;
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
operator|.
name|ua
argument_list|)
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_lun_ejected
parameter_list|(
name|struct
name|ctl_be_lun
modifier|*
name|be_lun
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|be_lun
operator|->
name|ctl_lun
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|lun
operator|->
name|flags
operator||=
name|CTL_LUN_EJECTED
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_lun_primary
parameter_list|(
name|struct
name|ctl_be_lun
modifier|*
name|be_lun
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|be_lun
operator|->
name|ctl_lun
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|lun
operator|->
name|flags
operator||=
name|CTL_LUN_PRIMARY_SC
expr_stmt|;
name|ctl_est_ua_all
argument_list|(
name|lun
argument_list|,
operator|-
literal|1
argument_list|,
name|CTL_UA_ASYM_ACC_CHANGE
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctl_isc_announce_lun
argument_list|(
name|lun
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_lun_secondary
parameter_list|(
name|struct
name|ctl_be_lun
modifier|*
name|be_lun
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|be_lun
operator|->
name|ctl_lun
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_LUN_PRIMARY_SC
expr_stmt|;
name|ctl_est_ua_all
argument_list|(
name|lun
argument_list|,
operator|-
literal|1
argument_list|,
name|CTL_UA_ASYM_ACC_CHANGE
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctl_isc_announce_lun
argument_list|(
name|lun
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_invalidate_lun
parameter_list|(
name|struct
name|ctl_be_lun
modifier|*
name|be_lun
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|be_lun
operator|->
name|ctl_lun
expr_stmt|;
name|softc
operator|=
name|lun
operator|->
name|ctl_softc
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
comment|/* 	 * The LUN needs to be disabled before it can be marked invalid. 	 */
if|if
condition|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_DISABLED
operator|)
operator|==
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Mark the LUN invalid. 	 */
name|lun
operator|->
name|flags
operator||=
name|CTL_LUN_INVALID
expr_stmt|;
comment|/* 	 * If there is nothing in the OOA queue, go ahead and free the LUN. 	 * If we have something in the OOA queue, we'll free it when the 	 * last I/O completes. 	 */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|lun
operator|->
name|ooa_queue
argument_list|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|ctl_free_lun
argument_list|(
name|lun
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
block|}
else|else
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ctl_lun_capacity_changed
parameter_list|(
name|struct
name|ctl_be_lun
modifier|*
name|be_lun
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|be_lun
operator|->
name|ctl_lun
decl_stmt|;
name|union
name|ctl_ha_msg
name|msg
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctl_est_ua_all
argument_list|(
name|lun
argument_list|,
operator|-
literal|1
argument_list|,
name|CTL_UA_CAPACITY_CHANGE
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|ctl_softc
operator|->
name|ha_mode
operator|==
name|CTL_HA_MODE_XFER
condition|)
block|{
comment|/* Send msg to other side. */
name|bzero
argument_list|(
operator|&
name|msg
operator|.
name|ua
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
operator|.
name|ua
argument_list|)
argument_list|)
expr_stmt|;
name|msg
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_UA
expr_stmt|;
name|msg
operator|.
name|hdr
operator|.
name|nexus
operator|.
name|initid
operator|=
operator|-
literal|1
expr_stmt|;
name|msg
operator|.
name|hdr
operator|.
name|nexus
operator|.
name|targ_port
operator|=
operator|-
literal|1
expr_stmt|;
name|msg
operator|.
name|hdr
operator|.
name|nexus
operator|.
name|targ_lun
operator|=
name|lun
operator|->
name|lun
expr_stmt|;
name|msg
operator|.
name|hdr
operator|.
name|nexus
operator|.
name|targ_mapped_lun
operator|=
name|lun
operator|->
name|lun
expr_stmt|;
name|msg
operator|.
name|ua
operator|.
name|ua_all
operator|=
literal|1
expr_stmt|;
name|msg
operator|.
name|ua
operator|.
name|ua_set
operator|=
literal|1
expr_stmt|;
name|msg
operator|.
name|ua
operator|.
name|ua_type
operator|=
name|CTL_UA_CAPACITY_CHANGE
expr_stmt|;
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
operator|.
name|ua
argument_list|)
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Backend "memory move is complete" callback for requests that never  * make it down to say RAIDCore's configuration code.  */
end_comment

begin_function
name|int
name|ctl_config_move_done
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_config_move_done\n"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|io
operator|->
name|io_hdr
operator|.
name|io_type
operator|==
name|CTL_IO_SCSI
argument_list|,
operator|(
literal|"Config I/O type isn't CTL_IO_SCSI (%d)!"
operator|,
name|io
operator|->
name|io_hdr
operator|.
name|io_type
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|port_status
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|==
name|CTL_STATUS_NONE
operator|||
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|==
name|CTL_SUCCESS
operator|)
condition|)
block|{
name|ctl_set_internal_failure
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*retry_count*/
name|io
operator|->
name|io_hdr
operator|.
name|port_status
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|io
operator|->
name|scsiio
operator|.
name|kern_data_resid
operator|!=
literal|0
operator|&&
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_DATA_MASK
operator|)
operator|==
name|CTL_FLAG_DATA_OUT
operator|&&
operator|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|==
name|CTL_STATUS_NONE
operator|||
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|==
name|CTL_SUCCESS
operator|)
condition|)
block|{
name|ctl_set_invalid_field_ciu
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctl_debug
operator|&
name|CTL_DEBUG_CDB_DATA
condition|)
name|ctl_data_print
argument_list|(
name|io
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_DATA_MASK
operator|)
operator|==
name|CTL_FLAG_DATA_IN
operator|)
operator|||
operator|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|!=
name|CTL_STATUS_NONE
operator|&&
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|!=
name|CTL_SUCCESS
operator|)
operator|||
operator|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ABORT
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* 		 * XXX KDM just assuming a single pointer here, and not a 		 * S/G list.  If we start using S/G lists for config data, 		 * we'll need to know how to clean them up here as well. 		 */
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ALLOCATED
condition|)
name|free
argument_list|(
name|io
operator|->
name|scsiio
operator|.
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|retval
operator|=
name|CTL_RETVAL_COMPLETE
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * XXX KDM now we need to continue data movement.  Some 		 * options: 		 * - call ctl_scsiio() again?  We don't do this for data 		 *   writes, because for those at least we know ahead of 		 *   time where the write will go and how long it is.  For 		 *   config writes, though, that information is largely 		 *   contained within the write itself, thus we need to 		 *   parse out the data again. 		 * 		 * - Call some other function once the data is in? 		 */
comment|/* 		 * XXX KDM call ctl_scsiio() again for now, and check flag 		 * bits to see whether we're allocated or not. 		 */
name|retval
operator|=
name|ctl_scsiio
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This gets called by a backend driver when it is done with a  * data_submit method.  */
end_comment

begin_function
name|void
name|ctl_data_submit_done
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
comment|/* 	 * If the IO_CONT flag is set, we need to call the supplied 	 * function to continue processing the I/O, instead of completing 	 * the I/O just yet. 	 * 	 * If there is an error, though, we don't want to keep processing. 	 * Instead, just send status back to the initiator. 	 */
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_IO_CONT
operator|)
operator|&&
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ABORT
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|==
name|CTL_STATUS_NONE
operator|||
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|==
name|CTL_SUCCESS
operator|)
condition|)
block|{
name|io
operator|->
name|scsiio
operator|.
name|io_cont
argument_list|(
name|io
argument_list|)
expr_stmt|;
return|return;
block|}
name|ctl_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This gets called by a backend driver when it is done with a  * configuration write.  */
end_comment

begin_function
name|void
name|ctl_config_write_done
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|uint8_t
modifier|*
name|buf
decl_stmt|;
comment|/* 	 * If the IO_CONT flag is set, we need to call the supplied 	 * function to continue processing the I/O, instead of completing 	 * the I/O just yet. 	 * 	 * If there is an error, though, we don't want to keep processing. 	 * Instead, just send status back to the initiator. 	 */
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_IO_CONT
operator|)
operator|&&
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ABORT
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|==
name|CTL_STATUS_NONE
operator|||
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|==
name|CTL_SUCCESS
operator|)
condition|)
block|{
name|io
operator|->
name|scsiio
operator|.
name|io_cont
argument_list|(
name|io
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Since a configuration write can be done for commands that actually 	 * have data allocated, like write buffer, and commands that have 	 * no data, like start/stop unit, we need to check here. 	 */
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ALLOCATED
condition|)
name|buf
operator|=
name|io
operator|->
name|scsiio
operator|.
name|kern_data_ptr
expr_stmt|;
else|else
name|buf
operator|=
name|NULL
expr_stmt|;
name|ctl_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
condition|)
name|free
argument_list|(
name|buf
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ctl_config_read_done
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|uint8_t
modifier|*
name|buf
decl_stmt|;
comment|/* 	 * If there is some error -- we are done, skip data transfer. 	 */
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ABORT
operator|)
operator|!=
literal|0
operator|||
operator|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|!=
name|CTL_STATUS_NONE
operator|&&
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|!=
name|CTL_SUCCESS
operator|)
condition|)
block|{
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ALLOCATED
condition|)
name|buf
operator|=
name|io
operator|->
name|scsiio
operator|.
name|kern_data_ptr
expr_stmt|;
else|else
name|buf
operator|=
name|NULL
expr_stmt|;
name|ctl_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
condition|)
name|free
argument_list|(
name|buf
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If the IO_CONT flag is set, we need to call the supplied 	 * function to continue processing the I/O, instead of completing 	 * the I/O just yet. 	 */
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_IO_CONT
condition|)
block|{
name|io
operator|->
name|scsiio
operator|.
name|io_cont
argument_list|(
name|io
argument_list|)
expr_stmt|;
return|return;
block|}
name|ctl_datamove
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * SCSI release command.  */
end_comment

begin_function
name|int
name|ctl_scsi_release
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
name|CTL_LUN
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|uint32_t
name|residx
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_scsi_release\n"
operator|)
argument_list|)
expr_stmt|;
name|residx
operator|=
name|ctl_get_initindex
argument_list|(
operator|&
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
argument_list|)
expr_stmt|;
comment|/* 	 * XXX KDM right now, we only support LUN reservation.  We don't 	 * support 3rd party reservations, or extent reservations, which 	 * might actually need the parameter list.  If we've gotten this 	 * far, we've got a LUN reservation.  Anything else got kicked out 	 * above.  So, according to SPC, ignore the length. 	 */
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
comment|/* 	 * According to SPC, it is not an error for an intiator to attempt 	 * to release a reservation on a LUN that isn't reserved, or that 	 * is reserved by another initiator.  The reservation can only be 	 * released, though, by the initiator who made it or by one of 	 * several reset type events. 	 */
if|if
condition|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_RESERVED
operator|)
operator|&&
operator|(
name|lun
operator|->
name|res_idx
operator|==
name|residx
operator|)
condition|)
name|lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_LUN_RESERVED
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_scsi_reserve
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
name|CTL_LUN
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|uint32_t
name|residx
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_reserve\n"
operator|)
argument_list|)
expr_stmt|;
name|residx
operator|=
name|ctl_get_initindex
argument_list|(
operator|&
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
argument_list|)
expr_stmt|;
comment|/* 	 * XXX KDM right now, we only support LUN reservation.  We don't 	 * support 3rd party reservations, or extent reservations, which 	 * might actually need the parameter list.  If we've gotten this 	 * far, we've got a LUN reservation.  Anything else got kicked out 	 * above.  So, according to SPC, ignore the length. 	 */
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_RESERVED
operator|)
operator|&&
operator|(
name|lun
operator|->
name|res_idx
operator|!=
name|residx
operator|)
condition|)
block|{
name|ctl_set_reservation_conflict
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
comment|/* SPC-3 exceptions to SPC-2 RESERVE and RELEASE behavior. */
if|if
condition|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_PR_RESERVED
condition|)
block|{
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|lun
operator|->
name|flags
operator||=
name|CTL_LUN_RESERVED
expr_stmt|;
name|lun
operator|->
name|res_idx
operator|=
name|residx
expr_stmt|;
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|bailout
label|:
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_start_stop
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
name|CTL_LUN
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|struct
name|scsi_start_stop_unit
modifier|*
name|cdb
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_start_stop\n"
operator|)
argument_list|)
expr_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_start_stop_unit
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
if|if
condition|(
operator|(
name|cdb
operator|->
name|how
operator|&
name|SSS_PC_MASK
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_PR_RESERVED
operator|)
operator|&&
operator|(
name|cdb
operator|->
name|how
operator|&
name|SSS_START
operator|)
operator|==
literal|0
condition|)
block|{
name|uint32_t
name|residx
decl_stmt|;
name|residx
operator|=
name|ctl_get_initindex
argument_list|(
operator|&
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl_get_prkey
argument_list|(
name|lun
argument_list|,
name|residx
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|lun
operator|->
name|pr_res_idx
operator|!=
name|residx
operator|&&
name|lun
operator|->
name|pr_res_type
operator|<
literal|4
operator|)
condition|)
block|{
name|ctl_set_reservation_conflict
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|cdb
operator|->
name|how
operator|&
name|SSS_LOEJ
operator|)
operator|&&
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_REMOVABLE
operator|)
operator|==
literal|0
condition|)
block|{
name|ctl_set_invalid_field
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|4
argument_list|,
comment|/*bit_valid*/
literal|1
argument_list|,
comment|/*bit*/
literal|1
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|cdb
operator|->
name|how
operator|&
name|SSS_START
operator|)
operator|==
literal|0
operator|&&
operator|(
name|cdb
operator|->
name|how
operator|&
name|SSS_LOEJ
operator|)
operator|&&
name|lun
operator|->
name|prevent_count
operator|>
literal|0
condition|)
block|{
comment|/* "Medium removal prevented" */
name|ctl_set_sense
argument_list|(
name|ctsio
argument_list|,
comment|/*current_error*/
literal|1
argument_list|,
comment|/*sense_key*/
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_NO_MEDIA
operator|)
condition|?
name|SSD_KEY_NOT_READY
else|:
name|SSD_KEY_ILLEGAL_REQUEST
argument_list|,
comment|/*asc*/
literal|0x53
argument_list|,
comment|/*ascq*/
literal|0x02
argument_list|,
name|SSD_ELEM_NONE
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
block|}
name|retval
operator|=
name|lun
operator|->
name|backend
operator|->
name|config_write
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_prevent_allow
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
name|CTL_LUN
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|struct
name|scsi_prevent
modifier|*
name|cdb
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|uint32_t
name|initidx
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_prevent_allow\n"
operator|)
argument_list|)
expr_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_prevent
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
if|if
condition|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_REMOVABLE
operator|)
operator|==
literal|0
operator|||
name|lun
operator|->
name|prevent
operator|==
name|NULL
condition|)
block|{
name|ctl_set_invalid_opcode
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
name|initidx
operator|=
name|ctl_get_initindex
argument_list|(
operator|&
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cdb
operator|->
name|how
operator|&
name|PR_PREVENT
operator|)
operator|&&
name|ctl_is_set
argument_list|(
name|lun
operator|->
name|prevent
argument_list|,
name|initidx
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ctl_set_mask
argument_list|(
name|lun
operator|->
name|prevent
argument_list|,
name|initidx
argument_list|)
expr_stmt|;
name|lun
operator|->
name|prevent_count
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|cdb
operator|->
name|how
operator|&
name|PR_PREVENT
operator|)
operator|==
literal|0
operator|&&
name|ctl_is_set
argument_list|(
name|lun
operator|->
name|prevent
argument_list|,
name|initidx
argument_list|)
condition|)
block|{
name|ctl_clear_mask
argument_list|(
name|lun
operator|->
name|prevent
argument_list|,
name|initidx
argument_list|)
expr_stmt|;
name|lun
operator|->
name|prevent_count
operator|--
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|retval
operator|=
name|lun
operator|->
name|backend
operator|->
name|config_write
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We support the SYNCHRONIZE CACHE command (10 and 16 byte versions), but  * we don't really do anything with the LBA and length fields if the user  * passes them in.  Instead we'll just flush out the cache for the entire  * LUN.  */
end_comment

begin_function
name|int
name|ctl_sync_cache
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
name|CTL_LUN
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|struct
name|ctl_lba_len_flags
modifier|*
name|lbalen
decl_stmt|;
name|uint64_t
name|starting_lba
decl_stmt|;
name|uint32_t
name|block_count
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|uint8_t
name|byte2
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_sync_cache\n"
operator|)
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|ctsio
operator|->
name|cdb
index|[
literal|0
index|]
condition|)
block|{
case|case
name|SYNCHRONIZE_CACHE
case|:
block|{
name|struct
name|scsi_sync_cache
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_sync_cache
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|starting_lba
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|begin_lba
argument_list|)
expr_stmt|;
name|block_count
operator|=
name|scsi_2btoul
argument_list|(
name|cdb
operator|->
name|lb_count
argument_list|)
expr_stmt|;
name|byte2
operator|=
name|cdb
operator|->
name|byte2
expr_stmt|;
break|break;
block|}
case|case
name|SYNCHRONIZE_CACHE_16
case|:
block|{
name|struct
name|scsi_sync_cache_16
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_sync_cache_16
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|starting_lba
operator|=
name|scsi_8btou64
argument_list|(
name|cdb
operator|->
name|begin_lba
argument_list|)
expr_stmt|;
name|block_count
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|lb_count
argument_list|)
expr_stmt|;
name|byte2
operator|=
name|cdb
operator|->
name|byte2
expr_stmt|;
break|break;
block|}
default|default:
name|ctl_set_invalid_opcode
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
break|break;
comment|/* NOTREACHED */
block|}
comment|/* 	 * We check the LBA and length, but don't do anything with them. 	 * A SYNCHRONIZE CACHE will cause the entire cache for this lun to 	 * get flushed.  This check will just help satisfy anyone who wants 	 * to see an error for an out of range LBA. 	 */
if|if
condition|(
operator|(
name|starting_lba
operator|+
name|block_count
operator|)
operator|>
operator|(
name|lun
operator|->
name|be_lun
operator|->
name|maxlba
operator|+
literal|1
operator|)
condition|)
block|{
name|ctl_set_lba_out_of_range
argument_list|(
name|ctsio
argument_list|,
name|MAX
argument_list|(
name|starting_lba
argument_list|,
name|lun
operator|->
name|be_lun
operator|->
name|maxlba
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|lbalen
operator|=
operator|(
expr|struct
name|ctl_lba_len_flags
operator|*
operator|)
operator|&
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LBA_LEN
index|]
expr_stmt|;
name|lbalen
operator|->
name|lba
operator|=
name|starting_lba
expr_stmt|;
name|lbalen
operator|->
name|len
operator|=
name|block_count
expr_stmt|;
name|lbalen
operator|->
name|flags
operator|=
name|byte2
expr_stmt|;
name|retval
operator|=
name|lun
operator|->
name|backend
operator|->
name|config_write
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
name|bailout
label|:
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_format
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|scsi_format
modifier|*
name|cdb
decl_stmt|;
name|int
name|length
decl_stmt|,
name|defect_list_len
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_format\n"
operator|)
argument_list|)
expr_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_format
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SF_FMTDATA
condition|)
block|{
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SF_LONGLIST
condition|)
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_format_header_long
argument_list|)
expr_stmt|;
else|else
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_format_header_short
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ALLOCATED
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|length
operator|>
literal|0
operator|)
condition|)
block|{
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
name|length
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|length
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|length
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
name|defect_list_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SF_FMTDATA
condition|)
block|{
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SF_LONGLIST
condition|)
block|{
name|struct
name|scsi_format_header_long
modifier|*
name|header
decl_stmt|;
name|header
operator|=
operator|(
expr|struct
name|scsi_format_header_long
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|defect_list_len
operator|=
name|scsi_4btoul
argument_list|(
name|header
operator|->
name|defect_list_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|defect_list_len
operator|!=
literal|0
condition|)
block|{
name|ctl_set_invalid_field
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|0
argument_list|,
comment|/*field*/
literal|2
argument_list|,
comment|/*bit_valid*/
literal|0
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
block|}
else|else
block|{
name|struct
name|scsi_format_header_short
modifier|*
name|header
decl_stmt|;
name|header
operator|=
operator|(
expr|struct
name|scsi_format_header_short
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|defect_list_len
operator|=
name|scsi_2btoul
argument_list|(
name|header
operator|->
name|defect_list_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|defect_list_len
operator|!=
literal|0
condition|)
block|{
name|ctl_set_invalid_field
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|0
argument_list|,
comment|/*field*/
literal|2
argument_list|,
comment|/*bit_valid*/
literal|0
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
block|}
block|}
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|bailout
label|:
if|if
condition|(
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ALLOCATED
condition|)
block|{
name|free
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator|&=
operator|~
name|CTL_FLAG_ALLOCATED
expr_stmt|;
block|}
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_read_buffer
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
name|CTL_LUN
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|uint64_t
name|buffer_offset
decl_stmt|;
name|uint32_t
name|len
decl_stmt|;
name|uint8_t
name|byte2
decl_stmt|;
specifier|static
name|uint8_t
name|descr
index|[
literal|4
index|]
decl_stmt|;
specifier|static
name|uint8_t
name|echo_descr
index|[
literal|4
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_read_buffer\n"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ctsio
operator|->
name|cdb
index|[
literal|0
index|]
condition|)
block|{
case|case
name|READ_BUFFER
case|:
block|{
name|struct
name|scsi_read_buffer
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_read_buffer
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|buffer_offset
operator|=
name|scsi_3btoul
argument_list|(
name|cdb
operator|->
name|offset
argument_list|)
expr_stmt|;
name|len
operator|=
name|scsi_3btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
name|byte2
operator|=
name|cdb
operator|->
name|byte2
expr_stmt|;
break|break;
block|}
case|case
name|READ_BUFFER_16
case|:
block|{
name|struct
name|scsi_read_buffer_16
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_read_buffer_16
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|buffer_offset
operator|=
name|scsi_8btou64
argument_list|(
name|cdb
operator|->
name|offset
argument_list|)
expr_stmt|;
name|len
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
name|byte2
operator|=
name|cdb
operator|->
name|byte2
expr_stmt|;
break|break;
block|}
default|default:
comment|/* This shouldn't happen. */
name|ctl_set_invalid_opcode
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
if|if
condition|(
name|buffer_offset
operator|>
name|CTL_WRITE_BUFFER_SIZE
operator|||
name|buffer_offset
operator|+
name|len
operator|>
name|CTL_WRITE_BUFFER_SIZE
condition|)
block|{
name|ctl_set_invalid_field
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|6
argument_list|,
comment|/*bit_valid*/
literal|0
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|byte2
operator|&
name|RWB_MODE
operator|)
operator|==
name|RWB_MODE_DESCR
condition|)
block|{
name|descr
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|scsi_ulto3b
argument_list|(
name|CTL_WRITE_BUFFER_SIZE
argument_list|,
operator|&
name|descr
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|descr
expr_stmt|;
name|len
operator|=
name|min
argument_list|(
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|descr
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|byte2
operator|&
name|RWB_MODE
operator|)
operator|==
name|RWB_MODE_ECHO_DESCR
condition|)
block|{
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|echo_descr
expr_stmt|;
name|len
operator|=
name|min
argument_list|(
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|echo_descr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|lun
operator|->
name|write_buffer
operator|==
name|NULL
condition|)
block|{
name|lun
operator|->
name|write_buffer
operator|=
name|malloc
argument_list|(
name|CTL_WRITE_BUFFER_SIZE
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|lun
operator|->
name|write_buffer
operator|+
name|buffer_offset
expr_stmt|;
block|}
name|ctsio
operator|->
name|kern_data_len
operator|=
name|len
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|len
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_write_buffer
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
name|CTL_LUN
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|struct
name|scsi_write_buffer
modifier|*
name|cdb
decl_stmt|;
name|int
name|buffer_offset
decl_stmt|,
name|len
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_write_buffer\n"
operator|)
argument_list|)
expr_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_write_buffer
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|len
operator|=
name|scsi_3btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
name|buffer_offset
operator|=
name|scsi_3btoul
argument_list|(
name|cdb
operator|->
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer_offset
operator|+
name|len
operator|>
name|CTL_WRITE_BUFFER_SIZE
condition|)
block|{
name|ctl_set_invalid_field
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|6
argument_list|,
comment|/*bit_valid*/
literal|0
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
comment|/* 	 * If we've got a kernel request that hasn't been malloced yet, 	 * malloc it and tell the caller the data buffer is here. 	 */
if|if
condition|(
operator|(
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ALLOCATED
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|lun
operator|->
name|write_buffer
operator|==
name|NULL
condition|)
block|{
name|lun
operator|->
name|write_buffer
operator|=
name|malloc
argument_list|(
name|CTL_WRITE_BUFFER_SIZE
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|lun
operator|->
name|write_buffer
operator|+
name|buffer_offset
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|len
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|len
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_write_same
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
name|CTL_LUN
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|struct
name|ctl_lba_len_flags
modifier|*
name|lbalen
decl_stmt|;
name|uint64_t
name|lba
decl_stmt|;
name|uint32_t
name|num_blocks
decl_stmt|;
name|int
name|len
decl_stmt|,
name|retval
decl_stmt|;
name|uint8_t
name|byte2
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_write_same\n"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ctsio
operator|->
name|cdb
index|[
literal|0
index|]
condition|)
block|{
case|case
name|WRITE_SAME_10
case|:
block|{
name|struct
name|scsi_write_same_10
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_write_same_10
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|lba
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
name|num_blocks
operator|=
name|scsi_2btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
name|byte2
operator|=
name|cdb
operator|->
name|byte2
expr_stmt|;
break|break;
block|}
case|case
name|WRITE_SAME_16
case|:
block|{
name|struct
name|scsi_write_same_16
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_write_same_16
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|lba
operator|=
name|scsi_8btou64
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
name|num_blocks
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
name|byte2
operator|=
name|cdb
operator|->
name|byte2
expr_stmt|;
break|break;
block|}
default|default:
comment|/* 		 * We got a command we don't support.  This shouldn't 		 * happen, commands should be filtered out above us. 		 */
name|ctl_set_invalid_opcode
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
break|break;
comment|/* NOTREACHED */
block|}
comment|/* ANCHOR flag can be used only together with UNMAP */
if|if
condition|(
operator|(
name|byte2
operator|&
name|SWS_UNMAP
operator|)
operator|==
literal|0
operator|&&
operator|(
name|byte2
operator|&
name|SWS_ANCHOR
operator|)
operator|!=
literal|0
condition|)
block|{
name|ctl_set_invalid_field
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|1
argument_list|,
comment|/*bit_valid*/
literal|1
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
comment|/* 	 * The first check is to make sure we're in bounds, the second 	 * check is to catch wrap-around problems.  If the lba + num blocks 	 * is less than the lba, then we've wrapped around and the block 	 * range is invalid anyway. 	 */
if|if
condition|(
operator|(
operator|(
name|lba
operator|+
name|num_blocks
operator|)
operator|>
operator|(
name|lun
operator|->
name|be_lun
operator|->
name|maxlba
operator|+
literal|1
operator|)
operator|)
operator|||
operator|(
operator|(
name|lba
operator|+
name|num_blocks
operator|)
operator|<
name|lba
operator|)
condition|)
block|{
name|ctl_set_lba_out_of_range
argument_list|(
name|ctsio
argument_list|,
name|MAX
argument_list|(
name|lba
argument_list|,
name|lun
operator|->
name|be_lun
operator|->
name|maxlba
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
comment|/* Zero number of blocks means "to the last logical block" */
if|if
condition|(
name|num_blocks
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|lun
operator|->
name|be_lun
operator|->
name|maxlba
operator|+
literal|1
operator|)
operator|-
name|lba
operator|>
name|UINT32_MAX
condition|)
block|{
name|ctl_set_invalid_field
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|0
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|0
argument_list|,
comment|/*bit_valid*/
literal|0
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
name|num_blocks
operator|=
operator|(
name|lun
operator|->
name|be_lun
operator|->
name|maxlba
operator|+
literal|1
operator|)
operator|-
name|lba
expr_stmt|;
block|}
name|len
operator|=
name|lun
operator|->
name|be_lun
operator|->
name|blocksize
expr_stmt|;
comment|/* 	 * If we've got a kernel request that hasn't been malloced yet, 	 * malloc it and tell the caller the data buffer is here. 	 */
if|if
condition|(
operator|(
name|byte2
operator|&
name|SWS_NDOB
operator|)
operator|==
literal|0
operator|&&
operator|(
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ALLOCATED
operator|)
operator|==
literal|0
condition|)
block|{
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
name|len
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|len
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|len
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
name|lbalen
operator|=
operator|(
expr|struct
name|ctl_lba_len_flags
operator|*
operator|)
operator|&
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LBA_LEN
index|]
expr_stmt|;
name|lbalen
operator|->
name|lba
operator|=
name|lba
expr_stmt|;
name|lbalen
operator|->
name|len
operator|=
name|num_blocks
expr_stmt|;
name|lbalen
operator|->
name|flags
operator|=
name|byte2
expr_stmt|;
name|retval
operator|=
name|lun
operator|->
name|backend
operator|->
name|config_write
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_unmap
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
name|CTL_LUN
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|struct
name|scsi_unmap
modifier|*
name|cdb
decl_stmt|;
name|struct
name|ctl_ptr_len_flags
modifier|*
name|ptrlen
decl_stmt|;
name|struct
name|scsi_unmap_header
modifier|*
name|hdr
decl_stmt|;
name|struct
name|scsi_unmap_desc
modifier|*
name|buf
decl_stmt|,
modifier|*
name|end
decl_stmt|,
modifier|*
name|endnz
decl_stmt|,
modifier|*
name|range
decl_stmt|;
name|uint64_t
name|lba
decl_stmt|;
name|uint32_t
name|num_blocks
decl_stmt|;
name|int
name|len
decl_stmt|,
name|retval
decl_stmt|;
name|uint8_t
name|byte2
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_unmap\n"
operator|)
argument_list|)
expr_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_unmap
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|len
operator|=
name|scsi_2btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
name|byte2
operator|=
name|cdb
operator|->
name|byte2
expr_stmt|;
comment|/* 	 * If we've got a kernel request that hasn't been malloced yet, 	 * malloc it and tell the caller the data buffer is here. 	 */
if|if
condition|(
operator|(
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ALLOCATED
operator|)
operator|==
literal|0
condition|)
block|{
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
name|len
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|len
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|len
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
name|len
operator|=
name|ctsio
operator|->
name|kern_total_len
operator|-
name|ctsio
operator|->
name|kern_data_resid
expr_stmt|;
name|hdr
operator|=
operator|(
expr|struct
name|scsi_unmap_header
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|||
name|len
operator|<
operator|(
name|scsi_2btoul
argument_list|(
name|hdr
operator|->
name|length
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|hdr
operator|->
name|length
argument_list|)
operator|)
operator|||
name|len
operator|<
operator|(
name|scsi_2btoul
argument_list|(
name|hdr
operator|->
name|desc_length
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|)
operator|||
name|scsi_2btoul
argument_list|(
name|hdr
operator|->
name|desc_length
argument_list|)
operator|%
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ctl_set_invalid_field
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|0
argument_list|,
comment|/*command*/
literal|0
argument_list|,
comment|/*field*/
literal|0
argument_list|,
comment|/*bit_valid*/
literal|0
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|len
operator|=
name|scsi_2btoul
argument_list|(
name|hdr
operator|->
name|desc_length
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
expr|struct
name|scsi_unmap_desc
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
expr_stmt|;
name|end
operator|=
name|buf
operator|+
name|len
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
expr_stmt|;
name|endnz
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|range
operator|=
name|buf
init|;
name|range
operator|<
name|end
condition|;
name|range
operator|++
control|)
block|{
name|lba
operator|=
name|scsi_8btou64
argument_list|(
name|range
operator|->
name|lba
argument_list|)
expr_stmt|;
name|num_blocks
operator|=
name|scsi_4btoul
argument_list|(
name|range
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|lba
operator|+
name|num_blocks
operator|)
operator|>
operator|(
name|lun
operator|->
name|be_lun
operator|->
name|maxlba
operator|+
literal|1
operator|)
operator|)
operator|||
operator|(
operator|(
name|lba
operator|+
name|num_blocks
operator|)
operator|<
name|lba
operator|)
condition|)
block|{
name|ctl_set_lba_out_of_range
argument_list|(
name|ctsio
argument_list|,
name|MAX
argument_list|(
name|lba
argument_list|,
name|lun
operator|->
name|be_lun
operator|->
name|maxlba
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
if|if
condition|(
name|num_blocks
operator|!=
literal|0
condition|)
name|endnz
operator|=
name|range
operator|+
literal|1
expr_stmt|;
block|}
comment|/* 	 * Block backend can not handle zero last range. 	 * Filter it out and return if there is nothing left. 	 */
name|len
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|endnz
operator|-
operator|(
name|uint8_t
operator|*
operator|)
name|buf
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ptrlen
operator|=
operator|(
expr|struct
name|ctl_ptr_len_flags
operator|*
operator|)
operator|&
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LBA_LEN
index|]
expr_stmt|;
name|ptrlen
operator|->
name|ptr
operator|=
operator|(
name|void
operator|*
operator|)
name|buf
expr_stmt|;
name|ptrlen
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|ptrlen
operator|->
name|flags
operator|=
name|byte2
expr_stmt|;
name|ctl_check_blocked
argument_list|(
name|lun
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|retval
operator|=
name|lun
operator|->
name|backend
operator|->
name|config_write
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
name|done
label|:
if|if
condition|(
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ALLOCATED
condition|)
block|{
name|free
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator|&=
operator|~
name|CTL_FLAG_ALLOCATED
expr_stmt|;
block|}
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_default_page_handler
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|struct
name|ctl_page_index
modifier|*
name|page_index
parameter_list|,
name|uint8_t
modifier|*
name|page_ptr
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
name|CTL_LUN
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|uint8_t
modifier|*
name|current_cp
decl_stmt|;
name|int
name|set_ua
decl_stmt|;
name|uint32_t
name|initidx
decl_stmt|;
name|initidx
operator|=
name|ctl_get_initindex
argument_list|(
operator|&
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
argument_list|)
expr_stmt|;
name|set_ua
operator|=
literal|0
expr_stmt|;
name|current_cp
operator|=
operator|(
name|page_index
operator|->
name|page_data
operator|+
operator|(
name|page_index
operator|->
name|page_len
operator|*
name|CTL_PAGE_CURRENT
operator|)
operator|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|current_cp
argument_list|,
name|page_ptr
argument_list|,
name|page_index
operator|->
name|page_len
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
name|current_cp
argument_list|,
name|page_ptr
argument_list|,
name|page_index
operator|->
name|page_len
argument_list|)
expr_stmt|;
name|set_ua
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|set_ua
operator|!=
literal|0
condition|)
name|ctl_est_ua_all
argument_list|(
name|lun
argument_list|,
name|initidx
argument_list|,
name|CTL_UA_MODE_CHANGE
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_ua
condition|)
block|{
name|ctl_isc_announce_mode
argument_list|(
name|lun
argument_list|,
name|ctl_get_initindex
argument_list|(
operator|&
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
argument_list|)
argument_list|,
name|page_index
operator|->
name|page_code
argument_list|,
name|page_index
operator|->
name|subpage
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_ie_timer
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
name|arg
decl_stmt|;
name|uint64_t
name|t
decl_stmt|;
if|if
condition|(
name|lun
operator|->
name|ie_asc
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|lun
operator|->
name|MODE_IE
operator|.
name|mrie
operator|==
name|SIEP_MRIE_UA
condition|)
name|ctl_est_ua_all
argument_list|(
name|lun
argument_list|,
operator|-
literal|1
argument_list|,
name|CTL_UA_IE
argument_list|)
expr_stmt|;
else|else
name|lun
operator|->
name|ie_reported
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|ie_reportcnt
operator|<
name|scsi_4btoul
argument_list|(
name|lun
operator|->
name|MODE_IE
operator|.
name|report_count
argument_list|)
condition|)
block|{
name|lun
operator|->
name|ie_reportcnt
operator|++
expr_stmt|;
name|t
operator|=
name|scsi_4btoul
argument_list|(
name|lun
operator|->
name|MODE_IE
operator|.
name|interval_timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
literal|0
operator|||
name|t
operator|==
name|UINT32_MAX
condition|)
name|t
operator|=
literal|3000
expr_stmt|;
comment|/* 5 min */
name|callout_schedule
argument_list|(
operator|&
name|lun
operator|->
name|ie_callout
argument_list|,
name|t
operator|*
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|ctl_ie_page_handler
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|struct
name|ctl_page_index
modifier|*
name|page_index
parameter_list|,
name|uint8_t
modifier|*
name|page_ptr
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
name|CTL_LUN
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|struct
name|scsi_info_exceptions_page
modifier|*
name|pg
decl_stmt|;
name|uint64_t
name|t
decl_stmt|;
operator|(
name|void
operator|)
name|ctl_default_page_handler
argument_list|(
name|ctsio
argument_list|,
name|page_index
argument_list|,
name|page_ptr
argument_list|)
expr_stmt|;
name|pg
operator|=
operator|(
expr|struct
name|scsi_info_exceptions_page
operator|*
operator|)
name|page_ptr
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|pg
operator|->
name|info_flags
operator|&
name|SIEP_FLAGS_TEST
condition|)
block|{
name|lun
operator|->
name|ie_asc
operator|=
literal|0x5d
expr_stmt|;
name|lun
operator|->
name|ie_ascq
operator|=
literal|0xff
expr_stmt|;
if|if
condition|(
name|pg
operator|->
name|mrie
operator|==
name|SIEP_MRIE_UA
condition|)
block|{
name|ctl_est_ua_all
argument_list|(
name|lun
argument_list|,
operator|-
literal|1
argument_list|,
name|CTL_UA_IE
argument_list|)
expr_stmt|;
name|lun
operator|->
name|ie_reported
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ctl_clr_ua_all
argument_list|(
name|lun
argument_list|,
operator|-
literal|1
argument_list|,
name|CTL_UA_IE
argument_list|)
expr_stmt|;
name|lun
operator|->
name|ie_reported
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|lun
operator|->
name|ie_reportcnt
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|ie_reportcnt
operator|<
name|scsi_4btoul
argument_list|(
name|pg
operator|->
name|report_count
argument_list|)
condition|)
block|{
name|lun
operator|->
name|ie_reportcnt
operator|++
expr_stmt|;
name|t
operator|=
name|scsi_4btoul
argument_list|(
name|pg
operator|->
name|interval_timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
literal|0
operator|||
name|t
operator|==
name|UINT32_MAX
condition|)
name|t
operator|=
literal|3000
expr_stmt|;
comment|/* 5 min */
name|callout_reset
argument_list|(
operator|&
name|lun
operator|->
name|ie_callout
argument_list|,
name|t
operator|*
name|hz
operator|/
literal|10
argument_list|,
name|ctl_ie_timer
argument_list|,
name|lun
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|lun
operator|->
name|ie_asc
operator|=
literal|0
expr_stmt|;
name|lun
operator|->
name|ie_ascq
operator|=
literal|0
expr_stmt|;
name|lun
operator|->
name|ie_reported
operator|=
literal|1
expr_stmt|;
name|ctl_clr_ua_all
argument_list|(
name|lun
argument_list|,
operator|-
literal|1
argument_list|,
name|CTL_UA_IE
argument_list|)
expr_stmt|;
name|lun
operator|->
name|ie_reportcnt
operator|=
name|UINT32_MAX
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|lun
operator|->
name|ie_callout
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_do_mode_select
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
name|CTL_LUN
argument_list|(
name|io
argument_list|)
decl_stmt|;
name|struct
name|scsi_mode_page_header
modifier|*
name|page_header
decl_stmt|;
name|struct
name|ctl_page_index
modifier|*
name|page_index
decl_stmt|;
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
decl_stmt|;
name|int
name|page_len
decl_stmt|,
name|page_len_offset
decl_stmt|,
name|page_len_size
decl_stmt|;
name|union
name|ctl_modepage_info
modifier|*
name|modepage_info
decl_stmt|;
name|uint16_t
modifier|*
name|len_left
decl_stmt|,
modifier|*
name|len_used
decl_stmt|;
name|int
name|retval
decl_stmt|,
name|i
decl_stmt|;
name|ctsio
operator|=
operator|&
name|io
operator|->
name|scsiio
expr_stmt|;
name|page_index
operator|=
name|NULL
expr_stmt|;
name|page_len
operator|=
literal|0
expr_stmt|;
name|modepage_info
operator|=
operator|(
expr|union
name|ctl_modepage_info
operator|*
operator|)
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_MODEPAGE
index|]
operator|.
name|bytes
expr_stmt|;
name|len_left
operator|=
operator|&
name|modepage_info
operator|->
name|header
operator|.
name|len_left
expr_stmt|;
name|len_used
operator|=
operator|&
name|modepage_info
operator|->
name|header
operator|.
name|len_used
expr_stmt|;
name|do_next_page
label|:
name|page_header
operator|=
operator|(
expr|struct
name|scsi_mode_page_header
operator|*
operator|)
operator|(
name|ctsio
operator|->
name|kern_data_ptr
operator|+
operator|*
name|len_used
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|len_left
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|len_left
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_mode_page_header
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|ctl_set_param_len_error
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|page_header
operator|->
name|page_code
operator|&
name|SMPH_SPF
operator|)
operator|&&
operator|(
operator|*
name|len_left
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_mode_page_header_sp
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|ctl_set_param_len_error
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
comment|/* 	 * XXX KDM should we do something with the block descriptor? 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_NUM_MODE_PAGES
condition|;
name|i
operator|++
control|)
block|{
name|page_index
operator|=
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|index
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
operator|==
name|T_DIRECT
operator|&&
operator|(
name|page_index
operator|->
name|page_flags
operator|&
name|CTL_PAGE_FLAG_DIRECT
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
operator|==
name|T_PROCESSOR
operator|&&
operator|(
name|page_index
operator|->
name|page_flags
operator|&
name|CTL_PAGE_FLAG_PROC
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
operator|==
name|T_CDROM
operator|&&
operator|(
name|page_index
operator|->
name|page_flags
operator|&
name|CTL_PAGE_FLAG_CDROM
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|page_index
operator|->
name|page_code
operator|&
name|SMPH_PC_MASK
operator|)
operator|!=
operator|(
name|page_header
operator|->
name|page_code
operator|&
name|SMPH_PC_MASK
operator|)
condition|)
continue|continue;
comment|/* 		 * If neither page has a subpage code, then we've got a 		 * match. 		 */
if|if
condition|(
operator|(
operator|(
name|page_index
operator|->
name|page_code
operator|&
name|SMPH_SPF
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|page_header
operator|->
name|page_code
operator|&
name|SMPH_SPF
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|page_len
operator|=
name|page_header
operator|->
name|page_length
expr_stmt|;
break|break;
block|}
comment|/* 		 * If both pages have subpages, then the subpage numbers 		 * have to match. 		 */
if|if
condition|(
operator|(
name|page_index
operator|->
name|page_code
operator|&
name|SMPH_SPF
operator|)
operator|&&
operator|(
name|page_header
operator|->
name|page_code
operator|&
name|SMPH_SPF
operator|)
condition|)
block|{
name|struct
name|scsi_mode_page_header_sp
modifier|*
name|sph
decl_stmt|;
name|sph
operator|=
operator|(
expr|struct
name|scsi_mode_page_header_sp
operator|*
operator|)
name|page_header
expr_stmt|;
if|if
condition|(
name|page_index
operator|->
name|subpage
operator|==
name|sph
operator|->
name|subpage
condition|)
block|{
name|page_len
operator|=
name|scsi_2btoul
argument_list|(
name|sph
operator|->
name|page_length
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* 	 * If we couldn't find the page, or if we don't have a mode select 	 * handler for it, send back an error to the user. 	 */
if|if
condition|(
operator|(
name|i
operator|>=
name|CTL_NUM_MODE_PAGES
operator|)
operator|||
operator|(
name|page_index
operator|->
name|select_handler
operator|==
name|NULL
operator|)
condition|)
block|{
name|ctl_set_invalid_field
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|0
argument_list|,
comment|/*field*/
operator|*
name|len_used
argument_list|,
comment|/*bit_valid*/
literal|0
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
if|if
condition|(
name|page_index
operator|->
name|page_code
operator|&
name|SMPH_SPF
condition|)
block|{
name|page_len_offset
operator|=
literal|2
expr_stmt|;
name|page_len_size
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|page_len_size
operator|=
literal|1
expr_stmt|;
name|page_len_offset
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * If the length the initiator gives us isn't the one we specify in 	 * the mode page header, or if they didn't specify enough data in 	 * the CDB to avoid truncating this page, kick out the request. 	 */
if|if
condition|(
name|page_len
operator|!=
name|page_index
operator|->
name|page_len
operator|-
name|page_len_offset
operator|-
name|page_len_size
condition|)
block|{
name|ctl_set_invalid_field
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|0
argument_list|,
comment|/*field*/
operator|*
name|len_used
operator|+
name|page_len_offset
argument_list|,
comment|/*bit_valid*/
literal|0
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|len_left
operator|<
name|page_index
operator|->
name|page_len
condition|)
block|{
name|free
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|ctl_set_param_len_error
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
comment|/* 	 * Run through the mode page, checking to make sure that the bits 	 * the user changed are actually legal for him to change. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|page_index
operator|->
name|page_len
condition|;
name|i
operator|++
control|)
block|{
name|uint8_t
modifier|*
name|user_byte
decl_stmt|,
modifier|*
name|change_mask
decl_stmt|,
modifier|*
name|current_byte
decl_stmt|;
name|int
name|bad_bit
decl_stmt|;
name|int
name|j
decl_stmt|;
name|user_byte
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|page_header
operator|+
name|i
expr_stmt|;
name|change_mask
operator|=
name|page_index
operator|->
name|page_data
operator|+
operator|(
name|page_index
operator|->
name|page_len
operator|*
name|CTL_PAGE_CHANGEABLE
operator|)
operator|+
name|i
expr_stmt|;
name|current_byte
operator|=
name|page_index
operator|->
name|page_data
operator|+
operator|(
name|page_index
operator|->
name|page_len
operator|*
name|CTL_PAGE_CURRENT
operator|)
operator|+
name|i
expr_stmt|;
comment|/* 		 * Check to see whether the user set any bits in this byte 		 * that he is not allowed to set. 		 */
if|if
condition|(
operator|(
operator|*
name|user_byte
operator|&
operator|~
operator|(
operator|*
name|change_mask
operator|)
operator|)
operator|==
operator|(
operator|*
name|current_byte
operator|&
operator|~
operator|(
operator|*
name|change_mask
operator|)
operator|)
condition|)
continue|continue;
comment|/* 		 * Go through bit by bit to determine which one is illegal. 		 */
name|bad_bit
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|7
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
if|if
condition|(
operator|(
operator|(
operator|(
literal|1
operator|<<
name|i
operator|)
operator|&
operator|~
operator|(
operator|*
name|change_mask
operator|)
operator|)
operator|&
operator|*
name|user_byte
operator|)
operator|!=
operator|(
operator|(
operator|(
literal|1
operator|<<
name|i
operator|)
operator|&
operator|~
operator|(
operator|*
name|change_mask
operator|)
operator|)
operator|&
operator|*
name|current_byte
operator|)
condition|)
block|{
name|bad_bit
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
name|ctl_set_invalid_field
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|0
argument_list|,
comment|/*field*/
operator|*
name|len_used
operator|+
name|i
argument_list|,
comment|/*bit_valid*/
literal|1
argument_list|,
comment|/*bit*/
name|bad_bit
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
comment|/* 	 * Decrement these before we call the page handler, since we may 	 * end up getting called back one way or another before the handler 	 * returns to this context. 	 */
operator|*
name|len_left
operator|-=
name|page_index
operator|->
name|page_len
expr_stmt|;
operator|*
name|len_used
operator|+=
name|page_index
operator|->
name|page_len
expr_stmt|;
name|retval
operator|=
name|page_index
operator|->
name|select_handler
argument_list|(
name|ctsio
argument_list|,
name|page_index
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|page_header
argument_list|)
expr_stmt|;
comment|/* 	 * If the page handler returns CTL_RETVAL_QUEUED, then we need to 	 * wait until this queued command completes to finish processing 	 * the mode page.  If it returns anything other than 	 * CTL_RETVAL_COMPLETE (e.g. CTL_RETVAL_ERROR), then it should have 	 * already set the sense information, freed the data pointer, and 	 * completed the io for us. 	 */
if|if
condition|(
name|retval
operator|!=
name|CTL_RETVAL_COMPLETE
condition|)
goto|goto
name|bailout_no_done
goto|;
comment|/* 	 * If the initiator sent us more than one page, parse the next one. 	 */
if|if
condition|(
operator|*
name|len_left
operator|>
literal|0
condition|)
goto|goto
name|do_next_page
goto|;
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
name|bailout_no_done
label|:
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_mode_select
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
name|CTL_LUN
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|union
name|ctl_modepage_info
modifier|*
name|modepage_info
decl_stmt|;
name|int
name|bd_len
decl_stmt|,
name|i
decl_stmt|,
name|header_size
decl_stmt|,
name|param_len
decl_stmt|,
name|pf
decl_stmt|,
name|rtd
decl_stmt|,
name|sp
decl_stmt|;
name|uint32_t
name|initidx
decl_stmt|;
name|initidx
operator|=
name|ctl_get_initindex
argument_list|(
operator|&
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ctsio
operator|->
name|cdb
index|[
literal|0
index|]
condition|)
block|{
case|case
name|MODE_SELECT_6
case|:
block|{
name|struct
name|scsi_mode_select_6
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_mode_select_6
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|pf
operator|=
operator|(
name|cdb
operator|->
name|byte2
operator|&
name|SMS_PF
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|rtd
operator|=
operator|(
name|cdb
operator|->
name|byte2
operator|&
name|SMS_RTD
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|sp
operator|=
operator|(
name|cdb
operator|->
name|byte2
operator|&
name|SMS_SP
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|param_len
operator|=
name|cdb
operator|->
name|length
expr_stmt|;
name|header_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_mode_header_6
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MODE_SELECT_10
case|:
block|{
name|struct
name|scsi_mode_select_10
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_mode_select_10
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|pf
operator|=
operator|(
name|cdb
operator|->
name|byte2
operator|&
name|SMS_PF
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|rtd
operator|=
operator|(
name|cdb
operator|->
name|byte2
operator|&
name|SMS_RTD
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|sp
operator|=
operator|(
name|cdb
operator|->
name|byte2
operator|&
name|SMS_SP
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|param_len
operator|=
name|scsi_2btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
name|header_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_mode_header_10
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|ctl_set_invalid_opcode
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
if|if
condition|(
name|rtd
condition|)
block|{
if|if
condition|(
name|param_len
operator|!=
literal|0
condition|)
block|{
name|ctl_set_invalid_field
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|0
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|0
argument_list|,
comment|/*bit_valid*/
literal|0
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
comment|/* Revert to defaults. */
name|ctl_init_page_index
argument_list|(
name|lun
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctl_est_ua_all
argument_list|(
name|lun
argument_list|,
name|initidx
argument_list|,
name|CTL_UA_MODE_CHANGE
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_NUM_MODE_PAGES
condition|;
name|i
operator|++
control|)
block|{
name|ctl_isc_announce_mode
argument_list|(
name|lun
argument_list|,
operator|-
literal|1
argument_list|,
name|lun
operator|->
name|mode_pages
operator|.
name|index
index|[
name|i
index|]
operator|.
name|page_code
operator|&
name|SMPH_PC_MASK
argument_list|,
name|lun
operator|->
name|mode_pages
operator|.
name|index
index|[
name|i
index|]
operator|.
name|subpage
argument_list|)
expr_stmt|;
block|}
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
comment|/* 	 * From SPC-3: 	 * "A parameter list length of zero indicates that the Data-Out Buffer 	 * shall be empty. This condition shall not be considered as an error." 	 */
if|if
condition|(
name|param_len
operator|==
literal|0
condition|)
block|{
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
comment|/* 	 * Since we'll hit this the first time through, prior to 	 * allocation, we don't need to free a data buffer here. 	 */
if|if
condition|(
name|param_len
operator|<
name|header_size
condition|)
block|{
name|ctl_set_param_len_error
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
comment|/* 	 * Allocate the data buffer and grab the user's data.  In theory, 	 * we shouldn't have to sanity check the parameter list length here 	 * because the maximum size is 64K.  We should be able to malloc 	 * that much without too many problems. 	 */
if|if
condition|(
operator|(
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ALLOCATED
operator|)
operator|==
literal|0
condition|)
block|{
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
name|param_len
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|param_len
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|param_len
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
switch|switch
condition|(
name|ctsio
operator|->
name|cdb
index|[
literal|0
index|]
condition|)
block|{
case|case
name|MODE_SELECT_6
case|:
block|{
name|struct
name|scsi_mode_header_6
modifier|*
name|mh6
decl_stmt|;
name|mh6
operator|=
operator|(
expr|struct
name|scsi_mode_header_6
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|bd_len
operator|=
name|mh6
operator|->
name|blk_desc_len
expr_stmt|;
break|break;
block|}
case|case
name|MODE_SELECT_10
case|:
block|{
name|struct
name|scsi_mode_header_10
modifier|*
name|mh10
decl_stmt|;
name|mh10
operator|=
operator|(
expr|struct
name|scsi_mode_header_10
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|bd_len
operator|=
name|scsi_2btoul
argument_list|(
name|mh10
operator|->
name|blk_desc_len
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|panic
argument_list|(
literal|"%s: Invalid CDB type %#x"
argument_list|,
name|__func__
argument_list|,
name|ctsio
operator|->
name|cdb
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|param_len
operator|<
operator|(
name|header_size
operator|+
name|bd_len
operator|)
condition|)
block|{
name|free
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|ctl_set_param_len_error
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
comment|/* 	 * Set the IO_CONT flag, so that if this I/O gets passed to 	 * ctl_config_write_done(), it'll get passed back to 	 * ctl_do_mode_select() for further processing, or completion if 	 * we're all done. 	 */
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_IO_CONT
expr_stmt|;
name|ctsio
operator|->
name|io_cont
operator|=
name|ctl_do_mode_select
expr_stmt|;
name|modepage_info
operator|=
operator|(
expr|union
name|ctl_modepage_info
operator|*
operator|)
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_MODEPAGE
index|]
operator|.
name|bytes
expr_stmt|;
name|memset
argument_list|(
name|modepage_info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|modepage_info
argument_list|)
argument_list|)
expr_stmt|;
name|modepage_info
operator|->
name|header
operator|.
name|len_left
operator|=
name|param_len
operator|-
name|header_size
operator|-
name|bd_len
expr_stmt|;
name|modepage_info
operator|->
name|header
operator|.
name|len_used
operator|=
name|header_size
operator|+
name|bd_len
expr_stmt|;
return|return
operator|(
name|ctl_do_mode_select
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_mode_sense
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
name|CTL_LUN
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|int
name|pc
decl_stmt|,
name|page_code
decl_stmt|,
name|dbd
decl_stmt|,
name|llba
decl_stmt|,
name|subpage
decl_stmt|;
name|int
name|alloc_len
decl_stmt|,
name|page_len
decl_stmt|,
name|header_len
decl_stmt|,
name|total_len
decl_stmt|;
name|struct
name|scsi_mode_block_descr
modifier|*
name|block_desc
decl_stmt|;
name|struct
name|ctl_page_index
modifier|*
name|page_index
decl_stmt|;
name|dbd
operator|=
literal|0
expr_stmt|;
name|llba
operator|=
literal|0
expr_stmt|;
name|block_desc
operator|=
name|NULL
expr_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_mode_sense\n"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ctsio
operator|->
name|cdb
index|[
literal|0
index|]
condition|)
block|{
case|case
name|MODE_SENSE_6
case|:
block|{
name|struct
name|scsi_mode_sense_6
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_mode_sense_6
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|header_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_mode_hdr_6
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SMS_DBD
condition|)
name|dbd
operator|=
literal|1
expr_stmt|;
else|else
name|header_len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_mode_block_descr
argument_list|)
expr_stmt|;
name|pc
operator|=
operator|(
name|cdb
operator|->
name|page
operator|&
name|SMS_PAGE_CTRL_MASK
operator|)
operator|>>
literal|6
expr_stmt|;
name|page_code
operator|=
name|cdb
operator|->
name|page
operator|&
name|SMS_PAGE_CODE
expr_stmt|;
name|subpage
operator|=
name|cdb
operator|->
name|subpage
expr_stmt|;
name|alloc_len
operator|=
name|cdb
operator|->
name|length
expr_stmt|;
break|break;
block|}
case|case
name|MODE_SENSE_10
case|:
block|{
name|struct
name|scsi_mode_sense_10
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_mode_sense_10
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|header_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_mode_hdr_10
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SMS_DBD
condition|)
name|dbd
operator|=
literal|1
expr_stmt|;
else|else
name|header_len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_mode_block_descr
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SMS10_LLBAA
condition|)
name|llba
operator|=
literal|1
expr_stmt|;
name|pc
operator|=
operator|(
name|cdb
operator|->
name|page
operator|&
name|SMS_PAGE_CTRL_MASK
operator|)
operator|>>
literal|6
expr_stmt|;
name|page_code
operator|=
name|cdb
operator|->
name|page
operator|&
name|SMS_PAGE_CODE
expr_stmt|;
name|subpage
operator|=
name|cdb
operator|->
name|subpage
expr_stmt|;
name|alloc_len
operator|=
name|scsi_2btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|ctl_set_invalid_opcode
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
break|break;
comment|/* NOTREACHED */
block|}
comment|/* 	 * We have to make a first pass through to calculate the size of 	 * the pages that match the user's query.  Then we allocate enough 	 * memory to hold it, and actually copy the data into the buffer. 	 */
switch|switch
condition|(
name|page_code
condition|)
block|{
case|case
name|SMS_ALL_PAGES_PAGE
case|:
block|{
name|u_int
name|i
decl_stmt|;
name|page_len
operator|=
literal|0
expr_stmt|;
comment|/* 		 * At the moment, values other than 0 and 0xff here are 		 * reserved according to SPC-3. 		 */
if|if
condition|(
operator|(
name|subpage
operator|!=
name|SMS_SUBPAGE_PAGE_0
operator|)
operator|&&
operator|(
name|subpage
operator|!=
name|SMS_SUBPAGE_ALL
operator|)
condition|)
block|{
name|ctl_set_invalid_field
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|3
argument_list|,
comment|/*bit_valid*/
literal|0
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_NUM_MODE_PAGES
condition|;
name|i
operator|++
control|)
block|{
name|page_index
operator|=
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|index
index|[
name|i
index|]
expr_stmt|;
comment|/* Make sure the page is supported for this dev type */
if|if
condition|(
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
operator|==
name|T_DIRECT
operator|&&
operator|(
name|page_index
operator|->
name|page_flags
operator|&
name|CTL_PAGE_FLAG_DIRECT
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
operator|==
name|T_PROCESSOR
operator|&&
operator|(
name|page_index
operator|->
name|page_flags
operator|&
name|CTL_PAGE_FLAG_PROC
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
operator|==
name|T_CDROM
operator|&&
operator|(
name|page_index
operator|->
name|page_flags
operator|&
name|CTL_PAGE_FLAG_CDROM
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* 			 * We don't use this subpage if the user didn't 			 * request all subpages. 			 */
if|if
condition|(
operator|(
name|page_index
operator|->
name|subpage
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|subpage
operator|==
name|SMS_SUBPAGE_PAGE_0
operator|)
condition|)
continue|continue;
if|#
directive|if
literal|0
block|printf("found page %#x len %d\n", 			       page_index->page_code& SMPH_PC_MASK, 			       page_index->page_len);
endif|#
directive|endif
name|page_len
operator|+=
name|page_index
operator|->
name|page_len
expr_stmt|;
block|}
break|break;
block|}
default|default:
block|{
name|u_int
name|i
decl_stmt|;
name|page_len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_NUM_MODE_PAGES
condition|;
name|i
operator|++
control|)
block|{
name|page_index
operator|=
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|index
index|[
name|i
index|]
expr_stmt|;
comment|/* Make sure the page is supported for this dev type */
if|if
condition|(
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
operator|==
name|T_DIRECT
operator|&&
operator|(
name|page_index
operator|->
name|page_flags
operator|&
name|CTL_PAGE_FLAG_DIRECT
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
operator|==
name|T_PROCESSOR
operator|&&
operator|(
name|page_index
operator|->
name|page_flags
operator|&
name|CTL_PAGE_FLAG_PROC
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
operator|==
name|T_CDROM
operator|&&
operator|(
name|page_index
operator|->
name|page_flags
operator|&
name|CTL_PAGE_FLAG_CDROM
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Look for the right page code */
if|if
condition|(
operator|(
name|page_index
operator|->
name|page_code
operator|&
name|SMPH_PC_MASK
operator|)
operator|!=
name|page_code
condition|)
continue|continue;
comment|/* Look for the right subpage or the subpage wildcard*/
if|if
condition|(
operator|(
name|page_index
operator|->
name|subpage
operator|!=
name|subpage
operator|)
operator|&&
operator|(
name|subpage
operator|!=
name|SMS_SUBPAGE_ALL
operator|)
condition|)
continue|continue;
if|#
directive|if
literal|0
block|printf("found page %#x len %d\n", 			       page_index->page_code& SMPH_PC_MASK, 			       page_index->page_len);
endif|#
directive|endif
name|page_len
operator|+=
name|page_index
operator|->
name|page_len
expr_stmt|;
block|}
if|if
condition|(
name|page_len
operator|==
literal|0
condition|)
block|{
name|ctl_set_invalid_field
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|2
argument_list|,
comment|/*bit_valid*/
literal|1
argument_list|,
comment|/*bit*/
literal|5
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
break|break;
block|}
block|}
name|total_len
operator|=
name|header_len
operator|+
name|page_len
expr_stmt|;
if|#
directive|if
literal|0
block|printf("header_len = %d, page_len = %d, total_len = %d\n", 	       header_len, page_len, total_len);
endif|#
directive|endif
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
name|total_len
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|min
argument_list|(
name|total_len
argument_list|,
name|alloc_len
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|ctsio
operator|->
name|kern_data_len
expr_stmt|;
switch|switch
condition|(
name|ctsio
operator|->
name|cdb
index|[
literal|0
index|]
condition|)
block|{
case|case
name|MODE_SENSE_6
case|:
block|{
name|struct
name|scsi_mode_hdr_6
modifier|*
name|header
decl_stmt|;
name|header
operator|=
operator|(
expr|struct
name|scsi_mode_hdr_6
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|header
operator|->
name|datalen
operator|=
name|MIN
argument_list|(
name|total_len
operator|-
literal|1
argument_list|,
literal|254
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
operator|==
name|T_DIRECT
condition|)
block|{
name|header
operator|->
name|dev_specific
operator|=
literal|0x10
expr_stmt|;
comment|/* DPOFUA */
if|if
condition|(
operator|(
name|lun
operator|->
name|be_lun
operator|->
name|flags
operator|&
name|CTL_LUN_FLAG_READONLY
operator|)
operator|||
operator|(
name|lun
operator|->
name|MODE_CTRL
operator|.
name|eca_and_aen
operator|&
name|SCP_SWP
operator|)
operator|!=
literal|0
condition|)
name|header
operator|->
name|dev_specific
operator||=
literal|0x80
expr_stmt|;
comment|/* WP */
block|}
if|if
condition|(
name|dbd
condition|)
name|header
operator|->
name|block_descr_len
operator|=
literal|0
expr_stmt|;
else|else
name|header
operator|->
name|block_descr_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_mode_block_descr
argument_list|)
expr_stmt|;
name|block_desc
operator|=
operator|(
expr|struct
name|scsi_mode_block_descr
operator|*
operator|)
operator|&
name|header
index|[
literal|1
index|]
expr_stmt|;
break|break;
block|}
case|case
name|MODE_SENSE_10
case|:
block|{
name|struct
name|scsi_mode_hdr_10
modifier|*
name|header
decl_stmt|;
name|int
name|datalen
decl_stmt|;
name|header
operator|=
operator|(
expr|struct
name|scsi_mode_hdr_10
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|datalen
operator|=
name|MIN
argument_list|(
name|total_len
operator|-
literal|2
argument_list|,
literal|65533
argument_list|)
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|datalen
argument_list|,
name|header
operator|->
name|datalen
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
operator|==
name|T_DIRECT
condition|)
block|{
name|header
operator|->
name|dev_specific
operator|=
literal|0x10
expr_stmt|;
comment|/* DPOFUA */
if|if
condition|(
operator|(
name|lun
operator|->
name|be_lun
operator|->
name|flags
operator|&
name|CTL_LUN_FLAG_READONLY
operator|)
operator|||
operator|(
name|lun
operator|->
name|MODE_CTRL
operator|.
name|eca_and_aen
operator|&
name|SCP_SWP
operator|)
operator|!=
literal|0
condition|)
name|header
operator|->
name|dev_specific
operator||=
literal|0x80
expr_stmt|;
comment|/* WP */
block|}
if|if
condition|(
name|dbd
condition|)
name|scsi_ulto2b
argument_list|(
literal|0
argument_list|,
name|header
operator|->
name|block_descr_len
argument_list|)
expr_stmt|;
else|else
name|scsi_ulto2b
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_mode_block_descr
argument_list|)
argument_list|,
name|header
operator|->
name|block_descr_len
argument_list|)
expr_stmt|;
name|block_desc
operator|=
operator|(
expr|struct
name|scsi_mode_block_descr
operator|*
operator|)
operator|&
name|header
index|[
literal|1
index|]
expr_stmt|;
break|break;
block|}
default|default:
name|panic
argument_list|(
literal|"%s: Invalid CDB type %#x"
argument_list|,
name|__func__
argument_list|,
name|ctsio
operator|->
name|cdb
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we've got a disk, use its blocksize in the block 	 * descriptor.  Otherwise, just set it to 0. 	 */
if|if
condition|(
name|dbd
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
operator|==
name|T_DIRECT
condition|)
name|scsi_ulto3b
argument_list|(
name|lun
operator|->
name|be_lun
operator|->
name|blocksize
argument_list|,
name|block_desc
operator|->
name|block_len
argument_list|)
expr_stmt|;
else|else
name|scsi_ulto3b
argument_list|(
literal|0
argument_list|,
name|block_desc
operator|->
name|block_len
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|page_code
condition|)
block|{
case|case
name|SMS_ALL_PAGES_PAGE
case|:
block|{
name|int
name|i
decl_stmt|,
name|data_used
decl_stmt|;
name|data_used
operator|=
name|header_len
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_NUM_MODE_PAGES
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ctl_page_index
modifier|*
name|page_index
decl_stmt|;
name|page_index
operator|=
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|index
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
operator|==
name|T_DIRECT
operator|&&
operator|(
name|page_index
operator|->
name|page_flags
operator|&
name|CTL_PAGE_FLAG_DIRECT
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
operator|==
name|T_PROCESSOR
operator|&&
operator|(
name|page_index
operator|->
name|page_flags
operator|&
name|CTL_PAGE_FLAG_PROC
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
operator|==
name|T_CDROM
operator|&&
operator|(
name|page_index
operator|->
name|page_flags
operator|&
name|CTL_PAGE_FLAG_CDROM
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* 			 * We don't use this subpage if the user didn't 			 * request all subpages.  We already checked (above) 			 * to make sure the user only specified a subpage 			 * of 0 or 0xff in the SMS_ALL_PAGES_PAGE case. 			 */
if|if
condition|(
operator|(
name|page_index
operator|->
name|subpage
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|subpage
operator|==
name|SMS_SUBPAGE_PAGE_0
operator|)
condition|)
continue|continue;
comment|/* 			 * Call the handler, if it exists, to update the 			 * page to the latest values. 			 */
if|if
condition|(
name|page_index
operator|->
name|sense_handler
operator|!=
name|NULL
condition|)
name|page_index
operator|->
name|sense_handler
argument_list|(
name|ctsio
argument_list|,
name|page_index
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
operator|+
name|data_used
argument_list|,
name|page_index
operator|->
name|page_data
operator|+
operator|(
name|page_index
operator|->
name|page_len
operator|*
name|pc
operator|)
argument_list|,
name|page_index
operator|->
name|page_len
argument_list|)
expr_stmt|;
name|data_used
operator|+=
name|page_index
operator|->
name|page_len
expr_stmt|;
block|}
break|break;
block|}
default|default:
block|{
name|int
name|i
decl_stmt|,
name|data_used
decl_stmt|;
name|data_used
operator|=
name|header_len
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_NUM_MODE_PAGES
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ctl_page_index
modifier|*
name|page_index
decl_stmt|;
name|page_index
operator|=
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|index
index|[
name|i
index|]
expr_stmt|;
comment|/* Look for the right page code */
if|if
condition|(
operator|(
name|page_index
operator|->
name|page_code
operator|&
name|SMPH_PC_MASK
operator|)
operator|!=
name|page_code
condition|)
continue|continue;
comment|/* Look for the right subpage or the subpage wildcard*/
if|if
condition|(
operator|(
name|page_index
operator|->
name|subpage
operator|!=
name|subpage
operator|)
operator|&&
operator|(
name|subpage
operator|!=
name|SMS_SUBPAGE_ALL
operator|)
condition|)
continue|continue;
comment|/* Make sure the page is supported for this dev type */
if|if
condition|(
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
operator|==
name|T_DIRECT
operator|&&
operator|(
name|page_index
operator|->
name|page_flags
operator|&
name|CTL_PAGE_FLAG_DIRECT
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
operator|==
name|T_PROCESSOR
operator|&&
operator|(
name|page_index
operator|->
name|page_flags
operator|&
name|CTL_PAGE_FLAG_PROC
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
operator|==
name|T_CDROM
operator|&&
operator|(
name|page_index
operator|->
name|page_flags
operator|&
name|CTL_PAGE_FLAG_CDROM
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* 			 * Call the handler, if it exists, to update the 			 * page to the latest values. 			 */
if|if
condition|(
name|page_index
operator|->
name|sense_handler
operator|!=
name|NULL
condition|)
name|page_index
operator|->
name|sense_handler
argument_list|(
name|ctsio
argument_list|,
name|page_index
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
operator|+
name|data_used
argument_list|,
name|page_index
operator|->
name|page_data
operator|+
operator|(
name|page_index
operator|->
name|page_len
operator|*
name|pc
operator|)
argument_list|,
name|page_index
operator|->
name|page_len
argument_list|)
expr_stmt|;
name|data_used
operator|+=
name|page_index
operator|->
name|page_len
expr_stmt|;
block|}
break|break;
block|}
block|}
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_lbp_log_sense_handler
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|struct
name|ctl_page_index
modifier|*
name|page_index
parameter_list|,
name|int
name|pc
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
name|CTL_LUN
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|struct
name|scsi_log_param_header
modifier|*
name|phdr
decl_stmt|;
name|uint8_t
modifier|*
name|data
decl_stmt|;
name|uint64_t
name|val
decl_stmt|;
name|data
operator|=
name|page_index
operator|->
name|page_data
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|backend
operator|->
name|lun_attr
operator|!=
name|NULL
operator|&&
operator|(
name|val
operator|=
name|lun
operator|->
name|backend
operator|->
name|lun_attr
argument_list|(
name|lun
operator|->
name|be_lun
operator|->
name|be_lun
argument_list|,
literal|"blocksavail"
argument_list|)
operator|)
operator|!=
name|UINT64_MAX
condition|)
block|{
name|phdr
operator|=
operator|(
expr|struct
name|scsi_log_param_header
operator|*
operator|)
name|data
expr_stmt|;
name|scsi_ulto2b
argument_list|(
literal|0x0001
argument_list|,
name|phdr
operator|->
name|param_code
argument_list|)
expr_stmt|;
name|phdr
operator|->
name|param_control
operator|=
name|SLP_LBIN
operator||
name|SLP_LP
expr_stmt|;
name|phdr
operator|->
name|param_len
operator|=
literal|8
expr_stmt|;
name|data
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|phdr
operator|+
literal|1
operator|)
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|val
operator|>>
name|CTL_LBP_EXPONENT
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|data
index|[
literal|4
index|]
operator|=
literal|0x02
expr_stmt|;
comment|/* per-pool */
name|data
operator|+=
name|phdr
operator|->
name|param_len
expr_stmt|;
block|}
if|if
condition|(
name|lun
operator|->
name|backend
operator|->
name|lun_attr
operator|!=
name|NULL
operator|&&
operator|(
name|val
operator|=
name|lun
operator|->
name|backend
operator|->
name|lun_attr
argument_list|(
name|lun
operator|->
name|be_lun
operator|->
name|be_lun
argument_list|,
literal|"blocksused"
argument_list|)
operator|)
operator|!=
name|UINT64_MAX
condition|)
block|{
name|phdr
operator|=
operator|(
expr|struct
name|scsi_log_param_header
operator|*
operator|)
name|data
expr_stmt|;
name|scsi_ulto2b
argument_list|(
literal|0x0002
argument_list|,
name|phdr
operator|->
name|param_code
argument_list|)
expr_stmt|;
name|phdr
operator|->
name|param_control
operator|=
name|SLP_LBIN
operator||
name|SLP_LP
expr_stmt|;
name|phdr
operator|->
name|param_len
operator|=
literal|8
expr_stmt|;
name|data
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|phdr
operator|+
literal|1
operator|)
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|val
operator|>>
name|CTL_LBP_EXPONENT
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|data
index|[
literal|4
index|]
operator|=
literal|0x01
expr_stmt|;
comment|/* per-LUN */
name|data
operator|+=
name|phdr
operator|->
name|param_len
expr_stmt|;
block|}
if|if
condition|(
name|lun
operator|->
name|backend
operator|->
name|lun_attr
operator|!=
name|NULL
operator|&&
operator|(
name|val
operator|=
name|lun
operator|->
name|backend
operator|->
name|lun_attr
argument_list|(
name|lun
operator|->
name|be_lun
operator|->
name|be_lun
argument_list|,
literal|"poolblocksavail"
argument_list|)
operator|)
operator|!=
name|UINT64_MAX
condition|)
block|{
name|phdr
operator|=
operator|(
expr|struct
name|scsi_log_param_header
operator|*
operator|)
name|data
expr_stmt|;
name|scsi_ulto2b
argument_list|(
literal|0x00f1
argument_list|,
name|phdr
operator|->
name|param_code
argument_list|)
expr_stmt|;
name|phdr
operator|->
name|param_control
operator|=
name|SLP_LBIN
operator||
name|SLP_LP
expr_stmt|;
name|phdr
operator|->
name|param_len
operator|=
literal|8
expr_stmt|;
name|data
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|phdr
operator|+
literal|1
operator|)
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|val
operator|>>
name|CTL_LBP_EXPONENT
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|data
index|[
literal|4
index|]
operator|=
literal|0x02
expr_stmt|;
comment|/* per-pool */
name|data
operator|+=
name|phdr
operator|->
name|param_len
expr_stmt|;
block|}
if|if
condition|(
name|lun
operator|->
name|backend
operator|->
name|lun_attr
operator|!=
name|NULL
operator|&&
operator|(
name|val
operator|=
name|lun
operator|->
name|backend
operator|->
name|lun_attr
argument_list|(
name|lun
operator|->
name|be_lun
operator|->
name|be_lun
argument_list|,
literal|"poolblocksused"
argument_list|)
operator|)
operator|!=
name|UINT64_MAX
condition|)
block|{
name|phdr
operator|=
operator|(
expr|struct
name|scsi_log_param_header
operator|*
operator|)
name|data
expr_stmt|;
name|scsi_ulto2b
argument_list|(
literal|0x00f2
argument_list|,
name|phdr
operator|->
name|param_code
argument_list|)
expr_stmt|;
name|phdr
operator|->
name|param_control
operator|=
name|SLP_LBIN
operator||
name|SLP_LP
expr_stmt|;
name|phdr
operator|->
name|param_len
operator|=
literal|8
expr_stmt|;
name|data
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|phdr
operator|+
literal|1
operator|)
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|val
operator|>>
name|CTL_LBP_EXPONENT
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|data
index|[
literal|4
index|]
operator|=
literal|0x02
expr_stmt|;
comment|/* per-pool */
name|data
operator|+=
name|phdr
operator|->
name|param_len
expr_stmt|;
block|}
name|page_index
operator|->
name|page_len
operator|=
name|data
operator|-
name|page_index
operator|->
name|page_data
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_sap_log_sense_handler
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|struct
name|ctl_page_index
modifier|*
name|page_index
parameter_list|,
name|int
name|pc
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
name|CTL_LUN
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|struct
name|stat_page
modifier|*
name|data
decl_stmt|;
name|struct
name|bintime
modifier|*
name|t
decl_stmt|;
name|data
operator|=
operator|(
expr|struct
name|stat_page
operator|*
operator|)
name|page_index
operator|->
name|page_data
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|SLP_SAP
argument_list|,
name|data
operator|->
name|sap
operator|.
name|hdr
operator|.
name|param_code
argument_list|)
expr_stmt|;
name|data
operator|->
name|sap
operator|.
name|hdr
operator|.
name|param_control
operator|=
name|SLP_LBIN
expr_stmt|;
name|data
operator|->
name|sap
operator|.
name|hdr
operator|.
name|param_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_log_stat_and_perf
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_log_param_header
argument_list|)
expr_stmt|;
name|scsi_u64to8b
argument_list|(
name|lun
operator|->
name|stats
operator|.
name|operations
index|[
name|CTL_STATS_READ
index|]
argument_list|,
name|data
operator|->
name|sap
operator|.
name|read_num
argument_list|)
expr_stmt|;
name|scsi_u64to8b
argument_list|(
name|lun
operator|->
name|stats
operator|.
name|operations
index|[
name|CTL_STATS_WRITE
index|]
argument_list|,
name|data
operator|->
name|sap
operator|.
name|write_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|be_lun
operator|->
name|blocksize
operator|>
literal|0
condition|)
block|{
name|scsi_u64to8b
argument_list|(
name|lun
operator|->
name|stats
operator|.
name|bytes
index|[
name|CTL_STATS_WRITE
index|]
operator|/
name|lun
operator|->
name|be_lun
operator|->
name|blocksize
argument_list|,
name|data
operator|->
name|sap
operator|.
name|recvieved_lba
argument_list|)
expr_stmt|;
name|scsi_u64to8b
argument_list|(
name|lun
operator|->
name|stats
operator|.
name|bytes
index|[
name|CTL_STATS_READ
index|]
operator|/
name|lun
operator|->
name|be_lun
operator|->
name|blocksize
argument_list|,
name|data
operator|->
name|sap
operator|.
name|transmitted_lba
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
operator|&
name|lun
operator|->
name|stats
operator|.
name|time
index|[
name|CTL_STATS_READ
index|]
expr_stmt|;
name|scsi_u64to8b
argument_list|(
operator|(
name|uint64_t
operator|)
name|t
operator|->
name|sec
operator|*
literal|1000
operator|+
name|t
operator|->
name|frac
operator|/
operator|(
name|UINT64_MAX
operator|/
literal|1000
operator|)
argument_list|,
name|data
operator|->
name|sap
operator|.
name|read_int
argument_list|)
expr_stmt|;
name|t
operator|=
operator|&
name|lun
operator|->
name|stats
operator|.
name|time
index|[
name|CTL_STATS_WRITE
index|]
expr_stmt|;
name|scsi_u64to8b
argument_list|(
operator|(
name|uint64_t
operator|)
name|t
operator|->
name|sec
operator|*
literal|1000
operator|+
name|t
operator|->
name|frac
operator|/
operator|(
name|UINT64_MAX
operator|/
literal|1000
operator|)
argument_list|,
name|data
operator|->
name|sap
operator|.
name|write_int
argument_list|)
expr_stmt|;
name|scsi_u64to8b
argument_list|(
literal|0
argument_list|,
name|data
operator|->
name|sap
operator|.
name|weighted_num
argument_list|)
expr_stmt|;
name|scsi_u64to8b
argument_list|(
literal|0
argument_list|,
name|data
operator|->
name|sap
operator|.
name|weighted_int
argument_list|)
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|SLP_IT
argument_list|,
name|data
operator|->
name|it
operator|.
name|hdr
operator|.
name|param_code
argument_list|)
expr_stmt|;
name|data
operator|->
name|it
operator|.
name|hdr
operator|.
name|param_control
operator|=
name|SLP_LBIN
expr_stmt|;
name|data
operator|->
name|it
operator|.
name|hdr
operator|.
name|param_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_log_idle_time
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_log_param_header
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CTL_TIME_IO
name|scsi_u64to8b
argument_list|(
name|lun
operator|->
name|idle_time
operator|/
name|SBT_1MS
argument_list|,
name|data
operator|->
name|it
operator|.
name|idle_int
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|scsi_ulto2b
argument_list|(
name|SLP_TI
argument_list|,
name|data
operator|->
name|ti
operator|.
name|hdr
operator|.
name|param_code
argument_list|)
expr_stmt|;
name|data
operator|->
name|it
operator|.
name|hdr
operator|.
name|param_control
operator|=
name|SLP_LBIN
expr_stmt|;
name|data
operator|->
name|ti
operator|.
name|hdr
operator|.
name|param_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_log_time_interval
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_log_param_header
argument_list|)
expr_stmt|;
name|scsi_ulto4b
argument_list|(
literal|3
argument_list|,
name|data
operator|->
name|ti
operator|.
name|exponent
argument_list|)
expr_stmt|;
name|scsi_ulto4b
argument_list|(
literal|1
argument_list|,
name|data
operator|->
name|ti
operator|.
name|integer
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_ie_log_sense_handler
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|struct
name|ctl_page_index
modifier|*
name|page_index
parameter_list|,
name|int
name|pc
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
name|CTL_LUN
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|struct
name|scsi_log_informational_exceptions
modifier|*
name|data
decl_stmt|;
name|data
operator|=
operator|(
expr|struct
name|scsi_log_informational_exceptions
operator|*
operator|)
name|page_index
operator|->
name|page_data
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|SLP_IE_GEN
argument_list|,
name|data
operator|->
name|hdr
operator|.
name|param_code
argument_list|)
expr_stmt|;
name|data
operator|->
name|hdr
operator|.
name|param_control
operator|=
name|SLP_LBIN
expr_stmt|;
name|data
operator|->
name|hdr
operator|.
name|param_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_log_informational_exceptions
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_log_param_header
argument_list|)
expr_stmt|;
name|data
operator|->
name|ie_asc
operator|=
name|lun
operator|->
name|ie_asc
expr_stmt|;
name|data
operator|->
name|ie_ascq
operator|=
name|lun
operator|->
name|ie_ascq
expr_stmt|;
name|data
operator|->
name|temperature
operator|=
literal|0xff
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_log_sense
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
name|CTL_LUN
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|pc
decl_stmt|,
name|page_code
decl_stmt|,
name|subpage
decl_stmt|;
name|int
name|alloc_len
decl_stmt|,
name|total_len
decl_stmt|;
name|struct
name|ctl_page_index
modifier|*
name|page_index
decl_stmt|;
name|struct
name|scsi_log_sense
modifier|*
name|cdb
decl_stmt|;
name|struct
name|scsi_log_header
modifier|*
name|header
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_log_sense\n"
operator|)
argument_list|)
expr_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_log_sense
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|pc
operator|=
operator|(
name|cdb
operator|->
name|page
operator|&
name|SLS_PAGE_CTRL_MASK
operator|)
operator|>>
literal|6
expr_stmt|;
name|page_code
operator|=
name|cdb
operator|->
name|page
operator|&
name|SLS_PAGE_CODE
expr_stmt|;
name|subpage
operator|=
name|cdb
operator|->
name|subpage
expr_stmt|;
name|alloc_len
operator|=
name|scsi_2btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
name|page_index
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_NUM_LOG_PAGES
condition|;
name|i
operator|++
control|)
block|{
name|page_index
operator|=
operator|&
name|lun
operator|->
name|log_pages
operator|.
name|index
index|[
name|i
index|]
expr_stmt|;
comment|/* Look for the right page code */
if|if
condition|(
operator|(
name|page_index
operator|->
name|page_code
operator|&
name|SL_PAGE_CODE
operator|)
operator|!=
name|page_code
condition|)
continue|continue;
comment|/* Look for the right subpage or the subpage wildcard*/
if|if
condition|(
name|page_index
operator|->
name|subpage
operator|!=
name|subpage
condition|)
continue|continue;
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|CTL_NUM_LOG_PAGES
condition|)
block|{
name|ctl_set_invalid_field
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|2
argument_list|,
comment|/*bit_valid*/
literal|0
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
name|total_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_log_header
argument_list|)
operator|+
name|page_index
operator|->
name|page_len
expr_stmt|;
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
name|total_len
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|min
argument_list|(
name|total_len
argument_list|,
name|alloc_len
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|ctsio
operator|->
name|kern_data_len
expr_stmt|;
name|header
operator|=
operator|(
expr|struct
name|scsi_log_header
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|header
operator|->
name|page
operator|=
name|page_index
operator|->
name|page_code
expr_stmt|;
if|if
condition|(
name|page_index
operator|->
name|page_code
operator|==
name|SLS_LOGICAL_BLOCK_PROVISIONING
condition|)
name|header
operator|->
name|page
operator||=
name|SL_DS
expr_stmt|;
if|if
condition|(
name|page_index
operator|->
name|subpage
condition|)
block|{
name|header
operator|->
name|page
operator||=
name|SL_SPF
expr_stmt|;
name|header
operator|->
name|subpage
operator|=
name|page_index
operator|->
name|subpage
expr_stmt|;
block|}
name|scsi_ulto2b
argument_list|(
name|page_index
operator|->
name|page_len
argument_list|,
name|header
operator|->
name|datalen
argument_list|)
expr_stmt|;
comment|/* 	 * Call the handler, if it exists, to update the 	 * page to the latest values. 	 */
if|if
condition|(
name|page_index
operator|->
name|sense_handler
operator|!=
name|NULL
condition|)
name|page_index
operator|->
name|sense_handler
argument_list|(
name|ctsio
argument_list|,
name|page_index
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|header
operator|+
literal|1
argument_list|,
name|page_index
operator|->
name|page_data
argument_list|,
name|page_index
operator|->
name|page_len
argument_list|)
expr_stmt|;
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_read_capacity
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
name|CTL_LUN
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|struct
name|scsi_read_capacity
modifier|*
name|cdb
decl_stmt|;
name|struct
name|scsi_read_capacity_data
modifier|*
name|data
decl_stmt|;
name|uint32_t
name|lba
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_read_capacity\n"
operator|)
argument_list|)
expr_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_read_capacity
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|lba
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|cdb
operator|->
name|pmi
operator|&
name|SRC_PMI
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|lba
operator|!=
literal|0
operator|)
condition|)
block|{
name|ctl_set_invalid_field
argument_list|(
comment|/*ctsio*/
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|2
argument_list|,
comment|/*bit_valid*/
literal|0
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
expr|struct
name|scsi_read_capacity_data
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If the maximum LBA is greater than 0xfffffffe, the user must 	 * issue a SERVICE ACTION IN (16) command, with the read capacity 	 * serivce action set. 	 */
if|if
condition|(
name|lun
operator|->
name|be_lun
operator|->
name|maxlba
operator|>
literal|0xfffffffe
condition|)
name|scsi_ulto4b
argument_list|(
literal|0xffffffff
argument_list|,
name|data
operator|->
name|addr
argument_list|)
expr_stmt|;
else|else
name|scsi_ulto4b
argument_list|(
name|lun
operator|->
name|be_lun
operator|->
name|maxlba
argument_list|,
name|data
operator|->
name|addr
argument_list|)
expr_stmt|;
comment|/* 	 * XXX KDM this may not be 512 bytes... 	 */
name|scsi_ulto4b
argument_list|(
name|lun
operator|->
name|be_lun
operator|->
name|blocksize
argument_list|,
name|data
operator|->
name|length
argument_list|)
expr_stmt|;
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_read_capacity_16
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
name|CTL_LUN
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|struct
name|scsi_read_capacity_16
modifier|*
name|cdb
decl_stmt|;
name|struct
name|scsi_read_capacity_data_long
modifier|*
name|data
decl_stmt|;
name|uint64_t
name|lba
decl_stmt|;
name|uint32_t
name|alloc_len
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_read_capacity_16\n"
operator|)
argument_list|)
expr_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_read_capacity_16
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|alloc_len
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|alloc_len
argument_list|)
expr_stmt|;
name|lba
operator|=
name|scsi_8btou64
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cdb
operator|->
name|reladr
operator|&
name|SRC16_PMI
operator|)
operator|&&
operator|(
name|lba
operator|!=
literal|0
operator|)
condition|)
block|{
name|ctl_set_invalid_field
argument_list|(
comment|/*ctsio*/
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|2
argument_list|,
comment|/*bit_valid*/
literal|0
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
expr|struct
name|scsi_read_capacity_data_long
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|min
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
argument_list|,
name|alloc_len
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|ctsio
operator|->
name|kern_data_len
expr_stmt|;
name|scsi_u64to8b
argument_list|(
name|lun
operator|->
name|be_lun
operator|->
name|maxlba
argument_list|,
name|data
operator|->
name|addr
argument_list|)
expr_stmt|;
comment|/* XXX KDM this may not be 512 bytes... */
name|scsi_ulto4b
argument_list|(
name|lun
operator|->
name|be_lun
operator|->
name|blocksize
argument_list|,
name|data
operator|->
name|length
argument_list|)
expr_stmt|;
name|data
operator|->
name|prot_lbppbe
operator|=
name|lun
operator|->
name|be_lun
operator|->
name|pblockexp
operator|&
name|SRC16_LBPPBE
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|lun
operator|->
name|be_lun
operator|->
name|pblockoff
operator|&
name|SRC16_LALBA_A
argument_list|,
name|data
operator|->
name|lalba_lbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|be_lun
operator|->
name|flags
operator|&
name|CTL_LUN_FLAG_UNMAP
condition|)
name|data
operator|->
name|lalba_lbp
index|[
literal|0
index|]
operator||=
name|SRC16_LBPME
operator||
name|SRC16_LBPRZ
expr_stmt|;
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_get_lba_status
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
name|CTL_LUN
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|struct
name|scsi_get_lba_status
modifier|*
name|cdb
decl_stmt|;
name|struct
name|scsi_get_lba_status_data
modifier|*
name|data
decl_stmt|;
name|struct
name|ctl_lba_len_flags
modifier|*
name|lbalen
decl_stmt|;
name|uint64_t
name|lba
decl_stmt|;
name|uint32_t
name|alloc_len
decl_stmt|,
name|total_len
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_get_lba_status\n"
operator|)
argument_list|)
expr_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_get_lba_status
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|lba
operator|=
name|scsi_8btou64
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
name|alloc_len
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|alloc_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|lba
operator|>
name|lun
operator|->
name|be_lun
operator|->
name|maxlba
condition|)
block|{
name|ctl_set_lba_out_of_range
argument_list|(
name|ctsio
argument_list|,
name|lba
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
name|total_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|data
operator|->
name|descr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
name|total_len
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
expr|struct
name|scsi_get_lba_status_data
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|min
argument_list|(
name|total_len
argument_list|,
name|alloc_len
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|ctsio
operator|->
name|kern_data_len
expr_stmt|;
comment|/* Fill dummy data in case backend can't tell anything. */
name|scsi_ulto4b
argument_list|(
literal|4
operator|+
sizeof|sizeof
argument_list|(
name|data
operator|->
name|descr
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|data
operator|->
name|length
argument_list|)
expr_stmt|;
name|scsi_u64to8b
argument_list|(
name|lba
argument_list|,
name|data
operator|->
name|descr
index|[
literal|0
index|]
operator|.
name|addr
argument_list|)
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|MIN
argument_list|(
name|UINT32_MAX
argument_list|,
name|lun
operator|->
name|be_lun
operator|->
name|maxlba
operator|+
literal|1
operator|-
name|lba
argument_list|)
argument_list|,
name|data
operator|->
name|descr
index|[
literal|0
index|]
operator|.
name|length
argument_list|)
expr_stmt|;
name|data
operator|->
name|descr
index|[
literal|0
index|]
operator|.
name|status
operator|=
literal|0
expr_stmt|;
comment|/* Mapped or unknown. */
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|lbalen
operator|=
operator|(
expr|struct
name|ctl_lba_len_flags
operator|*
operator|)
operator|&
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LBA_LEN
index|]
expr_stmt|;
name|lbalen
operator|->
name|lba
operator|=
name|lba
expr_stmt|;
name|lbalen
operator|->
name|len
operator|=
name|total_len
expr_stmt|;
name|lbalen
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|retval
operator|=
name|lun
operator|->
name|backend
operator|->
name|config_read
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_read_defect
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|scsi_read_defect_data_10
modifier|*
name|ccb10
decl_stmt|;
name|struct
name|scsi_read_defect_data_12
modifier|*
name|ccb12
decl_stmt|;
name|struct
name|scsi_read_defect_data_hdr_10
modifier|*
name|data10
decl_stmt|;
name|struct
name|scsi_read_defect_data_hdr_12
modifier|*
name|data12
decl_stmt|;
name|uint32_t
name|alloc_len
decl_stmt|,
name|data_len
decl_stmt|;
name|uint8_t
name|format
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_read_defect\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctsio
operator|->
name|cdb
index|[
literal|0
index|]
operator|==
name|READ_DEFECT_DATA_10
condition|)
block|{
name|ccb10
operator|=
operator|(
expr|struct
name|scsi_read_defect_data_10
operator|*
operator|)
operator|&
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|format
operator|=
name|ccb10
operator|->
name|format
expr_stmt|;
name|alloc_len
operator|=
name|scsi_2btoul
argument_list|(
name|ccb10
operator|->
name|alloc_length
argument_list|)
expr_stmt|;
name|data_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|data10
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ccb12
operator|=
operator|(
expr|struct
name|scsi_read_defect_data_12
operator|*
operator|)
operator|&
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|format
operator|=
name|ccb12
operator|->
name|format
expr_stmt|;
name|alloc_len
operator|=
name|scsi_4btoul
argument_list|(
name|ccb12
operator|->
name|alloc_length
argument_list|)
expr_stmt|;
name|data_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|data12
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|alloc_len
operator|==
literal|0
condition|)
block|{
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
name|data_len
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|min
argument_list|(
name|data_len
argument_list|,
name|alloc_len
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|ctsio
operator|->
name|kern_data_len
expr_stmt|;
if|if
condition|(
name|ctsio
operator|->
name|cdb
index|[
literal|0
index|]
operator|==
name|READ_DEFECT_DATA_10
condition|)
block|{
name|data10
operator|=
operator|(
expr|struct
name|scsi_read_defect_data_hdr_10
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|data10
operator|->
name|format
operator|=
name|format
expr_stmt|;
name|scsi_ulto2b
argument_list|(
literal|0
argument_list|,
name|data10
operator|->
name|length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|data12
operator|=
operator|(
expr|struct
name|scsi_read_defect_data_hdr_12
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|data12
operator|->
name|format
operator|=
name|format
expr_stmt|;
name|scsi_ulto2b
argument_list|(
literal|0
argument_list|,
name|data12
operator|->
name|generation
argument_list|)
expr_stmt|;
name|scsi_ulto4b
argument_list|(
literal|0
argument_list|,
name|data12
operator|->
name|length
argument_list|)
expr_stmt|;
block|}
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_report_tagret_port_groups
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|CTL_SOFTC
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
name|CTL_LUN
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|struct
name|scsi_maintenance_in
modifier|*
name|cdb
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|int
name|alloc_len
decl_stmt|,
name|ext
decl_stmt|,
name|total_len
init|=
literal|0
decl_stmt|,
name|g
decl_stmt|,
name|pc
decl_stmt|,
name|pg
decl_stmt|,
name|ts
decl_stmt|,
name|os
decl_stmt|;
name|int
name|num_ha_groups
decl_stmt|,
name|num_target_ports
decl_stmt|,
name|shared_group
decl_stmt|;
name|struct
name|ctl_port
modifier|*
name|port
decl_stmt|;
name|struct
name|scsi_target_group_data
modifier|*
name|rtg_ptr
decl_stmt|;
name|struct
name|scsi_target_group_data_extended
modifier|*
name|rtg_ext_ptr
decl_stmt|;
name|struct
name|scsi_target_port_group_descriptor
modifier|*
name|tpg_desc
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_report_tagret_port_groups\n"
operator|)
argument_list|)
expr_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_maintenance_in
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|retval
operator|=
name|CTL_RETVAL_COMPLETE
expr_stmt|;
switch|switch
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|STG_PDF_MASK
condition|)
block|{
case|case
name|STG_PDF_LENGTH
case|:
name|ext
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|STG_PDF_EXTENDED
case|:
name|ext
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|ctl_set_invalid_field
argument_list|(
comment|/*ctsio*/
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|2
argument_list|,
comment|/*bit_valid*/
literal|1
argument_list|,
comment|/*bit*/
literal|5
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
name|num_target_ports
operator|=
literal|0
expr_stmt|;
name|shared_group
operator|=
operator|(
name|softc
operator|->
name|is_single
operator|!=
literal|0
operator|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|port
argument_list|,
argument|&softc->port_list
argument_list|,
argument|links
argument_list|)
block|{
if|if
condition|(
operator|(
name|port
operator|->
name|status
operator|&
name|CTL_PORT_STATUS_ONLINE
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|ctl_lun_map_to_port
argument_list|(
name|port
argument_list|,
name|lun
operator|->
name|lun
argument_list|)
operator|==
name|UINT32_MAX
condition|)
continue|continue;
name|num_target_ports
operator|++
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|status
operator|&
name|CTL_PORT_STATUS_HA_SHARED
condition|)
name|shared_group
operator|=
literal|1
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|num_ha_groups
operator|=
operator|(
name|softc
operator|->
name|is_single
operator|)
condition|?
literal|0
else|:
name|NUM_HA_SHELVES
expr_stmt|;
if|if
condition|(
name|ext
condition|)
name|total_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_target_group_data_extended
argument_list|)
expr_stmt|;
else|else
name|total_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_target_group_data
argument_list|)
expr_stmt|;
name|total_len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_target_port_group_descriptor
argument_list|)
operator|*
operator|(
name|shared_group
operator|+
name|num_ha_groups
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_target_port_descriptor
argument_list|)
operator|*
name|num_target_ports
expr_stmt|;
name|alloc_len
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
name|total_len
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|min
argument_list|(
name|total_len
argument_list|,
name|alloc_len
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|ctsio
operator|->
name|kern_data_len
expr_stmt|;
if|if
condition|(
name|ext
condition|)
block|{
name|rtg_ext_ptr
operator|=
operator|(
expr|struct
name|scsi_target_group_data_extended
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|total_len
operator|-
literal|4
argument_list|,
name|rtg_ext_ptr
operator|->
name|length
argument_list|)
expr_stmt|;
name|rtg_ext_ptr
operator|->
name|format_type
operator|=
literal|0x10
expr_stmt|;
name|rtg_ext_ptr
operator|->
name|implicit_transition_time
operator|=
literal|0
expr_stmt|;
name|tpg_desc
operator|=
operator|&
name|rtg_ext_ptr
operator|->
name|groups
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|rtg_ptr
operator|=
operator|(
expr|struct
name|scsi_target_group_data
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|total_len
operator|-
literal|4
argument_list|,
name|rtg_ptr
operator|->
name|length
argument_list|)
expr_stmt|;
name|tpg_desc
operator|=
operator|&
name|rtg_ptr
operator|->
name|groups
index|[
literal|0
index|]
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|pg
operator|=
name|softc
operator|->
name|port_min
operator|/
name|softc
operator|->
name|port_cnt
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|flags
operator|&
operator|(
name|CTL_LUN_PRIMARY_SC
operator||
name|CTL_LUN_PEER_SC_PRIMARY
operator|)
condition|)
block|{
comment|/* Some shelf is known to be primary. */
if|if
condition|(
name|softc
operator|->
name|ha_link
operator|==
name|CTL_HA_LINK_OFFLINE
condition|)
name|os
operator|=
name|TPG_ASYMMETRIC_ACCESS_UNAVAILABLE
expr_stmt|;
elseif|else
if|if
condition|(
name|softc
operator|->
name|ha_link
operator|==
name|CTL_HA_LINK_UNKNOWN
condition|)
name|os
operator|=
name|TPG_ASYMMETRIC_ACCESS_TRANSITIONING
expr_stmt|;
elseif|else
if|if
condition|(
name|softc
operator|->
name|ha_mode
operator|==
name|CTL_HA_MODE_ACT_STBY
condition|)
name|os
operator|=
name|TPG_ASYMMETRIC_ACCESS_STANDBY
expr_stmt|;
else|else
name|os
operator|=
name|TPG_ASYMMETRIC_ACCESS_NONOPTIMIZED
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_PRIMARY_SC
condition|)
block|{
name|ts
operator|=
name|TPG_ASYMMETRIC_ACCESS_OPTIMIZED
expr_stmt|;
block|}
else|else
block|{
name|ts
operator|=
name|os
expr_stmt|;
name|os
operator|=
name|TPG_ASYMMETRIC_ACCESS_OPTIMIZED
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* No known primary shelf. */
if|if
condition|(
name|softc
operator|->
name|ha_link
operator|==
name|CTL_HA_LINK_OFFLINE
condition|)
block|{
name|ts
operator|=
name|TPG_ASYMMETRIC_ACCESS_UNAVAILABLE
expr_stmt|;
name|os
operator|=
name|TPG_ASYMMETRIC_ACCESS_OPTIMIZED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|softc
operator|->
name|ha_link
operator|==
name|CTL_HA_LINK_UNKNOWN
condition|)
block|{
name|ts
operator|=
name|TPG_ASYMMETRIC_ACCESS_TRANSITIONING
expr_stmt|;
name|os
operator|=
name|TPG_ASYMMETRIC_ACCESS_OPTIMIZED
expr_stmt|;
block|}
else|else
block|{
name|ts
operator|=
name|os
operator|=
name|TPG_ASYMMETRIC_ACCESS_TRANSITIONING
expr_stmt|;
block|}
block|}
if|if
condition|(
name|shared_group
condition|)
block|{
name|tpg_desc
operator|->
name|pref_state
operator|=
name|ts
expr_stmt|;
name|tpg_desc
operator|->
name|support
operator|=
name|TPG_AO_SUP
operator||
name|TPG_AN_SUP
operator||
name|TPG_S_SUP
operator||
name|TPG_U_SUP
operator||
name|TPG_T_SUP
expr_stmt|;
name|scsi_ulto2b
argument_list|(
literal|1
argument_list|,
name|tpg_desc
operator|->
name|target_port_group
argument_list|)
expr_stmt|;
name|tpg_desc
operator|->
name|status
operator|=
name|TPG_IMPLICIT
expr_stmt|;
name|pc
operator|=
literal|0
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|port
argument_list|,
argument|&softc->port_list
argument_list|,
argument|links
argument_list|)
block|{
if|if
condition|(
operator|(
name|port
operator|->
name|status
operator|&
name|CTL_PORT_STATUS_ONLINE
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|!
name|softc
operator|->
name|is_single
operator|&&
operator|(
name|port
operator|->
name|status
operator|&
name|CTL_PORT_STATUS_HA_SHARED
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|ctl_lun_map_to_port
argument_list|(
name|port
argument_list|,
name|lun
operator|->
name|lun
argument_list|)
operator|==
name|UINT32_MAX
condition|)
continue|continue;
name|scsi_ulto2b
argument_list|(
name|port
operator|->
name|targ_port
argument_list|,
name|tpg_desc
operator|->
name|descriptors
index|[
name|pc
index|]
operator|.
name|relative_target_port_identifier
argument_list|)
expr_stmt|;
name|pc
operator|++
expr_stmt|;
block|}
name|tpg_desc
operator|->
name|target_port_count
operator|=
name|pc
expr_stmt|;
name|tpg_desc
operator|=
operator|(
expr|struct
name|scsi_target_port_group_descriptor
operator|*
operator|)
operator|&
name|tpg_desc
operator|->
name|descriptors
index|[
name|pc
index|]
expr_stmt|;
block|}
for|for
control|(
name|g
operator|=
literal|0
init|;
name|g
operator|<
name|num_ha_groups
condition|;
name|g
operator|++
control|)
block|{
name|tpg_desc
operator|->
name|pref_state
operator|=
operator|(
name|g
operator|==
name|pg
operator|)
condition|?
name|ts
else|:
name|os
expr_stmt|;
name|tpg_desc
operator|->
name|support
operator|=
name|TPG_AO_SUP
operator||
name|TPG_AN_SUP
operator||
name|TPG_S_SUP
operator||
name|TPG_U_SUP
operator||
name|TPG_T_SUP
expr_stmt|;
name|scsi_ulto2b
argument_list|(
literal|2
operator|+
name|g
argument_list|,
name|tpg_desc
operator|->
name|target_port_group
argument_list|)
expr_stmt|;
name|tpg_desc
operator|->
name|status
operator|=
name|TPG_IMPLICIT
expr_stmt|;
name|pc
operator|=
literal|0
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|port
argument_list|,
argument|&softc->port_list
argument_list|,
argument|links
argument_list|)
block|{
if|if
condition|(
name|port
operator|->
name|targ_port
operator|<
name|g
operator|*
name|softc
operator|->
name|port_cnt
operator|||
name|port
operator|->
name|targ_port
operator|>=
operator|(
name|g
operator|+
literal|1
operator|)
operator|*
name|softc
operator|->
name|port_cnt
condition|)
continue|continue;
if|if
condition|(
operator|(
name|port
operator|->
name|status
operator|&
name|CTL_PORT_STATUS_ONLINE
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|port
operator|->
name|status
operator|&
name|CTL_PORT_STATUS_HA_SHARED
condition|)
continue|continue;
if|if
condition|(
name|ctl_lun_map_to_port
argument_list|(
name|port
argument_list|,
name|lun
operator|->
name|lun
argument_list|)
operator|==
name|UINT32_MAX
condition|)
continue|continue;
name|scsi_ulto2b
argument_list|(
name|port
operator|->
name|targ_port
argument_list|,
name|tpg_desc
operator|->
name|descriptors
index|[
name|pc
index|]
operator|.
name|relative_target_port_identifier
argument_list|)
expr_stmt|;
name|pc
operator|++
expr_stmt|;
block|}
name|tpg_desc
operator|->
name|target_port_count
operator|=
name|pc
expr_stmt|;
name|tpg_desc
operator|=
operator|(
expr|struct
name|scsi_target_port_group_descriptor
operator|*
operator|)
operator|&
name|tpg_desc
operator|->
name|descriptors
index|[
name|pc
index|]
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_report_supported_opcodes
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
name|CTL_LUN
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|struct
name|scsi_report_supported_opcodes
modifier|*
name|cdb
decl_stmt|;
specifier|const
name|struct
name|ctl_cmd_entry
modifier|*
name|entry
decl_stmt|,
modifier|*
name|sentry
decl_stmt|;
name|struct
name|scsi_report_supported_opcodes_all
modifier|*
name|all
decl_stmt|;
name|struct
name|scsi_report_supported_opcodes_descr
modifier|*
name|descr
decl_stmt|;
name|struct
name|scsi_report_supported_opcodes_one
modifier|*
name|one
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|int
name|alloc_len
decl_stmt|,
name|total_len
decl_stmt|;
name|int
name|opcode
decl_stmt|,
name|service_action
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|num
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_report_supported_opcodes\n"
operator|)
argument_list|)
expr_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_report_supported_opcodes
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|retval
operator|=
name|CTL_RETVAL_COMPLETE
expr_stmt|;
name|opcode
operator|=
name|cdb
operator|->
name|requested_opcode
expr_stmt|;
name|service_action
operator|=
name|scsi_2btoul
argument_list|(
name|cdb
operator|->
name|requested_service_action
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cdb
operator|->
name|options
operator|&
name|RSO_OPTIONS_MASK
condition|)
block|{
case|case
name|RSO_OPTIONS_ALL
case|:
name|num
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|entry
operator|=
operator|&
name|ctl_cmd_table
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|flags
operator|&
name|CTL_CMD_FLAG_SA5
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|32
condition|;
name|j
operator|++
control|)
block|{
name|sentry
operator|=
operator|&
operator|(
operator|(
specifier|const
expr|struct
name|ctl_cmd_entry
operator|*
operator|)
name|entry
operator|->
name|execute
operator|)
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|ctl_cmd_applicable
argument_list|(
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
argument_list|,
name|sentry
argument_list|)
condition|)
name|num
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ctl_cmd_applicable
argument_list|(
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
argument_list|,
name|entry
argument_list|)
condition|)
name|num
operator|++
expr_stmt|;
block|}
block|}
name|total_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_report_supported_opcodes_all
argument_list|)
operator|+
name|num
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_report_supported_opcodes_descr
argument_list|)
expr_stmt|;
break|break;
case|case
name|RSO_OPTIONS_OC
case|:
if|if
condition|(
name|ctl_cmd_table
index|[
name|opcode
index|]
operator|.
name|flags
operator|&
name|CTL_CMD_FLAG_SA5
condition|)
block|{
name|ctl_set_invalid_field
argument_list|(
comment|/*ctsio*/
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|2
argument_list|,
comment|/*bit_valid*/
literal|1
argument_list|,
comment|/*bit*/
literal|2
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
name|total_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_report_supported_opcodes_one
argument_list|)
operator|+
literal|32
expr_stmt|;
break|break;
case|case
name|RSO_OPTIONS_OC_SA
case|:
if|if
condition|(
operator|(
name|ctl_cmd_table
index|[
name|opcode
index|]
operator|.
name|flags
operator|&
name|CTL_CMD_FLAG_SA5
operator|)
operator|==
literal|0
operator|||
name|service_action
operator|>=
literal|32
condition|)
block|{
name|ctl_set_invalid_field
argument_list|(
comment|/*ctsio*/
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|2
argument_list|,
comment|/*bit_valid*/
literal|1
argument_list|,
comment|/*bit*/
literal|2
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
comment|/* FALLTHROUGH */
case|case
name|RSO_OPTIONS_OC_ASA
case|:
name|total_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_report_supported_opcodes_one
argument_list|)
operator|+
literal|32
expr_stmt|;
break|break;
default|default:
name|ctl_set_invalid_field
argument_list|(
comment|/*ctsio*/
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|2
argument_list|,
comment|/*bit_valid*/
literal|1
argument_list|,
comment|/*bit*/
literal|2
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
name|alloc_len
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
name|total_len
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|min
argument_list|(
name|total_len
argument_list|,
name|alloc_len
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|ctsio
operator|->
name|kern_data_len
expr_stmt|;
switch|switch
condition|(
name|cdb
operator|->
name|options
operator|&
name|RSO_OPTIONS_MASK
condition|)
block|{
case|case
name|RSO_OPTIONS_ALL
case|:
name|all
operator|=
operator|(
expr|struct
name|scsi_report_supported_opcodes_all
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|num
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|entry
operator|=
operator|&
name|ctl_cmd_table
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|flags
operator|&
name|CTL_CMD_FLAG_SA5
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|32
condition|;
name|j
operator|++
control|)
block|{
name|sentry
operator|=
operator|&
operator|(
operator|(
specifier|const
expr|struct
name|ctl_cmd_entry
operator|*
operator|)
name|entry
operator|->
name|execute
operator|)
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|ctl_cmd_applicable
argument_list|(
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
argument_list|,
name|sentry
argument_list|)
condition|)
continue|continue;
name|descr
operator|=
operator|&
name|all
operator|->
name|descr
index|[
name|num
operator|++
index|]
expr_stmt|;
name|descr
operator|->
name|opcode
operator|=
name|i
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|j
argument_list|,
name|descr
operator|->
name|service_action
argument_list|)
expr_stmt|;
name|descr
operator|->
name|flags
operator|=
name|RSO_SERVACTV
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|sentry
operator|->
name|length
argument_list|,
name|descr
operator|->
name|cdb_length
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|ctl_cmd_applicable
argument_list|(
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
argument_list|,
name|entry
argument_list|)
condition|)
continue|continue;
name|descr
operator|=
operator|&
name|all
operator|->
name|descr
index|[
name|num
operator|++
index|]
expr_stmt|;
name|descr
operator|->
name|opcode
operator|=
name|i
expr_stmt|;
name|scsi_ulto2b
argument_list|(
literal|0
argument_list|,
name|descr
operator|->
name|service_action
argument_list|)
expr_stmt|;
name|descr
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|entry
operator|->
name|length
argument_list|,
name|descr
operator|->
name|cdb_length
argument_list|)
expr_stmt|;
block|}
block|}
name|scsi_ulto4b
argument_list|(
name|num
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_report_supported_opcodes_descr
argument_list|)
argument_list|,
name|all
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|RSO_OPTIONS_OC
case|:
name|one
operator|=
operator|(
expr|struct
name|scsi_report_supported_opcodes_one
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|entry
operator|=
operator|&
name|ctl_cmd_table
index|[
name|opcode
index|]
expr_stmt|;
goto|goto
name|fill_one
goto|;
case|case
name|RSO_OPTIONS_OC_SA
case|:
name|one
operator|=
operator|(
expr|struct
name|scsi_report_supported_opcodes_one
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|entry
operator|=
operator|&
name|ctl_cmd_table
index|[
name|opcode
index|]
expr_stmt|;
name|entry
operator|=
operator|&
operator|(
operator|(
specifier|const
expr|struct
name|ctl_cmd_entry
operator|*
operator|)
name|entry
operator|->
name|execute
operator|)
index|[
name|service_action
index|]
expr_stmt|;
name|fill_one
label|:
if|if
condition|(
name|ctl_cmd_applicable
argument_list|(
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
argument_list|,
name|entry
argument_list|)
condition|)
block|{
name|one
operator|->
name|support
operator|=
literal|3
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|entry
operator|->
name|length
argument_list|,
name|one
operator|->
name|cdb_length
argument_list|)
expr_stmt|;
name|one
operator|->
name|cdb_usage
index|[
literal|0
index|]
operator|=
name|opcode
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|one
operator|->
name|cdb_usage
index|[
literal|1
index|]
argument_list|,
name|entry
operator|->
name|usage
argument_list|,
name|entry
operator|->
name|length
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|one
operator|->
name|support
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|RSO_OPTIONS_OC_ASA
case|:
name|one
operator|=
operator|(
expr|struct
name|scsi_report_supported_opcodes_one
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|entry
operator|=
operator|&
name|ctl_cmd_table
index|[
name|opcode
index|]
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|flags
operator|&
name|CTL_CMD_FLAG_SA5
condition|)
block|{
name|entry
operator|=
operator|&
operator|(
operator|(
specifier|const
expr|struct
name|ctl_cmd_entry
operator|*
operator|)
name|entry
operator|->
name|execute
operator|)
index|[
name|service_action
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|service_action
operator|!=
literal|0
condition|)
block|{
name|one
operator|->
name|support
operator|=
literal|1
expr_stmt|;
break|break;
block|}
goto|goto
name|fill_one
goto|;
block|}
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_report_supported_tmf
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|scsi_report_supported_tmf
modifier|*
name|cdb
decl_stmt|;
name|struct
name|scsi_report_supported_tmf_ext_data
modifier|*
name|data
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|int
name|alloc_len
decl_stmt|,
name|total_len
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_report_supported_tmf\n"
operator|)
argument_list|)
expr_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_report_supported_tmf
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|retval
operator|=
name|CTL_RETVAL_COMPLETE
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|options
operator|&
name|RST_REPD
condition|)
name|total_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_report_supported_tmf_ext_data
argument_list|)
expr_stmt|;
else|else
name|total_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_report_supported_tmf_data
argument_list|)
expr_stmt|;
name|alloc_len
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
name|total_len
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|min
argument_list|(
name|total_len
argument_list|,
name|alloc_len
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|ctsio
operator|->
name|kern_data_len
expr_stmt|;
name|data
operator|=
operator|(
expr|struct
name|scsi_report_supported_tmf_ext_data
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|data
operator|->
name|byte1
operator||=
name|RST_ATS
operator||
name|RST_ATSS
operator||
name|RST_CTSS
operator||
name|RST_LURS
operator||
name|RST_QTS
operator||
name|RST_TRS
expr_stmt|;
name|data
operator|->
name|byte2
operator||=
name|RST_QAES
operator||
name|RST_QTSS
operator||
name|RST_ITNRS
expr_stmt|;
name|data
operator|->
name|length
operator|=
name|total_len
operator|-
literal|4
expr_stmt|;
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_report_timestamp
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|scsi_report_timestamp
modifier|*
name|cdb
decl_stmt|;
name|struct
name|scsi_report_timestamp_data
modifier|*
name|data
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|int64_t
name|timestamp
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|int
name|alloc_len
decl_stmt|,
name|total_len
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_report_timestamp\n"
operator|)
argument_list|)
expr_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_report_timestamp
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|retval
operator|=
name|CTL_RETVAL_COMPLETE
expr_stmt|;
name|total_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_report_timestamp_data
argument_list|)
expr_stmt|;
name|alloc_len
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
name|total_len
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|min
argument_list|(
name|total_len
argument_list|,
name|alloc_len
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|ctsio
operator|->
name|kern_data_len
expr_stmt|;
name|data
operator|=
operator|(
expr|struct
name|scsi_report_timestamp_data
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|scsi_ulto2b
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
operator|-
literal|2
argument_list|,
name|data
operator|->
name|length
argument_list|)
expr_stmt|;
name|data
operator|->
name|origin
operator|=
name|RTS_ORIG_OUTSIDE
expr_stmt|;
name|getmicrotime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|timestamp
operator|=
operator|(
name|int64_t
operator|)
name|tv
operator|.
name|tv_sec
operator|*
literal|1000
operator|+
name|tv
operator|.
name|tv_usec
operator|/
literal|1000
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|timestamp
operator|>>
literal|16
argument_list|,
name|data
operator|->
name|timestamp
argument_list|)
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|timestamp
operator|&
literal|0xffff
argument_list|,
operator|&
name|data
operator|->
name|timestamp
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_persistent_reserve_in
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|CTL_SOFTC
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
name|CTL_LUN
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|struct
name|scsi_per_res_in
modifier|*
name|cdb
decl_stmt|;
name|int
name|alloc_len
decl_stmt|,
name|total_len
init|=
literal|0
decl_stmt|;
comment|/* struct scsi_per_res_in_rsrv in_data; */
name|uint64_t
name|key
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_persistent_reserve_in\n"
operator|)
argument_list|)
expr_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_per_res_in
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|alloc_len
operator|=
name|scsi_2btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
name|retry
label|:
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cdb
operator|->
name|action
condition|)
block|{
case|case
name|SPRI_RK
case|:
comment|/* read keys */
name|total_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_per_res_in_keys
argument_list|)
operator|+
name|lun
operator|->
name|pr_key_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_per_res_key
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPRI_RR
case|:
comment|/* read reservation */
if|if
condition|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_PR_RESERVED
condition|)
name|total_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_per_res_in_rsrv
argument_list|)
expr_stmt|;
else|else
name|total_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_per_res_in_header
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPRI_RC
case|:
comment|/* report capabilities */
name|total_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_per_res_cap
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPRI_RS
case|:
comment|/* read full status */
name|total_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_per_res_in_header
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_per_res_in_full_desc
argument_list|)
operator|+
literal|256
operator|)
operator|*
name|lun
operator|->
name|pr_key_count
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: Invalid PR type %#x"
argument_list|,
name|__func__
argument_list|,
name|cdb
operator|->
name|action
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
name|total_len
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|min
argument_list|(
name|total_len
argument_list|,
name|alloc_len
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|ctsio
operator|->
name|kern_data_len
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cdb
operator|->
name|action
condition|)
block|{
case|case
name|SPRI_RK
case|:
block|{
comment|// read keys
name|struct
name|scsi_per_res_in_keys
modifier|*
name|res_keys
decl_stmt|;
name|int
name|i
decl_stmt|,
name|key_count
decl_stmt|;
name|res_keys
operator|=
operator|(
expr|struct
name|scsi_per_res_in_keys
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
comment|/* 		 * We had to drop the lock to allocate our buffer, which 		 * leaves time for someone to come in with another 		 * persistent reservation.  (That is unlikely, though, 		 * since this should be the only persistent reservation 		 * command active right now.) 		 */
if|if
condition|(
name|total_len
operator|!=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_per_res_in_keys
argument_list|)
operator|+
operator|(
name|lun
operator|->
name|pr_key_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_per_res_key
argument_list|)
operator|)
operator|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: reservation length changed, retrying\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|scsi_ulto4b
argument_list|(
name|lun
operator|->
name|pr_generation
argument_list|,
name|res_keys
operator|->
name|header
operator|.
name|generation
argument_list|)
expr_stmt|;
name|scsi_ulto4b
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_per_res_key
argument_list|)
operator|*
name|lun
operator|->
name|pr_key_count
argument_list|,
name|res_keys
operator|->
name|header
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|key_count
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_MAX_INITIATORS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|key
operator|=
name|ctl_get_prkey
argument_list|(
name|lun
argument_list|,
name|i
argument_list|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* 			 * We used lun->pr_key_count to calculate the 			 * size to allocate.  If it turns out the number of 			 * initiators with the registered flag set is 			 * larger than that (i.e. they haven't been kept in 			 * sync), we've got a problem. 			 */
if|if
condition|(
name|key_count
operator|>=
name|lun
operator|->
name|pr_key_count
condition|)
block|{
name|key_count
operator|++
expr_stmt|;
continue|continue;
block|}
name|scsi_u64to8b
argument_list|(
name|key
argument_list|,
name|res_keys
operator|->
name|keys
index|[
name|key_count
index|]
operator|.
name|key
argument_list|)
expr_stmt|;
name|key_count
operator|++
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SPRI_RR
case|:
block|{
comment|// read reservation
name|struct
name|scsi_per_res_in_rsrv
modifier|*
name|res
decl_stmt|;
name|int
name|tmp_len
decl_stmt|,
name|header_only
decl_stmt|;
name|res
operator|=
operator|(
expr|struct
name|scsi_per_res_in_rsrv
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|lun
operator|->
name|pr_generation
argument_list|,
name|res
operator|->
name|header
operator|.
name|generation
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_PR_RESERVED
condition|)
block|{
name|tmp_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_per_res_in_rsrv
argument_list|)
expr_stmt|;
name|scsi_ulto4b
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_per_res_in_rsrv_data
argument_list|)
argument_list|,
name|res
operator|->
name|header
operator|.
name|length
argument_list|)
expr_stmt|;
name|header_only
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|tmp_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_per_res_in_header
argument_list|)
expr_stmt|;
name|scsi_ulto4b
argument_list|(
literal|0
argument_list|,
name|res
operator|->
name|header
operator|.
name|length
argument_list|)
expr_stmt|;
name|header_only
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 		 * We had to drop the lock to allocate our buffer, which 		 * leaves time for someone to come in with another 		 * persistent reservation.  (That is unlikely, though, 		 * since this should be the only persistent reservation 		 * command active right now.) 		 */
if|if
condition|(
name|tmp_len
operator|!=
name|total_len
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: reservation status changed, retrying\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
comment|/* 		 * No reservation held, so we're done. 		 */
if|if
condition|(
name|header_only
operator|!=
literal|0
condition|)
break|break;
comment|/* 		 * If the registration is an All Registrants type, the key 		 * is 0, since it doesn't really matter. 		 */
if|if
condition|(
name|lun
operator|->
name|pr_res_idx
operator|!=
name|CTL_PR_ALL_REGISTRANTS
condition|)
block|{
name|scsi_u64to8b
argument_list|(
name|ctl_get_prkey
argument_list|(
name|lun
argument_list|,
name|lun
operator|->
name|pr_res_idx
argument_list|)
argument_list|,
name|res
operator|->
name|data
operator|.
name|reservation
argument_list|)
expr_stmt|;
block|}
name|res
operator|->
name|data
operator|.
name|scopetype
operator|=
name|lun
operator|->
name|pr_res_type
expr_stmt|;
break|break;
block|}
case|case
name|SPRI_RC
case|:
comment|//report capabilities
block|{
name|struct
name|scsi_per_res_cap
modifier|*
name|res_cap
decl_stmt|;
name|uint16_t
name|type_mask
decl_stmt|;
name|res_cap
operator|=
operator|(
expr|struct
name|scsi_per_res_cap
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|scsi_ulto2b
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|res_cap
argument_list|)
argument_list|,
name|res_cap
operator|->
name|length
argument_list|)
expr_stmt|;
name|res_cap
operator|->
name|flags1
operator|=
name|SPRI_CRH
expr_stmt|;
name|res_cap
operator|->
name|flags2
operator|=
name|SPRI_TMV
operator||
name|SPRI_ALLOW_5
expr_stmt|;
name|type_mask
operator|=
name|SPRI_TM_WR_EX_AR
operator||
name|SPRI_TM_EX_AC_RO
operator||
name|SPRI_TM_WR_EX_RO
operator||
name|SPRI_TM_EX_AC
operator||
name|SPRI_TM_WR_EX
operator||
name|SPRI_TM_EX_AC_AR
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|type_mask
argument_list|,
name|res_cap
operator|->
name|type_mask
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SPRI_RS
case|:
block|{
comment|// read full status
name|struct
name|scsi_per_res_in_full
modifier|*
name|res_status
decl_stmt|;
name|struct
name|scsi_per_res_in_full_desc
modifier|*
name|res_desc
decl_stmt|;
name|struct
name|ctl_port
modifier|*
name|port
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|res_status
operator|=
operator|(
expr|struct
name|scsi_per_res_in_full
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
comment|/* 		 * We had to drop the lock to allocate our buffer, which 		 * leaves time for someone to come in with another 		 * persistent reservation.  (That is unlikely, though, 		 * since this should be the only persistent reservation 		 * command active right now.) 		 */
if|if
condition|(
name|total_len
operator|<
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_per_res_in_header
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_per_res_in_full_desc
argument_list|)
operator|+
literal|256
operator|)
operator|*
name|lun
operator|->
name|pr_key_count
operator|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: reservation length changed, retrying\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|scsi_ulto4b
argument_list|(
name|lun
operator|->
name|pr_generation
argument_list|,
name|res_status
operator|->
name|header
operator|.
name|generation
argument_list|)
expr_stmt|;
name|res_desc
operator|=
operator|&
name|res_status
operator|->
name|desc
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_MAX_INITIATORS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|key
operator|=
name|ctl_get_prkey
argument_list|(
name|lun
argument_list|,
name|i
argument_list|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|scsi_u64to8b
argument_list|(
name|key
argument_list|,
name|res_desc
operator|->
name|res_key
operator|.
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_PR_RESERVED
operator|)
operator|&&
operator|(
name|lun
operator|->
name|pr_res_idx
operator|==
name|i
operator|||
name|lun
operator|->
name|pr_res_idx
operator|==
name|CTL_PR_ALL_REGISTRANTS
operator|)
condition|)
block|{
name|res_desc
operator|->
name|flags
operator|=
name|SPRI_FULL_R_HOLDER
expr_stmt|;
name|res_desc
operator|->
name|scopetype
operator|=
name|lun
operator|->
name|pr_res_type
expr_stmt|;
block|}
name|scsi_ulto2b
argument_list|(
name|i
operator|/
name|CTL_MAX_INIT_PER_PORT
argument_list|,
name|res_desc
operator|->
name|rel_trgt_port_id
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|port
operator|=
name|softc
operator|->
name|ctl_ports
index|[
name|i
operator|/
name|CTL_MAX_INIT_PER_PORT
index|]
expr_stmt|;
if|if
condition|(
name|port
operator|!=
name|NULL
condition|)
name|len
operator|=
name|ctl_create_iid
argument_list|(
name|port
argument_list|,
name|i
operator|%
name|CTL_MAX_INIT_PER_PORT
argument_list|,
name|res_desc
operator|->
name|transport_id
argument_list|)
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|len
argument_list|,
name|res_desc
operator|->
name|additional_length
argument_list|)
expr_stmt|;
name|res_desc
operator|=
operator|(
expr|struct
name|scsi_per_res_in_full_desc
operator|*
operator|)
operator|&
name|res_desc
operator|->
name|transport_id
index|[
name|len
index|]
expr_stmt|;
block|}
name|scsi_ulto4b
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|res_desc
operator|-
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|res_status
operator|->
name|desc
index|[
literal|0
index|]
argument_list|,
name|res_status
operator|->
name|header
operator|.
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|panic
argument_list|(
literal|"%s: Invalid PR type %#x"
argument_list|,
name|__func__
argument_list|,
name|cdb
operator|->
name|action
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns 0 if ctl_persistent_reserve_out() should continue, non-zero if  * it should return.  */
end_comment

begin_function
specifier|static
name|int
name|ctl_pro_preempt
parameter_list|(
name|struct
name|ctl_softc
modifier|*
name|softc
parameter_list|,
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|,
name|uint64_t
name|res_key
parameter_list|,
name|uint64_t
name|sa_res_key
parameter_list|,
name|uint8_t
name|type
parameter_list|,
name|uint32_t
name|residx
parameter_list|,
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|struct
name|scsi_per_res_out
modifier|*
name|cdb
parameter_list|,
name|struct
name|scsi_per_res_out_parms
modifier|*
name|param
parameter_list|)
block|{
name|union
name|ctl_ha_msg
name|persis_io
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa_res_key
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|lun
operator|->
name|pr_res_idx
operator|==
name|CTL_PR_ALL_REGISTRANTS
condition|)
block|{
comment|/* validate scope and type */
if|if
condition|(
operator|(
name|cdb
operator|->
name|scope_type
operator|&
name|SPR_SCOPE_MASK
operator|)
operator|!=
name|SPR_LU_SCOPE
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctl_set_invalid_field
argument_list|(
comment|/*ctsio*/
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|2
argument_list|,
comment|/*bit_valid*/
literal|1
argument_list|,
comment|/*bit*/
literal|4
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|type
operator|>
literal|8
operator|||
name|type
operator|==
literal|2
operator|||
name|type
operator|==
literal|4
operator|||
name|type
operator|==
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctl_set_invalid_field
argument_list|(
comment|/*ctsio*/
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|2
argument_list|,
comment|/*bit_valid*/
literal|1
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 			 * Unregister everybody else and build UA for 			 * them 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_MAX_INITIATORS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|residx
operator|||
name|ctl_get_prkey
argument_list|(
name|lun
argument_list|,
name|i
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|ctl_clr_prkey
argument_list|(
name|lun
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ctl_est_ua
argument_list|(
name|lun
argument_list|,
name|i
argument_list|,
name|CTL_UA_REG_PREEMPT
argument_list|)
expr_stmt|;
block|}
name|lun
operator|->
name|pr_key_count
operator|=
literal|1
expr_stmt|;
name|lun
operator|->
name|pr_res_type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|pr_res_type
operator|!=
name|SPR_TYPE_WR_EX_AR
operator|&&
name|lun
operator|->
name|pr_res_type
operator|!=
name|SPR_TYPE_EX_AC_AR
condition|)
name|lun
operator|->
name|pr_res_idx
operator|=
name|residx
expr_stmt|;
name|lun
operator|->
name|pr_generation
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
comment|/* send msg to other side */
name|persis_io
operator|.
name|hdr
operator|.
name|nexus
operator|=
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
expr_stmt|;
name|persis_io
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_PERS_ACTION
expr_stmt|;
name|persis_io
operator|.
name|pr
operator|.
name|pr_info
operator|.
name|action
operator|=
name|CTL_PR_PREEMPT
expr_stmt|;
name|persis_io
operator|.
name|pr
operator|.
name|pr_info
operator|.
name|residx
operator|=
name|lun
operator|->
name|pr_res_idx
expr_stmt|;
name|persis_io
operator|.
name|pr
operator|.
name|pr_info
operator|.
name|res_type
operator|=
name|type
expr_stmt|;
name|memcpy
argument_list|(
name|persis_io
operator|.
name|pr
operator|.
name|pr_info
operator|.
name|sa_res_key
argument_list|,
name|param
operator|->
name|serv_act_res_key
argument_list|,
sizeof|sizeof
argument_list|(
name|param
operator|->
name|serv_act_res_key
argument_list|)
argument_list|)
expr_stmt|;
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|persis_io
argument_list|,
sizeof|sizeof
argument_list|(
name|persis_io
operator|.
name|pr
argument_list|)
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* not all registrants */
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|ctl_set_invalid_field
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|0
argument_list|,
comment|/*field*/
literal|8
argument_list|,
comment|/*bit_valid*/
literal|0
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|lun
operator|->
name|pr_res_idx
operator|==
name|CTL_PR_ALL_REGISTRANTS
operator|||
operator|!
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_PR_RESERVED
operator|)
condition|)
block|{
name|int
name|found
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|res_key
operator|==
name|sa_res_key
condition|)
block|{
comment|/* special case */
comment|/* 			 * The spec implies this is not good but doesn't 			 * say what to do. There are two choices either 			 * generate a res conflict or check condition 			 * with illegal field in parameter data. Since 			 * that is what is done when the sa_res_key is 			 * zero I'll take that approach since this has 			 * to do with the sa_res_key. 			 */
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|ctl_set_invalid_field
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|0
argument_list|,
comment|/*field*/
literal|8
argument_list|,
comment|/*bit_valid*/
literal|0
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_MAX_INITIATORS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ctl_get_prkey
argument_list|(
name|lun
argument_list|,
name|i
argument_list|)
operator|!=
name|sa_res_key
condition|)
continue|continue;
name|found
operator|=
literal|1
expr_stmt|;
name|ctl_clr_prkey
argument_list|(
name|lun
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|lun
operator|->
name|pr_key_count
operator|--
expr_stmt|;
name|ctl_est_ua
argument_list|(
name|lun
argument_list|,
name|i
argument_list|,
name|CTL_UA_REG_PREEMPT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|ctl_set_reservation_conflict
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
name|lun
operator|->
name|pr_generation
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
comment|/* send msg to other side */
name|persis_io
operator|.
name|hdr
operator|.
name|nexus
operator|=
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
expr_stmt|;
name|persis_io
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_PERS_ACTION
expr_stmt|;
name|persis_io
operator|.
name|pr
operator|.
name|pr_info
operator|.
name|action
operator|=
name|CTL_PR_PREEMPT
expr_stmt|;
name|persis_io
operator|.
name|pr
operator|.
name|pr_info
operator|.
name|residx
operator|=
name|lun
operator|->
name|pr_res_idx
expr_stmt|;
name|persis_io
operator|.
name|pr
operator|.
name|pr_info
operator|.
name|res_type
operator|=
name|type
expr_stmt|;
name|memcpy
argument_list|(
name|persis_io
operator|.
name|pr
operator|.
name|pr_info
operator|.
name|sa_res_key
argument_list|,
name|param
operator|->
name|serv_act_res_key
argument_list|,
sizeof|sizeof
argument_list|(
name|param
operator|->
name|serv_act_res_key
argument_list|)
argument_list|)
expr_stmt|;
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|persis_io
argument_list|,
sizeof|sizeof
argument_list|(
name|persis_io
operator|.
name|pr
argument_list|)
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Reserved but not all registrants */
comment|/* sa_res_key is res holder */
if|if
condition|(
name|sa_res_key
operator|==
name|ctl_get_prkey
argument_list|(
name|lun
argument_list|,
name|lun
operator|->
name|pr_res_idx
argument_list|)
condition|)
block|{
comment|/* validate scope and type */
if|if
condition|(
operator|(
name|cdb
operator|->
name|scope_type
operator|&
name|SPR_SCOPE_MASK
operator|)
operator|!=
name|SPR_LU_SCOPE
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctl_set_invalid_field
argument_list|(
comment|/*ctsio*/
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|2
argument_list|,
comment|/*bit_valid*/
literal|1
argument_list|,
comment|/*bit*/
literal|4
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|type
operator|>
literal|8
operator|||
name|type
operator|==
literal|2
operator|||
name|type
operator|==
literal|4
operator|||
name|type
operator|==
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctl_set_invalid_field
argument_list|(
comment|/*ctsio*/
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|2
argument_list|,
comment|/*bit_valid*/
literal|1
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 			 * Do the following: 			 * if sa_res_key != res_key remove all 			 * registrants w/sa_res_key and generate UA 			 * for these registrants(Registrations 			 * Preempted) if it wasn't an exclusive 			 * reservation generate UA(Reservations 			 * Preempted) for all other registered nexuses 			 * if the type has changed. Establish the new 			 * reservation and holder. If res_key and 			 * sa_res_key are the same do the above 			 * except don't unregister the res holder. 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_MAX_INITIATORS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|residx
operator|||
name|ctl_get_prkey
argument_list|(
name|lun
argument_list|,
name|i
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|sa_res_key
operator|==
name|ctl_get_prkey
argument_list|(
name|lun
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|ctl_clr_prkey
argument_list|(
name|lun
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|lun
operator|->
name|pr_key_count
operator|--
expr_stmt|;
name|ctl_est_ua
argument_list|(
name|lun
argument_list|,
name|i
argument_list|,
name|CTL_UA_REG_PREEMPT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|!=
name|lun
operator|->
name|pr_res_type
operator|&&
operator|(
name|lun
operator|->
name|pr_res_type
operator|==
name|SPR_TYPE_WR_EX_RO
operator|||
name|lun
operator|->
name|pr_res_type
operator|==
name|SPR_TYPE_EX_AC_RO
operator|)
condition|)
block|{
name|ctl_est_ua
argument_list|(
name|lun
argument_list|,
name|i
argument_list|,
name|CTL_UA_RES_RELEASE
argument_list|)
expr_stmt|;
block|}
block|}
name|lun
operator|->
name|pr_res_type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|pr_res_type
operator|!=
name|SPR_TYPE_WR_EX_AR
operator|&&
name|lun
operator|->
name|pr_res_type
operator|!=
name|SPR_TYPE_EX_AC_AR
condition|)
name|lun
operator|->
name|pr_res_idx
operator|=
name|residx
expr_stmt|;
else|else
name|lun
operator|->
name|pr_res_idx
operator|=
name|CTL_PR_ALL_REGISTRANTS
expr_stmt|;
name|lun
operator|->
name|pr_generation
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|persis_io
operator|.
name|hdr
operator|.
name|nexus
operator|=
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
expr_stmt|;
name|persis_io
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_PERS_ACTION
expr_stmt|;
name|persis_io
operator|.
name|pr
operator|.
name|pr_info
operator|.
name|action
operator|=
name|CTL_PR_PREEMPT
expr_stmt|;
name|persis_io
operator|.
name|pr
operator|.
name|pr_info
operator|.
name|residx
operator|=
name|lun
operator|->
name|pr_res_idx
expr_stmt|;
name|persis_io
operator|.
name|pr
operator|.
name|pr_info
operator|.
name|res_type
operator|=
name|type
expr_stmt|;
name|memcpy
argument_list|(
name|persis_io
operator|.
name|pr
operator|.
name|pr_info
operator|.
name|sa_res_key
argument_list|,
name|param
operator|->
name|serv_act_res_key
argument_list|,
sizeof|sizeof
argument_list|(
name|param
operator|->
name|serv_act_res_key
argument_list|)
argument_list|)
expr_stmt|;
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|persis_io
argument_list|,
sizeof|sizeof
argument_list|(
name|persis_io
operator|.
name|pr
argument_list|)
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * sa_res_key is not the res holder just 			 * remove registrants 			 */
name|int
name|found
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_MAX_INITIATORS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sa_res_key
operator|!=
name|ctl_get_prkey
argument_list|(
name|lun
argument_list|,
name|i
argument_list|)
condition|)
continue|continue;
name|found
operator|=
literal|1
expr_stmt|;
name|ctl_clr_prkey
argument_list|(
name|lun
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|lun
operator|->
name|pr_key_count
operator|--
expr_stmt|;
name|ctl_est_ua
argument_list|(
name|lun
argument_list|,
name|i
argument_list|,
name|CTL_UA_REG_PREEMPT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|ctl_set_reservation_conflict
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|lun
operator|->
name|pr_generation
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|persis_io
operator|.
name|hdr
operator|.
name|nexus
operator|=
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
expr_stmt|;
name|persis_io
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_PERS_ACTION
expr_stmt|;
name|persis_io
operator|.
name|pr
operator|.
name|pr_info
operator|.
name|action
operator|=
name|CTL_PR_PREEMPT
expr_stmt|;
name|persis_io
operator|.
name|pr
operator|.
name|pr_info
operator|.
name|residx
operator|=
name|lun
operator|->
name|pr_res_idx
expr_stmt|;
name|persis_io
operator|.
name|pr
operator|.
name|pr_info
operator|.
name|res_type
operator|=
name|type
expr_stmt|;
name|memcpy
argument_list|(
name|persis_io
operator|.
name|pr
operator|.
name|pr_info
operator|.
name|sa_res_key
argument_list|,
name|param
operator|->
name|serv_act_res_key
argument_list|,
sizeof|sizeof
argument_list|(
name|param
operator|->
name|serv_act_res_key
argument_list|)
argument_list|)
expr_stmt|;
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|persis_io
argument_list|,
sizeof|sizeof
argument_list|(
name|persis_io
operator|.
name|pr
argument_list|)
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_pro_preempt_other
parameter_list|(
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|,
name|union
name|ctl_ha_msg
modifier|*
name|msg
parameter_list|)
block|{
name|uint64_t
name|sa_res_key
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sa_res_key
operator|=
name|scsi_8btou64
argument_list|(
name|msg
operator|->
name|pr
operator|.
name|pr_info
operator|.
name|sa_res_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|pr_res_idx
operator|==
name|CTL_PR_ALL_REGISTRANTS
operator|||
name|lun
operator|->
name|pr_res_idx
operator|==
name|CTL_PR_NO_RESERVATION
operator|||
name|sa_res_key
operator|!=
name|ctl_get_prkey
argument_list|(
name|lun
argument_list|,
name|lun
operator|->
name|pr_res_idx
argument_list|)
condition|)
block|{
if|if
condition|(
name|sa_res_key
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Unregister everybody else and build UA for 			 * them 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_MAX_INITIATORS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|msg
operator|->
name|pr
operator|.
name|pr_info
operator|.
name|residx
operator|||
name|ctl_get_prkey
argument_list|(
name|lun
argument_list|,
name|i
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|ctl_clr_prkey
argument_list|(
name|lun
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ctl_est_ua
argument_list|(
name|lun
argument_list|,
name|i
argument_list|,
name|CTL_UA_REG_PREEMPT
argument_list|)
expr_stmt|;
block|}
name|lun
operator|->
name|pr_key_count
operator|=
literal|1
expr_stmt|;
name|lun
operator|->
name|pr_res_type
operator|=
name|msg
operator|->
name|pr
operator|.
name|pr_info
operator|.
name|res_type
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|pr_res_type
operator|!=
name|SPR_TYPE_WR_EX_AR
operator|&&
name|lun
operator|->
name|pr_res_type
operator|!=
name|SPR_TYPE_EX_AC_AR
condition|)
name|lun
operator|->
name|pr_res_idx
operator|=
name|msg
operator|->
name|pr
operator|.
name|pr_info
operator|.
name|residx
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_MAX_INITIATORS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sa_res_key
operator|==
name|ctl_get_prkey
argument_list|(
name|lun
argument_list|,
name|i
argument_list|)
condition|)
continue|continue;
name|ctl_clr_prkey
argument_list|(
name|lun
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|lun
operator|->
name|pr_key_count
operator|--
expr_stmt|;
name|ctl_est_ua
argument_list|(
name|lun
argument_list|,
name|i
argument_list|,
name|CTL_UA_REG_PREEMPT
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_MAX_INITIATORS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|msg
operator|->
name|pr
operator|.
name|pr_info
operator|.
name|residx
operator|||
name|ctl_get_prkey
argument_list|(
name|lun
argument_list|,
name|i
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|sa_res_key
operator|==
name|ctl_get_prkey
argument_list|(
name|lun
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|ctl_clr_prkey
argument_list|(
name|lun
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|lun
operator|->
name|pr_key_count
operator|--
expr_stmt|;
name|ctl_est_ua
argument_list|(
name|lun
argument_list|,
name|i
argument_list|,
name|CTL_UA_REG_PREEMPT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|msg
operator|->
name|pr
operator|.
name|pr_info
operator|.
name|res_type
operator|!=
name|lun
operator|->
name|pr_res_type
operator|&&
operator|(
name|lun
operator|->
name|pr_res_type
operator|==
name|SPR_TYPE_WR_EX_RO
operator|||
name|lun
operator|->
name|pr_res_type
operator|==
name|SPR_TYPE_EX_AC_RO
operator|)
condition|)
block|{
name|ctl_est_ua
argument_list|(
name|lun
argument_list|,
name|i
argument_list|,
name|CTL_UA_RES_RELEASE
argument_list|)
expr_stmt|;
block|}
block|}
name|lun
operator|->
name|pr_res_type
operator|=
name|msg
operator|->
name|pr
operator|.
name|pr_info
operator|.
name|res_type
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|pr_res_type
operator|!=
name|SPR_TYPE_WR_EX_AR
operator|&&
name|lun
operator|->
name|pr_res_type
operator|!=
name|SPR_TYPE_EX_AC_AR
condition|)
name|lun
operator|->
name|pr_res_idx
operator|=
name|msg
operator|->
name|pr
operator|.
name|pr_info
operator|.
name|residx
expr_stmt|;
else|else
name|lun
operator|->
name|pr_res_idx
operator|=
name|CTL_PR_ALL_REGISTRANTS
expr_stmt|;
block|}
name|lun
operator|->
name|pr_generation
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ctl_persistent_reserve_out
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|CTL_SOFTC
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
name|CTL_LUN
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|u_int32_t
name|param_len
decl_stmt|;
name|struct
name|scsi_per_res_out
modifier|*
name|cdb
decl_stmt|;
name|struct
name|scsi_per_res_out_parms
modifier|*
name|param
decl_stmt|;
name|uint32_t
name|residx
decl_stmt|;
name|uint64_t
name|res_key
decl_stmt|,
name|sa_res_key
decl_stmt|,
name|key
decl_stmt|;
name|uint8_t
name|type
decl_stmt|;
name|union
name|ctl_ha_msg
name|persis_io
decl_stmt|;
name|int
name|i
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_persistent_reserve_out\n"
operator|)
argument_list|)
expr_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_per_res_out
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|retval
operator|=
name|CTL_RETVAL_COMPLETE
expr_stmt|;
comment|/* 	 * We only support whole-LUN scope.  The scope& type are ignored for 	 * register, register and ignore existing key and clear. 	 * We sometimes ignore scope and type on preempts too!! 	 * Verify reservation type here as well. 	 */
name|type
operator|=
name|cdb
operator|->
name|scope_type
operator|&
name|SPR_TYPE_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|cdb
operator|->
name|action
operator|==
name|SPRO_RESERVE
operator|)
operator|||
operator|(
name|cdb
operator|->
name|action
operator|==
name|SPRO_RELEASE
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|cdb
operator|->
name|scope_type
operator|&
name|SPR_SCOPE_MASK
operator|)
operator|!=
name|SPR_LU_SCOPE
condition|)
block|{
name|ctl_set_invalid_field
argument_list|(
comment|/*ctsio*/
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|2
argument_list|,
comment|/*bit_valid*/
literal|1
argument_list|,
comment|/*bit*/
literal|4
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
if|if
condition|(
name|type
operator|>
literal|8
operator|||
name|type
operator|==
literal|2
operator|||
name|type
operator|==
literal|4
operator|||
name|type
operator|==
literal|0
condition|)
block|{
name|ctl_set_invalid_field
argument_list|(
comment|/*ctsio*/
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|2
argument_list|,
comment|/*bit_valid*/
literal|1
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
block|}
name|param_len
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ALLOCATED
operator|)
operator|==
literal|0
condition|)
block|{
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
name|param_len
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|param_len
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|param_len
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
name|param
operator|=
operator|(
expr|struct
name|scsi_per_res_out_parms
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|residx
operator|=
name|ctl_get_initindex
argument_list|(
operator|&
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
argument_list|)
expr_stmt|;
name|res_key
operator|=
name|scsi_8btou64
argument_list|(
name|param
operator|->
name|res_key
operator|.
name|key
argument_list|)
expr_stmt|;
name|sa_res_key
operator|=
name|scsi_8btou64
argument_list|(
name|param
operator|->
name|serv_act_res_key
argument_list|)
expr_stmt|;
comment|/* 	 * Validate the reservation key here except for SPRO_REG_IGNO 	 * This must be done for all other service actions 	 */
if|if
condition|(
operator|(
name|cdb
operator|->
name|action
operator|&
name|SPRO_ACTION_MASK
operator|)
operator|!=
name|SPRO_REG_IGNO
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|key
operator|=
name|ctl_get_prkey
argument_list|(
name|lun
argument_list|,
name|residx
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|res_key
operator|!=
name|key
condition|)
block|{
comment|/* 				 * The current key passed in doesn't match 				 * the one the initiator previously 				 * registered. 				 */
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|ctl_set_reservation_conflict
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|cdb
operator|->
name|action
operator|&
name|SPRO_ACTION_MASK
operator|)
operator|!=
name|SPRO_REGISTER
condition|)
block|{
comment|/* 			 * We are not registered 			 */
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|ctl_set_reservation_conflict
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|res_key
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * We are not registered and trying to register but 			 * the register key isn't zero. 			 */
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|ctl_set_reservation_conflict
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|cdb
operator|->
name|action
operator|&
name|SPRO_ACTION_MASK
condition|)
block|{
case|case
name|SPRO_REGISTER
case|:
case|case
name|SPRO_REG_IGNO
case|:
block|{
if|#
directive|if
literal|0
block|printf("Registration received\n");
endif|#
directive|endif
comment|/* 		 * We don't support any of these options, as we report in 		 * the read capabilities request (see 		 * ctl_persistent_reserve_in(), above). 		 */
if|if
condition|(
operator|(
name|param
operator|->
name|flags
operator|&
name|SPR_SPEC_I_PT
operator|)
operator|||
operator|(
name|param
operator|->
name|flags
operator|&
name|SPR_ALL_TG_PT
operator|)
operator|||
operator|(
name|param
operator|->
name|flags
operator|&
name|SPR_APTPL
operator|)
condition|)
block|{
name|int
name|bit_ptr
decl_stmt|;
if|if
condition|(
name|param
operator|->
name|flags
operator|&
name|SPR_APTPL
condition|)
name|bit_ptr
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|param
operator|->
name|flags
operator|&
name|SPR_ALL_TG_PT
condition|)
name|bit_ptr
operator|=
literal|2
expr_stmt|;
else|else
comment|/* SPR_SPEC_I_PT */
name|bit_ptr
operator|=
literal|3
expr_stmt|;
name|free
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|ctl_set_invalid_field
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|0
argument_list|,
comment|/*field*/
literal|20
argument_list|,
comment|/*bit_valid*/
literal|1
argument_list|,
comment|/*bit*/
name|bit_ptr
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
comment|/* 		 * The initiator wants to clear the 		 * key/unregister. 		 */
if|if
condition|(
name|sa_res_key
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|res_key
operator|==
literal|0
operator|&&
operator|(
name|cdb
operator|->
name|action
operator|&
name|SPRO_ACTION_MASK
operator|)
operator|==
name|SPRO_REGISTER
operator|)
operator|||
operator|(
operator|(
name|cdb
operator|->
name|action
operator|&
name|SPRO_ACTION_MASK
operator|)
operator|==
name|SPRO_REG_IGNO
operator|&&
name|ctl_get_prkey
argument_list|(
name|lun
argument_list|,
name|residx
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|ctl_clr_prkey
argument_list|(
name|lun
argument_list|,
name|residx
argument_list|)
expr_stmt|;
name|lun
operator|->
name|pr_key_count
operator|--
expr_stmt|;
if|if
condition|(
name|residx
operator|==
name|lun
operator|->
name|pr_res_idx
condition|)
block|{
name|lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_LUN_PR_RESERVED
expr_stmt|;
name|lun
operator|->
name|pr_res_idx
operator|=
name|CTL_PR_NO_RESERVATION
expr_stmt|;
if|if
condition|(
operator|(
name|lun
operator|->
name|pr_res_type
operator|==
name|SPR_TYPE_WR_EX_RO
operator|||
name|lun
operator|->
name|pr_res_type
operator|==
name|SPR_TYPE_EX_AC_RO
operator|)
operator|&&
name|lun
operator|->
name|pr_key_count
condition|)
block|{
comment|/* 					 * If the reservation is a registrants 					 * only type we need to generate a UA 					 * for other registered inits.  The 					 * sense code should be RESERVATIONS 					 * RELEASED 					 */
for|for
control|(
name|i
operator|=
name|softc
operator|->
name|init_min
init|;
name|i
operator|<
name|softc
operator|->
name|init_max
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ctl_get_prkey
argument_list|(
name|lun
argument_list|,
name|i
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|ctl_est_ua
argument_list|(
name|lun
argument_list|,
name|i
argument_list|,
name|CTL_UA_RES_RELEASE
argument_list|)
expr_stmt|;
block|}
block|}
name|lun
operator|->
name|pr_res_type
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lun
operator|->
name|pr_res_idx
operator|==
name|CTL_PR_ALL_REGISTRANTS
condition|)
block|{
if|if
condition|(
name|lun
operator|->
name|pr_key_count
operator|==
literal|0
condition|)
block|{
name|lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_LUN_PR_RESERVED
expr_stmt|;
name|lun
operator|->
name|pr_res_type
operator|=
literal|0
expr_stmt|;
name|lun
operator|->
name|pr_res_idx
operator|=
name|CTL_PR_NO_RESERVATION
expr_stmt|;
block|}
block|}
name|lun
operator|->
name|pr_generation
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|persis_io
operator|.
name|hdr
operator|.
name|nexus
operator|=
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
expr_stmt|;
name|persis_io
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_PERS_ACTION
expr_stmt|;
name|persis_io
operator|.
name|pr
operator|.
name|pr_info
operator|.
name|action
operator|=
name|CTL_PR_UNREG_KEY
expr_stmt|;
name|persis_io
operator|.
name|pr
operator|.
name|pr_info
operator|.
name|residx
operator|=
name|residx
expr_stmt|;
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|persis_io
argument_list|,
sizeof|sizeof
argument_list|(
name|persis_io
operator|.
name|pr
argument_list|)
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* sa_res_key != 0 */
block|{
comment|/* 			 * If we aren't registered currently then increment 			 * the key count and set the registered flag. 			 */
name|ctl_alloc_prkey
argument_list|(
name|lun
argument_list|,
name|residx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl_get_prkey
argument_list|(
name|lun
argument_list|,
name|residx
argument_list|)
operator|==
literal|0
condition|)
name|lun
operator|->
name|pr_key_count
operator|++
expr_stmt|;
name|ctl_set_prkey
argument_list|(
name|lun
argument_list|,
name|residx
argument_list|,
name|sa_res_key
argument_list|)
expr_stmt|;
name|lun
operator|->
name|pr_generation
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|persis_io
operator|.
name|hdr
operator|.
name|nexus
operator|=
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
expr_stmt|;
name|persis_io
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_PERS_ACTION
expr_stmt|;
name|persis_io
operator|.
name|pr
operator|.
name|pr_info
operator|.
name|action
operator|=
name|CTL_PR_REG_KEY
expr_stmt|;
name|persis_io
operator|.
name|pr
operator|.
name|pr_info
operator|.
name|residx
operator|=
name|residx
expr_stmt|;
name|memcpy
argument_list|(
name|persis_io
operator|.
name|pr
operator|.
name|pr_info
operator|.
name|sa_res_key
argument_list|,
name|param
operator|->
name|serv_act_res_key
argument_list|,
sizeof|sizeof
argument_list|(
name|param
operator|->
name|serv_act_res_key
argument_list|)
argument_list|)
expr_stmt|;
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|persis_io
argument_list|,
sizeof|sizeof
argument_list|(
name|persis_io
operator|.
name|pr
argument_list|)
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SPRO_RESERVE
case|:
if|#
directive|if
literal|0
block|printf("Reserve executed type %d\n", type);
endif|#
directive|endif
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_PR_RESERVED
condition|)
block|{
comment|/* 			 * if this isn't the reservation holder and it's 			 * not a "all registrants" type or if the type is 			 * different then we have a conflict 			 */
if|if
condition|(
operator|(
name|lun
operator|->
name|pr_res_idx
operator|!=
name|residx
operator|&&
name|lun
operator|->
name|pr_res_idx
operator|!=
name|CTL_PR_ALL_REGISTRANTS
operator|)
operator|||
name|lun
operator|->
name|pr_res_type
operator|!=
name|type
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|ctl_set_reservation_conflict
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* create a reservation */
block|{
comment|/* 			 * If it's not an "all registrants" type record 			 * reservation holder 			 */
if|if
condition|(
name|type
operator|!=
name|SPR_TYPE_WR_EX_AR
operator|&&
name|type
operator|!=
name|SPR_TYPE_EX_AC_AR
condition|)
name|lun
operator|->
name|pr_res_idx
operator|=
name|residx
expr_stmt|;
comment|/* Res holder */
else|else
name|lun
operator|->
name|pr_res_idx
operator|=
name|CTL_PR_ALL_REGISTRANTS
expr_stmt|;
name|lun
operator|->
name|flags
operator||=
name|CTL_LUN_PR_RESERVED
expr_stmt|;
name|lun
operator|->
name|pr_res_type
operator|=
name|type
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
comment|/* send msg to other side */
name|persis_io
operator|.
name|hdr
operator|.
name|nexus
operator|=
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
expr_stmt|;
name|persis_io
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_PERS_ACTION
expr_stmt|;
name|persis_io
operator|.
name|pr
operator|.
name|pr_info
operator|.
name|action
operator|=
name|CTL_PR_RESERVE
expr_stmt|;
name|persis_io
operator|.
name|pr
operator|.
name|pr_info
operator|.
name|residx
operator|=
name|lun
operator|->
name|pr_res_idx
expr_stmt|;
name|persis_io
operator|.
name|pr
operator|.
name|pr_info
operator|.
name|res_type
operator|=
name|type
expr_stmt|;
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|persis_io
argument_list|,
sizeof|sizeof
argument_list|(
name|persis_io
operator|.
name|pr
argument_list|)
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SPRO_RELEASE
case|:
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_PR_RESERVED
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* No reservation exists return good status */
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 		 * Is this nexus a reservation holder? 		 */
if|if
condition|(
name|lun
operator|->
name|pr_res_idx
operator|!=
name|residx
operator|&&
name|lun
operator|->
name|pr_res_idx
operator|!=
name|CTL_PR_ALL_REGISTRANTS
condition|)
block|{
comment|/* 			 * not a res holder return good status but 			 * do nothing 			 */
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|lun
operator|->
name|pr_res_type
operator|!=
name|type
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|ctl_set_illegal_pr_release
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
comment|/* okay to release */
name|lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_LUN_PR_RESERVED
expr_stmt|;
name|lun
operator|->
name|pr_res_idx
operator|=
name|CTL_PR_NO_RESERVATION
expr_stmt|;
name|lun
operator|->
name|pr_res_type
operator|=
literal|0
expr_stmt|;
comment|/* 		 * If this isn't an exclusive access reservation and NUAR 		 * is not set, generate UA for all other registrants. 		 */
if|if
condition|(
name|type
operator|!=
name|SPR_TYPE_EX_AC
operator|&&
name|type
operator|!=
name|SPR_TYPE_WR_EX
operator|&&
operator|(
name|lun
operator|->
name|MODE_CTRL
operator|.
name|queue_flags
operator|&
name|SCP_NUAR
operator|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
name|softc
operator|->
name|init_min
init|;
name|i
operator|<
name|softc
operator|->
name|init_max
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|residx
operator|||
name|ctl_get_prkey
argument_list|(
name|lun
argument_list|,
name|i
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|ctl_est_ua
argument_list|(
name|lun
argument_list|,
name|i
argument_list|,
name|CTL_UA_RES_RELEASE
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
comment|/* Send msg to other side */
name|persis_io
operator|.
name|hdr
operator|.
name|nexus
operator|=
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
expr_stmt|;
name|persis_io
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_PERS_ACTION
expr_stmt|;
name|persis_io
operator|.
name|pr
operator|.
name|pr_info
operator|.
name|action
operator|=
name|CTL_PR_RELEASE
expr_stmt|;
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|persis_io
argument_list|,
sizeof|sizeof
argument_list|(
name|persis_io
operator|.
name|pr
argument_list|)
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPRO_CLEAR
case|:
comment|/* send msg to other side */
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_LUN_PR_RESERVED
expr_stmt|;
name|lun
operator|->
name|pr_res_type
operator|=
literal|0
expr_stmt|;
name|lun
operator|->
name|pr_key_count
operator|=
literal|0
expr_stmt|;
name|lun
operator|->
name|pr_res_idx
operator|=
name|CTL_PR_NO_RESERVATION
expr_stmt|;
name|ctl_clr_prkey
argument_list|(
name|lun
argument_list|,
name|residx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_MAX_INITIATORS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ctl_get_prkey
argument_list|(
name|lun
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ctl_clr_prkey
argument_list|(
name|lun
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ctl_est_ua
argument_list|(
name|lun
argument_list|,
name|i
argument_list|,
name|CTL_UA_REG_PREEMPT
argument_list|)
expr_stmt|;
block|}
name|lun
operator|->
name|pr_generation
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|persis_io
operator|.
name|hdr
operator|.
name|nexus
operator|=
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
expr_stmt|;
name|persis_io
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_PERS_ACTION
expr_stmt|;
name|persis_io
operator|.
name|pr
operator|.
name|pr_info
operator|.
name|action
operator|=
name|CTL_PR_CLEAR
expr_stmt|;
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|persis_io
argument_list|,
sizeof|sizeof
argument_list|(
name|persis_io
operator|.
name|pr
argument_list|)
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPRO_PREEMPT
case|:
case|case
name|SPRO_PRE_ABO
case|:
block|{
name|int
name|nretval
decl_stmt|;
name|nretval
operator|=
name|ctl_pro_preempt
argument_list|(
name|softc
argument_list|,
name|lun
argument_list|,
name|res_key
argument_list|,
name|sa_res_key
argument_list|,
name|type
argument_list|,
name|residx
argument_list|,
name|ctsio
argument_list|,
name|cdb
argument_list|,
name|param
argument_list|)
expr_stmt|;
if|if
condition|(
name|nretval
operator|!=
literal|0
condition|)
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
break|break;
block|}
default|default:
name|panic
argument_list|(
literal|"%s: Invalid PR type %#x"
argument_list|,
name|__func__
argument_list|,
name|cdb
operator|->
name|action
argument_list|)
expr_stmt|;
block|}
name|done
label|:
name|free
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This routine is for handling a message from the other SC pertaining to  * persistent reserve out. All the error checking will have been done  * so only perorming the action need be done here to keep the two  * in sync.  */
end_comment

begin_function
specifier|static
name|void
name|ctl_hndl_per_res_out_on_other_sc
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|CTL_SOFTC
argument_list|(
name|io
argument_list|)
decl_stmt|;
name|union
name|ctl_ha_msg
modifier|*
name|msg
init|=
operator|(
expr|union
name|ctl_ha_msg
operator|*
operator|)
operator|&
name|io
operator|->
name|presio
operator|.
name|pr_msg
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint32_t
name|residx
decl_stmt|,
name|targ_lun
decl_stmt|;
name|targ_lun
operator|=
name|msg
operator|->
name|hdr
operator|.
name|nexus
operator|.
name|targ_mapped_lun
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|targ_lun
operator|>=
name|CTL_MAX_LUNS
operator|||
operator|(
name|lun
operator|=
name|softc
operator|->
name|ctl_luns
index|[
name|targ_lun
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_DISABLED
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|residx
operator|=
name|ctl_get_initindex
argument_list|(
operator|&
name|msg
operator|->
name|hdr
operator|.
name|nexus
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|msg
operator|->
name|pr
operator|.
name|pr_info
operator|.
name|action
condition|)
block|{
case|case
name|CTL_PR_REG_KEY
case|:
name|ctl_alloc_prkey
argument_list|(
name|lun
argument_list|,
name|msg
operator|->
name|pr
operator|.
name|pr_info
operator|.
name|residx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl_get_prkey
argument_list|(
name|lun
argument_list|,
name|msg
operator|->
name|pr
operator|.
name|pr_info
operator|.
name|residx
argument_list|)
operator|==
literal|0
condition|)
name|lun
operator|->
name|pr_key_count
operator|++
expr_stmt|;
name|ctl_set_prkey
argument_list|(
name|lun
argument_list|,
name|msg
operator|->
name|pr
operator|.
name|pr_info
operator|.
name|residx
argument_list|,
name|scsi_8btou64
argument_list|(
name|msg
operator|->
name|pr
operator|.
name|pr_info
operator|.
name|sa_res_key
argument_list|)
argument_list|)
expr_stmt|;
name|lun
operator|->
name|pr_generation
operator|++
expr_stmt|;
break|break;
case|case
name|CTL_PR_UNREG_KEY
case|:
name|ctl_clr_prkey
argument_list|(
name|lun
argument_list|,
name|msg
operator|->
name|pr
operator|.
name|pr_info
operator|.
name|residx
argument_list|)
expr_stmt|;
name|lun
operator|->
name|pr_key_count
operator|--
expr_stmt|;
comment|/* XXX Need to see if the reservation has been released */
comment|/* if so do we need to generate UA? */
if|if
condition|(
name|msg
operator|->
name|pr
operator|.
name|pr_info
operator|.
name|residx
operator|==
name|lun
operator|->
name|pr_res_idx
condition|)
block|{
name|lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_LUN_PR_RESERVED
expr_stmt|;
name|lun
operator|->
name|pr_res_idx
operator|=
name|CTL_PR_NO_RESERVATION
expr_stmt|;
if|if
condition|(
operator|(
name|lun
operator|->
name|pr_res_type
operator|==
name|SPR_TYPE_WR_EX_RO
operator|||
name|lun
operator|->
name|pr_res_type
operator|==
name|SPR_TYPE_EX_AC_RO
operator|)
operator|&&
name|lun
operator|->
name|pr_key_count
condition|)
block|{
comment|/* 				 * If the reservation is a registrants 				 * only type we need to generate a UA 				 * for other registered inits.  The 				 * sense code should be RESERVATIONS 				 * RELEASED 				 */
for|for
control|(
name|i
operator|=
name|softc
operator|->
name|init_min
init|;
name|i
operator|<
name|softc
operator|->
name|init_max
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ctl_get_prkey
argument_list|(
name|lun
argument_list|,
name|i
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|ctl_est_ua
argument_list|(
name|lun
argument_list|,
name|i
argument_list|,
name|CTL_UA_RES_RELEASE
argument_list|)
expr_stmt|;
block|}
block|}
name|lun
operator|->
name|pr_res_type
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lun
operator|->
name|pr_res_idx
operator|==
name|CTL_PR_ALL_REGISTRANTS
condition|)
block|{
if|if
condition|(
name|lun
operator|->
name|pr_key_count
operator|==
literal|0
condition|)
block|{
name|lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_LUN_PR_RESERVED
expr_stmt|;
name|lun
operator|->
name|pr_res_type
operator|=
literal|0
expr_stmt|;
name|lun
operator|->
name|pr_res_idx
operator|=
name|CTL_PR_NO_RESERVATION
expr_stmt|;
block|}
block|}
name|lun
operator|->
name|pr_generation
operator|++
expr_stmt|;
break|break;
case|case
name|CTL_PR_RESERVE
case|:
name|lun
operator|->
name|flags
operator||=
name|CTL_LUN_PR_RESERVED
expr_stmt|;
name|lun
operator|->
name|pr_res_type
operator|=
name|msg
operator|->
name|pr
operator|.
name|pr_info
operator|.
name|res_type
expr_stmt|;
name|lun
operator|->
name|pr_res_idx
operator|=
name|msg
operator|->
name|pr
operator|.
name|pr_info
operator|.
name|residx
expr_stmt|;
break|break;
case|case
name|CTL_PR_RELEASE
case|:
comment|/* 		 * If this isn't an exclusive access reservation and NUAR 		 * is not set, generate UA for all other registrants. 		 */
if|if
condition|(
name|lun
operator|->
name|pr_res_type
operator|!=
name|SPR_TYPE_EX_AC
operator|&&
name|lun
operator|->
name|pr_res_type
operator|!=
name|SPR_TYPE_WR_EX
operator|&&
operator|(
name|lun
operator|->
name|MODE_CTRL
operator|.
name|queue_flags
operator|&
name|SCP_NUAR
operator|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
name|softc
operator|->
name|init_min
init|;
name|i
operator|<
name|softc
operator|->
name|init_max
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|==
name|residx
operator|||
name|ctl_get_prkey
argument_list|(
name|lun
argument_list|,
name|i
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|ctl_est_ua
argument_list|(
name|lun
argument_list|,
name|i
argument_list|,
name|CTL_UA_RES_RELEASE
argument_list|)
expr_stmt|;
block|}
name|lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_LUN_PR_RESERVED
expr_stmt|;
name|lun
operator|->
name|pr_res_idx
operator|=
name|CTL_PR_NO_RESERVATION
expr_stmt|;
name|lun
operator|->
name|pr_res_type
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CTL_PR_PREEMPT
case|:
name|ctl_pro_preempt_other
argument_list|(
name|lun
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_PR_CLEAR
case|:
name|lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_LUN_PR_RESERVED
expr_stmt|;
name|lun
operator|->
name|pr_res_type
operator|=
literal|0
expr_stmt|;
name|lun
operator|->
name|pr_key_count
operator|=
literal|0
expr_stmt|;
name|lun
operator|->
name|pr_res_idx
operator|=
name|CTL_PR_NO_RESERVATION
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_MAX_INITIATORS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ctl_get_prkey
argument_list|(
name|lun
argument_list|,
name|i
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|ctl_clr_prkey
argument_list|(
name|lun
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ctl_est_ua
argument_list|(
name|lun
argument_list|,
name|i
argument_list|,
name|CTL_UA_REG_PREEMPT
argument_list|)
expr_stmt|;
block|}
name|lun
operator|->
name|pr_generation
operator|++
expr_stmt|;
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ctl_read_write
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
name|CTL_LUN
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|struct
name|ctl_lba_len_flags
modifier|*
name|lbalen
decl_stmt|;
name|uint64_t
name|lba
decl_stmt|;
name|uint32_t
name|num_blocks
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|retval
decl_stmt|;
name|int
name|isread
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_read_write: command: %#x\n"
operator|,
name|ctsio
operator|->
name|cdb
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
name|isread
operator|=
name|ctsio
operator|->
name|cdb
index|[
literal|0
index|]
operator|==
name|READ_6
operator|||
name|ctsio
operator|->
name|cdb
index|[
literal|0
index|]
operator|==
name|READ_10
operator|||
name|ctsio
operator|->
name|cdb
index|[
literal|0
index|]
operator|==
name|READ_12
operator|||
name|ctsio
operator|->
name|cdb
index|[
literal|0
index|]
operator|==
name|READ_16
expr_stmt|;
switch|switch
condition|(
name|ctsio
operator|->
name|cdb
index|[
literal|0
index|]
condition|)
block|{
case|case
name|READ_6
case|:
case|case
name|WRITE_6
case|:
block|{
name|struct
name|scsi_rw_6
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_rw_6
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|lba
operator|=
name|scsi_3btoul
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
comment|/* only 5 bits are valid in the most significant address byte */
name|lba
operator|&=
literal|0x1fffff
expr_stmt|;
name|num_blocks
operator|=
name|cdb
operator|->
name|length
expr_stmt|;
comment|/* 		 * This is correct according to SBC-2. 		 */
if|if
condition|(
name|num_blocks
operator|==
literal|0
condition|)
name|num_blocks
operator|=
literal|256
expr_stmt|;
break|break;
block|}
case|case
name|READ_10
case|:
case|case
name|WRITE_10
case|:
block|{
name|struct
name|scsi_rw_10
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_rw_10
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SRW10_FUA
condition|)
name|flags
operator||=
name|CTL_LLF_FUA
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SRW10_DPO
condition|)
name|flags
operator||=
name|CTL_LLF_DPO
expr_stmt|;
name|lba
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
name|num_blocks
operator|=
name|scsi_2btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|WRITE_VERIFY_10
case|:
block|{
name|struct
name|scsi_write_verify_10
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_write_verify_10
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|flags
operator||=
name|CTL_LLF_FUA
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SWV_DPO
condition|)
name|flags
operator||=
name|CTL_LLF_DPO
expr_stmt|;
name|lba
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
name|num_blocks
operator|=
name|scsi_2btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|READ_12
case|:
case|case
name|WRITE_12
case|:
block|{
name|struct
name|scsi_rw_12
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_rw_12
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SRW12_FUA
condition|)
name|flags
operator||=
name|CTL_LLF_FUA
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SRW12_DPO
condition|)
name|flags
operator||=
name|CTL_LLF_DPO
expr_stmt|;
name|lba
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
name|num_blocks
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|WRITE_VERIFY_12
case|:
block|{
name|struct
name|scsi_write_verify_12
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_write_verify_12
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|flags
operator||=
name|CTL_LLF_FUA
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SWV_DPO
condition|)
name|flags
operator||=
name|CTL_LLF_DPO
expr_stmt|;
name|lba
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
name|num_blocks
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|READ_16
case|:
case|case
name|WRITE_16
case|:
block|{
name|struct
name|scsi_rw_16
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_rw_16
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SRW12_FUA
condition|)
name|flags
operator||=
name|CTL_LLF_FUA
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SRW12_DPO
condition|)
name|flags
operator||=
name|CTL_LLF_DPO
expr_stmt|;
name|lba
operator|=
name|scsi_8btou64
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
name|num_blocks
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|WRITE_ATOMIC_16
case|:
block|{
name|struct
name|scsi_write_atomic_16
modifier|*
name|cdb
decl_stmt|;
if|if
condition|(
name|lun
operator|->
name|be_lun
operator|->
name|atomicblock
operator|==
literal|0
condition|)
block|{
name|ctl_set_invalid_opcode
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
name|cdb
operator|=
operator|(
expr|struct
name|scsi_write_atomic_16
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SRW12_FUA
condition|)
name|flags
operator||=
name|CTL_LLF_FUA
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SRW12_DPO
condition|)
name|flags
operator||=
name|CTL_LLF_DPO
expr_stmt|;
name|lba
operator|=
name|scsi_8btou64
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
name|num_blocks
operator|=
name|scsi_2btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_blocks
operator|>
name|lun
operator|->
name|be_lun
operator|->
name|atomicblock
condition|)
block|{
name|ctl_set_invalid_field
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|12
argument_list|,
comment|/*bit_valid*/
literal|0
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
break|break;
block|}
case|case
name|WRITE_VERIFY_16
case|:
block|{
name|struct
name|scsi_write_verify_16
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_write_verify_16
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|flags
operator||=
name|CTL_LLF_FUA
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SWV_DPO
condition|)
name|flags
operator||=
name|CTL_LLF_DPO
expr_stmt|;
name|lba
operator|=
name|scsi_8btou64
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
name|num_blocks
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
comment|/* 		 * We got a command we don't support.  This shouldn't 		 * happen, commands should be filtered out above us. 		 */
name|ctl_set_invalid_opcode
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
break|break;
comment|/* NOTREACHED */
block|}
comment|/* 	 * The first check is to make sure we're in bounds, the second 	 * check is to catch wrap-around problems.  If the lba + num blocks 	 * is less than the lba, then we've wrapped around and the block 	 * range is invalid anyway. 	 */
if|if
condition|(
operator|(
operator|(
name|lba
operator|+
name|num_blocks
operator|)
operator|>
operator|(
name|lun
operator|->
name|be_lun
operator|->
name|maxlba
operator|+
literal|1
operator|)
operator|)
operator|||
operator|(
operator|(
name|lba
operator|+
name|num_blocks
operator|)
operator|<
name|lba
operator|)
condition|)
block|{
name|ctl_set_lba_out_of_range
argument_list|(
name|ctsio
argument_list|,
name|MAX
argument_list|(
name|lba
argument_list|,
name|lun
operator|->
name|be_lun
operator|->
name|maxlba
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
comment|/* 	 * According to SBC-3, a transfer length of 0 is not an error. 	 * Note that this cannot happen with WRITE(6) or READ(6), since 0 	 * translates to 256 blocks for those commands. 	 */
if|if
condition|(
name|num_blocks
operator|==
literal|0
condition|)
block|{
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
comment|/* Set FUA and/or DPO if caches are disabled. */
if|if
condition|(
name|isread
condition|)
block|{
if|if
condition|(
operator|(
name|lun
operator|->
name|MODE_CACHING
operator|.
name|flags1
operator|&
name|SCP_RCD
operator|)
operator|!=
literal|0
condition|)
name|flags
operator||=
name|CTL_LLF_FUA
operator||
name|CTL_LLF_DPO
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|lun
operator|->
name|MODE_CACHING
operator|.
name|flags1
operator|&
name|SCP_WCE
operator|)
operator|==
literal|0
condition|)
name|flags
operator||=
name|CTL_LLF_FUA
expr_stmt|;
block|}
name|lbalen
operator|=
operator|(
expr|struct
name|ctl_lba_len_flags
operator|*
operator|)
operator|&
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LBA_LEN
index|]
expr_stmt|;
name|lbalen
operator|->
name|lba
operator|=
name|lba
expr_stmt|;
name|lbalen
operator|->
name|len
operator|=
name|num_blocks
expr_stmt|;
name|lbalen
operator|->
name|flags
operator|=
operator|(
name|isread
condition|?
name|CTL_LLF_READ
else|:
name|CTL_LLF_WRITE
operator|)
operator||
name|flags
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|num_blocks
operator|*
name|lun
operator|->
name|be_lun
operator|->
name|blocksize
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_read_write: calling data_submit()\n"
operator|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|lun
operator|->
name|backend
operator|->
name|data_submit
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_cnw_cont
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
name|CTL_LUN
argument_list|(
name|io
argument_list|)
decl_stmt|;
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
decl_stmt|;
name|struct
name|ctl_lba_len_flags
modifier|*
name|lbalen
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|ctsio
operator|=
operator|&
name|io
operator|->
name|scsiio
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|status
operator|=
name|CTL_STATUS_NONE
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator|&=
operator|~
name|CTL_FLAG_IO_CONT
expr_stmt|;
name|lbalen
operator|=
operator|(
expr|struct
name|ctl_lba_len_flags
operator|*
operator|)
operator|&
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LBA_LEN
index|]
expr_stmt|;
name|lbalen
operator|->
name|flags
operator|&=
operator|~
name|CTL_LLF_COMPARE
expr_stmt|;
name|lbalen
operator|->
name|flags
operator||=
name|CTL_LLF_WRITE
expr_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_cnw_cont: calling data_submit()\n"
operator|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|lun
operator|->
name|backend
operator|->
name|data_submit
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_cnw
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
name|CTL_LUN
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|struct
name|ctl_lba_len_flags
modifier|*
name|lbalen
decl_stmt|;
name|uint64_t
name|lba
decl_stmt|;
name|uint32_t
name|num_blocks
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|retval
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_cnw: command: %#x\n"
operator|,
name|ctsio
operator|->
name|cdb
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|ctsio
operator|->
name|cdb
index|[
literal|0
index|]
condition|)
block|{
case|case
name|COMPARE_AND_WRITE
case|:
block|{
name|struct
name|scsi_compare_and_write
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_compare_and_write
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SRW10_FUA
condition|)
name|flags
operator||=
name|CTL_LLF_FUA
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SRW10_DPO
condition|)
name|flags
operator||=
name|CTL_LLF_DPO
expr_stmt|;
name|lba
operator|=
name|scsi_8btou64
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
name|num_blocks
operator|=
name|cdb
operator|->
name|length
expr_stmt|;
break|break;
block|}
default|default:
comment|/* 		 * We got a command we don't support.  This shouldn't 		 * happen, commands should be filtered out above us. 		 */
name|ctl_set_invalid_opcode
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
break|break;
comment|/* NOTREACHED */
block|}
comment|/* 	 * The first check is to make sure we're in bounds, the second 	 * check is to catch wrap-around problems.  If the lba + num blocks 	 * is less than the lba, then we've wrapped around and the block 	 * range is invalid anyway. 	 */
if|if
condition|(
operator|(
operator|(
name|lba
operator|+
name|num_blocks
operator|)
operator|>
operator|(
name|lun
operator|->
name|be_lun
operator|->
name|maxlba
operator|+
literal|1
operator|)
operator|)
operator|||
operator|(
operator|(
name|lba
operator|+
name|num_blocks
operator|)
operator|<
name|lba
operator|)
condition|)
block|{
name|ctl_set_lba_out_of_range
argument_list|(
name|ctsio
argument_list|,
name|MAX
argument_list|(
name|lba
argument_list|,
name|lun
operator|->
name|be_lun
operator|->
name|maxlba
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
comment|/* 	 * According to SBC-3, a transfer length of 0 is not an error. 	 */
if|if
condition|(
name|num_blocks
operator|==
literal|0
condition|)
block|{
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
comment|/* Set FUA if write cache is disabled. */
if|if
condition|(
operator|(
name|lun
operator|->
name|MODE_CACHING
operator|.
name|flags1
operator|&
name|SCP_WCE
operator|)
operator|==
literal|0
condition|)
name|flags
operator||=
name|CTL_LLF_FUA
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
literal|2
operator|*
name|num_blocks
operator|*
name|lun
operator|->
name|be_lun
operator|->
name|blocksize
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Set the IO_CONT flag, so that if this I/O gets passed to 	 * ctl_data_submit_done(), it'll get passed back to 	 * ctl_ctl_cnw_cont() for further processing. 	 */
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_IO_CONT
expr_stmt|;
name|ctsio
operator|->
name|io_cont
operator|=
name|ctl_cnw_cont
expr_stmt|;
name|lbalen
operator|=
operator|(
expr|struct
name|ctl_lba_len_flags
operator|*
operator|)
operator|&
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LBA_LEN
index|]
expr_stmt|;
name|lbalen
operator|->
name|lba
operator|=
name|lba
expr_stmt|;
name|lbalen
operator|->
name|len
operator|=
name|num_blocks
expr_stmt|;
name|lbalen
operator|->
name|flags
operator|=
name|CTL_LLF_COMPARE
operator||
name|flags
expr_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_cnw: calling data_submit()\n"
operator|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|lun
operator|->
name|backend
operator|->
name|data_submit
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_verify
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
name|CTL_LUN
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|struct
name|ctl_lba_len_flags
modifier|*
name|lbalen
decl_stmt|;
name|uint64_t
name|lba
decl_stmt|;
name|uint32_t
name|num_blocks
decl_stmt|;
name|int
name|bytchk
decl_stmt|,
name|flags
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_verify: command: %#x\n"
operator|,
name|ctsio
operator|->
name|cdb
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
name|bytchk
operator|=
literal|0
expr_stmt|;
name|flags
operator|=
name|CTL_LLF_FUA
expr_stmt|;
switch|switch
condition|(
name|ctsio
operator|->
name|cdb
index|[
literal|0
index|]
condition|)
block|{
case|case
name|VERIFY_10
case|:
block|{
name|struct
name|scsi_verify_10
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_verify_10
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SVFY_BYTCHK
condition|)
name|bytchk
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SVFY_DPO
condition|)
name|flags
operator||=
name|CTL_LLF_DPO
expr_stmt|;
name|lba
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
name|num_blocks
operator|=
name|scsi_2btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|VERIFY_12
case|:
block|{
name|struct
name|scsi_verify_12
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_verify_12
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SVFY_BYTCHK
condition|)
name|bytchk
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SVFY_DPO
condition|)
name|flags
operator||=
name|CTL_LLF_DPO
expr_stmt|;
name|lba
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
name|num_blocks
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|VERIFY_16
case|:
block|{
name|struct
name|scsi_rw_16
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_rw_16
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SVFY_BYTCHK
condition|)
name|bytchk
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SVFY_DPO
condition|)
name|flags
operator||=
name|CTL_LLF_DPO
expr_stmt|;
name|lba
operator|=
name|scsi_8btou64
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
name|num_blocks
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
comment|/* 		 * We got a command we don't support.  This shouldn't 		 * happen, commands should be filtered out above us. 		 */
name|ctl_set_invalid_opcode
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
comment|/* 	 * The first check is to make sure we're in bounds, the second 	 * check is to catch wrap-around problems.  If the lba + num blocks 	 * is less than the lba, then we've wrapped around and the block 	 * range is invalid anyway. 	 */
if|if
condition|(
operator|(
operator|(
name|lba
operator|+
name|num_blocks
operator|)
operator|>
operator|(
name|lun
operator|->
name|be_lun
operator|->
name|maxlba
operator|+
literal|1
operator|)
operator|)
operator|||
operator|(
operator|(
name|lba
operator|+
name|num_blocks
operator|)
operator|<
name|lba
operator|)
condition|)
block|{
name|ctl_set_lba_out_of_range
argument_list|(
name|ctsio
argument_list|,
name|MAX
argument_list|(
name|lba
argument_list|,
name|lun
operator|->
name|be_lun
operator|->
name|maxlba
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
comment|/* 	 * According to SBC-3, a transfer length of 0 is not an error. 	 */
if|if
condition|(
name|num_blocks
operator|==
literal|0
condition|)
block|{
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
name|lbalen
operator|=
operator|(
expr|struct
name|ctl_lba_len_flags
operator|*
operator|)
operator|&
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LBA_LEN
index|]
expr_stmt|;
name|lbalen
operator|->
name|lba
operator|=
name|lba
expr_stmt|;
name|lbalen
operator|->
name|len
operator|=
name|num_blocks
expr_stmt|;
if|if
condition|(
name|bytchk
condition|)
block|{
name|lbalen
operator|->
name|flags
operator|=
name|CTL_LLF_COMPARE
operator||
name|flags
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|num_blocks
operator|*
name|lun
operator|->
name|be_lun
operator|->
name|blocksize
expr_stmt|;
block|}
else|else
block|{
name|lbalen
operator|->
name|flags
operator|=
name|CTL_LLF_VERIFY
operator||
name|flags
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
literal|0
expr_stmt|;
block|}
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_verify: calling data_submit()\n"
operator|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|lun
operator|->
name|backend
operator|->
name|data_submit
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_report_luns
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|CTL_SOFTC
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|struct
name|ctl_port
modifier|*
name|port
init|=
name|CTL_PORT
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|,
modifier|*
name|request_lun
init|=
name|CTL_LUN
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|struct
name|scsi_report_luns
modifier|*
name|cdb
decl_stmt|;
name|struct
name|scsi_report_luns_data
modifier|*
name|lun_data
decl_stmt|;
name|int
name|num_filled
decl_stmt|,
name|num_luns
decl_stmt|,
name|num_port_luns
decl_stmt|,
name|retval
decl_stmt|;
name|uint32_t
name|alloc_len
decl_stmt|,
name|lun_datalen
decl_stmt|;
name|uint32_t
name|initidx
decl_stmt|,
name|targ_lun_id
decl_stmt|,
name|lun_id
decl_stmt|;
name|retval
operator|=
name|CTL_RETVAL_COMPLETE
expr_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_report_luns
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_report_luns\n"
operator|)
argument_list|)
expr_stmt|;
name|num_luns
operator|=
literal|0
expr_stmt|;
name|num_port_luns
operator|=
name|port
operator|->
name|lun_map
condition|?
name|port
operator|->
name|lun_map_size
else|:
name|CTL_MAX_LUNS
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|targ_lun_id
operator|=
literal|0
init|;
name|targ_lun_id
operator|<
name|num_port_luns
condition|;
name|targ_lun_id
operator|++
control|)
block|{
if|if
condition|(
name|ctl_lun_map_from_port
argument_list|(
name|port
argument_list|,
name|targ_lun_id
argument_list|)
operator|!=
name|UINT32_MAX
condition|)
name|num_luns
operator|++
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cdb
operator|->
name|select_report
condition|)
block|{
case|case
name|RPL_REPORT_DEFAULT
case|:
case|case
name|RPL_REPORT_ALL
case|:
case|case
name|RPL_REPORT_NONSUBSID
case|:
break|break;
case|case
name|RPL_REPORT_WELLKNOWN
case|:
case|case
name|RPL_REPORT_ADMIN
case|:
case|case
name|RPL_REPORT_CONGLOM
case|:
name|num_luns
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|ctl_set_invalid_field
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|2
argument_list|,
comment|/*bit_valid*/
literal|0
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
break|break;
comment|/* NOTREACHED */
block|}
name|alloc_len
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
comment|/* 	 * The initiator has to allocate at least 16 bytes for this request, 	 * so he can at least get the header and the first LUN.  Otherwise 	 * we reject the request (per SPC-3 rev 14, section 6.21). 	 */
if|if
condition|(
name|alloc_len
operator|<
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_report_luns_data
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_report_luns_lundata
argument_list|)
operator|)
condition|)
block|{
name|ctl_set_invalid_field
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|6
argument_list|,
comment|/*bit_valid*/
literal|0
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
name|lun_datalen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|lun_data
argument_list|)
operator|+
operator|(
name|num_luns
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_report_luns_lundata
argument_list|)
operator|)
expr_stmt|;
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
name|lun_datalen
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|lun_data
operator|=
operator|(
expr|struct
name|scsi_report_luns_data
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
name|initidx
operator|=
name|ctl_get_initindex
argument_list|(
operator|&
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|targ_lun_id
operator|=
literal|0
operator|,
name|num_filled
operator|=
literal|0
init|;
name|targ_lun_id
operator|<
name|num_port_luns
operator|&&
name|num_filled
operator|<
name|num_luns
condition|;
name|targ_lun_id
operator|++
control|)
block|{
name|lun_id
operator|=
name|ctl_lun_map_from_port
argument_list|(
name|port
argument_list|,
name|targ_lun_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun_id
operator|==
name|UINT32_MAX
condition|)
continue|continue;
name|lun
operator|=
name|softc
operator|->
name|ctl_luns
index|[
name|lun_id
index|]
expr_stmt|;
if|if
condition|(
name|lun
operator|==
name|NULL
condition|)
continue|continue;
name|be64enc
argument_list|(
name|lun_data
operator|->
name|luns
index|[
name|num_filled
operator|++
index|]
operator|.
name|lundata
argument_list|,
name|ctl_encode_lun
argument_list|(
name|targ_lun_id
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * According to SPC-3, rev 14 section 6.21: 		 * 		 * "The execution of a REPORT LUNS command to any valid and 		 * installed logical unit shall clear the REPORTED LUNS DATA 		 * HAS CHANGED unit attention condition for all logical 		 * units of that target with respect to the requesting 		 * initiator. A valid and installed logical unit is one 		 * having a PERIPHERAL QUALIFIER of 000b in the standard 		 * INQUIRY data (see 6.4.2)." 		 * 		 * If request_lun is NULL, the LUN this report luns command 		 * was issued to is either disabled or doesn't exist. In that 		 * case, we shouldn't clear any pending lun change unit 		 * attention. 		 */
if|if
condition|(
name|request_lun
operator|!=
name|NULL
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctl_clr_ua
argument_list|(
name|lun
argument_list|,
name|initidx
argument_list|,
name|CTL_UA_LUN_CHANGE
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
comment|/* 	 * It's quite possible that we've returned fewer LUNs than we allocated 	 * space for.  Trim it. 	 */
name|lun_datalen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|lun_data
argument_list|)
operator|+
operator|(
name|num_filled
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_report_luns_lundata
argument_list|)
operator|)
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|min
argument_list|(
name|lun_datalen
argument_list|,
name|alloc_len
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|ctsio
operator|->
name|kern_data_len
expr_stmt|;
comment|/* 	 * We set this to the actual data length, regardless of how much 	 * space we actually have to return results.  If the user looks at 	 * this value, he'll know whether or not he allocated enough space 	 * and reissue the command if necessary.  We don't support well 	 * known logical units, so if the user asks for that, return none. 	 */
name|scsi_ulto4b
argument_list|(
name|lun_datalen
operator|-
literal|8
argument_list|,
name|lun_data
operator|->
name|length
argument_list|)
expr_stmt|;
comment|/* 	 * We can only return SCSI_STATUS_CHECK_COND when we can't satisfy 	 * this request. 	 */
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_request_sense
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|CTL_SOFTC
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
name|CTL_LUN
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|struct
name|scsi_request_sense
modifier|*
name|cdb
decl_stmt|;
name|struct
name|scsi_sense_data
modifier|*
name|sense_ptr
decl_stmt|,
modifier|*
name|ps
decl_stmt|;
name|uint32_t
name|initidx
decl_stmt|;
name|int
name|have_error
decl_stmt|;
name|u_int
name|sense_len
init|=
name|SSD_FULL_SIZE
decl_stmt|;
name|scsi_sense_data_type
name|sense_format
decl_stmt|;
name|ctl_ua_type
name|ua_type
decl_stmt|;
name|uint8_t
name|asc
init|=
literal|0
decl_stmt|,
name|ascq
init|=
literal|0
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_request_sense
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_request_sense\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Determine which sense format the user wants. 	 */
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SRS_DESC
condition|)
name|sense_format
operator|=
name|SSD_TYPE_DESC
expr_stmt|;
else|else
name|sense_format
operator|=
name|SSD_TYPE_FIXED
expr_stmt|;
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sense_ptr
argument_list|)
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sense_ptr
operator|=
operator|(
expr|struct
name|scsi_sense_data
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
comment|/* 	 * struct scsi_sense_data, which is currently set to 256 bytes, is 	 * larger than the largest allowed value for the length field in the 	 * REQUEST SENSE CDB, which is 252 bytes as of SPC-4. 	 */
name|ctsio
operator|->
name|kern_data_len
operator|=
name|cdb
operator|->
name|length
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|cdb
operator|->
name|length
expr_stmt|;
comment|/* 	 * If we don't have a LUN, we don't have any pending sense. 	 */
if|if
condition|(
name|lun
operator|==
name|NULL
operator|||
operator|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_PRIMARY_SC
operator|)
operator|==
literal|0
operator|&&
name|softc
operator|->
name|ha_link
operator|<
name|CTL_HA_LINK_UNKNOWN
operator|)
condition|)
block|{
comment|/* "Logical unit not supported" */
name|ctl_set_sense_data
argument_list|(
name|sense_ptr
argument_list|,
operator|&
name|sense_len
argument_list|,
name|NULL
argument_list|,
name|sense_format
argument_list|,
comment|/*current_error*/
literal|1
argument_list|,
comment|/*sense_key*/
name|SSD_KEY_ILLEGAL_REQUEST
argument_list|,
comment|/*asc*/
literal|0x25
argument_list|,
comment|/*ascq*/
literal|0x00
argument_list|,
name|SSD_ELEM_NONE
argument_list|)
expr_stmt|;
goto|goto
name|send
goto|;
block|}
name|have_error
operator|=
literal|0
expr_stmt|;
name|initidx
operator|=
name|ctl_get_initindex
argument_list|(
operator|&
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
argument_list|)
expr_stmt|;
comment|/* 	 * Check for pending sense, and then for pending unit attentions. 	 * Pending sense gets returned first, then pending unit attentions. 	 */
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ps
operator|=
name|lun
operator|->
name|pending_sense
index|[
name|initidx
operator|/
name|CTL_MAX_INIT_PER_PORT
index|]
expr_stmt|;
if|if
condition|(
name|ps
operator|!=
name|NULL
condition|)
name|ps
operator|+=
name|initidx
operator|%
name|CTL_MAX_INIT_PER_PORT
expr_stmt|;
if|if
condition|(
name|ps
operator|!=
name|NULL
operator|&&
name|ps
operator|->
name|error_code
operator|!=
literal|0
condition|)
block|{
name|scsi_sense_data_type
name|stored_format
decl_stmt|;
comment|/* 		 * Check to see which sense format was used for the stored 		 * sense data. 		 */
name|stored_format
operator|=
name|scsi_sense_type
argument_list|(
name|ps
argument_list|)
expr_stmt|;
comment|/* 		 * If the user requested a different sense format than the 		 * one we stored, then we need to convert it to the other 		 * format.  If we're going from descriptor to fixed format 		 * sense data, we may lose things in translation, depending 		 * on what options were used. 		 * 		 * If the stored format is SSD_TYPE_NONE (i.e. invalid), 		 * for some reason we'll just copy it out as-is. 		 */
if|if
condition|(
operator|(
name|stored_format
operator|==
name|SSD_TYPE_FIXED
operator|)
operator|&&
operator|(
name|sense_format
operator|==
name|SSD_TYPE_DESC
operator|)
condition|)
name|ctl_sense_to_desc
argument_list|(
operator|(
expr|struct
name|scsi_sense_data_fixed
operator|*
operator|)
name|ps
argument_list|,
operator|(
expr|struct
name|scsi_sense_data_desc
operator|*
operator|)
name|sense_ptr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|stored_format
operator|==
name|SSD_TYPE_DESC
operator|)
operator|&&
operator|(
name|sense_format
operator|==
name|SSD_TYPE_FIXED
operator|)
condition|)
name|ctl_sense_to_fixed
argument_list|(
operator|(
expr|struct
name|scsi_sense_data_desc
operator|*
operator|)
name|ps
argument_list|,
operator|(
expr|struct
name|scsi_sense_data_fixed
operator|*
operator|)
name|sense_ptr
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|sense_ptr
argument_list|,
name|ps
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sense_ptr
argument_list|)
argument_list|)
expr_stmt|;
name|ps
operator|->
name|error_code
operator|=
literal|0
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ua_type
operator|=
name|ctl_build_ua
argument_list|(
name|lun
argument_list|,
name|initidx
argument_list|,
name|sense_ptr
argument_list|,
operator|&
name|sense_len
argument_list|,
name|sense_format
argument_list|)
expr_stmt|;
if|if
condition|(
name|ua_type
operator|!=
name|CTL_UA_NONE
condition|)
name|have_error
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|have_error
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Report informational exception if have one and allowed. 		 */
if|if
condition|(
name|lun
operator|->
name|MODE_IE
operator|.
name|mrie
operator|!=
name|SIEP_MRIE_NO
condition|)
block|{
name|asc
operator|=
name|lun
operator|->
name|ie_asc
expr_stmt|;
name|ascq
operator|=
name|lun
operator|->
name|ie_ascq
expr_stmt|;
block|}
name|ctl_set_sense_data
argument_list|(
name|sense_ptr
argument_list|,
operator|&
name|sense_len
argument_list|,
name|lun
argument_list|,
name|sense_format
argument_list|,
comment|/*current_error*/
literal|1
argument_list|,
comment|/*sense_key*/
name|SSD_KEY_NO_SENSE
argument_list|,
comment|/*asc*/
name|asc
argument_list|,
comment|/*ascq*/
name|ascq
argument_list|,
name|SSD_ELEM_NONE
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|send
label|:
comment|/* 	 * We report the SCSI status as OK, since the status of the command 	 * itself is OK.  We're reporting sense as parameter data. 	 */
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_tur
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_tur\n"
operator|)
argument_list|)
expr_stmt|;
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * SCSI VPD page 0x00, the Supported VPD Pages page.  */
end_comment

begin_function
specifier|static
name|int
name|ctl_inquiry_evpd_supported
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|int
name|alloc_len
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
name|CTL_LUN
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|struct
name|scsi_vpd_supported_pages
modifier|*
name|pages
decl_stmt|;
name|int
name|sup_page_size
decl_stmt|;
name|int
name|p
decl_stmt|;
name|sup_page_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_supported_pages
argument_list|)
operator|*
name|SCSI_EVPD_NUM_SUPPORTED_PAGES
expr_stmt|;
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
name|sup_page_size
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|pages
operator|=
operator|(
expr|struct
name|scsi_vpd_supported_pages
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|min
argument_list|(
name|sup_page_size
argument_list|,
name|alloc_len
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|ctsio
operator|->
name|kern_data_len
expr_stmt|;
comment|/* 	 * The control device is always connected.  The disk device, on the 	 * other hand, may not be online all the time.  Need to change this 	 * to figure out whether the disk device is actually online or not. 	 */
if|if
condition|(
name|lun
operator|!=
name|NULL
condition|)
name|pages
operator|->
name|device
operator|=
operator|(
name|SID_QUAL_LU_CONNECTED
operator|<<
literal|5
operator|)
operator||
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
expr_stmt|;
else|else
name|pages
operator|->
name|device
operator|=
operator|(
name|SID_QUAL_LU_OFFLINE
operator|<<
literal|5
operator|)
operator||
name|T_DIRECT
expr_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
comment|/* Supported VPD pages */
name|pages
operator|->
name|page_list
index|[
name|p
operator|++
index|]
operator|=
name|SVPD_SUPPORTED_PAGES
expr_stmt|;
comment|/* Serial Number */
name|pages
operator|->
name|page_list
index|[
name|p
operator|++
index|]
operator|=
name|SVPD_UNIT_SERIAL_NUMBER
expr_stmt|;
comment|/* Device Identification */
name|pages
operator|->
name|page_list
index|[
name|p
operator|++
index|]
operator|=
name|SVPD_DEVICE_ID
expr_stmt|;
comment|/* Extended INQUIRY Data */
name|pages
operator|->
name|page_list
index|[
name|p
operator|++
index|]
operator|=
name|SVPD_EXTENDED_INQUIRY_DATA
expr_stmt|;
comment|/* Mode Page Policy */
name|pages
operator|->
name|page_list
index|[
name|p
operator|++
index|]
operator|=
name|SVPD_MODE_PAGE_POLICY
expr_stmt|;
comment|/* SCSI Ports */
name|pages
operator|->
name|page_list
index|[
name|p
operator|++
index|]
operator|=
name|SVPD_SCSI_PORTS
expr_stmt|;
comment|/* Third-party Copy */
name|pages
operator|->
name|page_list
index|[
name|p
operator|++
index|]
operator|=
name|SVPD_SCSI_TPC
expr_stmt|;
if|if
condition|(
name|lun
operator|!=
name|NULL
operator|&&
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
operator|==
name|T_DIRECT
condition|)
block|{
comment|/* Block limits */
name|pages
operator|->
name|page_list
index|[
name|p
operator|++
index|]
operator|=
name|SVPD_BLOCK_LIMITS
expr_stmt|;
comment|/* Block Device Characteristics */
name|pages
operator|->
name|page_list
index|[
name|p
operator|++
index|]
operator|=
name|SVPD_BDC
expr_stmt|;
comment|/* Logical Block Provisioning */
name|pages
operator|->
name|page_list
index|[
name|p
operator|++
index|]
operator|=
name|SVPD_LBP
expr_stmt|;
block|}
name|pages
operator|->
name|length
operator|=
name|p
expr_stmt|;
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * SCSI VPD page 0x80, the Unit Serial Number page.  */
end_comment

begin_function
specifier|static
name|int
name|ctl_inquiry_evpd_serial
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|int
name|alloc_len
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
name|CTL_LUN
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|struct
name|scsi_vpd_unit_serial_number
modifier|*
name|sn_ptr
decl_stmt|;
name|int
name|data_len
decl_stmt|;
name|data_len
operator|=
literal|4
operator|+
name|CTL_SN_LEN
expr_stmt|;
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
name|data_len
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|sn_ptr
operator|=
operator|(
expr|struct
name|scsi_vpd_unit_serial_number
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|min
argument_list|(
name|data_len
argument_list|,
name|alloc_len
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|ctsio
operator|->
name|kern_data_len
expr_stmt|;
comment|/* 	 * The control device is always connected.  The disk device, on the 	 * other hand, may not be online all the time.  Need to change this 	 * to figure out whether the disk device is actually online or not. 	 */
if|if
condition|(
name|lun
operator|!=
name|NULL
condition|)
name|sn_ptr
operator|->
name|device
operator|=
operator|(
name|SID_QUAL_LU_CONNECTED
operator|<<
literal|5
operator|)
operator||
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
expr_stmt|;
else|else
name|sn_ptr
operator|->
name|device
operator|=
operator|(
name|SID_QUAL_LU_OFFLINE
operator|<<
literal|5
operator|)
operator||
name|T_DIRECT
expr_stmt|;
name|sn_ptr
operator|->
name|page_code
operator|=
name|SVPD_UNIT_SERIAL_NUMBER
expr_stmt|;
name|sn_ptr
operator|->
name|length
operator|=
name|CTL_SN_LEN
expr_stmt|;
comment|/* 	 * If we don't have a LUN, we just leave the serial number as 	 * all spaces. 	 */
if|if
condition|(
name|lun
operator|!=
name|NULL
condition|)
block|{
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sn_ptr
operator|->
name|serial_num
argument_list|,
operator|(
name|char
operator|*
operator|)
name|lun
operator|->
name|be_lun
operator|->
name|serial_num
argument_list|,
name|CTL_SN_LEN
argument_list|)
expr_stmt|;
block|}
else|else
name|memset
argument_list|(
name|sn_ptr
operator|->
name|serial_num
argument_list|,
literal|0x20
argument_list|,
name|CTL_SN_LEN
argument_list|)
expr_stmt|;
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * SCSI VPD page 0x86, the Extended INQUIRY Data page.  */
end_comment

begin_function
specifier|static
name|int
name|ctl_inquiry_evpd_eid
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|int
name|alloc_len
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
name|CTL_LUN
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|struct
name|scsi_vpd_extended_inquiry_data
modifier|*
name|eid_ptr
decl_stmt|;
name|int
name|data_len
decl_stmt|;
name|data_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_extended_inquiry_data
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
name|data_len
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|eid_ptr
operator|=
operator|(
expr|struct
name|scsi_vpd_extended_inquiry_data
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|min
argument_list|(
name|data_len
argument_list|,
name|alloc_len
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|ctsio
operator|->
name|kern_data_len
expr_stmt|;
comment|/* 	 * The control device is always connected.  The disk device, on the 	 * other hand, may not be online all the time. 	 */
if|if
condition|(
name|lun
operator|!=
name|NULL
condition|)
name|eid_ptr
operator|->
name|device
operator|=
operator|(
name|SID_QUAL_LU_CONNECTED
operator|<<
literal|5
operator|)
operator||
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
expr_stmt|;
else|else
name|eid_ptr
operator|->
name|device
operator|=
operator|(
name|SID_QUAL_LU_OFFLINE
operator|<<
literal|5
operator|)
operator||
name|T_DIRECT
expr_stmt|;
name|eid_ptr
operator|->
name|page_code
operator|=
name|SVPD_EXTENDED_INQUIRY_DATA
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|data_len
operator|-
literal|4
argument_list|,
name|eid_ptr
operator|->
name|page_length
argument_list|)
expr_stmt|;
comment|/* 	 * We support head of queue, ordered and simple tags. 	 */
name|eid_ptr
operator|->
name|flags2
operator|=
name|SVPD_EID_HEADSUP
operator||
name|SVPD_EID_ORDSUP
operator||
name|SVPD_EID_SIMPSUP
expr_stmt|;
comment|/* 	 * Volatile cache supported. 	 */
name|eid_ptr
operator|->
name|flags3
operator|=
name|SVPD_EID_V_SUP
expr_stmt|;
comment|/* 	 * This means that we clear the REPORTED LUNS DATA HAS CHANGED unit 	 * attention for a particular IT nexus on all LUNs once we report 	 * it to that nexus once.  This bit is required as of SPC-4. 	 */
name|eid_ptr
operator|->
name|flags4
operator|=
name|SVPD_EID_LUICLR
expr_stmt|;
comment|/* 	 * We support revert to defaults (RTD) bit in MODE SELECT. 	 */
name|eid_ptr
operator|->
name|flags5
operator|=
name|SVPD_EID_RTD_SUP
expr_stmt|;
comment|/* 	 * XXX KDM in order to correctly answer this, we would need 	 * information from the SIM to determine how much sense data it 	 * can send.  So this would really be a path inquiry field, most 	 * likely.  This can be set to a maximum of 252 according to SPC-4, 	 * but the hardware may or may not be able to support that much. 	 * 0 just means that the maximum sense data length is not reported. 	 */
name|eid_ptr
operator|->
name|max_sense_length
operator|=
literal|0
expr_stmt|;
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_inquiry_evpd_mpp
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|int
name|alloc_len
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
name|CTL_LUN
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|struct
name|scsi_vpd_mode_page_policy
modifier|*
name|mpp_ptr
decl_stmt|;
name|int
name|data_len
decl_stmt|;
name|data_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_mode_page_policy
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_mode_page_policy_descr
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
name|data_len
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|mpp_ptr
operator|=
operator|(
expr|struct
name|scsi_vpd_mode_page_policy
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|min
argument_list|(
name|data_len
argument_list|,
name|alloc_len
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|ctsio
operator|->
name|kern_data_len
expr_stmt|;
comment|/* 	 * The control device is always connected.  The disk device, on the 	 * other hand, may not be online all the time. 	 */
if|if
condition|(
name|lun
operator|!=
name|NULL
condition|)
name|mpp_ptr
operator|->
name|device
operator|=
operator|(
name|SID_QUAL_LU_CONNECTED
operator|<<
literal|5
operator|)
operator||
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
expr_stmt|;
else|else
name|mpp_ptr
operator|->
name|device
operator|=
operator|(
name|SID_QUAL_LU_OFFLINE
operator|<<
literal|5
operator|)
operator||
name|T_DIRECT
expr_stmt|;
name|mpp_ptr
operator|->
name|page_code
operator|=
name|SVPD_MODE_PAGE_POLICY
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|data_len
operator|-
literal|4
argument_list|,
name|mpp_ptr
operator|->
name|page_length
argument_list|)
expr_stmt|;
name|mpp_ptr
operator|->
name|descr
index|[
literal|0
index|]
operator|.
name|page_code
operator|=
literal|0x3f
expr_stmt|;
name|mpp_ptr
operator|->
name|descr
index|[
literal|0
index|]
operator|.
name|subpage_code
operator|=
literal|0xff
expr_stmt|;
name|mpp_ptr
operator|->
name|descr
index|[
literal|0
index|]
operator|.
name|policy
operator|=
name|SVPD_MPP_SHARED
expr_stmt|;
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * SCSI VPD page 0x83, the Device Identification page.  */
end_comment

begin_function
specifier|static
name|int
name|ctl_inquiry_evpd_devid
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|int
name|alloc_len
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|CTL_SOFTC
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|struct
name|ctl_port
modifier|*
name|port
init|=
name|CTL_PORT
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
name|CTL_LUN
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|struct
name|scsi_vpd_device_id
modifier|*
name|devid_ptr
decl_stmt|;
name|struct
name|scsi_vpd_id_descriptor
modifier|*
name|desc
decl_stmt|;
name|int
name|data_len
decl_stmt|,
name|g
decl_stmt|;
name|uint8_t
name|proto
decl_stmt|;
name|data_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_device_id
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_id_descriptor
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_id_rel_trgt_port_id
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_id_descriptor
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_id_trgt_port_grp_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|&&
name|lun
operator|->
name|lun_devid
condition|)
name|data_len
operator|+=
name|lun
operator|->
name|lun_devid
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|port
operator|&&
name|port
operator|->
name|port_devid
condition|)
name|data_len
operator|+=
name|port
operator|->
name|port_devid
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|port
operator|&&
name|port
operator|->
name|target_devid
condition|)
name|data_len
operator|+=
name|port
operator|->
name|target_devid
operator|->
name|len
expr_stmt|;
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
name|data_len
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|devid_ptr
operator|=
operator|(
expr|struct
name|scsi_vpd_device_id
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|min
argument_list|(
name|data_len
argument_list|,
name|alloc_len
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|ctsio
operator|->
name|kern_data_len
expr_stmt|;
comment|/* 	 * The control device is always connected.  The disk device, on the 	 * other hand, may not be online all the time. 	 */
if|if
condition|(
name|lun
operator|!=
name|NULL
condition|)
name|devid_ptr
operator|->
name|device
operator|=
operator|(
name|SID_QUAL_LU_CONNECTED
operator|<<
literal|5
operator|)
operator||
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
expr_stmt|;
else|else
name|devid_ptr
operator|->
name|device
operator|=
operator|(
name|SID_QUAL_LU_OFFLINE
operator|<<
literal|5
operator|)
operator||
name|T_DIRECT
expr_stmt|;
name|devid_ptr
operator|->
name|page_code
operator|=
name|SVPD_DEVICE_ID
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|data_len
operator|-
literal|4
argument_list|,
name|devid_ptr
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|&&
name|port
operator|->
name|port_type
operator|==
name|CTL_PORT_FC
condition|)
name|proto
operator|=
name|SCSI_PROTO_FC
operator|<<
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|port
operator|&&
name|port
operator|->
name|port_type
operator|==
name|CTL_PORT_SAS
condition|)
name|proto
operator|=
name|SCSI_PROTO_SAS
operator|<<
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|port
operator|&&
name|port
operator|->
name|port_type
operator|==
name|CTL_PORT_ISCSI
condition|)
name|proto
operator|=
name|SCSI_PROTO_ISCSI
operator|<<
literal|4
expr_stmt|;
else|else
name|proto
operator|=
name|SCSI_PROTO_SPI
operator|<<
literal|4
expr_stmt|;
name|desc
operator|=
operator|(
expr|struct
name|scsi_vpd_id_descriptor
operator|*
operator|)
name|devid_ptr
operator|->
name|desc_list
expr_stmt|;
comment|/* 	 * We're using a LUN association here.  i.e., this device ID is a 	 * per-LUN identifier. 	 */
if|if
condition|(
name|lun
operator|&&
name|lun
operator|->
name|lun_devid
condition|)
block|{
name|memcpy
argument_list|(
name|desc
argument_list|,
name|lun
operator|->
name|lun_devid
operator|->
name|data
argument_list|,
name|lun
operator|->
name|lun_devid
operator|->
name|len
argument_list|)
expr_stmt|;
name|desc
operator|=
operator|(
expr|struct
name|scsi_vpd_id_descriptor
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|desc
operator|+
name|lun
operator|->
name|lun_devid
operator|->
name|len
operator|)
expr_stmt|;
block|}
comment|/* 	 * This is for the WWPN which is a port association. 	 */
if|if
condition|(
name|port
operator|&&
name|port
operator|->
name|port_devid
condition|)
block|{
name|memcpy
argument_list|(
name|desc
argument_list|,
name|port
operator|->
name|port_devid
operator|->
name|data
argument_list|,
name|port
operator|->
name|port_devid
operator|->
name|len
argument_list|)
expr_stmt|;
name|desc
operator|=
operator|(
expr|struct
name|scsi_vpd_id_descriptor
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|desc
operator|+
name|port
operator|->
name|port_devid
operator|->
name|len
operator|)
expr_stmt|;
block|}
comment|/* 	 * This is for the Relative Target Port(type 4h) identifier 	 */
name|desc
operator|->
name|proto_codeset
operator|=
name|proto
operator||
name|SVPD_ID_CODESET_BINARY
expr_stmt|;
name|desc
operator|->
name|id_type
operator|=
name|SVPD_ID_PIV
operator||
name|SVPD_ID_ASSOC_PORT
operator||
name|SVPD_ID_TYPE_RELTARG
expr_stmt|;
name|desc
operator|->
name|length
operator|=
literal|4
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
argument_list|,
operator|&
name|desc
operator|->
name|identifier
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|desc
operator|=
operator|(
expr|struct
name|scsi_vpd_id_descriptor
operator|*
operator|)
operator|(
operator|&
name|desc
operator|->
name|identifier
index|[
literal|0
index|]
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_id_rel_trgt_port_id
argument_list|)
operator|)
expr_stmt|;
comment|/* 	 * This is for the Target Port Group(type 5h) identifier 	 */
name|desc
operator|->
name|proto_codeset
operator|=
name|proto
operator||
name|SVPD_ID_CODESET_BINARY
expr_stmt|;
name|desc
operator|->
name|id_type
operator|=
name|SVPD_ID_PIV
operator||
name|SVPD_ID_ASSOC_PORT
operator||
name|SVPD_ID_TYPE_TPORTGRP
expr_stmt|;
name|desc
operator|->
name|length
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|is_single
operator|||
operator|(
name|port
operator|&&
name|port
operator|->
name|status
operator|&
name|CTL_PORT_STATUS_HA_SHARED
operator|)
condition|)
name|g
operator|=
literal|1
expr_stmt|;
else|else
name|g
operator|=
literal|2
operator|+
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
operator|/
name|softc
operator|->
name|port_cnt
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|g
argument_list|,
operator|&
name|desc
operator|->
name|identifier
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|desc
operator|=
operator|(
expr|struct
name|scsi_vpd_id_descriptor
operator|*
operator|)
operator|(
operator|&
name|desc
operator|->
name|identifier
index|[
literal|0
index|]
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_id_trgt_port_grp_id
argument_list|)
operator|)
expr_stmt|;
comment|/* 	 * This is for the Target identifier 	 */
if|if
condition|(
name|port
operator|&&
name|port
operator|->
name|target_devid
condition|)
block|{
name|memcpy
argument_list|(
name|desc
argument_list|,
name|port
operator|->
name|target_devid
operator|->
name|data
argument_list|,
name|port
operator|->
name|target_devid
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_inquiry_evpd_scsi_ports
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|int
name|alloc_len
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|CTL_SOFTC
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
name|CTL_LUN
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|struct
name|scsi_vpd_scsi_ports
modifier|*
name|sp
decl_stmt|;
name|struct
name|scsi_vpd_port_designation
modifier|*
name|pd
decl_stmt|;
name|struct
name|scsi_vpd_port_designation_cont
modifier|*
name|pdc
decl_stmt|;
name|struct
name|ctl_port
modifier|*
name|port
decl_stmt|;
name|int
name|data_len
decl_stmt|,
name|num_target_ports
decl_stmt|,
name|iid_len
decl_stmt|,
name|id_len
decl_stmt|;
name|num_target_ports
operator|=
literal|0
expr_stmt|;
name|iid_len
operator|=
literal|0
expr_stmt|;
name|id_len
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|port
argument_list|,
argument|&softc->port_list
argument_list|,
argument|links
argument_list|)
block|{
if|if
condition|(
operator|(
name|port
operator|->
name|status
operator|&
name|CTL_PORT_STATUS_ONLINE
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|lun
operator|!=
name|NULL
operator|&&
name|ctl_lun_map_to_port
argument_list|(
name|port
argument_list|,
name|lun
operator|->
name|lun
argument_list|)
operator|==
name|UINT32_MAX
condition|)
continue|continue;
name|num_target_ports
operator|++
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|init_devid
condition|)
name|iid_len
operator|+=
name|port
operator|->
name|init_devid
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|port_devid
condition|)
name|id_len
operator|+=
name|port
operator|->
name|port_devid
operator|->
name|len
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|data_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_scsi_ports
argument_list|)
operator|+
name|num_target_ports
operator|*
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_port_designation
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_port_designation_cont
argument_list|)
operator|)
operator|+
name|iid_len
operator|+
name|id_len
expr_stmt|;
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
name|data_len
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|sp
operator|=
operator|(
expr|struct
name|scsi_vpd_scsi_ports
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|min
argument_list|(
name|data_len
argument_list|,
name|alloc_len
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|ctsio
operator|->
name|kern_data_len
expr_stmt|;
comment|/* 	 * The control device is always connected.  The disk device, on the 	 * other hand, may not be online all the time.  Need to change this 	 * to figure out whether the disk device is actually online or not. 	 */
if|if
condition|(
name|lun
operator|!=
name|NULL
condition|)
name|sp
operator|->
name|device
operator|=
operator|(
name|SID_QUAL_LU_CONNECTED
operator|<<
literal|5
operator|)
operator||
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
expr_stmt|;
else|else
name|sp
operator|->
name|device
operator|=
operator|(
name|SID_QUAL_LU_OFFLINE
operator|<<
literal|5
operator|)
operator||
name|T_DIRECT
expr_stmt|;
name|sp
operator|->
name|page_code
operator|=
name|SVPD_SCSI_PORTS
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|data_len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_scsi_ports
argument_list|)
argument_list|,
name|sp
operator|->
name|page_length
argument_list|)
expr_stmt|;
name|pd
operator|=
operator|&
name|sp
operator|->
name|design
index|[
literal|0
index|]
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|port
argument_list|,
argument|&softc->port_list
argument_list|,
argument|links
argument_list|)
block|{
if|if
condition|(
operator|(
name|port
operator|->
name|status
operator|&
name|CTL_PORT_STATUS_ONLINE
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|lun
operator|!=
name|NULL
operator|&&
name|ctl_lun_map_to_port
argument_list|(
name|port
argument_list|,
name|lun
operator|->
name|lun
argument_list|)
operator|==
name|UINT32_MAX
condition|)
continue|continue;
name|scsi_ulto2b
argument_list|(
name|port
operator|->
name|targ_port
argument_list|,
name|pd
operator|->
name|relative_port_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|init_devid
condition|)
block|{
name|iid_len
operator|=
name|port
operator|->
name|init_devid
operator|->
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|pd
operator|->
name|initiator_transportid
argument_list|,
name|port
operator|->
name|init_devid
operator|->
name|data
argument_list|,
name|port
operator|->
name|init_devid
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
else|else
name|iid_len
operator|=
literal|0
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|iid_len
argument_list|,
name|pd
operator|->
name|initiator_transportid_length
argument_list|)
expr_stmt|;
name|pdc
operator|=
operator|(
expr|struct
name|scsi_vpd_port_designation_cont
operator|*
operator|)
operator|(
operator|&
name|pd
operator|->
name|initiator_transportid
index|[
name|iid_len
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|port_devid
condition|)
block|{
name|id_len
operator|=
name|port
operator|->
name|port_devid
operator|->
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|pdc
operator|->
name|target_port_descriptors
argument_list|,
name|port
operator|->
name|port_devid
operator|->
name|data
argument_list|,
name|port
operator|->
name|port_devid
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
else|else
name|id_len
operator|=
literal|0
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|id_len
argument_list|,
name|pdc
operator|->
name|target_port_descriptors_length
argument_list|)
expr_stmt|;
name|pd
operator|=
operator|(
expr|struct
name|scsi_vpd_port_designation
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|pdc
operator|->
name|target_port_descriptors
operator|+
name|id_len
operator|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_inquiry_evpd_block_limits
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|int
name|alloc_len
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
name|CTL_LUN
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|struct
name|scsi_vpd_block_limits
modifier|*
name|bl_ptr
decl_stmt|;
name|uint64_t
name|ival
decl_stmt|;
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|bl_ptr
argument_list|)
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|bl_ptr
operator|=
operator|(
expr|struct
name|scsi_vpd_block_limits
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|min
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|bl_ptr
argument_list|)
argument_list|,
name|alloc_len
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|ctsio
operator|->
name|kern_data_len
expr_stmt|;
comment|/* 	 * The control device is always connected.  The disk device, on the 	 * other hand, may not be online all the time.  Need to change this 	 * to figure out whether the disk device is actually online or not. 	 */
if|if
condition|(
name|lun
operator|!=
name|NULL
condition|)
name|bl_ptr
operator|->
name|device
operator|=
operator|(
name|SID_QUAL_LU_CONNECTED
operator|<<
literal|5
operator|)
operator||
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
expr_stmt|;
else|else
name|bl_ptr
operator|->
name|device
operator|=
operator|(
name|SID_QUAL_LU_OFFLINE
operator|<<
literal|5
operator|)
operator||
name|T_DIRECT
expr_stmt|;
name|bl_ptr
operator|->
name|page_code
operator|=
name|SVPD_BLOCK_LIMITS
expr_stmt|;
name|scsi_ulto2b
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|bl_ptr
argument_list|)
operator|-
literal|4
argument_list|,
name|bl_ptr
operator|->
name|page_length
argument_list|)
expr_stmt|;
name|bl_ptr
operator|->
name|max_cmp_write_len
operator|=
literal|0xff
expr_stmt|;
name|scsi_ulto4b
argument_list|(
literal|0xffffffff
argument_list|,
name|bl_ptr
operator|->
name|max_txfer_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|!=
name|NULL
condition|)
block|{
name|scsi_ulto4b
argument_list|(
name|lun
operator|->
name|be_lun
operator|->
name|opttxferlen
argument_list|,
name|bl_ptr
operator|->
name|opt_txfer_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|be_lun
operator|->
name|flags
operator|&
name|CTL_LUN_FLAG_UNMAP
condition|)
block|{
name|ival
operator|=
literal|0xffffffff
expr_stmt|;
name|ctl_get_opt_number
argument_list|(
operator|&
name|lun
operator|->
name|be_lun
operator|->
name|options
argument_list|,
literal|"unmap_max_lba"
argument_list|,
operator|&
name|ival
argument_list|)
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|ival
argument_list|,
name|bl_ptr
operator|->
name|max_unmap_lba_cnt
argument_list|)
expr_stmt|;
name|ival
operator|=
literal|0xffffffff
expr_stmt|;
name|ctl_get_opt_number
argument_list|(
operator|&
name|lun
operator|->
name|be_lun
operator|->
name|options
argument_list|,
literal|"unmap_max_descr"
argument_list|,
operator|&
name|ival
argument_list|)
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|ival
argument_list|,
name|bl_ptr
operator|->
name|max_unmap_blk_cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|be_lun
operator|->
name|ublockexp
operator|!=
literal|0
condition|)
block|{
name|scsi_ulto4b
argument_list|(
operator|(
literal|1
operator|<<
name|lun
operator|->
name|be_lun
operator|->
name|ublockexp
operator|)
argument_list|,
name|bl_ptr
operator|->
name|opt_unmap_grain
argument_list|)
expr_stmt|;
name|scsi_ulto4b
argument_list|(
literal|0x80000000
operator||
name|lun
operator|->
name|be_lun
operator|->
name|ublockoff
argument_list|,
name|bl_ptr
operator|->
name|unmap_grain_align
argument_list|)
expr_stmt|;
block|}
block|}
name|scsi_ulto4b
argument_list|(
name|lun
operator|->
name|be_lun
operator|->
name|atomicblock
argument_list|,
name|bl_ptr
operator|->
name|max_atomic_transfer_length
argument_list|)
expr_stmt|;
name|scsi_ulto4b
argument_list|(
literal|0
argument_list|,
name|bl_ptr
operator|->
name|atomic_alignment
argument_list|)
expr_stmt|;
name|scsi_ulto4b
argument_list|(
literal|0
argument_list|,
name|bl_ptr
operator|->
name|atomic_transfer_length_granularity
argument_list|)
expr_stmt|;
name|scsi_ulto4b
argument_list|(
literal|0
argument_list|,
name|bl_ptr
operator|->
name|max_atomic_transfer_length_with_atomic_boundary
argument_list|)
expr_stmt|;
name|scsi_ulto4b
argument_list|(
literal|0
argument_list|,
name|bl_ptr
operator|->
name|max_atomic_boundary_size
argument_list|)
expr_stmt|;
name|ival
operator|=
name|UINT64_MAX
expr_stmt|;
name|ctl_get_opt_number
argument_list|(
operator|&
name|lun
operator|->
name|be_lun
operator|->
name|options
argument_list|,
literal|"write_same_max_lba"
argument_list|,
operator|&
name|ival
argument_list|)
expr_stmt|;
name|scsi_u64to8b
argument_list|(
name|ival
argument_list|,
name|bl_ptr
operator|->
name|max_write_same_length
argument_list|)
expr_stmt|;
block|}
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_inquiry_evpd_bdc
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|int
name|alloc_len
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
name|CTL_LUN
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|struct
name|scsi_vpd_block_device_characteristics
modifier|*
name|bdc_ptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|bdc_ptr
argument_list|)
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|bdc_ptr
operator|=
operator|(
expr|struct
name|scsi_vpd_block_device_characteristics
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|min
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|bdc_ptr
argument_list|)
argument_list|,
name|alloc_len
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|ctsio
operator|->
name|kern_data_len
expr_stmt|;
comment|/* 	 * The control device is always connected.  The disk device, on the 	 * other hand, may not be online all the time.  Need to change this 	 * to figure out whether the disk device is actually online or not. 	 */
if|if
condition|(
name|lun
operator|!=
name|NULL
condition|)
name|bdc_ptr
operator|->
name|device
operator|=
operator|(
name|SID_QUAL_LU_CONNECTED
operator|<<
literal|5
operator|)
operator||
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
expr_stmt|;
else|else
name|bdc_ptr
operator|->
name|device
operator|=
operator|(
name|SID_QUAL_LU_OFFLINE
operator|<<
literal|5
operator|)
operator||
name|T_DIRECT
expr_stmt|;
name|bdc_ptr
operator|->
name|page_code
operator|=
name|SVPD_BDC
expr_stmt|;
name|scsi_ulto2b
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|bdc_ptr
argument_list|)
operator|-
literal|4
argument_list|,
name|bdc_ptr
operator|->
name|page_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|!=
name|NULL
operator|&&
operator|(
name|value
operator|=
name|ctl_get_opt
argument_list|(
operator|&
name|lun
operator|->
name|be_lun
operator|->
name|options
argument_list|,
literal|"rpm"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|i
operator|=
name|strtol
argument_list|(
name|value
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|i
operator|=
name|CTL_DEFAULT_ROTATION_RATE
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|i
argument_list|,
name|bdc_ptr
operator|->
name|medium_rotation_rate
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|!=
name|NULL
operator|&&
operator|(
name|value
operator|=
name|ctl_get_opt
argument_list|(
operator|&
name|lun
operator|->
name|be_lun
operator|->
name|options
argument_list|,
literal|"formfactor"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|i
operator|=
name|strtol
argument_list|(
name|value
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|i
operator|=
literal|0
expr_stmt|;
name|bdc_ptr
operator|->
name|wab_wac_ff
operator|=
operator|(
name|i
operator|&
literal|0x0f
operator|)
expr_stmt|;
name|bdc_ptr
operator|->
name|flags
operator|=
name|SVPD_FUAB
operator||
name|SVPD_VBULS
expr_stmt|;
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_inquiry_evpd_lbp
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|int
name|alloc_len
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
name|CTL_LUN
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|struct
name|scsi_vpd_logical_block_prov
modifier|*
name|lbp_ptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|lbp_ptr
argument_list|)
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|lbp_ptr
operator|=
operator|(
expr|struct
name|scsi_vpd_logical_block_prov
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|min
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|lbp_ptr
argument_list|)
argument_list|,
name|alloc_len
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|ctsio
operator|->
name|kern_data_len
expr_stmt|;
comment|/* 	 * The control device is always connected.  The disk device, on the 	 * other hand, may not be online all the time.  Need to change this 	 * to figure out whether the disk device is actually online or not. 	 */
if|if
condition|(
name|lun
operator|!=
name|NULL
condition|)
name|lbp_ptr
operator|->
name|device
operator|=
operator|(
name|SID_QUAL_LU_CONNECTED
operator|<<
literal|5
operator|)
operator||
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
expr_stmt|;
else|else
name|lbp_ptr
operator|->
name|device
operator|=
operator|(
name|SID_QUAL_LU_OFFLINE
operator|<<
literal|5
operator|)
operator||
name|T_DIRECT
expr_stmt|;
name|lbp_ptr
operator|->
name|page_code
operator|=
name|SVPD_LBP
expr_stmt|;
name|scsi_ulto2b
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|lbp_ptr
argument_list|)
operator|-
literal|4
argument_list|,
name|lbp_ptr
operator|->
name|page_length
argument_list|)
expr_stmt|;
name|lbp_ptr
operator|->
name|threshold_exponent
operator|=
name|CTL_LBP_EXPONENT
expr_stmt|;
if|if
condition|(
name|lun
operator|!=
name|NULL
operator|&&
name|lun
operator|->
name|be_lun
operator|->
name|flags
operator|&
name|CTL_LUN_FLAG_UNMAP
condition|)
block|{
name|lbp_ptr
operator|->
name|flags
operator|=
name|SVPD_LBP_UNMAP
operator||
name|SVPD_LBP_WS16
operator||
name|SVPD_LBP_WS10
operator||
name|SVPD_LBP_RZ
operator||
name|SVPD_LBP_ANC_SUP
expr_stmt|;
name|value
operator|=
name|ctl_get_opt
argument_list|(
operator|&
name|lun
operator|->
name|be_lun
operator|->
name|options
argument_list|,
literal|"provisioning_type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"resource"
argument_list|)
operator|==
literal|0
condition|)
name|lbp_ptr
operator|->
name|prov_type
operator|=
name|SVPD_LBP_RESOURCE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"thin"
argument_list|)
operator|==
literal|0
condition|)
name|lbp_ptr
operator|->
name|prov_type
operator|=
name|SVPD_LBP_THIN
expr_stmt|;
block|}
else|else
name|lbp_ptr
operator|->
name|prov_type
operator|=
name|SVPD_LBP_THIN
expr_stmt|;
block|}
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * INQUIRY with the EVPD bit set.  */
end_comment

begin_function
specifier|static
name|int
name|ctl_inquiry_evpd
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
name|CTL_LUN
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|struct
name|scsi_inquiry
modifier|*
name|cdb
decl_stmt|;
name|int
name|alloc_len
decl_stmt|,
name|retval
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_inquiry
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|alloc_len
operator|=
name|scsi_2btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cdb
operator|->
name|page_code
condition|)
block|{
case|case
name|SVPD_SUPPORTED_PAGES
case|:
name|retval
operator|=
name|ctl_inquiry_evpd_supported
argument_list|(
name|ctsio
argument_list|,
name|alloc_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVPD_UNIT_SERIAL_NUMBER
case|:
name|retval
operator|=
name|ctl_inquiry_evpd_serial
argument_list|(
name|ctsio
argument_list|,
name|alloc_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVPD_DEVICE_ID
case|:
name|retval
operator|=
name|ctl_inquiry_evpd_devid
argument_list|(
name|ctsio
argument_list|,
name|alloc_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVPD_EXTENDED_INQUIRY_DATA
case|:
name|retval
operator|=
name|ctl_inquiry_evpd_eid
argument_list|(
name|ctsio
argument_list|,
name|alloc_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVPD_MODE_PAGE_POLICY
case|:
name|retval
operator|=
name|ctl_inquiry_evpd_mpp
argument_list|(
name|ctsio
argument_list|,
name|alloc_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVPD_SCSI_PORTS
case|:
name|retval
operator|=
name|ctl_inquiry_evpd_scsi_ports
argument_list|(
name|ctsio
argument_list|,
name|alloc_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVPD_SCSI_TPC
case|:
name|retval
operator|=
name|ctl_inquiry_evpd_tpc
argument_list|(
name|ctsio
argument_list|,
name|alloc_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVPD_BLOCK_LIMITS
case|:
if|if
condition|(
name|lun
operator|==
name|NULL
operator|||
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
operator|!=
name|T_DIRECT
condition|)
goto|goto
name|err
goto|;
name|retval
operator|=
name|ctl_inquiry_evpd_block_limits
argument_list|(
name|ctsio
argument_list|,
name|alloc_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVPD_BDC
case|:
if|if
condition|(
name|lun
operator|==
name|NULL
operator|||
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
operator|!=
name|T_DIRECT
condition|)
goto|goto
name|err
goto|;
name|retval
operator|=
name|ctl_inquiry_evpd_bdc
argument_list|(
name|ctsio
argument_list|,
name|alloc_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVPD_LBP
case|:
if|if
condition|(
name|lun
operator|==
name|NULL
operator|||
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
operator|!=
name|T_DIRECT
condition|)
goto|goto
name|err
goto|;
name|retval
operator|=
name|ctl_inquiry_evpd_lbp
argument_list|(
name|ctsio
argument_list|,
name|alloc_len
argument_list|)
expr_stmt|;
break|break;
default|default:
name|err
label|:
name|ctl_set_invalid_field
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|2
argument_list|,
comment|/*bit_valid*/
literal|0
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
name|retval
operator|=
name|CTL_RETVAL_COMPLETE
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Standard INQUIRY data.  */
end_comment

begin_function
specifier|static
name|int
name|ctl_inquiry_std
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|CTL_SOFTC
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|struct
name|ctl_port
modifier|*
name|port
init|=
name|CTL_PORT
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
name|CTL_LUN
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|struct
name|scsi_inquiry_data
modifier|*
name|inq_ptr
decl_stmt|;
name|struct
name|scsi_inquiry
modifier|*
name|cdb
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|uint32_t
name|alloc_len
decl_stmt|,
name|data_len
decl_stmt|;
name|ctl_port_type
name|port_type
decl_stmt|;
name|port_type
operator|=
name|port
operator|->
name|port_type
expr_stmt|;
if|if
condition|(
name|port_type
operator|==
name|CTL_PORT_IOCTL
operator|||
name|port_type
operator|==
name|CTL_PORT_INTERNAL
condition|)
name|port_type
operator|=
name|CTL_PORT_SCSI
expr_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_inquiry
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|alloc_len
operator|=
name|scsi_2btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
comment|/* 	 * We malloc the full inquiry data size here and fill it 	 * in.  If the user only asks for less, we'll give him 	 * that much. 	 */
name|data_len
operator|=
name|offsetof
argument_list|(
expr|struct
name|scsi_inquiry_data
argument_list|,
name|vendor_specific1
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
name|data_len
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|inq_ptr
operator|=
operator|(
expr|struct
name|scsi_inquiry_data
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|min
argument_list|(
name|data_len
argument_list|,
name|alloc_len
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|ctsio
operator|->
name|kern_data_len
expr_stmt|;
if|if
condition|(
name|lun
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_PRIMARY_SC
operator|)
operator|||
name|softc
operator|->
name|ha_link
operator|>=
name|CTL_HA_LINK_UNKNOWN
condition|)
block|{
name|inq_ptr
operator|->
name|device
operator|=
operator|(
name|SID_QUAL_LU_CONNECTED
operator|<<
literal|5
operator|)
operator||
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
expr_stmt|;
block|}
else|else
block|{
name|inq_ptr
operator|->
name|device
operator|=
operator|(
name|SID_QUAL_LU_OFFLINE
operator|<<
literal|5
operator|)
operator||
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
expr_stmt|;
block|}
if|if
condition|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_REMOVABLE
condition|)
name|inq_ptr
operator|->
name|dev_qual2
operator||=
name|SID_RMB
expr_stmt|;
block|}
else|else
name|inq_ptr
operator|->
name|device
operator|=
operator|(
name|SID_QUAL_BAD_LU
operator|<<
literal|5
operator|)
operator||
name|T_NODEVICE
expr_stmt|;
comment|/* RMB in byte 2 is 0 */
name|inq_ptr
operator|->
name|version
operator|=
name|SCSI_REV_SPC5
expr_stmt|;
comment|/* 	 * According to SAM-3, even if a device only supports a single 	 * level of LUN addressing, it should still set the HISUP bit: 	 * 	 * 4.9.1 Logical unit numbers overview 	 * 	 * All logical unit number formats described in this standard are 	 * hierarchical in structure even when only a single level in that 	 * hierarchy is used. The HISUP bit shall be set to one in the 	 * standard INQUIRY data (see SPC-2) when any logical unit number 	 * format described in this standard is used.  Non-hierarchical 	 * formats are outside the scope of this standard. 	 * 	 * Therefore we set the HiSup bit here. 	 * 	 * The response format is 2, per SPC-3. 	 */
name|inq_ptr
operator|->
name|response_format
operator|=
name|SID_HiSup
operator||
literal|2
expr_stmt|;
name|inq_ptr
operator|->
name|additional_length
operator|=
name|data_len
operator|-
operator|(
name|offsetof
argument_list|(
expr|struct
name|scsi_inquiry_data
argument_list|,
name|additional_length
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"additional_length = %d\n"
operator|,
name|inq_ptr
operator|->
name|additional_length
operator|)
argument_list|)
expr_stmt|;
name|inq_ptr
operator|->
name|spc3_flags
operator|=
name|SPC3_SID_3PC
operator||
name|SPC3_SID_TPGS_IMPLICIT
expr_stmt|;
if|if
condition|(
name|port_type
operator|==
name|CTL_PORT_SCSI
condition|)
name|inq_ptr
operator|->
name|spc2_flags
operator|=
name|SPC2_SID_ADDR16
expr_stmt|;
name|inq_ptr
operator|->
name|spc2_flags
operator||=
name|SPC2_SID_MultiP
expr_stmt|;
name|inq_ptr
operator|->
name|flags
operator|=
name|SID_CmdQue
expr_stmt|;
if|if
condition|(
name|port_type
operator|==
name|CTL_PORT_SCSI
condition|)
name|inq_ptr
operator|->
name|flags
operator||=
name|SID_WBus16
operator||
name|SID_Sync
expr_stmt|;
comment|/* 	 * Per SPC-3, unused bytes in ASCII strings are filled with spaces. 	 * We have 8 bytes for the vendor name, and 16 bytes for the device 	 * name and 4 bytes for the revision. 	 */
if|if
condition|(
name|lun
operator|==
name|NULL
operator|||
operator|(
name|val
operator|=
name|ctl_get_opt
argument_list|(
operator|&
name|lun
operator|->
name|be_lun
operator|->
name|options
argument_list|,
literal|"vendor"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|strncpy
argument_list|(
name|inq_ptr
operator|->
name|vendor
argument_list|,
name|CTL_VENDOR
argument_list|,
sizeof|sizeof
argument_list|(
name|inq_ptr
operator|->
name|vendor
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memset
argument_list|(
name|inq_ptr
operator|->
name|vendor
argument_list|,
literal|' '
argument_list|,
sizeof|sizeof
argument_list|(
name|inq_ptr
operator|->
name|vendor
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|inq_ptr
operator|->
name|vendor
argument_list|,
name|val
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|inq_ptr
operator|->
name|vendor
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lun
operator|==
name|NULL
condition|)
block|{
name|strncpy
argument_list|(
name|inq_ptr
operator|->
name|product
argument_list|,
name|CTL_DIRECT_PRODUCT
argument_list|,
sizeof|sizeof
argument_list|(
name|inq_ptr
operator|->
name|product
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|val
operator|=
name|ctl_get_opt
argument_list|(
operator|&
name|lun
operator|->
name|be_lun
operator|->
name|options
argument_list|,
literal|"product"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
switch|switch
condition|(
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
condition|)
block|{
case|case
name|T_DIRECT
case|:
name|strncpy
argument_list|(
name|inq_ptr
operator|->
name|product
argument_list|,
name|CTL_DIRECT_PRODUCT
argument_list|,
sizeof|sizeof
argument_list|(
name|inq_ptr
operator|->
name|product
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_PROCESSOR
case|:
name|strncpy
argument_list|(
name|inq_ptr
operator|->
name|product
argument_list|,
name|CTL_PROCESSOR_PRODUCT
argument_list|,
sizeof|sizeof
argument_list|(
name|inq_ptr
operator|->
name|product
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_CDROM
case|:
name|strncpy
argument_list|(
name|inq_ptr
operator|->
name|product
argument_list|,
name|CTL_CDROM_PRODUCT
argument_list|,
sizeof|sizeof
argument_list|(
name|inq_ptr
operator|->
name|product
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|strncpy
argument_list|(
name|inq_ptr
operator|->
name|product
argument_list|,
name|CTL_UNKNOWN_PRODUCT
argument_list|,
sizeof|sizeof
argument_list|(
name|inq_ptr
operator|->
name|product
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|memset
argument_list|(
name|inq_ptr
operator|->
name|product
argument_list|,
literal|' '
argument_list|,
sizeof|sizeof
argument_list|(
name|inq_ptr
operator|->
name|product
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|inq_ptr
operator|->
name|product
argument_list|,
name|val
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|inq_ptr
operator|->
name|product
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * XXX make this a macro somewhere so it automatically gets 	 * incremented when we make changes. 	 */
if|if
condition|(
name|lun
operator|==
name|NULL
operator|||
operator|(
name|val
operator|=
name|ctl_get_opt
argument_list|(
operator|&
name|lun
operator|->
name|be_lun
operator|->
name|options
argument_list|,
literal|"revision"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|strncpy
argument_list|(
name|inq_ptr
operator|->
name|revision
argument_list|,
literal|"0001"
argument_list|,
sizeof|sizeof
argument_list|(
name|inq_ptr
operator|->
name|revision
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memset
argument_list|(
name|inq_ptr
operator|->
name|revision
argument_list|,
literal|' '
argument_list|,
sizeof|sizeof
argument_list|(
name|inq_ptr
operator|->
name|revision
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|inq_ptr
operator|->
name|revision
argument_list|,
name|val
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|inq_ptr
operator|->
name|revision
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * For parallel SCSI, we support double transition and single 	 * transition clocking.  We also support QAS (Quick Arbitration 	 * and Selection) and Information Unit transfers on both the 	 * control and array devices. 	 */
if|if
condition|(
name|port_type
operator|==
name|CTL_PORT_SCSI
condition|)
name|inq_ptr
operator|->
name|spi3data
operator|=
name|SID_SPI_CLOCK_DT_ST
operator||
name|SID_SPI_QAS
operator||
name|SID_SPI_IUS
expr_stmt|;
comment|/* SAM-6 (no version claimed) */
name|scsi_ulto2b
argument_list|(
literal|0x00C0
argument_list|,
name|inq_ptr
operator|->
name|version1
argument_list|)
expr_stmt|;
comment|/* SPC-5 (no version claimed) */
name|scsi_ulto2b
argument_list|(
literal|0x05C0
argument_list|,
name|inq_ptr
operator|->
name|version2
argument_list|)
expr_stmt|;
if|if
condition|(
name|port_type
operator|==
name|CTL_PORT_FC
condition|)
block|{
comment|/* FCP-2 ANSI INCITS.350:2003 */
name|scsi_ulto2b
argument_list|(
literal|0x0917
argument_list|,
name|inq_ptr
operator|->
name|version3
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|port_type
operator|==
name|CTL_PORT_SCSI
condition|)
block|{
comment|/* SPI-4 ANSI INCITS.362:200x */
name|scsi_ulto2b
argument_list|(
literal|0x0B56
argument_list|,
name|inq_ptr
operator|->
name|version3
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|port_type
operator|==
name|CTL_PORT_ISCSI
condition|)
block|{
comment|/* iSCSI (no version claimed) */
name|scsi_ulto2b
argument_list|(
literal|0x0960
argument_list|,
name|inq_ptr
operator|->
name|version3
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|port_type
operator|==
name|CTL_PORT_SAS
condition|)
block|{
comment|/* SAS (no version claimed) */
name|scsi_ulto2b
argument_list|(
literal|0x0BE0
argument_list|,
name|inq_ptr
operator|->
name|version3
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lun
operator|==
name|NULL
condition|)
block|{
comment|/* SBC-4 (no version claimed) */
name|scsi_ulto2b
argument_list|(
literal|0x0600
argument_list|,
name|inq_ptr
operator|->
name|version4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
condition|)
block|{
case|case
name|T_DIRECT
case|:
comment|/* SBC-4 (no version claimed) */
name|scsi_ulto2b
argument_list|(
literal|0x0600
argument_list|,
name|inq_ptr
operator|->
name|version4
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_PROCESSOR
case|:
break|break;
case|case
name|T_CDROM
case|:
comment|/* MMC-6 (no version claimed) */
name|scsi_ulto2b
argument_list|(
literal|0x04E0
argument_list|,
name|inq_ptr
operator|->
name|version4
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_inquiry
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|scsi_inquiry
modifier|*
name|cdb
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_inquiry\n"
operator|)
argument_list|)
expr_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_inquiry
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SI_EVPD
condition|)
name|retval
operator|=
name|ctl_inquiry_evpd
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cdb
operator|->
name|page_code
operator|==
literal|0
condition|)
name|retval
operator|=
name|ctl_inquiry_std
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
else|else
block|{
name|ctl_set_invalid_field
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|2
argument_list|,
comment|/*bit_valid*/
literal|0
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_get_config
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
name|CTL_LUN
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|struct
name|scsi_get_config_header
modifier|*
name|hdr
decl_stmt|;
name|struct
name|scsi_get_config_feature
modifier|*
name|feature
decl_stmt|;
name|struct
name|scsi_get_config
modifier|*
name|cdb
decl_stmt|;
name|uint32_t
name|alloc_len
decl_stmt|,
name|data_len
decl_stmt|;
name|int
name|rt
decl_stmt|,
name|starting
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_get_config
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|rt
operator|=
operator|(
name|cdb
operator|->
name|rt
operator|&
name|SGC_RT_MASK
operator|)
expr_stmt|;
name|starting
operator|=
name|scsi_2btoul
argument_list|(
name|cdb
operator|->
name|starting_feature
argument_list|)
expr_stmt|;
name|alloc_len
operator|=
name|scsi_2btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
name|data_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_get_config_header
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_get_config_feature
argument_list|)
operator|+
literal|8
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_get_config_feature
argument_list|)
operator|+
literal|8
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_get_config_feature
argument_list|)
operator|+
literal|4
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_get_config_feature
argument_list|)
operator|+
literal|4
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_get_config_feature
argument_list|)
operator|+
literal|8
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_get_config_feature
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_get_config_feature
argument_list|)
operator|+
literal|4
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_get_config_feature
argument_list|)
operator|+
literal|4
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_get_config_feature
argument_list|)
operator|+
literal|4
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_get_config_feature
argument_list|)
operator|+
literal|4
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_get_config_feature
argument_list|)
operator|+
literal|4
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_get_config_feature
argument_list|)
operator|+
literal|4
expr_stmt|;
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
name|data_len
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|hdr
operator|=
operator|(
expr|struct
name|scsi_get_config_header
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_NO_MEDIA
condition|)
name|scsi_ulto2b
argument_list|(
literal|0x0000
argument_list|,
name|hdr
operator|->
name|current_profile
argument_list|)
expr_stmt|;
else|else
name|scsi_ulto2b
argument_list|(
literal|0x0010
argument_list|,
name|hdr
operator|->
name|current_profile
argument_list|)
expr_stmt|;
name|feature
operator|=
operator|(
expr|struct
name|scsi_get_config_feature
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|starting
operator|>
literal|0x003b
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|starting
operator|>
literal|0x003a
condition|)
goto|goto
name|f3b
goto|;
if|if
condition|(
name|starting
operator|>
literal|0x002b
condition|)
goto|goto
name|f3a
goto|;
if|if
condition|(
name|starting
operator|>
literal|0x002a
condition|)
goto|goto
name|f2b
goto|;
if|if
condition|(
name|starting
operator|>
literal|0x001f
condition|)
goto|goto
name|f2a
goto|;
if|if
condition|(
name|starting
operator|>
literal|0x001e
condition|)
goto|goto
name|f1f
goto|;
if|if
condition|(
name|starting
operator|>
literal|0x001d
condition|)
goto|goto
name|f1e
goto|;
if|if
condition|(
name|starting
operator|>
literal|0x0010
condition|)
goto|goto
name|f1d
goto|;
if|if
condition|(
name|starting
operator|>
literal|0x0003
condition|)
goto|goto
name|f10
goto|;
if|if
condition|(
name|starting
operator|>
literal|0x0002
condition|)
goto|goto
name|f3
goto|;
if|if
condition|(
name|starting
operator|>
literal|0x0001
condition|)
goto|goto
name|f2
goto|;
if|if
condition|(
name|starting
operator|>
literal|0x0000
condition|)
goto|goto
name|f1
goto|;
comment|/* Profile List */
name|scsi_ulto2b
argument_list|(
literal|0x0000
argument_list|,
name|feature
operator|->
name|feature_code
argument_list|)
expr_stmt|;
name|feature
operator|->
name|flags
operator|=
name|SGC_F_PERSISTENT
operator||
name|SGC_F_CURRENT
expr_stmt|;
name|feature
operator|->
name|add_length
operator|=
literal|8
expr_stmt|;
name|scsi_ulto2b
argument_list|(
literal|0x0008
argument_list|,
operator|&
name|feature
operator|->
name|feature_data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* CD-ROM */
name|feature
operator|->
name|feature_data
index|[
literal|2
index|]
operator|=
literal|0x00
expr_stmt|;
name|scsi_ulto2b
argument_list|(
literal|0x0010
argument_list|,
operator|&
name|feature
operator|->
name|feature_data
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
comment|/* DVD-ROM */
name|feature
operator|->
name|feature_data
index|[
literal|6
index|]
operator|=
literal|0x01
expr_stmt|;
name|feature
operator|=
operator|(
expr|struct
name|scsi_get_config_feature
operator|*
operator|)
operator|&
name|feature
operator|->
name|feature_data
index|[
name|feature
operator|->
name|add_length
index|]
expr_stmt|;
name|f1
label|:
comment|/* Core */
name|scsi_ulto2b
argument_list|(
literal|0x0001
argument_list|,
name|feature
operator|->
name|feature_code
argument_list|)
expr_stmt|;
name|feature
operator|->
name|flags
operator|=
literal|0x08
operator||
name|SGC_F_PERSISTENT
operator||
name|SGC_F_CURRENT
expr_stmt|;
name|feature
operator|->
name|add_length
operator|=
literal|8
expr_stmt|;
name|scsi_ulto4b
argument_list|(
literal|0x00000000
argument_list|,
operator|&
name|feature
operator|->
name|feature_data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|feature
operator|->
name|feature_data
index|[
literal|4
index|]
operator|=
literal|0x03
expr_stmt|;
name|feature
operator|=
operator|(
expr|struct
name|scsi_get_config_feature
operator|*
operator|)
operator|&
name|feature
operator|->
name|feature_data
index|[
name|feature
operator|->
name|add_length
index|]
expr_stmt|;
name|f2
label|:
comment|/* Morphing */
name|scsi_ulto2b
argument_list|(
literal|0x0002
argument_list|,
name|feature
operator|->
name|feature_code
argument_list|)
expr_stmt|;
name|feature
operator|->
name|flags
operator|=
literal|0x04
operator||
name|SGC_F_PERSISTENT
operator||
name|SGC_F_CURRENT
expr_stmt|;
name|feature
operator|->
name|add_length
operator|=
literal|4
expr_stmt|;
name|feature
operator|->
name|feature_data
index|[
literal|0
index|]
operator|=
literal|0x02
expr_stmt|;
name|feature
operator|=
operator|(
expr|struct
name|scsi_get_config_feature
operator|*
operator|)
operator|&
name|feature
operator|->
name|feature_data
index|[
name|feature
operator|->
name|add_length
index|]
expr_stmt|;
name|f3
label|:
comment|/* Removable Medium */
name|scsi_ulto2b
argument_list|(
literal|0x0003
argument_list|,
name|feature
operator|->
name|feature_code
argument_list|)
expr_stmt|;
name|feature
operator|->
name|flags
operator|=
literal|0x04
operator||
name|SGC_F_PERSISTENT
operator||
name|SGC_F_CURRENT
expr_stmt|;
name|feature
operator|->
name|add_length
operator|=
literal|4
expr_stmt|;
name|feature
operator|->
name|feature_data
index|[
literal|0
index|]
operator|=
literal|0x39
expr_stmt|;
name|feature
operator|=
operator|(
expr|struct
name|scsi_get_config_feature
operator|*
operator|)
operator|&
name|feature
operator|->
name|feature_data
index|[
name|feature
operator|->
name|add_length
index|]
expr_stmt|;
if|if
condition|(
name|rt
operator|==
name|SGC_RT_CURRENT
operator|&&
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_NO_MEDIA
operator|)
condition|)
goto|goto
name|done
goto|;
name|f10
label|:
comment|/* Random Read */
name|scsi_ulto2b
argument_list|(
literal|0x0010
argument_list|,
name|feature
operator|->
name|feature_code
argument_list|)
expr_stmt|;
name|feature
operator|->
name|flags
operator|=
literal|0x00
expr_stmt|;
if|if
condition|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_NO_MEDIA
operator|)
operator|==
literal|0
condition|)
name|feature
operator|->
name|flags
operator||=
name|SGC_F_CURRENT
expr_stmt|;
name|feature
operator|->
name|add_length
operator|=
literal|8
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|lun
operator|->
name|be_lun
operator|->
name|blocksize
argument_list|,
operator|&
name|feature
operator|->
name|feature_data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|scsi_ulto2b
argument_list|(
literal|1
argument_list|,
operator|&
name|feature
operator|->
name|feature_data
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|feature
operator|->
name|feature_data
index|[
literal|6
index|]
operator|=
literal|0x00
expr_stmt|;
name|feature
operator|=
operator|(
expr|struct
name|scsi_get_config_feature
operator|*
operator|)
operator|&
name|feature
operator|->
name|feature_data
index|[
name|feature
operator|->
name|add_length
index|]
expr_stmt|;
name|f1d
label|:
comment|/* Multi-Read */
name|scsi_ulto2b
argument_list|(
literal|0x001D
argument_list|,
name|feature
operator|->
name|feature_code
argument_list|)
expr_stmt|;
name|feature
operator|->
name|flags
operator|=
literal|0x00
expr_stmt|;
if|if
condition|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_NO_MEDIA
operator|)
operator|==
literal|0
condition|)
name|feature
operator|->
name|flags
operator||=
name|SGC_F_CURRENT
expr_stmt|;
name|feature
operator|->
name|add_length
operator|=
literal|0
expr_stmt|;
name|feature
operator|=
operator|(
expr|struct
name|scsi_get_config_feature
operator|*
operator|)
operator|&
name|feature
operator|->
name|feature_data
index|[
name|feature
operator|->
name|add_length
index|]
expr_stmt|;
name|f1e
label|:
comment|/* CD Read */
name|scsi_ulto2b
argument_list|(
literal|0x001E
argument_list|,
name|feature
operator|->
name|feature_code
argument_list|)
expr_stmt|;
name|feature
operator|->
name|flags
operator|=
literal|0x00
expr_stmt|;
if|if
condition|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_NO_MEDIA
operator|)
operator|==
literal|0
condition|)
name|feature
operator|->
name|flags
operator||=
name|SGC_F_CURRENT
expr_stmt|;
name|feature
operator|->
name|add_length
operator|=
literal|4
expr_stmt|;
name|feature
operator|->
name|feature_data
index|[
literal|0
index|]
operator|=
literal|0x00
expr_stmt|;
name|feature
operator|=
operator|(
expr|struct
name|scsi_get_config_feature
operator|*
operator|)
operator|&
name|feature
operator|->
name|feature_data
index|[
name|feature
operator|->
name|add_length
index|]
expr_stmt|;
name|f1f
label|:
comment|/* DVD Read */
name|scsi_ulto2b
argument_list|(
literal|0x001F
argument_list|,
name|feature
operator|->
name|feature_code
argument_list|)
expr_stmt|;
name|feature
operator|->
name|flags
operator|=
literal|0x08
expr_stmt|;
if|if
condition|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_NO_MEDIA
operator|)
operator|==
literal|0
condition|)
name|feature
operator|->
name|flags
operator||=
name|SGC_F_CURRENT
expr_stmt|;
name|feature
operator|->
name|add_length
operator|=
literal|4
expr_stmt|;
name|feature
operator|->
name|feature_data
index|[
literal|0
index|]
operator|=
literal|0x01
expr_stmt|;
name|feature
operator|->
name|feature_data
index|[
literal|2
index|]
operator|=
literal|0x03
expr_stmt|;
name|feature
operator|=
operator|(
expr|struct
name|scsi_get_config_feature
operator|*
operator|)
operator|&
name|feature
operator|->
name|feature_data
index|[
name|feature
operator|->
name|add_length
index|]
expr_stmt|;
name|f2a
label|:
comment|/* DVD+RW */
name|scsi_ulto2b
argument_list|(
literal|0x002A
argument_list|,
name|feature
operator|->
name|feature_code
argument_list|)
expr_stmt|;
name|feature
operator|->
name|flags
operator|=
literal|0x04
expr_stmt|;
if|if
condition|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_NO_MEDIA
operator|)
operator|==
literal|0
condition|)
name|feature
operator|->
name|flags
operator||=
name|SGC_F_CURRENT
expr_stmt|;
name|feature
operator|->
name|add_length
operator|=
literal|4
expr_stmt|;
name|feature
operator|->
name|feature_data
index|[
literal|0
index|]
operator|=
literal|0x00
expr_stmt|;
name|feature
operator|->
name|feature_data
index|[
literal|1
index|]
operator|=
literal|0x00
expr_stmt|;
name|feature
operator|=
operator|(
expr|struct
name|scsi_get_config_feature
operator|*
operator|)
operator|&
name|feature
operator|->
name|feature_data
index|[
name|feature
operator|->
name|add_length
index|]
expr_stmt|;
name|f2b
label|:
comment|/* DVD+R */
name|scsi_ulto2b
argument_list|(
literal|0x002B
argument_list|,
name|feature
operator|->
name|feature_code
argument_list|)
expr_stmt|;
name|feature
operator|->
name|flags
operator|=
literal|0x00
expr_stmt|;
if|if
condition|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_NO_MEDIA
operator|)
operator|==
literal|0
condition|)
name|feature
operator|->
name|flags
operator||=
name|SGC_F_CURRENT
expr_stmt|;
name|feature
operator|->
name|add_length
operator|=
literal|4
expr_stmt|;
name|feature
operator|->
name|feature_data
index|[
literal|0
index|]
operator|=
literal|0x00
expr_stmt|;
name|feature
operator|=
operator|(
expr|struct
name|scsi_get_config_feature
operator|*
operator|)
operator|&
name|feature
operator|->
name|feature_data
index|[
name|feature
operator|->
name|add_length
index|]
expr_stmt|;
name|f3a
label|:
comment|/* DVD+RW Dual Layer */
name|scsi_ulto2b
argument_list|(
literal|0x003A
argument_list|,
name|feature
operator|->
name|feature_code
argument_list|)
expr_stmt|;
name|feature
operator|->
name|flags
operator|=
literal|0x00
expr_stmt|;
if|if
condition|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_NO_MEDIA
operator|)
operator|==
literal|0
condition|)
name|feature
operator|->
name|flags
operator||=
name|SGC_F_CURRENT
expr_stmt|;
name|feature
operator|->
name|add_length
operator|=
literal|4
expr_stmt|;
name|feature
operator|->
name|feature_data
index|[
literal|0
index|]
operator|=
literal|0x00
expr_stmt|;
name|feature
operator|->
name|feature_data
index|[
literal|1
index|]
operator|=
literal|0x00
expr_stmt|;
name|feature
operator|=
operator|(
expr|struct
name|scsi_get_config_feature
operator|*
operator|)
operator|&
name|feature
operator|->
name|feature_data
index|[
name|feature
operator|->
name|add_length
index|]
expr_stmt|;
name|f3b
label|:
comment|/* DVD+R Dual Layer */
name|scsi_ulto2b
argument_list|(
literal|0x003B
argument_list|,
name|feature
operator|->
name|feature_code
argument_list|)
expr_stmt|;
name|feature
operator|->
name|flags
operator|=
literal|0x00
expr_stmt|;
if|if
condition|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_NO_MEDIA
operator|)
operator|==
literal|0
condition|)
name|feature
operator|->
name|flags
operator||=
name|SGC_F_CURRENT
expr_stmt|;
name|feature
operator|->
name|add_length
operator|=
literal|4
expr_stmt|;
name|feature
operator|->
name|feature_data
index|[
literal|0
index|]
operator|=
literal|0x00
expr_stmt|;
name|feature
operator|=
operator|(
expr|struct
name|scsi_get_config_feature
operator|*
operator|)
operator|&
name|feature
operator|->
name|feature_data
index|[
name|feature
operator|->
name|add_length
index|]
expr_stmt|;
name|done
label|:
name|data_len
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|feature
operator|-
operator|(
name|uint8_t
operator|*
operator|)
name|hdr
expr_stmt|;
if|if
condition|(
name|rt
operator|==
name|SGC_RT_SPECIFIC
operator|&&
name|data_len
operator|>
literal|4
condition|)
block|{
name|feature
operator|=
operator|(
expr|struct
name|scsi_get_config_feature
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|scsi_2btoul
argument_list|(
name|feature
operator|->
name|feature_code
argument_list|)
operator|==
name|starting
condition|)
name|feature
operator|=
operator|(
expr|struct
name|scsi_get_config_feature
operator|*
operator|)
operator|&
name|feature
operator|->
name|feature_data
index|[
name|feature
operator|->
name|add_length
index|]
expr_stmt|;
name|data_len
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|feature
operator|-
operator|(
name|uint8_t
operator|*
operator|)
name|hdr
expr_stmt|;
block|}
name|scsi_ulto4b
argument_list|(
name|data_len
operator|-
literal|4
argument_list|,
name|hdr
operator|->
name|data_length
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|min
argument_list|(
name|data_len
argument_list|,
name|alloc_len
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|ctsio
operator|->
name|kern_data_len
expr_stmt|;
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_get_event_status
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|scsi_get_event_status_header
modifier|*
name|hdr
decl_stmt|;
name|struct
name|scsi_get_event_status
modifier|*
name|cdb
decl_stmt|;
name|uint32_t
name|alloc_len
decl_stmt|,
name|data_len
decl_stmt|;
name|int
name|notif_class
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_get_event_status
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
if|if
condition|(
operator|(
name|cdb
operator|->
name|byte2
operator|&
name|SGESN_POLLED
operator|)
operator|==
literal|0
condition|)
block|{
name|ctl_set_invalid_field
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|1
argument_list|,
comment|/*bit_valid*/
literal|1
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
name|notif_class
operator|=
name|cdb
operator|->
name|notif_class
expr_stmt|;
name|alloc_len
operator|=
name|scsi_2btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
name|data_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_get_event_status_header
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
name|data_len
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|min
argument_list|(
name|data_len
argument_list|,
name|alloc_len
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|ctsio
operator|->
name|kern_data_len
expr_stmt|;
name|hdr
operator|=
operator|(
expr|struct
name|scsi_get_event_status_header
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|scsi_ulto2b
argument_list|(
literal|0
argument_list|,
name|hdr
operator|->
name|descr_length
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|nea_class
operator|=
name|SGESN_NEA
expr_stmt|;
name|hdr
operator|->
name|supported_class
operator|=
literal|0
expr_stmt|;
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_mechanism_status
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|scsi_mechanism_status_header
modifier|*
name|hdr
decl_stmt|;
name|struct
name|scsi_mechanism_status
modifier|*
name|cdb
decl_stmt|;
name|uint32_t
name|alloc_len
decl_stmt|,
name|data_len
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_mechanism_status
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|alloc_len
operator|=
name|scsi_2btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
name|data_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_mechanism_status_header
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
name|data_len
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|min
argument_list|(
name|data_len
argument_list|,
name|alloc_len
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|ctsio
operator|->
name|kern_data_len
expr_stmt|;
name|hdr
operator|=
operator|(
expr|struct
name|scsi_mechanism_status_header
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|hdr
operator|->
name|state1
operator|=
literal|0x00
expr_stmt|;
name|hdr
operator|->
name|state2
operator|=
literal|0xe0
expr_stmt|;
name|scsi_ulto3b
argument_list|(
literal|0
argument_list|,
name|hdr
operator|->
name|lba
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|slots_num
operator|=
literal|0
expr_stmt|;
name|scsi_ulto2b
argument_list|(
literal|0
argument_list|,
name|hdr
operator|->
name|slots_length
argument_list|)
expr_stmt|;
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_ultomsf
parameter_list|(
name|uint32_t
name|lba
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|)
block|{
name|lba
operator|+=
literal|150
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|bin2bcd
argument_list|(
operator|(
name|lba
operator|/
literal|75
operator|)
operator|/
literal|60
argument_list|)
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|bin2bcd
argument_list|(
operator|(
name|lba
operator|/
literal|75
operator|)
operator|%
literal|60
argument_list|)
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|bin2bcd
argument_list|(
name|lba
operator|%
literal|75
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ctl_read_toc
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
name|CTL_LUN
argument_list|(
name|ctsio
argument_list|)
decl_stmt|;
name|struct
name|scsi_read_toc_hdr
modifier|*
name|hdr
decl_stmt|;
name|struct
name|scsi_read_toc_type01_descr
modifier|*
name|descr
decl_stmt|;
name|struct
name|scsi_read_toc
modifier|*
name|cdb
decl_stmt|;
name|uint32_t
name|alloc_len
decl_stmt|,
name|data_len
decl_stmt|;
name|int
name|format
decl_stmt|,
name|msf
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_read_toc
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|msf
operator|=
operator|(
name|cdb
operator|->
name|byte2
operator|&
name|CD_MSF
operator|)
operator|!=
literal|0
expr_stmt|;
name|format
operator|=
name|cdb
operator|->
name|format
expr_stmt|;
name|alloc_len
operator|=
name|scsi_2btoul
argument_list|(
name|cdb
operator|->
name|data_len
argument_list|)
expr_stmt|;
name|data_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_toc_hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|format
operator|==
literal|0
condition|)
name|data_len
operator|+=
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_toc_type01_descr
argument_list|)
expr_stmt|;
else|else
name|data_len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_toc_type01_descr
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
name|data_len
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|min
argument_list|(
name|data_len
argument_list|,
name|alloc_len
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|ctsio
operator|->
name|kern_data_len
expr_stmt|;
name|hdr
operator|=
operator|(
expr|struct
name|scsi_read_toc_hdr
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
if|if
condition|(
name|format
operator|==
literal|0
condition|)
block|{
name|scsi_ulto2b
argument_list|(
literal|0x12
argument_list|,
name|hdr
operator|->
name|data_length
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|first
operator|=
literal|1
expr_stmt|;
name|hdr
operator|->
name|last
operator|=
literal|1
expr_stmt|;
name|descr
operator|=
operator|(
expr|struct
name|scsi_read_toc_type01_descr
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
expr_stmt|;
name|descr
operator|->
name|addr_ctl
operator|=
literal|0x14
expr_stmt|;
name|descr
operator|->
name|track_number
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|msf
condition|)
name|ctl_ultomsf
argument_list|(
literal|0
argument_list|,
name|descr
operator|->
name|track_start
argument_list|)
expr_stmt|;
else|else
name|scsi_ulto4b
argument_list|(
literal|0
argument_list|,
name|descr
operator|->
name|track_start
argument_list|)
expr_stmt|;
name|descr
operator|++
expr_stmt|;
name|descr
operator|->
name|addr_ctl
operator|=
literal|0x14
expr_stmt|;
name|descr
operator|->
name|track_number
operator|=
literal|0xaa
expr_stmt|;
if|if
condition|(
name|msf
condition|)
name|ctl_ultomsf
argument_list|(
name|lun
operator|->
name|be_lun
operator|->
name|maxlba
operator|+
literal|1
argument_list|,
name|descr
operator|->
name|track_start
argument_list|)
expr_stmt|;
else|else
name|scsi_ulto4b
argument_list|(
name|lun
operator|->
name|be_lun
operator|->
name|maxlba
operator|+
literal|1
argument_list|,
name|descr
operator|->
name|track_start
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|scsi_ulto2b
argument_list|(
literal|0x0a
argument_list|,
name|hdr
operator|->
name|data_length
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|first
operator|=
literal|1
expr_stmt|;
name|hdr
operator|->
name|last
operator|=
literal|1
expr_stmt|;
name|descr
operator|=
operator|(
expr|struct
name|scsi_read_toc_type01_descr
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
expr_stmt|;
name|descr
operator|->
name|addr_ctl
operator|=
literal|0x14
expr_stmt|;
name|descr
operator|->
name|track_number
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|msf
condition|)
name|ctl_ultomsf
argument_list|(
literal|0
argument_list|,
name|descr
operator|->
name|track_start
argument_list|)
expr_stmt|;
else|else
name|scsi_ulto4b
argument_list|(
literal|0
argument_list|,
name|descr
operator|->
name|track_start
argument_list|)
expr_stmt|;
block|}
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * For known CDB types, parse the LBA and length.  */
end_comment

begin_function
specifier|static
name|int
name|ctl_get_lba_len
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|,
name|uint64_t
modifier|*
name|lba
parameter_list|,
name|uint64_t
modifier|*
name|len
parameter_list|)
block|{
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|io_type
operator|!=
name|CTL_IO_SCSI
condition|)
return|return
operator|(
literal|1
operator|)
return|;
switch|switch
condition|(
name|io
operator|->
name|scsiio
operator|.
name|cdb
index|[
literal|0
index|]
condition|)
block|{
case|case
name|COMPARE_AND_WRITE
case|:
block|{
name|struct
name|scsi_compare_and_write
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_compare_and_write
operator|*
operator|)
name|io
operator|->
name|scsiio
operator|.
name|cdb
expr_stmt|;
operator|*
name|lba
operator|=
name|scsi_8btou64
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
operator|*
name|len
operator|=
name|cdb
operator|->
name|length
expr_stmt|;
break|break;
block|}
case|case
name|READ_6
case|:
case|case
name|WRITE_6
case|:
block|{
name|struct
name|scsi_rw_6
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_rw_6
operator|*
operator|)
name|io
operator|->
name|scsiio
operator|.
name|cdb
expr_stmt|;
operator|*
name|lba
operator|=
name|scsi_3btoul
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
comment|/* only 5 bits are valid in the most significant address byte */
operator|*
name|lba
operator|&=
literal|0x1fffff
expr_stmt|;
operator|*
name|len
operator|=
name|cdb
operator|->
name|length
expr_stmt|;
break|break;
block|}
case|case
name|READ_10
case|:
case|case
name|WRITE_10
case|:
block|{
name|struct
name|scsi_rw_10
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_rw_10
operator|*
operator|)
name|io
operator|->
name|scsiio
operator|.
name|cdb
expr_stmt|;
operator|*
name|lba
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
operator|*
name|len
operator|=
name|scsi_2btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|WRITE_VERIFY_10
case|:
block|{
name|struct
name|scsi_write_verify_10
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_write_verify_10
operator|*
operator|)
name|io
operator|->
name|scsiio
operator|.
name|cdb
expr_stmt|;
operator|*
name|lba
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
operator|*
name|len
operator|=
name|scsi_2btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|READ_12
case|:
case|case
name|WRITE_12
case|:
block|{
name|struct
name|scsi_rw_12
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_rw_12
operator|*
operator|)
name|io
operator|->
name|scsiio
operator|.
name|cdb
expr_stmt|;
operator|*
name|lba
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
operator|*
name|len
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|WRITE_VERIFY_12
case|:
block|{
name|struct
name|scsi_write_verify_12
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_write_verify_12
operator|*
operator|)
name|io
operator|->
name|scsiio
operator|.
name|cdb
expr_stmt|;
operator|*
name|lba
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
operator|*
name|len
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|READ_16
case|:
case|case
name|WRITE_16
case|:
block|{
name|struct
name|scsi_rw_16
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_rw_16
operator|*
operator|)
name|io
operator|->
name|scsiio
operator|.
name|cdb
expr_stmt|;
operator|*
name|lba
operator|=
name|scsi_8btou64
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
operator|*
name|len
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|WRITE_ATOMIC_16
case|:
block|{
name|struct
name|scsi_write_atomic_16
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_write_atomic_16
operator|*
operator|)
name|io
operator|->
name|scsiio
operator|.
name|cdb
expr_stmt|;
operator|*
name|lba
operator|=
name|scsi_8btou64
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
operator|*
name|len
operator|=
name|scsi_2btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|WRITE_VERIFY_16
case|:
block|{
name|struct
name|scsi_write_verify_16
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_write_verify_16
operator|*
operator|)
name|io
operator|->
name|scsiio
operator|.
name|cdb
expr_stmt|;
operator|*
name|lba
operator|=
name|scsi_8btou64
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
operator|*
name|len
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|WRITE_SAME_10
case|:
block|{
name|struct
name|scsi_write_same_10
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_write_same_10
operator|*
operator|)
name|io
operator|->
name|scsiio
operator|.
name|cdb
expr_stmt|;
operator|*
name|lba
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
operator|*
name|len
operator|=
name|scsi_2btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|WRITE_SAME_16
case|:
block|{
name|struct
name|scsi_write_same_16
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_write_same_16
operator|*
operator|)
name|io
operator|->
name|scsiio
operator|.
name|cdb
expr_stmt|;
operator|*
name|lba
operator|=
name|scsi_8btou64
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
operator|*
name|len
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|VERIFY_10
case|:
block|{
name|struct
name|scsi_verify_10
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_verify_10
operator|*
operator|)
name|io
operator|->
name|scsiio
operator|.
name|cdb
expr_stmt|;
operator|*
name|lba
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
operator|*
name|len
operator|=
name|scsi_2btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|VERIFY_12
case|:
block|{
name|struct
name|scsi_verify_12
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_verify_12
operator|*
operator|)
name|io
operator|->
name|scsiio
operator|.
name|cdb
expr_stmt|;
operator|*
name|lba
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
operator|*
name|len
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|VERIFY_16
case|:
block|{
name|struct
name|scsi_verify_16
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_verify_16
operator|*
operator|)
name|io
operator|->
name|scsiio
operator|.
name|cdb
expr_stmt|;
operator|*
name|lba
operator|=
name|scsi_8btou64
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
operator|*
name|len
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|UNMAP
case|:
block|{
operator|*
name|lba
operator|=
literal|0
expr_stmt|;
operator|*
name|len
operator|=
name|UINT64_MAX
expr_stmt|;
break|break;
block|}
case|case
name|SERVICE_ACTION_IN
case|:
block|{
comment|/* GET LBA STATUS */
name|struct
name|scsi_get_lba_status
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_get_lba_status
operator|*
operator|)
name|io
operator|->
name|scsiio
operator|.
name|cdb
expr_stmt|;
operator|*
name|lba
operator|=
name|scsi_8btou64
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
operator|*
name|len
operator|=
name|UINT32_MAX
expr_stmt|;
break|break;
block|}
default|default:
return|return
operator|(
literal|1
operator|)
return|;
break|break;
comment|/* NOTREACHED */
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ctl_action
name|ctl_extent_check_lba
parameter_list|(
name|uint64_t
name|lba1
parameter_list|,
name|uint64_t
name|len1
parameter_list|,
name|uint64_t
name|lba2
parameter_list|,
name|uint64_t
name|len2
parameter_list|,
name|bool
name|seq
parameter_list|)
block|{
name|uint64_t
name|endlba1
decl_stmt|,
name|endlba2
decl_stmt|;
name|endlba1
operator|=
name|lba1
operator|+
name|len1
operator|-
operator|(
name|seq
condition|?
literal|0
else|:
literal|1
operator|)
expr_stmt|;
name|endlba2
operator|=
name|lba2
operator|+
name|len2
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|endlba1
operator|<
name|lba2
operator|)
operator|||
operator|(
name|endlba2
operator|<
name|lba1
operator|)
condition|)
return|return
operator|(
name|CTL_ACTION_PASS
operator|)
return|;
else|else
return|return
operator|(
name|CTL_ACTION_BLOCK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_extent_check_unmap
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|,
name|uint64_t
name|lba2
parameter_list|,
name|uint64_t
name|len2
parameter_list|)
block|{
name|struct
name|ctl_ptr_len_flags
modifier|*
name|ptrlen
decl_stmt|;
name|struct
name|scsi_unmap_desc
modifier|*
name|buf
decl_stmt|,
modifier|*
name|end
decl_stmt|,
modifier|*
name|range
decl_stmt|;
name|uint64_t
name|lba
decl_stmt|;
name|uint32_t
name|len
decl_stmt|;
comment|/* If not UNMAP -- go other way. */
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|io_type
operator|!=
name|CTL_IO_SCSI
operator|||
name|io
operator|->
name|scsiio
operator|.
name|cdb
index|[
literal|0
index|]
operator|!=
name|UNMAP
condition|)
return|return
operator|(
name|CTL_ACTION_ERROR
operator|)
return|;
comment|/* If UNMAP without data -- block and wait for data. */
name|ptrlen
operator|=
operator|(
expr|struct
name|ctl_ptr_len_flags
operator|*
operator|)
operator|&
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LBA_LEN
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ALLOCATED
operator|)
operator|==
literal|0
operator|||
name|ptrlen
operator|->
name|ptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|CTL_ACTION_BLOCK
operator|)
return|;
comment|/* UNMAP with data -- check for collision. */
name|buf
operator|=
operator|(
expr|struct
name|scsi_unmap_desc
operator|*
operator|)
name|ptrlen
operator|->
name|ptr
expr_stmt|;
name|end
operator|=
name|buf
operator|+
name|ptrlen
operator|->
name|len
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|range
operator|=
name|buf
init|;
name|range
operator|<
name|end
condition|;
name|range
operator|++
control|)
block|{
name|lba
operator|=
name|scsi_8btou64
argument_list|(
name|range
operator|->
name|lba
argument_list|)
expr_stmt|;
name|len
operator|=
name|scsi_4btoul
argument_list|(
name|range
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lba
operator|<
name|lba2
operator|+
name|len2
operator|)
operator|&&
operator|(
name|lba
operator|+
name|len
operator|>
name|lba2
operator|)
condition|)
return|return
operator|(
name|CTL_ACTION_BLOCK
operator|)
return|;
block|}
return|return
operator|(
name|CTL_ACTION_PASS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ctl_action
name|ctl_extent_check
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io1
parameter_list|,
name|union
name|ctl_io
modifier|*
name|io2
parameter_list|,
name|bool
name|seq
parameter_list|)
block|{
name|uint64_t
name|lba1
decl_stmt|,
name|lba2
decl_stmt|;
name|uint64_t
name|len1
decl_stmt|,
name|len2
decl_stmt|;
name|int
name|retval
decl_stmt|;
if|if
condition|(
name|ctl_get_lba_len
argument_list|(
name|io2
argument_list|,
operator|&
name|lba2
argument_list|,
operator|&
name|len2
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|CTL_ACTION_ERROR
operator|)
return|;
name|retval
operator|=
name|ctl_extent_check_unmap
argument_list|(
name|io1
argument_list|,
name|lba2
argument_list|,
name|len2
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|CTL_ACTION_ERROR
condition|)
return|return
operator|(
name|retval
operator|)
return|;
if|if
condition|(
name|ctl_get_lba_len
argument_list|(
name|io1
argument_list|,
operator|&
name|lba1
argument_list|,
operator|&
name|len1
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|CTL_ACTION_ERROR
operator|)
return|;
if|if
condition|(
name|io1
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_SERSEQ_DONE
condition|)
name|seq
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
name|ctl_extent_check_lba
argument_list|(
name|lba1
argument_list|,
name|len1
argument_list|,
name|lba2
argument_list|,
name|len2
argument_list|,
name|seq
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ctl_action
name|ctl_extent_check_seq
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io1
parameter_list|,
name|union
name|ctl_io
modifier|*
name|io2
parameter_list|)
block|{
name|uint64_t
name|lba1
decl_stmt|,
name|lba2
decl_stmt|;
name|uint64_t
name|len1
decl_stmt|,
name|len2
decl_stmt|;
if|if
condition|(
name|io1
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_SERSEQ_DONE
condition|)
return|return
operator|(
name|CTL_ACTION_PASS
operator|)
return|;
if|if
condition|(
name|ctl_get_lba_len
argument_list|(
name|io1
argument_list|,
operator|&
name|lba1
argument_list|,
operator|&
name|len1
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|CTL_ACTION_ERROR
operator|)
return|;
if|if
condition|(
name|ctl_get_lba_len
argument_list|(
name|io2
argument_list|,
operator|&
name|lba2
argument_list|,
operator|&
name|len2
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|CTL_ACTION_ERROR
operator|)
return|;
if|if
condition|(
name|lba1
operator|+
name|len1
operator|==
name|lba2
condition|)
return|return
operator|(
name|CTL_ACTION_BLOCK
operator|)
return|;
return|return
operator|(
name|CTL_ACTION_PASS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ctl_action
name|ctl_check_for_blockage
parameter_list|(
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|,
name|union
name|ctl_io
modifier|*
name|pending_io
parameter_list|,
name|union
name|ctl_io
modifier|*
name|ooa_io
parameter_list|)
block|{
specifier|const
name|struct
name|ctl_cmd_entry
modifier|*
name|pending_entry
decl_stmt|,
modifier|*
name|ooa_entry
decl_stmt|;
specifier|const
name|ctl_serialize_action
modifier|*
name|serialize_row
decl_stmt|;
comment|/* 	 * The initiator attempted multiple untagged commands at the same 	 * time.  Can't do that. 	 */
if|if
condition|(
operator|(
name|pending_io
operator|->
name|scsiio
operator|.
name|tag_type
operator|==
name|CTL_TAG_UNTAGGED
operator|)
operator|&&
operator|(
name|ooa_io
operator|->
name|scsiio
operator|.
name|tag_type
operator|==
name|CTL_TAG_UNTAGGED
operator|)
operator|&&
operator|(
operator|(
name|pending_io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
operator|==
name|ooa_io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
operator|)
operator|&&
operator|(
name|pending_io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|initid
operator|==
name|ooa_io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|initid
operator|)
operator|)
operator|&&
operator|(
operator|(
name|ooa_io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
operator|(
name|CTL_FLAG_ABORT
operator||
name|CTL_FLAG_STATUS_SENT
operator|)
operator|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|CTL_ACTION_OVERLAP
operator|)
return|;
comment|/* 	 * The initiator attempted to send multiple tagged commands with 	 * the same ID.  (It's fine if different initiators have the same 	 * tag ID.) 	 * 	 * Even if all of those conditions are true, we don't kill the I/O 	 * if the command ahead of us has been aborted.  We won't end up 	 * sending it to the FETD, and it's perfectly legal to resend a 	 * command with the same tag number as long as the previous 	 * instance of this tag number has been aborted somehow. 	 */
if|if
condition|(
operator|(
name|pending_io
operator|->
name|scsiio
operator|.
name|tag_type
operator|!=
name|CTL_TAG_UNTAGGED
operator|)
operator|&&
operator|(
name|ooa_io
operator|->
name|scsiio
operator|.
name|tag_type
operator|!=
name|CTL_TAG_UNTAGGED
operator|)
operator|&&
operator|(
name|pending_io
operator|->
name|scsiio
operator|.
name|tag_num
operator|==
name|ooa_io
operator|->
name|scsiio
operator|.
name|tag_num
operator|)
operator|&&
operator|(
operator|(
name|pending_io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
operator|==
name|ooa_io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
operator|)
operator|&&
operator|(
name|pending_io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|initid
operator|==
name|ooa_io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|initid
operator|)
operator|)
operator|&&
operator|(
operator|(
name|ooa_io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
operator|(
name|CTL_FLAG_ABORT
operator||
name|CTL_FLAG_STATUS_SENT
operator|)
operator|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|CTL_ACTION_OVERLAP_TAG
operator|)
return|;
comment|/* 	 * If we get a head of queue tag, SAM-3 says that we should 	 * immediately execute it. 	 * 	 * What happens if this command would normally block for some other 	 * reason?  e.g. a request sense with a head of queue tag 	 * immediately after a write.  Normally that would block, but this 	 * will result in its getting executed immediately... 	 * 	 * We currently return "pass" instead of "skip", so we'll end up 	 * going through the rest of the queue to check for overlapped tags. 	 * 	 * XXX KDM check for other types of blockage first?? 	 */
if|if
condition|(
name|pending_io
operator|->
name|scsiio
operator|.
name|tag_type
operator|==
name|CTL_TAG_HEAD_OF_QUEUE
condition|)
return|return
operator|(
name|CTL_ACTION_PASS
operator|)
return|;
comment|/* 	 * Ordered tags have to block until all items ahead of them 	 * have completed.  If we get called with an ordered tag, we always 	 * block, if something else is ahead of us in the queue. 	 */
if|if
condition|(
name|pending_io
operator|->
name|scsiio
operator|.
name|tag_type
operator|==
name|CTL_TAG_ORDERED
condition|)
return|return
operator|(
name|CTL_ACTION_BLOCK
operator|)
return|;
comment|/* 	 * Simple tags get blocked until all head of queue and ordered tags 	 * ahead of them have completed.  I'm lumping untagged commands in 	 * with simple tags here.  XXX KDM is that the right thing to do? 	 */
if|if
condition|(
operator|(
operator|(
name|pending_io
operator|->
name|scsiio
operator|.
name|tag_type
operator|==
name|CTL_TAG_UNTAGGED
operator|)
operator|||
operator|(
name|pending_io
operator|->
name|scsiio
operator|.
name|tag_type
operator|==
name|CTL_TAG_SIMPLE
operator|)
operator|)
operator|&&
operator|(
operator|(
name|ooa_io
operator|->
name|scsiio
operator|.
name|tag_type
operator|==
name|CTL_TAG_HEAD_OF_QUEUE
operator|)
operator|||
operator|(
name|ooa_io
operator|->
name|scsiio
operator|.
name|tag_type
operator|==
name|CTL_TAG_ORDERED
operator|)
operator|)
condition|)
return|return
operator|(
name|CTL_ACTION_BLOCK
operator|)
return|;
name|pending_entry
operator|=
name|ctl_get_cmd_entry
argument_list|(
operator|&
name|pending_io
operator|->
name|scsiio
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pending_entry
operator|->
name|seridx
operator|<
name|CTL_SERIDX_COUNT
argument_list|,
operator|(
literal|"%s: Invalid seridx %d for pending CDB %02x %02x @ %p"
operator|,
name|__func__
operator|,
name|pending_entry
operator|->
name|seridx
operator|,
name|pending_io
operator|->
name|scsiio
operator|.
name|cdb
index|[
literal|0
index|]
operator|,
name|pending_io
operator|->
name|scsiio
operator|.
name|cdb
index|[
literal|1
index|]
operator|,
name|pending_io
operator|)
argument_list|)
expr_stmt|;
name|ooa_entry
operator|=
name|ctl_get_cmd_entry
argument_list|(
operator|&
name|ooa_io
operator|->
name|scsiio
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ooa_entry
operator|->
name|seridx
operator|==
name|CTL_SERIDX_INVLD
condition|)
return|return
operator|(
name|CTL_ACTION_PASS
operator|)
return|;
comment|/* Unsupported command in OOA queue */
name|KASSERT
argument_list|(
name|ooa_entry
operator|->
name|seridx
operator|<
name|CTL_SERIDX_COUNT
argument_list|,
operator|(
literal|"%s: Invalid seridx %d for ooa CDB %02x %02x @ %p"
operator|,
name|__func__
operator|,
name|ooa_entry
operator|->
name|seridx
operator|,
name|ooa_io
operator|->
name|scsiio
operator|.
name|cdb
index|[
literal|0
index|]
operator|,
name|ooa_io
operator|->
name|scsiio
operator|.
name|cdb
index|[
literal|1
index|]
operator|,
name|ooa_io
operator|)
argument_list|)
expr_stmt|;
name|serialize_row
operator|=
name|ctl_serialize_table
index|[
name|ooa_entry
operator|->
name|seridx
index|]
expr_stmt|;
switch|switch
condition|(
name|serialize_row
index|[
name|pending_entry
operator|->
name|seridx
index|]
condition|)
block|{
case|case
name|CTL_SER_BLOCK
case|:
return|return
operator|(
name|CTL_ACTION_BLOCK
operator|)
return|;
case|case
name|CTL_SER_EXTENT
case|:
return|return
operator|(
name|ctl_extent_check
argument_list|(
name|ooa_io
argument_list|,
name|pending_io
argument_list|,
operator|(
name|lun
operator|->
name|be_lun
operator|&&
name|lun
operator|->
name|be_lun
operator|->
name|serseq
operator|==
name|CTL_LUN_SERSEQ_ON
operator|)
argument_list|)
operator|)
return|;
case|case
name|CTL_SER_EXTENTOPT
case|:
if|if
condition|(
operator|(
name|lun
operator|->
name|MODE_CTRL
operator|.
name|queue_flags
operator|&
name|SCP_QUEUE_ALG_MASK
operator|)
operator|!=
name|SCP_QUEUE_ALG_UNRESTRICTED
condition|)
return|return
operator|(
name|ctl_extent_check
argument_list|(
name|ooa_io
argument_list|,
name|pending_io
argument_list|,
operator|(
name|lun
operator|->
name|be_lun
operator|&&
name|lun
operator|->
name|be_lun
operator|->
name|serseq
operator|==
name|CTL_LUN_SERSEQ_ON
operator|)
argument_list|)
operator|)
return|;
return|return
operator|(
name|CTL_ACTION_PASS
operator|)
return|;
case|case
name|CTL_SER_EXTENTSEQ
case|:
if|if
condition|(
name|lun
operator|->
name|be_lun
operator|&&
name|lun
operator|->
name|be_lun
operator|->
name|serseq
operator|!=
name|CTL_LUN_SERSEQ_OFF
condition|)
return|return
operator|(
name|ctl_extent_check_seq
argument_list|(
name|ooa_io
argument_list|,
name|pending_io
argument_list|)
operator|)
return|;
return|return
operator|(
name|CTL_ACTION_PASS
operator|)
return|;
case|case
name|CTL_SER_PASS
case|:
return|return
operator|(
name|CTL_ACTION_PASS
operator|)
return|;
case|case
name|CTL_SER_BLOCKOPT
case|:
if|if
condition|(
operator|(
name|lun
operator|->
name|MODE_CTRL
operator|.
name|queue_flags
operator|&
name|SCP_QUEUE_ALG_MASK
operator|)
operator|!=
name|SCP_QUEUE_ALG_UNRESTRICTED
condition|)
return|return
operator|(
name|CTL_ACTION_BLOCK
operator|)
return|;
return|return
operator|(
name|CTL_ACTION_PASS
operator|)
return|;
case|case
name|CTL_SER_SKIP
case|:
return|return
operator|(
name|CTL_ACTION_SKIP
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"%s: Invalid serialization value %d for %d => %d"
argument_list|,
name|__func__
argument_list|,
name|serialize_row
index|[
name|pending_entry
operator|->
name|seridx
index|]
argument_list|,
name|pending_entry
operator|->
name|seridx
argument_list|,
name|ooa_entry
operator|->
name|seridx
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|CTL_ACTION_ERROR
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check for blockage or overlaps against the OOA (Order Of Arrival) queue.  * Assumptions:  * - pending_io is generally either incoming, or on the blocked queue  * - starting I/O is the I/O we want to start the check with.  */
end_comment

begin_function
specifier|static
name|ctl_action
name|ctl_check_ooa
parameter_list|(
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|,
name|union
name|ctl_io
modifier|*
name|pending_io
parameter_list|,
name|union
name|ctl_io
modifier|*
name|starting_io
parameter_list|)
block|{
name|union
name|ctl_io
modifier|*
name|ooa_io
decl_stmt|;
name|ctl_action
name|action
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * Run back along the OOA queue, starting with the current 	 * blocked I/O and going through every I/O before it on the 	 * queue.  If starting_io is NULL, we'll just end up returning 	 * CTL_ACTION_PASS. 	 */
for|for
control|(
name|ooa_io
operator|=
name|starting_io
init|;
name|ooa_io
operator|!=
name|NULL
condition|;
name|ooa_io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|TAILQ_PREV
argument_list|(
operator|&
name|ooa_io
operator|->
name|io_hdr
argument_list|,
name|ctl_ooaq
argument_list|,
name|ooa_links
argument_list|)
control|)
block|{
comment|/* 		 * This routine just checks to see whether 		 * cur_blocked is blocked by ooa_io, which is ahead 		 * of it in the queue.  It doesn't queue/dequeue 		 * cur_blocked. 		 */
name|action
operator|=
name|ctl_check_for_blockage
argument_list|(
name|lun
argument_list|,
name|pending_io
argument_list|,
name|ooa_io
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|CTL_ACTION_BLOCK
case|:
case|case
name|CTL_ACTION_OVERLAP
case|:
case|case
name|CTL_ACTION_OVERLAP_TAG
case|:
case|case
name|CTL_ACTION_SKIP
case|:
case|case
name|CTL_ACTION_ERROR
case|:
return|return
operator|(
name|action
operator|)
return|;
break|break;
comment|/* NOTREACHED */
case|case
name|CTL_ACTION_PASS
case|:
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: Invalid action %d\n"
argument_list|,
name|__func__
argument_list|,
name|action
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|CTL_ACTION_PASS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Assumptions:  * - An I/O has just completed, and has been removed from the per-LUN OOA  *   queue, so some items on the blocked queue may now be unblocked.  */
end_comment

begin_function
specifier|static
name|int
name|ctl_check_blocked
parameter_list|(
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|lun
operator|->
name|ctl_softc
decl_stmt|;
name|union
name|ctl_io
modifier|*
name|cur_blocked
decl_stmt|,
modifier|*
name|next_blocked
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * Run forward from the head of the blocked queue, checking each 	 * entry against the I/Os prior to it on the OOA queue to see if 	 * there is still any blockage. 	 * 	 * We cannot use the TAILQ_FOREACH() macro, because it can't deal 	 * with our removing a variable on it while it is traversing the 	 * list. 	 */
for|for
control|(
name|cur_blocked
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|TAILQ_FIRST
argument_list|(
operator|&
name|lun
operator|->
name|blocked_queue
argument_list|)
init|;
name|cur_blocked
operator|!=
name|NULL
condition|;
name|cur_blocked
operator|=
name|next_blocked
control|)
block|{
name|union
name|ctl_io
modifier|*
name|prev_ooa
decl_stmt|;
name|ctl_action
name|action
decl_stmt|;
name|next_blocked
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|TAILQ_NEXT
argument_list|(
operator|&
name|cur_blocked
operator|->
name|io_hdr
argument_list|,
name|blocked_links
argument_list|)
expr_stmt|;
name|prev_ooa
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|TAILQ_PREV
argument_list|(
operator|&
name|cur_blocked
operator|->
name|io_hdr
argument_list|,
name|ctl_ooaq
argument_list|,
name|ooa_links
argument_list|)
expr_stmt|;
comment|/* 		 * If cur_blocked happens to be the first item in the OOA 		 * queue now, prev_ooa will be NULL, and the action 		 * returned will just be CTL_ACTION_PASS. 		 */
name|action
operator|=
name|ctl_check_ooa
argument_list|(
name|lun
argument_list|,
name|cur_blocked
argument_list|,
name|prev_ooa
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|CTL_ACTION_BLOCK
case|:
comment|/* Nothing to do here, still blocked */
break|break;
case|case
name|CTL_ACTION_OVERLAP
case|:
case|case
name|CTL_ACTION_OVERLAP_TAG
case|:
comment|/* 			 * This shouldn't happen!  In theory we've already 			 * checked this command for overlap... 			 */
break|break;
case|case
name|CTL_ACTION_PASS
case|:
case|case
name|CTL_ACTION_SKIP
case|:
block|{
specifier|const
name|struct
name|ctl_cmd_entry
modifier|*
name|entry
decl_stmt|;
comment|/* 			 * The skip case shouldn't happen, this transaction 			 * should have never made it onto the blocked queue. 			 */
comment|/* 			 * This I/O is no longer blocked, we can remove it 			 * from the blocked queue.  Since this is a TAILQ 			 * (doubly linked list), we can do O(1) removals 			 * from any place on the list. 			 */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|lun
operator|->
name|blocked_queue
argument_list|,
operator|&
name|cur_blocked
operator|->
name|io_hdr
argument_list|,
name|blocked_links
argument_list|)
expr_stmt|;
name|cur_blocked
operator|->
name|io_hdr
operator|.
name|flags
operator|&=
operator|~
name|CTL_FLAG_BLOCKED
expr_stmt|;
if|if
condition|(
operator|(
name|softc
operator|->
name|ha_mode
operator|!=
name|CTL_HA_MODE_XFER
operator|)
operator|&&
operator|(
name|cur_blocked
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_FROM_OTHER_SC
operator|)
condition|)
block|{
comment|/* 				 * Need to send IO back to original side to 				 * run 				 */
name|union
name|ctl_ha_msg
name|msg_info
decl_stmt|;
name|cur_blocked
operator|->
name|io_hdr
operator|.
name|flags
operator|&=
operator|~
name|CTL_FLAG_IO_ACTIVE
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|original_sc
operator|=
name|cur_blocked
operator|->
name|io_hdr
operator|.
name|original_sc
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|serializing_sc
operator|=
name|cur_blocked
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_R2R
expr_stmt|;
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|msg_info
argument_list|,
sizeof|sizeof
argument_list|(
name|msg_info
operator|.
name|hdr
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
break|break;
block|}
name|entry
operator|=
name|ctl_get_cmd_entry
argument_list|(
operator|&
name|cur_blocked
operator|->
name|scsiio
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 			 * Check this I/O for LUN state changes that may 			 * have happened while this command was blocked. 			 * The LUN state may have been changed by a command 			 * ahead of us in the queue, so we need to re-check 			 * for any states that can be caused by SCSI 			 * commands. 			 */
if|if
condition|(
name|ctl_scsiio_lun_check
argument_list|(
name|lun
argument_list|,
name|entry
argument_list|,
operator|&
name|cur_blocked
operator|->
name|scsiio
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cur_blocked
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_IS_WAS_ON_RTR
expr_stmt|;
name|ctl_enqueue_rtr
argument_list|(
name|cur_blocked
argument_list|)
expr_stmt|;
block|}
else|else
name|ctl_done
argument_list|(
name|cur_blocked
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
comment|/* 			 * This probably shouldn't happen -- we shouldn't 			 * get CTL_ACTION_ERROR, or anything else. 			 */
break|break;
block|}
block|}
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This routine (with one exception) checks LUN flags that can be set by  * commands ahead of us in the OOA queue.  These flags have to be checked  * when a command initially comes in, and when we pull a command off the  * blocked queue and are preparing to execute it.  The reason we have to  * check these flags for commands on the blocked queue is that the LUN  * state may have been changed by a command ahead of us while we're on the  * blocked queue.  *  * Ordering is somewhat important with these checks, so please pay  * careful attention to the placement of any new checks.  */
end_comment

begin_function
specifier|static
name|int
name|ctl_scsiio_lun_check
parameter_list|(
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|,
specifier|const
name|struct
name|ctl_cmd_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|lun
operator|->
name|ctl_softc
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|uint32_t
name|residx
decl_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * If this shelf is a secondary shelf controller, we may have to 	 * reject some commands disallowed by HA mode and link state. 	 */
if|if
condition|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_PRIMARY_SC
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|softc
operator|->
name|ha_link
operator|==
name|CTL_HA_LINK_OFFLINE
operator|&&
operator|(
name|entry
operator|->
name|flags
operator|&
name|CTL_CMD_FLAG_OK_ON_UNAVAIL
operator|)
operator|==
literal|0
condition|)
block|{
name|ctl_set_lun_unavail
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_PEER_SC_PRIMARY
operator|)
operator|==
literal|0
operator|&&
operator|(
name|entry
operator|->
name|flags
operator|&
name|CTL_CMD_FLAG_OK_ON_UNAVAIL
operator|)
operator|==
literal|0
condition|)
block|{
name|ctl_set_lun_transit
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
name|softc
operator|->
name|ha_mode
operator|==
name|CTL_HA_MODE_ACT_STBY
operator|&&
operator|(
name|entry
operator|->
name|flags
operator|&
name|CTL_CMD_FLAG_OK_ON_STANDBY
operator|)
operator|==
literal|0
condition|)
block|{
name|ctl_set_lun_standby
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
comment|/* The rest of checks are only done on executing side */
if|if
condition|(
name|softc
operator|->
name|ha_mode
operator|==
name|CTL_HA_MODE_XFER
condition|)
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
name|entry
operator|->
name|pattern
operator|&
name|CTL_LUN_PAT_WRITE
condition|)
block|{
if|if
condition|(
name|lun
operator|->
name|be_lun
operator|&&
name|lun
operator|->
name|be_lun
operator|->
name|flags
operator|&
name|CTL_LUN_FLAG_READONLY
condition|)
block|{
name|ctl_set_hw_write_protected
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
operator|(
name|lun
operator|->
name|MODE_CTRL
operator|.
name|eca_and_aen
operator|&
name|SCP_SWP
operator|)
operator|!=
literal|0
condition|)
block|{
name|ctl_set_sense
argument_list|(
name|ctsio
argument_list|,
comment|/*current_error*/
literal|1
argument_list|,
comment|/*sense_key*/
name|SSD_KEY_DATA_PROTECT
argument_list|,
comment|/*asc*/
literal|0x27
argument_list|,
comment|/*ascq*/
literal|0x02
argument_list|,
name|SSD_ELEM_NONE
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
block|}
comment|/* 	 * Check for a reservation conflict.  If this command isn't allowed 	 * even on reserved LUNs, and if this initiator isn't the one who 	 * reserved us, reject the command with a reservation conflict. 	 */
name|residx
operator|=
name|ctl_get_initindex
argument_list|(
operator|&
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_RESERVED
operator|)
operator|&&
operator|(
operator|(
name|entry
operator|->
name|flags
operator|&
name|CTL_CMD_FLAG_ALLOW_ON_RESV
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|lun
operator|->
name|res_idx
operator|!=
name|residx
condition|)
block|{
name|ctl_set_reservation_conflict
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
block|}
if|if
condition|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_PR_RESERVED
operator|)
operator|==
literal|0
operator|||
operator|(
name|entry
operator|->
name|flags
operator|&
name|CTL_CMD_FLAG_ALLOW_ON_PR_RESV
operator|)
condition|)
block|{
comment|/* No reservation or command is allowed. */
empty_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|entry
operator|->
name|flags
operator|&
name|CTL_CMD_FLAG_ALLOW_ON_PR_WRESV
operator|)
operator|&&
operator|(
name|lun
operator|->
name|pr_res_type
operator|==
name|SPR_TYPE_WR_EX
operator|||
name|lun
operator|->
name|pr_res_type
operator|==
name|SPR_TYPE_WR_EX_RO
operator|||
name|lun
operator|->
name|pr_res_type
operator|==
name|SPR_TYPE_WR_EX_AR
operator|)
condition|)
block|{
comment|/* The command is allowed for Write Exclusive resv. */
empty_stmt|;
block|}
else|else
block|{
comment|/* 		 * if we aren't registered or it's a res holder type 		 * reservation and this isn't the res holder then set a 		 * conflict. 		 */
if|if
condition|(
name|ctl_get_prkey
argument_list|(
name|lun
argument_list|,
name|residx
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|residx
operator|!=
name|lun
operator|->
name|pr_res_idx
operator|&&
name|lun
operator|->
name|pr_res_type
operator|<
literal|4
operator|)
condition|)
block|{
name|ctl_set_reservation_conflict
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
block|}
if|if
condition|(
operator|(
name|entry
operator|->
name|flags
operator|&
name|CTL_CMD_FLAG_OK_ON_NO_MEDIA
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_EJECTED
condition|)
name|ctl_set_lun_ejected
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_NO_MEDIA
condition|)
block|{
if|if
condition|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_REMOVABLE
condition|)
name|ctl_set_lun_no_media
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
else|else
name|ctl_set_lun_int_reqd
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_STOPPED
condition|)
name|ctl_set_lun_stopped
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
else|else
goto|goto
name|bailout
goto|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|bailout
label|:
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_failover_io
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|,
name|int
name|have_lock
parameter_list|)
block|{
name|ctl_set_busy
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_failover_lun
parameter_list|(
name|union
name|ctl_io
modifier|*
name|rio
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|CTL_SOFTC
argument_list|(
name|rio
argument_list|)
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|struct
name|ctl_io_hdr
modifier|*
name|io
decl_stmt|,
modifier|*
name|next_io
decl_stmt|;
name|uint32_t
name|targ_lun
decl_stmt|;
name|targ_lun
operator|=
name|rio
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_mapped_lun
expr_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"FAILOVER for lun %ju\n"
operator|,
name|targ_lun
operator|)
argument_list|)
expr_stmt|;
comment|/* Find and lock the LUN. */
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|targ_lun
operator|>
name|CTL_MAX_LUNS
operator|||
operator|(
name|lun
operator|=
name|softc
operator|->
name|ctl_luns
index|[
name|targ_lun
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_DISABLED
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|softc
operator|->
name|ha_mode
operator|==
name|CTL_HA_MODE_XFER
condition|)
block|{
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|io
argument_list|,
argument|&lun->ooa_queue
argument_list|,
argument|ooa_links
argument_list|,
argument|next_io
argument_list|)
block|{
comment|/* We are master */
if|if
condition|(
name|io
operator|->
name|flags
operator|&
name|CTL_FLAG_FROM_OTHER_SC
condition|)
block|{
if|if
condition|(
name|io
operator|->
name|flags
operator|&
name|CTL_FLAG_IO_ACTIVE
condition|)
block|{
name|io
operator|->
name|flags
operator||=
name|CTL_FLAG_ABORT
expr_stmt|;
name|io
operator|->
name|flags
operator||=
name|CTL_FLAG_FAILOVER
expr_stmt|;
block|}
else|else
block|{
comment|/* This can be only due to DATAMOVE */
name|io
operator|->
name|msg_type
operator|=
name|CTL_MSG_DATAMOVE_DONE
expr_stmt|;
name|io
operator|->
name|flags
operator|&=
operator|~
name|CTL_FLAG_DMA_INPROG
expr_stmt|;
name|io
operator|->
name|flags
operator||=
name|CTL_FLAG_IO_ACTIVE
expr_stmt|;
name|io
operator|->
name|port_status
operator|=
literal|31340
expr_stmt|;
name|ctl_enqueue_isc
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|io
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* We are slave */
if|if
condition|(
name|io
operator|->
name|flags
operator|&
name|CTL_FLAG_SENT_2OTHER_SC
condition|)
block|{
name|io
operator|->
name|flags
operator|&=
operator|~
name|CTL_FLAG_SENT_2OTHER_SC
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|flags
operator|&
name|CTL_FLAG_IO_ACTIVE
condition|)
block|{
name|io
operator|->
name|flags
operator||=
name|CTL_FLAG_FAILOVER
expr_stmt|;
block|}
else|else
block|{
name|ctl_set_busy
argument_list|(
operator|&
operator|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|io
operator|)
operator|->
name|scsiio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|io
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* SERIALIZE modes */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|io
argument_list|,
argument|&lun->blocked_queue
argument_list|,
argument|blocked_links
argument_list|,
argument|next_io
argument_list|)
block|{
comment|/* We are master */
if|if
condition|(
name|io
operator|->
name|flags
operator|&
name|CTL_FLAG_FROM_OTHER_SC
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|lun
operator|->
name|blocked_queue
argument_list|,
name|io
argument_list|,
name|blocked_links
argument_list|)
expr_stmt|;
name|io
operator|->
name|flags
operator|&=
operator|~
name|CTL_FLAG_BLOCKED
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|lun
operator|->
name|ooa_queue
argument_list|,
name|io
argument_list|,
name|ooa_links
argument_list|)
expr_stmt|;
name|ctl_free_io
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|io
argument_list|)
expr_stmt|;
block|}
block|}
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|io
argument_list|,
argument|&lun->ooa_queue
argument_list|,
argument|ooa_links
argument_list|,
argument|next_io
argument_list|)
block|{
comment|/* We are master */
if|if
condition|(
name|io
operator|->
name|flags
operator|&
name|CTL_FLAG_FROM_OTHER_SC
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|lun
operator|->
name|ooa_queue
argument_list|,
name|io
argument_list|,
name|ooa_links
argument_list|)
expr_stmt|;
name|ctl_free_io
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|io
argument_list|)
expr_stmt|;
block|}
comment|/* We are slave */
if|if
condition|(
name|io
operator|->
name|flags
operator|&
name|CTL_FLAG_SENT_2OTHER_SC
condition|)
block|{
name|io
operator|->
name|flags
operator|&=
operator|~
name|CTL_FLAG_SENT_2OTHER_SC
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|io
operator|->
name|flags
operator|&
name|CTL_FLAG_IO_ACTIVE
operator|)
condition|)
block|{
name|ctl_set_busy
argument_list|(
operator|&
operator|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|io
operator|)
operator|->
name|scsiio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|io
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|ctl_check_blocked
argument_list|(
name|lun
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_scsiio_precheck
parameter_list|(
name|struct
name|ctl_softc
modifier|*
name|softc
parameter_list|,
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
specifier|const
name|struct
name|ctl_cmd_entry
modifier|*
name|entry
decl_stmt|;
name|uint32_t
name|initidx
decl_stmt|,
name|targ_lun
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|lun
operator|=
name|NULL
expr_stmt|;
name|targ_lun
operator|=
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_mapped_lun
expr_stmt|;
if|if
condition|(
name|targ_lun
operator|<
name|CTL_MAX_LUNS
condition|)
name|lun
operator|=
name|softc
operator|->
name|ctl_luns
index|[
name|targ_lun
index|]
expr_stmt|;
if|if
condition|(
name|lun
condition|)
block|{
comment|/* 		 * If the LUN is invalid, pretend that it doesn't exist. 		 * It will go away as soon as all pending I/O has been 		 * completed. 		 */
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_DISABLED
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|lun
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|CTL_LUN
argument_list|(
name|ctsio
argument_list|)
operator|=
name|lun
expr_stmt|;
if|if
condition|(
name|lun
condition|)
block|{
name|CTL_BACKEND_LUN
argument_list|(
name|ctsio
argument_list|)
operator|=
name|lun
operator|->
name|be_lun
expr_stmt|;
comment|/* 		 * Every I/O goes into the OOA queue for a particular LUN, 		 * and stays there until completion. 		 */
ifdef|#
directive|ifdef
name|CTL_TIME_IO
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|lun
operator|->
name|ooa_queue
argument_list|)
condition|)
name|lun
operator|->
name|idle_time
operator|+=
name|getsbinuptime
argument_list|()
operator|-
name|lun
operator|->
name|last_busy
expr_stmt|;
endif|#
directive|endif
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|lun
operator|->
name|ooa_queue
argument_list|,
operator|&
name|ctsio
operator|->
name|io_hdr
argument_list|,
name|ooa_links
argument_list|)
expr_stmt|;
block|}
comment|/* Get command entry and return error if it is unsuppotyed. */
name|entry
operator|=
name|ctl_validate_command
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|lun
condition|)
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator|&=
operator|~
name|CTL_FLAG_DATA_MASK
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|entry
operator|->
name|flags
operator|&
name|CTL_FLAG_DATA_MASK
expr_stmt|;
comment|/* 	 * Check to see whether we can send this command to LUNs that don't 	 * exist.  This should pretty much only be the case for inquiry 	 * and request sense.  Further checks, below, really require having 	 * a LUN, so we can't really check the command anymore.  Just put 	 * it on the rtr queue. 	 */
if|if
condition|(
name|lun
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|flags
operator|&
name|CTL_CMD_FLAG_OK_ON_NO_LUN
condition|)
block|{
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_IS_WAS_ON_RTR
expr_stmt|;
name|ctl_enqueue_rtr
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
name|ctl_set_unsupported_lun
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_scsiio_precheck: bailing out due to invalid LUN\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
else|else
block|{
comment|/* 		 * Make sure we support this particular command on this LUN. 		 * e.g., we don't support writes to the control LUN. 		 */
if|if
condition|(
operator|!
name|ctl_cmd_applicable
argument_list|(
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
argument_list|,
name|entry
argument_list|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctl_set_invalid_opcode
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
block|}
name|initidx
operator|=
name|ctl_get_initindex
argument_list|(
operator|&
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
argument_list|)
expr_stmt|;
comment|/* 	 * If we've got a request sense, it'll clear the contingent 	 * allegiance condition.  Otherwise, if we have a CA condition for 	 * this initiator, clear it, because it sent down a command other 	 * than request sense. 	 */
if|if
condition|(
name|ctsio
operator|->
name|cdb
index|[
literal|0
index|]
operator|!=
name|REQUEST_SENSE
condition|)
block|{
name|struct
name|scsi_sense_data
modifier|*
name|ps
decl_stmt|;
name|ps
operator|=
name|lun
operator|->
name|pending_sense
index|[
name|initidx
operator|/
name|CTL_MAX_INIT_PER_PORT
index|]
expr_stmt|;
if|if
condition|(
name|ps
operator|!=
name|NULL
condition|)
name|ps
index|[
name|initidx
operator|%
name|CTL_MAX_INIT_PER_PORT
index|]
operator|.
name|error_code
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * If the command has this flag set, it handles its own unit 	 * attention reporting, we shouldn't do anything.  Otherwise we 	 * check for any pending unit attentions, and send them back to the 	 * initiator.  We only do this when a command initially comes in, 	 * not when we pull it off the blocked queue. 	 * 	 * According to SAM-3, section 5.3.2, the order that things get 	 * presented back to the host is basically unit attentions caused 	 * by some sort of reset event, busy status, reservation conflicts 	 * or task set full, and finally any other status. 	 * 	 * One issue here is that some of the unit attentions we report 	 * don't fall into the "reset" category (e.g. "reported luns data 	 * has changed").  So reporting it here, before the reservation 	 * check, may be technically wrong.  I guess the only thing to do 	 * would be to check for and report the reset events here, and then 	 * check for the other unit attention types after we check for a 	 * reservation conflict. 	 * 	 * XXX KDM need to fix this 	 */
if|if
condition|(
operator|(
name|entry
operator|->
name|flags
operator|&
name|CTL_CMD_FLAG_NO_SENSE
operator|)
operator|==
literal|0
condition|)
block|{
name|ctl_ua_type
name|ua_type
decl_stmt|;
name|u_int
name|sense_len
init|=
literal|0
decl_stmt|;
name|ua_type
operator|=
name|ctl_build_ua
argument_list|(
name|lun
argument_list|,
name|initidx
argument_list|,
operator|&
name|ctsio
operator|->
name|sense_data
argument_list|,
operator|&
name|sense_len
argument_list|,
name|SSD_TYPE_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ua_type
operator|!=
name|CTL_UA_NONE
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|scsi_status
operator|=
name|SCSI_STATUS_CHECK_COND
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|status
operator|=
name|CTL_SCSI_ERROR
operator||
name|CTL_AUTOSENSE
expr_stmt|;
name|ctsio
operator|->
name|sense_len
operator|=
name|sense_len
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
block|}
if|if
condition|(
name|ctl_scsiio_lun_check
argument_list|(
name|lun
argument_list|,
name|entry
argument_list|,
name|ctsio
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
comment|/* 	 * XXX CHD this is where we want to send IO to other side if 	 * this LUN is secondary on this SC. We will need to make a copy 	 * of the IO and flag the IO on this side as SENT_2OTHER and the flag 	 * the copy we send as FROM_OTHER. 	 * We also need to stuff the address of the original IO so we can 	 * find it easily. Something similar will need be done on the other 	 * side so when we are done we can find the copy. 	 */
if|if
condition|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_PRIMARY_SC
operator|)
operator|==
literal|0
operator|&&
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_PEER_SC_PRIMARY
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|entry
operator|->
name|flags
operator|&
name|CTL_CMD_FLAG_RUN_HERE
operator|)
operator|==
literal|0
condition|)
block|{
name|union
name|ctl_ha_msg
name|msg_info
decl_stmt|;
name|int
name|isc_retval
decl_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_SENT_2OTHER_SC
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator|&=
operator|~
name|CTL_FLAG_IO_ACTIVE
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_SERIALIZE
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|original_sc
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|serializing_sc
operator|=
name|NULL
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|nexus
operator|=
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
expr_stmt|;
name|msg_info
operator|.
name|scsi
operator|.
name|tag_num
operator|=
name|ctsio
operator|->
name|tag_num
expr_stmt|;
name|msg_info
operator|.
name|scsi
operator|.
name|tag_type
operator|=
name|ctsio
operator|->
name|tag_type
expr_stmt|;
name|msg_info
operator|.
name|scsi
operator|.
name|cdb_len
operator|=
name|ctsio
operator|->
name|cdb_len
expr_stmt|;
name|memcpy
argument_list|(
name|msg_info
operator|.
name|scsi
operator|.
name|cdb
argument_list|,
name|ctsio
operator|->
name|cdb
argument_list|,
name|CTL_MAX_CDBLEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|isc_retval
operator|=
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|msg_info
argument_list|,
sizeof|sizeof
argument_list|(
name|msg_info
operator|.
name|scsi
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|msg_info
operator|.
name|scsi
operator|.
name|sense_data
argument_list|)
argument_list|,
name|M_WAITOK
argument_list|)
operator|)
operator|>
name|CTL_HA_STATUS_SUCCESS
condition|)
block|{
name|ctl_set_busy
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
switch|switch
condition|(
name|ctl_check_ooa
argument_list|(
name|lun
argument_list|,
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|,
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|TAILQ_PREV
argument_list|(
operator|&
name|ctsio
operator|->
name|io_hdr
argument_list|,
name|ctl_ooaq
argument_list|,
name|ooa_links
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|CTL_ACTION_BLOCK
case|:
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_BLOCKED
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|lun
operator|->
name|blocked_queue
argument_list|,
operator|&
name|ctsio
operator|->
name|io_hdr
argument_list|,
name|blocked_links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
case|case
name|CTL_ACTION_PASS
case|:
case|case
name|CTL_ACTION_SKIP
case|:
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_IS_WAS_ON_RTR
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctl_enqueue_rtr
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_ACTION_OVERLAP
case|:
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctl_set_overlapped_cmd
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_ACTION_OVERLAP_TAG
case|:
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctl_set_overlapped_tag
argument_list|(
name|ctsio
argument_list|,
name|ctsio
operator|->
name|tag_num
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_ACTION_ERROR
case|:
default|default:
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctl_set_internal_failure
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|0
argument_list|,
comment|/*retry_count*/
literal|0
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|struct
name|ctl_cmd_entry
modifier|*
name|ctl_get_cmd_entry
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|int
modifier|*
name|sa
parameter_list|)
block|{
specifier|const
name|struct
name|ctl_cmd_entry
modifier|*
name|entry
decl_stmt|;
name|int
name|service_action
decl_stmt|;
name|entry
operator|=
operator|&
name|ctl_cmd_table
index|[
name|ctsio
operator|->
name|cdb
index|[
literal|0
index|]
index|]
expr_stmt|;
if|if
condition|(
name|sa
condition|)
operator|*
name|sa
operator|=
operator|(
operator|(
name|entry
operator|->
name|flags
operator|&
name|CTL_CMD_FLAG_SA5
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|flags
operator|&
name|CTL_CMD_FLAG_SA5
condition|)
block|{
name|service_action
operator|=
name|ctsio
operator|->
name|cdb
index|[
literal|1
index|]
operator|&
name|SERVICE_ACTION_MASK
expr_stmt|;
name|entry
operator|=
operator|&
operator|(
operator|(
specifier|const
expr|struct
name|ctl_cmd_entry
operator|*
operator|)
name|entry
operator|->
name|execute
operator|)
index|[
name|service_action
index|]
expr_stmt|;
block|}
return|return
operator|(
name|entry
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|struct
name|ctl_cmd_entry
modifier|*
name|ctl_validate_command
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
specifier|const
name|struct
name|ctl_cmd_entry
modifier|*
name|entry
decl_stmt|;
name|int
name|i
decl_stmt|,
name|sa
decl_stmt|;
name|uint8_t
name|diff
decl_stmt|;
name|entry
operator|=
name|ctl_get_cmd_entry
argument_list|(
name|ctsio
argument_list|,
operator|&
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|execute
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|sa
condition|)
name|ctl_set_invalid_field
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|1
argument_list|,
comment|/*bit_valid*/
literal|1
argument_list|,
comment|/*bit*/
literal|4
argument_list|)
expr_stmt|;
else|else
name|ctl_set_invalid_opcode
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|KASSERT
argument_list|(
name|entry
operator|->
name|length
operator|>
literal|0
argument_list|,
operator|(
literal|"Not defined length for command 0x%02x/0x%02x"
operator|,
name|ctsio
operator|->
name|cdb
index|[
literal|0
index|]
operator|,
name|ctsio
operator|->
name|cdb
index|[
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|entry
operator|->
name|length
condition|;
name|i
operator|++
control|)
block|{
name|diff
operator|=
name|ctsio
operator|->
name|cdb
index|[
name|i
index|]
operator|&
operator|~
name|entry
operator|->
name|usage
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|diff
operator|==
literal|0
condition|)
continue|continue;
name|ctl_set_invalid_field
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
name|i
argument_list|,
comment|/*bit_valid*/
literal|1
argument_list|,
comment|/*bit*/
name|fls
argument_list|(
name|diff
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|entry
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_cmd_applicable
parameter_list|(
name|uint8_t
name|lun_type
parameter_list|,
specifier|const
name|struct
name|ctl_cmd_entry
modifier|*
name|entry
parameter_list|)
block|{
switch|switch
condition|(
name|lun_type
condition|)
block|{
case|case
name|T_DIRECT
case|:
if|if
condition|(
operator|(
name|entry
operator|->
name|flags
operator|&
name|CTL_CMD_FLAG_OK_ON_DIRECT
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|T_PROCESSOR
case|:
if|if
condition|(
operator|(
name|entry
operator|->
name|flags
operator|&
name|CTL_CMD_FLAG_OK_ON_PROC
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|T_CDROM
case|:
if|if
condition|(
operator|(
name|entry
operator|->
name|flags
operator|&
name|CTL_CMD_FLAG_OK_ON_CDROM
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_scsiio
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
specifier|const
name|struct
name|ctl_cmd_entry
modifier|*
name|entry
decl_stmt|;
name|retval
operator|=
name|CTL_RETVAL_COMPLETE
expr_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_scsiio cdb[0]=%02X\n"
operator|,
name|ctsio
operator|->
name|cdb
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
name|entry
operator|=
name|ctl_get_cmd_entry
argument_list|(
name|ctsio
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * If this I/O has been aborted, just send it straight to 	 * ctl_done() without executing it. 	 */
if|if
condition|(
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ABORT
condition|)
block|{
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
comment|/* 	 * All the checks should have been handled by ctl_scsiio_precheck(). 	 * We should be clear now to just execute the I/O. 	 */
name|retval
operator|=
name|entry
operator|->
name|execute
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|bailout
label|:
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_target_reset
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|CTL_SOFTC
argument_list|(
name|io
argument_list|)
decl_stmt|;
name|struct
name|ctl_port
modifier|*
name|port
init|=
name|CTL_PORT
argument_list|(
name|io
argument_list|)
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|uint32_t
name|initidx
decl_stmt|;
name|ctl_ua_type
name|ua_type
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_FROM_OTHER_SC
operator|)
condition|)
block|{
name|union
name|ctl_ha_msg
name|msg_info
decl_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|nexus
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|nexus
expr_stmt|;
name|msg_info
operator|.
name|task
operator|.
name|task_action
operator|=
name|io
operator|->
name|taskio
operator|.
name|task_action
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_MANAGE_TASKS
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|original_sc
operator|=
name|NULL
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|serializing_sc
operator|=
name|NULL
expr_stmt|;
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|msg_info
argument_list|,
sizeof|sizeof
argument_list|(
name|msg_info
operator|.
name|task
argument_list|)
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
name|initidx
operator|=
name|ctl_get_initindex
argument_list|(
operator|&
name|io
operator|->
name|io_hdr
operator|.
name|nexus
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|taskio
operator|.
name|task_action
operator|==
name|CTL_TASK_TARGET_RESET
condition|)
name|ua_type
operator|=
name|CTL_UA_TARG_RESET
expr_stmt|;
else|else
name|ua_type
operator|=
name|CTL_UA_BUS_RESET
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|lun
argument_list|,
argument|&softc->lun_list
argument_list|,
argument|links
argument_list|)
block|{
if|if
condition|(
name|port
operator|!=
name|NULL
operator|&&
name|ctl_lun_map_to_port
argument_list|(
name|port
argument_list|,
name|lun
operator|->
name|lun
argument_list|)
operator|==
name|UINT32_MAX
condition|)
continue|continue;
name|ctl_do_lun_reset
argument_list|(
name|lun
argument_list|,
name|initidx
argument_list|,
name|ua_type
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|io
operator|->
name|taskio
operator|.
name|task_status
operator|=
name|CTL_TASK_FUNCTION_COMPLETE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The LUN should always be set.  The I/O is optional, and is used to  * distinguish between I/Os sent by this initiator, and by other  * initiators.  We set unit attention for initiators other than this one.  * SAM-3 is vague on this point.  It does say that a unit attention should  * be established for other initiators when a LUN is reset (see section  * 5.7.3), but it doesn't specifically say that the unit attention should  * be established for this particular initiator when a LUN is reset.  Here  * is the relevant text, from SAM-3 rev 8:  *  * 5.7.2 When a SCSI initiator port aborts its own tasks  *  * When a SCSI initiator port causes its own task(s) to be aborted, no  * notification that the task(s) have been aborted shall be returned to  * the SCSI initiator port other than the completion response for the  * command or task management function action that caused the task(s) to  * be aborted and notification(s) associated with related effects of the  * action (e.g., a reset unit attention condition).  *  * XXX KDM for now, we're setting unit attention for all initiators.  */
end_comment

begin_function
specifier|static
name|void
name|ctl_do_lun_reset
parameter_list|(
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|,
name|uint32_t
name|initidx
parameter_list|,
name|ctl_ua_type
name|ua_type
parameter_list|)
block|{
name|union
name|ctl_io
modifier|*
name|xio
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
comment|/* Abort tasks. */
for|for
control|(
name|xio
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|TAILQ_FIRST
argument_list|(
operator|&
name|lun
operator|->
name|ooa_queue
argument_list|)
init|;
name|xio
operator|!=
name|NULL
condition|;
name|xio
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|TAILQ_NEXT
argument_list|(
operator|&
name|xio
operator|->
name|io_hdr
argument_list|,
name|ooa_links
argument_list|)
control|)
block|{
name|xio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ABORT
operator||
name|CTL_FLAG_ABORT_STATUS
expr_stmt|;
block|}
comment|/* Clear CA. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_MAX_PORTS
condition|;
name|i
operator|++
control|)
block|{
name|free
argument_list|(
name|lun
operator|->
name|pending_sense
index|[
name|i
index|]
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|lun
operator|->
name|pending_sense
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Clear reservation. */
name|lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_LUN_RESERVED
expr_stmt|;
comment|/* Clear prevent media removal. */
if|if
condition|(
name|lun
operator|->
name|prevent
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_MAX_INITIATORS
condition|;
name|i
operator|++
control|)
name|ctl_clear_mask
argument_list|(
name|lun
operator|->
name|prevent
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|lun
operator|->
name|prevent_count
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Clear TPC status */
name|ctl_tpc_lun_clear
argument_list|(
name|lun
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Establish UA. */
if|#
directive|if
literal|0
block|ctl_est_ua_all(lun, initidx, ua_type);
else|#
directive|else
name|ctl_est_ua_all
argument_list|(
name|lun
argument_list|,
operator|-
literal|1
argument_list|,
name|ua_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_lun_reset
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|CTL_SOFTC
argument_list|(
name|io
argument_list|)
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|uint32_t
name|targ_lun
decl_stmt|,
name|initidx
decl_stmt|;
name|targ_lun
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_mapped_lun
expr_stmt|;
name|initidx
operator|=
name|ctl_get_initindex
argument_list|(
operator|&
name|io
operator|->
name|io_hdr
operator|.
name|nexus
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|targ_lun
operator|>=
name|CTL_MAX_LUNS
operator|||
operator|(
name|lun
operator|=
name|softc
operator|->
name|ctl_luns
index|[
name|targ_lun
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|io
operator|->
name|taskio
operator|.
name|task_status
operator|=
name|CTL_TASK_LUN_DOES_NOT_EXIST
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|ctl_do_lun_reset
argument_list|(
name|lun
argument_list|,
name|initidx
argument_list|,
name|CTL_UA_LUN_RESET
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|io
operator|->
name|taskio
operator|.
name|task_status
operator|=
name|CTL_TASK_FUNCTION_COMPLETE
expr_stmt|;
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_FROM_OTHER_SC
operator|)
operator|==
literal|0
condition|)
block|{
name|union
name|ctl_ha_msg
name|msg_info
decl_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_MANAGE_TASKS
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|nexus
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|nexus
expr_stmt|;
name|msg_info
operator|.
name|task
operator|.
name|task_action
operator|=
name|CTL_TASK_LUN_RESET
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|original_sc
operator|=
name|NULL
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|serializing_sc
operator|=
name|NULL
expr_stmt|;
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|msg_info
argument_list|,
sizeof|sizeof
argument_list|(
name|msg_info
operator|.
name|task
argument_list|)
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_abort_tasks_lun
parameter_list|(
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|,
name|uint32_t
name|targ_port
parameter_list|,
name|uint32_t
name|init_id
parameter_list|,
name|int
name|other_sc
parameter_list|)
block|{
name|union
name|ctl_io
modifier|*
name|xio
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * Run through the OOA queue and attempt to find the given I/O. 	 * The target port, initiator ID, tag type and tag number have to 	 * match the values that we got from the initiator.  If we have an 	 * untagged command to abort, simply abort the first untagged command 	 * we come to.  We only allow one untagged command at a time of course. 	 */
for|for
control|(
name|xio
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|TAILQ_FIRST
argument_list|(
operator|&
name|lun
operator|->
name|ooa_queue
argument_list|)
init|;
name|xio
operator|!=
name|NULL
condition|;
name|xio
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|TAILQ_NEXT
argument_list|(
operator|&
name|xio
operator|->
name|io_hdr
argument_list|,
name|ooa_links
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|targ_port
operator|==
name|UINT32_MAX
operator|||
name|targ_port
operator|==
name|xio
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
operator|)
operator|&&
operator|(
name|init_id
operator|==
name|UINT32_MAX
operator|||
name|init_id
operator|==
name|xio
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|initid
operator|)
condition|)
block|{
if|if
condition|(
name|targ_port
operator|!=
name|xio
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
operator|||
name|init_id
operator|!=
name|xio
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|initid
condition|)
name|xio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ABORT_STATUS
expr_stmt|;
name|xio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ABORT
expr_stmt|;
if|if
condition|(
operator|!
name|other_sc
operator|&&
operator|!
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_PRIMARY_SC
operator|)
condition|)
block|{
name|union
name|ctl_ha_msg
name|msg_info
decl_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|nexus
operator|=
name|xio
operator|->
name|io_hdr
operator|.
name|nexus
expr_stmt|;
name|msg_info
operator|.
name|task
operator|.
name|task_action
operator|=
name|CTL_TASK_ABORT_TASK
expr_stmt|;
name|msg_info
operator|.
name|task
operator|.
name|tag_num
operator|=
name|xio
operator|->
name|scsiio
operator|.
name|tag_num
expr_stmt|;
name|msg_info
operator|.
name|task
operator|.
name|tag_type
operator|=
name|xio
operator|->
name|scsiio
operator|.
name|tag_type
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_MANAGE_TASKS
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|original_sc
operator|=
name|NULL
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|serializing_sc
operator|=
name|NULL
expr_stmt|;
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|msg_info
argument_list|,
sizeof|sizeof
argument_list|(
name|msg_info
operator|.
name|task
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_abort_task_set
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|CTL_SOFTC
argument_list|(
name|io
argument_list|)
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|uint32_t
name|targ_lun
decl_stmt|;
comment|/* 	 * Look up the LUN. 	 */
name|targ_lun
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_mapped_lun
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|targ_lun
operator|>=
name|CTL_MAX_LUNS
operator|||
operator|(
name|lun
operator|=
name|softc
operator|->
name|ctl_luns
index|[
name|targ_lun
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|io
operator|->
name|taskio
operator|.
name|task_status
operator|=
name|CTL_TASK_LUN_DOES_NOT_EXIST
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|taskio
operator|.
name|task_action
operator|==
name|CTL_TASK_ABORT_TASK_SET
condition|)
block|{
name|ctl_abort_tasks_lun
argument_list|(
name|lun
argument_list|,
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
argument_list|,
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|initid
argument_list|,
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_FROM_OTHER_SC
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* CTL_TASK_CLEAR_TASK_SET */
name|ctl_abort_tasks_lun
argument_list|(
name|lun
argument_list|,
name|UINT32_MAX
argument_list|,
name|UINT32_MAX
argument_list|,
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_FROM_OTHER_SC
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|io
operator|->
name|taskio
operator|.
name|task_status
operator|=
name|CTL_TASK_FUNCTION_COMPLETE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_i_t_nexus_loss
parameter_list|(
name|struct
name|ctl_softc
modifier|*
name|softc
parameter_list|,
name|uint32_t
name|initidx
parameter_list|,
name|ctl_ua_type
name|ua_type
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|struct
name|scsi_sense_data
modifier|*
name|ps
decl_stmt|;
name|uint32_t
name|p
decl_stmt|,
name|i
decl_stmt|;
name|p
operator|=
name|initidx
operator|/
name|CTL_MAX_INIT_PER_PORT
expr_stmt|;
name|i
operator|=
name|initidx
operator|%
name|CTL_MAX_INIT_PER_PORT
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|lun
argument_list|,
argument|&softc->lun_list
argument_list|,
argument|links
argument_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
comment|/* Abort tasks. */
name|ctl_abort_tasks_lun
argument_list|(
name|lun
argument_list|,
name|p
argument_list|,
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Clear CA. */
name|ps
operator|=
name|lun
operator|->
name|pending_sense
index|[
name|p
index|]
expr_stmt|;
if|if
condition|(
name|ps
operator|!=
name|NULL
condition|)
name|ps
index|[
name|i
index|]
operator|.
name|error_code
operator|=
literal|0
expr_stmt|;
comment|/* Clear reservation. */
if|if
condition|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_RESERVED
operator|)
operator|&&
operator|(
name|lun
operator|->
name|res_idx
operator|==
name|initidx
operator|)
condition|)
name|lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_LUN_RESERVED
expr_stmt|;
comment|/* Clear prevent media removal. */
if|if
condition|(
name|lun
operator|->
name|prevent
operator|&&
name|ctl_is_set
argument_list|(
name|lun
operator|->
name|prevent
argument_list|,
name|initidx
argument_list|)
condition|)
block|{
name|ctl_clear_mask
argument_list|(
name|lun
operator|->
name|prevent
argument_list|,
name|initidx
argument_list|)
expr_stmt|;
name|lun
operator|->
name|prevent_count
operator|--
expr_stmt|;
block|}
comment|/* Clear TPC status */
name|ctl_tpc_lun_clear
argument_list|(
name|lun
argument_list|,
name|initidx
argument_list|)
expr_stmt|;
comment|/* Establish UA. */
name|ctl_est_ua
argument_list|(
name|lun
argument_list|,
name|initidx
argument_list|,
name|ua_type
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_i_t_nexus_reset
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|CTL_SOFTC
argument_list|(
name|io
argument_list|)
decl_stmt|;
name|uint32_t
name|initidx
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_FROM_OTHER_SC
operator|)
condition|)
block|{
name|union
name|ctl_ha_msg
name|msg_info
decl_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|nexus
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|nexus
expr_stmt|;
name|msg_info
operator|.
name|task
operator|.
name|task_action
operator|=
name|CTL_TASK_I_T_NEXUS_RESET
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_MANAGE_TASKS
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|original_sc
operator|=
name|NULL
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|serializing_sc
operator|=
name|NULL
expr_stmt|;
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|msg_info
argument_list|,
sizeof|sizeof
argument_list|(
name|msg_info
operator|.
name|task
argument_list|)
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
name|initidx
operator|=
name|ctl_get_initindex
argument_list|(
operator|&
name|io
operator|->
name|io_hdr
operator|.
name|nexus
argument_list|)
expr_stmt|;
name|ctl_i_t_nexus_loss
argument_list|(
name|softc
argument_list|,
name|initidx
argument_list|,
name|CTL_UA_I_T_NEXUS_LOSS
argument_list|)
expr_stmt|;
name|io
operator|->
name|taskio
operator|.
name|task_status
operator|=
name|CTL_TASK_FUNCTION_COMPLETE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_abort_task
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|CTL_SOFTC
argument_list|(
name|io
argument_list|)
decl_stmt|;
name|union
name|ctl_io
modifier|*
name|xio
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
if|#
directive|if
literal|0
block|struct sbuf sb; 	char printbuf[128];
endif|#
directive|endif
name|int
name|found
decl_stmt|;
name|uint32_t
name|targ_lun
decl_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Look up the LUN. 	 */
name|targ_lun
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_mapped_lun
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|targ_lun
operator|>=
name|CTL_MAX_LUNS
operator|||
operator|(
name|lun
operator|=
name|softc
operator|->
name|ctl_luns
index|[
name|targ_lun
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|io
operator|->
name|taskio
operator|.
name|task_status
operator|=
name|CTL_TASK_LUN_DOES_NOT_EXIST
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|#
directive|if
literal|0
block|printf("ctl_abort_task: called for lun %lld, tag %d type %d\n", 	       lun->lun, io->taskio.tag_num, io->taskio.tag_type);
endif|#
directive|endif
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Run through the OOA queue and attempt to find the given I/O. 	 * The target port, initiator ID, tag type and tag number have to 	 * match the values that we got from the initiator.  If we have an 	 * untagged command to abort, simply abort the first untagged command 	 * we come to.  We only allow one untagged command at a time of course. 	 */
for|for
control|(
name|xio
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|TAILQ_FIRST
argument_list|(
operator|&
name|lun
operator|->
name|ooa_queue
argument_list|)
init|;
name|xio
operator|!=
name|NULL
condition|;
name|xio
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|TAILQ_NEXT
argument_list|(
operator|&
name|xio
operator|->
name|io_hdr
argument_list|,
name|ooa_links
argument_list|)
control|)
block|{
if|#
directive|if
literal|0
block|sbuf_new(&sb, printbuf, sizeof(printbuf), SBUF_FIXEDLEN);  		sbuf_printf(&sb, "LUN %lld tag %d type %d%s%s%s%s: ", 			    lun->lun, xio->scsiio.tag_num, 			    xio->scsiio.tag_type, 			    (xio->io_hdr.blocked_links.tqe_prev 			    == NULL) ? "" : " BLOCKED", 			    (xio->io_hdr.flags& 			    CTL_FLAG_DMA_INPROG) ? " DMA" : "", 			    (xio->io_hdr.flags& 			    CTL_FLAG_ABORT) ? " ABORT" : "", 			    (xio->io_hdr.flags& 			    CTL_FLAG_IS_WAS_ON_RTR ? " RTR" : "")); 		ctl_scsi_command_string(&xio->scsiio, NULL,&sb); 		sbuf_finish(&sb); 		printf("%s\n", sbuf_data(&sb));
endif|#
directive|endif
if|if
condition|(
operator|(
name|xio
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
operator|!=
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
operator|)
operator|||
operator|(
name|xio
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|initid
operator|!=
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|initid
operator|)
operator|||
operator|(
name|xio
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ABORT
operator|)
condition|)
continue|continue;
comment|/* 		 * If the abort says that the task is untagged, the 		 * task in the queue must be untagged.  Otherwise, 		 * we just check to see whether the tag numbers 		 * match.  This is because the QLogic firmware 		 * doesn't pass back the tag type in an abort 		 * request. 		 */
if|#
directive|if
literal|0
block|if (((xio->scsiio.tag_type == CTL_TAG_UNTAGGED)&& (io->taskio.tag_type == CTL_TAG_UNTAGGED)) 		 || (xio->scsiio.tag_num == io->taskio.tag_num))
endif|#
directive|endif
comment|/* 		 * XXX KDM we've got problems with FC, because it 		 * doesn't send down a tag type with aborts.  So we 		 * can only really go by the tag number... 		 * This may cause problems with parallel SCSI. 		 * Need to figure that out!! 		 */
if|if
condition|(
name|xio
operator|->
name|scsiio
operator|.
name|tag_num
operator|==
name|io
operator|->
name|taskio
operator|.
name|tag_num
condition|)
block|{
name|xio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ABORT
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_FROM_OTHER_SC
operator|)
operator|==
literal|0
operator|&&
operator|!
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_PRIMARY_SC
operator|)
condition|)
block|{
name|union
name|ctl_ha_msg
name|msg_info
decl_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|nexus
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|nexus
expr_stmt|;
name|msg_info
operator|.
name|task
operator|.
name|task_action
operator|=
name|CTL_TASK_ABORT_TASK
expr_stmt|;
name|msg_info
operator|.
name|task
operator|.
name|tag_num
operator|=
name|io
operator|->
name|taskio
operator|.
name|tag_num
expr_stmt|;
name|msg_info
operator|.
name|task
operator|.
name|tag_type
operator|=
name|io
operator|->
name|taskio
operator|.
name|tag_type
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_MANAGE_TASKS
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|original_sc
operator|=
name|NULL
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|serializing_sc
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
literal|0
block|printf("Sent Abort to other side\n");
endif|#
directive|endif
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|msg_info
argument_list|,
sizeof|sizeof
argument_list|(
name|msg_info
operator|.
name|task
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|printf("ctl_abort_task: found I/O to abort\n");
endif|#
directive|endif
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|==
literal|0
condition|)
block|{
comment|/* 		 * This isn't really an error.  It's entirely possible for 		 * the abort and command completion to cross on the wire. 		 * This is more of an informative/diagnostic error. 		 */
if|#
directive|if
literal|0
block|printf("ctl_abort_task: ABORT sent for nonexistent I/O: " 		       "%u:%u:%u tag %d type %d\n", 		       io->io_hdr.nexus.initid, 		       io->io_hdr.nexus.targ_port, 		       io->io_hdr.nexus.targ_lun, io->taskio.tag_num, 		       io->taskio.tag_type);
endif|#
directive|endif
block|}
name|io
operator|->
name|taskio
operator|.
name|task_status
operator|=
name|CTL_TASK_FUNCTION_COMPLETE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_query_task
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|,
name|int
name|task_set
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|CTL_SOFTC
argument_list|(
name|io
argument_list|)
decl_stmt|;
name|union
name|ctl_io
modifier|*
name|xio
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
name|uint32_t
name|targ_lun
decl_stmt|;
name|targ_lun
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_mapped_lun
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|targ_lun
operator|>=
name|CTL_MAX_LUNS
operator|||
operator|(
name|lun
operator|=
name|softc
operator|->
name|ctl_luns
index|[
name|targ_lun
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|io
operator|->
name|taskio
operator|.
name|task_status
operator|=
name|CTL_TASK_LUN_DOES_NOT_EXIST
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|xio
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|TAILQ_FIRST
argument_list|(
operator|&
name|lun
operator|->
name|ooa_queue
argument_list|)
init|;
name|xio
operator|!=
name|NULL
condition|;
name|xio
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|TAILQ_NEXT
argument_list|(
operator|&
name|xio
operator|->
name|io_hdr
argument_list|,
name|ooa_links
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|xio
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
operator|!=
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
operator|)
operator|||
operator|(
name|xio
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|initid
operator|!=
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|initid
operator|)
operator|||
operator|(
name|xio
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ABORT
operator|)
condition|)
continue|continue;
if|if
condition|(
name|task_set
operator|||
name|xio
operator|->
name|scsiio
operator|.
name|tag_num
operator|==
name|io
operator|->
name|taskio
operator|.
name|tag_num
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
condition|)
name|io
operator|->
name|taskio
operator|.
name|task_status
operator|=
name|CTL_TASK_FUNCTION_SUCCEEDED
expr_stmt|;
else|else
name|io
operator|->
name|taskio
operator|.
name|task_status
operator|=
name|CTL_TASK_FUNCTION_COMPLETE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_query_async_event
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|CTL_SOFTC
argument_list|(
name|io
argument_list|)
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|ctl_ua_type
name|ua
decl_stmt|;
name|uint32_t
name|targ_lun
decl_stmt|,
name|initidx
decl_stmt|;
name|targ_lun
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_mapped_lun
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|targ_lun
operator|>=
name|CTL_MAX_LUNS
operator|||
operator|(
name|lun
operator|=
name|softc
operator|->
name|ctl_luns
index|[
name|targ_lun
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|io
operator|->
name|taskio
operator|.
name|task_status
operator|=
name|CTL_TASK_LUN_DOES_NOT_EXIST
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|initidx
operator|=
name|ctl_get_initindex
argument_list|(
operator|&
name|io
operator|->
name|io_hdr
operator|.
name|nexus
argument_list|)
expr_stmt|;
name|ua
operator|=
name|ctl_build_qae
argument_list|(
name|lun
argument_list|,
name|initidx
argument_list|,
name|io
operator|->
name|taskio
operator|.
name|task_resp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ua
operator|!=
name|CTL_UA_NONE
condition|)
name|io
operator|->
name|taskio
operator|.
name|task_status
operator|=
name|CTL_TASK_FUNCTION_SUCCEEDED
expr_stmt|;
else|else
name|io
operator|->
name|taskio
operator|.
name|task_status
operator|=
name|CTL_TASK_FUNCTION_COMPLETE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_run_task
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|int
name|retval
init|=
literal|1
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_run_task\n"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|io
operator|->
name|io_hdr
operator|.
name|io_type
operator|==
name|CTL_IO_TASK
argument_list|,
operator|(
literal|"ctl_run_task: Unextected io_type %d\n"
operator|,
name|io
operator|->
name|io_hdr
operator|.
name|io_type
operator|)
argument_list|)
expr_stmt|;
name|io
operator|->
name|taskio
operator|.
name|task_status
operator|=
name|CTL_TASK_FUNCTION_NOT_SUPPORTED
expr_stmt|;
name|bzero
argument_list|(
name|io
operator|->
name|taskio
operator|.
name|task_resp
argument_list|,
sizeof|sizeof
argument_list|(
name|io
operator|->
name|taskio
operator|.
name|task_resp
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|io
operator|->
name|taskio
operator|.
name|task_action
condition|)
block|{
case|case
name|CTL_TASK_ABORT_TASK
case|:
name|retval
operator|=
name|ctl_abort_task
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_TASK_ABORT_TASK_SET
case|:
case|case
name|CTL_TASK_CLEAR_TASK_SET
case|:
name|retval
operator|=
name|ctl_abort_task_set
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_TASK_CLEAR_ACA
case|:
break|break;
case|case
name|CTL_TASK_I_T_NEXUS_RESET
case|:
name|retval
operator|=
name|ctl_i_t_nexus_reset
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_TASK_LUN_RESET
case|:
name|retval
operator|=
name|ctl_lun_reset
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_TASK_TARGET_RESET
case|:
case|case
name|CTL_TASK_BUS_RESET
case|:
name|retval
operator|=
name|ctl_target_reset
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_TASK_PORT_LOGIN
case|:
break|break;
case|case
name|CTL_TASK_PORT_LOGOUT
case|:
break|break;
case|case
name|CTL_TASK_QUERY_TASK
case|:
name|retval
operator|=
name|ctl_query_task
argument_list|(
name|io
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_TASK_QUERY_TASK_SET
case|:
name|retval
operator|=
name|ctl_query_task
argument_list|(
name|io
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_TASK_QUERY_ASYNC_EVENT
case|:
name|retval
operator|=
name|ctl_query_async_event
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"%s: got unknown task management event %d\n"
argument_list|,
name|__func__
argument_list|,
name|io
operator|->
name|taskio
operator|.
name|task_action
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|=
name|CTL_SUCCESS
expr_stmt|;
else|else
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|=
name|CTL_ERROR
expr_stmt|;
name|ctl_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * For HA operation.  Handle commands that come in from the other  * controller.  */
end_comment

begin_function
specifier|static
name|void
name|ctl_handle_isc
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|CTL_SOFTC
argument_list|(
name|io
argument_list|)
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
specifier|const
name|struct
name|ctl_cmd_entry
modifier|*
name|entry
decl_stmt|;
name|uint32_t
name|targ_lun
decl_stmt|;
name|targ_lun
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_mapped_lun
expr_stmt|;
switch|switch
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|msg_type
condition|)
block|{
case|case
name|CTL_MSG_SERIALIZE
case|:
name|ctl_serialize_other_sc_cmd
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_MSG_R2R
case|:
comment|/* Only used in SER_ONLY mode. */
name|entry
operator|=
name|ctl_get_cmd_entry
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|targ_lun
operator|>=
name|CTL_MAX_LUNS
operator|||
operator|(
name|lun
operator|=
name|softc
operator|->
name|ctl_luns
index|[
name|targ_lun
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
name|ctl_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
block|}
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl_scsiio_lun_check
argument_list|(
name|lun
argument_list|,
name|entry
argument_list|,
operator|&
name|io
operator|->
name|scsiio
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
block|}
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_IS_WAS_ON_RTR
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctl_enqueue_rtr
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_MSG_FINISH_IO
case|:
if|if
condition|(
name|softc
operator|->
name|ha_mode
operator|==
name|CTL_HA_MODE_XFER
condition|)
block|{
name|ctl_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|targ_lun
operator|>=
name|CTL_MAX_LUNS
operator|||
operator|(
name|lun
operator|=
name|softc
operator|->
name|ctl_luns
index|[
name|targ_lun
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
name|ctl_free_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
block|}
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|lun
operator|->
name|ooa_queue
argument_list|,
operator|&
name|io
operator|->
name|io_hdr
argument_list|,
name|ooa_links
argument_list|)
expr_stmt|;
name|ctl_check_blocked
argument_list|(
name|lun
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctl_free_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_MSG_PERS_ACTION
case|:
name|ctl_hndl_per_res_out_on_other_sc
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|ctl_free_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_MSG_BAD_JUJU
case|:
name|ctl_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_MSG_DATAMOVE
case|:
comment|/* Only used in XFER mode */
name|ctl_datamove_remote
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_MSG_DATAMOVE_DONE
case|:
comment|/* Only used in XFER mode */
name|io
operator|->
name|scsiio
operator|.
name|be_move_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_MSG_FAILOVER
case|:
name|ctl_failover_lun
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|ctl_free_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"%s: Invalid message type %d\n"
argument_list|,
name|__func__
argument_list|,
name|io
operator|->
name|io_hdr
operator|.
name|msg_type
argument_list|)
expr_stmt|;
name|ctl_free_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Returns the match type in the case of a match, or CTL_LUN_PAT_NONE if  * there is no match.  */
end_comment

begin_function
specifier|static
name|ctl_lun_error_pattern
name|ctl_cmd_pattern_match
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|struct
name|ctl_error_desc
modifier|*
name|desc
parameter_list|)
block|{
specifier|const
name|struct
name|ctl_cmd_entry
modifier|*
name|entry
decl_stmt|;
name|ctl_lun_error_pattern
name|filtered_pattern
decl_stmt|,
name|pattern
decl_stmt|;
name|pattern
operator|=
name|desc
operator|->
name|error_pattern
expr_stmt|;
comment|/* 	 * XXX KDM we need more data passed into this function to match a 	 * custom pattern, and we actually need to implement custom pattern 	 * matching. 	 */
if|if
condition|(
name|pattern
operator|&
name|CTL_LUN_PAT_CMD
condition|)
return|return
operator|(
name|CTL_LUN_PAT_CMD
operator|)
return|;
if|if
condition|(
operator|(
name|pattern
operator|&
name|CTL_LUN_PAT_MASK
operator|)
operator|==
name|CTL_LUN_PAT_ANY
condition|)
return|return
operator|(
name|CTL_LUN_PAT_ANY
operator|)
return|;
name|entry
operator|=
name|ctl_get_cmd_entry
argument_list|(
name|ctsio
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|filtered_pattern
operator|=
name|entry
operator|->
name|pattern
operator|&
name|pattern
expr_stmt|;
comment|/* 	 * If the user requested specific flags in the pattern (e.g. 	 * CTL_LUN_PAT_RANGE), make sure the command supports all of those 	 * flags. 	 * 	 * If the user did not specify any flags, it doesn't matter whether 	 * or not the command supports the flags. 	 */
if|if
condition|(
operator|(
name|filtered_pattern
operator|&
operator|~
name|CTL_LUN_PAT_MASK
operator|)
operator|!=
operator|(
name|pattern
operator|&
operator|~
name|CTL_LUN_PAT_MASK
operator|)
condition|)
return|return
operator|(
name|CTL_LUN_PAT_NONE
operator|)
return|;
comment|/* 	 * If the user asked for a range check, see if the requested LBA 	 * range overlaps with this command's LBA range. 	 */
if|if
condition|(
name|filtered_pattern
operator|&
name|CTL_LUN_PAT_RANGE
condition|)
block|{
name|uint64_t
name|lba1
decl_stmt|;
name|uint64_t
name|len1
decl_stmt|;
name|ctl_action
name|action
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|ctl_get_lba_len
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|,
operator|&
name|lba1
argument_list|,
operator|&
name|len1
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
return|return
operator|(
name|CTL_LUN_PAT_NONE
operator|)
return|;
name|action
operator|=
name|ctl_extent_check_lba
argument_list|(
name|lba1
argument_list|,
name|len1
argument_list|,
name|desc
operator|->
name|lba_range
operator|.
name|lba
argument_list|,
name|desc
operator|->
name|lba_range
operator|.
name|len
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* 		 * A "pass" means that the LBA ranges don't overlap, so 		 * this doesn't match the user's range criteria. 		 */
if|if
condition|(
name|action
operator|==
name|CTL_ACTION_PASS
condition|)
return|return
operator|(
name|CTL_LUN_PAT_NONE
operator|)
return|;
block|}
return|return
operator|(
name|filtered_pattern
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_inject_error
parameter_list|(
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|,
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_error_desc
modifier|*
name|desc
decl_stmt|,
modifier|*
name|desc2
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|desc
argument_list|,
argument|&lun->error_list
argument_list|,
argument|links
argument_list|,
argument|desc2
argument_list|)
block|{
name|ctl_lun_error_pattern
name|pattern
decl_stmt|;
comment|/* 		 * Check to see whether this particular command matches 		 * the pattern in the descriptor. 		 */
name|pattern
operator|=
name|ctl_cmd_pattern_match
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|,
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pattern
operator|&
name|CTL_LUN_PAT_MASK
operator|)
operator|==
name|CTL_LUN_PAT_NONE
condition|)
continue|continue;
switch|switch
condition|(
name|desc
operator|->
name|lun_error
operator|&
name|CTL_LUN_INJ_TYPE
condition|)
block|{
case|case
name|CTL_LUN_INJ_ABORTED
case|:
name|ctl_set_aborted
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_LUN_INJ_MEDIUM_ERR
case|:
name|ctl_set_medium_error
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|,
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_DATA_MASK
operator|)
operator|!=
name|CTL_FLAG_DATA_OUT
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_LUN_INJ_UA
case|:
comment|/* 29h/00h  POWER ON, RESET, OR BUS DEVICE RESET 			 * OCCURRED */
name|ctl_set_ua
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|,
literal|0x29
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_LUN_INJ_CUSTOM
case|:
comment|/* 			 * We're assuming the user knows what he is doing. 			 * Just copy the sense information without doing 			 * checks. 			 */
name|bcopy
argument_list|(
operator|&
name|desc
operator|->
name|custom_sense
argument_list|,
operator|&
name|io
operator|->
name|scsiio
operator|.
name|sense_data
argument_list|,
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
name|desc
operator|->
name|custom_sense
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|io
operator|->
name|scsiio
operator|.
name|sense_data
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|scsi_status
operator|=
name|SCSI_STATUS_CHECK_COND
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|sense_len
operator|=
name|SSD_FULL_SIZE
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|=
name|CTL_SCSI_ERROR
operator||
name|CTL_AUTOSENSE
expr_stmt|;
break|break;
case|case
name|CTL_LUN_INJ_NONE
case|:
default|default:
comment|/* 			 * If this is an error injection type we don't know 			 * about, clear the continuous flag (if it is set) 			 * so it will get deleted below. 			 */
name|desc
operator|->
name|lun_error
operator|&=
operator|~
name|CTL_LUN_INJ_CONTINUOUS
expr_stmt|;
break|break;
block|}
comment|/* 		 * By default, each error injection action is a one-shot 		 */
if|if
condition|(
name|desc
operator|->
name|lun_error
operator|&
name|CTL_LUN_INJ_CONTINUOUS
condition|)
continue|continue;
name|STAILQ_REMOVE
argument_list|(
operator|&
name|lun
operator|->
name|error_list
argument_list|,
name|desc
argument_list|,
name|ctl_error_desc
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|desc
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CTL_IO_DELAY
end_ifdef

begin_function
specifier|static
name|void
name|ctl_datamove_timer_wakeup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|arg
expr_stmt|;
name|ctl_datamove
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CTL_IO_DELAY */
end_comment

begin_function
name|void
name|ctl_datamove
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|void
function_decl|(
modifier|*
name|fe_datamove
function_decl|)
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
name|mtx_assert
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|ctl_softc
operator|*
operator|)
name|CTL_SOFTC
argument_list|(
name|io
argument_list|)
operator|)
operator|->
name|ctl_lock
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_datamove\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* No data transferred yet.  Frontend must update this when done. */
name|io
operator|->
name|scsiio
operator|.
name|kern_data_resid
operator|=
name|io
operator|->
name|scsiio
operator|.
name|kern_data_len
expr_stmt|;
ifdef|#
directive|ifdef
name|CTL_TIME_IO
if|if
condition|(
operator|(
name|time_uptime
operator|-
name|io
operator|->
name|io_hdr
operator|.
name|start_time
operator|)
operator|>
name|ctl_time_io_secs
condition|)
block|{
name|char
name|str
index|[
literal|256
index|]
decl_stmt|;
name|char
name|path_str
index|[
literal|64
index|]
decl_stmt|;
name|struct
name|sbuf
name|sb
decl_stmt|;
name|ctl_scsi_path_string
argument_list|(
name|io
argument_list|,
name|path_str
argument_list|,
sizeof|sizeof
argument_list|(
name|path_str
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_new
argument_list|(
operator|&
name|sb
argument_list|,
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|,
name|SBUF_FIXEDLEN
argument_list|)
expr_stmt|;
name|sbuf_cat
argument_list|(
operator|&
name|sb
argument_list|,
name|path_str
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|io_type
condition|)
block|{
case|case
name|CTL_IO_SCSI
case|:
name|ctl_scsi_command_string
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|,
name|NULL
argument_list|,
operator|&
name|sb
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|sbuf_cat
argument_list|(
operator|&
name|sb
argument_list|,
name|path_str
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"Tag: 0x%04x, type %d\n"
argument_list|,
name|io
operator|->
name|scsiio
operator|.
name|tag_num
argument_list|,
name|io
operator|->
name|scsiio
operator|.
name|tag_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_IO_TASK
case|:
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"Task I/O type: %d, Tag: 0x%04x, "
literal|"Tag Type: %d\n"
argument_list|,
name|io
operator|->
name|taskio
operator|.
name|task_action
argument_list|,
name|io
operator|->
name|taskio
operator|.
name|tag_num
argument_list|,
name|io
operator|->
name|taskio
operator|.
name|tag_type
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: Invalid CTL I/O type %d\n"
argument_list|,
name|__func__
argument_list|,
name|io
operator|->
name|io_hdr
operator|.
name|io_type
argument_list|)
expr_stmt|;
block|}
name|sbuf_cat
argument_list|(
operator|&
name|sb
argument_list|,
name|path_str
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"ctl_datamove: %jd seconds\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|time_uptime
operator|-
name|io
operator|->
name|io_hdr
operator|.
name|start_time
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|sbuf_data
argument_list|(
operator|&
name|sb
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* CTL_TIME_IO */
ifdef|#
directive|ifdef
name|CTL_IO_DELAY
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_DELAY_DONE
condition|)
block|{
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&=
operator|~
name|CTL_FLAG_DELAY_DONE
expr_stmt|;
block|}
else|else
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|lun
operator|=
name|CTL_LUN
argument_list|(
name|io
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lun
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|lun
operator|->
name|delay_info
operator|.
name|datamove_delay
operator|>
literal|0
operator|)
condition|)
block|{
name|callout_init
argument_list|(
operator|&
name|io
operator|->
name|io_hdr
operator|.
name|delay_callout
argument_list|,
comment|/*mpsafe*/
literal|1
argument_list|)
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_DELAY_DONE
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|io
operator|->
name|io_hdr
operator|.
name|delay_callout
argument_list|,
name|lun
operator|->
name|delay_info
operator|.
name|datamove_delay
operator|*
name|hz
argument_list|,
name|ctl_datamove_timer_wakeup
argument_list|,
name|io
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|delay_info
operator|.
name|datamove_type
operator|==
name|CTL_DELAY_TYPE_ONESHOT
condition|)
name|lun
operator|->
name|delay_info
operator|.
name|datamove_delay
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
comment|/* 	 * This command has been aborted.  Set the port status, so we fail 	 * the data move. 	 */
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ABORT
condition|)
block|{
name|printf
argument_list|(
literal|"ctl_datamove: tag 0x%04x on (%u:%u:%u) aborted\n"
argument_list|,
name|io
operator|->
name|scsiio
operator|.
name|tag_num
argument_list|,
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|initid
argument_list|,
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
argument_list|,
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_lun
argument_list|)
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|port_status
operator|=
literal|31337
expr_stmt|;
comment|/* 		 * Note that the backend, in this case, will get the 		 * callback in its context.  In other cases it may get 		 * called in the frontend's interrupt thread context. 		 */
name|io
operator|->
name|scsiio
operator|.
name|be_move_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Don't confuse frontend with zero length data move. */
if|if
condition|(
name|io
operator|->
name|scsiio
operator|.
name|kern_data_len
operator|==
literal|0
condition|)
block|{
name|io
operator|->
name|scsiio
operator|.
name|be_move_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
return|return;
block|}
name|fe_datamove
operator|=
name|CTL_PORT
argument_list|(
name|io
argument_list|)
operator|->
name|fe_datamove
expr_stmt|;
name|fe_datamove
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_send_datamove_done
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|,
name|int
name|have_lock
parameter_list|)
block|{
name|union
name|ctl_ha_msg
name|msg
decl_stmt|;
ifdef|#
directive|ifdef
name|CTL_TIME_IO
name|struct
name|bintime
name|cur_bt
decl_stmt|;
endif|#
directive|endif
name|memset
argument_list|(
operator|&
name|msg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|msg
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_DATAMOVE_DONE
expr_stmt|;
name|msg
operator|.
name|hdr
operator|.
name|original_sc
operator|=
name|io
expr_stmt|;
name|msg
operator|.
name|hdr
operator|.
name|serializing_sc
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|serializing_sc
expr_stmt|;
name|msg
operator|.
name|hdr
operator|.
name|nexus
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|nexus
expr_stmt|;
name|msg
operator|.
name|hdr
operator|.
name|status
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|status
expr_stmt|;
name|msg
operator|.
name|scsi
operator|.
name|kern_data_resid
operator|=
name|io
operator|->
name|scsiio
operator|.
name|kern_data_resid
expr_stmt|;
name|msg
operator|.
name|scsi
operator|.
name|tag_num
operator|=
name|io
operator|->
name|scsiio
operator|.
name|tag_num
expr_stmt|;
name|msg
operator|.
name|scsi
operator|.
name|tag_type
operator|=
name|io
operator|->
name|scsiio
operator|.
name|tag_type
expr_stmt|;
name|msg
operator|.
name|scsi
operator|.
name|scsi_status
operator|=
name|io
operator|->
name|scsiio
operator|.
name|scsi_status
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|msg
operator|.
name|scsi
operator|.
name|sense_data
argument_list|,
operator|&
name|io
operator|->
name|scsiio
operator|.
name|sense_data
argument_list|,
name|io
operator|->
name|scsiio
operator|.
name|sense_len
argument_list|)
expr_stmt|;
name|msg
operator|.
name|scsi
operator|.
name|sense_len
operator|=
name|io
operator|->
name|scsiio
operator|.
name|sense_len
expr_stmt|;
name|msg
operator|.
name|scsi
operator|.
name|port_status
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|port_status
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&=
operator|~
name|CTL_FLAG_IO_ACTIVE
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_FAILOVER
condition|)
block|{
name|ctl_failover_io
argument_list|(
name|io
argument_list|,
comment|/*have_lock*/
name|have_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
operator|.
name|scsi
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|msg
operator|.
name|scsi
operator|.
name|sense_data
argument_list|)
operator|+
name|msg
operator|.
name|scsi
operator|.
name|sense_len
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CTL_TIME_IO
name|getbinuptime
argument_list|(
operator|&
name|cur_bt
argument_list|)
expr_stmt|;
name|bintime_sub
argument_list|(
operator|&
name|cur_bt
argument_list|,
operator|&
name|io
operator|->
name|io_hdr
operator|.
name|dma_start_bt
argument_list|)
expr_stmt|;
name|bintime_add
argument_list|(
operator|&
name|io
operator|->
name|io_hdr
operator|.
name|dma_bt
argument_list|,
operator|&
name|cur_bt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|io
operator|->
name|io_hdr
operator|.
name|num_dmas
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The DMA to the remote side is done, now we need to tell the other side  * we're done so it can continue with its data movement.  */
end_comment

begin_function
specifier|static
name|void
name|ctl_datamove_remote_write_cb
parameter_list|(
name|struct
name|ctl_ha_dt_req
modifier|*
name|rq
parameter_list|)
block|{
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|io
operator|=
name|rq
operator|->
name|context
expr_stmt|;
if|if
condition|(
name|rq
operator|->
name|ret
operator|!=
name|CTL_HA_STATUS_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ISC DMA write failed with error %d"
argument_list|,
name|__func__
argument_list|,
name|rq
operator|->
name|ret
argument_list|)
expr_stmt|;
name|ctl_set_internal_failure
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*retry_count*/
name|rq
operator|->
name|ret
argument_list|)
expr_stmt|;
block|}
name|ctl_dt_req_free
argument_list|(
name|rq
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|io
operator|->
name|scsiio
operator|.
name|kern_sg_entries
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|io
operator|->
name|io_hdr
operator|.
name|local_sglist
index|[
name|i
index|]
operator|.
name|addr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|io
operator|->
name|io_hdr
operator|.
name|remote_sglist
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|remote_sglist
operator|=
name|NULL
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|local_sglist
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * The data is in local and remote memory, so now we need to send 	 * status (good or back) back to the other side. 	 */
name|ctl_send_datamove_done
argument_list|(
name|io
argument_list|,
comment|/*have_lock*/
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * We've moved the data from the host/controller into local memory.  Now we  * need to push it over to the remote controller's memory.  */
end_comment

begin_function
specifier|static
name|int
name|ctl_datamove_remote_dm_write_cb
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|ctl_datamove_remote_xfer
argument_list|(
name|io
argument_list|,
name|CTL_HA_DT_CMD_WRITE
argument_list|,
name|ctl_datamove_remote_write_cb
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_datamove_remote_write
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|void
function_decl|(
modifier|*
name|fe_datamove
function_decl|)
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
comment|/* 	 * - Get the data from the host/HBA into local memory. 	 * - DMA memory from the local controller to the remote controller. 	 * - Send status back to the remote controller. 	 */
name|retval
operator|=
name|ctl_datamove_remote_sgl_setup
argument_list|(
name|io
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
return|return;
comment|/* Switch the pointer over so the FETD knows what to do */
name|io
operator|->
name|scsiio
operator|.
name|kern_data_ptr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|io
operator|->
name|io_hdr
operator|.
name|local_sglist
expr_stmt|;
comment|/* 	 * Use a custom move done callback, since we need to send completion 	 * back to the other controller, not to the backend on this side. 	 */
name|io
operator|->
name|scsiio
operator|.
name|be_move_done
operator|=
name|ctl_datamove_remote_dm_write_cb
expr_stmt|;
name|fe_datamove
operator|=
name|CTL_PORT
argument_list|(
name|io
argument_list|)
operator|->
name|fe_datamove
expr_stmt|;
name|fe_datamove
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_datamove_remote_dm_read_cb
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
if|#
directive|if
literal|0
block|char str[256]; 	char path_str[64]; 	struct sbuf sb;
endif|#
directive|endif
name|uint32_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|io
operator|->
name|scsiio
operator|.
name|kern_sg_entries
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|io
operator|->
name|io_hdr
operator|.
name|local_sglist
index|[
name|i
index|]
operator|.
name|addr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|io
operator|->
name|io_hdr
operator|.
name|remote_sglist
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|remote_sglist
operator|=
name|NULL
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|local_sglist
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
literal|0
block|scsi_path_string(io, path_str, sizeof(path_str)); 	sbuf_new(&sb, str, sizeof(str), SBUF_FIXEDLEN); 	sbuf_cat(&sb, path_str); 	scsi_command_string(&io->scsiio, NULL,&sb); 	sbuf_printf(&sb, "\n"); 	sbuf_cat(&sb, path_str); 	sbuf_printf(&sb, "Tag: 0x%04x, type %d\n", 		    io->scsiio.tag_num, io->scsiio.tag_type); 	sbuf_cat(&sb, path_str); 	sbuf_printf(&sb, "%s: flags %#x, status %#x\n", __func__, 		    io->io_hdr.flags, io->io_hdr.status); 	sbuf_finish(&sb); 	printk("%s", sbuf_data(&sb));
endif|#
directive|endif
comment|/* 	 * The read is done, now we need to send status (good or bad) back 	 * to the other side. 	 */
name|ctl_send_datamove_done
argument_list|(
name|io
argument_list|,
comment|/*have_lock*/
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_datamove_remote_read_cb
parameter_list|(
name|struct
name|ctl_ha_dt_req
modifier|*
name|rq
parameter_list|)
block|{
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|void
function_decl|(
modifier|*
name|fe_datamove
function_decl|)
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
name|io
operator|=
name|rq
operator|->
name|context
expr_stmt|;
if|if
condition|(
name|rq
operator|->
name|ret
operator|!=
name|CTL_HA_STATUS_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ISC DMA read failed with error %d\n"
argument_list|,
name|__func__
argument_list|,
name|rq
operator|->
name|ret
argument_list|)
expr_stmt|;
name|ctl_set_internal_failure
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*retry_count*/
name|rq
operator|->
name|ret
argument_list|)
expr_stmt|;
block|}
name|ctl_dt_req_free
argument_list|(
name|rq
argument_list|)
expr_stmt|;
comment|/* Switch the pointer over so the FETD knows what to do */
name|io
operator|->
name|scsiio
operator|.
name|kern_data_ptr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|io
operator|->
name|io_hdr
operator|.
name|local_sglist
expr_stmt|;
comment|/* 	 * Use a custom move done callback, since we need to send completion 	 * back to the other controller, not to the backend on this side. 	 */
name|io
operator|->
name|scsiio
operator|.
name|be_move_done
operator|=
name|ctl_datamove_remote_dm_read_cb
expr_stmt|;
comment|/* XXX KDM add checks like the ones in ctl_datamove? */
name|fe_datamove
operator|=
name|CTL_PORT
argument_list|(
name|io
argument_list|)
operator|->
name|fe_datamove
expr_stmt|;
name|fe_datamove
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_datamove_remote_sgl_setup
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_sg_entry
modifier|*
name|local_sglist
decl_stmt|;
name|uint32_t
name|len_to_go
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|int
name|i
decl_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|local_sglist
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|local_sglist
expr_stmt|;
name|len_to_go
operator|=
name|io
operator|->
name|scsiio
operator|.
name|kern_data_len
expr_stmt|;
comment|/* 	 * The difficult thing here is that the size of the various 	 * S/G segments may be different than the size from the 	 * remote controller.  That'll make it harder when DMAing 	 * the data back to the other side. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|len_to_go
operator|>
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|local_sglist
index|[
name|i
index|]
operator|.
name|len
operator|=
name|MIN
argument_list|(
name|len_to_go
argument_list|,
name|CTL_HA_DATAMOVE_SEGMENT
argument_list|)
expr_stmt|;
name|local_sglist
index|[
name|i
index|]
operator|.
name|addr
operator|=
name|malloc
argument_list|(
name|local_sglist
index|[
name|i
index|]
operator|.
name|len
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|len_to_go
operator|-=
name|local_sglist
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
block|}
comment|/* 	 * Reset the number of S/G entries accordingly.  The original 	 * number of S/G entries is available in rem_sg_entries. 	 */
name|io
operator|->
name|scsiio
operator|.
name|kern_sg_entries
operator|=
name|i
expr_stmt|;
if|#
directive|if
literal|0
block|printf("%s: kern_sg_entries = %d\n", __func__, 	       io->scsiio.kern_sg_entries); 	for (i = 0; i< io->scsiio.kern_sg_entries; i++) 		printf("%s: sg[%d] = %p, %lu\n", __func__, i, 		       local_sglist[i].addr, local_sglist[i].len);
endif|#
directive|endif
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_datamove_remote_xfer
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|,
name|unsigned
name|command
parameter_list|,
name|ctl_ha_dt_cb
name|callback
parameter_list|)
block|{
name|struct
name|ctl_ha_dt_req
modifier|*
name|rq
decl_stmt|;
name|struct
name|ctl_sg_entry
modifier|*
name|remote_sglist
decl_stmt|,
modifier|*
name|local_sglist
decl_stmt|;
name|uint32_t
name|local_used
decl_stmt|,
name|remote_used
decl_stmt|,
name|total_used
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|isc_ret
decl_stmt|;
name|rq
operator|=
name|ctl_dt_req_alloc
argument_list|()
expr_stmt|;
comment|/* 	 * If we failed to allocate the request, and if the DMA didn't fail 	 * anyway, set busy status.  This is just a resource allocation 	 * failure. 	 */
if|if
condition|(
operator|(
name|rq
operator|==
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|!=
name|CTL_STATUS_NONE
operator|&&
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|!=
name|CTL_SUCCESS
operator|)
condition|)
name|ctl_set_busy
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|!=
name|CTL_STATUS_NONE
operator|&&
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|!=
name|CTL_SUCCESS
condition|)
block|{
if|if
condition|(
name|rq
operator|!=
name|NULL
condition|)
name|ctl_dt_req_free
argument_list|(
name|rq
argument_list|)
expr_stmt|;
comment|/* 		 * The data move failed.  We need to return status back 		 * to the other controller.  No point in trying to DMA 		 * data to the remote controller. 		 */
name|ctl_send_datamove_done
argument_list|(
name|io
argument_list|,
comment|/*have_lock*/
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|local_sglist
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|local_sglist
expr_stmt|;
name|remote_sglist
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|remote_sglist
expr_stmt|;
name|local_used
operator|=
literal|0
expr_stmt|;
name|remote_used
operator|=
literal|0
expr_stmt|;
name|total_used
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Pull/push the data over the wire from/to the other controller. 	 * This takes into account the possibility that the local and 	 * remote sglists may not be identical in terms of the size of 	 * the elements and the number of elements. 	 * 	 * One fundamental assumption here is that the length allocated for 	 * both the local and remote sglists is identical.  Otherwise, we've 	 * essentially got a coding error of some sort. 	 */
name|isc_ret
operator|=
name|CTL_HA_STATUS_SUCCESS
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|total_used
operator|<
name|io
operator|->
name|scsiio
operator|.
name|kern_data_len
condition|;
control|)
block|{
name|uint32_t
name|cur_len
decl_stmt|;
name|uint8_t
modifier|*
name|tmp_ptr
decl_stmt|;
name|rq
operator|->
name|command
operator|=
name|command
expr_stmt|;
name|rq
operator|->
name|context
operator|=
name|io
expr_stmt|;
comment|/* 		 * Both pointers should be aligned.  But it is possible 		 * that the allocation length is not.  They should both 		 * also have enough slack left over at the end, though, 		 * to round up to the next 8 byte boundary. 		 */
name|cur_len
operator|=
name|MIN
argument_list|(
name|local_sglist
index|[
name|i
index|]
operator|.
name|len
operator|-
name|local_used
argument_list|,
name|remote_sglist
index|[
name|j
index|]
operator|.
name|len
operator|-
name|remote_used
argument_list|)
expr_stmt|;
name|rq
operator|->
name|size
operator|=
name|cur_len
expr_stmt|;
name|tmp_ptr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|local_sglist
index|[
name|i
index|]
operator|.
name|addr
expr_stmt|;
name|tmp_ptr
operator|+=
name|local_used
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Use physical addresses when talking to ISC hardware */
block|if ((io->io_hdr.flags& CTL_FLAG_BUS_ADDR) == 0) {
comment|/* XXX KDM use busdma */
block|rq->local = vtophys(tmp_ptr); 		} else 			rq->local = tmp_ptr;
else|#
directive|else
name|KASSERT
argument_list|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_BUS_ADDR
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"HA does not support BUS_ADDR"
operator|)
argument_list|)
expr_stmt|;
name|rq
operator|->
name|local
operator|=
name|tmp_ptr
expr_stmt|;
endif|#
directive|endif
name|tmp_ptr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|remote_sglist
index|[
name|j
index|]
operator|.
name|addr
expr_stmt|;
name|tmp_ptr
operator|+=
name|remote_used
expr_stmt|;
name|rq
operator|->
name|remote
operator|=
name|tmp_ptr
expr_stmt|;
name|rq
operator|->
name|callback
operator|=
name|NULL
expr_stmt|;
name|local_used
operator|+=
name|cur_len
expr_stmt|;
if|if
condition|(
name|local_used
operator|>=
name|local_sglist
index|[
name|i
index|]
operator|.
name|len
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|local_used
operator|=
literal|0
expr_stmt|;
block|}
name|remote_used
operator|+=
name|cur_len
expr_stmt|;
if|if
condition|(
name|remote_used
operator|>=
name|remote_sglist
index|[
name|j
index|]
operator|.
name|len
condition|)
block|{
name|j
operator|++
expr_stmt|;
name|remote_used
operator|=
literal|0
expr_stmt|;
block|}
name|total_used
operator|+=
name|cur_len
expr_stmt|;
if|if
condition|(
name|total_used
operator|>=
name|io
operator|->
name|scsiio
operator|.
name|kern_data_len
condition|)
name|rq
operator|->
name|callback
operator|=
name|callback
expr_stmt|;
if|#
directive|if
literal|0
block|printf("%s: %s: local %p remote %p size %d\n", __func__, 		       (command == CTL_HA_DT_CMD_WRITE) ? "WRITE" : "READ", 		       rq->local, rq->remote, rq->size);
endif|#
directive|endif
name|isc_ret
operator|=
name|ctl_dt_single
argument_list|(
name|rq
argument_list|)
expr_stmt|;
if|if
condition|(
name|isc_ret
operator|>
name|CTL_HA_STATUS_SUCCESS
condition|)
break|break;
block|}
if|if
condition|(
name|isc_ret
operator|!=
name|CTL_HA_STATUS_WAIT
condition|)
block|{
name|rq
operator|->
name|ret
operator|=
name|isc_ret
expr_stmt|;
name|callback
argument_list|(
name|rq
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_datamove_remote_read
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
comment|/* 	 * This will send an error to the other controller in the case of a 	 * failure. 	 */
name|retval
operator|=
name|ctl_datamove_remote_sgl_setup
argument_list|(
name|io
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
return|return;
name|retval
operator|=
name|ctl_datamove_remote_xfer
argument_list|(
name|io
argument_list|,
name|CTL_HA_DT_CMD_READ
argument_list|,
name|ctl_datamove_remote_read_cb
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Make sure we free memory if there was an error..  The 		 * ctl_datamove_remote_xfer() function will send the 		 * datamove done message, or call the callback with an 		 * error if there is a problem. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|io
operator|->
name|scsiio
operator|.
name|kern_sg_entries
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|io
operator|->
name|io_hdr
operator|.
name|local_sglist
index|[
name|i
index|]
operator|.
name|addr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|io
operator|->
name|io_hdr
operator|.
name|remote_sglist
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|remote_sglist
operator|=
name|NULL
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|local_sglist
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Process a datamove request from the other controller.  This is used for  * XFER mode only, not SER_ONLY mode.  For writes, we DMA into local memory  * first.  Once that is complete, the data gets DMAed into the remote  * controller's memory.  For reads, we DMA from the remote controller's  * memory into our memory first, and then move it out to the FETD.  */
end_comment

begin_function
specifier|static
name|void
name|ctl_datamove_remote
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|ctl_softc
operator|*
operator|)
name|CTL_SOFTC
argument_list|(
name|io
argument_list|)
operator|)
operator|->
name|ctl_lock
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_FAILOVER
condition|)
block|{
name|ctl_failover_io
argument_list|(
name|io
argument_list|,
comment|/*have_lock*/
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Note that we look for an aborted I/O here, but don't do some of 	 * the other checks that ctl_datamove() normally does. 	 * We don't need to run the datamove delay code, since that should 	 * have been done if need be on the other controller. 	 */
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ABORT
condition|)
block|{
name|printf
argument_list|(
literal|"%s: tag 0x%04x on (%u:%u:%u) aborted\n"
argument_list|,
name|__func__
argument_list|,
name|io
operator|->
name|scsiio
operator|.
name|tag_num
argument_list|,
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|initid
argument_list|,
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
argument_list|,
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_lun
argument_list|)
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|port_status
operator|=
literal|31338
expr_stmt|;
name|ctl_send_datamove_done
argument_list|(
name|io
argument_list|,
comment|/*have_lock*/
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_DATA_MASK
operator|)
operator|==
name|CTL_FLAG_DATA_OUT
condition|)
name|ctl_datamove_remote_write
argument_list|(
name|io
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_DATA_MASK
operator|)
operator|==
name|CTL_FLAG_DATA_IN
condition|)
name|ctl_datamove_remote_read
argument_list|(
name|io
argument_list|)
expr_stmt|;
else|else
block|{
name|io
operator|->
name|io_hdr
operator|.
name|port_status
operator|=
literal|31339
expr_stmt|;
name|ctl_send_datamove_done
argument_list|(
name|io
argument_list|,
comment|/*have_lock*/
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_process_done
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|CTL_SOFTC
argument_list|(
name|io
argument_list|)
decl_stmt|;
name|struct
name|ctl_port
modifier|*
name|port
init|=
name|CTL_PORT
argument_list|(
name|io
argument_list|)
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
name|CTL_LUN
argument_list|(
name|io
argument_list|)
decl_stmt|;
name|void
function_decl|(
modifier|*
name|fe_done
function_decl|)
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
name|union
name|ctl_ha_msg
name|msg
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_process_done\n"
operator|)
argument_list|)
expr_stmt|;
name|fe_done
operator|=
name|port
operator|->
name|fe_done
expr_stmt|;
ifdef|#
directive|ifdef
name|CTL_TIME_IO
if|if
condition|(
operator|(
name|time_uptime
operator|-
name|io
operator|->
name|io_hdr
operator|.
name|start_time
operator|)
operator|>
name|ctl_time_io_secs
condition|)
block|{
name|char
name|str
index|[
literal|256
index|]
decl_stmt|;
name|char
name|path_str
index|[
literal|64
index|]
decl_stmt|;
name|struct
name|sbuf
name|sb
decl_stmt|;
name|ctl_scsi_path_string
argument_list|(
name|io
argument_list|,
name|path_str
argument_list|,
sizeof|sizeof
argument_list|(
name|path_str
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_new
argument_list|(
operator|&
name|sb
argument_list|,
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|,
name|SBUF_FIXEDLEN
argument_list|)
expr_stmt|;
name|sbuf_cat
argument_list|(
operator|&
name|sb
argument_list|,
name|path_str
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|io_type
condition|)
block|{
case|case
name|CTL_IO_SCSI
case|:
name|ctl_scsi_command_string
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|,
name|NULL
argument_list|,
operator|&
name|sb
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|sbuf_cat
argument_list|(
operator|&
name|sb
argument_list|,
name|path_str
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"Tag: 0x%04x, type %d\n"
argument_list|,
name|io
operator|->
name|scsiio
operator|.
name|tag_num
argument_list|,
name|io
operator|->
name|scsiio
operator|.
name|tag_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_IO_TASK
case|:
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"Task I/O type: %d, Tag: 0x%04x, "
literal|"Tag Type: %d\n"
argument_list|,
name|io
operator|->
name|taskio
operator|.
name|task_action
argument_list|,
name|io
operator|->
name|taskio
operator|.
name|tag_num
argument_list|,
name|io
operator|->
name|taskio
operator|.
name|tag_type
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: Invalid CTL I/O type %d\n"
argument_list|,
name|__func__
argument_list|,
name|io
operator|->
name|io_hdr
operator|.
name|io_type
argument_list|)
expr_stmt|;
block|}
name|sbuf_cat
argument_list|(
operator|&
name|sb
argument_list|,
name|path_str
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"ctl_process_done: %jd seconds\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|time_uptime
operator|-
name|io
operator|->
name|io_hdr
operator|.
name|start_time
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|sbuf_data
argument_list|(
operator|&
name|sb
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* CTL_TIME_IO */
switch|switch
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|io_type
condition|)
block|{
case|case
name|CTL_IO_SCSI
case|:
break|break;
case|case
name|CTL_IO_TASK
case|:
if|if
condition|(
name|ctl_debug
operator|&
name|CTL_DEBUG_INFO
condition|)
name|ctl_io_error_print
argument_list|(
name|io
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fe_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
return|return;
default|default:
name|panic
argument_list|(
literal|"%s: Invalid CTL I/O type %d\n"
argument_list|,
name|__func__
argument_list|,
name|io
operator|->
name|io_hdr
operator|.
name|io_type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lun
operator|==
name|NULL
condition|)
block|{
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"NULL LUN for lun %d\n"
operator|,
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_mapped_lun
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Check to see if we have any informational exception and status 	 * of this command can be modified to report it in form of either 	 * RECOVERED ERROR or NO SENSE, depending on MRIE mode page field. 	 */
if|if
condition|(
name|lun
operator|->
name|ie_reported
operator|==
literal|0
operator|&&
name|lun
operator|->
name|ie_asc
operator|!=
literal|0
operator|&&
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|==
name|CTL_SUCCESS
operator|&&
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_STATUS_SENT
operator|)
operator|==
literal|0
condition|)
block|{
name|uint8_t
name|mrie
init|=
name|lun
operator|->
name|MODE_IE
operator|.
name|mrie
decl_stmt|;
name|uint8_t
name|per
init|=
operator|(
operator|(
name|lun
operator|->
name|MODE_RWER
operator|.
name|byte3
operator|&
name|SMS_RWER_PER
operator|)
operator|||
operator|(
name|lun
operator|->
name|MODE_VER
operator|.
name|byte3
operator|&
name|SMS_VER_PER
operator|)
operator|)
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|mrie
operator|==
name|SIEP_MRIE_REC_COND
operator|&&
name|per
operator|)
operator|||
name|mrie
operator|==
name|SIEP_MRIE_REC_UNCOND
operator|||
name|mrie
operator|==
name|SIEP_MRIE_NO_SENSE
operator|)
operator|&&
operator|(
name|ctl_get_cmd_entry
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|,
name|NULL
argument_list|)
operator|->
name|flags
operator|&
name|CTL_CMD_FLAG_NO_SENSE
operator|)
operator|==
literal|0
condition|)
block|{
name|ctl_set_sense
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|,
comment|/*current_error*/
literal|1
argument_list|,
comment|/*sense_key*/
operator|(
name|mrie
operator|==
name|SIEP_MRIE_NO_SENSE
operator|)
condition|?
name|SSD_KEY_NO_SENSE
else|:
name|SSD_KEY_RECOVERED_ERROR
argument_list|,
comment|/*asc*/
name|lun
operator|->
name|ie_asc
argument_list|,
comment|/*ascq*/
name|lun
operator|->
name|ie_ascq
argument_list|,
name|SSD_ELEM_NONE
argument_list|)
expr_stmt|;
name|lun
operator|->
name|ie_reported
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|lun
operator|->
name|ie_reported
operator|<
literal|0
condition|)
name|lun
operator|->
name|ie_reported
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Check to see if we have any errors to inject here.  We only 	 * inject errors for commands that don't already have errors set. 	 */
if|if
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|lun
operator|->
name|error_list
argument_list|)
operator|&&
operator|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|==
name|CTL_SUCCESS
operator|)
operator|&&
operator|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_STATUS_SENT
operator|)
operator|==
literal|0
operator|)
condition|)
name|ctl_inject_error
argument_list|(
name|lun
argument_list|,
name|io
argument_list|)
expr_stmt|;
comment|/* 	 * XXX KDM how do we treat commands that aren't completed 	 * successfully? 	 * 	 * XXX KDM should we also track I/O latency? 	 */
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|==
name|CTL_SUCCESS
operator|&&
name|io
operator|->
name|io_hdr
operator|.
name|io_type
operator|==
name|CTL_IO_SCSI
condition|)
block|{
name|int
name|type
decl_stmt|;
ifdef|#
directive|ifdef
name|CTL_TIME_IO
name|struct
name|bintime
name|bt
decl_stmt|;
name|getbinuptime
argument_list|(
operator|&
name|bt
argument_list|)
expr_stmt|;
name|bintime_sub
argument_list|(
operator|&
name|bt
argument_list|,
operator|&
name|io
operator|->
name|io_hdr
operator|.
name|start_bt
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_DATA_MASK
operator|)
operator|==
name|CTL_FLAG_DATA_IN
condition|)
name|type
operator|=
name|CTL_STATS_READ
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_DATA_MASK
operator|)
operator|==
name|CTL_FLAG_DATA_OUT
condition|)
name|type
operator|=
name|CTL_STATS_WRITE
expr_stmt|;
else|else
name|type
operator|=
name|CTL_STATS_NO_IO
expr_stmt|;
ifdef|#
directive|ifdef
name|CTL_LEGACY_STATS
name|uint32_t
name|targ_port
init|=
name|port
operator|->
name|targ_port
decl_stmt|;
name|lun
operator|->
name|legacy_stats
operator|.
name|ports
index|[
name|targ_port
index|]
operator|.
name|bytes
index|[
name|type
index|]
operator|+=
name|io
operator|->
name|scsiio
operator|.
name|kern_total_len
expr_stmt|;
name|lun
operator|->
name|legacy_stats
operator|.
name|ports
index|[
name|targ_port
index|]
operator|.
name|operations
index|[
name|type
index|]
operator|++
expr_stmt|;
name|lun
operator|->
name|legacy_stats
operator|.
name|ports
index|[
name|targ_port
index|]
operator|.
name|num_dmas
index|[
name|type
index|]
operator|+=
name|io
operator|->
name|io_hdr
operator|.
name|num_dmas
expr_stmt|;
ifdef|#
directive|ifdef
name|CTL_TIME_IO
name|bintime_add
argument_list|(
operator|&
name|lun
operator|->
name|legacy_stats
operator|.
name|ports
index|[
name|targ_port
index|]
operator|.
name|dma_time
index|[
name|type
index|]
argument_list|,
operator|&
name|io
operator|->
name|io_hdr
operator|.
name|dma_bt
argument_list|)
expr_stmt|;
name|bintime_add
argument_list|(
operator|&
name|lun
operator|->
name|legacy_stats
operator|.
name|ports
index|[
name|targ_port
index|]
operator|.
name|time
index|[
name|type
index|]
argument_list|,
operator|&
name|bt
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* CTL_LEGACY_STATS */
name|lun
operator|->
name|stats
operator|.
name|bytes
index|[
name|type
index|]
operator|+=
name|io
operator|->
name|scsiio
operator|.
name|kern_total_len
expr_stmt|;
name|lun
operator|->
name|stats
operator|.
name|operations
index|[
name|type
index|]
operator|++
expr_stmt|;
name|lun
operator|->
name|stats
operator|.
name|dmas
index|[
name|type
index|]
operator|+=
name|io
operator|->
name|io_hdr
operator|.
name|num_dmas
expr_stmt|;
ifdef|#
directive|ifdef
name|CTL_TIME_IO
name|bintime_add
argument_list|(
operator|&
name|lun
operator|->
name|stats
operator|.
name|dma_time
index|[
name|type
index|]
argument_list|,
operator|&
name|io
operator|->
name|io_hdr
operator|.
name|dma_bt
argument_list|)
expr_stmt|;
name|bintime_add
argument_list|(
operator|&
name|lun
operator|->
name|stats
operator|.
name|time
index|[
name|type
index|]
argument_list|,
operator|&
name|bt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mtx_lock
argument_list|(
operator|&
name|port
operator|->
name|port_lock
argument_list|)
expr_stmt|;
name|port
operator|->
name|stats
operator|.
name|bytes
index|[
name|type
index|]
operator|+=
name|io
operator|->
name|scsiio
operator|.
name|kern_total_len
expr_stmt|;
name|port
operator|->
name|stats
operator|.
name|operations
index|[
name|type
index|]
operator|++
expr_stmt|;
name|port
operator|->
name|stats
operator|.
name|dmas
index|[
name|type
index|]
operator|+=
name|io
operator|->
name|io_hdr
operator|.
name|num_dmas
expr_stmt|;
ifdef|#
directive|ifdef
name|CTL_TIME_IO
name|bintime_add
argument_list|(
operator|&
name|port
operator|->
name|stats
operator|.
name|dma_time
index|[
name|type
index|]
argument_list|,
operator|&
name|io
operator|->
name|io_hdr
operator|.
name|dma_bt
argument_list|)
expr_stmt|;
name|bintime_add
argument_list|(
operator|&
name|port
operator|->
name|stats
operator|.
name|time
index|[
name|type
index|]
argument_list|,
operator|&
name|bt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mtx_unlock
argument_list|(
operator|&
name|port
operator|->
name|port_lock
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Remove this from the OOA queue. 	 */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|lun
operator|->
name|ooa_queue
argument_list|,
operator|&
name|io
operator|->
name|io_hdr
argument_list|,
name|ooa_links
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CTL_TIME_IO
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|lun
operator|->
name|ooa_queue
argument_list|)
condition|)
name|lun
operator|->
name|last_busy
operator|=
name|getsbinuptime
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Run through the blocked queue on this LUN and see if anything 	 * has become unblocked, now that this transaction is done. 	 */
name|ctl_check_blocked
argument_list|(
name|lun
argument_list|)
expr_stmt|;
comment|/* 	 * If the LUN has been invalidated, free it if there is nothing 	 * left on its OOA queue. 	 */
if|if
condition|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_INVALID
operator|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|lun
operator|->
name|ooa_queue
argument_list|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|ctl_free_lun
argument_list|(
name|lun
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
block|}
else|else
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|bailout
label|:
comment|/* 	 * If this command has been aborted, make sure we set the status 	 * properly.  The FETD is responsible for freeing the I/O and doing 	 * whatever it needs to do to clean up its state. 	 */
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ABORT
condition|)
name|ctl_set_task_aborted
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
comment|/* 	 * If enabled, print command error status. 	 */
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|!=
name|CTL_SUCCESS
operator|&&
operator|(
name|ctl_debug
operator|&
name|CTL_DEBUG_INFO
operator|)
operator|!=
literal|0
condition|)
name|ctl_io_error_print
argument_list|(
name|io
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Tell the FETD or the other shelf controller we're done with this 	 * command.  Note that only SCSI commands get to this point.  Task 	 * management commands are completed above. 	 */
if|if
condition|(
operator|(
name|softc
operator|->
name|ha_mode
operator|!=
name|CTL_HA_MODE_XFER
operator|)
operator|&&
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_SENT_2OTHER_SC
operator|)
condition|)
block|{
name|memset
argument_list|(
operator|&
name|msg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|msg
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_FINISH_IO
expr_stmt|;
name|msg
operator|.
name|hdr
operator|.
name|serializing_sc
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|serializing_sc
expr_stmt|;
name|msg
operator|.
name|hdr
operator|.
name|nexus
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|nexus
expr_stmt|;
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
operator|.
name|scsi
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|msg
operator|.
name|scsi
operator|.
name|sense_data
argument_list|)
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
name|fe_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Front end should call this if it doesn't do autosense.  When the request  * sense comes back in from the initiator, we'll dequeue this and send it.  */
end_comment

begin_function
name|int
name|ctl_queue_sense
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|CTL_SOFTC
argument_list|(
name|io
argument_list|)
decl_stmt|;
name|struct
name|ctl_port
modifier|*
name|port
init|=
name|CTL_PORT
argument_list|(
name|io
argument_list|)
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|struct
name|scsi_sense_data
modifier|*
name|ps
decl_stmt|;
name|uint32_t
name|initidx
decl_stmt|,
name|p
decl_stmt|,
name|targ_lun
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_queue_sense\n"
operator|)
argument_list|)
expr_stmt|;
name|targ_lun
operator|=
name|ctl_lun_map_from_port
argument_list|(
name|port
argument_list|,
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_lun
argument_list|)
expr_stmt|;
comment|/* 	 * LUN lookup will likely move to the ctl_work_thread() once we 	 * have our new queueing infrastructure (that doesn't put things on 	 * a per-LUN queue initially).  That is so that we can handle 	 * things like an INQUIRY to a LUN that we don't have enabled.  We 	 * can't deal with that right now. 	 * If we don't have a LUN for this, just toss the sense information. 	 */
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|targ_lun
operator|>=
name|CTL_MAX_LUNS
operator|||
operator|(
name|lun
operator|=
name|softc
operator|->
name|ctl_luns
index|[
name|targ_lun
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|initidx
operator|=
name|ctl_get_initindex
argument_list|(
operator|&
name|io
operator|->
name|io_hdr
operator|.
name|nexus
argument_list|)
expr_stmt|;
name|p
operator|=
name|initidx
operator|/
name|CTL_MAX_INIT_PER_PORT
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|pending_sense
index|[
name|p
index|]
operator|==
name|NULL
condition|)
block|{
name|lun
operator|->
name|pending_sense
index|[
name|p
index|]
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ps
argument_list|)
operator|*
name|CTL_MAX_INIT_PER_PORT
argument_list|,
name|M_CTL
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ps
operator|=
name|lun
operator|->
name|pending_sense
index|[
name|p
index|]
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ps
operator|+=
name|initidx
operator|%
name|CTL_MAX_INIT_PER_PORT
expr_stmt|;
name|memset
argument_list|(
name|ps
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ps
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ps
argument_list|,
operator|&
name|io
operator|->
name|scsiio
operator|.
name|sense_data
argument_list|,
name|io
operator|->
name|scsiio
operator|.
name|sense_len
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|bailout
label|:
name|ctl_free_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Primary command inlet from frontend ports.  All SCSI and task I/O  * requests must go through this function.  */
end_comment

begin_function
name|int
name|ctl_queue
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_port
modifier|*
name|port
init|=
name|CTL_PORT
argument_list|(
name|io
argument_list|)
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_queue cdb[0]=%02X\n"
operator|,
name|io
operator|->
name|scsiio
operator|.
name|cdb
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CTL_TIME_IO
name|io
operator|->
name|io_hdr
operator|.
name|start_time
operator|=
name|time_uptime
expr_stmt|;
name|getbinuptime
argument_list|(
operator|&
name|io
operator|->
name|io_hdr
operator|.
name|start_bt
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CTL_TIME_IO */
comment|/* Map FE-specific LUN ID into global one. */
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_mapped_lun
operator|=
name|ctl_lun_map_from_port
argument_list|(
name|port
argument_list|,
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_lun
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|io_type
condition|)
block|{
case|case
name|CTL_IO_SCSI
case|:
case|case
name|CTL_IO_TASK
case|:
if|if
condition|(
name|ctl_debug
operator|&
name|CTL_DEBUG_CDB
condition|)
name|ctl_io_print
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|ctl_enqueue_incoming
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"ctl_queue: unknown I/O type %d\n"
argument_list|,
name|io
operator|->
name|io_hdr
operator|.
name|io_type
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CTL_IO_DELAY
end_ifdef

begin_function
specifier|static
name|void
name|ctl_done_timer_wakeup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|arg
expr_stmt|;
name|ctl_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CTL_IO_DELAY */
end_comment

begin_function
name|void
name|ctl_serseq_done
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
name|CTL_LUN
argument_list|(
name|io
argument_list|)
decl_stmt|;
empty_stmt|;
if|if
condition|(
name|lun
operator|->
name|be_lun
operator|==
name|NULL
operator|||
name|lun
operator|->
name|be_lun
operator|->
name|serseq
operator|==
name|CTL_LUN_SERSEQ_OFF
condition|)
return|return;
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_SERSEQ_DONE
expr_stmt|;
name|ctl_check_blocked
argument_list|(
name|lun
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ctl_done
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
comment|/* 	 * Enable this to catch duplicate completion issues. 	 */
if|#
directive|if
literal|0
block|if (io->io_hdr.flags& CTL_FLAG_ALREADY_DONE) { 		printf("%s: type %d msg %d cdb %x iptl: " 		       "%u:%u:%u tag 0x%04x " 		       "flag %#x status %x\n", 			__func__, 			io->io_hdr.io_type, 			io->io_hdr.msg_type, 			io->scsiio.cdb[0], 			io->io_hdr.nexus.initid, 			io->io_hdr.nexus.targ_port, 			io->io_hdr.nexus.targ_lun, 			(io->io_hdr.io_type == 			CTL_IO_TASK) ? 			io->taskio.tag_num : 			io->scsiio.tag_num, 		        io->io_hdr.flags, 			io->io_hdr.status); 	} else 		io->io_hdr.flags |= CTL_FLAG_ALREADY_DONE;
endif|#
directive|endif
comment|/* 	 * This is an internal copy of an I/O, and should not go through 	 * the normal done processing logic. 	 */
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_INT_COPY
condition|)
return|return;
ifdef|#
directive|ifdef
name|CTL_IO_DELAY
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_DELAY_DONE
condition|)
block|{
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&=
operator|~
name|CTL_FLAG_DELAY_DONE
expr_stmt|;
block|}
else|else
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
init|=
name|CTL_LUN
argument_list|(
name|io
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|lun
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|lun
operator|->
name|delay_info
operator|.
name|done_delay
operator|>
literal|0
operator|)
condition|)
block|{
name|callout_init
argument_list|(
operator|&
name|io
operator|->
name|io_hdr
operator|.
name|delay_callout
argument_list|,
comment|/*mpsafe*/
literal|1
argument_list|)
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_DELAY_DONE
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|io
operator|->
name|io_hdr
operator|.
name|delay_callout
argument_list|,
name|lun
operator|->
name|delay_info
operator|.
name|done_delay
operator|*
name|hz
argument_list|,
name|ctl_done_timer_wakeup
argument_list|,
name|io
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|delay_info
operator|.
name|done_type
operator|==
name|CTL_DELAY_TYPE_ONESHOT
condition|)
name|lun
operator|->
name|delay_info
operator|.
name|done_delay
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
comment|/* CTL_IO_DELAY */
name|ctl_enqueue_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_work_thread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ctl_thread
modifier|*
name|thr
init|=
operator|(
expr|struct
name|ctl_thread
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|thr
operator|->
name|ctl_softc
decl_stmt|;
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_work_thread starting\n"
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|softc
operator|->
name|shutdown
condition|)
block|{
comment|/* 		 * We handle the queues in this order: 		 * - ISC 		 * - done queue (to free up resources, unblock other commands) 		 * - RtR queue 		 * - incoming queue 		 * 		 * If those queues are empty, we break out of the loop and 		 * go to sleep. 		 */
name|mtx_lock
argument_list|(
operator|&
name|thr
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
name|io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|STAILQ_FIRST
argument_list|(
operator|&
name|thr
operator|->
name|isc_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|thr
operator|->
name|isc_queue
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|thr
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
name|ctl_handle_isc
argument_list|(
name|io
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|STAILQ_FIRST
argument_list|(
operator|&
name|thr
operator|->
name|done_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|thr
operator|->
name|done_queue
argument_list|,
name|links
argument_list|)
expr_stmt|;
comment|/* clear any blocked commands, call fe_done */
name|mtx_unlock
argument_list|(
operator|&
name|thr
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
name|ctl_process_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|STAILQ_FIRST
argument_list|(
operator|&
name|thr
operator|->
name|incoming_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|thr
operator|->
name|incoming_queue
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|thr
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|io_type
operator|==
name|CTL_IO_TASK
condition|)
name|ctl_run_task
argument_list|(
name|io
argument_list|)
expr_stmt|;
else|else
name|ctl_scsiio_precheck
argument_list|(
name|softc
argument_list|,
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|STAILQ_FIRST
argument_list|(
operator|&
name|thr
operator|->
name|rtr_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|thr
operator|->
name|rtr_queue
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|thr
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
name|retval
operator|=
name|ctl_scsiio
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|CTL_RETVAL_COMPLETE
condition|)
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_scsiio failed\n"
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Sleep until we have something to do. */
name|mtx_sleep
argument_list|(
name|thr
argument_list|,
operator|&
name|thr
operator|->
name|queue_lock
argument_list|,
name|PDROP
operator||
name|PRIBIO
argument_list|,
literal|"-"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|thr
operator|->
name|thread
operator|=
name|NULL
expr_stmt|;
name|kthread_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_lun_thread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
operator|(
expr|struct
name|ctl_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|ctl_be_lun
modifier|*
name|be_lun
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_lun_thread starting\n"
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|softc
operator|->
name|shutdown
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|be_lun
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|softc
operator|->
name|pending_lun_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|be_lun
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|softc
operator|->
name|pending_lun_queue
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|ctl_create_lun
argument_list|(
name|be_lun
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Sleep until we have something to do. */
name|mtx_sleep
argument_list|(
operator|&
name|softc
operator|->
name|pending_lun_queue
argument_list|,
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|,
name|PDROP
operator||
name|PRIBIO
argument_list|,
literal|"-"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|softc
operator|->
name|lun_thread
operator|=
name|NULL
expr_stmt|;
name|kthread_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_thresh_thread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
operator|(
expr|struct
name|ctl_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|struct
name|ctl_logical_block_provisioning_page
modifier|*
name|page
decl_stmt|;
specifier|const
name|char
modifier|*
name|attr
decl_stmt|;
name|union
name|ctl_ha_msg
name|msg
decl_stmt|;
name|uint64_t
name|thres
decl_stmt|,
name|val
decl_stmt|;
name|int
name|i
decl_stmt|,
name|e
decl_stmt|,
name|set
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_thresh_thread starting\n"
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|softc
operator|->
name|shutdown
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|lun
argument_list|,
argument|&softc->lun_list
argument_list|,
argument|links
argument_list|)
block|{
if|if
condition|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_DISABLED
operator|)
operator|||
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_NO_MEDIA
operator|)
operator|||
name|lun
operator|->
name|backend
operator|->
name|lun_attr
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_PRIMARY_SC
operator|)
operator|==
literal|0
operator|&&
name|softc
operator|->
name|ha_mode
operator|==
name|CTL_HA_MODE_XFER
condition|)
continue|continue;
if|if
condition|(
operator|(
name|lun
operator|->
name|MODE_RWER
operator|.
name|byte8
operator|&
name|SMS_RWER_LBPERE
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|e
operator|=
literal|0
expr_stmt|;
name|page
operator|=
operator|&
name|lun
operator|->
name|MODE_LBP
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_NUM_LBP_THRESH
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|page
operator|->
name|descr
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|SLBPPD_ENABLED
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|thres
operator|=
name|scsi_4btoul
argument_list|(
name|page
operator|->
name|descr
index|[
name|i
index|]
operator|.
name|count
argument_list|)
expr_stmt|;
name|thres
operator|<<=
name|CTL_LBP_EXPONENT
expr_stmt|;
switch|switch
condition|(
name|page
operator|->
name|descr
index|[
name|i
index|]
operator|.
name|resource
condition|)
block|{
case|case
literal|0x01
case|:
name|attr
operator|=
literal|"blocksavail"
expr_stmt|;
break|break;
case|case
literal|0x02
case|:
name|attr
operator|=
literal|"blocksused"
expr_stmt|;
break|break;
case|case
literal|0xf1
case|:
name|attr
operator|=
literal|"poolblocksavail"
expr_stmt|;
break|break;
case|case
literal|0xf2
case|:
name|attr
operator|=
literal|"poolblocksused"
expr_stmt|;
break|break;
default|default:
continue|continue;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
comment|// XXX
name|val
operator|=
name|lun
operator|->
name|backend
operator|->
name|lun_attr
argument_list|(
name|lun
operator|->
name|be_lun
operator|->
name|be_lun
argument_list|,
name|attr
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|UINT64_MAX
condition|)
continue|continue;
if|if
condition|(
operator|(
name|page
operator|->
name|descr
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|SLBPPD_ARMING_MASK
operator|)
operator|==
name|SLBPPD_ARMING_INC
condition|)
name|e
operator|=
operator|(
name|val
operator|>=
name|thres
operator|)
expr_stmt|;
else|else
name|e
operator|=
operator|(
name|val
operator|<=
name|thres
operator|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
break|break;
block|}
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
block|{
name|scsi_u64to8b
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|page
operator|->
name|descr
index|[
name|i
index|]
operator|-
operator|(
name|uint8_t
operator|*
operator|)
name|page
argument_list|,
name|lun
operator|->
name|ua_tpt_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|lasttpt
operator|==
literal|0
operator|||
name|time_uptime
operator|-
name|lun
operator|->
name|lasttpt
operator|>=
name|CTL_LBP_UA_PERIOD
condition|)
block|{
name|lun
operator|->
name|lasttpt
operator|=
name|time_uptime
expr_stmt|;
name|ctl_est_ua_all
argument_list|(
name|lun
argument_list|,
operator|-
literal|1
argument_list|,
name|CTL_UA_THIN_PROV_THRES
argument_list|)
expr_stmt|;
name|set
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|set
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|lun
operator|->
name|lasttpt
operator|=
literal|0
expr_stmt|;
name|ctl_clr_ua_all
argument_list|(
name|lun
argument_list|,
operator|-
literal|1
argument_list|,
name|CTL_UA_THIN_PROV_THRES
argument_list|)
expr_stmt|;
name|set
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|!=
literal|0
operator|&&
name|lun
operator|->
name|ctl_softc
operator|->
name|ha_mode
operator|==
name|CTL_HA_MODE_XFER
condition|)
block|{
comment|/* Send msg to other side. */
name|bzero
argument_list|(
operator|&
name|msg
operator|.
name|ua
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
operator|.
name|ua
argument_list|)
argument_list|)
expr_stmt|;
name|msg
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_UA
expr_stmt|;
name|msg
operator|.
name|hdr
operator|.
name|nexus
operator|.
name|initid
operator|=
operator|-
literal|1
expr_stmt|;
name|msg
operator|.
name|hdr
operator|.
name|nexus
operator|.
name|targ_port
operator|=
operator|-
literal|1
expr_stmt|;
name|msg
operator|.
name|hdr
operator|.
name|nexus
operator|.
name|targ_lun
operator|=
name|lun
operator|->
name|lun
expr_stmt|;
name|msg
operator|.
name|hdr
operator|.
name|nexus
operator|.
name|targ_mapped_lun
operator|=
name|lun
operator|->
name|lun
expr_stmt|;
name|msg
operator|.
name|ua
operator|.
name|ua_all
operator|=
literal|1
expr_stmt|;
name|msg
operator|.
name|ua
operator|.
name|ua_set
operator|=
operator|(
name|set
operator|>
literal|0
operator|)
expr_stmt|;
name|msg
operator|.
name|ua
operator|.
name|ua_type
operator|=
name|CTL_UA_THIN_PROV_THRES
expr_stmt|;
name|memcpy
argument_list|(
name|msg
operator|.
name|ua
operator|.
name|ua_info
argument_list|,
name|lun
operator|->
name|ua_tpt_info
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
comment|// XXX
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
operator|.
name|ua
argument_list|)
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_sleep
argument_list|(
operator|&
name|softc
operator|->
name|thresh_thread
argument_list|,
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|,
name|PDROP
operator||
name|PRIBIO
argument_list|,
literal|"-"
argument_list|,
name|CTL_LBP_PERIOD
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
name|softc
operator|->
name|thresh_thread
operator|=
name|NULL
expr_stmt|;
name|kthread_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_enqueue_incoming
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|CTL_SOFTC
argument_list|(
name|io
argument_list|)
decl_stmt|;
name|struct
name|ctl_thread
modifier|*
name|thr
decl_stmt|;
name|u_int
name|idx
decl_stmt|;
name|idx
operator|=
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
operator|*
literal|127
operator|+
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|initid
operator|)
operator|%
name|worker_threads
expr_stmt|;
name|thr
operator|=
operator|&
name|softc
operator|->
name|threads
index|[
name|idx
index|]
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|thr
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|thr
operator|->
name|incoming_queue
argument_list|,
operator|&
name|io
operator|->
name|io_hdr
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|thr
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|thr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_enqueue_rtr
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|CTL_SOFTC
argument_list|(
name|io
argument_list|)
decl_stmt|;
name|struct
name|ctl_thread
modifier|*
name|thr
decl_stmt|;
name|thr
operator|=
operator|&
name|softc
operator|->
name|threads
index|[
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_mapped_lun
operator|%
name|worker_threads
index|]
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|thr
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|thr
operator|->
name|rtr_queue
argument_list|,
operator|&
name|io
operator|->
name|io_hdr
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|thr
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|thr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_enqueue_done
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|CTL_SOFTC
argument_list|(
name|io
argument_list|)
decl_stmt|;
name|struct
name|ctl_thread
modifier|*
name|thr
decl_stmt|;
name|thr
operator|=
operator|&
name|softc
operator|->
name|threads
index|[
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_mapped_lun
operator|%
name|worker_threads
index|]
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|thr
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|thr
operator|->
name|done_queue
argument_list|,
operator|&
name|io
operator|->
name|io_hdr
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|thr
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|thr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_enqueue_isc
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|CTL_SOFTC
argument_list|(
name|io
argument_list|)
decl_stmt|;
name|struct
name|ctl_thread
modifier|*
name|thr
decl_stmt|;
name|thr
operator|=
operator|&
name|softc
operator|->
name|threads
index|[
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_mapped_lun
operator|%
name|worker_threads
index|]
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|thr
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|thr
operator|->
name|isc_queue
argument_list|,
operator|&
name|io
operator|->
name|io_hdr
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|thr
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|thr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  vim: ts=8  */
end_comment

end_unit

