begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003-2009 Silicon Graphics International Corp.  * Copyright (c) 2012 The FreeBSD Foundation  * All rights reserved.  *  * Portions of this software were developed by Edward Tomasz Napierala  * under sponsorship from the FreeBSD Foundation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    substantially similar to the "NO WARRANTY" disclaimer below  *    ("Disclaimer") and any redistribution must be conditioned upon  *    including a substantially similar Disclaimer requirement for further  *    binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGES.  *  * $Id: //depot/users/kenm/FreeBSD-test2/sys/cam/ctl/ctl.c#8 $  */
end_comment

begin_comment
comment|/*  * CAM Target Layer, a SCSI device emulation subsystem.  *  * Author: Ken Merry<ken@FreeBSD.org>  */
end_comment

begin_define
define|#
directive|define
name|_CTL_C
end_define

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_da.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_io.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_frontend.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_frontend_internal.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_util.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_backend.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_ha.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_private.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/ctl/ctl_error.h>
end_include

begin_decl_stmt
name|struct
name|ctl_softc
modifier|*
name|control_softc
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Size and alignment macros needed for Copan-specific HA hardware.  These  * can go away when the HA code is re-written, and uses busdma for any  * hardware.  */
end_comment

begin_define
define|#
directive|define
name|CTL_ALIGN_8B
parameter_list|(
name|target
parameter_list|,
name|source
parameter_list|,
name|type
parameter_list|)
define|\
value|if (((uint32_t)source& 0x7) != 0)				\ 		target = (type)(source + (0x8 - ((uint32_t)source& 0x7)));\ 	else								\ 		target = (type)source;
end_define

begin_define
define|#
directive|define
name|CTL_SIZE_8B
parameter_list|(
name|target
parameter_list|,
name|size
parameter_list|)
define|\
value|if ((size& 0x7) != 0)						\ 		target = size + (0x8 - (size& 0x7));			\ 	else								\ 		target = size;
end_define

begin_define
define|#
directive|define
name|CTL_ALIGN_8B_MARGIN
value|16
end_define

begin_comment
comment|/*  * Template mode pages.  */
end_comment

begin_comment
comment|/*  * Note that these are default values only.  The actual values will be  * filled in when the user does a mode sense.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|copan_power_subpage
name|power_page_default
init|=
block|{
comment|/*page_code*/
name|PWR_PAGE_CODE
operator||
name|SMPH_SPF
block|,
comment|/*subpage*/
name|PWR_SUBPAGE_CODE
block|,
comment|/*page_length*/
block|{
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|copan_power_subpage
argument_list|)
operator|-
literal|4
operator|)
operator|&
literal|0xff00
block|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|copan_power_subpage
argument_list|)
operator|-
literal|4
operator|)
operator|&
literal|0x00ff
block|}
block|,
comment|/*page_version*/
name|PWR_VERSION
block|,
comment|/* total_luns */
literal|26
block|,
comment|/* max_active_luns*/
name|PWR_DFLT_MAX_LUNS
block|,
comment|/*reserved*/
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|copan_power_subpage
name|power_page_changeable
init|=
block|{
comment|/*page_code*/
name|PWR_PAGE_CODE
operator||
name|SMPH_SPF
block|,
comment|/*subpage*/
name|PWR_SUBPAGE_CODE
block|,
comment|/*page_length*/
block|{
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|copan_power_subpage
argument_list|)
operator|-
literal|4
operator|)
operator|&
literal|0xff00
block|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|copan_power_subpage
argument_list|)
operator|-
literal|4
operator|)
operator|&
literal|0x00ff
block|}
block|,
comment|/*page_version*/
literal|0
block|,
comment|/* total_luns */
literal|0
block|,
comment|/* max_active_luns*/
literal|0
block|,
comment|/*reserved*/
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|copan_aps_subpage
name|aps_page_default
init|=
block|{
name|APS_PAGE_CODE
operator||
name|SMPH_SPF
block|,
comment|//page_code
name|APS_SUBPAGE_CODE
block|,
comment|//subpage
block|{
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|copan_aps_subpage
argument_list|)
operator|-
literal|4
operator|)
operator|&
literal|0xff00
block|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|copan_aps_subpage
argument_list|)
operator|-
literal|4
operator|)
operator|&
literal|0x00ff
block|}
block|,
comment|//page_length
name|APS_VERSION
block|,
comment|//page_version
literal|0
block|,
comment|//lock_active
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
comment|//reserved
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|copan_aps_subpage
name|aps_page_changeable
init|=
block|{
name|APS_PAGE_CODE
operator||
name|SMPH_SPF
block|,
comment|//page_code
name|APS_SUBPAGE_CODE
block|,
comment|//subpage
block|{
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|copan_aps_subpage
argument_list|)
operator|-
literal|4
operator|)
operator|&
literal|0xff00
block|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|copan_aps_subpage
argument_list|)
operator|-
literal|4
operator|)
operator|&
literal|0x00ff
block|}
block|,
comment|//page_length
literal|0
block|,
comment|//page_version
literal|0
block|,
comment|//lock_active
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
comment|//reserved
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|copan_debugconf_subpage
name|debugconf_page_default
init|=
block|{
name|DBGCNF_PAGE_CODE
operator||
name|SMPH_SPF
block|,
comment|/* page_code */
name|DBGCNF_SUBPAGE_CODE
block|,
comment|/* subpage */
block|{
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|copan_debugconf_subpage
argument_list|)
operator|-
literal|4
operator|)
operator|>>
literal|8
block|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|copan_debugconf_subpage
argument_list|)
operator|-
literal|4
operator|)
operator|>>
literal|0
block|}
block|,
comment|/* page_length */
name|DBGCNF_VERSION
block|,
comment|/* page_version */
block|{
name|CTL_TIME_IO_DEFAULT_SECS
operator|>>
literal|8
block|,
name|CTL_TIME_IO_DEFAULT_SECS
operator|>>
literal|0
block|}
block|,
comment|/* ctl_time_io_secs */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|copan_debugconf_subpage
name|debugconf_page_changeable
init|=
block|{
name|DBGCNF_PAGE_CODE
operator||
name|SMPH_SPF
block|,
comment|/* page_code */
name|DBGCNF_SUBPAGE_CODE
block|,
comment|/* subpage */
block|{
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|copan_debugconf_subpage
argument_list|)
operator|-
literal|4
operator|)
operator|>>
literal|8
block|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|copan_debugconf_subpage
argument_list|)
operator|-
literal|4
operator|)
operator|>>
literal|0
block|}
block|,
comment|/* page_length */
literal|0
block|,
comment|/* page_version */
block|{
literal|0xff
block|,
literal|0xff
block|}
block|,
comment|/* ctl_time_io_secs */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|scsi_format_page
name|format_page_default
init|=
block|{
comment|/*page_code*/
name|SMS_FORMAT_DEVICE_PAGE
block|,
comment|/*page_length*/
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_format_page
argument_list|)
operator|-
literal|2
block|,
comment|/*tracks_per_zone*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*alt_sectors_per_zone*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*alt_tracks_per_zone*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*alt_tracks_per_lun*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*sectors_per_track*/
block|{
operator|(
name|CTL_DEFAULT_SECTORS_PER_TRACK
operator|>>
literal|8
operator|)
operator|&
literal|0xff
block|,
name|CTL_DEFAULT_SECTORS_PER_TRACK
operator|&
literal|0xff
block|}
block|,
comment|/*bytes_per_sector*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*interleave*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*track_skew*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*cylinder_skew*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*flags*/
name|SFP_HSEC
block|,
comment|/*reserved*/
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|scsi_format_page
name|format_page_changeable
init|=
block|{
comment|/*page_code*/
name|SMS_FORMAT_DEVICE_PAGE
block|,
comment|/*page_length*/
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_format_page
argument_list|)
operator|-
literal|2
block|,
comment|/*tracks_per_zone*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*alt_sectors_per_zone*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*alt_tracks_per_zone*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*alt_tracks_per_lun*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*sectors_per_track*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*bytes_per_sector*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*interleave*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*track_skew*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*cylinder_skew*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*flags*/
literal|0
block|,
comment|/*reserved*/
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|scsi_rigid_disk_page
name|rigid_disk_page_default
init|=
block|{
comment|/*page_code*/
name|SMS_RIGID_DISK_PAGE
block|,
comment|/*page_length*/
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_rigid_disk_page
argument_list|)
operator|-
literal|2
block|,
comment|/*cylinders*/
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/*heads*/
name|CTL_DEFAULT_HEADS
block|,
comment|/*start_write_precomp*/
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/*start_reduced_current*/
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/*step_rate*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*landing_zone_cylinder*/
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/*rpl*/
name|SRDP_RPL_DISABLED
block|,
comment|/*rotational_offset*/
literal|0
block|,
comment|/*reserved1*/
literal|0
block|,
comment|/*rotation_rate*/
block|{
operator|(
name|CTL_DEFAULT_ROTATION_RATE
operator|>>
literal|8
operator|)
operator|&
literal|0xff
block|,
name|CTL_DEFAULT_ROTATION_RATE
operator|&
literal|0xff
block|}
block|,
comment|/*reserved2*/
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|scsi_rigid_disk_page
name|rigid_disk_page_changeable
init|=
block|{
comment|/*page_code*/
name|SMS_RIGID_DISK_PAGE
block|,
comment|/*page_length*/
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_rigid_disk_page
argument_list|)
operator|-
literal|2
block|,
comment|/*cylinders*/
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/*heads*/
literal|0
block|,
comment|/*start_write_precomp*/
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/*start_reduced_current*/
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/*step_rate*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*landing_zone_cylinder*/
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/*rpl*/
literal|0
block|,
comment|/*rotational_offset*/
literal|0
block|,
comment|/*reserved1*/
literal|0
block|,
comment|/*rotation_rate*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*reserved2*/
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|scsi_caching_page
name|caching_page_default
init|=
block|{
comment|/*page_code*/
name|SMS_CACHING_PAGE
block|,
comment|/*page_length*/
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_caching_page
argument_list|)
operator|-
literal|2
block|,
comment|/*flags1*/
name|SCP_DISC
operator||
name|SCP_WCE
block|,
comment|/*ret_priority*/
literal|0
block|,
comment|/*disable_pf_transfer_len*/
block|{
literal|0xff
block|,
literal|0xff
block|}
block|,
comment|/*min_prefetch*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*max_prefetch*/
block|{
literal|0xff
block|,
literal|0xff
block|}
block|,
comment|/*max_pf_ceiling*/
block|{
literal|0xff
block|,
literal|0xff
block|}
block|,
comment|/*flags2*/
literal|0
block|,
comment|/*cache_segments*/
literal|0
block|,
comment|/*cache_seg_size*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*reserved*/
literal|0
block|,
comment|/*non_cache_seg_size*/
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|scsi_caching_page
name|caching_page_changeable
init|=
block|{
comment|/*page_code*/
name|SMS_CACHING_PAGE
block|,
comment|/*page_length*/
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_caching_page
argument_list|)
operator|-
literal|2
block|,
comment|/*flags1*/
name|SCP_WCE
operator||
name|SCP_RCD
block|,
comment|/*ret_priority*/
literal|0
block|,
comment|/*disable_pf_transfer_len*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*min_prefetch*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*max_prefetch*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*max_pf_ceiling*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*flags2*/
literal|0
block|,
comment|/*cache_segments*/
literal|0
block|,
comment|/*cache_seg_size*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*reserved*/
literal|0
block|,
comment|/*non_cache_seg_size*/
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|scsi_control_page
name|control_page_default
init|=
block|{
comment|/*page_code*/
name|SMS_CONTROL_MODE_PAGE
block|,
comment|/*page_length*/
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_control_page
argument_list|)
operator|-
literal|2
block|,
comment|/*rlec*/
literal|0
block|,
comment|/*queue_flags*/
name|SCP_QUEUE_ALG_RESTRICTED
block|,
comment|/*eca_and_aen*/
literal|0
block|,
comment|/*flags4*/
name|SCP_TAS
block|,
comment|/*aen_holdoff_period*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*busy_timeout_period*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*extended_selftest_completion_time*/
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|scsi_control_page
name|control_page_changeable
init|=
block|{
comment|/*page_code*/
name|SMS_CONTROL_MODE_PAGE
block|,
comment|/*page_length*/
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_control_page
argument_list|)
operator|-
literal|2
block|,
comment|/*rlec*/
name|SCP_DSENSE
block|,
comment|/*queue_flags*/
name|SCP_QUEUE_ALG_MASK
block|,
comment|/*eca_and_aen*/
name|SCP_SWP
block|,
comment|/*flags4*/
literal|0
block|,
comment|/*aen_holdoff_period*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*busy_timeout_period*/
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*extended_selftest_completion_time*/
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * XXX KDM move these into the softc.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|rcv_sync_msg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|persis_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint8_t
name|ctl_pause_rtr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ctl_is_single
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|index_to_aps_page
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_kern_cam
argument_list|,
name|OID_AUTO
argument_list|,
name|ctl
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"CAM Target Layer"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|worker_threads
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"kern.cam.ctl.worker_threads"
argument_list|,
operator|&
name|worker_threads
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_cam_ctl
argument_list|,
name|OID_AUTO
argument_list|,
name|worker_threads
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|worker_threads
argument_list|,
literal|1
argument_list|,
literal|"Number of worker threads"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"kern.cam.ctl.verbose"
argument_list|,
operator|&
name|verbose
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_cam_ctl
argument_list|,
name|OID_AUTO
argument_list|,
name|verbose
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|verbose
argument_list|,
literal|0
argument_list|,
literal|"Show SCSI errors returned to initiator"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Supported pages (0x00), Serial number (0x80), Device ID (0x83),  * Extended INQUIRY Data (0x86), Mode Page Policy (0x87),  * SCSI Ports (0x88), Third-party Copy (0x8F), Block limits (0xB0),  * Block Device Characteristics (0xB1) and Logical Block Provisioning (0xB2)  */
end_comment

begin_define
define|#
directive|define
name|SCSI_EVPD_NUM_SUPPORTED_PAGES
value|10
end_define

begin_function_decl
specifier|static
name|void
name|ctl_isc_event_handler
parameter_list|(
name|ctl_ha_channel
name|chanel
parameter_list|,
name|ctl_ha_event
name|event
parameter_list|,
name|int
name|param
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_copy_sense_data
parameter_list|(
name|union
name|ctl_ha_msg
modifier|*
name|src
parameter_list|,
name|union
name|ctl_io
modifier|*
name|dest
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ctl_shutdown
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_ioctl_online
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_ioctl_offline
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_ioctl_lun_enable
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ctl_id
name|targ_id
parameter_list|,
name|int
name|lun_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_ioctl_lun_disable
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ctl_id
name|targ_id
parameter_list|,
name|int
name|lun_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_ioctl_do_datamove
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_serialize_other_sc_cmd
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_ioctl_submit_wait
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_ioctl_datamove
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_ioctl_done
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_ioctl_hard_startstop_callback
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|cfi_metatask
modifier|*
name|metatask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_ioctl_bbrread_callback
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|cfi_metatask
modifier|*
name|metatask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_ioctl_fill_ooa
parameter_list|(
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|,
name|uint32_t
modifier|*
name|cur_fill_num
parameter_list|,
name|struct
name|ctl_ooa
modifier|*
name|ooa_hdr
parameter_list|,
name|struct
name|ctl_ooa_entry
modifier|*
name|kern_entries
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|ctl_map_lun
parameter_list|(
name|int
name|port_num
parameter_list|,
name|uint32_t
name|lun
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|ctl_map_lun_back
parameter_list|(
name|int
name|port_num
parameter_list|,
name|uint32_t
name|lun
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|unused
end_ifdef

begin_function_decl
specifier|static
name|union
name|ctl_io
modifier|*
name|ctl_malloc_io
parameter_list|(
name|ctl_io_type
name|io_type
parameter_list|,
name|uint32_t
name|targ_port
parameter_list|,
name|uint32_t
name|targ_target
parameter_list|,
name|uint32_t
name|targ_lun
parameter_list|,
name|int
name|can_wait
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_kfree_io
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* unused */
end_comment

begin_function_decl
specifier|static
name|int
name|ctl_alloc_lun
parameter_list|(
name|struct
name|ctl_softc
modifier|*
name|ctl_softc
parameter_list|,
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|,
name|struct
name|ctl_be_lun
modifier|*
name|be_lun
parameter_list|,
name|struct
name|ctl_id
name|target_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_free_lun
parameter_list|(
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_create_lun
parameter_list|(
name|struct
name|ctl_be_lun
modifier|*
name|be_lun
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/** static void ctl_failover_change_pages(struct ctl_softc *softc, 				      struct ctl_scsiio *ctsio, int master); **/
end_comment

begin_function_decl
specifier|static
name|int
name|ctl_do_mode_select
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_pro_preempt
parameter_list|(
name|struct
name|ctl_softc
modifier|*
name|softc
parameter_list|,
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|,
name|uint64_t
name|res_key
parameter_list|,
name|uint64_t
name|sa_res_key
parameter_list|,
name|uint8_t
name|type
parameter_list|,
name|uint32_t
name|residx
parameter_list|,
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|struct
name|scsi_per_res_out
modifier|*
name|cdb
parameter_list|,
name|struct
name|scsi_per_res_out_parms
modifier|*
name|param
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_pro_preempt_other
parameter_list|(
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|,
name|union
name|ctl_ha_msg
modifier|*
name|msg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_hndl_per_res_out_on_other_sc
parameter_list|(
name|union
name|ctl_ha_msg
modifier|*
name|msg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_inquiry_evpd_supported
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|int
name|alloc_len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_inquiry_evpd_serial
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|int
name|alloc_len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_inquiry_evpd_devid
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|int
name|alloc_len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_inquiry_evpd_eid
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|int
name|alloc_len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_inquiry_evpd_mpp
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|int
name|alloc_len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_inquiry_evpd_scsi_ports
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|int
name|alloc_len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_inquiry_evpd_block_limits
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|int
name|alloc_len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_inquiry_evpd_bdc
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|int
name|alloc_len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_inquiry_evpd_lbp
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|int
name|alloc_len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_inquiry_evpd
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_inquiry_std
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_get_lba_len
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|,
name|uint64_t
modifier|*
name|lba
parameter_list|,
name|uint64_t
modifier|*
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ctl_action
name|ctl_extent_check
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io1
parameter_list|,
name|union
name|ctl_io
modifier|*
name|io2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ctl_action
name|ctl_check_for_blockage
parameter_list|(
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|,
name|union
name|ctl_io
modifier|*
name|pending_io
parameter_list|,
name|union
name|ctl_io
modifier|*
name|ooa_io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ctl_action
name|ctl_check_ooa
parameter_list|(
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|,
name|union
name|ctl_io
modifier|*
name|pending_io
parameter_list|,
name|union
name|ctl_io
modifier|*
name|starting_io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_check_blocked
parameter_list|(
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_scsiio_lun_check
parameter_list|(
name|struct
name|ctl_softc
modifier|*
name|ctl_softc
parameter_list|,
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|,
specifier|const
name|struct
name|ctl_cmd_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|//static int ctl_check_rtr(union ctl_io *pending_io, struct ctl_softc *softc);
end_comment

begin_function_decl
specifier|static
name|void
name|ctl_failover
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_scsiio_precheck
parameter_list|(
name|struct
name|ctl_softc
modifier|*
name|ctl_softc
parameter_list|,
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_scsiio
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_bus_reset
parameter_list|(
name|struct
name|ctl_softc
modifier|*
name|ctl_softc
parameter_list|,
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_target_reset
parameter_list|(
name|struct
name|ctl_softc
modifier|*
name|ctl_softc
parameter_list|,
name|union
name|ctl_io
modifier|*
name|io
parameter_list|,
name|ctl_ua_type
name|ua_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_lun_reset
parameter_list|(
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|,
name|union
name|ctl_io
modifier|*
name|io
parameter_list|,
name|ctl_ua_type
name|ua_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_abort_task
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_abort_task_set
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_i_t_nexus_reset
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_run_task
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|CTL_IO_DELAY
end_ifdef

begin_function_decl
specifier|static
name|void
name|ctl_datamove_timer_wakeup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_done_timer_wakeup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CTL_IO_DELAY */
end_comment

begin_function_decl
specifier|static
name|void
name|ctl_send_datamove_done
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|,
name|int
name|have_lock
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_datamove_remote_write_cb
parameter_list|(
name|struct
name|ctl_ha_dt_req
modifier|*
name|rq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_datamove_remote_dm_write_cb
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_datamove_remote_write
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_datamove_remote_dm_read_cb
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_datamove_remote_read_cb
parameter_list|(
name|struct
name|ctl_ha_dt_req
modifier|*
name|rq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_datamove_remote_sgl_setup
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_datamove_remote_xfer
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|,
name|unsigned
name|command
parameter_list|,
name|ctl_ha_dt_cb
name|callback
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_datamove_remote_read
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_datamove_remote
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_process_done
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_lun_thread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_work_thread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_enqueue_incoming
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_enqueue_rtr
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_enqueue_done
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_enqueue_isc
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|struct
name|ctl_cmd_entry
modifier|*
name|ctl_get_cmd_entry
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|int
modifier|*
name|sa
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|struct
name|ctl_cmd_entry
modifier|*
name|ctl_validate_command
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ctl_cmd_applicable
parameter_list|(
name|uint8_t
name|lun_type
parameter_list|,
specifier|const
name|struct
name|ctl_cmd_entry
modifier|*
name|entry
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Load the serialization table.  This isn't very pretty, but is probably  * the easiest way to do it.  */
end_comment

begin_include
include|#
directive|include
file|"ctl_ser_table.c"
end_include

begin_comment
comment|/*  * We only need to define open, close and ioctl routines for this driver.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|ctl_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_flags
operator|=
literal|0
block|,
operator|.
name|d_open
operator|=
name|ctl_open
block|,
operator|.
name|d_close
operator|=
name|ctl_close
block|,
operator|.
name|d_ioctl
operator|=
name|ctl_ioctl
block|,
operator|.
name|d_name
operator|=
literal|"ctl"
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_CTL
argument_list|,
literal|"ctlmem"
argument_list|,
literal|"Memory used for CTL"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_CTLIO
argument_list|,
literal|"ctlio"
argument_list|,
literal|"Memory used for CTL requests"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|ctl_module_event_handler
parameter_list|(
name|module_t
parameter_list|,
name|int
comment|/*modeventtype_t*/
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|moduledata_t
name|ctl_moduledata
init|=
block|{
literal|"ctl"
block|,
name|ctl_module_event_handler
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|ctl
argument_list|,
name|ctl_moduledata
argument_list|,
name|SI_SUB_CONFIGURE
argument_list|,
name|SI_ORDER_THIRD
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|ctl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|ctl_frontend
name|ioctl_frontend
init|=
block|{
operator|.
name|name
operator|=
literal|"ioctl"
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|ctl_isc_handler_finish_xfer
parameter_list|(
name|struct
name|ctl_softc
modifier|*
name|ctl_softc
parameter_list|,
name|union
name|ctl_ha_msg
modifier|*
name|msg_info
parameter_list|)
block|{
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
decl_stmt|;
if|if
condition|(
name|msg_info
operator|->
name|hdr
operator|.
name|original_sc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: original_sc == NULL!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* XXX KDM now what? */
return|return;
block|}
name|ctsio
operator|=
operator|&
name|msg_info
operator|->
name|hdr
operator|.
name|original_sc
operator|->
name|scsiio
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_IO_ACTIVE
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_FINISH_IO
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|status
operator|=
name|msg_info
operator|->
name|hdr
operator|.
name|status
expr_stmt|;
name|ctsio
operator|->
name|scsi_status
operator|=
name|msg_info
operator|->
name|scsi
operator|.
name|scsi_status
expr_stmt|;
name|ctsio
operator|->
name|sense_len
operator|=
name|msg_info
operator|->
name|scsi
operator|.
name|sense_len
expr_stmt|;
name|ctsio
operator|->
name|sense_residual
operator|=
name|msg_info
operator|->
name|scsi
operator|.
name|sense_residual
expr_stmt|;
name|ctsio
operator|->
name|residual
operator|=
name|msg_info
operator|->
name|scsi
operator|.
name|residual
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ctsio
operator|->
name|sense_data
argument_list|,
operator|&
name|msg_info
operator|->
name|scsi
operator|.
name|sense_data
argument_list|,
sizeof|sizeof
argument_list|(
name|ctsio
operator|->
name|sense_data
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LBA_LEN
index|]
operator|.
name|bytes
argument_list|,
operator|&
name|msg_info
operator|->
name|scsi
operator|.
name|lbalen
argument_list|,
sizeof|sizeof
argument_list|(
name|msg_info
operator|->
name|scsi
operator|.
name|lbalen
argument_list|)
argument_list|)
expr_stmt|;
name|ctl_enqueue_isc
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_isc_handler_finish_ser_only
parameter_list|(
name|struct
name|ctl_softc
modifier|*
name|ctl_softc
parameter_list|,
name|union
name|ctl_ha_msg
modifier|*
name|msg_info
parameter_list|)
block|{
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
decl_stmt|;
if|if
condition|(
name|msg_info
operator|->
name|hdr
operator|.
name|serializing_sc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: serializing_sc == NULL!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* XXX KDM now what? */
return|return;
block|}
name|ctsio
operator|=
operator|&
name|msg_info
operator|->
name|hdr
operator|.
name|serializing_sc
operator|->
name|scsiio
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 	 * Attempt to catch the situation where an I/O has 	 * been freed, and we're using it again. 	 */
block|if (ctsio->io_hdr.io_type == 0xff) { 		union ctl_io *tmp_io; 		tmp_io = (union ctl_io *)ctsio; 		printf("%s: %p use after free!\n", __func__, 		       ctsio); 		printf("%s: type %d msg %d cdb %x iptl: " 		       "%d:%d:%d:%d tag 0x%04x " 		       "flag %#x status %x\n", 			__func__, 			tmp_io->io_hdr.io_type, 			tmp_io->io_hdr.msg_type, 			tmp_io->scsiio.cdb[0], 			tmp_io->io_hdr.nexus.initid.id, 			tmp_io->io_hdr.nexus.targ_port, 			tmp_io->io_hdr.nexus.targ_target.id, 			tmp_io->io_hdr.nexus.targ_lun, 			(tmp_io->io_hdr.io_type == 			CTL_IO_TASK) ? 			tmp_io->taskio.tag_num : 			tmp_io->scsiio.tag_num, 		        tmp_io->io_hdr.flags, 			tmp_io->io_hdr.status); 	}
endif|#
directive|endif
name|ctsio
operator|->
name|io_hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_FINISH_IO
expr_stmt|;
name|ctl_enqueue_isc
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ISC (Inter Shelf Communication) event handler.  Events from the HA  * subsystem come in here.  */
end_comment

begin_function
specifier|static
name|void
name|ctl_isc_event_handler
parameter_list|(
name|ctl_ha_channel
name|channel
parameter_list|,
name|ctl_ha_event
name|event
parameter_list|,
name|int
name|param
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|ctl_softc
decl_stmt|;
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|struct
name|ctl_prio
modifier|*
name|presio
decl_stmt|;
name|ctl_ha_status
name|isc_status
decl_stmt|;
name|ctl_softc
operator|=
name|control_softc
expr_stmt|;
name|io
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
literal|0
block|printf("CTL: Isc Msg event %d\n", event);
endif|#
directive|endif
if|if
condition|(
name|event
operator|==
name|CTL_HA_EVT_MSG_RECV
condition|)
block|{
name|union
name|ctl_ha_msg
name|msg_info
decl_stmt|;
name|isc_status
operator|=
name|ctl_ha_msg_recv
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|msg_info
argument_list|,
sizeof|sizeof
argument_list|(
name|msg_info
argument_list|)
argument_list|,
comment|/*wait*/
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf("CTL: msg_type %d\n", msg_info.msg_type);
endif|#
directive|endif
if|if
condition|(
name|isc_status
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Error receiving message, status = %d\n"
argument_list|,
name|isc_status
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|msg_info
operator|.
name|hdr
operator|.
name|msg_type
condition|)
block|{
case|case
name|CTL_MSG_SERIALIZE
case|:
if|#
directive|if
literal|0
block|printf("Serialize\n");
endif|#
directive|endif
name|io
operator|=
name|ctl_alloc_io
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ctl_softc
operator|->
name|othersc_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ctl_isc_event_handler: can't allocate "
literal|"ctl_io!\n"
argument_list|)
expr_stmt|;
comment|/* Bad Juju */
comment|/* Need to set busy and send msg back */
name|msg_info
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_BAD_JUJU
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|status
operator|=
name|CTL_SCSI_ERROR
expr_stmt|;
name|msg_info
operator|.
name|scsi
operator|.
name|scsi_status
operator|=
name|SCSI_STATUS_BUSY
expr_stmt|;
name|msg_info
operator|.
name|scsi
operator|.
name|sense_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|msg_info
argument_list|,
sizeof|sizeof
argument_list|(
name|msg_info
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|>
name|CTL_HA_STATUS_SUCCESS
condition|)
block|{ 				}
goto|goto
name|bailout
goto|;
block|}
name|ctl_zero_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
comment|// populate ctsio from msg_info
name|io
operator|->
name|io_hdr
operator|.
name|io_type
operator|=
name|CTL_IO_SCSI
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_SERIALIZE
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|original_sc
operator|=
name|msg_info
operator|.
name|hdr
operator|.
name|original_sc
expr_stmt|;
if|#
directive|if
literal|0
block|printf("pOrig %x\n", (int)msg_info.original_sc);
endif|#
directive|endif
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_FROM_OTHER_SC
operator||
name|CTL_FLAG_IO_ACTIVE
expr_stmt|;
comment|/* 			 * If we're in serialization-only mode, we don't 			 * want to go through full done processing.  Thus 			 * the COPY flag. 			 * 			 * XXX KDM add another flag that is more specific. 			 */
if|if
condition|(
name|ctl_softc
operator|->
name|ha_mode
operator|==
name|CTL_HA_MODE_SER_ONLY
condition|)
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_INT_COPY
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|=
name|msg_info
operator|.
name|hdr
operator|.
name|nexus
expr_stmt|;
if|#
directive|if
literal|0
block|printf("targ %d, port %d, iid %d, lun %d\n", 			       io->io_hdr.nexus.targ_target.id, 			       io->io_hdr.nexus.targ_port, 			       io->io_hdr.nexus.initid.id, 			       io->io_hdr.nexus.targ_lun);
endif|#
directive|endif
name|io
operator|->
name|scsiio
operator|.
name|tag_num
operator|=
name|msg_info
operator|.
name|scsi
operator|.
name|tag_num
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|tag_type
operator|=
name|msg_info
operator|.
name|scsi
operator|.
name|tag_type
expr_stmt|;
name|memcpy
argument_list|(
name|io
operator|->
name|scsiio
operator|.
name|cdb
argument_list|,
name|msg_info
operator|.
name|scsi
operator|.
name|cdb
argument_list|,
name|CTL_MAX_CDBLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl_softc
operator|->
name|ha_mode
operator|==
name|CTL_HA_MODE_XFER
condition|)
block|{
specifier|const
name|struct
name|ctl_cmd_entry
modifier|*
name|entry
decl_stmt|;
name|entry
operator|=
name|ctl_get_cmd_entry
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&=
operator|~
name|CTL_FLAG_DATA_MASK
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|entry
operator|->
name|flags
operator|&
name|CTL_FLAG_DATA_MASK
expr_stmt|;
block|}
name|ctl_enqueue_isc
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
comment|/* Performed on the Originating SC, XFER mode only */
case|case
name|CTL_MSG_DATAMOVE
case|:
block|{
name|struct
name|ctl_sg_entry
modifier|*
name|sgl
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|io
operator|=
name|msg_info
operator|.
name|hdr
operator|.
name|original_sc
expr_stmt|;
if|if
condition|(
name|io
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: original_sc == NULL!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* XXX KDM do something here */
break|break;
block|}
name|io
operator|->
name|io_hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_DATAMOVE
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_IO_ACTIVE
expr_stmt|;
comment|/* 			 * Keep track of this, we need to send it back over 			 * when the datamove is complete. 			 */
name|io
operator|->
name|io_hdr
operator|.
name|serializing_sc
operator|=
name|msg_info
operator|.
name|hdr
operator|.
name|serializing_sc
expr_stmt|;
if|if
condition|(
name|msg_info
operator|.
name|dt
operator|.
name|sg_sequence
operator|==
literal|0
condition|)
block|{
comment|/* 				 * XXX KDM we use the preallocated S/G list 				 * here, but we'll need to change this to 				 * dynamic allocation if we need larger S/G 				 * lists. 				 */
if|if
condition|(
name|msg_info
operator|.
name|dt
operator|.
name|kern_sg_entries
operator|>
sizeof|sizeof
argument_list|(
name|io
operator|->
name|io_hdr
operator|.
name|remote_sglist
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|io
operator|->
name|io_hdr
operator|.
name|remote_sglist
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: number of S/G entries "
literal|"needed %u> allocated num %zd\n"
argument_list|,
name|__func__
argument_list|,
name|msg_info
operator|.
name|dt
operator|.
name|kern_sg_entries
argument_list|,
sizeof|sizeof
argument_list|(
name|io
operator|->
name|io_hdr
operator|.
name|remote_sglist
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|io
operator|->
name|io_hdr
operator|.
name|remote_sglist
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 					 * XXX KDM send a message back to 					 * the other side to shut down the 					 * DMA.  The error will come back 					 * through via the normal channel. 					 */
break|break;
block|}
name|sgl
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|remote_sglist
expr_stmt|;
name|memset
argument_list|(
name|sgl
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|io
operator|->
name|io_hdr
operator|.
name|remote_sglist
argument_list|)
argument_list|)
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|kern_data_ptr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|sgl
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|kern_sg_entries
operator|=
name|msg_info
operator|.
name|dt
operator|.
name|kern_sg_entries
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|rem_sg_entries
operator|=
name|msg_info
operator|.
name|dt
operator|.
name|kern_sg_entries
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|kern_data_len
operator|=
name|msg_info
operator|.
name|dt
operator|.
name|kern_data_len
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|kern_total_len
operator|=
name|msg_info
operator|.
name|dt
operator|.
name|kern_total_len
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|kern_data_resid
operator|=
name|msg_info
operator|.
name|dt
operator|.
name|kern_data_resid
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|kern_rel_offset
operator|=
name|msg_info
operator|.
name|dt
operator|.
name|kern_rel_offset
expr_stmt|;
comment|/* 				 * Clear out per-DMA flags. 				 */
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&=
operator|~
name|CTL_FLAG_RDMA_MASK
expr_stmt|;
comment|/* 				 * Add per-DMA flags that are set for this 				 * particular DMA request. 				 */
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|msg_info
operator|.
name|dt
operator|.
name|flags
operator|&
name|CTL_FLAG_RDMA_MASK
expr_stmt|;
block|}
else|else
name|sgl
operator|=
operator|(
expr|struct
name|ctl_sg_entry
operator|*
operator|)
name|io
operator|->
name|scsiio
operator|.
name|kern_data_ptr
expr_stmt|;
for|for
control|(
name|i
operator|=
name|msg_info
operator|.
name|dt
operator|.
name|sent_sg_entries
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|msg_info
operator|.
name|dt
operator|.
name|sent_sg_entries
operator|+
name|msg_info
operator|.
name|dt
operator|.
name|cur_sg_entries
operator|)
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
name|sgl
index|[
name|i
index|]
operator|.
name|addr
operator|=
name|msg_info
operator|.
name|dt
operator|.
name|sg_list
index|[
name|j
index|]
operator|.
name|addr
expr_stmt|;
name|sgl
index|[
name|i
index|]
operator|.
name|len
operator|=
name|msg_info
operator|.
name|dt
operator|.
name|sg_list
index|[
name|j
index|]
operator|.
name|len
expr_stmt|;
if|#
directive|if
literal|0
block|printf("%s: L: %p,%d -> %p,%d j=%d, i=%d\n", 				       __func__, 				       msg_info.dt.sg_list[j].addr, 				       msg_info.dt.sg_list[j].len, 				       sgl[i].addr, sgl[i].len, j, i);
endif|#
directive|endif
block|}
if|#
directive|if
literal|0
block|memcpy(&sgl[msg_info.dt.sent_sg_entries], 			       msg_info.dt.sg_list, 			       sizeof(*sgl) * msg_info.dt.cur_sg_entries);
endif|#
directive|endif
comment|/* 			 * If this is the last piece of the I/O, we've got 			 * the full S/G list.  Queue processing in the thread. 			 * Otherwise wait for the next piece. 			 */
if|if
condition|(
name|msg_info
operator|.
name|dt
operator|.
name|sg_last
operator|!=
literal|0
condition|)
name|ctl_enqueue_isc
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Performed on the Serializing (primary) SC, XFER mode only */
case|case
name|CTL_MSG_DATAMOVE_DONE
case|:
block|{
if|if
condition|(
name|msg_info
operator|.
name|hdr
operator|.
name|serializing_sc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: serializing_sc == NULL!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* XXX KDM now what? */
break|break;
block|}
comment|/* 			 * We grab the sense information here in case 			 * there was a failure, so we can return status 			 * back to the initiator. 			 */
name|io
operator|=
name|msg_info
operator|.
name|hdr
operator|.
name|serializing_sc
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_DATAMOVE_DONE
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|=
name|msg_info
operator|.
name|hdr
operator|.
name|status
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|scsi_status
operator|=
name|msg_info
operator|.
name|scsi
operator|.
name|scsi_status
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|sense_len
operator|=
name|msg_info
operator|.
name|scsi
operator|.
name|sense_len
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|sense_residual
operator|=
name|msg_info
operator|.
name|scsi
operator|.
name|sense_residual
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|port_status
operator|=
name|msg_info
operator|.
name|scsi
operator|.
name|fetd_status
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|residual
operator|=
name|msg_info
operator|.
name|scsi
operator|.
name|residual
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|io
operator|->
name|scsiio
operator|.
name|sense_data
argument_list|,
operator|&
name|msg_info
operator|.
name|scsi
operator|.
name|sense_data
argument_list|,
sizeof|sizeof
argument_list|(
name|io
operator|->
name|scsiio
operator|.
name|sense_data
argument_list|)
argument_list|)
expr_stmt|;
name|ctl_enqueue_isc
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Preformed on Originating SC, SER_ONLY mode */
case|case
name|CTL_MSG_R2R
case|:
name|io
operator|=
name|msg_info
operator|.
name|hdr
operator|.
name|original_sc
expr_stmt|;
if|if
condition|(
name|io
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Major Bummer\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
if|#
directive|if
literal|0
block|printf("pOrig %x\n",(int) ctsio);
endif|#
directive|endif
block|}
name|io
operator|->
name|io_hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_R2R
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|serializing_sc
operator|=
name|msg_info
operator|.
name|hdr
operator|.
name|serializing_sc
expr_stmt|;
name|ctl_enqueue_isc
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * Performed on Serializing(i.e. primary SC) SC in SER_ONLY 		 * mode. 		 * Performed on the Originating (i.e. secondary) SC in XFER 		 * mode 		 */
case|case
name|CTL_MSG_FINISH_IO
case|:
if|if
condition|(
name|ctl_softc
operator|->
name|ha_mode
operator|==
name|CTL_HA_MODE_XFER
condition|)
name|ctl_isc_handler_finish_xfer
argument_list|(
name|ctl_softc
argument_list|,
operator|&
name|msg_info
argument_list|)
expr_stmt|;
else|else
name|ctl_isc_handler_finish_ser_only
argument_list|(
name|ctl_softc
argument_list|,
operator|&
name|msg_info
argument_list|)
expr_stmt|;
break|break;
comment|/* Preformed on Originating SC */
case|case
name|CTL_MSG_BAD_JUJU
case|:
name|io
operator|=
name|msg_info
operator|.
name|hdr
operator|.
name|original_sc
expr_stmt|;
if|if
condition|(
name|io
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Bad JUJU!, original_sc is NULL!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
break|break;
block|}
name|ctl_copy_sense_data
argument_list|(
operator|&
name|msg_info
argument_list|,
name|io
argument_list|)
expr_stmt|;
comment|/* 			 * IO should have already been cleaned up on other 			 * SC so clear this flag so we won't send a message 			 * back to finish the IO there. 			 */
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&=
operator|~
name|CTL_FLAG_SENT_2OTHER_SC
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_IO_ACTIVE
expr_stmt|;
comment|/* io = msg_info.hdr.serializing_sc; */
name|io
operator|->
name|io_hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_BAD_JUJU
expr_stmt|;
name|ctl_enqueue_isc
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
comment|/* Handle resets sent from the other side */
case|case
name|CTL_MSG_MANAGE_TASKS
case|:
block|{
name|struct
name|ctl_taskio
modifier|*
name|taskio
decl_stmt|;
name|taskio
operator|=
operator|(
expr|struct
name|ctl_taskio
operator|*
operator|)
name|ctl_alloc_io
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ctl_softc
operator|->
name|othersc_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|taskio
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ctl_isc_event_handler: can't allocate "
literal|"ctl_io!\n"
argument_list|)
expr_stmt|;
comment|/* Bad Juju */
comment|/* should I just call the proper reset func 				   here??? */
goto|goto
name|bailout
goto|;
block|}
name|ctl_zero_io
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|taskio
argument_list|)
expr_stmt|;
name|taskio
operator|->
name|io_hdr
operator|.
name|io_type
operator|=
name|CTL_IO_TASK
expr_stmt|;
name|taskio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_FROM_OTHER_SC
expr_stmt|;
name|taskio
operator|->
name|io_hdr
operator|.
name|nexus
operator|=
name|msg_info
operator|.
name|hdr
operator|.
name|nexus
expr_stmt|;
name|taskio
operator|->
name|task_action
operator|=
name|msg_info
operator|.
name|task
operator|.
name|task_action
expr_stmt|;
name|taskio
operator|->
name|tag_num
operator|=
name|msg_info
operator|.
name|task
operator|.
name|tag_num
expr_stmt|;
name|taskio
operator|->
name|tag_type
operator|=
name|msg_info
operator|.
name|task
operator|.
name|tag_type
expr_stmt|;
ifdef|#
directive|ifdef
name|CTL_TIME_IO
name|taskio
operator|->
name|io_hdr
operator|.
name|start_time
operator|=
name|time_uptime
expr_stmt|;
name|getbintime
argument_list|(
operator|&
name|taskio
operator|->
name|io_hdr
operator|.
name|start_bt
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|cs_prof_gettime(&taskio->io_hdr.start_ticks);
endif|#
directive|endif
endif|#
directive|endif
comment|/* CTL_TIME_IO */
name|ctl_run_task
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|taskio
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Persistent Reserve action which needs attention */
case|case
name|CTL_MSG_PERS_ACTION
case|:
name|presio
operator|=
operator|(
expr|struct
name|ctl_prio
operator|*
operator|)
name|ctl_alloc_io
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ctl_softc
operator|->
name|othersc_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|presio
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ctl_isc_event_handler: can't allocate "
literal|"ctl_io!\n"
argument_list|)
expr_stmt|;
comment|/* Bad Juju */
comment|/* Need to set busy and send msg back */
goto|goto
name|bailout
goto|;
block|}
name|ctl_zero_io
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|presio
argument_list|)
expr_stmt|;
name|presio
operator|->
name|io_hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_PERS_ACTION
expr_stmt|;
name|presio
operator|->
name|pr_msg
operator|=
name|msg_info
operator|.
name|pr
expr_stmt|;
name|ctl_enqueue_isc
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|presio
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_MSG_SYNC_FE
case|:
name|rcv_sync_msg
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CTL_MSG_APS_LOCK
case|:
block|{
comment|// It's quicker to execute this then to
comment|// queue it.
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|struct
name|ctl_page_index
modifier|*
name|page_index
decl_stmt|;
name|struct
name|copan_aps_subpage
modifier|*
name|current_sp
decl_stmt|;
name|uint32_t
name|targ_lun
decl_stmt|;
name|targ_lun
operator|=
name|msg_info
operator|.
name|hdr
operator|.
name|nexus
operator|.
name|targ_mapped_lun
expr_stmt|;
name|lun
operator|=
name|ctl_softc
operator|->
name|ctl_luns
index|[
name|targ_lun
index|]
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|page_index
operator|=
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|index
index|[
name|index_to_aps_page
index|]
expr_stmt|;
name|current_sp
operator|=
operator|(
expr|struct
name|copan_aps_subpage
operator|*
operator|)
operator|(
name|page_index
operator|->
name|page_data
operator|+
operator|(
name|page_index
operator|->
name|page_len
operator|*
name|CTL_PAGE_CURRENT
operator|)
operator|)
expr_stmt|;
name|current_sp
operator|->
name|lock_active
operator|=
name|msg_info
operator|.
name|aps
operator|.
name|lock_flag
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|printf
argument_list|(
literal|"How did I get here?\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|event
operator|==
name|CTL_HA_EVT_MSG_SENT
condition|)
block|{
if|if
condition|(
name|param
operator|!=
name|CTL_HA_STATUS_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"Bad status from ctl_ha_msg_send status %d\n"
argument_list|,
name|param
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
elseif|else
if|if
condition|(
name|event
operator|==
name|CTL_HA_EVT_DISCONNECT
condition|)
block|{
name|printf
argument_list|(
literal|"CTL: Got a disconnect from Isc\n"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"ctl_isc_event_handler: Unknown event %d\n"
argument_list|,
name|event
argument_list|)
expr_stmt|;
return|return;
block|}
name|bailout
label|:
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_copy_sense_data
parameter_list|(
name|union
name|ctl_ha_msg
modifier|*
name|src
parameter_list|,
name|union
name|ctl_io
modifier|*
name|dest
parameter_list|)
block|{
name|struct
name|scsi_sense_data
modifier|*
name|sense
decl_stmt|;
name|sense
operator|=
operator|&
name|dest
operator|->
name|scsiio
operator|.
name|sense_data
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|src
operator|->
name|scsi
operator|.
name|sense_data
argument_list|,
name|sense
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sense
argument_list|)
argument_list|)
expr_stmt|;
name|dest
operator|->
name|scsiio
operator|.
name|scsi_status
operator|=
name|src
operator|->
name|scsi
operator|.
name|scsi_status
expr_stmt|;
name|dest
operator|->
name|scsiio
operator|.
name|sense_len
operator|=
name|src
operator|->
name|scsi
operator|.
name|sense_len
expr_stmt|;
name|dest
operator|->
name|io_hdr
operator|.
name|status
operator|=
name|src
operator|->
name|hdr
operator|.
name|status
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_init
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ctl_io_pool
modifier|*
name|internal_pool
decl_stmt|,
modifier|*
name|emergency_pool
decl_stmt|,
modifier|*
name|other_pool
decl_stmt|;
name|struct
name|ctl_port
modifier|*
name|port
decl_stmt|;
name|uint8_t
name|sc_id
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|,
name|retval
decl_stmt|;
comment|//int isc_retval;
name|retval
operator|=
literal|0
expr_stmt|;
name|ctl_pause_rtr
operator|=
literal|0
expr_stmt|;
name|rcv_sync_msg
operator|=
literal|0
expr_stmt|;
name|control_softc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|control_softc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|softc
operator|=
name|control_softc
expr_stmt|;
name|softc
operator|->
name|dev
operator|=
name|make_dev
argument_list|(
operator|&
name|ctl_cdevsw
argument_list|,
literal|0
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0600
argument_list|,
literal|"cam/ctl"
argument_list|)
expr_stmt|;
name|softc
operator|->
name|dev
operator|->
name|si_drv1
operator|=
name|softc
expr_stmt|;
comment|/* 	 * By default, return a "bad LUN" peripheral qualifier for unknown 	 * LUNs.  The user can override this default using the tunable or 	 * sysctl.  See the comment in ctl_inquiry_std() for more details. 	 */
name|softc
operator|->
name|inquiry_pq_no_lun
operator|=
literal|1
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"kern.cam.ctl.inquiry_pq_no_lun"
argument_list|,
operator|&
name|softc
operator|->
name|inquiry_pq_no_lun
argument_list|)
expr_stmt|;
name|sysctl_ctx_init
argument_list|(
operator|&
name|softc
operator|->
name|sysctl_ctx
argument_list|)
expr_stmt|;
name|softc
operator|->
name|sysctl_tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
operator|&
name|softc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_STATIC_CHILDREN
argument_list|(
name|_kern_cam
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ctl"
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"CAM Target Layer"
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|sysctl_tree
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unable to allocate sysctl tree\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|destroy_dev
argument_list|(
name|softc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|control_softc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|control_softc
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|SYSCTL_ADD_INT
argument_list|(
operator|&
name|softc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|softc
operator|->
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"inquiry_pq_no_lun"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|softc
operator|->
name|inquiry_pq_no_lun
argument_list|,
literal|0
argument_list|,
literal|"Report no lun possible for invalid LUNs"
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|,
literal|"CTL mutex"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|softc
operator|->
name|pool_lock
argument_list|,
literal|"CTL pool mutex"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|softc
operator|->
name|open_count
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Default to actually sending a SYNCHRONIZE CACHE command down to 	 * the drive. 	 */
name|softc
operator|->
name|flags
operator|=
name|CTL_FLAG_REAL_SYNC
expr_stmt|;
comment|/* 	 * In Copan's HA scheme, the "master" and "slave" roles are 	 * figured out through the slot the controller is in.  Although it 	 * is an active/active system, someone has to be in charge.  	 */
ifdef|#
directive|ifdef
name|NEEDTOPORT
name|scmicro_rw
argument_list|(
name|SCMICRO_GET_SHELF_ID
argument_list|,
operator|&
name|sc_id
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc_id
operator|==
literal|0
condition|)
block|{
name|softc
operator|->
name|flags
operator||=
name|CTL_FLAG_MASTER_SHELF
expr_stmt|;
name|persis_offset
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|persis_offset
operator|=
name|CTL_MAX_INITIATORS
expr_stmt|;
comment|/* 	 * XXX KDM need to figure out where we want to get our target ID 	 * and WWID.  Is it different on each port? 	 */
name|softc
operator|->
name|target
operator|.
name|id
operator|=
literal|0
expr_stmt|;
name|softc
operator|->
name|target
operator|.
name|wwid
index|[
literal|0
index|]
operator|=
literal|0x12345678
expr_stmt|;
name|softc
operator|->
name|target
operator|.
name|wwid
index|[
literal|1
index|]
operator|=
literal|0x87654321
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|softc
operator|->
name|lun_list
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|softc
operator|->
name|pending_lun_queue
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|softc
operator|->
name|fe_list
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|softc
operator|->
name|port_list
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|softc
operator|->
name|be_list
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|softc
operator|->
name|io_pools
argument_list|)
expr_stmt|;
name|ctl_tpc_init
argument_list|(
name|softc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl_pool_create
argument_list|(
name|softc
argument_list|,
name|CTL_POOL_INTERNAL
argument_list|,
name|CTL_POOL_ENTRIES_INTERNAL
argument_list|,
operator|&
name|internal_pool
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ctl: can't allocate %d entry internal pool, "
literal|"exiting\n"
argument_list|,
name|CTL_POOL_ENTRIES_INTERNAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|ctl_pool_create
argument_list|(
name|softc
argument_list|,
name|CTL_POOL_EMERGENCY
argument_list|,
name|CTL_POOL_ENTRIES_EMERGENCY
argument_list|,
operator|&
name|emergency_pool
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ctl: can't allocate %d entry emergency pool, "
literal|"exiting\n"
argument_list|,
name|CTL_POOL_ENTRIES_EMERGENCY
argument_list|)
expr_stmt|;
name|ctl_pool_free
argument_list|(
name|internal_pool
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|ctl_pool_create
argument_list|(
name|softc
argument_list|,
name|CTL_POOL_4OTHERSC
argument_list|,
name|CTL_POOL_ENTRIES_OTHER_SC
argument_list|,
operator|&
name|other_pool
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ctl: can't allocate %d entry other SC pool, "
literal|"exiting\n"
argument_list|,
name|CTL_POOL_ENTRIES_OTHER_SC
argument_list|)
expr_stmt|;
name|ctl_pool_free
argument_list|(
name|internal_pool
argument_list|)
expr_stmt|;
name|ctl_pool_free
argument_list|(
name|emergency_pool
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|softc
operator|->
name|internal_pool
operator|=
name|internal_pool
expr_stmt|;
name|softc
operator|->
name|emergency_pool
operator|=
name|emergency_pool
expr_stmt|;
name|softc
operator|->
name|othersc_pool
operator|=
name|other_pool
expr_stmt|;
if|if
condition|(
name|worker_threads
operator|<=
literal|0
condition|)
name|worker_threads
operator|=
name|max
argument_list|(
literal|1
argument_list|,
name|mp_ncpus
operator|/
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|worker_threads
operator|>
name|CTL_MAX_THREADS
condition|)
name|worker_threads
operator|=
name|CTL_MAX_THREADS
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|worker_threads
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ctl_thread
modifier|*
name|thr
init|=
operator|&
name|softc
operator|->
name|threads
index|[
name|i
index|]
decl_stmt|;
name|mtx_init
argument_list|(
operator|&
name|thr
operator|->
name|queue_lock
argument_list|,
literal|"CTL queue mutex"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|thr
operator|->
name|ctl_softc
operator|=
name|softc
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|thr
operator|->
name|incoming_queue
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|thr
operator|->
name|rtr_queue
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|thr
operator|->
name|done_queue
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|thr
operator|->
name|isc_queue
argument_list|)
expr_stmt|;
name|error
operator|=
name|kproc_kthread_add
argument_list|(
name|ctl_work_thread
argument_list|,
name|thr
argument_list|,
operator|&
name|softc
operator|->
name|ctl_proc
argument_list|,
operator|&
name|thr
operator|->
name|thread
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"ctl"
argument_list|,
literal|"work%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"error creating CTL work thread!\n"
argument_list|)
expr_stmt|;
name|ctl_pool_free
argument_list|(
name|internal_pool
argument_list|)
expr_stmt|;
name|ctl_pool_free
argument_list|(
name|emergency_pool
argument_list|)
expr_stmt|;
name|ctl_pool_free
argument_list|(
name|other_pool
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|error
operator|=
name|kproc_kthread_add
argument_list|(
name|ctl_lun_thread
argument_list|,
name|softc
argument_list|,
operator|&
name|softc
operator|->
name|ctl_proc
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"ctl"
argument_list|,
literal|"lun"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"error creating CTL lun thread!\n"
argument_list|)
expr_stmt|;
name|ctl_pool_free
argument_list|(
name|internal_pool
argument_list|)
expr_stmt|;
name|ctl_pool_free
argument_list|(
name|emergency_pool
argument_list|)
expr_stmt|;
name|ctl_pool_free
argument_list|(
name|other_pool
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"ctl: CAM Target Layer loaded\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the ioctl front end. 	 */
name|ctl_frontend_register
argument_list|(
operator|&
name|ioctl_frontend
argument_list|)
expr_stmt|;
name|port
operator|=
operator|&
name|softc
operator|->
name|ioctl_info
operator|.
name|port
expr_stmt|;
name|port
operator|->
name|frontend
operator|=
operator|&
name|ioctl_frontend
expr_stmt|;
name|sprintf
argument_list|(
name|softc
operator|->
name|ioctl_info
operator|.
name|port_name
argument_list|,
literal|"ioctl"
argument_list|)
expr_stmt|;
name|port
operator|->
name|port_type
operator|=
name|CTL_PORT_IOCTL
expr_stmt|;
name|port
operator|->
name|num_requested_ctl_io
operator|=
literal|100
expr_stmt|;
name|port
operator|->
name|port_name
operator|=
name|softc
operator|->
name|ioctl_info
operator|.
name|port_name
expr_stmt|;
name|port
operator|->
name|port_online
operator|=
name|ctl_ioctl_online
expr_stmt|;
name|port
operator|->
name|port_offline
operator|=
name|ctl_ioctl_offline
expr_stmt|;
name|port
operator|->
name|onoff_arg
operator|=
operator|&
name|softc
operator|->
name|ioctl_info
expr_stmt|;
name|port
operator|->
name|lun_enable
operator|=
name|ctl_ioctl_lun_enable
expr_stmt|;
name|port
operator|->
name|lun_disable
operator|=
name|ctl_ioctl_lun_disable
expr_stmt|;
name|port
operator|->
name|targ_lun_arg
operator|=
operator|&
name|softc
operator|->
name|ioctl_info
expr_stmt|;
name|port
operator|->
name|fe_datamove
operator|=
name|ctl_ioctl_datamove
expr_stmt|;
name|port
operator|->
name|fe_done
operator|=
name|ctl_ioctl_done
expr_stmt|;
name|port
operator|->
name|max_targets
operator|=
literal|15
expr_stmt|;
name|port
operator|->
name|max_target_id
operator|=
literal|15
expr_stmt|;
if|if
condition|(
name|ctl_port_register
argument_list|(
operator|&
name|softc
operator|->
name|ioctl_info
operator|.
name|port
argument_list|,
operator|(
name|softc
operator|->
name|flags
operator|&
name|CTL_FLAG_MASTER_SHELF
operator|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ctl: ioctl front end registration failed, will "
literal|"continue anyway\n"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CTL_IO_DELAY
if|if
condition|(
sizeof|sizeof
argument_list|(
expr|struct
name|callout
argument_list|)
operator|>
name|CTL_TIMER_BYTES
condition|)
block|{
name|printf
argument_list|(
literal|"sizeof(struct callout) %zd> CTL_TIMER_BYTES %zd\n"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|callout
argument_list|)
argument_list|,
name|CTL_TIMER_BYTES
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* CTL_IO_DELAY */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ctl_shutdown
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|,
modifier|*
name|next_lun
decl_stmt|;
name|struct
name|ctl_io_pool
modifier|*
name|pool
decl_stmt|;
name|softc
operator|=
operator|(
expr|struct
name|ctl_softc
operator|*
operator|)
name|control_softc
expr_stmt|;
if|if
condition|(
name|ctl_port_deregister
argument_list|(
operator|&
name|softc
operator|->
name|ioctl_info
operator|.
name|port
argument_list|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"ctl: ioctl front end deregistration failed\n"
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Free up each LUN. 	 */
for|for
control|(
name|lun
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|softc
operator|->
name|lun_list
argument_list|)
init|;
name|lun
operator|!=
name|NULL
condition|;
name|lun
operator|=
name|next_lun
control|)
block|{
name|next_lun
operator|=
name|STAILQ_NEXT
argument_list|(
name|lun
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|ctl_free_lun
argument_list|(
name|lun
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|ctl_frontend_deregister
argument_list|(
operator|&
name|ioctl_frontend
argument_list|)
expr_stmt|;
comment|/* 	 * This will rip the rug out from under any FETDs or anyone else 	 * that has a pool allocated.  Since we increment our module 	 * refcount any time someone outside the main CTL module allocates 	 * a pool, we shouldn't have any problems here.  The user won't be 	 * able to unload the CTL module until client modules have 	 * successfully unloaded. 	 */
while|while
condition|(
operator|(
name|pool
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|softc
operator|->
name|io_pools
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|ctl_pool_free
argument_list|(
name|pool
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|ctl_shutdown_thread(softc->work_thread); 	mtx_destroy(&softc->queue_lock);
endif|#
directive|endif
name|ctl_tpc_shutdown
argument_list|(
name|softc
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|softc
operator|->
name|pool_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|destroy_dev
argument_list|(
name|softc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|sysctl_ctx_free
argument_list|(
operator|&
name|softc
operator|->
name|sysctl_ctx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|control_softc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|control_softc
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"ctl: CAM Target Layer unloaded\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_module_event_handler
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|MOD_LOAD
case|:
return|return
operator|(
name|ctl_init
argument_list|()
operator|)
return|;
case|case
name|MOD_UNLOAD
case|:
return|return
operator|(
name|EBUSY
operator|)
return|;
default|default:
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * XXX KDM should we do some access checks here?  Bump a reference count to  * prevent a CTL module from being unloaded while someone has it open?  */
end_comment

begin_function
specifier|static
name|int
name|ctl_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_port_enable
parameter_list|(
name|ctl_port_type
name|port_type
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ctl_port
modifier|*
name|port
decl_stmt|;
if|if
condition|(
name|ctl_is_single
operator|==
literal|0
condition|)
block|{
name|union
name|ctl_ha_msg
name|msg_info
decl_stmt|;
name|int
name|isc_retval
decl_stmt|;
if|#
directive|if
literal|0
block|printf("%s: HA mode, synchronizing frontend enable\n", 		        __func__);
endif|#
directive|endif
name|msg_info
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_SYNC_FE
expr_stmt|;
if|if
condition|(
operator|(
name|isc_retval
operator|=
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|msg_info
argument_list|,
sizeof|sizeof
argument_list|(
name|msg_info
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
operator|>
name|CTL_HA_STATUS_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"Sync msg send error retval %d\n"
argument_list|,
name|isc_retval
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|rcv_sync_msg
condition|)
block|{
name|isc_retval
operator|=
name|ctl_ha_msg_recv
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|msg_info
argument_list|,
sizeof|sizeof
argument_list|(
name|msg_info
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|printf("CTL:Frontend Enable\n"); 	} else { 		printf("%s: single mode, skipping frontend synchronization\n", 		        __func__);
endif|#
directive|endif
block|}
name|softc
operator|=
name|control_softc
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|port
argument_list|,
argument|&softc->port_list
argument_list|,
argument|links
argument_list|)
block|{
if|if
condition|(
name|port_type
operator|&
name|port
operator|->
name|port_type
condition|)
block|{
if|#
directive|if
literal|0
block|printf("port %d\n", port->targ_port);
endif|#
directive|endif
name|ctl_port_online
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_port_disable
parameter_list|(
name|ctl_port_type
name|port_type
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ctl_port
modifier|*
name|port
decl_stmt|;
name|softc
operator|=
name|control_softc
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|port
argument_list|,
argument|&softc->port_list
argument_list|,
argument|links
argument_list|)
block|{
if|if
condition|(
name|port_type
operator|&
name|port
operator|->
name|port_type
condition|)
name|ctl_port_offline
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns 0 for success, 1 for failure.  * Currently the only failure mode is if there aren't enough entries  * allocated.  So, in case of a failure, look at num_entries_dropped,  * reallocate and try again.  */
end_comment

begin_function
name|int
name|ctl_port_list
parameter_list|(
name|struct
name|ctl_port_entry
modifier|*
name|entries
parameter_list|,
name|int
name|num_entries_alloced
parameter_list|,
name|int
modifier|*
name|num_entries_filled
parameter_list|,
name|int
modifier|*
name|num_entries_dropped
parameter_list|,
name|ctl_port_type
name|port_type
parameter_list|,
name|int
name|no_virtual
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ctl_port
modifier|*
name|port
decl_stmt|;
name|int
name|entries_dropped
decl_stmt|,
name|entries_filled
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|int
name|i
decl_stmt|;
name|softc
operator|=
name|control_softc
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|entries_filled
operator|=
literal|0
expr_stmt|;
name|entries_dropped
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|port
argument_list|,
argument|&softc->port_list
argument_list|,
argument|links
argument_list|)
block|{
name|struct
name|ctl_port_entry
modifier|*
name|entry
decl_stmt|;
if|if
condition|(
operator|(
name|port
operator|->
name|port_type
operator|&
name|port_type
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|no_virtual
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|port
operator|->
name|virtual_port
operator|!=
literal|0
operator|)
condition|)
continue|continue;
if|if
condition|(
name|entries_filled
operator|>=
name|num_entries_alloced
condition|)
block|{
name|entries_dropped
operator|++
expr_stmt|;
continue|continue;
block|}
name|entry
operator|=
operator|&
name|entries
index|[
name|i
index|]
expr_stmt|;
name|entry
operator|->
name|port_type
operator|=
name|port
operator|->
name|port_type
expr_stmt|;
name|strlcpy
argument_list|(
name|entry
operator|->
name|port_name
argument_list|,
name|port
operator|->
name|port_name
argument_list|,
sizeof|sizeof
argument_list|(
name|entry
operator|->
name|port_name
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|physical_port
operator|=
name|port
operator|->
name|physical_port
expr_stmt|;
name|entry
operator|->
name|virtual_port
operator|=
name|port
operator|->
name|virtual_port
expr_stmt|;
name|entry
operator|->
name|wwnn
operator|=
name|port
operator|->
name|wwnn
expr_stmt|;
name|entry
operator|->
name|wwpn
operator|=
name|port
operator|->
name|wwpn
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|entries_filled
operator|++
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|entries_dropped
operator|>
literal|0
condition|)
name|retval
operator|=
literal|1
expr_stmt|;
operator|*
name|num_entries_dropped
operator|=
name|entries_dropped
expr_stmt|;
operator|*
name|num_entries_filled
operator|=
name|entries_filled
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_ioctl_online
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ctl_ioctl_info
modifier|*
name|ioctl_info
decl_stmt|;
name|ioctl_info
operator|=
operator|(
expr|struct
name|ctl_ioctl_info
operator|*
operator|)
name|arg
expr_stmt|;
name|ioctl_info
operator|->
name|flags
operator||=
name|CTL_IOCTL_FLAG_ENABLED
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_ioctl_offline
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ctl_ioctl_info
modifier|*
name|ioctl_info
decl_stmt|;
name|ioctl_info
operator|=
operator|(
expr|struct
name|ctl_ioctl_info
operator|*
operator|)
name|arg
expr_stmt|;
name|ioctl_info
operator|->
name|flags
operator|&=
operator|~
name|CTL_IOCTL_FLAG_ENABLED
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove an initiator by port number and initiator ID.  * Returns 0 for success, -1 for failure.  */
end_comment

begin_function
name|int
name|ctl_remove_initiator
parameter_list|(
name|struct
name|ctl_port
modifier|*
name|port
parameter_list|,
name|int
name|iid
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|control_softc
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|iid
operator|>
name|CTL_MAX_INIT_PER_PORT
condition|)
block|{
name|printf
argument_list|(
literal|"%s: initiator ID %u> maximun %u!\n"
argument_list|,
name|__func__
argument_list|,
name|iid
argument_list|,
name|CTL_MAX_INIT_PER_PORT
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|port
operator|->
name|wwpn_iid
index|[
name|iid
index|]
operator|.
name|in_use
operator|--
expr_stmt|;
name|port
operator|->
name|wwpn_iid
index|[
name|iid
index|]
operator|.
name|last_use
operator|=
name|time_uptime
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add an initiator to the initiator map.  * Returns iid for success,< 0 for failure.  */
end_comment

begin_function
name|int
name|ctl_add_initiator
parameter_list|(
name|struct
name|ctl_port
modifier|*
name|port
parameter_list|,
name|int
name|iid
parameter_list|,
name|uint64_t
name|wwpn
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|control_softc
decl_stmt|;
name|time_t
name|best_time
decl_stmt|;
name|int
name|i
decl_stmt|,
name|best
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|iid
operator|>=
name|CTL_MAX_INIT_PER_PORT
condition|)
block|{
name|printf
argument_list|(
literal|"%s: WWPN %#jx initiator ID %u> maximum %u!\n"
argument_list|,
name|__func__
argument_list|,
name|wwpn
argument_list|,
name|iid
argument_list|,
name|CTL_MAX_INIT_PER_PORT
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|iid
operator|<
literal|0
operator|&&
operator|(
name|wwpn
operator|!=
literal|0
operator|||
name|name
operator|!=
name|NULL
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_MAX_INIT_PER_PORT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|wwpn
operator|!=
literal|0
operator|&&
name|wwpn
operator|==
name|port
operator|->
name|wwpn_iid
index|[
name|i
index|]
operator|.
name|wwpn
condition|)
block|{
name|iid
operator|=
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|name
operator|!=
name|NULL
operator|&&
name|port
operator|->
name|wwpn_iid
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|port
operator|->
name|wwpn_iid
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|iid
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|iid
operator|<
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_MAX_INIT_PER_PORT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|port
operator|->
name|wwpn_iid
index|[
name|i
index|]
operator|.
name|in_use
operator|==
literal|0
operator|&&
name|port
operator|->
name|wwpn_iid
index|[
name|i
index|]
operator|.
name|wwpn
operator|==
literal|0
operator|&&
name|port
operator|->
name|wwpn_iid
index|[
name|i
index|]
operator|.
name|name
operator|==
name|NULL
condition|)
block|{
name|iid
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|iid
operator|<
literal|0
condition|)
block|{
name|best
operator|=
operator|-
literal|1
expr_stmt|;
name|best_time
operator|=
name|INT32_MAX
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_MAX_INIT_PER_PORT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|port
operator|->
name|wwpn_iid
index|[
name|i
index|]
operator|.
name|in_use
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|port
operator|->
name|wwpn_iid
index|[
name|i
index|]
operator|.
name|last_use
operator|<
name|best_time
condition|)
block|{
name|best
operator|=
name|i
expr_stmt|;
name|best_time
operator|=
name|port
operator|->
name|wwpn_iid
index|[
name|i
index|]
operator|.
name|last_use
expr_stmt|;
block|}
block|}
block|}
name|iid
operator|=
name|best
expr_stmt|;
block|}
if|if
condition|(
name|iid
operator|<
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
if|if
condition|(
name|port
operator|->
name|wwpn_iid
index|[
name|iid
index|]
operator|.
name|in_use
operator|>
literal|0
operator|&&
operator|(
name|wwpn
operator|!=
literal|0
operator|||
name|name
operator|!=
name|NULL
operator|)
condition|)
block|{
comment|/* 		 * This is not an error yet. 		 */
if|if
condition|(
name|wwpn
operator|!=
literal|0
operator|&&
name|wwpn
operator|==
name|port
operator|->
name|wwpn_iid
index|[
name|iid
index|]
operator|.
name|wwpn
condition|)
block|{
if|#
directive|if
literal|0
block|printf("%s: port %d iid %u WWPN %#jx arrived" 			    " again\n", __func__, port->targ_port, 			    iid, (uintmax_t)wwpn);
endif|#
directive|endif
goto|goto
name|take
goto|;
block|}
if|if
condition|(
name|name
operator|!=
name|NULL
operator|&&
name|port
operator|->
name|wwpn_iid
index|[
name|iid
index|]
operator|.
name|name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|port
operator|->
name|wwpn_iid
index|[
name|iid
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
literal|0
block|printf("%s: port %d iid %u name '%s' arrived" 			    " again\n", __func__, port->targ_port, 			    iid, name);
endif|#
directive|endif
goto|goto
name|take
goto|;
block|}
comment|/* 		 * This is an error, but what do we do about it?  The 		 * driver is telling us we have a new WWPN for this 		 * initiator ID, so we pretty much need to use it. 		 */
name|printf
argument_list|(
literal|"%s: port %d iid %u WWPN %#jx '%s' arrived,"
literal|" but WWPN %#jx '%s' is still at that address\n"
argument_list|,
name|__func__
argument_list|,
name|port
operator|->
name|targ_port
argument_list|,
name|iid
argument_list|,
name|wwpn
argument_list|,
name|name
argument_list|,
operator|(
name|uintmax_t
operator|)
name|port
operator|->
name|wwpn_iid
index|[
name|iid
index|]
operator|.
name|wwpn
argument_list|,
name|port
operator|->
name|wwpn_iid
index|[
name|iid
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
comment|/* 		 * XXX KDM clear have_ca and ua_pending on each LUN for 		 * this initiator. 		 */
block|}
name|take
label|:
name|free
argument_list|(
name|port
operator|->
name|wwpn_iid
index|[
name|iid
index|]
operator|.
name|name
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|port
operator|->
name|wwpn_iid
index|[
name|iid
index|]
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|port
operator|->
name|wwpn_iid
index|[
name|iid
index|]
operator|.
name|wwpn
operator|=
name|wwpn
expr_stmt|;
name|port
operator|->
name|wwpn_iid
index|[
name|iid
index|]
operator|.
name|in_use
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|iid
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_create_iid
parameter_list|(
name|struct
name|ctl_port
modifier|*
name|port
parameter_list|,
name|int
name|iid
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
switch|switch
condition|(
name|port
operator|->
name|port_type
condition|)
block|{
case|case
name|CTL_PORT_FC
case|:
block|{
name|struct
name|scsi_transportid_fcp
modifier|*
name|id
init|=
operator|(
expr|struct
name|scsi_transportid_fcp
operator|*
operator|)
name|buf
decl_stmt|;
if|if
condition|(
name|port
operator|->
name|wwpn_iid
index|[
name|iid
index|]
operator|.
name|wwpn
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|memset
argument_list|(
name|id
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|id
operator|->
name|format_protocol
operator|=
name|SCSI_PROTO_FC
expr_stmt|;
name|scsi_u64to8b
argument_list|(
name|port
operator|->
name|wwpn_iid
index|[
name|iid
index|]
operator|.
name|wwpn
argument_list|,
name|id
operator|->
name|n_port_name
argument_list|)
expr_stmt|;
return|return
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|id
argument_list|)
operator|)
return|;
block|}
case|case
name|CTL_PORT_ISCSI
case|:
block|{
name|struct
name|scsi_transportid_iscsi_port
modifier|*
name|id
init|=
operator|(
expr|struct
name|scsi_transportid_iscsi_port
operator|*
operator|)
name|buf
decl_stmt|;
if|if
condition|(
name|port
operator|->
name|wwpn_iid
index|[
name|iid
index|]
operator|.
name|name
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|memset
argument_list|(
name|id
argument_list|,
literal|0
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|id
operator|->
name|format_protocol
operator|=
name|SCSI_TRN_ISCSI_FORMAT_PORT
operator||
name|SCSI_PROTO_ISCSI
expr_stmt|;
name|len
operator|=
name|strlcpy
argument_list|(
name|id
operator|->
name|iscsi_name
argument_list|,
name|port
operator|->
name|wwpn_iid
index|[
name|iid
index|]
operator|.
name|name
argument_list|,
literal|252
argument_list|)
operator|+
literal|1
expr_stmt|;
name|len
operator|=
name|roundup2
argument_list|(
name|min
argument_list|(
name|len
argument_list|,
literal|252
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|len
argument_list|,
name|id
operator|->
name|additional_length
argument_list|)
expr_stmt|;
return|return
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|id
argument_list|)
operator|+
name|len
operator|)
return|;
block|}
case|case
name|CTL_PORT_SAS
case|:
block|{
name|struct
name|scsi_transportid_sas
modifier|*
name|id
init|=
operator|(
expr|struct
name|scsi_transportid_sas
operator|*
operator|)
name|buf
decl_stmt|;
if|if
condition|(
name|port
operator|->
name|wwpn_iid
index|[
name|iid
index|]
operator|.
name|wwpn
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|memset
argument_list|(
name|id
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|id
operator|->
name|format_protocol
operator|=
name|SCSI_PROTO_SAS
expr_stmt|;
name|scsi_u64to8b
argument_list|(
name|port
operator|->
name|wwpn_iid
index|[
name|iid
index|]
operator|.
name|wwpn
argument_list|,
name|id
operator|->
name|sas_address
argument_list|)
expr_stmt|;
return|return
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|id
argument_list|)
operator|)
return|;
block|}
default|default:
block|{
name|struct
name|scsi_transportid_spi
modifier|*
name|id
init|=
operator|(
expr|struct
name|scsi_transportid_spi
operator|*
operator|)
name|buf
decl_stmt|;
name|memset
argument_list|(
name|id
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|id
operator|->
name|format_protocol
operator|=
name|SCSI_PROTO_SPI
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|iid
argument_list|,
name|id
operator|->
name|scsi_addr
argument_list|)
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|port
operator|->
name|targ_port
argument_list|,
name|id
operator|->
name|rel_trgt_port_id
argument_list|)
expr_stmt|;
return|return
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|id
argument_list|)
operator|)
return|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_ioctl_lun_enable
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ctl_id
name|targ_id
parameter_list|,
name|int
name|lun_id
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_ioctl_lun_disable
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ctl_id
name|targ_id
parameter_list|,
name|int
name|lun_id
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Data movement routine for the CTL ioctl frontend port.  */
end_comment

begin_function
specifier|static
name|int
name|ctl_ioctl_do_datamove
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|ctl_sg_entry
modifier|*
name|ext_sglist
decl_stmt|,
modifier|*
name|kern_sglist
decl_stmt|;
name|struct
name|ctl_sg_entry
name|ext_entry
decl_stmt|,
name|kern_entry
decl_stmt|;
name|int
name|ext_sglen
decl_stmt|,
name|ext_sg_entries
decl_stmt|,
name|kern_sg_entries
decl_stmt|;
name|int
name|ext_sg_start
decl_stmt|,
name|ext_offset
decl_stmt|;
name|int
name|len_to_copy
decl_stmt|,
name|len_copied
decl_stmt|;
name|int
name|kern_watermark
decl_stmt|,
name|ext_watermark
decl_stmt|;
name|int
name|ext_sglist_malloced
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|ext_sglist_malloced
operator|=
literal|0
expr_stmt|;
name|ext_sg_start
operator|=
literal|0
expr_stmt|;
name|ext_offset
operator|=
literal|0
expr_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_ioctl_do_datamove\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If this flag is set, fake the data transfer. 	 */
if|if
condition|(
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_NO_DATAMOVE
condition|)
block|{
name|ctsio
operator|->
name|ext_data_filled
operator|=
name|ctsio
operator|->
name|ext_data_len
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
comment|/* 	 * To simplify things here, if we have a single buffer, stick it in 	 * a S/G entry and just make it a single entry S/G list. 	 */
if|if
condition|(
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_EDPTR_SGLIST
condition|)
block|{
name|int
name|len_seen
decl_stmt|;
name|ext_sglen
operator|=
name|ctsio
operator|->
name|ext_sg_entries
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ext_sglist
argument_list|)
expr_stmt|;
name|ext_sglist
operator|=
operator|(
expr|struct
name|ctl_sg_entry
operator|*
operator|)
name|malloc
argument_list|(
name|ext_sglen
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|ext_sglist_malloced
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|copyin
argument_list|(
name|ctsio
operator|->
name|ext_data_ptr
argument_list|,
name|ext_sglist
argument_list|,
name|ext_sglen
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ctl_set_internal_failure
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|0
argument_list|,
comment|/*retry_count*/
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|ext_sg_entries
operator|=
name|ctsio
operator|->
name|ext_sg_entries
expr_stmt|;
name|len_seen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ext_sg_entries
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|len_seen
operator|+
name|ext_sglist
index|[
name|i
index|]
operator|.
name|len
operator|)
operator|>=
name|ctsio
operator|->
name|ext_data_filled
condition|)
block|{
name|ext_sg_start
operator|=
name|i
expr_stmt|;
name|ext_offset
operator|=
name|ctsio
operator|->
name|ext_data_filled
operator|-
name|len_seen
expr_stmt|;
break|break;
block|}
name|len_seen
operator|+=
name|ext_sglist
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
block|}
block|}
else|else
block|{
name|ext_sglist
operator|=
operator|&
name|ext_entry
expr_stmt|;
name|ext_sglist
operator|->
name|addr
operator|=
name|ctsio
operator|->
name|ext_data_ptr
expr_stmt|;
name|ext_sglist
operator|->
name|len
operator|=
name|ctsio
operator|->
name|ext_data_len
expr_stmt|;
name|ext_sg_entries
operator|=
literal|1
expr_stmt|;
name|ext_sg_start
operator|=
literal|0
expr_stmt|;
name|ext_offset
operator|=
name|ctsio
operator|->
name|ext_data_filled
expr_stmt|;
block|}
if|if
condition|(
name|ctsio
operator|->
name|kern_sg_entries
operator|>
literal|0
condition|)
block|{
name|kern_sglist
operator|=
operator|(
expr|struct
name|ctl_sg_entry
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|kern_sg_entries
operator|=
name|ctsio
operator|->
name|kern_sg_entries
expr_stmt|;
block|}
else|else
block|{
name|kern_sglist
operator|=
operator|&
name|kern_entry
expr_stmt|;
name|kern_sglist
operator|->
name|addr
operator|=
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|kern_sglist
operator|->
name|len
operator|=
name|ctsio
operator|->
name|kern_data_len
expr_stmt|;
name|kern_sg_entries
operator|=
literal|1
expr_stmt|;
block|}
name|kern_watermark
operator|=
literal|0
expr_stmt|;
name|ext_watermark
operator|=
name|ext_offset
expr_stmt|;
name|len_copied
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ext_sg_start
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|ext_sg_entries
operator|&&
name|j
operator|<
name|kern_sg_entries
condition|;
control|)
block|{
name|uint8_t
modifier|*
name|ext_ptr
decl_stmt|,
modifier|*
name|kern_ptr
decl_stmt|;
name|len_to_copy
operator|=
name|ctl_min
argument_list|(
name|ext_sglist
index|[
name|i
index|]
operator|.
name|len
operator|-
name|ext_watermark
argument_list|,
name|kern_sglist
index|[
name|j
index|]
operator|.
name|len
operator|-
name|kern_watermark
argument_list|)
expr_stmt|;
name|ext_ptr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|ext_sglist
index|[
name|i
index|]
operator|.
name|addr
expr_stmt|;
name|ext_ptr
operator|=
name|ext_ptr
operator|+
name|ext_watermark
expr_stmt|;
if|if
condition|(
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_BUS_ADDR
condition|)
block|{
comment|/* 			 * XXX KDM fix this! 			 */
name|panic
argument_list|(
literal|"need to implement bus address support"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|kern_ptr = bus_to_virt(kern_sglist[j].addr);
endif|#
directive|endif
block|}
else|else
name|kern_ptr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|kern_sglist
index|[
name|j
index|]
operator|.
name|addr
expr_stmt|;
name|kern_ptr
operator|=
name|kern_ptr
operator|+
name|kern_watermark
expr_stmt|;
name|kern_watermark
operator|+=
name|len_to_copy
expr_stmt|;
name|ext_watermark
operator|+=
name|len_to_copy
expr_stmt|;
if|if
condition|(
operator|(
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_DATA_MASK
operator|)
operator|==
name|CTL_FLAG_DATA_IN
condition|)
block|{
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_ioctl_do_datamove: copying %d "
literal|"bytes to user\n"
operator|,
name|len_to_copy
operator|)
argument_list|)
expr_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_ioctl_do_datamove: from %p "
literal|"to %p\n"
operator|,
name|kern_ptr
operator|,
name|ext_ptr
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyout
argument_list|(
name|kern_ptr
argument_list|,
name|ext_ptr
argument_list|,
name|len_to_copy
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ctl_set_internal_failure
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|0
argument_list|,
comment|/*retry_count*/
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
block|}
else|else
block|{
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_ioctl_do_datamove: copying %d "
literal|"bytes from user\n"
operator|,
name|len_to_copy
operator|)
argument_list|)
expr_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_ioctl_do_datamove: from %p "
literal|"to %p\n"
operator|,
name|ext_ptr
operator|,
name|kern_ptr
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyin
argument_list|(
name|ext_ptr
argument_list|,
name|kern_ptr
argument_list|,
name|len_to_copy
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ctl_set_internal_failure
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|0
argument_list|,
comment|/*retry_count*/
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
block|}
name|len_copied
operator|+=
name|len_to_copy
expr_stmt|;
if|if
condition|(
name|ext_sglist
index|[
name|i
index|]
operator|.
name|len
operator|==
name|ext_watermark
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|ext_watermark
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|kern_sglist
index|[
name|j
index|]
operator|.
name|len
operator|==
name|kern_watermark
condition|)
block|{
name|j
operator|++
expr_stmt|;
name|kern_watermark
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|ctsio
operator|->
name|ext_data_filled
operator|+=
name|len_copied
expr_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_ioctl_do_datamove: ext_sg_entries: %d, "
literal|"kern_sg_entries: %d\n"
operator|,
name|ext_sg_entries
operator|,
name|kern_sg_entries
operator|)
argument_list|)
expr_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_ioctl_do_datamove: ext_data_len = %d, "
literal|"kern_data_len = %d\n"
operator|,
name|ctsio
operator|->
name|ext_data_len
operator|,
name|ctsio
operator|->
name|kern_data_len
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX KDM set residual?? */
name|bailout
label|:
if|if
condition|(
name|ext_sglist_malloced
operator|!=
literal|0
condition|)
name|free
argument_list|(
name|ext_sglist
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Serialize a command that went down the "wrong" side, and so was sent to  * this controller for execution.  The logic is a little different than the  * standard case in ctl_scsiio_precheck().  Errors in this case need to get  * sent back to the other side, but in the success case, we execute the  * command on this side (XFER mode) or tell the other side to execute it  * (SER_ONLY mode).  */
end_comment

begin_function
specifier|static
name|int
name|ctl_serialize_other_sc_cmd
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|ctl_softc
decl_stmt|;
name|union
name|ctl_ha_msg
name|msg_info
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|uint32_t
name|targ_lun
decl_stmt|;
name|ctl_softc
operator|=
name|control_softc
expr_stmt|;
name|targ_lun
operator|=
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_mapped_lun
expr_stmt|;
name|lun
operator|=
name|ctl_softc
operator|->
name|ctl_luns
index|[
name|targ_lun
index|]
expr_stmt|;
if|if
condition|(
name|lun
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Why isn't LUN defined? The other side wouldn't 		 * send a cmd if the LUN is undefined. 		 */
name|printf
argument_list|(
literal|"%s: Bad JUJU!, LUN is NULL!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* "Logical unit not supported" */
name|ctl_set_sense_data
argument_list|(
operator|&
name|msg_info
operator|.
name|scsi
operator|.
name|sense_data
argument_list|,
name|lun
argument_list|,
comment|/*sense_format*/
name|SSD_TYPE_NONE
argument_list|,
comment|/*current_error*/
literal|1
argument_list|,
comment|/*sense_key*/
name|SSD_KEY_ILLEGAL_REQUEST
argument_list|,
comment|/*asc*/
literal|0x25
argument_list|,
comment|/*ascq*/
literal|0x00
argument_list|,
name|SSD_ELEM_NONE
argument_list|)
expr_stmt|;
name|msg_info
operator|.
name|scsi
operator|.
name|sense_len
operator|=
name|SSD_FULL_SIZE
expr_stmt|;
name|msg_info
operator|.
name|scsi
operator|.
name|scsi_status
operator|=
name|SCSI_STATUS_CHECK_COND
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|status
operator|=
name|CTL_SCSI_ERROR
operator||
name|CTL_AUTOSENSE
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|original_sc
operator|=
name|ctsio
operator|->
name|io_hdr
operator|.
name|original_sc
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|serializing_sc
operator|=
name|NULL
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_BAD_JUJU
expr_stmt|;
if|if
condition|(
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|msg_info
argument_list|,
sizeof|sizeof
argument_list|(
name|msg_info
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|>
name|CTL_HA_STATUS_SUCCESS
condition|)
block|{ 		}
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|lun
operator|->
name|ooa_queue
argument_list|,
operator|&
name|ctsio
operator|->
name|io_hdr
argument_list|,
name|ooa_links
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ctl_check_ooa
argument_list|(
name|lun
argument_list|,
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|,
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|TAILQ_PREV
argument_list|(
operator|&
name|ctsio
operator|->
name|io_hdr
argument_list|,
name|ctl_ooaq
argument_list|,
name|ooa_links
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|CTL_ACTION_BLOCK
case|:
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_BLOCKED
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|lun
operator|->
name|blocked_queue
argument_list|,
operator|&
name|ctsio
operator|->
name|io_hdr
argument_list|,
name|blocked_links
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_ACTION_PASS
case|:
case|case
name|CTL_ACTION_SKIP
case|:
if|if
condition|(
name|ctl_softc
operator|->
name|ha_mode
operator|==
name|CTL_HA_MODE_XFER
condition|)
block|{
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_IS_WAS_ON_RTR
expr_stmt|;
name|ctl_enqueue_rtr
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* send msg back to other side */
name|msg_info
operator|.
name|hdr
operator|.
name|original_sc
operator|=
name|ctsio
operator|->
name|io_hdr
operator|.
name|original_sc
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|serializing_sc
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_R2R
expr_stmt|;
if|#
directive|if
literal|0
block|printf("2. pOrig %x\n", (int)msg_info.hdr.original_sc);
endif|#
directive|endif
if|if
condition|(
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|msg_info
argument_list|,
sizeof|sizeof
argument_list|(
name|msg_info
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|>
name|CTL_HA_STATUS_SUCCESS
condition|)
block|{ 			}
block|}
break|break;
case|case
name|CTL_ACTION_OVERLAP
case|:
comment|/* OVERLAPPED COMMANDS ATTEMPTED */
name|ctl_set_sense_data
argument_list|(
operator|&
name|msg_info
operator|.
name|scsi
operator|.
name|sense_data
argument_list|,
name|lun
argument_list|,
comment|/*sense_format*/
name|SSD_TYPE_NONE
argument_list|,
comment|/*current_error*/
literal|1
argument_list|,
comment|/*sense_key*/
name|SSD_KEY_ILLEGAL_REQUEST
argument_list|,
comment|/*asc*/
literal|0x4E
argument_list|,
comment|/*ascq*/
literal|0x00
argument_list|,
name|SSD_ELEM_NONE
argument_list|)
expr_stmt|;
name|msg_info
operator|.
name|scsi
operator|.
name|sense_len
operator|=
name|SSD_FULL_SIZE
expr_stmt|;
name|msg_info
operator|.
name|scsi
operator|.
name|scsi_status
operator|=
name|SCSI_STATUS_CHECK_COND
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|status
operator|=
name|CTL_SCSI_ERROR
operator||
name|CTL_AUTOSENSE
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|original_sc
operator|=
name|ctsio
operator|->
name|io_hdr
operator|.
name|original_sc
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|serializing_sc
operator|=
name|NULL
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_BAD_JUJU
expr_stmt|;
if|#
directive|if
literal|0
block|printf("BAD JUJU:Major Bummer Overlap\n");
endif|#
directive|endif
name|TAILQ_REMOVE
argument_list|(
operator|&
name|lun
operator|->
name|ooa_queue
argument_list|,
operator|&
name|ctsio
operator|->
name|io_hdr
argument_list|,
name|ooa_links
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|msg_info
argument_list|,
sizeof|sizeof
argument_list|(
name|msg_info
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|>
name|CTL_HA_STATUS_SUCCESS
condition|)
block|{ 		}
break|break;
case|case
name|CTL_ACTION_OVERLAP_TAG
case|:
comment|/* TAGGED OVERLAPPED COMMANDS (NN = QUEUE TAG) */
name|ctl_set_sense_data
argument_list|(
operator|&
name|msg_info
operator|.
name|scsi
operator|.
name|sense_data
argument_list|,
name|lun
argument_list|,
comment|/*sense_format*/
name|SSD_TYPE_NONE
argument_list|,
comment|/*current_error*/
literal|1
argument_list|,
comment|/*sense_key*/
name|SSD_KEY_ILLEGAL_REQUEST
argument_list|,
comment|/*asc*/
literal|0x4D
argument_list|,
comment|/*ascq*/
name|ctsio
operator|->
name|tag_num
operator|&
literal|0xff
argument_list|,
name|SSD_ELEM_NONE
argument_list|)
expr_stmt|;
name|msg_info
operator|.
name|scsi
operator|.
name|sense_len
operator|=
name|SSD_FULL_SIZE
expr_stmt|;
name|msg_info
operator|.
name|scsi
operator|.
name|scsi_status
operator|=
name|SCSI_STATUS_CHECK_COND
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|status
operator|=
name|CTL_SCSI_ERROR
operator||
name|CTL_AUTOSENSE
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|original_sc
operator|=
name|ctsio
operator|->
name|io_hdr
operator|.
name|original_sc
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|serializing_sc
operator|=
name|NULL
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_BAD_JUJU
expr_stmt|;
if|#
directive|if
literal|0
block|printf("BAD JUJU:Major Bummer Overlap Tag\n");
endif|#
directive|endif
name|TAILQ_REMOVE
argument_list|(
operator|&
name|lun
operator|->
name|ooa_queue
argument_list|,
operator|&
name|ctsio
operator|->
name|io_hdr
argument_list|,
name|ooa_links
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|msg_info
argument_list|,
sizeof|sizeof
argument_list|(
name|msg_info
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|>
name|CTL_HA_STATUS_SUCCESS
condition|)
block|{ 		}
break|break;
case|case
name|CTL_ACTION_ERROR
case|:
default|default:
comment|/* "Internal target failure" */
name|ctl_set_sense_data
argument_list|(
operator|&
name|msg_info
operator|.
name|scsi
operator|.
name|sense_data
argument_list|,
name|lun
argument_list|,
comment|/*sense_format*/
name|SSD_TYPE_NONE
argument_list|,
comment|/*current_error*/
literal|1
argument_list|,
comment|/*sense_key*/
name|SSD_KEY_HARDWARE_ERROR
argument_list|,
comment|/*asc*/
literal|0x44
argument_list|,
comment|/*ascq*/
literal|0x00
argument_list|,
name|SSD_ELEM_NONE
argument_list|)
expr_stmt|;
name|msg_info
operator|.
name|scsi
operator|.
name|sense_len
operator|=
name|SSD_FULL_SIZE
expr_stmt|;
name|msg_info
operator|.
name|scsi
operator|.
name|scsi_status
operator|=
name|SCSI_STATUS_CHECK_COND
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|status
operator|=
name|CTL_SCSI_ERROR
operator||
name|CTL_AUTOSENSE
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|original_sc
operator|=
name|ctsio
operator|->
name|io_hdr
operator|.
name|original_sc
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|serializing_sc
operator|=
name|NULL
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_BAD_JUJU
expr_stmt|;
if|#
directive|if
literal|0
block|printf("BAD JUJU:Major Bummer HW Error\n");
endif|#
directive|endif
name|TAILQ_REMOVE
argument_list|(
operator|&
name|lun
operator|->
name|ooa_queue
argument_list|,
operator|&
name|ctsio
operator|->
name|io_hdr
argument_list|,
name|ooa_links
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|msg_info
argument_list|,
sizeof|sizeof
argument_list|(
name|msg_info
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|>
name|CTL_HA_STATUS_SUCCESS
condition|)
block|{ 		}
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_ioctl_submit_wait
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_fe_ioctl_params
name|params
decl_stmt|;
name|ctl_fe_ioctl_state
name|last_state
decl_stmt|;
name|int
name|done
decl_stmt|,
name|retval
decl_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|params
argument_list|,
sizeof|sizeof
argument_list|(
name|params
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|params
operator|.
name|ioctl_mtx
argument_list|,
literal|"ctliocmtx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|params
operator|.
name|sem
argument_list|,
literal|"ctlioccv"
argument_list|)
expr_stmt|;
name|params
operator|.
name|state
operator|=
name|CTL_IOCTL_INPROG
expr_stmt|;
name|last_state
operator|=
name|params
operator|.
name|state
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_FRONTEND
index|]
operator|.
name|ptr
operator|=
operator|&
name|params
expr_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_ioctl_submit_wait\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* This shouldn't happen */
if|if
condition|(
operator|(
name|retval
operator|=
name|ctl_queue
argument_list|(
name|io
argument_list|)
operator|)
operator|!=
name|CTL_RETVAL_COMPLETE
condition|)
return|return
operator|(
name|retval
operator|)
return|;
name|done
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|mtx_lock
argument_list|(
operator|&
name|params
operator|.
name|ioctl_mtx
argument_list|)
expr_stmt|;
comment|/* 		 * Check the state here, and don't sleep if the state has 		 * already changed (i.e. wakeup has already occured, but we 		 * weren't waiting yet). 		 */
if|if
condition|(
name|params
operator|.
name|state
operator|==
name|last_state
condition|)
block|{
comment|/* XXX KDM cv_wait_sig instead? */
name|cv_wait
argument_list|(
operator|&
name|params
operator|.
name|sem
argument_list|,
operator|&
name|params
operator|.
name|ioctl_mtx
argument_list|)
expr_stmt|;
block|}
name|last_state
operator|=
name|params
operator|.
name|state
expr_stmt|;
switch|switch
condition|(
name|params
operator|.
name|state
condition|)
block|{
case|case
name|CTL_IOCTL_INPROG
case|:
comment|/* Why did we wake up? */
comment|/* XXX KDM error here? */
name|mtx_unlock
argument_list|(
operator|&
name|params
operator|.
name|ioctl_mtx
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_IOCTL_DATAMOVE
case|:
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"got CTL_IOCTL_DATAMOVE\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 			 * change last_state back to INPROG to avoid 			 * deadlock on subsequent data moves. 			 */
name|params
operator|.
name|state
operator|=
name|last_state
operator|=
name|CTL_IOCTL_INPROG
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|params
operator|.
name|ioctl_mtx
argument_list|)
expr_stmt|;
name|ctl_ioctl_do_datamove
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
comment|/* 			 * Note that in some cases, most notably writes, 			 * this will queue the I/O and call us back later. 			 * In other cases, generally reads, this routine 			 * will immediately call back and wake us up, 			 * probably using our own context. 			 */
name|io
operator|->
name|scsiio
operator|.
name|be_move_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_IOCTL_DONE
case|:
name|mtx_unlock
argument_list|(
operator|&
name|params
operator|.
name|ioctl_mtx
argument_list|)
expr_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"got CTL_IOCTL_DONE\n"
operator|)
argument_list|)
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|mtx_unlock
argument_list|(
operator|&
name|params
operator|.
name|ioctl_mtx
argument_list|)
expr_stmt|;
comment|/* XXX KDM error here? */
break|break;
block|}
block|}
do|while
condition|(
name|done
operator|==
literal|0
condition|)
do|;
name|mtx_destroy
argument_list|(
operator|&
name|params
operator|.
name|ioctl_mtx
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|params
operator|.
name|sem
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_ioctl_datamove
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_fe_ioctl_params
modifier|*
name|params
decl_stmt|;
name|params
operator|=
operator|(
expr|struct
name|ctl_fe_ioctl_params
operator|*
operator|)
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_FRONTEND
index|]
operator|.
name|ptr
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|params
operator|->
name|ioctl_mtx
argument_list|)
expr_stmt|;
name|params
operator|->
name|state
operator|=
name|CTL_IOCTL_DATAMOVE
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|params
operator|->
name|sem
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|params
operator|->
name|ioctl_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_ioctl_done
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_fe_ioctl_params
modifier|*
name|params
decl_stmt|;
name|params
operator|=
operator|(
expr|struct
name|ctl_fe_ioctl_params
operator|*
operator|)
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_FRONTEND
index|]
operator|.
name|ptr
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|params
operator|->
name|ioctl_mtx
argument_list|)
expr_stmt|;
name|params
operator|->
name|state
operator|=
name|CTL_IOCTL_DONE
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|params
operator|->
name|sem
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|params
operator|->
name|ioctl_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_ioctl_hard_startstop_callback
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|cfi_metatask
modifier|*
name|metatask
parameter_list|)
block|{
name|struct
name|ctl_fe_ioctl_startstop_info
modifier|*
name|sd_info
decl_stmt|;
name|sd_info
operator|=
operator|(
expr|struct
name|ctl_fe_ioctl_startstop_info
operator|*
operator|)
name|arg
expr_stmt|;
name|sd_info
operator|->
name|hs_info
operator|.
name|status
operator|=
name|metatask
operator|->
name|status
expr_stmt|;
name|sd_info
operator|->
name|hs_info
operator|.
name|total_luns
operator|=
name|metatask
operator|->
name|taskinfo
operator|.
name|startstop
operator|.
name|total_luns
expr_stmt|;
name|sd_info
operator|->
name|hs_info
operator|.
name|luns_complete
operator|=
name|metatask
operator|->
name|taskinfo
operator|.
name|startstop
operator|.
name|luns_complete
expr_stmt|;
name|sd_info
operator|->
name|hs_info
operator|.
name|luns_failed
operator|=
name|metatask
operator|->
name|taskinfo
operator|.
name|startstop
operator|.
name|luns_failed
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|sd_info
operator|->
name|sem
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_ioctl_bbrread_callback
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|cfi_metatask
modifier|*
name|metatask
parameter_list|)
block|{
name|struct
name|ctl_fe_ioctl_bbrread_info
modifier|*
name|fe_bbr_info
decl_stmt|;
name|fe_bbr_info
operator|=
operator|(
expr|struct
name|ctl_fe_ioctl_bbrread_info
operator|*
operator|)
name|arg
expr_stmt|;
name|mtx_lock
argument_list|(
name|fe_bbr_info
operator|->
name|lock
argument_list|)
expr_stmt|;
name|fe_bbr_info
operator|->
name|bbr_info
operator|->
name|status
operator|=
name|metatask
operator|->
name|status
expr_stmt|;
name|fe_bbr_info
operator|->
name|bbr_info
operator|->
name|bbr_status
operator|=
name|metatask
operator|->
name|taskinfo
operator|.
name|bbrread
operator|.
name|status
expr_stmt|;
name|fe_bbr_info
operator|->
name|wakeup_done
operator|=
literal|1
expr_stmt|;
name|mtx_unlock
argument_list|(
name|fe_bbr_info
operator|->
name|lock
argument_list|)
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|fe_bbr_info
operator|->
name|sem
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns 0 for success, errno for failure.  */
end_comment

begin_function
specifier|static
name|int
name|ctl_ioctl_fill_ooa
parameter_list|(
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|,
name|uint32_t
modifier|*
name|cur_fill_num
parameter_list|,
name|struct
name|ctl_ooa
modifier|*
name|ooa_hdr
parameter_list|,
name|struct
name|ctl_ooa_entry
modifier|*
name|kern_entries
parameter_list|)
block|{
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|TAILQ_FIRST
argument_list|(
operator|&
name|lun
operator|->
name|ooa_queue
argument_list|)
init|;
operator|(
name|io
operator|!=
name|NULL
operator|)
condition|;
operator|(
operator|*
name|cur_fill_num
operator|)
operator|++
operator|,
name|io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|TAILQ_NEXT
argument_list|(
operator|&
name|io
operator|->
name|io_hdr
argument_list|,
name|ooa_links
argument_list|)
control|)
block|{
name|struct
name|ctl_ooa_entry
modifier|*
name|entry
decl_stmt|;
comment|/* 		 * If we've got more than we can fit, just count the 		 * remaining entries. 		 */
if|if
condition|(
operator|*
name|cur_fill_num
operator|>=
name|ooa_hdr
operator|->
name|alloc_num
condition|)
continue|continue;
name|entry
operator|=
operator|&
name|kern_entries
index|[
operator|*
name|cur_fill_num
index|]
expr_stmt|;
name|entry
operator|->
name|tag_num
operator|=
name|io
operator|->
name|scsiio
operator|.
name|tag_num
expr_stmt|;
name|entry
operator|->
name|lun_num
operator|=
name|lun
operator|->
name|lun
expr_stmt|;
ifdef|#
directive|ifdef
name|CTL_TIME_IO
name|entry
operator|->
name|start_bt
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|start_bt
expr_stmt|;
endif|#
directive|endif
name|bcopy
argument_list|(
name|io
operator|->
name|scsiio
operator|.
name|cdb
argument_list|,
name|entry
operator|->
name|cdb
argument_list|,
name|io
operator|->
name|scsiio
operator|.
name|cdb_len
argument_list|)
expr_stmt|;
name|entry
operator|->
name|cdb_len
operator|=
name|io
operator|->
name|scsiio
operator|.
name|cdb_len
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_BLOCKED
condition|)
name|entry
operator|->
name|cmd_flags
operator||=
name|CTL_OOACMD_FLAG_BLOCKED
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_DMA_INPROG
condition|)
name|entry
operator|->
name|cmd_flags
operator||=
name|CTL_OOACMD_FLAG_DMA
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ABORT
condition|)
name|entry
operator|->
name|cmd_flags
operator||=
name|CTL_OOACMD_FLAG_ABORT
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_IS_WAS_ON_RTR
condition|)
name|entry
operator|->
name|cmd_flags
operator||=
name|CTL_OOACMD_FLAG_RTR
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_DMA_QUEUED
condition|)
name|entry
operator|->
name|cmd_flags
operator||=
name|CTL_OOACMD_FLAG_DMA_QUEUED
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|ctl_copyin_alloc
parameter_list|(
name|void
modifier|*
name|user_addr
parameter_list|,
name|int
name|len
parameter_list|,
name|char
modifier|*
name|error_str
parameter_list|,
name|size_t
name|error_str_len
parameter_list|)
block|{
name|void
modifier|*
name|kptr
decl_stmt|;
name|kptr
operator|=
name|malloc
argument_list|(
name|len
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyin
argument_list|(
name|user_addr
argument_list|,
name|kptr
argument_list|,
name|len
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|error_str
argument_list|,
name|error_str_len
argument_list|,
literal|"Error copying %d bytes "
literal|"from user address %p to kernel address %p"
argument_list|,
name|len
argument_list|,
name|user_addr
argument_list|,
name|kptr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|kptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|kptr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_free_args
parameter_list|(
name|int
name|num_args
parameter_list|,
name|struct
name|ctl_be_arg
modifier|*
name|args
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|args
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_args
condition|;
name|i
operator|++
control|)
block|{
name|free
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|kname
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|kvalue
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|args
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ctl_be_arg
modifier|*
name|ctl_copyin_args
parameter_list|(
name|int
name|num_args
parameter_list|,
name|struct
name|ctl_be_arg
modifier|*
name|uargs
parameter_list|,
name|char
modifier|*
name|error_str
parameter_list|,
name|size_t
name|error_str_len
parameter_list|)
block|{
name|struct
name|ctl_be_arg
modifier|*
name|args
decl_stmt|;
name|int
name|i
decl_stmt|;
name|args
operator|=
name|ctl_copyin_alloc
argument_list|(
name|uargs
argument_list|,
name|num_args
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|args
argument_list|)
argument_list|,
name|error_str
argument_list|,
name|error_str_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|==
name|NULL
condition|)
goto|goto
name|bailout
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_args
condition|;
name|i
operator|++
control|)
block|{
name|args
index|[
name|i
index|]
operator|.
name|kname
operator|=
name|NULL
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|kvalue
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_args
condition|;
name|i
operator|++
control|)
block|{
name|uint8_t
modifier|*
name|tmpptr
decl_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|kname
operator|=
name|ctl_copyin_alloc
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|namelen
argument_list|,
name|error_str
argument_list|,
name|error_str_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|kname
operator|==
name|NULL
condition|)
goto|goto
name|bailout
goto|;
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|kname
index|[
name|args
index|[
name|i
index|]
operator|.
name|namelen
operator|-
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|snprintf
argument_list|(
name|error_str
argument_list|,
name|error_str_len
argument_list|,
literal|"Argument %d "
literal|"name is not NUL-terminated"
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|CTL_BEARG_RD
condition|)
block|{
name|tmpptr
operator|=
name|ctl_copyin_alloc
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|vallen
argument_list|,
name|error_str
argument_list|,
name|error_str_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpptr
operator|==
name|NULL
condition|)
goto|goto
name|bailout
goto|;
if|if
condition|(
operator|(
name|args
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|CTL_BEARG_ASCII
operator|)
operator|&&
operator|(
name|tmpptr
index|[
name|args
index|[
name|i
index|]
operator|.
name|vallen
operator|-
literal|1
index|]
operator|!=
literal|'\0'
operator|)
condition|)
block|{
name|snprintf
argument_list|(
name|error_str
argument_list|,
name|error_str_len
argument_list|,
literal|"Argument "
literal|"%d value is not NUL-terminated"
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|args
index|[
name|i
index|]
operator|.
name|kvalue
operator|=
name|tmpptr
expr_stmt|;
block|}
else|else
block|{
name|args
index|[
name|i
index|]
operator|.
name|kvalue
operator|=
name|malloc
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|vallen
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|args
operator|)
return|;
name|bailout
label|:
name|ctl_free_args
argument_list|(
name|num_args
argument_list|,
name|args
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_copyout_args
parameter_list|(
name|int
name|num_args
parameter_list|,
name|struct
name|ctl_be_arg
modifier|*
name|args
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_args
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|CTL_BEARG_WR
condition|)
name|copyout
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|kvalue
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|vallen
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Escape characters that are illegal or not recommended in XML.  */
end_comment

begin_function
name|int
name|ctl_sbuf_printf_esc
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|char
modifier|*
name|str
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
operator|*
name|str
condition|;
name|str
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|str
condition|)
block|{
case|case
literal|'&'
case|:
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"&amp;"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"&gt;"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"&lt;"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|retval
operator|=
name|sbuf_putc
argument_list|(
name|sb
argument_list|,
operator|*
name|str
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|softc
operator|=
name|control_softc
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|CTL_IO
case|:
block|{
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|void
modifier|*
name|pool_tmp
decl_stmt|;
comment|/* 		 * If we haven't been "enabled", don't allow any SCSI I/O 		 * to this FETD. 		 */
if|if
condition|(
operator|(
name|softc
operator|->
name|ioctl_info
operator|.
name|flags
operator|&
name|CTL_IOCTL_FLAG_ENABLED
operator|)
operator|==
literal|0
condition|)
block|{
name|retval
operator|=
name|EPERM
expr_stmt|;
break|break;
block|}
name|io
operator|=
name|ctl_alloc_io
argument_list|(
name|softc
operator|->
name|ioctl_info
operator|.
name|port
operator|.
name|ctl_pool_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ctl_ioctl: can't allocate ctl_io!\n"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|ENOSPC
expr_stmt|;
break|break;
block|}
comment|/* 		 * Need to save the pool reference so it doesn't get 		 * spammed by the user's ctl_io. 		 */
name|pool_tmp
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|pool
expr_stmt|;
name|memcpy
argument_list|(
name|io
argument_list|,
operator|(
name|void
operator|*
operator|)
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|io
argument_list|)
argument_list|)
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|pool
operator|=
name|pool_tmp
expr_stmt|;
comment|/* 		 * No status yet, so make sure the status is set properly. 		 */
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|=
name|CTL_STATUS_NONE
expr_stmt|;
comment|/* 		 * The user sets the initiator ID, target and LUN IDs. 		 */
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
operator|=
name|softc
operator|->
name|ioctl_info
operator|.
name|port
operator|.
name|targ_port
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_USER_REQ
expr_stmt|;
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|io_type
operator|==
name|CTL_IO_SCSI
operator|)
operator|&&
operator|(
name|io
operator|->
name|scsiio
operator|.
name|tag_type
operator|!=
name|CTL_TAG_UNTAGGED
operator|)
condition|)
name|io
operator|->
name|scsiio
operator|.
name|tag_num
operator|=
name|softc
operator|->
name|ioctl_info
operator|.
name|cur_tag_num
operator|++
expr_stmt|;
name|retval
operator|=
name|ctl_ioctl_submit_wait
argument_list|(
name|io
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|ctl_free_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
block|}
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|addr
argument_list|,
name|io
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|io
argument_list|)
argument_list|)
expr_stmt|;
comment|/* return this to our pool */
name|ctl_free_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CTL_ENABLE_PORT
case|:
case|case
name|CTL_DISABLE_PORT
case|:
case|case
name|CTL_SET_PORT_WWNS
case|:
block|{
name|struct
name|ctl_port
modifier|*
name|port
decl_stmt|;
name|struct
name|ctl_port_entry
modifier|*
name|entry
decl_stmt|;
name|entry
operator|=
operator|(
expr|struct
name|ctl_port_entry
operator|*
operator|)
name|addr
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|port
argument_list|,
argument|&softc->port_list
argument_list|,
argument|links
argument_list|)
block|{
name|int
name|action
decl_stmt|,
name|done
decl_stmt|;
name|action
operator|=
literal|0
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|entry
operator|->
name|port_type
operator|==
name|CTL_PORT_NONE
operator|)
operator|&&
operator|(
name|entry
operator|->
name|targ_port
operator|==
name|port
operator|->
name|targ_port
operator|)
condition|)
block|{
comment|/* 				 * If the user only wants to enable or 				 * disable or set WWNs on a specific port, 				 * do the operation and we're done. 				 */
name|action
operator|=
literal|1
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|->
name|port_type
operator|&
name|port
operator|->
name|port_type
condition|)
block|{
comment|/* 				 * Compare the user's type mask with the 				 * particular frontend type to see if we 				 * have a match. 				 */
name|action
operator|=
literal|1
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
comment|/* 				 * Make sure the user isn't trying to set 				 * WWNs on multiple ports at the same time. 				 */
if|if
condition|(
name|cmd
operator|==
name|CTL_SET_PORT_WWNS
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Can't set WWNs on "
literal|"multiple ports\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|retval
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|action
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * XXX KDM we have to drop the lock here, 				 * because the online/offline operations 				 * can potentially block.  We need to 				 * reference count the frontends so they 				 * can't go away, 				 */
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|CTL_ENABLE_PORT
condition|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|lun
argument_list|,
argument|&softc->lun_list
argument_list|,
argument|links
argument_list|)
block|{
name|port
operator|->
name|lun_enable
argument_list|(
name|port
operator|->
name|targ_lun_arg
argument_list|,
name|lun
operator|->
name|target
argument_list|,
name|lun
operator|->
name|lun
argument_list|)
expr_stmt|;
block|}
name|ctl_port_online
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|==
name|CTL_DISABLE_PORT
condition|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|ctl_port_offline
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|lun
argument_list|,
argument|&softc->lun_list
argument_list|,
argument|links
argument_list|)
block|{
name|port
operator|->
name|lun_disable
argument_list|(
name|port
operator|->
name|targ_lun_arg
argument_list|,
name|lun
operator|->
name|target
argument_list|,
name|lun
operator|->
name|lun
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|CTL_SET_PORT_WWNS
condition|)
name|ctl_port_set_wwns
argument_list|(
name|port
argument_list|,
operator|(
name|entry
operator|->
name|flags
operator|&
name|CTL_PORT_WWNN_VALID
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|,
name|entry
operator|->
name|wwnn
argument_list|,
operator|(
name|entry
operator|->
name|flags
operator|&
name|CTL_PORT_WWPN_VALID
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|,
name|entry
operator|->
name|wwpn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|done
operator|!=
literal|0
condition|)
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CTL_GET_PORT_LIST
case|:
block|{
name|struct
name|ctl_port
modifier|*
name|port
decl_stmt|;
name|struct
name|ctl_port_list
modifier|*
name|list
decl_stmt|;
name|int
name|i
decl_stmt|;
name|list
operator|=
operator|(
expr|struct
name|ctl_port_list
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|list
operator|->
name|alloc_len
operator|!=
operator|(
name|list
operator|->
name|alloc_num
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ctl_port_entry
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: CTL_GET_PORT_LIST: alloc_len %u != "
literal|"alloc_num %u * sizeof(struct ctl_port_entry) "
literal|"%zu\n"
argument_list|,
name|__func__
argument_list|,
name|list
operator|->
name|alloc_len
argument_list|,
name|list
operator|->
name|alloc_num
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ctl_port_entry
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|list
operator|->
name|fill_len
operator|=
literal|0
expr_stmt|;
name|list
operator|->
name|fill_num
operator|=
literal|0
expr_stmt|;
name|list
operator|->
name|dropped_num
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|port
argument_list|,
argument|&softc->port_list
argument_list|,
argument|links
argument_list|)
block|{
name|struct
name|ctl_port_entry
name|entry
decl_stmt|,
modifier|*
name|list_entry
decl_stmt|;
if|if
condition|(
name|list
operator|->
name|fill_num
operator|>=
name|list
operator|->
name|alloc_num
condition|)
block|{
name|list
operator|->
name|dropped_num
operator|++
expr_stmt|;
continue|continue;
block|}
name|entry
operator|.
name|port_type
operator|=
name|port
operator|->
name|port_type
expr_stmt|;
name|strlcpy
argument_list|(
name|entry
operator|.
name|port_name
argument_list|,
name|port
operator|->
name|port_name
argument_list|,
sizeof|sizeof
argument_list|(
name|entry
operator|.
name|port_name
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|.
name|targ_port
operator|=
name|port
operator|->
name|targ_port
expr_stmt|;
name|entry
operator|.
name|physical_port
operator|=
name|port
operator|->
name|physical_port
expr_stmt|;
name|entry
operator|.
name|virtual_port
operator|=
name|port
operator|->
name|virtual_port
expr_stmt|;
name|entry
operator|.
name|wwnn
operator|=
name|port
operator|->
name|wwnn
expr_stmt|;
name|entry
operator|.
name|wwpn
operator|=
name|port
operator|->
name|wwpn
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|status
operator|&
name|CTL_PORT_STATUS_ONLINE
condition|)
name|entry
operator|.
name|online
operator|=
literal|1
expr_stmt|;
else|else
name|entry
operator|.
name|online
operator|=
literal|0
expr_stmt|;
name|list_entry
operator|=
operator|&
name|list
operator|->
name|entries
index|[
name|i
index|]
expr_stmt|;
name|retval
operator|=
name|copyout
argument_list|(
operator|&
name|entry
argument_list|,
name|list_entry
argument_list|,
sizeof|sizeof
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: CTL_GET_PORT_LIST: copyout "
literal|"returned %d\n"
argument_list|,
name|__func__
argument_list|,
name|retval
argument_list|)
expr_stmt|;
break|break;
block|}
name|i
operator|++
expr_stmt|;
name|list
operator|->
name|fill_num
operator|++
expr_stmt|;
name|list
operator|->
name|fill_len
operator|+=
sizeof|sizeof
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
comment|/* 		 * If this is non-zero, we had a copyout fault, so there's 		 * probably no point in attempting to set the status inside 		 * the structure. 		 */
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|list
operator|->
name|dropped_num
operator|>
literal|0
condition|)
name|list
operator|->
name|status
operator|=
name|CTL_PORT_LIST_NEED_MORE_SPACE
expr_stmt|;
else|else
name|list
operator|->
name|status
operator|=
name|CTL_PORT_LIST_OK
expr_stmt|;
break|break;
block|}
case|case
name|CTL_DUMP_OOA
case|:
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|char
name|printbuf
index|[
literal|128
index|]
decl_stmt|;
name|struct
name|sbuf
name|sb
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Dumping OOA queues:\n"
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|lun
argument_list|,
argument|&softc->lun_list
argument_list|,
argument|links
argument_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|TAILQ_FIRST
argument_list|(
operator|&
name|lun
operator|->
name|ooa_queue
argument_list|)
init|;
name|io
operator|!=
name|NULL
condition|;
name|io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|TAILQ_NEXT
argument_list|(
operator|&
name|io
operator|->
name|io_hdr
argument_list|,
name|ooa_links
argument_list|)
control|)
block|{
name|sbuf_new
argument_list|(
operator|&
name|sb
argument_list|,
name|printbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|printbuf
argument_list|)
argument_list|,
name|SBUF_FIXEDLEN
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"LUN %jd tag 0x%04x%s%s%s%s: "
argument_list|,
operator|(
name|intmax_t
operator|)
name|lun
operator|->
name|lun
argument_list|,
name|io
operator|->
name|scsiio
operator|.
name|tag_num
argument_list|,
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_BLOCKED
operator|)
condition|?
literal|""
else|:
literal|" BLOCKED"
argument_list|,
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_DMA_INPROG
operator|)
condition|?
literal|" DMA"
else|:
literal|""
argument_list|,
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ABORT
operator|)
condition|?
literal|" ABORT"
else|:
literal|""
argument_list|,
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_IS_WAS_ON_RTR
operator|)
condition|?
literal|" RTR"
else|:
literal|""
argument_list|)
expr_stmt|;
name|ctl_scsi_command_string
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|,
name|NULL
argument_list|,
operator|&
name|sb
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|sbuf_data
argument_list|(
operator|&
name|sb
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"OOA queues dump done\n"
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CTL_GET_OOA
case|:
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|struct
name|ctl_ooa
modifier|*
name|ooa_hdr
decl_stmt|;
name|struct
name|ctl_ooa_entry
modifier|*
name|entries
decl_stmt|;
name|uint32_t
name|cur_fill_num
decl_stmt|;
name|ooa_hdr
operator|=
operator|(
expr|struct
name|ctl_ooa
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
operator|(
name|ooa_hdr
operator|->
name|alloc_len
operator|==
literal|0
operator|)
operator|||
operator|(
name|ooa_hdr
operator|->
name|alloc_num
operator|==
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: CTL_GET_OOA: alloc len %u and alloc num %u "
literal|"must be non-zero\n"
argument_list|,
name|__func__
argument_list|,
name|ooa_hdr
operator|->
name|alloc_len
argument_list|,
name|ooa_hdr
operator|->
name|alloc_num
argument_list|)
expr_stmt|;
name|retval
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ooa_hdr
operator|->
name|alloc_len
operator|!=
operator|(
name|ooa_hdr
operator|->
name|alloc_num
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ctl_ooa_entry
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: CTL_GET_OOA: alloc len %u must be alloc "
literal|"num %d * sizeof(struct ctl_ooa_entry) %zd\n"
argument_list|,
name|__func__
argument_list|,
name|ooa_hdr
operator|->
name|alloc_len
argument_list|,
name|ooa_hdr
operator|->
name|alloc_num
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ctl_ooa_entry
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|entries
operator|=
name|malloc
argument_list|(
name|ooa_hdr
operator|->
name|alloc_len
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|entries
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: could not allocate %d bytes for OOA "
literal|"dump\n"
argument_list|,
name|__func__
argument_list|,
name|ooa_hdr
operator|->
name|alloc_len
argument_list|)
expr_stmt|;
name|retval
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|ooa_hdr
operator|->
name|flags
operator|&
name|CTL_OOA_FLAG_ALL_LUNS
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|ooa_hdr
operator|->
name|lun_num
operator|>=
name|CTL_MAX_LUNS
operator|)
operator|||
operator|(
name|softc
operator|->
name|ctl_luns
index|[
name|ooa_hdr
operator|->
name|lun_num
index|]
operator|==
name|NULL
operator|)
operator|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|entries
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: CTL_GET_OOA: invalid LUN %ju\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ooa_hdr
operator|->
name|lun_num
argument_list|)
expr_stmt|;
name|retval
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|cur_fill_num
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ooa_hdr
operator|->
name|flags
operator|&
name|CTL_OOA_FLAG_ALL_LUNS
condition|)
block|{
name|STAILQ_FOREACH
argument_list|(
argument|lun
argument_list|,
argument|&softc->lun_list
argument_list|,
argument|links
argument_list|)
block|{
name|retval
operator|=
name|ctl_ioctl_fill_ooa
argument_list|(
name|lun
argument_list|,
operator|&
name|cur_fill_num
argument_list|,
name|ooa_hdr
argument_list|,
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|entries
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|lun
operator|=
name|softc
operator|->
name|ctl_luns
index|[
name|ooa_hdr
operator|->
name|lun_num
index|]
expr_stmt|;
name|retval
operator|=
name|ctl_ioctl_fill_ooa
argument_list|(
name|lun
argument_list|,
operator|&
name|cur_fill_num
argument_list|,
name|ooa_hdr
argument_list|,
name|entries
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|ooa_hdr
operator|->
name|fill_num
operator|=
name|min
argument_list|(
name|cur_fill_num
argument_list|,
name|ooa_hdr
operator|->
name|alloc_num
argument_list|)
expr_stmt|;
name|ooa_hdr
operator|->
name|fill_len
operator|=
name|ooa_hdr
operator|->
name|fill_num
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ctl_ooa_entry
argument_list|)
expr_stmt|;
name|retval
operator|=
name|copyout
argument_list|(
name|entries
argument_list|,
name|ooa_hdr
operator|->
name|entries
argument_list|,
name|ooa_hdr
operator|->
name|fill_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: error copying out %d bytes for OOA dump\n"
argument_list|,
name|__func__
argument_list|,
name|ooa_hdr
operator|->
name|fill_len
argument_list|)
expr_stmt|;
block|}
name|getbintime
argument_list|(
operator|&
name|ooa_hdr
operator|->
name|cur_bt
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_fill_num
operator|>
name|ooa_hdr
operator|->
name|alloc_num
condition|)
block|{
name|ooa_hdr
operator|->
name|dropped_num
operator|=
name|cur_fill_num
operator|-
name|ooa_hdr
operator|->
name|alloc_num
expr_stmt|;
name|ooa_hdr
operator|->
name|status
operator|=
name|CTL_OOA_NEED_MORE_SPACE
expr_stmt|;
block|}
else|else
block|{
name|ooa_hdr
operator|->
name|dropped_num
operator|=
literal|0
expr_stmt|;
name|ooa_hdr
operator|->
name|status
operator|=
name|CTL_OOA_OK
expr_stmt|;
block|}
name|free
argument_list|(
name|entries
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CTL_CHECK_OOA
case|:
block|{
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|struct
name|ctl_ooa_info
modifier|*
name|ooa_info
decl_stmt|;
name|ooa_info
operator|=
operator|(
expr|struct
name|ctl_ooa_info
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|ooa_info
operator|->
name|lun_id
operator|>=
name|CTL_MAX_LUNS
condition|)
block|{
name|ooa_info
operator|->
name|status
operator|=
name|CTL_OOA_INVALID_LUN
expr_stmt|;
break|break;
block|}
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|lun
operator|=
name|softc
operator|->
name|ctl_luns
index|[
name|ooa_info
operator|->
name|lun_id
index|]
expr_stmt|;
if|if
condition|(
name|lun
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|ooa_info
operator|->
name|status
operator|=
name|CTL_OOA_INVALID_LUN
expr_stmt|;
break|break;
block|}
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|ooa_info
operator|->
name|num_entries
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|TAILQ_FIRST
argument_list|(
operator|&
name|lun
operator|->
name|ooa_queue
argument_list|)
init|;
name|io
operator|!=
name|NULL
condition|;
name|io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|TAILQ_NEXT
argument_list|(
operator|&
name|io
operator|->
name|io_hdr
argument_list|,
name|ooa_links
argument_list|)
control|)
block|{
name|ooa_info
operator|->
name|num_entries
operator|++
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ooa_info
operator|->
name|status
operator|=
name|CTL_OOA_SUCCESS
expr_stmt|;
break|break;
block|}
case|case
name|CTL_HARD_START
case|:
case|case
name|CTL_HARD_STOP
case|:
block|{
name|struct
name|ctl_fe_ioctl_startstop_info
name|ss_info
decl_stmt|;
name|struct
name|cfi_metatask
modifier|*
name|metatask
decl_stmt|;
name|struct
name|mtx
name|hs_mtx
decl_stmt|;
name|mtx_init
argument_list|(
operator|&
name|hs_mtx
argument_list|,
literal|"HS Mutex"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|ss_info
operator|.
name|sem
argument_list|,
literal|"hard start/stop cv"
argument_list|)
expr_stmt|;
name|metatask
operator|=
name|cfi_alloc_metatask
argument_list|(
comment|/*can_wait*/
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|metatask
operator|==
name|NULL
condition|)
block|{
name|retval
operator|=
name|ENOMEM
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|hs_mtx
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cmd
operator|==
name|CTL_HARD_START
condition|)
name|metatask
operator|->
name|tasktype
operator|=
name|CFI_TASK_STARTUP
expr_stmt|;
else|else
name|metatask
operator|->
name|tasktype
operator|=
name|CFI_TASK_SHUTDOWN
expr_stmt|;
name|metatask
operator|->
name|callback
operator|=
name|ctl_ioctl_hard_startstop_callback
expr_stmt|;
name|metatask
operator|->
name|callback_arg
operator|=
operator|&
name|ss_info
expr_stmt|;
name|cfi_action
argument_list|(
name|metatask
argument_list|)
expr_stmt|;
comment|/* Wait for the callback */
name|mtx_lock
argument_list|(
operator|&
name|hs_mtx
argument_list|)
expr_stmt|;
name|cv_wait_sig
argument_list|(
operator|&
name|ss_info
operator|.
name|sem
argument_list|,
operator|&
name|hs_mtx
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|hs_mtx
argument_list|)
expr_stmt|;
comment|/* 		 * All information has been copied from the metatask by the 		 * time cv_broadcast() is called, so we free the metatask here. 		 */
name|cfi_free_metatask
argument_list|(
name|metatask
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|addr
argument_list|,
operator|&
name|ss_info
operator|.
name|hs_info
argument_list|,
sizeof|sizeof
argument_list|(
name|ss_info
operator|.
name|hs_info
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|hs_mtx
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CTL_BBRREAD
case|:
block|{
name|struct
name|ctl_bbrread_info
modifier|*
name|bbr_info
decl_stmt|;
name|struct
name|ctl_fe_ioctl_bbrread_info
name|fe_bbr_info
decl_stmt|;
name|struct
name|mtx
name|bbr_mtx
decl_stmt|;
name|struct
name|cfi_metatask
modifier|*
name|metatask
decl_stmt|;
name|bbr_info
operator|=
operator|(
expr|struct
name|ctl_bbrread_info
operator|*
operator|)
name|addr
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|fe_bbr_info
argument_list|,
sizeof|sizeof
argument_list|(
name|fe_bbr_info
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|bbr_mtx
argument_list|,
sizeof|sizeof
argument_list|(
name|bbr_mtx
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|bbr_mtx
argument_list|,
literal|"BBR Mutex"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|fe_bbr_info
operator|.
name|bbr_info
operator|=
name|bbr_info
expr_stmt|;
name|fe_bbr_info
operator|.
name|lock
operator|=
operator|&
name|bbr_mtx
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|fe_bbr_info
operator|.
name|sem
argument_list|,
literal|"BBR read cv"
argument_list|)
expr_stmt|;
name|metatask
operator|=
name|cfi_alloc_metatask
argument_list|(
comment|/*can_wait*/
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|metatask
operator|==
name|NULL
condition|)
block|{
name|mtx_destroy
argument_list|(
operator|&
name|bbr_mtx
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|fe_bbr_info
operator|.
name|sem
argument_list|)
expr_stmt|;
name|retval
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|metatask
operator|->
name|tasktype
operator|=
name|CFI_TASK_BBRREAD
expr_stmt|;
name|metatask
operator|->
name|callback
operator|=
name|ctl_ioctl_bbrread_callback
expr_stmt|;
name|metatask
operator|->
name|callback_arg
operator|=
operator|&
name|fe_bbr_info
expr_stmt|;
name|metatask
operator|->
name|taskinfo
operator|.
name|bbrread
operator|.
name|lun_num
operator|=
name|bbr_info
operator|->
name|lun_num
expr_stmt|;
name|metatask
operator|->
name|taskinfo
operator|.
name|bbrread
operator|.
name|lba
operator|=
name|bbr_info
operator|->
name|lba
expr_stmt|;
name|metatask
operator|->
name|taskinfo
operator|.
name|bbrread
operator|.
name|len
operator|=
name|bbr_info
operator|->
name|len
expr_stmt|;
name|cfi_action
argument_list|(
name|metatask
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|bbr_mtx
argument_list|)
expr_stmt|;
while|while
condition|(
name|fe_bbr_info
operator|.
name|wakeup_done
operator|==
literal|0
condition|)
name|cv_wait_sig
argument_list|(
operator|&
name|fe_bbr_info
operator|.
name|sem
argument_list|,
operator|&
name|bbr_mtx
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|bbr_mtx
argument_list|)
expr_stmt|;
name|bbr_info
operator|->
name|status
operator|=
name|metatask
operator|->
name|status
expr_stmt|;
name|bbr_info
operator|->
name|bbr_status
operator|=
name|metatask
operator|->
name|taskinfo
operator|.
name|bbrread
operator|.
name|status
expr_stmt|;
name|bbr_info
operator|->
name|scsi_status
operator|=
name|metatask
operator|->
name|taskinfo
operator|.
name|bbrread
operator|.
name|scsi_status
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|bbr_info
operator|->
name|sense_data
argument_list|,
operator|&
name|metatask
operator|->
name|taskinfo
operator|.
name|bbrread
operator|.
name|sense_data
argument_list|,
name|ctl_min
argument_list|(
sizeof|sizeof
argument_list|(
name|bbr_info
operator|->
name|sense_data
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|metatask
operator|->
name|taskinfo
operator|.
name|bbrread
operator|.
name|sense_data
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|cfi_free_metatask
argument_list|(
name|metatask
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|bbr_mtx
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|fe_bbr_info
operator|.
name|sem
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CTL_DELAY_IO
case|:
block|{
name|struct
name|ctl_io_delay_info
modifier|*
name|delay_info
decl_stmt|;
ifdef|#
directive|ifdef
name|CTL_IO_DELAY
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
endif|#
directive|endif
comment|/* CTL_IO_DELAY */
name|delay_info
operator|=
operator|(
expr|struct
name|ctl_io_delay_info
operator|*
operator|)
name|addr
expr_stmt|;
ifdef|#
directive|ifdef
name|CTL_IO_DELAY
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|delay_info
operator|->
name|lun_id
operator|>=
name|CTL_MAX_LUNS
operator|)
operator|||
operator|(
name|softc
operator|->
name|ctl_luns
index|[
name|delay_info
operator|->
name|lun_id
index|]
operator|==
name|NULL
operator|)
condition|)
block|{
name|delay_info
operator|->
name|status
operator|=
name|CTL_DELAY_STATUS_INVALID_LUN
expr_stmt|;
block|}
else|else
block|{
name|lun
operator|=
name|softc
operator|->
name|ctl_luns
index|[
name|delay_info
operator|->
name|lun_id
index|]
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|delay_info
operator|->
name|status
operator|=
name|CTL_DELAY_STATUS_OK
expr_stmt|;
switch|switch
condition|(
name|delay_info
operator|->
name|delay_type
condition|)
block|{
case|case
name|CTL_DELAY_TYPE_CONT
case|:
break|break;
case|case
name|CTL_DELAY_TYPE_ONESHOT
case|:
break|break;
default|default:
name|delay_info
operator|->
name|status
operator|=
name|CTL_DELAY_STATUS_INVALID_TYPE
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|delay_info
operator|->
name|delay_loc
condition|)
block|{
case|case
name|CTL_DELAY_LOC_DATAMOVE
case|:
name|lun
operator|->
name|delay_info
operator|.
name|datamove_type
operator|=
name|delay_info
operator|->
name|delay_type
expr_stmt|;
name|lun
operator|->
name|delay_info
operator|.
name|datamove_delay
operator|=
name|delay_info
operator|->
name|delay_secs
expr_stmt|;
break|break;
case|case
name|CTL_DELAY_LOC_DONE
case|:
name|lun
operator|->
name|delay_info
operator|.
name|done_type
operator|=
name|delay_info
operator|->
name|delay_type
expr_stmt|;
name|lun
operator|->
name|delay_info
operator|.
name|done_delay
operator|=
name|delay_info
operator|->
name|delay_secs
expr_stmt|;
break|break;
default|default:
name|delay_info
operator|->
name|status
operator|=
name|CTL_DELAY_STATUS_INVALID_LOC
expr_stmt|;
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
else|#
directive|else
name|delay_info
operator|->
name|status
operator|=
name|CTL_DELAY_STATUS_NOT_IMPLEMENTED
expr_stmt|;
endif|#
directive|endif
comment|/* CTL_IO_DELAY */
break|break;
block|}
case|case
name|CTL_REALSYNC_SET
case|:
block|{
name|int
modifier|*
name|syncstate
decl_stmt|;
name|syncstate
operator|=
operator|(
name|int
operator|*
operator|)
name|addr
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|syncstate
condition|)
block|{
case|case
literal|0
case|:
name|softc
operator|->
name|flags
operator|&=
operator|~
name|CTL_FLAG_REAL_SYNC
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|softc
operator|->
name|flags
operator||=
name|CTL_FLAG_REAL_SYNC
expr_stmt|;
break|break;
default|default:
name|retval
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CTL_REALSYNC_GET
case|:
block|{
name|int
modifier|*
name|syncstate
decl_stmt|;
name|syncstate
operator|=
operator|(
name|int
operator|*
operator|)
name|addr
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|flags
operator|&
name|CTL_FLAG_REAL_SYNC
condition|)
operator|*
name|syncstate
operator|=
literal|1
expr_stmt|;
else|else
operator|*
name|syncstate
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CTL_SETSYNC
case|:
case|case
name|CTL_GETSYNC
case|:
block|{
name|struct
name|ctl_sync_info
modifier|*
name|sync_info
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|sync_info
operator|=
operator|(
expr|struct
name|ctl_sync_info
operator|*
operator|)
name|addr
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|lun
operator|=
name|softc
operator|->
name|ctl_luns
index|[
name|sync_info
operator|->
name|lun_id
index|]
expr_stmt|;
if|if
condition|(
name|lun
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|sync_info
operator|->
name|status
operator|=
name|CTL_GS_SYNC_NO_LUN
expr_stmt|;
block|}
comment|/* 		 * Get or set the sync interval.  We're not bounds checking 		 * in the set case, hopefully the user won't do something 		 * silly. 		 */
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|CTL_GETSYNC
condition|)
name|sync_info
operator|->
name|sync_interval
operator|=
name|lun
operator|->
name|sync_interval
expr_stmt|;
else|else
name|lun
operator|->
name|sync_interval
operator|=
name|sync_info
operator|->
name|sync_interval
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|sync_info
operator|->
name|status
operator|=
name|CTL_GS_SYNC_OK
expr_stmt|;
break|break;
block|}
case|case
name|CTL_GETSTATS
case|:
block|{
name|struct
name|ctl_stats
modifier|*
name|stats
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|int
name|i
decl_stmt|;
name|stats
operator|=
operator|(
expr|struct
name|ctl_stats
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ctl_lun_io_stats
argument_list|)
operator|*
name|softc
operator|->
name|num_luns
operator|)
operator|>
name|stats
operator|->
name|alloc_len
condition|)
block|{
name|stats
operator|->
name|status
operator|=
name|CTL_SS_NEED_MORE_SPACE
expr_stmt|;
name|stats
operator|->
name|num_luns
operator|=
name|softc
operator|->
name|num_luns
expr_stmt|;
break|break;
block|}
comment|/* 		 * XXX KDM no locking here.  If the LUN list changes, 		 * things can blow up. 		 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|lun
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|softc
operator|->
name|lun_list
argument_list|)
init|;
name|lun
operator|!=
name|NULL
condition|;
name|i
operator|++
operator|,
name|lun
operator|=
name|STAILQ_NEXT
argument_list|(
name|lun
argument_list|,
name|links
argument_list|)
control|)
block|{
name|retval
operator|=
name|copyout
argument_list|(
operator|&
name|lun
operator|->
name|stats
argument_list|,
operator|&
name|stats
operator|->
name|lun_stats
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|lun
operator|->
name|stats
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
block|}
name|stats
operator|->
name|num_luns
operator|=
name|softc
operator|->
name|num_luns
expr_stmt|;
name|stats
operator|->
name|fill_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ctl_lun_io_stats
argument_list|)
operator|*
name|softc
operator|->
name|num_luns
expr_stmt|;
name|stats
operator|->
name|status
operator|=
name|CTL_SS_OK
expr_stmt|;
ifdef|#
directive|ifdef
name|CTL_TIME_IO
name|stats
operator|->
name|flags
operator|=
name|CTL_STATS_FLAG_TIME_VALID
expr_stmt|;
else|#
directive|else
name|stats
operator|->
name|flags
operator|=
name|CTL_STATS_FLAG_NONE
expr_stmt|;
endif|#
directive|endif
name|getnanouptime
argument_list|(
operator|&
name|stats
operator|->
name|timestamp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CTL_ERROR_INJECT
case|:
block|{
name|struct
name|ctl_error_desc
modifier|*
name|err_desc
decl_stmt|,
modifier|*
name|new_err_desc
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|err_desc
operator|=
operator|(
expr|struct
name|ctl_error_desc
operator|*
operator|)
name|addr
expr_stmt|;
name|new_err_desc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new_err_desc
argument_list|)
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|err_desc
argument_list|,
name|new_err_desc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_err_desc
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|lun
operator|=
name|softc
operator|->
name|ctl_luns
index|[
name|err_desc
operator|->
name|lun_id
index|]
expr_stmt|;
if|if
condition|(
name|lun
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new_err_desc
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: CTL_ERROR_INJECT: invalid LUN %ju\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|uintmax_t
operator|)
name|err_desc
operator|->
name|lun_id
argument_list|)
expr_stmt|;
name|retval
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
comment|/* 		 * We could do some checking here to verify the validity 		 * of the request, but given the complexity of error 		 * injection requests, the checking logic would be fairly 		 * complex. 		 * 		 * For now, if the request is invalid, it just won't get 		 * executed and might get deleted. 		 */
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|lun
operator|->
name|error_list
argument_list|,
name|new_err_desc
argument_list|,
name|links
argument_list|)
expr_stmt|;
comment|/* 		 * XXX KDM check to make sure the serial number is unique, 		 * in case we somehow manage to wrap.  That shouldn't 		 * happen for a very long time, but it's the right thing to 		 * do. 		 */
name|new_err_desc
operator|->
name|serial
operator|=
name|lun
operator|->
name|error_serial
expr_stmt|;
name|err_desc
operator|->
name|serial
operator|=
name|lun
operator|->
name|error_serial
expr_stmt|;
name|lun
operator|->
name|error_serial
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CTL_ERROR_INJECT_DELETE
case|:
block|{
name|struct
name|ctl_error_desc
modifier|*
name|delete_desc
decl_stmt|,
modifier|*
name|desc
decl_stmt|,
modifier|*
name|desc2
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|int
name|delete_done
decl_stmt|;
name|delete_desc
operator|=
operator|(
expr|struct
name|ctl_error_desc
operator|*
operator|)
name|addr
expr_stmt|;
name|delete_done
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|lun
operator|=
name|softc
operator|->
name|ctl_luns
index|[
name|delete_desc
operator|->
name|lun_id
index|]
expr_stmt|;
if|if
condition|(
name|lun
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: CTL_ERROR_INJECT_DELETE: invalid LUN %ju\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|uintmax_t
operator|)
name|delete_desc
operator|->
name|lun_id
argument_list|)
expr_stmt|;
name|retval
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|desc
argument_list|,
argument|&lun->error_list
argument_list|,
argument|links
argument_list|,
argument|desc2
argument_list|)
block|{
if|if
condition|(
name|desc
operator|->
name|serial
operator|!=
name|delete_desc
operator|->
name|serial
condition|)
continue|continue;
name|STAILQ_REMOVE
argument_list|(
operator|&
name|lun
operator|->
name|error_list
argument_list|,
name|desc
argument_list|,
name|ctl_error_desc
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|desc
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|delete_done
operator|=
literal|1
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|delete_done
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: CTL_ERROR_INJECT_DELETE: can't find "
literal|"error serial %ju on LUN %u\n"
argument_list|,
name|__func__
argument_list|,
name|delete_desc
operator|->
name|serial
argument_list|,
name|delete_desc
operator|->
name|lun_id
argument_list|)
expr_stmt|;
name|retval
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
break|break;
block|}
case|case
name|CTL_DUMP_STRUCTS
case|:
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|idx
decl_stmt|;
name|struct
name|ctl_port
modifier|*
name|port
decl_stmt|;
name|struct
name|ctl_frontend
modifier|*
name|fe
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"CTL Persistent Reservation information start:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_MAX_LUNS
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|lun
operator|=
name|softc
operator|->
name|ctl_luns
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|lun
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_DISABLED
operator|)
operator|!=
literal|0
operator|)
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
name|CTL_MAX_PORTS
operator|*
literal|2
operator|)
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|CTL_MAX_INIT_PER_PORT
condition|;
name|k
operator|++
control|)
block|{
name|idx
operator|=
name|j
operator|*
name|CTL_MAX_INIT_PER_PORT
operator|+
name|k
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|pr_keys
index|[
name|idx
index|]
operator|==
literal|0
condition|)
continue|continue;
name|printf
argument_list|(
literal|"  LUN %d port %d iid %d key "
literal|"%#jx\n"
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
operator|(
name|uintmax_t
operator|)
name|lun
operator|->
name|pr_keys
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|printf
argument_list|(
literal|"CTL Persistent Reservation information end\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"CTL Ports:\n"
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|port
argument_list|,
argument|&softc->port_list
argument_list|,
argument|links
argument_list|)
block|{
name|printf
argument_list|(
literal|"  Port %d '%s' Frontend '%s' Type %u pp %d vp %d WWNN "
literal|"%#jx WWPN %#jx\n"
argument_list|,
name|port
operator|->
name|targ_port
argument_list|,
name|port
operator|->
name|port_name
argument_list|,
name|port
operator|->
name|frontend
operator|->
name|name
argument_list|,
name|port
operator|->
name|port_type
argument_list|,
name|port
operator|->
name|physical_port
argument_list|,
name|port
operator|->
name|virtual_port
argument_list|,
operator|(
name|uintmax_t
operator|)
name|port
operator|->
name|wwnn
argument_list|,
operator|(
name|uintmax_t
operator|)
name|port
operator|->
name|wwpn
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|CTL_MAX_INIT_PER_PORT
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|port
operator|->
name|wwpn_iid
index|[
name|j
index|]
operator|.
name|in_use
operator|==
literal|0
operator|&&
name|port
operator|->
name|wwpn_iid
index|[
name|j
index|]
operator|.
name|wwpn
operator|==
literal|0
operator|&&
name|port
operator|->
name|wwpn_iid
index|[
name|j
index|]
operator|.
name|name
operator|==
name|NULL
condition|)
continue|continue;
name|printf
argument_list|(
literal|"    iid %u use %d WWPN %#jx '%s'\n"
argument_list|,
name|j
argument_list|,
name|port
operator|->
name|wwpn_iid
index|[
name|j
index|]
operator|.
name|in_use
argument_list|,
operator|(
name|uintmax_t
operator|)
name|port
operator|->
name|wwpn_iid
index|[
name|j
index|]
operator|.
name|wwpn
argument_list|,
name|port
operator|->
name|wwpn_iid
index|[
name|j
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"CTL Port information end\n"
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
comment|/* 		 * XXX KDM calling this without a lock.  We'd likely want 		 * to drop the lock before calling the frontend's dump 		 * routine anyway. 		 */
name|printf
argument_list|(
literal|"CTL Frontends:\n"
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|fe
argument_list|,
argument|&softc->fe_list
argument_list|,
argument|links
argument_list|)
block|{
name|printf
argument_list|(
literal|"  Frontend '%s'\n"
argument_list|,
name|fe
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|fe
operator|->
name|fe_dump
operator|!=
name|NULL
condition|)
name|fe
operator|->
name|fe_dump
argument_list|()
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"CTL Frontend information end\n"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CTL_LUN_REQ
case|:
block|{
name|struct
name|ctl_lun_req
modifier|*
name|lun_req
decl_stmt|;
name|struct
name|ctl_backend_driver
modifier|*
name|backend
decl_stmt|;
name|lun_req
operator|=
operator|(
expr|struct
name|ctl_lun_req
operator|*
operator|)
name|addr
expr_stmt|;
name|backend
operator|=
name|ctl_backend_find
argument_list|(
name|lun_req
operator|->
name|backend
argument_list|)
expr_stmt|;
if|if
condition|(
name|backend
operator|==
name|NULL
condition|)
block|{
name|lun_req
operator|->
name|status
operator|=
name|CTL_LUN_ERROR
expr_stmt|;
name|snprintf
argument_list|(
name|lun_req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|lun_req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"Backend \"%s\" not found."
argument_list|,
name|lun_req
operator|->
name|backend
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|lun_req
operator|->
name|num_be_args
operator|>
literal|0
condition|)
block|{
name|lun_req
operator|->
name|kern_be_args
operator|=
name|ctl_copyin_args
argument_list|(
name|lun_req
operator|->
name|num_be_args
argument_list|,
name|lun_req
operator|->
name|be_args
argument_list|,
name|lun_req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|lun_req
operator|->
name|error_str
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun_req
operator|->
name|kern_be_args
operator|==
name|NULL
condition|)
block|{
name|lun_req
operator|->
name|status
operator|=
name|CTL_LUN_ERROR
expr_stmt|;
break|break;
block|}
block|}
name|retval
operator|=
name|backend
operator|->
name|ioctl
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|addr
argument_list|,
name|flag
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun_req
operator|->
name|num_be_args
operator|>
literal|0
condition|)
block|{
name|ctl_copyout_args
argument_list|(
name|lun_req
operator|->
name|num_be_args
argument_list|,
name|lun_req
operator|->
name|kern_be_args
argument_list|)
expr_stmt|;
name|ctl_free_args
argument_list|(
name|lun_req
operator|->
name|num_be_args
argument_list|,
name|lun_req
operator|->
name|kern_be_args
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|CTL_LUN_LIST
case|:
block|{
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|struct
name|ctl_lun_list
modifier|*
name|list
decl_stmt|;
name|struct
name|ctl_option
modifier|*
name|opt
decl_stmt|;
name|list
operator|=
operator|(
expr|struct
name|ctl_lun_list
operator|*
operator|)
name|addr
expr_stmt|;
comment|/* 		 * Allocate a fixed length sbuf here, based on the length 		 * of the user's buffer.  We could allocate an auto-extending 		 * buffer, and then tell the user how much larger our 		 * amount of data is than his buffer, but that presents 		 * some problems: 		 * 		 * 1.  The sbuf(9) routines use a blocking malloc, and so 		 *     we can't hold a lock while calling them with an 		 *     auto-extending buffer.  		 * 		 * 2.  There is not currently a LUN reference counting 		 *     mechanism, outside of outstanding transactions on 		 *     the LUN's OOA queue.  So a LUN could go away on us 		 *     while we're getting the LUN number, backend-specific 		 *     information, etc.  Thus, given the way things 		 *     currently work, we need to hold the CTL lock while 		 *     grabbing LUN information. 		 * 		 * So, from the user's standpoint, the best thing to do is 		 * allocate what he thinks is a reasonable buffer length, 		 * and then if he gets a CTL_LUN_LIST_NEED_MORE_SPACE error, 		 * double the buffer length and try again.  (And repeat 		 * that until he succeeds.) 		 */
name|sb
operator|=
name|sbuf_new
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|list
operator|->
name|alloc_len
argument_list|,
name|SBUF_FIXEDLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
block|{
name|list
operator|->
name|status
operator|=
name|CTL_LUN_LIST_ERROR
expr_stmt|;
name|snprintf
argument_list|(
name|list
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|list
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"Unable to allocate %d bytes for LUN list"
argument_list|,
name|list
operator|->
name|alloc_len
argument_list|)
expr_stmt|;
break|break;
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"<ctllunlist>\n"
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|lun
argument_list|,
argument|&softc->lun_list
argument_list|,
argument|links
argument_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"<lun id=\"%ju\">\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|lun
operator|->
name|lun
argument_list|)
expr_stmt|;
comment|/* 			 * Bail out as soon as we see that we've overfilled 			 * the buffer. 			 */
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\t<backend_type>%s"
literal|"</backend_type>\n"
argument_list|,
operator|(
name|lun
operator|->
name|backend
operator|==
name|NULL
operator|)
condition|?
literal|"none"
else|:
name|lun
operator|->
name|backend
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\t<lun_type>%d</lun_type>\n"
argument_list|,
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|lun
operator|->
name|backend
operator|==
name|NULL
condition|)
block|{
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"</lun>\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
continue|continue;
block|}
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\t<size>%ju</size>\n"
argument_list|,
operator|(
name|lun
operator|->
name|be_lun
operator|->
name|maxlba
operator|>
literal|0
operator|)
condition|?
name|lun
operator|->
name|be_lun
operator|->
name|maxlba
operator|+
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\t<blocksize>%u</blocksize>\n"
argument_list|,
name|lun
operator|->
name|be_lun
operator|->
name|blocksize
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\t<serial_number>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
name|retval
operator|=
name|ctl_sbuf_printf_esc
argument_list|(
name|sb
argument_list|,
name|lun
operator|->
name|be_lun
operator|->
name|serial_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"</serial_number>\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\t<device_id>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
name|retval
operator|=
name|ctl_sbuf_printf_esc
argument_list|(
name|sb
argument_list|,
name|lun
operator|->
name|be_lun
operator|->
name|device_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"</device_id>\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|lun
operator|->
name|backend
operator|->
name|lun_info
operator|!=
name|NULL
condition|)
block|{
name|retval
operator|=
name|lun
operator|->
name|backend
operator|->
name|lun_info
argument_list|(
name|lun
operator|->
name|be_lun
operator|->
name|be_lun
argument_list|,
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
block|}
name|STAILQ_FOREACH
argument_list|(
argument|opt
argument_list|,
argument|&lun->be_lun->options
argument_list|,
argument|links
argument_list|)
block|{
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\t<%s>%s</%s>\n"
argument_list|,
name|opt
operator|->
name|name
argument_list|,
name|opt
operator|->
name|value
argument_list|,
name|opt
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
block|}
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"</lun>\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lun
operator|!=
name|NULL
condition|)
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|retval
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"</ctllunlist>\n"
argument_list|)
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|retval
operator|=
literal|0
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|list
operator|->
name|status
operator|=
name|CTL_LUN_LIST_NEED_MORE_SPACE
expr_stmt|;
name|snprintf
argument_list|(
name|list
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|list
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"Out of space, %d bytes is too small"
argument_list|,
name|list
operator|->
name|alloc_len
argument_list|)
expr_stmt|;
break|break;
block|}
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|retval
operator|=
name|copyout
argument_list|(
name|sbuf_data
argument_list|(
name|sb
argument_list|)
argument_list|,
name|list
operator|->
name|lun_xml
argument_list|,
name|sbuf_len
argument_list|(
name|sb
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|list
operator|->
name|fill_len
operator|=
name|sbuf_len
argument_list|(
name|sb
argument_list|)
operator|+
literal|1
expr_stmt|;
name|list
operator|->
name|status
operator|=
name|CTL_LUN_LIST_OK
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CTL_ISCSI
case|:
block|{
name|struct
name|ctl_iscsi
modifier|*
name|ci
decl_stmt|;
name|struct
name|ctl_frontend
modifier|*
name|fe
decl_stmt|;
name|ci
operator|=
operator|(
expr|struct
name|ctl_iscsi
operator|*
operator|)
name|addr
expr_stmt|;
name|fe
operator|=
name|ctl_frontend_find
argument_list|(
literal|"iscsi"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fe
operator|==
name|NULL
condition|)
block|{
name|ci
operator|->
name|status
operator|=
name|CTL_ISCSI_ERROR
expr_stmt|;
name|snprintf
argument_list|(
name|ci
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|ci
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"Frontend \"iscsi\" not found."
argument_list|)
expr_stmt|;
break|break;
block|}
name|retval
operator|=
name|fe
operator|->
name|ioctl
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|addr
argument_list|,
name|flag
argument_list|,
name|td
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CTL_PORT_REQ
case|:
block|{
name|struct
name|ctl_req
modifier|*
name|req
decl_stmt|;
name|struct
name|ctl_frontend
modifier|*
name|fe
decl_stmt|;
name|req
operator|=
operator|(
expr|struct
name|ctl_req
operator|*
operator|)
name|addr
expr_stmt|;
name|fe
operator|=
name|ctl_frontend_find
argument_list|(
name|req
operator|->
name|driver
argument_list|)
expr_stmt|;
if|if
condition|(
name|fe
operator|==
name|NULL
condition|)
block|{
name|req
operator|->
name|status
operator|=
name|CTL_LUN_ERROR
expr_stmt|;
name|snprintf
argument_list|(
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"Frontend \"%s\" not found."
argument_list|,
name|req
operator|->
name|driver
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|req
operator|->
name|num_args
operator|>
literal|0
condition|)
block|{
name|req
operator|->
name|kern_args
operator|=
name|ctl_copyin_args
argument_list|(
name|req
operator|->
name|num_args
argument_list|,
name|req
operator|->
name|args
argument_list|,
name|req
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|error_str
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|kern_args
operator|==
name|NULL
condition|)
block|{
name|req
operator|->
name|status
operator|=
name|CTL_LUN_ERROR
expr_stmt|;
break|break;
block|}
block|}
name|retval
operator|=
name|fe
operator|->
name|ioctl
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|addr
argument_list|,
name|flag
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|num_args
operator|>
literal|0
condition|)
block|{
name|ctl_copyout_args
argument_list|(
name|req
operator|->
name|num_args
argument_list|,
name|req
operator|->
name|kern_args
argument_list|)
expr_stmt|;
name|ctl_free_args
argument_list|(
name|req
operator|->
name|num_args
argument_list|,
name|req
operator|->
name|kern_args
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|CTL_PORT_LIST
case|:
block|{
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|struct
name|ctl_port
modifier|*
name|port
decl_stmt|;
name|struct
name|ctl_lun_list
modifier|*
name|list
decl_stmt|;
name|struct
name|ctl_option
modifier|*
name|opt
decl_stmt|;
name|list
operator|=
operator|(
expr|struct
name|ctl_lun_list
operator|*
operator|)
name|addr
expr_stmt|;
name|sb
operator|=
name|sbuf_new
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|list
operator|->
name|alloc_len
argument_list|,
name|SBUF_FIXEDLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
block|{
name|list
operator|->
name|status
operator|=
name|CTL_LUN_LIST_ERROR
expr_stmt|;
name|snprintf
argument_list|(
name|list
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|list
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"Unable to allocate %d bytes for LUN list"
argument_list|,
name|list
operator|->
name|alloc_len
argument_list|)
expr_stmt|;
break|break;
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"<ctlportlist>\n"
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|port
argument_list|,
argument|&softc->port_list
argument_list|,
argument|links
argument_list|)
block|{
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"<targ_port id=\"%ju\">\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|port
operator|->
name|targ_port
argument_list|)
expr_stmt|;
comment|/* 			 * Bail out as soon as we see that we've overfilled 			 * the buffer. 			 */
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\t<frontend_type>%s"
literal|"</frontend_type>\n"
argument_list|,
name|port
operator|->
name|frontend
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\t<port_type>%d</port_type>\n"
argument_list|,
name|port
operator|->
name|port_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\t<online>%s</online>\n"
argument_list|,
operator|(
name|port
operator|->
name|status
operator|&
name|CTL_PORT_STATUS_ONLINE
operator|)
condition|?
literal|"YES"
else|:
literal|"NO"
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\t<port_name>%s</port_name>\n"
argument_list|,
name|port
operator|->
name|port_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\t<physical_port>%d</physical_port>\n"
argument_list|,
name|port
operator|->
name|physical_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\t<virtual_port>%d</virtual_port>\n"
argument_list|,
name|port
operator|->
name|virtual_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\t<wwnn>%#jx</wwnn>\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|port
operator|->
name|wwnn
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\t<wwpn>%#jx</wwpn>\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|port
operator|->
name|wwpn
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|port
operator|->
name|port_info
operator|!=
name|NULL
condition|)
block|{
name|retval
operator|=
name|port
operator|->
name|port_info
argument_list|(
name|port
operator|->
name|onoff_arg
argument_list|,
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
block|}
name|STAILQ_FOREACH
argument_list|(
argument|opt
argument_list|,
argument|&port->options
argument_list|,
argument|links
argument_list|)
block|{
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\t<%s>%s</%s>\n"
argument_list|,
name|opt
operator|->
name|name
argument_list|,
name|opt
operator|->
name|value
argument_list|,
name|opt
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
block|}
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"</targ_port>\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|retval
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|retval
operator|=
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"</ctlportlist>\n"
argument_list|)
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|retval
operator|=
literal|0
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|list
operator|->
name|status
operator|=
name|CTL_LUN_LIST_NEED_MORE_SPACE
expr_stmt|;
name|snprintf
argument_list|(
name|list
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|list
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"Out of space, %d bytes is too small"
argument_list|,
name|list
operator|->
name|alloc_len
argument_list|)
expr_stmt|;
break|break;
block|}
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|retval
operator|=
name|copyout
argument_list|(
name|sbuf_data
argument_list|(
name|sb
argument_list|)
argument_list|,
name|list
operator|->
name|lun_xml
argument_list|,
name|sbuf_len
argument_list|(
name|sb
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|list
operator|->
name|fill_len
operator|=
name|sbuf_len
argument_list|(
name|sb
argument_list|)
operator|+
literal|1
expr_stmt|;
name|list
operator|->
name|status
operator|=
name|CTL_LUN_LIST_OK
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
block|{
comment|/* XXX KDM should we fix this? */
if|#
directive|if
literal|0
block|struct ctl_backend_driver *backend; 		unsigned int type; 		int found;  		found = 0;
comment|/* 		 * We encode the backend type as the ioctl type for backend 		 * ioctls.  So parse it out here, and then search for a 		 * backend of this type. 		 */
block|type = _IOC_TYPE(cmd);  		STAILQ_FOREACH(backend,&softc->be_list, links) { 			if (backend->type == type) { 				found = 1; 				break; 			} 		} 		if (found == 0) { 			printf("ctl: unknown ioctl command %#lx or backend " 			       "%d\n", cmd, type); 			retval = EINVAL; 			break; 		} 		retval = backend->ioctl(dev, cmd, addr, flag, td);
endif|#
directive|endif
name|retval
operator|=
name|ENOTTY
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|ctl_get_initindex
parameter_list|(
name|struct
name|ctl_nexus
modifier|*
name|nexus
parameter_list|)
block|{
if|if
condition|(
name|nexus
operator|->
name|targ_port
operator|<
name|CTL_MAX_PORTS
condition|)
return|return
operator|(
name|nexus
operator|->
name|initid
operator|.
name|id
operator|+
operator|(
name|nexus
operator|->
name|targ_port
operator|*
name|CTL_MAX_INIT_PER_PORT
operator|)
operator|)
return|;
else|else
return|return
operator|(
name|nexus
operator|->
name|initid
operator|.
name|id
operator|+
operator|(
operator|(
name|nexus
operator|->
name|targ_port
operator|-
name|CTL_MAX_PORTS
operator|)
operator|*
name|CTL_MAX_INIT_PER_PORT
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|ctl_get_resindex
parameter_list|(
name|struct
name|ctl_nexus
modifier|*
name|nexus
parameter_list|)
block|{
return|return
operator|(
name|nexus
operator|->
name|initid
operator|.
name|id
operator|+
operator|(
name|nexus
operator|->
name|targ_port
operator|*
name|CTL_MAX_INIT_PER_PORT
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|ctl_port_idx
parameter_list|(
name|int
name|port_num
parameter_list|)
block|{
if|if
condition|(
name|port_num
operator|<
name|CTL_MAX_PORTS
condition|)
return|return
operator|(
name|port_num
operator|)
return|;
else|else
return|return
operator|(
name|port_num
operator|-
name|CTL_MAX_PORTS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|ctl_map_lun
parameter_list|(
name|int
name|port_num
parameter_list|,
name|uint32_t
name|lun_id
parameter_list|)
block|{
name|struct
name|ctl_port
modifier|*
name|port
decl_stmt|;
name|port
operator|=
name|control_softc
operator|->
name|ctl_ports
index|[
name|ctl_port_idx
argument_list|(
name|port_num
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|port
operator|==
name|NULL
condition|)
return|return
operator|(
name|UINT32_MAX
operator|)
return|;
if|if
condition|(
name|port
operator|->
name|lun_map
operator|==
name|NULL
condition|)
return|return
operator|(
name|lun_id
operator|)
return|;
return|return
operator|(
name|port
operator|->
name|lun_map
argument_list|(
name|port
operator|->
name|targ_lun_arg
argument_list|,
name|lun_id
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|ctl_map_lun_back
parameter_list|(
name|int
name|port_num
parameter_list|,
name|uint32_t
name|lun_id
parameter_list|)
block|{
name|struct
name|ctl_port
modifier|*
name|port
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|port
operator|=
name|control_softc
operator|->
name|ctl_ports
index|[
name|ctl_port_idx
argument_list|(
name|port_num
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|lun_map
operator|==
name|NULL
condition|)
return|return
operator|(
name|lun_id
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_MAX_LUNS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|port
operator|->
name|lun_map
argument_list|(
name|port
operator|->
name|targ_lun_arg
argument_list|,
name|i
argument_list|)
operator|==
name|lun_id
condition|)
return|return
operator|(
name|i
operator|)
return|;
block|}
return|return
operator|(
name|UINT32_MAX
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Note:  This only works for bitmask sizes that are at least 32 bits, and  * that are a power of 2.  */
end_comment

begin_function
name|int
name|ctl_ffz
parameter_list|(
name|uint32_t
modifier|*
name|mask
parameter_list|,
name|uint32_t
name|size
parameter_list|)
block|{
name|uint32_t
name|num_chunks
decl_stmt|,
name|num_pieces
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|num_chunks
operator|=
operator|(
name|size
operator|>>
literal|5
operator|)
expr_stmt|;
if|if
condition|(
name|num_chunks
operator|==
literal|0
condition|)
name|num_chunks
operator|++
expr_stmt|;
name|num_pieces
operator|=
name|ctl_min
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
literal|8
operator|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_chunks
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_pieces
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|mask
index|[
name|i
index|]
operator|&
operator|(
literal|1
operator|<<
name|j
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|(
name|i
operator|<<
literal|5
operator|)
operator|+
name|j
operator|)
return|;
block|}
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_set_mask
parameter_list|(
name|uint32_t
modifier|*
name|mask
parameter_list|,
name|uint32_t
name|bit
parameter_list|)
block|{
name|uint32_t
name|chunk
decl_stmt|,
name|piece
decl_stmt|;
name|chunk
operator|=
name|bit
operator|>>
literal|5
expr_stmt|;
name|piece
operator|=
name|bit
operator|%
operator|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
literal|8
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|mask
index|[
name|chunk
index|]
operator|&
operator|(
literal|1
operator|<<
name|piece
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|else
name|mask
index|[
name|chunk
index|]
operator||=
operator|(
literal|1
operator|<<
name|piece
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_clear_mask
parameter_list|(
name|uint32_t
modifier|*
name|mask
parameter_list|,
name|uint32_t
name|bit
parameter_list|)
block|{
name|uint32_t
name|chunk
decl_stmt|,
name|piece
decl_stmt|;
name|chunk
operator|=
name|bit
operator|>>
literal|5
expr_stmt|;
name|piece
operator|=
name|bit
operator|%
operator|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
literal|8
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|mask
index|[
name|chunk
index|]
operator|&
operator|(
literal|1
operator|<<
name|piece
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|else
name|mask
index|[
name|chunk
index|]
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|piece
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_is_set
parameter_list|(
name|uint32_t
modifier|*
name|mask
parameter_list|,
name|uint32_t
name|bit
parameter_list|)
block|{
name|uint32_t
name|chunk
decl_stmt|,
name|piece
decl_stmt|;
name|chunk
operator|=
name|bit
operator|>>
literal|5
expr_stmt|;
name|piece
operator|=
name|bit
operator|%
operator|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
literal|8
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|mask
index|[
name|chunk
index|]
operator|&
operator|(
literal|1
operator|<<
name|piece
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|unused
end_ifdef

begin_comment
comment|/*  * The bus, target and lun are optional, they can be filled in later.  * can_wait is used to determine whether we can wait on the malloc or not.  */
end_comment

begin_function
name|union
name|ctl_io
modifier|*
name|ctl_malloc_io
parameter_list|(
name|ctl_io_type
name|io_type
parameter_list|,
name|uint32_t
name|targ_port
parameter_list|,
name|uint32_t
name|targ_target
parameter_list|,
name|uint32_t
name|targ_lun
parameter_list|,
name|int
name|can_wait
parameter_list|)
block|{
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
if|if
condition|(
name|can_wait
condition|)
name|io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|io
argument_list|)
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
else|else
name|io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|io
argument_list|)
argument_list|,
name|M_CTL
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|!=
name|NULL
condition|)
block|{
name|io
operator|->
name|io_hdr
operator|.
name|io_type
operator|=
name|io_type
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|targ_port
operator|=
name|targ_port
expr_stmt|;
comment|/* 		 * XXX KDM this needs to change/go away.  We need to move 		 * to a preallocated pool of ctl_scsiio structures. 		 */
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_target
operator|.
name|id
operator|=
name|targ_target
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_lun
operator|=
name|targ_lun
expr_stmt|;
block|}
return|return
operator|(
name|io
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ctl_kfree_io
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|free
argument_list|(
name|io
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* unused */
end_comment

begin_comment
comment|/*  * ctl_softc, pool_type, total_ctl_io are passed in.  * npool is passed out.  */
end_comment

begin_function
name|int
name|ctl_pool_create
parameter_list|(
name|struct
name|ctl_softc
modifier|*
name|ctl_softc
parameter_list|,
name|ctl_pool_type
name|pool_type
parameter_list|,
name|uint32_t
name|total_ctl_io
parameter_list|,
name|struct
name|ctl_io_pool
modifier|*
modifier|*
name|npool
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|union
name|ctl_io
modifier|*
name|cur_io
decl_stmt|,
modifier|*
name|next_io
decl_stmt|;
name|struct
name|ctl_io_pool
modifier|*
name|pool
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|pool
operator|=
operator|(
expr|struct
name|ctl_io_pool
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pool
argument_list|)
argument_list|,
name|M_CTL
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|pool
operator|==
name|NULL
condition|)
block|{
name|retval
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|pool
operator|->
name|type
operator|=
name|pool_type
expr_stmt|;
name|pool
operator|->
name|ctl_softc
operator|=
name|ctl_softc
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ctl_softc
operator|->
name|pool_lock
argument_list|)
expr_stmt|;
name|pool
operator|->
name|id
operator|=
name|ctl_softc
operator|->
name|cur_pool_id
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ctl_softc
operator|->
name|pool_lock
argument_list|)
expr_stmt|;
name|pool
operator|->
name|flags
operator|=
name|CTL_POOL_FLAG_NONE
expr_stmt|;
name|pool
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
comment|/* Reference for validity. */
name|STAILQ_INIT
argument_list|(
operator|&
name|pool
operator|->
name|free_queue
argument_list|)
expr_stmt|;
comment|/* 	 * XXX KDM other options here: 	 * - allocate a page at a time 	 * - allocate one big chunk of memory. 	 * Page allocation might work well, but would take a little more 	 * tracking. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|total_ctl_io
condition|;
name|i
operator|++
control|)
block|{
name|cur_io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cur_io
argument_list|)
argument_list|,
name|M_CTLIO
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_io
operator|==
name|NULL
condition|)
block|{
name|retval
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|cur_io
operator|->
name|io_hdr
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pool
operator|->
name|free_queue
argument_list|,
operator|&
name|cur_io
operator|->
name|io_hdr
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|pool
operator|->
name|total_ctl_io
operator|++
expr_stmt|;
name|pool
operator|->
name|free_ctl_io
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|cur_io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|STAILQ_FIRST
argument_list|(
operator|&
name|pool
operator|->
name|free_queue
argument_list|)
init|;
name|cur_io
operator|!=
name|NULL
condition|;
name|cur_io
operator|=
name|next_io
control|)
block|{
name|next_io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|STAILQ_NEXT
argument_list|(
operator|&
name|cur_io
operator|->
name|io_hdr
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE
argument_list|(
operator|&
name|pool
operator|->
name|free_queue
argument_list|,
operator|&
name|cur_io
operator|->
name|io_hdr
argument_list|,
name|ctl_io_hdr
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cur_io
argument_list|,
name|M_CTLIO
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|pool
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|ctl_softc
operator|->
name|pool_lock
argument_list|)
expr_stmt|;
name|ctl_softc
operator|->
name|num_pools
operator|++
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ctl_softc
operator|->
name|io_pools
argument_list|,
name|pool
argument_list|,
name|links
argument_list|)
expr_stmt|;
comment|/* 	 * Increment our usage count if this is an external consumer, so we 	 * can't get unloaded until the external consumer (most likely a 	 * FETD) unloads and frees his pool. 	 * 	 * XXX KDM will this increment the caller's module use count, or 	 * mine? 	 */
if|#
directive|if
literal|0
block|if ((pool_type != CTL_POOL_EMERGENCY)&& (pool_type != CTL_POOL_INTERNAL)&& (pool_type != CTL_POOL_4OTHERSC)) 		MOD_INC_USE_COUNT;
endif|#
directive|endif
name|mtx_unlock
argument_list|(
operator|&
name|ctl_softc
operator|->
name|pool_lock
argument_list|)
expr_stmt|;
operator|*
name|npool
operator|=
name|pool
expr_stmt|;
name|bailout
label|:
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_pool_acquire
parameter_list|(
name|struct
name|ctl_io_pool
modifier|*
name|pool
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|pool
operator|->
name|ctl_softc
operator|->
name|pool_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|pool
operator|->
name|flags
operator|&
name|CTL_POOL_FLAG_INVALID
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|pool
operator|->
name|refcount
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_pool_release
parameter_list|(
name|struct
name|ctl_io_pool
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|ctl_softc
init|=
name|pool
operator|->
name|ctl_softc
decl_stmt|;
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|ctl_softc
operator|->
name|pool_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|pool
operator|->
name|refcount
operator|!=
literal|0
condition|)
return|return;
while|while
condition|(
operator|(
name|io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|STAILQ_FIRST
argument_list|(
operator|&
name|pool
operator|->
name|free_queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_REMOVE
argument_list|(
operator|&
name|pool
operator|->
name|free_queue
argument_list|,
operator|&
name|io
operator|->
name|io_hdr
argument_list|,
name|ctl_io_hdr
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|io
argument_list|,
name|M_CTLIO
argument_list|)
expr_stmt|;
block|}
name|STAILQ_REMOVE
argument_list|(
operator|&
name|ctl_softc
operator|->
name|io_pools
argument_list|,
name|pool
argument_list|,
name|ctl_io_pool
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|ctl_softc
operator|->
name|num_pools
operator|--
expr_stmt|;
comment|/* 	 * XXX KDM will this decrement the caller's usage count or mine? 	 */
if|#
directive|if
literal|0
block|if ((pool->type != CTL_POOL_EMERGENCY)&& (pool->type != CTL_POOL_INTERNAL)&& (pool->type != CTL_POOL_4OTHERSC)) 		MOD_DEC_USE_COUNT;
endif|#
directive|endif
name|free
argument_list|(
name|pool
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ctl_pool_free
parameter_list|(
name|struct
name|ctl_io_pool
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|ctl_softc
decl_stmt|;
if|if
condition|(
name|pool
operator|==
name|NULL
condition|)
return|return;
name|ctl_softc
operator|=
name|pool
operator|->
name|ctl_softc
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ctl_softc
operator|->
name|pool_lock
argument_list|)
expr_stmt|;
name|pool
operator|->
name|flags
operator||=
name|CTL_POOL_FLAG_INVALID
expr_stmt|;
name|ctl_pool_release
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ctl_softc
operator|->
name|pool_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine does not block (except for spinlocks of course).  * It tries to allocate a ctl_io union from the caller's pool as quickly as  * possible.  */
end_comment

begin_function
name|union
name|ctl_io
modifier|*
name|ctl_alloc_io
parameter_list|(
name|void
modifier|*
name|pool_ref
parameter_list|)
block|{
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|struct
name|ctl_softc
modifier|*
name|ctl_softc
decl_stmt|;
name|struct
name|ctl_io_pool
modifier|*
name|pool
decl_stmt|,
modifier|*
name|npool
decl_stmt|;
name|struct
name|ctl_io_pool
modifier|*
name|emergency_pool
decl_stmt|;
name|pool
operator|=
operator|(
expr|struct
name|ctl_io_pool
operator|*
operator|)
name|pool_ref
expr_stmt|;
if|if
condition|(
name|pool
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: pool is NULL\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|emergency_pool
operator|=
name|NULL
expr_stmt|;
name|ctl_softc
operator|=
name|pool
operator|->
name|ctl_softc
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ctl_softc
operator|->
name|pool_lock
argument_list|)
expr_stmt|;
comment|/* 	 * First, try to get the io structure from the user's pool. 	 */
if|if
condition|(
name|ctl_pool_acquire
argument_list|(
name|pool
argument_list|)
operator|==
literal|0
condition|)
block|{
name|io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|STAILQ_FIRST
argument_list|(
operator|&
name|pool
operator|->
name|free_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|pool
operator|->
name|free_queue
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|pool
operator|->
name|total_allocated
operator|++
expr_stmt|;
name|pool
operator|->
name|free_ctl_io
operator|--
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ctl_softc
operator|->
name|pool_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|io
operator|)
return|;
block|}
else|else
name|ctl_pool_release
argument_list|(
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If he doesn't have any io structures left, search for an 	 * emergency pool and grab one from there. 	 */
name|STAILQ_FOREACH
argument_list|(
argument|npool
argument_list|,
argument|&ctl_softc->io_pools
argument_list|,
argument|links
argument_list|)
block|{
if|if
condition|(
name|npool
operator|->
name|type
operator|!=
name|CTL_POOL_EMERGENCY
condition|)
continue|continue;
if|if
condition|(
name|ctl_pool_acquire
argument_list|(
name|npool
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|emergency_pool
operator|=
name|npool
expr_stmt|;
name|io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|STAILQ_FIRST
argument_list|(
operator|&
name|npool
operator|->
name|free_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|npool
operator|->
name|free_queue
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|npool
operator|->
name|total_allocated
operator|++
expr_stmt|;
name|npool
operator|->
name|free_ctl_io
operator|--
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ctl_softc
operator|->
name|pool_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|io
operator|)
return|;
block|}
else|else
name|ctl_pool_release
argument_list|(
name|npool
argument_list|)
expr_stmt|;
block|}
comment|/* Drop the spinlock before we malloc */
name|mtx_unlock
argument_list|(
operator|&
name|ctl_softc
operator|->
name|pool_lock
argument_list|)
expr_stmt|;
comment|/* 	 * The emergency pool (if it exists) didn't have one, so try an 	 * atomic (i.e. nonblocking) malloc and see if we get lucky. 	 */
name|io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|io
argument_list|)
argument_list|,
name|M_CTLIO
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * If the emergency pool exists but is empty, add this 		 * ctl_io to its list when it gets freed. 		 */
if|if
condition|(
name|emergency_pool
operator|!=
name|NULL
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|ctl_softc
operator|->
name|pool_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl_pool_acquire
argument_list|(
name|emergency_pool
argument_list|)
operator|==
literal|0
condition|)
block|{
name|io
operator|->
name|io_hdr
operator|.
name|pool
operator|=
name|emergency_pool
expr_stmt|;
name|emergency_pool
operator|->
name|total_ctl_io
operator|++
expr_stmt|;
comment|/* 				 * Need to bump this, otherwise 				 * total_allocated and total_freed won't 				 * match when we no longer have anything 				 * outstanding. 				 */
name|emergency_pool
operator|->
name|total_allocated
operator|++
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|ctl_softc
operator|->
name|pool_lock
argument_list|)
expr_stmt|;
block|}
else|else
name|io
operator|->
name|io_hdr
operator|.
name|pool
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|io
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ctl_free_io
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
if|if
condition|(
name|io
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * If this ctl_io has a pool, return it to that pool. 	 */
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|pool
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ctl_io_pool
modifier|*
name|pool
decl_stmt|;
name|pool
operator|=
operator|(
expr|struct
name|ctl_io_pool
operator|*
operator|)
name|io
operator|->
name|io_hdr
operator|.
name|pool
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|pool
operator|->
name|ctl_softc
operator|->
name|pool_lock
argument_list|)
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|io_type
operator|=
literal|0xff
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pool
operator|->
name|free_queue
argument_list|,
operator|&
name|io
operator|->
name|io_hdr
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|pool
operator|->
name|total_freed
operator|++
expr_stmt|;
name|pool
operator|->
name|free_ctl_io
operator|++
expr_stmt|;
name|ctl_pool_release
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|pool
operator|->
name|ctl_softc
operator|->
name|pool_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Otherwise, just free it.  We probably malloced it and 		 * the emergency pool wasn't available. 		 */
name|free
argument_list|(
name|io
argument_list|,
name|M_CTLIO
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ctl_zero_io
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|void
modifier|*
name|pool_ref
decl_stmt|;
if|if
condition|(
name|io
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * May need to preserve linked list pointers at some point too. 	 */
name|pool_ref
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|pool
expr_stmt|;
name|memset
argument_list|(
name|io
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|io
argument_list|)
argument_list|)
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|pool
operator|=
name|pool_ref
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine is currently used for internal copies of ctl_ios that need  * to persist for some reason after we've already returned status to the  * FETD.  (Thus the flag set.)  *  * XXX XXX  * Note that this makes a blind copy of all fields in the ctl_io, except  * for the pool reference.  This includes any memory that has been  * allocated!  That memory will no longer be valid after done has been  * called, so this would be VERY DANGEROUS for command that actually does  * any reads or writes.  Right now (11/7/2005), this is only used for immediate  * start and stop commands, which don't transfer any data, so this is not a  * problem.  If it is used for anything else, the caller would also need to  * allocate data buffer space and this routine would need to be modified to  * copy the data buffer(s) as well.  */
end_comment

begin_function
name|void
name|ctl_copy_io
parameter_list|(
name|union
name|ctl_io
modifier|*
name|src
parameter_list|,
name|union
name|ctl_io
modifier|*
name|dest
parameter_list|)
block|{
name|void
modifier|*
name|pool_ref
decl_stmt|;
if|if
condition|(
operator|(
name|src
operator|==
name|NULL
operator|)
operator|||
operator|(
name|dest
operator|==
name|NULL
operator|)
condition|)
return|return;
comment|/* 	 * May need to preserve linked list pointers at some point too. 	 */
name|pool_ref
operator|=
name|dest
operator|->
name|io_hdr
operator|.
name|pool
expr_stmt|;
name|memcpy
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|ctl_min
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|src
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dest
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dest
operator|->
name|io_hdr
operator|.
name|pool
operator|=
name|pool_ref
expr_stmt|;
comment|/* 	 * We need to know that this is an internal copy, and doesn't need 	 * to get passed back to the FETD that allocated it. 	 */
name|dest
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_INT_COPY
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|NEEDTOPORT
end_ifdef

begin_function
specifier|static
name|void
name|ctl_update_power_subpage
parameter_list|(
name|struct
name|copan_power_subpage
modifier|*
name|page
parameter_list|)
block|{
name|int
name|num_luns
decl_stmt|,
name|num_partitions
decl_stmt|,
name|config_type
decl_stmt|;
name|struct
name|ctl_softc
modifier|*
name|softc
decl_stmt|;
name|cs_BOOL_t
name|aor_present
decl_stmt|,
name|shelf_50pct_power
decl_stmt|;
name|cs_raidset_personality_t
name|rs_type
decl_stmt|;
name|int
name|max_active_luns
decl_stmt|;
name|softc
operator|=
name|control_softc
expr_stmt|;
comment|/* subtract out the processor LUN */
name|num_luns
operator|=
name|softc
operator|->
name|num_luns
operator|-
literal|1
expr_stmt|;
comment|/* 	 * Default to 7 LUNs active, which was the only number we allowed 	 * in the past. 	 */
name|max_active_luns
operator|=
literal|7
expr_stmt|;
name|num_partitions
operator|=
name|config_GetRsPartitionInfo
argument_list|()
expr_stmt|;
name|config_type
operator|=
name|config_GetConfigType
argument_list|()
expr_stmt|;
name|shelf_50pct_power
operator|=
name|config_GetShelfPowerMode
argument_list|()
expr_stmt|;
name|aor_present
operator|=
name|config_IsAorRsPresent
argument_list|()
expr_stmt|;
name|rs_type
operator|=
name|ddb_GetRsRaidType
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rs_type
operator|!=
name|CS_RAIDSET_PERSONALITY_RAID5
operator|)
operator|&&
operator|(
name|rs_type
operator|!=
name|CS_RAIDSET_PERSONALITY_RAID1
operator|)
condition|)
block|{
name|EPRINT
argument_list|(
literal|0
argument_list|,
literal|"Unsupported RS type %d!"
argument_list|,
name|rs_type
argument_list|)
expr_stmt|;
block|}
name|page
operator|->
name|total_luns
operator|=
name|num_luns
expr_stmt|;
switch|switch
condition|(
name|config_type
condition|)
block|{
case|case
literal|40
case|:
comment|/* 		 * In a 40 drive configuration, it doesn't matter what DC 		 * cards we have, whether we have AOR enabled or not, 		 * partitioning or not, or what type of RAIDset we have. 		 * In that scenario, we can power up every LUN we present 		 * to the user. 		 */
name|max_active_luns
operator|=
name|num_luns
expr_stmt|;
break|break;
case|case
literal|64
case|:
if|if
condition|(
name|shelf_50pct_power
operator|==
name|CS_FALSE
condition|)
block|{
comment|/* 25% power */
if|if
condition|(
name|aor_present
operator|==
name|CS_TRUE
condition|)
block|{
if|if
condition|(
name|rs_type
operator|==
name|CS_RAIDSET_PERSONALITY_RAID5
condition|)
block|{
name|max_active_luns
operator|=
literal|7
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rs_type
operator|==
name|CS_RAIDSET_PERSONALITY_RAID1
condition|)
block|{
name|max_active_luns
operator|=
literal|14
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX KDM now what?? */
block|}
block|}
else|else
block|{
if|if
condition|(
name|rs_type
operator|==
name|CS_RAIDSET_PERSONALITY_RAID5
condition|)
block|{
name|max_active_luns
operator|=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rs_type
operator|==
name|CS_RAIDSET_PERSONALITY_RAID1
condition|)
block|{
name|max_active_luns
operator|=
literal|16
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX KDM now what?? */
block|}
block|}
block|}
else|else
block|{
comment|/* 50% power */
comment|/* 			 * With 50% power in a 64 drive configuration, we 			 * can power all LUNs we present. 			 */
name|max_active_luns
operator|=
name|num_luns
expr_stmt|;
block|}
break|break;
case|case
literal|112
case|:
if|if
condition|(
name|shelf_50pct_power
operator|==
name|CS_FALSE
condition|)
block|{
comment|/* 25% power */
if|if
condition|(
name|aor_present
operator|==
name|CS_TRUE
condition|)
block|{
if|if
condition|(
name|rs_type
operator|==
name|CS_RAIDSET_PERSONALITY_RAID5
condition|)
block|{
name|max_active_luns
operator|=
literal|7
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rs_type
operator|==
name|CS_RAIDSET_PERSONALITY_RAID1
condition|)
block|{
name|max_active_luns
operator|=
literal|14
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX KDM now what?? */
block|}
block|}
else|else
block|{
if|if
condition|(
name|rs_type
operator|==
name|CS_RAIDSET_PERSONALITY_RAID5
condition|)
block|{
name|max_active_luns
operator|=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rs_type
operator|==
name|CS_RAIDSET_PERSONALITY_RAID1
condition|)
block|{
name|max_active_luns
operator|=
literal|16
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX KDM now what?? */
block|}
block|}
block|}
else|else
block|{
comment|/* 50% power */
if|if
condition|(
name|aor_present
operator|==
name|CS_TRUE
condition|)
block|{
if|if
condition|(
name|rs_type
operator|==
name|CS_RAIDSET_PERSONALITY_RAID5
condition|)
block|{
name|max_active_luns
operator|=
literal|14
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rs_type
operator|==
name|CS_RAIDSET_PERSONALITY_RAID1
condition|)
block|{
comment|/* 					 * We're assuming here that disk 					 * caching is enabled, and so we're 					 * able to power up half of each 					 * LUN, and cache all writes. 					 */
name|max_active_luns
operator|=
name|num_luns
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX KDM now what?? */
block|}
block|}
else|else
block|{
if|if
condition|(
name|rs_type
operator|==
name|CS_RAIDSET_PERSONALITY_RAID5
condition|)
block|{
name|max_active_luns
operator|=
literal|15
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rs_type
operator|==
name|CS_RAIDSET_PERSONALITY_RAID1
condition|)
block|{
name|max_active_luns
operator|=
literal|30
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX KDM now what?? */
block|}
block|}
block|}
break|break;
default|default:
comment|/* 		 * In this case, we have an unknown configuration, so we 		 * just use the default from above. 		 */
break|break;
block|}
name|page
operator|->
name|max_active_luns
operator|=
name|max_active_luns
expr_stmt|;
if|#
directive|if
literal|0
block|printk("%s: total_luns = %d, max_active_luns = %d\n", __func__, 	       page->total_luns, page->max_active_luns);
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NEEDTOPORT */
end_comment

begin_comment
comment|/*  * This routine could be used in the future to load default and/or saved  * mode page parameters for a particuar lun.  */
end_comment

begin_function
specifier|static
name|int
name|ctl_init_page_index
parameter_list|(
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|ctl_page_index
modifier|*
name|page_index
decl_stmt|;
name|struct
name|ctl_softc
modifier|*
name|softc
decl_stmt|;
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|index
argument_list|,
name|page_index_template
argument_list|,
sizeof|sizeof
argument_list|(
name|page_index_template
argument_list|)
argument_list|)
expr_stmt|;
name|softc
operator|=
name|lun
operator|->
name|ctl_softc
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_NUM_MODE_PAGES
condition|;
name|i
operator|++
control|)
block|{
name|page_index
operator|=
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|index
index|[
name|i
index|]
expr_stmt|;
comment|/* 		 * If this is a disk-only mode page, there's no point in 		 * setting it up.  For some pages, we have to have some 		 * basic information about the disk in order to calculate the 		 * mode page data. 		 */
if|if
condition|(
operator|(
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
operator|!=
name|T_DIRECT
operator|)
operator|&&
operator|(
name|page_index
operator|->
name|page_flags
operator|&
name|CTL_PAGE_FLAG_DISK_ONLY
operator|)
condition|)
continue|continue;
switch|switch
condition|(
name|page_index
operator|->
name|page_code
operator|&
name|SMPH_PC_MASK
condition|)
block|{
case|case
name|SMS_FORMAT_DEVICE_PAGE
case|:
block|{
name|struct
name|scsi_format_page
modifier|*
name|format_page
decl_stmt|;
if|if
condition|(
name|page_index
operator|->
name|subpage
operator|!=
name|SMS_SUBPAGE_PAGE_0
condition|)
name|panic
argument_list|(
literal|"subpage is incorrect!"
argument_list|)
expr_stmt|;
comment|/* 			 * Sectors per track are set above.  Bytes per 			 * sector need to be set here on a per-LUN basis. 			 */
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|format_page
index|[
name|CTL_PAGE_CURRENT
index|]
argument_list|,
operator|&
name|format_page_default
argument_list|,
sizeof|sizeof
argument_list|(
name|format_page_default
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|format_page
index|[
name|CTL_PAGE_CHANGEABLE
index|]
argument_list|,
operator|&
name|format_page_changeable
argument_list|,
sizeof|sizeof
argument_list|(
name|format_page_changeable
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|format_page
index|[
name|CTL_PAGE_DEFAULT
index|]
argument_list|,
operator|&
name|format_page_default
argument_list|,
sizeof|sizeof
argument_list|(
name|format_page_default
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|format_page
index|[
name|CTL_PAGE_SAVED
index|]
argument_list|,
operator|&
name|format_page_default
argument_list|,
sizeof|sizeof
argument_list|(
name|format_page_default
argument_list|)
argument_list|)
expr_stmt|;
name|format_page
operator|=
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|format_page
index|[
name|CTL_PAGE_CURRENT
index|]
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|lun
operator|->
name|be_lun
operator|->
name|blocksize
argument_list|,
name|format_page
operator|->
name|bytes_per_sector
argument_list|)
expr_stmt|;
name|format_page
operator|=
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|format_page
index|[
name|CTL_PAGE_DEFAULT
index|]
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|lun
operator|->
name|be_lun
operator|->
name|blocksize
argument_list|,
name|format_page
operator|->
name|bytes_per_sector
argument_list|)
expr_stmt|;
name|format_page
operator|=
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|format_page
index|[
name|CTL_PAGE_SAVED
index|]
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|lun
operator|->
name|be_lun
operator|->
name|blocksize
argument_list|,
name|format_page
operator|->
name|bytes_per_sector
argument_list|)
expr_stmt|;
name|page_index
operator|->
name|page_data
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|lun
operator|->
name|mode_pages
operator|.
name|format_page
expr_stmt|;
break|break;
block|}
case|case
name|SMS_RIGID_DISK_PAGE
case|:
block|{
name|struct
name|scsi_rigid_disk_page
modifier|*
name|rigid_disk_page
decl_stmt|;
name|uint32_t
name|sectors_per_cylinder
decl_stmt|;
name|uint64_t
name|cylinders
decl_stmt|;
ifndef|#
directive|ifndef
name|__XSCALE__
name|int
name|shift
decl_stmt|;
endif|#
directive|endif
comment|/* !__XSCALE__ */
if|if
condition|(
name|page_index
operator|->
name|subpage
operator|!=
name|SMS_SUBPAGE_PAGE_0
condition|)
name|panic
argument_list|(
literal|"invalid subpage value %d"
argument_list|,
name|page_index
operator|->
name|subpage
argument_list|)
expr_stmt|;
comment|/* 			 * Rotation rate and sectors per track are set 			 * above.  We calculate the cylinders here based on 			 * capacity.  Due to the number of heads and 			 * sectors per track we're using, smaller arrays 			 * may turn out to have 0 cylinders.  Linux and 			 * FreeBSD don't pay attention to these mode pages 			 * to figure out capacity, but Solaris does.  It 			 * seems to deal with 0 cylinders just fine, and 			 * works out a fake geometry based on the capacity. 			 */
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|rigid_disk_page
index|[
name|CTL_PAGE_CURRENT
index|]
argument_list|,
operator|&
name|rigid_disk_page_default
argument_list|,
sizeof|sizeof
argument_list|(
name|rigid_disk_page_default
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|rigid_disk_page
index|[
name|CTL_PAGE_CHANGEABLE
index|]
argument_list|,
operator|&
name|rigid_disk_page_changeable
argument_list|,
sizeof|sizeof
argument_list|(
name|rigid_disk_page_changeable
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|rigid_disk_page
index|[
name|CTL_PAGE_DEFAULT
index|]
argument_list|,
operator|&
name|rigid_disk_page_default
argument_list|,
sizeof|sizeof
argument_list|(
name|rigid_disk_page_default
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|rigid_disk_page
index|[
name|CTL_PAGE_SAVED
index|]
argument_list|,
operator|&
name|rigid_disk_page_default
argument_list|,
sizeof|sizeof
argument_list|(
name|rigid_disk_page_default
argument_list|)
argument_list|)
expr_stmt|;
name|sectors_per_cylinder
operator|=
name|CTL_DEFAULT_SECTORS_PER_TRACK
operator|*
name|CTL_DEFAULT_HEADS
expr_stmt|;
comment|/* 			 * The divide method here will be more accurate, 			 * probably, but results in floating point being 			 * used in the kernel on i386 (__udivdi3()).  On the 			 * XScale, though, __udivdi3() is implemented in 			 * software. 			 * 			 * The shift method for cylinder calculation is 			 * accurate if sectors_per_cylinder is a power of 			 * 2.  Otherwise it might be slightly off -- you 			 * might have a bit of a truncation problem. 			 */
ifdef|#
directive|ifdef
name|__XSCALE__
name|cylinders
operator|=
operator|(
name|lun
operator|->
name|be_lun
operator|->
name|maxlba
operator|+
literal|1
operator|)
operator|/
name|sectors_per_cylinder
expr_stmt|;
else|#
directive|else
for|for
control|(
name|shift
operator|=
literal|31
init|;
name|shift
operator|>
literal|0
condition|;
name|shift
operator|--
control|)
block|{
if|if
condition|(
name|sectors_per_cylinder
operator|&
operator|(
literal|1
operator|<<
name|shift
operator|)
condition|)
break|break;
block|}
name|cylinders
operator|=
operator|(
name|lun
operator|->
name|be_lun
operator|->
name|maxlba
operator|+
literal|1
operator|)
operator|>>
name|shift
expr_stmt|;
endif|#
directive|endif
comment|/* 			 * We've basically got 3 bytes, or 24 bits for the 			 * cylinder size in the mode page.  If we're over, 			 * just round down to 2^24. 			 */
if|if
condition|(
name|cylinders
operator|>
literal|0xffffff
condition|)
name|cylinders
operator|=
literal|0xffffff
expr_stmt|;
name|rigid_disk_page
operator|=
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|rigid_disk_page
index|[
name|CTL_PAGE_CURRENT
index|]
expr_stmt|;
name|scsi_ulto3b
argument_list|(
name|cylinders
argument_list|,
name|rigid_disk_page
operator|->
name|cylinders
argument_list|)
expr_stmt|;
name|rigid_disk_page
operator|=
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|rigid_disk_page
index|[
name|CTL_PAGE_DEFAULT
index|]
expr_stmt|;
name|scsi_ulto3b
argument_list|(
name|cylinders
argument_list|,
name|rigid_disk_page
operator|->
name|cylinders
argument_list|)
expr_stmt|;
name|rigid_disk_page
operator|=
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|rigid_disk_page
index|[
name|CTL_PAGE_SAVED
index|]
expr_stmt|;
name|scsi_ulto3b
argument_list|(
name|cylinders
argument_list|,
name|rigid_disk_page
operator|->
name|cylinders
argument_list|)
expr_stmt|;
name|page_index
operator|->
name|page_data
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|lun
operator|->
name|mode_pages
operator|.
name|rigid_disk_page
expr_stmt|;
break|break;
block|}
case|case
name|SMS_CACHING_PAGE
case|:
block|{
name|struct
name|scsi_caching_page
modifier|*
name|caching_page
decl_stmt|;
if|if
condition|(
name|page_index
operator|->
name|subpage
operator|!=
name|SMS_SUBPAGE_PAGE_0
condition|)
name|panic
argument_list|(
literal|"invalid subpage value %d"
argument_list|,
name|page_index
operator|->
name|subpage
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|caching_page
index|[
name|CTL_PAGE_DEFAULT
index|]
argument_list|,
operator|&
name|caching_page_default
argument_list|,
sizeof|sizeof
argument_list|(
name|caching_page_default
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|caching_page
index|[
name|CTL_PAGE_CHANGEABLE
index|]
argument_list|,
operator|&
name|caching_page_changeable
argument_list|,
sizeof|sizeof
argument_list|(
name|caching_page_changeable
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|caching_page
index|[
name|CTL_PAGE_SAVED
index|]
argument_list|,
operator|&
name|caching_page_default
argument_list|,
sizeof|sizeof
argument_list|(
name|caching_page_default
argument_list|)
argument_list|)
expr_stmt|;
name|caching_page
operator|=
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|caching_page
index|[
name|CTL_PAGE_SAVED
index|]
expr_stmt|;
name|value
operator|=
name|ctl_get_opt
argument_list|(
operator|&
name|lun
operator|->
name|be_lun
operator|->
name|options
argument_list|,
literal|"writecache"
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
condition|)
name|caching_page
operator|->
name|flags1
operator|&=
operator|~
name|SCP_WCE
expr_stmt|;
name|value
operator|=
name|ctl_get_opt
argument_list|(
operator|&
name|lun
operator|->
name|be_lun
operator|->
name|options
argument_list|,
literal|"readcache"
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
condition|)
name|caching_page
operator|->
name|flags1
operator||=
name|SCP_RCD
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|caching_page
index|[
name|CTL_PAGE_CURRENT
index|]
argument_list|,
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|caching_page
index|[
name|CTL_PAGE_SAVED
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|caching_page_default
argument_list|)
argument_list|)
expr_stmt|;
name|page_index
operator|->
name|page_data
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|lun
operator|->
name|mode_pages
operator|.
name|caching_page
expr_stmt|;
break|break;
block|}
case|case
name|SMS_CONTROL_MODE_PAGE
case|:
block|{
name|struct
name|scsi_control_page
modifier|*
name|control_page
decl_stmt|;
if|if
condition|(
name|page_index
operator|->
name|subpage
operator|!=
name|SMS_SUBPAGE_PAGE_0
condition|)
name|panic
argument_list|(
literal|"invalid subpage value %d"
argument_list|,
name|page_index
operator|->
name|subpage
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|control_page
index|[
name|CTL_PAGE_DEFAULT
index|]
argument_list|,
operator|&
name|control_page_default
argument_list|,
sizeof|sizeof
argument_list|(
name|control_page_default
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|control_page
index|[
name|CTL_PAGE_CHANGEABLE
index|]
argument_list|,
operator|&
name|control_page_changeable
argument_list|,
sizeof|sizeof
argument_list|(
name|control_page_changeable
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|control_page
index|[
name|CTL_PAGE_SAVED
index|]
argument_list|,
operator|&
name|control_page_default
argument_list|,
sizeof|sizeof
argument_list|(
name|control_page_default
argument_list|)
argument_list|)
expr_stmt|;
name|control_page
operator|=
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|control_page
index|[
name|CTL_PAGE_SAVED
index|]
expr_stmt|;
name|value
operator|=
name|ctl_get_opt
argument_list|(
operator|&
name|lun
operator|->
name|be_lun
operator|->
name|options
argument_list|,
literal|"reordering"
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"unrestricted"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|control_page
operator|->
name|queue_flags
operator|&=
operator|~
name|SCP_QUEUE_ALG_MASK
expr_stmt|;
name|control_page
operator|->
name|queue_flags
operator||=
name|SCP_QUEUE_ALG_UNRESTRICTED
expr_stmt|;
block|}
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|control_page
index|[
name|CTL_PAGE_CURRENT
index|]
argument_list|,
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|control_page
index|[
name|CTL_PAGE_SAVED
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|control_page_default
argument_list|)
argument_list|)
expr_stmt|;
name|page_index
operator|->
name|page_data
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|lun
operator|->
name|mode_pages
operator|.
name|control_page
expr_stmt|;
break|break;
block|}
case|case
name|SMS_VENDOR_SPECIFIC_PAGE
case|:
block|{
switch|switch
condition|(
name|page_index
operator|->
name|subpage
condition|)
block|{
case|case
name|PWR_SUBPAGE_CODE
case|:
block|{
name|struct
name|copan_power_subpage
modifier|*
name|current_page
decl_stmt|,
modifier|*
name|saved_page
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|power_subpage
index|[
name|CTL_PAGE_CURRENT
index|]
argument_list|,
operator|&
name|power_page_default
argument_list|,
sizeof|sizeof
argument_list|(
name|power_page_default
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|power_subpage
index|[
name|CTL_PAGE_CHANGEABLE
index|]
argument_list|,
operator|&
name|power_page_changeable
argument_list|,
sizeof|sizeof
argument_list|(
name|power_page_changeable
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|power_subpage
index|[
name|CTL_PAGE_DEFAULT
index|]
argument_list|,
operator|&
name|power_page_default
argument_list|,
sizeof|sizeof
argument_list|(
name|power_page_default
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|power_subpage
index|[
name|CTL_PAGE_SAVED
index|]
argument_list|,
operator|&
name|power_page_default
argument_list|,
sizeof|sizeof
argument_list|(
name|power_page_default
argument_list|)
argument_list|)
expr_stmt|;
name|page_index
operator|->
name|page_data
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|lun
operator|->
name|mode_pages
operator|.
name|power_subpage
expr_stmt|;
name|current_page
operator|=
operator|(
expr|struct
name|copan_power_subpage
operator|*
operator|)
operator|(
name|page_index
operator|->
name|page_data
operator|+
operator|(
name|page_index
operator|->
name|page_len
operator|*
name|CTL_PAGE_CURRENT
operator|)
operator|)
expr_stmt|;
name|saved_page
operator|=
operator|(
expr|struct
name|copan_power_subpage
operator|*
operator|)
operator|(
name|page_index
operator|->
name|page_data
operator|+
operator|(
name|page_index
operator|->
name|page_len
operator|*
name|CTL_PAGE_SAVED
operator|)
operator|)
expr_stmt|;
break|break;
block|}
case|case
name|APS_SUBPAGE_CODE
case|:
block|{
name|struct
name|copan_aps_subpage
modifier|*
name|current_page
decl_stmt|,
modifier|*
name|saved_page
decl_stmt|;
comment|// This gets set multiple times but
comment|// it should always be the same. It's
comment|// only done during init so who cares.
name|index_to_aps_page
operator|=
name|i
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|aps_subpage
index|[
name|CTL_PAGE_CURRENT
index|]
argument_list|,
operator|&
name|aps_page_default
argument_list|,
sizeof|sizeof
argument_list|(
name|aps_page_default
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|aps_subpage
index|[
name|CTL_PAGE_CHANGEABLE
index|]
argument_list|,
operator|&
name|aps_page_changeable
argument_list|,
sizeof|sizeof
argument_list|(
name|aps_page_changeable
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|aps_subpage
index|[
name|CTL_PAGE_DEFAULT
index|]
argument_list|,
operator|&
name|aps_page_default
argument_list|,
sizeof|sizeof
argument_list|(
name|aps_page_default
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|aps_subpage
index|[
name|CTL_PAGE_SAVED
index|]
argument_list|,
operator|&
name|aps_page_default
argument_list|,
sizeof|sizeof
argument_list|(
name|aps_page_default
argument_list|)
argument_list|)
expr_stmt|;
name|page_index
operator|->
name|page_data
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|lun
operator|->
name|mode_pages
operator|.
name|aps_subpage
expr_stmt|;
name|current_page
operator|=
operator|(
expr|struct
name|copan_aps_subpage
operator|*
operator|)
operator|(
name|page_index
operator|->
name|page_data
operator|+
operator|(
name|page_index
operator|->
name|page_len
operator|*
name|CTL_PAGE_CURRENT
operator|)
operator|)
expr_stmt|;
name|saved_page
operator|=
operator|(
expr|struct
name|copan_aps_subpage
operator|*
operator|)
operator|(
name|page_index
operator|->
name|page_data
operator|+
operator|(
name|page_index
operator|->
name|page_len
operator|*
name|CTL_PAGE_SAVED
operator|)
operator|)
expr_stmt|;
break|break;
block|}
case|case
name|DBGCNF_SUBPAGE_CODE
case|:
block|{
name|struct
name|copan_debugconf_subpage
modifier|*
name|current_page
decl_stmt|,
modifier|*
name|saved_page
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|debugconf_subpage
index|[
name|CTL_PAGE_CURRENT
index|]
argument_list|,
operator|&
name|debugconf_page_default
argument_list|,
sizeof|sizeof
argument_list|(
name|debugconf_page_default
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|debugconf_subpage
index|[
name|CTL_PAGE_CHANGEABLE
index|]
argument_list|,
operator|&
name|debugconf_page_changeable
argument_list|,
sizeof|sizeof
argument_list|(
name|debugconf_page_changeable
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|debugconf_subpage
index|[
name|CTL_PAGE_DEFAULT
index|]
argument_list|,
operator|&
name|debugconf_page_default
argument_list|,
sizeof|sizeof
argument_list|(
name|debugconf_page_default
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|debugconf_subpage
index|[
name|CTL_PAGE_SAVED
index|]
argument_list|,
operator|&
name|debugconf_page_default
argument_list|,
sizeof|sizeof
argument_list|(
name|debugconf_page_default
argument_list|)
argument_list|)
expr_stmt|;
name|page_index
operator|->
name|page_data
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|lun
operator|->
name|mode_pages
operator|.
name|debugconf_subpage
expr_stmt|;
name|current_page
operator|=
operator|(
expr|struct
name|copan_debugconf_subpage
operator|*
operator|)
operator|(
name|page_index
operator|->
name|page_data
operator|+
operator|(
name|page_index
operator|->
name|page_len
operator|*
name|CTL_PAGE_CURRENT
operator|)
operator|)
expr_stmt|;
name|saved_page
operator|=
operator|(
expr|struct
name|copan_debugconf_subpage
operator|*
operator|)
operator|(
name|page_index
operator|->
name|page_data
operator|+
operator|(
name|page_index
operator|->
name|page_len
operator|*
name|CTL_PAGE_SAVED
operator|)
operator|)
expr_stmt|;
break|break;
block|}
default|default:
name|panic
argument_list|(
literal|"invalid subpage value %d"
argument_list|,
name|page_index
operator|->
name|subpage
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
default|default:
name|panic
argument_list|(
literal|"invalid page value %d"
argument_list|,
name|page_index
operator|->
name|page_code
operator|&
name|SMPH_PC_MASK
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * LUN allocation.  *  * Requirements:  * - caller allocates and zeros LUN storage, or passes in a NULL LUN if he  *   wants us to allocate the LUN and he can block.  * - ctl_softc is always set  * - be_lun is set if the LUN has a backend (needed for disk LUNs)  *  * Returns 0 for success, non-zero (errno) for failure.  */
end_comment

begin_function
specifier|static
name|int
name|ctl_alloc_lun
parameter_list|(
name|struct
name|ctl_softc
modifier|*
name|ctl_softc
parameter_list|,
name|struct
name|ctl_lun
modifier|*
name|ctl_lun
parameter_list|,
name|struct
name|ctl_be_lun
modifier|*
specifier|const
name|be_lun
parameter_list|,
name|struct
name|ctl_id
name|target_id
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|nlun
decl_stmt|,
modifier|*
name|lun
decl_stmt|;
name|struct
name|ctl_port
modifier|*
name|port
decl_stmt|;
name|struct
name|scsi_vpd_id_descriptor
modifier|*
name|desc
decl_stmt|;
name|struct
name|scsi_vpd_id_t10
modifier|*
name|t10id
decl_stmt|;
specifier|const
name|char
modifier|*
name|eui
decl_stmt|,
modifier|*
name|naa
decl_stmt|,
modifier|*
name|scsiname
decl_stmt|,
modifier|*
name|vendor
decl_stmt|,
modifier|*
name|value
decl_stmt|;
name|int
name|lun_number
decl_stmt|,
name|i
decl_stmt|,
name|lun_malloced
decl_stmt|;
name|int
name|devidlen
decl_stmt|,
name|idlen1
decl_stmt|,
name|idlen2
init|=
literal|0
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
name|be_lun
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * We currently only support Direct Access or Processor LUN types. 	 */
switch|switch
condition|(
name|be_lun
operator|->
name|lun_type
condition|)
block|{
case|case
name|T_DIRECT
case|:
break|break;
case|case
name|T_PROCESSOR
case|:
break|break;
case|case
name|T_SEQUENTIAL
case|:
case|case
name|T_CHANGER
case|:
default|default:
name|be_lun
operator|->
name|lun_config_status
argument_list|(
name|be_lun
operator|->
name|be_lun
argument_list|,
name|CTL_LUN_CONFIG_FAILURE
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ctl_lun
operator|==
name|NULL
condition|)
block|{
name|lun
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|lun
argument_list|)
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|lun_malloced
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|lun_malloced
operator|=
literal|0
expr_stmt|;
name|lun
operator|=
name|ctl_lun
expr_stmt|;
block|}
name|memset
argument_list|(
name|lun
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lun
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun_malloced
condition|)
name|lun
operator|->
name|flags
operator|=
name|CTL_LUN_MALLOCED
expr_stmt|;
comment|/* Generate LUN ID. */
name|devidlen
operator|=
name|max
argument_list|(
name|CTL_DEVID_MIN_LEN
argument_list|,
name|strnlen
argument_list|(
name|be_lun
operator|->
name|device_id
argument_list|,
name|CTL_DEVID_LEN
argument_list|)
argument_list|)
expr_stmt|;
name|idlen1
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|t10id
argument_list|)
operator|+
name|devidlen
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_id_descriptor
argument_list|)
operator|+
name|idlen1
expr_stmt|;
name|scsiname
operator|=
name|ctl_get_opt
argument_list|(
operator|&
name|be_lun
operator|->
name|options
argument_list|,
literal|"scsiname"
argument_list|)
expr_stmt|;
if|if
condition|(
name|scsiname
operator|!=
name|NULL
condition|)
block|{
name|idlen2
operator|=
name|roundup2
argument_list|(
name|strlen
argument_list|(
name|scsiname
argument_list|)
operator|+
literal|1
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_id_descriptor
argument_list|)
operator|+
name|idlen2
expr_stmt|;
block|}
name|eui
operator|=
name|ctl_get_opt
argument_list|(
operator|&
name|be_lun
operator|->
name|options
argument_list|,
literal|"eui"
argument_list|)
expr_stmt|;
if|if
condition|(
name|eui
operator|!=
name|NULL
condition|)
block|{
name|len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_id_descriptor
argument_list|)
operator|+
literal|8
expr_stmt|;
block|}
name|naa
operator|=
name|ctl_get_opt
argument_list|(
operator|&
name|be_lun
operator|->
name|options
argument_list|,
literal|"naa"
argument_list|)
expr_stmt|;
if|if
condition|(
name|naa
operator|!=
name|NULL
condition|)
block|{
name|len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_id_descriptor
argument_list|)
operator|+
literal|8
expr_stmt|;
block|}
name|lun
operator|->
name|lun_devid
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ctl_devid
argument_list|)
operator|+
name|len
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|lun
operator|->
name|lun_devid
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|desc
operator|=
operator|(
expr|struct
name|scsi_vpd_id_descriptor
operator|*
operator|)
name|lun
operator|->
name|lun_devid
operator|->
name|data
expr_stmt|;
name|desc
operator|->
name|proto_codeset
operator|=
name|SVPD_ID_CODESET_ASCII
expr_stmt|;
name|desc
operator|->
name|id_type
operator|=
name|SVPD_ID_PIV
operator||
name|SVPD_ID_ASSOC_LUN
operator||
name|SVPD_ID_TYPE_T10
expr_stmt|;
name|desc
operator|->
name|length
operator|=
name|idlen1
expr_stmt|;
name|t10id
operator|=
operator|(
expr|struct
name|scsi_vpd_id_t10
operator|*
operator|)
operator|&
name|desc
operator|->
name|identifier
index|[
literal|0
index|]
expr_stmt|;
name|memset
argument_list|(
name|t10id
operator|->
name|vendor
argument_list|,
literal|' '
argument_list|,
sizeof|sizeof
argument_list|(
name|t10id
operator|->
name|vendor
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vendor
operator|=
name|ctl_get_opt
argument_list|(
operator|&
name|be_lun
operator|->
name|options
argument_list|,
literal|"vendor"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t10id
operator|->
name|vendor
argument_list|,
name|CTL_VENDOR
argument_list|,
sizeof|sizeof
argument_list|(
name|t10id
operator|->
name|vendor
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strncpy
argument_list|(
name|t10id
operator|->
name|vendor
argument_list|,
name|vendor
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|t10id
operator|->
name|vendor
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|vendor
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t10id
operator|->
name|vendor_spec_id
argument_list|,
operator|(
name|char
operator|*
operator|)
name|be_lun
operator|->
name|device_id
argument_list|,
name|devidlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|scsiname
operator|!=
name|NULL
condition|)
block|{
name|desc
operator|=
operator|(
expr|struct
name|scsi_vpd_id_descriptor
operator|*
operator|)
operator|(
operator|&
name|desc
operator|->
name|identifier
index|[
literal|0
index|]
operator|+
name|desc
operator|->
name|length
operator|)
expr_stmt|;
name|desc
operator|->
name|proto_codeset
operator|=
name|SVPD_ID_CODESET_UTF8
expr_stmt|;
name|desc
operator|->
name|id_type
operator|=
name|SVPD_ID_PIV
operator||
name|SVPD_ID_ASSOC_LUN
operator||
name|SVPD_ID_TYPE_SCSI_NAME
expr_stmt|;
name|desc
operator|->
name|length
operator|=
name|idlen2
expr_stmt|;
name|strlcpy
argument_list|(
name|desc
operator|->
name|identifier
argument_list|,
name|scsiname
argument_list|,
name|idlen2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|eui
operator|!=
name|NULL
condition|)
block|{
name|desc
operator|=
operator|(
expr|struct
name|scsi_vpd_id_descriptor
operator|*
operator|)
operator|(
operator|&
name|desc
operator|->
name|identifier
index|[
literal|0
index|]
operator|+
name|desc
operator|->
name|length
operator|)
expr_stmt|;
name|desc
operator|->
name|proto_codeset
operator|=
name|SVPD_ID_CODESET_BINARY
expr_stmt|;
name|desc
operator|->
name|id_type
operator|=
name|SVPD_ID_PIV
operator||
name|SVPD_ID_ASSOC_LUN
operator||
name|SVPD_ID_TYPE_EUI64
expr_stmt|;
name|desc
operator|->
name|length
operator|=
literal|8
expr_stmt|;
name|scsi_u64to8b
argument_list|(
name|strtouq
argument_list|(
name|eui
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
argument_list|,
name|desc
operator|->
name|identifier
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|naa
operator|!=
name|NULL
condition|)
block|{
name|desc
operator|=
operator|(
expr|struct
name|scsi_vpd_id_descriptor
operator|*
operator|)
operator|(
operator|&
name|desc
operator|->
name|identifier
index|[
literal|0
index|]
operator|+
name|desc
operator|->
name|length
operator|)
expr_stmt|;
name|desc
operator|->
name|proto_codeset
operator|=
name|SVPD_ID_CODESET_BINARY
expr_stmt|;
name|desc
operator|->
name|id_type
operator|=
name|SVPD_ID_PIV
operator||
name|SVPD_ID_ASSOC_LUN
operator||
name|SVPD_ID_TYPE_NAA
expr_stmt|;
name|desc
operator|->
name|length
operator|=
literal|8
expr_stmt|;
name|scsi_u64to8b
argument_list|(
name|strtouq
argument_list|(
name|naa
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
argument_list|,
name|desc
operator|->
name|identifier
argument_list|)
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|ctl_softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
comment|/* 	 * See if the caller requested a particular LUN number.  If so, see 	 * if it is available.  Otherwise, allocate the first available LUN. 	 */
if|if
condition|(
name|be_lun
operator|->
name|flags
operator|&
name|CTL_LUN_FLAG_ID_REQ
condition|)
block|{
if|if
condition|(
operator|(
name|be_lun
operator|->
name|req_lun_id
operator|>
operator|(
name|CTL_MAX_LUNS
operator|-
literal|1
operator|)
operator|)
operator|||
operator|(
name|ctl_is_set
argument_list|(
name|ctl_softc
operator|->
name|ctl_lun_mask
argument_list|,
name|be_lun
operator|->
name|req_lun_id
argument_list|)
operator|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|ctl_softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|be_lun
operator|->
name|req_lun_id
operator|>
operator|(
name|CTL_MAX_LUNS
operator|-
literal|1
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ctl: requested LUN ID %d is higher "
literal|"than CTL_MAX_LUNS - 1 (%d)\n"
argument_list|,
name|be_lun
operator|->
name|req_lun_id
argument_list|,
name|CTL_MAX_LUNS
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * XXX KDM return an error, or just assign 				 * another LUN ID in this case?? 				 */
name|printf
argument_list|(
literal|"ctl: requested LUN ID %d is already "
literal|"in use\n"
argument_list|,
name|be_lun
operator|->
name|req_lun_id
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_MALLOCED
condition|)
name|free
argument_list|(
name|lun
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|be_lun
operator|->
name|lun_config_status
argument_list|(
name|be_lun
operator|->
name|be_lun
argument_list|,
name|CTL_LUN_CONFIG_FAILURE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
name|lun_number
operator|=
name|be_lun
operator|->
name|req_lun_id
expr_stmt|;
block|}
else|else
block|{
name|lun_number
operator|=
name|ctl_ffz
argument_list|(
name|ctl_softc
operator|->
name|ctl_lun_mask
argument_list|,
name|CTL_MAX_LUNS
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun_number
operator|==
operator|-
literal|1
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|ctl_softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ctl: can't allocate LUN on target %ju, out of "
literal|"LUNs\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|target_id
operator|.
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_MALLOCED
condition|)
name|free
argument_list|(
name|lun
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|be_lun
operator|->
name|lun_config_status
argument_list|(
name|be_lun
operator|->
name|be_lun
argument_list|,
name|CTL_LUN_CONFIG_FAILURE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
block|}
name|ctl_set_mask
argument_list|(
name|ctl_softc
operator|->
name|ctl_lun_mask
argument_list|,
name|lun_number
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|,
literal|"CTL LUN"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|lun
operator|->
name|target
operator|=
name|target_id
expr_stmt|;
name|lun
operator|->
name|lun
operator|=
name|lun_number
expr_stmt|;
name|lun
operator|->
name|be_lun
operator|=
name|be_lun
expr_stmt|;
comment|/* 	 * The processor LUN is always enabled.  Disk LUNs come on line 	 * disabled, and must be enabled by the backend. 	 */
name|lun
operator|->
name|flags
operator||=
name|CTL_LUN_DISABLED
expr_stmt|;
name|lun
operator|->
name|backend
operator|=
name|be_lun
operator|->
name|be
expr_stmt|;
name|be_lun
operator|->
name|ctl_lun
operator|=
name|lun
expr_stmt|;
name|be_lun
operator|->
name|lun_id
operator|=
name|lun_number
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|be_lun
operator|->
name|be
operator|->
name|num_luns
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|be_lun
operator|->
name|flags
operator|&
name|CTL_LUN_FLAG_POWERED_OFF
condition|)
name|lun
operator|->
name|flags
operator||=
name|CTL_LUN_STOPPED
expr_stmt|;
if|if
condition|(
name|be_lun
operator|->
name|flags
operator|&
name|CTL_LUN_FLAG_INOPERABLE
condition|)
name|lun
operator|->
name|flags
operator||=
name|CTL_LUN_INOPERABLE
expr_stmt|;
if|if
condition|(
name|be_lun
operator|->
name|flags
operator|&
name|CTL_LUN_FLAG_PRIMARY
condition|)
name|lun
operator|->
name|flags
operator||=
name|CTL_LUN_PRIMARY_SC
expr_stmt|;
name|value
operator|=
name|ctl_get_opt
argument_list|(
operator|&
name|be_lun
operator|->
name|options
argument_list|,
literal|"readonly"
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"on"
argument_list|)
operator|==
literal|0
condition|)
name|lun
operator|->
name|flags
operator||=
name|CTL_LUN_READONLY
expr_stmt|;
name|lun
operator|->
name|ctl_softc
operator|=
name|ctl_softc
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|lun
operator|->
name|ooa_queue
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|lun
operator|->
name|blocked_queue
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|lun
operator|->
name|error_list
argument_list|)
expr_stmt|;
name|ctl_tpc_lun_init
argument_list|(
name|lun
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the mode page index. 	 */
name|ctl_init_page_index
argument_list|(
name|lun
argument_list|)
expr_stmt|;
comment|/* 	 * Set the poweron UA for all initiators on this LUN only. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_MAX_INITIATORS
condition|;
name|i
operator|++
control|)
name|lun
operator|->
name|pending_ua
index|[
name|i
index|]
operator|=
name|CTL_UA_POWERON
expr_stmt|;
comment|/* 	 * Now, before we insert this lun on the lun list, set the lun 	 * inventory changed UA for all other luns. 	 */
name|STAILQ_FOREACH
argument_list|(
argument|nlun
argument_list|,
argument|&ctl_softc->lun_list
argument_list|,
argument|links
argument_list|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_MAX_INITIATORS
condition|;
name|i
operator|++
control|)
block|{
name|nlun
operator|->
name|pending_ua
index|[
name|i
index|]
operator||=
name|CTL_UA_LUN_CHANGE
expr_stmt|;
block|}
block|}
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ctl_softc
operator|->
name|lun_list
argument_list|,
name|lun
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|ctl_softc
operator|->
name|ctl_luns
index|[
name|lun_number
index|]
operator|=
name|lun
expr_stmt|;
name|ctl_softc
operator|->
name|num_luns
operator|++
expr_stmt|;
comment|/* Setup statistics gathering */
name|lun
operator|->
name|stats
operator|.
name|device_type
operator|=
name|be_lun
operator|->
name|lun_type
expr_stmt|;
name|lun
operator|->
name|stats
operator|.
name|lun_number
operator|=
name|lun_number
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|stats
operator|.
name|device_type
operator|==
name|T_DIRECT
condition|)
name|lun
operator|->
name|stats
operator|.
name|blocksize
operator|=
name|be_lun
operator|->
name|blocksize
expr_stmt|;
else|else
name|lun
operator|->
name|stats
operator|.
name|flags
operator|=
name|CTL_LUN_STATS_NO_BLOCKSIZE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_MAX_PORTS
condition|;
name|i
operator|++
control|)
name|lun
operator|->
name|stats
operator|.
name|ports
index|[
name|i
index|]
operator|.
name|targ_port
operator|=
name|i
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ctl_softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|lun
operator|->
name|be_lun
operator|->
name|lun_config_status
argument_list|(
name|lun
operator|->
name|be_lun
operator|->
name|be_lun
argument_list|,
name|CTL_LUN_CONFIG_OK
argument_list|)
expr_stmt|;
comment|/* 	 * Run through each registered FETD and bring it online if it isn't 	 * already.  Enable the target ID if it hasn't been enabled, and 	 * enable this particular LUN. 	 */
name|STAILQ_FOREACH
argument_list|(
argument|port
argument_list|,
argument|&ctl_softc->port_list
argument_list|,
argument|links
argument_list|)
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|port
operator|->
name|lun_enable
argument_list|(
name|port
operator|->
name|targ_lun_arg
argument_list|,
name|target_id
argument_list|,
name|lun_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ctl_alloc_lun: FETD %s port %d returned error "
literal|"%d for lun_enable on target %ju lun %d\n"
argument_list|,
name|port
operator|->
name|port_name
argument_list|,
name|port
operator|->
name|targ_port
argument_list|,
name|retval
argument_list|,
operator|(
name|uintmax_t
operator|)
name|target_id
operator|.
name|id
argument_list|,
name|lun_number
argument_list|)
expr_stmt|;
block|}
else|else
name|port
operator|->
name|status
operator||=
name|CTL_PORT_STATUS_LUN_ONLINE
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Delete a LUN.  * Assumptions:  * - LUN has already been marked invalid and any pending I/O has been taken  *   care of.  */
end_comment

begin_function
specifier|static
name|int
name|ctl_free_lun
parameter_list|(
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
decl_stmt|;
if|#
directive|if
literal|0
block|struct ctl_port *port;
endif|#
directive|endif
name|struct
name|ctl_lun
modifier|*
name|nlun
decl_stmt|;
name|int
name|i
decl_stmt|;
name|softc
operator|=
name|lun
operator|->
name|ctl_softc
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE
argument_list|(
operator|&
name|softc
operator|->
name|lun_list
argument_list|,
name|lun
argument_list|,
name|ctl_lun
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|ctl_clear_mask
argument_list|(
name|softc
operator|->
name|ctl_lun_mask
argument_list|,
name|lun
operator|->
name|lun
argument_list|)
expr_stmt|;
name|softc
operator|->
name|ctl_luns
index|[
name|lun
operator|->
name|lun
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|lun
operator|->
name|ooa_queue
argument_list|)
condition|)
name|panic
argument_list|(
literal|"Freeing a LUN %p with outstanding I/O!!\n"
argument_list|,
name|lun
argument_list|)
expr_stmt|;
name|softc
operator|->
name|num_luns
operator|--
expr_stmt|;
comment|/* 	 * XXX KDM this scheme only works for a single target/multiple LUN 	 * setup.  It needs to be revamped for a multiple target scheme. 	 * 	 * XXX KDM this results in port->lun_disable() getting called twice, 	 * once when ctl_disable_lun() is called, and a second time here. 	 * We really need to re-think the LUN disable semantics.  There 	 * should probably be several steps/levels to LUN removal: 	 *  - disable 	 *  - invalidate 	 *  - free  	 * 	 * Right now we only have a disable method when communicating to 	 * the front end ports, at least for individual LUNs. 	 */
if|#
directive|if
literal|0
block|STAILQ_FOREACH(port,&softc->port_list, links) { 		int retval;  		retval = port->lun_disable(port->targ_lun_arg, lun->target, 					 lun->lun); 		if (retval != 0) { 			printf("ctl_free_lun: FETD %s port %d returned error " 			       "%d for lun_disable on target %ju lun %jd\n", 			       port->port_name, port->targ_port, retval, 			       (uintmax_t)lun->target.id, (intmax_t)lun->lun); 		}  		if (STAILQ_FIRST(&softc->lun_list) == NULL) { 			port->status&= ~CTL_PORT_STATUS_LUN_ONLINE;  			retval = port->targ_disable(port->targ_lun_arg,lun->target); 			if (retval != 0) { 				printf("ctl_free_lun: FETD %s port %d " 				       "returned error %d for targ_disable on " 				       "target %ju\n", port->port_name, 				       port->targ_port, retval, 				       (uintmax_t)lun->target.id); 			} else 				port->status&= ~CTL_PORT_STATUS_TARG_ONLINE;  			if ((port->status& CTL_PORT_STATUS_TARG_ONLINE) != 0) 				continue;
if|#
directive|if
literal|0
block|port->port_offline(port->onoff_arg); 			port->status&= ~CTL_PORT_STATUS_ONLINE;
endif|#
directive|endif
block|} 	}
endif|#
directive|endif
comment|/* 	 * Tell the backend to free resources, if this LUN has a backend. 	 */
name|atomic_subtract_int
argument_list|(
operator|&
name|lun
operator|->
name|be_lun
operator|->
name|be
operator|->
name|num_luns
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lun
operator|->
name|be_lun
operator|->
name|lun_shutdown
argument_list|(
name|lun
operator|->
name|be_lun
operator|->
name|be_lun
argument_list|)
expr_stmt|;
name|ctl_tpc_lun_shutdown
argument_list|(
name|lun
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lun
operator|->
name|lun_devid
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_MALLOCED
condition|)
name|free
argument_list|(
name|lun
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|nlun
argument_list|,
argument|&softc->lun_list
argument_list|,
argument|links
argument_list|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_MAX_INITIATORS
condition|;
name|i
operator|++
control|)
block|{
name|nlun
operator|->
name|pending_ua
index|[
name|i
index|]
operator||=
name|CTL_UA_LUN_CHANGE
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_create_lun
parameter_list|(
name|struct
name|ctl_be_lun
modifier|*
name|be_lun
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|ctl_softc
decl_stmt|;
name|ctl_softc
operator|=
name|control_softc
expr_stmt|;
comment|/* 	 * ctl_alloc_lun() should handle all potential failure cases. 	 */
name|ctl_alloc_lun
argument_list|(
name|ctl_softc
argument_list|,
name|NULL
argument_list|,
name|be_lun
argument_list|,
name|ctl_softc
operator|->
name|target
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ctl_add_lun
parameter_list|(
name|struct
name|ctl_be_lun
modifier|*
name|be_lun
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|ctl_softc
init|=
name|control_softc
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ctl_softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ctl_softc
operator|->
name|pending_lun_queue
argument_list|,
name|be_lun
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ctl_softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|ctl_softc
operator|->
name|pending_lun_queue
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_enable_lun
parameter_list|(
name|struct
name|ctl_be_lun
modifier|*
name|be_lun
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|ctl_softc
decl_stmt|;
name|struct
name|ctl_port
modifier|*
name|port
decl_stmt|,
modifier|*
name|nport
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|ctl_softc
operator|=
name|control_softc
expr_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|be_lun
operator|->
name|ctl_lun
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ctl_softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_DISABLED
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * eh?  Why did we get called if the LUN is already 		 * enabled? 		 */
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ctl_softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_LUN_DISABLED
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|port
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|ctl_softc
operator|->
name|port_list
argument_list|)
init|;
name|port
operator|!=
name|NULL
condition|;
name|port
operator|=
name|nport
control|)
block|{
name|nport
operator|=
name|STAILQ_NEXT
argument_list|(
name|port
argument_list|,
name|links
argument_list|)
expr_stmt|;
comment|/* 		 * Drop the lock while we call the FETD's enable routine. 		 * This can lead to a callback into CTL (at least in the 		 * case of the internal initiator frontend. 		 */
name|mtx_unlock
argument_list|(
operator|&
name|ctl_softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|retval
operator|=
name|port
operator|->
name|lun_enable
argument_list|(
name|port
operator|->
name|targ_lun_arg
argument_list|,
name|lun
operator|->
name|target
argument_list|,
name|lun
operator|->
name|lun
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ctl_softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: FETD %s port %d returned error "
literal|"%d for lun_enable on target %ju lun %jd\n"
argument_list|,
name|__func__
argument_list|,
name|port
operator|->
name|port_name
argument_list|,
name|port
operator|->
name|targ_port
argument_list|,
name|retval
argument_list|,
operator|(
name|uintmax_t
operator|)
name|lun
operator|->
name|target
operator|.
name|id
argument_list|,
operator|(
name|intmax_t
operator|)
name|lun
operator|->
name|lun
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|else {
comment|/* NOTE:  TODO:  why does lun enable affect port status? */
block|port->status |= CTL_PORT_STATUS_LUN_ONLINE; 		}
endif|#
directive|endif
block|}
name|mtx_unlock
argument_list|(
operator|&
name|ctl_softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_disable_lun
parameter_list|(
name|struct
name|ctl_be_lun
modifier|*
name|be_lun
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|ctl_softc
decl_stmt|;
name|struct
name|ctl_port
modifier|*
name|port
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|ctl_softc
operator|=
name|control_softc
expr_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|be_lun
operator|->
name|ctl_lun
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ctl_softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_DISABLED
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ctl_softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|lun
operator|->
name|flags
operator||=
name|CTL_LUN_DISABLED
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|port
argument_list|,
argument|&ctl_softc->port_list
argument_list|,
argument|links
argument_list|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|ctl_softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
comment|/* 		 * Drop the lock before we call the frontend's disable 		 * routine, to avoid lock order reversals. 		 * 		 * XXX KDM what happens if the frontend list changes while 		 * we're traversing it?  It's unlikely, but should be handled. 		 */
name|retval
operator|=
name|port
operator|->
name|lun_disable
argument_list|(
name|port
operator|->
name|targ_lun_arg
argument_list|,
name|lun
operator|->
name|target
argument_list|,
name|lun
operator|->
name|lun
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ctl_softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ctl_alloc_lun: FETD %s port %d returned error "
literal|"%d for lun_disable on target %ju lun %jd\n"
argument_list|,
name|port
operator|->
name|port_name
argument_list|,
name|port
operator|->
name|targ_port
argument_list|,
name|retval
argument_list|,
operator|(
name|uintmax_t
operator|)
name|lun
operator|->
name|target
operator|.
name|id
argument_list|,
operator|(
name|intmax_t
operator|)
name|lun
operator|->
name|lun
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|ctl_softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_start_lun
parameter_list|(
name|struct
name|ctl_be_lun
modifier|*
name|be_lun
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|ctl_softc
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|ctl_softc
operator|=
name|control_softc
expr_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|be_lun
operator|->
name|ctl_lun
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_LUN_STOPPED
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_stop_lun
parameter_list|(
name|struct
name|ctl_be_lun
modifier|*
name|be_lun
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|ctl_softc
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|ctl_softc
operator|=
name|control_softc
expr_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|be_lun
operator|->
name|ctl_lun
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|lun
operator|->
name|flags
operator||=
name|CTL_LUN_STOPPED
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_lun_offline
parameter_list|(
name|struct
name|ctl_be_lun
modifier|*
name|be_lun
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|ctl_softc
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|ctl_softc
operator|=
name|control_softc
expr_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|be_lun
operator|->
name|ctl_lun
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|lun
operator|->
name|flags
operator||=
name|CTL_LUN_OFFLINE
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_lun_online
parameter_list|(
name|struct
name|ctl_be_lun
modifier|*
name|be_lun
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|ctl_softc
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|ctl_softc
operator|=
name|control_softc
expr_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|be_lun
operator|->
name|ctl_lun
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_LUN_OFFLINE
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_invalidate_lun
parameter_list|(
name|struct
name|ctl_be_lun
modifier|*
name|be_lun
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|ctl_softc
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|ctl_softc
operator|=
name|control_softc
expr_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|be_lun
operator|->
name|ctl_lun
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
comment|/* 	 * The LUN needs to be disabled before it can be marked invalid. 	 */
if|if
condition|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_DISABLED
operator|)
operator|==
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Mark the LUN invalid. 	 */
name|lun
operator|->
name|flags
operator||=
name|CTL_LUN_INVALID
expr_stmt|;
comment|/* 	 * If there is nothing in the OOA queue, go ahead and free the LUN. 	 * If we have something in the OOA queue, we'll free it when the 	 * last I/O completes. 	 */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|lun
operator|->
name|ooa_queue
argument_list|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ctl_softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|ctl_free_lun
argument_list|(
name|lun
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ctl_softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
block|}
else|else
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_lun_inoperable
parameter_list|(
name|struct
name|ctl_be_lun
modifier|*
name|be_lun
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|ctl_softc
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|ctl_softc
operator|=
name|control_softc
expr_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|be_lun
operator|->
name|ctl_lun
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|lun
operator|->
name|flags
operator||=
name|CTL_LUN_INOPERABLE
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_lun_operable
parameter_list|(
name|struct
name|ctl_be_lun
modifier|*
name|be_lun
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|ctl_softc
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|ctl_softc
operator|=
name|control_softc
expr_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|be_lun
operator|->
name|ctl_lun
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_LUN_INOPERABLE
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_lun_power_lock
parameter_list|(
name|struct
name|ctl_be_lun
modifier|*
name|be_lun
parameter_list|,
name|struct
name|ctl_nexus
modifier|*
name|nexus
parameter_list|,
name|int
name|lock
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|struct
name|copan_aps_subpage
modifier|*
name|current_sp
decl_stmt|;
name|struct
name|ctl_page_index
modifier|*
name|page_index
decl_stmt|;
name|int
name|i
decl_stmt|;
name|softc
operator|=
name|control_softc
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|be_lun
operator|->
name|ctl_lun
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|page_index
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_NUM_MODE_PAGES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|lun
operator|->
name|mode_pages
operator|.
name|index
index|[
name|i
index|]
operator|.
name|page_code
operator|&
name|SMPH_PC_MASK
operator|)
operator|!=
name|APS_PAGE_CODE
condition|)
continue|continue;
if|if
condition|(
name|lun
operator|->
name|mode_pages
operator|.
name|index
index|[
name|i
index|]
operator|.
name|subpage
operator|!=
name|APS_SUBPAGE_CODE
condition|)
continue|continue;
name|page_index
operator|=
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|index
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|page_index
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: APS subpage not found for lun %ju!\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|uintmax_t
operator|)
name|lun
operator|->
name|lun
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|#
directive|if
literal|0
block|if ((softc->aps_locked_lun != 0)&& (softc->aps_locked_lun != lun->lun)) { 		printf("%s: attempt to lock LUN %llu when %llu is already " 		       "locked\n"); 		mtx_unlock(&lun->lun_lock); 		mtx_unlock(&softc->ctl_lock); 		return (1); 	}
endif|#
directive|endif
name|current_sp
operator|=
operator|(
expr|struct
name|copan_aps_subpage
operator|*
operator|)
operator|(
name|page_index
operator|->
name|page_data
operator|+
operator|(
name|page_index
operator|->
name|page_len
operator|*
name|CTL_PAGE_CURRENT
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|lock
operator|!=
literal|0
condition|)
block|{
name|current_sp
operator|->
name|lock_active
operator|=
name|APS_LOCK_ACTIVE
expr_stmt|;
name|softc
operator|->
name|aps_locked_lun
operator|=
name|lun
operator|->
name|lun
expr_stmt|;
block|}
else|else
block|{
name|current_sp
operator|->
name|lock_active
operator|=
literal|0
expr_stmt|;
name|softc
operator|->
name|aps_locked_lun
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * If we're in HA mode, try to send the lock message to the other 	 * side. 	 */
if|if
condition|(
name|ctl_is_single
operator|==
literal|0
condition|)
block|{
name|int
name|isc_retval
decl_stmt|;
name|union
name|ctl_ha_msg
name|lock_msg
decl_stmt|;
name|lock_msg
operator|.
name|hdr
operator|.
name|nexus
operator|=
operator|*
name|nexus
expr_stmt|;
name|lock_msg
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_APS_LOCK
expr_stmt|;
if|if
condition|(
name|lock
operator|!=
literal|0
condition|)
name|lock_msg
operator|.
name|aps
operator|.
name|lock_flag
operator|=
literal|1
expr_stmt|;
else|else
name|lock_msg
operator|.
name|aps
operator|.
name|lock_flag
operator|=
literal|0
expr_stmt|;
name|isc_retval
operator|=
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|lock_msg
argument_list|,
sizeof|sizeof
argument_list|(
name|lock_msg
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|isc_retval
operator|>
name|CTL_HA_STATUS_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"%s: APS (lock=%d) error returned from "
literal|"ctl_ha_msg_send: %d\n"
argument_list|,
name|__func__
argument_list|,
name|lock
argument_list|,
name|isc_retval
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ctl_lun_capacity_changed
parameter_list|(
name|struct
name|ctl_be_lun
modifier|*
name|be_lun
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|struct
name|ctl_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|softc
operator|=
name|control_softc
expr_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|be_lun
operator|->
name|ctl_lun
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_MAX_INITIATORS
condition|;
name|i
operator|++
control|)
name|lun
operator|->
name|pending_ua
index|[
name|i
index|]
operator||=
name|CTL_UA_CAPACITY_CHANGED
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Backend "memory move is complete" callback for requests that never  * make it down to say RAIDCore's configuration code.  */
end_comment

begin_function
name|int
name|ctl_config_move_done
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|CTL_RETVAL_COMPLETE
expr_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_config_move_done\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * XXX KDM this shouldn't happen, but what if it does? 	 */
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|io_type
operator|!=
name|CTL_IO_SCSI
condition|)
name|panic
argument_list|(
literal|"I/O type isn't CTL_IO_SCSI!"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|port_status
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ABORT
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|==
name|CTL_STATUS_NONE
operator|)
condition|)
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|=
name|CTL_SUCCESS
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|port_status
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ABORT
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|==
name|CTL_STATUS_NONE
operator|)
condition|)
block|{
comment|/* 		 * For hardware error sense keys, the sense key 		 * specific value is defined to be a retry count, 		 * but we use it to pass back an internal FETD 		 * error code.  XXX KDM  Hopefully the FETD is only 		 * using 16 bits for an error code, since that's 		 * all the space we have in the sks field. 		 */
name|ctl_set_internal_failure
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*retry_count*/
name|io
operator|->
name|io_hdr
operator|.
name|port_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ALLOCATED
condition|)
name|free
argument_list|(
name|io
operator|->
name|scsiio
operator|.
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
operator|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_DATA_MASK
operator|)
operator|==
name|CTL_FLAG_DATA_IN
operator|)
operator|||
operator|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|!=
name|CTL_SUCCESS
operator|)
operator|||
operator|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ABORT
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* 		 * XXX KDM just assuming a single pointer here, and not a 		 * S/G list.  If we start using S/G lists for config data, 		 * we'll need to know how to clean them up here as well. 		 */
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ALLOCATED
condition|)
name|free
argument_list|(
name|io
operator|->
name|scsiio
operator|.
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
comment|/* Hopefully the user has already set the status... */
name|ctl_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * XXX KDM now we need to continue data movement.  Some 		 * options: 		 * - call ctl_scsiio() again?  We don't do this for data 		 *   writes, because for those at least we know ahead of 		 *   time where the write will go and how long it is.  For 		 *   config writes, though, that information is largely 		 *   contained within the write itself, thus we need to 		 *   parse out the data again. 		 * 		 * - Call some other function once the data is in? 		 */
comment|/* 		 * XXX KDM call ctl_scsiio() again for now, and check flag 		 * bits to see whether we're allocated or not. 		 */
name|retval
operator|=
name|ctl_scsiio
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
block|}
name|bailout
label|:
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This gets called by a backend driver when it is done with a  * data_submit method.  */
end_comment

begin_function
name|void
name|ctl_data_submit_done
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
comment|/* 	 * If the IO_CONT flag is set, we need to call the supplied 	 * function to continue processing the I/O, instead of completing 	 * the I/O just yet. 	 * 	 * If there is an error, though, we don't want to keep processing. 	 * Instead, just send status back to the initiator. 	 */
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_IO_CONT
operator|)
operator|&&
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ABORT
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|==
name|CTL_STATUS_NONE
operator|||
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|==
name|CTL_SUCCESS
operator|)
condition|)
block|{
name|io
operator|->
name|scsiio
operator|.
name|io_cont
argument_list|(
name|io
argument_list|)
expr_stmt|;
return|return;
block|}
name|ctl_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This gets called by a backend driver when it is done with a  * configuration write.  */
end_comment

begin_function
name|void
name|ctl_config_write_done
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|uint8_t
modifier|*
name|buf
decl_stmt|;
comment|/* 	 * If the IO_CONT flag is set, we need to call the supplied 	 * function to continue processing the I/O, instead of completing 	 * the I/O just yet. 	 * 	 * If there is an error, though, we don't want to keep processing. 	 * Instead, just send status back to the initiator. 	 */
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_IO_CONT
operator|)
operator|&&
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ABORT
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|==
name|CTL_STATUS_NONE
operator|||
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|==
name|CTL_SUCCESS
operator|)
condition|)
block|{
name|io
operator|->
name|scsiio
operator|.
name|io_cont
argument_list|(
name|io
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Since a configuration write can be done for commands that actually 	 * have data allocated, like write buffer, and commands that have 	 * no data, like start/stop unit, we need to check here. 	 */
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ALLOCATED
condition|)
name|buf
operator|=
name|io
operator|->
name|scsiio
operator|.
name|kern_data_ptr
expr_stmt|;
else|else
name|buf
operator|=
name|NULL
expr_stmt|;
name|ctl_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
condition|)
name|free
argument_list|(
name|buf
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * SCSI release command.  */
end_comment

begin_function
name|int
name|ctl_scsi_release
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|int
name|length
decl_stmt|,
name|longid
decl_stmt|,
name|thirdparty_id
decl_stmt|,
name|resv_id
decl_stmt|;
name|struct
name|ctl_softc
modifier|*
name|ctl_softc
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|uint32_t
name|residx
decl_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
name|resv_id
operator|=
literal|0
expr_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_scsi_release\n"
operator|)
argument_list|)
expr_stmt|;
name|residx
operator|=
name|ctl_get_resindex
argument_list|(
operator|&
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
argument_list|)
expr_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LUN
index|]
operator|.
name|ptr
expr_stmt|;
name|ctl_softc
operator|=
name|control_softc
expr_stmt|;
switch|switch
condition|(
name|ctsio
operator|->
name|cdb
index|[
literal|0
index|]
condition|)
block|{
case|case
name|RELEASE_10
case|:
block|{
name|struct
name|scsi_release_10
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_release_10
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SR10_LONGID
condition|)
name|longid
operator|=
literal|1
expr_stmt|;
else|else
name|thirdparty_id
operator|=
name|cdb
operator|->
name|thirdparty_id
expr_stmt|;
name|resv_id
operator|=
name|cdb
operator|->
name|resv_id
expr_stmt|;
name|length
operator|=
name|scsi_2btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * XXX KDM right now, we only support LUN reservation.  We don't 	 * support 3rd party reservations, or extent reservations, which 	 * might actually need the parameter list.  If we've gotten this 	 * far, we've got a LUN reservation.  Anything else got kicked out 	 * above.  So, according to SPC, ignore the length. 	 */
name|length
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ALLOCATED
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|length
operator|>
literal|0
operator|)
condition|)
block|{
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
name|length
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|length
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|length
expr_stmt|;
name|ctsio
operator|->
name|kern_data_resid
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
if|if
condition|(
name|length
operator|>
literal|0
condition|)
name|thirdparty_id
operator|=
name|scsi_8btou64
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
comment|/* 	 * According to SPC, it is not an error for an intiator to attempt 	 * to release a reservation on a LUN that isn't reserved, or that 	 * is reserved by another initiator.  The reservation can only be 	 * released, though, by the initiator who made it or by one of 	 * several reset type events. 	 */
if|if
condition|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_RESERVED
operator|)
operator|&&
operator|(
name|lun
operator|->
name|res_idx
operator|==
name|residx
operator|)
condition|)
name|lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_LUN_RESERVED
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|scsi_status
operator|=
name|SCSI_STATUS_OK
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|status
operator|=
name|CTL_SUCCESS
expr_stmt|;
if|if
condition|(
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ALLOCATED
condition|)
block|{
name|free
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator|&=
operator|~
name|CTL_FLAG_ALLOCATED
expr_stmt|;
block|}
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_scsi_reserve
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|int
name|extent
decl_stmt|,
name|thirdparty
decl_stmt|,
name|longid
decl_stmt|;
name|int
name|resv_id
decl_stmt|,
name|length
decl_stmt|;
name|uint64_t
name|thirdparty_id
decl_stmt|;
name|struct
name|ctl_softc
modifier|*
name|ctl_softc
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|uint32_t
name|residx
decl_stmt|;
name|extent
operator|=
literal|0
expr_stmt|;
name|thirdparty
operator|=
literal|0
expr_stmt|;
name|longid
operator|=
literal|0
expr_stmt|;
name|resv_id
operator|=
literal|0
expr_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
name|thirdparty_id
operator|=
literal|0
expr_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_reserve\n"
operator|)
argument_list|)
expr_stmt|;
name|residx
operator|=
name|ctl_get_resindex
argument_list|(
operator|&
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
argument_list|)
expr_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LUN
index|]
operator|.
name|ptr
expr_stmt|;
name|ctl_softc
operator|=
name|control_softc
expr_stmt|;
switch|switch
condition|(
name|ctsio
operator|->
name|cdb
index|[
literal|0
index|]
condition|)
block|{
case|case
name|RESERVE_10
case|:
block|{
name|struct
name|scsi_reserve_10
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_reserve_10
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SR10_LONGID
condition|)
name|longid
operator|=
literal|1
expr_stmt|;
else|else
name|thirdparty_id
operator|=
name|cdb
operator|->
name|thirdparty_id
expr_stmt|;
name|resv_id
operator|=
name|cdb
operator|->
name|resv_id
expr_stmt|;
name|length
operator|=
name|scsi_2btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * XXX KDM right now, we only support LUN reservation.  We don't 	 * support 3rd party reservations, or extent reservations, which 	 * might actually need the parameter list.  If we've gotten this 	 * far, we've got a LUN reservation.  Anything else got kicked out 	 * above.  So, according to SPC, ignore the length. 	 */
name|length
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ALLOCATED
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|length
operator|>
literal|0
operator|)
condition|)
block|{
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
name|length
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|length
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|length
expr_stmt|;
name|ctsio
operator|->
name|kern_data_resid
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
if|if
condition|(
name|length
operator|>
literal|0
condition|)
name|thirdparty_id
operator|=
name|scsi_8btou64
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_RESERVED
operator|)
operator|&&
operator|(
name|lun
operator|->
name|res_idx
operator|!=
name|residx
operator|)
condition|)
block|{
name|ctsio
operator|->
name|scsi_status
operator|=
name|SCSI_STATUS_RESERV_CONFLICT
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|status
operator|=
name|CTL_SCSI_ERROR
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|lun
operator|->
name|flags
operator||=
name|CTL_LUN_RESERVED
expr_stmt|;
name|lun
operator|->
name|res_idx
operator|=
name|residx
expr_stmt|;
name|ctsio
operator|->
name|scsi_status
operator|=
name|SCSI_STATUS_OK
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|status
operator|=
name|CTL_SUCCESS
expr_stmt|;
name|bailout
label|:
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ALLOCATED
condition|)
block|{
name|free
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator|&=
operator|~
name|CTL_FLAG_ALLOCATED
expr_stmt|;
block|}
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_start_stop
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|scsi_start_stop_unit
modifier|*
name|cdb
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|struct
name|ctl_softc
modifier|*
name|ctl_softc
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_start_stop\n"
operator|)
argument_list|)
expr_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LUN
index|]
operator|.
name|ptr
expr_stmt|;
name|ctl_softc
operator|=
name|control_softc
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_start_stop_unit
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
comment|/* 	 * XXX KDM 	 * We don't support the immediate bit on a stop unit.  In order to 	 * do that, we would need to code up a way to know that a stop is 	 * pending, and hold off any new commands until it completes, one 	 * way or another.  Then we could accept or reject those commands 	 * depending on its status.  We would almost need to do the reverse 	 * of what we do below for an immediate start -- return the copy of 	 * the ctl_io to the FETD with status to send to the host (and to 	 * free the copy!) and then free the original I/O once the stop 	 * actually completes.  That way, the OOA queue mechanism can work 	 * to block commands that shouldn't proceed.  Another alternative 	 * would be to put the copy in the queue in place of the original, 	 * and return the original back to the caller.  That could be 	 * slightly safer.. 	 */
if|if
condition|(
operator|(
name|cdb
operator|->
name|byte2
operator|&
name|SSS_IMMED
operator|)
operator|&&
operator|(
operator|(
name|cdb
operator|->
name|how
operator|&
name|SSS_START
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|ctl_set_invalid_field
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|1
argument_list|,
comment|/*bit_valid*/
literal|1
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_PR_RESERVED
operator|)
operator|&&
operator|(
operator|(
name|cdb
operator|->
name|how
operator|&
name|SSS_START
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|uint32_t
name|residx
decl_stmt|;
name|residx
operator|=
name|ctl_get_resindex
argument_list|(
operator|&
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|pr_keys
index|[
name|residx
index|]
operator|==
literal|0
operator|||
operator|(
name|lun
operator|->
name|pr_res_idx
operator|!=
name|residx
operator|&&
name|lun
operator|->
name|res_type
operator|<
literal|4
operator|)
condition|)
block|{
name|ctl_set_reservation_conflict
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
block|}
comment|/* 	 * If there is no backend on this device, we can't start or stop 	 * it.  In theory we shouldn't get any start/stop commands in the 	 * first place at this level if the LUN doesn't have a backend. 	 * That should get stopped by the command decode code. 	 */
if|if
condition|(
name|lun
operator|->
name|backend
operator|==
name|NULL
condition|)
block|{
name|ctl_set_invalid_opcode
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
comment|/* 	 * XXX KDM Copan-specific offline behavior. 	 * Figure out a reasonable way to port this? 	 */
ifdef|#
directive|ifdef
name|NEEDTOPORT
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|cdb
operator|->
name|byte2
operator|&
name|SSS_ONOFFLINE
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_OFFLINE
operator|)
condition|)
block|{
comment|/* 		 * If the LUN is offline, and the on/offline bit isn't set, 		 * reject the start or stop.  Otherwise, let it through. 		 */
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctl_set_lun_not_ready
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NEEDTOPORT */
comment|/* 		 * This could be a start or a stop when we're online, 		 * or a stop/offline or start/online.  A start or stop when 		 * we're offline is covered in the case above. 		 */
comment|/* 		 * In the non-immediate case, we send the request to 		 * the backend and return status to the user when 		 * it is done. 		 * 		 * In the immediate case, we allocate a new ctl_io 		 * to hold a copy of the request, and send that to 		 * the backend.  We then set good status on the 		 * user's request and return it immediately. 		 */
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SSS_IMMED
condition|)
block|{
name|union
name|ctl_io
modifier|*
name|new_io
decl_stmt|;
name|new_io
operator|=
name|ctl_alloc_io
argument_list|(
name|ctsio
operator|->
name|io_hdr
operator|.
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_io
operator|==
name|NULL
condition|)
block|{
name|ctl_set_busy
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctl_copy_io
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|,
name|new_io
argument_list|)
expr_stmt|;
name|retval
operator|=
name|lun
operator|->
name|backend
operator|->
name|config_write
argument_list|(
name|new_io
argument_list|)
expr_stmt|;
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|retval
operator|=
name|lun
operator|->
name|backend
operator|->
name|config_write
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|NEEDTOPORT
block|}
endif|#
directive|endif
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We support the SYNCHRONIZE CACHE command (10 and 16 byte versions), but  * we don't really do anything with the LBA and length fields if the user  * passes them in.  Instead we'll just flush out the cache for the entire  * LUN.  */
end_comment

begin_function
name|int
name|ctl_sync_cache
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|struct
name|ctl_softc
modifier|*
name|ctl_softc
decl_stmt|;
name|uint64_t
name|starting_lba
decl_stmt|;
name|uint32_t
name|block_count
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_sync_cache\n"
operator|)
argument_list|)
expr_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LUN
index|]
operator|.
name|ptr
expr_stmt|;
name|ctl_softc
operator|=
name|control_softc
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|ctsio
operator|->
name|cdb
index|[
literal|0
index|]
condition|)
block|{
case|case
name|SYNCHRONIZE_CACHE
case|:
block|{
name|struct
name|scsi_sync_cache
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_sync_cache
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|starting_lba
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|begin_lba
argument_list|)
expr_stmt|;
name|block_count
operator|=
name|scsi_2btoul
argument_list|(
name|cdb
operator|->
name|lb_count
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SYNCHRONIZE_CACHE_16
case|:
block|{
name|struct
name|scsi_sync_cache_16
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_sync_cache_16
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|starting_lba
operator|=
name|scsi_8btou64
argument_list|(
name|cdb
operator|->
name|begin_lba
argument_list|)
expr_stmt|;
name|block_count
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|lb_count
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|ctl_set_invalid_opcode
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
break|break;
comment|/* NOTREACHED */
block|}
comment|/* 	 * We check the LBA and length, but don't do anything with them. 	 * A SYNCHRONIZE CACHE will cause the entire cache for this lun to 	 * get flushed.  This check will just help satisfy anyone who wants 	 * to see an error for an out of range LBA. 	 */
if|if
condition|(
operator|(
name|starting_lba
operator|+
name|block_count
operator|)
operator|>
operator|(
name|lun
operator|->
name|be_lun
operator|->
name|maxlba
operator|+
literal|1
operator|)
condition|)
block|{
name|ctl_set_lba_out_of_range
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
comment|/* 	 * If this LUN has no backend, we can't flush the cache anyway. 	 */
if|if
condition|(
name|lun
operator|->
name|backend
operator|==
name|NULL
condition|)
block|{
name|ctl_set_invalid_opcode
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
comment|/* 	 * Check to see whether we're configured to send the SYNCHRONIZE 	 * CACHE command directly to the back end. 	 */
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ctl_softc
operator|->
name|flags
operator|&
name|CTL_FLAG_REAL_SYNC
operator|)
operator|&&
operator|(
operator|++
operator|(
name|lun
operator|->
name|sync_count
operator|)
operator|>=
name|lun
operator|->
name|sync_interval
operator|)
condition|)
block|{
name|lun
operator|->
name|sync_count
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|retval
operator|=
name|lun
operator|->
name|backend
operator|->
name|config_write
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
block|}
name|bailout
label|:
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_format
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|scsi_format
modifier|*
name|cdb
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|struct
name|ctl_softc
modifier|*
name|ctl_softc
decl_stmt|;
name|int
name|length
decl_stmt|,
name|defect_list_len
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_format\n"
operator|)
argument_list|)
expr_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LUN
index|]
operator|.
name|ptr
expr_stmt|;
name|ctl_softc
operator|=
name|control_softc
expr_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_format
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SF_FMTDATA
condition|)
block|{
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SF_LONGLIST
condition|)
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_format_header_long
argument_list|)
expr_stmt|;
else|else
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_format_header_short
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ALLOCATED
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|length
operator|>
literal|0
operator|)
condition|)
block|{
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
name|length
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|length
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|length
expr_stmt|;
name|ctsio
operator|->
name|kern_data_resid
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
name|defect_list_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SF_FMTDATA
condition|)
block|{
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SF_LONGLIST
condition|)
block|{
name|struct
name|scsi_format_header_long
modifier|*
name|header
decl_stmt|;
name|header
operator|=
operator|(
expr|struct
name|scsi_format_header_long
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|defect_list_len
operator|=
name|scsi_4btoul
argument_list|(
name|header
operator|->
name|defect_list_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|defect_list_len
operator|!=
literal|0
condition|)
block|{
name|ctl_set_invalid_field
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|0
argument_list|,
comment|/*field*/
literal|2
argument_list|,
comment|/*bit_valid*/
literal|0
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
block|}
else|else
block|{
name|struct
name|scsi_format_header_short
modifier|*
name|header
decl_stmt|;
name|header
operator|=
operator|(
expr|struct
name|scsi_format_header_short
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|defect_list_len
operator|=
name|scsi_2btoul
argument_list|(
name|header
operator|->
name|defect_list_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|defect_list_len
operator|!=
literal|0
condition|)
block|{
name|ctl_set_invalid_field
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|0
argument_list|,
comment|/*field*/
literal|2
argument_list|,
comment|/*bit_valid*/
literal|0
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
block|}
block|}
comment|/* 	 * The format command will clear out the "Medium format corrupted" 	 * status if set by the configuration code.  That status is really 	 * just a way to notify the host that we have lost the media, and 	 * get them to issue a command that will basically make them think 	 * they're blowing away the media. 	 */
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_LUN_INOPERABLE
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|scsi_status
operator|=
name|SCSI_STATUS_OK
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|status
operator|=
name|CTL_SUCCESS
expr_stmt|;
name|bailout
label|:
if|if
condition|(
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ALLOCATED
condition|)
block|{
name|free
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator|&=
operator|~
name|CTL_FLAG_ALLOCATED
expr_stmt|;
block|}
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_read_buffer
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|scsi_read_buffer
modifier|*
name|cdb
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|int
name|buffer_offset
decl_stmt|,
name|len
decl_stmt|;
specifier|static
name|uint8_t
name|descr
index|[
literal|4
index|]
decl_stmt|;
specifier|static
name|uint8_t
name|echo_descr
index|[
literal|4
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_read_buffer\n"
operator|)
argument_list|)
expr_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LUN
index|]
operator|.
name|ptr
expr_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_read_buffer
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_PR_RESERVED
condition|)
block|{
name|uint32_t
name|residx
decl_stmt|;
comment|/* 		 * XXX KDM need a lock here. 		 */
name|residx
operator|=
name|ctl_get_resindex
argument_list|(
operator|&
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lun
operator|->
name|res_type
operator|==
name|SPR_TYPE_EX_AC
operator|&&
name|residx
operator|!=
name|lun
operator|->
name|pr_res_idx
operator|)
operator|||
operator|(
operator|(
name|lun
operator|->
name|res_type
operator|==
name|SPR_TYPE_EX_AC_RO
operator|||
name|lun
operator|->
name|res_type
operator|==
name|SPR_TYPE_EX_AC_AR
operator|)
operator|&&
name|lun
operator|->
name|pr_keys
index|[
name|residx
index|]
operator|==
literal|0
operator|)
condition|)
block|{
name|ctl_set_reservation_conflict
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|cdb
operator|->
name|byte2
operator|&
name|RWB_MODE
operator|)
operator|!=
name|RWB_MODE_DATA
operator|&&
operator|(
name|cdb
operator|->
name|byte2
operator|&
name|RWB_MODE
operator|)
operator|!=
name|RWB_MODE_ECHO_DESCR
operator|&&
operator|(
name|cdb
operator|->
name|byte2
operator|&
name|RWB_MODE
operator|)
operator|!=
name|RWB_MODE_DESCR
condition|)
block|{
name|ctl_set_invalid_field
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|1
argument_list|,
comment|/*bit_valid*/
literal|1
argument_list|,
comment|/*bit*/
literal|4
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
name|len
operator|=
name|scsi_3btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
name|buffer_offset
operator|=
name|scsi_3btoul
argument_list|(
name|cdb
operator|->
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer_offset
operator|+
name|len
operator|>
sizeof|sizeof
argument_list|(
name|lun
operator|->
name|write_buffer
argument_list|)
condition|)
block|{
name|ctl_set_invalid_field
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|6
argument_list|,
comment|/*bit_valid*/
literal|0
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|cdb
operator|->
name|byte2
operator|&
name|RWB_MODE
operator|)
operator|==
name|RWB_MODE_DESCR
condition|)
block|{
name|descr
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|scsi_ulto3b
argument_list|(
sizeof|sizeof
argument_list|(
name|lun
operator|->
name|write_buffer
argument_list|)
argument_list|,
operator|&
name|descr
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|descr
expr_stmt|;
name|len
operator|=
name|min
argument_list|(
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|descr
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|cdb
operator|->
name|byte2
operator|&
name|RWB_MODE
operator|)
operator|==
name|RWB_MODE_ECHO_DESCR
condition|)
block|{
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|echo_descr
expr_stmt|;
name|len
operator|=
name|min
argument_list|(
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|echo_descr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|lun
operator|->
name|write_buffer
operator|+
name|buffer_offset
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|len
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|len
expr_stmt|;
name|ctsio
operator|->
name|kern_data_resid
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_write_buffer
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|scsi_write_buffer
modifier|*
name|cdb
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|int
name|buffer_offset
decl_stmt|,
name|len
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_write_buffer\n"
operator|)
argument_list|)
expr_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LUN
index|]
operator|.
name|ptr
expr_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_write_buffer
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
if|if
condition|(
operator|(
name|cdb
operator|->
name|byte2
operator|&
name|RWB_MODE
operator|)
operator|!=
name|RWB_MODE_DATA
condition|)
block|{
name|ctl_set_invalid_field
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|1
argument_list|,
comment|/*bit_valid*/
literal|1
argument_list|,
comment|/*bit*/
literal|4
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
name|len
operator|=
name|scsi_3btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
name|buffer_offset
operator|=
name|scsi_3btoul
argument_list|(
name|cdb
operator|->
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer_offset
operator|+
name|len
operator|>
sizeof|sizeof
argument_list|(
name|lun
operator|->
name|write_buffer
argument_list|)
condition|)
block|{
name|ctl_set_invalid_field
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|6
argument_list|,
comment|/*bit_valid*/
literal|0
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
comment|/* 	 * If we've got a kernel request that hasn't been malloced yet, 	 * malloc it and tell the caller the data buffer is here. 	 */
if|if
condition|(
operator|(
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ALLOCATED
operator|)
operator|==
literal|0
condition|)
block|{
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|lun
operator|->
name|write_buffer
operator|+
name|buffer_offset
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|len
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|len
expr_stmt|;
name|ctsio
operator|->
name|kern_data_resid
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_write_same
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|struct
name|ctl_lba_len_flags
modifier|*
name|lbalen
decl_stmt|;
name|uint64_t
name|lba
decl_stmt|;
name|uint32_t
name|num_blocks
decl_stmt|;
name|int
name|len
decl_stmt|,
name|retval
decl_stmt|;
name|uint8_t
name|byte2
decl_stmt|;
name|retval
operator|=
name|CTL_RETVAL_COMPLETE
expr_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_write_same\n"
operator|)
argument_list|)
expr_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LUN
index|]
operator|.
name|ptr
expr_stmt|;
switch|switch
condition|(
name|ctsio
operator|->
name|cdb
index|[
literal|0
index|]
condition|)
block|{
case|case
name|WRITE_SAME_10
case|:
block|{
name|struct
name|scsi_write_same_10
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_write_same_10
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|lba
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
name|num_blocks
operator|=
name|scsi_2btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
name|byte2
operator|=
name|cdb
operator|->
name|byte2
expr_stmt|;
break|break;
block|}
case|case
name|WRITE_SAME_16
case|:
block|{
name|struct
name|scsi_write_same_16
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_write_same_16
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|lba
operator|=
name|scsi_8btou64
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
name|num_blocks
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
name|byte2
operator|=
name|cdb
operator|->
name|byte2
expr_stmt|;
break|break;
block|}
default|default:
comment|/* 		 * We got a command we don't support.  This shouldn't 		 * happen, commands should be filtered out above us. 		 */
name|ctl_set_invalid_opcode
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
break|break;
comment|/* NOTREACHED */
block|}
comment|/* NDOB and ANCHOR flags can be used only together with UNMAP */
if|if
condition|(
operator|(
name|byte2
operator|&
name|SWS_UNMAP
operator|)
operator|==
literal|0
operator|&&
operator|(
name|byte2
operator|&
operator|(
name|SWS_NDOB
operator||
name|SWS_ANCHOR
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ctl_set_invalid_field
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|1
argument_list|,
comment|/*bit_valid*/
literal|1
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
comment|/* 	 * The first check is to make sure we're in bounds, the second 	 * check is to catch wrap-around problems.  If the lba + num blocks 	 * is less than the lba, then we've wrapped around and the block 	 * range is invalid anyway. 	 */
if|if
condition|(
operator|(
operator|(
name|lba
operator|+
name|num_blocks
operator|)
operator|>
operator|(
name|lun
operator|->
name|be_lun
operator|->
name|maxlba
operator|+
literal|1
operator|)
operator|)
operator|||
operator|(
operator|(
name|lba
operator|+
name|num_blocks
operator|)
operator|<
name|lba
operator|)
condition|)
block|{
name|ctl_set_lba_out_of_range
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
comment|/* Zero number of blocks means "to the last logical block" */
if|if
condition|(
name|num_blocks
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|lun
operator|->
name|be_lun
operator|->
name|maxlba
operator|+
literal|1
operator|)
operator|-
name|lba
operator|>
name|UINT32_MAX
condition|)
block|{
name|ctl_set_invalid_field
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|0
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|0
argument_list|,
comment|/*bit_valid*/
literal|0
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
name|num_blocks
operator|=
operator|(
name|lun
operator|->
name|be_lun
operator|->
name|maxlba
operator|+
literal|1
operator|)
operator|-
name|lba
expr_stmt|;
block|}
name|len
operator|=
name|lun
operator|->
name|be_lun
operator|->
name|blocksize
expr_stmt|;
comment|/* 	 * If we've got a kernel request that hasn't been malloced yet, 	 * malloc it and tell the caller the data buffer is here. 	 */
if|if
condition|(
operator|(
name|byte2
operator|&
name|SWS_NDOB
operator|)
operator|==
literal|0
operator|&&
operator|(
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ALLOCATED
operator|)
operator|==
literal|0
condition|)
block|{
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
name|len
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
empty_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|len
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|len
expr_stmt|;
name|ctsio
operator|->
name|kern_data_resid
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
name|lbalen
operator|=
operator|(
expr|struct
name|ctl_lba_len_flags
operator|*
operator|)
operator|&
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LBA_LEN
index|]
expr_stmt|;
name|lbalen
operator|->
name|lba
operator|=
name|lba
expr_stmt|;
name|lbalen
operator|->
name|len
operator|=
name|num_blocks
expr_stmt|;
name|lbalen
operator|->
name|flags
operator|=
name|byte2
expr_stmt|;
name|retval
operator|=
name|lun
operator|->
name|backend
operator|->
name|config_write
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_unmap
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|struct
name|scsi_unmap
modifier|*
name|cdb
decl_stmt|;
name|struct
name|ctl_ptr_len_flags
modifier|*
name|ptrlen
decl_stmt|;
name|struct
name|scsi_unmap_header
modifier|*
name|hdr
decl_stmt|;
name|struct
name|scsi_unmap_desc
modifier|*
name|buf
decl_stmt|,
modifier|*
name|end
decl_stmt|,
modifier|*
name|endnz
decl_stmt|,
modifier|*
name|range
decl_stmt|;
name|uint64_t
name|lba
decl_stmt|;
name|uint32_t
name|num_blocks
decl_stmt|;
name|int
name|len
decl_stmt|,
name|retval
decl_stmt|;
name|uint8_t
name|byte2
decl_stmt|;
name|retval
operator|=
name|CTL_RETVAL_COMPLETE
expr_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_unmap\n"
operator|)
argument_list|)
expr_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LUN
index|]
operator|.
name|ptr
expr_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_unmap
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|len
operator|=
name|scsi_2btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
name|byte2
operator|=
name|cdb
operator|->
name|byte2
expr_stmt|;
comment|/* 	 * If we've got a kernel request that hasn't been malloced yet, 	 * malloc it and tell the caller the data buffer is here. 	 */
if|if
condition|(
operator|(
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ALLOCATED
operator|)
operator|==
literal|0
condition|)
block|{
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
name|len
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
empty_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|len
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|len
expr_stmt|;
name|ctsio
operator|->
name|kern_data_resid
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
name|len
operator|=
name|ctsio
operator|->
name|kern_total_len
operator|-
name|ctsio
operator|->
name|kern_data_resid
expr_stmt|;
name|hdr
operator|=
operator|(
expr|struct
name|scsi_unmap_header
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|||
name|len
operator|<
operator|(
name|scsi_2btoul
argument_list|(
name|hdr
operator|->
name|length
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|hdr
operator|->
name|length
argument_list|)
operator|)
operator|||
name|len
operator|<
operator|(
name|scsi_2btoul
argument_list|(
name|hdr
operator|->
name|desc_length
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|)
operator|||
name|scsi_2btoul
argument_list|(
name|hdr
operator|->
name|desc_length
argument_list|)
operator|%
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ctl_set_invalid_field
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|0
argument_list|,
comment|/*command*/
literal|0
argument_list|,
comment|/*field*/
literal|0
argument_list|,
comment|/*bit_valid*/
literal|0
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
name|len
operator|=
name|scsi_2btoul
argument_list|(
name|hdr
operator|->
name|desc_length
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
expr|struct
name|scsi_unmap_desc
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
expr_stmt|;
name|end
operator|=
name|buf
operator|+
name|len
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
expr_stmt|;
name|endnz
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|range
operator|=
name|buf
init|;
name|range
operator|<
name|end
condition|;
name|range
operator|++
control|)
block|{
name|lba
operator|=
name|scsi_8btou64
argument_list|(
name|range
operator|->
name|lba
argument_list|)
expr_stmt|;
name|num_blocks
operator|=
name|scsi_4btoul
argument_list|(
name|range
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|lba
operator|+
name|num_blocks
operator|)
operator|>
operator|(
name|lun
operator|->
name|be_lun
operator|->
name|maxlba
operator|+
literal|1
operator|)
operator|)
operator|||
operator|(
operator|(
name|lba
operator|+
name|num_blocks
operator|)
operator|<
name|lba
operator|)
condition|)
block|{
name|ctl_set_lba_out_of_range
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
if|if
condition|(
name|num_blocks
operator|!=
literal|0
condition|)
name|endnz
operator|=
name|range
operator|+
literal|1
expr_stmt|;
block|}
comment|/* 	 * Block backend can not handle zero last range. 	 * Filter it out and return if there is nothing left. 	 */
name|len
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|endnz
operator|-
operator|(
name|uint8_t
operator|*
operator|)
name|buf
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ptrlen
operator|=
operator|(
expr|struct
name|ctl_ptr_len_flags
operator|*
operator|)
operator|&
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LBA_LEN
index|]
expr_stmt|;
name|ptrlen
operator|->
name|ptr
operator|=
operator|(
name|void
operator|*
operator|)
name|buf
expr_stmt|;
name|ptrlen
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|ptrlen
operator|->
name|flags
operator|=
name|byte2
expr_stmt|;
name|ctl_check_blocked
argument_list|(
name|lun
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|retval
operator|=
name|lun
operator|->
name|backend
operator|->
name|config_write
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Note that this function currently doesn't actually do anything inside  * CTL to enforce things if the DQue bit is turned on.  *  * Also note that this function can't be used in the default case, because  * the DQue bit isn't set in the changeable mask for the control mode page  * anyway.  This is just here as an example for how to implement a page  * handler, and a placeholder in case we want to allow the user to turn  * tagged queueing on and off.  *  * The D_SENSE bit handling is functional, however, and will turn  * descriptor sense on and off for a given LUN.  */
end_comment

begin_function
name|int
name|ctl_control_page_handler
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|struct
name|ctl_page_index
modifier|*
name|page_index
parameter_list|,
name|uint8_t
modifier|*
name|page_ptr
parameter_list|)
block|{
name|struct
name|scsi_control_page
modifier|*
name|current_cp
decl_stmt|,
modifier|*
name|saved_cp
decl_stmt|,
modifier|*
name|user_cp
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|struct
name|ctl_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|set_ua
decl_stmt|;
name|uint32_t
name|initidx
decl_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LUN
index|]
operator|.
name|ptr
expr_stmt|;
name|initidx
operator|=
name|ctl_get_initindex
argument_list|(
operator|&
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
argument_list|)
expr_stmt|;
name|set_ua
operator|=
literal|0
expr_stmt|;
name|user_cp
operator|=
operator|(
expr|struct
name|scsi_control_page
operator|*
operator|)
name|page_ptr
expr_stmt|;
name|current_cp
operator|=
operator|(
expr|struct
name|scsi_control_page
operator|*
operator|)
operator|(
name|page_index
operator|->
name|page_data
operator|+
operator|(
name|page_index
operator|->
name|page_len
operator|*
name|CTL_PAGE_CURRENT
operator|)
operator|)
expr_stmt|;
name|saved_cp
operator|=
operator|(
expr|struct
name|scsi_control_page
operator|*
operator|)
operator|(
name|page_index
operator|->
name|page_data
operator|+
operator|(
name|page_index
operator|->
name|page_len
operator|*
name|CTL_PAGE_SAVED
operator|)
operator|)
expr_stmt|;
name|softc
operator|=
name|control_softc
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|current_cp
operator|->
name|rlec
operator|&
name|SCP_DSENSE
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|user_cp
operator|->
name|rlec
operator|&
name|SCP_DSENSE
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* 		 * Descriptor sense is currently turned off and the user 		 * wants to turn it on. 		 */
name|current_cp
operator|->
name|rlec
operator||=
name|SCP_DSENSE
expr_stmt|;
name|saved_cp
operator|->
name|rlec
operator||=
name|SCP_DSENSE
expr_stmt|;
name|lun
operator|->
name|flags
operator||=
name|CTL_LUN_SENSE_DESC
expr_stmt|;
name|set_ua
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|current_cp
operator|->
name|rlec
operator|&
name|SCP_DSENSE
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|user_cp
operator|->
name|rlec
operator|&
name|SCP_DSENSE
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * Descriptor sense is currently turned on, and the user 		 * wants to turn it off. 		 */
name|current_cp
operator|->
name|rlec
operator|&=
operator|~
name|SCP_DSENSE
expr_stmt|;
name|saved_cp
operator|->
name|rlec
operator|&=
operator|~
name|SCP_DSENSE
expr_stmt|;
name|lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_LUN_SENSE_DESC
expr_stmt|;
name|set_ua
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|current_cp
operator|->
name|queue_flags
operator|&
name|SCP_QUEUE_ALG_MASK
operator|)
operator|!=
operator|(
name|user_cp
operator|->
name|queue_flags
operator|&
name|SCP_QUEUE_ALG_MASK
operator|)
condition|)
block|{
name|current_cp
operator|->
name|queue_flags
operator|&=
operator|~
name|SCP_QUEUE_ALG_MASK
expr_stmt|;
name|current_cp
operator|->
name|queue_flags
operator||=
name|user_cp
operator|->
name|queue_flags
operator|&
name|SCP_QUEUE_ALG_MASK
expr_stmt|;
name|saved_cp
operator|->
name|queue_flags
operator|&=
operator|~
name|SCP_QUEUE_ALG_MASK
expr_stmt|;
name|saved_cp
operator|->
name|queue_flags
operator||=
name|user_cp
operator|->
name|queue_flags
operator|&
name|SCP_QUEUE_ALG_MASK
expr_stmt|;
name|set_ua
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|current_cp
operator|->
name|eca_and_aen
operator|&
name|SCP_SWP
operator|)
operator|!=
operator|(
name|user_cp
operator|->
name|eca_and_aen
operator|&
name|SCP_SWP
operator|)
condition|)
block|{
name|current_cp
operator|->
name|eca_and_aen
operator|&=
operator|~
name|SCP_SWP
expr_stmt|;
name|current_cp
operator|->
name|eca_and_aen
operator||=
name|user_cp
operator|->
name|eca_and_aen
operator|&
name|SCP_SWP
expr_stmt|;
name|saved_cp
operator|->
name|eca_and_aen
operator|&=
operator|~
name|SCP_SWP
expr_stmt|;
name|saved_cp
operator|->
name|eca_and_aen
operator||=
name|user_cp
operator|->
name|eca_and_aen
operator|&
name|SCP_SWP
expr_stmt|;
name|set_ua
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|set_ua
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* 		 * Let other initiators know that the mode 		 * parameters for this LUN have changed. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_MAX_INITIATORS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|initidx
condition|)
continue|continue;
name|lun
operator|->
name|pending_ua
index|[
name|i
index|]
operator||=
name|CTL_UA_MODE_CHANGE
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_caching_sp_handler
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|struct
name|ctl_page_index
modifier|*
name|page_index
parameter_list|,
name|uint8_t
modifier|*
name|page_ptr
parameter_list|)
block|{
name|struct
name|scsi_caching_page
modifier|*
name|current_cp
decl_stmt|,
modifier|*
name|saved_cp
decl_stmt|,
modifier|*
name|user_cp
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|int
name|set_ua
decl_stmt|;
name|uint32_t
name|initidx
decl_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LUN
index|]
operator|.
name|ptr
expr_stmt|;
name|initidx
operator|=
name|ctl_get_initindex
argument_list|(
operator|&
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
argument_list|)
expr_stmt|;
name|set_ua
operator|=
literal|0
expr_stmt|;
name|user_cp
operator|=
operator|(
expr|struct
name|scsi_caching_page
operator|*
operator|)
name|page_ptr
expr_stmt|;
name|current_cp
operator|=
operator|(
expr|struct
name|scsi_caching_page
operator|*
operator|)
operator|(
name|page_index
operator|->
name|page_data
operator|+
operator|(
name|page_index
operator|->
name|page_len
operator|*
name|CTL_PAGE_CURRENT
operator|)
operator|)
expr_stmt|;
name|saved_cp
operator|=
operator|(
expr|struct
name|scsi_caching_page
operator|*
operator|)
operator|(
name|page_index
operator|->
name|page_data
operator|+
operator|(
name|page_index
operator|->
name|page_len
operator|*
name|CTL_PAGE_SAVED
operator|)
operator|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|current_cp
operator|->
name|flags1
operator|&
operator|(
name|SCP_WCE
operator||
name|SCP_RCD
operator|)
operator|)
operator|!=
operator|(
name|user_cp
operator|->
name|flags1
operator|&
operator|(
name|SCP_WCE
operator||
name|SCP_RCD
operator|)
operator|)
condition|)
block|{
name|current_cp
operator|->
name|flags1
operator|&=
operator|~
operator|(
name|SCP_WCE
operator||
name|SCP_RCD
operator|)
expr_stmt|;
name|current_cp
operator|->
name|flags1
operator||=
name|user_cp
operator|->
name|flags1
operator|&
operator|(
name|SCP_WCE
operator||
name|SCP_RCD
operator|)
expr_stmt|;
name|saved_cp
operator|->
name|flags1
operator|&=
operator|~
operator|(
name|SCP_WCE
operator||
name|SCP_RCD
operator|)
expr_stmt|;
name|saved_cp
operator|->
name|flags1
operator||=
name|user_cp
operator|->
name|flags1
operator|&
operator|(
name|SCP_WCE
operator||
name|SCP_RCD
operator|)
expr_stmt|;
name|set_ua
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|set_ua
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* 		 * Let other initiators know that the mode 		 * parameters for this LUN have changed. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_MAX_INITIATORS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|initidx
condition|)
continue|continue;
name|lun
operator|->
name|pending_ua
index|[
name|i
index|]
operator||=
name|CTL_UA_MODE_CHANGE
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_power_sp_handler
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|struct
name|ctl_page_index
modifier|*
name|page_index
parameter_list|,
name|uint8_t
modifier|*
name|page_ptr
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_power_sp_sense_handler
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|struct
name|ctl_page_index
modifier|*
name|page_index
parameter_list|,
name|int
name|pc
parameter_list|)
block|{
name|struct
name|copan_power_subpage
modifier|*
name|page
decl_stmt|;
name|page
operator|=
operator|(
expr|struct
name|copan_power_subpage
operator|*
operator|)
name|page_index
operator|->
name|page_data
operator|+
operator|(
name|page_index
operator|->
name|page_len
operator|*
name|pc
operator|)
expr_stmt|;
switch|switch
condition|(
name|pc
condition|)
block|{
case|case
name|SMS_PAGE_CTRL_CHANGEABLE
operator|>>
literal|6
case|:
comment|/* 		 * We don't update the changable bits for this page. 		 */
break|break;
case|case
name|SMS_PAGE_CTRL_CURRENT
operator|>>
literal|6
case|:
case|case
name|SMS_PAGE_CTRL_DEFAULT
operator|>>
literal|6
case|:
case|case
name|SMS_PAGE_CTRL_SAVED
operator|>>
literal|6
case|:
ifdef|#
directive|ifdef
name|NEEDTOPORT
name|ctl_update_power_subpage
argument_list|(
name|page
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
ifdef|#
directive|ifdef
name|NEEDTOPORT
name|EPRINT
argument_list|(
literal|0
argument_list|,
literal|"Invalid PC %d!!"
argument_list|,
name|pc
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_aps_sp_handler
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|struct
name|ctl_page_index
modifier|*
name|page_index
parameter_list|,
name|uint8_t
modifier|*
name|page_ptr
parameter_list|)
block|{
name|struct
name|copan_aps_subpage
modifier|*
name|user_sp
decl_stmt|;
name|struct
name|copan_aps_subpage
modifier|*
name|current_sp
decl_stmt|;
name|union
name|ctl_modepage_info
modifier|*
name|modepage_info
decl_stmt|;
name|struct
name|ctl_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|CTL_RETVAL_COMPLETE
expr_stmt|;
name|current_sp
operator|=
operator|(
expr|struct
name|copan_aps_subpage
operator|*
operator|)
operator|(
name|page_index
operator|->
name|page_data
operator|+
operator|(
name|page_index
operator|->
name|page_len
operator|*
name|CTL_PAGE_CURRENT
operator|)
operator|)
expr_stmt|;
name|softc
operator|=
name|control_softc
expr_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LUN
index|]
operator|.
name|ptr
expr_stmt|;
name|user_sp
operator|=
operator|(
expr|struct
name|copan_aps_subpage
operator|*
operator|)
name|page_ptr
expr_stmt|;
name|modepage_info
operator|=
operator|(
expr|union
name|ctl_modepage_info
operator|*
operator|)
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_MODEPAGE
index|]
operator|.
name|bytes
expr_stmt|;
name|modepage_info
operator|->
name|header
operator|.
name|page_code
operator|=
name|page_index
operator|->
name|page_code
operator|&
name|SMPH_PC_MASK
expr_stmt|;
name|modepage_info
operator|->
name|header
operator|.
name|subpage
operator|=
name|page_index
operator|->
name|subpage
expr_stmt|;
name|modepage_info
operator|->
name|aps
operator|.
name|lock_active
operator|=
name|user_sp
operator|->
name|lock_active
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
comment|/* 	 * If there is a request to lock the LUN and another LUN is locked 	 * this is an error. If the requested LUN is already locked ignore 	 * the request. If no LUN is locked attempt to lock it. 	 * if there is a request to unlock the LUN and the LUN is currently 	 * locked attempt to unlock it. Otherwise ignore the request. i.e. 	 * if another LUN is locked or no LUN is locked. 	 */
if|if
condition|(
name|user_sp
operator|->
name|lock_active
operator|&
name|APS_LOCK_ACTIVE
condition|)
block|{
if|if
condition|(
name|softc
operator|->
name|aps_locked_lun
operator|==
name|lun
operator|->
name|lun
condition|)
block|{
comment|/* 			 * This LUN is already locked, so we're done. 			 */
name|retval
operator|=
name|CTL_RETVAL_COMPLETE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|softc
operator|->
name|aps_locked_lun
operator|==
literal|0
condition|)
block|{
comment|/* 			 * No one has the lock, pass the request to the 			 * backend. 			 */
name|retval
operator|=
name|lun
operator|->
name|backend
operator|->
name|config_write
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Someone else has the lock, throw out the request. 			 */
name|ctl_set_already_locked
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
comment|/* 			 * Set the return value so that ctl_do_mode_select() 			 * won't try to complete the command.  We already 			 * completed it here. 			 */
name|retval
operator|=
name|CTL_RETVAL_ERROR
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|softc
operator|->
name|aps_locked_lun
operator|==
name|lun
operator|->
name|lun
condition|)
block|{
comment|/* 		 * This LUN is locked, so pass the unlock request to the 		 * backend. 		 */
name|retval
operator|=
name|lun
operator|->
name|backend
operator|->
name|config_write
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_debugconf_sp_select_handler
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|struct
name|ctl_page_index
modifier|*
name|page_index
parameter_list|,
name|uint8_t
modifier|*
name|page_ptr
parameter_list|)
block|{
name|uint8_t
modifier|*
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
name|c
operator|=
operator|(
operator|(
expr|struct
name|copan_debugconf_subpage
operator|*
operator|)
name|page_ptr
operator|)
operator|->
name|ctl_time_io_secs
expr_stmt|;
name|ctl_time_io_secs
operator|=
operator|(
name|c
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|c
index|[
literal|1
index|]
operator|<<
literal|0
operator|)
operator||
literal|0
expr_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"set ctl_time_io_secs to %d\n"
operator|,
name|ctl_time_io_secs
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"set ctl_time_io_secs to %d\n"
argument_list|,
name|ctl_time_io_secs
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"page data:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %.2x"
argument_list|,
name|page_ptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_debugconf_sp_sense_handler
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|struct
name|ctl_page_index
modifier|*
name|page_index
parameter_list|,
name|int
name|pc
parameter_list|)
block|{
name|struct
name|copan_debugconf_subpage
modifier|*
name|page
decl_stmt|;
name|page
operator|=
operator|(
expr|struct
name|copan_debugconf_subpage
operator|*
operator|)
name|page_index
operator|->
name|page_data
operator|+
operator|(
name|page_index
operator|->
name|page_len
operator|*
name|pc
operator|)
expr_stmt|;
switch|switch
condition|(
name|pc
condition|)
block|{
case|case
name|SMS_PAGE_CTRL_CHANGEABLE
operator|>>
literal|6
case|:
case|case
name|SMS_PAGE_CTRL_DEFAULT
operator|>>
literal|6
case|:
case|case
name|SMS_PAGE_CTRL_SAVED
operator|>>
literal|6
case|:
comment|/* 		 * We don't update the changable or default bits for this page. 		 */
break|break;
case|case
name|SMS_PAGE_CTRL_CURRENT
operator|>>
literal|6
case|:
name|page
operator|->
name|ctl_time_io_secs
index|[
literal|0
index|]
operator|=
name|ctl_time_io_secs
operator|>>
literal|8
expr_stmt|;
name|page
operator|->
name|ctl_time_io_secs
index|[
literal|1
index|]
operator|=
name|ctl_time_io_secs
operator|>>
literal|0
expr_stmt|;
break|break;
default|default:
ifdef|#
directive|ifdef
name|NEEDTOPORT
name|EPRINT
argument_list|(
literal|0
argument_list|,
literal|"Invalid PC %d!!"
argument_list|,
name|pc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NEEDTOPORT */
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_do_mode_select
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|scsi_mode_page_header
modifier|*
name|page_header
decl_stmt|;
name|struct
name|ctl_page_index
modifier|*
name|page_index
decl_stmt|;
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
decl_stmt|;
name|int
name|control_dev
decl_stmt|,
name|page_len
decl_stmt|;
name|int
name|page_len_offset
decl_stmt|,
name|page_len_size
decl_stmt|;
name|union
name|ctl_modepage_info
modifier|*
name|modepage_info
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|int
modifier|*
name|len_left
decl_stmt|,
modifier|*
name|len_used
decl_stmt|;
name|int
name|retval
decl_stmt|,
name|i
decl_stmt|;
name|ctsio
operator|=
operator|&
name|io
operator|->
name|scsiio
expr_stmt|;
name|page_index
operator|=
name|NULL
expr_stmt|;
name|page_len
operator|=
literal|0
expr_stmt|;
name|retval
operator|=
name|CTL_RETVAL_COMPLETE
expr_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LUN
index|]
operator|.
name|ptr
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
operator|!=
name|T_DIRECT
condition|)
name|control_dev
operator|=
literal|1
expr_stmt|;
else|else
name|control_dev
operator|=
literal|0
expr_stmt|;
name|modepage_info
operator|=
operator|(
expr|union
name|ctl_modepage_info
operator|*
operator|)
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_MODEPAGE
index|]
operator|.
name|bytes
expr_stmt|;
name|len_left
operator|=
operator|&
name|modepage_info
operator|->
name|header
operator|.
name|len_left
expr_stmt|;
name|len_used
operator|=
operator|&
name|modepage_info
operator|->
name|header
operator|.
name|len_used
expr_stmt|;
name|do_next_page
label|:
name|page_header
operator|=
operator|(
expr|struct
name|scsi_mode_page_header
operator|*
operator|)
operator|(
name|ctsio
operator|->
name|kern_data_ptr
operator|+
operator|*
name|len_used
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|len_left
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|len_left
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_mode_page_header
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|ctl_set_param_len_error
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|page_header
operator|->
name|page_code
operator|&
name|SMPH_SPF
operator|)
operator|&&
operator|(
operator|*
name|len_left
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_mode_page_header_sp
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|ctl_set_param_len_error
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
comment|/* 	 * XXX KDM should we do something with the block descriptor? 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_NUM_MODE_PAGES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|control_dev
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|lun
operator|->
name|mode_pages
operator|.
name|index
index|[
name|i
index|]
operator|.
name|page_flags
operator|&
name|CTL_PAGE_FLAG_DISK_ONLY
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|lun
operator|->
name|mode_pages
operator|.
name|index
index|[
name|i
index|]
operator|.
name|page_code
operator|&
name|SMPH_PC_MASK
operator|)
operator|!=
operator|(
name|page_header
operator|->
name|page_code
operator|&
name|SMPH_PC_MASK
operator|)
condition|)
continue|continue;
comment|/* 		 * If neither page has a subpage code, then we've got a 		 * match. 		 */
if|if
condition|(
operator|(
operator|(
name|lun
operator|->
name|mode_pages
operator|.
name|index
index|[
name|i
index|]
operator|.
name|page_code
operator|&
name|SMPH_SPF
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|page_header
operator|->
name|page_code
operator|&
name|SMPH_SPF
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|page_index
operator|=
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|index
index|[
name|i
index|]
expr_stmt|;
name|page_len
operator|=
name|page_header
operator|->
name|page_length
expr_stmt|;
break|break;
block|}
comment|/* 		 * If both pages have subpages, then the subpage numbers 		 * have to match. 		 */
if|if
condition|(
operator|(
name|lun
operator|->
name|mode_pages
operator|.
name|index
index|[
name|i
index|]
operator|.
name|page_code
operator|&
name|SMPH_SPF
operator|)
operator|&&
operator|(
name|page_header
operator|->
name|page_code
operator|&
name|SMPH_SPF
operator|)
condition|)
block|{
name|struct
name|scsi_mode_page_header_sp
modifier|*
name|sph
decl_stmt|;
name|sph
operator|=
operator|(
expr|struct
name|scsi_mode_page_header_sp
operator|*
operator|)
name|page_header
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|mode_pages
operator|.
name|index
index|[
name|i
index|]
operator|.
name|subpage
operator|==
name|sph
operator|->
name|subpage
condition|)
block|{
name|page_index
operator|=
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|index
index|[
name|i
index|]
expr_stmt|;
name|page_len
operator|=
name|scsi_2btoul
argument_list|(
name|sph
operator|->
name|page_length
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* 	 * If we couldn't find the page, or if we don't have a mode select 	 * handler for it, send back an error to the user. 	 */
if|if
condition|(
operator|(
name|page_index
operator|==
name|NULL
operator|)
operator|||
operator|(
name|page_index
operator|->
name|select_handler
operator|==
name|NULL
operator|)
condition|)
block|{
name|ctl_set_invalid_field
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|0
argument_list|,
comment|/*field*/
operator|*
name|len_used
argument_list|,
comment|/*bit_valid*/
literal|0
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
if|if
condition|(
name|page_index
operator|->
name|page_code
operator|&
name|SMPH_SPF
condition|)
block|{
name|page_len_offset
operator|=
literal|2
expr_stmt|;
name|page_len_size
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|page_len_size
operator|=
literal|1
expr_stmt|;
name|page_len_offset
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * If the length the initiator gives us isn't the one we specify in 	 * the mode page header, or if they didn't specify enough data in 	 * the CDB to avoid truncating this page, kick out the request. 	 */
if|if
condition|(
operator|(
name|page_len
operator|!=
operator|(
name|page_index
operator|->
name|page_len
operator|-
name|page_len_offset
operator|-
name|page_len_size
operator|)
operator|)
operator|||
operator|(
operator|*
name|len_left
operator|<
name|page_index
operator|->
name|page_len
operator|)
condition|)
block|{
name|ctl_set_invalid_field
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|0
argument_list|,
comment|/*field*/
operator|*
name|len_used
operator|+
name|page_len_offset
argument_list|,
comment|/*bit_valid*/
literal|0
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
comment|/* 	 * Run through the mode page, checking to make sure that the bits 	 * the user changed are actually legal for him to change. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|page_index
operator|->
name|page_len
condition|;
name|i
operator|++
control|)
block|{
name|uint8_t
modifier|*
name|user_byte
decl_stmt|,
modifier|*
name|change_mask
decl_stmt|,
modifier|*
name|current_byte
decl_stmt|;
name|int
name|bad_bit
decl_stmt|;
name|int
name|j
decl_stmt|;
name|user_byte
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|page_header
operator|+
name|i
expr_stmt|;
name|change_mask
operator|=
name|page_index
operator|->
name|page_data
operator|+
operator|(
name|page_index
operator|->
name|page_len
operator|*
name|CTL_PAGE_CHANGEABLE
operator|)
operator|+
name|i
expr_stmt|;
name|current_byte
operator|=
name|page_index
operator|->
name|page_data
operator|+
operator|(
name|page_index
operator|->
name|page_len
operator|*
name|CTL_PAGE_CURRENT
operator|)
operator|+
name|i
expr_stmt|;
comment|/* 		 * Check to see whether the user set any bits in this byte 		 * that he is not allowed to set. 		 */
if|if
condition|(
operator|(
operator|*
name|user_byte
operator|&
operator|~
operator|(
operator|*
name|change_mask
operator|)
operator|)
operator|==
operator|(
operator|*
name|current_byte
operator|&
operator|~
operator|(
operator|*
name|change_mask
operator|)
operator|)
condition|)
continue|continue;
comment|/* 		 * Go through bit by bit to determine which one is illegal. 		 */
name|bad_bit
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|7
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
if|if
condition|(
operator|(
operator|(
operator|(
literal|1
operator|<<
name|i
operator|)
operator|&
operator|~
operator|(
operator|*
name|change_mask
operator|)
operator|)
operator|&
operator|*
name|user_byte
operator|)
operator|!=
operator|(
operator|(
operator|(
literal|1
operator|<<
name|i
operator|)
operator|&
operator|~
operator|(
operator|*
name|change_mask
operator|)
operator|)
operator|&
operator|*
name|current_byte
operator|)
condition|)
block|{
name|bad_bit
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
name|ctl_set_invalid_field
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|0
argument_list|,
comment|/*field*/
operator|*
name|len_used
operator|+
name|i
argument_list|,
comment|/*bit_valid*/
literal|1
argument_list|,
comment|/*bit*/
name|bad_bit
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
comment|/* 	 * Decrement these before we call the page handler, since we may 	 * end up getting called back one way or another before the handler 	 * returns to this context. 	 */
operator|*
name|len_left
operator|-=
name|page_index
operator|->
name|page_len
expr_stmt|;
operator|*
name|len_used
operator|+=
name|page_index
operator|->
name|page_len
expr_stmt|;
name|retval
operator|=
name|page_index
operator|->
name|select_handler
argument_list|(
name|ctsio
argument_list|,
name|page_index
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|page_header
argument_list|)
expr_stmt|;
comment|/* 	 * If the page handler returns CTL_RETVAL_QUEUED, then we need to 	 * wait until this queued command completes to finish processing 	 * the mode page.  If it returns anything other than 	 * CTL_RETVAL_COMPLETE (e.g. CTL_RETVAL_ERROR), then it should have 	 * already set the sense information, freed the data pointer, and 	 * completed the io for us. 	 */
if|if
condition|(
name|retval
operator|!=
name|CTL_RETVAL_COMPLETE
condition|)
goto|goto
name|bailout_no_done
goto|;
comment|/* 	 * If the initiator sent us more than one page, parse the next one. 	 */
if|if
condition|(
operator|*
name|len_left
operator|>
literal|0
condition|)
goto|goto
name|do_next_page
goto|;
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
name|bailout_no_done
label|:
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_mode_select
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|int
name|param_len
decl_stmt|,
name|pf
decl_stmt|,
name|sp
decl_stmt|;
name|int
name|header_size
decl_stmt|,
name|bd_len
decl_stmt|;
name|int
name|len_left
decl_stmt|,
name|len_used
decl_stmt|;
name|struct
name|ctl_page_index
modifier|*
name|page_index
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|int
name|control_dev
decl_stmt|,
name|page_len
decl_stmt|;
name|union
name|ctl_modepage_info
modifier|*
name|modepage_info
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|pf
operator|=
literal|0
expr_stmt|;
name|sp
operator|=
literal|0
expr_stmt|;
name|page_len
operator|=
literal|0
expr_stmt|;
name|len_used
operator|=
literal|0
expr_stmt|;
name|len_left
operator|=
literal|0
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|bd_len
operator|=
literal|0
expr_stmt|;
name|page_index
operator|=
name|NULL
expr_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LUN
index|]
operator|.
name|ptr
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
operator|!=
name|T_DIRECT
condition|)
name|control_dev
operator|=
literal|1
expr_stmt|;
else|else
name|control_dev
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|ctsio
operator|->
name|cdb
index|[
literal|0
index|]
condition|)
block|{
case|case
name|MODE_SELECT_6
case|:
block|{
name|struct
name|scsi_mode_select_6
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_mode_select_6
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|pf
operator|=
operator|(
name|cdb
operator|->
name|byte2
operator|&
name|SMS_PF
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|sp
operator|=
operator|(
name|cdb
operator|->
name|byte2
operator|&
name|SMS_SP
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|param_len
operator|=
name|cdb
operator|->
name|length
expr_stmt|;
name|header_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_mode_header_6
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MODE_SELECT_10
case|:
block|{
name|struct
name|scsi_mode_select_10
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_mode_select_10
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|pf
operator|=
operator|(
name|cdb
operator|->
name|byte2
operator|&
name|SMS_PF
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|sp
operator|=
operator|(
name|cdb
operator|->
name|byte2
operator|&
name|SMS_SP
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|param_len
operator|=
name|scsi_2btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
name|header_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_mode_header_10
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|ctl_set_invalid_opcode
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
break|break;
comment|/* NOTREACHED */
block|}
comment|/* 	 * From SPC-3: 	 * "A parameter list length of zero indicates that the Data-Out Buffer 	 * shall be empty. This condition shall not be considered as an error." 	 */
if|if
condition|(
name|param_len
operator|==
literal|0
condition|)
block|{
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
comment|/* 	 * Since we'll hit this the first time through, prior to 	 * allocation, we don't need to free a data buffer here. 	 */
if|if
condition|(
name|param_len
operator|<
name|header_size
condition|)
block|{
name|ctl_set_param_len_error
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
comment|/* 	 * Allocate the data buffer and grab the user's data.  In theory, 	 * we shouldn't have to sanity check the parameter list length here 	 * because the maximum size is 64K.  We should be able to malloc 	 * that much without too many problems. 	 */
if|if
condition|(
operator|(
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ALLOCATED
operator|)
operator|==
literal|0
condition|)
block|{
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
name|param_len
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|param_len
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|param_len
expr_stmt|;
name|ctsio
operator|->
name|kern_data_resid
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
switch|switch
condition|(
name|ctsio
operator|->
name|cdb
index|[
literal|0
index|]
condition|)
block|{
case|case
name|MODE_SELECT_6
case|:
block|{
name|struct
name|scsi_mode_header_6
modifier|*
name|mh6
decl_stmt|;
name|mh6
operator|=
operator|(
expr|struct
name|scsi_mode_header_6
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|bd_len
operator|=
name|mh6
operator|->
name|blk_desc_len
expr_stmt|;
break|break;
block|}
case|case
name|MODE_SELECT_10
case|:
block|{
name|struct
name|scsi_mode_header_10
modifier|*
name|mh10
decl_stmt|;
name|mh10
operator|=
operator|(
expr|struct
name|scsi_mode_header_10
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|bd_len
operator|=
name|scsi_2btoul
argument_list|(
name|mh10
operator|->
name|blk_desc_len
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|panic
argument_list|(
literal|"Invalid CDB type %#x"
argument_list|,
name|ctsio
operator|->
name|cdb
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|param_len
operator|<
operator|(
name|header_size
operator|+
name|bd_len
operator|)
condition|)
block|{
name|free
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|ctl_set_param_len_error
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
comment|/* 	 * Set the IO_CONT flag, so that if this I/O gets passed to 	 * ctl_config_write_done(), it'll get passed back to 	 * ctl_do_mode_select() for further processing, or completion if 	 * we're all done. 	 */
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_IO_CONT
expr_stmt|;
name|ctsio
operator|->
name|io_cont
operator|=
name|ctl_do_mode_select
expr_stmt|;
name|modepage_info
operator|=
operator|(
expr|union
name|ctl_modepage_info
operator|*
operator|)
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_MODEPAGE
index|]
operator|.
name|bytes
expr_stmt|;
name|memset
argument_list|(
name|modepage_info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|modepage_info
argument_list|)
argument_list|)
expr_stmt|;
name|len_left
operator|=
name|param_len
operator|-
name|header_size
operator|-
name|bd_len
expr_stmt|;
name|len_used
operator|=
name|header_size
operator|+
name|bd_len
expr_stmt|;
name|modepage_info
operator|->
name|header
operator|.
name|len_left
operator|=
name|len_left
expr_stmt|;
name|modepage_info
operator|->
name|header
operator|.
name|len_used
operator|=
name|len_used
expr_stmt|;
return|return
operator|(
name|ctl_do_mode_select
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_mode_sense
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|int
name|pc
decl_stmt|,
name|page_code
decl_stmt|,
name|dbd
decl_stmt|,
name|llba
decl_stmt|,
name|subpage
decl_stmt|;
name|int
name|alloc_len
decl_stmt|,
name|page_len
decl_stmt|,
name|header_len
decl_stmt|,
name|total_len
decl_stmt|;
name|struct
name|scsi_mode_block_descr
modifier|*
name|block_desc
decl_stmt|;
name|struct
name|ctl_page_index
modifier|*
name|page_index
decl_stmt|;
name|int
name|control_dev
decl_stmt|;
name|dbd
operator|=
literal|0
expr_stmt|;
name|llba
operator|=
literal|0
expr_stmt|;
name|block_desc
operator|=
name|NULL
expr_stmt|;
name|page_index
operator|=
name|NULL
expr_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_mode_sense\n"
operator|)
argument_list|)
expr_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LUN
index|]
operator|.
name|ptr
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
operator|!=
name|T_DIRECT
condition|)
name|control_dev
operator|=
literal|1
expr_stmt|;
else|else
name|control_dev
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_PR_RESERVED
condition|)
block|{
name|uint32_t
name|residx
decl_stmt|;
comment|/* 		 * XXX KDM need a lock here. 		 */
name|residx
operator|=
name|ctl_get_resindex
argument_list|(
operator|&
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lun
operator|->
name|res_type
operator|==
name|SPR_TYPE_EX_AC
operator|&&
name|residx
operator|!=
name|lun
operator|->
name|pr_res_idx
operator|)
operator|||
operator|(
operator|(
name|lun
operator|->
name|res_type
operator|==
name|SPR_TYPE_EX_AC_RO
operator|||
name|lun
operator|->
name|res_type
operator|==
name|SPR_TYPE_EX_AC_AR
operator|)
operator|&&
name|lun
operator|->
name|pr_keys
index|[
name|residx
index|]
operator|==
literal|0
operator|)
condition|)
block|{
name|ctl_set_reservation_conflict
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
block|}
switch|switch
condition|(
name|ctsio
operator|->
name|cdb
index|[
literal|0
index|]
condition|)
block|{
case|case
name|MODE_SENSE_6
case|:
block|{
name|struct
name|scsi_mode_sense_6
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_mode_sense_6
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|header_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_mode_hdr_6
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SMS_DBD
condition|)
name|dbd
operator|=
literal|1
expr_stmt|;
else|else
name|header_len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_mode_block_descr
argument_list|)
expr_stmt|;
name|pc
operator|=
operator|(
name|cdb
operator|->
name|page
operator|&
name|SMS_PAGE_CTRL_MASK
operator|)
operator|>>
literal|6
expr_stmt|;
name|page_code
operator|=
name|cdb
operator|->
name|page
operator|&
name|SMS_PAGE_CODE
expr_stmt|;
name|subpage
operator|=
name|cdb
operator|->
name|subpage
expr_stmt|;
name|alloc_len
operator|=
name|cdb
operator|->
name|length
expr_stmt|;
break|break;
block|}
case|case
name|MODE_SENSE_10
case|:
block|{
name|struct
name|scsi_mode_sense_10
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_mode_sense_10
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|header_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_mode_hdr_10
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SMS_DBD
condition|)
name|dbd
operator|=
literal|1
expr_stmt|;
else|else
name|header_len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_mode_block_descr
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SMS10_LLBAA
condition|)
name|llba
operator|=
literal|1
expr_stmt|;
name|pc
operator|=
operator|(
name|cdb
operator|->
name|page
operator|&
name|SMS_PAGE_CTRL_MASK
operator|)
operator|>>
literal|6
expr_stmt|;
name|page_code
operator|=
name|cdb
operator|->
name|page
operator|&
name|SMS_PAGE_CODE
expr_stmt|;
name|subpage
operator|=
name|cdb
operator|->
name|subpage
expr_stmt|;
name|alloc_len
operator|=
name|scsi_2btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|ctl_set_invalid_opcode
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
break|break;
comment|/* NOTREACHED */
block|}
comment|/* 	 * We have to make a first pass through to calculate the size of 	 * the pages that match the user's query.  Then we allocate enough 	 * memory to hold it, and actually copy the data into the buffer. 	 */
switch|switch
condition|(
name|page_code
condition|)
block|{
case|case
name|SMS_ALL_PAGES_PAGE
case|:
block|{
name|int
name|i
decl_stmt|;
name|page_len
operator|=
literal|0
expr_stmt|;
comment|/* 		 * At the moment, values other than 0 and 0xff here are 		 * reserved according to SPC-3. 		 */
if|if
condition|(
operator|(
name|subpage
operator|!=
name|SMS_SUBPAGE_PAGE_0
operator|)
operator|&&
operator|(
name|subpage
operator|!=
name|SMS_SUBPAGE_ALL
operator|)
condition|)
block|{
name|ctl_set_invalid_field
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|3
argument_list|,
comment|/*bit_valid*/
literal|0
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_NUM_MODE_PAGES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|control_dev
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|lun
operator|->
name|mode_pages
operator|.
name|index
index|[
name|i
index|]
operator|.
name|page_flags
operator|&
name|CTL_PAGE_FLAG_DISK_ONLY
operator|)
condition|)
continue|continue;
comment|/* 			 * We don't use this subpage if the user didn't 			 * request all subpages. 			 */
if|if
condition|(
operator|(
name|lun
operator|->
name|mode_pages
operator|.
name|index
index|[
name|i
index|]
operator|.
name|subpage
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|subpage
operator|==
name|SMS_SUBPAGE_PAGE_0
operator|)
condition|)
continue|continue;
if|#
directive|if
literal|0
block|printf("found page %#x len %d\n", 			       lun->mode_pages.index[i].page_code& 			       SMPH_PC_MASK, 			       lun->mode_pages.index[i].page_len);
endif|#
directive|endif
name|page_len
operator|+=
name|lun
operator|->
name|mode_pages
operator|.
name|index
index|[
name|i
index|]
operator|.
name|page_len
expr_stmt|;
block|}
break|break;
block|}
default|default:
block|{
name|int
name|i
decl_stmt|;
name|page_len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_NUM_MODE_PAGES
condition|;
name|i
operator|++
control|)
block|{
comment|/* Look for the right page code */
if|if
condition|(
operator|(
name|lun
operator|->
name|mode_pages
operator|.
name|index
index|[
name|i
index|]
operator|.
name|page_code
operator|&
name|SMPH_PC_MASK
operator|)
operator|!=
name|page_code
condition|)
continue|continue;
comment|/* Look for the right subpage or the subpage wildcard*/
if|if
condition|(
operator|(
name|lun
operator|->
name|mode_pages
operator|.
name|index
index|[
name|i
index|]
operator|.
name|subpage
operator|!=
name|subpage
operator|)
operator|&&
operator|(
name|subpage
operator|!=
name|SMS_SUBPAGE_ALL
operator|)
condition|)
continue|continue;
comment|/* Make sure the page is supported for this dev type */
if|if
condition|(
operator|(
name|control_dev
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|lun
operator|->
name|mode_pages
operator|.
name|index
index|[
name|i
index|]
operator|.
name|page_flags
operator|&
name|CTL_PAGE_FLAG_DISK_ONLY
operator|)
condition|)
continue|continue;
if|#
directive|if
literal|0
block|printf("found page %#x len %d\n", 			       lun->mode_pages.index[i].page_code& 			       SMPH_PC_MASK, 			       lun->mode_pages.index[i].page_len);
endif|#
directive|endif
name|page_len
operator|+=
name|lun
operator|->
name|mode_pages
operator|.
name|index
index|[
name|i
index|]
operator|.
name|page_len
expr_stmt|;
block|}
if|if
condition|(
name|page_len
operator|==
literal|0
condition|)
block|{
name|ctl_set_invalid_field
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|2
argument_list|,
comment|/*bit_valid*/
literal|1
argument_list|,
comment|/*bit*/
literal|5
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
break|break;
block|}
block|}
name|total_len
operator|=
name|header_len
operator|+
name|page_len
expr_stmt|;
if|#
directive|if
literal|0
block|printf("header_len = %d, page_len = %d, total_len = %d\n", 	       header_len, page_len, total_len);
endif|#
directive|endif
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
name|total_len
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_data_resid
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|total_len
operator|<
name|alloc_len
condition|)
block|{
name|ctsio
operator|->
name|residual
operator|=
name|alloc_len
operator|-
name|total_len
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|total_len
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|total_len
expr_stmt|;
block|}
else|else
block|{
name|ctsio
operator|->
name|residual
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|alloc_len
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|alloc_len
expr_stmt|;
block|}
switch|switch
condition|(
name|ctsio
operator|->
name|cdb
index|[
literal|0
index|]
condition|)
block|{
case|case
name|MODE_SENSE_6
case|:
block|{
name|struct
name|scsi_mode_hdr_6
modifier|*
name|header
decl_stmt|;
name|header
operator|=
operator|(
expr|struct
name|scsi_mode_hdr_6
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|header
operator|->
name|datalen
operator|=
name|ctl_min
argument_list|(
name|total_len
operator|-
literal|1
argument_list|,
literal|254
argument_list|)
expr_stmt|;
if|if
condition|(
name|control_dev
operator|==
literal|0
condition|)
block|{
name|header
operator|->
name|dev_specific
operator|=
literal|0x10
expr_stmt|;
comment|/* DPOFUA */
if|if
condition|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_READONLY
operator|)
operator|||
operator|(
name|lun
operator|->
name|mode_pages
operator|.
name|control_page
index|[
name|CTL_PAGE_CURRENT
index|]
operator|.
name|eca_and_aen
operator|&
name|SCP_SWP
operator|)
operator|!=
literal|0
condition|)
name|header
operator|->
name|dev_specific
operator||=
literal|0x80
expr_stmt|;
comment|/* WP */
block|}
if|if
condition|(
name|dbd
condition|)
name|header
operator|->
name|block_descr_len
operator|=
literal|0
expr_stmt|;
else|else
name|header
operator|->
name|block_descr_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_mode_block_descr
argument_list|)
expr_stmt|;
name|block_desc
operator|=
operator|(
expr|struct
name|scsi_mode_block_descr
operator|*
operator|)
operator|&
name|header
index|[
literal|1
index|]
expr_stmt|;
break|break;
block|}
case|case
name|MODE_SENSE_10
case|:
block|{
name|struct
name|scsi_mode_hdr_10
modifier|*
name|header
decl_stmt|;
name|int
name|datalen
decl_stmt|;
name|header
operator|=
operator|(
expr|struct
name|scsi_mode_hdr_10
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|datalen
operator|=
name|ctl_min
argument_list|(
name|total_len
operator|-
literal|2
argument_list|,
literal|65533
argument_list|)
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|datalen
argument_list|,
name|header
operator|->
name|datalen
argument_list|)
expr_stmt|;
if|if
condition|(
name|control_dev
operator|==
literal|0
condition|)
block|{
name|header
operator|->
name|dev_specific
operator|=
literal|0x10
expr_stmt|;
comment|/* DPOFUA */
if|if
condition|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_READONLY
operator|)
operator|||
operator|(
name|lun
operator|->
name|mode_pages
operator|.
name|control_page
index|[
name|CTL_PAGE_CURRENT
index|]
operator|.
name|eca_and_aen
operator|&
name|SCP_SWP
operator|)
operator|!=
literal|0
condition|)
name|header
operator|->
name|dev_specific
operator||=
literal|0x80
expr_stmt|;
comment|/* WP */
block|}
if|if
condition|(
name|dbd
condition|)
name|scsi_ulto2b
argument_list|(
literal|0
argument_list|,
name|header
operator|->
name|block_descr_len
argument_list|)
expr_stmt|;
else|else
name|scsi_ulto2b
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_mode_block_descr
argument_list|)
argument_list|,
name|header
operator|->
name|block_descr_len
argument_list|)
expr_stmt|;
name|block_desc
operator|=
operator|(
expr|struct
name|scsi_mode_block_descr
operator|*
operator|)
operator|&
name|header
index|[
literal|1
index|]
expr_stmt|;
break|break;
block|}
default|default:
name|panic
argument_list|(
literal|"invalid CDB type %#x"
argument_list|,
name|ctsio
operator|->
name|cdb
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
comment|/* NOTREACHED */
block|}
comment|/* 	 * If we've got a disk, use its blocksize in the block 	 * descriptor.  Otherwise, just set it to 0. 	 */
if|if
condition|(
name|dbd
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|control_dev
operator|==
literal|0
condition|)
name|scsi_ulto3b
argument_list|(
name|lun
operator|->
name|be_lun
operator|->
name|blocksize
argument_list|,
name|block_desc
operator|->
name|block_len
argument_list|)
expr_stmt|;
else|else
name|scsi_ulto3b
argument_list|(
literal|0
argument_list|,
name|block_desc
operator|->
name|block_len
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|page_code
condition|)
block|{
case|case
name|SMS_ALL_PAGES_PAGE
case|:
block|{
name|int
name|i
decl_stmt|,
name|data_used
decl_stmt|;
name|data_used
operator|=
name|header_len
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_NUM_MODE_PAGES
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ctl_page_index
modifier|*
name|page_index
decl_stmt|;
name|page_index
operator|=
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|index
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|control_dev
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|page_index
operator|->
name|page_flags
operator|&
name|CTL_PAGE_FLAG_DISK_ONLY
operator|)
condition|)
continue|continue;
comment|/* 			 * We don't use this subpage if the user didn't 			 * request all subpages.  We already checked (above) 			 * to make sure the user only specified a subpage 			 * of 0 or 0xff in the SMS_ALL_PAGES_PAGE case. 			 */
if|if
condition|(
operator|(
name|page_index
operator|->
name|subpage
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|subpage
operator|==
name|SMS_SUBPAGE_PAGE_0
operator|)
condition|)
continue|continue;
comment|/* 			 * Call the handler, if it exists, to update the 			 * page to the latest values. 			 */
if|if
condition|(
name|page_index
operator|->
name|sense_handler
operator|!=
name|NULL
condition|)
name|page_index
operator|->
name|sense_handler
argument_list|(
name|ctsio
argument_list|,
name|page_index
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
operator|+
name|data_used
argument_list|,
name|page_index
operator|->
name|page_data
operator|+
operator|(
name|page_index
operator|->
name|page_len
operator|*
name|pc
operator|)
argument_list|,
name|page_index
operator|->
name|page_len
argument_list|)
expr_stmt|;
name|data_used
operator|+=
name|page_index
operator|->
name|page_len
expr_stmt|;
block|}
break|break;
block|}
default|default:
block|{
name|int
name|i
decl_stmt|,
name|data_used
decl_stmt|;
name|data_used
operator|=
name|header_len
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_NUM_MODE_PAGES
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ctl_page_index
modifier|*
name|page_index
decl_stmt|;
name|page_index
operator|=
operator|&
name|lun
operator|->
name|mode_pages
operator|.
name|index
index|[
name|i
index|]
expr_stmt|;
comment|/* Look for the right page code */
if|if
condition|(
operator|(
name|page_index
operator|->
name|page_code
operator|&
name|SMPH_PC_MASK
operator|)
operator|!=
name|page_code
condition|)
continue|continue;
comment|/* Look for the right subpage or the subpage wildcard*/
if|if
condition|(
operator|(
name|page_index
operator|->
name|subpage
operator|!=
name|subpage
operator|)
operator|&&
operator|(
name|subpage
operator|!=
name|SMS_SUBPAGE_ALL
operator|)
condition|)
continue|continue;
comment|/* Make sure the page is supported for this dev type */
if|if
condition|(
operator|(
name|control_dev
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|page_index
operator|->
name|page_flags
operator|&
name|CTL_PAGE_FLAG_DISK_ONLY
operator|)
condition|)
continue|continue;
comment|/* 			 * Call the handler, if it exists, to update the 			 * page to the latest values. 			 */
if|if
condition|(
name|page_index
operator|->
name|sense_handler
operator|!=
name|NULL
condition|)
name|page_index
operator|->
name|sense_handler
argument_list|(
name|ctsio
argument_list|,
name|page_index
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
operator|+
name|data_used
argument_list|,
name|page_index
operator|->
name|page_data
operator|+
operator|(
name|page_index
operator|->
name|page_len
operator|*
name|pc
operator|)
argument_list|,
name|page_index
operator|->
name|page_len
argument_list|)
expr_stmt|;
name|data_used
operator|+=
name|page_index
operator|->
name|page_len
expr_stmt|;
block|}
break|break;
block|}
block|}
name|ctsio
operator|->
name|scsi_status
operator|=
name|SCSI_STATUS_OK
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_read_capacity
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|scsi_read_capacity
modifier|*
name|cdb
decl_stmt|;
name|struct
name|scsi_read_capacity_data
modifier|*
name|data
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|uint32_t
name|lba
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_read_capacity\n"
operator|)
argument_list|)
expr_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_read_capacity
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|lba
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|cdb
operator|->
name|pmi
operator|&
name|SRC_PMI
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|lba
operator|!=
literal|0
operator|)
condition|)
block|{
name|ctl_set_invalid_field
argument_list|(
comment|/*ctsio*/
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|2
argument_list|,
comment|/*bit_valid*/
literal|0
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LUN
index|]
operator|.
name|ptr
expr_stmt|;
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
expr|struct
name|scsi_read_capacity_data
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|ctsio
operator|->
name|residual
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_data_resid
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If the maximum LBA is greater than 0xfffffffe, the user must 	 * issue a SERVICE ACTION IN (16) command, with the read capacity 	 * serivce action set. 	 */
if|if
condition|(
name|lun
operator|->
name|be_lun
operator|->
name|maxlba
operator|>
literal|0xfffffffe
condition|)
name|scsi_ulto4b
argument_list|(
literal|0xffffffff
argument_list|,
name|data
operator|->
name|addr
argument_list|)
expr_stmt|;
else|else
name|scsi_ulto4b
argument_list|(
name|lun
operator|->
name|be_lun
operator|->
name|maxlba
argument_list|,
name|data
operator|->
name|addr
argument_list|)
expr_stmt|;
comment|/* 	 * XXX KDM this may not be 512 bytes... 	 */
name|scsi_ulto4b
argument_list|(
name|lun
operator|->
name|be_lun
operator|->
name|blocksize
argument_list|,
name|data
operator|->
name|length
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|scsi_status
operator|=
name|SCSI_STATUS_OK
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_read_capacity_16
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|scsi_read_capacity_16
modifier|*
name|cdb
decl_stmt|;
name|struct
name|scsi_read_capacity_data_long
modifier|*
name|data
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|uint64_t
name|lba
decl_stmt|;
name|uint32_t
name|alloc_len
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_read_capacity_16\n"
operator|)
argument_list|)
expr_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_read_capacity_16
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|alloc_len
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|alloc_len
argument_list|)
expr_stmt|;
name|lba
operator|=
name|scsi_8btou64
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cdb
operator|->
name|reladr
operator|&
name|SRC16_PMI
operator|)
operator|&&
operator|(
name|lba
operator|!=
literal|0
operator|)
condition|)
block|{
name|ctl_set_invalid_field
argument_list|(
comment|/*ctsio*/
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|2
argument_list|,
comment|/*bit_valid*/
literal|0
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LUN
index|]
operator|.
name|ptr
expr_stmt|;
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
expr|struct
name|scsi_read_capacity_data_long
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
operator|<
name|alloc_len
condition|)
block|{
name|ctsio
operator|->
name|residual
operator|=
name|alloc_len
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctsio
operator|->
name|residual
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|alloc_len
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|alloc_len
expr_stmt|;
block|}
name|ctsio
operator|->
name|kern_data_resid
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
name|scsi_u64to8b
argument_list|(
name|lun
operator|->
name|be_lun
operator|->
name|maxlba
argument_list|,
name|data
operator|->
name|addr
argument_list|)
expr_stmt|;
comment|/* XXX KDM this may not be 512 bytes... */
name|scsi_ulto4b
argument_list|(
name|lun
operator|->
name|be_lun
operator|->
name|blocksize
argument_list|,
name|data
operator|->
name|length
argument_list|)
expr_stmt|;
name|data
operator|->
name|prot_lbppbe
operator|=
name|lun
operator|->
name|be_lun
operator|->
name|pblockexp
operator|&
name|SRC16_LBPPBE
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|lun
operator|->
name|be_lun
operator|->
name|pblockoff
operator|&
name|SRC16_LALBA_A
argument_list|,
name|data
operator|->
name|lalba_lbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|be_lun
operator|->
name|flags
operator|&
name|CTL_LUN_FLAG_UNMAP
condition|)
name|data
operator|->
name|lalba_lbp
index|[
literal|0
index|]
operator||=
name|SRC16_LBPME
operator||
name|SRC16_LBPRZ
expr_stmt|;
name|ctsio
operator|->
name|scsi_status
operator|=
name|SCSI_STATUS_OK
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_report_tagret_port_groups
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|scsi_maintenance_in
modifier|*
name|cdb
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|int
name|alloc_len
decl_stmt|,
name|ext
decl_stmt|,
name|total_len
init|=
literal|0
decl_stmt|,
name|g
decl_stmt|,
name|p
decl_stmt|,
name|pc
decl_stmt|,
name|pg
decl_stmt|;
name|int
name|num_target_port_groups
decl_stmt|,
name|num_target_ports
decl_stmt|,
name|single
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|struct
name|ctl_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|ctl_port
modifier|*
name|port
decl_stmt|;
name|struct
name|scsi_target_group_data
modifier|*
name|rtg_ptr
decl_stmt|;
name|struct
name|scsi_target_group_data_extended
modifier|*
name|rtg_ext_ptr
decl_stmt|;
name|struct
name|scsi_target_port_group_descriptor
modifier|*
name|tpg_desc
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_report_tagret_port_groups\n"
operator|)
argument_list|)
expr_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_maintenance_in
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|softc
operator|=
name|control_softc
expr_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LUN
index|]
operator|.
name|ptr
expr_stmt|;
name|retval
operator|=
name|CTL_RETVAL_COMPLETE
expr_stmt|;
switch|switch
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|STG_PDF_MASK
condition|)
block|{
case|case
name|STG_PDF_LENGTH
case|:
name|ext
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|STG_PDF_EXTENDED
case|:
name|ext
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|ctl_set_invalid_field
argument_list|(
comment|/*ctsio*/
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|2
argument_list|,
comment|/*bit_valid*/
literal|1
argument_list|,
comment|/*bit*/
literal|5
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
name|single
operator|=
name|ctl_is_single
expr_stmt|;
if|if
condition|(
name|single
condition|)
name|num_target_port_groups
operator|=
literal|1
expr_stmt|;
else|else
name|num_target_port_groups
operator|=
name|NUM_TARGET_PORT_GROUPS
expr_stmt|;
name|num_target_ports
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|port
argument_list|,
argument|&softc->port_list
argument_list|,
argument|links
argument_list|)
block|{
if|if
condition|(
operator|(
name|port
operator|->
name|status
operator|&
name|CTL_PORT_STATUS_ONLINE
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|ctl_map_lun_back
argument_list|(
name|port
operator|->
name|targ_port
argument_list|,
name|lun
operator|->
name|lun
argument_list|)
operator|>=
name|CTL_MAX_LUNS
condition|)
continue|continue;
name|num_target_ports
operator|++
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext
condition|)
name|total_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_target_group_data_extended
argument_list|)
expr_stmt|;
else|else
name|total_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_target_group_data
argument_list|)
expr_stmt|;
name|total_len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_target_port_group_descriptor
argument_list|)
operator|*
name|num_target_port_groups
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_target_port_descriptor
argument_list|)
operator|*
name|num_target_ports
operator|*
name|num_target_port_groups
expr_stmt|;
name|alloc_len
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
name|total_len
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|total_len
operator|<
name|alloc_len
condition|)
block|{
name|ctsio
operator|->
name|residual
operator|=
name|alloc_len
operator|-
name|total_len
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|total_len
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|total_len
expr_stmt|;
block|}
else|else
block|{
name|ctsio
operator|->
name|residual
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|alloc_len
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|alloc_len
expr_stmt|;
block|}
name|ctsio
operator|->
name|kern_data_resid
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ext
condition|)
block|{
name|rtg_ext_ptr
operator|=
operator|(
expr|struct
name|scsi_target_group_data_extended
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|total_len
operator|-
literal|4
argument_list|,
name|rtg_ext_ptr
operator|->
name|length
argument_list|)
expr_stmt|;
name|rtg_ext_ptr
operator|->
name|format_type
operator|=
literal|0x10
expr_stmt|;
name|rtg_ext_ptr
operator|->
name|implicit_transition_time
operator|=
literal|0
expr_stmt|;
name|tpg_desc
operator|=
operator|&
name|rtg_ext_ptr
operator|->
name|groups
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|rtg_ptr
operator|=
operator|(
expr|struct
name|scsi_target_group_data
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|total_len
operator|-
literal|4
argument_list|,
name|rtg_ptr
operator|->
name|length
argument_list|)
expr_stmt|;
name|tpg_desc
operator|=
operator|&
name|rtg_ptr
operator|->
name|groups
index|[
literal|0
index|]
expr_stmt|;
block|}
name|pg
operator|=
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
operator|/
name|CTL_MAX_PORTS
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|g
operator|=
literal|0
init|;
name|g
operator|<
name|num_target_port_groups
condition|;
name|g
operator|++
control|)
block|{
if|if
condition|(
name|g
operator|==
name|pg
condition|)
name|tpg_desc
operator|->
name|pref_state
operator|=
name|TPG_PRIMARY
operator||
name|TPG_ASYMMETRIC_ACCESS_OPTIMIZED
expr_stmt|;
else|else
name|tpg_desc
operator|->
name|pref_state
operator|=
name|TPG_ASYMMETRIC_ACCESS_NONOPTIMIZED
expr_stmt|;
name|tpg_desc
operator|->
name|support
operator|=
name|TPG_AO_SUP
expr_stmt|;
if|if
condition|(
operator|!
name|single
condition|)
name|tpg_desc
operator|->
name|support
operator||=
name|TPG_AN_SUP
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|g
operator|+
literal|1
argument_list|,
name|tpg_desc
operator|->
name|target_port_group
argument_list|)
expr_stmt|;
name|tpg_desc
operator|->
name|status
operator|=
name|TPG_IMPLICIT
expr_stmt|;
name|pc
operator|=
literal|0
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|port
argument_list|,
argument|&softc->port_list
argument_list|,
argument|links
argument_list|)
block|{
if|if
condition|(
operator|(
name|port
operator|->
name|status
operator|&
name|CTL_PORT_STATUS_ONLINE
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|ctl_map_lun_back
argument_list|(
name|port
operator|->
name|targ_port
argument_list|,
name|lun
operator|->
name|lun
argument_list|)
operator|>=
name|CTL_MAX_LUNS
condition|)
continue|continue;
name|p
operator|=
name|port
operator|->
name|targ_port
operator|%
name|CTL_MAX_PORTS
operator|+
name|g
operator|*
name|CTL_MAX_PORTS
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|p
argument_list|,
name|tpg_desc
operator|->
name|descriptors
index|[
name|pc
index|]
operator|.
name|relative_target_port_identifier
argument_list|)
expr_stmt|;
name|pc
operator|++
expr_stmt|;
block|}
name|tpg_desc
operator|->
name|target_port_count
operator|=
name|pc
expr_stmt|;
name|tpg_desc
operator|=
operator|(
expr|struct
name|scsi_target_port_group_descriptor
operator|*
operator|)
operator|&
name|tpg_desc
operator|->
name|descriptors
index|[
name|pc
index|]
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"buf = %x %x %x %x %x %x %x %x\n"
operator|,
name|ctsio
operator|->
name|kern_data_ptr
index|[
literal|0
index|]
operator|,
name|ctsio
operator|->
name|kern_data_ptr
index|[
literal|1
index|]
operator|,
name|ctsio
operator|->
name|kern_data_ptr
index|[
literal|2
index|]
operator|,
name|ctsio
operator|->
name|kern_data_ptr
index|[
literal|3
index|]
operator|,
name|ctsio
operator|->
name|kern_data_ptr
index|[
literal|4
index|]
operator|,
name|ctsio
operator|->
name|kern_data_ptr
index|[
literal|5
index|]
operator|,
name|ctsio
operator|->
name|kern_data_ptr
index|[
literal|6
index|]
operator|,
name|ctsio
operator|->
name|kern_data_ptr
index|[
literal|7
index|]
operator|)
argument_list|)
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_report_supported_opcodes
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|struct
name|scsi_report_supported_opcodes
modifier|*
name|cdb
decl_stmt|;
specifier|const
name|struct
name|ctl_cmd_entry
modifier|*
name|entry
decl_stmt|,
modifier|*
name|sentry
decl_stmt|;
name|struct
name|scsi_report_supported_opcodes_all
modifier|*
name|all
decl_stmt|;
name|struct
name|scsi_report_supported_opcodes_descr
modifier|*
name|descr
decl_stmt|;
name|struct
name|scsi_report_supported_opcodes_one
modifier|*
name|one
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|int
name|alloc_len
decl_stmt|,
name|total_len
decl_stmt|;
name|int
name|opcode
decl_stmt|,
name|service_action
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|num
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_report_supported_opcodes\n"
operator|)
argument_list|)
expr_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_report_supported_opcodes
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LUN
index|]
operator|.
name|ptr
expr_stmt|;
name|retval
operator|=
name|CTL_RETVAL_COMPLETE
expr_stmt|;
name|opcode
operator|=
name|cdb
operator|->
name|requested_opcode
expr_stmt|;
name|service_action
operator|=
name|scsi_2btoul
argument_list|(
name|cdb
operator|->
name|requested_service_action
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cdb
operator|->
name|options
operator|&
name|RSO_OPTIONS_MASK
condition|)
block|{
case|case
name|RSO_OPTIONS_ALL
case|:
name|num
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|entry
operator|=
operator|&
name|ctl_cmd_table
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|flags
operator|&
name|CTL_CMD_FLAG_SA5
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|32
condition|;
name|j
operator|++
control|)
block|{
name|sentry
operator|=
operator|&
operator|(
operator|(
specifier|const
expr|struct
name|ctl_cmd_entry
operator|*
operator|)
name|entry
operator|->
name|execute
operator|)
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|ctl_cmd_applicable
argument_list|(
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
argument_list|,
name|sentry
argument_list|)
condition|)
name|num
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ctl_cmd_applicable
argument_list|(
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
argument_list|,
name|entry
argument_list|)
condition|)
name|num
operator|++
expr_stmt|;
block|}
block|}
name|total_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_report_supported_opcodes_all
argument_list|)
operator|+
name|num
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_report_supported_opcodes_descr
argument_list|)
expr_stmt|;
break|break;
case|case
name|RSO_OPTIONS_OC
case|:
if|if
condition|(
name|ctl_cmd_table
index|[
name|opcode
index|]
operator|.
name|flags
operator|&
name|CTL_CMD_FLAG_SA5
condition|)
block|{
name|ctl_set_invalid_field
argument_list|(
comment|/*ctsio*/
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|2
argument_list|,
comment|/*bit_valid*/
literal|1
argument_list|,
comment|/*bit*/
literal|2
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
name|total_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_report_supported_opcodes_one
argument_list|)
operator|+
literal|32
expr_stmt|;
break|break;
case|case
name|RSO_OPTIONS_OC_SA
case|:
if|if
condition|(
operator|(
name|ctl_cmd_table
index|[
name|opcode
index|]
operator|.
name|flags
operator|&
name|CTL_CMD_FLAG_SA5
operator|)
operator|==
literal|0
operator|||
name|service_action
operator|>=
literal|32
condition|)
block|{
name|ctl_set_invalid_field
argument_list|(
comment|/*ctsio*/
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|2
argument_list|,
comment|/*bit_valid*/
literal|1
argument_list|,
comment|/*bit*/
literal|2
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
name|total_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_report_supported_opcodes_one
argument_list|)
operator|+
literal|32
expr_stmt|;
break|break;
default|default:
name|ctl_set_invalid_field
argument_list|(
comment|/*ctsio*/
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|2
argument_list|,
comment|/*bit_valid*/
literal|1
argument_list|,
comment|/*bit*/
literal|2
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
name|alloc_len
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
name|total_len
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|total_len
operator|<
name|alloc_len
condition|)
block|{
name|ctsio
operator|->
name|residual
operator|=
name|alloc_len
operator|-
name|total_len
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|total_len
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|total_len
expr_stmt|;
block|}
else|else
block|{
name|ctsio
operator|->
name|residual
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|alloc_len
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|alloc_len
expr_stmt|;
block|}
name|ctsio
operator|->
name|kern_data_resid
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cdb
operator|->
name|options
operator|&
name|RSO_OPTIONS_MASK
condition|)
block|{
case|case
name|RSO_OPTIONS_ALL
case|:
name|all
operator|=
operator|(
expr|struct
name|scsi_report_supported_opcodes_all
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|num
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|entry
operator|=
operator|&
name|ctl_cmd_table
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|flags
operator|&
name|CTL_CMD_FLAG_SA5
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|32
condition|;
name|j
operator|++
control|)
block|{
name|sentry
operator|=
operator|&
operator|(
operator|(
specifier|const
expr|struct
name|ctl_cmd_entry
operator|*
operator|)
name|entry
operator|->
name|execute
operator|)
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|ctl_cmd_applicable
argument_list|(
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
argument_list|,
name|sentry
argument_list|)
condition|)
continue|continue;
name|descr
operator|=
operator|&
name|all
operator|->
name|descr
index|[
name|num
operator|++
index|]
expr_stmt|;
name|descr
operator|->
name|opcode
operator|=
name|i
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|j
argument_list|,
name|descr
operator|->
name|service_action
argument_list|)
expr_stmt|;
name|descr
operator|->
name|flags
operator|=
name|RSO_SERVACTV
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|sentry
operator|->
name|length
argument_list|,
name|descr
operator|->
name|cdb_length
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|ctl_cmd_applicable
argument_list|(
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
argument_list|,
name|entry
argument_list|)
condition|)
continue|continue;
name|descr
operator|=
operator|&
name|all
operator|->
name|descr
index|[
name|num
operator|++
index|]
expr_stmt|;
name|descr
operator|->
name|opcode
operator|=
name|i
expr_stmt|;
name|scsi_ulto2b
argument_list|(
literal|0
argument_list|,
name|descr
operator|->
name|service_action
argument_list|)
expr_stmt|;
name|descr
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|entry
operator|->
name|length
argument_list|,
name|descr
operator|->
name|cdb_length
argument_list|)
expr_stmt|;
block|}
block|}
name|scsi_ulto4b
argument_list|(
name|num
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_report_supported_opcodes_descr
argument_list|)
argument_list|,
name|all
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|RSO_OPTIONS_OC
case|:
name|one
operator|=
operator|(
expr|struct
name|scsi_report_supported_opcodes_one
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|entry
operator|=
operator|&
name|ctl_cmd_table
index|[
name|opcode
index|]
expr_stmt|;
goto|goto
name|fill_one
goto|;
case|case
name|RSO_OPTIONS_OC_SA
case|:
name|one
operator|=
operator|(
expr|struct
name|scsi_report_supported_opcodes_one
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|entry
operator|=
operator|&
name|ctl_cmd_table
index|[
name|opcode
index|]
expr_stmt|;
name|entry
operator|=
operator|&
operator|(
operator|(
specifier|const
expr|struct
name|ctl_cmd_entry
operator|*
operator|)
name|entry
operator|->
name|execute
operator|)
index|[
name|service_action
index|]
expr_stmt|;
name|fill_one
label|:
if|if
condition|(
name|ctl_cmd_applicable
argument_list|(
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
argument_list|,
name|entry
argument_list|)
condition|)
block|{
name|one
operator|->
name|support
operator|=
literal|3
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|entry
operator|->
name|length
argument_list|,
name|one
operator|->
name|cdb_length
argument_list|)
expr_stmt|;
name|one
operator|->
name|cdb_usage
index|[
literal|0
index|]
operator|=
name|opcode
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|one
operator|->
name|cdb_usage
index|[
literal|1
index|]
argument_list|,
name|entry
operator|->
name|usage
argument_list|,
name|entry
operator|->
name|length
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|one
operator|->
name|support
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_report_supported_tmf
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|struct
name|scsi_report_supported_tmf
modifier|*
name|cdb
decl_stmt|;
name|struct
name|scsi_report_supported_tmf_data
modifier|*
name|data
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|int
name|alloc_len
decl_stmt|,
name|total_len
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_report_supported_tmf\n"
operator|)
argument_list|)
expr_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_report_supported_tmf
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LUN
index|]
operator|.
name|ptr
expr_stmt|;
name|retval
operator|=
name|CTL_RETVAL_COMPLETE
expr_stmt|;
name|total_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_report_supported_tmf_data
argument_list|)
expr_stmt|;
name|alloc_len
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
name|total_len
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|total_len
operator|<
name|alloc_len
condition|)
block|{
name|ctsio
operator|->
name|residual
operator|=
name|alloc_len
operator|-
name|total_len
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|total_len
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|total_len
expr_stmt|;
block|}
else|else
block|{
name|ctsio
operator|->
name|residual
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|alloc_len
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|alloc_len
expr_stmt|;
block|}
name|ctsio
operator|->
name|kern_data_resid
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|data
operator|=
operator|(
expr|struct
name|scsi_report_supported_tmf_data
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|data
operator|->
name|byte1
operator||=
name|RST_ATS
operator||
name|RST_ATSS
operator||
name|RST_CTSS
operator||
name|RST_LURS
operator||
name|RST_TRS
expr_stmt|;
name|data
operator|->
name|byte2
operator||=
name|RST_ITNRS
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_report_timestamp
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|struct
name|scsi_report_timestamp
modifier|*
name|cdb
decl_stmt|;
name|struct
name|scsi_report_timestamp_data
modifier|*
name|data
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|int64_t
name|timestamp
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|int
name|alloc_len
decl_stmt|,
name|total_len
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_report_timestamp\n"
operator|)
argument_list|)
expr_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_report_timestamp
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LUN
index|]
operator|.
name|ptr
expr_stmt|;
name|retval
operator|=
name|CTL_RETVAL_COMPLETE
expr_stmt|;
name|total_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_report_timestamp_data
argument_list|)
expr_stmt|;
name|alloc_len
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
name|total_len
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|total_len
operator|<
name|alloc_len
condition|)
block|{
name|ctsio
operator|->
name|residual
operator|=
name|alloc_len
operator|-
name|total_len
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|total_len
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|total_len
expr_stmt|;
block|}
else|else
block|{
name|ctsio
operator|->
name|residual
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|alloc_len
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|alloc_len
expr_stmt|;
block|}
name|ctsio
operator|->
name|kern_data_resid
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|data
operator|=
operator|(
expr|struct
name|scsi_report_timestamp_data
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|scsi_ulto2b
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
operator|-
literal|2
argument_list|,
name|data
operator|->
name|length
argument_list|)
expr_stmt|;
name|data
operator|->
name|origin
operator|=
name|RTS_ORIG_OUTSIDE
expr_stmt|;
name|getmicrotime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|timestamp
operator|=
operator|(
name|int64_t
operator|)
name|tv
operator|.
name|tv_sec
operator|*
literal|1000
operator|+
name|tv
operator|.
name|tv_usec
operator|/
literal|1000
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|timestamp
operator|>>
literal|16
argument_list|,
name|data
operator|->
name|timestamp
argument_list|)
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|timestamp
operator|&
literal|0xffff
argument_list|,
operator|&
name|data
operator|->
name|timestamp
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_persistent_reserve_in
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|scsi_per_res_in
modifier|*
name|cdb
decl_stmt|;
name|int
name|alloc_len
decl_stmt|,
name|total_len
init|=
literal|0
decl_stmt|;
comment|/* struct scsi_per_res_in_rsrv in_data; */
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|struct
name|ctl_softc
modifier|*
name|softc
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_persistent_reserve_in\n"
operator|)
argument_list|)
expr_stmt|;
name|softc
operator|=
name|control_softc
expr_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_per_res_in
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|alloc_len
operator|=
name|scsi_2btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LUN
index|]
operator|.
name|ptr
expr_stmt|;
name|retry
label|:
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cdb
operator|->
name|action
condition|)
block|{
case|case
name|SPRI_RK
case|:
comment|/* read keys */
name|total_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_per_res_in_keys
argument_list|)
operator|+
name|lun
operator|->
name|pr_key_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_per_res_key
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPRI_RR
case|:
comment|/* read reservation */
if|if
condition|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_PR_RESERVED
condition|)
name|total_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_per_res_in_rsrv
argument_list|)
expr_stmt|;
else|else
name|total_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_per_res_in_header
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPRI_RC
case|:
comment|/* report capabilities */
name|total_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_per_res_cap
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPRI_RS
case|:
comment|/* read full status */
name|total_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_per_res_in_header
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_per_res_in_full_desc
argument_list|)
operator|+
literal|256
operator|)
operator|*
name|lun
operator|->
name|pr_key_count
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"Invalid PR type %x"
argument_list|,
name|cdb
operator|->
name|action
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
name|total_len
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|total_len
operator|<
name|alloc_len
condition|)
block|{
name|ctsio
operator|->
name|residual
operator|=
name|alloc_len
operator|-
name|total_len
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|total_len
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|total_len
expr_stmt|;
block|}
else|else
block|{
name|ctsio
operator|->
name|residual
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|alloc_len
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|alloc_len
expr_stmt|;
block|}
name|ctsio
operator|->
name|kern_data_resid
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cdb
operator|->
name|action
condition|)
block|{
case|case
name|SPRI_RK
case|:
block|{
comment|// read keys
name|struct
name|scsi_per_res_in_keys
modifier|*
name|res_keys
decl_stmt|;
name|int
name|i
decl_stmt|,
name|key_count
decl_stmt|;
name|res_keys
operator|=
operator|(
expr|struct
name|scsi_per_res_in_keys
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
comment|/* 		 * We had to drop the lock to allocate our buffer, which 		 * leaves time for someone to come in with another 		 * persistent reservation.  (That is unlikely, though, 		 * since this should be the only persistent reservation 		 * command active right now.) 		 */
if|if
condition|(
name|total_len
operator|!=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_per_res_in_keys
argument_list|)
operator|+
operator|(
name|lun
operator|->
name|pr_key_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_per_res_key
argument_list|)
operator|)
operator|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: reservation length changed, retrying\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|scsi_ulto4b
argument_list|(
name|lun
operator|->
name|PRGeneration
argument_list|,
name|res_keys
operator|->
name|header
operator|.
name|generation
argument_list|)
expr_stmt|;
name|scsi_ulto4b
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_per_res_key
argument_list|)
operator|*
name|lun
operator|->
name|pr_key_count
argument_list|,
name|res_keys
operator|->
name|header
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|key_count
operator|=
literal|0
init|;
name|i
operator|<
literal|2
operator|*
name|CTL_MAX_INITIATORS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|lun
operator|->
name|pr_keys
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
comment|/* 			 * We used lun->pr_key_count to calculate the 			 * size to allocate.  If it turns out the number of 			 * initiators with the registered flag set is 			 * larger than that (i.e. they haven't been kept in 			 * sync), we've got a problem. 			 */
if|if
condition|(
name|key_count
operator|>=
name|lun
operator|->
name|pr_key_count
condition|)
block|{
ifdef|#
directive|ifdef
name|NEEDTOPORT
name|csevent_log
argument_list|(
name|CSC_CTL
operator||
name|CSC_SHELF_SW
operator||
name|CTL_PR_ERROR
argument_list|,
name|csevent_LogType_Fault
argument_list|,
name|csevent_AlertLevel_Yellow
argument_list|,
name|csevent_FRU_ShelfController
argument_list|,
name|csevent_FRU_Firmware
argument_list|,
name|csevent_FRU_Unknown
argument_list|,
literal|"registered keys %d>= key "
literal|"count %d"
argument_list|,
name|key_count
argument_list|,
name|lun
operator|->
name|pr_key_count
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|key_count
operator|++
expr_stmt|;
continue|continue;
block|}
name|scsi_u64to8b
argument_list|(
name|lun
operator|->
name|pr_keys
index|[
name|i
index|]
argument_list|,
name|res_keys
operator|->
name|keys
index|[
name|key_count
index|]
operator|.
name|key
argument_list|)
expr_stmt|;
name|key_count
operator|++
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SPRI_RR
case|:
block|{
comment|// read reservation
name|struct
name|scsi_per_res_in_rsrv
modifier|*
name|res
decl_stmt|;
name|int
name|tmp_len
decl_stmt|,
name|header_only
decl_stmt|;
name|res
operator|=
operator|(
expr|struct
name|scsi_per_res_in_rsrv
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|lun
operator|->
name|PRGeneration
argument_list|,
name|res
operator|->
name|header
operator|.
name|generation
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_PR_RESERVED
condition|)
block|{
name|tmp_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_per_res_in_rsrv
argument_list|)
expr_stmt|;
name|scsi_ulto4b
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_per_res_in_rsrv_data
argument_list|)
argument_list|,
name|res
operator|->
name|header
operator|.
name|length
argument_list|)
expr_stmt|;
name|header_only
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|tmp_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_per_res_in_header
argument_list|)
expr_stmt|;
name|scsi_ulto4b
argument_list|(
literal|0
argument_list|,
name|res
operator|->
name|header
operator|.
name|length
argument_list|)
expr_stmt|;
name|header_only
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 		 * We had to drop the lock to allocate our buffer, which 		 * leaves time for someone to come in with another 		 * persistent reservation.  (That is unlikely, though, 		 * since this should be the only persistent reservation 		 * command active right now.) 		 */
if|if
condition|(
name|tmp_len
operator|!=
name|total_len
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: reservation status changed, retrying\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
comment|/* 		 * No reservation held, so we're done. 		 */
if|if
condition|(
name|header_only
operator|!=
literal|0
condition|)
break|break;
comment|/* 		 * If the registration is an All Registrants type, the key 		 * is 0, since it doesn't really matter. 		 */
if|if
condition|(
name|lun
operator|->
name|pr_res_idx
operator|!=
name|CTL_PR_ALL_REGISTRANTS
condition|)
block|{
name|scsi_u64to8b
argument_list|(
name|lun
operator|->
name|pr_keys
index|[
name|lun
operator|->
name|pr_res_idx
index|]
argument_list|,
name|res
operator|->
name|data
operator|.
name|reservation
argument_list|)
expr_stmt|;
block|}
name|res
operator|->
name|data
operator|.
name|scopetype
operator|=
name|lun
operator|->
name|res_type
expr_stmt|;
break|break;
block|}
case|case
name|SPRI_RC
case|:
comment|//report capabilities
block|{
name|struct
name|scsi_per_res_cap
modifier|*
name|res_cap
decl_stmt|;
name|uint16_t
name|type_mask
decl_stmt|;
name|res_cap
operator|=
operator|(
expr|struct
name|scsi_per_res_cap
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|scsi_ulto2b
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|res_cap
argument_list|)
argument_list|,
name|res_cap
operator|->
name|length
argument_list|)
expr_stmt|;
name|res_cap
operator|->
name|flags2
operator||=
name|SPRI_TMV
operator||
name|SPRI_ALLOW_5
expr_stmt|;
name|type_mask
operator|=
name|SPRI_TM_WR_EX_AR
operator||
name|SPRI_TM_EX_AC_RO
operator||
name|SPRI_TM_WR_EX_RO
operator||
name|SPRI_TM_EX_AC
operator||
name|SPRI_TM_WR_EX
operator||
name|SPRI_TM_EX_AC_AR
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|type_mask
argument_list|,
name|res_cap
operator|->
name|type_mask
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SPRI_RS
case|:
block|{
comment|// read full status
name|struct
name|scsi_per_res_in_full
modifier|*
name|res_status
decl_stmt|;
name|struct
name|scsi_per_res_in_full_desc
modifier|*
name|res_desc
decl_stmt|;
name|struct
name|ctl_port
modifier|*
name|port
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|res_status
operator|=
operator|(
expr|struct
name|scsi_per_res_in_full
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
comment|/* 		 * We had to drop the lock to allocate our buffer, which 		 * leaves time for someone to come in with another 		 * persistent reservation.  (That is unlikely, though, 		 * since this should be the only persistent reservation 		 * command active right now.) 		 */
if|if
condition|(
name|total_len
operator|<
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_per_res_in_header
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_per_res_in_full_desc
argument_list|)
operator|+
literal|256
operator|)
operator|*
name|lun
operator|->
name|pr_key_count
operator|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: reservation length changed, retrying\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|scsi_ulto4b
argument_list|(
name|lun
operator|->
name|PRGeneration
argument_list|,
name|res_status
operator|->
name|header
operator|.
name|generation
argument_list|)
expr_stmt|;
name|res_desc
operator|=
operator|&
name|res_status
operator|->
name|desc
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
operator|*
name|CTL_MAX_INITIATORS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|lun
operator|->
name|pr_keys
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
name|scsi_u64to8b
argument_list|(
name|lun
operator|->
name|pr_keys
index|[
name|i
index|]
argument_list|,
name|res_desc
operator|->
name|res_key
operator|.
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_PR_RESERVED
operator|)
operator|&&
operator|(
name|lun
operator|->
name|pr_res_idx
operator|==
name|i
operator|||
name|lun
operator|->
name|pr_res_idx
operator|==
name|CTL_PR_ALL_REGISTRANTS
operator|)
condition|)
block|{
name|res_desc
operator|->
name|flags
operator|=
name|SPRI_FULL_R_HOLDER
expr_stmt|;
name|res_desc
operator|->
name|scopetype
operator|=
name|lun
operator|->
name|res_type
expr_stmt|;
block|}
name|scsi_ulto2b
argument_list|(
name|i
operator|/
name|CTL_MAX_INIT_PER_PORT
argument_list|,
name|res_desc
operator|->
name|rel_trgt_port_id
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|port
operator|=
name|softc
operator|->
name|ctl_ports
index|[
name|ctl_port_idx
argument_list|(
name|i
operator|/
name|CTL_MAX_INIT_PER_PORT
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|port
operator|!=
name|NULL
condition|)
name|len
operator|=
name|ctl_create_iid
argument_list|(
name|port
argument_list|,
name|i
operator|%
name|CTL_MAX_INIT_PER_PORT
argument_list|,
name|res_desc
operator|->
name|transport_id
argument_list|)
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|len
argument_list|,
name|res_desc
operator|->
name|additional_length
argument_list|)
expr_stmt|;
name|res_desc
operator|=
operator|(
expr|struct
name|scsi_per_res_in_full_desc
operator|*
operator|)
operator|&
name|res_desc
operator|->
name|transport_id
index|[
name|len
index|]
expr_stmt|;
block|}
name|scsi_ulto4b
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|res_desc
operator|-
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|res_status
operator|->
name|desc
index|[
literal|0
index|]
argument_list|,
name|res_status
operator|->
name|header
operator|.
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
comment|/* 		 * This is a bug, because we just checked for this above, 		 * and should have returned an error. 		 */
name|panic
argument_list|(
literal|"Invalid PR type %x"
argument_list|,
name|cdb
operator|->
name|action
argument_list|)
expr_stmt|;
break|break;
comment|/* NOTREACHED */
block|}
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"buf = %x %x %x %x %x %x %x %x\n"
operator|,
name|ctsio
operator|->
name|kern_data_ptr
index|[
literal|0
index|]
operator|,
name|ctsio
operator|->
name|kern_data_ptr
index|[
literal|1
index|]
operator|,
name|ctsio
operator|->
name|kern_data_ptr
index|[
literal|2
index|]
operator|,
name|ctsio
operator|->
name|kern_data_ptr
index|[
literal|3
index|]
operator|,
name|ctsio
operator|->
name|kern_data_ptr
index|[
literal|4
index|]
operator|,
name|ctsio
operator|->
name|kern_data_ptr
index|[
literal|5
index|]
operator|,
name|ctsio
operator|->
name|kern_data_ptr
index|[
literal|6
index|]
operator|,
name|ctsio
operator|->
name|kern_data_ptr
index|[
literal|7
index|]
operator|)
argument_list|)
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns 0 if ctl_persistent_reserve_out() should continue, non-zero if  * it should return.  */
end_comment

begin_function
specifier|static
name|int
name|ctl_pro_preempt
parameter_list|(
name|struct
name|ctl_softc
modifier|*
name|softc
parameter_list|,
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|,
name|uint64_t
name|res_key
parameter_list|,
name|uint64_t
name|sa_res_key
parameter_list|,
name|uint8_t
name|type
parameter_list|,
name|uint32_t
name|residx
parameter_list|,
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|struct
name|scsi_per_res_out
modifier|*
name|cdb
parameter_list|,
name|struct
name|scsi_per_res_out_parms
modifier|*
name|param
parameter_list|)
block|{
name|union
name|ctl_ha_msg
name|persis_io
decl_stmt|;
name|int
name|retval
decl_stmt|,
name|i
decl_stmt|;
name|int
name|isc_retval
decl_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa_res_key
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|lun
operator|->
name|pr_res_idx
operator|==
name|CTL_PR_ALL_REGISTRANTS
condition|)
block|{
comment|/* validate scope and type */
if|if
condition|(
operator|(
name|cdb
operator|->
name|scope_type
operator|&
name|SPR_SCOPE_MASK
operator|)
operator|!=
name|SPR_LU_SCOPE
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctl_set_invalid_field
argument_list|(
comment|/*ctsio*/
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|2
argument_list|,
comment|/*bit_valid*/
literal|1
argument_list|,
comment|/*bit*/
literal|4
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|type
operator|>
literal|8
operator|||
name|type
operator|==
literal|2
operator|||
name|type
operator|==
literal|4
operator|||
name|type
operator|==
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctl_set_invalid_field
argument_list|(
comment|/*ctsio*/
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|2
argument_list|,
comment|/*bit_valid*/
literal|1
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 			 * Unregister everybody else and build UA for 			 * them 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
operator|*
name|CTL_MAX_INITIATORS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|residx
operator|||
name|lun
operator|->
name|pr_keys
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|!
name|persis_offset
operator|&&
name|i
operator|<
name|CTL_MAX_INITIATORS
condition|)
name|lun
operator|->
name|pending_ua
index|[
name|i
index|]
operator||=
name|CTL_UA_REG_PREEMPT
expr_stmt|;
elseif|else
if|if
condition|(
name|persis_offset
operator|&&
name|i
operator|>=
name|persis_offset
condition|)
name|lun
operator|->
name|pending_ua
index|[
name|i
operator|-
name|persis_offset
index|]
operator||=
name|CTL_UA_REG_PREEMPT
expr_stmt|;
name|lun
operator|->
name|pr_keys
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|lun
operator|->
name|pr_key_count
operator|=
literal|1
expr_stmt|;
name|lun
operator|->
name|res_type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|res_type
operator|!=
name|SPR_TYPE_WR_EX_AR
operator|&&
name|lun
operator|->
name|res_type
operator|!=
name|SPR_TYPE_EX_AC_AR
condition|)
name|lun
operator|->
name|pr_res_idx
operator|=
name|residx
expr_stmt|;
comment|/* send msg to other side */
name|persis_io
operator|.
name|hdr
operator|.
name|nexus
operator|=
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
expr_stmt|;
name|persis_io
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_PERS_ACTION
expr_stmt|;
name|persis_io
operator|.
name|pr
operator|.
name|pr_info
operator|.
name|action
operator|=
name|CTL_PR_PREEMPT
expr_stmt|;
name|persis_io
operator|.
name|pr
operator|.
name|pr_info
operator|.
name|residx
operator|=
name|lun
operator|->
name|pr_res_idx
expr_stmt|;
name|persis_io
operator|.
name|pr
operator|.
name|pr_info
operator|.
name|res_type
operator|=
name|type
expr_stmt|;
name|memcpy
argument_list|(
name|persis_io
operator|.
name|pr
operator|.
name|pr_info
operator|.
name|sa_res_key
argument_list|,
name|param
operator|->
name|serv_act_res_key
argument_list|,
sizeof|sizeof
argument_list|(
name|param
operator|->
name|serv_act_res_key
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|isc_retval
operator|=
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|persis_io
argument_list|,
sizeof|sizeof
argument_list|(
name|persis_io
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|>
name|CTL_HA_STATUS_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"CTL:Persis Out error returned "
literal|"from ctl_ha_msg_send %d\n"
argument_list|,
name|isc_retval
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* not all registrants */
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|ctl_set_invalid_field
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|0
argument_list|,
comment|/*field*/
literal|8
argument_list|,
comment|/*bit_valid*/
literal|0
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|lun
operator|->
name|pr_res_idx
operator|==
name|CTL_PR_ALL_REGISTRANTS
operator|||
operator|!
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_PR_RESERVED
operator|)
condition|)
block|{
name|int
name|found
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|res_key
operator|==
name|sa_res_key
condition|)
block|{
comment|/* special case */
comment|/* 			 * The spec implies this is not good but doesn't 			 * say what to do. There are two choices either 			 * generate a res conflict or check condition 			 * with illegal field in parameter data. Since 			 * that is what is done when the sa_res_key is 			 * zero I'll take that approach since this has 			 * to do with the sa_res_key. 			 */
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|ctl_set_invalid_field
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|0
argument_list|,
comment|/*field*/
literal|8
argument_list|,
comment|/*bit_valid*/
literal|0
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
operator|*
name|CTL_MAX_INITIATORS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|lun
operator|->
name|pr_keys
index|[
name|i
index|]
operator|!=
name|sa_res_key
condition|)
continue|continue;
name|found
operator|=
literal|1
expr_stmt|;
name|lun
operator|->
name|pr_keys
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|lun
operator|->
name|pr_key_count
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|persis_offset
operator|&&
name|i
operator|<
name|CTL_MAX_INITIATORS
condition|)
name|lun
operator|->
name|pending_ua
index|[
name|i
index|]
operator||=
name|CTL_UA_REG_PREEMPT
expr_stmt|;
elseif|else
if|if
condition|(
name|persis_offset
operator|&&
name|i
operator|>=
name|persis_offset
condition|)
name|lun
operator|->
name|pending_ua
index|[
name|i
operator|-
name|persis_offset
index|]
operator||=
name|CTL_UA_REG_PREEMPT
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|ctl_set_reservation_conflict
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
comment|/* send msg to other side */
name|persis_io
operator|.
name|hdr
operator|.
name|nexus
operator|=
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
expr_stmt|;
name|persis_io
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_PERS_ACTION
expr_stmt|;
name|persis_io
operator|.
name|pr
operator|.
name|pr_info
operator|.
name|action
operator|=
name|CTL_PR_PREEMPT
expr_stmt|;
name|persis_io
operator|.
name|pr
operator|.
name|pr_info
operator|.
name|residx
operator|=
name|lun
operator|->
name|pr_res_idx
expr_stmt|;
name|persis_io
operator|.
name|pr
operator|.
name|pr_info
operator|.
name|res_type
operator|=
name|type
expr_stmt|;
name|memcpy
argument_list|(
name|persis_io
operator|.
name|pr
operator|.
name|pr_info
operator|.
name|sa_res_key
argument_list|,
name|param
operator|->
name|serv_act_res_key
argument_list|,
sizeof|sizeof
argument_list|(
name|param
operator|->
name|serv_act_res_key
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|isc_retval
operator|=
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|persis_io
argument_list|,
sizeof|sizeof
argument_list|(
name|persis_io
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|>
name|CTL_HA_STATUS_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"CTL:Persis Out error returned from "
literal|"ctl_ha_msg_send %d\n"
argument_list|,
name|isc_retval
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Reserved but not all registrants */
comment|/* sa_res_key is res holder */
if|if
condition|(
name|sa_res_key
operator|==
name|lun
operator|->
name|pr_keys
index|[
name|lun
operator|->
name|pr_res_idx
index|]
condition|)
block|{
comment|/* validate scope and type */
if|if
condition|(
operator|(
name|cdb
operator|->
name|scope_type
operator|&
name|SPR_SCOPE_MASK
operator|)
operator|!=
name|SPR_LU_SCOPE
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctl_set_invalid_field
argument_list|(
comment|/*ctsio*/
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|2
argument_list|,
comment|/*bit_valid*/
literal|1
argument_list|,
comment|/*bit*/
literal|4
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|type
operator|>
literal|8
operator|||
name|type
operator|==
literal|2
operator|||
name|type
operator|==
literal|4
operator|||
name|type
operator|==
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctl_set_invalid_field
argument_list|(
comment|/*ctsio*/
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|2
argument_list|,
comment|/*bit_valid*/
literal|1
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 			 * Do the following: 			 * if sa_res_key != res_key remove all 			 * registrants w/sa_res_key and generate UA 			 * for these registrants(Registrations 			 * Preempted) if it wasn't an exclusive 			 * reservation generate UA(Reservations 			 * Preempted) for all other registered nexuses 			 * if the type has changed. Establish the new 			 * reservation and holder. If res_key and 			 * sa_res_key are the same do the above 			 * except don't unregister the res holder. 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
operator|*
name|CTL_MAX_INITIATORS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|residx
operator|||
name|lun
operator|->
name|pr_keys
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|sa_res_key
operator|==
name|lun
operator|->
name|pr_keys
index|[
name|i
index|]
condition|)
block|{
name|lun
operator|->
name|pr_keys
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|lun
operator|->
name|pr_key_count
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|persis_offset
operator|&&
name|i
operator|<
name|CTL_MAX_INITIATORS
condition|)
name|lun
operator|->
name|pending_ua
index|[
name|i
index|]
operator||=
name|CTL_UA_REG_PREEMPT
expr_stmt|;
elseif|else
if|if
condition|(
name|persis_offset
operator|&&
name|i
operator|>=
name|persis_offset
condition|)
name|lun
operator|->
name|pending_ua
index|[
name|i
operator|-
name|persis_offset
index|]
operator||=
name|CTL_UA_REG_PREEMPT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|!=
name|lun
operator|->
name|res_type
operator|&&
operator|(
name|lun
operator|->
name|res_type
operator|==
name|SPR_TYPE_WR_EX_RO
operator|||
name|lun
operator|->
name|res_type
operator|==
name|SPR_TYPE_EX_AC_RO
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|persis_offset
operator|&&
name|i
operator|<
name|CTL_MAX_INITIATORS
condition|)
name|lun
operator|->
name|pending_ua
index|[
name|i
index|]
operator||=
name|CTL_UA_RES_RELEASE
expr_stmt|;
elseif|else
if|if
condition|(
name|persis_offset
operator|&&
name|i
operator|>=
name|persis_offset
condition|)
name|lun
operator|->
name|pending_ua
index|[
name|i
operator|-
name|persis_offset
index|]
operator||=
name|CTL_UA_RES_RELEASE
expr_stmt|;
block|}
block|}
name|lun
operator|->
name|res_type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|res_type
operator|!=
name|SPR_TYPE_WR_EX_AR
operator|&&
name|lun
operator|->
name|res_type
operator|!=
name|SPR_TYPE_EX_AC_AR
condition|)
name|lun
operator|->
name|pr_res_idx
operator|=
name|residx
expr_stmt|;
else|else
name|lun
operator|->
name|pr_res_idx
operator|=
name|CTL_PR_ALL_REGISTRANTS
expr_stmt|;
name|persis_io
operator|.
name|hdr
operator|.
name|nexus
operator|=
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
expr_stmt|;
name|persis_io
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_PERS_ACTION
expr_stmt|;
name|persis_io
operator|.
name|pr
operator|.
name|pr_info
operator|.
name|action
operator|=
name|CTL_PR_PREEMPT
expr_stmt|;
name|persis_io
operator|.
name|pr
operator|.
name|pr_info
operator|.
name|residx
operator|=
name|lun
operator|->
name|pr_res_idx
expr_stmt|;
name|persis_io
operator|.
name|pr
operator|.
name|pr_info
operator|.
name|res_type
operator|=
name|type
expr_stmt|;
name|memcpy
argument_list|(
name|persis_io
operator|.
name|pr
operator|.
name|pr_info
operator|.
name|sa_res_key
argument_list|,
name|param
operator|->
name|serv_act_res_key
argument_list|,
sizeof|sizeof
argument_list|(
name|param
operator|->
name|serv_act_res_key
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|isc_retval
operator|=
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|persis_io
argument_list|,
sizeof|sizeof
argument_list|(
name|persis_io
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|>
name|CTL_HA_STATUS_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"CTL:Persis Out error returned "
literal|"from ctl_ha_msg_send %d\n"
argument_list|,
name|isc_retval
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * sa_res_key is not the res holder just 			 * remove registrants 			 */
name|int
name|found
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
operator|*
name|CTL_MAX_INITIATORS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sa_res_key
operator|!=
name|lun
operator|->
name|pr_keys
index|[
name|i
index|]
condition|)
continue|continue;
name|found
operator|=
literal|1
expr_stmt|;
name|lun
operator|->
name|pr_keys
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|lun
operator|->
name|pr_key_count
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|persis_offset
operator|&&
name|i
operator|<
name|CTL_MAX_INITIATORS
condition|)
name|lun
operator|->
name|pending_ua
index|[
name|i
index|]
operator||=
name|CTL_UA_REG_PREEMPT
expr_stmt|;
elseif|else
if|if
condition|(
name|persis_offset
operator|&&
name|i
operator|>=
name|persis_offset
condition|)
name|lun
operator|->
name|pending_ua
index|[
name|i
operator|-
name|persis_offset
index|]
operator||=
name|CTL_UA_REG_PREEMPT
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|ctl_set_reservation_conflict
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|persis_io
operator|.
name|hdr
operator|.
name|nexus
operator|=
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
expr_stmt|;
name|persis_io
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_PERS_ACTION
expr_stmt|;
name|persis_io
operator|.
name|pr
operator|.
name|pr_info
operator|.
name|action
operator|=
name|CTL_PR_PREEMPT
expr_stmt|;
name|persis_io
operator|.
name|pr
operator|.
name|pr_info
operator|.
name|residx
operator|=
name|lun
operator|->
name|pr_res_idx
expr_stmt|;
name|persis_io
operator|.
name|pr
operator|.
name|pr_info
operator|.
name|res_type
operator|=
name|type
expr_stmt|;
name|memcpy
argument_list|(
name|persis_io
operator|.
name|pr
operator|.
name|pr_info
operator|.
name|sa_res_key
argument_list|,
name|param
operator|->
name|serv_act_res_key
argument_list|,
sizeof|sizeof
argument_list|(
name|param
operator|->
name|serv_act_res_key
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|isc_retval
operator|=
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|persis_io
argument_list|,
sizeof|sizeof
argument_list|(
name|persis_io
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|>
name|CTL_HA_STATUS_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"CTL:Persis Out error returned "
literal|"from ctl_ha_msg_send %d\n"
argument_list|,
name|isc_retval
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|lun
operator|->
name|PRGeneration
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_pro_preempt_other
parameter_list|(
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|,
name|union
name|ctl_ha_msg
modifier|*
name|msg
parameter_list|)
block|{
name|uint64_t
name|sa_res_key
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sa_res_key
operator|=
name|scsi_8btou64
argument_list|(
name|msg
operator|->
name|pr
operator|.
name|pr_info
operator|.
name|sa_res_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|pr_res_idx
operator|==
name|CTL_PR_ALL_REGISTRANTS
operator|||
name|lun
operator|->
name|pr_res_idx
operator|==
name|CTL_PR_NO_RESERVATION
operator|||
name|sa_res_key
operator|!=
name|lun
operator|->
name|pr_keys
index|[
name|lun
operator|->
name|pr_res_idx
index|]
condition|)
block|{
if|if
condition|(
name|sa_res_key
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Unregister everybody else and build UA for 			 * them 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
operator|*
name|CTL_MAX_INITIATORS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|msg
operator|->
name|pr
operator|.
name|pr_info
operator|.
name|residx
operator|||
name|lun
operator|->
name|pr_keys
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|!
name|persis_offset
operator|&&
name|i
operator|<
name|CTL_MAX_INITIATORS
condition|)
name|lun
operator|->
name|pending_ua
index|[
name|i
index|]
operator||=
name|CTL_UA_REG_PREEMPT
expr_stmt|;
elseif|else
if|if
condition|(
name|persis_offset
operator|&&
name|i
operator|>=
name|persis_offset
condition|)
name|lun
operator|->
name|pending_ua
index|[
name|i
operator|-
name|persis_offset
index|]
operator||=
name|CTL_UA_REG_PREEMPT
expr_stmt|;
name|lun
operator|->
name|pr_keys
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|lun
operator|->
name|pr_key_count
operator|=
literal|1
expr_stmt|;
name|lun
operator|->
name|res_type
operator|=
name|msg
operator|->
name|pr
operator|.
name|pr_info
operator|.
name|res_type
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|res_type
operator|!=
name|SPR_TYPE_WR_EX_AR
operator|&&
name|lun
operator|->
name|res_type
operator|!=
name|SPR_TYPE_EX_AC_AR
condition|)
name|lun
operator|->
name|pr_res_idx
operator|=
name|msg
operator|->
name|pr
operator|.
name|pr_info
operator|.
name|residx
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
operator|*
name|CTL_MAX_INITIATORS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sa_res_key
operator|==
name|lun
operator|->
name|pr_keys
index|[
name|i
index|]
condition|)
continue|continue;
name|lun
operator|->
name|pr_keys
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|lun
operator|->
name|pr_key_count
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|persis_offset
operator|&&
name|i
operator|<
name|persis_offset
condition|)
name|lun
operator|->
name|pending_ua
index|[
name|i
index|]
operator||=
name|CTL_UA_REG_PREEMPT
expr_stmt|;
elseif|else
if|if
condition|(
name|persis_offset
operator|&&
name|i
operator|>=
name|persis_offset
condition|)
name|lun
operator|->
name|pending_ua
index|[
name|i
operator|-
name|persis_offset
index|]
operator||=
name|CTL_UA_REG_PREEMPT
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
operator|*
name|CTL_MAX_INITIATORS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|msg
operator|->
name|pr
operator|.
name|pr_info
operator|.
name|residx
operator|||
name|lun
operator|->
name|pr_keys
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|sa_res_key
operator|==
name|lun
operator|->
name|pr_keys
index|[
name|i
index|]
condition|)
block|{
name|lun
operator|->
name|pr_keys
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|lun
operator|->
name|pr_key_count
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|persis_offset
operator|&&
name|i
operator|<
name|CTL_MAX_INITIATORS
condition|)
name|lun
operator|->
name|pending_ua
index|[
name|i
index|]
operator||=
name|CTL_UA_REG_PREEMPT
expr_stmt|;
elseif|else
if|if
condition|(
name|persis_offset
operator|&&
name|i
operator|>=
name|persis_offset
condition|)
name|lun
operator|->
name|pending_ua
index|[
name|i
operator|-
name|persis_offset
index|]
operator||=
name|CTL_UA_REG_PREEMPT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|msg
operator|->
name|pr
operator|.
name|pr_info
operator|.
name|res_type
operator|!=
name|lun
operator|->
name|res_type
operator|&&
operator|(
name|lun
operator|->
name|res_type
operator|==
name|SPR_TYPE_WR_EX_RO
operator|||
name|lun
operator|->
name|res_type
operator|==
name|SPR_TYPE_EX_AC_RO
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|persis_offset
operator|&&
name|i
operator|<
name|persis_offset
condition|)
name|lun
operator|->
name|pending_ua
index|[
name|i
index|]
operator||=
name|CTL_UA_RES_RELEASE
expr_stmt|;
elseif|else
if|if
condition|(
name|persis_offset
operator|&&
name|i
operator|>=
name|persis_offset
condition|)
name|lun
operator|->
name|pending_ua
index|[
name|i
operator|-
name|persis_offset
index|]
operator||=
name|CTL_UA_RES_RELEASE
expr_stmt|;
block|}
block|}
name|lun
operator|->
name|res_type
operator|=
name|msg
operator|->
name|pr
operator|.
name|pr_info
operator|.
name|res_type
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|res_type
operator|!=
name|SPR_TYPE_WR_EX_AR
operator|&&
name|lun
operator|->
name|res_type
operator|!=
name|SPR_TYPE_EX_AC_AR
condition|)
name|lun
operator|->
name|pr_res_idx
operator|=
name|msg
operator|->
name|pr
operator|.
name|pr_info
operator|.
name|residx
expr_stmt|;
else|else
name|lun
operator|->
name|pr_res_idx
operator|=
name|CTL_PR_ALL_REGISTRANTS
expr_stmt|;
block|}
name|lun
operator|->
name|PRGeneration
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ctl_persistent_reserve_out
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|int
name|isc_retval
decl_stmt|;
name|u_int32_t
name|param_len
decl_stmt|;
name|struct
name|scsi_per_res_out
modifier|*
name|cdb
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|struct
name|scsi_per_res_out_parms
modifier|*
name|param
decl_stmt|;
name|struct
name|ctl_softc
modifier|*
name|softc
decl_stmt|;
name|uint32_t
name|residx
decl_stmt|;
name|uint64_t
name|res_key
decl_stmt|,
name|sa_res_key
decl_stmt|;
name|uint8_t
name|type
decl_stmt|;
name|union
name|ctl_ha_msg
name|persis_io
decl_stmt|;
name|int
name|i
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_persistent_reserve_out\n"
operator|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|CTL_RETVAL_COMPLETE
expr_stmt|;
name|softc
operator|=
name|control_softc
expr_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_per_res_out
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LUN
index|]
operator|.
name|ptr
expr_stmt|;
comment|/* 	 * We only support whole-LUN scope.  The scope& type are ignored for 	 * register, register and ignore existing key and clear. 	 * We sometimes ignore scope and type on preempts too!! 	 * Verify reservation type here as well. 	 */
name|type
operator|=
name|cdb
operator|->
name|scope_type
operator|&
name|SPR_TYPE_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|cdb
operator|->
name|action
operator|==
name|SPRO_RESERVE
operator|)
operator|||
operator|(
name|cdb
operator|->
name|action
operator|==
name|SPRO_RELEASE
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|cdb
operator|->
name|scope_type
operator|&
name|SPR_SCOPE_MASK
operator|)
operator|!=
name|SPR_LU_SCOPE
condition|)
block|{
name|ctl_set_invalid_field
argument_list|(
comment|/*ctsio*/
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|2
argument_list|,
comment|/*bit_valid*/
literal|1
argument_list|,
comment|/*bit*/
literal|4
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
if|if
condition|(
name|type
operator|>
literal|8
operator|||
name|type
operator|==
literal|2
operator|||
name|type
operator|==
literal|4
operator|||
name|type
operator|==
literal|0
condition|)
block|{
name|ctl_set_invalid_field
argument_list|(
comment|/*ctsio*/
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|2
argument_list|,
comment|/*bit_valid*/
literal|1
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
block|}
name|param_len
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ALLOCATED
operator|)
operator|==
literal|0
condition|)
block|{
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
name|param_len
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|param_len
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|param_len
expr_stmt|;
name|ctsio
operator|->
name|kern_data_resid
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
name|param
operator|=
operator|(
expr|struct
name|scsi_per_res_out_parms
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|residx
operator|=
name|ctl_get_resindex
argument_list|(
operator|&
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
argument_list|)
expr_stmt|;
name|res_key
operator|=
name|scsi_8btou64
argument_list|(
name|param
operator|->
name|res_key
operator|.
name|key
argument_list|)
expr_stmt|;
name|sa_res_key
operator|=
name|scsi_8btou64
argument_list|(
name|param
operator|->
name|serv_act_res_key
argument_list|)
expr_stmt|;
comment|/* 	 * Validate the reservation key here except for SPRO_REG_IGNO 	 * This must be done for all other service actions 	 */
if|if
condition|(
operator|(
name|cdb
operator|->
name|action
operator|&
name|SPRO_ACTION_MASK
operator|)
operator|!=
name|SPRO_REG_IGNO
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|pr_keys
index|[
name|residx
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|res_key
operator|!=
name|lun
operator|->
name|pr_keys
index|[
name|residx
index|]
condition|)
block|{
comment|/* 				 * The current key passed in doesn't match 				 * the one the initiator previously 				 * registered. 				 */
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|ctl_set_reservation_conflict
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|cdb
operator|->
name|action
operator|&
name|SPRO_ACTION_MASK
operator|)
operator|!=
name|SPRO_REGISTER
condition|)
block|{
comment|/* 			 * We are not registered 			 */
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|ctl_set_reservation_conflict
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|res_key
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * We are not registered and trying to register but 			 * the register key isn't zero. 			 */
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|ctl_set_reservation_conflict
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|cdb
operator|->
name|action
operator|&
name|SPRO_ACTION_MASK
condition|)
block|{
case|case
name|SPRO_REGISTER
case|:
case|case
name|SPRO_REG_IGNO
case|:
block|{
if|#
directive|if
literal|0
block|printf("Registration received\n");
endif|#
directive|endif
comment|/* 		 * We don't support any of these options, as we report in 		 * the read capabilities request (see 		 * ctl_persistent_reserve_in(), above). 		 */
if|if
condition|(
operator|(
name|param
operator|->
name|flags
operator|&
name|SPR_SPEC_I_PT
operator|)
operator|||
operator|(
name|param
operator|->
name|flags
operator|&
name|SPR_ALL_TG_PT
operator|)
operator|||
operator|(
name|param
operator|->
name|flags
operator|&
name|SPR_APTPL
operator|)
condition|)
block|{
name|int
name|bit_ptr
decl_stmt|;
if|if
condition|(
name|param
operator|->
name|flags
operator|&
name|SPR_APTPL
condition|)
name|bit_ptr
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|param
operator|->
name|flags
operator|&
name|SPR_ALL_TG_PT
condition|)
name|bit_ptr
operator|=
literal|2
expr_stmt|;
else|else
comment|/* SPR_SPEC_I_PT */
name|bit_ptr
operator|=
literal|3
expr_stmt|;
name|free
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|ctl_set_invalid_field
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|0
argument_list|,
comment|/*field*/
literal|20
argument_list|,
comment|/*bit_valid*/
literal|1
argument_list|,
comment|/*bit*/
name|bit_ptr
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
comment|/* 		 * The initiator wants to clear the 		 * key/unregister. 		 */
if|if
condition|(
name|sa_res_key
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|res_key
operator|==
literal|0
operator|&&
operator|(
name|cdb
operator|->
name|action
operator|&
name|SPRO_ACTION_MASK
operator|)
operator|==
name|SPRO_REGISTER
operator|)
operator|||
operator|(
operator|(
name|cdb
operator|->
name|action
operator|&
name|SPRO_ACTION_MASK
operator|)
operator|==
name|SPRO_REG_IGNO
operator|&&
name|lun
operator|->
name|pr_keys
index|[
name|residx
index|]
operator|==
literal|0
operator|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|lun
operator|->
name|pr_keys
index|[
name|residx
index|]
operator|=
literal|0
expr_stmt|;
name|lun
operator|->
name|pr_key_count
operator|--
expr_stmt|;
if|if
condition|(
name|residx
operator|==
name|lun
operator|->
name|pr_res_idx
condition|)
block|{
name|lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_LUN_PR_RESERVED
expr_stmt|;
name|lun
operator|->
name|pr_res_idx
operator|=
name|CTL_PR_NO_RESERVATION
expr_stmt|;
if|if
condition|(
operator|(
name|lun
operator|->
name|res_type
operator|==
name|SPR_TYPE_WR_EX_RO
operator|||
name|lun
operator|->
name|res_type
operator|==
name|SPR_TYPE_EX_AC_RO
operator|)
operator|&&
name|lun
operator|->
name|pr_key_count
condition|)
block|{
comment|/* 					 * If the reservation is a registrants 					 * only type we need to generate a UA 					 * for other registered inits.  The 					 * sense code should be RESERVATIONS 					 * RELEASED 					 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_MAX_INITIATORS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|lun
operator|->
name|pr_keys
index|[
name|i
operator|+
name|persis_offset
index|]
operator|==
literal|0
condition|)
continue|continue;
name|lun
operator|->
name|pending_ua
index|[
name|i
index|]
operator||=
name|CTL_UA_RES_RELEASE
expr_stmt|;
block|}
block|}
name|lun
operator|->
name|res_type
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lun
operator|->
name|pr_res_idx
operator|==
name|CTL_PR_ALL_REGISTRANTS
condition|)
block|{
if|if
condition|(
name|lun
operator|->
name|pr_key_count
operator|==
literal|0
condition|)
block|{
name|lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_LUN_PR_RESERVED
expr_stmt|;
name|lun
operator|->
name|res_type
operator|=
literal|0
expr_stmt|;
name|lun
operator|->
name|pr_res_idx
operator|=
name|CTL_PR_NO_RESERVATION
expr_stmt|;
block|}
block|}
name|persis_io
operator|.
name|hdr
operator|.
name|nexus
operator|=
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
expr_stmt|;
name|persis_io
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_PERS_ACTION
expr_stmt|;
name|persis_io
operator|.
name|pr
operator|.
name|pr_info
operator|.
name|action
operator|=
name|CTL_PR_UNREG_KEY
expr_stmt|;
name|persis_io
operator|.
name|pr
operator|.
name|pr_info
operator|.
name|residx
operator|=
name|residx
expr_stmt|;
if|if
condition|(
operator|(
name|isc_retval
operator|=
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|persis_io
argument_list|,
sizeof|sizeof
argument_list|(
name|persis_io
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|>
name|CTL_HA_STATUS_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"CTL:Persis Out error returned from "
literal|"ctl_ha_msg_send %d\n"
argument_list|,
name|isc_retval
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* sa_res_key != 0 */
block|{
comment|/* 			 * If we aren't registered currently then increment 			 * the key count and set the registered flag. 			 */
if|if
condition|(
name|lun
operator|->
name|pr_keys
index|[
name|residx
index|]
operator|==
literal|0
condition|)
name|lun
operator|->
name|pr_key_count
operator|++
expr_stmt|;
name|lun
operator|->
name|pr_keys
index|[
name|residx
index|]
operator|=
name|sa_res_key
expr_stmt|;
name|persis_io
operator|.
name|hdr
operator|.
name|nexus
operator|=
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
expr_stmt|;
name|persis_io
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_PERS_ACTION
expr_stmt|;
name|persis_io
operator|.
name|pr
operator|.
name|pr_info
operator|.
name|action
operator|=
name|CTL_PR_REG_KEY
expr_stmt|;
name|persis_io
operator|.
name|pr
operator|.
name|pr_info
operator|.
name|residx
operator|=
name|residx
expr_stmt|;
name|memcpy
argument_list|(
name|persis_io
operator|.
name|pr
operator|.
name|pr_info
operator|.
name|sa_res_key
argument_list|,
name|param
operator|->
name|serv_act_res_key
argument_list|,
sizeof|sizeof
argument_list|(
name|param
operator|->
name|serv_act_res_key
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|isc_retval
operator|=
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|persis_io
argument_list|,
sizeof|sizeof
argument_list|(
name|persis_io
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|>
name|CTL_HA_STATUS_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"CTL:Persis Out error returned from "
literal|"ctl_ha_msg_send %d\n"
argument_list|,
name|isc_retval
argument_list|)
expr_stmt|;
block|}
block|}
name|lun
operator|->
name|PRGeneration
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SPRO_RESERVE
case|:
if|#
directive|if
literal|0
block|printf("Reserve executed type %d\n", type);
endif|#
directive|endif
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_PR_RESERVED
condition|)
block|{
comment|/* 			 * if this isn't the reservation holder and it's 			 * not a "all registrants" type or if the type is 			 * different then we have a conflict 			 */
if|if
condition|(
operator|(
name|lun
operator|->
name|pr_res_idx
operator|!=
name|residx
operator|&&
name|lun
operator|->
name|pr_res_idx
operator|!=
name|CTL_PR_ALL_REGISTRANTS
operator|)
operator|||
name|lun
operator|->
name|res_type
operator|!=
name|type
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|ctl_set_reservation_conflict
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* create a reservation */
block|{
comment|/* 			 * If it's not an "all registrants" type record 			 * reservation holder 			 */
if|if
condition|(
name|type
operator|!=
name|SPR_TYPE_WR_EX_AR
operator|&&
name|type
operator|!=
name|SPR_TYPE_EX_AC_AR
condition|)
name|lun
operator|->
name|pr_res_idx
operator|=
name|residx
expr_stmt|;
comment|/* Res holder */
else|else
name|lun
operator|->
name|pr_res_idx
operator|=
name|CTL_PR_ALL_REGISTRANTS
expr_stmt|;
name|lun
operator|->
name|flags
operator||=
name|CTL_LUN_PR_RESERVED
expr_stmt|;
name|lun
operator|->
name|res_type
operator|=
name|type
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
comment|/* send msg to other side */
name|persis_io
operator|.
name|hdr
operator|.
name|nexus
operator|=
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
expr_stmt|;
name|persis_io
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_PERS_ACTION
expr_stmt|;
name|persis_io
operator|.
name|pr
operator|.
name|pr_info
operator|.
name|action
operator|=
name|CTL_PR_RESERVE
expr_stmt|;
name|persis_io
operator|.
name|pr
operator|.
name|pr_info
operator|.
name|residx
operator|=
name|lun
operator|->
name|pr_res_idx
expr_stmt|;
name|persis_io
operator|.
name|pr
operator|.
name|pr_info
operator|.
name|res_type
operator|=
name|type
expr_stmt|;
if|if
condition|(
operator|(
name|isc_retval
operator|=
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|persis_io
argument_list|,
sizeof|sizeof
argument_list|(
name|persis_io
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|>
name|CTL_HA_STATUS_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"CTL:Persis Out error returned from "
literal|"ctl_ha_msg_send %d\n"
argument_list|,
name|isc_retval
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SPRO_RELEASE
case|:
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_PR_RESERVED
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* No reservation exists return good status */
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 		 * Is this nexus a reservation holder? 		 */
if|if
condition|(
name|lun
operator|->
name|pr_res_idx
operator|!=
name|residx
operator|&&
name|lun
operator|->
name|pr_res_idx
operator|!=
name|CTL_PR_ALL_REGISTRANTS
condition|)
block|{
comment|/* 			 * not a res holder return good status but 			 * do nothing 			 */
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|lun
operator|->
name|res_type
operator|!=
name|type
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|ctl_set_illegal_pr_release
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
comment|/* okay to release */
name|lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_LUN_PR_RESERVED
expr_stmt|;
name|lun
operator|->
name|pr_res_idx
operator|=
name|CTL_PR_NO_RESERVATION
expr_stmt|;
name|lun
operator|->
name|res_type
operator|=
literal|0
expr_stmt|;
comment|/* 		 * if this isn't an exclusive access 		 * res generate UA for all other 		 * registrants. 		 */
if|if
condition|(
name|type
operator|!=
name|SPR_TYPE_EX_AC
operator|&&
name|type
operator|!=
name|SPR_TYPE_WR_EX
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_MAX_INITIATORS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|residx
operator|||
name|lun
operator|->
name|pr_keys
index|[
name|i
operator|+
name|persis_offset
index|]
operator|==
literal|0
condition|)
continue|continue;
name|lun
operator|->
name|pending_ua
index|[
name|i
index|]
operator||=
name|CTL_UA_RES_RELEASE
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
comment|/* Send msg to other side */
name|persis_io
operator|.
name|hdr
operator|.
name|nexus
operator|=
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
expr_stmt|;
name|persis_io
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_PERS_ACTION
expr_stmt|;
name|persis_io
operator|.
name|pr
operator|.
name|pr_info
operator|.
name|action
operator|=
name|CTL_PR_RELEASE
expr_stmt|;
if|if
condition|(
operator|(
name|isc_retval
operator|=
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|persis_io
argument_list|,
sizeof|sizeof
argument_list|(
name|persis_io
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|>
name|CTL_HA_STATUS_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"CTL:Persis Out error returned from "
literal|"ctl_ha_msg_send %d\n"
argument_list|,
name|isc_retval
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SPRO_CLEAR
case|:
comment|/* send msg to other side */
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_LUN_PR_RESERVED
expr_stmt|;
name|lun
operator|->
name|res_type
operator|=
literal|0
expr_stmt|;
name|lun
operator|->
name|pr_key_count
operator|=
literal|0
expr_stmt|;
name|lun
operator|->
name|pr_res_idx
operator|=
name|CTL_PR_NO_RESERVATION
expr_stmt|;
name|lun
operator|->
name|pr_keys
index|[
name|residx
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
operator|*
name|CTL_MAX_INITIATORS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|lun
operator|->
name|pr_keys
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|persis_offset
operator|&&
name|i
operator|<
name|CTL_MAX_INITIATORS
condition|)
name|lun
operator|->
name|pending_ua
index|[
name|i
index|]
operator||=
name|CTL_UA_RES_PREEMPT
expr_stmt|;
elseif|else
if|if
condition|(
name|persis_offset
operator|&&
name|i
operator|>=
name|persis_offset
condition|)
name|lun
operator|->
name|pending_ua
index|[
name|i
operator|-
name|persis_offset
index|]
operator||=
name|CTL_UA_RES_PREEMPT
expr_stmt|;
name|lun
operator|->
name|pr_keys
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|lun
operator|->
name|PRGeneration
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|persis_io
operator|.
name|hdr
operator|.
name|nexus
operator|=
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
expr_stmt|;
name|persis_io
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_PERS_ACTION
expr_stmt|;
name|persis_io
operator|.
name|pr
operator|.
name|pr_info
operator|.
name|action
operator|=
name|CTL_PR_CLEAR
expr_stmt|;
if|if
condition|(
operator|(
name|isc_retval
operator|=
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|persis_io
argument_list|,
sizeof|sizeof
argument_list|(
name|persis_io
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|>
name|CTL_HA_STATUS_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"CTL:Persis Out error returned from "
literal|"ctl_ha_msg_send %d\n"
argument_list|,
name|isc_retval
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SPRO_PREEMPT
case|:
block|{
name|int
name|nretval
decl_stmt|;
name|nretval
operator|=
name|ctl_pro_preempt
argument_list|(
name|softc
argument_list|,
name|lun
argument_list|,
name|res_key
argument_list|,
name|sa_res_key
argument_list|,
name|type
argument_list|,
name|residx
argument_list|,
name|ctsio
argument_list|,
name|cdb
argument_list|,
name|param
argument_list|)
expr_stmt|;
if|if
condition|(
name|nretval
operator|!=
literal|0
condition|)
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
break|break;
block|}
default|default:
name|panic
argument_list|(
literal|"Invalid PR type %x"
argument_list|,
name|cdb
operator|->
name|action
argument_list|)
expr_stmt|;
block|}
name|done
label|:
name|free
argument_list|(
name|ctsio
operator|->
name|kern_data_ptr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This routine is for handling a message from the other SC pertaining to  * persistent reserve out. All the error checking will have been done  * so only perorming the action need be done here to keep the two  * in sync.  */
end_comment

begin_function
specifier|static
name|void
name|ctl_hndl_per_res_out_on_other_sc
parameter_list|(
name|union
name|ctl_ha_msg
modifier|*
name|msg
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|struct
name|ctl_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint32_t
name|targ_lun
decl_stmt|;
name|softc
operator|=
name|control_softc
expr_stmt|;
name|targ_lun
operator|=
name|msg
operator|->
name|hdr
operator|.
name|nexus
operator|.
name|targ_mapped_lun
expr_stmt|;
name|lun
operator|=
name|softc
operator|->
name|ctl_luns
index|[
name|targ_lun
index|]
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|msg
operator|->
name|pr
operator|.
name|pr_info
operator|.
name|action
condition|)
block|{
case|case
name|CTL_PR_REG_KEY
case|:
if|if
condition|(
name|lun
operator|->
name|pr_keys
index|[
name|msg
operator|->
name|pr
operator|.
name|pr_info
operator|.
name|residx
index|]
operator|==
literal|0
condition|)
name|lun
operator|->
name|pr_key_count
operator|++
expr_stmt|;
name|lun
operator|->
name|pr_keys
index|[
name|msg
operator|->
name|pr
operator|.
name|pr_info
operator|.
name|residx
index|]
operator|=
name|scsi_8btou64
argument_list|(
name|msg
operator|->
name|pr
operator|.
name|pr_info
operator|.
name|sa_res_key
argument_list|)
expr_stmt|;
name|lun
operator|->
name|PRGeneration
operator|++
expr_stmt|;
break|break;
case|case
name|CTL_PR_UNREG_KEY
case|:
name|lun
operator|->
name|pr_keys
index|[
name|msg
operator|->
name|pr
operator|.
name|pr_info
operator|.
name|residx
index|]
operator|=
literal|0
expr_stmt|;
name|lun
operator|->
name|pr_key_count
operator|--
expr_stmt|;
comment|/* XXX Need to see if the reservation has been released */
comment|/* if so do we need to generate UA? */
if|if
condition|(
name|msg
operator|->
name|pr
operator|.
name|pr_info
operator|.
name|residx
operator|==
name|lun
operator|->
name|pr_res_idx
condition|)
block|{
name|lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_LUN_PR_RESERVED
expr_stmt|;
name|lun
operator|->
name|pr_res_idx
operator|=
name|CTL_PR_NO_RESERVATION
expr_stmt|;
if|if
condition|(
operator|(
name|lun
operator|->
name|res_type
operator|==
name|SPR_TYPE_WR_EX_RO
operator|||
name|lun
operator|->
name|res_type
operator|==
name|SPR_TYPE_EX_AC_RO
operator|)
operator|&&
name|lun
operator|->
name|pr_key_count
condition|)
block|{
comment|/* 				 * If the reservation is a registrants 				 * only type we need to generate a UA 				 * for other registered inits.  The 				 * sense code should be RESERVATIONS 				 * RELEASED 				 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_MAX_INITIATORS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|lun
operator|->
name|pr_keys
index|[
name|i
operator|+
name|persis_offset
index|]
operator|==
literal|0
condition|)
continue|continue;
name|lun
operator|->
name|pending_ua
index|[
name|i
index|]
operator||=
name|CTL_UA_RES_RELEASE
expr_stmt|;
block|}
block|}
name|lun
operator|->
name|res_type
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lun
operator|->
name|pr_res_idx
operator|==
name|CTL_PR_ALL_REGISTRANTS
condition|)
block|{
if|if
condition|(
name|lun
operator|->
name|pr_key_count
operator|==
literal|0
condition|)
block|{
name|lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_LUN_PR_RESERVED
expr_stmt|;
name|lun
operator|->
name|res_type
operator|=
literal|0
expr_stmt|;
name|lun
operator|->
name|pr_res_idx
operator|=
name|CTL_PR_NO_RESERVATION
expr_stmt|;
block|}
block|}
name|lun
operator|->
name|PRGeneration
operator|++
expr_stmt|;
break|break;
case|case
name|CTL_PR_RESERVE
case|:
name|lun
operator|->
name|flags
operator||=
name|CTL_LUN_PR_RESERVED
expr_stmt|;
name|lun
operator|->
name|res_type
operator|=
name|msg
operator|->
name|pr
operator|.
name|pr_info
operator|.
name|res_type
expr_stmt|;
name|lun
operator|->
name|pr_res_idx
operator|=
name|msg
operator|->
name|pr
operator|.
name|pr_info
operator|.
name|residx
expr_stmt|;
break|break;
case|case
name|CTL_PR_RELEASE
case|:
comment|/* 		 * if this isn't an exclusive access res generate UA for all 		 * other registrants. 		 */
if|if
condition|(
name|lun
operator|->
name|res_type
operator|!=
name|SPR_TYPE_EX_AC
operator|&&
name|lun
operator|->
name|res_type
operator|!=
name|SPR_TYPE_WR_EX
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_MAX_INITIATORS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|lun
operator|->
name|pr_keys
index|[
name|i
operator|+
name|persis_offset
index|]
operator|!=
literal|0
condition|)
name|lun
operator|->
name|pending_ua
index|[
name|i
index|]
operator||=
name|CTL_UA_RES_RELEASE
expr_stmt|;
block|}
name|lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_LUN_PR_RESERVED
expr_stmt|;
name|lun
operator|->
name|pr_res_idx
operator|=
name|CTL_PR_NO_RESERVATION
expr_stmt|;
name|lun
operator|->
name|res_type
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CTL_PR_PREEMPT
case|:
name|ctl_pro_preempt_other
argument_list|(
name|lun
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_PR_CLEAR
case|:
name|lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_LUN_PR_RESERVED
expr_stmt|;
name|lun
operator|->
name|res_type
operator|=
literal|0
expr_stmt|;
name|lun
operator|->
name|pr_key_count
operator|=
literal|0
expr_stmt|;
name|lun
operator|->
name|pr_res_idx
operator|=
name|CTL_PR_NO_RESERVATION
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
operator|*
name|CTL_MAX_INITIATORS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|lun
operator|->
name|pr_keys
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|!
name|persis_offset
operator|&&
name|i
operator|<
name|CTL_MAX_INITIATORS
condition|)
name|lun
operator|->
name|pending_ua
index|[
name|i
index|]
operator||=
name|CTL_UA_RES_PREEMPT
expr_stmt|;
elseif|else
if|if
condition|(
name|persis_offset
operator|&&
name|i
operator|>=
name|persis_offset
condition|)
name|lun
operator|->
name|pending_ua
index|[
name|i
operator|-
name|persis_offset
index|]
operator||=
name|CTL_UA_RES_PREEMPT
expr_stmt|;
name|lun
operator|->
name|pr_keys
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|lun
operator|->
name|PRGeneration
operator|++
expr_stmt|;
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ctl_read_write
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|struct
name|ctl_lba_len_flags
modifier|*
name|lbalen
decl_stmt|;
name|uint64_t
name|lba
decl_stmt|;
name|uint32_t
name|num_blocks
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|retval
decl_stmt|;
name|int
name|isread
decl_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LUN
index|]
operator|.
name|ptr
expr_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_read_write: command: %#x\n"
operator|,
name|ctsio
operator|->
name|cdb
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
name|retval
operator|=
name|CTL_RETVAL_COMPLETE
expr_stmt|;
name|isread
operator|=
name|ctsio
operator|->
name|cdb
index|[
literal|0
index|]
operator|==
name|READ_6
operator|||
name|ctsio
operator|->
name|cdb
index|[
literal|0
index|]
operator|==
name|READ_10
operator|||
name|ctsio
operator|->
name|cdb
index|[
literal|0
index|]
operator|==
name|READ_12
operator|||
name|ctsio
operator|->
name|cdb
index|[
literal|0
index|]
operator|==
name|READ_16
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_PR_RESERVED
operator|&&
name|isread
condition|)
block|{
name|uint32_t
name|residx
decl_stmt|;
comment|/* 		 * XXX KDM need a lock here. 		 */
name|residx
operator|=
name|ctl_get_resindex
argument_list|(
operator|&
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lun
operator|->
name|res_type
operator|==
name|SPR_TYPE_EX_AC
operator|&&
name|residx
operator|!=
name|lun
operator|->
name|pr_res_idx
operator|)
operator|||
operator|(
operator|(
name|lun
operator|->
name|res_type
operator|==
name|SPR_TYPE_EX_AC_RO
operator|||
name|lun
operator|->
name|res_type
operator|==
name|SPR_TYPE_EX_AC_AR
operator|)
operator|&&
name|lun
operator|->
name|pr_keys
index|[
name|residx
index|]
operator|==
literal|0
operator|)
condition|)
block|{
name|ctl_set_reservation_conflict
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
block|}
switch|switch
condition|(
name|ctsio
operator|->
name|cdb
index|[
literal|0
index|]
condition|)
block|{
case|case
name|READ_6
case|:
case|case
name|WRITE_6
case|:
block|{
name|struct
name|scsi_rw_6
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_rw_6
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|lba
operator|=
name|scsi_3btoul
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
comment|/* only 5 bits are valid in the most significant address byte */
name|lba
operator|&=
literal|0x1fffff
expr_stmt|;
name|num_blocks
operator|=
name|cdb
operator|->
name|length
expr_stmt|;
comment|/* 		 * This is correct according to SBC-2. 		 */
if|if
condition|(
name|num_blocks
operator|==
literal|0
condition|)
name|num_blocks
operator|=
literal|256
expr_stmt|;
break|break;
block|}
case|case
name|READ_10
case|:
case|case
name|WRITE_10
case|:
block|{
name|struct
name|scsi_rw_10
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_rw_10
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SRW10_FUA
condition|)
name|flags
operator||=
name|CTL_LLF_FUA
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SRW10_DPO
condition|)
name|flags
operator||=
name|CTL_LLF_DPO
expr_stmt|;
name|lba
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
name|num_blocks
operator|=
name|scsi_2btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|WRITE_VERIFY_10
case|:
block|{
name|struct
name|scsi_write_verify_10
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_write_verify_10
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|flags
operator||=
name|CTL_LLF_FUA
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SWV_DPO
condition|)
name|flags
operator||=
name|CTL_LLF_DPO
expr_stmt|;
name|lba
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
name|num_blocks
operator|=
name|scsi_2btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|READ_12
case|:
case|case
name|WRITE_12
case|:
block|{
name|struct
name|scsi_rw_12
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_rw_12
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SRW12_FUA
condition|)
name|flags
operator||=
name|CTL_LLF_FUA
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SRW12_DPO
condition|)
name|flags
operator||=
name|CTL_LLF_DPO
expr_stmt|;
name|lba
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
name|num_blocks
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|WRITE_VERIFY_12
case|:
block|{
name|struct
name|scsi_write_verify_12
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_write_verify_12
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|flags
operator||=
name|CTL_LLF_FUA
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SWV_DPO
condition|)
name|flags
operator||=
name|CTL_LLF_DPO
expr_stmt|;
name|lba
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
name|num_blocks
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|READ_16
case|:
case|case
name|WRITE_16
case|:
block|{
name|struct
name|scsi_rw_16
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_rw_16
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SRW12_FUA
condition|)
name|flags
operator||=
name|CTL_LLF_FUA
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SRW12_DPO
condition|)
name|flags
operator||=
name|CTL_LLF_DPO
expr_stmt|;
name|lba
operator|=
name|scsi_8btou64
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
name|num_blocks
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|WRITE_ATOMIC_16
case|:
block|{
name|struct
name|scsi_rw_16
modifier|*
name|cdb
decl_stmt|;
if|if
condition|(
name|lun
operator|->
name|be_lun
operator|->
name|atomicblock
operator|==
literal|0
condition|)
block|{
name|ctl_set_invalid_opcode
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
name|cdb
operator|=
operator|(
expr|struct
name|scsi_rw_16
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SRW12_FUA
condition|)
name|flags
operator||=
name|CTL_LLF_FUA
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SRW12_DPO
condition|)
name|flags
operator||=
name|CTL_LLF_DPO
expr_stmt|;
name|lba
operator|=
name|scsi_8btou64
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
name|num_blocks
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_blocks
operator|>
name|lun
operator|->
name|be_lun
operator|->
name|atomicblock
condition|)
block|{
name|ctl_set_invalid_field
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|12
argument_list|,
comment|/*bit_valid*/
literal|0
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
break|break;
block|}
case|case
name|WRITE_VERIFY_16
case|:
block|{
name|struct
name|scsi_write_verify_16
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_write_verify_16
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|flags
operator||=
name|CTL_LLF_FUA
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SWV_DPO
condition|)
name|flags
operator||=
name|CTL_LLF_DPO
expr_stmt|;
name|lba
operator|=
name|scsi_8btou64
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
name|num_blocks
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
comment|/* 		 * We got a command we don't support.  This shouldn't 		 * happen, commands should be filtered out above us. 		 */
name|ctl_set_invalid_opcode
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
break|break;
comment|/* NOTREACHED */
block|}
comment|/* 	 * The first check is to make sure we're in bounds, the second 	 * check is to catch wrap-around problems.  If the lba + num blocks 	 * is less than the lba, then we've wrapped around and the block 	 * range is invalid anyway. 	 */
if|if
condition|(
operator|(
operator|(
name|lba
operator|+
name|num_blocks
operator|)
operator|>
operator|(
name|lun
operator|->
name|be_lun
operator|->
name|maxlba
operator|+
literal|1
operator|)
operator|)
operator|||
operator|(
operator|(
name|lba
operator|+
name|num_blocks
operator|)
operator|<
name|lba
operator|)
condition|)
block|{
name|ctl_set_lba_out_of_range
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
comment|/* 	 * According to SBC-3, a transfer length of 0 is not an error. 	 * Note that this cannot happen with WRITE(6) or READ(6), since 0 	 * translates to 256 blocks for those commands. 	 */
if|if
condition|(
name|num_blocks
operator|==
literal|0
condition|)
block|{
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
comment|/* Set FUA and/or DPO if caches are disabled. */
if|if
condition|(
name|isread
condition|)
block|{
if|if
condition|(
operator|(
name|lun
operator|->
name|mode_pages
operator|.
name|caching_page
index|[
name|CTL_PAGE_CURRENT
index|]
operator|.
name|flags1
operator|&
name|SCP_RCD
operator|)
operator|!=
literal|0
condition|)
name|flags
operator||=
name|CTL_LLF_FUA
operator||
name|CTL_LLF_DPO
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|lun
operator|->
name|mode_pages
operator|.
name|caching_page
index|[
name|CTL_PAGE_CURRENT
index|]
operator|.
name|flags1
operator|&
name|SCP_WCE
operator|)
operator|==
literal|0
condition|)
name|flags
operator||=
name|CTL_LLF_FUA
expr_stmt|;
block|}
name|lbalen
operator|=
operator|(
expr|struct
name|ctl_lba_len_flags
operator|*
operator|)
operator|&
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LBA_LEN
index|]
expr_stmt|;
name|lbalen
operator|->
name|lba
operator|=
name|lba
expr_stmt|;
name|lbalen
operator|->
name|len
operator|=
name|num_blocks
expr_stmt|;
name|lbalen
operator|->
name|flags
operator|=
operator|(
name|isread
condition|?
name|CTL_LLF_READ
else|:
name|CTL_LLF_WRITE
operator|)
operator||
name|flags
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|num_blocks
operator|*
name|lun
operator|->
name|be_lun
operator|->
name|blocksize
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_read_write: calling data_submit()\n"
operator|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|lun
operator|->
name|backend
operator|->
name|data_submit
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_cnw_cont
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|struct
name|ctl_lba_len_flags
modifier|*
name|lbalen
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|ctsio
operator|=
operator|&
name|io
operator|->
name|scsiio
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|status
operator|=
name|CTL_STATUS_NONE
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator|&=
operator|~
name|CTL_FLAG_IO_CONT
expr_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LUN
index|]
operator|.
name|ptr
expr_stmt|;
name|lbalen
operator|=
operator|(
expr|struct
name|ctl_lba_len_flags
operator|*
operator|)
operator|&
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LBA_LEN
index|]
expr_stmt|;
name|lbalen
operator|->
name|flags
operator|&=
operator|~
name|CTL_LLF_COMPARE
expr_stmt|;
name|lbalen
operator|->
name|flags
operator||=
name|CTL_LLF_WRITE
expr_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_cnw_cont: calling data_submit()\n"
operator|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|lun
operator|->
name|backend
operator|->
name|data_submit
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_cnw
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|struct
name|ctl_lba_len_flags
modifier|*
name|lbalen
decl_stmt|;
name|uint64_t
name|lba
decl_stmt|;
name|uint32_t
name|num_blocks
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|retval
decl_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LUN
index|]
operator|.
name|ptr
expr_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_cnw: command: %#x\n"
operator|,
name|ctsio
operator|->
name|cdb
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
name|retval
operator|=
name|CTL_RETVAL_COMPLETE
expr_stmt|;
switch|switch
condition|(
name|ctsio
operator|->
name|cdb
index|[
literal|0
index|]
condition|)
block|{
case|case
name|COMPARE_AND_WRITE
case|:
block|{
name|struct
name|scsi_compare_and_write
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_compare_and_write
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SRW10_FUA
condition|)
name|flags
operator||=
name|CTL_LLF_FUA
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SRW10_DPO
condition|)
name|flags
operator||=
name|CTL_LLF_DPO
expr_stmt|;
name|lba
operator|=
name|scsi_8btou64
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
name|num_blocks
operator|=
name|cdb
operator|->
name|length
expr_stmt|;
break|break;
block|}
default|default:
comment|/* 		 * We got a command we don't support.  This shouldn't 		 * happen, commands should be filtered out above us. 		 */
name|ctl_set_invalid_opcode
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
break|break;
comment|/* NOTREACHED */
block|}
comment|/* 	 * The first check is to make sure we're in bounds, the second 	 * check is to catch wrap-around problems.  If the lba + num blocks 	 * is less than the lba, then we've wrapped around and the block 	 * range is invalid anyway. 	 */
if|if
condition|(
operator|(
operator|(
name|lba
operator|+
name|num_blocks
operator|)
operator|>
operator|(
name|lun
operator|->
name|be_lun
operator|->
name|maxlba
operator|+
literal|1
operator|)
operator|)
operator|||
operator|(
operator|(
name|lba
operator|+
name|num_blocks
operator|)
operator|<
name|lba
operator|)
condition|)
block|{
name|ctl_set_lba_out_of_range
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
comment|/* 	 * According to SBC-3, a transfer length of 0 is not an error. 	 */
if|if
condition|(
name|num_blocks
operator|==
literal|0
condition|)
block|{
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
comment|/* Set FUA if write cache is disabled. */
if|if
condition|(
operator|(
name|lun
operator|->
name|mode_pages
operator|.
name|caching_page
index|[
name|CTL_PAGE_CURRENT
index|]
operator|.
name|flags1
operator|&
name|SCP_WCE
operator|)
operator|==
literal|0
condition|)
name|flags
operator||=
name|CTL_LLF_FUA
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
literal|2
operator|*
name|num_blocks
operator|*
name|lun
operator|->
name|be_lun
operator|->
name|blocksize
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Set the IO_CONT flag, so that if this I/O gets passed to 	 * ctl_data_submit_done(), it'll get passed back to 	 * ctl_ctl_cnw_cont() for further processing. 	 */
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_IO_CONT
expr_stmt|;
name|ctsio
operator|->
name|io_cont
operator|=
name|ctl_cnw_cont
expr_stmt|;
name|lbalen
operator|=
operator|(
expr|struct
name|ctl_lba_len_flags
operator|*
operator|)
operator|&
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LBA_LEN
index|]
expr_stmt|;
name|lbalen
operator|->
name|lba
operator|=
name|lba
expr_stmt|;
name|lbalen
operator|->
name|len
operator|=
name|num_blocks
expr_stmt|;
name|lbalen
operator|->
name|flags
operator|=
name|CTL_LLF_COMPARE
operator||
name|flags
expr_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_cnw: calling data_submit()\n"
operator|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|lun
operator|->
name|backend
operator|->
name|data_submit
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_verify
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|struct
name|ctl_lba_len_flags
modifier|*
name|lbalen
decl_stmt|;
name|uint64_t
name|lba
decl_stmt|;
name|uint32_t
name|num_blocks
decl_stmt|;
name|int
name|bytchk
decl_stmt|,
name|flags
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LUN
index|]
operator|.
name|ptr
expr_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_verify: command: %#x\n"
operator|,
name|ctsio
operator|->
name|cdb
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
name|bytchk
operator|=
literal|0
expr_stmt|;
name|flags
operator|=
name|CTL_LLF_FUA
expr_stmt|;
name|retval
operator|=
name|CTL_RETVAL_COMPLETE
expr_stmt|;
switch|switch
condition|(
name|ctsio
operator|->
name|cdb
index|[
literal|0
index|]
condition|)
block|{
case|case
name|VERIFY_10
case|:
block|{
name|struct
name|scsi_verify_10
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_verify_10
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SVFY_BYTCHK
condition|)
name|bytchk
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SVFY_DPO
condition|)
name|flags
operator||=
name|CTL_LLF_DPO
expr_stmt|;
name|lba
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
name|num_blocks
operator|=
name|scsi_2btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|VERIFY_12
case|:
block|{
name|struct
name|scsi_verify_12
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_verify_12
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SVFY_BYTCHK
condition|)
name|bytchk
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SVFY_DPO
condition|)
name|flags
operator||=
name|CTL_LLF_DPO
expr_stmt|;
name|lba
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
name|num_blocks
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|VERIFY_16
case|:
block|{
name|struct
name|scsi_rw_16
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_rw_16
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SVFY_BYTCHK
condition|)
name|bytchk
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SVFY_DPO
condition|)
name|flags
operator||=
name|CTL_LLF_DPO
expr_stmt|;
name|lba
operator|=
name|scsi_8btou64
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
name|num_blocks
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
comment|/* 		 * We got a command we don't support.  This shouldn't 		 * happen, commands should be filtered out above us. 		 */
name|ctl_set_invalid_opcode
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
comment|/* 	 * The first check is to make sure we're in bounds, the second 	 * check is to catch wrap-around problems.  If the lba + num blocks 	 * is less than the lba, then we've wrapped around and the block 	 * range is invalid anyway. 	 */
if|if
condition|(
operator|(
operator|(
name|lba
operator|+
name|num_blocks
operator|)
operator|>
operator|(
name|lun
operator|->
name|be_lun
operator|->
name|maxlba
operator|+
literal|1
operator|)
operator|)
operator|||
operator|(
operator|(
name|lba
operator|+
name|num_blocks
operator|)
operator|<
name|lba
operator|)
condition|)
block|{
name|ctl_set_lba_out_of_range
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
comment|/* 	 * According to SBC-3, a transfer length of 0 is not an error. 	 */
if|if
condition|(
name|num_blocks
operator|==
literal|0
condition|)
block|{
name|ctl_set_success
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
name|lbalen
operator|=
operator|(
expr|struct
name|ctl_lba_len_flags
operator|*
operator|)
operator|&
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LBA_LEN
index|]
expr_stmt|;
name|lbalen
operator|->
name|lba
operator|=
name|lba
expr_stmt|;
name|lbalen
operator|->
name|len
operator|=
name|num_blocks
expr_stmt|;
if|if
condition|(
name|bytchk
condition|)
block|{
name|lbalen
operator|->
name|flags
operator|=
name|CTL_LLF_COMPARE
operator||
name|flags
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|num_blocks
operator|*
name|lun
operator|->
name|be_lun
operator|->
name|blocksize
expr_stmt|;
block|}
else|else
block|{
name|lbalen
operator|->
name|flags
operator|=
name|CTL_LLF_VERIFY
operator||
name|flags
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
literal|0
expr_stmt|;
block|}
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_verify: calling data_submit()\n"
operator|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|lun
operator|->
name|backend
operator|->
name|data_submit
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_report_luns
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|scsi_report_luns
modifier|*
name|cdb
decl_stmt|;
name|struct
name|scsi_report_luns_data
modifier|*
name|lun_data
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|,
modifier|*
name|request_lun
decl_stmt|;
name|int
name|num_luns
decl_stmt|,
name|retval
decl_stmt|;
name|uint32_t
name|alloc_len
decl_stmt|,
name|lun_datalen
decl_stmt|;
name|int
name|num_filled
decl_stmt|,
name|well_known
decl_stmt|;
name|uint32_t
name|initidx
decl_stmt|,
name|targ_lun_id
decl_stmt|,
name|lun_id
decl_stmt|;
name|retval
operator|=
name|CTL_RETVAL_COMPLETE
expr_stmt|;
name|well_known
operator|=
literal|0
expr_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_report_luns
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_report_luns\n"
operator|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|control_softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|num_luns
operator|=
name|control_softc
operator|->
name|num_luns
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|control_softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cdb
operator|->
name|select_report
condition|)
block|{
case|case
name|RPL_REPORT_DEFAULT
case|:
case|case
name|RPL_REPORT_ALL
case|:
break|break;
case|case
name|RPL_REPORT_WELLKNOWN
case|:
name|well_known
operator|=
literal|1
expr_stmt|;
name|num_luns
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|ctl_set_invalid_field
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|2
argument_list|,
comment|/*bit_valid*/
literal|0
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
break|break;
comment|/* NOTREACHED */
block|}
name|alloc_len
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
comment|/* 	 * The initiator has to allocate at least 16 bytes for this request, 	 * so he can at least get the header and the first LUN.  Otherwise 	 * we reject the request (per SPC-3 rev 14, section 6.21). 	 */
if|if
condition|(
name|alloc_len
operator|<
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_report_luns_data
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_report_luns_lundata
argument_list|)
operator|)
condition|)
block|{
name|ctl_set_invalid_field
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|6
argument_list|,
comment|/*bit_valid*/
literal|0
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
name|request_lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LUN
index|]
operator|.
name|ptr
expr_stmt|;
name|lun_datalen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|lun_data
argument_list|)
operator|+
operator|(
name|num_luns
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_report_luns_lundata
argument_list|)
operator|)
expr_stmt|;
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
name|lun_datalen
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|lun_data
operator|=
operator|(
expr|struct
name|scsi_report_luns_data
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
name|initidx
operator|=
name|ctl_get_initindex
argument_list|(
operator|&
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|control_softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|targ_lun_id
operator|=
literal|0
operator|,
name|num_filled
operator|=
literal|0
init|;
name|targ_lun_id
operator|<
name|CTL_MAX_LUNS
operator|&&
name|num_filled
operator|<
name|num_luns
condition|;
name|targ_lun_id
operator|++
control|)
block|{
name|lun_id
operator|=
name|ctl_map_lun
argument_list|(
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
argument_list|,
name|targ_lun_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun_id
operator|>=
name|CTL_MAX_LUNS
condition|)
continue|continue;
name|lun
operator|=
name|control_softc
operator|->
name|ctl_luns
index|[
name|lun_id
index|]
expr_stmt|;
if|if
condition|(
name|lun
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|targ_lun_id
operator|<=
literal|0xff
condition|)
block|{
comment|/* 			 * Peripheral addressing method, bus number 0. 			 */
name|lun_data
operator|->
name|luns
index|[
name|num_filled
index|]
operator|.
name|lundata
index|[
literal|0
index|]
operator|=
name|RPL_LUNDATA_ATYP_PERIPH
expr_stmt|;
name|lun_data
operator|->
name|luns
index|[
name|num_filled
index|]
operator|.
name|lundata
index|[
literal|1
index|]
operator|=
name|targ_lun_id
expr_stmt|;
name|num_filled
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|targ_lun_id
operator|<=
literal|0x3fff
condition|)
block|{
comment|/* 			 * Flat addressing method. 			 */
name|lun_data
operator|->
name|luns
index|[
name|num_filled
index|]
operator|.
name|lundata
index|[
literal|0
index|]
operator|=
name|RPL_LUNDATA_ATYP_FLAT
operator||
operator|(
name|targ_lun_id
operator|&
name|RPL_LUNDATA_FLAT_LUN_MASK
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OLDCTLHEADERS
operator|(
name|SRLD_ADDR_FLAT
operator|<<
name|SRLD_ADDR_SHIFT
operator|)
operator||
operator|(
name|targ_lun_id
operator|&
name|SRLD_BUS_LUN_MASK
operator|)
expr_stmt|;
endif|#
directive|endif
name|lun_data
operator|->
name|luns
index|[
name|num_filled
index|]
operator|.
name|lundata
index|[
literal|1
index|]
operator|=
ifdef|#
directive|ifdef
name|OLDCTLHEADERS
name|targ_lun_id
operator|>>
name|SRLD_BUS_LUN_BITS
expr_stmt|;
endif|#
directive|endif
name|targ_lun_id
operator|>>
name|RPL_LUNDATA_FLAT_LUN_BITS
expr_stmt|;
name|num_filled
operator|++
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"ctl_report_luns: bogus LUN number %jd, "
literal|"skipping\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|targ_lun_id
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * According to SPC-3, rev 14 section 6.21: 		 * 		 * "The execution of a REPORT LUNS command to any valid and 		 * installed logical unit shall clear the REPORTED LUNS DATA 		 * HAS CHANGED unit attention condition for all logical 		 * units of that target with respect to the requesting 		 * initiator. A valid and installed logical unit is one 		 * having a PERIPHERAL QUALIFIER of 000b in the standard 		 * INQUIRY data (see 6.4.2)." 		 * 		 * If request_lun is NULL, the LUN this report luns command 		 * was issued to is either disabled or doesn't exist. In that 		 * case, we shouldn't clear any pending lun change unit 		 * attention. 		 */
if|if
condition|(
name|request_lun
operator|!=
name|NULL
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|lun
operator|->
name|pending_ua
index|[
name|initidx
index|]
operator|&=
operator|~
name|CTL_UA_LUN_CHANGE
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|control_softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
comment|/* 	 * It's quite possible that we've returned fewer LUNs than we allocated 	 * space for.  Trim it. 	 */
name|lun_datalen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|lun_data
argument_list|)
operator|+
operator|(
name|num_filled
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_report_luns_lundata
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|lun_datalen
operator|<
name|alloc_len
condition|)
block|{
name|ctsio
operator|->
name|residual
operator|=
name|alloc_len
operator|-
name|lun_datalen
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|lun_datalen
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|lun_datalen
expr_stmt|;
block|}
else|else
block|{
name|ctsio
operator|->
name|residual
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|alloc_len
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|alloc_len
expr_stmt|;
block|}
name|ctsio
operator|->
name|kern_data_resid
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
comment|/* 	 * We set this to the actual data length, regardless of how much 	 * space we actually have to return results.  If the user looks at 	 * this value, he'll know whether or not he allocated enough space 	 * and reissue the command if necessary.  We don't support well 	 * known logical units, so if the user asks for that, return none. 	 */
name|scsi_ulto4b
argument_list|(
name|lun_datalen
operator|-
literal|8
argument_list|,
name|lun_data
operator|->
name|length
argument_list|)
expr_stmt|;
comment|/* 	 * We can only return SCSI_STATUS_CHECK_COND when we can't satisfy 	 * this request. 	 */
name|ctsio
operator|->
name|scsi_status
operator|=
name|SCSI_STATUS_OK
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_request_sense
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|scsi_request_sense
modifier|*
name|cdb
decl_stmt|;
name|struct
name|scsi_sense_data
modifier|*
name|sense_ptr
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|uint32_t
name|initidx
decl_stmt|;
name|int
name|have_error
decl_stmt|;
name|scsi_sense_data_type
name|sense_format
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_request_sense
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LUN
index|]
operator|.
name|ptr
expr_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_request_sense\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Determine which sense format the user wants. 	 */
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SRS_DESC
condition|)
name|sense_format
operator|=
name|SSD_TYPE_DESC
expr_stmt|;
else|else
name|sense_format
operator|=
name|SSD_TYPE_FIXED
expr_stmt|;
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sense_ptr
argument_list|)
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sense_ptr
operator|=
operator|(
expr|struct
name|scsi_sense_data
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
comment|/* 	 * struct scsi_sense_data, which is currently set to 256 bytes, is 	 * larger than the largest allowed value for the length field in the 	 * REQUEST SENSE CDB, which is 252 bytes as of SPC-4. 	 */
name|ctsio
operator|->
name|residual
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|cdb
operator|->
name|length
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|cdb
operator|->
name|length
expr_stmt|;
name|ctsio
operator|->
name|kern_data_resid
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If we don't have a LUN, we don't have any pending sense. 	 */
if|if
condition|(
name|lun
operator|==
name|NULL
condition|)
goto|goto
name|no_sense
goto|;
name|have_error
operator|=
literal|0
expr_stmt|;
name|initidx
operator|=
name|ctl_get_initindex
argument_list|(
operator|&
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
argument_list|)
expr_stmt|;
comment|/* 	 * Check for pending sense, and then for pending unit attentions. 	 * Pending sense gets returned first, then pending unit attentions. 	 */
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CTL_WITH_CA
if|if
condition|(
name|ctl_is_set
argument_list|(
name|lun
operator|->
name|have_ca
argument_list|,
name|initidx
argument_list|)
condition|)
block|{
name|scsi_sense_data_type
name|stored_format
decl_stmt|;
comment|/* 		 * Check to see which sense format was used for the stored 		 * sense data. 		 */
name|stored_format
operator|=
name|scsi_sense_type
argument_list|(
operator|&
name|lun
operator|->
name|pending_sense
index|[
name|initidx
index|]
argument_list|)
expr_stmt|;
comment|/* 		 * If the user requested a different sense format than the 		 * one we stored, then we need to convert it to the other 		 * format.  If we're going from descriptor to fixed format 		 * sense data, we may lose things in translation, depending 		 * on what options were used. 		 * 		 * If the stored format is SSD_TYPE_NONE (i.e. invalid), 		 * for some reason we'll just copy it out as-is. 		 */
if|if
condition|(
operator|(
name|stored_format
operator|==
name|SSD_TYPE_FIXED
operator|)
operator|&&
operator|(
name|sense_format
operator|==
name|SSD_TYPE_DESC
operator|)
condition|)
name|ctl_sense_to_desc
argument_list|(
operator|(
expr|struct
name|scsi_sense_data_fixed
operator|*
operator|)
operator|&
name|lun
operator|->
name|pending_sense
index|[
name|initidx
index|]
argument_list|,
operator|(
expr|struct
name|scsi_sense_data_desc
operator|*
operator|)
name|sense_ptr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|stored_format
operator|==
name|SSD_TYPE_DESC
operator|)
operator|&&
operator|(
name|sense_format
operator|==
name|SSD_TYPE_FIXED
operator|)
condition|)
name|ctl_sense_to_fixed
argument_list|(
operator|(
expr|struct
name|scsi_sense_data_desc
operator|*
operator|)
operator|&
name|lun
operator|->
name|pending_sense
index|[
name|initidx
index|]
argument_list|,
operator|(
expr|struct
name|scsi_sense_data_fixed
operator|*
operator|)
name|sense_ptr
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|sense_ptr
argument_list|,
operator|&
name|lun
operator|->
name|pending_sense
index|[
name|initidx
index|]
argument_list|,
name|ctl_min
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sense_ptr
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|lun
operator|->
name|pending_sense
index|[
name|initidx
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ctl_clear_mask
argument_list|(
name|lun
operator|->
name|have_ca
argument_list|,
name|initidx
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|lun
operator|->
name|pending_ua
index|[
name|initidx
index|]
operator|!=
name|CTL_UA_NONE
condition|)
block|{
name|ctl_ua_type
name|ua_type
decl_stmt|;
name|ua_type
operator|=
name|ctl_build_ua
argument_list|(
operator|&
name|lun
operator|->
name|pending_ua
index|[
name|initidx
index|]
argument_list|,
name|sense_ptr
argument_list|,
name|sense_format
argument_list|)
expr_stmt|;
if|if
condition|(
name|ua_type
operator|!=
name|CTL_UA_NONE
condition|)
name|have_error
operator|=
literal|1
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
comment|/* 	 * We already have a pending error, return it. 	 */
if|if
condition|(
name|have_error
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * We report the SCSI status as OK, since the status of the 		 * request sense command itself is OK. 		 */
name|ctsio
operator|->
name|scsi_status
operator|=
name|SCSI_STATUS_OK
expr_stmt|;
comment|/* 		 * We report 0 for the sense length, because we aren't doing 		 * autosense in this case.  We're reporting sense as 		 * parameter data. 		 */
name|ctsio
operator|->
name|sense_len
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
name|no_sense
label|:
comment|/* 	 * No sense information to report, so we report that everything is 	 * okay. 	 */
name|ctl_set_sense_data
argument_list|(
name|sense_ptr
argument_list|,
name|lun
argument_list|,
name|sense_format
argument_list|,
comment|/*current_error*/
literal|1
argument_list|,
comment|/*sense_key*/
name|SSD_KEY_NO_SENSE
argument_list|,
comment|/*asc*/
literal|0x00
argument_list|,
comment|/*ascq*/
literal|0x00
argument_list|,
name|SSD_ELEM_NONE
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|scsi_status
operator|=
name|SCSI_STATUS_OK
expr_stmt|;
comment|/* 	 * We report 0 for the sense length, because we aren't doing 	 * autosense in this case.  We're reporting sense as parameter data. 	 */
name|ctsio
operator|->
name|sense_len
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_tur
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LUN
index|]
operator|.
name|ptr
expr_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_tur\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ctsio
operator|->
name|scsi_status
operator|=
name|SCSI_STATUS_OK
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|status
operator|=
name|CTL_SUCCESS
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_function
specifier|static
name|int
name|ctl_cmddt_inquiry
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{  }
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|ctl_inquiry_evpd_supported
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|int
name|alloc_len
parameter_list|)
block|{
name|struct
name|scsi_vpd_supported_pages
modifier|*
name|pages
decl_stmt|;
name|int
name|sup_page_size
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LUN
index|]
operator|.
name|ptr
expr_stmt|;
name|sup_page_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_supported_pages
argument_list|)
operator|*
name|SCSI_EVPD_NUM_SUPPORTED_PAGES
expr_stmt|;
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
name|sup_page_size
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|pages
operator|=
operator|(
expr|struct
name|scsi_vpd_supported_pages
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sup_page_size
operator|<
name|alloc_len
condition|)
block|{
name|ctsio
operator|->
name|residual
operator|=
name|alloc_len
operator|-
name|sup_page_size
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|sup_page_size
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|sup_page_size
expr_stmt|;
block|}
else|else
block|{
name|ctsio
operator|->
name|residual
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|alloc_len
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|alloc_len
expr_stmt|;
block|}
name|ctsio
operator|->
name|kern_data_resid
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
comment|/* 	 * The control device is always connected.  The disk device, on the 	 * other hand, may not be online all the time.  Need to change this 	 * to figure out whether the disk device is actually online or not. 	 */
if|if
condition|(
name|lun
operator|!=
name|NULL
condition|)
name|pages
operator|->
name|device
operator|=
operator|(
name|SID_QUAL_LU_CONNECTED
operator|<<
literal|5
operator|)
operator||
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
expr_stmt|;
else|else
name|pages
operator|->
name|device
operator|=
operator|(
name|SID_QUAL_LU_OFFLINE
operator|<<
literal|5
operator|)
operator||
name|T_DIRECT
expr_stmt|;
name|pages
operator|->
name|length
operator|=
name|SCSI_EVPD_NUM_SUPPORTED_PAGES
expr_stmt|;
comment|/* Supported VPD pages */
name|pages
operator|->
name|page_list
index|[
literal|0
index|]
operator|=
name|SVPD_SUPPORTED_PAGES
expr_stmt|;
comment|/* Serial Number */
name|pages
operator|->
name|page_list
index|[
literal|1
index|]
operator|=
name|SVPD_UNIT_SERIAL_NUMBER
expr_stmt|;
comment|/* Device Identification */
name|pages
operator|->
name|page_list
index|[
literal|2
index|]
operator|=
name|SVPD_DEVICE_ID
expr_stmt|;
comment|/* Extended INQUIRY Data */
name|pages
operator|->
name|page_list
index|[
literal|3
index|]
operator|=
name|SVPD_EXTENDED_INQUIRY_DATA
expr_stmt|;
comment|/* Mode Page Policy */
name|pages
operator|->
name|page_list
index|[
literal|4
index|]
operator|=
name|SVPD_MODE_PAGE_POLICY
expr_stmt|;
comment|/* SCSI Ports */
name|pages
operator|->
name|page_list
index|[
literal|5
index|]
operator|=
name|SVPD_SCSI_PORTS
expr_stmt|;
comment|/* Third-party Copy */
name|pages
operator|->
name|page_list
index|[
literal|6
index|]
operator|=
name|SVPD_SCSI_TPC
expr_stmt|;
comment|/* Block limits */
name|pages
operator|->
name|page_list
index|[
literal|7
index|]
operator|=
name|SVPD_BLOCK_LIMITS
expr_stmt|;
comment|/* Block Device Characteristics */
name|pages
operator|->
name|page_list
index|[
literal|8
index|]
operator|=
name|SVPD_BDC
expr_stmt|;
comment|/* Logical Block Provisioning */
name|pages
operator|->
name|page_list
index|[
literal|9
index|]
operator|=
name|SVPD_LBP
expr_stmt|;
name|ctsio
operator|->
name|scsi_status
operator|=
name|SCSI_STATUS_OK
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_inquiry_evpd_serial
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|int
name|alloc_len
parameter_list|)
block|{
name|struct
name|scsi_vpd_unit_serial_number
modifier|*
name|sn_ptr
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LUN
index|]
operator|.
name|ptr
expr_stmt|;
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sn_ptr
argument_list|)
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|sn_ptr
operator|=
operator|(
expr|struct
name|scsi_vpd_unit_serial_number
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
operator|*
name|sn_ptr
argument_list|)
operator|<
name|alloc_len
condition|)
block|{
name|ctsio
operator|->
name|residual
operator|=
name|alloc_len
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|sn_ptr
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sn_ptr
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sn_ptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctsio
operator|->
name|residual
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|alloc_len
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|alloc_len
expr_stmt|;
block|}
name|ctsio
operator|->
name|kern_data_resid
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
comment|/* 	 * The control device is always connected.  The disk device, on the 	 * other hand, may not be online all the time.  Need to change this 	 * to figure out whether the disk device is actually online or not. 	 */
if|if
condition|(
name|lun
operator|!=
name|NULL
condition|)
name|sn_ptr
operator|->
name|device
operator|=
operator|(
name|SID_QUAL_LU_CONNECTED
operator|<<
literal|5
operator|)
operator||
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
expr_stmt|;
else|else
name|sn_ptr
operator|->
name|device
operator|=
operator|(
name|SID_QUAL_LU_OFFLINE
operator|<<
literal|5
operator|)
operator||
name|T_DIRECT
expr_stmt|;
name|sn_ptr
operator|->
name|page_code
operator|=
name|SVPD_UNIT_SERIAL_NUMBER
expr_stmt|;
name|sn_ptr
operator|->
name|length
operator|=
name|ctl_min
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sn_ptr
argument_list|)
operator|-
literal|4
argument_list|,
name|CTL_SN_LEN
argument_list|)
expr_stmt|;
comment|/* 	 * If we don't have a LUN, we just leave the serial number as 	 * all spaces. 	 */
name|memset
argument_list|(
name|sn_ptr
operator|->
name|serial_num
argument_list|,
literal|0x20
argument_list|,
sizeof|sizeof
argument_list|(
name|sn_ptr
operator|->
name|serial_num
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|!=
name|NULL
condition|)
block|{
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sn_ptr
operator|->
name|serial_num
argument_list|,
operator|(
name|char
operator|*
operator|)
name|lun
operator|->
name|be_lun
operator|->
name|serial_num
argument_list|,
name|CTL_SN_LEN
argument_list|)
expr_stmt|;
block|}
name|ctsio
operator|->
name|scsi_status
operator|=
name|SCSI_STATUS_OK
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_inquiry_evpd_eid
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|int
name|alloc_len
parameter_list|)
block|{
name|struct
name|scsi_vpd_extended_inquiry_data
modifier|*
name|eid_ptr
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|int
name|data_len
decl_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LUN
index|]
operator|.
name|ptr
expr_stmt|;
name|data_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_extended_inquiry_data
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
name|data_len
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|eid_ptr
operator|=
operator|(
expr|struct
name|scsi_vpd_extended_inquiry_data
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|data_len
operator|<
name|alloc_len
condition|)
block|{
name|ctsio
operator|->
name|residual
operator|=
name|alloc_len
operator|-
name|data_len
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|data_len
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|data_len
expr_stmt|;
block|}
else|else
block|{
name|ctsio
operator|->
name|residual
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|alloc_len
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|alloc_len
expr_stmt|;
block|}
name|ctsio
operator|->
name|kern_data_resid
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
comment|/* 	 * The control device is always connected.  The disk device, on the 	 * other hand, may not be online all the time. 	 */
if|if
condition|(
name|lun
operator|!=
name|NULL
condition|)
name|eid_ptr
operator|->
name|device
operator|=
operator|(
name|SID_QUAL_LU_CONNECTED
operator|<<
literal|5
operator|)
operator||
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
expr_stmt|;
else|else
name|eid_ptr
operator|->
name|device
operator|=
operator|(
name|SID_QUAL_LU_OFFLINE
operator|<<
literal|5
operator|)
operator||
name|T_DIRECT
expr_stmt|;
name|eid_ptr
operator|->
name|page_code
operator|=
name|SVPD_EXTENDED_INQUIRY_DATA
expr_stmt|;
name|eid_ptr
operator|->
name|page_length
operator|=
name|data_len
operator|-
literal|4
expr_stmt|;
name|eid_ptr
operator|->
name|flags2
operator|=
name|SVPD_EID_HEADSUP
operator||
name|SVPD_EID_ORDSUP
operator||
name|SVPD_EID_SIMPSUP
expr_stmt|;
name|eid_ptr
operator|->
name|flags3
operator|=
name|SVPD_EID_V_SUP
expr_stmt|;
name|ctsio
operator|->
name|scsi_status
operator|=
name|SCSI_STATUS_OK
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_inquiry_evpd_mpp
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|int
name|alloc_len
parameter_list|)
block|{
name|struct
name|scsi_vpd_mode_page_policy
modifier|*
name|mpp_ptr
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|int
name|data_len
decl_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LUN
index|]
operator|.
name|ptr
expr_stmt|;
name|data_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_mode_page_policy
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_mode_page_policy_descr
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
name|data_len
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|mpp_ptr
operator|=
operator|(
expr|struct
name|scsi_vpd_mode_page_policy
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|data_len
operator|<
name|alloc_len
condition|)
block|{
name|ctsio
operator|->
name|residual
operator|=
name|alloc_len
operator|-
name|data_len
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|data_len
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|data_len
expr_stmt|;
block|}
else|else
block|{
name|ctsio
operator|->
name|residual
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|alloc_len
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|alloc_len
expr_stmt|;
block|}
name|ctsio
operator|->
name|kern_data_resid
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
comment|/* 	 * The control device is always connected.  The disk device, on the 	 * other hand, may not be online all the time. 	 */
if|if
condition|(
name|lun
operator|!=
name|NULL
condition|)
name|mpp_ptr
operator|->
name|device
operator|=
operator|(
name|SID_QUAL_LU_CONNECTED
operator|<<
literal|5
operator|)
operator||
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
expr_stmt|;
else|else
name|mpp_ptr
operator|->
name|device
operator|=
operator|(
name|SID_QUAL_LU_OFFLINE
operator|<<
literal|5
operator|)
operator||
name|T_DIRECT
expr_stmt|;
name|mpp_ptr
operator|->
name|page_code
operator|=
name|SVPD_MODE_PAGE_POLICY
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|data_len
operator|-
literal|4
argument_list|,
name|mpp_ptr
operator|->
name|page_length
argument_list|)
expr_stmt|;
name|mpp_ptr
operator|->
name|descr
index|[
literal|0
index|]
operator|.
name|page_code
operator|=
literal|0x3f
expr_stmt|;
name|mpp_ptr
operator|->
name|descr
index|[
literal|0
index|]
operator|.
name|subpage_code
operator|=
literal|0xff
expr_stmt|;
name|mpp_ptr
operator|->
name|descr
index|[
literal|0
index|]
operator|.
name|policy
operator|=
name|SVPD_MPP_SHARED
expr_stmt|;
name|ctsio
operator|->
name|scsi_status
operator|=
name|SCSI_STATUS_OK
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_inquiry_evpd_devid
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|int
name|alloc_len
parameter_list|)
block|{
name|struct
name|scsi_vpd_device_id
modifier|*
name|devid_ptr
decl_stmt|;
name|struct
name|scsi_vpd_id_descriptor
modifier|*
name|desc
decl_stmt|;
name|struct
name|ctl_softc
modifier|*
name|ctl_softc
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|struct
name|ctl_port
modifier|*
name|port
decl_stmt|;
name|int
name|data_len
decl_stmt|;
name|uint8_t
name|proto
decl_stmt|;
name|ctl_softc
operator|=
name|control_softc
expr_stmt|;
name|port
operator|=
name|ctl_softc
operator|->
name|ctl_ports
index|[
name|ctl_port_idx
argument_list|(
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
argument_list|)
index|]
expr_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LUN
index|]
operator|.
name|ptr
expr_stmt|;
name|data_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_device_id
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_id_descriptor
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_id_rel_trgt_port_id
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_id_descriptor
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_id_trgt_port_grp_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|&&
name|lun
operator|->
name|lun_devid
condition|)
name|data_len
operator|+=
name|lun
operator|->
name|lun_devid
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|port_devid
condition|)
name|data_len
operator|+=
name|port
operator|->
name|port_devid
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|target_devid
condition|)
name|data_len
operator|+=
name|port
operator|->
name|target_devid
operator|->
name|len
expr_stmt|;
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
name|data_len
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|devid_ptr
operator|=
operator|(
expr|struct
name|scsi_vpd_device_id
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|data_len
operator|<
name|alloc_len
condition|)
block|{
name|ctsio
operator|->
name|residual
operator|=
name|alloc_len
operator|-
name|data_len
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|data_len
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|data_len
expr_stmt|;
block|}
else|else
block|{
name|ctsio
operator|->
name|residual
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|alloc_len
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|alloc_len
expr_stmt|;
block|}
name|ctsio
operator|->
name|kern_data_resid
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
comment|/* 	 * The control device is always connected.  The disk device, on the 	 * other hand, may not be online all the time. 	 */
if|if
condition|(
name|lun
operator|!=
name|NULL
condition|)
name|devid_ptr
operator|->
name|device
operator|=
operator|(
name|SID_QUAL_LU_CONNECTED
operator|<<
literal|5
operator|)
operator||
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
expr_stmt|;
else|else
name|devid_ptr
operator|->
name|device
operator|=
operator|(
name|SID_QUAL_LU_OFFLINE
operator|<<
literal|5
operator|)
operator||
name|T_DIRECT
expr_stmt|;
name|devid_ptr
operator|->
name|page_code
operator|=
name|SVPD_DEVICE_ID
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|data_len
operator|-
literal|4
argument_list|,
name|devid_ptr
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|port_type
operator|==
name|CTL_PORT_FC
condition|)
name|proto
operator|=
name|SCSI_PROTO_FC
operator|<<
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|port
operator|->
name|port_type
operator|==
name|CTL_PORT_ISCSI
condition|)
name|proto
operator|=
name|SCSI_PROTO_ISCSI
operator|<<
literal|4
expr_stmt|;
else|else
name|proto
operator|=
name|SCSI_PROTO_SPI
operator|<<
literal|4
expr_stmt|;
name|desc
operator|=
operator|(
expr|struct
name|scsi_vpd_id_descriptor
operator|*
operator|)
name|devid_ptr
operator|->
name|desc_list
expr_stmt|;
comment|/* 	 * We're using a LUN association here.  i.e., this device ID is a 	 * per-LUN identifier. 	 */
if|if
condition|(
name|lun
operator|&&
name|lun
operator|->
name|lun_devid
condition|)
block|{
name|memcpy
argument_list|(
name|desc
argument_list|,
name|lun
operator|->
name|lun_devid
operator|->
name|data
argument_list|,
name|lun
operator|->
name|lun_devid
operator|->
name|len
argument_list|)
expr_stmt|;
name|desc
operator|=
operator|(
expr|struct
name|scsi_vpd_id_descriptor
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|desc
operator|+
name|lun
operator|->
name|lun_devid
operator|->
name|len
operator|)
expr_stmt|;
block|}
comment|/* 	 * This is for the WWPN which is a port association. 	 */
if|if
condition|(
name|port
operator|->
name|port_devid
condition|)
block|{
name|memcpy
argument_list|(
name|desc
argument_list|,
name|port
operator|->
name|port_devid
operator|->
name|data
argument_list|,
name|port
operator|->
name|port_devid
operator|->
name|len
argument_list|)
expr_stmt|;
name|desc
operator|=
operator|(
expr|struct
name|scsi_vpd_id_descriptor
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|desc
operator|+
name|port
operator|->
name|port_devid
operator|->
name|len
operator|)
expr_stmt|;
block|}
comment|/* 	 * This is for the Relative Target Port(type 4h) identifier 	 */
name|desc
operator|->
name|proto_codeset
operator|=
name|proto
operator||
name|SVPD_ID_CODESET_BINARY
expr_stmt|;
name|desc
operator|->
name|id_type
operator|=
name|SVPD_ID_PIV
operator||
name|SVPD_ID_ASSOC_PORT
operator||
name|SVPD_ID_TYPE_RELTARG
expr_stmt|;
name|desc
operator|->
name|length
operator|=
literal|4
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
argument_list|,
operator|&
name|desc
operator|->
name|identifier
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|desc
operator|=
operator|(
expr|struct
name|scsi_vpd_id_descriptor
operator|*
operator|)
operator|(
operator|&
name|desc
operator|->
name|identifier
index|[
literal|0
index|]
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_id_rel_trgt_port_id
argument_list|)
operator|)
expr_stmt|;
comment|/* 	 * This is for the Target Port Group(type 5h) identifier 	 */
name|desc
operator|->
name|proto_codeset
operator|=
name|proto
operator||
name|SVPD_ID_CODESET_BINARY
expr_stmt|;
name|desc
operator|->
name|id_type
operator|=
name|SVPD_ID_PIV
operator||
name|SVPD_ID_ASSOC_PORT
operator||
name|SVPD_ID_TYPE_TPORTGRP
expr_stmt|;
name|desc
operator|->
name|length
operator|=
literal|4
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
operator|/
name|CTL_MAX_PORTS
operator|+
literal|1
argument_list|,
operator|&
name|desc
operator|->
name|identifier
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|desc
operator|=
operator|(
expr|struct
name|scsi_vpd_id_descriptor
operator|*
operator|)
operator|(
operator|&
name|desc
operator|->
name|identifier
index|[
literal|0
index|]
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_id_trgt_port_grp_id
argument_list|)
operator|)
expr_stmt|;
comment|/* 	 * This is for the Target identifier 	 */
if|if
condition|(
name|port
operator|->
name|target_devid
condition|)
block|{
name|memcpy
argument_list|(
name|desc
argument_list|,
name|port
operator|->
name|target_devid
operator|->
name|data
argument_list|,
name|port
operator|->
name|target_devid
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
name|ctsio
operator|->
name|scsi_status
operator|=
name|SCSI_STATUS_OK
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_inquiry_evpd_scsi_ports
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|int
name|alloc_len
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|control_softc
decl_stmt|;
name|struct
name|scsi_vpd_scsi_ports
modifier|*
name|sp
decl_stmt|;
name|struct
name|scsi_vpd_port_designation
modifier|*
name|pd
decl_stmt|;
name|struct
name|scsi_vpd_port_designation_cont
modifier|*
name|pdc
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|struct
name|ctl_port
modifier|*
name|port
decl_stmt|;
name|int
name|data_len
decl_stmt|,
name|num_target_ports
decl_stmt|,
name|iid_len
decl_stmt|,
name|id_len
decl_stmt|,
name|g
decl_stmt|,
name|pg
decl_stmt|,
name|p
decl_stmt|;
name|int
name|num_target_port_groups
decl_stmt|,
name|single
decl_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LUN
index|]
operator|.
name|ptr
expr_stmt|;
name|single
operator|=
name|ctl_is_single
expr_stmt|;
if|if
condition|(
name|single
condition|)
name|num_target_port_groups
operator|=
literal|1
expr_stmt|;
else|else
name|num_target_port_groups
operator|=
name|NUM_TARGET_PORT_GROUPS
expr_stmt|;
name|num_target_ports
operator|=
literal|0
expr_stmt|;
name|iid_len
operator|=
literal|0
expr_stmt|;
name|id_len
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|port
argument_list|,
argument|&softc->port_list
argument_list|,
argument|links
argument_list|)
block|{
if|if
condition|(
operator|(
name|port
operator|->
name|status
operator|&
name|CTL_PORT_STATUS_ONLINE
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|lun
operator|!=
name|NULL
operator|&&
name|ctl_map_lun_back
argument_list|(
name|port
operator|->
name|targ_port
argument_list|,
name|lun
operator|->
name|lun
argument_list|)
operator|>=
name|CTL_MAX_LUNS
condition|)
continue|continue;
name|num_target_ports
operator|++
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|init_devid
condition|)
name|iid_len
operator|+=
name|port
operator|->
name|init_devid
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|port_devid
condition|)
name|id_len
operator|+=
name|port
operator|->
name|port_devid
operator|->
name|len
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|data_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_scsi_ports
argument_list|)
operator|+
name|num_target_port_groups
operator|*
name|num_target_ports
operator|*
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_port_designation
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_port_designation_cont
argument_list|)
operator|)
operator|+
name|iid_len
operator|+
name|id_len
expr_stmt|;
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
name|data_len
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|sp
operator|=
operator|(
expr|struct
name|scsi_vpd_scsi_ports
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|data_len
operator|<
name|alloc_len
condition|)
block|{
name|ctsio
operator|->
name|residual
operator|=
name|alloc_len
operator|-
name|data_len
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|data_len
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|data_len
expr_stmt|;
block|}
else|else
block|{
name|ctsio
operator|->
name|residual
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|alloc_len
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|alloc_len
expr_stmt|;
block|}
name|ctsio
operator|->
name|kern_data_resid
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
comment|/* 	 * The control device is always connected.  The disk device, on the 	 * other hand, may not be online all the time.  Need to change this 	 * to figure out whether the disk device is actually online or not. 	 */
if|if
condition|(
name|lun
operator|!=
name|NULL
condition|)
name|sp
operator|->
name|device
operator|=
operator|(
name|SID_QUAL_LU_CONNECTED
operator|<<
literal|5
operator|)
operator||
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
expr_stmt|;
else|else
name|sp
operator|->
name|device
operator|=
operator|(
name|SID_QUAL_LU_OFFLINE
operator|<<
literal|5
operator|)
operator||
name|T_DIRECT
expr_stmt|;
name|sp
operator|->
name|page_code
operator|=
name|SVPD_SCSI_PORTS
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|data_len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_vpd_scsi_ports
argument_list|)
argument_list|,
name|sp
operator|->
name|page_length
argument_list|)
expr_stmt|;
name|pd
operator|=
operator|&
name|sp
operator|->
name|design
index|[
literal|0
index|]
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|flags
operator|&
name|CTL_FLAG_MASTER_SHELF
condition|)
name|pg
operator|=
literal|0
expr_stmt|;
else|else
name|pg
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|g
operator|=
literal|0
init|;
name|g
operator|<
name|num_target_port_groups
condition|;
name|g
operator|++
control|)
block|{
name|STAILQ_FOREACH
argument_list|(
argument|port
argument_list|,
argument|&softc->port_list
argument_list|,
argument|links
argument_list|)
block|{
if|if
condition|(
operator|(
name|port
operator|->
name|status
operator|&
name|CTL_PORT_STATUS_ONLINE
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|lun
operator|!=
name|NULL
operator|&&
name|ctl_map_lun_back
argument_list|(
name|port
operator|->
name|targ_port
argument_list|,
name|lun
operator|->
name|lun
argument_list|)
operator|>=
name|CTL_MAX_LUNS
condition|)
continue|continue;
name|p
operator|=
name|port
operator|->
name|targ_port
operator|%
name|CTL_MAX_PORTS
operator|+
name|g
operator|*
name|CTL_MAX_PORTS
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|p
argument_list|,
name|pd
operator|->
name|relative_port_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|init_devid
operator|&&
name|g
operator|==
name|pg
condition|)
block|{
name|iid_len
operator|=
name|port
operator|->
name|init_devid
operator|->
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|pd
operator|->
name|initiator_transportid
argument_list|,
name|port
operator|->
name|init_devid
operator|->
name|data
argument_list|,
name|port
operator|->
name|init_devid
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
else|else
name|iid_len
operator|=
literal|0
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|iid_len
argument_list|,
name|pd
operator|->
name|initiator_transportid_length
argument_list|)
expr_stmt|;
name|pdc
operator|=
operator|(
expr|struct
name|scsi_vpd_port_designation_cont
operator|*
operator|)
operator|(
operator|&
name|pd
operator|->
name|initiator_transportid
index|[
name|iid_len
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|port_devid
operator|&&
name|g
operator|==
name|pg
condition|)
block|{
name|id_len
operator|=
name|port
operator|->
name|port_devid
operator|->
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|pdc
operator|->
name|target_port_descriptors
argument_list|,
name|port
operator|->
name|port_devid
operator|->
name|data
argument_list|,
name|port
operator|->
name|port_devid
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
else|else
name|id_len
operator|=
literal|0
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|id_len
argument_list|,
name|pdc
operator|->
name|target_port_descriptors_length
argument_list|)
expr_stmt|;
name|pd
operator|=
operator|(
expr|struct
name|scsi_vpd_port_designation
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|pdc
operator|->
name|target_port_descriptors
operator|+
name|id_len
operator|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|scsi_status
operator|=
name|SCSI_STATUS_OK
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_inquiry_evpd_block_limits
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|int
name|alloc_len
parameter_list|)
block|{
name|struct
name|scsi_vpd_block_limits
modifier|*
name|bl_ptr
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|int
name|bs
decl_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LUN
index|]
operator|.
name|ptr
expr_stmt|;
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|bl_ptr
argument_list|)
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|bl_ptr
operator|=
operator|(
expr|struct
name|scsi_vpd_block_limits
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
operator|*
name|bl_ptr
argument_list|)
operator|<
name|alloc_len
condition|)
block|{
name|ctsio
operator|->
name|residual
operator|=
name|alloc_len
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|bl_ptr
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|bl_ptr
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|bl_ptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctsio
operator|->
name|residual
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|alloc_len
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|alloc_len
expr_stmt|;
block|}
name|ctsio
operator|->
name|kern_data_resid
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
comment|/* 	 * The control device is always connected.  The disk device, on the 	 * other hand, may not be online all the time.  Need to change this 	 * to figure out whether the disk device is actually online or not. 	 */
if|if
condition|(
name|lun
operator|!=
name|NULL
condition|)
name|bl_ptr
operator|->
name|device
operator|=
operator|(
name|SID_QUAL_LU_CONNECTED
operator|<<
literal|5
operator|)
operator||
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
expr_stmt|;
else|else
name|bl_ptr
operator|->
name|device
operator|=
operator|(
name|SID_QUAL_LU_OFFLINE
operator|<<
literal|5
operator|)
operator||
name|T_DIRECT
expr_stmt|;
name|bl_ptr
operator|->
name|page_code
operator|=
name|SVPD_BLOCK_LIMITS
expr_stmt|;
name|scsi_ulto2b
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|bl_ptr
argument_list|)
operator|-
literal|4
argument_list|,
name|bl_ptr
operator|->
name|page_length
argument_list|)
expr_stmt|;
name|bl_ptr
operator|->
name|max_cmp_write_len
operator|=
literal|0xff
expr_stmt|;
name|scsi_ulto4b
argument_list|(
literal|0xffffffff
argument_list|,
name|bl_ptr
operator|->
name|max_txfer_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|!=
name|NULL
condition|)
block|{
name|bs
operator|=
name|lun
operator|->
name|be_lun
operator|->
name|blocksize
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|MAXPHYS
operator|/
name|bs
argument_list|,
name|bl_ptr
operator|->
name|opt_txfer_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|be_lun
operator|->
name|flags
operator|&
name|CTL_LUN_FLAG_UNMAP
condition|)
block|{
name|scsi_ulto4b
argument_list|(
literal|0xffffffff
argument_list|,
name|bl_ptr
operator|->
name|max_unmap_lba_cnt
argument_list|)
expr_stmt|;
name|scsi_ulto4b
argument_list|(
literal|0xffffffff
argument_list|,
name|bl_ptr
operator|->
name|max_unmap_blk_cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|be_lun
operator|->
name|pblockexp
operator|!=
literal|0
condition|)
block|{
name|scsi_ulto4b
argument_list|(
operator|(
literal|1
operator|<<
name|lun
operator|->
name|be_lun
operator|->
name|pblockexp
operator|)
argument_list|,
name|bl_ptr
operator|->
name|opt_unmap_grain
argument_list|)
expr_stmt|;
name|scsi_ulto4b
argument_list|(
literal|0x80000000
operator||
name|lun
operator|->
name|be_lun
operator|->
name|pblockoff
argument_list|,
name|bl_ptr
operator|->
name|unmap_grain_align
argument_list|)
expr_stmt|;
block|}
block|}
name|scsi_ulto4b
argument_list|(
name|lun
operator|->
name|be_lun
operator|->
name|atomicblock
argument_list|,
name|bl_ptr
operator|->
name|max_atomic_transfer_length
argument_list|)
expr_stmt|;
name|scsi_ulto4b
argument_list|(
literal|0
argument_list|,
name|bl_ptr
operator|->
name|atomic_alignment
argument_list|)
expr_stmt|;
name|scsi_ulto4b
argument_list|(
literal|0
argument_list|,
name|bl_ptr
operator|->
name|atomic_transfer_length_granularity
argument_list|)
expr_stmt|;
block|}
name|scsi_u64to8b
argument_list|(
name|UINT64_MAX
argument_list|,
name|bl_ptr
operator|->
name|max_write_same_length
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|scsi_status
operator|=
name|SCSI_STATUS_OK
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_inquiry_evpd_bdc
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|int
name|alloc_len
parameter_list|)
block|{
name|struct
name|scsi_vpd_block_device_characteristics
modifier|*
name|bdc_ptr
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LUN
index|]
operator|.
name|ptr
expr_stmt|;
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|bdc_ptr
argument_list|)
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|bdc_ptr
operator|=
operator|(
expr|struct
name|scsi_vpd_block_device_characteristics
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
operator|*
name|bdc_ptr
argument_list|)
operator|<
name|alloc_len
condition|)
block|{
name|ctsio
operator|->
name|residual
operator|=
name|alloc_len
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|bdc_ptr
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|bdc_ptr
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|bdc_ptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctsio
operator|->
name|residual
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|alloc_len
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|alloc_len
expr_stmt|;
block|}
name|ctsio
operator|->
name|kern_data_resid
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
comment|/* 	 * The control device is always connected.  The disk device, on the 	 * other hand, may not be online all the time.  Need to change this 	 * to figure out whether the disk device is actually online or not. 	 */
if|if
condition|(
name|lun
operator|!=
name|NULL
condition|)
name|bdc_ptr
operator|->
name|device
operator|=
operator|(
name|SID_QUAL_LU_CONNECTED
operator|<<
literal|5
operator|)
operator||
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
expr_stmt|;
else|else
name|bdc_ptr
operator|->
name|device
operator|=
operator|(
name|SID_QUAL_LU_OFFLINE
operator|<<
literal|5
operator|)
operator||
name|T_DIRECT
expr_stmt|;
name|bdc_ptr
operator|->
name|page_code
operator|=
name|SVPD_BDC
expr_stmt|;
name|scsi_ulto2b
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|bdc_ptr
argument_list|)
operator|-
literal|4
argument_list|,
name|bdc_ptr
operator|->
name|page_length
argument_list|)
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|SVPD_NON_ROTATING
argument_list|,
name|bdc_ptr
operator|->
name|medium_rotation_rate
argument_list|)
expr_stmt|;
name|bdc_ptr
operator|->
name|flags
operator|=
name|SVPD_FUAB
operator||
name|SVPD_VBULS
expr_stmt|;
name|ctsio
operator|->
name|scsi_status
operator|=
name|SCSI_STATUS_OK
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_inquiry_evpd_lbp
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|int
name|alloc_len
parameter_list|)
block|{
name|struct
name|scsi_vpd_logical_block_prov
modifier|*
name|lbp_ptr
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LUN
index|]
operator|.
name|ptr
expr_stmt|;
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|lbp_ptr
argument_list|)
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|lbp_ptr
operator|=
operator|(
expr|struct
name|scsi_vpd_logical_block_prov
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
operator|*
name|lbp_ptr
argument_list|)
operator|<
name|alloc_len
condition|)
block|{
name|ctsio
operator|->
name|residual
operator|=
name|alloc_len
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|lbp_ptr
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|lbp_ptr
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|lbp_ptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctsio
operator|->
name|residual
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|alloc_len
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|alloc_len
expr_stmt|;
block|}
name|ctsio
operator|->
name|kern_data_resid
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
comment|/* 	 * The control device is always connected.  The disk device, on the 	 * other hand, may not be online all the time.  Need to change this 	 * to figure out whether the disk device is actually online or not. 	 */
if|if
condition|(
name|lun
operator|!=
name|NULL
condition|)
name|lbp_ptr
operator|->
name|device
operator|=
operator|(
name|SID_QUAL_LU_CONNECTED
operator|<<
literal|5
operator|)
operator||
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
expr_stmt|;
else|else
name|lbp_ptr
operator|->
name|device
operator|=
operator|(
name|SID_QUAL_LU_OFFLINE
operator|<<
literal|5
operator|)
operator||
name|T_DIRECT
expr_stmt|;
name|lbp_ptr
operator|->
name|page_code
operator|=
name|SVPD_LBP
expr_stmt|;
name|scsi_ulto2b
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|lbp_ptr
argument_list|)
operator|-
literal|4
argument_list|,
name|lbp_ptr
operator|->
name|page_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|!=
name|NULL
operator|&&
name|lun
operator|->
name|be_lun
operator|->
name|flags
operator|&
name|CTL_LUN_FLAG_UNMAP
condition|)
block|{
name|lbp_ptr
operator|->
name|flags
operator|=
name|SVPD_LBP_UNMAP
operator||
name|SVPD_LBP_WS16
operator||
name|SVPD_LBP_WS10
operator||
name|SVPD_LBP_RZ
operator||
name|SVPD_LBP_ANC_SUP
expr_stmt|;
name|lbp_ptr
operator|->
name|prov_type
operator|=
name|SVPD_LBP_RESOURCE
expr_stmt|;
block|}
name|ctsio
operator|->
name|scsi_status
operator|=
name|SCSI_STATUS_OK
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_inquiry_evpd
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|scsi_inquiry
modifier|*
name|cdb
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|int
name|alloc_len
decl_stmt|,
name|retval
decl_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LUN
index|]
operator|.
name|ptr
expr_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_inquiry
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|retval
operator|=
name|CTL_RETVAL_COMPLETE
expr_stmt|;
name|alloc_len
operator|=
name|scsi_2btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cdb
operator|->
name|page_code
condition|)
block|{
case|case
name|SVPD_SUPPORTED_PAGES
case|:
name|retval
operator|=
name|ctl_inquiry_evpd_supported
argument_list|(
name|ctsio
argument_list|,
name|alloc_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVPD_UNIT_SERIAL_NUMBER
case|:
name|retval
operator|=
name|ctl_inquiry_evpd_serial
argument_list|(
name|ctsio
argument_list|,
name|alloc_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVPD_DEVICE_ID
case|:
name|retval
operator|=
name|ctl_inquiry_evpd_devid
argument_list|(
name|ctsio
argument_list|,
name|alloc_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVPD_EXTENDED_INQUIRY_DATA
case|:
name|retval
operator|=
name|ctl_inquiry_evpd_eid
argument_list|(
name|ctsio
argument_list|,
name|alloc_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVPD_MODE_PAGE_POLICY
case|:
name|retval
operator|=
name|ctl_inquiry_evpd_mpp
argument_list|(
name|ctsio
argument_list|,
name|alloc_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVPD_SCSI_PORTS
case|:
name|retval
operator|=
name|ctl_inquiry_evpd_scsi_ports
argument_list|(
name|ctsio
argument_list|,
name|alloc_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVPD_SCSI_TPC
case|:
name|retval
operator|=
name|ctl_inquiry_evpd_tpc
argument_list|(
name|ctsio
argument_list|,
name|alloc_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVPD_BLOCK_LIMITS
case|:
name|retval
operator|=
name|ctl_inquiry_evpd_block_limits
argument_list|(
name|ctsio
argument_list|,
name|alloc_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVPD_BDC
case|:
name|retval
operator|=
name|ctl_inquiry_evpd_bdc
argument_list|(
name|ctsio
argument_list|,
name|alloc_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVPD_LBP
case|:
name|retval
operator|=
name|ctl_inquiry_evpd_lbp
argument_list|(
name|ctsio
argument_list|,
name|alloc_len
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ctl_set_invalid_field
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|2
argument_list|,
comment|/*bit_valid*/
literal|0
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
name|retval
operator|=
name|CTL_RETVAL_COMPLETE
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_inquiry_std
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|scsi_inquiry_data
modifier|*
name|inq_ptr
decl_stmt|;
name|struct
name|scsi_inquiry
modifier|*
name|cdb
decl_stmt|;
name|struct
name|ctl_softc
modifier|*
name|ctl_softc
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|uint32_t
name|alloc_len
decl_stmt|,
name|data_len
decl_stmt|;
name|ctl_port_type
name|port_type
decl_stmt|;
name|ctl_softc
operator|=
name|control_softc
expr_stmt|;
comment|/* 	 * Figure out whether we're talking to a Fibre Channel port or not. 	 * We treat the ioctl front end, and any SCSI adapters, as packetized 	 * SCSI front ends. 	 */
name|port_type
operator|=
name|ctl_softc
operator|->
name|ctl_ports
index|[
name|ctl_port_idx
argument_list|(
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
argument_list|)
index|]
operator|->
name|port_type
expr_stmt|;
if|if
condition|(
name|port_type
operator|==
name|CTL_PORT_IOCTL
operator|||
name|port_type
operator|==
name|CTL_PORT_INTERNAL
condition|)
name|port_type
operator|=
name|CTL_PORT_SCSI
expr_stmt|;
name|lun
operator|=
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LUN
index|]
operator|.
name|ptr
expr_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_inquiry
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
name|alloc_len
operator|=
name|scsi_2btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
comment|/* 	 * We malloc the full inquiry data size here and fill it 	 * in.  If the user only asks for less, we'll give him 	 * that much. 	 */
name|data_len
operator|=
name|offsetof
argument_list|(
expr|struct
name|scsi_inquiry_data
argument_list|,
name|vendor_specific1
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|kern_data_ptr
operator|=
name|malloc
argument_list|(
name|data_len
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|inq_ptr
operator|=
operator|(
expr|struct
name|scsi_inquiry_data
operator|*
operator|)
name|ctsio
operator|->
name|kern_data_ptr
expr_stmt|;
name|ctsio
operator|->
name|kern_sg_entries
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_data_resid
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_rel_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|data_len
operator|<
name|alloc_len
condition|)
block|{
name|ctsio
operator|->
name|residual
operator|=
name|alloc_len
operator|-
name|data_len
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|data_len
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|data_len
expr_stmt|;
block|}
else|else
block|{
name|ctsio
operator|->
name|residual
operator|=
literal|0
expr_stmt|;
name|ctsio
operator|->
name|kern_data_len
operator|=
name|alloc_len
expr_stmt|;
name|ctsio
operator|->
name|kern_total_len
operator|=
name|alloc_len
expr_stmt|;
block|}
comment|/* 	 * If we have a LUN configured, report it as connected.  Otherwise, 	 * report that it is offline or no device is supported, depending  	 * on the value of inquiry_pq_no_lun. 	 * 	 * According to the spec (SPC-4 r34), the peripheral qualifier 	 * SID_QUAL_LU_OFFLINE (001b) is used in the following scenario: 	 * 	 * "A peripheral device having the specified peripheral device type  	 * is not connected to this logical unit. However, the device 	 * server is capable of supporting the specified peripheral device 	 * type on this logical unit." 	 * 	 * According to the same spec, the peripheral qualifier 	 * SID_QUAL_BAD_LU (011b) is used in this scenario: 	 * 	 * "The device server is not capable of supporting a peripheral 	 * device on this logical unit. For this peripheral qualifier the 	 * peripheral device type shall be set to 1Fh. All other peripheral 	 * device type values are reserved for this peripheral qualifier." 	 * 	 * Given the text, it would seem that we probably want to report that 	 * the LUN is offline here.  There is no LUN connected, but we can 	 * support a LUN at the given LUN number. 	 * 	 * In the real world, though, it sounds like things are a little 	 * different: 	 * 	 * - Linux, when presented with a LUN with the offline peripheral 	 *   qualifier, will create an sg driver instance for it.  So when 	 *   you attach it to CTL, you wind up with a ton of sg driver 	 *   instances.  (One for every LUN that Linux bothered to probe.) 	 *   Linux does this despite the fact that it issues a REPORT LUNs 	 *   to LUN 0 to get the inventory of supported LUNs. 	 * 	 * - There is other anecdotal evidence (from Emulex folks) about 	 *   arrays that use the offline peripheral qualifier for LUNs that 	 *   are on the "passive" path in an active/passive array. 	 * 	 * So the solution is provide a hopefully reasonable default 	 * (return bad/no LUN) and allow the user to change the behavior 	 * with a tunable/sysctl variable. 	 */
if|if
condition|(
name|lun
operator|!=
name|NULL
condition|)
name|inq_ptr
operator|->
name|device
operator|=
operator|(
name|SID_QUAL_LU_CONNECTED
operator|<<
literal|5
operator|)
operator||
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
expr_stmt|;
elseif|else
if|if
condition|(
name|ctl_softc
operator|->
name|inquiry_pq_no_lun
operator|==
literal|0
condition|)
name|inq_ptr
operator|->
name|device
operator|=
operator|(
name|SID_QUAL_LU_OFFLINE
operator|<<
literal|5
operator|)
operator||
name|T_DIRECT
expr_stmt|;
else|else
name|inq_ptr
operator|->
name|device
operator|=
operator|(
name|SID_QUAL_BAD_LU
operator|<<
literal|5
operator|)
operator||
name|T_NODEVICE
expr_stmt|;
comment|/* RMB in byte 2 is 0 */
name|inq_ptr
operator|->
name|version
operator|=
name|SCSI_REV_SPC4
expr_stmt|;
comment|/* 	 * According to SAM-3, even if a device only supports a single 	 * level of LUN addressing, it should still set the HISUP bit: 	 * 	 * 4.9.1 Logical unit numbers overview 	 * 	 * All logical unit number formats described in this standard are 	 * hierarchical in structure even when only a single level in that 	 * hierarchy is used. The HISUP bit shall be set to one in the 	 * standard INQUIRY data (see SPC-2) when any logical unit number 	 * format described in this standard is used.  Non-hierarchical 	 * formats are outside the scope of this standard. 	 * 	 * Therefore we set the HiSup bit here. 	 * 	 * The reponse format is 2, per SPC-3. 	 */
name|inq_ptr
operator|->
name|response_format
operator|=
name|SID_HiSup
operator||
literal|2
expr_stmt|;
name|inq_ptr
operator|->
name|additional_length
operator|=
name|data_len
operator|-
operator|(
name|offsetof
argument_list|(
expr|struct
name|scsi_inquiry_data
argument_list|,
name|additional_length
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"additional_length = %d\n"
operator|,
name|inq_ptr
operator|->
name|additional_length
operator|)
argument_list|)
expr_stmt|;
name|inq_ptr
operator|->
name|spc3_flags
operator|=
name|SPC3_SID_3PC
operator||
name|SPC3_SID_TPGS_IMPLICIT
expr_stmt|;
comment|/* 16 bit addressing */
if|if
condition|(
name|port_type
operator|==
name|CTL_PORT_SCSI
condition|)
name|inq_ptr
operator|->
name|spc2_flags
operator|=
name|SPC2_SID_ADDR16
expr_stmt|;
comment|/* XXX set the SID_MultiP bit here if we're actually going to 	   respond on multiple ports */
name|inq_ptr
operator|->
name|spc2_flags
operator||=
name|SPC2_SID_MultiP
expr_stmt|;
comment|/* 16 bit data bus, synchronous transfers */
if|if
condition|(
name|port_type
operator|==
name|CTL_PORT_SCSI
condition|)
name|inq_ptr
operator|->
name|flags
operator|=
name|SID_WBus16
operator||
name|SID_Sync
expr_stmt|;
comment|/* 	 * XXX KDM do we want to support tagged queueing on the control 	 * device at all? 	 */
if|if
condition|(
operator|(
name|lun
operator|==
name|NULL
operator|)
operator|||
operator|(
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
operator|!=
name|T_PROCESSOR
operator|)
condition|)
name|inq_ptr
operator|->
name|flags
operator||=
name|SID_CmdQue
expr_stmt|;
comment|/* 	 * Per SPC-3, unused bytes in ASCII strings are filled with spaces. 	 * We have 8 bytes for the vendor name, and 16 bytes for the device 	 * name and 4 bytes for the revision. 	 */
if|if
condition|(
name|lun
operator|==
name|NULL
operator|||
operator|(
name|val
operator|=
name|ctl_get_opt
argument_list|(
operator|&
name|lun
operator|->
name|be_lun
operator|->
name|options
argument_list|,
literal|"vendor"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|strncpy
argument_list|(
name|inq_ptr
operator|->
name|vendor
argument_list|,
name|CTL_VENDOR
argument_list|,
sizeof|sizeof
argument_list|(
name|inq_ptr
operator|->
name|vendor
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memset
argument_list|(
name|inq_ptr
operator|->
name|vendor
argument_list|,
literal|' '
argument_list|,
sizeof|sizeof
argument_list|(
name|inq_ptr
operator|->
name|vendor
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|inq_ptr
operator|->
name|vendor
argument_list|,
name|val
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|inq_ptr
operator|->
name|vendor
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lun
operator|==
name|NULL
condition|)
block|{
name|strncpy
argument_list|(
name|inq_ptr
operator|->
name|product
argument_list|,
name|CTL_DIRECT_PRODUCT
argument_list|,
sizeof|sizeof
argument_list|(
name|inq_ptr
operator|->
name|product
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|val
operator|=
name|ctl_get_opt
argument_list|(
operator|&
name|lun
operator|->
name|be_lun
operator|->
name|options
argument_list|,
literal|"product"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
switch|switch
condition|(
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
condition|)
block|{
case|case
name|T_DIRECT
case|:
name|strncpy
argument_list|(
name|inq_ptr
operator|->
name|product
argument_list|,
name|CTL_DIRECT_PRODUCT
argument_list|,
sizeof|sizeof
argument_list|(
name|inq_ptr
operator|->
name|product
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_PROCESSOR
case|:
name|strncpy
argument_list|(
name|inq_ptr
operator|->
name|product
argument_list|,
name|CTL_PROCESSOR_PRODUCT
argument_list|,
sizeof|sizeof
argument_list|(
name|inq_ptr
operator|->
name|product
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|strncpy
argument_list|(
name|inq_ptr
operator|->
name|product
argument_list|,
name|CTL_UNKNOWN_PRODUCT
argument_list|,
sizeof|sizeof
argument_list|(
name|inq_ptr
operator|->
name|product
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|memset
argument_list|(
name|inq_ptr
operator|->
name|product
argument_list|,
literal|' '
argument_list|,
sizeof|sizeof
argument_list|(
name|inq_ptr
operator|->
name|product
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|inq_ptr
operator|->
name|product
argument_list|,
name|val
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|inq_ptr
operator|->
name|product
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * XXX make this a macro somewhere so it automatically gets 	 * incremented when we make changes. 	 */
if|if
condition|(
name|lun
operator|==
name|NULL
operator|||
operator|(
name|val
operator|=
name|ctl_get_opt
argument_list|(
operator|&
name|lun
operator|->
name|be_lun
operator|->
name|options
argument_list|,
literal|"revision"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|strncpy
argument_list|(
name|inq_ptr
operator|->
name|revision
argument_list|,
literal|"0001"
argument_list|,
sizeof|sizeof
argument_list|(
name|inq_ptr
operator|->
name|revision
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memset
argument_list|(
name|inq_ptr
operator|->
name|revision
argument_list|,
literal|' '
argument_list|,
sizeof|sizeof
argument_list|(
name|inq_ptr
operator|->
name|revision
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|inq_ptr
operator|->
name|revision
argument_list|,
name|val
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|inq_ptr
operator|->
name|revision
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * For parallel SCSI, we support double transition and single 	 * transition clocking.  We also support QAS (Quick Arbitration 	 * and Selection) and Information Unit transfers on both the 	 * control and array devices. 	 */
if|if
condition|(
name|port_type
operator|==
name|CTL_PORT_SCSI
condition|)
name|inq_ptr
operator|->
name|spi3data
operator|=
name|SID_SPI_CLOCK_DT_ST
operator||
name|SID_SPI_QAS
operator||
name|SID_SPI_IUS
expr_stmt|;
comment|/* SAM-5 (no version claimed) */
name|scsi_ulto2b
argument_list|(
literal|0x00A0
argument_list|,
name|inq_ptr
operator|->
name|version1
argument_list|)
expr_stmt|;
comment|/* SPC-4 (no version claimed) */
name|scsi_ulto2b
argument_list|(
literal|0x0460
argument_list|,
name|inq_ptr
operator|->
name|version2
argument_list|)
expr_stmt|;
if|if
condition|(
name|port_type
operator|==
name|CTL_PORT_FC
condition|)
block|{
comment|/* FCP-2 ANSI INCITS.350:2003 */
name|scsi_ulto2b
argument_list|(
literal|0x0917
argument_list|,
name|inq_ptr
operator|->
name|version3
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|port_type
operator|==
name|CTL_PORT_SCSI
condition|)
block|{
comment|/* SPI-4 ANSI INCITS.362:200x */
name|scsi_ulto2b
argument_list|(
literal|0x0B56
argument_list|,
name|inq_ptr
operator|->
name|version3
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|port_type
operator|==
name|CTL_PORT_ISCSI
condition|)
block|{
comment|/* iSCSI (no version claimed) */
name|scsi_ulto2b
argument_list|(
literal|0x0960
argument_list|,
name|inq_ptr
operator|->
name|version3
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|port_type
operator|==
name|CTL_PORT_SAS
condition|)
block|{
comment|/* SAS (no version claimed) */
name|scsi_ulto2b
argument_list|(
literal|0x0BE0
argument_list|,
name|inq_ptr
operator|->
name|version3
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lun
operator|==
name|NULL
condition|)
block|{
comment|/* SBC-4 (no version claimed) */
name|scsi_ulto2b
argument_list|(
literal|0x0600
argument_list|,
name|inq_ptr
operator|->
name|version4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
condition|)
block|{
case|case
name|T_DIRECT
case|:
comment|/* SBC-4 (no version claimed) */
name|scsi_ulto2b
argument_list|(
literal|0x0600
argument_list|,
name|inq_ptr
operator|->
name|version4
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_PROCESSOR
case|:
default|default:
break|break;
block|}
block|}
name|ctsio
operator|->
name|scsi_status
operator|=
name|SCSI_STATUS_OK
expr_stmt|;
if|if
condition|(
name|ctsio
operator|->
name|kern_data_len
operator|>
literal|0
condition|)
block|{
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ALLOCATED
expr_stmt|;
name|ctsio
operator|->
name|be_move_done
operator|=
name|ctl_config_move_done
expr_stmt|;
name|ctl_datamove
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctsio
operator|->
name|io_hdr
operator|.
name|status
operator|=
name|CTL_SUCCESS
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctl_inquiry
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|scsi_inquiry
modifier|*
name|cdb
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_inquiry\n"
operator|)
argument_list|)
expr_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_inquiry
operator|*
operator|)
name|ctsio
operator|->
name|cdb
expr_stmt|;
if|if
condition|(
name|cdb
operator|->
name|byte2
operator|&
name|SI_EVPD
condition|)
name|retval
operator|=
name|ctl_inquiry_evpd
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cdb
operator|->
name|page_code
operator|==
literal|0
condition|)
name|retval
operator|=
name|ctl_inquiry_std
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
else|else
block|{
name|ctl_set_invalid_field
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|2
argument_list|,
comment|/*bit_valid*/
literal|0
argument_list|,
comment|/*bit*/
literal|0
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * For known CDB types, parse the LBA and length.  */
end_comment

begin_function
specifier|static
name|int
name|ctl_get_lba_len
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|,
name|uint64_t
modifier|*
name|lba
parameter_list|,
name|uint64_t
modifier|*
name|len
parameter_list|)
block|{
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|io_type
operator|!=
name|CTL_IO_SCSI
condition|)
return|return
operator|(
literal|1
operator|)
return|;
switch|switch
condition|(
name|io
operator|->
name|scsiio
operator|.
name|cdb
index|[
literal|0
index|]
condition|)
block|{
case|case
name|COMPARE_AND_WRITE
case|:
block|{
name|struct
name|scsi_compare_and_write
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_compare_and_write
operator|*
operator|)
name|io
operator|->
name|scsiio
operator|.
name|cdb
expr_stmt|;
operator|*
name|lba
operator|=
name|scsi_8btou64
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
operator|*
name|len
operator|=
name|cdb
operator|->
name|length
expr_stmt|;
break|break;
block|}
case|case
name|READ_6
case|:
case|case
name|WRITE_6
case|:
block|{
name|struct
name|scsi_rw_6
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_rw_6
operator|*
operator|)
name|io
operator|->
name|scsiio
operator|.
name|cdb
expr_stmt|;
operator|*
name|lba
operator|=
name|scsi_3btoul
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
comment|/* only 5 bits are valid in the most significant address byte */
operator|*
name|lba
operator|&=
literal|0x1fffff
expr_stmt|;
operator|*
name|len
operator|=
name|cdb
operator|->
name|length
expr_stmt|;
break|break;
block|}
case|case
name|READ_10
case|:
case|case
name|WRITE_10
case|:
block|{
name|struct
name|scsi_rw_10
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_rw_10
operator|*
operator|)
name|io
operator|->
name|scsiio
operator|.
name|cdb
expr_stmt|;
operator|*
name|lba
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
operator|*
name|len
operator|=
name|scsi_2btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|WRITE_VERIFY_10
case|:
block|{
name|struct
name|scsi_write_verify_10
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_write_verify_10
operator|*
operator|)
name|io
operator|->
name|scsiio
operator|.
name|cdb
expr_stmt|;
operator|*
name|lba
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
operator|*
name|len
operator|=
name|scsi_2btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|READ_12
case|:
case|case
name|WRITE_12
case|:
block|{
name|struct
name|scsi_rw_12
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_rw_12
operator|*
operator|)
name|io
operator|->
name|scsiio
operator|.
name|cdb
expr_stmt|;
operator|*
name|lba
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
operator|*
name|len
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|WRITE_VERIFY_12
case|:
block|{
name|struct
name|scsi_write_verify_12
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_write_verify_12
operator|*
operator|)
name|io
operator|->
name|scsiio
operator|.
name|cdb
expr_stmt|;
operator|*
name|lba
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
operator|*
name|len
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|READ_16
case|:
case|case
name|WRITE_16
case|:
case|case
name|WRITE_ATOMIC_16
case|:
block|{
name|struct
name|scsi_rw_16
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_rw_16
operator|*
operator|)
name|io
operator|->
name|scsiio
operator|.
name|cdb
expr_stmt|;
operator|*
name|lba
operator|=
name|scsi_8btou64
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
operator|*
name|len
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|WRITE_VERIFY_16
case|:
block|{
name|struct
name|scsi_write_verify_16
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_write_verify_16
operator|*
operator|)
name|io
operator|->
name|scsiio
operator|.
name|cdb
expr_stmt|;
operator|*
name|lba
operator|=
name|scsi_8btou64
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
operator|*
name|len
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|WRITE_SAME_10
case|:
block|{
name|struct
name|scsi_write_same_10
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_write_same_10
operator|*
operator|)
name|io
operator|->
name|scsiio
operator|.
name|cdb
expr_stmt|;
operator|*
name|lba
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
operator|*
name|len
operator|=
name|scsi_2btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|WRITE_SAME_16
case|:
block|{
name|struct
name|scsi_write_same_16
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_write_same_16
operator|*
operator|)
name|io
operator|->
name|scsiio
operator|.
name|cdb
expr_stmt|;
operator|*
name|lba
operator|=
name|scsi_8btou64
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
operator|*
name|len
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|VERIFY_10
case|:
block|{
name|struct
name|scsi_verify_10
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_verify_10
operator|*
operator|)
name|io
operator|->
name|scsiio
operator|.
name|cdb
expr_stmt|;
operator|*
name|lba
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
operator|*
name|len
operator|=
name|scsi_2btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|VERIFY_12
case|:
block|{
name|struct
name|scsi_verify_12
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_verify_12
operator|*
operator|)
name|io
operator|->
name|scsiio
operator|.
name|cdb
expr_stmt|;
operator|*
name|lba
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
operator|*
name|len
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|VERIFY_16
case|:
block|{
name|struct
name|scsi_verify_16
modifier|*
name|cdb
decl_stmt|;
name|cdb
operator|=
operator|(
expr|struct
name|scsi_verify_16
operator|*
operator|)
name|io
operator|->
name|scsiio
operator|.
name|cdb
expr_stmt|;
operator|*
name|lba
operator|=
name|scsi_8btou64
argument_list|(
name|cdb
operator|->
name|addr
argument_list|)
expr_stmt|;
operator|*
name|len
operator|=
name|scsi_4btoul
argument_list|(
name|cdb
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|UNMAP
case|:
block|{
operator|*
name|lba
operator|=
literal|0
expr_stmt|;
operator|*
name|len
operator|=
name|UINT64_MAX
expr_stmt|;
break|break;
block|}
default|default:
return|return
operator|(
literal|1
operator|)
return|;
break|break;
comment|/* NOTREACHED */
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ctl_action
name|ctl_extent_check_lba
parameter_list|(
name|uint64_t
name|lba1
parameter_list|,
name|uint64_t
name|len1
parameter_list|,
name|uint64_t
name|lba2
parameter_list|,
name|uint64_t
name|len2
parameter_list|)
block|{
name|uint64_t
name|endlba1
decl_stmt|,
name|endlba2
decl_stmt|;
name|endlba1
operator|=
name|lba1
operator|+
name|len1
operator|-
literal|1
expr_stmt|;
name|endlba2
operator|=
name|lba2
operator|+
name|len2
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|endlba1
operator|<
name|lba2
operator|)
operator|||
operator|(
name|endlba2
operator|<
name|lba1
operator|)
condition|)
return|return
operator|(
name|CTL_ACTION_PASS
operator|)
return|;
else|else
return|return
operator|(
name|CTL_ACTION_BLOCK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_extent_check_unmap
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|,
name|uint64_t
name|lba2
parameter_list|,
name|uint64_t
name|len2
parameter_list|)
block|{
name|struct
name|ctl_ptr_len_flags
modifier|*
name|ptrlen
decl_stmt|;
name|struct
name|scsi_unmap_desc
modifier|*
name|buf
decl_stmt|,
modifier|*
name|end
decl_stmt|,
modifier|*
name|range
decl_stmt|;
name|uint64_t
name|lba
decl_stmt|;
name|uint32_t
name|len
decl_stmt|;
comment|/* If not UNMAP -- go other way. */
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|io_type
operator|!=
name|CTL_IO_SCSI
operator|||
name|io
operator|->
name|scsiio
operator|.
name|cdb
index|[
literal|0
index|]
operator|!=
name|UNMAP
condition|)
return|return
operator|(
name|CTL_ACTION_ERROR
operator|)
return|;
comment|/* If UNMAP without data -- block and wait for data. */
name|ptrlen
operator|=
operator|(
expr|struct
name|ctl_ptr_len_flags
operator|*
operator|)
operator|&
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LBA_LEN
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ALLOCATED
operator|)
operator|==
literal|0
operator|||
name|ptrlen
operator|->
name|ptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|CTL_ACTION_BLOCK
operator|)
return|;
comment|/* UNMAP with data -- check for collision. */
name|buf
operator|=
operator|(
expr|struct
name|scsi_unmap_desc
operator|*
operator|)
name|ptrlen
operator|->
name|ptr
expr_stmt|;
name|end
operator|=
name|buf
operator|+
name|ptrlen
operator|->
name|len
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|range
operator|=
name|buf
init|;
name|range
operator|<
name|end
condition|;
name|range
operator|++
control|)
block|{
name|lba
operator|=
name|scsi_8btou64
argument_list|(
name|range
operator|->
name|lba
argument_list|)
expr_stmt|;
name|len
operator|=
name|scsi_4btoul
argument_list|(
name|range
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lba
operator|<
name|lba2
operator|+
name|len2
operator|)
operator|&&
operator|(
name|lba
operator|+
name|len
operator|>
name|lba2
operator|)
condition|)
return|return
operator|(
name|CTL_ACTION_BLOCK
operator|)
return|;
block|}
return|return
operator|(
name|CTL_ACTION_PASS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ctl_action
name|ctl_extent_check
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io1
parameter_list|,
name|union
name|ctl_io
modifier|*
name|io2
parameter_list|)
block|{
name|uint64_t
name|lba1
decl_stmt|,
name|lba2
decl_stmt|;
name|uint64_t
name|len1
decl_stmt|,
name|len2
decl_stmt|;
name|int
name|retval
decl_stmt|;
if|if
condition|(
name|ctl_get_lba_len
argument_list|(
name|io1
argument_list|,
operator|&
name|lba1
argument_list|,
operator|&
name|len1
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|CTL_ACTION_ERROR
operator|)
return|;
name|retval
operator|=
name|ctl_extent_check_unmap
argument_list|(
name|io2
argument_list|,
name|lba1
argument_list|,
name|len1
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|CTL_ACTION_ERROR
condition|)
return|return
operator|(
name|retval
operator|)
return|;
if|if
condition|(
name|ctl_get_lba_len
argument_list|(
name|io2
argument_list|,
operator|&
name|lba2
argument_list|,
operator|&
name|len2
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|CTL_ACTION_ERROR
operator|)
return|;
return|return
operator|(
name|ctl_extent_check_lba
argument_list|(
name|lba1
argument_list|,
name|len1
argument_list|,
name|lba2
argument_list|,
name|len2
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ctl_action
name|ctl_check_for_blockage
parameter_list|(
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|,
name|union
name|ctl_io
modifier|*
name|pending_io
parameter_list|,
name|union
name|ctl_io
modifier|*
name|ooa_io
parameter_list|)
block|{
specifier|const
name|struct
name|ctl_cmd_entry
modifier|*
name|pending_entry
decl_stmt|,
modifier|*
name|ooa_entry
decl_stmt|;
name|ctl_serialize_action
modifier|*
name|serialize_row
decl_stmt|;
comment|/* 	 * The initiator attempted multiple untagged commands at the same 	 * time.  Can't do that. 	 */
if|if
condition|(
operator|(
name|pending_io
operator|->
name|scsiio
operator|.
name|tag_type
operator|==
name|CTL_TAG_UNTAGGED
operator|)
operator|&&
operator|(
name|ooa_io
operator|->
name|scsiio
operator|.
name|tag_type
operator|==
name|CTL_TAG_UNTAGGED
operator|)
operator|&&
operator|(
operator|(
name|pending_io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
operator|==
name|ooa_io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
operator|)
operator|&&
operator|(
name|pending_io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|initid
operator|.
name|id
operator|==
name|ooa_io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|initid
operator|.
name|id
operator|)
operator|)
operator|&&
operator|(
operator|(
name|ooa_io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ABORT
operator|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|CTL_ACTION_OVERLAP
operator|)
return|;
comment|/* 	 * The initiator attempted to send multiple tagged commands with 	 * the same ID.  (It's fine if different initiators have the same 	 * tag ID.) 	 * 	 * Even if all of those conditions are true, we don't kill the I/O 	 * if the command ahead of us has been aborted.  We won't end up 	 * sending it to the FETD, and it's perfectly legal to resend a 	 * command with the same tag number as long as the previous 	 * instance of this tag number has been aborted somehow. 	 */
if|if
condition|(
operator|(
name|pending_io
operator|->
name|scsiio
operator|.
name|tag_type
operator|!=
name|CTL_TAG_UNTAGGED
operator|)
operator|&&
operator|(
name|ooa_io
operator|->
name|scsiio
operator|.
name|tag_type
operator|!=
name|CTL_TAG_UNTAGGED
operator|)
operator|&&
operator|(
name|pending_io
operator|->
name|scsiio
operator|.
name|tag_num
operator|==
name|ooa_io
operator|->
name|scsiio
operator|.
name|tag_num
operator|)
operator|&&
operator|(
operator|(
name|pending_io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
operator|==
name|ooa_io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
operator|)
operator|&&
operator|(
name|pending_io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|initid
operator|.
name|id
operator|==
name|ooa_io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|initid
operator|.
name|id
operator|)
operator|)
operator|&&
operator|(
operator|(
name|ooa_io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ABORT
operator|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|CTL_ACTION_OVERLAP_TAG
operator|)
return|;
comment|/* 	 * If we get a head of queue tag, SAM-3 says that we should 	 * immediately execute it. 	 * 	 * What happens if this command would normally block for some other 	 * reason?  e.g. a request sense with a head of queue tag 	 * immediately after a write.  Normally that would block, but this 	 * will result in its getting executed immediately... 	 * 	 * We currently return "pass" instead of "skip", so we'll end up 	 * going through the rest of the queue to check for overlapped tags. 	 * 	 * XXX KDM check for other types of blockage first?? 	 */
if|if
condition|(
name|pending_io
operator|->
name|scsiio
operator|.
name|tag_type
operator|==
name|CTL_TAG_HEAD_OF_QUEUE
condition|)
return|return
operator|(
name|CTL_ACTION_PASS
operator|)
return|;
comment|/* 	 * Ordered tags have to block until all items ahead of them 	 * have completed.  If we get called with an ordered tag, we always 	 * block, if something else is ahead of us in the queue. 	 */
if|if
condition|(
name|pending_io
operator|->
name|scsiio
operator|.
name|tag_type
operator|==
name|CTL_TAG_ORDERED
condition|)
return|return
operator|(
name|CTL_ACTION_BLOCK
operator|)
return|;
comment|/* 	 * Simple tags get blocked until all head of queue and ordered tags 	 * ahead of them have completed.  I'm lumping untagged commands in 	 * with simple tags here.  XXX KDM is that the right thing to do? 	 */
if|if
condition|(
operator|(
operator|(
name|pending_io
operator|->
name|scsiio
operator|.
name|tag_type
operator|==
name|CTL_TAG_UNTAGGED
operator|)
operator|||
operator|(
name|pending_io
operator|->
name|scsiio
operator|.
name|tag_type
operator|==
name|CTL_TAG_SIMPLE
operator|)
operator|)
operator|&&
operator|(
operator|(
name|ooa_io
operator|->
name|scsiio
operator|.
name|tag_type
operator|==
name|CTL_TAG_HEAD_OF_QUEUE
operator|)
operator|||
operator|(
name|ooa_io
operator|->
name|scsiio
operator|.
name|tag_type
operator|==
name|CTL_TAG_ORDERED
operator|)
operator|)
condition|)
return|return
operator|(
name|CTL_ACTION_BLOCK
operator|)
return|;
name|pending_entry
operator|=
name|ctl_get_cmd_entry
argument_list|(
operator|&
name|pending_io
operator|->
name|scsiio
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ooa_entry
operator|=
name|ctl_get_cmd_entry
argument_list|(
operator|&
name|ooa_io
operator|->
name|scsiio
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|serialize_row
operator|=
name|ctl_serialize_table
index|[
name|ooa_entry
operator|->
name|seridx
index|]
expr_stmt|;
switch|switch
condition|(
name|serialize_row
index|[
name|pending_entry
operator|->
name|seridx
index|]
condition|)
block|{
case|case
name|CTL_SER_BLOCK
case|:
return|return
operator|(
name|CTL_ACTION_BLOCK
operator|)
return|;
case|case
name|CTL_SER_EXTENT
case|:
return|return
operator|(
name|ctl_extent_check
argument_list|(
name|pending_io
argument_list|,
name|ooa_io
argument_list|)
operator|)
return|;
case|case
name|CTL_SER_EXTENTOPT
case|:
if|if
condition|(
operator|(
name|lun
operator|->
name|mode_pages
operator|.
name|control_page
index|[
name|CTL_PAGE_CURRENT
index|]
operator|.
name|queue_flags
operator|&
name|SCP_QUEUE_ALG_MASK
operator|)
operator|!=
name|SCP_QUEUE_ALG_UNRESTRICTED
condition|)
return|return
operator|(
name|ctl_extent_check
argument_list|(
name|pending_io
argument_list|,
name|ooa_io
argument_list|)
operator|)
return|;
comment|/* FALLTHROUGH */
case|case
name|CTL_SER_PASS
case|:
return|return
operator|(
name|CTL_ACTION_PASS
operator|)
return|;
case|case
name|CTL_SER_BLOCKOPT
case|:
if|if
condition|(
operator|(
name|lun
operator|->
name|mode_pages
operator|.
name|control_page
index|[
name|CTL_PAGE_CURRENT
index|]
operator|.
name|queue_flags
operator|&
name|SCP_QUEUE_ALG_MASK
operator|)
operator|!=
name|SCP_QUEUE_ALG_UNRESTRICTED
condition|)
return|return
operator|(
name|CTL_ACTION_BLOCK
operator|)
return|;
return|return
operator|(
name|CTL_ACTION_PASS
operator|)
return|;
case|case
name|CTL_SER_SKIP
case|:
return|return
operator|(
name|CTL_ACTION_SKIP
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"invalid serialization value %d"
argument_list|,
name|serialize_row
index|[
name|pending_entry
operator|->
name|seridx
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|CTL_ACTION_ERROR
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check for blockage or overlaps against the OOA (Order Of Arrival) queue.  * Assumptions:  * - pending_io is generally either incoming, or on the blocked queue  * - starting I/O is the I/O we want to start the check with.  */
end_comment

begin_function
specifier|static
name|ctl_action
name|ctl_check_ooa
parameter_list|(
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|,
name|union
name|ctl_io
modifier|*
name|pending_io
parameter_list|,
name|union
name|ctl_io
modifier|*
name|starting_io
parameter_list|)
block|{
name|union
name|ctl_io
modifier|*
name|ooa_io
decl_stmt|;
name|ctl_action
name|action
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * Run back along the OOA queue, starting with the current 	 * blocked I/O and going through every I/O before it on the 	 * queue.  If starting_io is NULL, we'll just end up returning 	 * CTL_ACTION_PASS. 	 */
for|for
control|(
name|ooa_io
operator|=
name|starting_io
init|;
name|ooa_io
operator|!=
name|NULL
condition|;
name|ooa_io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|TAILQ_PREV
argument_list|(
operator|&
name|ooa_io
operator|->
name|io_hdr
argument_list|,
name|ctl_ooaq
argument_list|,
name|ooa_links
argument_list|)
control|)
block|{
comment|/* 		 * This routine just checks to see whether 		 * cur_blocked is blocked by ooa_io, which is ahead 		 * of it in the queue.  It doesn't queue/dequeue 		 * cur_blocked. 		 */
name|action
operator|=
name|ctl_check_for_blockage
argument_list|(
name|lun
argument_list|,
name|pending_io
argument_list|,
name|ooa_io
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|CTL_ACTION_BLOCK
case|:
case|case
name|CTL_ACTION_OVERLAP
case|:
case|case
name|CTL_ACTION_OVERLAP_TAG
case|:
case|case
name|CTL_ACTION_SKIP
case|:
case|case
name|CTL_ACTION_ERROR
case|:
return|return
operator|(
name|action
operator|)
return|;
break|break;
comment|/* NOTREACHED */
case|case
name|CTL_ACTION_PASS
case|:
break|break;
default|default:
name|panic
argument_list|(
literal|"invalid action %d"
argument_list|,
name|action
argument_list|)
expr_stmt|;
break|break;
comment|/* NOTREACHED */
block|}
block|}
return|return
operator|(
name|CTL_ACTION_PASS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Assumptions:  * - An I/O has just completed, and has been removed from the per-LUN OOA  *   queue, so some items on the blocked queue may now be unblocked.  */
end_comment

begin_function
specifier|static
name|int
name|ctl_check_blocked
parameter_list|(
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|)
block|{
name|union
name|ctl_io
modifier|*
name|cur_blocked
decl_stmt|,
modifier|*
name|next_blocked
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * Run forward from the head of the blocked queue, checking each 	 * entry against the I/Os prior to it on the OOA queue to see if 	 * there is still any blockage. 	 * 	 * We cannot use the TAILQ_FOREACH() macro, because it can't deal 	 * with our removing a variable on it while it is traversing the 	 * list. 	 */
for|for
control|(
name|cur_blocked
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|TAILQ_FIRST
argument_list|(
operator|&
name|lun
operator|->
name|blocked_queue
argument_list|)
init|;
name|cur_blocked
operator|!=
name|NULL
condition|;
name|cur_blocked
operator|=
name|next_blocked
control|)
block|{
name|union
name|ctl_io
modifier|*
name|prev_ooa
decl_stmt|;
name|ctl_action
name|action
decl_stmt|;
name|next_blocked
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|TAILQ_NEXT
argument_list|(
operator|&
name|cur_blocked
operator|->
name|io_hdr
argument_list|,
name|blocked_links
argument_list|)
expr_stmt|;
name|prev_ooa
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|TAILQ_PREV
argument_list|(
operator|&
name|cur_blocked
operator|->
name|io_hdr
argument_list|,
name|ctl_ooaq
argument_list|,
name|ooa_links
argument_list|)
expr_stmt|;
comment|/* 		 * If cur_blocked happens to be the first item in the OOA 		 * queue now, prev_ooa will be NULL, and the action 		 * returned will just be CTL_ACTION_PASS. 		 */
name|action
operator|=
name|ctl_check_ooa
argument_list|(
name|lun
argument_list|,
name|cur_blocked
argument_list|,
name|prev_ooa
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|CTL_ACTION_BLOCK
case|:
comment|/* Nothing to do here, still blocked */
break|break;
case|case
name|CTL_ACTION_OVERLAP
case|:
case|case
name|CTL_ACTION_OVERLAP_TAG
case|:
comment|/* 			 * This shouldn't happen!  In theory we've already 			 * checked this command for overlap... 			 */
break|break;
case|case
name|CTL_ACTION_PASS
case|:
case|case
name|CTL_ACTION_SKIP
case|:
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
decl_stmt|;
specifier|const
name|struct
name|ctl_cmd_entry
modifier|*
name|entry
decl_stmt|;
name|uint32_t
name|initidx
decl_stmt|;
name|int
name|isc_retval
decl_stmt|;
comment|/* 			 * The skip case shouldn't happen, this transaction 			 * should have never made it onto the blocked queue. 			 */
comment|/* 			 * This I/O is no longer blocked, we can remove it 			 * from the blocked queue.  Since this is a TAILQ 			 * (doubly linked list), we can do O(1) removals 			 * from any place on the list. 			 */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|lun
operator|->
name|blocked_queue
argument_list|,
operator|&
name|cur_blocked
operator|->
name|io_hdr
argument_list|,
name|blocked_links
argument_list|)
expr_stmt|;
name|cur_blocked
operator|->
name|io_hdr
operator|.
name|flags
operator|&=
operator|~
name|CTL_FLAG_BLOCKED
expr_stmt|;
if|if
condition|(
name|cur_blocked
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_FROM_OTHER_SC
condition|)
block|{
comment|/* 				 * Need to send IO back to original side to 				 * run 				 */
name|union
name|ctl_ha_msg
name|msg_info
decl_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|original_sc
operator|=
name|cur_blocked
operator|->
name|io_hdr
operator|.
name|original_sc
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|serializing_sc
operator|=
name|cur_blocked
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_R2R
expr_stmt|;
if|if
condition|(
operator|(
name|isc_retval
operator|=
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|msg_info
argument_list|,
sizeof|sizeof
argument_list|(
name|msg_info
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|>
name|CTL_HA_STATUS_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"CTL:Check Blocked error from "
literal|"ctl_ha_msg_send %d\n"
argument_list|,
name|isc_retval
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|entry
operator|=
name|ctl_get_cmd_entry
argument_list|(
operator|&
name|cur_blocked
operator|->
name|scsiio
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|softc
operator|=
name|control_softc
expr_stmt|;
name|initidx
operator|=
name|ctl_get_initindex
argument_list|(
operator|&
name|cur_blocked
operator|->
name|io_hdr
operator|.
name|nexus
argument_list|)
expr_stmt|;
comment|/* 			 * Check this I/O for LUN state changes that may 			 * have happened while this command was blocked. 			 * The LUN state may have been changed by a command 			 * ahead of us in the queue, so we need to re-check 			 * for any states that can be caused by SCSI 			 * commands. 			 */
if|if
condition|(
name|ctl_scsiio_lun_check
argument_list|(
name|softc
argument_list|,
name|lun
argument_list|,
name|entry
argument_list|,
operator|&
name|cur_blocked
operator|->
name|scsiio
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cur_blocked
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_IS_WAS_ON_RTR
expr_stmt|;
name|ctl_enqueue_rtr
argument_list|(
name|cur_blocked
argument_list|)
expr_stmt|;
block|}
else|else
name|ctl_done
argument_list|(
name|cur_blocked
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
comment|/* 			 * This probably shouldn't happen -- we shouldn't 			 * get CTL_ACTION_ERROR, or anything else. 			 */
break|break;
block|}
block|}
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This routine (with one exception) checks LUN flags that can be set by  * commands ahead of us in the OOA queue.  These flags have to be checked  * when a command initially comes in, and when we pull a command off the  * blocked queue and are preparing to execute it.  The reason we have to  * check these flags for commands on the blocked queue is that the LUN  * state may have been changed by a command ahead of us while we're on the  * blocked queue.  *  * Ordering is somewhat important with these checks, so please pay  * careful attention to the placement of any new checks.  */
end_comment

begin_function
specifier|static
name|int
name|ctl_scsiio_lun_check
parameter_list|(
name|struct
name|ctl_softc
modifier|*
name|ctl_softc
parameter_list|,
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|,
specifier|const
name|struct
name|ctl_cmd_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|uint32_t
name|residx
decl_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * If this shelf is a secondary shelf controller, we have to reject 	 * any media access commands. 	 */
if|#
directive|if
literal|0
comment|/* No longer needed for HA */
block|if (((ctl_softc->flags& CTL_FLAG_MASTER_SHELF) == 0)&& ((entry->flags& CTL_CMD_FLAG_OK_ON_SECONDARY) == 0)) { 		ctl_set_lun_standby(ctsio); 		retval = 1; 		goto bailout; 	}
endif|#
directive|endif
if|if
condition|(
name|entry
operator|->
name|pattern
operator|&
name|CTL_LUN_PAT_WRITE
condition|)
block|{
if|if
condition|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_READONLY
condition|)
block|{
name|ctl_set_sense
argument_list|(
name|ctsio
argument_list|,
comment|/*current_error*/
literal|1
argument_list|,
comment|/*sense_key*/
name|SSD_KEY_DATA_PROTECT
argument_list|,
comment|/*asc*/
literal|0x27
argument_list|,
comment|/*ascq*/
literal|0x01
argument_list|,
name|SSD_ELEM_NONE
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
operator|(
name|lun
operator|->
name|mode_pages
operator|.
name|control_page
index|[
name|CTL_PAGE_CURRENT
index|]
operator|.
name|eca_and_aen
operator|&
name|SCP_SWP
operator|)
operator|!=
literal|0
condition|)
block|{
name|ctl_set_sense
argument_list|(
name|ctsio
argument_list|,
comment|/*current_error*/
literal|1
argument_list|,
comment|/*sense_key*/
name|SSD_KEY_DATA_PROTECT
argument_list|,
comment|/*asc*/
literal|0x27
argument_list|,
comment|/*ascq*/
literal|0x02
argument_list|,
name|SSD_ELEM_NONE
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
block|}
comment|/* 	 * Check for a reservation conflict.  If this command isn't allowed 	 * even on reserved LUNs, and if this initiator isn't the one who 	 * reserved us, reject the command with a reservation conflict. 	 */
name|residx
operator|=
name|ctl_get_resindex
argument_list|(
operator|&
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_RESERVED
operator|)
operator|&&
operator|(
operator|(
name|entry
operator|->
name|flags
operator|&
name|CTL_CMD_FLAG_ALLOW_ON_RESV
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|lun
operator|->
name|res_idx
operator|!=
name|residx
condition|)
block|{
name|ctsio
operator|->
name|scsi_status
operator|=
name|SCSI_STATUS_RESERV_CONFLICT
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|status
operator|=
name|CTL_SCSI_ERROR
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
block|}
if|if
condition|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_PR_RESERVED
operator|)
operator|&&
operator|(
operator|(
name|entry
operator|->
name|flags
operator|&
name|CTL_CMD_FLAG_ALLOW_ON_PR_RESV
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * if we aren't registered or it's a res holder type 		 * reservation and this isn't the res holder then set a 		 * conflict. 		 * NOTE: Commands which might be allowed on write exclusive 		 * type reservations are checked in the particular command 		 * for a conflict. Read and SSU are the only ones. 		 */
if|if
condition|(
name|lun
operator|->
name|pr_keys
index|[
name|residx
index|]
operator|==
literal|0
operator|||
operator|(
name|residx
operator|!=
name|lun
operator|->
name|pr_res_idx
operator|&&
name|lun
operator|->
name|res_type
operator|<
literal|4
operator|)
condition|)
block|{
name|ctsio
operator|->
name|scsi_status
operator|=
name|SCSI_STATUS_RESERV_CONFLICT
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|status
operator|=
name|CTL_SCSI_ERROR
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
block|}
if|if
condition|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_OFFLINE
operator|)
operator|&&
operator|(
operator|(
name|entry
operator|->
name|flags
operator|&
name|CTL_CMD_FLAG_OK_ON_OFFLINE
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|ctl_set_lun_not_ready
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
comment|/* 	 * If the LUN is stopped, see if this particular command is allowed 	 * for a stopped lun.  Otherwise, reject it with 0x04,0x02. 	 */
if|if
condition|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_STOPPED
operator|)
operator|&&
operator|(
operator|(
name|entry
operator|->
name|flags
operator|&
name|CTL_CMD_FLAG_OK_ON_STOPPED
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* "Logical unit not ready, initializing cmd. required" */
name|ctl_set_lun_stopped
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_INOPERABLE
operator|)
operator|&&
operator|(
operator|(
name|entry
operator|->
name|flags
operator|&
name|CTL_CMD_FLAG_OK_ON_INOPERABLE
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* "Medium format corrupted" */
name|ctl_set_medium_format_corrupted
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|bailout
label|:
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_failover_io
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|,
name|int
name|have_lock
parameter_list|)
block|{
name|ctl_set_busy
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_failover
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|struct
name|ctl_softc
modifier|*
name|ctl_softc
decl_stmt|;
name|union
name|ctl_io
modifier|*
name|next_io
decl_stmt|,
modifier|*
name|pending_io
decl_stmt|;
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|int
name|lun_idx
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ctl_softc
operator|=
name|control_softc
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ctl_softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Remove any cmds from the other SC from the rtr queue.  These 	 * will obviously only be for LUNs for which we're the primary. 	 * We can't send status or get/send data for these commands. 	 * Since they haven't been executed yet, we can just remove them. 	 * We'll either abort them or delete them below, depending on 	 * which HA mode we're in. 	 */
ifdef|#
directive|ifdef
name|notyet
name|mtx_lock
argument_list|(
operator|&
name|ctl_softc
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|STAILQ_FIRST
argument_list|(
operator|&
name|ctl_softc
operator|->
name|rtr_queue
argument_list|)
init|;
name|io
operator|!=
name|NULL
condition|;
name|io
operator|=
name|next_io
control|)
block|{
name|next_io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|STAILQ_NEXT
argument_list|(
operator|&
name|io
operator|->
name|io_hdr
argument_list|,
name|links
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_FROM_OTHER_SC
condition|)
name|STAILQ_REMOVE
argument_list|(
operator|&
name|ctl_softc
operator|->
name|rtr_queue
argument_list|,
operator|&
name|io
operator|->
name|io_hdr
argument_list|,
name|ctl_io_hdr
argument_list|,
name|links
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|ctl_softc
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|lun_idx
operator|=
literal|0
init|;
name|lun_idx
operator|<
name|ctl_softc
operator|->
name|num_luns
condition|;
name|lun_idx
operator|++
control|)
block|{
name|lun
operator|=
name|ctl_softc
operator|->
name|ctl_luns
index|[
name|lun_idx
index|]
expr_stmt|;
if|if
condition|(
name|lun
operator|==
name|NULL
condition|)
continue|continue;
comment|/* 		 * Processor LUNs are primary on both sides. 		 * XXX will this always be true? 		 */
if|if
condition|(
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
operator|==
name|T_PROCESSOR
condition|)
continue|continue;
if|if
condition|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_PRIMARY_SC
operator|)
operator|&&
operator|(
name|ctl_softc
operator|->
name|ha_mode
operator|==
name|CTL_HA_MODE_SER_ONLY
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"FAILOVER: primary lun %d\n"
argument_list|,
name|lun_idx
argument_list|)
expr_stmt|;
comment|/* 			 * Remove all commands from the other SC. First from the 			 * blocked queue then from the ooa queue. Once we have 			 * removed them. Call ctl_check_blocked to see if there 			 * is anything that can run. 			 */
for|for
control|(
name|io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|TAILQ_FIRST
argument_list|(
operator|&
name|lun
operator|->
name|blocked_queue
argument_list|)
init|;
name|io
operator|!=
name|NULL
condition|;
name|io
operator|=
name|next_io
control|)
block|{
name|next_io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|TAILQ_NEXT
argument_list|(
operator|&
name|io
operator|->
name|io_hdr
argument_list|,
name|blocked_links
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_FROM_OTHER_SC
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|lun
operator|->
name|blocked_queue
argument_list|,
operator|&
name|io
operator|->
name|io_hdr
argument_list|,
name|blocked_links
argument_list|)
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&=
operator|~
name|CTL_FLAG_BLOCKED
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|lun
operator|->
name|ooa_queue
argument_list|,
operator|&
name|io
operator|->
name|io_hdr
argument_list|,
name|ooa_links
argument_list|)
expr_stmt|;
name|ctl_free_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|TAILQ_FIRST
argument_list|(
operator|&
name|lun
operator|->
name|ooa_queue
argument_list|)
init|;
name|io
operator|!=
name|NULL
condition|;
name|io
operator|=
name|next_io
control|)
block|{
name|next_io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|TAILQ_NEXT
argument_list|(
operator|&
name|io
operator|->
name|io_hdr
argument_list|,
name|ooa_links
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_FROM_OTHER_SC
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|lun
operator|->
name|ooa_queue
argument_list|,
operator|&
name|io
operator|->
name|io_hdr
argument_list|,
name|ooa_links
argument_list|)
expr_stmt|;
name|ctl_free_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
block|}
name|ctl_check_blocked
argument_list|(
name|lun
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_PRIMARY_SC
operator|)
operator|&&
operator|(
name|ctl_softc
operator|->
name|ha_mode
operator|==
name|CTL_HA_MODE_XFER
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"FAILOVER: primary lun %d\n"
argument_list|,
name|lun_idx
argument_list|)
expr_stmt|;
comment|/* 			 * Abort all commands from the other SC.  We can't 			 * send status back for them now.  These should get 			 * cleaned up when they are completed or come out 			 * for a datamove operation. 			 */
for|for
control|(
name|io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|TAILQ_FIRST
argument_list|(
operator|&
name|lun
operator|->
name|ooa_queue
argument_list|)
init|;
name|io
operator|!=
name|NULL
condition|;
name|io
operator|=
name|next_io
control|)
block|{
name|next_io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|TAILQ_NEXT
argument_list|(
operator|&
name|io
operator|->
name|io_hdr
argument_list|,
name|ooa_links
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_FROM_OTHER_SC
condition|)
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ABORT
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_PRIMARY_SC
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ctl_softc
operator|->
name|ha_mode
operator|==
name|CTL_HA_MODE_XFER
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"FAILOVER: secondary lun %d\n"
argument_list|,
name|lun_idx
argument_list|)
expr_stmt|;
name|lun
operator|->
name|flags
operator||=
name|CTL_LUN_PRIMARY_SC
expr_stmt|;
comment|/* 			 * We send all I/O that was sent to this controller 			 * and redirected to the other side back with 			 * busy status, and have the initiator retry it. 			 * Figuring out how much data has been transferred, 			 * etc. and picking up where we left off would be  			 * very tricky. 			 * 			 * XXX KDM need to remove I/O from the blocked 			 * queue as well! 			 */
for|for
control|(
name|pending_io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|TAILQ_FIRST
argument_list|(
operator|&
name|lun
operator|->
name|ooa_queue
argument_list|)
init|;
name|pending_io
operator|!=
name|NULL
condition|;
name|pending_io
operator|=
name|next_io
control|)
block|{
name|next_io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|TAILQ_NEXT
argument_list|(
operator|&
name|pending_io
operator|->
name|io_hdr
argument_list|,
name|ooa_links
argument_list|)
expr_stmt|;
name|pending_io
operator|->
name|io_hdr
operator|.
name|flags
operator|&=
operator|~
name|CTL_FLAG_SENT_2OTHER_SC
expr_stmt|;
if|if
condition|(
name|pending_io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_IO_ACTIVE
condition|)
block|{
name|pending_io
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_FAILOVER
expr_stmt|;
block|}
else|else
block|{
name|ctl_set_busy
argument_list|(
operator|&
name|pending_io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
name|pending_io
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 			 * Build Unit Attention 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_MAX_INITIATORS
condition|;
name|i
operator|++
control|)
block|{
name|lun
operator|->
name|pending_ua
index|[
name|i
index|]
operator||=
name|CTL_UA_ASYM_ACC_CHANGE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_PRIMARY_SC
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ctl_softc
operator|->
name|ha_mode
operator|==
name|CTL_HA_MODE_SER_ONLY
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"FAILOVER: secondary lun %d\n"
argument_list|,
name|lun_idx
argument_list|)
expr_stmt|;
comment|/* 			 * if the first io on the OOA is not on the RtR queue 			 * add it. 			 */
name|lun
operator|->
name|flags
operator||=
name|CTL_LUN_PRIMARY_SC
expr_stmt|;
name|pending_io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|TAILQ_FIRST
argument_list|(
operator|&
name|lun
operator|->
name|ooa_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_io
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Nothing on OOA queue\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|pending_io
operator|->
name|io_hdr
operator|.
name|flags
operator|&=
operator|~
name|CTL_FLAG_SENT_2OTHER_SC
expr_stmt|;
if|if
condition|(
operator|(
name|pending_io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_IS_WAS_ON_RTR
operator|)
operator|==
literal|0
condition|)
block|{
name|pending_io
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_IS_WAS_ON_RTR
expr_stmt|;
name|ctl_enqueue_rtr
argument_list|(
name|pending_io
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|else 			{ 				printf("Tag 0x%04x is running\n", 				      pending_io->scsiio.tag_num); 			}
endif|#
directive|endif
name|next_io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|TAILQ_NEXT
argument_list|(
operator|&
name|pending_io
operator|->
name|io_hdr
argument_list|,
name|ooa_links
argument_list|)
expr_stmt|;
for|for
control|(
name|pending_io
operator|=
name|next_io
init|;
name|pending_io
operator|!=
name|NULL
condition|;
name|pending_io
operator|=
name|next_io
control|)
block|{
name|pending_io
operator|->
name|io_hdr
operator|.
name|flags
operator|&=
operator|~
name|CTL_FLAG_SENT_2OTHER_SC
expr_stmt|;
name|next_io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|TAILQ_NEXT
argument_list|(
operator|&
name|pending_io
operator|->
name|io_hdr
argument_list|,
name|ooa_links
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_IS_WAS_ON_RTR
condition|)
block|{
if|#
directive|if
literal|0
block|printf("Tag 0x%04x is running\n", 				      		pending_io->scsiio.tag_num);
endif|#
directive|endif
continue|continue;
block|}
switch|switch
condition|(
name|ctl_check_ooa
argument_list|(
name|lun
argument_list|,
name|pending_io
argument_list|,
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|TAILQ_PREV
argument_list|(
operator|&
name|pending_io
operator|->
name|io_hdr
argument_list|,
name|ctl_ooaq
argument_list|,
name|ooa_links
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|CTL_ACTION_BLOCK
case|:
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|lun
operator|->
name|blocked_queue
argument_list|,
operator|&
name|pending_io
operator|->
name|io_hdr
argument_list|,
name|blocked_links
argument_list|)
expr_stmt|;
name|pending_io
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_BLOCKED
expr_stmt|;
break|break;
case|case
name|CTL_ACTION_PASS
case|:
case|case
name|CTL_ACTION_SKIP
case|:
name|pending_io
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_IS_WAS_ON_RTR
expr_stmt|;
name|ctl_enqueue_rtr
argument_list|(
name|pending_io
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_ACTION_OVERLAP
case|:
name|ctl_set_overlapped_cmd
argument_list|(
operator|(
expr|struct
name|ctl_scsiio
operator|*
operator|)
name|pending_io
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
name|pending_io
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_ACTION_OVERLAP_TAG
case|:
name|ctl_set_overlapped_tag
argument_list|(
operator|(
expr|struct
name|ctl_scsiio
operator|*
operator|)
name|pending_io
argument_list|,
name|pending_io
operator|->
name|scsiio
operator|.
name|tag_num
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
name|pending_io
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_ACTION_ERROR
case|:
default|default:
name|ctl_set_internal_failure
argument_list|(
operator|(
expr|struct
name|ctl_scsiio
operator|*
operator|)
name|pending_io
argument_list|,
literal|0
argument_list|,
comment|// sks_valid
literal|0
argument_list|)
expr_stmt|;
comment|//retry count
name|ctl_done
argument_list|(
name|pending_io
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* 			 * Build Unit Attention 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_MAX_INITIATORS
condition|;
name|i
operator|++
control|)
block|{
name|lun
operator|->
name|pending_ua
index|[
name|i
index|]
operator||=
name|CTL_UA_ASYM_ACC_CHANGE
expr_stmt|;
block|}
block|}
else|else
block|{
name|panic
argument_list|(
literal|"Unhandled HA mode failover, LUN flags = %#x, "
literal|"ha_mode = #%x"
argument_list|,
name|lun
operator|->
name|flags
argument_list|,
name|ctl_softc
operator|->
name|ha_mode
argument_list|)
expr_stmt|;
block|}
block|}
name|ctl_pause_rtr
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ctl_softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_scsiio_precheck
parameter_list|(
name|struct
name|ctl_softc
modifier|*
name|ctl_softc
parameter_list|,
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
specifier|const
name|struct
name|ctl_cmd_entry
modifier|*
name|entry
decl_stmt|;
name|uint32_t
name|initidx
decl_stmt|,
name|targ_lun
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|lun
operator|=
name|NULL
expr_stmt|;
name|targ_lun
operator|=
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_mapped_lun
expr_stmt|;
if|if
condition|(
operator|(
name|targ_lun
operator|<
name|CTL_MAX_LUNS
operator|)
operator|&&
operator|(
name|ctl_softc
operator|->
name|ctl_luns
index|[
name|targ_lun
index|]
operator|!=
name|NULL
operator|)
condition|)
block|{
name|lun
operator|=
name|ctl_softc
operator|->
name|ctl_luns
index|[
name|targ_lun
index|]
expr_stmt|;
comment|/* 		 * If the LUN is invalid, pretend that it doesn't exist. 		 * It will go away as soon as all pending I/O has been 		 * completed. 		 */
if|if
condition|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_DISABLED
condition|)
block|{
name|lun
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LUN
index|]
operator|.
name|ptr
operator|=
name|lun
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_BACKEND_LUN
index|]
operator|.
name|ptr
operator|=
name|lun
operator|->
name|be_lun
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
operator|==
name|T_PROCESSOR
condition|)
block|{
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_CONTROL_DEV
expr_stmt|;
block|}
comment|/* 			 * Every I/O goes into the OOA queue for a 			 * particular LUN, and stays there until completion. 			 */
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|lun
operator|->
name|ooa_queue
argument_list|,
operator|&
name|ctsio
operator|->
name|io_hdr
argument_list|,
name|ooa_links
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LUN
index|]
operator|.
name|ptr
operator|=
name|NULL
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_BACKEND_LUN
index|]
operator|.
name|ptr
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Get command entry and return error if it is unsuppotyed. */
name|entry
operator|=
name|ctl_validate_command
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|lun
condition|)
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator|&=
operator|~
name|CTL_FLAG_DATA_MASK
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|entry
operator|->
name|flags
operator|&
name|CTL_FLAG_DATA_MASK
expr_stmt|;
comment|/* 	 * Check to see whether we can send this command to LUNs that don't 	 * exist.  This should pretty much only be the case for inquiry 	 * and request sense.  Further checks, below, really require having 	 * a LUN, so we can't really check the command anymore.  Just put 	 * it on the rtr queue. 	 */
if|if
condition|(
name|lun
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|flags
operator|&
name|CTL_CMD_FLAG_OK_ON_ALL_LUNS
condition|)
block|{
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_IS_WAS_ON_RTR
expr_stmt|;
name|ctl_enqueue_rtr
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
name|ctl_set_unsupported_lun
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_scsiio_precheck: bailing out due to invalid LUN\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
else|else
block|{
comment|/* 		 * Make sure we support this particular command on this LUN. 		 * e.g., we don't support writes to the control LUN. 		 */
if|if
condition|(
operator|!
name|ctl_cmd_applicable
argument_list|(
name|lun
operator|->
name|be_lun
operator|->
name|lun_type
argument_list|,
name|entry
argument_list|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctl_set_invalid_opcode
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
block|}
name|initidx
operator|=
name|ctl_get_initindex
argument_list|(
operator|&
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CTL_WITH_CA
comment|/* 	 * If we've got a request sense, it'll clear the contingent 	 * allegiance condition.  Otherwise, if we have a CA condition for 	 * this initiator, clear it, because it sent down a command other 	 * than request sense. 	 */
if|if
condition|(
operator|(
name|ctsio
operator|->
name|cdb
index|[
literal|0
index|]
operator|!=
name|REQUEST_SENSE
operator|)
operator|&&
operator|(
name|ctl_is_set
argument_list|(
name|lun
operator|->
name|have_ca
argument_list|,
name|initidx
argument_list|)
operator|)
condition|)
name|ctl_clear_mask
argument_list|(
name|lun
operator|->
name|have_ca
argument_list|,
name|initidx
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * If the command has this flag set, it handles its own unit 	 * attention reporting, we shouldn't do anything.  Otherwise we 	 * check for any pending unit attentions, and send them back to the 	 * initiator.  We only do this when a command initially comes in, 	 * not when we pull it off the blocked queue. 	 * 	 * According to SAM-3, section 5.3.2, the order that things get 	 * presented back to the host is basically unit attentions caused 	 * by some sort of reset event, busy status, reservation conflicts 	 * or task set full, and finally any other status. 	 * 	 * One issue here is that some of the unit attentions we report 	 * don't fall into the "reset" category (e.g. "reported luns data 	 * has changed").  So reporting it here, before the reservation 	 * check, may be technically wrong.  I guess the only thing to do 	 * would be to check for and report the reset events here, and then 	 * check for the other unit attention types after we check for a 	 * reservation conflict. 	 * 	 * XXX KDM need to fix this 	 */
if|if
condition|(
operator|(
name|entry
operator|->
name|flags
operator|&
name|CTL_CMD_FLAG_NO_SENSE
operator|)
operator|==
literal|0
condition|)
block|{
name|ctl_ua_type
name|ua_type
decl_stmt|;
if|if
condition|(
name|lun
operator|->
name|pending_ua
index|[
name|initidx
index|]
operator|!=
name|CTL_UA_NONE
condition|)
block|{
name|scsi_sense_data_type
name|sense_format
decl_stmt|;
if|if
condition|(
name|lun
operator|!=
name|NULL
condition|)
name|sense_format
operator|=
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_SENSE_DESC
operator|)
condition|?
name|SSD_TYPE_DESC
else|:
name|SSD_TYPE_FIXED
expr_stmt|;
else|else
name|sense_format
operator|=
name|SSD_TYPE_FIXED
expr_stmt|;
name|ua_type
operator|=
name|ctl_build_ua
argument_list|(
operator|&
name|lun
operator|->
name|pending_ua
index|[
name|initidx
index|]
argument_list|,
operator|&
name|ctsio
operator|->
name|sense_data
argument_list|,
name|sense_format
argument_list|)
expr_stmt|;
if|if
condition|(
name|ua_type
operator|!=
name|CTL_UA_NONE
condition|)
block|{
name|ctsio
operator|->
name|scsi_status
operator|=
name|SCSI_STATUS_CHECK_COND
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|status
operator|=
name|CTL_SCSI_ERROR
operator||
name|CTL_AUTOSENSE
expr_stmt|;
name|ctsio
operator|->
name|sense_len
operator|=
name|SSD_FULL_SIZE
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
block|}
block|}
if|if
condition|(
name|ctl_scsiio_lun_check
argument_list|(
name|ctl_softc
argument_list|,
name|lun
argument_list|,
name|entry
argument_list|,
name|ctsio
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
comment|/* 	 * XXX CHD this is where we want to send IO to other side if 	 * this LUN is secondary on this SC. We will need to make a copy 	 * of the IO and flag the IO on this side as SENT_2OTHER and the flag 	 * the copy we send as FROM_OTHER. 	 * We also need to stuff the address of the original IO so we can 	 * find it easily. Something similar will need be done on the other 	 * side so when we are done we can find the copy. 	 */
if|if
condition|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_PRIMARY_SC
operator|)
operator|==
literal|0
condition|)
block|{
name|union
name|ctl_ha_msg
name|msg_info
decl_stmt|;
name|int
name|isc_retval
decl_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_SENT_2OTHER_SC
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_SERIALIZE
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|original_sc
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
expr_stmt|;
if|#
directive|if
literal|0
block|printf("1. ctsio %p\n", ctsio);
endif|#
directive|endif
name|msg_info
operator|.
name|hdr
operator|.
name|serializing_sc
operator|=
name|NULL
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|nexus
operator|=
name|ctsio
operator|->
name|io_hdr
operator|.
name|nexus
expr_stmt|;
name|msg_info
operator|.
name|scsi
operator|.
name|tag_num
operator|=
name|ctsio
operator|->
name|tag_num
expr_stmt|;
name|msg_info
operator|.
name|scsi
operator|.
name|tag_type
operator|=
name|ctsio
operator|->
name|tag_type
expr_stmt|;
name|memcpy
argument_list|(
name|msg_info
operator|.
name|scsi
operator|.
name|cdb
argument_list|,
name|ctsio
operator|->
name|cdb
argument_list|,
name|CTL_MAX_CDBLEN
argument_list|)
expr_stmt|;
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator|&=
operator|~
name|CTL_FLAG_IO_ACTIVE
expr_stmt|;
if|if
condition|(
operator|(
name|isc_retval
operator|=
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|msg_info
argument_list|,
sizeof|sizeof
argument_list|(
name|msg_info
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|>
name|CTL_HA_STATUS_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"CTL:precheck, ctl_ha_msg_send returned %d\n"
argument_list|,
name|isc_retval
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"CTL:opcode is %x\n"
argument_list|,
name|ctsio
operator|->
name|cdb
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
literal|0
block|printf("CTL:Precheck sent msg, opcode is %x\n",opcode);
endif|#
directive|endif
block|}
comment|/* 		 * XXX KDM this I/O is off the incoming queue, but hasn't 		 * been inserted on any other queue.  We may need to come 		 * up with a holding queue while we wait for serialization 		 * so that we have an idea of what we're waiting for from 		 * the other side. 		 */
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
switch|switch
condition|(
name|ctl_check_ooa
argument_list|(
name|lun
argument_list|,
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|,
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|TAILQ_PREV
argument_list|(
operator|&
name|ctsio
operator|->
name|io_hdr
argument_list|,
name|ctl_ooaq
argument_list|,
name|ooa_links
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|CTL_ACTION_BLOCK
case|:
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_BLOCKED
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|lun
operator|->
name|blocked_queue
argument_list|,
operator|&
name|ctsio
operator|->
name|io_hdr
argument_list|,
name|blocked_links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
case|case
name|CTL_ACTION_PASS
case|:
case|case
name|CTL_ACTION_SKIP
case|:
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_IS_WAS_ON_RTR
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctl_enqueue_rtr
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_ACTION_OVERLAP
case|:
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctl_set_overlapped_cmd
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_ACTION_OVERLAP_TAG
case|:
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctl_set_overlapped_tag
argument_list|(
name|ctsio
argument_list|,
name|ctsio
operator|->
name|tag_num
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_ACTION_ERROR
case|:
default|default:
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctl_set_internal_failure
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|0
argument_list|,
comment|/*retry_count*/
literal|0
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|struct
name|ctl_cmd_entry
modifier|*
name|ctl_get_cmd_entry
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|int
modifier|*
name|sa
parameter_list|)
block|{
specifier|const
name|struct
name|ctl_cmd_entry
modifier|*
name|entry
decl_stmt|;
name|int
name|service_action
decl_stmt|;
name|entry
operator|=
operator|&
name|ctl_cmd_table
index|[
name|ctsio
operator|->
name|cdb
index|[
literal|0
index|]
index|]
expr_stmt|;
if|if
condition|(
name|sa
condition|)
operator|*
name|sa
operator|=
operator|(
operator|(
name|entry
operator|->
name|flags
operator|&
name|CTL_CMD_FLAG_SA5
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|flags
operator|&
name|CTL_CMD_FLAG_SA5
condition|)
block|{
name|service_action
operator|=
name|ctsio
operator|->
name|cdb
index|[
literal|1
index|]
operator|&
name|SERVICE_ACTION_MASK
expr_stmt|;
name|entry
operator|=
operator|&
operator|(
operator|(
specifier|const
expr|struct
name|ctl_cmd_entry
operator|*
operator|)
name|entry
operator|->
name|execute
operator|)
index|[
name|service_action
index|]
expr_stmt|;
block|}
return|return
operator|(
name|entry
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|struct
name|ctl_cmd_entry
modifier|*
name|ctl_validate_command
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
specifier|const
name|struct
name|ctl_cmd_entry
modifier|*
name|entry
decl_stmt|;
name|int
name|i
decl_stmt|,
name|sa
decl_stmt|;
name|uint8_t
name|diff
decl_stmt|;
name|entry
operator|=
name|ctl_get_cmd_entry
argument_list|(
name|ctsio
argument_list|,
operator|&
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|execute
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|sa
condition|)
name|ctl_set_invalid_field
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
literal|1
argument_list|,
comment|/*bit_valid*/
literal|1
argument_list|,
comment|/*bit*/
literal|4
argument_list|)
expr_stmt|;
else|else
name|ctl_set_invalid_opcode
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|KASSERT
argument_list|(
name|entry
operator|->
name|length
operator|>
literal|0
argument_list|,
operator|(
literal|"Not defined length for command 0x%02x/0x%02x"
operator|,
name|ctsio
operator|->
name|cdb
index|[
literal|0
index|]
operator|,
name|ctsio
operator|->
name|cdb
index|[
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|entry
operator|->
name|length
condition|;
name|i
operator|++
control|)
block|{
name|diff
operator|=
name|ctsio
operator|->
name|cdb
index|[
name|i
index|]
operator|&
operator|~
name|entry
operator|->
name|usage
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|diff
operator|==
literal|0
condition|)
continue|continue;
name|ctl_set_invalid_field
argument_list|(
name|ctsio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*command*/
literal|1
argument_list|,
comment|/*field*/
name|i
argument_list|,
comment|/*bit_valid*/
literal|1
argument_list|,
comment|/*bit*/
name|fls
argument_list|(
name|diff
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|entry
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_cmd_applicable
parameter_list|(
name|uint8_t
name|lun_type
parameter_list|,
specifier|const
name|struct
name|ctl_cmd_entry
modifier|*
name|entry
parameter_list|)
block|{
switch|switch
condition|(
name|lun_type
condition|)
block|{
case|case
name|T_PROCESSOR
case|:
if|if
condition|(
operator|(
operator|(
name|entry
operator|->
name|flags
operator|&
name|CTL_CMD_FLAG_OK_ON_PROC
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|entry
operator|->
name|flags
operator|&
name|CTL_CMD_FLAG_OK_ON_ALL_LUNS
operator|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|T_DIRECT
case|:
if|if
condition|(
operator|(
operator|(
name|entry
operator|->
name|flags
operator|&
name|CTL_CMD_FLAG_OK_ON_SLUN
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|entry
operator|->
name|flags
operator|&
name|CTL_CMD_FLAG_OK_ON_ALL_LUNS
operator|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_scsiio
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
specifier|const
name|struct
name|ctl_cmd_entry
modifier|*
name|entry
decl_stmt|;
name|retval
operator|=
name|CTL_RETVAL_COMPLETE
expr_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_scsiio cdb[0]=%02X\n"
operator|,
name|ctsio
operator|->
name|cdb
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
name|entry
operator|=
name|ctl_get_cmd_entry
argument_list|(
name|ctsio
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * If this I/O has been aborted, just send it straight to 	 * ctl_done() without executing it. 	 */
if|if
condition|(
name|ctsio
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ABORT
condition|)
block|{
name|ctl_done
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
comment|/* 	 * All the checks should have been handled by ctl_scsiio_precheck(). 	 * We should be clear now to just execute the I/O. 	 */
name|retval
operator|=
name|entry
operator|->
name|execute
argument_list|(
name|ctsio
argument_list|)
expr_stmt|;
name|bailout
label|:
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Since we only implement one target right now, a bus reset simply resets  * our single target.  */
end_comment

begin_function
specifier|static
name|int
name|ctl_bus_reset
parameter_list|(
name|struct
name|ctl_softc
modifier|*
name|ctl_softc
parameter_list|,
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
return|return
operator|(
name|ctl_target_reset
argument_list|(
name|ctl_softc
argument_list|,
name|io
argument_list|,
name|CTL_UA_BUS_RESET
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_target_reset
parameter_list|(
name|struct
name|ctl_softc
modifier|*
name|ctl_softc
parameter_list|,
name|union
name|ctl_io
modifier|*
name|io
parameter_list|,
name|ctl_ua_type
name|ua_type
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|int
name|retval
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_FROM_OTHER_SC
operator|)
condition|)
block|{
name|union
name|ctl_ha_msg
name|msg_info
decl_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_SENT_2OTHER_SC
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|nexus
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|nexus
expr_stmt|;
if|if
condition|(
name|ua_type
operator|==
name|CTL_UA_TARG_RESET
condition|)
name|msg_info
operator|.
name|task
operator|.
name|task_action
operator|=
name|CTL_TASK_TARGET_RESET
expr_stmt|;
else|else
name|msg_info
operator|.
name|task
operator|.
name|task_action
operator|=
name|CTL_TASK_BUS_RESET
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_MANAGE_TASKS
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|original_sc
operator|=
name|NULL
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|serializing_sc
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|CTL_HA_STATUS_SUCCESS
operator|!=
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|msg_info
argument_list|,
sizeof|sizeof
argument_list|(
name|msg_info
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{ 		}
block|}
name|retval
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ctl_softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|lun
argument_list|,
argument|&ctl_softc->lun_list
argument_list|,
argument|links
argument_list|)
name|retval
operator|+=
name|ctl_lun_reset
argument_list|(
name|lun
argument_list|,
name|io
argument_list|,
name|ua_type
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ctl_softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The LUN should always be set.  The I/O is optional, and is used to  * distinguish between I/Os sent by this initiator, and by other  * initiators.  We set unit attention for initiators other than this one.  * SAM-3 is vague on this point.  It does say that a unit attention should  * be established for other initiators when a LUN is reset (see section  * 5.7.3), but it doesn't specifically say that the unit attention should  * be established for this particular initiator when a LUN is reset.  Here  * is the relevant text, from SAM-3 rev 8:  *  * 5.7.2 When a SCSI initiator port aborts its own tasks  *  * When a SCSI initiator port causes its own task(s) to be aborted, no  * notification that the task(s) have been aborted shall be returned to  * the SCSI initiator port other than the completion response for the  * command or task management function action that caused the task(s) to  * be aborted and notification(s) associated with related effects of the  * action (e.g., a reset unit attention condition).  *  * XXX KDM for now, we're setting unit attention for all initiators.  */
end_comment

begin_function
specifier|static
name|int
name|ctl_lun_reset
parameter_list|(
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|,
name|union
name|ctl_io
modifier|*
name|io
parameter_list|,
name|ctl_ua_type
name|ua_type
parameter_list|)
block|{
name|union
name|ctl_io
modifier|*
name|xio
decl_stmt|;
if|#
directive|if
literal|0
block|uint32_t initindex;
endif|#
directive|endif
name|int
name|i
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Run through the OOA queue and abort each I/O. 	 */
if|#
directive|if
literal|0
block|TAILQ_FOREACH((struct ctl_io_hdr *)xio,&lun->ooa_queue, ooa_links) {
endif|#
directive|endif
for|for
control|(
name|xio
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|TAILQ_FIRST
argument_list|(
operator|&
name|lun
operator|->
name|ooa_queue
argument_list|)
init|;
name|xio
operator|!=
name|NULL
condition|;
name|xio
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|TAILQ_NEXT
argument_list|(
operator|&
name|xio
operator|->
name|io_hdr
argument_list|,
name|ooa_links
argument_list|)
control|)
block|{
name|xio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ABORT
operator||
name|CTL_FLAG_ABORT_STATUS
expr_stmt|;
block|}
comment|/* 	 * This version sets unit attention for every 	 */
if|#
directive|if
literal|0
block|initindex = ctl_get_initindex(&io->io_hdr.nexus); 	for (i = 0; i< CTL_MAX_INITIATORS; i++) { 		if (initindex == i) 			continue; 		lun->pending_ua[i] |= ua_type; 	}
endif|#
directive|endif
comment|/* 	 * A reset (any kind, really) clears reservations established with 	 * RESERVE/RELEASE.  It does not clear reservations established 	 * with PERSISTENT RESERVE OUT, but we don't support that at the 	 * moment anyway.  See SPC-2, section 5.6.  SPC-3 doesn't address 	 * reservations made with the RESERVE/RELEASE commands, because 	 * those commands are obsolete in SPC-3. 	 */
name|lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_LUN_RESERVED
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_MAX_INITIATORS
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|CTL_WITH_CA
name|ctl_clear_mask
argument_list|(
name|lun
operator|->
name|have_ca
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|lun
operator|->
name|pending_ua
index|[
name|i
index|]
operator||=
name|ua_type
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_abort_tasks_lun
parameter_list|(
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|,
name|uint32_t
name|targ_port
parameter_list|,
name|uint32_t
name|init_id
parameter_list|,
name|int
name|other_sc
parameter_list|)
block|{
name|union
name|ctl_io
modifier|*
name|xio
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * Run through the OOA queue and attempt to find the given I/O. 	 * The target port, initiator ID, tag type and tag number have to 	 * match the values that we got from the initiator.  If we have an 	 * untagged command to abort, simply abort the first untagged command 	 * we come to.  We only allow one untagged command at a time of course. 	 */
for|for
control|(
name|xio
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|TAILQ_FIRST
argument_list|(
operator|&
name|lun
operator|->
name|ooa_queue
argument_list|)
init|;
name|xio
operator|!=
name|NULL
condition|;
name|xio
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|TAILQ_NEXT
argument_list|(
operator|&
name|xio
operator|->
name|io_hdr
argument_list|,
name|ooa_links
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|targ_port
operator|==
name|UINT32_MAX
operator|||
name|targ_port
operator|==
name|xio
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
operator|)
operator|&&
operator|(
name|init_id
operator|==
name|UINT32_MAX
operator|||
name|init_id
operator|==
name|xio
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|initid
operator|.
name|id
operator|)
condition|)
block|{
if|if
condition|(
name|targ_port
operator|!=
name|xio
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
operator|||
name|init_id
operator|!=
name|xio
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|initid
operator|.
name|id
condition|)
name|xio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ABORT_STATUS
expr_stmt|;
name|xio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ABORT
expr_stmt|;
if|if
condition|(
operator|!
name|other_sc
operator|&&
operator|!
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_PRIMARY_SC
operator|)
condition|)
block|{
name|union
name|ctl_ha_msg
name|msg_info
decl_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|nexus
operator|=
name|xio
operator|->
name|io_hdr
operator|.
name|nexus
expr_stmt|;
name|msg_info
operator|.
name|task
operator|.
name|task_action
operator|=
name|CTL_TASK_ABORT_TASK
expr_stmt|;
name|msg_info
operator|.
name|task
operator|.
name|tag_num
operator|=
name|xio
operator|->
name|scsiio
operator|.
name|tag_num
expr_stmt|;
name|msg_info
operator|.
name|task
operator|.
name|tag_type
operator|=
name|xio
operator|->
name|scsiio
operator|.
name|tag_type
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_MANAGE_TASKS
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|original_sc
operator|=
name|NULL
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|serializing_sc
operator|=
name|NULL
expr_stmt|;
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|msg_info
argument_list|,
sizeof|sizeof
argument_list|(
name|msg_info
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_abort_task_set
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|control_softc
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|uint32_t
name|targ_lun
decl_stmt|;
comment|/* 	 * Look up the LUN. 	 */
name|targ_lun
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_mapped_lun
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|targ_lun
operator|<
name|CTL_MAX_LUNS
operator|)
operator|&&
operator|(
name|softc
operator|->
name|ctl_luns
index|[
name|targ_lun
index|]
operator|!=
name|NULL
operator|)
condition|)
name|lun
operator|=
name|softc
operator|->
name|ctl_luns
index|[
name|targ_lun
index|]
expr_stmt|;
else|else
block|{
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|taskio
operator|.
name|task_action
operator|==
name|CTL_TASK_ABORT_TASK_SET
condition|)
block|{
name|ctl_abort_tasks_lun
argument_list|(
name|lun
argument_list|,
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
argument_list|,
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|initid
operator|.
name|id
argument_list|,
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_FROM_OTHER_SC
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* CTL_TASK_CLEAR_TASK_SET */
name|ctl_abort_tasks_lun
argument_list|(
name|lun
argument_list|,
name|UINT32_MAX
argument_list|,
name|UINT32_MAX
argument_list|,
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_FROM_OTHER_SC
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_i_t_nexus_reset
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|control_softc
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|uint32_t
name|initindex
decl_stmt|,
name|residx
decl_stmt|;
name|initindex
operator|=
name|ctl_get_initindex
argument_list|(
operator|&
name|io
operator|->
name|io_hdr
operator|.
name|nexus
argument_list|)
expr_stmt|;
name|residx
operator|=
name|ctl_get_resindex
argument_list|(
operator|&
name|io
operator|->
name|io_hdr
operator|.
name|nexus
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|lun
argument_list|,
argument|&softc->lun_list
argument_list|,
argument|links
argument_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctl_abort_tasks_lun
argument_list|(
name|lun
argument_list|,
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
argument_list|,
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|initid
operator|.
name|id
argument_list|,
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_FROM_OTHER_SC
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CTL_WITH_CA
name|ctl_clear_mask
argument_list|(
name|lun
operator|->
name|have_ca
argument_list|,
name|initindex
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_RESERVED
operator|)
operator|&&
operator|(
name|lun
operator|->
name|res_idx
operator|==
name|residx
operator|)
condition|)
name|lun
operator|->
name|flags
operator|&=
operator|~
name|CTL_LUN_RESERVED
expr_stmt|;
name|lun
operator|->
name|pending_ua
index|[
name|initindex
index|]
operator||=
name|CTL_UA_I_T_NEXUS_LOSS
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_abort_task
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|union
name|ctl_io
modifier|*
name|xio
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|struct
name|ctl_softc
modifier|*
name|ctl_softc
decl_stmt|;
if|#
directive|if
literal|0
block|struct sbuf sb; 	char printbuf[128];
endif|#
directive|endif
name|int
name|found
decl_stmt|;
name|uint32_t
name|targ_lun
decl_stmt|;
name|ctl_softc
operator|=
name|control_softc
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Look up the LUN. 	 */
name|targ_lun
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_mapped_lun
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ctl_softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|targ_lun
operator|<
name|CTL_MAX_LUNS
operator|)
operator|&&
operator|(
name|ctl_softc
operator|->
name|ctl_luns
index|[
name|targ_lun
index|]
operator|!=
name|NULL
operator|)
condition|)
name|lun
operator|=
name|ctl_softc
operator|->
name|ctl_luns
index|[
name|targ_lun
index|]
expr_stmt|;
else|else
block|{
name|mtx_unlock
argument_list|(
operator|&
name|ctl_softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|#
directive|if
literal|0
block|printf("ctl_abort_task: called for lun %lld, tag %d type %d\n", 	       lun->lun, io->taskio.tag_num, io->taskio.tag_type);
endif|#
directive|endif
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ctl_softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Run through the OOA queue and attempt to find the given I/O. 	 * The target port, initiator ID, tag type and tag number have to 	 * match the values that we got from the initiator.  If we have an 	 * untagged command to abort, simply abort the first untagged command 	 * we come to.  We only allow one untagged command at a time of course. 	 */
if|#
directive|if
literal|0
block|TAILQ_FOREACH((struct ctl_io_hdr *)xio,&lun->ooa_queue, ooa_links) {
endif|#
directive|endif
for|for
control|(
name|xio
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|TAILQ_FIRST
argument_list|(
operator|&
name|lun
operator|->
name|ooa_queue
argument_list|)
init|;
name|xio
operator|!=
name|NULL
condition|;
name|xio
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|TAILQ_NEXT
argument_list|(
operator|&
name|xio
operator|->
name|io_hdr
argument_list|,
name|ooa_links
argument_list|)
control|)
block|{
if|#
directive|if
literal|0
block|sbuf_new(&sb, printbuf, sizeof(printbuf), SBUF_FIXEDLEN);  		sbuf_printf(&sb, "LUN %lld tag %d type %d%s%s%s%s: ", 			    lun->lun, xio->scsiio.tag_num, 			    xio->scsiio.tag_type, 			    (xio->io_hdr.blocked_links.tqe_prev 			    == NULL) ? "" : " BLOCKED", 			    (xio->io_hdr.flags& 			    CTL_FLAG_DMA_INPROG) ? " DMA" : "", 			    (xio->io_hdr.flags& 			    CTL_FLAG_ABORT) ? " ABORT" : "", 			    (xio->io_hdr.flags& 			    CTL_FLAG_IS_WAS_ON_RTR ? " RTR" : "")); 		ctl_scsi_command_string(&xio->scsiio, NULL,&sb); 		sbuf_finish(&sb); 		printf("%s\n", sbuf_data(&sb));
endif|#
directive|endif
if|if
condition|(
operator|(
name|xio
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
operator|==
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
operator|)
operator|&&
operator|(
name|xio
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|initid
operator|.
name|id
operator|==
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|initid
operator|.
name|id
operator|)
condition|)
block|{
comment|/* 			 * If the abort says that the task is untagged, the 			 * task in the queue must be untagged.  Otherwise, 			 * we just check to see whether the tag numbers 			 * match.  This is because the QLogic firmware 			 * doesn't pass back the tag type in an abort 			 * request. 			 */
if|#
directive|if
literal|0
block|if (((xio->scsiio.tag_type == CTL_TAG_UNTAGGED)&& (io->taskio.tag_type == CTL_TAG_UNTAGGED)) 			 || (xio->scsiio.tag_num == io->taskio.tag_num)) {
endif|#
directive|endif
comment|/* 			 * XXX KDM we've got problems with FC, because it 			 * doesn't send down a tag type with aborts.  So we 			 * can only really go by the tag number... 			 * This may cause problems with parallel SCSI. 			 * Need to figure that out!! 			 */
if|if
condition|(
name|xio
operator|->
name|scsiio
operator|.
name|tag_num
operator|==
name|io
operator|->
name|taskio
operator|.
name|tag_num
condition|)
block|{
name|xio
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_ABORT
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_FROM_OTHER_SC
operator|)
operator|==
literal|0
operator|&&
operator|!
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_PRIMARY_SC
operator|)
condition|)
block|{
name|union
name|ctl_ha_msg
name|msg_info
decl_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_SENT_2OTHER_SC
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|nexus
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|nexus
expr_stmt|;
name|msg_info
operator|.
name|task
operator|.
name|task_action
operator|=
name|CTL_TASK_ABORT_TASK
expr_stmt|;
name|msg_info
operator|.
name|task
operator|.
name|tag_num
operator|=
name|io
operator|->
name|taskio
operator|.
name|tag_num
expr_stmt|;
name|msg_info
operator|.
name|task
operator|.
name|tag_type
operator|=
name|io
operator|->
name|taskio
operator|.
name|tag_type
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_MANAGE_TASKS
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|original_sc
operator|=
name|NULL
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|serializing_sc
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
literal|0
block|printf("Sent Abort to other side\n");
endif|#
directive|endif
if|if
condition|(
name|CTL_HA_STATUS_SUCCESS
operator|!=
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|msg_info
argument_list|,
sizeof|sizeof
argument_list|(
name|msg_info
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{ 					}
block|}
if|#
directive|if
literal|0
block|printf("ctl_abort_task: found I/O to abort\n");
endif|#
directive|endif
break|break;
block|}
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|==
literal|0
condition|)
block|{
comment|/* 		 * This isn't really an error.  It's entirely possible for 		 * the abort and command completion to cross on the wire. 		 * This is more of an informative/diagnostic error. 		 */
if|#
directive|if
literal|0
block|printf("ctl_abort_task: ABORT sent for nonexistent I/O: " 		       "%d:%d:%d:%d tag %d type %d\n", 		       io->io_hdr.nexus.initid.id, 		       io->io_hdr.nexus.targ_port, 		       io->io_hdr.nexus.targ_target.id, 		       io->io_hdr.nexus.targ_lun, io->taskio.tag_num, 		       io->taskio.tag_type);
endif|#
directive|endif
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_run_task
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|ctl_softc
init|=
name|control_softc
decl_stmt|;
name|int
name|retval
init|=
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|task_desc
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_run_task\n"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|io
operator|->
name|io_hdr
operator|.
name|io_type
operator|==
name|CTL_IO_TASK
argument_list|,
operator|(
literal|"ctl_run_task: Unextected io_type %d\n"
operator|,
name|io
operator|->
name|io_hdr
operator|.
name|io_type
operator|)
argument_list|)
expr_stmt|;
name|task_desc
operator|=
name|ctl_scsi_task_string
argument_list|(
operator|&
name|io
operator|->
name|taskio
argument_list|)
expr_stmt|;
if|if
condition|(
name|task_desc
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|NEEDTOPORT
name|csevent_log
argument_list|(
name|CSC_CTL
operator||
name|CSC_SHELF_SW
operator||
name|CTL_TASK_REPORT
argument_list|,
name|csevent_LogType_Trace
argument_list|,
name|csevent_Severity_Information
argument_list|,
name|csevent_AlertLevel_Green
argument_list|,
name|csevent_FRU_Firmware
argument_list|,
name|csevent_FRU_Unknown
argument_list|,
literal|"CTL: received task: %s"
argument_list|,
name|task_desc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|NEEDTOPORT
name|csevent_log
argument_list|(
name|CSC_CTL
operator||
name|CSC_SHELF_SW
operator||
name|CTL_TASK_REPORT
argument_list|,
name|csevent_LogType_Trace
argument_list|,
name|csevent_Severity_Information
argument_list|,
name|csevent_AlertLevel_Green
argument_list|,
name|csevent_FRU_Firmware
argument_list|,
name|csevent_FRU_Unknown
argument_list|,
literal|"CTL: received unknown task "
literal|"type: %d (%#x)"
argument_list|,
name|io
operator|->
name|taskio
operator|.
name|task_action
argument_list|,
name|io
operator|->
name|taskio
operator|.
name|task_action
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
switch|switch
condition|(
name|io
operator|->
name|taskio
operator|.
name|task_action
condition|)
block|{
case|case
name|CTL_TASK_ABORT_TASK
case|:
name|retval
operator|=
name|ctl_abort_task
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_TASK_ABORT_TASK_SET
case|:
case|case
name|CTL_TASK_CLEAR_TASK_SET
case|:
name|retval
operator|=
name|ctl_abort_task_set
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_TASK_CLEAR_ACA
case|:
break|break;
case|case
name|CTL_TASK_I_T_NEXUS_RESET
case|:
name|retval
operator|=
name|ctl_i_t_nexus_reset
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_TASK_LUN_RESET
case|:
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|uint32_t
name|targ_lun
decl_stmt|;
name|targ_lun
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_mapped_lun
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ctl_softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|targ_lun
operator|<
name|CTL_MAX_LUNS
operator|)
operator|&&
operator|(
name|ctl_softc
operator|->
name|ctl_luns
index|[
name|targ_lun
index|]
operator|!=
name|NULL
operator|)
condition|)
name|lun
operator|=
name|ctl_softc
operator|->
name|ctl_luns
index|[
name|targ_lun
index|]
expr_stmt|;
else|else
block|{
name|mtx_unlock
argument_list|(
operator|&
name|ctl_softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_FROM_OTHER_SC
operator|)
condition|)
block|{
name|union
name|ctl_ha_msg
name|msg_info
decl_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_SENT_2OTHER_SC
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_MANAGE_TASKS
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|nexus
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|nexus
expr_stmt|;
name|msg_info
operator|.
name|task
operator|.
name|task_action
operator|=
name|CTL_TASK_LUN_RESET
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|original_sc
operator|=
name|NULL
expr_stmt|;
name|msg_info
operator|.
name|hdr
operator|.
name|serializing_sc
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|CTL_HA_STATUS_SUCCESS
operator|!=
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|msg_info
argument_list|,
sizeof|sizeof
argument_list|(
name|msg_info
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{ 			}
block|}
name|retval
operator|=
name|ctl_lun_reset
argument_list|(
name|lun
argument_list|,
name|io
argument_list|,
name|CTL_UA_LUN_RESET
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ctl_softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CTL_TASK_TARGET_RESET
case|:
name|retval
operator|=
name|ctl_target_reset
argument_list|(
name|ctl_softc
argument_list|,
name|io
argument_list|,
name|CTL_UA_TARG_RESET
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_TASK_BUS_RESET
case|:
name|retval
operator|=
name|ctl_bus_reset
argument_list|(
name|ctl_softc
argument_list|,
name|io
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_TASK_PORT_LOGIN
case|:
break|break;
case|case
name|CTL_TASK_PORT_LOGOUT
case|:
break|break;
default|default:
name|printf
argument_list|(
literal|"ctl_run_task: got unknown task management event %d\n"
argument_list|,
name|io
operator|->
name|taskio
operator|.
name|task_action
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|=
name|CTL_SUCCESS
expr_stmt|;
else|else
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|=
name|CTL_ERROR
expr_stmt|;
name|ctl_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * For HA operation.  Handle commands that come in from the other  * controller.  */
end_comment

begin_function
specifier|static
name|void
name|ctl_handle_isc
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|int
name|free_io
decl_stmt|;
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|struct
name|ctl_softc
modifier|*
name|ctl_softc
decl_stmt|;
name|uint32_t
name|targ_lun
decl_stmt|;
name|ctl_softc
operator|=
name|control_softc
expr_stmt|;
name|targ_lun
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_mapped_lun
expr_stmt|;
name|lun
operator|=
name|ctl_softc
operator|->
name|ctl_luns
index|[
name|targ_lun
index|]
expr_stmt|;
switch|switch
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|msg_type
condition|)
block|{
case|case
name|CTL_MSG_SERIALIZE
case|:
name|free_io
operator|=
name|ctl_serialize_other_sc_cmd
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_MSG_R2R
case|:
block|{
specifier|const
name|struct
name|ctl_cmd_entry
modifier|*
name|entry
decl_stmt|;
comment|/* 		 * This is only used in SER_ONLY mode. 		 */
name|free_io
operator|=
literal|0
expr_stmt|;
name|entry
operator|=
name|ctl_get_cmd_entry
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl_scsiio_lun_check
argument_list|(
name|ctl_softc
argument_list|,
name|lun
argument_list|,
name|entry
argument_list|,
operator|(
expr|struct
name|ctl_scsiio
operator|*
operator|)
name|io
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctl_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
block|}
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_IS_WAS_ON_RTR
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|ctl_enqueue_rtr
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CTL_MSG_FINISH_IO
case|:
if|if
condition|(
name|ctl_softc
operator|->
name|ha_mode
operator|==
name|CTL_HA_MODE_XFER
condition|)
block|{
name|free_io
operator|=
literal|0
expr_stmt|;
name|ctl_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|free_io
operator|=
literal|1
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|lun
operator|->
name|ooa_queue
argument_list|,
operator|&
name|io
operator|->
name|io_hdr
argument_list|,
name|ooa_links
argument_list|)
expr_stmt|;
name|ctl_check_blocked
argument_list|(
name|lun
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CTL_MSG_PERS_ACTION
case|:
name|ctl_hndl_per_res_out_on_other_sc
argument_list|(
operator|(
expr|union
name|ctl_ha_msg
operator|*
operator|)
operator|&
name|io
operator|->
name|presio
operator|.
name|pr_msg
argument_list|)
expr_stmt|;
name|free_io
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CTL_MSG_BAD_JUJU
case|:
name|free_io
operator|=
literal|0
expr_stmt|;
name|ctl_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_MSG_DATAMOVE
case|:
comment|/* Only used in XFER mode */
name|free_io
operator|=
literal|0
expr_stmt|;
name|ctl_datamove_remote
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_MSG_DATAMOVE_DONE
case|:
comment|/* Only used in XFER mode */
name|free_io
operator|=
literal|0
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|be_move_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
default|default:
name|free_io
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Invalid message type %d\n"
argument_list|,
name|__func__
argument_list|,
name|io
operator|->
name|io_hdr
operator|.
name|msg_type
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|free_io
condition|)
name|ctl_free_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns the match type in the case of a match, or CTL_LUN_PAT_NONE if  * there is no match.  */
end_comment

begin_function
specifier|static
name|ctl_lun_error_pattern
name|ctl_cmd_pattern_match
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|,
name|struct
name|ctl_error_desc
modifier|*
name|desc
parameter_list|)
block|{
specifier|const
name|struct
name|ctl_cmd_entry
modifier|*
name|entry
decl_stmt|;
name|ctl_lun_error_pattern
name|filtered_pattern
decl_stmt|,
name|pattern
decl_stmt|;
name|pattern
operator|=
name|desc
operator|->
name|error_pattern
expr_stmt|;
comment|/* 	 * XXX KDM we need more data passed into this function to match a 	 * custom pattern, and we actually need to implement custom pattern 	 * matching. 	 */
if|if
condition|(
name|pattern
operator|&
name|CTL_LUN_PAT_CMD
condition|)
return|return
operator|(
name|CTL_LUN_PAT_CMD
operator|)
return|;
if|if
condition|(
operator|(
name|pattern
operator|&
name|CTL_LUN_PAT_MASK
operator|)
operator|==
name|CTL_LUN_PAT_ANY
condition|)
return|return
operator|(
name|CTL_LUN_PAT_ANY
operator|)
return|;
name|entry
operator|=
name|ctl_get_cmd_entry
argument_list|(
name|ctsio
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|filtered_pattern
operator|=
name|entry
operator|->
name|pattern
operator|&
name|pattern
expr_stmt|;
comment|/* 	 * If the user requested specific flags in the pattern (e.g. 	 * CTL_LUN_PAT_RANGE), make sure the command supports all of those 	 * flags. 	 * 	 * If the user did not specify any flags, it doesn't matter whether 	 * or not the command supports the flags. 	 */
if|if
condition|(
operator|(
name|filtered_pattern
operator|&
operator|~
name|CTL_LUN_PAT_MASK
operator|)
operator|!=
operator|(
name|pattern
operator|&
operator|~
name|CTL_LUN_PAT_MASK
operator|)
condition|)
return|return
operator|(
name|CTL_LUN_PAT_NONE
operator|)
return|;
comment|/* 	 * If the user asked for a range check, see if the requested LBA 	 * range overlaps with this command's LBA range. 	 */
if|if
condition|(
name|filtered_pattern
operator|&
name|CTL_LUN_PAT_RANGE
condition|)
block|{
name|uint64_t
name|lba1
decl_stmt|;
name|uint64_t
name|len1
decl_stmt|;
name|ctl_action
name|action
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|ctl_get_lba_len
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|,
operator|&
name|lba1
argument_list|,
operator|&
name|len1
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
return|return
operator|(
name|CTL_LUN_PAT_NONE
operator|)
return|;
name|action
operator|=
name|ctl_extent_check_lba
argument_list|(
name|lba1
argument_list|,
name|len1
argument_list|,
name|desc
operator|->
name|lba_range
operator|.
name|lba
argument_list|,
name|desc
operator|->
name|lba_range
operator|.
name|len
argument_list|)
expr_stmt|;
comment|/* 		 * A "pass" means that the LBA ranges don't overlap, so 		 * this doesn't match the user's range criteria. 		 */
if|if
condition|(
name|action
operator|==
name|CTL_ACTION_PASS
condition|)
return|return
operator|(
name|CTL_LUN_PAT_NONE
operator|)
return|;
block|}
return|return
operator|(
name|filtered_pattern
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_inject_error
parameter_list|(
name|struct
name|ctl_lun
modifier|*
name|lun
parameter_list|,
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_error_desc
modifier|*
name|desc
decl_stmt|,
modifier|*
name|desc2
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|desc
argument_list|,
argument|&lun->error_list
argument_list|,
argument|links
argument_list|,
argument|desc2
argument_list|)
block|{
name|ctl_lun_error_pattern
name|pattern
decl_stmt|;
comment|/* 		 * Check to see whether this particular command matches 		 * the pattern in the descriptor. 		 */
name|pattern
operator|=
name|ctl_cmd_pattern_match
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|,
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pattern
operator|&
name|CTL_LUN_PAT_MASK
operator|)
operator|==
name|CTL_LUN_PAT_NONE
condition|)
continue|continue;
switch|switch
condition|(
name|desc
operator|->
name|lun_error
operator|&
name|CTL_LUN_INJ_TYPE
condition|)
block|{
case|case
name|CTL_LUN_INJ_ABORTED
case|:
name|ctl_set_aborted
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_LUN_INJ_MEDIUM_ERR
case|:
name|ctl_set_medium_error
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_LUN_INJ_UA
case|:
comment|/* 29h/00h  POWER ON, RESET, OR BUS DEVICE RESET 			 * OCCURRED */
name|ctl_set_ua
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|,
literal|0x29
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_LUN_INJ_CUSTOM
case|:
comment|/* 			 * We're assuming the user knows what he is doing. 			 * Just copy the sense information without doing 			 * checks. 			 */
name|bcopy
argument_list|(
operator|&
name|desc
operator|->
name|custom_sense
argument_list|,
operator|&
name|io
operator|->
name|scsiio
operator|.
name|sense_data
argument_list|,
name|ctl_min
argument_list|(
sizeof|sizeof
argument_list|(
name|desc
operator|->
name|custom_sense
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|io
operator|->
name|scsiio
operator|.
name|sense_data
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|scsi_status
operator|=
name|SCSI_STATUS_CHECK_COND
expr_stmt|;
name|io
operator|->
name|scsiio
operator|.
name|sense_len
operator|=
name|SSD_FULL_SIZE
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|=
name|CTL_SCSI_ERROR
operator||
name|CTL_AUTOSENSE
expr_stmt|;
break|break;
case|case
name|CTL_LUN_INJ_NONE
case|:
default|default:
comment|/* 			 * If this is an error injection type we don't know 			 * about, clear the continuous flag (if it is set) 			 * so it will get deleted below. 			 */
name|desc
operator|->
name|lun_error
operator|&=
operator|~
name|CTL_LUN_INJ_CONTINUOUS
expr_stmt|;
break|break;
block|}
comment|/* 		 * By default, each error injection action is a one-shot 		 */
if|if
condition|(
name|desc
operator|->
name|lun_error
operator|&
name|CTL_LUN_INJ_CONTINUOUS
condition|)
continue|continue;
name|STAILQ_REMOVE
argument_list|(
operator|&
name|lun
operator|->
name|error_list
argument_list|,
name|desc
argument_list|,
name|ctl_error_desc
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|desc
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CTL_IO_DELAY
end_ifdef

begin_function
specifier|static
name|void
name|ctl_datamove_timer_wakeup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|arg
expr_stmt|;
name|ctl_datamove
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CTL_IO_DELAY */
end_comment

begin_function
name|void
name|ctl_datamove
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|void
function_decl|(
modifier|*
name|fe_datamove
function_decl|)
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
name|mtx_assert
argument_list|(
operator|&
name|control_softc
operator|->
name|ctl_lock
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_datamove\n"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CTL_TIME_IO
if|if
condition|(
operator|(
name|time_uptime
operator|-
name|io
operator|->
name|io_hdr
operator|.
name|start_time
operator|)
operator|>
name|ctl_time_io_secs
condition|)
block|{
name|char
name|str
index|[
literal|256
index|]
decl_stmt|;
name|char
name|path_str
index|[
literal|64
index|]
decl_stmt|;
name|struct
name|sbuf
name|sb
decl_stmt|;
name|ctl_scsi_path_string
argument_list|(
name|io
argument_list|,
name|path_str
argument_list|,
sizeof|sizeof
argument_list|(
name|path_str
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_new
argument_list|(
operator|&
name|sb
argument_list|,
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|,
name|SBUF_FIXEDLEN
argument_list|)
expr_stmt|;
name|sbuf_cat
argument_list|(
operator|&
name|sb
argument_list|,
name|path_str
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|io_type
condition|)
block|{
case|case
name|CTL_IO_SCSI
case|:
name|ctl_scsi_command_string
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|,
name|NULL
argument_list|,
operator|&
name|sb
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|sbuf_cat
argument_list|(
operator|&
name|sb
argument_list|,
name|path_str
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"Tag: 0x%04x, type %d\n"
argument_list|,
name|io
operator|->
name|scsiio
operator|.
name|tag_num
argument_list|,
name|io
operator|->
name|scsiio
operator|.
name|tag_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_IO_TASK
case|:
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"Task I/O type: %d, Tag: 0x%04x, "
literal|"Tag Type: %d\n"
argument_list|,
name|io
operator|->
name|taskio
operator|.
name|task_action
argument_list|,
name|io
operator|->
name|taskio
operator|.
name|tag_num
argument_list|,
name|io
operator|->
name|taskio
operator|.
name|tag_type
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Invalid CTL I/O type %d\n"
argument_list|,
name|io
operator|->
name|io_hdr
operator|.
name|io_type
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"Invalid CTL I/O type %d\n"
argument_list|,
name|io
operator|->
name|io_hdr
operator|.
name|io_type
argument_list|)
expr_stmt|;
break|break;
block|}
name|sbuf_cat
argument_list|(
operator|&
name|sb
argument_list|,
name|path_str
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"ctl_datamove: %jd seconds\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|time_uptime
operator|-
name|io
operator|->
name|io_hdr
operator|.
name|start_time
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|sbuf_data
argument_list|(
operator|&
name|sb
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* CTL_TIME_IO */
ifdef|#
directive|ifdef
name|CTL_IO_DELAY
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_DELAY_DONE
condition|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LUN
index|]
operator|.
name|ptr
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&=
operator|~
name|CTL_FLAG_DELAY_DONE
expr_stmt|;
block|}
else|else
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LUN
index|]
operator|.
name|ptr
expr_stmt|;
if|if
condition|(
operator|(
name|lun
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|lun
operator|->
name|delay_info
operator|.
name|datamove_delay
operator|>
literal|0
operator|)
condition|)
block|{
name|struct
name|callout
modifier|*
name|callout
decl_stmt|;
name|callout
operator|=
operator|(
expr|struct
name|callout
operator|*
operator|)
operator|&
name|io
operator|->
name|io_hdr
operator|.
name|timer_bytes
expr_stmt|;
name|callout_init
argument_list|(
name|callout
argument_list|,
comment|/*mpsafe*/
literal|1
argument_list|)
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_DELAY_DONE
expr_stmt|;
name|callout_reset
argument_list|(
name|callout
argument_list|,
name|lun
operator|->
name|delay_info
operator|.
name|datamove_delay
operator|*
name|hz
argument_list|,
name|ctl_datamove_timer_wakeup
argument_list|,
name|io
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|delay_info
operator|.
name|datamove_type
operator|==
name|CTL_DELAY_TYPE_ONESHOT
condition|)
name|lun
operator|->
name|delay_info
operator|.
name|datamove_delay
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
comment|/* 	 * This command has been aborted.  Set the port status, so we fail 	 * the data move. 	 */
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ABORT
condition|)
block|{
name|printf
argument_list|(
literal|"ctl_datamove: tag 0x%04x on (%ju:%d:%ju:%d) aborted\n"
argument_list|,
name|io
operator|->
name|scsiio
operator|.
name|tag_num
argument_list|,
operator|(
name|uintmax_t
operator|)
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|initid
operator|.
name|id
argument_list|,
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
argument_list|,
operator|(
name|uintmax_t
operator|)
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_target
operator|.
name|id
argument_list|,
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_lun
argument_list|)
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|port_status
operator|=
literal|31337
expr_stmt|;
comment|/* 		 * Note that the backend, in this case, will get the 		 * callback in its context.  In other cases it may get 		 * called in the frontend's interrupt thread context. 		 */
name|io
operator|->
name|scsiio
operator|.
name|be_move_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If we're in XFER mode and this I/O is from the other shelf 	 * controller, we need to send the DMA to the other side to 	 * actually transfer the data to/from the host.  In serialize only 	 * mode the transfer happens below CTL and ctl_datamove() is only 	 * called on the machine that originally received the I/O. 	 */
if|if
condition|(
operator|(
name|control_softc
operator|->
name|ha_mode
operator|==
name|CTL_HA_MODE_XFER
operator|)
operator|&&
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_FROM_OTHER_SC
operator|)
condition|)
block|{
name|union
name|ctl_ha_msg
name|msg
decl_stmt|;
name|uint32_t
name|sg_entries_sent
decl_stmt|;
name|int
name|do_sg_copy
decl_stmt|;
name|int
name|i
decl_stmt|;
name|memset
argument_list|(
operator|&
name|msg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|msg
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_DATAMOVE
expr_stmt|;
name|msg
operator|.
name|hdr
operator|.
name|original_sc
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|original_sc
expr_stmt|;
name|msg
operator|.
name|hdr
operator|.
name|serializing_sc
operator|=
name|io
expr_stmt|;
name|msg
operator|.
name|hdr
operator|.
name|nexus
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|nexus
expr_stmt|;
name|msg
operator|.
name|dt
operator|.
name|flags
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|flags
expr_stmt|;
comment|/* 		 * We convert everything into a S/G list here.  We can't 		 * pass by reference, only by value between controllers. 		 * So we can't pass a pointer to the S/G list, only as many 		 * S/G entries as we can fit in here.  If it's possible for 		 * us to get more than CTL_HA_MAX_SG_ENTRIES S/G entries, 		 * then we need to break this up into multiple transfers. 		 */
if|if
condition|(
name|io
operator|->
name|scsiio
operator|.
name|kern_sg_entries
operator|==
literal|0
condition|)
block|{
name|msg
operator|.
name|dt
operator|.
name|kern_sg_entries
operator|=
literal|1
expr_stmt|;
comment|/* 			 * If this is in cached memory, flush the cache 			 * before we send the DMA request to the other 			 * controller.  We want to do this in either the 			 * read or the write case.  The read case is 			 * straightforward.  In the write case, we want to 			 * make sure nothing is in the local cache that 			 * could overwrite the DMAed data. 			 */
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_NO_DATASYNC
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * XXX KDM use bus_dmamap_sync() here. 				 */
block|}
comment|/* 			 * Convert to a physical address if this is a 			 * virtual address. 			 */
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_BUS_ADDR
condition|)
block|{
name|msg
operator|.
name|dt
operator|.
name|sg_list
index|[
literal|0
index|]
operator|.
name|addr
operator|=
name|io
operator|->
name|scsiio
operator|.
name|kern_data_ptr
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * XXX KDM use busdma here! 				 */
if|#
directive|if
literal|0
block|msg.dt.sg_list[0].addr = (void *) 					vtophys(io->scsiio.kern_data_ptr);
endif|#
directive|endif
block|}
name|msg
operator|.
name|dt
operator|.
name|sg_list
index|[
literal|0
index|]
operator|.
name|len
operator|=
name|io
operator|->
name|scsiio
operator|.
name|kern_data_len
expr_stmt|;
name|do_sg_copy
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|struct
name|ctl_sg_entry
modifier|*
name|sgl
decl_stmt|;
name|do_sg_copy
operator|=
literal|1
expr_stmt|;
name|msg
operator|.
name|dt
operator|.
name|kern_sg_entries
operator|=
name|io
operator|->
name|scsiio
operator|.
name|kern_sg_entries
expr_stmt|;
name|sgl
operator|=
operator|(
expr|struct
name|ctl_sg_entry
operator|*
operator|)
name|io
operator|->
name|scsiio
operator|.
name|kern_data_ptr
expr_stmt|;
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_NO_DATASYNC
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * XXX KDM use bus_dmamap_sync() here. 				 */
block|}
block|}
name|msg
operator|.
name|dt
operator|.
name|kern_data_len
operator|=
name|io
operator|->
name|scsiio
operator|.
name|kern_data_len
expr_stmt|;
name|msg
operator|.
name|dt
operator|.
name|kern_total_len
operator|=
name|io
operator|->
name|scsiio
operator|.
name|kern_total_len
expr_stmt|;
name|msg
operator|.
name|dt
operator|.
name|kern_data_resid
operator|=
name|io
operator|->
name|scsiio
operator|.
name|kern_data_resid
expr_stmt|;
name|msg
operator|.
name|dt
operator|.
name|kern_rel_offset
operator|=
name|io
operator|->
name|scsiio
operator|.
name|kern_rel_offset
expr_stmt|;
name|msg
operator|.
name|dt
operator|.
name|sg_sequence
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Loop until we've sent all of the S/G entries.  On the 		 * other end, we'll recompose these S/G entries into one 		 * contiguous list before passing it to the 		 */
for|for
control|(
name|sg_entries_sent
operator|=
literal|0
init|;
name|sg_entries_sent
operator|<
name|msg
operator|.
name|dt
operator|.
name|kern_sg_entries
condition|;
name|msg
operator|.
name|dt
operator|.
name|sg_sequence
operator|++
control|)
block|{
name|msg
operator|.
name|dt
operator|.
name|cur_sg_entries
operator|=
name|ctl_min
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
name|msg
operator|.
name|dt
operator|.
name|sg_list
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|msg
operator|.
name|dt
operator|.
name|sg_list
index|[
literal|0
index|]
argument_list|)
operator|)
argument_list|,
name|msg
operator|.
name|dt
operator|.
name|kern_sg_entries
operator|-
name|sg_entries_sent
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_sg_copy
operator|!=
literal|0
condition|)
block|{
name|struct
name|ctl_sg_entry
modifier|*
name|sgl
decl_stmt|;
name|int
name|j
decl_stmt|;
name|sgl
operator|=
operator|(
expr|struct
name|ctl_sg_entry
operator|*
operator|)
name|io
operator|->
name|scsiio
operator|.
name|kern_data_ptr
expr_stmt|;
comment|/* 				 * If this is in cached memory, flush the cache 				 * before we send the DMA request to the other 				 * controller.  We want to do this in either 				 * the * read or the write case.  The read 				 * case is straightforward.  In the write 				 * case, we want to make sure nothing is 				 * in the local cache that could overwrite 				 * the DMAed data. 				 */
for|for
control|(
name|i
operator|=
name|sg_entries_sent
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|msg
operator|.
name|dt
operator|.
name|cur_sg_entries
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_NO_DATASYNC
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 						 * XXX KDM use bus_dmamap_sync() 						 */
block|}
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_BUS_ADDR
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 						 * XXX KDM use busdma. 						 */
if|#
directive|if
literal|0
block|msg.dt.sg_list[j].addr =(void *) 						       vtophys(sgl[i].addr);
endif|#
directive|endif
block|}
else|else
block|{
name|msg
operator|.
name|dt
operator|.
name|sg_list
index|[
name|j
index|]
operator|.
name|addr
operator|=
name|sgl
index|[
name|i
index|]
operator|.
name|addr
expr_stmt|;
block|}
name|msg
operator|.
name|dt
operator|.
name|sg_list
index|[
name|j
index|]
operator|.
name|len
operator|=
name|sgl
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
block|}
block|}
name|sg_entries_sent
operator|+=
name|msg
operator|.
name|dt
operator|.
name|cur_sg_entries
expr_stmt|;
if|if
condition|(
name|sg_entries_sent
operator|>=
name|msg
operator|.
name|dt
operator|.
name|kern_sg_entries
condition|)
name|msg
operator|.
name|dt
operator|.
name|sg_last
operator|=
literal|1
expr_stmt|;
else|else
name|msg
operator|.
name|dt
operator|.
name|sg_last
operator|=
literal|0
expr_stmt|;
comment|/* 			 * XXX KDM drop and reacquire the lock here? 			 */
if|if
condition|(
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|>
name|CTL_HA_STATUS_SUCCESS
condition|)
block|{
comment|/* 				 * XXX do something here. 				 */
block|}
name|msg
operator|.
name|dt
operator|.
name|sent_sg_entries
operator|=
name|sg_entries_sent
expr_stmt|;
block|}
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&=
operator|~
name|CTL_FLAG_IO_ACTIVE
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_FAILOVER
condition|)
name|ctl_failover_io
argument_list|(
name|io
argument_list|,
comment|/*have_lock*/
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Lookup the fe_datamove() function for this particular 		 * front end. 		 */
name|fe_datamove
operator|=
name|control_softc
operator|->
name|ctl_ports
index|[
name|ctl_port_idx
argument_list|(
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
argument_list|)
index|]
operator|->
name|fe_datamove
expr_stmt|;
name|fe_datamove
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_send_datamove_done
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|,
name|int
name|have_lock
parameter_list|)
block|{
name|union
name|ctl_ha_msg
name|msg
decl_stmt|;
name|int
name|isc_status
decl_stmt|;
name|memset
argument_list|(
operator|&
name|msg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|msg
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_DATAMOVE_DONE
expr_stmt|;
name|msg
operator|.
name|hdr
operator|.
name|original_sc
operator|=
name|io
expr_stmt|;
name|msg
operator|.
name|hdr
operator|.
name|serializing_sc
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|serializing_sc
expr_stmt|;
name|msg
operator|.
name|hdr
operator|.
name|nexus
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|nexus
expr_stmt|;
name|msg
operator|.
name|hdr
operator|.
name|status
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|status
expr_stmt|;
name|msg
operator|.
name|scsi
operator|.
name|tag_num
operator|=
name|io
operator|->
name|scsiio
operator|.
name|tag_num
expr_stmt|;
name|msg
operator|.
name|scsi
operator|.
name|tag_type
operator|=
name|io
operator|->
name|scsiio
operator|.
name|tag_type
expr_stmt|;
name|msg
operator|.
name|scsi
operator|.
name|scsi_status
operator|=
name|io
operator|->
name|scsiio
operator|.
name|scsi_status
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|msg
operator|.
name|scsi
operator|.
name|sense_data
argument_list|,
operator|&
name|io
operator|->
name|scsiio
operator|.
name|sense_data
argument_list|,
sizeof|sizeof
argument_list|(
name|io
operator|->
name|scsiio
operator|.
name|sense_data
argument_list|)
argument_list|)
expr_stmt|;
name|msg
operator|.
name|scsi
operator|.
name|sense_len
operator|=
name|io
operator|->
name|scsiio
operator|.
name|sense_len
expr_stmt|;
name|msg
operator|.
name|scsi
operator|.
name|sense_residual
operator|=
name|io
operator|->
name|scsiio
operator|.
name|sense_residual
expr_stmt|;
name|msg
operator|.
name|scsi
operator|.
name|fetd_status
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|port_status
expr_stmt|;
name|msg
operator|.
name|scsi
operator|.
name|residual
operator|=
name|io
operator|->
name|scsiio
operator|.
name|residual
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&=
operator|~
name|CTL_FLAG_IO_ACTIVE
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_FAILOVER
condition|)
block|{
name|ctl_failover_io
argument_list|(
name|io
argument_list|,
comment|/*have_lock*/
name|have_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|isc_status
operator|=
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|isc_status
operator|>
name|CTL_HA_STATUS_SUCCESS
condition|)
block|{
comment|/* XXX do something if this fails */
block|}
block|}
end_function

begin_comment
comment|/*  * The DMA to the remote side is done, now we need to tell the other side  * we're done so it can continue with its data movement.  */
end_comment

begin_function
specifier|static
name|void
name|ctl_datamove_remote_write_cb
parameter_list|(
name|struct
name|ctl_ha_dt_req
modifier|*
name|rq
parameter_list|)
block|{
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|io
operator|=
name|rq
operator|->
name|context
expr_stmt|;
if|if
condition|(
name|rq
operator|->
name|ret
operator|!=
name|CTL_HA_STATUS_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ISC DMA write failed with error %d"
argument_list|,
name|__func__
argument_list|,
name|rq
operator|->
name|ret
argument_list|)
expr_stmt|;
name|ctl_set_internal_failure
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*retry_count*/
name|rq
operator|->
name|ret
argument_list|)
expr_stmt|;
block|}
name|ctl_dt_req_free
argument_list|(
name|rq
argument_list|)
expr_stmt|;
comment|/* 	 * In this case, we had to malloc the memory locally.  Free it. 	 */
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_AUTO_MIRROR
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|io
operator|->
name|scsiio
operator|.
name|kern_sg_entries
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|io
operator|->
name|io_hdr
operator|.
name|local_sglist
index|[
name|i
index|]
operator|.
name|addr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The data is in local and remote memory, so now we need to send 	 * status (good or back) back to the other side. 	 */
name|ctl_send_datamove_done
argument_list|(
name|io
argument_list|,
comment|/*have_lock*/
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * We've moved the data from the host/controller into local memory.  Now we  * need to push it over to the remote controller's memory.  */
end_comment

begin_function
specifier|static
name|int
name|ctl_datamove_remote_dm_write_cb
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|retval
operator|=
name|ctl_datamove_remote_xfer
argument_list|(
name|io
argument_list|,
name|CTL_HA_DT_CMD_WRITE
argument_list|,
name|ctl_datamove_remote_write_cb
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_datamove_remote_write
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|void
function_decl|(
modifier|*
name|fe_datamove
function_decl|)
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
comment|/* 	 * - Get the data from the host/HBA into local memory. 	 * - DMA memory from the local controller to the remote controller. 	 * - Send status back to the remote controller. 	 */
name|retval
operator|=
name|ctl_datamove_remote_sgl_setup
argument_list|(
name|io
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
return|return;
comment|/* Switch the pointer over so the FETD knows what to do */
name|io
operator|->
name|scsiio
operator|.
name|kern_data_ptr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|io
operator|->
name|io_hdr
operator|.
name|local_sglist
expr_stmt|;
comment|/* 	 * Use a custom move done callback, since we need to send completion 	 * back to the other controller, not to the backend on this side. 	 */
name|io
operator|->
name|scsiio
operator|.
name|be_move_done
operator|=
name|ctl_datamove_remote_dm_write_cb
expr_stmt|;
name|fe_datamove
operator|=
name|control_softc
operator|->
name|ctl_ports
index|[
name|ctl_port_idx
argument_list|(
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
argument_list|)
index|]
operator|->
name|fe_datamove
expr_stmt|;
name|fe_datamove
argument_list|(
name|io
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_datamove_remote_dm_read_cb
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
if|#
directive|if
literal|0
block|char str[256]; 	char path_str[64]; 	struct sbuf sb;
endif|#
directive|endif
comment|/* 	 * In this case, we had to malloc the memory locally.  Free it. 	 */
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_AUTO_MIRROR
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|io
operator|->
name|scsiio
operator|.
name|kern_sg_entries
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|io
operator|->
name|io_hdr
operator|.
name|local_sglist
index|[
name|i
index|]
operator|.
name|addr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|scsi_path_string(io, path_str, sizeof(path_str)); 	sbuf_new(&sb, str, sizeof(str), SBUF_FIXEDLEN); 	sbuf_cat(&sb, path_str); 	scsi_command_string(&io->scsiio, NULL,&sb); 	sbuf_printf(&sb, "\n"); 	sbuf_cat(&sb, path_str); 	sbuf_printf(&sb, "Tag: 0x%04x, type %d\n", 		    io->scsiio.tag_num, io->scsiio.tag_type); 	sbuf_cat(&sb, path_str); 	sbuf_printf(&sb, "%s: flags %#x, status %#x\n", __func__, 		    io->io_hdr.flags, io->io_hdr.status); 	sbuf_finish(&sb); 	printk("%s", sbuf_data(&sb));
endif|#
directive|endif
comment|/* 	 * The read is done, now we need to send status (good or bad) back 	 * to the other side. 	 */
name|ctl_send_datamove_done
argument_list|(
name|io
argument_list|,
comment|/*have_lock*/
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_datamove_remote_read_cb
parameter_list|(
name|struct
name|ctl_ha_dt_req
modifier|*
name|rq
parameter_list|)
block|{
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|void
function_decl|(
modifier|*
name|fe_datamove
function_decl|)
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
name|io
operator|=
name|rq
operator|->
name|context
expr_stmt|;
if|if
condition|(
name|rq
operator|->
name|ret
operator|!=
name|CTL_HA_STATUS_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ISC DMA read failed with error %d"
argument_list|,
name|__func__
argument_list|,
name|rq
operator|->
name|ret
argument_list|)
expr_stmt|;
name|ctl_set_internal_failure
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*retry_count*/
name|rq
operator|->
name|ret
argument_list|)
expr_stmt|;
block|}
name|ctl_dt_req_free
argument_list|(
name|rq
argument_list|)
expr_stmt|;
comment|/* Switch the pointer over so the FETD knows what to do */
name|io
operator|->
name|scsiio
operator|.
name|kern_data_ptr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|io
operator|->
name|io_hdr
operator|.
name|local_sglist
expr_stmt|;
comment|/* 	 * Use a custom move done callback, since we need to send completion 	 * back to the other controller, not to the backend on this side. 	 */
name|io
operator|->
name|scsiio
operator|.
name|be_move_done
operator|=
name|ctl_datamove_remote_dm_read_cb
expr_stmt|;
comment|/* XXX KDM add checks like the ones in ctl_datamove? */
name|fe_datamove
operator|=
name|control_softc
operator|->
name|ctl_ports
index|[
name|ctl_port_idx
argument_list|(
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
argument_list|)
index|]
operator|->
name|fe_datamove
expr_stmt|;
name|fe_datamove
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_datamove_remote_sgl_setup
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_sg_entry
modifier|*
name|local_sglist
decl_stmt|,
modifier|*
name|remote_sglist
decl_stmt|;
name|struct
name|ctl_sg_entry
modifier|*
name|local_dma_sglist
decl_stmt|,
modifier|*
name|remote_dma_sglist
decl_stmt|;
name|struct
name|ctl_softc
modifier|*
name|softc
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|int
name|i
decl_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|softc
operator|=
name|control_softc
expr_stmt|;
name|local_sglist
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|local_sglist
expr_stmt|;
name|local_dma_sglist
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|local_dma_sglist
expr_stmt|;
name|remote_sglist
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|remote_sglist
expr_stmt|;
name|remote_dma_sglist
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|remote_dma_sglist
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_AUTO_MIRROR
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|io
operator|->
name|scsiio
operator|.
name|kern_sg_entries
condition|;
name|i
operator|++
control|)
block|{
name|local_sglist
index|[
name|i
index|]
operator|.
name|len
operator|=
name|remote_sglist
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
comment|/* 			 * XXX Detect the situation where the RS-level I/O 			 * redirector on the other side has already read the 			 * data off of the AOR RS on this side, and 			 * transferred it to remote (mirror) memory on the 			 * other side.  Since we already have the data in 			 * memory here, we just need to use it. 			 * 			 * XXX KDM this can probably be removed once we 			 * get the cache device code in and take the 			 * current AOR implementation out. 			 */
ifdef|#
directive|ifdef
name|NEEDTOPORT
if|if
condition|(
operator|(
name|remote_sglist
index|[
name|i
index|]
operator|.
name|addr
operator|>=
operator|(
name|void
operator|*
operator|)
name|vtophys
argument_list|(
name|softc
operator|->
name|mirr
operator|->
name|addr
argument_list|)
operator|)
operator|&&
operator|(
name|remote_sglist
index|[
name|i
index|]
operator|.
name|addr
operator|<
operator|(
operator|(
name|void
operator|*
operator|)
name|vtophys
argument_list|(
name|softc
operator|->
name|mirr
operator|->
name|addr
argument_list|)
operator|+
name|CacheMirrorOffset
operator|)
operator|)
condition|)
block|{
name|local_sglist
index|[
name|i
index|]
operator|.
name|addr
operator|=
name|remote_sglist
index|[
name|i
index|]
operator|.
name|addr
operator|-
name|CacheMirrorOffset
expr_stmt|;
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_DATA_MASK
operator|)
operator|==
name|CTL_FLAG_DATA_IN
condition|)
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_REDIR_DONE
expr_stmt|;
block|}
else|else
block|{
name|local_sglist
index|[
name|i
index|]
operator|.
name|addr
operator|=
name|remote_sglist
index|[
name|i
index|]
operator|.
name|addr
operator|+
name|CacheMirrorOffset
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
literal|0
block|printf("%s: local %p, remote %p, len %d\n", 			       __func__, local_sglist[i].addr, 			       remote_sglist[i].addr, local_sglist[i].len);
endif|#
directive|endif
block|}
block|}
else|else
block|{
name|uint32_t
name|len_to_go
decl_stmt|;
comment|/* 		 * In this case, we don't have automatically allocated 		 * memory for this I/O on this controller.  This typically 		 * happens with internal CTL I/O -- e.g. inquiry, mode 		 * sense, etc.  Anything coming from RAIDCore will have 		 * a mirror area available. 		 */
name|len_to_go
operator|=
name|io
operator|->
name|scsiio
operator|.
name|kern_data_len
expr_stmt|;
comment|/* 		 * Clear the no datasync flag, we have to use malloced 		 * buffers. 		 */
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&=
operator|~
name|CTL_FLAG_NO_DATASYNC
expr_stmt|;
comment|/* 		 * The difficult thing here is that the size of the various 		 * S/G segments may be different than the size from the 		 * remote controller.  That'll make it harder when DMAing 		 * the data back to the other side. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
sizeof|sizeof
argument_list|(
name|io
operator|->
name|io_hdr
operator|.
name|remote_sglist
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|io
operator|->
name|io_hdr
operator|.
name|remote_sglist
index|[
literal|0
index|]
argument_list|)
operator|)
operator|&&
operator|(
name|len_to_go
operator|>
literal|0
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|local_sglist
index|[
name|i
index|]
operator|.
name|len
operator|=
name|ctl_min
argument_list|(
name|len_to_go
argument_list|,
literal|131072
argument_list|)
expr_stmt|;
name|CTL_SIZE_8B
argument_list|(
name|local_dma_sglist
index|[
name|i
index|]
operator|.
name|len
argument_list|,
name|local_sglist
index|[
name|i
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
name|local_sglist
index|[
name|i
index|]
operator|.
name|addr
operator|=
name|malloc
argument_list|(
name|local_dma_sglist
index|[
name|i
index|]
operator|.
name|len
argument_list|,
name|M_CTL
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|local_dma_sglist
index|[
name|i
index|]
operator|.
name|addr
operator|=
name|local_sglist
index|[
name|i
index|]
operator|.
name|addr
expr_stmt|;
if|if
condition|(
name|local_sglist
index|[
name|i
index|]
operator|.
name|addr
operator|==
name|NULL
condition|)
block|{
name|int
name|j
decl_stmt|;
name|printf
argument_list|(
literal|"malloc failed for %zd bytes!"
argument_list|,
name|local_dma_sglist
index|[
name|i
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
name|free
argument_list|(
name|local_sglist
index|[
name|j
index|]
operator|.
name|addr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
block|}
name|ctl_set_internal_failure
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|,
comment|/*sks_valid*/
literal|1
argument_list|,
comment|/*retry_count*/
literal|4857
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout_error
goto|;
block|}
comment|/* XXX KDM do we need a sync here? */
name|len_to_go
operator|-=
name|local_sglist
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
block|}
comment|/* 		 * Reset the number of S/G entries accordingly.  The 		 * original number of S/G entries is available in 		 * rem_sg_entries. 		 */
name|io
operator|->
name|scsiio
operator|.
name|kern_sg_entries
operator|=
name|i
expr_stmt|;
if|#
directive|if
literal|0
block|printf("%s: kern_sg_entries = %d\n", __func__, 		       io->scsiio.kern_sg_entries); 		for (i = 0; i< io->scsiio.kern_sg_entries; i++) 			printf("%s: sg[%d] = %p, %d (DMA: %d)\n", __func__, i, 			       local_sglist[i].addr, local_sglist[i].len, 			       local_dma_sglist[i].len);
endif|#
directive|endif
block|}
return|return
operator|(
name|retval
operator|)
return|;
name|bailout_error
label|:
name|ctl_send_datamove_done
argument_list|(
name|io
argument_list|,
comment|/*have_lock*/
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_datamove_remote_xfer
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|,
name|unsigned
name|command
parameter_list|,
name|ctl_ha_dt_cb
name|callback
parameter_list|)
block|{
name|struct
name|ctl_ha_dt_req
modifier|*
name|rq
decl_stmt|;
name|struct
name|ctl_sg_entry
modifier|*
name|remote_sglist
decl_stmt|,
modifier|*
name|local_sglist
decl_stmt|;
name|struct
name|ctl_sg_entry
modifier|*
name|remote_dma_sglist
decl_stmt|,
modifier|*
name|local_dma_sglist
decl_stmt|;
name|uint32_t
name|local_used
decl_stmt|,
name|remote_used
decl_stmt|,
name|total_used
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|rq
operator|=
name|ctl_dt_req_alloc
argument_list|()
expr_stmt|;
comment|/* 	 * If we failed to allocate the request, and if the DMA didn't fail 	 * anyway, set busy status.  This is just a resource allocation 	 * failure. 	 */
if|if
condition|(
operator|(
name|rq
operator|==
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|!=
name|CTL_STATUS_NONE
operator|)
condition|)
name|ctl_set_busy
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|!=
name|CTL_STATUS_NONE
condition|)
block|{
if|if
condition|(
name|rq
operator|!=
name|NULL
condition|)
name|ctl_dt_req_free
argument_list|(
name|rq
argument_list|)
expr_stmt|;
comment|/* 		 * The data move failed.  We need to return status back 		 * to the other controller.  No point in trying to DMA 		 * data to the remote controller. 		 */
name|ctl_send_datamove_done
argument_list|(
name|io
argument_list|,
comment|/*have_lock*/
literal|0
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|local_sglist
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|local_sglist
expr_stmt|;
name|local_dma_sglist
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|local_dma_sglist
expr_stmt|;
name|remote_sglist
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|remote_sglist
expr_stmt|;
name|remote_dma_sglist
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|remote_dma_sglist
expr_stmt|;
name|local_used
operator|=
literal|0
expr_stmt|;
name|remote_used
operator|=
literal|0
expr_stmt|;
name|total_used
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_REDIR_DONE
condition|)
block|{
name|rq
operator|->
name|ret
operator|=
name|CTL_HA_STATUS_SUCCESS
expr_stmt|;
name|rq
operator|->
name|context
operator|=
name|io
expr_stmt|;
name|callback
argument_list|(
name|rq
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
comment|/* 	 * Pull/push the data over the wire from/to the other controller. 	 * This takes into account the possibility that the local and 	 * remote sglists may not be identical in terms of the size of 	 * the elements and the number of elements. 	 * 	 * One fundamental assumption here is that the length allocated for 	 * both the local and remote sglists is identical.  Otherwise, we've 	 * essentially got a coding error of some sort. 	 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|total_used
operator|<
name|io
operator|->
name|scsiio
operator|.
name|kern_data_len
condition|;
control|)
block|{
name|int
name|isc_ret
decl_stmt|;
name|uint32_t
name|cur_len
decl_stmt|,
name|dma_length
decl_stmt|;
name|uint8_t
modifier|*
name|tmp_ptr
decl_stmt|;
name|rq
operator|->
name|id
operator|=
name|CTL_HA_DATA_CTL
expr_stmt|;
name|rq
operator|->
name|command
operator|=
name|command
expr_stmt|;
name|rq
operator|->
name|context
operator|=
name|io
expr_stmt|;
comment|/* 		 * Both pointers should be aligned.  But it is possible 		 * that the allocation length is not.  They should both 		 * also have enough slack left over at the end, though, 		 * to round up to the next 8 byte boundary. 		 */
name|cur_len
operator|=
name|ctl_min
argument_list|(
name|local_sglist
index|[
name|i
index|]
operator|.
name|len
operator|-
name|local_used
argument_list|,
name|remote_sglist
index|[
name|j
index|]
operator|.
name|len
operator|-
name|remote_used
argument_list|)
expr_stmt|;
comment|/* 		 * In this case, we have a size issue and need to decrease 		 * the size, except in the case where we actually have less 		 * than 8 bytes left.  In that case, we need to increase 		 * the DMA length to get the last bit. 		 */
if|if
condition|(
operator|(
name|cur_len
operator|&
literal|0x7
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|cur_len
operator|>
literal|0x7
condition|)
block|{
name|cur_len
operator|=
name|cur_len
operator|-
operator|(
name|cur_len
operator|&
literal|0x7
operator|)
expr_stmt|;
name|dma_length
operator|=
name|cur_len
expr_stmt|;
block|}
else|else
block|{
name|CTL_SIZE_8B
argument_list|(
name|dma_length
argument_list|,
name|cur_len
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|dma_length
operator|=
name|cur_len
expr_stmt|;
comment|/* 		 * If we had to allocate memory for this I/O, instead of using 		 * the non-cached mirror memory, we'll need to flush the cache 		 * before trying to DMA to the other controller. 		 * 		 * We could end up doing this multiple times for the same 		 * segment if we have a larger local segment than remote 		 * segment.  That shouldn't be an issue. 		 */
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_NO_DATASYNC
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * XXX KDM use bus_dmamap_sync() here. 			 */
block|}
name|rq
operator|->
name|size
operator|=
name|dma_length
expr_stmt|;
name|tmp_ptr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|local_sglist
index|[
name|i
index|]
operator|.
name|addr
expr_stmt|;
name|tmp_ptr
operator|+=
name|local_used
expr_stmt|;
comment|/* Use physical addresses when talking to ISC hardware */
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_BUS_ADDR
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* XXX KDM use busdma */
if|#
directive|if
literal|0
block|rq->local = vtophys(tmp_ptr);
endif|#
directive|endif
block|}
else|else
name|rq
operator|->
name|local
operator|=
name|tmp_ptr
expr_stmt|;
name|tmp_ptr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|remote_sglist
index|[
name|j
index|]
operator|.
name|addr
expr_stmt|;
name|tmp_ptr
operator|+=
name|remote_used
expr_stmt|;
name|rq
operator|->
name|remote
operator|=
name|tmp_ptr
expr_stmt|;
name|rq
operator|->
name|callback
operator|=
name|NULL
expr_stmt|;
name|local_used
operator|+=
name|cur_len
expr_stmt|;
if|if
condition|(
name|local_used
operator|>=
name|local_sglist
index|[
name|i
index|]
operator|.
name|len
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|local_used
operator|=
literal|0
expr_stmt|;
block|}
name|remote_used
operator|+=
name|cur_len
expr_stmt|;
if|if
condition|(
name|remote_used
operator|>=
name|remote_sglist
index|[
name|j
index|]
operator|.
name|len
condition|)
block|{
name|j
operator|++
expr_stmt|;
name|remote_used
operator|=
literal|0
expr_stmt|;
block|}
name|total_used
operator|+=
name|cur_len
expr_stmt|;
if|if
condition|(
name|total_used
operator|>=
name|io
operator|->
name|scsiio
operator|.
name|kern_data_len
condition|)
name|rq
operator|->
name|callback
operator|=
name|callback
expr_stmt|;
if|if
condition|(
operator|(
name|rq
operator|->
name|size
operator|&
literal|0x7
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: warning: size %d is not on 8b boundary\n"
argument_list|,
name|__func__
argument_list|,
name|rq
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|uintptr_t
operator|)
name|rq
operator|->
name|local
operator|&
literal|0x7
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: warning: local %p not on 8b boundary\n"
argument_list|,
name|__func__
argument_list|,
name|rq
operator|->
name|local
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|uintptr_t
operator|)
name|rq
operator|->
name|remote
operator|&
literal|0x7
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: warning: remote %p not on 8b boundary\n"
argument_list|,
name|__func__
argument_list|,
name|rq
operator|->
name|local
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|printf("%s: %s: local %#x remote %#x size %d\n", __func__, 		       (command == CTL_HA_DT_CMD_WRITE) ? "WRITE" : "READ", 		       rq->local, rq->remote, rq->size);
endif|#
directive|endif
name|isc_ret
operator|=
name|ctl_dt_single
argument_list|(
name|rq
argument_list|)
expr_stmt|;
if|if
condition|(
name|isc_ret
operator|==
name|CTL_HA_STATUS_WAIT
condition|)
continue|continue;
if|if
condition|(
name|isc_ret
operator|==
name|CTL_HA_STATUS_DISCONNECT
condition|)
block|{
name|rq
operator|->
name|ret
operator|=
name|CTL_HA_STATUS_SUCCESS
expr_stmt|;
block|}
else|else
block|{
name|rq
operator|->
name|ret
operator|=
name|isc_ret
expr_stmt|;
block|}
name|callback
argument_list|(
name|rq
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|bailout
label|:
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_datamove_remote_read
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * This will send an error to the other controller in the case of a 	 * failure. 	 */
name|retval
operator|=
name|ctl_datamove_remote_sgl_setup
argument_list|(
name|io
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
return|return;
name|retval
operator|=
name|ctl_datamove_remote_xfer
argument_list|(
name|io
argument_list|,
name|CTL_HA_DT_CMD_READ
argument_list|,
name|ctl_datamove_remote_read_cb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|retval
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_AUTO_MIRROR
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * Make sure we free memory if there was an error..  The 		 * ctl_datamove_remote_xfer() function will send the 		 * datamove done message, or call the callback with an 		 * error if there is a problem. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|io
operator|->
name|scsiio
operator|.
name|kern_sg_entries
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|io
operator|->
name|io_hdr
operator|.
name|local_sglist
index|[
name|i
index|]
operator|.
name|addr
argument_list|,
name|M_CTL
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * Process a datamove request from the other controller.  This is used for  * XFER mode only, not SER_ONLY mode.  For writes, we DMA into local memory  * first.  Once that is complete, the data gets DMAed into the remote  * controller's memory.  For reads, we DMA from the remote controller's  * memory into our memory first, and then move it out to the FETD.  */
end_comment

begin_function
specifier|static
name|void
name|ctl_datamove_remote
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
decl_stmt|;
name|softc
operator|=
name|control_softc
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
comment|/* 	 * Note that we look for an aborted I/O here, but don't do some of 	 * the other checks that ctl_datamove() normally does. 	 * We don't need to run the datamove delay code, since that should 	 * have been done if need be on the other controller. 	 */
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ABORT
condition|)
block|{
name|printf
argument_list|(
literal|"%s: tag 0x%04x on (%d:%d:%d:%d) aborted\n"
argument_list|,
name|__func__
argument_list|,
name|io
operator|->
name|scsiio
operator|.
name|tag_num
argument_list|,
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|initid
operator|.
name|id
argument_list|,
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
argument_list|,
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_target
operator|.
name|id
argument_list|,
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_lun
argument_list|)
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|port_status
operator|=
literal|31338
expr_stmt|;
name|ctl_send_datamove_done
argument_list|(
name|io
argument_list|,
comment|/*have_lock*/
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_DATA_MASK
operator|)
operator|==
name|CTL_FLAG_DATA_OUT
condition|)
block|{
name|ctl_datamove_remote_write
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_DATA_MASK
operator|)
operator|==
name|CTL_FLAG_DATA_IN
condition|)
block|{
name|ctl_datamove_remote_read
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|union
name|ctl_ha_msg
name|msg
decl_stmt|;
name|struct
name|scsi_sense_data
modifier|*
name|sense
decl_stmt|;
name|uint8_t
name|sks
index|[
literal|3
index|]
decl_stmt|;
name|int
name|retry_count
decl_stmt|;
name|memset
argument_list|(
operator|&
name|msg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|msg
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_BAD_JUJU
expr_stmt|;
name|msg
operator|.
name|hdr
operator|.
name|status
operator|=
name|CTL_SCSI_ERROR
expr_stmt|;
name|msg
operator|.
name|scsi
operator|.
name|scsi_status
operator|=
name|SCSI_STATUS_CHECK_COND
expr_stmt|;
name|retry_count
operator|=
literal|4243
expr_stmt|;
name|sense
operator|=
operator|&
name|msg
operator|.
name|scsi
operator|.
name|sense_data
expr_stmt|;
name|sks
index|[
literal|0
index|]
operator|=
name|SSD_SCS_VALID
expr_stmt|;
name|sks
index|[
literal|1
index|]
operator|=
operator|(
name|retry_count
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|sks
index|[
literal|2
index|]
operator|=
name|retry_count
operator|&
literal|0xff
expr_stmt|;
comment|/* "Internal target failure" */
name|scsi_set_sense_data
argument_list|(
name|sense
argument_list|,
comment|/*sense_format*/
name|SSD_TYPE_NONE
argument_list|,
comment|/*current_error*/
literal|1
argument_list|,
comment|/*sense_key*/
name|SSD_KEY_HARDWARE_ERROR
argument_list|,
comment|/*asc*/
literal|0x44
argument_list|,
comment|/*ascq*/
literal|0x00
argument_list|,
comment|/*type*/
name|SSD_ELEM_SKS
argument_list|,
comment|/*size*/
sizeof|sizeof
argument_list|(
name|sks
argument_list|)
argument_list|,
comment|/*data*/
name|sks
argument_list|,
name|SSD_ELEM_NONE
argument_list|)
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&=
operator|~
name|CTL_FLAG_IO_ACTIVE
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_FAILOVER
condition|)
block|{
name|ctl_failover_io
argument_list|(
name|io
argument_list|,
comment|/*have_lock*/
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|>
name|CTL_HA_STATUS_SUCCESS
condition|)
block|{
comment|/* XXX KDM what to do if this fails? */
block|}
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ctl_process_done
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|struct
name|ctl_softc
modifier|*
name|ctl_softc
decl_stmt|;
name|void
function_decl|(
modifier|*
name|fe_done
function_decl|)
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
function_decl|;
name|uint32_t
name|targ_port
init|=
name|ctl_port_idx
argument_list|(
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
argument_list|)
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_process_done\n"
operator|)
argument_list|)
expr_stmt|;
name|fe_done
operator|=
name|control_softc
operator|->
name|ctl_ports
index|[
name|targ_port
index|]
operator|->
name|fe_done
expr_stmt|;
ifdef|#
directive|ifdef
name|CTL_TIME_IO
if|if
condition|(
operator|(
name|time_uptime
operator|-
name|io
operator|->
name|io_hdr
operator|.
name|start_time
operator|)
operator|>
name|ctl_time_io_secs
condition|)
block|{
name|char
name|str
index|[
literal|256
index|]
decl_stmt|;
name|char
name|path_str
index|[
literal|64
index|]
decl_stmt|;
name|struct
name|sbuf
name|sb
decl_stmt|;
name|ctl_scsi_path_string
argument_list|(
name|io
argument_list|,
name|path_str
argument_list|,
sizeof|sizeof
argument_list|(
name|path_str
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_new
argument_list|(
operator|&
name|sb
argument_list|,
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|,
name|SBUF_FIXEDLEN
argument_list|)
expr_stmt|;
name|sbuf_cat
argument_list|(
operator|&
name|sb
argument_list|,
name|path_str
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|io_type
condition|)
block|{
case|case
name|CTL_IO_SCSI
case|:
name|ctl_scsi_command_string
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|,
name|NULL
argument_list|,
operator|&
name|sb
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|sbuf_cat
argument_list|(
operator|&
name|sb
argument_list|,
name|path_str
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"Tag: 0x%04x, type %d\n"
argument_list|,
name|io
operator|->
name|scsiio
operator|.
name|tag_num
argument_list|,
name|io
operator|->
name|scsiio
operator|.
name|tag_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_IO_TASK
case|:
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"Task I/O type: %d, Tag: 0x%04x, "
literal|"Tag Type: %d\n"
argument_list|,
name|io
operator|->
name|taskio
operator|.
name|task_action
argument_list|,
name|io
operator|->
name|taskio
operator|.
name|tag_num
argument_list|,
name|io
operator|->
name|taskio
operator|.
name|tag_type
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Invalid CTL I/O type %d\n"
argument_list|,
name|io
operator|->
name|io_hdr
operator|.
name|io_type
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"Invalid CTL I/O type %d\n"
argument_list|,
name|io
operator|->
name|io_hdr
operator|.
name|io_type
argument_list|)
expr_stmt|;
break|break;
block|}
name|sbuf_cat
argument_list|(
operator|&
name|sb
argument_list|,
name|path_str
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"ctl_process_done: %jd seconds\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|time_uptime
operator|-
name|io
operator|->
name|io_hdr
operator|.
name|start_time
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|sbuf_data
argument_list|(
operator|&
name|sb
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* CTL_TIME_IO */
switch|switch
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|io_type
condition|)
block|{
case|case
name|CTL_IO_SCSI
case|:
break|break;
case|case
name|CTL_IO_TASK
case|:
if|if
condition|(
name|bootverbose
operator|||
name|verbose
operator|>
literal|0
condition|)
name|ctl_io_error_print
argument_list|(
name|io
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_FROM_OTHER_SC
condition|)
name|ctl_free_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
else|else
name|fe_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
break|break;
default|default:
name|printf
argument_list|(
literal|"ctl_process_done: invalid io type %d\n"
argument_list|,
name|io
operator|->
name|io_hdr
operator|.
name|io_type
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"ctl_process_done: invalid io type %d\n"
argument_list|,
name|io
operator|->
name|io_hdr
operator|.
name|io_type
argument_list|)
expr_stmt|;
break|break;
comment|/* NOTREACHED */
block|}
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LUN
index|]
operator|.
name|ptr
expr_stmt|;
if|if
condition|(
name|lun
operator|==
name|NULL
condition|)
block|{
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"NULL LUN for lun %d\n"
operator|,
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_mapped_lun
operator|)
argument_list|)
expr_stmt|;
name|fe_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|ctl_softc
operator|=
name|lun
operator|->
name|ctl_softc
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Check to see if we have any errors to inject here.  We only 	 * inject errors for commands that don't already have errors set. 	 */
if|if
condition|(
operator|(
name|STAILQ_FIRST
argument_list|(
operator|&
name|lun
operator|->
name|error_list
argument_list|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|==
name|CTL_SUCCESS
operator|)
condition|)
name|ctl_inject_error
argument_list|(
name|lun
argument_list|,
name|io
argument_list|)
expr_stmt|;
comment|/* 	 * XXX KDM how do we treat commands that aren't completed 	 * successfully? 	 * 	 * XXX KDM should we also track I/O latency? 	 */
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|==
name|CTL_SUCCESS
operator|&&
name|io
operator|->
name|io_hdr
operator|.
name|io_type
operator|==
name|CTL_IO_SCSI
condition|)
block|{
ifdef|#
directive|ifdef
name|CTL_TIME_IO
name|struct
name|bintime
name|cur_bt
decl_stmt|;
endif|#
directive|endif
name|int
name|type
decl_stmt|;
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_DATA_MASK
operator|)
operator|==
name|CTL_FLAG_DATA_IN
condition|)
name|type
operator|=
name|CTL_STATS_READ
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_DATA_MASK
operator|)
operator|==
name|CTL_FLAG_DATA_OUT
condition|)
name|type
operator|=
name|CTL_STATS_WRITE
expr_stmt|;
else|else
name|type
operator|=
name|CTL_STATS_NO_IO
expr_stmt|;
name|lun
operator|->
name|stats
operator|.
name|ports
index|[
name|targ_port
index|]
operator|.
name|bytes
index|[
name|type
index|]
operator|+=
name|io
operator|->
name|scsiio
operator|.
name|kern_total_len
expr_stmt|;
name|lun
operator|->
name|stats
operator|.
name|ports
index|[
name|targ_port
index|]
operator|.
name|operations
index|[
name|type
index|]
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|CTL_TIME_IO
name|bintime_add
argument_list|(
operator|&
name|lun
operator|->
name|stats
operator|.
name|ports
index|[
name|targ_port
index|]
operator|.
name|dma_time
index|[
name|type
index|]
argument_list|,
operator|&
name|io
operator|->
name|io_hdr
operator|.
name|dma_bt
argument_list|)
expr_stmt|;
name|lun
operator|->
name|stats
operator|.
name|ports
index|[
name|targ_port
index|]
operator|.
name|num_dmas
index|[
name|type
index|]
operator|+=
name|io
operator|->
name|io_hdr
operator|.
name|num_dmas
expr_stmt|;
name|getbintime
argument_list|(
operator|&
name|cur_bt
argument_list|)
expr_stmt|;
name|bintime_sub
argument_list|(
operator|&
name|cur_bt
argument_list|,
operator|&
name|io
operator|->
name|io_hdr
operator|.
name|start_bt
argument_list|)
expr_stmt|;
name|bintime_add
argument_list|(
operator|&
name|lun
operator|->
name|stats
operator|.
name|ports
index|[
name|targ_port
index|]
operator|.
name|time
index|[
name|type
index|]
argument_list|,
operator|&
name|cur_bt
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * Remove this from the OOA queue. 	 */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|lun
operator|->
name|ooa_queue
argument_list|,
operator|&
name|io
operator|->
name|io_hdr
argument_list|,
name|ooa_links
argument_list|)
expr_stmt|;
comment|/* 	 * Run through the blocked queue on this LUN and see if anything 	 * has become unblocked, now that this transaction is done. 	 */
name|ctl_check_blocked
argument_list|(
name|lun
argument_list|)
expr_stmt|;
comment|/* 	 * If the LUN has been invalidated, free it if there is nothing 	 * left on its OOA queue. 	 */
if|if
condition|(
operator|(
name|lun
operator|->
name|flags
operator|&
name|CTL_LUN_INVALID
operator|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|lun
operator|->
name|ooa_queue
argument_list|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ctl_softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|ctl_free_lun
argument_list|(
name|lun
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ctl_softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
block|}
else|else
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
comment|/* 	 * If this command has been aborted, make sure we set the status 	 * properly.  The FETD is responsible for freeing the I/O and doing 	 * whatever it needs to do to clean up its state. 	 */
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_ABORT
condition|)
name|ctl_set_task_aborted
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
comment|/* 	 * We print out status for every task management command.  For SCSI 	 * commands, we filter out any unit attention errors; they happen 	 * on every boot, and would clutter up the log.  Note:  task 	 * management commands aren't printed here, they are printed above, 	 * since they should never even make it down here. 	 */
switch|switch
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|io_type
condition|)
block|{
case|case
name|CTL_IO_SCSI
case|:
block|{
name|int
name|error_code
decl_stmt|,
name|sense_key
decl_stmt|,
name|asc
decl_stmt|,
name|ascq
decl_stmt|;
name|sense_key
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|==
name|CTL_SCSI_ERROR
operator|)
operator|&&
operator|(
name|io
operator|->
name|scsiio
operator|.
name|scsi_status
operator|==
name|SCSI_STATUS_CHECK_COND
operator|)
condition|)
block|{
comment|/* 			 * Since this is just for printing, no need to 			 * show errors here. 			 */
name|scsi_extract_sense_len
argument_list|(
operator|&
name|io
operator|->
name|scsiio
operator|.
name|sense_data
argument_list|,
name|io
operator|->
name|scsiio
operator|.
name|sense_len
argument_list|,
operator|&
name|error_code
argument_list|,
operator|&
name|sense_key
argument_list|,
operator|&
name|asc
argument_list|,
operator|&
name|ascq
argument_list|,
comment|/*show_errors*/
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|!=
name|CTL_SUCCESS
operator|)
operator|&&
operator|(
operator|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|status
operator|&
name|CTL_STATUS_MASK
operator|)
operator|!=
name|CTL_SCSI_ERROR
operator|)
operator|||
operator|(
name|io
operator|->
name|scsiio
operator|.
name|scsi_status
operator|!=
name|SCSI_STATUS_CHECK_COND
operator|)
operator|||
operator|(
name|sense_key
operator|!=
name|SSD_KEY_UNIT_ATTENTION
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|time_uptime
operator|-
name|ctl_softc
operator|->
name|last_print_jiffies
operator|)
operator|<=
literal|0
condition|)
block|{
name|ctl_softc
operator|->
name|skipped_prints
operator|++
expr_stmt|;
block|}
else|else
block|{
name|uint32_t
name|skipped_prints
decl_stmt|;
name|skipped_prints
operator|=
name|ctl_softc
operator|->
name|skipped_prints
expr_stmt|;
name|ctl_softc
operator|->
name|skipped_prints
operator|=
literal|0
expr_stmt|;
name|ctl_softc
operator|->
name|last_print_jiffies
operator|=
name|time_uptime
expr_stmt|;
if|if
condition|(
name|skipped_prints
operator|>
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|NEEDTOPORT
name|csevent_log
argument_list|(
name|CSC_CTL
operator||
name|CSC_SHELF_SW
operator||
name|CTL_ERROR_REPORT
argument_list|,
name|csevent_LogType_Trace
argument_list|,
name|csevent_Severity_Information
argument_list|,
name|csevent_AlertLevel_Green
argument_list|,
name|csevent_FRU_Firmware
argument_list|,
name|csevent_FRU_Unknown
argument_list|,
literal|"High CTL error volume, %d prints "
literal|"skipped"
argument_list|,
name|skipped_prints
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|bootverbose
operator|||
name|verbose
operator|>
literal|0
condition|)
name|ctl_io_error_print
argument_list|(
name|io
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|CTL_IO_TASK
case|:
if|if
condition|(
name|bootverbose
operator|||
name|verbose
operator|>
literal|0
condition|)
name|ctl_io_error_print
argument_list|(
name|io
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* 	 * Tell the FETD or the other shelf controller we're done with this 	 * command.  Note that only SCSI commands get to this point.  Task 	 * management commands are completed above. 	 * 	 * We only send status to the other controller if we're in XFER 	 * mode.  In SER_ONLY mode, the I/O is done on the controller that 	 * received the I/O (from CTL's perspective), and so the status is 	 * generated there. 	 *  	 * XXX KDM if we hold the lock here, we could cause a deadlock 	 * if the frontend comes back in in this context to queue 	 * something. 	 */
if|if
condition|(
operator|(
name|ctl_softc
operator|->
name|ha_mode
operator|==
name|CTL_HA_MODE_XFER
operator|)
operator|&&
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_FROM_OTHER_SC
operator|)
condition|)
block|{
name|union
name|ctl_ha_msg
name|msg
decl_stmt|;
name|memset
argument_list|(
operator|&
name|msg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|msg
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_FINISH_IO
expr_stmt|;
name|msg
operator|.
name|hdr
operator|.
name|original_sc
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|original_sc
expr_stmt|;
name|msg
operator|.
name|hdr
operator|.
name|nexus
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|nexus
expr_stmt|;
name|msg
operator|.
name|hdr
operator|.
name|status
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|status
expr_stmt|;
name|msg
operator|.
name|scsi
operator|.
name|scsi_status
operator|=
name|io
operator|->
name|scsiio
operator|.
name|scsi_status
expr_stmt|;
name|msg
operator|.
name|scsi
operator|.
name|tag_num
operator|=
name|io
operator|->
name|scsiio
operator|.
name|tag_num
expr_stmt|;
name|msg
operator|.
name|scsi
operator|.
name|tag_type
operator|=
name|io
operator|->
name|scsiio
operator|.
name|tag_type
expr_stmt|;
name|msg
operator|.
name|scsi
operator|.
name|sense_len
operator|=
name|io
operator|->
name|scsiio
operator|.
name|sense_len
expr_stmt|;
name|msg
operator|.
name|scsi
operator|.
name|sense_residual
operator|=
name|io
operator|->
name|scsiio
operator|.
name|sense_residual
expr_stmt|;
name|msg
operator|.
name|scsi
operator|.
name|residual
operator|=
name|io
operator|->
name|scsiio
operator|.
name|residual
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|msg
operator|.
name|scsi
operator|.
name|sense_data
argument_list|,
operator|&
name|io
operator|->
name|scsiio
operator|.
name|sense_data
argument_list|,
sizeof|sizeof
argument_list|(
name|io
operator|->
name|scsiio
operator|.
name|sense_data
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * We copy this whether or not this is an I/O-related 		 * command.  Otherwise, we'd have to go and check to see 		 * whether it's a read/write command, and it really isn't 		 * worth it. 		 */
name|memcpy
argument_list|(
operator|&
name|msg
operator|.
name|scsi
operator|.
name|lbalen
argument_list|,
operator|&
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LBA_LEN
index|]
operator|.
name|bytes
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
operator|.
name|scsi
operator|.
name|lbalen
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|>
name|CTL_HA_STATUS_SUCCESS
condition|)
block|{
comment|/* XXX do something here */
block|}
name|ctl_free_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
else|else
name|fe_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|bailout
label|:
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CTL_WITH_CA
end_ifdef

begin_comment
comment|/*  * Front end should call this if it doesn't do autosense.  When the request  * sense comes back in from the initiator, we'll dequeue this and send it.  */
end_comment

begin_function
name|int
name|ctl_queue_sense
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|struct
name|ctl_softc
modifier|*
name|ctl_softc
decl_stmt|;
name|uint32_t
name|initidx
decl_stmt|,
name|targ_lun
decl_stmt|;
name|ctl_softc
operator|=
name|control_softc
expr_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_queue_sense\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * LUN lookup will likely move to the ctl_work_thread() once we 	 * have our new queueing infrastructure (that doesn't put things on 	 * a per-LUN queue initially).  That is so that we can handle 	 * things like an INQUIRY to a LUN that we don't have enabled.  We 	 * can't deal with that right now. 	 */
name|mtx_lock
argument_list|(
operator|&
name|ctl_softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
comment|/* 	 * If we don't have a LUN for this, just toss the sense 	 * information. 	 */
name|targ_lun
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_lun
expr_stmt|;
name|targ_lun
operator|=
name|ctl_map_lun
argument_list|(
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
argument_list|,
name|targ_lun
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|targ_lun
operator|<
name|CTL_MAX_LUNS
operator|)
operator|&&
operator|(
name|ctl_softc
operator|->
name|ctl_luns
index|[
name|targ_lun
index|]
operator|!=
name|NULL
operator|)
condition|)
name|lun
operator|=
name|ctl_softc
operator|->
name|ctl_luns
index|[
name|targ_lun
index|]
expr_stmt|;
else|else
goto|goto
name|bailout
goto|;
name|initidx
operator|=
name|ctl_get_initindex
argument_list|(
operator|&
name|io
operator|->
name|io_hdr
operator|.
name|nexus
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Already have CA set for this LUN...toss the sense information. 	 */
if|if
condition|(
name|ctl_is_set
argument_list|(
name|lun
operator|->
name|have_ca
argument_list|,
name|initidx
argument_list|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|memcpy
argument_list|(
operator|&
name|lun
operator|->
name|pending_sense
index|[
name|initidx
index|]
argument_list|,
operator|&
name|io
operator|->
name|scsiio
operator|.
name|sense_data
argument_list|,
name|ctl_min
argument_list|(
sizeof|sizeof
argument_list|(
name|lun
operator|->
name|pending_sense
index|[
name|initidx
index|]
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|io
operator|->
name|scsiio
operator|.
name|sense_data
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ctl_set_mask
argument_list|(
name|lun
operator|->
name|have_ca
argument_list|,
name|initidx
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lun
operator|->
name|lun_lock
argument_list|)
expr_stmt|;
name|bailout
label|:
name|mtx_unlock
argument_list|(
operator|&
name|ctl_softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|ctl_free_io
argument_list|(
name|io
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Primary command inlet from frontend ports.  All SCSI and task I/O  * requests must go through this function.  */
end_comment

begin_function
name|int
name|ctl_queue
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|ctl_softc
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_queue cdb[0]=%02X\n"
operator|,
name|io
operator|->
name|scsiio
operator|.
name|cdb
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
name|ctl_softc
operator|=
name|control_softc
expr_stmt|;
ifdef|#
directive|ifdef
name|CTL_TIME_IO
name|io
operator|->
name|io_hdr
operator|.
name|start_time
operator|=
name|time_uptime
expr_stmt|;
name|getbintime
argument_list|(
operator|&
name|io
operator|->
name|io_hdr
operator|.
name|start_bt
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CTL_TIME_IO */
comment|/* Map FE-specific LUN ID into global one. */
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_mapped_lun
operator|=
name|ctl_map_lun
argument_list|(
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
argument_list|,
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_lun
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|io_type
condition|)
block|{
case|case
name|CTL_IO_SCSI
case|:
case|case
name|CTL_IO_TASK
case|:
name|ctl_enqueue_incoming
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"ctl_queue: unknown I/O type %d\n"
argument_list|,
name|io
operator|->
name|io_hdr
operator|.
name|io_type
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
name|CTL_RETVAL_COMPLETE
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CTL_IO_DELAY
end_ifdef

begin_function
specifier|static
name|void
name|ctl_done_timer_wakeup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|arg
expr_stmt|;
name|ctl_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CTL_IO_DELAY */
end_comment

begin_function
name|void
name|ctl_done
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|ctl_softc
decl_stmt|;
name|ctl_softc
operator|=
name|control_softc
expr_stmt|;
comment|/* 	 * Enable this to catch duplicate completion issues. 	 */
if|#
directive|if
literal|0
block|if (io->io_hdr.flags& CTL_FLAG_ALREADY_DONE) { 		printf("%s: type %d msg %d cdb %x iptl: " 		       "%d:%d:%d:%d tag 0x%04x " 		       "flag %#x status %x\n", 			__func__, 			io->io_hdr.io_type, 			io->io_hdr.msg_type, 			io->scsiio.cdb[0], 			io->io_hdr.nexus.initid.id, 			io->io_hdr.nexus.targ_port, 			io->io_hdr.nexus.targ_target.id, 			io->io_hdr.nexus.targ_lun, 			(io->io_hdr.io_type == 			CTL_IO_TASK) ? 			io->taskio.tag_num : 			io->scsiio.tag_num, 		        io->io_hdr.flags, 			io->io_hdr.status); 	} else 		io->io_hdr.flags |= CTL_FLAG_ALREADY_DONE;
endif|#
directive|endif
comment|/* 	 * This is an internal copy of an I/O, and should not go through 	 * the normal done processing logic. 	 */
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_INT_COPY
condition|)
return|return;
comment|/* 	 * We need to send a msg to the serializing shelf to finish the IO 	 * as well.  We don't send a finish message to the other shelf if 	 * this is a task management command.  Task management commands 	 * aren't serialized in the OOA queue, but rather just executed on 	 * both shelf controllers for commands that originated on that 	 * controller. 	 */
if|if
condition|(
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_SENT_2OTHER_SC
operator|)
operator|&&
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|io_type
operator|!=
name|CTL_IO_TASK
operator|)
condition|)
block|{
name|union
name|ctl_ha_msg
name|msg_io
decl_stmt|;
name|msg_io
operator|.
name|hdr
operator|.
name|msg_type
operator|=
name|CTL_MSG_FINISH_IO
expr_stmt|;
name|msg_io
operator|.
name|hdr
operator|.
name|serializing_sc
operator|=
name|io
operator|->
name|io_hdr
operator|.
name|serializing_sc
expr_stmt|;
if|if
condition|(
name|ctl_ha_msg_send
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
operator|&
name|msg_io
argument_list|,
sizeof|sizeof
argument_list|(
name|msg_io
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
name|CTL_HA_STATUS_SUCCESS
condition|)
block|{ 		}
comment|/* continue on to finish IO */
block|}
ifdef|#
directive|ifdef
name|CTL_IO_DELAY
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&
name|CTL_FLAG_DELAY_DONE
condition|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LUN
index|]
operator|.
name|ptr
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator|&=
operator|~
name|CTL_FLAG_DELAY_DONE
expr_stmt|;
block|}
else|else
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|io
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LUN
index|]
operator|.
name|ptr
expr_stmt|;
if|if
condition|(
operator|(
name|lun
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|lun
operator|->
name|delay_info
operator|.
name|done_delay
operator|>
literal|0
operator|)
condition|)
block|{
name|struct
name|callout
modifier|*
name|callout
decl_stmt|;
name|callout
operator|=
operator|(
expr|struct
name|callout
operator|*
operator|)
operator|&
name|io
operator|->
name|io_hdr
operator|.
name|timer_bytes
expr_stmt|;
name|callout_init
argument_list|(
name|callout
argument_list|,
comment|/*mpsafe*/
literal|1
argument_list|)
expr_stmt|;
name|io
operator|->
name|io_hdr
operator|.
name|flags
operator||=
name|CTL_FLAG_DELAY_DONE
expr_stmt|;
name|callout_reset
argument_list|(
name|callout
argument_list|,
name|lun
operator|->
name|delay_info
operator|.
name|done_delay
operator|*
name|hz
argument_list|,
name|ctl_done_timer_wakeup
argument_list|,
name|io
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|->
name|delay_info
operator|.
name|done_type
operator|==
name|CTL_DELAY_TYPE_ONESHOT
condition|)
name|lun
operator|->
name|delay_info
operator|.
name|done_delay
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
comment|/* CTL_IO_DELAY */
name|ctl_enqueue_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ctl_isc
parameter_list|(
name|struct
name|ctl_scsiio
modifier|*
name|ctsio
parameter_list|)
block|{
name|struct
name|ctl_lun
modifier|*
name|lun
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|lun
operator|=
operator|(
expr|struct
name|ctl_lun
operator|*
operator|)
name|ctsio
operator|->
name|io_hdr
operator|.
name|ctl_private
index|[
name|CTL_PRIV_LUN
index|]
operator|.
name|ptr
expr_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_isc: command: %02x\n"
operator|,
name|ctsio
operator|->
name|cdb
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_isc: calling data_submit()\n"
operator|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|lun
operator|->
name|backend
operator|->
name|data_submit
argument_list|(
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|ctsio
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_work_thread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ctl_thread
modifier|*
name|thr
init|=
operator|(
expr|struct
name|ctl_thread
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|thr
operator|->
name|ctl_softc
decl_stmt|;
name|union
name|ctl_io
modifier|*
name|io
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_work_thread starting\n"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|retval
operator|=
literal|0
expr_stmt|;
comment|/* 		 * We handle the queues in this order: 		 * - ISC 		 * - done queue (to free up resources, unblock other commands) 		 * - RtR queue 		 * - incoming queue 		 * 		 * If those queues are empty, we break out of the loop and 		 * go to sleep. 		 */
name|mtx_lock
argument_list|(
operator|&
name|thr
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
name|io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|STAILQ_FIRST
argument_list|(
operator|&
name|thr
operator|->
name|isc_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|thr
operator|->
name|isc_queue
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|thr
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
name|ctl_handle_isc
argument_list|(
name|io
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|STAILQ_FIRST
argument_list|(
operator|&
name|thr
operator|->
name|done_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|thr
operator|->
name|done_queue
argument_list|,
name|links
argument_list|)
expr_stmt|;
comment|/* clear any blocked commands, call fe_done */
name|mtx_unlock
argument_list|(
operator|&
name|thr
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
name|retval
operator|=
name|ctl_process_done
argument_list|(
name|io
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|STAILQ_FIRST
argument_list|(
operator|&
name|thr
operator|->
name|incoming_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|thr
operator|->
name|incoming_queue
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|thr
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|io_hdr
operator|.
name|io_type
operator|==
name|CTL_IO_TASK
condition|)
name|ctl_run_task
argument_list|(
name|io
argument_list|)
expr_stmt|;
else|else
name|ctl_scsiio_precheck
argument_list|(
name|softc
argument_list|,
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|ctl_pause_rtr
condition|)
block|{
name|io
operator|=
operator|(
expr|union
name|ctl_io
operator|*
operator|)
name|STAILQ_FIRST
argument_list|(
operator|&
name|thr
operator|->
name|rtr_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|thr
operator|->
name|rtr_queue
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|thr
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
name|retval
operator|=
name|ctl_scsiio
argument_list|(
operator|&
name|io
operator|->
name|scsiio
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|CTL_RETVAL_COMPLETE
condition|)
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_scsiio failed\n"
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* Sleep until we have something to do. */
name|mtx_sleep
argument_list|(
name|thr
argument_list|,
operator|&
name|thr
operator|->
name|queue_lock
argument_list|,
name|PDROP
operator||
name|PRIBIO
argument_list|,
literal|"-"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_lun_thread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
operator|(
expr|struct
name|ctl_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|ctl_be_lun
modifier|*
name|be_lun
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|CTL_DEBUG_PRINT
argument_list|(
operator|(
literal|"ctl_lun_thread starting\n"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|retval
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|be_lun
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|softc
operator|->
name|pending_lun_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|be_lun
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|softc
operator|->
name|pending_lun_queue
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|)
expr_stmt|;
name|ctl_create_lun
argument_list|(
name|be_lun
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Sleep until we have something to do. */
name|mtx_sleep
argument_list|(
operator|&
name|softc
operator|->
name|pending_lun_queue
argument_list|,
operator|&
name|softc
operator|->
name|ctl_lock
argument_list|,
name|PDROP
operator||
name|PRIBIO
argument_list|,
literal|"-"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_enqueue_incoming
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|control_softc
decl_stmt|;
name|struct
name|ctl_thread
modifier|*
name|thr
decl_stmt|;
name|u_int
name|idx
decl_stmt|;
name|idx
operator|=
operator|(
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_port
operator|*
literal|127
operator|+
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|initid
operator|.
name|id
operator|)
operator|%
name|worker_threads
expr_stmt|;
name|thr
operator|=
operator|&
name|softc
operator|->
name|threads
index|[
name|idx
index|]
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|thr
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|thr
operator|->
name|incoming_queue
argument_list|,
operator|&
name|io
operator|->
name|io_hdr
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|thr
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|thr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_enqueue_rtr
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|control_softc
decl_stmt|;
name|struct
name|ctl_thread
modifier|*
name|thr
decl_stmt|;
name|thr
operator|=
operator|&
name|softc
operator|->
name|threads
index|[
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_mapped_lun
operator|%
name|worker_threads
index|]
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|thr
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|thr
operator|->
name|rtr_queue
argument_list|,
operator|&
name|io
operator|->
name|io_hdr
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|thr
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|thr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_enqueue_done
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|control_softc
decl_stmt|;
name|struct
name|ctl_thread
modifier|*
name|thr
decl_stmt|;
name|thr
operator|=
operator|&
name|softc
operator|->
name|threads
index|[
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_mapped_lun
operator|%
name|worker_threads
index|]
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|thr
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|thr
operator|->
name|done_queue
argument_list|,
operator|&
name|io
operator|->
name|io_hdr
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|thr
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|thr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_enqueue_isc
parameter_list|(
name|union
name|ctl_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|ctl_softc
modifier|*
name|softc
init|=
name|control_softc
decl_stmt|;
name|struct
name|ctl_thread
modifier|*
name|thr
decl_stmt|;
name|thr
operator|=
operator|&
name|softc
operator|->
name|threads
index|[
name|io
operator|->
name|io_hdr
operator|.
name|nexus
operator|.
name|targ_mapped_lun
operator|%
name|worker_threads
index|]
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|thr
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|thr
operator|->
name|isc_queue
argument_list|,
operator|&
name|io
operator|->
name|io_hdr
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|thr
operator|->
name|queue_lock
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|thr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialization and failover */
end_comment

begin_function
name|void
name|ctl_init_isc_msg
parameter_list|(
name|void
parameter_list|)
block|{
name|printf
argument_list|(
literal|"CTL: Still calling this thing\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Init component  * 	Initializes component into configuration defined by bootMode  *	(see hasc-sv.c)  *  	returns hasc_Status:  * 		OK  *		ERROR - fatal error  */
end_comment

begin_function
specifier|static
name|ctl_ha_comp_status
name|ctl_isc_init
parameter_list|(
name|struct
name|ctl_ha_component
modifier|*
name|c
parameter_list|)
block|{
name|ctl_ha_comp_status
name|ret
init|=
name|CTL_HA_COMP_STATUS_OK
decl_stmt|;
name|c
operator|->
name|status
operator|=
name|ret
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Start component  * 	Starts component in state requested. If component starts successfully,  *	it must set its own state to the requestrd state  *	When requested state is HASC_STATE_HA, the component may refine it  * 	by adding _SLAVE or _MASTER flags.  *	Currently allowed state transitions are:  *	UNKNOWN->HA		- initial startup  *	UNKNOWN->SINGLE - initial startup when no parter detected  *	HA->SINGLE		- failover  * returns ctl_ha_comp_status:  * 		OK	- component successfully started in requested state  *		FAILED  - could not start the requested state, failover may  * 			  be possible  *		ERROR	- fatal error detected, no future startup possible  */
end_comment

begin_function
specifier|static
name|ctl_ha_comp_status
name|ctl_isc_start
parameter_list|(
name|struct
name|ctl_ha_component
modifier|*
name|c
parameter_list|,
name|ctl_ha_state
name|state
parameter_list|)
block|{
name|ctl_ha_comp_status
name|ret
init|=
name|CTL_HA_COMP_STATUS_OK
decl_stmt|;
name|printf
argument_list|(
literal|"%s: go\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|// UNKNOWN->HA or UNKNOWN->SINGLE (bootstrap)
if|if
condition|(
name|c
operator|->
name|state
operator|==
name|CTL_HA_STATE_UNKNOWN
condition|)
block|{
name|ctl_is_single
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ctl_ha_msg_create
argument_list|(
name|CTL_HA_CHAN_CTL
argument_list|,
name|ctl_isc_event_handler
argument_list|)
operator|!=
name|CTL_HA_STATUS_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"ctl_isc_start: ctl_ha_msg_create failed.\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|CTL_HA_COMP_STATUS_ERROR
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|CTL_HA_STATE_IS_HA
argument_list|(
name|c
operator|->
name|state
argument_list|)
operator|&&
name|CTL_HA_STATE_IS_SINGLE
argument_list|(
name|state
argument_list|)
condition|)
block|{
comment|// HA->SINGLE transition
name|ctl_failover
argument_list|()
expr_stmt|;
name|ctl_is_single
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"ctl_isc_start:Invalid state transition %X->%X\n"
argument_list|,
name|c
operator|->
name|state
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|ret
operator|=
name|CTL_HA_COMP_STATUS_ERROR
expr_stmt|;
block|}
if|if
condition|(
name|CTL_HA_STATE_IS_SINGLE
argument_list|(
name|state
argument_list|)
condition|)
name|ctl_is_single
operator|=
literal|1
expr_stmt|;
name|c
operator|->
name|state
operator|=
name|state
expr_stmt|;
name|c
operator|->
name|status
operator|=
name|ret
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Quiesce component  * The component must clear any error conditions (set status to OK) and  * prepare itself to another Start call  * returns ctl_ha_comp_status:  * 	OK  *	ERROR  */
end_comment

begin_function
specifier|static
name|ctl_ha_comp_status
name|ctl_isc_quiesce
parameter_list|(
name|struct
name|ctl_ha_component
modifier|*
name|c
parameter_list|)
block|{
name|int
name|ret
init|=
name|CTL_HA_COMP_STATUS_OK
decl_stmt|;
name|ctl_pause_rtr
operator|=
literal|1
expr_stmt|;
name|c
operator|->
name|status
operator|=
name|ret
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|ctl_ha_component
name|ctl_ha_component_ctlisc
init|=
block|{
operator|.
name|name
operator|=
literal|"CTL ISC"
block|,
operator|.
name|state
operator|=
name|CTL_HA_STATE_UNKNOWN
block|,
operator|.
name|init
operator|=
name|ctl_isc_init
block|,
operator|.
name|start
operator|=
name|ctl_isc_start
block|,
operator|.
name|quiesce
operator|=
name|ctl_isc_quiesce
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  vim: ts=8  */
end_comment

end_unit

