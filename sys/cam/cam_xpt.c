begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Implementation of the Common Access Method Transport (XPT) layer.  *  * Copyright (c) 1997, 1998, 1999 Justin T. Gibbs.  * Copyright (c) 1997, 1998, 1999 Kenneth D. Merry.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/md5.h>
end_include

begin_include
include|#
directive|include
file|<sys/interrupt.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PC98
end_ifdef

begin_include
include|#
directive|include
file|<pc98/pc98/pc98_machdep.h>
end_include

begin_comment
comment|/* geometry translation */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_pass.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_comment
comment|/* for xpt_print below */
end_comment

begin_include
include|#
directive|include
file|"opt_cam.h"
end_include

begin_comment
comment|/* Datastructures internal to the xpt layer */
end_comment

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_CAMXPT
argument_list|,
literal|"CAM XPT"
argument_list|,
literal|"CAM XPT buffers"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Object for defering XPT actions to a taskqueue */
end_comment

begin_struct
struct|struct
name|xpt_task
block|{
name|struct
name|task
name|task
decl_stmt|;
name|void
modifier|*
name|data1
decl_stmt|;
name|uintptr_t
name|data2
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Definition of an async handler callback block.  These are used to add  * SIMs and peripherals to the async callback lists.  */
end_comment

begin_struct
struct|struct
name|async_node
block|{
name|SLIST_ENTRY
argument_list|(
argument|async_node
argument_list|)
name|links
expr_stmt|;
name|u_int32_t
name|event_enable
decl_stmt|;
comment|/* Async Event enables */
name|void
function_decl|(
modifier|*
name|callback
function_decl|)
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|u_int32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|args
parameter_list|)
function_decl|;
name|void
modifier|*
name|callback_arg
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|SLIST_HEAD
argument_list|(
name|async_list
argument_list|,
name|async_node
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SLIST_HEAD
argument_list|(
name|periph_list
argument_list|,
name|cam_periph
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * This is the maximum number of high powered commands (e.g. start unit)  * that can be outstanding at a particular time.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CAM_MAX_HIGHPOWER
end_ifndef

begin_define
define|#
directive|define
name|CAM_MAX_HIGHPOWER
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Structure for queueing a device in a run queue.  * There is one run queue for allocating new ccbs,  * and another for sending ccbs to the controller.  */
end_comment

begin_struct
struct|struct
name|cam_ed_qinfo
block|{
name|cam_pinfo
name|pinfo
decl_stmt|;
name|struct
name|cam_ed
modifier|*
name|device
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * The CAM EDT (Existing Device Table) contains the device information for  * all devices for all busses in the system.  The table contains a  * cam_ed structure for each device on the bus.  */
end_comment

begin_struct
struct|struct
name|cam_ed
block|{
name|TAILQ_ENTRY
argument_list|(
argument|cam_ed
argument_list|)
name|links
expr_stmt|;
name|struct
name|cam_ed_qinfo
name|alloc_ccb_entry
decl_stmt|;
name|struct
name|cam_ed_qinfo
name|send_ccb_entry
decl_stmt|;
name|struct
name|cam_et
modifier|*
name|target
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|lun_id_t
name|lun_id
decl_stmt|;
name|struct
name|camq
name|drvq
decl_stmt|;
comment|/* 					 * Queue of type drivers wanting to do 					 * work on this device. 					 */
name|struct
name|cam_ccbq
name|ccbq
decl_stmt|;
comment|/* Queue of pending ccbs */
name|struct
name|async_list
name|asyncs
decl_stmt|;
comment|/* Async callback info for this B/T/L */
name|struct
name|periph_list
name|periphs
decl_stmt|;
comment|/* All attached devices */
name|u_int
name|generation
decl_stmt|;
comment|/* Generation number */
name|struct
name|cam_periph
modifier|*
name|owner
decl_stmt|;
comment|/* Peripheral driver's ownership tag */
name|struct
name|xpt_quirk_entry
modifier|*
name|quirk
decl_stmt|;
comment|/* Oddities about this device */
comment|/* Storage for the inquiry data */
name|cam_proto
name|protocol
decl_stmt|;
name|u_int
name|protocol_version
decl_stmt|;
name|cam_xport
name|transport
decl_stmt|;
name|u_int
name|transport_version
decl_stmt|;
name|struct
name|scsi_inquiry_data
name|inq_data
decl_stmt|;
name|u_int8_t
name|inq_flags
decl_stmt|;
comment|/* 					 * Current settings for inquiry flags. 					 * This allows us to override settings 					 * like disconnection and tagged 					 * queuing for a device. 					 */
name|u_int8_t
name|queue_flags
decl_stmt|;
comment|/* Queue flags from the control page */
name|u_int8_t
name|serial_num_len
decl_stmt|;
name|u_int8_t
modifier|*
name|serial_num
decl_stmt|;
name|u_int32_t
name|qfrozen_cnt
decl_stmt|;
name|u_int32_t
name|flags
decl_stmt|;
define|#
directive|define
name|CAM_DEV_UNCONFIGURED
value|0x01
define|#
directive|define
name|CAM_DEV_REL_TIMEOUT_PENDING
value|0x02
define|#
directive|define
name|CAM_DEV_REL_ON_COMPLETE
value|0x04
define|#
directive|define
name|CAM_DEV_REL_ON_QUEUE_EMPTY
value|0x08
define|#
directive|define
name|CAM_DEV_RESIZE_QUEUE_NEEDED
value|0x10
define|#
directive|define
name|CAM_DEV_TAG_AFTER_COUNT
value|0x20
define|#
directive|define
name|CAM_DEV_INQUIRY_DATA_VALID
value|0x40
define|#
directive|define
name|CAM_DEV_IN_DV
value|0x80
define|#
directive|define
name|CAM_DEV_DV_HIT_BOTTOM
value|0x100
name|u_int32_t
name|tag_delay_count
decl_stmt|;
define|#
directive|define
name|CAM_TAG_DELAY_COUNT
value|5
name|u_int32_t
name|tag_saved_openings
decl_stmt|;
name|u_int32_t
name|refcount
decl_stmt|;
name|struct
name|callout
name|callout
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Each target is represented by an ET (Existing Target).  These  * entries are created when a target is successfully probed with an  * identify, and removed when a device fails to respond after a number  * of retries, or a bus rescan finds the device missing.  */
end_comment

begin_struct
struct|struct
name|cam_et
block|{
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|cam_ed
argument_list|)
name|ed_entries
expr_stmt|;
name|TAILQ_ENTRY
argument_list|(
argument|cam_et
argument_list|)
name|links
expr_stmt|;
name|struct
name|cam_eb
modifier|*
name|bus
decl_stmt|;
name|target_id_t
name|target_id
decl_stmt|;
name|u_int32_t
name|refcount
decl_stmt|;
name|u_int
name|generation
decl_stmt|;
name|struct
name|timeval
name|last_reset
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Each bus is represented by an EB (Existing Bus).  These entries  * are created by calls to xpt_bus_register and deleted by calls to  * xpt_bus_deregister.  */
end_comment

begin_struct
struct|struct
name|cam_eb
block|{
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|cam_et
argument_list|)
name|et_entries
expr_stmt|;
name|TAILQ_ENTRY
argument_list|(
argument|cam_eb
argument_list|)
name|links
expr_stmt|;
name|path_id_t
name|path_id
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|struct
name|timeval
name|last_reset
decl_stmt|;
name|u_int32_t
name|flags
decl_stmt|;
define|#
directive|define
name|CAM_EB_RUNQ_SCHEDULED
value|0x01
name|u_int32_t
name|refcount
decl_stmt|;
name|u_int
name|generation
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|cam_path
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|cam_eb
modifier|*
name|bus
decl_stmt|;
name|struct
name|cam_et
modifier|*
name|target
decl_stmt|;
name|struct
name|cam_ed
modifier|*
name|device
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|xpt_quirk_entry
block|{
name|struct
name|scsi_inquiry_pattern
name|inq_pat
decl_stmt|;
name|u_int8_t
name|quirks
decl_stmt|;
define|#
directive|define
name|CAM_QUIRK_NOLUNS
value|0x01
define|#
directive|define
name|CAM_QUIRK_NOSERIAL
value|0x02
define|#
directive|define
name|CAM_QUIRK_HILUNS
value|0x04
define|#
directive|define
name|CAM_QUIRK_NOHILUNS
value|0x08
name|u_int
name|mintags
decl_stmt|;
name|u_int
name|maxtags
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|cam_srch_hi
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"kern.cam.cam_srch_hi"
argument_list|,
operator|&
name|cam_srch_hi
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|sysctl_cam_search_luns
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern_cam
argument_list|,
name|OID_AUTO
argument_list|,
name|cam_srch_hi
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sysctl_cam_search_luns
argument_list|,
literal|"I"
argument_list|,
literal|"allow search above LUN 7 for SCSI3 and greater devices"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|CAM_SCSI2_MAXLUN
value|8
end_define

begin_comment
comment|/*  * If we're not quirked to search<= the first 8 luns  * and we are either quirked to search above lun 8,  * or we're> SCSI-2 and we've enabled hilun searching,  * or we're> SCSI-2 and the last lun was a success,  * we can look for luns above lun 8.  */
end_comment

begin_define
define|#
directive|define
name|CAN_SRCH_HI_SPARSE
parameter_list|(
name|dv
parameter_list|)
define|\
value|(((dv->quirk->quirks& CAM_QUIRK_NOHILUNS) == 0) 	\&& ((dv->quirk->quirks& CAM_QUIRK_HILUNS)		\   || (SID_ANSI_REV(&dv->inq_data)> SCSI_REV_2&& cam_srch_hi)))
end_define

begin_define
define|#
directive|define
name|CAN_SRCH_HI_DENSE
parameter_list|(
name|dv
parameter_list|)
define|\
value|(((dv->quirk->quirks& CAM_QUIRK_NOHILUNS) == 0) 	\&& ((dv->quirk->quirks& CAM_QUIRK_HILUNS)		\   || (SID_ANSI_REV(&dv->inq_data)> SCSI_REV_2)))
end_define

begin_typedef
typedef|typedef
enum|enum
block|{
name|XPT_FLAG_OPEN
init|=
literal|0x01
block|}
name|xpt_flags
typedef|;
end_typedef

begin_struct
struct|struct
name|xpt_softc
block|{
name|xpt_flags
name|flags
decl_stmt|;
name|u_int32_t
name|xpt_generation
decl_stmt|;
comment|/* number of high powered commands that can go through right now */
name|STAILQ_HEAD
argument_list|(
argument|highpowerlist
argument_list|,
argument|ccb_hdr
argument_list|)
name|highpowerq
expr_stmt|;
name|int
name|num_highpower
decl_stmt|;
comment|/* queue for handling async rescan requests. */
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|ccb_hdr
argument_list|)
name|ccb_scanq
expr_stmt|;
comment|/* Registered busses */
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|cam_eb
argument_list|)
name|xpt_busses
expr_stmt|;
name|u_int
name|bus_generation
decl_stmt|;
name|struct
name|intr_config_hook
modifier|*
name|xpt_config_hook
decl_stmt|;
name|struct
name|mtx
name|xpt_topo_lock
decl_stmt|;
name|struct
name|mtx
name|xpt_lock
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|char
name|quantum
index|[]
init|=
literal|"QUANTUM"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|sony
index|[]
init|=
literal|"SONY"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|west_digital
index|[]
init|=
literal|"WDIGTL"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|samsung
index|[]
init|=
literal|"SAMSUNG"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|seagate
index|[]
init|=
literal|"SEAGATE"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|microp
index|[]
init|=
literal|"MICROP"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|xpt_quirk_entry
name|xpt_quirk_table
index|[]
init|=
block|{
block|{
comment|/* Reports QUEUE FULL for temporary resource shortages */
block|{
name|T_DIRECT
block|,
name|SIP_MEDIA_FIXED
block|,
name|quantum
block|,
literal|"XP39100*"
block|,
literal|"*"
block|}
block|,
comment|/*quirks*/
literal|0
block|,
comment|/*mintags*/
literal|24
block|,
comment|/*maxtags*/
literal|32
block|}
block|,
block|{
comment|/* Reports QUEUE FULL for temporary resource shortages */
block|{
name|T_DIRECT
block|,
name|SIP_MEDIA_FIXED
block|,
name|quantum
block|,
literal|"XP34550*"
block|,
literal|"*"
block|}
block|,
comment|/*quirks*/
literal|0
block|,
comment|/*mintags*/
literal|24
block|,
comment|/*maxtags*/
literal|32
block|}
block|,
block|{
comment|/* Reports QUEUE FULL for temporary resource shortages */
block|{
name|T_DIRECT
block|,
name|SIP_MEDIA_FIXED
block|,
name|quantum
block|,
literal|"XP32275*"
block|,
literal|"*"
block|}
block|,
comment|/*quirks*/
literal|0
block|,
comment|/*mintags*/
literal|24
block|,
comment|/*maxtags*/
literal|32
block|}
block|,
block|{
comment|/* Broken tagged queuing drive */
block|{
name|T_DIRECT
block|,
name|SIP_MEDIA_FIXED
block|,
name|microp
block|,
literal|"4421-07*"
block|,
literal|"*"
block|}
block|,
comment|/*quirks*/
literal|0
block|,
comment|/*mintags*/
literal|0
block|,
comment|/*maxtags*/
literal|0
block|}
block|,
block|{
comment|/* Broken tagged queuing drive */
block|{
name|T_DIRECT
block|,
name|SIP_MEDIA_FIXED
block|,
literal|"HP"
block|,
literal|"C372*"
block|,
literal|"*"
block|}
block|,
comment|/*quirks*/
literal|0
block|,
comment|/*mintags*/
literal|0
block|,
comment|/*maxtags*/
literal|0
block|}
block|,
block|{
comment|/* Broken tagged queuing drive */
block|{
name|T_DIRECT
block|,
name|SIP_MEDIA_FIXED
block|,
name|microp
block|,
literal|"3391*"
block|,
literal|"x43h"
block|}
block|,
comment|/*quirks*/
literal|0
block|,
comment|/*mintags*/
literal|0
block|,
comment|/*maxtags*/
literal|0
block|}
block|,
block|{
comment|/* 		 * Unfortunately, the Quantum Atlas III has the same 		 * problem as the Atlas II drives above. 		 * Reported by: "Johan Granlund"<johan@granlund.nu> 		 * 		 * For future reference, the drive with the problem was: 		 * QUANTUM QM39100TD-SW N1B0 		 *  		 * It's possible that Quantum will fix the problem in later 		 * firmware revisions.  If that happens, the quirk entry 		 * will need to be made specific to the firmware revisions 		 * with the problem. 		 *  		 */
comment|/* Reports QUEUE FULL for temporary resource shortages */
block|{
name|T_DIRECT
block|,
name|SIP_MEDIA_FIXED
block|,
name|quantum
block|,
literal|"QM39100*"
block|,
literal|"*"
block|}
block|,
comment|/*quirks*/
literal|0
block|,
comment|/*mintags*/
literal|24
block|,
comment|/*maxtags*/
literal|32
block|}
block|,
block|{
comment|/* 		 * 18 Gig Atlas III, same problem as the 9G version. 		 * Reported by: Andre Albsmeier 		 *<andre.albsmeier@mchp.siemens.de> 		 * 		 * For future reference, the drive with the problem was: 		 * QUANTUM QM318000TD-S N491 		 */
comment|/* Reports QUEUE FULL for temporary resource shortages */
block|{
name|T_DIRECT
block|,
name|SIP_MEDIA_FIXED
block|,
name|quantum
block|,
literal|"QM318000*"
block|,
literal|"*"
block|}
block|,
comment|/*quirks*/
literal|0
block|,
comment|/*mintags*/
literal|24
block|,
comment|/*maxtags*/
literal|32
block|}
block|,
block|{
comment|/* 		 * Broken tagged queuing drive 		 * Reported by: Bret Ford<bford@uop.cs.uop.edu> 		 *         and: Martin Renters<martin@tdc.on.ca> 		 */
block|{
name|T_DIRECT
block|,
name|SIP_MEDIA_FIXED
block|,
name|seagate
block|,
literal|"ST410800*"
block|,
literal|"71*"
block|}
block|,
comment|/*quirks*/
literal|0
block|,
comment|/*mintags*/
literal|0
block|,
comment|/*maxtags*/
literal|0
block|}
block|,
comment|/* 		 * The Seagate Medalist Pro drives have very poor write 		 * performance with anything more than 2 tags. 		 *  		 * Reported by:  Paul van der Zwan<paulz@trantor.xs4all.nl> 		 * Drive:<SEAGATE ST36530N 1444> 		 * 		 * Reported by:  Jeremy Lea<reg@shale.csir.co.za> 		 * Drive:<SEAGATE ST34520W 1281> 		 * 		 * No one has actually reported that the 9G version 		 * (ST39140*) of the Medalist Pro has the same problem, but 		 * we're assuming that it does because the 4G and 6.5G 		 * versions of the drive are broken. 		 */
block|{
block|{
name|T_DIRECT
block|,
name|SIP_MEDIA_FIXED
block|,
name|seagate
block|,
literal|"ST34520*"
block|,
literal|"*"
block|}
block|,
comment|/*quirks*/
literal|0
block|,
comment|/*mintags*/
literal|2
block|,
comment|/*maxtags*/
literal|2
block|}
block|,
block|{
block|{
name|T_DIRECT
block|,
name|SIP_MEDIA_FIXED
block|,
name|seagate
block|,
literal|"ST36530*"
block|,
literal|"*"
block|}
block|,
comment|/*quirks*/
literal|0
block|,
comment|/*mintags*/
literal|2
block|,
comment|/*maxtags*/
literal|2
block|}
block|,
block|{
block|{
name|T_DIRECT
block|,
name|SIP_MEDIA_FIXED
block|,
name|seagate
block|,
literal|"ST39140*"
block|,
literal|"*"
block|}
block|,
comment|/*quirks*/
literal|0
block|,
comment|/*mintags*/
literal|2
block|,
comment|/*maxtags*/
literal|2
block|}
block|,
block|{
comment|/* 		 * Slow when tagged queueing is enabled.  Write performance 		 * steadily drops off with more and more concurrent 		 * transactions.  Best sequential write performance with 		 * tagged queueing turned off and write caching turned on. 		 * 		 * PR:  kern/10398 		 * Submitted by:  Hideaki Okada<hokada@isl.melco.co.jp> 		 * Drive:  DCAS-34330 w/ "S65A" firmware. 		 * 		 * The drive with the problem had the "S65A" firmware 		 * revision, and has also been reported (by Stephen J. 		 * Roznowski<sjr@home.net>) for a drive with the "S61A" 		 * firmware revision. 		 * 		 * Although no one has reported problems with the 2 gig 		 * version of the DCAS drive, the assumption is that it 		 * has the same problems as the 4 gig version.  Therefore 		 * this quirk entries disables tagged queueing for all 		 * DCAS drives. 		 */
block|{
name|T_DIRECT
block|,
name|SIP_MEDIA_FIXED
block|,
literal|"IBM"
block|,
literal|"DCAS*"
block|,
literal|"*"
block|}
block|,
comment|/*quirks*/
literal|0
block|,
comment|/*mintags*/
literal|0
block|,
comment|/*maxtags*/
literal|0
block|}
block|,
block|{
comment|/* Broken tagged queuing drive */
block|{
name|T_DIRECT
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"iomega"
block|,
literal|"jaz*"
block|,
literal|"*"
block|}
block|,
comment|/*quirks*/
literal|0
block|,
comment|/*mintags*/
literal|0
block|,
comment|/*maxtags*/
literal|0
block|}
block|,
block|{
comment|/* Broken tagged queuing drive */
block|{
name|T_DIRECT
block|,
name|SIP_MEDIA_FIXED
block|,
literal|"CONNER"
block|,
literal|"CFP2107*"
block|,
literal|"*"
block|}
block|,
comment|/*quirks*/
literal|0
block|,
comment|/*mintags*/
literal|0
block|,
comment|/*maxtags*/
literal|0
block|}
block|,
block|{
comment|/* This does not support other than LUN 0 */
block|{
name|T_DIRECT
block|,
name|SIP_MEDIA_FIXED
block|,
literal|"VMware*"
block|,
literal|"*"
block|,
literal|"*"
block|}
block|,
name|CAM_QUIRK_NOLUNS
block|,
comment|/*mintags*/
literal|2
block|,
comment|/*maxtags*/
literal|255
block|}
block|,
block|{
comment|/* 		 * Broken tagged queuing drive. 		 * Submitted by: 		 * NAKAJI Hiroyuki<nakaji@zeisei.dpri.kyoto-u.ac.jp> 		 * in PR kern/9535 		 */
block|{
name|T_DIRECT
block|,
name|SIP_MEDIA_FIXED
block|,
name|samsung
block|,
literal|"WN34324U*"
block|,
literal|"*"
block|}
block|,
comment|/*quirks*/
literal|0
block|,
comment|/*mintags*/
literal|0
block|,
comment|/*maxtags*/
literal|0
block|}
block|,
block|{
comment|/* 		 * Slow when tagged queueing is enabled. (1.5MB/sec versus 		 * 8MB/sec.) 		 * Submitted by: Andrew Gallatin<gallatin@cs.duke.edu> 		 * Best performance with these drives is achieved with 		 * tagged queueing turned off, and write caching turned on. 		 */
block|{
name|T_DIRECT
block|,
name|SIP_MEDIA_FIXED
block|,
name|west_digital
block|,
literal|"WDE*"
block|,
literal|"*"
block|}
block|,
comment|/*quirks*/
literal|0
block|,
comment|/*mintags*/
literal|0
block|,
comment|/*maxtags*/
literal|0
block|}
block|,
block|{
comment|/* 		 * Slow when tagged queueing is enabled. (1.5MB/sec versus 		 * 8MB/sec.) 		 * Submitted by: Andrew Gallatin<gallatin@cs.duke.edu> 		 * Best performance with these drives is achieved with 		 * tagged queueing turned off, and write caching turned on. 		 */
block|{
name|T_DIRECT
block|,
name|SIP_MEDIA_FIXED
block|,
name|west_digital
block|,
literal|"ENTERPRISE"
block|,
literal|"*"
block|}
block|,
comment|/*quirks*/
literal|0
block|,
comment|/*mintags*/
literal|0
block|,
comment|/*maxtags*/
literal|0
block|}
block|,
block|{
comment|/* 		 * Doesn't handle queue full condition correctly, 		 * so we need to limit maxtags to what the device 		 * can handle instead of determining this automatically. 		 */
block|{
name|T_DIRECT
block|,
name|SIP_MEDIA_FIXED
block|,
name|samsung
block|,
literal|"WN321010S*"
block|,
literal|"*"
block|}
block|,
comment|/*quirks*/
literal|0
block|,
comment|/*mintags*/
literal|2
block|,
comment|/*maxtags*/
literal|32
block|}
block|,
block|{
comment|/* Really only one LUN */
block|{
name|T_ENCLOSURE
block|,
name|SIP_MEDIA_FIXED
block|,
literal|"SUN"
block|,
literal|"SENA"
block|,
literal|"*"
block|}
block|,
name|CAM_QUIRK_NOLUNS
block|,
comment|/*mintags*/
literal|0
block|,
comment|/*maxtags*/
literal|0
block|}
block|,
block|{
comment|/* I can't believe we need a quirk for DPT volumes. */
block|{
name|T_ANY
block|,
name|SIP_MEDIA_FIXED
operator||
name|SIP_MEDIA_REMOVABLE
block|,
literal|"DPT"
block|,
literal|"*"
block|,
literal|"*"
block|}
block|,
name|CAM_QUIRK_NOSERIAL
operator||
name|CAM_QUIRK_NOLUNS
block|,
comment|/*mintags*/
literal|0
block|,
comment|/*maxtags*/
literal|255
block|}
block|,
block|{
comment|/* 		 * Many Sony CDROM drives don't like multi-LUN probing. 		 */
block|{
name|T_CDROM
block|,
name|SIP_MEDIA_REMOVABLE
block|,
name|sony
block|,
literal|"CD-ROM CDU*"
block|,
literal|"*"
block|}
block|,
name|CAM_QUIRK_NOLUNS
block|,
comment|/*mintags*/
literal|0
block|,
comment|/*maxtags*/
literal|0
block|}
block|,
block|{
comment|/* 		 * This drive doesn't like multiple LUN probing. 		 * Submitted by:  Parag Patel<parag@cgt.com> 		 */
block|{
name|T_WORM
block|,
name|SIP_MEDIA_REMOVABLE
block|,
name|sony
block|,
literal|"CD-R   CDU9*"
block|,
literal|"*"
block|}
block|,
name|CAM_QUIRK_NOLUNS
block|,
comment|/*mintags*/
literal|0
block|,
comment|/*maxtags*/
literal|0
block|}
block|,
block|{
block|{
name|T_WORM
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"YAMAHA"
block|,
literal|"CDR100*"
block|,
literal|"*"
block|}
block|,
name|CAM_QUIRK_NOLUNS
block|,
comment|/*mintags*/
literal|0
block|,
comment|/*maxtags*/
literal|0
block|}
block|,
block|{
comment|/* 		 * The 8200 doesn't like multi-lun probing, and probably 		 * don't like serial number requests either. 		 */
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"EXABYTE"
block|,
literal|"EXB-8200*"
block|,
literal|"*"
block|}
block|,
name|CAM_QUIRK_NOSERIAL
operator||
name|CAM_QUIRK_NOLUNS
block|,
comment|/*mintags*/
literal|0
block|,
comment|/*maxtags*/
literal|0
block|}
block|,
block|{
comment|/* 		 * Let's try the same as above, but for a drive that says 		 * it's an IPL-6860 but is actually an EXB 8200. 		 */
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"EXABYTE"
block|,
literal|"IPL-6860*"
block|,
literal|"*"
block|}
block|,
name|CAM_QUIRK_NOSERIAL
operator||
name|CAM_QUIRK_NOLUNS
block|,
comment|/*mintags*/
literal|0
block|,
comment|/*maxtags*/
literal|0
block|}
block|,
block|{
comment|/* 		 * These Hitachi drives don't like multi-lun probing. 		 * The PR submitter has a DK319H, but says that the Linux 		 * kernel has a similar work-around for the DK312 and DK314, 		 * so all DK31* drives are quirked here. 		 * PR:            misc/18793 		 * Submitted by:  Paul Haddad<paul@pth.com> 		 */
block|{
name|T_DIRECT
block|,
name|SIP_MEDIA_FIXED
block|,
literal|"HITACHI"
block|,
literal|"DK31*"
block|,
literal|"*"
block|}
block|,
name|CAM_QUIRK_NOLUNS
block|,
comment|/*mintags*/
literal|2
block|,
comment|/*maxtags*/
literal|255
block|}
block|,
block|{
comment|/* 		 * The Hitachi CJ series with J8A8 firmware apparantly has 		 * problems with tagged commands. 		 * PR: 23536 		 * Reported by: amagai@nue.org 		 */
block|{
name|T_DIRECT
block|,
name|SIP_MEDIA_FIXED
block|,
literal|"HITACHI"
block|,
literal|"DK32CJ*"
block|,
literal|"J8A8"
block|}
block|,
name|CAM_QUIRK_NOLUNS
block|,
comment|/*mintags*/
literal|0
block|,
comment|/*maxtags*/
literal|0
block|}
block|,
block|{
comment|/* 		 * These are the large storage arrays. 		 * Submitted by:  William Carrel<william.carrel@infospace.com> 		 */
block|{
name|T_DIRECT
block|,
name|SIP_MEDIA_FIXED
block|,
literal|"HITACHI"
block|,
literal|"OPEN*"
block|,
literal|"*"
block|}
block|,
name|CAM_QUIRK_HILUNS
block|,
literal|2
block|,
literal|1024
block|}
block|,
block|{
comment|/* 		 * This old revision of the TDC3600 is also SCSI-1, and 		 * hangs upon serial number probing. 		 */
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"TANDBERG"
block|,
literal|" TDC 3600"
block|,
literal|"U07:"
block|}
block|,
name|CAM_QUIRK_NOSERIAL
block|,
comment|/*mintags*/
literal|0
block|,
comment|/*maxtags*/
literal|0
block|}
block|,
block|{
comment|/* 		 * Maxtor Personal Storage 3000XT (Firewire) 		 * hangs upon serial number probing. 		 */
block|{
name|T_DIRECT
block|,
name|SIP_MEDIA_FIXED
block|,
literal|"Maxtor"
block|,
literal|"1394 storage"
block|,
literal|"*"
block|}
block|,
name|CAM_QUIRK_NOSERIAL
block|,
comment|/*mintags*/
literal|0
block|,
comment|/*maxtags*/
literal|0
block|}
block|,
block|{
comment|/* 		 * Would repond to all LUNs if asked for. 		 */
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"CALIPER"
block|,
literal|"CP150"
block|,
literal|"*"
block|}
block|,
name|CAM_QUIRK_NOLUNS
block|,
comment|/*mintags*/
literal|0
block|,
comment|/*maxtags*/
literal|0
block|}
block|,
block|{
comment|/* 		 * Would repond to all LUNs if asked for. 		 */
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"KENNEDY"
block|,
literal|"96X2*"
block|,
literal|"*"
block|}
block|,
name|CAM_QUIRK_NOLUNS
block|,
comment|/*mintags*/
literal|0
block|,
comment|/*maxtags*/
literal|0
block|}
block|,
block|{
comment|/* Submitted by: Matthew Dodd<winter@jurai.net> */
block|{
name|T_PROCESSOR
block|,
name|SIP_MEDIA_FIXED
block|,
literal|"Cabletrn"
block|,
literal|"EA41*"
block|,
literal|"*"
block|}
block|,
name|CAM_QUIRK_NOLUNS
block|,
comment|/*mintags*/
literal|0
block|,
comment|/*maxtags*/
literal|0
block|}
block|,
block|{
comment|/* Submitted by: Matthew Dodd<winter@jurai.net> */
block|{
name|T_PROCESSOR
block|,
name|SIP_MEDIA_FIXED
block|,
literal|"CABLETRN"
block|,
literal|"EA41*"
block|,
literal|"*"
block|}
block|,
name|CAM_QUIRK_NOLUNS
block|,
comment|/*mintags*/
literal|0
block|,
comment|/*maxtags*/
literal|0
block|}
block|,
block|{
comment|/* TeraSolutions special settings for TRC-22 RAID */
block|{
name|T_DIRECT
block|,
name|SIP_MEDIA_FIXED
block|,
literal|"TERASOLU"
block|,
literal|"TRC-22"
block|,
literal|"*"
block|}
block|,
comment|/*quirks*/
literal|0
block|,
comment|/*mintags*/
literal|55
block|,
comment|/*maxtags*/
literal|255
block|}
block|,
block|{
comment|/* Veritas Storage Appliance */
block|{
name|T_DIRECT
block|,
name|SIP_MEDIA_FIXED
block|,
literal|"VERITAS"
block|,
literal|"*"
block|,
literal|"*"
block|}
block|,
name|CAM_QUIRK_HILUNS
block|,
comment|/*mintags*/
literal|2
block|,
comment|/*maxtags*/
literal|1024
block|}
block|,
block|{
comment|/* 		 * Would respond to all LUNs.  Device type and removable 		 * flag are jumper-selectable. 		 */
block|{
name|T_ANY
block|,
name|SIP_MEDIA_REMOVABLE
operator||
name|SIP_MEDIA_FIXED
block|,
literal|"MaxOptix"
block|,
literal|"Tahiti 1"
block|,
literal|"*"
block|}
block|,
name|CAM_QUIRK_NOLUNS
block|,
comment|/*mintags*/
literal|0
block|,
comment|/*maxtags*/
literal|0
block|}
block|,
block|{
comment|/* EasyRAID E5A aka. areca ARC-6010 */
block|{
name|T_DIRECT
block|,
name|SIP_MEDIA_FIXED
block|,
literal|"easyRAID"
block|,
literal|"*"
block|,
literal|"*"
block|}
block|,
name|CAM_QUIRK_NOHILUNS
block|,
comment|/*mintags*/
literal|2
block|,
comment|/*maxtags*/
literal|255
block|}
block|,
block|{
block|{
name|T_ENCLOSURE
block|,
name|SIP_MEDIA_FIXED
block|,
literal|"DP"
block|,
literal|"BACKPLANE"
block|,
literal|"*"
block|}
block|,
name|CAM_QUIRK_NOLUNS
block|,
comment|/*mintags*/
literal|0
block|,
comment|/*maxtags*/
literal|0
block|}
block|,
block|{
comment|/* Default tagged queuing parameters for all devices */
block|{
name|T_ANY
block|,
name|SIP_MEDIA_REMOVABLE
operator||
name|SIP_MEDIA_FIXED
block|,
comment|/*vendor*/
literal|"*"
block|,
comment|/*product*/
literal|"*"
block|,
comment|/*revision*/
literal|"*"
block|}
block|,
comment|/*quirks*/
literal|0
block|,
comment|/*mintags*/
literal|2
block|,
comment|/*maxtags*/
literal|255
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|xpt_quirk_table_size
init|=
sizeof|sizeof
argument_list|(
name|xpt_quirk_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|xpt_quirk_table
argument_list|)
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
enum|enum
block|{
name|DM_RET_COPY
init|=
literal|0x01
block|,
name|DM_RET_FLAG_MASK
init|=
literal|0x0f
block|,
name|DM_RET_NONE
init|=
literal|0x00
block|,
name|DM_RET_STOP
init|=
literal|0x10
block|,
name|DM_RET_DESCEND
init|=
literal|0x20
block|,
name|DM_RET_ERROR
init|=
literal|0x30
block|,
name|DM_RET_ACTION_MASK
init|=
literal|0xf0
block|}
name|dev_match_ret
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|XPT_DEPTH_BUS
block|,
name|XPT_DEPTH_TARGET
block|,
name|XPT_DEPTH_DEVICE
block|,
name|XPT_DEPTH_PERIPH
block|}
name|xpt_traverse_depth
typedef|;
end_typedef

begin_struct
struct|struct
name|xpt_traverse_config
block|{
name|xpt_traverse_depth
name|depth
decl_stmt|;
name|void
modifier|*
name|tr_func
decl_stmt|;
name|void
modifier|*
name|tr_arg
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|int
name|xpt_busfunc_t
parameter_list|(
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|int
name|xpt_targetfunc_t
parameter_list|(
name|struct
name|cam_et
modifier|*
name|target
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|int
name|xpt_devicefunc_t
parameter_list|(
name|struct
name|cam_ed
modifier|*
name|device
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|int
name|xpt_periphfunc_t
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|int
name|xpt_pdrvfunc_t
parameter_list|(
name|struct
name|periph_driver
modifier|*
modifier|*
name|pdrv
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/* Transport layer configuration information */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|xpt_softc
name|xsoftc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Queues for our software interrupt handler */
end_comment

begin_typedef
typedef|typedef
name|TAILQ_HEAD
argument_list|(
argument|cam_isrq
argument_list|,
argument|ccb_hdr
argument_list|)
name|cam_isrq_t
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|TAILQ_HEAD
argument_list|(
argument|cam_simq
argument_list|,
argument|cam_sim
argument_list|)
name|cam_simq_t
expr_stmt|;
end_typedef

begin_decl_stmt
specifier|static
name|cam_simq_t
name|cam_simq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|cam_simq_lock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointers to software interrupt handlers */
end_comment

begin_decl_stmt
specifier|static
name|void
modifier|*
name|cambio_ih
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cam_periph
modifier|*
name|xpt_periph
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_init_t
name|xpt_periph_init
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_init_t
name|probe_periph_init
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|periph_driver
name|xpt_driver
init|=
block|{
name|xpt_periph_init
block|,
literal|"xpt"
block|,
name|TAILQ_HEAD_INITIALIZER
argument_list|(
argument|xpt_driver.units
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|periph_driver
name|probe_driver
init|=
block|{
name|probe_periph_init
block|,
literal|"probe"
block|,
name|TAILQ_HEAD_INITIALIZER
argument_list|(
argument|probe_driver.units
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|PERIPHDRIVER_DECLARE
argument_list|(
name|xpt
argument_list|,
name|xpt_driver
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PERIPHDRIVER_DECLARE
argument_list|(
name|probe
argument_list|,
name|probe_driver
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|xptopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|xptclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|xptioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|xpt_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_flags
operator|=
literal|0
block|,
operator|.
name|d_open
operator|=
name|xptopen
block|,
operator|.
name|d_close
operator|=
name|xptclose
block|,
operator|.
name|d_ioctl
operator|=
name|xptioctl
block|,
operator|.
name|d_name
operator|=
literal|"xpt"
block|, }
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|dead_sim_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dead_sim_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Dummy SIM that is used when the real one has gone. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cam_sim
name|cam_dead_sim
init|=
block|{
operator|.
name|sim_action
operator|=
name|dead_sim_action
block|,
operator|.
name|sim_poll
operator|=
name|dead_sim_poll
block|,
operator|.
name|sim_name
operator|=
literal|"dead_sim"
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SIM_DEAD
parameter_list|(
name|sim
parameter_list|)
value|((sim) ==&cam_dead_sim)
end_define

begin_comment
comment|/* Storage for debugging datastructures */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CAMDEBUG
end_ifdef

begin_decl_stmt
name|struct
name|cam_path
modifier|*
name|cam_dpath
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int32_t
name|cam_dflags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int32_t
name|cam_debug_delay
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CAM_DEBUG_FLAGS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|CAMDEBUG
argument_list|)
end_if

begin_error
error|#
directive|error
literal|"You must have options CAMDEBUG to use options CAM_DEBUG_FLAGS"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * In order to enable the CAM_DEBUG_* options, the user must have CAMDEBUG  * enabled.  Also, the user must have either none, or all of CAM_DEBUG_BUS,  * CAM_DEBUG_TARGET, and CAM_DEBUG_LUN specified.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CAM_DEBUG_BUS
argument_list|)
operator|||
name|defined
argument_list|(
name|CAM_DEBUG_TARGET
argument_list|)
expr|\
operator|||
name|defined
argument_list|(
name|CAM_DEBUG_LUN
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|CAMDEBUG
end_ifdef

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CAM_DEBUG_BUS
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|CAM_DEBUG_TARGET
argument_list|)
expr|\
operator|||
operator|!
name|defined
argument_list|(
name|CAM_DEBUG_LUN
argument_list|)
end_if

begin_error
error|#
directive|error
literal|"You must define all or none of CAM_DEBUG_BUS, CAM_DEBUG_TARGET \         and CAM_DEBUG_LUN"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !CAM_DEBUG_BUS || !CAM_DEBUG_TARGET || !CAM_DEBUG_LUN */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !CAMDEBUG */
end_comment

begin_error
error|#
directive|error
literal|"You must use options CAMDEBUG if you use the CAM_DEBUG_* options"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CAMDEBUG */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CAM_DEBUG_BUS || CAM_DEBUG_TARGET || CAM_DEBUG_LUN */
end_comment

begin_comment
comment|/* Our boot-time initialization hook */
end_comment

begin_function_decl
specifier|static
name|int
name|cam_module_event_handler
parameter_list|(
name|module_t
parameter_list|,
name|int
comment|/*modeventtype_t*/
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|moduledata_t
name|cam_moduledata
init|=
block|{
literal|"cam"
block|,
name|cam_module_event_handler
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|xpt_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|cam
argument_list|,
name|cam_moduledata
argument_list|,
name|SI_SUB_CONFIGURE
argument_list|,
name|SI_ORDER_SECOND
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|cam
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|cam_status
name|xpt_compile_path
parameter_list|(
name|struct
name|cam_path
modifier|*
name|new_path
parameter_list|,
name|struct
name|cam_periph
modifier|*
name|perph
parameter_list|,
name|path_id_t
name|path_id
parameter_list|,
name|target_id_t
name|target_id
parameter_list|,
name|lun_id_t
name|lun_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xpt_release_path
parameter_list|(
name|struct
name|cam_path
modifier|*
name|path
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xpt_async_bcast
parameter_list|(
name|struct
name|async_list
modifier|*
name|async_head
parameter_list|,
name|u_int32_t
name|async_code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|async_arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xpt_dev_async
parameter_list|(
name|u_int32_t
name|async_code
parameter_list|,
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|,
name|struct
name|cam_et
modifier|*
name|target
parameter_list|,
name|struct
name|cam_ed
modifier|*
name|device
parameter_list|,
name|void
modifier|*
name|async_arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|path_id_t
name|xptnextfreepathid
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|path_id_t
name|xptpathid
parameter_list|(
specifier|const
name|char
modifier|*
name|sim_name
parameter_list|,
name|int
name|sim_unit
parameter_list|,
name|int
name|sim_bus
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|union
name|ccb
modifier|*
name|xpt_get_ccb
parameter_list|(
name|struct
name|cam_ed
modifier|*
name|device
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xpt_schedule_dev
parameter_list|(
name|struct
name|camq
modifier|*
name|queue
parameter_list|,
name|cam_pinfo
modifier|*
name|dev_pinfo
parameter_list|,
name|u_int32_t
name|new_priority
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xpt_run_dev_allocq
parameter_list|(
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xpt_run_dev_sendq
parameter_list|(
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|timeout_t
name|xpt_release_devq_timeout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xpt_release_simq_timeout
argument_list|(
name|void
operator|*
name|arg
argument_list|)
name|__unused
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|xpt_release_bus
parameter_list|(
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xpt_release_devq_device
parameter_list|(
name|struct
name|cam_ed
modifier|*
name|dev
parameter_list|,
name|u_int
name|count
parameter_list|,
name|int
name|run_queue
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|cam_et
modifier|*
name|xpt_alloc_target
parameter_list|(
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|,
name|target_id_t
name|target_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xpt_release_target
parameter_list|(
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|,
name|struct
name|cam_et
modifier|*
name|target
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|cam_ed
modifier|*
name|xpt_alloc_device
parameter_list|(
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|,
name|struct
name|cam_et
modifier|*
name|target
parameter_list|,
name|lun_id_t
name|lun_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xpt_release_device
parameter_list|(
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|,
name|struct
name|cam_et
modifier|*
name|target
parameter_list|,
name|struct
name|cam_ed
modifier|*
name|device
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|xpt_dev_ccbq_resize
parameter_list|(
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|int
name|newopenings
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|cam_eb
modifier|*
name|xpt_find_bus
parameter_list|(
name|path_id_t
name|path_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|cam_et
modifier|*
name|xpt_find_target
parameter_list|(
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|,
name|target_id_t
name|target_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|cam_ed
modifier|*
name|xpt_find_device
parameter_list|(
name|struct
name|cam_et
modifier|*
name|target
parameter_list|,
name|lun_id_t
name|lun_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xpt_scan_bus
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xpt_scan_lun
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|cam_flags
name|flags
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xptscandone
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|done_ccb
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|xpt_busfunc_t
name|xptconfigbuscountfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xpt_busfunc_t
name|xptconfigfunc
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|xpt_config
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|xpt_devicefunc_t
name|xptpassannouncefunc
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|xpt_finishconfig
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xptaction
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|work_ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xptpoll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|camisr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|camisr_runqueue
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|dev_match_ret
name|xptbusmatch
parameter_list|(
name|struct
name|dev_match_pattern
modifier|*
name|patterns
parameter_list|,
name|u_int
name|num_patterns
parameter_list|,
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|dev_match_ret
name|xptdevicematch
parameter_list|(
name|struct
name|dev_match_pattern
modifier|*
name|patterns
parameter_list|,
name|u_int
name|num_patterns
parameter_list|,
name|struct
name|cam_ed
modifier|*
name|device
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|dev_match_ret
name|xptperiphmatch
parameter_list|(
name|struct
name|dev_match_pattern
modifier|*
name|patterns
parameter_list|,
name|u_int
name|num_patterns
parameter_list|,
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|xpt_busfunc_t
name|xptedtbusfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xpt_targetfunc_t
name|xptedttargetfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xpt_devicefunc_t
name|xptedtdevicefunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xpt_periphfunc_t
name|xptedtperiphfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xpt_pdrvfunc_t
name|xptplistpdrvfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xpt_periphfunc_t
name|xptplistperiphfunc
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|xptedtmatch
parameter_list|(
name|struct
name|ccb_dev_match
modifier|*
name|cdm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xptperiphlistmatch
parameter_list|(
name|struct
name|ccb_dev_match
modifier|*
name|cdm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xptbustraverse
parameter_list|(
name|struct
name|cam_eb
modifier|*
name|start_bus
parameter_list|,
name|xpt_busfunc_t
modifier|*
name|tr_func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xpttargettraverse
parameter_list|(
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|,
name|struct
name|cam_et
modifier|*
name|start_target
parameter_list|,
name|xpt_targetfunc_t
modifier|*
name|tr_func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xptdevicetraverse
parameter_list|(
name|struct
name|cam_et
modifier|*
name|target
parameter_list|,
name|struct
name|cam_ed
modifier|*
name|start_device
parameter_list|,
name|xpt_devicefunc_t
modifier|*
name|tr_func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xptperiphtraverse
parameter_list|(
name|struct
name|cam_ed
modifier|*
name|device
parameter_list|,
name|struct
name|cam_periph
modifier|*
name|start_periph
parameter_list|,
name|xpt_periphfunc_t
modifier|*
name|tr_func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xptpdrvtraverse
parameter_list|(
name|struct
name|periph_driver
modifier|*
modifier|*
name|start_pdrv
parameter_list|,
name|xpt_pdrvfunc_t
modifier|*
name|tr_func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xptpdperiphtraverse
parameter_list|(
name|struct
name|periph_driver
modifier|*
modifier|*
name|pdrv
parameter_list|,
name|struct
name|cam_periph
modifier|*
name|start_periph
parameter_list|,
name|xpt_periphfunc_t
modifier|*
name|tr_func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|xpt_busfunc_t
name|xptdefbusfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xpt_targetfunc_t
name|xptdeftargetfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xpt_devicefunc_t
name|xptdefdevicefunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xpt_periphfunc_t
name|xptdefperiphfunc
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|xpt_for_all_busses
parameter_list|(
name|xpt_busfunc_t
modifier|*
name|tr_func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xpt_for_all_devices
parameter_list|(
name|xpt_devicefunc_t
modifier|*
name|tr_func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|xpt_devicefunc_t
name|xptsetasyncfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xpt_busfunc_t
name|xptsetasyncbusfunc
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|cam_status
name|xptregister
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cam_status
name|proberegister
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|probeschedule
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|probe_periph
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|probestart
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|start_ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|proberequestdefaultnegotiation
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|proberequestbackoff
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|cam_ed
modifier|*
name|device
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|probedone
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|done_ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|probecleanup
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xpt_find_quirk
parameter_list|(
name|struct
name|cam_ed
modifier|*
name|device
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xpt_devise_transport
parameter_list|(
name|struct
name|cam_path
modifier|*
name|path
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xpt_set_transfer_settings
parameter_list|(
name|struct
name|ccb_trans_settings
modifier|*
name|cts
parameter_list|,
name|struct
name|cam_ed
modifier|*
name|device
parameter_list|,
name|int
name|async_update
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xpt_toggle_tags
parameter_list|(
name|struct
name|cam_path
modifier|*
name|path
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xpt_start_tags
parameter_list|(
name|struct
name|cam_path
modifier|*
name|path
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|int
name|xpt_schedule_dev_allocq
parameter_list|(
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|,
name|struct
name|cam_ed
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|int
name|xpt_schedule_dev_sendq
parameter_list|(
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|,
name|struct
name|cam_ed
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|int
name|periph_is_queued
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|int
name|device_is_alloc_queued
parameter_list|(
name|struct
name|cam_ed
modifier|*
name|device
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|int
name|device_is_send_queued
parameter_list|(
name|struct
name|cam_ed
modifier|*
name|device
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|int
name|dev_allocq_is_runnable
parameter_list|(
name|struct
name|cam_devq
modifier|*
name|devq
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|__inline
name|int
name|xpt_schedule_dev_allocq
parameter_list|(
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|,
name|struct
name|cam_ed
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
if|if
condition|(
name|dev
operator|->
name|ccbq
operator|.
name|devq_openings
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|dev
operator|->
name|flags
operator|&
name|CAM_DEV_RESIZE_QUEUE_NEEDED
operator|)
operator|!=
literal|0
condition|)
block|{
name|cam_ccbq_resize
argument_list|(
operator|&
name|dev
operator|->
name|ccbq
argument_list|,
name|dev
operator|->
name|ccbq
operator|.
name|dev_openings
operator|+
name|dev
operator|->
name|ccbq
operator|.
name|dev_active
argument_list|)
expr_stmt|;
name|dev
operator|->
name|flags
operator|&=
operator|~
name|CAM_DEV_RESIZE_QUEUE_NEEDED
expr_stmt|;
block|}
comment|/* 		 * The priority of a device waiting for CCB resources 		 * is that of the the highest priority peripheral driver 		 * enqueued. 		 */
name|retval
operator|=
name|xpt_schedule_dev
argument_list|(
operator|&
name|bus
operator|->
name|sim
operator|->
name|devq
operator|->
name|alloc_queue
argument_list|,
operator|&
name|dev
operator|->
name|alloc_ccb_entry
operator|.
name|pinfo
argument_list|,
name|CAMQ_GET_HEAD
argument_list|(
operator|&
name|dev
operator|->
name|drvq
argument_list|)
operator|->
name|priority
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|xpt_schedule_dev_sendq
parameter_list|(
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|,
name|struct
name|cam_ed
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
if|if
condition|(
name|dev
operator|->
name|ccbq
operator|.
name|dev_openings
operator|>
literal|0
condition|)
block|{
comment|/* 		 * The priority of a device waiting for controller 		 * resources is that of the the highest priority CCB 		 * enqueued. 		 */
name|retval
operator|=
name|xpt_schedule_dev
argument_list|(
operator|&
name|bus
operator|->
name|sim
operator|->
name|devq
operator|->
name|send_queue
argument_list|,
operator|&
name|dev
operator|->
name|send_ccb_entry
operator|.
name|pinfo
argument_list|,
name|CAMQ_GET_HEAD
argument_list|(
operator|&
name|dev
operator|->
name|ccbq
operator|.
name|queue
argument_list|)
operator|->
name|priority
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|periph_is_queued
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
return|return
operator|(
name|periph
operator|->
name|pinfo
operator|.
name|index
operator|!=
name|CAM_UNQUEUED_INDEX
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|device_is_alloc_queued
parameter_list|(
name|struct
name|cam_ed
modifier|*
name|device
parameter_list|)
block|{
return|return
operator|(
name|device
operator|->
name|alloc_ccb_entry
operator|.
name|pinfo
operator|.
name|index
operator|!=
name|CAM_UNQUEUED_INDEX
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|device_is_send_queued
parameter_list|(
name|struct
name|cam_ed
modifier|*
name|device
parameter_list|)
block|{
return|return
operator|(
name|device
operator|->
name|send_ccb_entry
operator|.
name|pinfo
operator|.
name|index
operator|!=
name|CAM_UNQUEUED_INDEX
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|dev_allocq_is_runnable
parameter_list|(
name|struct
name|cam_devq
modifier|*
name|devq
parameter_list|)
block|{
comment|/* 	 * Have work to do. 	 * Have space to do more work. 	 * Allowed to do work. 	 */
return|return
operator|(
operator|(
name|devq
operator|->
name|alloc_queue
operator|.
name|qfrozen_cnt
operator|==
literal|0
operator|)
operator|&&
operator|(
name|devq
operator|->
name|alloc_queue
operator|.
name|entries
operator|>
literal|0
operator|)
operator|&&
operator|(
name|devq
operator|->
name|alloc_openings
operator|>
literal|0
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xpt_periph_init
parameter_list|()
block|{
name|make_dev
argument_list|(
operator|&
name|xpt_cdevsw
argument_list|,
literal|0
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0600
argument_list|,
literal|"xpt0"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|probe_periph_init
parameter_list|()
block|{ }
end_function

begin_function
specifier|static
name|void
name|xptdone
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|done_ccb
parameter_list|)
block|{
comment|/* Caller will release the CCB */
name|wakeup
argument_list|(
operator|&
name|done_ccb
operator|->
name|ccb_h
operator|.
name|cbfcnp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|xptopen
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
comment|/* 	 * Only allow read-write access. 	 */
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
name|FWRITE
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|flags
operator|&
name|FREAD
operator|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
comment|/* 	 * We don't allow nonblocking access. 	 */
if|if
condition|(
operator|(
name|flags
operator|&
name|O_NONBLOCK
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: can't do nonblocking access\n"
argument_list|,
name|devtoname
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
comment|/* Mark ourselves open */
name|mtx_lock
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_lock
argument_list|)
expr_stmt|;
name|xsoftc
operator|.
name|flags
operator||=
name|XPT_FLAG_OPEN
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xptclose
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
comment|/* Mark ourselves closed */
name|mtx_lock
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_lock
argument_list|)
expr_stmt|;
name|xsoftc
operator|.
name|flags
operator|&=
operator|~
name|XPT_FLAG_OPEN
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Don't automatically grab the xpt softc lock here even though this is going  * through the xpt device.  The xpt device is really just a back door for  * accessing other devices and SIMs, so the right thing to do is to grab  * the appropriate SIM lock once the bus/SIM is located.  */
end_comment

begin_function
specifier|static
name|int
name|xptioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
comment|/* 	 * For the transport layer CAMIOCOMMAND ioctl, we really only want 	 * to accept CCB types that don't quite make sense to send through a 	 * passthrough driver. XPT_PATH_INQ is an exception to this, as stated 	 * in the CAM spec. 	 */
case|case
name|CAMIOCOMMAND
case|:
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|union
name|ccb
modifier|*
name|inccb
decl_stmt|;
name|struct
name|cam_eb
modifier|*
name|bus
decl_stmt|;
name|inccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|addr
expr_stmt|;
name|bus
operator|=
name|xpt_find_bus
argument_list|(
name|inccb
operator|->
name|ccb_h
operator|.
name|path_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|inccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_SCAN_BUS
case|:
case|case
name|XPT_RESET_BUS
case|:
if|if
condition|(
operator|(
name|inccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|!=
name|CAM_TARGET_WILDCARD
operator|)
operator|||
operator|(
name|inccb
operator|->
name|ccb_h
operator|.
name|target_lun
operator|!=
name|CAM_LUN_WILDCARD
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
name|XPT_PATH_INQ
case|:
case|case
name|XPT_ENG_INQ
case|:
case|case
name|XPT_SCAN_LUN
case|:
name|ccb
operator|=
name|xpt_alloc_ccb
argument_list|()
expr_stmt|;
name|CAM_SIM_LOCK
argument_list|(
name|bus
operator|->
name|sim
argument_list|)
expr_stmt|;
comment|/* 			 * Create a path using the bus, target, and lun the 			 * user passed in. 			 */
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|xpt_periph
argument_list|,
name|inccb
operator|->
name|ccb_h
operator|.
name|path_id
argument_list|,
name|inccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|inccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
name|CAM_SIM_UNLOCK
argument_list|(
name|bus
operator|->
name|sim
argument_list|)
expr_stmt|;
name|xpt_free_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Ensure all of our fields are correct */
name|xpt_setup_ccb
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|inccb
operator|->
name|ccb_h
operator|.
name|pinfo
operator|.
name|priority
argument_list|)
expr_stmt|;
name|xpt_merge_ccb
argument_list|(
name|ccb
argument_list|,
name|inccb
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|cbfcnp
operator|=
name|xptdone
expr_stmt|;
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|ccb
argument_list|,
name|inccb
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|ccb
argument_list|)
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|xpt_free_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|CAM_SIM_UNLOCK
argument_list|(
name|bus
operator|->
name|sim
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_DEBUG
case|:
block|{
name|union
name|ccb
name|ccb
decl_stmt|;
comment|/* 			 * This is an immediate CCB, so it's okay to 			 * allocate it on the stack. 			 */
name|CAM_SIM_LOCK
argument_list|(
name|bus
operator|->
name|sim
argument_list|)
expr_stmt|;
comment|/* 			 * Create a path using the bus, target, and lun the 			 * user passed in. 			 */
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|ccb
operator|.
name|ccb_h
operator|.
name|path
argument_list|,
name|xpt_periph
argument_list|,
name|inccb
operator|->
name|ccb_h
operator|.
name|path_id
argument_list|,
name|inccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|inccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* Ensure all of our fields are correct */
name|xpt_setup_ccb
argument_list|(
operator|&
name|ccb
operator|.
name|ccb_h
argument_list|,
name|ccb
operator|.
name|ccb_h
operator|.
name|path
argument_list|,
name|inccb
operator|->
name|ccb_h
operator|.
name|pinfo
operator|.
name|priority
argument_list|)
expr_stmt|;
name|xpt_merge_ccb
argument_list|(
operator|&
name|ccb
argument_list|,
name|inccb
argument_list|)
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|cbfcnp
operator|=
name|xptdone
expr_stmt|;
name|xpt_action
argument_list|(
operator|&
name|ccb
argument_list|)
expr_stmt|;
name|CAM_SIM_UNLOCK
argument_list|(
name|bus
operator|->
name|sim
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|ccb
argument_list|,
name|inccb
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|ccb
argument_list|)
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|ccb
operator|.
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_DEV_MATCH
case|:
block|{
name|struct
name|cam_periph_map_info
name|mapinfo
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|old_path
decl_stmt|;
comment|/* 			 * We can't deal with physical addresses for this 			 * type of transaction. 			 */
if|if
condition|(
name|inccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DATA_PHYS
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* 			 * Save this in case the caller had it set to 			 * something in particular. 			 */
name|old_path
operator|=
name|inccb
operator|->
name|ccb_h
operator|.
name|path
expr_stmt|;
comment|/* 			 * We really don't need a path for the matching 			 * code.  The path is needed because of the 			 * debugging statements in xpt_action().  They 			 * assume that the CCB has a valid path. 			 */
name|inccb
operator|->
name|ccb_h
operator|.
name|path
operator|=
name|xpt_periph
operator|->
name|path
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|mapinfo
argument_list|,
sizeof|sizeof
argument_list|(
name|mapinfo
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * Map the pattern and match buffers into kernel 			 * virtual address space. 			 */
name|error
operator|=
name|cam_periph_mapmem
argument_list|(
name|inccb
argument_list|,
operator|&
name|mapinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|inccb
operator|->
name|ccb_h
operator|.
name|path
operator|=
name|old_path
expr_stmt|;
break|break;
block|}
comment|/* 			 * This is an immediate CCB, we can send it on directly. 			 */
name|xpt_action
argument_list|(
name|inccb
argument_list|)
expr_stmt|;
comment|/* 			 * Map the buffers back into user space. 			 */
name|cam_periph_unmapmem
argument_list|(
name|inccb
argument_list|,
operator|&
name|mapinfo
argument_list|)
expr_stmt|;
name|inccb
operator|->
name|ccb_h
operator|.
name|path
operator|=
name|old_path
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
default|default:
name|error
operator|=
name|ENOTSUP
expr_stmt|;
break|break;
block|}
break|break;
block|}
comment|/* 	 * This is the getpassthru ioctl. It takes a XPT_GDEVLIST ccb as input, 	 * with the periphal driver name and unit name filled in.  The other 	 * fields don't really matter as input.  The passthrough driver name 	 * ("pass"), and unit number are passed back in the ccb.  The current 	 * device generation number, and the index into the device peripheral 	 * driver list, and the status are also passed back.  Note that 	 * since we do everything in one pass, unlike the XPT_GDEVLIST ccb, 	 * we never return a status of CAM_GDEVLIST_LIST_CHANGED.  It is 	 * (or rather should be) impossible for the device peripheral driver 	 * list to change since we look at the whole thing in one pass, and 	 * we do it with lock protection. 	 *  	 */
case|case
name|CAMGETPASSTHRU
case|:
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|periph_driver
modifier|*
modifier|*
name|p_drv
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|u_int
name|unit
decl_stmt|;
name|u_int
name|cur_generation
decl_stmt|;
name|int
name|base_periph_found
decl_stmt|;
name|int
name|splbreaknum
decl_stmt|;
name|ccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|addr
expr_stmt|;
name|unit
operator|=
name|ccb
operator|->
name|cgdl
operator|.
name|unit_number
expr_stmt|;
name|name
operator|=
name|ccb
operator|->
name|cgdl
operator|.
name|periph_name
expr_stmt|;
comment|/* 		 * Every 100 devices, we want to drop our lock protection to 		 * give the software interrupt handler a chance to run. 		 * Most systems won't run into this check, but this should 		 * avoid starvation in the software interrupt handler in 		 * large systems. 		 */
name|splbreaknum
operator|=
literal|100
expr_stmt|;
name|ccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|addr
expr_stmt|;
name|base_periph_found
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Sanity check -- make sure we don't get a null peripheral 		 * driver name. 		 */
if|if
condition|(
operator|*
name|ccb
operator|->
name|cgdl
operator|.
name|periph_name
operator|==
literal|'\0'
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* Keep the list from changing while we traverse it */
name|mtx_lock
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_topo_lock
argument_list|)
expr_stmt|;
name|ptstartover
label|:
name|cur_generation
operator|=
name|xsoftc
operator|.
name|xpt_generation
expr_stmt|;
comment|/* first find our driver in the list of drivers */
for|for
control|(
name|p_drv
operator|=
name|periph_drivers
init|;
operator|*
name|p_drv
operator|!=
name|NULL
condition|;
name|p_drv
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|(
operator|*
name|p_drv
operator|)
operator|->
name|driver_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|*
name|p_drv
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_topo_lock
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP_ERR
expr_stmt|;
name|ccb
operator|->
name|cgdl
operator|.
name|status
operator|=
name|CAM_GDEVLIST_ERROR
expr_stmt|;
operator|*
name|ccb
operator|->
name|cgdl
operator|.
name|periph_name
operator|=
literal|'\0'
expr_stmt|;
name|ccb
operator|->
name|cgdl
operator|.
name|unit_number
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
comment|/* 		 * Run through every peripheral instance of this driver 		 * and check to see whether it matches the unit passed 		 * in by the user.  If it does, get out of the loops and 		 * find the passthrough driver associated with that 		 * peripheral driver. 		 */
for|for
control|(
name|periph
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
operator|(
operator|*
name|p_drv
operator|)
operator|->
name|units
argument_list|)
init|;
name|periph
operator|!=
name|NULL
condition|;
name|periph
operator|=
name|TAILQ_NEXT
argument_list|(
name|periph
argument_list|,
name|unit_links
argument_list|)
control|)
block|{
if|if
condition|(
name|periph
operator|->
name|unit_number
operator|==
name|unit
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
operator|--
name|splbreaknum
operator|==
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_topo_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_topo_lock
argument_list|)
expr_stmt|;
name|splbreaknum
operator|=
literal|100
expr_stmt|;
if|if
condition|(
name|cur_generation
operator|!=
name|xsoftc
operator|.
name|xpt_generation
condition|)
goto|goto
name|ptstartover
goto|;
block|}
block|}
comment|/* 		 * If we found the peripheral driver that the user passed 		 * in, go through all of the peripheral drivers for that 		 * particular device and look for a passthrough driver. 		 */
if|if
condition|(
name|periph
operator|!=
name|NULL
condition|)
block|{
name|struct
name|cam_ed
modifier|*
name|device
decl_stmt|;
name|int
name|i
decl_stmt|;
name|base_periph_found
operator|=
literal|1
expr_stmt|;
name|device
operator|=
name|periph
operator|->
name|path
operator|->
name|device
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|periph
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|device
operator|->
name|periphs
argument_list|)
init|;
name|periph
operator|!=
name|NULL
condition|;
name|periph
operator|=
name|SLIST_NEXT
argument_list|(
name|periph
argument_list|,
name|periph_links
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
comment|/* 				 * Check to see whether we have a 				 * passthrough device or not.  				 */
if|if
condition|(
name|strcmp
argument_list|(
name|periph
operator|->
name|periph_name
argument_list|,
literal|"pass"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 					 * Fill in the getdevlist fields. 					 */
name|strcpy
argument_list|(
name|ccb
operator|->
name|cgdl
operator|.
name|periph_name
argument_list|,
name|periph
operator|->
name|periph_name
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|cgdl
operator|.
name|unit_number
operator|=
name|periph
operator|->
name|unit_number
expr_stmt|;
if|if
condition|(
name|SLIST_NEXT
argument_list|(
name|periph
argument_list|,
name|periph_links
argument_list|)
condition|)
name|ccb
operator|->
name|cgdl
operator|.
name|status
operator|=
name|CAM_GDEVLIST_MORE_DEVS
expr_stmt|;
else|else
name|ccb
operator|->
name|cgdl
operator|.
name|status
operator|=
name|CAM_GDEVLIST_LAST_DEVICE
expr_stmt|;
name|ccb
operator|->
name|cgdl
operator|.
name|generation
operator|=
name|device
operator|->
name|generation
expr_stmt|;
name|ccb
operator|->
name|cgdl
operator|.
name|index
operator|=
name|i
expr_stmt|;
comment|/* 					 * Fill in some CCB header fields 					 * that the user may want. 					 */
name|ccb
operator|->
name|ccb_h
operator|.
name|path_id
operator|=
name|periph
operator|->
name|path
operator|->
name|bus
operator|->
name|path_id
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|=
name|periph
operator|->
name|path
operator|->
name|target
operator|->
name|target_id
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
operator|=
name|periph
operator|->
name|path
operator|->
name|device
operator|->
name|lun_id
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* 		 * If the periph is null here, one of two things has 		 * happened.  The first possibility is that we couldn't 		 * find the unit number of the particular peripheral driver 		 * that the user is asking about.  e.g. the user asks for 		 * the passthrough driver for "da11".  We find the list of 		 * "da" peripherals all right, but there is no unit 11. 		 * The other possibility is that we went through the list 		 * of peripheral drivers attached to the device structure, 		 * but didn't find one with the name "pass".  Either way, 		 * we return ENOENT, since we couldn't find something. 		 */
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP_ERR
expr_stmt|;
name|ccb
operator|->
name|cgdl
operator|.
name|status
operator|=
name|CAM_GDEVLIST_ERROR
expr_stmt|;
operator|*
name|ccb
operator|->
name|cgdl
operator|.
name|periph_name
operator|=
literal|'\0'
expr_stmt|;
name|ccb
operator|->
name|cgdl
operator|.
name|unit_number
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|ENOENT
expr_stmt|;
comment|/* 			 * It is unfortunate that this is even necessary, 			 * but there are many, many clueless users out there. 			 * If this is true, the user is looking for the 			 * passthrough driver, but doesn't have one in his 			 * kernel. 			 */
if|if
condition|(
name|base_periph_found
operator|==
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"xptioctl: pass driver is not in the "
literal|"kernel\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"xptioctl: put \"device pass0\" in "
literal|"your kernel config file\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_topo_lock
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|error
operator|=
name|ENOTTY
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cam_module_event_handler
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|MOD_LOAD
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|xpt_init
argument_list|(
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
break|break;
case|case
name|MOD_UNLOAD
case|:
return|return
name|EBUSY
return|;
default|default:
return|return
name|EOPNOTSUPP
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* thread to handle bus rescans */
end_comment

begin_function
specifier|static
name|void
name|xpt_scanner_thread
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|cam_isrq_t
name|queue
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Wait for a rescan request to come in.  When it does, splice 		 * it onto a queue from local storage so that the xpt lock 		 * doesn't need to be held while the requests are being 		 * processed. 		 */
name|xpt_lock_buses
argument_list|()
expr_stmt|;
name|msleep
argument_list|(
operator|&
name|xsoftc
operator|.
name|ccb_scanq
argument_list|,
operator|&
name|xsoftc
operator|.
name|xpt_topo_lock
argument_list|,
name|PRIBIO
argument_list|,
literal|"ccb_scanq"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|queue
argument_list|)
expr_stmt|;
name|TAILQ_CONCAT
argument_list|(
operator|&
name|queue
argument_list|,
operator|&
name|xsoftc
operator|.
name|ccb_scanq
argument_list|,
name|sim_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|xpt_unlock_buses
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|ccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|TAILQ_FIRST
argument_list|(
operator|&
name|queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|queue
argument_list|,
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|sim
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|path
operator|->
name|bus
operator|->
name|sim
expr_stmt|;
name|CAM_SIM_LOCK
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SCAN_BUS
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|cbfcnp
operator|=
name|xptdone
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|xpt_free_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|CAM_SIM_UNLOCK
argument_list|(
name|sim
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|xpt_rescan
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|hdr
decl_stmt|;
comment|/* 	 * Don't make duplicate entries for the same paths. 	 */
name|xpt_lock_buses
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|hdr
argument_list|,
argument|&xsoftc.ccb_scanq
argument_list|,
argument|sim_links.tqe
argument_list|)
block|{
if|if
condition|(
name|xpt_path_comp
argument_list|(
name|hdr
operator|->
name|path
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xpt_unlock_buses
argument_list|()
expr_stmt|;
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"rescan already queued\n"
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|xpt_free_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|xsoftc
operator|.
name|ccb_scanq
argument_list|,
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|xsoftc
operator|.
name|ccb_scanq
argument_list|)
expr_stmt|;
name|xpt_unlock_buses
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Functions accessed by the peripheral drivers */
end_comment

begin_function
specifier|static
name|int
name|xpt_init
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|struct
name|cam_sim
modifier|*
name|xpt_sim
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_busses
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|cam_simq
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|xsoftc
operator|.
name|ccb_scanq
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|xsoftc
operator|.
name|highpowerq
argument_list|)
expr_stmt|;
name|xsoftc
operator|.
name|num_highpower
operator|=
name|CAM_MAX_HIGHPOWER
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|cam_simq_lock
argument_list|,
literal|"CAM SIMQ lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_lock
argument_list|,
literal|"XPT lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_topo_lock
argument_list|,
literal|"XPT topology lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* 	 * The xpt layer is, itself, the equivelent of a SIM. 	 * Allow 16 ccbs in the ccb pool for it.  This should 	 * give decent parallelism when we probe busses and 	 * perform other XPT functions. 	 */
name|devq
operator|=
name|cam_simq_alloc
argument_list|(
literal|16
argument_list|)
expr_stmt|;
name|xpt_sim
operator|=
name|cam_sim_alloc
argument_list|(
name|xptaction
argument_list|,
name|xptpoll
argument_list|,
literal|"xpt"
argument_list|,
comment|/*softc*/
name|NULL
argument_list|,
comment|/*unit*/
literal|0
argument_list|,
comment|/*mtx*/
operator|&
name|xsoftc
operator|.
name|xpt_lock
argument_list|,
comment|/*max_dev_transactions*/
literal|0
argument_list|,
comment|/*max_tagged_dev_transactions*/
literal|0
argument_list|,
name|devq
argument_list|)
expr_stmt|;
if|if
condition|(
name|xpt_sim
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|xpt_sim
operator|->
name|max_ccbs
operator|=
literal|16
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|=
name|xpt_bus_register
argument_list|(
name|xpt_sim
argument_list|,
comment|/*bus #*/
literal|0
argument_list|)
operator|)
operator|!=
name|CAM_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"xpt_init: xpt_bus_register failed with status %#x,"
literal|" failing attach\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * Looking at the XPT from the SIM layer, the XPT is 	 * the equivelent of a peripheral driver.  Allocate 	 * a peripheral driver entry for us. 	 */
if|if
condition|(
operator|(
name|status
operator|=
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
name|NULL
argument_list|,
name|CAM_XPT_PATH_ID
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"xpt_init: xpt_create_path failed with status %#x,"
literal|" failing attach\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|cam_periph_alloc
argument_list|(
name|xptregister
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|"xpt"
argument_list|,
name|CAM_PERIPH_BIO
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|xpt_sim
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Register a callback for when interrupts are enabled. 	 */
name|xsoftc
operator|.
name|xpt_config_hook
operator|=
operator|(
expr|struct
name|intr_config_hook
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|intr_config_hook
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|xsoftc
operator|.
name|xpt_config_hook
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"xpt_init: Cannot malloc config hook "
literal|"- failing attach\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|xsoftc
operator|.
name|xpt_config_hook
operator|->
name|ich_func
operator|=
name|xpt_config
expr_stmt|;
if|if
condition|(
name|config_intrhook_establish
argument_list|(
name|xsoftc
operator|.
name|xpt_config_hook
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|xsoftc
operator|.
name|xpt_config_hook
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"xpt_init: config_intrhook_establish failed "
literal|"- failing attach\n"
argument_list|)
expr_stmt|;
block|}
comment|/* fire up rescan thread */
if|if
condition|(
name|kthread_create
argument_list|(
name|xpt_scanner_thread
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"xpt_thrd"
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"xpt_init: failed to create rescan thread\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Install our software interrupt handlers */
name|swi_add
argument_list|(
name|NULL
argument_list|,
literal|"cambio"
argument_list|,
name|camisr
argument_list|,
name|NULL
argument_list|,
name|SWI_CAMBIO
argument_list|,
name|INTR_MPSAFE
argument_list|,
operator|&
name|cambio_ih
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|cam_status
name|xptregister
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cam_sim
modifier|*
name|xpt_sim
decl_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"xptregister: periph was NULL!!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
name|xpt_sim
operator|=
operator|(
expr|struct
name|cam_sim
operator|*
operator|)
name|arg
expr_stmt|;
name|xpt_sim
operator|->
name|softc
operator|=
name|periph
expr_stmt|;
name|xpt_periph
operator|=
name|periph
expr_stmt|;
name|periph
operator|->
name|softc
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP
operator|)
return|;
block|}
end_function

begin_function
name|int32_t
name|xpt_add_periph
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|struct
name|cam_ed
modifier|*
name|device
decl_stmt|;
name|int32_t
name|status
decl_stmt|;
name|struct
name|periph_list
modifier|*
name|periph_head
decl_stmt|;
name|mtx_assert
argument_list|(
name|periph
operator|->
name|sim
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|device
operator|=
name|periph
operator|->
name|path
operator|->
name|device
expr_stmt|;
name|periph_head
operator|=
operator|&
name|device
operator|->
name|periphs
expr_stmt|;
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
if|if
condition|(
name|device
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Make room for this peripheral 		 * so it will fit in the queue 		 * when it's scheduled to run 		 */
name|status
operator|=
name|camq_resize
argument_list|(
operator|&
name|device
operator|->
name|drvq
argument_list|,
name|device
operator|->
name|drvq
operator|.
name|array_size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|device
operator|->
name|generation
operator|++
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
name|periph_head
argument_list|,
name|periph
argument_list|,
name|periph_links
argument_list|)
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_topo_lock
argument_list|)
expr_stmt|;
name|xsoftc
operator|.
name|xpt_generation
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_topo_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
name|void
name|xpt_remove_periph
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|struct
name|cam_ed
modifier|*
name|device
decl_stmt|;
name|mtx_assert
argument_list|(
name|periph
operator|->
name|sim
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|device
operator|=
name|periph
operator|->
name|path
operator|->
name|device
expr_stmt|;
if|if
condition|(
name|device
operator|!=
name|NULL
condition|)
block|{
name|struct
name|periph_list
modifier|*
name|periph_head
decl_stmt|;
name|periph_head
operator|=
operator|&
name|device
operator|->
name|periphs
expr_stmt|;
comment|/* Release the slot for this peripheral */
name|camq_resize
argument_list|(
operator|&
name|device
operator|->
name|drvq
argument_list|,
name|device
operator|->
name|drvq
operator|.
name|array_size
operator|-
literal|1
argument_list|)
expr_stmt|;
name|device
operator|->
name|generation
operator|++
expr_stmt|;
name|SLIST_REMOVE
argument_list|(
name|periph_head
argument_list|,
name|periph
argument_list|,
name|cam_periph
argument_list|,
name|periph_links
argument_list|)
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_topo_lock
argument_list|)
expr_stmt|;
name|xsoftc
operator|.
name|xpt_generation
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_topo_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xpt_announce_periph
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|char
modifier|*
name|announce_string
parameter_list|)
block|{
name|struct
name|ccb_pathinq
name|cpi
decl_stmt|;
name|struct
name|ccb_trans_settings
name|cts
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|u_int
name|speed
decl_stmt|;
name|u_int
name|freq
decl_stmt|;
name|u_int
name|mb
decl_stmt|;
name|mtx_assert
argument_list|(
name|periph
operator|->
name|sim
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|path
operator|=
name|periph
operator|->
name|path
expr_stmt|;
comment|/* 	 * To ensure that this is printed in one piece, 	 * mask out CAM interrupts. 	 */
name|printf
argument_list|(
literal|"%s%d at %s%d bus %d target %d lun %d\n"
argument_list|,
name|periph
operator|->
name|periph_name
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|,
name|path
operator|->
name|bus
operator|->
name|sim
operator|->
name|sim_name
argument_list|,
name|path
operator|->
name|bus
operator|->
name|sim
operator|->
name|unit_number
argument_list|,
name|path
operator|->
name|bus
operator|->
name|sim
operator|->
name|bus_id
argument_list|,
name|path
operator|->
name|target
operator|->
name|target_id
argument_list|,
name|path
operator|->
name|device
operator|->
name|lun_id
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s%d: "
argument_list|,
name|periph
operator|->
name|periph_name
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|)
expr_stmt|;
name|scsi_print_inquiry
argument_list|(
operator|&
name|path
operator|->
name|device
operator|->
name|inq_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
operator|&&
name|path
operator|->
name|device
operator|->
name|serial_num_len
operator|>
literal|0
condition|)
block|{
comment|/* Don't wrap the screen  - print only the first 60 chars */
name|printf
argument_list|(
literal|"%s%d: Serial Number %.60s\n"
argument_list|,
name|periph
operator|->
name|periph_name
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|,
name|path
operator|->
name|device
operator|->
name|serial_num
argument_list|)
expr_stmt|;
block|}
name|xpt_setup_ccb
argument_list|(
operator|&
name|cts
operator|.
name|ccb_h
argument_list|,
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|cts
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_GET_TRAN_SETTINGS
expr_stmt|;
name|cts
operator|.
name|type
operator|=
name|CTS_TYPE_CURRENT_SETTINGS
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|cts
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cts
operator|.
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
return|return;
block|}
comment|/* Ask the SIM for its base transfer speed */
name|xpt_setup_ccb
argument_list|(
operator|&
name|cpi
operator|.
name|ccb_h
argument_list|,
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|cpi
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_PATH_INQ
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|cpi
argument_list|)
expr_stmt|;
name|speed
operator|=
name|cpi
operator|.
name|base_transfer_speed
expr_stmt|;
name|freq
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cts
operator|.
name|ccb_h
operator|.
name|status
operator|==
name|CAM_REQ_CMP
operator|&&
name|cts
operator|.
name|transport
operator|==
name|XPORT_SPI
condition|)
block|{
name|struct
name|ccb_trans_settings_spi
modifier|*
name|spi
decl_stmt|;
name|spi
operator|=
operator|&
name|cts
operator|.
name|xport_specific
operator|.
name|spi
expr_stmt|;
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_SYNC_OFFSET
operator|)
operator|!=
literal|0
operator|&&
name|spi
operator|->
name|sync_offset
operator|!=
literal|0
condition|)
block|{
name|freq
operator|=
name|scsi_calc_syncsrate
argument_list|(
name|spi
operator|->
name|sync_period
argument_list|)
expr_stmt|;
name|speed
operator|=
name|freq
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_BUS_WIDTH
operator|)
operator|!=
literal|0
condition|)
name|speed
operator|*=
operator|(
literal|0x01
operator|<<
name|spi
operator|->
name|bus_width
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|cts
operator|.
name|ccb_h
operator|.
name|status
operator|==
name|CAM_REQ_CMP
operator|&&
name|cts
operator|.
name|transport
operator|==
name|XPORT_FC
condition|)
block|{
name|struct
name|ccb_trans_settings_fc
modifier|*
name|fc
init|=
operator|&
name|cts
operator|.
name|xport_specific
operator|.
name|fc
decl_stmt|;
if|if
condition|(
name|fc
operator|->
name|valid
operator|&
name|CTS_FC_VALID_SPEED
condition|)
block|{
name|speed
operator|=
name|fc
operator|->
name|bitrate
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cts
operator|.
name|ccb_h
operator|.
name|status
operator|==
name|CAM_REQ_CMP
operator|&&
name|cts
operator|.
name|transport
operator|==
name|XPORT_SAS
condition|)
block|{
name|struct
name|ccb_trans_settings_sas
modifier|*
name|sas
init|=
operator|&
name|cts
operator|.
name|xport_specific
operator|.
name|sas
decl_stmt|;
if|if
condition|(
name|sas
operator|->
name|valid
operator|&
name|CTS_SAS_VALID_SPEED
condition|)
block|{
name|speed
operator|=
name|sas
operator|->
name|bitrate
expr_stmt|;
block|}
block|}
name|mb
operator|=
name|speed
operator|/
literal|1000
expr_stmt|;
if|if
condition|(
name|mb
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"%s%d: %d.%03dMB/s transfers"
argument_list|,
name|periph
operator|->
name|periph_name
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|,
name|mb
argument_list|,
name|speed
operator|%
literal|1000
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s%d: %dKB/s transfers"
argument_list|,
name|periph
operator|->
name|periph_name
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|,
name|speed
argument_list|)
expr_stmt|;
comment|/* Report additional information about SPI connections */
if|if
condition|(
name|cts
operator|.
name|ccb_h
operator|.
name|status
operator|==
name|CAM_REQ_CMP
operator|&&
name|cts
operator|.
name|transport
operator|==
name|XPORT_SPI
condition|)
block|{
name|struct
name|ccb_trans_settings_spi
modifier|*
name|spi
decl_stmt|;
name|spi
operator|=
operator|&
name|cts
operator|.
name|xport_specific
operator|.
name|spi
expr_stmt|;
if|if
condition|(
name|freq
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|" (%d.%03dMHz%s, offset %d"
argument_list|,
name|freq
operator|/
literal|1000
argument_list|,
name|freq
operator|%
literal|1000
argument_list|,
operator|(
name|spi
operator|->
name|ppr_options
operator|&
name|MSG_EXT_PPR_DT_REQ
operator|)
operator|!=
literal|0
condition|?
literal|" DT"
else|:
literal|""
argument_list|,
name|spi
operator|->
name|sync_offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_BUS_WIDTH
operator|)
operator|!=
literal|0
operator|&&
name|spi
operator|->
name|bus_width
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|freq
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|" ("
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%dbit)"
argument_list|,
literal|8
operator|*
operator|(
literal|0x01
operator|<<
name|spi
operator|->
name|bus_width
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|freq
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cts
operator|.
name|ccb_h
operator|.
name|status
operator|==
name|CAM_REQ_CMP
operator|&&
name|cts
operator|.
name|transport
operator|==
name|XPORT_FC
condition|)
block|{
name|struct
name|ccb_trans_settings_fc
modifier|*
name|fc
decl_stmt|;
name|fc
operator|=
operator|&
name|cts
operator|.
name|xport_specific
operator|.
name|fc
expr_stmt|;
if|if
condition|(
name|fc
operator|->
name|valid
operator|&
name|CTS_FC_VALID_WWNN
condition|)
name|printf
argument_list|(
literal|" WWNN 0x%llx"
argument_list|,
operator|(
name|long
name|long
operator|)
name|fc
operator|->
name|wwnn
argument_list|)
expr_stmt|;
if|if
condition|(
name|fc
operator|->
name|valid
operator|&
name|CTS_FC_VALID_WWPN
condition|)
name|printf
argument_list|(
literal|" WWPN 0x%llx"
argument_list|,
operator|(
name|long
name|long
operator|)
name|fc
operator|->
name|wwpn
argument_list|)
expr_stmt|;
if|if
condition|(
name|fc
operator|->
name|valid
operator|&
name|CTS_FC_VALID_PORT
condition|)
name|printf
argument_list|(
literal|" PortID 0x%x"
argument_list|,
name|fc
operator|->
name|port
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|path
operator|->
name|device
operator|->
name|inq_flags
operator|&
name|SID_CmdQue
operator|||
name|path
operator|->
name|device
operator|->
name|flags
operator|&
name|CAM_DEV_TAG_AFTER_COUNT
condition|)
block|{
name|printf
argument_list|(
literal|"\n%s%d: Command Queueing Enabled"
argument_list|,
name|periph
operator|->
name|periph_name
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* 	 * We only want to print the caller's announce string if they've 	 * passed one in.. 	 */
if|if
condition|(
name|announce_string
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"%s%d: %s\n"
argument_list|,
name|periph
operator|->
name|periph_name
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|,
name|announce_string
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|dev_match_ret
name|xptbusmatch
parameter_list|(
name|struct
name|dev_match_pattern
modifier|*
name|patterns
parameter_list|,
name|u_int
name|num_patterns
parameter_list|,
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|)
block|{
name|dev_match_ret
name|retval
decl_stmt|;
name|int
name|i
decl_stmt|;
name|retval
operator|=
name|DM_RET_NONE
expr_stmt|;
comment|/* 	 * If we aren't given something to match against, that's an error. 	 */
if|if
condition|(
name|bus
operator|==
name|NULL
condition|)
return|return
operator|(
name|DM_RET_ERROR
operator|)
return|;
comment|/* 	 * If there are no match entries, then this bus matches no 	 * matter what. 	 */
if|if
condition|(
operator|(
name|patterns
operator|==
name|NULL
operator|)
operator|||
operator|(
name|num_patterns
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|DM_RET_DESCEND
operator||
name|DM_RET_COPY
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_patterns
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|bus_match_pattern
modifier|*
name|cur_pattern
decl_stmt|;
comment|/* 		 * If the pattern in question isn't for a bus node, we 		 * aren't interested.  However, we do indicate to the 		 * calling routine that we should continue descending the 		 * tree, since the user wants to match against lower-level 		 * EDT elements. 		 */
if|if
condition|(
name|patterns
index|[
name|i
index|]
operator|.
name|type
operator|!=
name|DEV_MATCH_BUS
condition|)
block|{
if|if
condition|(
operator|(
name|retval
operator|&
name|DM_RET_ACTION_MASK
operator|)
operator|==
name|DM_RET_NONE
condition|)
name|retval
operator||=
name|DM_RET_DESCEND
expr_stmt|;
continue|continue;
block|}
name|cur_pattern
operator|=
operator|&
name|patterns
index|[
name|i
index|]
operator|.
name|pattern
operator|.
name|bus_pattern
expr_stmt|;
comment|/* 		 * If they want to match any bus node, we give them any 		 * device node. 		 */
if|if
condition|(
name|cur_pattern
operator|->
name|flags
operator|==
name|BUS_MATCH_ANY
condition|)
block|{
comment|/* set the copy flag */
name|retval
operator||=
name|DM_RET_COPY
expr_stmt|;
comment|/* 			 * If we've already decided on an action, go ahead 			 * and return. 			 */
if|if
condition|(
operator|(
name|retval
operator|&
name|DM_RET_ACTION_MASK
operator|)
operator|!=
name|DM_RET_NONE
condition|)
return|return
operator|(
name|retval
operator|)
return|;
block|}
comment|/* 		 * Not sure why someone would do this... 		 */
if|if
condition|(
name|cur_pattern
operator|->
name|flags
operator|==
name|BUS_MATCH_NONE
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|cur_pattern
operator|->
name|flags
operator|&
name|BUS_MATCH_PATH
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|cur_pattern
operator|->
name|path_id
operator|!=
name|bus
operator|->
name|path_id
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|cur_pattern
operator|->
name|flags
operator|&
name|BUS_MATCH_BUS_ID
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|cur_pattern
operator|->
name|bus_id
operator|!=
name|bus
operator|->
name|sim
operator|->
name|bus_id
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|cur_pattern
operator|->
name|flags
operator|&
name|BUS_MATCH_UNIT
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|cur_pattern
operator|->
name|unit_number
operator|!=
name|bus
operator|->
name|sim
operator|->
name|unit_number
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|cur_pattern
operator|->
name|flags
operator|&
name|BUS_MATCH_NAME
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|cur_pattern
operator|->
name|dev_name
argument_list|,
name|bus
operator|->
name|sim
operator|->
name|sim_name
argument_list|,
name|DEV_IDLEN
argument_list|)
operator|!=
literal|0
operator|)
condition|)
continue|continue;
comment|/* 		 * If we get to this point, the user definitely wants  		 * information on this bus.  So tell the caller to copy the 		 * data out. 		 */
name|retval
operator||=
name|DM_RET_COPY
expr_stmt|;
comment|/* 		 * If the return action has been set to descend, then we 		 * know that we've already seen a non-bus matching 		 * expression, therefore we need to further descend the tree. 		 * This won't change by continuing around the loop, so we 		 * go ahead and return.  If we haven't seen a non-bus 		 * matching expression, we keep going around the loop until 		 * we exhaust the matching expressions.  We'll set the stop 		 * flag once we fall out of the loop. 		 */
if|if
condition|(
operator|(
name|retval
operator|&
name|DM_RET_ACTION_MASK
operator|)
operator|==
name|DM_RET_DESCEND
condition|)
return|return
operator|(
name|retval
operator|)
return|;
block|}
comment|/* 	 * If the return action hasn't been set to descend yet, that means 	 * we haven't seen anything other than bus matching patterns.  So 	 * tell the caller to stop descending the tree -- the user doesn't 	 * want to match against lower level tree elements. 	 */
if|if
condition|(
operator|(
name|retval
operator|&
name|DM_RET_ACTION_MASK
operator|)
operator|==
name|DM_RET_NONE
condition|)
name|retval
operator||=
name|DM_RET_STOP
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|dev_match_ret
name|xptdevicematch
parameter_list|(
name|struct
name|dev_match_pattern
modifier|*
name|patterns
parameter_list|,
name|u_int
name|num_patterns
parameter_list|,
name|struct
name|cam_ed
modifier|*
name|device
parameter_list|)
block|{
name|dev_match_ret
name|retval
decl_stmt|;
name|int
name|i
decl_stmt|;
name|retval
operator|=
name|DM_RET_NONE
expr_stmt|;
comment|/* 	 * If we aren't given something to match against, that's an error. 	 */
if|if
condition|(
name|device
operator|==
name|NULL
condition|)
return|return
operator|(
name|DM_RET_ERROR
operator|)
return|;
comment|/* 	 * If there are no match entries, then this device matches no 	 * matter what. 	 */
if|if
condition|(
operator|(
name|patterns
operator|==
name|NULL
operator|)
operator|||
operator|(
name|num_patterns
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|DM_RET_DESCEND
operator||
name|DM_RET_COPY
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_patterns
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|device_match_pattern
modifier|*
name|cur_pattern
decl_stmt|;
comment|/* 		 * If the pattern in question isn't for a device node, we 		 * aren't interested. 		 */
if|if
condition|(
name|patterns
index|[
name|i
index|]
operator|.
name|type
operator|!=
name|DEV_MATCH_DEVICE
condition|)
block|{
if|if
condition|(
operator|(
name|patterns
index|[
name|i
index|]
operator|.
name|type
operator|==
name|DEV_MATCH_PERIPH
operator|)
operator|&&
operator|(
operator|(
name|retval
operator|&
name|DM_RET_ACTION_MASK
operator|)
operator|==
name|DM_RET_NONE
operator|)
condition|)
name|retval
operator||=
name|DM_RET_DESCEND
expr_stmt|;
continue|continue;
block|}
name|cur_pattern
operator|=
operator|&
name|patterns
index|[
name|i
index|]
operator|.
name|pattern
operator|.
name|device_pattern
expr_stmt|;
comment|/* 		 * If they want to match any device node, we give them any 		 * device node. 		 */
if|if
condition|(
name|cur_pattern
operator|->
name|flags
operator|==
name|DEV_MATCH_ANY
condition|)
block|{
comment|/* set the copy flag */
name|retval
operator||=
name|DM_RET_COPY
expr_stmt|;
comment|/* 			 * If we've already decided on an action, go ahead 			 * and return. 			 */
if|if
condition|(
operator|(
name|retval
operator|&
name|DM_RET_ACTION_MASK
operator|)
operator|!=
name|DM_RET_NONE
condition|)
return|return
operator|(
name|retval
operator|)
return|;
block|}
comment|/* 		 * Not sure why someone would do this... 		 */
if|if
condition|(
name|cur_pattern
operator|->
name|flags
operator|==
name|DEV_MATCH_NONE
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|cur_pattern
operator|->
name|flags
operator|&
name|DEV_MATCH_PATH
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|cur_pattern
operator|->
name|path_id
operator|!=
name|device
operator|->
name|target
operator|->
name|bus
operator|->
name|path_id
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|cur_pattern
operator|->
name|flags
operator|&
name|DEV_MATCH_TARGET
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|cur_pattern
operator|->
name|target_id
operator|!=
name|device
operator|->
name|target
operator|->
name|target_id
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|cur_pattern
operator|->
name|flags
operator|&
name|DEV_MATCH_LUN
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|cur_pattern
operator|->
name|target_lun
operator|!=
name|device
operator|->
name|lun_id
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|cur_pattern
operator|->
name|flags
operator|&
name|DEV_MATCH_INQUIRY
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|cam_quirkmatch
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|device
operator|->
name|inq_data
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|cur_pattern
operator|->
name|inq_pat
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|cur_pattern
operator|->
name|inq_pat
argument_list|)
argument_list|,
name|scsi_static_inquiry_match
argument_list|)
operator|==
name|NULL
operator|)
condition|)
continue|continue;
comment|/* 		 * If we get to this point, the user definitely wants  		 * information on this device.  So tell the caller to copy 		 * the data out. 		 */
name|retval
operator||=
name|DM_RET_COPY
expr_stmt|;
comment|/* 		 * If the return action has been set to descend, then we 		 * know that we've already seen a peripheral matching 		 * expression, therefore we need to further descend the tree. 		 * This won't change by continuing around the loop, so we 		 * go ahead and return.  If we haven't seen a peripheral 		 * matching expression, we keep going around the loop until 		 * we exhaust the matching expressions.  We'll set the stop 		 * flag once we fall out of the loop. 		 */
if|if
condition|(
operator|(
name|retval
operator|&
name|DM_RET_ACTION_MASK
operator|)
operator|==
name|DM_RET_DESCEND
condition|)
return|return
operator|(
name|retval
operator|)
return|;
block|}
comment|/* 	 * If the return action hasn't been set to descend yet, that means 	 * we haven't seen any peripheral matching patterns.  So tell the 	 * caller to stop descending the tree -- the user doesn't want to 	 * match against lower level tree elements. 	 */
if|if
condition|(
operator|(
name|retval
operator|&
name|DM_RET_ACTION_MASK
operator|)
operator|==
name|DM_RET_NONE
condition|)
name|retval
operator||=
name|DM_RET_STOP
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Match a single peripheral against any number of match patterns.  */
end_comment

begin_function
specifier|static
name|dev_match_ret
name|xptperiphmatch
parameter_list|(
name|struct
name|dev_match_pattern
modifier|*
name|patterns
parameter_list|,
name|u_int
name|num_patterns
parameter_list|,
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|dev_match_ret
name|retval
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * If we aren't given something to match against, that's an error. 	 */
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
return|return
operator|(
name|DM_RET_ERROR
operator|)
return|;
comment|/* 	 * If there are no match entries, then this peripheral matches no 	 * matter what. 	 */
if|if
condition|(
operator|(
name|patterns
operator|==
name|NULL
operator|)
operator|||
operator|(
name|num_patterns
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|DM_RET_STOP
operator||
name|DM_RET_COPY
operator|)
return|;
comment|/* 	 * There aren't any nodes below a peripheral node, so there's no 	 * reason to descend the tree any further. 	 */
name|retval
operator|=
name|DM_RET_STOP
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_patterns
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|periph_match_pattern
modifier|*
name|cur_pattern
decl_stmt|;
comment|/* 		 * If the pattern in question isn't for a peripheral, we 		 * aren't interested. 		 */
if|if
condition|(
name|patterns
index|[
name|i
index|]
operator|.
name|type
operator|!=
name|DEV_MATCH_PERIPH
condition|)
continue|continue;
name|cur_pattern
operator|=
operator|&
name|patterns
index|[
name|i
index|]
operator|.
name|pattern
operator|.
name|periph_pattern
expr_stmt|;
comment|/* 		 * If they want to match on anything, then we will do so. 		 */
if|if
condition|(
name|cur_pattern
operator|->
name|flags
operator|==
name|PERIPH_MATCH_ANY
condition|)
block|{
comment|/* set the copy flag */
name|retval
operator||=
name|DM_RET_COPY
expr_stmt|;
comment|/* 			 * We've already set the return action to stop, 			 * since there are no nodes below peripherals in 			 * the tree. 			 */
return|return
operator|(
name|retval
operator|)
return|;
block|}
comment|/* 		 * Not sure why someone would do this... 		 */
if|if
condition|(
name|cur_pattern
operator|->
name|flags
operator|==
name|PERIPH_MATCH_NONE
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|cur_pattern
operator|->
name|flags
operator|&
name|PERIPH_MATCH_PATH
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|cur_pattern
operator|->
name|path_id
operator|!=
name|periph
operator|->
name|path
operator|->
name|bus
operator|->
name|path_id
operator|)
condition|)
continue|continue;
comment|/* 		 * For the target and lun id's, we have to make sure the 		 * target and lun pointers aren't NULL.  The xpt peripheral 		 * has a wildcard target and device. 		 */
if|if
condition|(
operator|(
operator|(
name|cur_pattern
operator|->
name|flags
operator|&
name|PERIPH_MATCH_TARGET
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|periph
operator|->
name|path
operator|->
name|target
operator|==
name|NULL
operator|)
operator|||
operator|(
name|cur_pattern
operator|->
name|target_id
operator|!=
name|periph
operator|->
name|path
operator|->
name|target
operator|->
name|target_id
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|cur_pattern
operator|->
name|flags
operator|&
name|PERIPH_MATCH_LUN
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|periph
operator|->
name|path
operator|->
name|device
operator|==
name|NULL
operator|)
operator|||
operator|(
name|cur_pattern
operator|->
name|target_lun
operator|!=
name|periph
operator|->
name|path
operator|->
name|device
operator|->
name|lun_id
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|cur_pattern
operator|->
name|flags
operator|&
name|PERIPH_MATCH_UNIT
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|cur_pattern
operator|->
name|unit_number
operator|!=
name|periph
operator|->
name|unit_number
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|cur_pattern
operator|->
name|flags
operator|&
name|PERIPH_MATCH_NAME
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|cur_pattern
operator|->
name|periph_name
argument_list|,
name|periph
operator|->
name|periph_name
argument_list|,
name|DEV_IDLEN
argument_list|)
operator|!=
literal|0
operator|)
condition|)
continue|continue;
comment|/* 		 * If we get to this point, the user definitely wants  		 * information on this peripheral.  So tell the caller to 		 * copy the data out. 		 */
name|retval
operator||=
name|DM_RET_COPY
expr_stmt|;
comment|/* 		 * The return action has already been set to stop, since 		 * peripherals don't have any nodes below them in the EDT. 		 */
return|return
operator|(
name|retval
operator|)
return|;
block|}
comment|/* 	 * If we get to this point, the peripheral that was passed in 	 * doesn't match any of the patterns. 	 */
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xptedtbusfunc
parameter_list|(
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ccb_dev_match
modifier|*
name|cdm
decl_stmt|;
name|dev_match_ret
name|retval
decl_stmt|;
name|cdm
operator|=
operator|(
expr|struct
name|ccb_dev_match
operator|*
operator|)
name|arg
expr_stmt|;
comment|/* 	 * If our position is for something deeper in the tree, that means 	 * that we've already seen this node.  So, we keep going down. 	 */
if|if
condition|(
operator|(
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|&
name|CAM_DEV_POS_BUS
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|bus
operator|==
name|bus
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|&
name|CAM_DEV_POS_TARGET
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|target
operator|!=
name|NULL
operator|)
condition|)
name|retval
operator|=
name|DM_RET_DESCEND
expr_stmt|;
else|else
name|retval
operator|=
name|xptbusmatch
argument_list|(
name|cdm
operator|->
name|patterns
argument_list|,
name|cdm
operator|->
name|num_patterns
argument_list|,
name|bus
argument_list|)
expr_stmt|;
comment|/* 	 * If we got an error, bail out of the search. 	 */
if|if
condition|(
operator|(
name|retval
operator|&
name|DM_RET_ACTION_MASK
operator|)
operator|==
name|DM_RET_ERROR
condition|)
block|{
name|cdm
operator|->
name|status
operator|=
name|CAM_DEV_MATCH_ERROR
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If the copy flag is set, copy this bus out. 	 */
if|if
condition|(
name|retval
operator|&
name|DM_RET_COPY
condition|)
block|{
name|int
name|spaceleft
decl_stmt|,
name|j
decl_stmt|;
name|spaceleft
operator|=
name|cdm
operator|->
name|match_buf_len
operator|-
operator|(
name|cdm
operator|->
name|num_matches
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dev_match_result
argument_list|)
operator|)
expr_stmt|;
comment|/* 		 * If we don't have enough space to put in another 		 * match result, save our position and tell the 		 * user there are more devices to check. 		 */
if|if
condition|(
name|spaceleft
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|dev_match_result
argument_list|)
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|cdm
operator|->
name|pos
argument_list|,
sizeof|sizeof
argument_list|(
name|cdm
operator|->
name|pos
argument_list|)
argument_list|)
expr_stmt|;
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|=
name|CAM_DEV_POS_EDT
operator||
name|CAM_DEV_POS_BUS
expr_stmt|;
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|bus
operator|=
name|bus
expr_stmt|;
name|cdm
operator|->
name|pos
operator|.
name|generations
index|[
name|CAM_BUS_GENERATION
index|]
operator|=
name|xsoftc
operator|.
name|bus_generation
expr_stmt|;
name|cdm
operator|->
name|status
operator|=
name|CAM_DEV_MATCH_MORE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|j
operator|=
name|cdm
operator|->
name|num_matches
expr_stmt|;
name|cdm
operator|->
name|num_matches
operator|++
expr_stmt|;
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|type
operator|=
name|DEV_MATCH_BUS
expr_stmt|;
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|result
operator|.
name|bus_result
operator|.
name|path_id
operator|=
name|bus
operator|->
name|path_id
expr_stmt|;
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|result
operator|.
name|bus_result
operator|.
name|bus_id
operator|=
name|bus
operator|->
name|sim
operator|->
name|bus_id
expr_stmt|;
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|result
operator|.
name|bus_result
operator|.
name|unit_number
operator|=
name|bus
operator|->
name|sim
operator|->
name|unit_number
expr_stmt|;
name|strncpy
argument_list|(
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|result
operator|.
name|bus_result
operator|.
name|dev_name
argument_list|,
name|bus
operator|->
name|sim
operator|->
name|sim_name
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the user is only interested in busses, there's no 	 * reason to descend to the next level in the tree. 	 */
if|if
condition|(
operator|(
name|retval
operator|&
name|DM_RET_ACTION_MASK
operator|)
operator|==
name|DM_RET_STOP
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * If there is a target generation recorded, check it to 	 * make sure the target list hasn't changed. 	 */
if|if
condition|(
operator|(
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|&
name|CAM_DEV_POS_BUS
operator|)
operator|&&
operator|(
name|bus
operator|==
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|bus
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|&
name|CAM_DEV_POS_TARGET
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|generations
index|[
name|CAM_TARGET_GENERATION
index|]
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|generations
index|[
name|CAM_TARGET_GENERATION
index|]
operator|!=
name|bus
operator|->
name|generation
operator|)
condition|)
block|{
name|cdm
operator|->
name|status
operator|=
name|CAM_DEV_MATCH_LIST_CHANGED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|&
name|CAM_DEV_POS_BUS
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|bus
operator|==
name|bus
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|&
name|CAM_DEV_POS_TARGET
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|target
operator|!=
name|NULL
operator|)
condition|)
return|return
operator|(
name|xpttargettraverse
argument_list|(
name|bus
argument_list|,
operator|(
expr|struct
name|cam_et
operator|*
operator|)
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|target
argument_list|,
name|xptedttargetfunc
argument_list|,
name|arg
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|xpttargettraverse
argument_list|(
name|bus
argument_list|,
name|NULL
argument_list|,
name|xptedttargetfunc
argument_list|,
name|arg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xptedttargetfunc
parameter_list|(
name|struct
name|cam_et
modifier|*
name|target
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ccb_dev_match
modifier|*
name|cdm
decl_stmt|;
name|cdm
operator|=
operator|(
expr|struct
name|ccb_dev_match
operator|*
operator|)
name|arg
expr_stmt|;
comment|/* 	 * If there is a device list generation recorded, check it to 	 * make sure the device list hasn't changed. 	 */
if|if
condition|(
operator|(
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|&
name|CAM_DEV_POS_BUS
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|bus
operator|==
name|target
operator|->
name|bus
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|&
name|CAM_DEV_POS_TARGET
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|target
operator|==
name|target
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|&
name|CAM_DEV_POS_DEVICE
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|generations
index|[
name|CAM_DEV_GENERATION
index|]
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|generations
index|[
name|CAM_DEV_GENERATION
index|]
operator|!=
name|target
operator|->
name|generation
operator|)
condition|)
block|{
name|cdm
operator|->
name|status
operator|=
name|CAM_DEV_MATCH_LIST_CHANGED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|&
name|CAM_DEV_POS_BUS
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|bus
operator|==
name|target
operator|->
name|bus
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|&
name|CAM_DEV_POS_TARGET
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|target
operator|==
name|target
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|&
name|CAM_DEV_POS_DEVICE
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|device
operator|!=
name|NULL
operator|)
condition|)
return|return
operator|(
name|xptdevicetraverse
argument_list|(
name|target
argument_list|,
operator|(
expr|struct
name|cam_ed
operator|*
operator|)
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|device
argument_list|,
name|xptedtdevicefunc
argument_list|,
name|arg
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|xptdevicetraverse
argument_list|(
name|target
argument_list|,
name|NULL
argument_list|,
name|xptedtdevicefunc
argument_list|,
name|arg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xptedtdevicefunc
parameter_list|(
name|struct
name|cam_ed
modifier|*
name|device
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ccb_dev_match
modifier|*
name|cdm
decl_stmt|;
name|dev_match_ret
name|retval
decl_stmt|;
name|cdm
operator|=
operator|(
expr|struct
name|ccb_dev_match
operator|*
operator|)
name|arg
expr_stmt|;
comment|/* 	 * If our position is for something deeper in the tree, that means 	 * that we've already seen this node.  So, we keep going down. 	 */
if|if
condition|(
operator|(
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|&
name|CAM_DEV_POS_DEVICE
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|device
operator|==
name|device
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|&
name|CAM_DEV_POS_PERIPH
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|periph
operator|!=
name|NULL
operator|)
condition|)
name|retval
operator|=
name|DM_RET_DESCEND
expr_stmt|;
else|else
name|retval
operator|=
name|xptdevicematch
argument_list|(
name|cdm
operator|->
name|patterns
argument_list|,
name|cdm
operator|->
name|num_patterns
argument_list|,
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|retval
operator|&
name|DM_RET_ACTION_MASK
operator|)
operator|==
name|DM_RET_ERROR
condition|)
block|{
name|cdm
operator|->
name|status
operator|=
name|CAM_DEV_MATCH_ERROR
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If the copy flag is set, copy this device out. 	 */
if|if
condition|(
name|retval
operator|&
name|DM_RET_COPY
condition|)
block|{
name|int
name|spaceleft
decl_stmt|,
name|j
decl_stmt|;
name|spaceleft
operator|=
name|cdm
operator|->
name|match_buf_len
operator|-
operator|(
name|cdm
operator|->
name|num_matches
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dev_match_result
argument_list|)
operator|)
expr_stmt|;
comment|/* 		 * If we don't have enough space to put in another 		 * match result, save our position and tell the 		 * user there are more devices to check. 		 */
if|if
condition|(
name|spaceleft
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|dev_match_result
argument_list|)
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|cdm
operator|->
name|pos
argument_list|,
sizeof|sizeof
argument_list|(
name|cdm
operator|->
name|pos
argument_list|)
argument_list|)
expr_stmt|;
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|=
name|CAM_DEV_POS_EDT
operator||
name|CAM_DEV_POS_BUS
operator||
name|CAM_DEV_POS_TARGET
operator||
name|CAM_DEV_POS_DEVICE
expr_stmt|;
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|bus
operator|=
name|device
operator|->
name|target
operator|->
name|bus
expr_stmt|;
name|cdm
operator|->
name|pos
operator|.
name|generations
index|[
name|CAM_BUS_GENERATION
index|]
operator|=
name|xsoftc
operator|.
name|bus_generation
expr_stmt|;
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|target
operator|=
name|device
operator|->
name|target
expr_stmt|;
name|cdm
operator|->
name|pos
operator|.
name|generations
index|[
name|CAM_TARGET_GENERATION
index|]
operator|=
name|device
operator|->
name|target
operator|->
name|bus
operator|->
name|generation
expr_stmt|;
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|device
operator|=
name|device
expr_stmt|;
name|cdm
operator|->
name|pos
operator|.
name|generations
index|[
name|CAM_DEV_GENERATION
index|]
operator|=
name|device
operator|->
name|target
operator|->
name|generation
expr_stmt|;
name|cdm
operator|->
name|status
operator|=
name|CAM_DEV_MATCH_MORE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|j
operator|=
name|cdm
operator|->
name|num_matches
expr_stmt|;
name|cdm
operator|->
name|num_matches
operator|++
expr_stmt|;
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|type
operator|=
name|DEV_MATCH_DEVICE
expr_stmt|;
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|result
operator|.
name|device_result
operator|.
name|path_id
operator|=
name|device
operator|->
name|target
operator|->
name|bus
operator|->
name|path_id
expr_stmt|;
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|result
operator|.
name|device_result
operator|.
name|target_id
operator|=
name|device
operator|->
name|target
operator|->
name|target_id
expr_stmt|;
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|result
operator|.
name|device_result
operator|.
name|target_lun
operator|=
name|device
operator|->
name|lun_id
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|device
operator|->
name|inq_data
argument_list|,
operator|&
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|result
operator|.
name|device_result
operator|.
name|inq_data
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_inquiry_data
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Let the user know whether this device is unconfigured */
if|if
condition|(
name|device
operator|->
name|flags
operator|&
name|CAM_DEV_UNCONFIGURED
condition|)
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|result
operator|.
name|device_result
operator|.
name|flags
operator|=
name|DEV_RESULT_UNCONFIGURED
expr_stmt|;
else|else
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|result
operator|.
name|device_result
operator|.
name|flags
operator|=
name|DEV_RESULT_NOFLAG
expr_stmt|;
block|}
comment|/* 	 * If the user isn't interested in peripherals, don't descend 	 * the tree any further. 	 */
if|if
condition|(
operator|(
name|retval
operator|&
name|DM_RET_ACTION_MASK
operator|)
operator|==
name|DM_RET_STOP
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * If there is a peripheral list generation recorded, make sure 	 * it hasn't changed. 	 */
if|if
condition|(
operator|(
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|&
name|CAM_DEV_POS_BUS
operator|)
operator|&&
operator|(
name|device
operator|->
name|target
operator|->
name|bus
operator|==
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|bus
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|&
name|CAM_DEV_POS_TARGET
operator|)
operator|&&
operator|(
name|device
operator|->
name|target
operator|==
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|target
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|&
name|CAM_DEV_POS_DEVICE
operator|)
operator|&&
operator|(
name|device
operator|==
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|device
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|&
name|CAM_DEV_POS_PERIPH
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|generations
index|[
name|CAM_PERIPH_GENERATION
index|]
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|generations
index|[
name|CAM_PERIPH_GENERATION
index|]
operator|!=
name|device
operator|->
name|generation
operator|)
condition|)
block|{
name|cdm
operator|->
name|status
operator|=
name|CAM_DEV_MATCH_LIST_CHANGED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|&
name|CAM_DEV_POS_BUS
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|bus
operator|==
name|device
operator|->
name|target
operator|->
name|bus
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|&
name|CAM_DEV_POS_TARGET
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|target
operator|==
name|device
operator|->
name|target
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|&
name|CAM_DEV_POS_DEVICE
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|device
operator|==
name|device
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|&
name|CAM_DEV_POS_PERIPH
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|periph
operator|!=
name|NULL
operator|)
condition|)
return|return
operator|(
name|xptperiphtraverse
argument_list|(
name|device
argument_list|,
operator|(
expr|struct
name|cam_periph
operator|*
operator|)
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|periph
argument_list|,
name|xptedtperiphfunc
argument_list|,
name|arg
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|xptperiphtraverse
argument_list|(
name|device
argument_list|,
name|NULL
argument_list|,
name|xptedtperiphfunc
argument_list|,
name|arg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xptedtperiphfunc
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ccb_dev_match
modifier|*
name|cdm
decl_stmt|;
name|dev_match_ret
name|retval
decl_stmt|;
name|cdm
operator|=
operator|(
expr|struct
name|ccb_dev_match
operator|*
operator|)
name|arg
expr_stmt|;
name|retval
operator|=
name|xptperiphmatch
argument_list|(
name|cdm
operator|->
name|patterns
argument_list|,
name|cdm
operator|->
name|num_patterns
argument_list|,
name|periph
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|retval
operator|&
name|DM_RET_ACTION_MASK
operator|)
operator|==
name|DM_RET_ERROR
condition|)
block|{
name|cdm
operator|->
name|status
operator|=
name|CAM_DEV_MATCH_ERROR
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If the copy flag is set, copy this peripheral out. 	 */
if|if
condition|(
name|retval
operator|&
name|DM_RET_COPY
condition|)
block|{
name|int
name|spaceleft
decl_stmt|,
name|j
decl_stmt|;
name|spaceleft
operator|=
name|cdm
operator|->
name|match_buf_len
operator|-
operator|(
name|cdm
operator|->
name|num_matches
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dev_match_result
argument_list|)
operator|)
expr_stmt|;
comment|/* 		 * If we don't have enough space to put in another 		 * match result, save our position and tell the 		 * user there are more devices to check. 		 */
if|if
condition|(
name|spaceleft
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|dev_match_result
argument_list|)
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|cdm
operator|->
name|pos
argument_list|,
sizeof|sizeof
argument_list|(
name|cdm
operator|->
name|pos
argument_list|)
argument_list|)
expr_stmt|;
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|=
name|CAM_DEV_POS_EDT
operator||
name|CAM_DEV_POS_BUS
operator||
name|CAM_DEV_POS_TARGET
operator||
name|CAM_DEV_POS_DEVICE
operator||
name|CAM_DEV_POS_PERIPH
expr_stmt|;
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|bus
operator|=
name|periph
operator|->
name|path
operator|->
name|bus
expr_stmt|;
name|cdm
operator|->
name|pos
operator|.
name|generations
index|[
name|CAM_BUS_GENERATION
index|]
operator|=
name|xsoftc
operator|.
name|bus_generation
expr_stmt|;
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|target
operator|=
name|periph
operator|->
name|path
operator|->
name|target
expr_stmt|;
name|cdm
operator|->
name|pos
operator|.
name|generations
index|[
name|CAM_TARGET_GENERATION
index|]
operator|=
name|periph
operator|->
name|path
operator|->
name|bus
operator|->
name|generation
expr_stmt|;
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|device
operator|=
name|periph
operator|->
name|path
operator|->
name|device
expr_stmt|;
name|cdm
operator|->
name|pos
operator|.
name|generations
index|[
name|CAM_DEV_GENERATION
index|]
operator|=
name|periph
operator|->
name|path
operator|->
name|target
operator|->
name|generation
expr_stmt|;
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|periph
operator|=
name|periph
expr_stmt|;
name|cdm
operator|->
name|pos
operator|.
name|generations
index|[
name|CAM_PERIPH_GENERATION
index|]
operator|=
name|periph
operator|->
name|path
operator|->
name|device
operator|->
name|generation
expr_stmt|;
name|cdm
operator|->
name|status
operator|=
name|CAM_DEV_MATCH_MORE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|j
operator|=
name|cdm
operator|->
name|num_matches
expr_stmt|;
name|cdm
operator|->
name|num_matches
operator|++
expr_stmt|;
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|type
operator|=
name|DEV_MATCH_PERIPH
expr_stmt|;
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|result
operator|.
name|periph_result
operator|.
name|path_id
operator|=
name|periph
operator|->
name|path
operator|->
name|bus
operator|->
name|path_id
expr_stmt|;
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|result
operator|.
name|periph_result
operator|.
name|target_id
operator|=
name|periph
operator|->
name|path
operator|->
name|target
operator|->
name|target_id
expr_stmt|;
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|result
operator|.
name|periph_result
operator|.
name|target_lun
operator|=
name|periph
operator|->
name|path
operator|->
name|device
operator|->
name|lun_id
expr_stmt|;
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|result
operator|.
name|periph_result
operator|.
name|unit_number
operator|=
name|periph
operator|->
name|unit_number
expr_stmt|;
name|strncpy
argument_list|(
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|result
operator|.
name|periph_result
operator|.
name|periph_name
argument_list|,
name|periph
operator|->
name|periph_name
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xptedtmatch
parameter_list|(
name|struct
name|ccb_dev_match
modifier|*
name|cdm
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|cdm
operator|->
name|num_matches
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Check the bus list generation.  If it has changed, the user 	 * needs to reset everything and start over. 	 */
if|if
condition|(
operator|(
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|&
name|CAM_DEV_POS_BUS
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|generations
index|[
name|CAM_BUS_GENERATION
index|]
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|generations
index|[
name|CAM_BUS_GENERATION
index|]
operator|!=
name|xsoftc
operator|.
name|bus_generation
operator|)
condition|)
block|{
name|cdm
operator|->
name|status
operator|=
name|CAM_DEV_MATCH_LIST_CHANGED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|&
name|CAM_DEV_POS_BUS
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|bus
operator|!=
name|NULL
operator|)
condition|)
name|ret
operator|=
name|xptbustraverse
argument_list|(
operator|(
expr|struct
name|cam_eb
operator|*
operator|)
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|bus
argument_list|,
name|xptedtbusfunc
argument_list|,
name|cdm
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|xptbustraverse
argument_list|(
name|NULL
argument_list|,
name|xptedtbusfunc
argument_list|,
name|cdm
argument_list|)
expr_stmt|;
comment|/* 	 * If we get back 0, that means that we had to stop before fully 	 * traversing the EDT.  It also means that one of the subroutines 	 * has set the status field to the proper value.  If we get back 1, 	 * we've fully traversed the EDT and copied out any matching entries. 	 */
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
name|cdm
operator|->
name|status
operator|=
name|CAM_DEV_MATCH_LAST
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xptplistpdrvfunc
parameter_list|(
name|struct
name|periph_driver
modifier|*
modifier|*
name|pdrv
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ccb_dev_match
modifier|*
name|cdm
decl_stmt|;
name|cdm
operator|=
operator|(
expr|struct
name|ccb_dev_match
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
operator|(
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|&
name|CAM_DEV_POS_PDPTR
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|pdrv
operator|==
name|pdrv
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|&
name|CAM_DEV_POS_PERIPH
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|generations
index|[
name|CAM_PERIPH_GENERATION
index|]
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|generations
index|[
name|CAM_PERIPH_GENERATION
index|]
operator|!=
operator|(
operator|*
name|pdrv
operator|)
operator|->
name|generation
operator|)
condition|)
block|{
name|cdm
operator|->
name|status
operator|=
name|CAM_DEV_MATCH_LIST_CHANGED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|&
name|CAM_DEV_POS_PDPTR
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|pdrv
operator|==
name|pdrv
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|&
name|CAM_DEV_POS_PERIPH
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|periph
operator|!=
name|NULL
operator|)
condition|)
return|return
operator|(
name|xptpdperiphtraverse
argument_list|(
name|pdrv
argument_list|,
operator|(
expr|struct
name|cam_periph
operator|*
operator|)
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|periph
argument_list|,
name|xptplistperiphfunc
argument_list|,
name|arg
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|xptpdperiphtraverse
argument_list|(
name|pdrv
argument_list|,
name|NULL
argument_list|,
name|xptplistperiphfunc
argument_list|,
name|arg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xptplistperiphfunc
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ccb_dev_match
modifier|*
name|cdm
decl_stmt|;
name|dev_match_ret
name|retval
decl_stmt|;
name|cdm
operator|=
operator|(
expr|struct
name|ccb_dev_match
operator|*
operator|)
name|arg
expr_stmt|;
name|retval
operator|=
name|xptperiphmatch
argument_list|(
name|cdm
operator|->
name|patterns
argument_list|,
name|cdm
operator|->
name|num_patterns
argument_list|,
name|periph
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|retval
operator|&
name|DM_RET_ACTION_MASK
operator|)
operator|==
name|DM_RET_ERROR
condition|)
block|{
name|cdm
operator|->
name|status
operator|=
name|CAM_DEV_MATCH_ERROR
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If the copy flag is set, copy this peripheral out. 	 */
if|if
condition|(
name|retval
operator|&
name|DM_RET_COPY
condition|)
block|{
name|int
name|spaceleft
decl_stmt|,
name|j
decl_stmt|;
name|spaceleft
operator|=
name|cdm
operator|->
name|match_buf_len
operator|-
operator|(
name|cdm
operator|->
name|num_matches
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dev_match_result
argument_list|)
operator|)
expr_stmt|;
comment|/* 		 * If we don't have enough space to put in another 		 * match result, save our position and tell the 		 * user there are more devices to check. 		 */
if|if
condition|(
name|spaceleft
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|dev_match_result
argument_list|)
condition|)
block|{
name|struct
name|periph_driver
modifier|*
modifier|*
name|pdrv
decl_stmt|;
name|pdrv
operator|=
name|NULL
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|cdm
operator|->
name|pos
argument_list|,
sizeof|sizeof
argument_list|(
name|cdm
operator|->
name|pos
argument_list|)
argument_list|)
expr_stmt|;
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|=
name|CAM_DEV_POS_PDRV
operator||
name|CAM_DEV_POS_PDPTR
operator||
name|CAM_DEV_POS_PERIPH
expr_stmt|;
comment|/* 			 * This may look a bit non-sensical, but it is 			 * actually quite logical.  There are very few 			 * peripheral drivers, and bloating every peripheral 			 * structure with a pointer back to its parent 			 * peripheral driver linker set entry would cost 			 * more in the long run than doing this quick lookup. 			 */
for|for
control|(
name|pdrv
operator|=
name|periph_drivers
init|;
operator|*
name|pdrv
operator|!=
name|NULL
condition|;
name|pdrv
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|(
operator|*
name|pdrv
operator|)
operator|->
name|driver_name
argument_list|,
name|periph
operator|->
name|periph_name
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
operator|*
name|pdrv
operator|==
name|NULL
condition|)
block|{
name|cdm
operator|->
name|status
operator|=
name|CAM_DEV_MATCH_ERROR
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|pdrv
operator|=
name|pdrv
expr_stmt|;
comment|/* 			 * The periph generation slot does double duty, as 			 * does the periph pointer slot.  They are used for 			 * both edt and pdrv lookups and positioning. 			 */
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|periph
operator|=
name|periph
expr_stmt|;
name|cdm
operator|->
name|pos
operator|.
name|generations
index|[
name|CAM_PERIPH_GENERATION
index|]
operator|=
operator|(
operator|*
name|pdrv
operator|)
operator|->
name|generation
expr_stmt|;
name|cdm
operator|->
name|status
operator|=
name|CAM_DEV_MATCH_MORE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|j
operator|=
name|cdm
operator|->
name|num_matches
expr_stmt|;
name|cdm
operator|->
name|num_matches
operator|++
expr_stmt|;
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|type
operator|=
name|DEV_MATCH_PERIPH
expr_stmt|;
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|result
operator|.
name|periph_result
operator|.
name|path_id
operator|=
name|periph
operator|->
name|path
operator|->
name|bus
operator|->
name|path_id
expr_stmt|;
comment|/* 		 * The transport layer peripheral doesn't have a target or 		 * lun. 		 */
if|if
condition|(
name|periph
operator|->
name|path
operator|->
name|target
condition|)
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|result
operator|.
name|periph_result
operator|.
name|target_id
operator|=
name|periph
operator|->
name|path
operator|->
name|target
operator|->
name|target_id
expr_stmt|;
else|else
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|result
operator|.
name|periph_result
operator|.
name|target_id
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|periph
operator|->
name|path
operator|->
name|device
condition|)
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|result
operator|.
name|periph_result
operator|.
name|target_lun
operator|=
name|periph
operator|->
name|path
operator|->
name|device
operator|->
name|lun_id
expr_stmt|;
else|else
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|result
operator|.
name|periph_result
operator|.
name|target_lun
operator|=
operator|-
literal|1
expr_stmt|;
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|result
operator|.
name|periph_result
operator|.
name|unit_number
operator|=
name|periph
operator|->
name|unit_number
expr_stmt|;
name|strncpy
argument_list|(
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|result
operator|.
name|periph_result
operator|.
name|periph_name
argument_list|,
name|periph
operator|->
name|periph_name
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xptperiphlistmatch
parameter_list|(
name|struct
name|ccb_dev_match
modifier|*
name|cdm
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|cdm
operator|->
name|num_matches
operator|=
literal|0
expr_stmt|;
comment|/* 	 * At this point in the edt traversal function, we check the bus 	 * list generation to make sure that no busses have been added or 	 * removed since the user last sent a XPT_DEV_MATCH ccb through. 	 * For the peripheral driver list traversal function, however, we 	 * don't have to worry about new peripheral driver types coming or 	 * going; they're in a linker set, and therefore can't change 	 * without a recompile. 	 */
if|if
condition|(
operator|(
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|&
name|CAM_DEV_POS_PDPTR
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|pdrv
operator|!=
name|NULL
operator|)
condition|)
name|ret
operator|=
name|xptpdrvtraverse
argument_list|(
operator|(
expr|struct
name|periph_driver
operator|*
operator|*
operator|)
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|pdrv
argument_list|,
name|xptplistpdrvfunc
argument_list|,
name|cdm
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|xptpdrvtraverse
argument_list|(
name|NULL
argument_list|,
name|xptplistpdrvfunc
argument_list|,
name|cdm
argument_list|)
expr_stmt|;
comment|/* 	 * If we get back 0, that means that we had to stop before fully 	 * traversing the peripheral driver tree.  It also means that one of 	 * the subroutines has set the status field to the proper value.  If 	 * we get back 1, we've fully traversed the EDT and copied out any 	 * matching entries. 	 */
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
name|cdm
operator|->
name|status
operator|=
name|CAM_DEV_MATCH_LAST
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xptbustraverse
parameter_list|(
name|struct
name|cam_eb
modifier|*
name|start_bus
parameter_list|,
name|xpt_busfunc_t
modifier|*
name|tr_func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cam_eb
modifier|*
name|bus
decl_stmt|,
modifier|*
name|next_bus
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_topo_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|bus
operator|=
operator|(
name|start_bus
condition|?
name|start_bus
else|:
name|TAILQ_FIRST
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_busses
argument_list|)
operator|)
init|;
name|bus
operator|!=
name|NULL
condition|;
name|bus
operator|=
name|next_bus
control|)
block|{
name|next_bus
operator|=
name|TAILQ_NEXT
argument_list|(
name|bus
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_topo_lock
argument_list|)
expr_stmt|;
name|CAM_SIM_LOCK
argument_list|(
name|bus
operator|->
name|sim
argument_list|)
expr_stmt|;
name|retval
operator|=
name|tr_func
argument_list|(
name|bus
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|CAM_SIM_UNLOCK
argument_list|(
name|bus
operator|->
name|sim
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
return|return
operator|(
name|retval
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_topo_lock
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_topo_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xpttargettraverse
parameter_list|(
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|,
name|struct
name|cam_et
modifier|*
name|start_target
parameter_list|,
name|xpt_targetfunc_t
modifier|*
name|tr_func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cam_et
modifier|*
name|target
decl_stmt|,
modifier|*
name|next_target
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|target
operator|=
operator|(
name|start_target
condition|?
name|start_target
else|:
name|TAILQ_FIRST
argument_list|(
operator|&
name|bus
operator|->
name|et_entries
argument_list|)
operator|)
init|;
name|target
operator|!=
name|NULL
condition|;
name|target
operator|=
name|next_target
control|)
block|{
name|next_target
operator|=
name|TAILQ_NEXT
argument_list|(
name|target
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|retval
operator|=
name|tr_func
argument_list|(
name|target
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
return|return
operator|(
name|retval
operator|)
return|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xptdevicetraverse
parameter_list|(
name|struct
name|cam_et
modifier|*
name|target
parameter_list|,
name|struct
name|cam_ed
modifier|*
name|start_device
parameter_list|,
name|xpt_devicefunc_t
modifier|*
name|tr_func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cam_ed
modifier|*
name|device
decl_stmt|,
modifier|*
name|next_device
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|device
operator|=
operator|(
name|start_device
condition|?
name|start_device
else|:
name|TAILQ_FIRST
argument_list|(
operator|&
name|target
operator|->
name|ed_entries
argument_list|)
operator|)
init|;
name|device
operator|!=
name|NULL
condition|;
name|device
operator|=
name|next_device
control|)
block|{
name|next_device
operator|=
name|TAILQ_NEXT
argument_list|(
name|device
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|retval
operator|=
name|tr_func
argument_list|(
name|device
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
return|return
operator|(
name|retval
operator|)
return|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xptperiphtraverse
parameter_list|(
name|struct
name|cam_ed
modifier|*
name|device
parameter_list|,
name|struct
name|cam_periph
modifier|*
name|start_periph
parameter_list|,
name|xpt_periphfunc_t
modifier|*
name|tr_func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|,
modifier|*
name|next_periph
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|periph
operator|=
operator|(
name|start_periph
condition|?
name|start_periph
else|:
name|SLIST_FIRST
argument_list|(
operator|&
name|device
operator|->
name|periphs
argument_list|)
operator|)
init|;
name|periph
operator|!=
name|NULL
condition|;
name|periph
operator|=
name|next_periph
control|)
block|{
name|next_periph
operator|=
name|SLIST_NEXT
argument_list|(
name|periph
argument_list|,
name|periph_links
argument_list|)
expr_stmt|;
name|retval
operator|=
name|tr_func
argument_list|(
name|periph
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
return|return
operator|(
name|retval
operator|)
return|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xptpdrvtraverse
parameter_list|(
name|struct
name|periph_driver
modifier|*
modifier|*
name|start_pdrv
parameter_list|,
name|xpt_pdrvfunc_t
modifier|*
name|tr_func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|periph_driver
modifier|*
modifier|*
name|pdrv
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
comment|/* 	 * We don't traverse the peripheral driver list like we do the 	 * other lists, because it is a linker set, and therefore cannot be 	 * changed during runtime.  If the peripheral driver list is ever 	 * re-done to be something other than a linker set (i.e. it can 	 * change while the system is running), the list traversal should 	 * be modified to work like the other traversal functions. 	 */
for|for
control|(
name|pdrv
operator|=
operator|(
name|start_pdrv
condition|?
name|start_pdrv
else|:
name|periph_drivers
operator|)
init|;
operator|*
name|pdrv
operator|!=
name|NULL
condition|;
name|pdrv
operator|++
control|)
block|{
name|retval
operator|=
name|tr_func
argument_list|(
name|pdrv
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
return|return
operator|(
name|retval
operator|)
return|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xptpdperiphtraverse
parameter_list|(
name|struct
name|periph_driver
modifier|*
modifier|*
name|pdrv
parameter_list|,
name|struct
name|cam_periph
modifier|*
name|start_periph
parameter_list|,
name|xpt_periphfunc_t
modifier|*
name|tr_func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|,
modifier|*
name|next_periph
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|periph
operator|=
operator|(
name|start_periph
condition|?
name|start_periph
else|:
name|TAILQ_FIRST
argument_list|(
operator|&
operator|(
operator|*
name|pdrv
operator|)
operator|->
name|units
argument_list|)
operator|)
init|;
name|periph
operator|!=
name|NULL
condition|;
name|periph
operator|=
name|next_periph
control|)
block|{
name|next_periph
operator|=
name|TAILQ_NEXT
argument_list|(
name|periph
argument_list|,
name|unit_links
argument_list|)
expr_stmt|;
name|retval
operator|=
name|tr_func
argument_list|(
name|periph
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
return|return
operator|(
name|retval
operator|)
return|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xptdefbusfunc
parameter_list|(
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|xpt_traverse_config
modifier|*
name|tr_config
decl_stmt|;
name|tr_config
operator|=
operator|(
expr|struct
name|xpt_traverse_config
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|tr_config
operator|->
name|depth
operator|==
name|XPT_DEPTH_BUS
condition|)
block|{
name|xpt_busfunc_t
modifier|*
name|tr_func
decl_stmt|;
name|tr_func
operator|=
operator|(
name|xpt_busfunc_t
operator|*
operator|)
name|tr_config
operator|->
name|tr_func
expr_stmt|;
return|return
operator|(
name|tr_func
argument_list|(
name|bus
argument_list|,
name|tr_config
operator|->
name|tr_arg
argument_list|)
operator|)
return|;
block|}
else|else
return|return
operator|(
name|xpttargettraverse
argument_list|(
name|bus
argument_list|,
name|NULL
argument_list|,
name|xptdeftargetfunc
argument_list|,
name|arg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xptdeftargetfunc
parameter_list|(
name|struct
name|cam_et
modifier|*
name|target
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|xpt_traverse_config
modifier|*
name|tr_config
decl_stmt|;
name|tr_config
operator|=
operator|(
expr|struct
name|xpt_traverse_config
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|tr_config
operator|->
name|depth
operator|==
name|XPT_DEPTH_TARGET
condition|)
block|{
name|xpt_targetfunc_t
modifier|*
name|tr_func
decl_stmt|;
name|tr_func
operator|=
operator|(
name|xpt_targetfunc_t
operator|*
operator|)
name|tr_config
operator|->
name|tr_func
expr_stmt|;
return|return
operator|(
name|tr_func
argument_list|(
name|target
argument_list|,
name|tr_config
operator|->
name|tr_arg
argument_list|)
operator|)
return|;
block|}
else|else
return|return
operator|(
name|xptdevicetraverse
argument_list|(
name|target
argument_list|,
name|NULL
argument_list|,
name|xptdefdevicefunc
argument_list|,
name|arg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xptdefdevicefunc
parameter_list|(
name|struct
name|cam_ed
modifier|*
name|device
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|xpt_traverse_config
modifier|*
name|tr_config
decl_stmt|;
name|tr_config
operator|=
operator|(
expr|struct
name|xpt_traverse_config
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|tr_config
operator|->
name|depth
operator|==
name|XPT_DEPTH_DEVICE
condition|)
block|{
name|xpt_devicefunc_t
modifier|*
name|tr_func
decl_stmt|;
name|tr_func
operator|=
operator|(
name|xpt_devicefunc_t
operator|*
operator|)
name|tr_config
operator|->
name|tr_func
expr_stmt|;
return|return
operator|(
name|tr_func
argument_list|(
name|device
argument_list|,
name|tr_config
operator|->
name|tr_arg
argument_list|)
operator|)
return|;
block|}
else|else
return|return
operator|(
name|xptperiphtraverse
argument_list|(
name|device
argument_list|,
name|NULL
argument_list|,
name|xptdefperiphfunc
argument_list|,
name|arg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xptdefperiphfunc
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|xpt_traverse_config
modifier|*
name|tr_config
decl_stmt|;
name|xpt_periphfunc_t
modifier|*
name|tr_func
decl_stmt|;
name|tr_config
operator|=
operator|(
expr|struct
name|xpt_traverse_config
operator|*
operator|)
name|arg
expr_stmt|;
name|tr_func
operator|=
operator|(
name|xpt_periphfunc_t
operator|*
operator|)
name|tr_config
operator|->
name|tr_func
expr_stmt|;
comment|/* 	 * Unlike the other default functions, we don't check for depth 	 * here.  The peripheral driver level is the last level in the EDT, 	 * so if we're here, we should execute the function in question. 	 */
return|return
operator|(
name|tr_func
argument_list|(
name|periph
argument_list|,
name|tr_config
operator|->
name|tr_arg
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Execute the given function for every bus in the EDT.  */
end_comment

begin_function
specifier|static
name|int
name|xpt_for_all_busses
parameter_list|(
name|xpt_busfunc_t
modifier|*
name|tr_func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|xpt_traverse_config
name|tr_config
decl_stmt|;
name|tr_config
operator|.
name|depth
operator|=
name|XPT_DEPTH_BUS
expr_stmt|;
name|tr_config
operator|.
name|tr_func
operator|=
name|tr_func
expr_stmt|;
name|tr_config
operator|.
name|tr_arg
operator|=
name|arg
expr_stmt|;
return|return
operator|(
name|xptbustraverse
argument_list|(
name|NULL
argument_list|,
name|xptdefbusfunc
argument_list|,
operator|&
name|tr_config
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Execute the given function for every device in the EDT.  */
end_comment

begin_function
specifier|static
name|int
name|xpt_for_all_devices
parameter_list|(
name|xpt_devicefunc_t
modifier|*
name|tr_func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|xpt_traverse_config
name|tr_config
decl_stmt|;
name|tr_config
operator|.
name|depth
operator|=
name|XPT_DEPTH_DEVICE
expr_stmt|;
name|tr_config
operator|.
name|tr_func
operator|=
name|tr_func
expr_stmt|;
name|tr_config
operator|.
name|tr_arg
operator|=
name|arg
expr_stmt|;
return|return
operator|(
name|xptbustraverse
argument_list|(
name|NULL
argument_list|,
name|xptdefbusfunc
argument_list|,
operator|&
name|tr_config
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xptsetasyncfunc
parameter_list|(
name|struct
name|cam_ed
modifier|*
name|device
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cam_path
name|path
decl_stmt|;
name|struct
name|ccb_getdev
name|cgd
decl_stmt|;
name|struct
name|async_node
modifier|*
name|cur_entry
decl_stmt|;
name|cur_entry
operator|=
operator|(
expr|struct
name|async_node
operator|*
operator|)
name|arg
expr_stmt|;
comment|/* 	 * Don't report unconfigured devices (Wildcard devs, 	 * devices only for target mode, device instances 	 * that have been invalidated but are waiting for 	 * their last reference count to be released). 	 */
if|if
condition|(
operator|(
name|device
operator|->
name|flags
operator|&
name|CAM_DEV_UNCONFIGURED
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|xpt_compile_path
argument_list|(
operator|&
name|path
argument_list|,
name|NULL
argument_list|,
name|device
operator|->
name|target
operator|->
name|bus
operator|->
name|path_id
argument_list|,
name|device
operator|->
name|target
operator|->
name|target_id
argument_list|,
name|device
operator|->
name|lun_id
argument_list|)
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|cgd
operator|.
name|ccb_h
argument_list|,
operator|&
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|cgd
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_GDEV_TYPE
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|cgd
argument_list|)
expr_stmt|;
name|cur_entry
operator|->
name|callback
argument_list|(
name|cur_entry
operator|->
name|callback_arg
argument_list|,
name|AC_FOUND_DEVICE
argument_list|,
operator|&
name|path
argument_list|,
operator|&
name|cgd
argument_list|)
expr_stmt|;
name|xpt_release_path
argument_list|(
operator|&
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xptsetasyncbusfunc
parameter_list|(
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cam_path
name|path
decl_stmt|;
name|struct
name|ccb_pathinq
name|cpi
decl_stmt|;
name|struct
name|async_node
modifier|*
name|cur_entry
decl_stmt|;
name|cur_entry
operator|=
operator|(
expr|struct
name|async_node
operator|*
operator|)
name|arg
expr_stmt|;
name|xpt_compile_path
argument_list|(
operator|&
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|bus
operator|->
name|sim
operator|->
name|path_id
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|cpi
operator|.
name|ccb_h
argument_list|,
operator|&
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|cpi
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_PATH_INQ
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|cpi
argument_list|)
expr_stmt|;
name|cur_entry
operator|->
name|callback
argument_list|(
name|cur_entry
operator|->
name|callback_arg
argument_list|,
name|AC_PATH_REGISTERED
argument_list|,
operator|&
name|path
argument_list|,
operator|&
name|cpi
argument_list|)
expr_stmt|;
name|xpt_release_path
argument_list|(
operator|&
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xpt_action_sasync_cb
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|async_node
modifier|*
name|cur_entry
decl_stmt|;
name|struct
name|xpt_task
modifier|*
name|task
decl_stmt|;
name|uint32_t
name|added
decl_stmt|;
name|task
operator|=
operator|(
expr|struct
name|xpt_task
operator|*
operator|)
name|context
expr_stmt|;
name|cur_entry
operator|=
operator|(
expr|struct
name|async_node
operator|*
operator|)
name|task
operator|->
name|data1
expr_stmt|;
name|added
operator|=
name|task
operator|->
name|data2
expr_stmt|;
if|if
condition|(
operator|(
name|added
operator|&
name|AC_FOUND_DEVICE
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Get this peripheral up to date with all 		 * the currently existing devices. 		 */
name|xpt_for_all_devices
argument_list|(
name|xptsetasyncfunc
argument_list|,
name|cur_entry
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|added
operator|&
name|AC_PATH_REGISTERED
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Get this peripheral up to date with all 		 * the currently existing busses. 		 */
name|xpt_for_all_busses
argument_list|(
name|xptsetasyncbusfunc
argument_list|,
name|cur_entry
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|task
argument_list|,
name|M_CAMXPT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xpt_action
parameter_list|(
name|union
name|ccb
modifier|*
name|start_ccb
parameter_list|)
block|{
name|CAM_DEBUG
argument_list|(
name|start_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"xpt_action\n"
operator|)
argument_list|)
expr_stmt|;
name|start_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INPROG
expr_stmt|;
switch|switch
condition|(
name|start_ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_SCSI_IO
case|:
block|{
name|struct
name|cam_ed
modifier|*
name|device
decl_stmt|;
ifdef|#
directive|ifdef
name|CAMDEBUG
name|char
name|cdb_str
index|[
operator|(
name|SCSI_MAX_CDBLEN
operator|*
literal|3
operator|)
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|path
operator|=
name|start_ccb
operator|->
name|ccb_h
operator|.
name|path
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * For the sake of compatibility with SCSI-1 		 * devices that may not understand the identify 		 * message, we include lun information in the 		 * second byte of all commands.  SCSI-1 specifies 		 * that luns are a 3 bit value and reserves only 3 		 * bits for lun information in the CDB.  Later 		 * revisions of the SCSI spec allow for more than 8 		 * luns, but have deprecated lun information in the 		 * CDB.  So, if the lun won't fit, we must omit. 		 * 		 * Also be aware that during initial probing for devices, 		 * the inquiry information is unknown but initialized to 0. 		 * This means that this code will be exercised while probing 		 * devices with an ANSI revision greater than 2. 		 */
name|device
operator|=
name|start_ccb
operator|->
name|ccb_h
operator|.
name|path
operator|->
name|device
expr_stmt|;
if|if
condition|(
name|device
operator|->
name|protocol_version
operator|<=
name|SCSI_REV_2
operator|&&
name|start_ccb
operator|->
name|ccb_h
operator|.
name|target_lun
operator|<
literal|8
operator|&&
operator|(
name|start_ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_POINTER
operator|)
operator|==
literal|0
condition|)
block|{
name|start_ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|1
index|]
operator||=
name|start_ccb
operator|->
name|ccb_h
operator|.
name|target_lun
operator|<<
literal|5
expr_stmt|;
block|}
name|start_ccb
operator|->
name|csio
operator|.
name|scsi_status
operator|=
name|SCSI_STATUS_OK
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|path
argument_list|,
name|CAM_DEBUG_CDB
argument_list|,
operator|(
literal|"%s. CDB: %s\n"
operator|,
name|scsi_op_desc
argument_list|(
name|start_ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
argument_list|,
operator|&
name|path
operator|->
name|device
operator|->
name|inq_data
argument_list|)
operator|,
name|scsi_cdb_string
argument_list|(
name|start_ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|cdb_str
argument_list|,
sizeof|sizeof
argument_list|(
name|cdb_str
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* FALLTHROUGH */
case|case
name|XPT_TARGET_IO
case|:
case|case
name|XPT_CONT_TARGET_IO
case|:
name|start_ccb
operator|->
name|csio
operator|.
name|sense_resid
operator|=
literal|0
expr_stmt|;
name|start_ccb
operator|->
name|csio
operator|.
name|resid
operator|=
literal|0
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|XPT_RESET_DEV
case|:
case|case
name|XPT_ENG_EXEC
case|:
block|{
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|int
name|runq
decl_stmt|;
name|path
operator|=
name|start_ccb
operator|->
name|ccb_h
operator|.
name|path
expr_stmt|;
name|sim
operator|=
name|path
operator|->
name|bus
operator|->
name|sim
expr_stmt|;
if|if
condition|(
name|SIM_DEAD
argument_list|(
name|sim
argument_list|)
condition|)
block|{
comment|/* The SIM has gone; just execute the CCB directly. */
name|cam_ccbq_send_ccb
argument_list|(
operator|&
name|path
operator|->
name|device
operator|->
name|ccbq
argument_list|,
name|start_ccb
argument_list|)
expr_stmt|;
operator|(
operator|*
operator|(
name|sim
operator|->
name|sim_action
operator|)
operator|)
operator|(
name|sim
operator|,
name|start_ccb
operator|)
expr_stmt|;
break|break;
block|}
name|cam_ccbq_insert_ccb
argument_list|(
operator|&
name|path
operator|->
name|device
operator|->
name|ccbq
argument_list|,
name|start_ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|->
name|device
operator|->
name|qfrozen_cnt
operator|==
literal|0
condition|)
name|runq
operator|=
name|xpt_schedule_dev_sendq
argument_list|(
name|path
operator|->
name|bus
argument_list|,
name|path
operator|->
name|device
argument_list|)
expr_stmt|;
else|else
name|runq
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|runq
operator|!=
literal|0
condition|)
name|xpt_run_dev_sendq
argument_list|(
name|path
operator|->
name|bus
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_SET_TRAN_SETTINGS
case|:
block|{
name|xpt_set_transfer_settings
argument_list|(
operator|&
name|start_ccb
operator|->
name|cts
argument_list|,
name|start_ccb
operator|->
name|ccb_h
operator|.
name|path
operator|->
name|device
argument_list|,
comment|/*async_update*/
name|FALSE
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_CALC_GEOMETRY
case|:
block|{
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
comment|/* Filter out garbage */
if|if
condition|(
name|start_ccb
operator|->
name|ccg
operator|.
name|block_size
operator|==
literal|0
operator|||
name|start_ccb
operator|->
name|ccg
operator|.
name|volume_size
operator|==
literal|0
condition|)
block|{
name|start_ccb
operator|->
name|ccg
operator|.
name|cylinders
operator|=
literal|0
expr_stmt|;
name|start_ccb
operator|->
name|ccg
operator|.
name|heads
operator|=
literal|0
expr_stmt|;
name|start_ccb
operator|->
name|ccg
operator|.
name|secs_per_track
operator|=
literal|0
expr_stmt|;
name|start_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|PC98
comment|/* 		 * In a PC-98 system, geometry translation depens on 		 * the "real" device geometry obtained from mode page 4. 		 * SCSI geometry translation is performed in the 		 * initialization routine of the SCSI BIOS and the result 		 * stored in host memory.  If the translation is available 		 * in host memory, use it.  If not, rely on the default 		 * translation the device driver performs. 		 */
if|if
condition|(
name|scsi_da_bios_params
argument_list|(
operator|&
name|start_ccb
operator|->
name|ccg
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|start_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
name|sim
operator|=
name|start_ccb
operator|->
name|ccb_h
operator|.
name|path
operator|->
name|bus
operator|->
name|sim
expr_stmt|;
operator|(
operator|*
operator|(
name|sim
operator|->
name|sim_action
operator|)
operator|)
operator|(
name|sim
operator|,
name|start_ccb
operator|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_ABORT
case|:
block|{
name|union
name|ccb
modifier|*
name|abort_ccb
decl_stmt|;
name|abort_ccb
operator|=
name|start_ccb
operator|->
name|cab
operator|.
name|abort_ccb
expr_stmt|;
if|if
condition|(
name|XPT_FC_IS_DEV_QUEUED
argument_list|(
name|abort_ccb
argument_list|)
condition|)
block|{
if|if
condition|(
name|abort_ccb
operator|->
name|ccb_h
operator|.
name|pinfo
operator|.
name|index
operator|>=
literal|0
condition|)
block|{
name|struct
name|cam_ccbq
modifier|*
name|ccbq
decl_stmt|;
name|ccbq
operator|=
operator|&
name|abort_ccb
operator|->
name|ccb_h
operator|.
name|path
operator|->
name|device
operator|->
name|ccbq
expr_stmt|;
name|cam_ccbq_remove_ccb
argument_list|(
name|ccbq
argument_list|,
name|abort_ccb
argument_list|)
expr_stmt|;
name|abort_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_ABORTED
operator||
name|CAM_DEV_QFRZN
expr_stmt|;
name|xpt_freeze_devq
argument_list|(
name|abort_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|abort_ccb
argument_list|)
expr_stmt|;
name|start_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|abort_ccb
operator|->
name|ccb_h
operator|.
name|pinfo
operator|.
name|index
operator|==
name|CAM_UNQUEUED_INDEX
operator|&&
operator|(
name|abort_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_SIM_QUEUED
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * We've caught this ccb en route to 				 * the SIM.  Flag it for abort and the 				 * SIM will do so just before starting 				 * real work on the CCB. 				 */
name|abort_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_ABORTED
operator||
name|CAM_DEV_QFRZN
expr_stmt|;
name|xpt_freeze_devq
argument_list|(
name|abort_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|start_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|XPT_FC_IS_QUEUED
argument_list|(
name|abort_ccb
argument_list|)
operator|&&
operator|(
name|abort_ccb
operator|->
name|ccb_h
operator|.
name|pinfo
operator|.
name|index
operator|==
name|CAM_DONEQ_INDEX
operator|)
condition|)
block|{
comment|/* 			 * It's already completed but waiting 			 * for our SWI to get to it. 			 */
name|start_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_UA_ABORT
expr_stmt|;
break|break;
block|}
comment|/* 		 * If we weren't able to take care of the abort request 		 * in the XPT, pass the request down to the SIM for processing. 		 */
block|}
comment|/* FALLTHROUGH */
case|case
name|XPT_ACCEPT_TARGET_IO
case|:
case|case
name|XPT_EN_LUN
case|:
case|case
name|XPT_IMMED_NOTIFY
case|:
case|case
name|XPT_NOTIFY_ACK
case|:
case|case
name|XPT_GET_TRAN_SETTINGS
case|:
case|case
name|XPT_RESET_BUS
case|:
block|{
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|sim
operator|=
name|start_ccb
operator|->
name|ccb_h
operator|.
name|path
operator|->
name|bus
operator|->
name|sim
expr_stmt|;
operator|(
operator|*
operator|(
name|sim
operator|->
name|sim_action
operator|)
operator|)
operator|(
name|sim
operator|,
name|start_ccb
operator|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_PATH_INQ
case|:
block|{
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|sim
operator|=
name|start_ccb
operator|->
name|ccb_h
operator|.
name|path
operator|->
name|bus
operator|->
name|sim
expr_stmt|;
operator|(
operator|*
operator|(
name|sim
operator|->
name|sim_action
operator|)
operator|)
operator|(
name|sim
operator|,
name|start_ccb
operator|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_PATH_STATS
case|:
name|start_ccb
operator|->
name|cpis
operator|.
name|last_reset
operator|=
name|start_ccb
operator|->
name|ccb_h
operator|.
name|path
operator|->
name|bus
operator|->
name|last_reset
expr_stmt|;
name|start_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
case|case
name|XPT_GDEV_TYPE
case|:
block|{
name|struct
name|cam_ed
modifier|*
name|dev
decl_stmt|;
name|dev
operator|=
name|start_ccb
operator|->
name|ccb_h
operator|.
name|path
operator|->
name|device
expr_stmt|;
if|if
condition|(
operator|(
name|dev
operator|->
name|flags
operator|&
name|CAM_DEV_UNCONFIGURED
operator|)
operator|!=
literal|0
condition|)
block|{
name|start_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_DEV_NOT_THERE
expr_stmt|;
block|}
else|else
block|{
name|struct
name|ccb_getdev
modifier|*
name|cgd
decl_stmt|;
name|struct
name|cam_eb
modifier|*
name|bus
decl_stmt|;
name|struct
name|cam_et
modifier|*
name|tar
decl_stmt|;
name|cgd
operator|=
operator|&
name|start_ccb
operator|->
name|cgd
expr_stmt|;
name|bus
operator|=
name|cgd
operator|->
name|ccb_h
operator|.
name|path
operator|->
name|bus
expr_stmt|;
name|tar
operator|=
name|cgd
operator|->
name|ccb_h
operator|.
name|path
operator|->
name|target
expr_stmt|;
name|cgd
operator|->
name|inq_data
operator|=
name|dev
operator|->
name|inq_data
expr_stmt|;
name|cgd
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|cgd
operator|->
name|serial_num_len
operator|=
name|dev
operator|->
name|serial_num_len
expr_stmt|;
if|if
condition|(
operator|(
name|dev
operator|->
name|serial_num_len
operator|>
literal|0
operator|)
operator|&&
operator|(
name|dev
operator|->
name|serial_num
operator|!=
name|NULL
operator|)
condition|)
name|bcopy
argument_list|(
name|dev
operator|->
name|serial_num
argument_list|,
name|cgd
operator|->
name|serial_num
argument_list|,
name|dev
operator|->
name|serial_num_len
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|XPT_GDEV_STATS
case|:
block|{
name|struct
name|cam_ed
modifier|*
name|dev
decl_stmt|;
name|dev
operator|=
name|start_ccb
operator|->
name|ccb_h
operator|.
name|path
operator|->
name|device
expr_stmt|;
if|if
condition|(
operator|(
name|dev
operator|->
name|flags
operator|&
name|CAM_DEV_UNCONFIGURED
operator|)
operator|!=
literal|0
condition|)
block|{
name|start_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_DEV_NOT_THERE
expr_stmt|;
block|}
else|else
block|{
name|struct
name|ccb_getdevstats
modifier|*
name|cgds
decl_stmt|;
name|struct
name|cam_eb
modifier|*
name|bus
decl_stmt|;
name|struct
name|cam_et
modifier|*
name|tar
decl_stmt|;
name|cgds
operator|=
operator|&
name|start_ccb
operator|->
name|cgds
expr_stmt|;
name|bus
operator|=
name|cgds
operator|->
name|ccb_h
operator|.
name|path
operator|->
name|bus
expr_stmt|;
name|tar
operator|=
name|cgds
operator|->
name|ccb_h
operator|.
name|path
operator|->
name|target
expr_stmt|;
name|cgds
operator|->
name|dev_openings
operator|=
name|dev
operator|->
name|ccbq
operator|.
name|dev_openings
expr_stmt|;
name|cgds
operator|->
name|dev_active
operator|=
name|dev
operator|->
name|ccbq
operator|.
name|dev_active
expr_stmt|;
name|cgds
operator|->
name|devq_openings
operator|=
name|dev
operator|->
name|ccbq
operator|.
name|devq_openings
expr_stmt|;
name|cgds
operator|->
name|devq_queued
operator|=
name|dev
operator|->
name|ccbq
operator|.
name|queue
operator|.
name|entries
expr_stmt|;
name|cgds
operator|->
name|held
operator|=
name|dev
operator|->
name|ccbq
operator|.
name|held
expr_stmt|;
name|cgds
operator|->
name|last_reset
operator|=
name|tar
operator|->
name|last_reset
expr_stmt|;
name|cgds
operator|->
name|maxtags
operator|=
name|dev
operator|->
name|quirk
operator|->
name|maxtags
expr_stmt|;
name|cgds
operator|->
name|mintags
operator|=
name|dev
operator|->
name|quirk
operator|->
name|mintags
expr_stmt|;
if|if
condition|(
name|timevalcmp
argument_list|(
operator|&
name|tar
operator|->
name|last_reset
argument_list|,
operator|&
name|bus
operator|->
name|last_reset
argument_list|,
operator|<
argument_list|)
condition|)
name|cgds
operator|->
name|last_reset
operator|=
name|bus
operator|->
name|last_reset
expr_stmt|;
name|cgds
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
block|}
break|break;
block|}
case|case
name|XPT_GDEVLIST
case|:
block|{
name|struct
name|cam_periph
modifier|*
name|nperiph
decl_stmt|;
name|struct
name|periph_list
modifier|*
name|periph_head
decl_stmt|;
name|struct
name|ccb_getdevlist
modifier|*
name|cgdl
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|struct
name|cam_ed
modifier|*
name|device
decl_stmt|;
name|int
name|found
decl_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Don't want anyone mucking with our data. 		 */
name|device
operator|=
name|start_ccb
operator|->
name|ccb_h
operator|.
name|path
operator|->
name|device
expr_stmt|;
name|periph_head
operator|=
operator|&
name|device
operator|->
name|periphs
expr_stmt|;
name|cgdl
operator|=
operator|&
name|start_ccb
operator|->
name|cgdl
expr_stmt|;
comment|/* 		 * Check and see if the list has changed since the user 		 * last requested a list member.  If so, tell them that the 		 * list has changed, and therefore they need to start over  		 * from the beginning. 		 */
if|if
condition|(
operator|(
name|cgdl
operator|->
name|index
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|cgdl
operator|->
name|generation
operator|!=
name|device
operator|->
name|generation
operator|)
condition|)
block|{
name|cgdl
operator|->
name|status
operator|=
name|CAM_GDEVLIST_LIST_CHANGED
expr_stmt|;
break|break;
block|}
comment|/* 		 * Traverse the list of peripherals and attempt to find  		 * the requested peripheral. 		 */
for|for
control|(
name|nperiph
operator|=
name|SLIST_FIRST
argument_list|(
name|periph_head
argument_list|)
operator|,
name|i
operator|=
literal|0
init|;
operator|(
name|nperiph
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|i
operator|<=
name|cgdl
operator|->
name|index
operator|)
condition|;
name|nperiph
operator|=
name|SLIST_NEXT
argument_list|(
name|nperiph
argument_list|,
name|periph_links
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|cgdl
operator|->
name|index
condition|)
block|{
name|strncpy
argument_list|(
name|cgdl
operator|->
name|periph_name
argument_list|,
name|nperiph
operator|->
name|periph_name
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
name|cgdl
operator|->
name|unit_number
operator|=
name|nperiph
operator|->
name|unit_number
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|found
operator|==
literal|0
condition|)
block|{
name|cgdl
operator|->
name|status
operator|=
name|CAM_GDEVLIST_ERROR
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|nperiph
operator|==
name|NULL
condition|)
name|cgdl
operator|->
name|status
operator|=
name|CAM_GDEVLIST_LAST_DEVICE
expr_stmt|;
else|else
name|cgdl
operator|->
name|status
operator|=
name|CAM_GDEVLIST_MORE_DEVS
expr_stmt|;
name|cgdl
operator|->
name|index
operator|++
expr_stmt|;
name|cgdl
operator|->
name|generation
operator|=
name|device
operator|->
name|generation
expr_stmt|;
name|cgdl
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
block|}
case|case
name|XPT_DEV_MATCH
case|:
block|{
name|dev_pos_type
name|position_type
decl_stmt|;
name|struct
name|ccb_dev_match
modifier|*
name|cdm
decl_stmt|;
name|cdm
operator|=
operator|&
name|start_ccb
operator|->
name|cdm
expr_stmt|;
comment|/* 		 * There are two ways of getting at information in the EDT. 		 * The first way is via the primary EDT tree.  It starts 		 * with a list of busses, then a list of targets on a bus, 		 * then devices/luns on a target, and then peripherals on a 		 * device/lun.  The "other" way is by the peripheral driver 		 * lists.  The peripheral driver lists are organized by 		 * peripheral driver.  (obviously)  So it makes sense to 		 * use the peripheral driver list if the user is looking 		 * for something like "da1", or all "da" devices.  If the 		 * user is looking for something on a particular bus/target 		 * or lun, it's generally better to go through the EDT tree. 		 */
if|if
condition|(
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|!=
name|CAM_DEV_POS_NONE
condition|)
name|position_type
operator|=
name|cdm
operator|->
name|pos
operator|.
name|position_type
expr_stmt|;
else|else
block|{
name|u_int
name|i
decl_stmt|;
name|position_type
operator|=
name|CAM_DEV_POS_NONE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cdm
operator|->
name|num_patterns
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|cdm
operator|->
name|patterns
index|[
name|i
index|]
operator|.
name|type
operator|==
name|DEV_MATCH_BUS
operator|)
operator|||
operator|(
name|cdm
operator|->
name|patterns
index|[
name|i
index|]
operator|.
name|type
operator|==
name|DEV_MATCH_DEVICE
operator|)
condition|)
block|{
name|position_type
operator|=
name|CAM_DEV_POS_EDT
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|cdm
operator|->
name|num_patterns
operator|==
literal|0
condition|)
name|position_type
operator|=
name|CAM_DEV_POS_EDT
expr_stmt|;
elseif|else
if|if
condition|(
name|position_type
operator|==
name|CAM_DEV_POS_NONE
condition|)
name|position_type
operator|=
name|CAM_DEV_POS_PDRV
expr_stmt|;
block|}
switch|switch
condition|(
name|position_type
operator|&
name|CAM_DEV_POS_TYPEMASK
condition|)
block|{
case|case
name|CAM_DEV_POS_EDT
case|:
name|xptedtmatch
argument_list|(
name|cdm
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_DEV_POS_PDRV
case|:
name|xptperiphlistmatch
argument_list|(
name|cdm
argument_list|)
expr_stmt|;
break|break;
default|default:
name|cdm
operator|->
name|status
operator|=
name|CAM_DEV_MATCH_ERROR
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cdm
operator|->
name|status
operator|==
name|CAM_DEV_MATCH_ERROR
condition|)
name|start_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP_ERR
expr_stmt|;
else|else
name|start_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
block|}
case|case
name|XPT_SASYNC_CB
case|:
block|{
name|struct
name|ccb_setasync
modifier|*
name|csa
decl_stmt|;
name|struct
name|async_node
modifier|*
name|cur_entry
decl_stmt|;
name|struct
name|async_list
modifier|*
name|async_head
decl_stmt|;
name|u_int32_t
name|added
decl_stmt|;
name|csa
operator|=
operator|&
name|start_ccb
operator|->
name|csa
expr_stmt|;
name|added
operator|=
name|csa
operator|->
name|event_enable
expr_stmt|;
name|async_head
operator|=
operator|&
name|csa
operator|->
name|ccb_h
operator|.
name|path
operator|->
name|device
operator|->
name|asyncs
expr_stmt|;
comment|/* 		 * If there is already an entry for us, simply 		 * update it. 		 */
name|cur_entry
operator|=
name|SLIST_FIRST
argument_list|(
name|async_head
argument_list|)
expr_stmt|;
while|while
condition|(
name|cur_entry
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|cur_entry
operator|->
name|callback_arg
operator|==
name|csa
operator|->
name|callback_arg
operator|)
operator|&&
operator|(
name|cur_entry
operator|->
name|callback
operator|==
name|csa
operator|->
name|callback
operator|)
condition|)
break|break;
name|cur_entry
operator|=
name|SLIST_NEXT
argument_list|(
name|cur_entry
argument_list|,
name|links
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cur_entry
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * If the request has no flags set, 			 * remove the entry. 			 */
name|added
operator|&=
operator|~
name|cur_entry
operator|->
name|event_enable
expr_stmt|;
if|if
condition|(
name|csa
operator|->
name|event_enable
operator|==
literal|0
condition|)
block|{
name|SLIST_REMOVE
argument_list|(
name|async_head
argument_list|,
name|cur_entry
argument_list|,
name|async_node
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|csa
operator|->
name|ccb_h
operator|.
name|path
operator|->
name|device
operator|->
name|refcount
operator|--
expr_stmt|;
name|free
argument_list|(
name|cur_entry
argument_list|,
name|M_CAMXPT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cur_entry
operator|->
name|event_enable
operator|=
name|csa
operator|->
name|event_enable
expr_stmt|;
block|}
block|}
else|else
block|{
name|cur_entry
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cur_entry
argument_list|)
argument_list|,
name|M_CAMXPT
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_entry
operator|==
name|NULL
condition|)
block|{
name|csa
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
break|break;
block|}
name|cur_entry
operator|->
name|event_enable
operator|=
name|csa
operator|->
name|event_enable
expr_stmt|;
name|cur_entry
operator|->
name|callback_arg
operator|=
name|csa
operator|->
name|callback_arg
expr_stmt|;
name|cur_entry
operator|->
name|callback
operator|=
name|csa
operator|->
name|callback
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
name|async_head
argument_list|,
name|cur_entry
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|csa
operator|->
name|ccb_h
operator|.
name|path
operator|->
name|device
operator|->
name|refcount
operator|++
expr_stmt|;
block|}
comment|/* 		 * Need to decouple this operation via a taqskqueue so that 		 * the locking doesn't become a mess. 		 */
if|if
condition|(
operator|(
name|added
operator|&
operator|(
name|AC_FOUND_DEVICE
operator||
name|AC_PATH_REGISTERED
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|xpt_task
modifier|*
name|task
decl_stmt|;
name|task
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|xpt_task
argument_list|)
argument_list|,
name|M_CAMXPT
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|task
operator|==
name|NULL
condition|)
block|{
name|csa
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
break|break;
block|}
name|TASK_INIT
argument_list|(
operator|&
name|task
operator|->
name|task
argument_list|,
literal|0
argument_list|,
name|xpt_action_sasync_cb
argument_list|,
name|task
argument_list|)
expr_stmt|;
name|task
operator|->
name|data1
operator|=
name|cur_entry
expr_stmt|;
name|task
operator|->
name|data2
operator|=
name|added
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|task
operator|->
name|task
argument_list|)
expr_stmt|;
block|}
name|start_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
block|}
case|case
name|XPT_REL_SIMQ
case|:
block|{
name|struct
name|ccb_relsim
modifier|*
name|crs
decl_stmt|;
name|struct
name|cam_ed
modifier|*
name|dev
decl_stmt|;
name|crs
operator|=
operator|&
name|start_ccb
operator|->
name|crs
expr_stmt|;
name|dev
operator|=
name|crs
operator|->
name|ccb_h
operator|.
name|path
operator|->
name|device
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
block|{
name|crs
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_DEV_NOT_THERE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|crs
operator|->
name|release_flags
operator|&
name|RELSIM_ADJUST_OPENINGS
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|INQ_DATA_TQ_ENABLED
argument_list|(
operator|&
name|dev
operator|->
name|inq_data
argument_list|)
condition|)
block|{
comment|/* Don't ever go below one opening */
if|if
condition|(
name|crs
operator|->
name|openings
operator|>
literal|0
condition|)
block|{
name|xpt_dev_ccbq_resize
argument_list|(
name|crs
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|crs
operator|->
name|openings
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|xpt_print
argument_list|(
name|crs
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"tagged openings now %d\n"
argument_list|,
name|crs
operator|->
name|openings
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|(
name|crs
operator|->
name|release_flags
operator|&
name|RELSIM_RELEASE_AFTER_TIMEOUT
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|dev
operator|->
name|flags
operator|&
name|CAM_DEV_REL_TIMEOUT_PENDING
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * Just extend the old timeout and decrement 				 * the freeze count so that a single timeout 				 * is sufficient for releasing the queue. 				 */
name|start_ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&=
operator|~
name|CAM_DEV_QFREEZE
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|dev
operator|->
name|callout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|start_ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFREEZE
expr_stmt|;
block|}
name|callout_reset
argument_list|(
operator|&
name|dev
operator|->
name|callout
argument_list|,
operator|(
name|crs
operator|->
name|release_timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|,
name|xpt_release_devq_timeout
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|dev
operator|->
name|flags
operator||=
name|CAM_DEV_REL_TIMEOUT_PENDING
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|crs
operator|->
name|release_flags
operator|&
name|RELSIM_RELEASE_AFTER_CMDCMPLT
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|dev
operator|->
name|flags
operator|&
name|CAM_DEV_REL_ON_COMPLETE
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * Decrement the freeze count so that a single 				 * completion is still sufficient to unfreeze 				 * the queue. 				 */
name|start_ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&=
operator|~
name|CAM_DEV_QFREEZE
expr_stmt|;
block|}
else|else
block|{
name|dev
operator|->
name|flags
operator||=
name|CAM_DEV_REL_ON_COMPLETE
expr_stmt|;
name|start_ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFREEZE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|crs
operator|->
name|release_flags
operator|&
name|RELSIM_RELEASE_AFTER_QEMPTY
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|dev
operator|->
name|flags
operator|&
name|CAM_DEV_REL_ON_QUEUE_EMPTY
operator|)
operator|!=
literal|0
operator|||
operator|(
name|dev
operator|->
name|ccbq
operator|.
name|dev_active
operator|==
literal|0
operator|)
condition|)
block|{
name|start_ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&=
operator|~
name|CAM_DEV_QFREEZE
expr_stmt|;
block|}
else|else
block|{
name|dev
operator|->
name|flags
operator||=
name|CAM_DEV_REL_ON_QUEUE_EMPTY
expr_stmt|;
name|start_ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFREEZE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|start_ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DEV_QFREEZE
operator|)
operator|==
literal|0
condition|)
block|{
name|xpt_release_devq
argument_list|(
name|crs
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*count*/
literal|1
argument_list|,
comment|/*run_queue*/
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|start_ccb
operator|->
name|crs
operator|.
name|qfrozen_cnt
operator|=
name|dev
operator|->
name|qfrozen_cnt
expr_stmt|;
name|start_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
block|}
case|case
name|XPT_SCAN_BUS
case|:
name|xpt_scan_bus
argument_list|(
name|start_ccb
operator|->
name|ccb_h
operator|.
name|path
operator|->
name|periph
argument_list|,
name|start_ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_SCAN_LUN
case|:
name|xpt_scan_lun
argument_list|(
name|start_ccb
operator|->
name|ccb_h
operator|.
name|path
operator|->
name|periph
argument_list|,
name|start_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|start_ccb
operator|->
name|crcn
operator|.
name|flags
argument_list|,
name|start_ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_DEBUG
case|:
block|{
ifdef|#
directive|ifdef
name|CAMDEBUG
ifdef|#
directive|ifdef
name|CAM_DEBUG_DELAY
name|cam_debug_delay
operator|=
name|CAM_DEBUG_DELAY
expr_stmt|;
endif|#
directive|endif
name|cam_dflags
operator|=
name|start_ccb
operator|->
name|cdbg
operator|.
name|flags
expr_stmt|;
if|if
condition|(
name|cam_dpath
operator|!=
name|NULL
condition|)
block|{
name|xpt_free_path
argument_list|(
name|cam_dpath
argument_list|)
expr_stmt|;
name|cam_dpath
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|cam_dflags
operator|!=
name|CAM_DEBUG_NONE
condition|)
block|{
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|cam_dpath
argument_list|,
name|xpt_periph
argument_list|,
name|start_ccb
operator|->
name|ccb_h
operator|.
name|path_id
argument_list|,
name|start_ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|start_ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|start_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
name|cam_dflags
operator|=
name|CAM_DEBUG_NONE
expr_stmt|;
block|}
else|else
block|{
name|start_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_print
argument_list|(
name|cam_dpath
argument_list|,
literal|"debugging flags now %x\n"
argument_list|,
name|cam_dflags
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|cam_dpath
operator|=
name|NULL
expr_stmt|;
name|start_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
block|}
else|#
directive|else
comment|/* !CAMDEBUG */
name|start_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_FUNC_NOTAVAIL
expr_stmt|;
endif|#
directive|endif
comment|/* CAMDEBUG */
break|break;
block|}
case|case
name|XPT_NOOP
case|:
if|if
condition|(
operator|(
name|start_ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DEV_QFREEZE
operator|)
operator|!=
literal|0
condition|)
name|xpt_freeze_devq
argument_list|(
name|start_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|start_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
default|default:
case|case
name|XPT_SDEV_TYPE
case|:
case|case
name|XPT_TERM_IO
case|:
case|case
name|XPT_ENG_INQ
case|:
comment|/* XXX Implement */
name|start_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_PROVIDE_FAIL
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|void
name|xpt_polled_action
parameter_list|(
name|union
name|ccb
modifier|*
name|start_ccb
parameter_list|)
block|{
name|u_int32_t
name|timeout
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
name|struct
name|cam_ed
modifier|*
name|dev
decl_stmt|;
name|timeout
operator|=
name|start_ccb
operator|->
name|ccb_h
operator|.
name|timeout
expr_stmt|;
name|sim
operator|=
name|start_ccb
operator|->
name|ccb_h
operator|.
name|path
operator|->
name|bus
operator|->
name|sim
expr_stmt|;
name|devq
operator|=
name|sim
operator|->
name|devq
expr_stmt|;
name|dev
operator|=
name|start_ccb
operator|->
name|ccb_h
operator|.
name|path
operator|->
name|device
expr_stmt|;
name|mtx_assert
argument_list|(
name|sim
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * Steal an opening so that no other queued requests 	 * can get it before us while we simulate interrupts. 	 */
name|dev
operator|->
name|ccbq
operator|.
name|devq_openings
operator|--
expr_stmt|;
name|dev
operator|->
name|ccbq
operator|.
name|dev_openings
operator|--
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|devq
operator|!=
name|NULL
operator|&&
name|devq
operator|->
name|send_openings
operator|<=
literal|0
operator|)
operator|||
name|dev
operator|->
name|ccbq
operator|.
name|dev_openings
operator|<
literal|0
operator|)
operator|&&
operator|(
operator|--
name|timeout
operator|>
literal|0
operator|)
condition|)
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
operator|(
operator|*
operator|(
name|sim
operator|->
name|sim_poll
operator|)
operator|)
operator|(
name|sim
operator|)
expr_stmt|;
name|camisr_runqueue
argument_list|(
operator|&
name|sim
operator|->
name|sim_doneq
argument_list|)
expr_stmt|;
block|}
name|dev
operator|->
name|ccbq
operator|.
name|devq_openings
operator|++
expr_stmt|;
name|dev
operator|->
name|ccbq
operator|.
name|dev_openings
operator|++
expr_stmt|;
if|if
condition|(
name|timeout
operator|!=
literal|0
condition|)
block|{
name|xpt_action
argument_list|(
name|start_ccb
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|timeout
operator|>
literal|0
condition|)
block|{
operator|(
operator|*
operator|(
name|sim
operator|->
name|sim_poll
operator|)
operator|)
operator|(
name|sim
operator|)
expr_stmt|;
name|camisr_runqueue
argument_list|(
operator|&
name|sim
operator|->
name|sim_doneq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|start_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_INPROG
condition|)
break|break;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
block|{
comment|/* 			 * XXX Is it worth adding a sim_timeout entry 			 * point so we can attempt recovery?  If 			 * this is only used for dumps, I don't think 			 * it is. 			 */
name|start_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_CMD_TIMEOUT
expr_stmt|;
block|}
block|}
else|else
block|{
name|start_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Schedule a peripheral driver to receive a ccb when it's  * target device has space for more transactions.  */
end_comment

begin_function
name|void
name|xpt_schedule
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|perph
parameter_list|,
name|u_int32_t
name|new_priority
parameter_list|)
block|{
name|struct
name|cam_ed
modifier|*
name|device
decl_stmt|;
name|union
name|ccb
modifier|*
name|work_ccb
decl_stmt|;
name|int
name|runq
decl_stmt|;
name|mtx_assert
argument_list|(
name|perph
operator|->
name|sim
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|perph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"xpt_schedule\n"
operator|)
argument_list|)
expr_stmt|;
name|device
operator|=
name|perph
operator|->
name|path
operator|->
name|device
expr_stmt|;
if|if
condition|(
name|periph_is_queued
argument_list|(
name|perph
argument_list|)
condition|)
block|{
comment|/* Simply reorder based on new priority */
name|CAM_DEBUG
argument_list|(
name|perph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"   change priority to %d\n"
operator|,
name|new_priority
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_priority
operator|<
name|perph
operator|->
name|pinfo
operator|.
name|priority
condition|)
block|{
name|camq_change_priority
argument_list|(
operator|&
name|device
operator|->
name|drvq
argument_list|,
name|perph
operator|->
name|pinfo
operator|.
name|index
argument_list|,
name|new_priority
argument_list|)
expr_stmt|;
block|}
name|runq
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SIM_DEAD
argument_list|(
name|perph
operator|->
name|path
operator|->
name|bus
operator|->
name|sim
argument_list|)
condition|)
block|{
comment|/* The SIM is gone so just call periph_start directly. */
name|work_ccb
operator|=
name|xpt_get_ccb
argument_list|(
name|perph
operator|->
name|path
operator|->
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|work_ccb
operator|==
name|NULL
condition|)
return|return;
comment|/* XXX */
name|xpt_setup_ccb
argument_list|(
operator|&
name|work_ccb
operator|->
name|ccb_h
argument_list|,
name|perph
operator|->
name|path
argument_list|,
name|new_priority
argument_list|)
expr_stmt|;
name|perph
operator|->
name|pinfo
operator|.
name|priority
operator|=
name|new_priority
expr_stmt|;
name|perph
operator|->
name|periph_start
argument_list|(
name|perph
argument_list|,
name|work_ccb
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* New entry on the queue */
name|CAM_DEBUG
argument_list|(
name|perph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"   added periph to queue\n"
operator|)
argument_list|)
expr_stmt|;
name|perph
operator|->
name|pinfo
operator|.
name|priority
operator|=
name|new_priority
expr_stmt|;
name|perph
operator|->
name|pinfo
operator|.
name|generation
operator|=
operator|++
name|device
operator|->
name|drvq
operator|.
name|generation
expr_stmt|;
name|camq_insert
argument_list|(
operator|&
name|device
operator|->
name|drvq
argument_list|,
operator|&
name|perph
operator|->
name|pinfo
argument_list|)
expr_stmt|;
name|runq
operator|=
name|xpt_schedule_dev_allocq
argument_list|(
name|perph
operator|->
name|path
operator|->
name|bus
argument_list|,
name|device
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|runq
operator|!=
literal|0
condition|)
block|{
name|CAM_DEBUG
argument_list|(
name|perph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"   calling xpt_run_devq\n"
operator|)
argument_list|)
expr_stmt|;
name|xpt_run_dev_allocq
argument_list|(
name|perph
operator|->
name|path
operator|->
name|bus
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Schedule a device to run on a given queue.  * If the device was inserted as a new entry on the queue,  * return 1 meaning the device queue should be run. If we  * were already queued, implying someone else has already  * started the queue, return 0 so the caller doesn't attempt  * to run the queue.  */
end_comment

begin_function
specifier|static
name|int
name|xpt_schedule_dev
parameter_list|(
name|struct
name|camq
modifier|*
name|queue
parameter_list|,
name|cam_pinfo
modifier|*
name|pinfo
parameter_list|,
name|u_int32_t
name|new_priority
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|u_int32_t
name|old_priority
decl_stmt|;
name|CAM_DEBUG_PRINT
argument_list|(
name|CAM_DEBUG_XPT
argument_list|,
operator|(
literal|"xpt_schedule_dev\n"
operator|)
argument_list|)
expr_stmt|;
name|old_priority
operator|=
name|pinfo
operator|->
name|priority
expr_stmt|;
comment|/* 	 * Are we already queued? 	 */
if|if
condition|(
name|pinfo
operator|->
name|index
operator|!=
name|CAM_UNQUEUED_INDEX
condition|)
block|{
comment|/* Simply reorder based on new priority */
if|if
condition|(
name|new_priority
operator|<
name|old_priority
condition|)
block|{
name|camq_change_priority
argument_list|(
name|queue
argument_list|,
name|pinfo
operator|->
name|index
argument_list|,
name|new_priority
argument_list|)
expr_stmt|;
name|CAM_DEBUG_PRINT
argument_list|(
name|CAM_DEBUG_XPT
argument_list|,
operator|(
literal|"changed priority to %d\n"
operator|,
name|new_priority
operator|)
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* New entry on the queue */
if|if
condition|(
name|new_priority
operator|<
name|old_priority
condition|)
name|pinfo
operator|->
name|priority
operator|=
name|new_priority
expr_stmt|;
name|CAM_DEBUG_PRINT
argument_list|(
name|CAM_DEBUG_XPT
argument_list|,
operator|(
literal|"Inserting onto queue\n"
operator|)
argument_list|)
expr_stmt|;
name|pinfo
operator|->
name|generation
operator|=
operator|++
name|queue
operator|->
name|generation
expr_stmt|;
name|camq_insert
argument_list|(
name|queue
argument_list|,
name|pinfo
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xpt_run_dev_allocq
parameter_list|(
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|)
block|{
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
name|CAM_DEBUG_PRINT
argument_list|(
name|CAM_DEBUG_XPT
argument_list|,
operator|(
literal|"xpt_run_dev_allocq\n"
operator|)
argument_list|)
expr_stmt|;
name|devq
operator|=
name|bus
operator|->
name|sim
operator|->
name|devq
expr_stmt|;
name|CAM_DEBUG_PRINT
argument_list|(
name|CAM_DEBUG_XPT
argument_list|,
operator|(
literal|"   qfrozen_cnt == 0x%x, entries == %d, "
literal|"openings == %d, active == %d\n"
operator|,
name|devq
operator|->
name|alloc_queue
operator|.
name|qfrozen_cnt
operator|,
name|devq
operator|->
name|alloc_queue
operator|.
name|entries
operator|,
name|devq
operator|->
name|alloc_openings
operator|,
name|devq
operator|->
name|alloc_active
operator|)
argument_list|)
expr_stmt|;
name|devq
operator|->
name|alloc_queue
operator|.
name|qfrozen_cnt
operator|++
expr_stmt|;
while|while
condition|(
operator|(
name|devq
operator|->
name|alloc_queue
operator|.
name|entries
operator|>
literal|0
operator|)
operator|&&
operator|(
name|devq
operator|->
name|alloc_openings
operator|>
literal|0
operator|)
operator|&&
operator|(
name|devq
operator|->
name|alloc_queue
operator|.
name|qfrozen_cnt
operator|<=
literal|1
operator|)
condition|)
block|{
name|struct
name|cam_ed_qinfo
modifier|*
name|qinfo
decl_stmt|;
name|struct
name|cam_ed
modifier|*
name|device
decl_stmt|;
name|union
name|ccb
modifier|*
name|work_ccb
decl_stmt|;
name|struct
name|cam_periph
modifier|*
name|drv
decl_stmt|;
name|struct
name|camq
modifier|*
name|drvq
decl_stmt|;
name|qinfo
operator|=
operator|(
expr|struct
name|cam_ed_qinfo
operator|*
operator|)
name|camq_remove
argument_list|(
operator|&
name|devq
operator|->
name|alloc_queue
argument_list|,
name|CAMQ_HEAD
argument_list|)
expr_stmt|;
name|device
operator|=
name|qinfo
operator|->
name|device
expr_stmt|;
name|CAM_DEBUG_PRINT
argument_list|(
name|CAM_DEBUG_XPT
argument_list|,
operator|(
literal|"running device %p\n"
operator|,
name|device
operator|)
argument_list|)
expr_stmt|;
name|drvq
operator|=
operator|&
name|device
operator|->
name|drvq
expr_stmt|;
ifdef|#
directive|ifdef
name|CAMDEBUG
if|if
condition|(
name|drvq
operator|->
name|entries
operator|<=
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"xpt_run_dev_allocq: "
literal|"Device on queue without any work to do"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|work_ccb
operator|=
name|xpt_get_ccb
argument_list|(
name|device
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|devq
operator|->
name|alloc_openings
operator|--
expr_stmt|;
name|devq
operator|->
name|alloc_active
operator|++
expr_stmt|;
name|drv
operator|=
operator|(
expr|struct
name|cam_periph
operator|*
operator|)
name|camq_remove
argument_list|(
name|drvq
argument_list|,
name|CAMQ_HEAD
argument_list|)
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|work_ccb
operator|->
name|ccb_h
argument_list|,
name|drv
operator|->
name|path
argument_list|,
name|drv
operator|->
name|pinfo
operator|.
name|priority
argument_list|)
expr_stmt|;
name|CAM_DEBUG_PRINT
argument_list|(
name|CAM_DEBUG_XPT
argument_list|,
operator|(
literal|"calling periph start\n"
operator|)
argument_list|)
expr_stmt|;
name|drv
operator|->
name|periph_start
argument_list|(
name|drv
argument_list|,
name|work_ccb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Malloc failure in alloc_ccb 			 */
comment|/* 			 * XXX add us to a list to be run from free_ccb 			 * if we don't have any ccbs active on this 			 * device queue otherwise we may never get run 			 * again. 			 */
break|break;
block|}
if|if
condition|(
name|drvq
operator|->
name|entries
operator|>
literal|0
condition|)
block|{
comment|/* We have more work.  Attempt to reschedule */
name|xpt_schedule_dev_allocq
argument_list|(
name|bus
argument_list|,
name|device
argument_list|)
expr_stmt|;
block|}
block|}
name|devq
operator|->
name|alloc_queue
operator|.
name|qfrozen_cnt
operator|--
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xpt_run_dev_sendq
parameter_list|(
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|)
block|{
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
name|CAM_DEBUG_PRINT
argument_list|(
name|CAM_DEBUG_XPT
argument_list|,
operator|(
literal|"xpt_run_dev_sendq\n"
operator|)
argument_list|)
expr_stmt|;
name|devq
operator|=
name|bus
operator|->
name|sim
operator|->
name|devq
expr_stmt|;
name|devq
operator|->
name|send_queue
operator|.
name|qfrozen_cnt
operator|++
expr_stmt|;
while|while
condition|(
operator|(
name|devq
operator|->
name|send_queue
operator|.
name|entries
operator|>
literal|0
operator|)
operator|&&
operator|(
name|devq
operator|->
name|send_openings
operator|>
literal|0
operator|)
condition|)
block|{
name|struct
name|cam_ed_qinfo
modifier|*
name|qinfo
decl_stmt|;
name|struct
name|cam_ed
modifier|*
name|device
decl_stmt|;
name|union
name|ccb
modifier|*
name|work_ccb
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
if|if
condition|(
name|devq
operator|->
name|send_queue
operator|.
name|qfrozen_cnt
operator|>
literal|1
condition|)
block|{
break|break;
block|}
name|qinfo
operator|=
operator|(
expr|struct
name|cam_ed_qinfo
operator|*
operator|)
name|camq_remove
argument_list|(
operator|&
name|devq
operator|->
name|send_queue
argument_list|,
name|CAMQ_HEAD
argument_list|)
expr_stmt|;
name|device
operator|=
name|qinfo
operator|->
name|device
expr_stmt|;
comment|/* 		 * If the device has been "frozen", don't attempt 		 * to run it. 		 */
if|if
condition|(
name|device
operator|->
name|qfrozen_cnt
operator|>
literal|0
condition|)
block|{
continue|continue;
block|}
name|CAM_DEBUG_PRINT
argument_list|(
name|CAM_DEBUG_XPT
argument_list|,
operator|(
literal|"running device %p\n"
operator|,
name|device
operator|)
argument_list|)
expr_stmt|;
name|work_ccb
operator|=
name|cam_ccbq_peek_ccb
argument_list|(
operator|&
name|device
operator|->
name|ccbq
argument_list|,
name|CAMQ_HEAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|work_ccb
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"device on run queue with no ccbs???\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|work_ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_HIGH_POWER
operator|)
operator|!=
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|xsoftc
operator|.
name|num_highpower
operator|<=
literal|0
condition|)
block|{
comment|/* 				 * We got a high power command, but we 				 * don't have any available slots.  Freeze 				 * the device queue until we have a slot 				 * available. 				 */
name|device
operator|->
name|qfrozen_cnt
operator|++
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|xsoftc
operator|.
name|highpowerq
argument_list|,
operator|&
name|work_ccb
operator|->
name|ccb_h
argument_list|,
name|xpt_links
operator|.
name|stqe
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
comment|/* 				 * Consume a high power slot while 				 * this ccb runs. 				 */
name|xsoftc
operator|.
name|num_highpower
operator|--
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_lock
argument_list|)
expr_stmt|;
block|}
name|devq
operator|->
name|active_dev
operator|=
name|device
expr_stmt|;
name|cam_ccbq_remove_ccb
argument_list|(
operator|&
name|device
operator|->
name|ccbq
argument_list|,
name|work_ccb
argument_list|)
expr_stmt|;
name|cam_ccbq_send_ccb
argument_list|(
operator|&
name|device
operator|->
name|ccbq
argument_list|,
name|work_ccb
argument_list|)
expr_stmt|;
name|devq
operator|->
name|send_openings
operator|--
expr_stmt|;
name|devq
operator|->
name|send_active
operator|++
expr_stmt|;
if|if
condition|(
name|device
operator|->
name|ccbq
operator|.
name|queue
operator|.
name|entries
operator|>
literal|0
condition|)
name|xpt_schedule_dev_sendq
argument_list|(
name|bus
argument_list|,
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|work_ccb
operator|&&
operator|(
name|work_ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DEV_QFREEZE
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * The client wants to freeze the queue 			 * after this CCB is sent. 			 */
name|device
operator|->
name|qfrozen_cnt
operator|++
expr_stmt|;
block|}
comment|/* In Target mode, the peripheral driver knows best... */
if|if
condition|(
name|work_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_SCSI_IO
condition|)
block|{
if|if
condition|(
operator|(
name|device
operator|->
name|inq_flags
operator|&
name|SID_CmdQue
operator|)
operator|!=
literal|0
operator|&&
name|work_ccb
operator|->
name|csio
operator|.
name|tag_action
operator|!=
name|CAM_TAG_ACTION_NONE
condition|)
name|work_ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_TAG_ACTION_VALID
expr_stmt|;
else|else
comment|/* 				 * Clear this in case of a retried CCB that 				 * failed due to a rejected tag. 				 */
name|work_ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&=
operator|~
name|CAM_TAG_ACTION_VALID
expr_stmt|;
block|}
comment|/* 		 * Device queues can be shared among multiple sim instances 		 * that reside on different busses.  Use the SIM in the queue 		 * CCB's path, rather than the one in the bus that was passed 		 * into this function. 		 */
name|sim
operator|=
name|work_ccb
operator|->
name|ccb_h
operator|.
name|path
operator|->
name|bus
operator|->
name|sim
expr_stmt|;
operator|(
operator|*
operator|(
name|sim
operator|->
name|sim_action
operator|)
operator|)
operator|(
name|sim
operator|,
name|work_ccb
operator|)
expr_stmt|;
name|devq
operator|->
name|active_dev
operator|=
name|NULL
expr_stmt|;
block|}
name|devq
operator|->
name|send_queue
operator|.
name|qfrozen_cnt
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function merges stuff from the slave ccb into the master ccb, while  * keeping important fields in the master ccb constant.  */
end_comment

begin_function
name|void
name|xpt_merge_ccb
parameter_list|(
name|union
name|ccb
modifier|*
name|master_ccb
parameter_list|,
name|union
name|ccb
modifier|*
name|slave_ccb
parameter_list|)
block|{
comment|/* 	 * Pull fields that are valid for peripheral drivers to set 	 * into the master CCB along with the CCB "payload". 	 */
name|master_ccb
operator|->
name|ccb_h
operator|.
name|retry_count
operator|=
name|slave_ccb
operator|->
name|ccb_h
operator|.
name|retry_count
expr_stmt|;
name|master_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|slave_ccb
operator|->
name|ccb_h
operator|.
name|func_code
expr_stmt|;
name|master_ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|=
name|slave_ccb
operator|->
name|ccb_h
operator|.
name|timeout
expr_stmt|;
name|master_ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|=
name|slave_ccb
operator|->
name|ccb_h
operator|.
name|flags
expr_stmt|;
name|bcopy
argument_list|(
operator|&
operator|(
operator|&
name|slave_ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
operator|&
operator|(
operator|&
name|master_ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|ccb
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xpt_setup_ccb
parameter_list|(
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|u_int32_t
name|priority
parameter_list|)
block|{
name|CAM_DEBUG
argument_list|(
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"xpt_setup_ccb\n"
operator|)
argument_list|)
expr_stmt|;
name|ccb_h
operator|->
name|pinfo
operator|.
name|priority
operator|=
name|priority
expr_stmt|;
name|ccb_h
operator|->
name|path
operator|=
name|path
expr_stmt|;
name|ccb_h
operator|->
name|path_id
operator|=
name|path
operator|->
name|bus
operator|->
name|path_id
expr_stmt|;
if|if
condition|(
name|path
operator|->
name|target
condition|)
name|ccb_h
operator|->
name|target_id
operator|=
name|path
operator|->
name|target
operator|->
name|target_id
expr_stmt|;
else|else
name|ccb_h
operator|->
name|target_id
operator|=
name|CAM_TARGET_WILDCARD
expr_stmt|;
if|if
condition|(
name|path
operator|->
name|device
condition|)
block|{
name|ccb_h
operator|->
name|target_lun
operator|=
name|path
operator|->
name|device
operator|->
name|lun_id
expr_stmt|;
name|ccb_h
operator|->
name|pinfo
operator|.
name|generation
operator|=
operator|++
name|path
operator|->
name|device
operator|->
name|ccbq
operator|.
name|queue
operator|.
name|generation
expr_stmt|;
block|}
else|else
block|{
name|ccb_h
operator|->
name|target_lun
operator|=
name|CAM_TARGET_WILDCARD
expr_stmt|;
block|}
name|ccb_h
operator|->
name|pinfo
operator|.
name|index
operator|=
name|CAM_UNQUEUED_INDEX
expr_stmt|;
name|ccb_h
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Path manipulation functions */
end_comment

begin_function
name|cam_status
name|xpt_create_path
parameter_list|(
name|struct
name|cam_path
modifier|*
modifier|*
name|new_path_ptr
parameter_list|,
name|struct
name|cam_periph
modifier|*
name|perph
parameter_list|,
name|path_id_t
name|path_id
parameter_list|,
name|target_id_t
name|target_id
parameter_list|,
name|lun_id_t
name|lun_id
parameter_list|)
block|{
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|path
operator|=
operator|(
expr|struct
name|cam_path
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|path
argument_list|)
argument_list|,
name|M_CAMXPT
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
block|{
name|status
operator|=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
name|status
operator|=
name|xpt_compile_path
argument_list|(
name|path
argument_list|,
name|perph
argument_list|,
name|path_id
argument_list|,
name|target_id
argument_list|,
name|lun_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|free
argument_list|(
name|path
argument_list|,
name|M_CAMXPT
argument_list|)
expr_stmt|;
name|path
operator|=
name|NULL
expr_stmt|;
block|}
operator|*
name|new_path_ptr
operator|=
name|path
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
name|cam_status
name|xpt_create_path_unlocked
parameter_list|(
name|struct
name|cam_path
modifier|*
modifier|*
name|new_path_ptr
parameter_list|,
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|path_id_t
name|path_id
parameter_list|,
name|target_id_t
name|target_id
parameter_list|,
name|lun_id_t
name|lun_id
parameter_list|)
block|{
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|struct
name|cam_eb
modifier|*
name|bus
init|=
name|NULL
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|int
name|need_unlock
init|=
literal|0
decl_stmt|;
name|path
operator|=
operator|(
expr|struct
name|cam_path
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|path
argument_list|)
argument_list|,
name|M_CAMXPT
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|path_id
operator|!=
name|CAM_BUS_WILDCARD
condition|)
block|{
name|bus
operator|=
name|xpt_find_bus
argument_list|(
name|path_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus
operator|!=
name|NULL
condition|)
block|{
name|need_unlock
operator|=
literal|1
expr_stmt|;
name|CAM_SIM_LOCK
argument_list|(
name|bus
operator|->
name|sim
argument_list|)
expr_stmt|;
block|}
block|}
name|status
operator|=
name|xpt_compile_path
argument_list|(
name|path
argument_list|,
name|periph
argument_list|,
name|path_id
argument_list|,
name|target_id
argument_list|,
name|lun_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_unlock
condition|)
name|CAM_SIM_UNLOCK
argument_list|(
name|bus
operator|->
name|sim
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|free
argument_list|(
name|path
argument_list|,
name|M_CAMXPT
argument_list|)
expr_stmt|;
name|path
operator|=
name|NULL
expr_stmt|;
block|}
operator|*
name|new_path_ptr
operator|=
name|path
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|cam_status
name|xpt_compile_path
parameter_list|(
name|struct
name|cam_path
modifier|*
name|new_path
parameter_list|,
name|struct
name|cam_periph
modifier|*
name|perph
parameter_list|,
name|path_id_t
name|path_id
parameter_list|,
name|target_id_t
name|target_id
parameter_list|,
name|lun_id_t
name|lun_id
parameter_list|)
block|{
name|struct
name|cam_eb
modifier|*
name|bus
decl_stmt|;
name|struct
name|cam_et
modifier|*
name|target
decl_stmt|;
name|struct
name|cam_ed
modifier|*
name|device
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
comment|/* Completed without error */
name|target
operator|=
name|NULL
expr_stmt|;
comment|/* Wildcarded */
name|device
operator|=
name|NULL
expr_stmt|;
comment|/* Wildcarded */
comment|/* 	 * We will potentially modify the EDT, so block interrupts 	 * that may attempt to create cam paths. 	 */
name|bus
operator|=
name|xpt_find_bus
argument_list|(
name|path_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus
operator|==
name|NULL
condition|)
block|{
name|status
operator|=
name|CAM_PATH_INVALID
expr_stmt|;
block|}
else|else
block|{
name|target
operator|=
name|xpt_find_target
argument_list|(
name|bus
argument_list|,
name|target_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
name|NULL
condition|)
block|{
comment|/* Create one */
name|struct
name|cam_et
modifier|*
name|new_target
decl_stmt|;
name|new_target
operator|=
name|xpt_alloc_target
argument_list|(
name|bus
argument_list|,
name|target_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_target
operator|==
name|NULL
condition|)
block|{
name|status
operator|=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
block|}
else|else
block|{
name|target
operator|=
name|new_target
expr_stmt|;
block|}
block|}
if|if
condition|(
name|target
operator|!=
name|NULL
condition|)
block|{
name|device
operator|=
name|xpt_find_device
argument_list|(
name|target
argument_list|,
name|lun_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|device
operator|==
name|NULL
condition|)
block|{
comment|/* Create one */
name|struct
name|cam_ed
modifier|*
name|new_device
decl_stmt|;
name|new_device
operator|=
name|xpt_alloc_device
argument_list|(
name|bus
argument_list|,
name|target
argument_list|,
name|lun_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_device
operator|==
name|NULL
condition|)
block|{
name|status
operator|=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
block|}
else|else
block|{
name|device
operator|=
name|new_device
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* 	 * Only touch the user's data if we are successful. 	 */
if|if
condition|(
name|status
operator|==
name|CAM_REQ_CMP
condition|)
block|{
name|new_path
operator|->
name|periph
operator|=
name|perph
expr_stmt|;
name|new_path
operator|->
name|bus
operator|=
name|bus
expr_stmt|;
name|new_path
operator|->
name|target
operator|=
name|target
expr_stmt|;
name|new_path
operator|->
name|device
operator|=
name|device
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|new_path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"xpt_compile_path\n"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|device
operator|!=
name|NULL
condition|)
name|xpt_release_device
argument_list|(
name|bus
argument_list|,
name|target
argument_list|,
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|!=
name|NULL
condition|)
name|xpt_release_target
argument_list|(
name|bus
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus
operator|!=
name|NULL
condition|)
name|xpt_release_bus
argument_list|(
name|bus
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xpt_release_path
parameter_list|(
name|struct
name|cam_path
modifier|*
name|path
parameter_list|)
block|{
name|CAM_DEBUG
argument_list|(
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"xpt_release_path\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|->
name|device
operator|!=
name|NULL
condition|)
block|{
name|xpt_release_device
argument_list|(
name|path
operator|->
name|bus
argument_list|,
name|path
operator|->
name|target
argument_list|,
name|path
operator|->
name|device
argument_list|)
expr_stmt|;
name|path
operator|->
name|device
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|path
operator|->
name|target
operator|!=
name|NULL
condition|)
block|{
name|xpt_release_target
argument_list|(
name|path
operator|->
name|bus
argument_list|,
name|path
operator|->
name|target
argument_list|)
expr_stmt|;
name|path
operator|->
name|target
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|path
operator|->
name|bus
operator|!=
name|NULL
condition|)
block|{
name|xpt_release_bus
argument_list|(
name|path
operator|->
name|bus
argument_list|)
expr_stmt|;
name|path
operator|->
name|bus
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|xpt_free_path
parameter_list|(
name|struct
name|cam_path
modifier|*
name|path
parameter_list|)
block|{
name|CAM_DEBUG
argument_list|(
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"xpt_free_path\n"
operator|)
argument_list|)
expr_stmt|;
name|xpt_release_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|,
name|M_CAMXPT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return -1 for failure, 0 for exact match, 1 for match with wildcards  * in path1, 2 for match with wildcards in path2.  */
end_comment

begin_function
name|int
name|xpt_path_comp
parameter_list|(
name|struct
name|cam_path
modifier|*
name|path1
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path2
parameter_list|)
block|{
name|int
name|retval
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|path1
operator|->
name|bus
operator|!=
name|path2
operator|->
name|bus
condition|)
block|{
if|if
condition|(
name|path1
operator|->
name|bus
operator|->
name|path_id
operator|==
name|CAM_BUS_WILDCARD
condition|)
name|retval
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|path2
operator|->
name|bus
operator|->
name|path_id
operator|==
name|CAM_BUS_WILDCARD
condition|)
name|retval
operator|=
literal|2
expr_stmt|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|path1
operator|->
name|target
operator|!=
name|path2
operator|->
name|target
condition|)
block|{
if|if
condition|(
name|path1
operator|->
name|target
operator|->
name|target_id
operator|==
name|CAM_TARGET_WILDCARD
condition|)
block|{
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
name|retval
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|path2
operator|->
name|target
operator|->
name|target_id
operator|==
name|CAM_TARGET_WILDCARD
condition|)
name|retval
operator|=
literal|2
expr_stmt|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|path1
operator|->
name|device
operator|!=
name|path2
operator|->
name|device
condition|)
block|{
if|if
condition|(
name|path1
operator|->
name|device
operator|->
name|lun_id
operator|==
name|CAM_LUN_WILDCARD
condition|)
block|{
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
name|retval
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|path2
operator|->
name|device
operator|->
name|lun_id
operator|==
name|CAM_LUN_WILDCARD
condition|)
name|retval
operator|=
literal|2
expr_stmt|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|void
name|xpt_print_path
parameter_list|(
name|struct
name|cam_path
modifier|*
name|path
parameter_list|)
block|{
name|mtx_assert
argument_list|(
name|path
operator|->
name|bus
operator|->
name|sim
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"(nopath): "
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|path
operator|->
name|periph
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"(%s%d:"
argument_list|,
name|path
operator|->
name|periph
operator|->
name|periph_name
argument_list|,
name|path
operator|->
name|periph
operator|->
name|unit_number
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"(noperiph:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|->
name|bus
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"%s%d:%d:"
argument_list|,
name|path
operator|->
name|bus
operator|->
name|sim
operator|->
name|sim_name
argument_list|,
name|path
operator|->
name|bus
operator|->
name|sim
operator|->
name|unit_number
argument_list|,
name|path
operator|->
name|bus
operator|->
name|sim
operator|->
name|bus_id
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"nobus:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|->
name|target
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"%d:"
argument_list|,
name|path
operator|->
name|target
operator|->
name|target_id
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"X:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|->
name|device
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"%d): "
argument_list|,
name|path
operator|->
name|device
operator|->
name|lun_id
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"X): "
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|xpt_print
parameter_list|(
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|xpt_print_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vprintf
argument_list|(
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|xpt_path_string
parameter_list|(
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|char
modifier|*
name|str
parameter_list|,
name|size_t
name|str_len
parameter_list|)
block|{
name|struct
name|sbuf
name|sb
decl_stmt|;
name|mtx_assert
argument_list|(
name|path
operator|->
name|bus
operator|->
name|sim
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|sbuf_new
argument_list|(
operator|&
name|sb
argument_list|,
name|str
argument_list|,
name|str_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"(nopath): "
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|path
operator|->
name|periph
operator|!=
name|NULL
condition|)
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"(%s%d:"
argument_list|,
name|path
operator|->
name|periph
operator|->
name|periph_name
argument_list|,
name|path
operator|->
name|periph
operator|->
name|unit_number
argument_list|)
expr_stmt|;
else|else
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"(noperiph:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|->
name|bus
operator|!=
name|NULL
condition|)
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"%s%d:%d:"
argument_list|,
name|path
operator|->
name|bus
operator|->
name|sim
operator|->
name|sim_name
argument_list|,
name|path
operator|->
name|bus
operator|->
name|sim
operator|->
name|unit_number
argument_list|,
name|path
operator|->
name|bus
operator|->
name|sim
operator|->
name|bus_id
argument_list|)
expr_stmt|;
else|else
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"nobus:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|->
name|target
operator|!=
name|NULL
condition|)
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"%d:"
argument_list|,
name|path
operator|->
name|target
operator|->
name|target_id
argument_list|)
expr_stmt|;
else|else
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"X:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|->
name|device
operator|!=
name|NULL
condition|)
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"%d): "
argument_list|,
name|path
operator|->
name|device
operator|->
name|lun_id
argument_list|)
expr_stmt|;
else|else
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"X): "
argument_list|)
expr_stmt|;
block|}
name|sbuf_finish
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|sbuf_len
argument_list|(
operator|&
name|sb
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|path_id_t
name|xpt_path_path_id
parameter_list|(
name|struct
name|cam_path
modifier|*
name|path
parameter_list|)
block|{
name|mtx_assert
argument_list|(
name|path
operator|->
name|bus
operator|->
name|sim
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
return|return
operator|(
name|path
operator|->
name|bus
operator|->
name|path_id
operator|)
return|;
block|}
end_function

begin_function
name|target_id_t
name|xpt_path_target_id
parameter_list|(
name|struct
name|cam_path
modifier|*
name|path
parameter_list|)
block|{
name|mtx_assert
argument_list|(
name|path
operator|->
name|bus
operator|->
name|sim
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|->
name|target
operator|!=
name|NULL
condition|)
return|return
operator|(
name|path
operator|->
name|target
operator|->
name|target_id
operator|)
return|;
else|else
return|return
operator|(
name|CAM_TARGET_WILDCARD
operator|)
return|;
block|}
end_function

begin_function
name|lun_id_t
name|xpt_path_lun_id
parameter_list|(
name|struct
name|cam_path
modifier|*
name|path
parameter_list|)
block|{
name|mtx_assert
argument_list|(
name|path
operator|->
name|bus
operator|->
name|sim
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|->
name|device
operator|!=
name|NULL
condition|)
return|return
operator|(
name|path
operator|->
name|device
operator|->
name|lun_id
operator|)
return|;
else|else
return|return
operator|(
name|CAM_LUN_WILDCARD
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|cam_sim
modifier|*
name|xpt_path_sim
parameter_list|(
name|struct
name|cam_path
modifier|*
name|path
parameter_list|)
block|{
return|return
operator|(
name|path
operator|->
name|bus
operator|->
name|sim
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|cam_periph
modifier|*
name|xpt_path_periph
parameter_list|(
name|struct
name|cam_path
modifier|*
name|path
parameter_list|)
block|{
name|mtx_assert
argument_list|(
name|path
operator|->
name|bus
operator|->
name|sim
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
return|return
operator|(
name|path
operator|->
name|periph
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Release a CAM control block for the caller.  Remit the cost of the structure  * to the device referenced by the path.  If the this device had no 'credits'  * and peripheral drivers have registered async callbacks for this notification  * call them now.  */
end_comment

begin_function
name|void
name|xpt_release_ccb
parameter_list|(
name|union
name|ccb
modifier|*
name|free_ccb
parameter_list|)
block|{
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|struct
name|cam_ed
modifier|*
name|device
decl_stmt|;
name|struct
name|cam_eb
modifier|*
name|bus
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|CAM_DEBUG_PRINT
argument_list|(
name|CAM_DEBUG_XPT
argument_list|,
operator|(
literal|"xpt_release_ccb\n"
operator|)
argument_list|)
expr_stmt|;
name|path
operator|=
name|free_ccb
operator|->
name|ccb_h
operator|.
name|path
expr_stmt|;
name|device
operator|=
name|path
operator|->
name|device
expr_stmt|;
name|bus
operator|=
name|path
operator|->
name|bus
expr_stmt|;
name|sim
operator|=
name|bus
operator|->
name|sim
expr_stmt|;
name|mtx_assert
argument_list|(
name|sim
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|cam_ccbq_release_opening
argument_list|(
operator|&
name|device
operator|->
name|ccbq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sim
operator|->
name|ccb_count
operator|>
name|sim
operator|->
name|max_ccbs
condition|)
block|{
name|xpt_free_ccb
argument_list|(
name|free_ccb
argument_list|)
expr_stmt|;
name|sim
operator|->
name|ccb_count
operator|--
expr_stmt|;
block|}
else|else
block|{
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|sim
operator|->
name|ccb_freeq
argument_list|,
operator|&
name|free_ccb
operator|->
name|ccb_h
argument_list|,
name|xpt_links
operator|.
name|sle
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sim
operator|->
name|devq
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|sim
operator|->
name|devq
operator|->
name|alloc_openings
operator|++
expr_stmt|;
name|sim
operator|->
name|devq
operator|->
name|alloc_active
operator|--
expr_stmt|;
comment|/* XXX Turn this into an inline function - xpt_run_device?? */
if|if
condition|(
operator|(
name|device_is_alloc_queued
argument_list|(
name|device
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|device
operator|->
name|drvq
operator|.
name|entries
operator|>
literal|0
operator|)
condition|)
block|{
name|xpt_schedule_dev_allocq
argument_list|(
name|bus
argument_list|,
name|device
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dev_allocq_is_runnable
argument_list|(
name|sim
operator|->
name|devq
argument_list|)
condition|)
name|xpt_run_dev_allocq
argument_list|(
name|bus
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Functions accessed by SIM drivers */
end_comment

begin_comment
comment|/*  * A sim structure, listing the SIM entry points and instance  * identification info is passed to xpt_bus_register to hook the SIM  * into the CAM framework.  xpt_bus_register creates a cam_eb entry  * for this new bus and places it in the array of busses and assigns  * it a path_id.  The path_id may be influenced by "hard wiring"  * information specified by the user.  Once interrupt services are  * availible, the bus will be probed.  */
end_comment

begin_function
name|int32_t
name|xpt_bus_register
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|u_int32_t
name|bus
parameter_list|)
block|{
name|struct
name|cam_eb
modifier|*
name|new_bus
decl_stmt|;
name|struct
name|cam_eb
modifier|*
name|old_bus
decl_stmt|;
name|struct
name|ccb_pathinq
name|cpi
decl_stmt|;
name|mtx_assert
argument_list|(
name|sim
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|sim
operator|->
name|bus_id
operator|=
name|bus
expr_stmt|;
name|new_bus
operator|=
operator|(
expr|struct
name|cam_eb
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new_bus
argument_list|)
argument_list|,
name|M_CAMXPT
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_bus
operator|==
name|NULL
condition|)
block|{
comment|/* Couldn't satisfy request */
return|return
operator|(
name|CAM_RESRC_UNAVAIL
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|sim
operator|->
name|sim_name
argument_list|,
literal|"xpt"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sim
operator|->
name|path_id
operator|=
name|xptpathid
argument_list|(
name|sim
operator|->
name|sim_name
argument_list|,
name|sim
operator|->
name|unit_number
argument_list|,
name|sim
operator|->
name|bus_id
argument_list|)
expr_stmt|;
block|}
name|TAILQ_INIT
argument_list|(
operator|&
name|new_bus
operator|->
name|et_entries
argument_list|)
expr_stmt|;
name|new_bus
operator|->
name|path_id
operator|=
name|sim
operator|->
name|path_id
expr_stmt|;
name|new_bus
operator|->
name|sim
operator|=
name|sim
expr_stmt|;
name|timevalclear
argument_list|(
operator|&
name|new_bus
operator|->
name|last_reset
argument_list|)
expr_stmt|;
name|new_bus
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|new_bus
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
comment|/* Held until a bus_deregister event */
name|new_bus
operator|->
name|generation
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_topo_lock
argument_list|)
expr_stmt|;
name|old_bus
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_busses
argument_list|)
expr_stmt|;
while|while
condition|(
name|old_bus
operator|!=
name|NULL
operator|&&
name|old_bus
operator|->
name|path_id
operator|<
name|new_bus
operator|->
name|path_id
condition|)
name|old_bus
operator|=
name|TAILQ_NEXT
argument_list|(
name|old_bus
argument_list|,
name|links
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_bus
operator|!=
name|NULL
condition|)
name|TAILQ_INSERT_BEFORE
argument_list|(
name|old_bus
argument_list|,
name|new_bus
argument_list|,
name|links
argument_list|)
expr_stmt|;
else|else
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_busses
argument_list|,
name|new_bus
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|xsoftc
operator|.
name|bus_generation
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_topo_lock
argument_list|)
expr_stmt|;
comment|/* Notify interested parties */
if|if
condition|(
name|sim
operator|->
name|path_id
operator|!=
name|CAM_XPT_PATH_ID
condition|)
block|{
name|struct
name|cam_path
name|path
decl_stmt|;
name|xpt_compile_path
argument_list|(
operator|&
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|sim
operator|->
name|path_id
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|cpi
operator|.
name|ccb_h
argument_list|,
operator|&
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|cpi
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_PATH_INQ
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|cpi
argument_list|)
expr_stmt|;
name|xpt_async
argument_list|(
name|AC_PATH_REGISTERED
argument_list|,
operator|&
name|path
argument_list|,
operator|&
name|cpi
argument_list|)
expr_stmt|;
name|xpt_release_path
argument_list|(
operator|&
name|path
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|CAM_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|int32_t
name|xpt_bus_deregister
parameter_list|(
name|path_id_t
name|pathid
parameter_list|)
block|{
name|struct
name|cam_path
name|bus_path
decl_stmt|;
name|struct
name|cam_ed
modifier|*
name|device
decl_stmt|;
name|struct
name|cam_ed_qinfo
modifier|*
name|qinfo
decl_stmt|;
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|ccbsim
decl_stmt|;
name|union
name|ccb
modifier|*
name|work_ccb
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|status
operator|=
name|xpt_compile_path
argument_list|(
operator|&
name|bus_path
argument_list|,
name|NULL
argument_list|,
name|pathid
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
return|return
operator|(
name|status
operator|)
return|;
name|xpt_async
argument_list|(
name|AC_LOST_DEVICE
argument_list|,
operator|&
name|bus_path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xpt_async
argument_list|(
name|AC_PATH_DEREGISTERED
argument_list|,
operator|&
name|bus_path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* The SIM may be gone, so use a dummy SIM for any stray operations. */
name|devq
operator|=
name|bus_path
operator|.
name|bus
operator|->
name|sim
operator|->
name|devq
expr_stmt|;
name|ccbsim
operator|=
name|bus_path
operator|.
name|bus
operator|->
name|sim
expr_stmt|;
name|bus_path
operator|.
name|bus
operator|->
name|sim
operator|=
operator|&
name|cam_dead_sim
expr_stmt|;
comment|/* Execute any pending operations now. */
while|while
condition|(
operator|(
name|qinfo
operator|=
operator|(
expr|struct
name|cam_ed_qinfo
operator|*
operator|)
name|camq_remove
argument_list|(
operator|&
name|devq
operator|->
name|send_queue
argument_list|,
name|CAMQ_HEAD
argument_list|)
operator|)
operator|!=
name|NULL
operator|||
operator|(
name|qinfo
operator|=
operator|(
expr|struct
name|cam_ed_qinfo
operator|*
operator|)
name|camq_remove
argument_list|(
operator|&
name|devq
operator|->
name|alloc_queue
argument_list|,
name|CAMQ_HEAD
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
do|do
block|{
name|device
operator|=
name|qinfo
operator|->
name|device
expr_stmt|;
name|work_ccb
operator|=
name|cam_ccbq_peek_ccb
argument_list|(
operator|&
name|device
operator|->
name|ccbq
argument_list|,
name|CAMQ_HEAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|work_ccb
operator|!=
name|NULL
condition|)
block|{
name|devq
operator|->
name|active_dev
operator|=
name|device
expr_stmt|;
name|cam_ccbq_remove_ccb
argument_list|(
operator|&
name|device
operator|->
name|ccbq
argument_list|,
name|work_ccb
argument_list|)
expr_stmt|;
name|cam_ccbq_send_ccb
argument_list|(
operator|&
name|device
operator|->
name|ccbq
argument_list|,
name|work_ccb
argument_list|)
expr_stmt|;
operator|(
operator|*
operator|(
name|ccbsim
operator|->
name|sim_action
operator|)
operator|)
operator|(
name|ccbsim
operator|,
name|work_ccb
operator|)
expr_stmt|;
block|}
name|periph
operator|=
operator|(
expr|struct
name|cam_periph
operator|*
operator|)
name|camq_remove
argument_list|(
operator|&
name|device
operator|->
name|drvq
argument_list|,
name|CAMQ_HEAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|periph
operator|!=
name|NULL
condition|)
name|xpt_schedule
argument_list|(
name|periph
argument_list|,
name|periph
operator|->
name|pinfo
operator|.
name|priority
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|work_ccb
operator|!=
name|NULL
operator|||
name|periph
operator|!=
name|NULL
condition|)
do|;
block|}
comment|/* Make sure all completed CCBs are processed. */
while|while
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ccbsim
operator|->
name|sim_doneq
argument_list|)
condition|)
block|{
name|camisr_runqueue
argument_list|(
operator|&
name|ccbsim
operator|->
name|sim_doneq
argument_list|)
expr_stmt|;
comment|/* Repeat the async's for the benefit of any new devices. */
name|xpt_async
argument_list|(
name|AC_LOST_DEVICE
argument_list|,
operator|&
name|bus_path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xpt_async
argument_list|(
name|AC_PATH_DEREGISTERED
argument_list|,
operator|&
name|bus_path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Release the reference count held while registered. */
name|xpt_release_bus
argument_list|(
name|bus_path
operator|.
name|bus
argument_list|)
expr_stmt|;
name|xpt_release_path
argument_list|(
operator|&
name|bus_path
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|path_id_t
name|xptnextfreepathid
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cam_eb
modifier|*
name|bus
decl_stmt|;
name|path_id_t
name|pathid
decl_stmt|;
specifier|const
name|char
modifier|*
name|strval
decl_stmt|;
name|pathid
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_topo_lock
argument_list|)
expr_stmt|;
name|bus
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_busses
argument_list|)
expr_stmt|;
name|retry
label|:
comment|/* Find an unoccupied pathid */
while|while
condition|(
name|bus
operator|!=
name|NULL
operator|&&
name|bus
operator|->
name|path_id
operator|<=
name|pathid
condition|)
block|{
if|if
condition|(
name|bus
operator|->
name|path_id
operator|==
name|pathid
condition|)
name|pathid
operator|++
expr_stmt|;
name|bus
operator|=
name|TAILQ_NEXT
argument_list|(
name|bus
argument_list|,
name|links
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_topo_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Ensure that this pathid is not reserved for 	 * a bus that may be registered in the future. 	 */
if|if
condition|(
name|resource_string_value
argument_list|(
literal|"scbus"
argument_list|,
name|pathid
argument_list|,
literal|"at"
argument_list|,
operator|&
name|strval
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|++
name|pathid
expr_stmt|;
comment|/* Start the search over */
name|mtx_lock
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_topo_lock
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
return|return
operator|(
name|pathid
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|path_id_t
name|xptpathid
parameter_list|(
specifier|const
name|char
modifier|*
name|sim_name
parameter_list|,
name|int
name|sim_unit
parameter_list|,
name|int
name|sim_bus
parameter_list|)
block|{
name|path_id_t
name|pathid
decl_stmt|;
name|int
name|i
decl_stmt|,
name|dunit
decl_stmt|,
name|val
decl_stmt|;
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|dname
decl_stmt|;
name|pathid
operator|=
name|CAM_XPT_PATH_ID
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s%d"
argument_list|,
name|sim_name
argument_list|,
name|sim_unit
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|resource_find_match
argument_list|(
operator|&
name|i
argument_list|,
operator|&
name|dname
argument_list|,
operator|&
name|dunit
argument_list|,
literal|"at"
argument_list|,
name|buf
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|dname
argument_list|,
literal|"scbus"
argument_list|)
condition|)
block|{
comment|/* Avoid a bit of foot shooting. */
continue|continue;
block|}
if|if
condition|(
name|dunit
operator|<
literal|0
condition|)
comment|/* unwired?! */
continue|continue;
if|if
condition|(
name|resource_int_value
argument_list|(
literal|"scbus"
argument_list|,
name|dunit
argument_list|,
literal|"bus"
argument_list|,
operator|&
name|val
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sim_bus
operator|==
name|val
condition|)
block|{
name|pathid
operator|=
name|dunit
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|sim_bus
operator|==
literal|0
condition|)
block|{
comment|/* Unspecified matches bus 0 */
name|pathid
operator|=
name|dunit
expr_stmt|;
break|break;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Ambiguous scbus configuration for %s%d "
literal|"bus %d, cannot wire down.  The kernel "
literal|"config entry for scbus%d should "
literal|"specify a controller bus.\n"
literal|"Scbus will be assigned dynamically.\n"
argument_list|,
name|sim_name
argument_list|,
name|sim_unit
argument_list|,
name|sim_bus
argument_list|,
name|dunit
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|pathid
operator|==
name|CAM_XPT_PATH_ID
condition|)
name|pathid
operator|=
name|xptnextfreepathid
argument_list|()
expr_stmt|;
return|return
operator|(
name|pathid
operator|)
return|;
block|}
end_function

begin_function
name|void
name|xpt_async
parameter_list|(
name|u_int32_t
name|async_code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|async_arg
parameter_list|)
block|{
name|struct
name|cam_eb
modifier|*
name|bus
decl_stmt|;
name|struct
name|cam_et
modifier|*
name|target
decl_stmt|,
modifier|*
name|next_target
decl_stmt|;
name|struct
name|cam_ed
modifier|*
name|device
decl_stmt|,
modifier|*
name|next_device
decl_stmt|;
name|mtx_assert
argument_list|(
name|path
operator|->
name|bus
operator|->
name|sim
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"xpt_async\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Most async events come from a CAM interrupt context.  In 	 * a few cases, the error recovery code at the peripheral layer, 	 * which may run from our SWI or a process context, may signal 	 * deferred events with a call to xpt_async. 	 */
name|bus
operator|=
name|path
operator|->
name|bus
expr_stmt|;
if|if
condition|(
name|async_code
operator|==
name|AC_BUS_RESET
condition|)
block|{
comment|/* Update our notion of when the last reset occurred */
name|microtime
argument_list|(
operator|&
name|bus
operator|->
name|last_reset
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|target
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|bus
operator|->
name|et_entries
argument_list|)
init|;
name|target
operator|!=
name|NULL
condition|;
name|target
operator|=
name|next_target
control|)
block|{
name|next_target
operator|=
name|TAILQ_NEXT
argument_list|(
name|target
argument_list|,
name|links
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|->
name|target
operator|!=
name|target
operator|&&
name|path
operator|->
name|target
operator|->
name|target_id
operator|!=
name|CAM_TARGET_WILDCARD
operator|&&
name|target
operator|->
name|target_id
operator|!=
name|CAM_TARGET_WILDCARD
condition|)
continue|continue;
if|if
condition|(
name|async_code
operator|==
name|AC_SENT_BDR
condition|)
block|{
comment|/* Update our notion of when the last reset occurred */
name|microtime
argument_list|(
operator|&
name|path
operator|->
name|target
operator|->
name|last_reset
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|device
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|target
operator|->
name|ed_entries
argument_list|)
init|;
name|device
operator|!=
name|NULL
condition|;
name|device
operator|=
name|next_device
control|)
block|{
name|next_device
operator|=
name|TAILQ_NEXT
argument_list|(
name|device
argument_list|,
name|links
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|->
name|device
operator|!=
name|device
operator|&&
name|path
operator|->
name|device
operator|->
name|lun_id
operator|!=
name|CAM_LUN_WILDCARD
operator|&&
name|device
operator|->
name|lun_id
operator|!=
name|CAM_LUN_WILDCARD
condition|)
continue|continue;
name|xpt_dev_async
argument_list|(
name|async_code
argument_list|,
name|bus
argument_list|,
name|target
argument_list|,
name|device
argument_list|,
name|async_arg
argument_list|)
expr_stmt|;
name|xpt_async_bcast
argument_list|(
operator|&
name|device
operator|->
name|asyncs
argument_list|,
name|async_code
argument_list|,
name|path
argument_list|,
name|async_arg
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * If this wasn't a fully wildcarded async, tell all 	 * clients that want all async events. 	 */
if|if
condition|(
name|bus
operator|!=
name|xpt_periph
operator|->
name|path
operator|->
name|bus
condition|)
name|xpt_async_bcast
argument_list|(
operator|&
name|xpt_periph
operator|->
name|path
operator|->
name|device
operator|->
name|asyncs
argument_list|,
name|async_code
argument_list|,
name|path
argument_list|,
name|async_arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xpt_async_bcast
parameter_list|(
name|struct
name|async_list
modifier|*
name|async_head
parameter_list|,
name|u_int32_t
name|async_code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|async_arg
parameter_list|)
block|{
name|struct
name|async_node
modifier|*
name|cur_entry
decl_stmt|;
name|cur_entry
operator|=
name|SLIST_FIRST
argument_list|(
name|async_head
argument_list|)
expr_stmt|;
while|while
condition|(
name|cur_entry
operator|!=
name|NULL
condition|)
block|{
name|struct
name|async_node
modifier|*
name|next_entry
decl_stmt|;
comment|/* 		 * Grab the next list entry before we call the current 		 * entry's callback.  This is because the callback function 		 * can delete its async callback entry. 		 */
name|next_entry
operator|=
name|SLIST_NEXT
argument_list|(
name|cur_entry
argument_list|,
name|links
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cur_entry
operator|->
name|event_enable
operator|&
name|async_code
operator|)
operator|!=
literal|0
condition|)
name|cur_entry
operator|->
name|callback
argument_list|(
name|cur_entry
operator|->
name|callback_arg
argument_list|,
name|async_code
argument_list|,
name|path
argument_list|,
name|async_arg
argument_list|)
expr_stmt|;
name|cur_entry
operator|=
name|next_entry
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Handle any per-device event notifications that require action by the XPT.  */
end_comment

begin_function
specifier|static
name|void
name|xpt_dev_async
parameter_list|(
name|u_int32_t
name|async_code
parameter_list|,
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|,
name|struct
name|cam_et
modifier|*
name|target
parameter_list|,
name|struct
name|cam_ed
modifier|*
name|device
parameter_list|,
name|void
modifier|*
name|async_arg
parameter_list|)
block|{
name|cam_status
name|status
decl_stmt|;
name|struct
name|cam_path
name|newpath
decl_stmt|;
comment|/* 	 * We only need to handle events for real devices. 	 */
if|if
condition|(
name|target
operator|->
name|target_id
operator|==
name|CAM_TARGET_WILDCARD
operator|||
name|device
operator|->
name|lun_id
operator|==
name|CAM_LUN_WILDCARD
condition|)
return|return;
comment|/* 	 * We need our own path with wildcards expanded to 	 * handle certain types of events. 	 */
if|if
condition|(
operator|(
name|async_code
operator|==
name|AC_SENT_BDR
operator|)
operator|||
operator|(
name|async_code
operator|==
name|AC_BUS_RESET
operator|)
operator|||
operator|(
name|async_code
operator|==
name|AC_INQ_CHANGED
operator|)
condition|)
name|status
operator|=
name|xpt_compile_path
argument_list|(
operator|&
name|newpath
argument_list|,
name|NULL
argument_list|,
name|bus
operator|->
name|path_id
argument_list|,
name|target
operator|->
name|target_id
argument_list|,
name|device
operator|->
name|lun_id
argument_list|)
expr_stmt|;
else|else
name|status
operator|=
name|CAM_REQ_CMP_ERR
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|CAM_REQ_CMP
condition|)
block|{
comment|/* 		 * Allow transfer negotiation to occur in a 		 * tag free environment. 		 */
if|if
condition|(
name|async_code
operator|==
name|AC_SENT_BDR
operator|||
name|async_code
operator|==
name|AC_BUS_RESET
condition|)
name|xpt_toggle_tags
argument_list|(
operator|&
name|newpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|async_code
operator|==
name|AC_INQ_CHANGED
condition|)
block|{
comment|/* 			 * We've sent a start unit command, or 			 * something similar to a device that 			 * may have caused its inquiry data to 			 * change. So we re-scan the device to 			 * refresh the inquiry data for it. 			 */
name|xpt_scan_lun
argument_list|(
name|newpath
operator|.
name|periph
argument_list|,
operator|&
name|newpath
argument_list|,
name|CAM_EXPECT_INQ_CHANGE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|xpt_release_path
argument_list|(
operator|&
name|newpath
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|async_code
operator|==
name|AC_LOST_DEVICE
condition|)
block|{
name|device
operator|->
name|flags
operator||=
name|CAM_DEV_UNCONFIGURED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|async_code
operator|==
name|AC_TRANSFER_NEG
condition|)
block|{
name|struct
name|ccb_trans_settings
modifier|*
name|settings
decl_stmt|;
name|settings
operator|=
operator|(
expr|struct
name|ccb_trans_settings
operator|*
operator|)
name|async_arg
expr_stmt|;
name|xpt_set_transfer_settings
argument_list|(
name|settings
argument_list|,
name|device
argument_list|,
comment|/*async_update*/
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|u_int32_t
name|xpt_freeze_devq
parameter_list|(
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|u_int
name|count
parameter_list|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|ccbh
decl_stmt|;
name|mtx_assert
argument_list|(
name|path
operator|->
name|bus
operator|->
name|sim
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|path
operator|->
name|device
operator|->
name|qfrozen_cnt
operator|+=
name|count
expr_stmt|;
comment|/* 	 * Mark the last CCB in the queue as needing 	 * to be requeued if the driver hasn't 	 * changed it's state yet.  This fixes a race 	 * where a ccb is just about to be queued to 	 * a controller driver when it's interrupt routine 	 * freezes the queue.  To completly close the 	 * hole, controller drives must check to see 	 * if a ccb's status is still CAM_REQ_INPROG 	 * just before they queue 	 * the CCB.  See ahc_action/ahc_freeze_devq for 	 * an example. 	 */
name|ccbh
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|path
operator|->
name|device
operator|->
name|ccbq
operator|.
name|active_ccbs
argument_list|,
name|ccb_hdr_tailq
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccbh
operator|&&
name|ccbh
operator|->
name|status
operator|==
name|CAM_REQ_INPROG
condition|)
name|ccbh
operator|->
name|status
operator|=
name|CAM_REQUEUE_REQ
expr_stmt|;
return|return
operator|(
name|path
operator|->
name|device
operator|->
name|qfrozen_cnt
operator|)
return|;
block|}
end_function

begin_function
name|u_int32_t
name|xpt_freeze_simq
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|u_int
name|count
parameter_list|)
block|{
name|mtx_assert
argument_list|(
name|sim
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|sim
operator|->
name|devq
operator|->
name|send_queue
operator|.
name|qfrozen_cnt
operator|+=
name|count
expr_stmt|;
if|if
condition|(
name|sim
operator|->
name|devq
operator|->
name|active_dev
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|ccbh
decl_stmt|;
name|ccbh
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|sim
operator|->
name|devq
operator|->
name|active_dev
operator|->
name|ccbq
operator|.
name|active_ccbs
argument_list|,
name|ccb_hdr_tailq
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccbh
operator|&&
name|ccbh
operator|->
name|status
operator|==
name|CAM_REQ_INPROG
condition|)
name|ccbh
operator|->
name|status
operator|=
name|CAM_REQUEUE_REQ
expr_stmt|;
block|}
return|return
operator|(
name|sim
operator|->
name|devq
operator|->
name|send_queue
operator|.
name|qfrozen_cnt
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xpt_release_devq_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cam_ed
modifier|*
name|device
decl_stmt|;
name|device
operator|=
operator|(
expr|struct
name|cam_ed
operator|*
operator|)
name|arg
expr_stmt|;
name|xpt_release_devq_device
argument_list|(
name|device
argument_list|,
comment|/*count*/
literal|1
argument_list|,
comment|/*run_queue*/
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xpt_release_devq
parameter_list|(
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|u_int
name|count
parameter_list|,
name|int
name|run_queue
parameter_list|)
block|{
name|mtx_assert
argument_list|(
name|path
operator|->
name|bus
operator|->
name|sim
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|xpt_release_devq_device
argument_list|(
name|path
operator|->
name|device
argument_list|,
name|count
argument_list|,
name|run_queue
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xpt_release_devq_device
parameter_list|(
name|struct
name|cam_ed
modifier|*
name|dev
parameter_list|,
name|u_int
name|count
parameter_list|,
name|int
name|run_queue
parameter_list|)
block|{
name|int
name|rundevq
decl_stmt|;
name|rundevq
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|qfrozen_cnt
operator|>
literal|0
condition|)
block|{
name|count
operator|=
operator|(
name|count
operator|>
name|dev
operator|->
name|qfrozen_cnt
operator|)
condition|?
name|dev
operator|->
name|qfrozen_cnt
else|:
name|count
expr_stmt|;
name|dev
operator|->
name|qfrozen_cnt
operator|-=
name|count
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|qfrozen_cnt
operator|==
literal|0
condition|)
block|{
comment|/* 			 * No longer need to wait for a successful 			 * command completion. 			 */
name|dev
operator|->
name|flags
operator|&=
operator|~
name|CAM_DEV_REL_ON_COMPLETE
expr_stmt|;
comment|/* 			 * Remove any timeouts that might be scheduled 			 * to release this queue. 			 */
if|if
condition|(
operator|(
name|dev
operator|->
name|flags
operator|&
name|CAM_DEV_REL_TIMEOUT_PENDING
operator|)
operator|!=
literal|0
condition|)
block|{
name|callout_stop
argument_list|(
operator|&
name|dev
operator|->
name|callout
argument_list|)
expr_stmt|;
name|dev
operator|->
name|flags
operator|&=
operator|~
name|CAM_DEV_REL_TIMEOUT_PENDING
expr_stmt|;
block|}
comment|/* 			 * Now that we are unfrozen schedule the 			 * device so any pending transactions are 			 * run. 			 */
if|if
condition|(
operator|(
name|dev
operator|->
name|ccbq
operator|.
name|queue
operator|.
name|entries
operator|>
literal|0
operator|)
operator|&&
operator|(
name|xpt_schedule_dev_sendq
argument_list|(
name|dev
operator|->
name|target
operator|->
name|bus
argument_list|,
name|dev
argument_list|)
operator|)
operator|&&
operator|(
name|run_queue
operator|!=
literal|0
operator|)
condition|)
block|{
name|rundevq
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|rundevq
operator|!=
literal|0
condition|)
name|xpt_run_dev_sendq
argument_list|(
name|dev
operator|->
name|target
operator|->
name|bus
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xpt_release_simq
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|int
name|run_queue
parameter_list|)
block|{
name|struct
name|camq
modifier|*
name|sendq
decl_stmt|;
name|mtx_assert
argument_list|(
name|sim
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|sendq
operator|=
operator|&
operator|(
name|sim
operator|->
name|devq
operator|->
name|send_queue
operator|)
expr_stmt|;
if|if
condition|(
name|sendq
operator|->
name|qfrozen_cnt
operator|>
literal|0
condition|)
block|{
name|sendq
operator|->
name|qfrozen_cnt
operator|--
expr_stmt|;
if|if
condition|(
name|sendq
operator|->
name|qfrozen_cnt
operator|==
literal|0
condition|)
block|{
name|struct
name|cam_eb
modifier|*
name|bus
decl_stmt|;
comment|/* 			 * If there is a timeout scheduled to release this 			 * sim queue, remove it.  The queue frozen count is 			 * already at 0. 			 */
if|if
condition|(
operator|(
name|sim
operator|->
name|flags
operator|&
name|CAM_SIM_REL_TIMEOUT_PENDING
operator|)
operator|!=
literal|0
condition|)
block|{
name|callout_stop
argument_list|(
operator|&
name|sim
operator|->
name|callout
argument_list|)
expr_stmt|;
name|sim
operator|->
name|flags
operator|&=
operator|~
name|CAM_SIM_REL_TIMEOUT_PENDING
expr_stmt|;
block|}
name|bus
operator|=
name|xpt_find_bus
argument_list|(
name|sim
operator|->
name|path_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|run_queue
condition|)
block|{
comment|/* 				 * Now that we are unfrozen run the send queue. 				 */
name|xpt_run_dev_sendq
argument_list|(
name|bus
argument_list|)
expr_stmt|;
block|}
name|xpt_release_bus
argument_list|(
name|bus
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * XXX Appears to be unused.  */
end_comment

begin_function
specifier|static
name|void
name|xpt_release_simq_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|sim
operator|=
operator|(
expr|struct
name|cam_sim
operator|*
operator|)
name|arg
expr_stmt|;
name|xpt_release_simq
argument_list|(
name|sim
argument_list|,
comment|/* run_queue */
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xpt_done
parameter_list|(
name|union
name|ccb
modifier|*
name|done_ccb
parameter_list|)
block|{
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"xpt_done\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|&
name|XPT_FC_QUEUED
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Queue up the request for handling by our SWI handler 		 * any of the "non-immediate" type of ccbs. 		 */
name|sim
operator|=
name|done_ccb
operator|->
name|ccb_h
operator|.
name|path
operator|->
name|bus
operator|->
name|sim
expr_stmt|;
switch|switch
condition|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|path
operator|->
name|periph
operator|->
name|type
condition|)
block|{
case|case
name|CAM_PERIPH_BIO
case|:
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sim
operator|->
name|sim_doneq
argument_list|,
operator|&
name|done_ccb
operator|->
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|done_ccb
operator|->
name|ccb_h
operator|.
name|pinfo
operator|.
name|index
operator|=
name|CAM_DONEQ_INDEX
expr_stmt|;
if|if
condition|(
operator|(
name|sim
operator|->
name|flags
operator|&
name|CAM_SIM_ON_DONEQ
operator|)
operator|==
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|cam_simq_lock
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|cam_simq
argument_list|,
name|sim
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|sim
operator|->
name|flags
operator||=
name|CAM_SIM_ON_DONEQ
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|cam_simq_lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|path
operator|->
name|periph
operator|->
name|flags
operator|&
name|CAM_PERIPH_POLLED
operator|)
operator|==
literal|0
condition|)
name|swi_sched
argument_list|(
name|cambio_ih
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"unknown periph type %d"
argument_list|,
name|done_ccb
operator|->
name|ccb_h
operator|.
name|path
operator|->
name|periph
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|union
name|ccb
modifier|*
name|xpt_alloc_ccb
parameter_list|()
block|{
name|union
name|ccb
modifier|*
name|new_ccb
decl_stmt|;
name|new_ccb
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new_ccb
argument_list|)
argument_list|,
name|M_CAMXPT
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
return|return
operator|(
name|new_ccb
operator|)
return|;
block|}
end_function

begin_function
name|union
name|ccb
modifier|*
name|xpt_alloc_ccb_nowait
parameter_list|()
block|{
name|union
name|ccb
modifier|*
name|new_ccb
decl_stmt|;
name|new_ccb
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new_ccb
argument_list|)
argument_list|,
name|M_CAMXPT
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
return|return
operator|(
name|new_ccb
operator|)
return|;
block|}
end_function

begin_function
name|void
name|xpt_free_ccb
parameter_list|(
name|union
name|ccb
modifier|*
name|free_ccb
parameter_list|)
block|{
name|free
argument_list|(
name|free_ccb
argument_list|,
name|M_CAMXPT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Private XPT functions */
end_comment

begin_comment
comment|/*  * Get a CAM control block for the caller. Charge the structure to the device  * referenced by the path.  If the this device has no 'credits' then the  * device already has the maximum number of outstanding operations under way  * and we return NULL. If we don't have sufficient resources to allocate more  * ccbs, we also return NULL.  */
end_comment

begin_function
specifier|static
name|union
name|ccb
modifier|*
name|xpt_get_ccb
parameter_list|(
name|struct
name|cam_ed
modifier|*
name|device
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|new_ccb
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|sim
operator|=
name|device
operator|->
name|sim
expr_stmt|;
if|if
condition|(
operator|(
name|new_ccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|SLIST_FIRST
argument_list|(
operator|&
name|sim
operator|->
name|ccb_freeq
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|new_ccb
operator|=
name|xpt_alloc_ccb_nowait
argument_list|()
expr_stmt|;
if|if
condition|(
name|new_ccb
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|sim
operator|->
name|flags
operator|&
name|CAM_SIM_MPSAFE
operator|)
operator|==
literal|0
condition|)
name|callout_handle_init
argument_list|(
operator|&
name|new_ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|sim
operator|->
name|ccb_freeq
argument_list|,
operator|&
name|new_ccb
operator|->
name|ccb_h
argument_list|,
name|xpt_links
operator|.
name|sle
argument_list|)
expr_stmt|;
name|sim
operator|->
name|ccb_count
operator|++
expr_stmt|;
block|}
name|cam_ccbq_take_opening
argument_list|(
operator|&
name|device
operator|->
name|ccbq
argument_list|)
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|sim
operator|->
name|ccb_freeq
argument_list|,
name|xpt_links
operator|.
name|sle
argument_list|)
expr_stmt|;
return|return
operator|(
name|new_ccb
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xpt_release_bus
parameter_list|(
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|--
name|bus
operator|->
name|refcount
operator|==
literal|0
operator|)
operator|&&
operator|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|bus
operator|->
name|et_entries
argument_list|)
operator|==
name|NULL
operator|)
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_topo_lock
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_busses
argument_list|,
name|bus
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|xsoftc
operator|.
name|bus_generation
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_topo_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bus
argument_list|,
name|M_CAMXPT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|cam_et
modifier|*
name|xpt_alloc_target
parameter_list|(
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|,
name|target_id_t
name|target_id
parameter_list|)
block|{
name|struct
name|cam_et
modifier|*
name|target
decl_stmt|;
name|target
operator|=
operator|(
expr|struct
name|cam_et
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|target
argument_list|)
argument_list|,
name|M_CAMXPT
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|!=
name|NULL
condition|)
block|{
name|struct
name|cam_et
modifier|*
name|cur_target
decl_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|target
operator|->
name|ed_entries
argument_list|)
expr_stmt|;
name|target
operator|->
name|bus
operator|=
name|bus
expr_stmt|;
name|target
operator|->
name|target_id
operator|=
name|target_id
expr_stmt|;
name|target
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
name|target
operator|->
name|generation
operator|=
literal|0
expr_stmt|;
name|timevalclear
argument_list|(
operator|&
name|target
operator|->
name|last_reset
argument_list|)
expr_stmt|;
comment|/* 		 * Hold a reference to our parent bus so it 		 * will not go away before we do. 		 */
name|bus
operator|->
name|refcount
operator|++
expr_stmt|;
comment|/* Insertion sort into our bus's target list */
name|cur_target
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|bus
operator|->
name|et_entries
argument_list|)
expr_stmt|;
while|while
condition|(
name|cur_target
operator|!=
name|NULL
operator|&&
name|cur_target
operator|->
name|target_id
operator|<
name|target_id
condition|)
name|cur_target
operator|=
name|TAILQ_NEXT
argument_list|(
name|cur_target
argument_list|,
name|links
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_target
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_INSERT_BEFORE
argument_list|(
name|cur_target
argument_list|,
name|target
argument_list|,
name|links
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|bus
operator|->
name|et_entries
argument_list|,
name|target
argument_list|,
name|links
argument_list|)
expr_stmt|;
block|}
name|bus
operator|->
name|generation
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|target
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xpt_release_target
parameter_list|(
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|,
name|struct
name|cam_et
modifier|*
name|target
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|--
name|target
operator|->
name|refcount
operator|==
literal|0
operator|)
operator|&&
operator|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|target
operator|->
name|ed_entries
argument_list|)
operator|==
name|NULL
operator|)
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|bus
operator|->
name|et_entries
argument_list|,
name|target
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|bus
operator|->
name|generation
operator|++
expr_stmt|;
name|free
argument_list|(
name|target
argument_list|,
name|M_CAMXPT
argument_list|)
expr_stmt|;
name|xpt_release_bus
argument_list|(
name|bus
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|cam_ed
modifier|*
name|xpt_alloc_device
parameter_list|(
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|,
name|struct
name|cam_et
modifier|*
name|target
parameter_list|,
name|lun_id_t
name|lun_id
parameter_list|)
block|{
name|struct
name|cam_path
name|path
decl_stmt|;
name|struct
name|cam_ed
modifier|*
name|device
decl_stmt|;
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
if|if
condition|(
name|SIM_DEAD
argument_list|(
name|bus
operator|->
name|sim
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Make space for us in the device queue on our bus */
name|devq
operator|=
name|bus
operator|->
name|sim
operator|->
name|devq
expr_stmt|;
name|status
operator|=
name|cam_devq_resize
argument_list|(
name|devq
argument_list|,
name|devq
operator|->
name|alloc_queue
operator|.
name|array_size
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|device
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|device
operator|=
operator|(
expr|struct
name|cam_ed
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|device
argument_list|)
argument_list|,
name|M_CAMXPT
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|device
operator|!=
name|NULL
condition|)
block|{
name|struct
name|cam_ed
modifier|*
name|cur_device
decl_stmt|;
name|cam_init_pinfo
argument_list|(
operator|&
name|device
operator|->
name|alloc_ccb_entry
operator|.
name|pinfo
argument_list|)
expr_stmt|;
name|device
operator|->
name|alloc_ccb_entry
operator|.
name|device
operator|=
name|device
expr_stmt|;
name|cam_init_pinfo
argument_list|(
operator|&
name|device
operator|->
name|send_ccb_entry
operator|.
name|pinfo
argument_list|)
expr_stmt|;
name|device
operator|->
name|send_ccb_entry
operator|.
name|device
operator|=
name|device
expr_stmt|;
name|device
operator|->
name|target
operator|=
name|target
expr_stmt|;
name|device
operator|->
name|lun_id
operator|=
name|lun_id
expr_stmt|;
name|device
operator|->
name|sim
operator|=
name|bus
operator|->
name|sim
expr_stmt|;
comment|/* Initialize our queues */
if|if
condition|(
name|camq_init
argument_list|(
operator|&
name|device
operator|->
name|drvq
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|device
argument_list|,
name|M_CAMXPT
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|cam_ccbq_init
argument_list|(
operator|&
name|device
operator|->
name|ccbq
argument_list|,
name|bus
operator|->
name|sim
operator|->
name|max_dev_openings
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|camq_fini
argument_list|(
operator|&
name|device
operator|->
name|drvq
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|device
argument_list|,
name|M_CAMXPT
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|SLIST_INIT
argument_list|(
operator|&
name|device
operator|->
name|asyncs
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|device
operator|->
name|periphs
argument_list|)
expr_stmt|;
name|device
operator|->
name|generation
operator|=
literal|0
expr_stmt|;
name|device
operator|->
name|owner
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * Take the default quirk entry until we have inquiry 		 * data and can determine a better quirk to use. 		 */
name|device
operator|->
name|quirk
operator|=
operator|&
name|xpt_quirk_table
index|[
name|xpt_quirk_table_size
operator|-
literal|1
index|]
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|device
operator|->
name|inq_data
argument_list|,
sizeof|sizeof
argument_list|(
name|device
operator|->
name|inq_data
argument_list|)
argument_list|)
expr_stmt|;
name|device
operator|->
name|inq_flags
operator|=
literal|0
expr_stmt|;
name|device
operator|->
name|queue_flags
operator|=
literal|0
expr_stmt|;
name|device
operator|->
name|serial_num
operator|=
name|NULL
expr_stmt|;
name|device
operator|->
name|serial_num_len
operator|=
literal|0
expr_stmt|;
name|device
operator|->
name|qfrozen_cnt
operator|=
literal|0
expr_stmt|;
name|device
operator|->
name|flags
operator|=
name|CAM_DEV_UNCONFIGURED
expr_stmt|;
name|device
operator|->
name|tag_delay_count
operator|=
literal|0
expr_stmt|;
name|device
operator|->
name|tag_saved_openings
operator|=
literal|0
expr_stmt|;
name|device
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|bus
operator|->
name|sim
operator|->
name|flags
operator|&
name|CAM_SIM_MPSAFE
condition|)
name|callout_init_mtx
argument_list|(
operator|&
name|device
operator|->
name|callout
argument_list|,
name|bus
operator|->
name|sim
operator|->
name|mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|callout_init_mtx
argument_list|(
operator|&
name|device
operator|->
name|callout
argument_list|,
operator|&
name|Giant
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Hold a reference to our parent target so it 		 * will not go away before we do. 		 */
name|target
operator|->
name|refcount
operator|++
expr_stmt|;
comment|/* 		 * XXX should be limited by number of CCBs this bus can 		 * do. 		 */
name|bus
operator|->
name|sim
operator|->
name|max_ccbs
operator|+=
name|device
operator|->
name|ccbq
operator|.
name|devq_openings
expr_stmt|;
comment|/* Insertion sort into our target's device list */
name|cur_device
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|target
operator|->
name|ed_entries
argument_list|)
expr_stmt|;
while|while
condition|(
name|cur_device
operator|!=
name|NULL
operator|&&
name|cur_device
operator|->
name|lun_id
operator|<
name|lun_id
condition|)
name|cur_device
operator|=
name|TAILQ_NEXT
argument_list|(
name|cur_device
argument_list|,
name|links
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_device
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_INSERT_BEFORE
argument_list|(
name|cur_device
argument_list|,
name|device
argument_list|,
name|links
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|target
operator|->
name|ed_entries
argument_list|,
name|device
argument_list|,
name|links
argument_list|)
expr_stmt|;
block|}
name|target
operator|->
name|generation
operator|++
expr_stmt|;
if|if
condition|(
name|lun_id
operator|!=
name|CAM_LUN_WILDCARD
condition|)
block|{
name|xpt_compile_path
argument_list|(
operator|&
name|path
argument_list|,
name|NULL
argument_list|,
name|bus
operator|->
name|path_id
argument_list|,
name|target
operator|->
name|target_id
argument_list|,
name|lun_id
argument_list|)
expr_stmt|;
name|xpt_devise_transport
argument_list|(
operator|&
name|path
argument_list|)
expr_stmt|;
name|xpt_release_path
argument_list|(
operator|&
name|path
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|device
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xpt_release_device
parameter_list|(
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|,
name|struct
name|cam_et
modifier|*
name|target
parameter_list|,
name|struct
name|cam_ed
modifier|*
name|device
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|--
name|device
operator|->
name|refcount
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|device
operator|->
name|flags
operator|&
name|CAM_DEV_UNCONFIGURED
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
if|if
condition|(
name|device
operator|->
name|alloc_ccb_entry
operator|.
name|pinfo
operator|.
name|index
operator|!=
name|CAM_UNQUEUED_INDEX
operator|||
name|device
operator|->
name|send_ccb_entry
operator|.
name|pinfo
operator|.
name|index
operator|!=
name|CAM_UNQUEUED_INDEX
condition|)
name|panic
argument_list|(
literal|"Removing device while still queued for ccbs"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|device
operator|->
name|flags
operator|&
name|CAM_DEV_REL_TIMEOUT_PENDING
operator|)
operator|!=
literal|0
condition|)
name|callout_stop
argument_list|(
operator|&
name|device
operator|->
name|callout
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|target
operator|->
name|ed_entries
argument_list|,
name|device
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|target
operator|->
name|generation
operator|++
expr_stmt|;
name|bus
operator|->
name|sim
operator|->
name|max_ccbs
operator|-=
name|device
operator|->
name|ccbq
operator|.
name|devq_openings
expr_stmt|;
if|if
condition|(
operator|!
name|SIM_DEAD
argument_list|(
name|bus
operator|->
name|sim
argument_list|)
condition|)
block|{
comment|/* Release our slot in the devq */
name|devq
operator|=
name|bus
operator|->
name|sim
operator|->
name|devq
expr_stmt|;
name|cam_devq_resize
argument_list|(
name|devq
argument_list|,
name|devq
operator|->
name|alloc_queue
operator|.
name|array_size
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|camq_fini
argument_list|(
operator|&
name|device
operator|->
name|drvq
argument_list|)
expr_stmt|;
name|camq_fini
argument_list|(
operator|&
name|device
operator|->
name|ccbq
operator|.
name|queue
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|device
argument_list|,
name|M_CAMXPT
argument_list|)
expr_stmt|;
name|xpt_release_target
argument_list|(
name|bus
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|u_int32_t
name|xpt_dev_ccbq_resize
parameter_list|(
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|int
name|newopenings
parameter_list|)
block|{
name|int
name|diff
decl_stmt|;
name|int
name|result
decl_stmt|;
name|struct
name|cam_ed
modifier|*
name|dev
decl_stmt|;
name|dev
operator|=
name|path
operator|->
name|device
expr_stmt|;
name|diff
operator|=
name|newopenings
operator|-
operator|(
name|dev
operator|->
name|ccbq
operator|.
name|dev_active
operator|+
name|dev
operator|->
name|ccbq
operator|.
name|dev_openings
operator|)
expr_stmt|;
name|result
operator|=
name|cam_ccbq_resize
argument_list|(
operator|&
name|dev
operator|->
name|ccbq
argument_list|,
name|newopenings
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|CAM_REQ_CMP
operator|&&
operator|(
name|diff
operator|<
literal|0
operator|)
condition|)
block|{
name|dev
operator|->
name|flags
operator||=
name|CAM_DEV_RESIZE_QUEUE_NEEDED
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dev
operator|->
name|flags
operator|&
name|CAM_DEV_TAG_AFTER_COUNT
operator|)
operator|!=
literal|0
operator|||
operator|(
name|dev
operator|->
name|inq_flags
operator|&
name|SID_CmdQue
operator|)
operator|!=
literal|0
condition|)
name|dev
operator|->
name|tag_saved_openings
operator|=
name|newopenings
expr_stmt|;
comment|/* Adjust the global limit */
name|dev
operator|->
name|sim
operator|->
name|max_ccbs
operator|+=
name|diff
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|cam_eb
modifier|*
name|xpt_find_bus
parameter_list|(
name|path_id_t
name|path_id
parameter_list|)
block|{
name|struct
name|cam_eb
modifier|*
name|bus
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_topo_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|bus
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_busses
argument_list|)
init|;
name|bus
operator|!=
name|NULL
condition|;
name|bus
operator|=
name|TAILQ_NEXT
argument_list|(
name|bus
argument_list|,
name|links
argument_list|)
control|)
block|{
if|if
condition|(
name|bus
operator|->
name|path_id
operator|==
name|path_id
condition|)
block|{
name|bus
operator|->
name|refcount
operator|++
expr_stmt|;
break|break;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_topo_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|bus
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|cam_et
modifier|*
name|xpt_find_target
parameter_list|(
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|,
name|target_id_t
name|target_id
parameter_list|)
block|{
name|struct
name|cam_et
modifier|*
name|target
decl_stmt|;
for|for
control|(
name|target
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|bus
operator|->
name|et_entries
argument_list|)
init|;
name|target
operator|!=
name|NULL
condition|;
name|target
operator|=
name|TAILQ_NEXT
argument_list|(
name|target
argument_list|,
name|links
argument_list|)
control|)
block|{
if|if
condition|(
name|target
operator|->
name|target_id
operator|==
name|target_id
condition|)
block|{
name|target
operator|->
name|refcount
operator|++
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|target
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|cam_ed
modifier|*
name|xpt_find_device
parameter_list|(
name|struct
name|cam_et
modifier|*
name|target
parameter_list|,
name|lun_id_t
name|lun_id
parameter_list|)
block|{
name|struct
name|cam_ed
modifier|*
name|device
decl_stmt|;
for|for
control|(
name|device
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|target
operator|->
name|ed_entries
argument_list|)
init|;
name|device
operator|!=
name|NULL
condition|;
name|device
operator|=
name|TAILQ_NEXT
argument_list|(
name|device
argument_list|,
name|links
argument_list|)
control|)
block|{
if|if
condition|(
name|device
operator|->
name|lun_id
operator|==
name|lun_id
condition|)
block|{
name|device
operator|->
name|refcount
operator|++
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|device
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
block|{
name|union
name|ccb
modifier|*
name|request_ccb
decl_stmt|;
name|struct
name|ccb_pathinq
modifier|*
name|cpi
decl_stmt|;
name|int
name|counter
decl_stmt|;
block|}
name|xpt_scan_bus_info
typedef|;
end_typedef

begin_comment
comment|/*  * To start a scan, request_ccb is an XPT_SCAN_BUS ccb.  * As the scan progresses, xpt_scan_bus is used as the  * callback on completion function.  */
end_comment

begin_function
specifier|static
name|void
name|xpt_scan_bus
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|request_ccb
parameter_list|)
block|{
name|CAM_DEBUG
argument_list|(
name|request_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"xpt_scan_bus\n"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|request_ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_SCAN_BUS
case|:
block|{
name|xpt_scan_bus_info
modifier|*
name|scan_info
decl_stmt|;
name|union
name|ccb
modifier|*
name|work_ccb
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|u_int
name|max_target
decl_stmt|;
name|u_int
name|initiator_id
decl_stmt|;
comment|/* Find out the characteristics of the bus */
name|work_ccb
operator|=
name|xpt_alloc_ccb_nowait
argument_list|()
expr_stmt|;
if|if
condition|(
name|work_ccb
operator|==
name|NULL
condition|)
block|{
name|request_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|request_ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|xpt_setup_ccb
argument_list|(
operator|&
name|work_ccb
operator|->
name|ccb_h
argument_list|,
name|request_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|request_ccb
operator|->
name|ccb_h
operator|.
name|pinfo
operator|.
name|priority
argument_list|)
expr_stmt|;
name|work_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_PATH_INQ
expr_stmt|;
name|xpt_action
argument_list|(
name|work_ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|work_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|request_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|work_ccb
operator|->
name|ccb_h
operator|.
name|status
expr_stmt|;
name|xpt_free_ccb
argument_list|(
name|work_ccb
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|request_ccb
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|work_ccb
operator|->
name|cpi
operator|.
name|hba_misc
operator|&
name|PIM_NOINITIATOR
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Can't scan the bus on an adapter that 			 * cannot perform the initiator role. 			 */
name|request_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_free_ccb
argument_list|(
name|work_ccb
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|request_ccb
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Save some state for use while we probe for devices */
name|scan_info
operator|=
operator|(
name|xpt_scan_bus_info
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|xpt_scan_bus_info
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|scan_info
operator|->
name|request_ccb
operator|=
name|request_ccb
expr_stmt|;
name|scan_info
operator|->
name|cpi
operator|=
operator|&
name|work_ccb
operator|->
name|cpi
expr_stmt|;
comment|/* Cache on our stack so we can work asynchronously */
name|max_target
operator|=
name|scan_info
operator|->
name|cpi
operator|->
name|max_target
expr_stmt|;
name|initiator_id
operator|=
name|scan_info
operator|->
name|cpi
operator|->
name|initiator_id
expr_stmt|;
comment|/* 		 * We can scan all targets in parallel, or do it sequentially. 		 */
if|if
condition|(
name|scan_info
operator|->
name|cpi
operator|->
name|hba_misc
operator|&
name|PIM_SEQSCAN
condition|)
block|{
name|max_target
operator|=
literal|0
expr_stmt|;
name|scan_info
operator|->
name|counter
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|scan_info
operator|->
name|counter
operator|=
name|scan_info
operator|->
name|cpi
operator|->
name|max_target
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|scan_info
operator|->
name|cpi
operator|->
name|initiator_id
operator|<
name|scan_info
operator|->
name|counter
condition|)
block|{
name|scan_info
operator|->
name|counter
operator|--
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|max_target
condition|;
name|i
operator|++
control|)
block|{
name|cam_status
name|status
decl_stmt|;
if|if
condition|(
name|i
operator|==
name|initiator_id
condition|)
continue|continue;
name|status
operator|=
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
name|xpt_periph
argument_list|,
name|request_ccb
operator|->
name|ccb_h
operator|.
name|path_id
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"xpt_scan_bus: xpt_create_path failed"
literal|" with status %#x, bus scan halted\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|scan_info
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|request_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|status
expr_stmt|;
name|xpt_free_ccb
argument_list|(
name|work_ccb
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|request_ccb
argument_list|)
expr_stmt|;
break|break;
block|}
name|work_ccb
operator|=
name|xpt_alloc_ccb_nowait
argument_list|()
expr_stmt|;
if|if
condition|(
name|work_ccb
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|scan_info
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|request_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|request_ccb
argument_list|)
expr_stmt|;
break|break;
block|}
name|xpt_setup_ccb
argument_list|(
operator|&
name|work_ccb
operator|->
name|ccb_h
argument_list|,
name|path
argument_list|,
name|request_ccb
operator|->
name|ccb_h
operator|.
name|pinfo
operator|.
name|priority
argument_list|)
expr_stmt|;
name|work_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SCAN_LUN
expr_stmt|;
name|work_ccb
operator|->
name|ccb_h
operator|.
name|cbfcnp
operator|=
name|xpt_scan_bus
expr_stmt|;
name|work_ccb
operator|->
name|ccb_h
operator|.
name|ppriv_ptr0
operator|=
name|scan_info
expr_stmt|;
name|work_ccb
operator|->
name|crcn
operator|.
name|flags
operator|=
name|request_ccb
operator|->
name|crcn
operator|.
name|flags
expr_stmt|;
name|xpt_action
argument_list|(
name|work_ccb
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|XPT_SCAN_LUN
case|:
block|{
name|cam_status
name|status
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|xpt_scan_bus_info
modifier|*
name|scan_info
decl_stmt|;
name|path_id_t
name|path_id
decl_stmt|;
name|target_id_t
name|target_id
decl_stmt|;
name|lun_id_t
name|lun_id
decl_stmt|;
comment|/* Reuse the same CCB to query if a device was really found */
name|scan_info
operator|=
operator|(
name|xpt_scan_bus_info
operator|*
operator|)
name|request_ccb
operator|->
name|ccb_h
operator|.
name|ppriv_ptr0
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|request_ccb
operator|->
name|ccb_h
argument_list|,
name|request_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|request_ccb
operator|->
name|ccb_h
operator|.
name|pinfo
operator|.
name|priority
argument_list|)
expr_stmt|;
name|request_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_GDEV_TYPE
expr_stmt|;
name|path_id
operator|=
name|request_ccb
operator|->
name|ccb_h
operator|.
name|path_id
expr_stmt|;
name|target_id
operator|=
name|request_ccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|lun_id
operator|=
name|request_ccb
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
name|xpt_action
argument_list|(
name|request_ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|request_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|struct
name|cam_ed
modifier|*
name|device
decl_stmt|;
name|struct
name|cam_et
modifier|*
name|target
decl_stmt|;
name|int
name|phl
decl_stmt|;
comment|/* 			 * If we already probed lun 0 successfully, or 			 * we have additional configured luns on this 			 * target that might have "gone away", go onto 			 * the next lun. 			 */
name|target
operator|=
name|request_ccb
operator|->
name|ccb_h
operator|.
name|path
operator|->
name|target
expr_stmt|;
comment|/* 			 * We may touch devices that we don't 			 * hold references too, so ensure they 			 * don't disappear out from under us. 			 * The target above is referenced by the 			 * path in the request ccb. 			 */
name|phl
operator|=
literal|0
expr_stmt|;
name|device
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|target
operator|->
name|ed_entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|device
operator|!=
name|NULL
condition|)
block|{
name|phl
operator|=
name|CAN_SRCH_HI_SPARSE
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|device
operator|->
name|lun_id
operator|==
literal|0
condition|)
name|device
operator|=
name|TAILQ_NEXT
argument_list|(
name|device
argument_list|,
name|links
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|lun_id
operator|!=
literal|0
operator|)
operator|||
operator|(
name|device
operator|!=
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|lun_id
operator|<
operator|(
name|CAM_SCSI2_MAXLUN
operator|-
literal|1
operator|)
operator|||
name|phl
condition|)
name|lun_id
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|struct
name|cam_ed
modifier|*
name|device
decl_stmt|;
name|device
operator|=
name|request_ccb
operator|->
name|ccb_h
operator|.
name|path
operator|->
name|device
expr_stmt|;
if|if
condition|(
operator|(
name|device
operator|->
name|quirk
operator|->
name|quirks
operator|&
name|CAM_QUIRK_NOLUNS
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Try the next lun */
if|if
condition|(
name|lun_id
operator|<
operator|(
name|CAM_SCSI2_MAXLUN
operator|-
literal|1
operator|)
operator|||
name|CAN_SRCH_HI_DENSE
argument_list|(
name|device
argument_list|)
condition|)
name|lun_id
operator|++
expr_stmt|;
block|}
block|}
comment|/* 		 * Free the current request path- we're done with it. 		 */
name|xpt_free_path
argument_list|(
name|request_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
comment|/* 		 * Check to see if we scan any further luns. 		 */
if|if
condition|(
name|lun_id
operator|==
name|request_ccb
operator|->
name|ccb_h
operator|.
name|target_lun
operator|||
name|lun_id
operator|>
name|scan_info
operator|->
name|cpi
operator|->
name|max_lun
condition|)
block|{
name|int
name|done
decl_stmt|;
name|hop_again
label|:
name|done
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|scan_info
operator|->
name|cpi
operator|->
name|hba_misc
operator|&
name|PIM_SEQSCAN
condition|)
block|{
name|scan_info
operator|->
name|counter
operator|++
expr_stmt|;
if|if
condition|(
name|scan_info
operator|->
name|counter
operator|==
name|scan_info
operator|->
name|cpi
operator|->
name|initiator_id
condition|)
block|{
name|scan_info
operator|->
name|counter
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|scan_info
operator|->
name|counter
operator|>=
name|scan_info
operator|->
name|cpi
operator|->
name|max_target
operator|+
literal|1
condition|)
block|{
name|done
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|scan_info
operator|->
name|counter
operator|--
expr_stmt|;
if|if
condition|(
name|scan_info
operator|->
name|counter
operator|==
literal|0
condition|)
block|{
name|done
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|done
condition|)
block|{
name|xpt_free_ccb
argument_list|(
name|request_ccb
argument_list|)
expr_stmt|;
name|xpt_free_ccb
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|scan_info
operator|->
name|cpi
argument_list|)
expr_stmt|;
name|request_ccb
operator|=
name|scan_info
operator|->
name|request_ccb
expr_stmt|;
name|free
argument_list|(
name|scan_info
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|request_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|request_ccb
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|scan_info
operator|->
name|cpi
operator|->
name|hba_misc
operator|&
name|PIM_SEQSCAN
operator|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
name|status
operator|=
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
name|xpt_periph
argument_list|,
name|scan_info
operator|->
name|request_ccb
operator|->
name|ccb_h
operator|.
name|path_id
argument_list|,
name|scan_info
operator|->
name|counter
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"xpt_scan_bus: xpt_create_path failed"
literal|" with status %#x, bus scan halted\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|xpt_free_ccb
argument_list|(
name|request_ccb
argument_list|)
expr_stmt|;
name|xpt_free_ccb
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|scan_info
operator|->
name|cpi
argument_list|)
expr_stmt|;
name|request_ccb
operator|=
name|scan_info
operator|->
name|request_ccb
expr_stmt|;
name|free
argument_list|(
name|scan_info
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|request_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|status
expr_stmt|;
name|xpt_done
argument_list|(
name|request_ccb
argument_list|)
expr_stmt|;
break|break;
block|}
name|xpt_setup_ccb
argument_list|(
operator|&
name|request_ccb
operator|->
name|ccb_h
argument_list|,
name|path
argument_list|,
name|request_ccb
operator|->
name|ccb_h
operator|.
name|pinfo
operator|.
name|priority
argument_list|)
expr_stmt|;
name|request_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SCAN_LUN
expr_stmt|;
name|request_ccb
operator|->
name|ccb_h
operator|.
name|cbfcnp
operator|=
name|xpt_scan_bus
expr_stmt|;
name|request_ccb
operator|->
name|ccb_h
operator|.
name|ppriv_ptr0
operator|=
name|scan_info
expr_stmt|;
name|request_ccb
operator|->
name|crcn
operator|.
name|flags
operator|=
name|scan_info
operator|->
name|request_ccb
operator|->
name|crcn
operator|.
name|flags
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
name|xpt_periph
argument_list|,
name|path_id
argument_list|,
name|target_id
argument_list|,
name|lun_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"xpt_scan_bus: xpt_create_path failed "
literal|"with status %#x, halting LUN scan\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
goto|goto
name|hop_again
goto|;
block|}
name|xpt_setup_ccb
argument_list|(
operator|&
name|request_ccb
operator|->
name|ccb_h
argument_list|,
name|path
argument_list|,
name|request_ccb
operator|->
name|ccb_h
operator|.
name|pinfo
operator|.
name|priority
argument_list|)
expr_stmt|;
name|request_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SCAN_LUN
expr_stmt|;
name|request_ccb
operator|->
name|ccb_h
operator|.
name|cbfcnp
operator|=
name|xpt_scan_bus
expr_stmt|;
name|request_ccb
operator|->
name|ccb_h
operator|.
name|ppriv_ptr0
operator|=
name|scan_info
expr_stmt|;
name|request_ccb
operator|->
name|crcn
operator|.
name|flags
operator|=
name|scan_info
operator|->
name|request_ccb
operator|->
name|crcn
operator|.
name|flags
expr_stmt|;
block|}
name|xpt_action
argument_list|(
name|request_ccb
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
block|}
end_function

begin_typedef
typedef|typedef
enum|enum
block|{
name|PROBE_TUR
block|,
name|PROBE_INQUIRY
block|,
comment|/* this counts as DV0 for Basic Domain Validation */
name|PROBE_FULL_INQUIRY
block|,
name|PROBE_MODE_SENSE
block|,
name|PROBE_SERIAL_NUM
block|,
name|PROBE_TUR_FOR_NEGOTIATION
block|,
name|PROBE_INQUIRY_BASIC_DV1
block|,
name|PROBE_INQUIRY_BASIC_DV2
block|,
name|PROBE_DV_EXIT
block|}
name|probe_action
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|PROBE_INQUIRY_CKSUM
init|=
literal|0x01
block|,
name|PROBE_SERIAL_CKSUM
init|=
literal|0x02
block|,
name|PROBE_NO_ANNOUNCE
init|=
literal|0x04
block|}
name|probe_flags
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|ccb_hdr
argument_list|)
name|request_ccbs
expr_stmt|;
name|probe_action
name|action
decl_stmt|;
name|union
name|ccb
name|saved_ccb
decl_stmt|;
name|probe_flags
name|flags
decl_stmt|;
name|MD5_CTX
name|context
decl_stmt|;
name|u_int8_t
name|digest
index|[
literal|16
index|]
decl_stmt|;
block|}
name|probe_softc
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|xpt_scan_lun
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|cam_flags
name|flags
parameter_list|,
name|union
name|ccb
modifier|*
name|request_ccb
parameter_list|)
block|{
name|struct
name|ccb_pathinq
name|cpi
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|new_path
decl_stmt|;
name|struct
name|cam_periph
modifier|*
name|old_periph
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|request_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"xpt_scan_lun\n"
operator|)
argument_list|)
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|cpi
operator|.
name|ccb_h
argument_list|,
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|cpi
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_PATH_INQ
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|cpi
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpi
operator|.
name|ccb_h
operator|.
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
if|if
condition|(
name|request_ccb
operator|!=
name|NULL
condition|)
block|{
name|request_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|cpi
operator|.
name|ccb_h
operator|.
name|status
expr_stmt|;
name|xpt_done
argument_list|(
name|request_ccb
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
operator|(
name|cpi
operator|.
name|hba_misc
operator|&
name|PIM_NOINITIATOR
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Can't scan the bus on an adapter that 		 * cannot perform the initiator role. 		 */
if|if
condition|(
name|request_ccb
operator|!=
name|NULL
condition|)
block|{
name|request_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|request_ccb
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|request_ccb
operator|==
name|NULL
condition|)
block|{
name|request_ccb
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|union
name|ccb
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|request_ccb
operator|==
name|NULL
condition|)
block|{
name|xpt_print
argument_list|(
name|path
argument_list|,
literal|"xpt_scan_lun: can't allocate CCB, "
literal|"can't continue\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|new_path
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new_path
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_path
operator|==
name|NULL
condition|)
block|{
name|xpt_print
argument_list|(
name|path
argument_list|,
literal|"xpt_scan_lun: can't allocate path, "
literal|"can't continue\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|request_ccb
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return;
block|}
name|status
operator|=
name|xpt_compile_path
argument_list|(
name|new_path
argument_list|,
name|xpt_periph
argument_list|,
name|path
operator|->
name|bus
operator|->
name|path_id
argument_list|,
name|path
operator|->
name|target
operator|->
name|target_id
argument_list|,
name|path
operator|->
name|device
operator|->
name|lun_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_print
argument_list|(
name|path
argument_list|,
literal|"xpt_scan_lun: can't compile path, "
literal|"can't continue\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|request_ccb
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new_path
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return;
block|}
name|xpt_setup_ccb
argument_list|(
operator|&
name|request_ccb
operator|->
name|ccb_h
argument_list|,
name|new_path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|request_ccb
operator|->
name|ccb_h
operator|.
name|cbfcnp
operator|=
name|xptscandone
expr_stmt|;
name|request_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SCAN_LUN
expr_stmt|;
name|request_ccb
operator|->
name|crcn
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|old_periph
operator|=
name|cam_periph_find
argument_list|(
name|path
argument_list|,
literal|"probe"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|probe_softc
modifier|*
name|softc
decl_stmt|;
name|softc
operator|=
operator|(
name|probe_softc
operator|*
operator|)
name|old_periph
operator|->
name|softc
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|softc
operator|->
name|request_ccbs
argument_list|,
operator|&
name|request_ccb
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|cam_periph_alloc
argument_list|(
name|proberegister
argument_list|,
name|NULL
argument_list|,
name|probecleanup
argument_list|,
name|probestart
argument_list|,
literal|"probe"
argument_list|,
name|CAM_PERIPH_BIO
argument_list|,
name|request_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|request_ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_print
argument_list|(
name|path
argument_list|,
literal|"xpt_scan_lun: cam_alloc_periph "
literal|"returned an error, can't continue probe\n"
argument_list|)
expr_stmt|;
name|request_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|status
expr_stmt|;
name|xpt_done
argument_list|(
name|request_ccb
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xptscandone
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|done_ccb
parameter_list|)
block|{
name|xpt_release_path
argument_list|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|done_ccb
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|cam_status
name|proberegister
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|request_ccb
decl_stmt|;
comment|/* CCB representing the probe request */
name|cam_status
name|status
decl_stmt|;
name|probe_softc
modifier|*
name|softc
decl_stmt|;
name|request_ccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"proberegister: periph was NULL!!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
if|if
condition|(
name|request_ccb
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"proberegister: no probe CCB, "
literal|"can't register device\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
name|softc
operator|=
operator|(
name|probe_softc
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|softc
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"proberegister: Unable to probe new device. "
literal|"Unable to allocate softc\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
name|TAILQ_INIT
argument_list|(
operator|&
name|softc
operator|->
name|request_ccbs
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|softc
operator|->
name|request_ccbs
argument_list|,
operator|&
name|request_ccb
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|softc
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|periph
operator|->
name|softc
operator|=
name|softc
expr_stmt|;
name|status
operator|=
name|cam_periph_acquire
argument_list|(
name|periph
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
return|return
operator|(
name|status
operator|)
return|;
block|}
comment|/* 	 * Ensure we've waited at least a bus settle 	 * delay before attempting to probe the device. 	 * For HBAs that don't do bus resets, this won't make a difference. 	 */
name|cam_periph_freeze_after_event
argument_list|(
name|periph
argument_list|,
operator|&
name|periph
operator|->
name|path
operator|->
name|bus
operator|->
name|last_reset
argument_list|,
name|scsi_delay
argument_list|)
expr_stmt|;
name|probeschedule
argument_list|(
name|periph
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|probeschedule
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|struct
name|ccb_pathinq
name|cpi
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|probe_softc
modifier|*
name|softc
decl_stmt|;
name|softc
operator|=
operator|(
name|probe_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|ccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|TAILQ_FIRST
argument_list|(
operator|&
name|softc
operator|->
name|request_ccbs
argument_list|)
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|cpi
operator|.
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|cpi
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_PATH_INQ
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|cpi
argument_list|)
expr_stmt|;
comment|/* 	 * If a device has gone away and another device, or the same one, 	 * is back in the same place, it should have a unit attention 	 * condition pending.  It will not report the unit attention in 	 * response to an inquiry, which may leave invalid transfer 	 * negotiations in effect.  The TUR will reveal the unit attention 	 * condition.  Only send the TUR for lun 0, since some devices  	 * will get confused by commands other than inquiry to non-existent 	 * luns.  If you think a device has gone away start your scan from 	 * lun 0.  This will insure that any bogus transfer settings are 	 * invalidated. 	 * 	 * If we haven't seen the device before and the controller supports 	 * some kind of transfer negotiation, negotiate with the first 	 * sent command if no bus reset was performed at startup.  This 	 * ensures that the device is not confused by transfer negotiation 	 * settings left over by loader or BIOS action. 	 */
if|if
condition|(
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
operator|->
name|device
operator|->
name|flags
operator|&
name|CAM_DEV_UNCONFIGURED
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
operator|==
literal|0
operator|)
condition|)
block|{
name|softc
operator|->
name|action
operator|=
name|PROBE_TUR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|cpi
operator|.
name|hba_inquiry
operator|&
operator|(
name|PI_WIDE_32
operator||
name|PI_WIDE_16
operator||
name|PI_SDTR_ABLE
operator|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|cpi
operator|.
name|hba_misc
operator|&
name|PIM_NOBUSRESET
operator|)
operator|!=
literal|0
condition|)
block|{
name|proberequestdefaultnegotiation
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|softc
operator|->
name|action
operator|=
name|PROBE_INQUIRY
expr_stmt|;
block|}
else|else
block|{
name|softc
operator|->
name|action
operator|=
name|PROBE_INQUIRY
expr_stmt|;
block|}
if|if
condition|(
name|ccb
operator|->
name|crcn
operator|.
name|flags
operator|&
name|CAM_EXPECT_INQ_CHANGE
condition|)
name|softc
operator|->
name|flags
operator||=
name|PROBE_NO_ANNOUNCE
expr_stmt|;
else|else
name|softc
operator|->
name|flags
operator|&=
operator|~
name|PROBE_NO_ANNOUNCE
expr_stmt|;
name|xpt_schedule
argument_list|(
name|periph
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|pinfo
operator|.
name|priority
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|probestart
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|start_ccb
parameter_list|)
block|{
comment|/* Probe the device that our peripheral driver points to */
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|probe_softc
modifier|*
name|softc
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|start_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"probestart\n"
operator|)
argument_list|)
expr_stmt|;
name|softc
operator|=
operator|(
name|probe_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|csio
operator|=
operator|&
name|start_ccb
operator|->
name|csio
expr_stmt|;
switch|switch
condition|(
name|softc
operator|->
name|action
condition|)
block|{
case|case
name|PROBE_TUR
case|:
case|case
name|PROBE_TUR_FOR_NEGOTIATION
case|:
case|case
name|PROBE_DV_EXIT
case|:
block|{
name|scsi_test_unit_ready
argument_list|(
name|csio
argument_list|,
comment|/*retries*/
literal|4
argument_list|,
name|probedone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
comment|/*timeout*/
literal|60000
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|PROBE_INQUIRY
case|:
case|case
name|PROBE_FULL_INQUIRY
case|:
case|case
name|PROBE_INQUIRY_BASIC_DV1
case|:
case|case
name|PROBE_INQUIRY_BASIC_DV2
case|:
block|{
name|u_int
name|inquiry_len
decl_stmt|;
name|struct
name|scsi_inquiry_data
modifier|*
name|inq_buf
decl_stmt|;
name|inq_buf
operator|=
operator|&
name|periph
operator|->
name|path
operator|->
name|device
operator|->
name|inq_data
expr_stmt|;
comment|/* 		 * If the device is currently configured, we calculate an 		 * MD5 checksum of the inquiry data, and if the serial number 		 * length is greater than 0, add the serial number data 		 * into the checksum as well.  Once the inquiry and the 		 * serial number check finish, we attempt to figure out 		 * whether we still have the same device. 		 */
if|if
condition|(
operator|(
name|periph
operator|->
name|path
operator|->
name|device
operator|->
name|flags
operator|&
name|CAM_DEV_UNCONFIGURED
operator|)
operator|==
literal|0
condition|)
block|{
name|MD5Init
argument_list|(
operator|&
name|softc
operator|->
name|context
argument_list|)
expr_stmt|;
name|MD5Update
argument_list|(
operator|&
name|softc
operator|->
name|context
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|inq_buf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_inquiry_data
argument_list|)
argument_list|)
expr_stmt|;
name|softc
operator|->
name|flags
operator||=
name|PROBE_INQUIRY_CKSUM
expr_stmt|;
if|if
condition|(
name|periph
operator|->
name|path
operator|->
name|device
operator|->
name|serial_num_len
operator|>
literal|0
condition|)
block|{
name|MD5Update
argument_list|(
operator|&
name|softc
operator|->
name|context
argument_list|,
name|periph
operator|->
name|path
operator|->
name|device
operator|->
name|serial_num
argument_list|,
name|periph
operator|->
name|path
operator|->
name|device
operator|->
name|serial_num_len
argument_list|)
expr_stmt|;
name|softc
operator|->
name|flags
operator||=
name|PROBE_SERIAL_CKSUM
expr_stmt|;
block|}
name|MD5Final
argument_list|(
name|softc
operator|->
name|digest
argument_list|,
operator|&
name|softc
operator|->
name|context
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|softc
operator|->
name|action
operator|==
name|PROBE_INQUIRY
condition|)
name|inquiry_len
operator|=
name|SHORT_INQUIRY_LENGTH
expr_stmt|;
else|else
name|inquiry_len
operator|=
name|SID_ADDITIONAL_LENGTH
argument_list|(
name|inq_buf
argument_list|)
expr_stmt|;
comment|/* 		 * Some parallel SCSI devices fail to send an 		 * ignore wide residue message when dealing with 		 * odd length inquiry requests.  Round up to be 		 * safe. 		 */
name|inquiry_len
operator|=
name|roundup2
argument_list|(
name|inquiry_len
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|action
operator|==
name|PROBE_INQUIRY_BASIC_DV1
operator|||
name|softc
operator|->
name|action
operator|==
name|PROBE_INQUIRY_BASIC_DV2
condition|)
block|{
name|inq_buf
operator|=
name|malloc
argument_list|(
name|inquiry_len
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inq_buf
operator|==
name|NULL
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"malloc failure- skipping Basic"
literal|"Domain Validation\n"
argument_list|)
expr_stmt|;
name|softc
operator|->
name|action
operator|=
name|PROBE_DV_EXIT
expr_stmt|;
name|scsi_test_unit_ready
argument_list|(
name|csio
argument_list|,
comment|/*retries*/
literal|4
argument_list|,
name|probedone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
comment|/*timeout*/
literal|60000
argument_list|)
expr_stmt|;
break|break;
block|}
name|scsi_inquiry
argument_list|(
name|csio
argument_list|,
comment|/*retries*/
literal|4
argument_list|,
name|probedone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
name|inq_buf
argument_list|,
name|inquiry_len
argument_list|,
comment|/*evpd*/
name|FALSE
argument_list|,
comment|/*page_code*/
literal|0
argument_list|,
name|SSD_MIN_SIZE
argument_list|,
comment|/*timeout*/
literal|60
operator|*
literal|1000
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|PROBE_MODE_SENSE
case|:
block|{
name|void
modifier|*
name|mode_buf
decl_stmt|;
name|int
name|mode_buf_len
decl_stmt|;
name|mode_buf_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_mode_header_6
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_mode_blk_desc
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_control_page
argument_list|)
expr_stmt|;
name|mode_buf
operator|=
name|malloc
argument_list|(
name|mode_buf_len
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode_buf
operator|!=
name|NULL
condition|)
block|{
name|scsi_mode_sense
argument_list|(
name|csio
argument_list|,
comment|/*retries*/
literal|4
argument_list|,
name|probedone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*dbd*/
name|FALSE
argument_list|,
name|SMS_PAGE_CTRL_CURRENT
argument_list|,
name|SMS_CONTROL_MODE_PAGE
argument_list|,
name|mode_buf
argument_list|,
name|mode_buf_len
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
comment|/*timeout*/
literal|60000
argument_list|)
expr_stmt|;
break|break;
block|}
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"Unable to mode sense control page - "
literal|"malloc failure\n"
argument_list|)
expr_stmt|;
name|softc
operator|->
name|action
operator|=
name|PROBE_SERIAL_NUM
expr_stmt|;
block|}
comment|/* FALLTHROUGH */
case|case
name|PROBE_SERIAL_NUM
case|:
block|{
name|struct
name|scsi_vpd_unit_serial_number
modifier|*
name|serial_buf
decl_stmt|;
name|struct
name|cam_ed
modifier|*
name|device
decl_stmt|;
name|serial_buf
operator|=
name|NULL
expr_stmt|;
name|device
operator|=
name|periph
operator|->
name|path
operator|->
name|device
expr_stmt|;
name|device
operator|->
name|serial_num
operator|=
name|NULL
expr_stmt|;
name|device
operator|->
name|serial_num_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|device
operator|->
name|quirk
operator|->
name|quirks
operator|&
name|CAM_QUIRK_NOSERIAL
operator|)
operator|==
literal|0
condition|)
name|serial_buf
operator|=
operator|(
expr|struct
name|scsi_vpd_unit_serial_number
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|serial_buf
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|serial_buf
operator|!=
name|NULL
condition|)
block|{
name|scsi_inquiry
argument_list|(
name|csio
argument_list|,
comment|/*retries*/
literal|4
argument_list|,
name|probedone
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
name|serial_buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|serial_buf
argument_list|)
argument_list|,
comment|/*evpd*/
name|TRUE
argument_list|,
name|SVPD_UNIT_SERIAL_NUMBER
argument_list|,
name|SSD_MIN_SIZE
argument_list|,
comment|/*timeout*/
literal|60
operator|*
literal|1000
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * We'll have to do without, let our probedone 		 * routine finish up for us. 		 */
name|start_ccb
operator|->
name|csio
operator|.
name|data_ptr
operator|=
name|NULL
expr_stmt|;
name|probedone
argument_list|(
name|periph
argument_list|,
name|start_ccb
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|xpt_action
argument_list|(
name|start_ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|proberequestdefaultnegotiation
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|struct
name|ccb_trans_settings
name|cts
decl_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|cts
operator|.
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|cts
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_GET_TRAN_SETTINGS
expr_stmt|;
name|cts
operator|.
name|type
operator|=
name|CTS_TYPE_USER_SETTINGS
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|cts
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cts
operator|.
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
return|return;
block|}
name|cts
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SET_TRAN_SETTINGS
expr_stmt|;
name|cts
operator|.
name|type
operator|=
name|CTS_TYPE_CURRENT_SETTINGS
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|cts
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Backoff Negotiation Code- only pertinent for SPI devices.  */
end_comment

begin_function
specifier|static
name|int
name|proberequestbackoff
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|struct
name|cam_ed
modifier|*
name|device
parameter_list|)
block|{
name|struct
name|ccb_trans_settings
name|cts
decl_stmt|;
name|struct
name|ccb_trans_settings_spi
modifier|*
name|spi
decl_stmt|;
name|memset
argument_list|(
operator|&
name|cts
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cts
argument_list|)
argument_list|)
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|cts
operator|.
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|cts
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_GET_TRAN_SETTINGS
expr_stmt|;
name|cts
operator|.
name|type
operator|=
name|CTS_TYPE_CURRENT_SETTINGS
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|cts
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cts
operator|.
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"failed to get current device settings\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|cts
operator|.
name|transport
operator|!=
name|XPORT_SPI
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"not SPI transport\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|spi
operator|=
operator|&
name|cts
operator|.
name|xport_specific
operator|.
name|spi
expr_stmt|;
comment|/* 	 * We cannot renegotiate sync rate if we don't have one. 	 */
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_SYNC_RATE
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"no sync rate known\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * We'll assert that we don't have to touch PPR options- the 	 * SIM will see what we do with period and offset and adjust 	 * the PPR options as appropriate. 	 */
comment|/* 	 * A sync rate with unknown or zero offset is nonsensical. 	 * A sync period of zero means Async. 	 */
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_SYNC_OFFSET
operator|)
operator|==
literal|0
operator|||
name|spi
operator|->
name|sync_offset
operator|==
literal|0
operator|||
name|spi
operator|->
name|sync_period
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
block|{
name|xpt_print
argument_list|(
name|periph
operator|->
name|path
argument_list|,
literal|"no sync rate available\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|device
operator|->
name|flags
operator|&
name|CAM_DEV_DV_HIT_BOTTOM
condition|)
block|{
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_INFO
argument_list|,
operator|(
literal|"hit async: giving up on DV\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Jump sync_period up by one, but stop at 5MHz and fall back to Async. 	 * We don't try to remember 'last' settings to see if the SIM actually 	 * gets into the speed we want to set. We check on the SIM telling 	 * us that a requested speed is bad, but otherwise don't try and 	 * check the speed due to the asynchronous and handshake nature 	 * of speed setting. 	 */
name|spi
operator|->
name|valid
operator|=
name|CTS_SPI_VALID_SYNC_RATE
operator||
name|CTS_SPI_VALID_SYNC_OFFSET
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|spi
operator|->
name|sync_period
operator|++
expr_stmt|;
if|if
condition|(
name|spi
operator|->
name|sync_period
operator|>=
literal|0xf
condition|)
block|{
name|spi
operator|->
name|sync_period
operator|=
literal|0
expr_stmt|;
name|spi
operator|->
name|sync_offset
operator|=
literal|0
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_INFO
argument_list|,
operator|(
literal|"setting to async for DV\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 			 * Once we hit async, we don't want to try 			 * any more settings. 			 */
name|device
operator|->
name|flags
operator||=
name|CAM_DEV_DV_HIT_BOTTOM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bootverbose
condition|)
block|{
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_INFO
argument_list|,
operator|(
literal|"DV: period 0x%x\n"
operator|,
name|spi
operator|->
name|sync_period
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"setting period to 0x%x\n"
argument_list|,
name|spi
operator|->
name|sync_period
argument_list|)
expr_stmt|;
block|}
name|cts
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SET_TRAN_SETTINGS
expr_stmt|;
name|cts
operator|.
name|type
operator|=
name|CTS_TYPE_CURRENT_SETTINGS
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|cts
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cts
operator|.
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_CMP
condition|)
block|{
break|break;
block|}
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_INFO
argument_list|,
operator|(
literal|"DV: failed to set period 0x%x\n"
operator|,
name|spi
operator|->
name|sync_period
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|spi
operator|->
name|sync_period
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|probedone
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|done_ccb
parameter_list|)
block|{
name|probe_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|u_int32_t
name|priority
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"probedone\n"
operator|)
argument_list|)
expr_stmt|;
name|softc
operator|=
operator|(
name|probe_softc
operator|*
operator|)
name|periph
operator|->
name|softc
expr_stmt|;
name|path
operator|=
name|done_ccb
operator|->
name|ccb_h
operator|.
name|path
expr_stmt|;
name|priority
operator|=
name|done_ccb
operator|->
name|ccb_h
operator|.
name|pinfo
operator|.
name|priority
expr_stmt|;
switch|switch
condition|(
name|softc
operator|->
name|action
condition|)
block|{
case|case
name|PROBE_TUR
case|:
block|{
if|if
condition|(
operator|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
if|if
condition|(
name|cam_periph_error
argument_list|(
name|done_ccb
argument_list|,
literal|0
argument_list|,
name|SF_NO_PRINT
argument_list|,
name|NULL
argument_list|)
operator|==
name|ERESTART
condition|)
return|return;
elseif|else
if|if
condition|(
operator|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|!=
literal|0
condition|)
comment|/* Don't wedge the queue */
name|xpt_release_devq
argument_list|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*count*/
literal|1
argument_list|,
comment|/*run_queue*/
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|softc
operator|->
name|action
operator|=
name|PROBE_INQUIRY
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
name|xpt_schedule
argument_list|(
name|periph
argument_list|,
name|priority
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|PROBE_INQUIRY
case|:
case|case
name|PROBE_FULL_INQUIRY
case|:
block|{
if|if
condition|(
operator|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_CMP
condition|)
block|{
name|struct
name|scsi_inquiry_data
modifier|*
name|inq_buf
decl_stmt|;
name|u_int8_t
name|periph_qual
decl_stmt|;
name|path
operator|->
name|device
operator|->
name|flags
operator||=
name|CAM_DEV_INQUIRY_DATA_VALID
expr_stmt|;
name|inq_buf
operator|=
operator|&
name|path
operator|->
name|device
operator|->
name|inq_data
expr_stmt|;
name|periph_qual
operator|=
name|SID_QUAL
argument_list|(
name|inq_buf
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|periph_qual
condition|)
block|{
case|case
name|SID_QUAL_LU_CONNECTED
case|:
block|{
name|u_int8_t
name|len
decl_stmt|;
comment|/* 				 * We conservatively request only 				 * SHORT_INQUIRY_LEN bytes of inquiry 				 * information during our first try 				 * at sending an INQUIRY. If the device 				 * has more information to give, 				 * perform a second request specifying 				 * the amount of information the device 				 * is willing to give. 				 */
name|len
operator|=
name|inq_buf
operator|->
name|additional_length
operator|+
name|offsetof
argument_list|(
expr|struct
name|scsi_inquiry_data
argument_list|,
name|additional_length
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|action
operator|==
name|PROBE_INQUIRY
operator|&&
name|len
operator|>
name|SHORT_INQUIRY_LENGTH
condition|)
block|{
name|softc
operator|->
name|action
operator|=
name|PROBE_FULL_INQUIRY
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
name|xpt_schedule
argument_list|(
name|periph
argument_list|,
name|priority
argument_list|)
expr_stmt|;
return|return;
block|}
name|xpt_find_quirk
argument_list|(
name|path
operator|->
name|device
argument_list|)
expr_stmt|;
name|xpt_devise_transport
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|INQ_DATA_TQ_ENABLED
argument_list|(
name|inq_buf
argument_list|)
condition|)
name|softc
operator|->
name|action
operator|=
name|PROBE_MODE_SENSE
expr_stmt|;
else|else
name|softc
operator|->
name|action
operator|=
name|PROBE_SERIAL_NUM
expr_stmt|;
name|path
operator|->
name|device
operator|->
name|flags
operator|&=
operator|~
name|CAM_DEV_UNCONFIGURED
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
name|xpt_schedule
argument_list|(
name|periph
argument_list|,
name|priority
argument_list|)
expr_stmt|;
return|return;
block|}
default|default:
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|cam_periph_error
argument_list|(
name|done_ccb
argument_list|,
literal|0
argument_list|,
name|done_ccb
operator|->
name|ccb_h
operator|.
name|target_lun
operator|>
literal|0
condition|?
name|SF_RETRY_UA
operator||
name|SF_QUIET_IR
else|:
name|SF_RETRY_UA
argument_list|,
operator|&
name|softc
operator|->
name|saved_ccb
argument_list|)
operator|==
name|ERESTART
condition|)
block|{
return|return;
block|}
elseif|else
if|if
condition|(
operator|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Don't wedge the queue */
name|xpt_release_devq
argument_list|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*count*/
literal|1
argument_list|,
comment|/*run_queue*/
name|TRUE
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If we get to this point, we got an error status back 		 * from the inquiry and the error status doesn't require 		 * automatically retrying the command.  Therefore, the 		 * inquiry failed.  If we had inquiry information before 		 * for this device, but this latest inquiry command failed, 		 * the device has probably gone away.  If this device isn't 		 * already marked unconfigured, notify the peripheral 		 * drivers that this device is no more. 		 */
if|if
condition|(
operator|(
name|path
operator|->
name|device
operator|->
name|flags
operator|&
name|CAM_DEV_UNCONFIGURED
operator|)
operator|==
literal|0
condition|)
comment|/* Send the async notification. */
name|xpt_async
argument_list|(
name|AC_LOST_DEVICE
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|PROBE_MODE_SENSE
case|:
block|{
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|struct
name|scsi_mode_header_6
modifier|*
name|mode_hdr
decl_stmt|;
name|csio
operator|=
operator|&
name|done_ccb
operator|->
name|csio
expr_stmt|;
name|mode_hdr
operator|=
operator|(
expr|struct
name|scsi_mode_header_6
operator|*
operator|)
name|csio
operator|->
name|data_ptr
expr_stmt|;
if|if
condition|(
operator|(
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_CMP
condition|)
block|{
name|struct
name|scsi_control_page
modifier|*
name|page
decl_stmt|;
name|u_int8_t
modifier|*
name|offset
decl_stmt|;
name|offset
operator|=
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|mode_hdr
index|[
literal|1
index|]
operator|)
operator|+
name|mode_hdr
operator|->
name|blk_desc_len
expr_stmt|;
name|page
operator|=
operator|(
expr|struct
name|scsi_control_page
operator|*
operator|)
name|offset
expr_stmt|;
name|path
operator|->
name|device
operator|->
name|queue_flags
operator|=
name|page
operator|->
name|queue_flags
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cam_periph_error
argument_list|(
name|done_ccb
argument_list|,
literal|0
argument_list|,
name|SF_RETRY_UA
operator||
name|SF_NO_PRINT
argument_list|,
operator|&
name|softc
operator|->
name|saved_ccb
argument_list|)
operator|==
name|ERESTART
condition|)
block|{
return|return;
block|}
elseif|else
if|if
condition|(
operator|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Don't wedge the queue */
name|xpt_release_devq
argument_list|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*count*/
literal|1
argument_list|,
comment|/*run_queue*/
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|xpt_release_ccb
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mode_hdr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|softc
operator|->
name|action
operator|=
name|PROBE_SERIAL_NUM
expr_stmt|;
name|xpt_schedule
argument_list|(
name|periph
argument_list|,
name|priority
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|PROBE_SERIAL_NUM
case|:
block|{
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|struct
name|scsi_vpd_unit_serial_number
modifier|*
name|serial_buf
decl_stmt|;
name|u_int32_t
name|priority
decl_stmt|;
name|int
name|changed
decl_stmt|;
name|int
name|have_serialnum
decl_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
name|have_serialnum
operator|=
literal|0
expr_stmt|;
name|csio
operator|=
operator|&
name|done_ccb
operator|->
name|csio
expr_stmt|;
name|priority
operator|=
name|done_ccb
operator|->
name|ccb_h
operator|.
name|pinfo
operator|.
name|priority
expr_stmt|;
name|serial_buf
operator|=
operator|(
expr|struct
name|scsi_vpd_unit_serial_number
operator|*
operator|)
name|csio
operator|->
name|data_ptr
expr_stmt|;
comment|/* Clean up from previous instance of this device */
if|if
condition|(
name|path
operator|->
name|device
operator|->
name|serial_num
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|path
operator|->
name|device
operator|->
name|serial_num
argument_list|,
name|M_CAMXPT
argument_list|)
expr_stmt|;
name|path
operator|->
name|device
operator|->
name|serial_num
operator|=
name|NULL
expr_stmt|;
name|path
operator|->
name|device
operator|->
name|serial_num_len
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|serial_buf
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Don't process the command as it was never sent 			 */
block|}
elseif|else
if|if
condition|(
operator|(
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_CMP
operator|&&
operator|(
name|serial_buf
operator|->
name|length
operator|>
literal|0
operator|)
condition|)
block|{
name|have_serialnum
operator|=
literal|1
expr_stmt|;
name|path
operator|->
name|device
operator|->
name|serial_num
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|serial_buf
operator|->
name|length
operator|+
literal|1
operator|)
argument_list|,
name|M_CAMXPT
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|->
name|device
operator|->
name|serial_num
operator|!=
name|NULL
condition|)
block|{
name|bcopy
argument_list|(
name|serial_buf
operator|->
name|serial_num
argument_list|,
name|path
operator|->
name|device
operator|->
name|serial_num
argument_list|,
name|serial_buf
operator|->
name|length
argument_list|)
expr_stmt|;
name|path
operator|->
name|device
operator|->
name|serial_num_len
operator|=
name|serial_buf
operator|->
name|length
expr_stmt|;
name|path
operator|->
name|device
operator|->
name|serial_num
index|[
name|serial_buf
operator|->
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|cam_periph_error
argument_list|(
name|done_ccb
argument_list|,
literal|0
argument_list|,
name|SF_RETRY_UA
operator||
name|SF_NO_PRINT
argument_list|,
operator|&
name|softc
operator|->
name|saved_ccb
argument_list|)
operator|==
name|ERESTART
condition|)
block|{
return|return;
block|}
elseif|else
if|if
condition|(
operator|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Don't wedge the queue */
name|xpt_release_devq
argument_list|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*count*/
literal|1
argument_list|,
comment|/*run_queue*/
name|TRUE
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Let's see if we have seen this device before. 		 */
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|PROBE_INQUIRY_CKSUM
operator|)
operator|!=
literal|0
condition|)
block|{
name|MD5_CTX
name|context
decl_stmt|;
name|u_int8_t
name|digest
index|[
literal|16
index|]
decl_stmt|;
name|MD5Init
argument_list|(
operator|&
name|context
argument_list|)
expr_stmt|;
name|MD5Update
argument_list|(
operator|&
name|context
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|path
operator|->
name|device
operator|->
name|inq_data
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_inquiry_data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_serialnum
condition|)
name|MD5Update
argument_list|(
operator|&
name|context
argument_list|,
name|serial_buf
operator|->
name|serial_num
argument_list|,
name|serial_buf
operator|->
name|length
argument_list|)
expr_stmt|;
name|MD5Final
argument_list|(
name|digest
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|softc
operator|->
name|digest
argument_list|,
name|digest
argument_list|,
literal|16
argument_list|)
operator|==
literal|0
condition|)
name|changed
operator|=
literal|0
expr_stmt|;
comment|/* 			 * XXX Do we need to do a TUR in order to ensure 			 *     that the device really hasn't changed??? 			 */
if|if
condition|(
operator|(
name|changed
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|PROBE_NO_ANNOUNCE
operator|)
operator|==
literal|0
operator|)
condition|)
name|xpt_async
argument_list|(
name|AC_LOST_DEVICE
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|serial_buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|serial_buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|changed
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Now that we have all the necessary 			 * information to safely perform transfer 			 * negotiations... Controllers don't perform 			 * any negotiation or tagged queuing until 			 * after the first XPT_SET_TRAN_SETTINGS ccb is 			 * received.  So, on a new device, just retrieve 			 * the user settings, and set them as the current 			 * settings to set the device up. 			 */
name|proberequestdefaultnegotiation
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
comment|/* 			 * Perform a TUR to allow the controller to 			 * perform any necessary transfer negotiation. 			 */
name|softc
operator|->
name|action
operator|=
name|PROBE_TUR_FOR_NEGOTIATION
expr_stmt|;
name|xpt_schedule
argument_list|(
name|periph
argument_list|,
name|priority
argument_list|)
expr_stmt|;
return|return;
block|}
name|xpt_release_ccb
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|PROBE_TUR_FOR_NEGOTIATION
case|:
case|case
name|PROBE_DV_EXIT
case|:
if|if
condition|(
operator|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Don't wedge the queue */
name|xpt_release_devq
argument_list|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*count*/
literal|1
argument_list|,
comment|/*run_queue*/
name|TRUE
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Do Domain Validation for lun 0 on devices that claim 		 * to support Synchronous Transfer modes. 		 */
if|if
condition|(
name|softc
operator|->
name|action
operator|==
name|PROBE_TUR_FOR_NEGOTIATION
operator|&&
name|done_ccb
operator|->
name|ccb_h
operator|.
name|target_lun
operator|==
literal|0
operator|&&
operator|(
name|path
operator|->
name|device
operator|->
name|inq_data
operator|.
name|flags
operator|&
name|SID_Sync
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|path
operator|->
name|device
operator|->
name|flags
operator|&
name|CAM_DEV_IN_DV
operator|)
operator|==
literal|0
condition|)
block|{
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_INFO
argument_list|,
operator|(
literal|"Begin Domain Validation\n"
operator|)
argument_list|)
expr_stmt|;
name|path
operator|->
name|device
operator|->
name|flags
operator||=
name|CAM_DEV_IN_DV
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
name|softc
operator|->
name|action
operator|=
name|PROBE_INQUIRY_BASIC_DV1
expr_stmt|;
name|xpt_schedule
argument_list|(
name|periph
argument_list|,
name|priority
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|softc
operator|->
name|action
operator|==
name|PROBE_DV_EXIT
condition|)
block|{
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_INFO
argument_list|,
operator|(
literal|"Leave Domain Validation\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|path
operator|->
name|device
operator|->
name|flags
operator|&=
operator|~
operator|(
name|CAM_DEV_UNCONFIGURED
operator||
name|CAM_DEV_IN_DV
operator||
name|CAM_DEV_DV_HIT_BOTTOM
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|PROBE_NO_ANNOUNCE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Inform the XPT that a new device has been found */
name|done_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_GDEV_TYPE
expr_stmt|;
name|xpt_action
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
name|xpt_async
argument_list|(
name|AC_FOUND_DEVICE
argument_list|,
name|done_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|done_ccb
argument_list|)
expr_stmt|;
block|}
name|xpt_release_ccb
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROBE_INQUIRY_BASIC_DV1
case|:
case|case
name|PROBE_INQUIRY_BASIC_DV2
case|:
block|{
name|struct
name|scsi_inquiry_data
modifier|*
name|nbuf
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
if|if
condition|(
operator|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Don't wedge the queue */
name|xpt_release_devq
argument_list|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*count*/
literal|1
argument_list|,
comment|/*run_queue*/
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|csio
operator|=
operator|&
name|done_ccb
operator|->
name|csio
expr_stmt|;
name|nbuf
operator|=
operator|(
expr|struct
name|scsi_inquiry_data
operator|*
operator|)
name|csio
operator|->
name|data_ptr
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|nbuf
argument_list|,
operator|&
name|path
operator|->
name|device
operator|->
name|inq_data
argument_list|,
name|SHORT_INQUIRY_LENGTH
argument_list|)
condition|)
block|{
name|xpt_print
argument_list|(
name|path
argument_list|,
literal|"inquiry data fails comparison at DV%d step\n"
argument_list|,
name|softc
operator|->
name|action
operator|==
name|PROBE_INQUIRY_BASIC_DV1
condition|?
literal|1
else|:
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|proberequestbackoff
argument_list|(
name|periph
argument_list|,
name|path
operator|->
name|device
argument_list|)
condition|)
block|{
name|path
operator|->
name|device
operator|->
name|flags
operator|&=
operator|~
name|CAM_DEV_IN_DV
expr_stmt|;
name|softc
operator|->
name|action
operator|=
name|PROBE_TUR_FOR_NEGOTIATION
expr_stmt|;
block|}
else|else
block|{
comment|/* give up */
name|softc
operator|->
name|action
operator|=
name|PROBE_DV_EXIT
expr_stmt|;
block|}
name|free
argument_list|(
name|nbuf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
name|xpt_schedule
argument_list|(
name|periph
argument_list|,
name|priority
argument_list|)
expr_stmt|;
return|return;
block|}
name|free
argument_list|(
name|nbuf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|action
operator|==
name|PROBE_INQUIRY_BASIC_DV1
condition|)
block|{
name|softc
operator|->
name|action
operator|=
name|PROBE_INQUIRY_BASIC_DV2
expr_stmt|;
name|xpt_release_ccb
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
name|xpt_schedule
argument_list|(
name|periph
argument_list|,
name|priority
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|softc
operator|->
name|action
operator|==
name|PROBE_DV_EXIT
condition|)
block|{
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_INFO
argument_list|,
operator|(
literal|"Leave Domain Validation Successfully\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|path
operator|->
name|device
operator|->
name|flags
operator|&=
operator|~
operator|(
name|CAM_DEV_UNCONFIGURED
operator||
name|CAM_DEV_IN_DV
operator||
name|CAM_DEV_DV_HIT_BOTTOM
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|softc
operator|->
name|flags
operator|&
name|PROBE_NO_ANNOUNCE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Inform the XPT that a new device has been found */
name|done_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_GDEV_TYPE
expr_stmt|;
name|xpt_action
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
name|xpt_async
argument_list|(
name|AC_FOUND_DEVICE
argument_list|,
name|done_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|done_ccb
argument_list|)
expr_stmt|;
block|}
name|xpt_release_ccb
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|done_ccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|TAILQ_FIRST
argument_list|(
operator|&
name|softc
operator|->
name|request_ccbs
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|softc
operator|->
name|request_ccbs
argument_list|,
operator|&
name|done_ccb
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|softc
operator|->
name|request_ccbs
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|cam_periph_invalidate
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|cam_periph_release
argument_list|(
name|periph
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|probeschedule
argument_list|(
name|periph
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|probecleanup
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|free
argument_list|(
name|periph
operator|->
name|softc
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xpt_find_quirk
parameter_list|(
name|struct
name|cam_ed
modifier|*
name|device
parameter_list|)
block|{
name|caddr_t
name|match
decl_stmt|;
name|match
operator|=
name|cam_quirkmatch
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|device
operator|->
name|inq_data
argument_list|,
operator|(
name|caddr_t
operator|)
name|xpt_quirk_table
argument_list|,
sizeof|sizeof
argument_list|(
name|xpt_quirk_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|xpt_quirk_table
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|xpt_quirk_table
argument_list|)
argument_list|,
name|scsi_inquiry_match
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"xpt_find_quirk: device didn't match wildcard entry!!"
argument_list|)
expr_stmt|;
name|device
operator|->
name|quirk
operator|=
operator|(
expr|struct
name|xpt_quirk_entry
operator|*
operator|)
name|match
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_cam_search_luns
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|bool
decl_stmt|;
name|bool
operator|=
name|cam_srch_hi
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|bool
argument_list|,
sizeof|sizeof
argument_list|(
name|bool
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|bool
operator|==
literal|0
operator|||
name|bool
operator|==
literal|1
condition|)
block|{
name|cam_srch_hi
operator|=
name|bool
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xpt_devise_transport
parameter_list|(
name|struct
name|cam_path
modifier|*
name|path
parameter_list|)
block|{
name|struct
name|ccb_pathinq
name|cpi
decl_stmt|;
name|struct
name|ccb_trans_settings
name|cts
decl_stmt|;
name|struct
name|scsi_inquiry_data
modifier|*
name|inq_buf
decl_stmt|;
comment|/* Get transport information from the SIM */
name|xpt_setup_ccb
argument_list|(
operator|&
name|cpi
operator|.
name|ccb_h
argument_list|,
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|cpi
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_PATH_INQ
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|cpi
argument_list|)
expr_stmt|;
name|inq_buf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|path
operator|->
name|device
operator|->
name|flags
operator|&
name|CAM_DEV_INQUIRY_DATA_VALID
operator|)
operator|!=
literal|0
condition|)
name|inq_buf
operator|=
operator|&
name|path
operator|->
name|device
operator|->
name|inq_data
expr_stmt|;
name|path
operator|->
name|device
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|path
operator|->
name|device
operator|->
name|protocol_version
operator|=
name|inq_buf
operator|!=
name|NULL
condition|?
name|SID_ANSI_REV
argument_list|(
name|inq_buf
argument_list|)
else|:
name|cpi
operator|.
name|protocol_version
expr_stmt|;
name|path
operator|->
name|device
operator|->
name|transport
operator|=
name|cpi
operator|.
name|transport
expr_stmt|;
name|path
operator|->
name|device
operator|->
name|transport_version
operator|=
name|cpi
operator|.
name|transport_version
expr_stmt|;
comment|/* 	 * Any device not using SPI3 features should 	 * be considered SPI2 or lower. 	 */
if|if
condition|(
name|inq_buf
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|path
operator|->
name|device
operator|->
name|transport
operator|==
name|XPORT_SPI
operator|&&
operator|(
name|inq_buf
operator|->
name|spi3data
operator|&
name|SID_SPI_MASK
operator|)
operator|==
literal|0
operator|&&
name|path
operator|->
name|device
operator|->
name|transport_version
operator|>
literal|2
condition|)
name|path
operator|->
name|device
operator|->
name|transport_version
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|struct
name|cam_ed
modifier|*
name|otherdev
decl_stmt|;
for|for
control|(
name|otherdev
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|path
operator|->
name|target
operator|->
name|ed_entries
argument_list|)
init|;
name|otherdev
operator|!=
name|NULL
condition|;
name|otherdev
operator|=
name|TAILQ_NEXT
argument_list|(
name|otherdev
argument_list|,
name|links
argument_list|)
control|)
block|{
if|if
condition|(
name|otherdev
operator|!=
name|path
operator|->
name|device
condition|)
break|break;
block|}
if|if
condition|(
name|otherdev
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * Initially assume the same versioning as 			 * prior luns for this target. 			 */
name|path
operator|->
name|device
operator|->
name|protocol_version
operator|=
name|otherdev
operator|->
name|protocol_version
expr_stmt|;
name|path
operator|->
name|device
operator|->
name|transport_version
operator|=
name|otherdev
operator|->
name|transport_version
expr_stmt|;
block|}
else|else
block|{
comment|/* Until we know better, opt for safty */
name|path
operator|->
name|device
operator|->
name|protocol_version
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|path
operator|->
name|device
operator|->
name|transport
operator|==
name|XPORT_SPI
condition|)
name|path
operator|->
name|device
operator|->
name|transport_version
operator|=
literal|2
expr_stmt|;
else|else
name|path
operator|->
name|device
operator|->
name|transport_version
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 	 * XXX 	 * For a device compliant with SPC-2 we should be able 	 * to determine the transport version supported by 	 * scrutinizing the version descriptors in the 	 * inquiry buffer. 	 */
comment|/* Tell the controller what we think */
name|xpt_setup_ccb
argument_list|(
operator|&
name|cts
operator|.
name|ccb_h
argument_list|,
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|cts
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SET_TRAN_SETTINGS
expr_stmt|;
name|cts
operator|.
name|type
operator|=
name|CTS_TYPE_CURRENT_SETTINGS
expr_stmt|;
name|cts
operator|.
name|transport
operator|=
name|path
operator|->
name|device
operator|->
name|transport
expr_stmt|;
name|cts
operator|.
name|transport_version
operator|=
name|path
operator|->
name|device
operator|->
name|transport_version
expr_stmt|;
name|cts
operator|.
name|protocol
operator|=
name|path
operator|->
name|device
operator|->
name|protocol
expr_stmt|;
name|cts
operator|.
name|protocol_version
operator|=
name|path
operator|->
name|device
operator|->
name|protocol_version
expr_stmt|;
name|cts
operator|.
name|proto_specific
operator|.
name|valid
operator|=
literal|0
expr_stmt|;
name|cts
operator|.
name|xport_specific
operator|.
name|valid
operator|=
literal|0
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|cts
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xpt_set_transfer_settings
parameter_list|(
name|struct
name|ccb_trans_settings
modifier|*
name|cts
parameter_list|,
name|struct
name|cam_ed
modifier|*
name|device
parameter_list|,
name|int
name|async_update
parameter_list|)
block|{
name|struct
name|ccb_pathinq
name|cpi
decl_stmt|;
name|struct
name|ccb_trans_settings
name|cur_cts
decl_stmt|;
name|struct
name|ccb_trans_settings_scsi
modifier|*
name|scsi
decl_stmt|;
name|struct
name|ccb_trans_settings_scsi
modifier|*
name|cur_scsi
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|struct
name|scsi_inquiry_data
modifier|*
name|inq_data
decl_stmt|;
if|if
condition|(
name|device
operator|==
name|NULL
condition|)
block|{
name|cts
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_PATH_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|cts
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cts
operator|->
name|protocol
operator|==
name|PROTO_UNKNOWN
operator|||
name|cts
operator|->
name|protocol
operator|==
name|PROTO_UNSPECIFIED
condition|)
block|{
name|cts
operator|->
name|protocol
operator|=
name|device
operator|->
name|protocol
expr_stmt|;
name|cts
operator|->
name|protocol_version
operator|=
name|device
operator|->
name|protocol_version
expr_stmt|;
block|}
if|if
condition|(
name|cts
operator|->
name|protocol_version
operator|==
name|PROTO_VERSION_UNKNOWN
operator|||
name|cts
operator|->
name|protocol_version
operator|==
name|PROTO_VERSION_UNSPECIFIED
condition|)
name|cts
operator|->
name|protocol_version
operator|=
name|device
operator|->
name|protocol_version
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|protocol
operator|!=
name|device
operator|->
name|protocol
condition|)
block|{
name|xpt_print
argument_list|(
name|cts
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"Uninitialized Protocol %x:%x?\n"
argument_list|,
name|cts
operator|->
name|protocol
argument_list|,
name|device
operator|->
name|protocol
argument_list|)
expr_stmt|;
name|cts
operator|->
name|protocol
operator|=
name|device
operator|->
name|protocol
expr_stmt|;
block|}
if|if
condition|(
name|cts
operator|->
name|protocol_version
operator|>
name|device
operator|->
name|protocol_version
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
block|{
name|xpt_print
argument_list|(
name|cts
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"Down reving Protocol "
literal|"Version from %d to %d?\n"
argument_list|,
name|cts
operator|->
name|protocol_version
argument_list|,
name|device
operator|->
name|protocol_version
argument_list|)
expr_stmt|;
block|}
name|cts
operator|->
name|protocol_version
operator|=
name|device
operator|->
name|protocol_version
expr_stmt|;
block|}
if|if
condition|(
name|cts
operator|->
name|transport
operator|==
name|XPORT_UNKNOWN
operator|||
name|cts
operator|->
name|transport
operator|==
name|XPORT_UNSPECIFIED
condition|)
block|{
name|cts
operator|->
name|transport
operator|=
name|device
operator|->
name|transport
expr_stmt|;
name|cts
operator|->
name|transport_version
operator|=
name|device
operator|->
name|transport_version
expr_stmt|;
block|}
if|if
condition|(
name|cts
operator|->
name|transport_version
operator|==
name|XPORT_VERSION_UNKNOWN
operator|||
name|cts
operator|->
name|transport_version
operator|==
name|XPORT_VERSION_UNSPECIFIED
condition|)
name|cts
operator|->
name|transport_version
operator|=
name|device
operator|->
name|transport_version
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|transport
operator|!=
name|device
operator|->
name|transport
condition|)
block|{
name|xpt_print
argument_list|(
name|cts
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"Uninitialized Transport %x:%x?\n"
argument_list|,
name|cts
operator|->
name|transport
argument_list|,
name|device
operator|->
name|transport
argument_list|)
expr_stmt|;
name|cts
operator|->
name|transport
operator|=
name|device
operator|->
name|transport
expr_stmt|;
block|}
if|if
condition|(
name|cts
operator|->
name|transport_version
operator|>
name|device
operator|->
name|transport_version
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
block|{
name|xpt_print
argument_list|(
name|cts
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"Down reving Transport "
literal|"Version from %d to %d?\n"
argument_list|,
name|cts
operator|->
name|transport_version
argument_list|,
name|device
operator|->
name|transport_version
argument_list|)
expr_stmt|;
block|}
name|cts
operator|->
name|transport_version
operator|=
name|device
operator|->
name|transport_version
expr_stmt|;
block|}
name|sim
operator|=
name|cts
operator|->
name|ccb_h
operator|.
name|path
operator|->
name|bus
operator|->
name|sim
expr_stmt|;
comment|/* 	 * Nothing more of interest to do unless 	 * this is a device connected via the 	 * SCSI protocol. 	 */
if|if
condition|(
name|cts
operator|->
name|protocol
operator|!=
name|PROTO_SCSI
condition|)
block|{
if|if
condition|(
name|async_update
operator|==
name|FALSE
condition|)
operator|(
operator|*
operator|(
name|sim
operator|->
name|sim_action
operator|)
operator|)
operator|(
name|sim
operator|,
operator|(
expr|union
name|ccb
operator|*
operator|)
name|cts
operator|)
expr_stmt|;
return|return;
block|}
name|inq_data
operator|=
operator|&
name|device
operator|->
name|inq_data
expr_stmt|;
name|scsi
operator|=
operator|&
name|cts
operator|->
name|proto_specific
operator|.
name|scsi
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|cpi
operator|.
name|ccb_h
argument_list|,
name|cts
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|cpi
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_PATH_INQ
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|cpi
argument_list|)
expr_stmt|;
comment|/* SCSI specific sanity checking */
if|if
condition|(
operator|(
name|cpi
operator|.
name|hba_inquiry
operator|&
name|PI_TAG_ABLE
operator|)
operator|==
literal|0
operator|||
operator|(
name|INQ_DATA_TQ_ENABLED
argument_list|(
name|inq_data
argument_list|)
operator|)
operator|==
literal|0
operator|||
operator|(
name|device
operator|->
name|queue_flags
operator|&
name|SCP_QUEUE_DQUE
operator|)
operator|!=
literal|0
operator|||
operator|(
name|device
operator|->
name|quirk
operator|->
name|mintags
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * Can't tag on hardware that doesn't support tags, 		 * doesn't have it enabled, or has broken tag support. 		 */
name|scsi
operator|->
name|flags
operator|&=
operator|~
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
block|}
if|if
condition|(
name|async_update
operator|==
name|FALSE
condition|)
block|{
comment|/* 		 * Perform sanity checking against what the 		 * controller and device can do. 		 */
name|xpt_setup_ccb
argument_list|(
operator|&
name|cur_cts
operator|.
name|ccb_h
argument_list|,
name|cts
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|cur_cts
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_GET_TRAN_SETTINGS
expr_stmt|;
name|cur_cts
operator|.
name|type
operator|=
name|cts
operator|->
name|type
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|cur_cts
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cur_cts
operator|.
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
return|return;
block|}
name|cur_scsi
operator|=
operator|&
name|cur_cts
operator|.
name|proto_specific
operator|.
name|scsi
expr_stmt|;
if|if
condition|(
operator|(
name|scsi
operator|->
name|valid
operator|&
name|CTS_SCSI_VALID_TQ
operator|)
operator|==
literal|0
condition|)
block|{
name|scsi
operator|->
name|flags
operator|&=
operator|~
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
name|scsi
operator|->
name|flags
operator||=
name|cur_scsi
operator|->
name|flags
operator|&
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cur_scsi
operator|->
name|valid
operator|&
name|CTS_SCSI_VALID_TQ
operator|)
operator|==
literal|0
condition|)
name|scsi
operator|->
name|flags
operator|&=
operator|~
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
block|}
comment|/* SPI specific sanity checking */
if|if
condition|(
name|cts
operator|->
name|transport
operator|==
name|XPORT_SPI
operator|&&
name|async_update
operator|==
name|FALSE
condition|)
block|{
name|u_int
name|spi3caps
decl_stmt|;
name|struct
name|ccb_trans_settings_spi
modifier|*
name|spi
decl_stmt|;
name|struct
name|ccb_trans_settings_spi
modifier|*
name|cur_spi
decl_stmt|;
name|spi
operator|=
operator|&
name|cts
operator|->
name|xport_specific
operator|.
name|spi
expr_stmt|;
name|cur_spi
operator|=
operator|&
name|cur_cts
operator|.
name|xport_specific
operator|.
name|spi
expr_stmt|;
comment|/* Fill in any gaps in what the user gave us */
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_SYNC_RATE
operator|)
operator|==
literal|0
condition|)
name|spi
operator|->
name|sync_period
operator|=
name|cur_spi
operator|->
name|sync_period
expr_stmt|;
if|if
condition|(
operator|(
name|cur_spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_SYNC_RATE
operator|)
operator|==
literal|0
condition|)
name|spi
operator|->
name|sync_period
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_SYNC_OFFSET
operator|)
operator|==
literal|0
condition|)
name|spi
operator|->
name|sync_offset
operator|=
name|cur_spi
operator|->
name|sync_offset
expr_stmt|;
if|if
condition|(
operator|(
name|cur_spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_SYNC_OFFSET
operator|)
operator|==
literal|0
condition|)
name|spi
operator|->
name|sync_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_PPR_OPTIONS
operator|)
operator|==
literal|0
condition|)
name|spi
operator|->
name|ppr_options
operator|=
name|cur_spi
operator|->
name|ppr_options
expr_stmt|;
if|if
condition|(
operator|(
name|cur_spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_PPR_OPTIONS
operator|)
operator|==
literal|0
condition|)
name|spi
operator|->
name|ppr_options
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_BUS_WIDTH
operator|)
operator|==
literal|0
condition|)
name|spi
operator|->
name|bus_width
operator|=
name|cur_spi
operator|->
name|bus_width
expr_stmt|;
if|if
condition|(
operator|(
name|cur_spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_BUS_WIDTH
operator|)
operator|==
literal|0
condition|)
name|spi
operator|->
name|bus_width
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_DISC
operator|)
operator|==
literal|0
condition|)
block|{
name|spi
operator|->
name|flags
operator|&=
operator|~
name|CTS_SPI_FLAGS_DISC_ENB
expr_stmt|;
name|spi
operator|->
name|flags
operator||=
name|cur_spi
operator|->
name|flags
operator|&
name|CTS_SPI_FLAGS_DISC_ENB
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cur_spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_DISC
operator|)
operator|==
literal|0
condition|)
name|spi
operator|->
name|flags
operator|&=
operator|~
name|CTS_SPI_FLAGS_DISC_ENB
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|device
operator|->
name|flags
operator|&
name|CAM_DEV_INQUIRY_DATA_VALID
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|inq_data
operator|->
name|flags
operator|&
name|SID_Sync
operator|)
operator|==
literal|0
operator|&&
name|cts
operator|->
name|type
operator|==
name|CTS_TYPE_CURRENT_SETTINGS
operator|)
operator|||
operator|(
operator|(
name|cpi
operator|.
name|hba_inquiry
operator|&
name|PI_SDTR_ABLE
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|spi
operator|->
name|sync_offset
operator|==
literal|0
operator|)
operator|||
operator|(
name|spi
operator|->
name|sync_period
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* Force async */
name|spi
operator|->
name|sync_period
operator|=
literal|0
expr_stmt|;
name|spi
operator|->
name|sync_offset
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|spi
operator|->
name|bus_width
condition|)
block|{
case|case
name|MSG_EXT_WDTR_BUS_32_BIT
case|:
if|if
condition|(
operator|(
operator|(
name|device
operator|->
name|flags
operator|&
name|CAM_DEV_INQUIRY_DATA_VALID
operator|)
operator|==
literal|0
operator|||
operator|(
name|inq_data
operator|->
name|flags
operator|&
name|SID_WBus32
operator|)
operator|!=
literal|0
operator|||
name|cts
operator|->
name|type
operator|==
name|CTS_TYPE_USER_SETTINGS
operator|)
operator|&&
operator|(
name|cpi
operator|.
name|hba_inquiry
operator|&
name|PI_WIDE_32
operator|)
operator|!=
literal|0
condition|)
break|break;
comment|/* Fall Through to 16-bit */
case|case
name|MSG_EXT_WDTR_BUS_16_BIT
case|:
if|if
condition|(
operator|(
operator|(
name|device
operator|->
name|flags
operator|&
name|CAM_DEV_INQUIRY_DATA_VALID
operator|)
operator|==
literal|0
operator|||
operator|(
name|inq_data
operator|->
name|flags
operator|&
name|SID_WBus16
operator|)
operator|!=
literal|0
operator|||
name|cts
operator|->
name|type
operator|==
name|CTS_TYPE_USER_SETTINGS
operator|)
operator|&&
operator|(
name|cpi
operator|.
name|hba_inquiry
operator|&
name|PI_WIDE_16
operator|)
operator|!=
literal|0
condition|)
block|{
name|spi
operator|->
name|bus_width
operator|=
name|MSG_EXT_WDTR_BUS_16_BIT
expr_stmt|;
break|break;
block|}
comment|/* Fall Through to 8-bit */
default|default:
comment|/* New bus width?? */
case|case
name|MSG_EXT_WDTR_BUS_8_BIT
case|:
comment|/* All targets can do this */
name|spi
operator|->
name|bus_width
operator|=
name|MSG_EXT_WDTR_BUS_8_BIT
expr_stmt|;
break|break;
block|}
name|spi3caps
operator|=
name|cpi
operator|.
name|xport_specific
operator|.
name|spi
operator|.
name|ppr_options
expr_stmt|;
if|if
condition|(
operator|(
name|device
operator|->
name|flags
operator|&
name|CAM_DEV_INQUIRY_DATA_VALID
operator|)
operator|!=
literal|0
operator|&&
name|cts
operator|->
name|type
operator|==
name|CTS_TYPE_CURRENT_SETTINGS
condition|)
name|spi3caps
operator|&=
name|inq_data
operator|->
name|spi3data
expr_stmt|;
if|if
condition|(
operator|(
name|spi3caps
operator|&
name|SID_SPI_CLOCK_DT
operator|)
operator|==
literal|0
condition|)
name|spi
operator|->
name|ppr_options
operator|&=
operator|~
name|MSG_EXT_PPR_DT_REQ
expr_stmt|;
if|if
condition|(
operator|(
name|spi3caps
operator|&
name|SID_SPI_IUS
operator|)
operator|==
literal|0
condition|)
name|spi
operator|->
name|ppr_options
operator|&=
operator|~
name|MSG_EXT_PPR_IU_REQ
expr_stmt|;
if|if
condition|(
operator|(
name|spi3caps
operator|&
name|SID_SPI_QAS
operator|)
operator|==
literal|0
condition|)
name|spi
operator|->
name|ppr_options
operator|&=
operator|~
name|MSG_EXT_PPR_QAS_REQ
expr_stmt|;
comment|/* No SPI Transfer settings are allowed unless we are wide */
if|if
condition|(
name|spi
operator|->
name|bus_width
operator|==
literal|0
condition|)
name|spi
operator|->
name|ppr_options
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|spi
operator|->
name|flags
operator|&
name|CTS_SPI_FLAGS_DISC_ENB
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Can't tag queue without disconnection. 			 */
name|scsi
operator|->
name|flags
operator|&=
operator|~
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
name|scsi
operator|->
name|valid
operator||=
name|CTS_SCSI_VALID_TQ
expr_stmt|;
block|}
comment|/* 		 * If we are currently performing tagged transactions to 		 * this device and want to change its negotiation parameters, 		 * go non-tagged for a bit to give the controller a chance to 		 * negotiate unhampered by tag messages. 		 */
if|if
condition|(
name|cts
operator|->
name|type
operator|==
name|CTS_TYPE_CURRENT_SETTINGS
operator|&&
operator|(
name|device
operator|->
name|inq_flags
operator|&
name|SID_CmdQue
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|scsi
operator|->
name|flags
operator|&
name|CTS_SCSI_FLAGS_TAG_ENB
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|spi
operator|->
name|flags
operator|&
operator|(
name|CTS_SPI_VALID_SYNC_RATE
operator||
name|CTS_SPI_VALID_SYNC_OFFSET
operator||
name|CTS_SPI_VALID_BUS_WIDTH
operator|)
operator|)
operator|!=
literal|0
condition|)
name|xpt_toggle_tags
argument_list|(
name|cts
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cts
operator|->
name|type
operator|==
name|CTS_TYPE_CURRENT_SETTINGS
operator|&&
operator|(
name|scsi
operator|->
name|valid
operator|&
name|CTS_SCSI_VALID_TQ
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|device_tagenb
decl_stmt|;
comment|/* 		 * If we are transitioning from tags to no-tags or 		 * vice-versa, we need to carefully freeze and restart 		 * the queue so that we don't overlap tagged and non-tagged 		 * commands.  We also temporarily stop tags if there is 		 * a change in transfer negotiation settings to allow 		 * "tag-less" negotiation. 		 */
if|if
condition|(
operator|(
name|device
operator|->
name|flags
operator|&
name|CAM_DEV_TAG_AFTER_COUNT
operator|)
operator|!=
literal|0
operator|||
operator|(
name|device
operator|->
name|inq_flags
operator|&
name|SID_CmdQue
operator|)
operator|!=
literal|0
condition|)
name|device_tagenb
operator|=
name|TRUE
expr_stmt|;
else|else
name|device_tagenb
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|scsi
operator|->
name|flags
operator|&
name|CTS_SCSI_FLAGS_TAG_ENB
operator|)
operator|!=
literal|0
operator|&&
name|device_tagenb
operator|==
name|FALSE
operator|)
operator|||
operator|(
operator|(
name|scsi
operator|->
name|flags
operator|&
name|CTS_SCSI_FLAGS_TAG_ENB
operator|)
operator|==
literal|0
operator|&&
name|device_tagenb
operator|==
name|TRUE
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|scsi
operator|->
name|flags
operator|&
name|CTS_SCSI_FLAGS_TAG_ENB
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * Delay change to use tags until after a 				 * few commands have gone to this device so 				 * the controller has time to perform transfer 				 * negotiations without tagged messages getting 				 * in the way. 				 */
name|device
operator|->
name|tag_delay_count
operator|=
name|CAM_TAG_DELAY_COUNT
expr_stmt|;
name|device
operator|->
name|flags
operator||=
name|CAM_DEV_TAG_AFTER_COUNT
expr_stmt|;
block|}
else|else
block|{
name|struct
name|ccb_relsim
name|crs
decl_stmt|;
name|xpt_freeze_devq
argument_list|(
name|cts
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
name|device
operator|->
name|inq_flags
operator|&=
operator|~
name|SID_CmdQue
expr_stmt|;
name|xpt_dev_ccbq_resize
argument_list|(
name|cts
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|sim
operator|->
name|max_dev_openings
argument_list|)
expr_stmt|;
name|device
operator|->
name|flags
operator|&=
operator|~
name|CAM_DEV_TAG_AFTER_COUNT
expr_stmt|;
name|device
operator|->
name|tag_delay_count
operator|=
literal|0
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|crs
operator|.
name|ccb_h
argument_list|,
name|cts
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|crs
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_REL_SIMQ
expr_stmt|;
name|crs
operator|.
name|release_flags
operator|=
name|RELSIM_RELEASE_AFTER_QEMPTY
expr_stmt|;
name|crs
operator|.
name|openings
operator|=
name|crs
operator|.
name|release_timeout
operator|=
name|crs
operator|.
name|qfrozen_cnt
operator|=
literal|0
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|crs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|async_update
operator|==
name|FALSE
condition|)
operator|(
operator|*
operator|(
name|sim
operator|->
name|sim_action
operator|)
operator|)
operator|(
name|sim
operator|,
operator|(
expr|union
name|ccb
operator|*
operator|)
name|cts
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xpt_toggle_tags
parameter_list|(
name|struct
name|cam_path
modifier|*
name|path
parameter_list|)
block|{
name|struct
name|cam_ed
modifier|*
name|dev
decl_stmt|;
comment|/* 	 * Give controllers a chance to renegotiate 	 * before starting tag operations.  We 	 * "toggle" tagged queuing off then on 	 * which causes the tag enable command delay 	 * counter to come into effect. 	 */
name|dev
operator|=
name|path
operator|->
name|device
expr_stmt|;
if|if
condition|(
operator|(
name|dev
operator|->
name|flags
operator|&
name|CAM_DEV_TAG_AFTER_COUNT
operator|)
operator|!=
literal|0
operator|||
operator|(
operator|(
name|dev
operator|->
name|inq_flags
operator|&
name|SID_CmdQue
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|dev
operator|->
name|inq_flags
operator|&
operator|(
name|SID_Sync
operator||
name|SID_WBus16
operator||
name|SID_WBus32
operator|)
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|struct
name|ccb_trans_settings
name|cts
decl_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|cts
operator|.
name|ccb_h
argument_list|,
name|path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cts
operator|.
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cts
operator|.
name|protocol_version
operator|=
name|PROTO_VERSION_UNSPECIFIED
expr_stmt|;
name|cts
operator|.
name|transport
operator|=
name|XPORT_UNSPECIFIED
expr_stmt|;
name|cts
operator|.
name|transport_version
operator|=
name|XPORT_VERSION_UNSPECIFIED
expr_stmt|;
name|cts
operator|.
name|proto_specific
operator|.
name|scsi
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|cts
operator|.
name|proto_specific
operator|.
name|scsi
operator|.
name|valid
operator|=
name|CTS_SCSI_VALID_TQ
expr_stmt|;
name|xpt_set_transfer_settings
argument_list|(
operator|&
name|cts
argument_list|,
name|path
operator|->
name|device
argument_list|,
comment|/*async_update*/
name|TRUE
argument_list|)
expr_stmt|;
name|cts
operator|.
name|proto_specific
operator|.
name|scsi
operator|.
name|flags
operator|=
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
name|xpt_set_transfer_settings
argument_list|(
operator|&
name|cts
argument_list|,
name|path
operator|->
name|device
argument_list|,
comment|/*async_update*/
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xpt_start_tags
parameter_list|(
name|struct
name|cam_path
modifier|*
name|path
parameter_list|)
block|{
name|struct
name|ccb_relsim
name|crs
decl_stmt|;
name|struct
name|cam_ed
modifier|*
name|device
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|int
name|newopenings
decl_stmt|;
name|device
operator|=
name|path
operator|->
name|device
expr_stmt|;
name|sim
operator|=
name|path
operator|->
name|bus
operator|->
name|sim
expr_stmt|;
name|device
operator|->
name|flags
operator|&=
operator|~
name|CAM_DEV_TAG_AFTER_COUNT
expr_stmt|;
name|xpt_freeze_devq
argument_list|(
name|path
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
name|device
operator|->
name|inq_flags
operator||=
name|SID_CmdQue
expr_stmt|;
if|if
condition|(
name|device
operator|->
name|tag_saved_openings
operator|!=
literal|0
condition|)
name|newopenings
operator|=
name|device
operator|->
name|tag_saved_openings
expr_stmt|;
else|else
name|newopenings
operator|=
name|min
argument_list|(
name|device
operator|->
name|quirk
operator|->
name|maxtags
argument_list|,
name|sim
operator|->
name|max_tagged_dev_openings
argument_list|)
expr_stmt|;
name|xpt_dev_ccbq_resize
argument_list|(
name|path
argument_list|,
name|newopenings
argument_list|)
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|crs
operator|.
name|ccb_h
argument_list|,
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|crs
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_REL_SIMQ
expr_stmt|;
name|crs
operator|.
name|release_flags
operator|=
name|RELSIM_RELEASE_AFTER_QEMPTY
expr_stmt|;
name|crs
operator|.
name|openings
operator|=
name|crs
operator|.
name|release_timeout
operator|=
name|crs
operator|.
name|qfrozen_cnt
operator|=
literal|0
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|crs
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|busses_to_config
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|busses_to_reset
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|xptconfigbuscountfunc
parameter_list|(
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|mtx_assert
argument_list|(
name|bus
operator|->
name|sim
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus
operator|->
name|path_id
operator|!=
name|CAM_XPT_PATH_ID
condition|)
block|{
name|struct
name|cam_path
name|path
decl_stmt|;
name|struct
name|ccb_pathinq
name|cpi
decl_stmt|;
name|int
name|can_negotiate
decl_stmt|;
name|busses_to_config
operator|++
expr_stmt|;
name|xpt_compile_path
argument_list|(
operator|&
name|path
argument_list|,
name|NULL
argument_list|,
name|bus
operator|->
name|path_id
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|cpi
operator|.
name|ccb_h
argument_list|,
operator|&
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|cpi
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_PATH_INQ
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|cpi
argument_list|)
expr_stmt|;
name|can_negotiate
operator|=
name|cpi
operator|.
name|hba_inquiry
expr_stmt|;
name|can_negotiate
operator|&=
operator|(
name|PI_WIDE_32
operator||
name|PI_WIDE_16
operator||
name|PI_SDTR_ABLE
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|cpi
operator|.
name|hba_misc
operator|&
name|PIM_NOBUSRESET
operator|)
operator|==
literal|0
operator|&&
name|can_negotiate
condition|)
name|busses_to_reset
operator|++
expr_stmt|;
name|xpt_release_path
argument_list|(
operator|&
name|path
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xptconfigfunc
parameter_list|(
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|union
name|ccb
modifier|*
name|work_ccb
decl_stmt|;
name|mtx_assert
argument_list|(
name|bus
operator|->
name|sim
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus
operator|->
name|path_id
operator|!=
name|CAM_XPT_PATH_ID
condition|)
block|{
name|cam_status
name|status
decl_stmt|;
name|int
name|can_negotiate
decl_stmt|;
name|work_ccb
operator|=
name|xpt_alloc_ccb_nowait
argument_list|()
expr_stmt|;
if|if
condition|(
name|work_ccb
operator|==
name|NULL
condition|)
block|{
name|busses_to_config
operator|--
expr_stmt|;
name|xpt_finishconfig
argument_list|(
name|xpt_periph
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|status
operator|=
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
name|xpt_periph
argument_list|,
name|bus
operator|->
name|path_id
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"xptconfigfunc: xpt_create_path failed with "
literal|"status %#x for bus %d\n"
argument_list|,
name|status
argument_list|,
name|bus
operator|->
name|path_id
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"xptconfigfunc: halting bus configuration\n"
argument_list|)
expr_stmt|;
name|xpt_free_ccb
argument_list|(
name|work_ccb
argument_list|)
expr_stmt|;
name|busses_to_config
operator|--
expr_stmt|;
name|xpt_finishconfig
argument_list|(
name|xpt_periph
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|xpt_setup_ccb
argument_list|(
operator|&
name|work_ccb
operator|->
name|ccb_h
argument_list|,
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|work_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_PATH_INQ
expr_stmt|;
name|xpt_action
argument_list|(
name|work_ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|work_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"xptconfigfunc: CPI failed on bus %d "
literal|"with status %d\n"
argument_list|,
name|bus
operator|->
name|path_id
argument_list|,
name|work_ccb
operator|->
name|ccb_h
operator|.
name|status
argument_list|)
expr_stmt|;
name|xpt_finishconfig
argument_list|(
name|xpt_periph
argument_list|,
name|work_ccb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|can_negotiate
operator|=
name|work_ccb
operator|->
name|cpi
operator|.
name|hba_inquiry
expr_stmt|;
name|can_negotiate
operator|&=
operator|(
name|PI_WIDE_32
operator||
name|PI_WIDE_16
operator||
name|PI_SDTR_ABLE
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|work_ccb
operator|->
name|cpi
operator|.
name|hba_misc
operator|&
name|PIM_NOBUSRESET
operator|)
operator|==
literal|0
operator|&&
operator|(
name|can_negotiate
operator|!=
literal|0
operator|)
condition|)
block|{
name|xpt_setup_ccb
argument_list|(
operator|&
name|work_ccb
operator|->
name|ccb_h
argument_list|,
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|work_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_RESET_BUS
expr_stmt|;
name|work_ccb
operator|->
name|ccb_h
operator|.
name|cbfcnp
operator|=
name|NULL
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"Resetting Bus\n"
operator|)
argument_list|)
expr_stmt|;
name|xpt_action
argument_list|(
name|work_ccb
argument_list|)
expr_stmt|;
name|xpt_finishconfig
argument_list|(
name|xpt_periph
argument_list|,
name|work_ccb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Act as though we performed a successful BUS RESET */
name|work_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_RESET_BUS
expr_stmt|;
name|xpt_finishconfig
argument_list|(
name|xpt_periph
argument_list|,
name|work_ccb
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xpt_config
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
comment|/* 	 * Now that interrupts are enabled, go find our devices 	 */
ifdef|#
directive|ifdef
name|CAMDEBUG
comment|/* Setup debugging flags and path */
ifdef|#
directive|ifdef
name|CAM_DEBUG_FLAGS
name|cam_dflags
operator|=
name|CAM_DEBUG_FLAGS
expr_stmt|;
else|#
directive|else
comment|/* !CAM_DEBUG_FLAGS */
name|cam_dflags
operator|=
name|CAM_DEBUG_NONE
expr_stmt|;
endif|#
directive|endif
comment|/* CAM_DEBUG_FLAGS */
ifdef|#
directive|ifdef
name|CAM_DEBUG_BUS
if|if
condition|(
name|cam_dflags
operator|!=
name|CAM_DEBUG_NONE
condition|)
block|{
comment|/* 		 * Locking is specifically omitted here.  No SIMs have 		 * registered yet, so xpt_create_path will only be searching 		 * empty lists of targets and devices. 		 */
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|cam_dpath
argument_list|,
name|xpt_periph
argument_list|,
name|CAM_DEBUG_BUS
argument_list|,
name|CAM_DEBUG_TARGET
argument_list|,
name|CAM_DEBUG_LUN
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"xpt_config: xpt_create_path() failed for debug"
literal|" target %d:%d:%d, debugging disabled\n"
argument_list|,
name|CAM_DEBUG_BUS
argument_list|,
name|CAM_DEBUG_TARGET
argument_list|,
name|CAM_DEBUG_LUN
argument_list|)
expr_stmt|;
name|cam_dflags
operator|=
name|CAM_DEBUG_NONE
expr_stmt|;
block|}
block|}
else|else
name|cam_dpath
operator|=
name|NULL
expr_stmt|;
else|#
directive|else
comment|/* !CAM_DEBUG_BUS */
name|cam_dpath
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* CAM_DEBUG_BUS */
endif|#
directive|endif
comment|/* CAMDEBUG */
comment|/* 	 * Scan all installed busses. 	 */
name|xpt_for_all_busses
argument_list|(
name|xptconfigbuscountfunc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|busses_to_config
operator|==
literal|0
condition|)
block|{
comment|/* Call manually because we don't have any busses */
name|xpt_finishconfig
argument_list|(
name|xpt_periph
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|busses_to_reset
operator|>
literal|0
operator|&&
name|scsi_delay
operator|>=
literal|2000
condition|)
block|{
name|printf
argument_list|(
literal|"Waiting %d seconds for SCSI "
literal|"devices to settle\n"
argument_list|,
name|scsi_delay
operator|/
literal|1000
argument_list|)
expr_stmt|;
block|}
name|xpt_for_all_busses
argument_list|(
name|xptconfigfunc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * If the given device only has one peripheral attached to it, and if that  * peripheral is the passthrough driver, announce it.  This insures that the  * user sees some sort of announcement for every peripheral in their system.  */
end_comment

begin_function
specifier|static
name|int
name|xptpassannouncefunc
parameter_list|(
name|struct
name|cam_ed
modifier|*
name|device
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|periph
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|device
operator|->
name|periphs
argument_list|)
operator|,
name|i
operator|=
literal|0
init|;
name|periph
operator|!=
name|NULL
condition|;
name|periph
operator|=
name|SLIST_NEXT
argument_list|(
name|periph
argument_list|,
name|periph_links
argument_list|)
operator|,
name|i
operator|++
control|)
empty_stmt|;
name|periph
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|device
operator|->
name|periphs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|==
literal|1
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|periph
operator|->
name|periph_name
argument_list|,
literal|"pass"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|xpt_announce_periph
argument_list|(
name|periph
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xpt_finishconfig_task
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|periph_driver
modifier|*
modifier|*
name|p_drv
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|busses_to_config
operator|==
literal|0
condition|)
block|{
comment|/* Register all the peripheral drivers */
comment|/* XXX This will have to change when we have loadable modules */
name|p_drv
operator|=
name|periph_drivers
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|p_drv
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
operator|(
operator|*
name|p_drv
index|[
name|i
index|]
operator|->
name|init
operator|)
operator|(
operator|)
expr_stmt|;
block|}
comment|/* 		 * Check for devices with no "standard" peripheral driver 		 * attached.  For any devices like that, announce the 		 * passthrough driver so the user will see something. 		 */
name|xpt_for_all_devices
argument_list|(
name|xptpassannouncefunc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Release our hook so that the boot can continue. */
name|config_intrhook_disestablish
argument_list|(
name|xsoftc
operator|.
name|xpt_config_hook
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|xsoftc
operator|.
name|xpt_config_hook
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|xsoftc
operator|.
name|xpt_config_hook
operator|=
name|NULL
expr_stmt|;
block|}
name|free
argument_list|(
name|context
argument_list|,
name|M_CAMXPT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xpt_finishconfig
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|done_ccb
parameter_list|)
block|{
name|struct
name|xpt_task
modifier|*
name|task
decl_stmt|;
if|if
condition|(
name|done_ccb
operator|!=
name|NULL
condition|)
block|{
name|CAM_DEBUG
argument_list|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"xpt_finishconfig\n"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_RESET_BUS
case|:
if|if
condition|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|==
name|CAM_REQ_CMP
condition|)
block|{
name|done_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SCAN_BUS
expr_stmt|;
name|done_ccb
operator|->
name|ccb_h
operator|.
name|cbfcnp
operator|=
name|xpt_finishconfig
expr_stmt|;
name|done_ccb
operator|->
name|crcn
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|xpt_action
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* FALLTHROUGH */
case|case
name|XPT_SCAN_BUS
case|:
default|default:
name|xpt_free_path
argument_list|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|busses_to_config
operator|--
expr_stmt|;
break|break;
block|}
block|}
name|task
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|xpt_task
argument_list|)
argument_list|,
name|M_CAMXPT
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|task
operator|!=
name|NULL
condition|)
block|{
name|TASK_INIT
argument_list|(
operator|&
name|task
operator|->
name|task
argument_list|,
literal|0
argument_list|,
name|xpt_finishconfig_task
argument_list|,
name|task
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|task
operator|->
name|task
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|done_ccb
operator|!=
name|NULL
condition|)
name|xpt_free_ccb
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xptaction
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|work_ccb
parameter_list|)
block|{
name|CAM_DEBUG
argument_list|(
name|work_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"xptaction\n"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|work_ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
comment|/* Common cases first */
case|case
name|XPT_PATH_INQ
case|:
comment|/* Path routing inquiry */
block|{
name|struct
name|ccb_pathinq
modifier|*
name|cpi
decl_stmt|;
name|cpi
operator|=
operator|&
name|work_ccb
operator|->
name|cpi
expr_stmt|;
name|cpi
operator|->
name|version_num
operator|=
literal|1
expr_stmt|;
comment|/* XXX??? */
name|cpi
operator|->
name|hba_inquiry
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|target_sprt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_misc
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_eng_cnt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|max_target
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|max_lun
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|initiator_id
operator|=
literal|0
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|sim_vid
argument_list|,
literal|"FreeBSD"
argument_list|,
name|SIM_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|hba_vid
argument_list|,
literal|""
argument_list|,
name|HBA_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|dev_name
argument_list|,
name|sim
operator|->
name|sim_name
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|unit_number
operator|=
name|sim
operator|->
name|unit_number
expr_stmt|;
name|cpi
operator|->
name|bus_id
operator|=
name|sim
operator|->
name|bus_id
expr_stmt|;
name|cpi
operator|->
name|base_transfer_speed
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|protocol
operator|=
name|PROTO_UNSPECIFIED
expr_stmt|;
name|cpi
operator|->
name|protocol_version
operator|=
name|PROTO_VERSION_UNSPECIFIED
expr_stmt|;
name|cpi
operator|->
name|transport
operator|=
name|XPORT_UNSPECIFIED
expr_stmt|;
name|cpi
operator|->
name|transport_version
operator|=
name|XPORT_VERSION_UNSPECIFIED
expr_stmt|;
name|cpi
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|work_ccb
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|work_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|work_ccb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * The xpt as a "controller" has no interrupt sources, so polling  * is a no-op.  */
end_comment

begin_function
specifier|static
name|void
name|xptpoll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|xpt_lock_buses
parameter_list|(
name|void
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_topo_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xpt_unlock_buses
parameter_list|(
name|void
parameter_list|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_topo_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|camisr
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|cam_simq_t
name|queue
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|cam_simq_lock
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|queue
argument_list|)
expr_stmt|;
name|TAILQ_CONCAT
argument_list|(
operator|&
name|queue
argument_list|,
operator|&
name|cam_simq
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|cam_simq_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|sim
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|queue
argument_list|,
name|sim
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|CAM_SIM_LOCK
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|sim
operator|->
name|flags
operator|&=
operator|~
name|CAM_SIM_ON_DONEQ
expr_stmt|;
name|camisr_runqueue
argument_list|(
operator|&
name|sim
operator|->
name|sim_doneq
argument_list|)
expr_stmt|;
name|CAM_SIM_UNLOCK
argument_list|(
name|sim
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|camisr_runqueue
parameter_list|(
name|void
modifier|*
name|V_queue
parameter_list|)
block|{
name|cam_isrq_t
modifier|*
name|queue
init|=
name|V_queue
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
while|while
condition|(
operator|(
name|ccb_h
operator|=
name|TAILQ_FIRST
argument_list|(
name|queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|runq
decl_stmt|;
name|TAILQ_REMOVE
argument_list|(
name|queue
argument_list|,
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|ccb_h
operator|->
name|pinfo
operator|.
name|index
operator|=
name|CAM_UNQUEUED_INDEX
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|ccb_h
operator|->
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"camisr\n"
operator|)
argument_list|)
expr_stmt|;
name|runq
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_HIGH_POWER
condition|)
block|{
name|struct
name|highpowerlist
modifier|*
name|hphead
decl_stmt|;
name|union
name|ccb
modifier|*
name|send_ccb
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_lock
argument_list|)
expr_stmt|;
name|hphead
operator|=
operator|&
name|xsoftc
operator|.
name|highpowerq
expr_stmt|;
name|send_ccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|STAILQ_FIRST
argument_list|(
name|hphead
argument_list|)
expr_stmt|;
comment|/* 			 * Increment the count since this command is done. 			 */
name|xsoftc
operator|.
name|num_highpower
operator|++
expr_stmt|;
comment|/*  			 * Any high powered commands queued up? 			 */
if|if
condition|(
name|send_ccb
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
name|hphead
argument_list|,
name|xpt_links
operator|.
name|stqe
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_lock
argument_list|)
expr_stmt|;
name|xpt_release_devq
argument_list|(
name|send_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*count*/
literal|1
argument_list|,
comment|/*runqueue*/
name|TRUE
argument_list|)
expr_stmt|;
block|}
else|else
name|mtx_unlock
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|func_code
operator|&
name|XPT_FC_USER_CCB
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|cam_ed
modifier|*
name|dev
decl_stmt|;
name|dev
operator|=
name|ccb_h
operator|->
name|path
operator|->
name|device
expr_stmt|;
name|cam_ccbq_ccb_done
argument_list|(
operator|&
name|dev
operator|->
name|ccbq
argument_list|,
operator|(
expr|union
name|ccb
operator|*
operator|)
name|ccb_h
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SIM_DEAD
argument_list|(
name|ccb_h
operator|->
name|path
operator|->
name|bus
operator|->
name|sim
argument_list|)
condition|)
block|{
name|ccb_h
operator|->
name|path
operator|->
name|bus
operator|->
name|sim
operator|->
name|devq
operator|->
name|send_active
operator|--
expr_stmt|;
name|ccb_h
operator|->
name|path
operator|->
name|bus
operator|->
name|sim
operator|->
name|devq
operator|->
name|send_openings
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|dev
operator|->
name|flags
operator|&
name|CAM_DEV_REL_ON_COMPLETE
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ccb_h
operator|->
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQUEUE_REQ
operator|)
operator|||
operator|(
operator|(
name|dev
operator|->
name|flags
operator|&
name|CAM_DEV_REL_ON_QUEUE_EMPTY
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|dev
operator|->
name|ccbq
operator|.
name|dev_active
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|xpt_release_devq
argument_list|(
name|ccb_h
operator|->
name|path
argument_list|,
comment|/*count*/
literal|1
argument_list|,
comment|/*run_queue*/
name|TRUE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dev
operator|->
name|flags
operator|&
name|CAM_DEV_TAG_AFTER_COUNT
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|--
name|dev
operator|->
name|tag_delay_count
operator|==
literal|0
operator|)
condition|)
name|xpt_start_tags
argument_list|(
name|ccb_h
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dev
operator|->
name|ccbq
operator|.
name|queue
operator|.
name|entries
operator|>
literal|0
operator|)
operator|&&
operator|(
name|dev
operator|->
name|qfrozen_cnt
operator|==
literal|0
operator|)
operator|&&
operator|(
name|device_is_send_queued
argument_list|(
name|dev
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|runq
operator|=
name|xpt_schedule_dev_sendq
argument_list|(
name|ccb_h
operator|->
name|path
operator|->
name|bus
argument_list|,
name|dev
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ccb_h
operator|->
name|status
operator|&
name|CAM_RELEASE_SIMQ
condition|)
block|{
name|xpt_release_simq
argument_list|(
name|ccb_h
operator|->
name|path
operator|->
name|bus
operator|->
name|sim
argument_list|,
comment|/*run_queue*/
name|TRUE
argument_list|)
expr_stmt|;
name|ccb_h
operator|->
name|status
operator|&=
operator|~
name|CAM_RELEASE_SIMQ
expr_stmt|;
name|runq
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_DEV_QFRZDIS
operator|)
operator|&&
operator|(
name|ccb_h
operator|->
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
condition|)
block|{
name|xpt_release_devq
argument_list|(
name|ccb_h
operator|->
name|path
argument_list|,
comment|/*count*/
literal|1
argument_list|,
comment|/*run_queue*/
name|TRUE
argument_list|)
expr_stmt|;
name|ccb_h
operator|->
name|status
operator|&=
operator|~
name|CAM_DEV_QFRZN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|runq
condition|)
block|{
name|xpt_run_dev_sendq
argument_list|(
name|ccb_h
operator|->
name|path
operator|->
name|bus
argument_list|)
expr_stmt|;
block|}
comment|/* Call the peripheral driver's callback */
call|(
modifier|*
name|ccb_h
operator|->
name|cbfcnp
call|)
argument_list|(
name|ccb_h
operator|->
name|path
operator|->
name|periph
argument_list|,
operator|(
expr|union
name|ccb
operator|*
operator|)
name|ccb_h
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dead_sim_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_DEV_NOT_THERE
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dead_sim_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
block|{ }
end_function

end_unit

