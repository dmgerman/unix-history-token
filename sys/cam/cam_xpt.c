begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Implementation of the Common Access Method Transport (XPT) layer.  *  * Copyright (c) 1997, 1998, 1999 Justin T. Gibbs.  * Copyright (c) 1997, 1998, 1999 Kenneth D. Merry.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/interrupt.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_queue.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_internal.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_compat.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_pass.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_comment
comment|/* geometry translation */
end_comment

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_comment
comment|/* for xpt_print below */
end_comment

begin_include
include|#
directive|include
file|"opt_cam.h"
end_include

begin_comment
comment|/*  * This is the maximum number of high powered commands (e.g. start unit)  * that can be outstanding at a particular time.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CAM_MAX_HIGHPOWER
end_ifndef

begin_define
define|#
directive|define
name|CAM_MAX_HIGHPOWER
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Datastructures internal to the xpt layer */
end_comment

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_CAMXPT
argument_list|,
literal|"CAM XPT"
argument_list|,
literal|"CAM XPT buffers"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_CAMDEV
argument_list|,
literal|"CAM DEV"
argument_list|,
literal|"CAM devices"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_CAMCCB
argument_list|,
literal|"CAM CCB"
argument_list|,
literal|"CAM CCBs"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_CAMPATH
argument_list|,
literal|"CAM path"
argument_list|,
literal|"CAM paths"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Object for defering XPT actions to a taskqueue */
end_comment

begin_struct
struct|struct
name|xpt_task
block|{
name|struct
name|task
name|task
decl_stmt|;
name|void
modifier|*
name|data1
decl_stmt|;
name|uintptr_t
name|data2
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|xpt_softc
block|{
name|uint32_t
name|xpt_generation
decl_stmt|;
comment|/* number of high powered commands that can go through right now */
name|struct
name|mtx
name|xpt_highpower_lock
decl_stmt|;
name|STAILQ_HEAD
argument_list|(
argument|highpowerlist
argument_list|,
argument|cam_ed
argument_list|)
name|highpowerq
expr_stmt|;
name|int
name|num_highpower
decl_stmt|;
comment|/* queue for handling async rescan requests. */
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|ccb_hdr
argument_list|)
name|ccb_scanq
expr_stmt|;
name|int
name|buses_to_config
decl_stmt|;
name|int
name|buses_config_done
decl_stmt|;
comment|/* Registered busses */
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|cam_eb
argument_list|)
name|xpt_busses
expr_stmt|;
name|u_int
name|bus_generation
decl_stmt|;
name|struct
name|intr_config_hook
modifier|*
name|xpt_config_hook
decl_stmt|;
name|int
name|boot_delay
decl_stmt|;
name|struct
name|callout
name|boot_callout
decl_stmt|;
name|struct
name|mtx
name|xpt_topo_lock
decl_stmt|;
name|struct
name|mtx
name|xpt_lock
decl_stmt|;
name|struct
name|taskqueue
modifier|*
name|xpt_taskq
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
enum|enum
block|{
name|DM_RET_COPY
init|=
literal|0x01
block|,
name|DM_RET_FLAG_MASK
init|=
literal|0x0f
block|,
name|DM_RET_NONE
init|=
literal|0x00
block|,
name|DM_RET_STOP
init|=
literal|0x10
block|,
name|DM_RET_DESCEND
init|=
literal|0x20
block|,
name|DM_RET_ERROR
init|=
literal|0x30
block|,
name|DM_RET_ACTION_MASK
init|=
literal|0xf0
block|}
name|dev_match_ret
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|XPT_DEPTH_BUS
block|,
name|XPT_DEPTH_TARGET
block|,
name|XPT_DEPTH_DEVICE
block|,
name|XPT_DEPTH_PERIPH
block|}
name|xpt_traverse_depth
typedef|;
end_typedef

begin_struct
struct|struct
name|xpt_traverse_config
block|{
name|xpt_traverse_depth
name|depth
decl_stmt|;
name|void
modifier|*
name|tr_func
decl_stmt|;
name|void
modifier|*
name|tr_arg
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|int
name|xpt_busfunc_t
parameter_list|(
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|int
name|xpt_targetfunc_t
parameter_list|(
name|struct
name|cam_et
modifier|*
name|target
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|int
name|xpt_devicefunc_t
parameter_list|(
name|struct
name|cam_ed
modifier|*
name|device
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|int
name|xpt_periphfunc_t
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|int
name|xpt_pdrvfunc_t
parameter_list|(
name|struct
name|periph_driver
modifier|*
modifier|*
name|pdrv
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/* Transport layer configuration information */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|xpt_softc
name|xsoftc
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MTX_SYSINIT
argument_list|(
name|xpt_topo_init
argument_list|,
operator|&
name|xsoftc
operator|.
name|xpt_topo_lock
argument_list|,
literal|"XPT topology lock"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_cam
argument_list|,
name|OID_AUTO
argument_list|,
name|boot_delay
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|xsoftc
operator|.
name|boot_delay
argument_list|,
literal|0
argument_list|,
literal|"Bus registration wait time"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_cam
argument_list|,
name|OID_AUTO
argument_list|,
name|xpt_generation
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|xsoftc
operator|.
name|xpt_generation
argument_list|,
literal|0
argument_list|,
literal|"CAM peripheral generation count"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|cam_doneq
block|{
name|struct
name|mtx_padalign
name|cam_doneq_mtx
decl_stmt|;
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|ccb_hdr
argument_list|)
name|cam_doneq
expr_stmt|;
name|int
name|cam_doneq_sleep
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|cam_doneq
name|cam_doneqs
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cam_num_doneqs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|proc
modifier|*
name|cam_proc
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_cam
argument_list|,
name|OID_AUTO
argument_list|,
name|num_doneqs
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|cam_num_doneqs
argument_list|,
literal|0
argument_list|,
literal|"Number of completion queues/threads"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|cam_periph
modifier|*
name|xpt_periph
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|periph_init_t
name|xpt_periph_init
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|periph_driver
name|xpt_driver
init|=
block|{
name|xpt_periph_init
block|,
literal|"xpt"
block|,
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|xpt_driver
operator|.
name|units
argument_list|)
block|,
comment|/* generation */
literal|0
block|,
name|CAM_PERIPH_DRV_EARLY
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|PERIPHDRIVER_DECLARE
argument_list|(
name|xpt
argument_list|,
name|xpt_driver
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|xptopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|xptclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|xptioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|xptdoioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|xpt_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_flags
operator|=
literal|0
block|,
operator|.
name|d_open
operator|=
name|xptopen
block|,
operator|.
name|d_close
operator|=
name|xptclose
block|,
operator|.
name|d_ioctl
operator|=
name|xptioctl
block|,
operator|.
name|d_name
operator|=
literal|"xpt"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Storage for debugging datastructures */
end_comment

begin_decl_stmt
name|struct
name|cam_path
modifier|*
name|cam_dpath
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int32_t
name|cam_dflags
init|=
name|CAM_DEBUG_FLAGS
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_cam
argument_list|,
name|OID_AUTO
argument_list|,
name|dflags
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|cam_dflags
argument_list|,
literal|0
argument_list|,
literal|"Enabled debug flags"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|u_int32_t
name|cam_debug_delay
init|=
name|CAM_DEBUG_DELAY
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_cam
argument_list|,
name|OID_AUTO
argument_list|,
name|debug_delay
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|cam_debug_delay
argument_list|,
literal|0
argument_list|,
literal|"Delay in us after each debug message"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Our boot-time initialization hook */
end_comment

begin_function_decl
specifier|static
name|int
name|cam_module_event_handler
parameter_list|(
name|module_t
parameter_list|,
name|int
comment|/*modeventtype_t*/
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|moduledata_t
name|cam_moduledata
init|=
block|{
literal|"cam"
block|,
name|cam_module_event_handler
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|xpt_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|cam
argument_list|,
name|cam_moduledata
argument_list|,
name|SI_SUB_CONFIGURE
argument_list|,
name|SI_ORDER_SECOND
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|cam
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|xpt_async_bcast
parameter_list|(
name|struct
name|async_list
modifier|*
name|async_head
parameter_list|,
name|u_int32_t
name|async_code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|async_arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|path_id_t
name|xptnextfreepathid
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|path_id_t
name|xptpathid
parameter_list|(
specifier|const
name|char
modifier|*
name|sim_name
parameter_list|,
name|int
name|sim_unit
parameter_list|,
name|int
name|sim_bus
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|union
name|ccb
modifier|*
name|xpt_get_ccb
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|union
name|ccb
modifier|*
name|xpt_get_ccb_nowait
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xpt_run_allocq
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|sleep
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xpt_run_allocq_task
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xpt_run_devq
parameter_list|(
name|struct
name|cam_devq
modifier|*
name|devq
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|timeout_t
name|xpt_release_devq_timeout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xpt_release_simq_timeout
argument_list|(
name|void
operator|*
name|arg
argument_list|)
name|__unused
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|xpt_acquire_bus
parameter_list|(
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xpt_release_bus
parameter_list|(
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|xpt_freeze_devq_device
parameter_list|(
name|struct
name|cam_ed
modifier|*
name|dev
parameter_list|,
name|u_int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xpt_release_devq_device
parameter_list|(
name|struct
name|cam_ed
modifier|*
name|dev
parameter_list|,
name|u_int
name|count
parameter_list|,
name|int
name|run_queue
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|cam_et
modifier|*
name|xpt_alloc_target
parameter_list|(
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|,
name|target_id_t
name|target_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xpt_acquire_target
parameter_list|(
name|struct
name|cam_et
modifier|*
name|target
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xpt_release_target
parameter_list|(
name|struct
name|cam_et
modifier|*
name|target
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|cam_eb
modifier|*
name|xpt_find_bus
parameter_list|(
name|path_id_t
name|path_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|cam_et
modifier|*
name|xpt_find_target
parameter_list|(
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|,
name|target_id_t
name|target_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|cam_ed
modifier|*
name|xpt_find_device
parameter_list|(
name|struct
name|cam_et
modifier|*
name|target
parameter_list|,
name|lun_id_t
name|lun_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xpt_config
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xpt_schedule_dev
parameter_list|(
name|struct
name|camq
modifier|*
name|queue
parameter_list|,
name|cam_pinfo
modifier|*
name|dev_pinfo
parameter_list|,
name|u_int32_t
name|new_priority
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|xpt_devicefunc_t
name|xptpassannouncefunc
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|xptaction
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|work_ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xptpoll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|camisr_runqueue
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xpt_done_process
parameter_list|(
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xpt_done_td
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|dev_match_ret
name|xptbusmatch
parameter_list|(
name|struct
name|dev_match_pattern
modifier|*
name|patterns
parameter_list|,
name|u_int
name|num_patterns
parameter_list|,
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|dev_match_ret
name|xptdevicematch
parameter_list|(
name|struct
name|dev_match_pattern
modifier|*
name|patterns
parameter_list|,
name|u_int
name|num_patterns
parameter_list|,
name|struct
name|cam_ed
modifier|*
name|device
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|dev_match_ret
name|xptperiphmatch
parameter_list|(
name|struct
name|dev_match_pattern
modifier|*
name|patterns
parameter_list|,
name|u_int
name|num_patterns
parameter_list|,
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|xpt_busfunc_t
name|xptedtbusfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xpt_targetfunc_t
name|xptedttargetfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xpt_devicefunc_t
name|xptedtdevicefunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xpt_periphfunc_t
name|xptedtperiphfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xpt_pdrvfunc_t
name|xptplistpdrvfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xpt_periphfunc_t
name|xptplistperiphfunc
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|xptedtmatch
parameter_list|(
name|struct
name|ccb_dev_match
modifier|*
name|cdm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xptperiphlistmatch
parameter_list|(
name|struct
name|ccb_dev_match
modifier|*
name|cdm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xptbustraverse
parameter_list|(
name|struct
name|cam_eb
modifier|*
name|start_bus
parameter_list|,
name|xpt_busfunc_t
modifier|*
name|tr_func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xpttargettraverse
parameter_list|(
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|,
name|struct
name|cam_et
modifier|*
name|start_target
parameter_list|,
name|xpt_targetfunc_t
modifier|*
name|tr_func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xptdevicetraverse
parameter_list|(
name|struct
name|cam_et
modifier|*
name|target
parameter_list|,
name|struct
name|cam_ed
modifier|*
name|start_device
parameter_list|,
name|xpt_devicefunc_t
modifier|*
name|tr_func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xptperiphtraverse
parameter_list|(
name|struct
name|cam_ed
modifier|*
name|device
parameter_list|,
name|struct
name|cam_periph
modifier|*
name|start_periph
parameter_list|,
name|xpt_periphfunc_t
modifier|*
name|tr_func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xptpdrvtraverse
parameter_list|(
name|struct
name|periph_driver
modifier|*
modifier|*
name|start_pdrv
parameter_list|,
name|xpt_pdrvfunc_t
modifier|*
name|tr_func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xptpdperiphtraverse
parameter_list|(
name|struct
name|periph_driver
modifier|*
modifier|*
name|pdrv
parameter_list|,
name|struct
name|cam_periph
modifier|*
name|start_periph
parameter_list|,
name|xpt_periphfunc_t
modifier|*
name|tr_func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|xpt_busfunc_t
name|xptdefbusfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xpt_targetfunc_t
name|xptdeftargetfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xpt_devicefunc_t
name|xptdefdevicefunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xpt_periphfunc_t
name|xptdefperiphfunc
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|xpt_finishconfig_task
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xpt_dev_async_default
parameter_list|(
name|u_int32_t
name|async_code
parameter_list|,
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|,
name|struct
name|cam_et
modifier|*
name|target
parameter_list|,
name|struct
name|cam_ed
modifier|*
name|device
parameter_list|,
name|void
modifier|*
name|async_arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|cam_ed
modifier|*
name|xpt_alloc_device_default
parameter_list|(
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|,
name|struct
name|cam_et
modifier|*
name|target
parameter_list|,
name|lun_id_t
name|lun_id
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|xpt_devicefunc_t
name|xptsetasyncfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xpt_busfunc_t
name|xptsetasyncbusfunc
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|cam_status
name|xptregister
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|xpt_action_name
parameter_list|(
name|uint32_t
name|action
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|int
name|device_is_queued
parameter_list|(
name|struct
name|cam_ed
modifier|*
name|device
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|__inline
name|int
name|xpt_schedule_devq
parameter_list|(
name|struct
name|cam_devq
modifier|*
name|devq
parameter_list|,
name|struct
name|cam_ed
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|devq
operator|->
name|send_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dev
operator|->
name|ccbq
operator|.
name|queue
operator|.
name|entries
operator|>
literal|0
operator|)
operator|&&
operator|(
name|dev
operator|->
name|ccbq
operator|.
name|dev_openings
operator|>
literal|0
operator|)
operator|&&
operator|(
name|dev
operator|->
name|ccbq
operator|.
name|queue
operator|.
name|qfrozen_cnt
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * The priority of a device waiting for controller 		 * resources is that of the highest priority CCB 		 * enqueued. 		 */
name|retval
operator|=
name|xpt_schedule_dev
argument_list|(
operator|&
name|devq
operator|->
name|send_queue
argument_list|,
operator|&
name|dev
operator|->
name|devq_entry
argument_list|,
name|CAMQ_GET_PRIO
argument_list|(
operator|&
name|dev
operator|->
name|ccbq
operator|.
name|queue
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|device_is_queued
parameter_list|(
name|struct
name|cam_ed
modifier|*
name|device
parameter_list|)
block|{
return|return
operator|(
name|device
operator|->
name|devq_entry
operator|.
name|index
operator|!=
name|CAM_UNQUEUED_INDEX
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xpt_periph_init
parameter_list|()
block|{
name|make_dev
argument_list|(
operator|&
name|xpt_cdevsw
argument_list|,
literal|0
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0600
argument_list|,
literal|"xpt0"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|xptopen
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
comment|/* 	 * Only allow read-write access. 	 */
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
name|FWRITE
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|flags
operator|&
name|FREAD
operator|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
comment|/* 	 * We don't allow nonblocking access. 	 */
if|if
condition|(
operator|(
name|flags
operator|&
name|O_NONBLOCK
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: can't do nonblocking access\n"
argument_list|,
name|devtoname
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xptclose
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Don't automatically grab the xpt softc lock here even though this is going  * through the xpt device.  The xpt device is really just a back door for  * accessing other devices and SIMs, so the right thing to do is to grab  * the appropriate SIM lock once the bus/SIM is located.  */
end_comment

begin_function
specifier|static
name|int
name|xptioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xptdoioctl
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|addr
argument_list|,
name|flag
argument_list|,
name|td
argument_list|)
operator|)
operator|==
name|ENOTTY
condition|)
block|{
name|error
operator|=
name|cam_compat_ioctl
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|addr
argument_list|,
name|flag
argument_list|,
name|td
argument_list|,
name|xptdoioctl
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xptdoioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
comment|/* 	 * For the transport layer CAMIOCOMMAND ioctl, we really only want 	 * to accept CCB types that don't quite make sense to send through a 	 * passthrough driver. XPT_PATH_INQ is an exception to this, as stated 	 * in the CAM spec. 	 */
case|case
name|CAMIOCOMMAND
case|:
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|union
name|ccb
modifier|*
name|inccb
decl_stmt|;
name|struct
name|cam_eb
modifier|*
name|bus
decl_stmt|;
name|inccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|addr
expr_stmt|;
name|bus
operator|=
name|xpt_find_bus
argument_list|(
name|inccb
operator|->
name|ccb_h
operator|.
name|path_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
switch|switch
condition|(
name|inccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_SCAN_BUS
case|:
case|case
name|XPT_RESET_BUS
case|:
if|if
condition|(
name|inccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|!=
name|CAM_TARGET_WILDCARD
operator|||
name|inccb
operator|->
name|ccb_h
operator|.
name|target_lun
operator|!=
name|CAM_LUN_WILDCARD
condition|)
block|{
name|xpt_release_bus
argument_list|(
name|bus
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
break|break;
case|case
name|XPT_SCAN_TGT
case|:
if|if
condition|(
name|inccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|==
name|CAM_TARGET_WILDCARD
operator|||
name|inccb
operator|->
name|ccb_h
operator|.
name|target_lun
operator|!=
name|CAM_LUN_WILDCARD
condition|)
block|{
name|xpt_release_bus
argument_list|(
name|bus
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
break|break;
default|default:
break|break;
block|}
switch|switch
condition|(
name|inccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_SCAN_BUS
case|:
case|case
name|XPT_RESET_BUS
case|:
case|case
name|XPT_PATH_INQ
case|:
case|case
name|XPT_ENG_INQ
case|:
case|case
name|XPT_SCAN_LUN
case|:
case|case
name|XPT_SCAN_TGT
case|:
name|ccb
operator|=
name|xpt_alloc_ccb
argument_list|()
expr_stmt|;
comment|/* 			 * Create a path using the bus, target, and lun the 			 * user passed in. 			 */
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|NULL
argument_list|,
name|inccb
operator|->
name|ccb_h
operator|.
name|path_id
argument_list|,
name|inccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|inccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
name|xpt_free_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Ensure all of our fields are correct */
name|xpt_setup_ccb
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|inccb
operator|->
name|ccb_h
operator|.
name|pinfo
operator|.
name|priority
argument_list|)
expr_stmt|;
name|xpt_merge_ccb
argument_list|(
name|ccb
argument_list|,
name|inccb
argument_list|)
expr_stmt|;
name|xpt_path_lock
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|cam_periph_runccb
argument_list|(
name|ccb
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xpt_path_unlock
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|ccb
argument_list|,
name|inccb
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|ccb
argument_list|)
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|xpt_free_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_DEBUG
case|:
block|{
name|union
name|ccb
name|ccb
decl_stmt|;
comment|/* 			 * This is an immediate CCB, so it's okay to 			 * allocate it on the stack. 			 */
comment|/* 			 * Create a path using the bus, target, and lun the 			 * user passed in. 			 */
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|ccb
operator|.
name|ccb_h
operator|.
name|path
argument_list|,
name|NULL
argument_list|,
name|inccb
operator|->
name|ccb_h
operator|.
name|path_id
argument_list|,
name|inccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|inccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* Ensure all of our fields are correct */
name|xpt_setup_ccb
argument_list|(
operator|&
name|ccb
operator|.
name|ccb_h
argument_list|,
name|ccb
operator|.
name|ccb_h
operator|.
name|path
argument_list|,
name|inccb
operator|->
name|ccb_h
operator|.
name|pinfo
operator|.
name|priority
argument_list|)
expr_stmt|;
name|xpt_merge_ccb
argument_list|(
operator|&
name|ccb
argument_list|,
name|inccb
argument_list|)
expr_stmt|;
name|xpt_action
argument_list|(
operator|&
name|ccb
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|ccb
argument_list|,
name|inccb
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|ccb
argument_list|)
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|ccb
operator|.
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_DEV_MATCH
case|:
block|{
name|struct
name|cam_periph_map_info
name|mapinfo
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|old_path
decl_stmt|;
comment|/* 			 * We can't deal with physical addresses for this 			 * type of transaction. 			 */
if|if
condition|(
operator|(
name|inccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DATA_MASK
operator|)
operator|!=
name|CAM_DATA_VADDR
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* 			 * Save this in case the caller had it set to 			 * something in particular. 			 */
name|old_path
operator|=
name|inccb
operator|->
name|ccb_h
operator|.
name|path
expr_stmt|;
comment|/* 			 * We really don't need a path for the matching 			 * code.  The path is needed because of the 			 * debugging statements in xpt_action().  They 			 * assume that the CCB has a valid path. 			 */
name|inccb
operator|->
name|ccb_h
operator|.
name|path
operator|=
name|xpt_periph
operator|->
name|path
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|mapinfo
argument_list|,
sizeof|sizeof
argument_list|(
name|mapinfo
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * Map the pattern and match buffers into kernel 			 * virtual address space. 			 */
name|error
operator|=
name|cam_periph_mapmem
argument_list|(
name|inccb
argument_list|,
operator|&
name|mapinfo
argument_list|,
name|MAXPHYS
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|inccb
operator|->
name|ccb_h
operator|.
name|path
operator|=
name|old_path
expr_stmt|;
break|break;
block|}
comment|/* 			 * This is an immediate CCB, we can send it on directly. 			 */
name|xpt_action
argument_list|(
name|inccb
argument_list|)
expr_stmt|;
comment|/* 			 * Map the buffers back into user space. 			 */
name|cam_periph_unmapmem
argument_list|(
name|inccb
argument_list|,
operator|&
name|mapinfo
argument_list|)
expr_stmt|;
name|inccb
operator|->
name|ccb_h
operator|.
name|path
operator|=
name|old_path
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
default|default:
name|error
operator|=
name|ENOTSUP
expr_stmt|;
break|break;
block|}
name|xpt_release_bus
argument_list|(
name|bus
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	 * This is the getpassthru ioctl. It takes a XPT_GDEVLIST ccb as input, 	 * with the periphal driver name and unit name filled in.  The other 	 * fields don't really matter as input.  The passthrough driver name 	 * ("pass"), and unit number are passed back in the ccb.  The current 	 * device generation number, and the index into the device peripheral 	 * driver list, and the status are also passed back.  Note that 	 * since we do everything in one pass, unlike the XPT_GDEVLIST ccb, 	 * we never return a status of CAM_GDEVLIST_LIST_CHANGED.  It is 	 * (or rather should be) impossible for the device peripheral driver 	 * list to change since we look at the whole thing in one pass, and 	 * we do it with lock protection. 	 * 	 */
case|case
name|CAMGETPASSTHRU
case|:
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|periph_driver
modifier|*
modifier|*
name|p_drv
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|u_int
name|unit
decl_stmt|;
name|int
name|base_periph_found
decl_stmt|;
name|ccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|addr
expr_stmt|;
name|unit
operator|=
name|ccb
operator|->
name|cgdl
operator|.
name|unit_number
expr_stmt|;
name|name
operator|=
name|ccb
operator|->
name|cgdl
operator|.
name|periph_name
expr_stmt|;
name|base_periph_found
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Sanity check -- make sure we don't get a null peripheral 		 * driver name. 		 */
if|if
condition|(
operator|*
name|ccb
operator|->
name|cgdl
operator|.
name|periph_name
operator|==
literal|'\0'
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* Keep the list from changing while we traverse it */
name|xpt_lock_buses
argument_list|()
expr_stmt|;
comment|/* first find our driver in the list of drivers */
for|for
control|(
name|p_drv
operator|=
name|periph_drivers
init|;
operator|*
name|p_drv
operator|!=
name|NULL
condition|;
name|p_drv
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|(
operator|*
name|p_drv
operator|)
operator|->
name|driver_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|*
name|p_drv
operator|==
name|NULL
condition|)
block|{
name|xpt_unlock_buses
argument_list|()
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP_ERR
expr_stmt|;
name|ccb
operator|->
name|cgdl
operator|.
name|status
operator|=
name|CAM_GDEVLIST_ERROR
expr_stmt|;
operator|*
name|ccb
operator|->
name|cgdl
operator|.
name|periph_name
operator|=
literal|'\0'
expr_stmt|;
name|ccb
operator|->
name|cgdl
operator|.
name|unit_number
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
comment|/* 		 * Run through every peripheral instance of this driver 		 * and check to see whether it matches the unit passed 		 * in by the user.  If it does, get out of the loops and 		 * find the passthrough driver associated with that 		 * peripheral driver. 		 */
for|for
control|(
name|periph
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
operator|(
operator|*
name|p_drv
operator|)
operator|->
name|units
argument_list|)
init|;
name|periph
operator|!=
name|NULL
condition|;
name|periph
operator|=
name|TAILQ_NEXT
argument_list|(
name|periph
argument_list|,
name|unit_links
argument_list|)
control|)
block|{
if|if
condition|(
name|periph
operator|->
name|unit_number
operator|==
name|unit
condition|)
break|break;
block|}
comment|/* 		 * If we found the peripheral driver that the user passed 		 * in, go through all of the peripheral drivers for that 		 * particular device and look for a passthrough driver. 		 */
if|if
condition|(
name|periph
operator|!=
name|NULL
condition|)
block|{
name|struct
name|cam_ed
modifier|*
name|device
decl_stmt|;
name|int
name|i
decl_stmt|;
name|base_periph_found
operator|=
literal|1
expr_stmt|;
name|device
operator|=
name|periph
operator|->
name|path
operator|->
name|device
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|periph
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|device
operator|->
name|periphs
argument_list|)
init|;
name|periph
operator|!=
name|NULL
condition|;
name|periph
operator|=
name|SLIST_NEXT
argument_list|(
name|periph
argument_list|,
name|periph_links
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
comment|/* 				 * Check to see whether we have a 				 * passthrough device or not. 				 */
if|if
condition|(
name|strcmp
argument_list|(
name|periph
operator|->
name|periph_name
argument_list|,
literal|"pass"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 					 * Fill in the getdevlist fields. 					 */
name|strcpy
argument_list|(
name|ccb
operator|->
name|cgdl
operator|.
name|periph_name
argument_list|,
name|periph
operator|->
name|periph_name
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|cgdl
operator|.
name|unit_number
operator|=
name|periph
operator|->
name|unit_number
expr_stmt|;
if|if
condition|(
name|SLIST_NEXT
argument_list|(
name|periph
argument_list|,
name|periph_links
argument_list|)
condition|)
name|ccb
operator|->
name|cgdl
operator|.
name|status
operator|=
name|CAM_GDEVLIST_MORE_DEVS
expr_stmt|;
else|else
name|ccb
operator|->
name|cgdl
operator|.
name|status
operator|=
name|CAM_GDEVLIST_LAST_DEVICE
expr_stmt|;
name|ccb
operator|->
name|cgdl
operator|.
name|generation
operator|=
name|device
operator|->
name|generation
expr_stmt|;
name|ccb
operator|->
name|cgdl
operator|.
name|index
operator|=
name|i
expr_stmt|;
comment|/* 					 * Fill in some CCB header fields 					 * that the user may want. 					 */
name|ccb
operator|->
name|ccb_h
operator|.
name|path_id
operator|=
name|periph
operator|->
name|path
operator|->
name|bus
operator|->
name|path_id
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|=
name|periph
operator|->
name|path
operator|->
name|target
operator|->
name|target_id
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
operator|=
name|periph
operator|->
name|path
operator|->
name|device
operator|->
name|lun_id
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* 		 * If the periph is null here, one of two things has 		 * happened.  The first possibility is that we couldn't 		 * find the unit number of the particular peripheral driver 		 * that the user is asking about.  e.g. the user asks for 		 * the passthrough driver for "da11".  We find the list of 		 * "da" peripherals all right, but there is no unit 11. 		 * The other possibility is that we went through the list 		 * of peripheral drivers attached to the device structure, 		 * but didn't find one with the name "pass".  Either way, 		 * we return ENOENT, since we couldn't find something. 		 */
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP_ERR
expr_stmt|;
name|ccb
operator|->
name|cgdl
operator|.
name|status
operator|=
name|CAM_GDEVLIST_ERROR
expr_stmt|;
operator|*
name|ccb
operator|->
name|cgdl
operator|.
name|periph_name
operator|=
literal|'\0'
expr_stmt|;
name|ccb
operator|->
name|cgdl
operator|.
name|unit_number
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|ENOENT
expr_stmt|;
comment|/* 			 * It is unfortunate that this is even necessary, 			 * but there are many, many clueless users out there. 			 * If this is true, the user is looking for the 			 * passthrough driver, but doesn't have one in his 			 * kernel. 			 */
if|if
condition|(
name|base_periph_found
operator|==
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"xptioctl: pass driver is not in the "
literal|"kernel\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"xptioctl: put \"device pass\" in "
literal|"your kernel config file\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|xpt_unlock_buses
argument_list|()
expr_stmt|;
break|break;
block|}
default|default:
name|error
operator|=
name|ENOTTY
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cam_module_event_handler
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|MOD_LOAD
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|xpt_init
argument_list|(
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
break|break;
case|case
name|MOD_UNLOAD
case|:
return|return
name|EBUSY
return|;
default|default:
return|return
name|EOPNOTSUPP
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|xpt_proto
modifier|*
name|xpt_proto_find
parameter_list|(
name|cam_proto
name|proto
parameter_list|)
block|{
name|struct
name|xpt_proto
modifier|*
modifier|*
name|pp
decl_stmt|;
name|SET_FOREACH
argument_list|(
argument|pp
argument_list|,
argument|cam_xpt_proto_set
argument_list|)
block|{
if|if
condition|(
operator|(
operator|*
name|pp
operator|)
operator|->
name|proto
operator|==
name|proto
condition|)
return|return
operator|*
name|pp
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xpt_rescan_done
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|done_ccb
parameter_list|)
block|{
if|if
condition|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|ppriv_ptr1
operator|==
name|NULL
condition|)
block|{
name|xpt_free_path
argument_list|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|xpt_free_ccb
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|done_ccb
operator|->
name|ccb_h
operator|.
name|cbfcnp
operator|=
name|done_ccb
operator|->
name|ccb_h
operator|.
name|ppriv_ptr1
expr_stmt|;
call|(
modifier|*
name|done_ccb
operator|->
name|ccb_h
operator|.
name|cbfcnp
call|)
argument_list|(
name|periph
argument_list|,
name|done_ccb
argument_list|)
expr_stmt|;
block|}
name|xpt_release_boot
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* thread to handle bus rescans */
end_comment

begin_function
specifier|static
name|void
name|xpt_scanner_thread
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|cam_path
name|path
decl_stmt|;
name|xpt_lock_buses
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|xsoftc
operator|.
name|ccb_scanq
argument_list|)
condition|)
name|msleep
argument_list|(
operator|&
name|xsoftc
operator|.
name|ccb_scanq
argument_list|,
operator|&
name|xsoftc
operator|.
name|xpt_topo_lock
argument_list|,
name|PRIBIO
argument_list|,
literal|"-"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|TAILQ_FIRST
argument_list|(
operator|&
name|xsoftc
operator|.
name|ccb_scanq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|xsoftc
operator|.
name|ccb_scanq
argument_list|,
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|xpt_unlock_buses
argument_list|()
expr_stmt|;
comment|/* 			 * Since lock can be dropped inside and path freed 			 * by completion callback even before return here, 			 * take our own path copy for reference. 			 */
name|xpt_copy_path
argument_list|(
operator|&
name|path
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|xpt_path_lock
argument_list|(
operator|&
name|path
argument_list|)
expr_stmt|;
name|xpt_action
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|xpt_path_unlock
argument_list|(
operator|&
name|path
argument_list|)
expr_stmt|;
name|xpt_release_path
argument_list|(
operator|&
name|path
argument_list|)
expr_stmt|;
name|xpt_lock_buses
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|xpt_rescan
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|hdr
decl_stmt|;
comment|/* Prepare request */
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
operator|->
name|target
operator|->
name|target_id
operator|==
name|CAM_TARGET_WILDCARD
operator|&&
name|ccb
operator|->
name|ccb_h
operator|.
name|path
operator|->
name|device
operator|->
name|lun_id
operator|==
name|CAM_LUN_WILDCARD
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SCAN_BUS
expr_stmt|;
elseif|else
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
operator|->
name|target
operator|->
name|target_id
operator|!=
name|CAM_TARGET_WILDCARD
operator|&&
name|ccb
operator|->
name|ccb_h
operator|.
name|path
operator|->
name|device
operator|->
name|lun_id
operator|==
name|CAM_LUN_WILDCARD
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SCAN_TGT
expr_stmt|;
elseif|else
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
operator|->
name|target
operator|->
name|target_id
operator|!=
name|CAM_TARGET_WILDCARD
operator|&&
name|ccb
operator|->
name|ccb_h
operator|.
name|path
operator|->
name|device
operator|->
name|lun_id
operator|!=
name|CAM_LUN_WILDCARD
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SCAN_LUN
expr_stmt|;
else|else
block|{
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"illegal scan path\n"
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|xpt_free_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|CAM_DEBUG
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"xpt_rescan: func %#x %s\n"
operator|,
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|,
name|xpt_action_name
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|ppriv_ptr1
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|cbfcnp
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|cbfcnp
operator|=
name|xpt_rescan_done
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_PRIORITY_XPT
argument_list|)
expr_stmt|;
comment|/* Don't make duplicate entries for the same paths. */
name|xpt_lock_buses
argument_list|()
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|ppriv_ptr1
operator|==
name|NULL
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|hdr
argument_list|,
argument|&xsoftc.ccb_scanq
argument_list|,
argument|sim_links.tqe
argument_list|)
block|{
if|if
condition|(
name|xpt_path_comp
argument_list|(
name|hdr
operator|->
name|path
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
operator|==
literal|0
condition|)
block|{
name|wakeup
argument_list|(
operator|&
name|xsoftc
operator|.
name|ccb_scanq
argument_list|)
expr_stmt|;
name|xpt_unlock_buses
argument_list|()
expr_stmt|;
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"rescan already queued\n"
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|xpt_free_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|xsoftc
operator|.
name|ccb_scanq
argument_list|,
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|xsoftc
operator|.
name|buses_to_config
operator|++
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|xsoftc
operator|.
name|ccb_scanq
argument_list|)
expr_stmt|;
name|xpt_unlock_buses
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Functions accessed by the peripheral drivers */
end_comment

begin_function
specifier|static
name|int
name|xpt_init
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|struct
name|cam_sim
modifier|*
name|xpt_sim
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_busses
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|xsoftc
operator|.
name|ccb_scanq
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|xsoftc
operator|.
name|highpowerq
argument_list|)
expr_stmt|;
name|xsoftc
operator|.
name|num_highpower
operator|=
name|CAM_MAX_HIGHPOWER
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_lock
argument_list|,
literal|"XPT lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_highpower_lock
argument_list|,
literal|"XPT highpower lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|xsoftc
operator|.
name|xpt_taskq
operator|=
name|taskqueue_create
argument_list|(
literal|"CAM XPT task"
argument_list|,
name|M_WAITOK
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
comment|/*context*/
operator|&
name|xsoftc
operator|.
name|xpt_taskq
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CAM_BOOT_DELAY
comment|/* 	 * Override this value at compile time to assist our users 	 * who don't use loader to boot a kernel. 	 */
name|xsoftc
operator|.
name|boot_delay
operator|=
name|CAM_BOOT_DELAY
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * The xpt layer is, itself, the equivalent of a SIM. 	 * Allow 16 ccbs in the ccb pool for it.  This should 	 * give decent parallelism when we probe busses and 	 * perform other XPT functions. 	 */
name|devq
operator|=
name|cam_simq_alloc
argument_list|(
literal|16
argument_list|)
expr_stmt|;
name|xpt_sim
operator|=
name|cam_sim_alloc
argument_list|(
name|xptaction
argument_list|,
name|xptpoll
argument_list|,
literal|"xpt"
argument_list|,
comment|/*softc*/
name|NULL
argument_list|,
comment|/*unit*/
literal|0
argument_list|,
comment|/*mtx*/
operator|&
name|xsoftc
operator|.
name|xpt_lock
argument_list|,
comment|/*max_dev_transactions*/
literal|0
argument_list|,
comment|/*max_tagged_dev_transactions*/
literal|0
argument_list|,
name|devq
argument_list|)
expr_stmt|;
if|if
condition|(
name|xpt_sim
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|=
name|xpt_bus_register
argument_list|(
name|xpt_sim
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|CAM_SUCCESS
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_lock
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"xpt_init: xpt_bus_register failed with status %#x,"
literal|" failing attach\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Looking at the XPT from the SIM layer, the XPT is 	 * the equivalent of a peripheral driver.  Allocate 	 * a peripheral driver entry for us. 	 */
if|if
condition|(
operator|(
name|status
operator|=
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
name|NULL
argument_list|,
name|CAM_XPT_PATH_ID
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"xpt_init: xpt_create_path failed with status %#x,"
literal|" failing attach\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|xpt_path_lock
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|cam_periph_alloc
argument_list|(
name|xptregister
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|"xpt"
argument_list|,
name|CAM_PERIPH_BIO
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|xpt_sim
argument_list|)
expr_stmt|;
name|xpt_path_unlock
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|cam_num_doneqs
operator|<
literal|1
condition|)
name|cam_num_doneqs
operator|=
literal|1
operator|+
name|mp_ncpus
operator|/
literal|6
expr_stmt|;
elseif|else
if|if
condition|(
name|cam_num_doneqs
operator|>
name|MAXCPU
condition|)
name|cam_num_doneqs
operator|=
name|MAXCPU
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cam_num_doneqs
condition|;
name|i
operator|++
control|)
block|{
name|mtx_init
argument_list|(
operator|&
name|cam_doneqs
index|[
name|i
index|]
operator|.
name|cam_doneq_mtx
argument_list|,
literal|"CAM doneq"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|cam_doneqs
index|[
name|i
index|]
operator|.
name|cam_doneq
argument_list|)
expr_stmt|;
name|error
operator|=
name|kproc_kthread_add
argument_list|(
name|xpt_done_td
argument_list|,
operator|&
name|cam_doneqs
index|[
name|i
index|]
argument_list|,
operator|&
name|cam_proc
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cam"
argument_list|,
literal|"doneq%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|cam_num_doneqs
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|cam_num_doneqs
operator|<
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"xpt_init: Cannot init completion queues "
literal|"- failing attach\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* 	 * Register a callback for when interrupts are enabled. 	 */
name|xsoftc
operator|.
name|xpt_config_hook
operator|=
operator|(
expr|struct
name|intr_config_hook
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|intr_config_hook
argument_list|)
argument_list|,
name|M_CAMXPT
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|xsoftc
operator|.
name|xpt_config_hook
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"xpt_init: Cannot malloc config hook "
literal|"- failing attach\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|xsoftc
operator|.
name|xpt_config_hook
operator|->
name|ich_func
operator|=
name|xpt_config
expr_stmt|;
if|if
condition|(
name|config_intrhook_establish
argument_list|(
name|xsoftc
operator|.
name|xpt_config_hook
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|xsoftc
operator|.
name|xpt_config_hook
argument_list|,
name|M_CAMXPT
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"xpt_init: config_intrhook_establish failed "
literal|"- failing attach\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|cam_status
name|xptregister
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cam_sim
modifier|*
name|xpt_sim
decl_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"xptregister: periph was NULL!!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP_ERR
operator|)
return|;
block|}
name|xpt_sim
operator|=
operator|(
expr|struct
name|cam_sim
operator|*
operator|)
name|arg
expr_stmt|;
name|xpt_sim
operator|->
name|softc
operator|=
name|periph
expr_stmt|;
name|xpt_periph
operator|=
name|periph
expr_stmt|;
name|periph
operator|->
name|softc
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP
operator|)
return|;
block|}
end_function

begin_function
name|int32_t
name|xpt_add_periph
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|struct
name|cam_ed
modifier|*
name|device
decl_stmt|;
name|int32_t
name|status
decl_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|periph
operator|->
name|periph_run_task
argument_list|,
literal|0
argument_list|,
name|xpt_run_allocq_task
argument_list|,
name|periph
argument_list|)
expr_stmt|;
name|device
operator|=
name|periph
operator|->
name|path
operator|->
name|device
expr_stmt|;
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
if|if
condition|(
name|device
operator|!=
name|NULL
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|device
operator|->
name|target
operator|->
name|bus
operator|->
name|eb_mtx
argument_list|)
expr_stmt|;
name|device
operator|->
name|generation
operator|++
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|device
operator|->
name|periphs
argument_list|,
name|periph
argument_list|,
name|periph_links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|device
operator|->
name|target
operator|->
name|bus
operator|->
name|eb_mtx
argument_list|)
expr_stmt|;
name|atomic_add_32
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_generation
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
name|void
name|xpt_remove_periph
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|struct
name|cam_ed
modifier|*
name|device
decl_stmt|;
name|device
operator|=
name|periph
operator|->
name|path
operator|->
name|device
expr_stmt|;
if|if
condition|(
name|device
operator|!=
name|NULL
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|device
operator|->
name|target
operator|->
name|bus
operator|->
name|eb_mtx
argument_list|)
expr_stmt|;
name|device
operator|->
name|generation
operator|++
expr_stmt|;
name|SLIST_REMOVE
argument_list|(
operator|&
name|device
operator|->
name|periphs
argument_list|,
name|periph
argument_list|,
name|cam_periph
argument_list|,
name|periph_links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|device
operator|->
name|target
operator|->
name|bus
operator|->
name|eb_mtx
argument_list|)
expr_stmt|;
name|atomic_add_32
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_generation
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|xpt_announce_periph
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|char
modifier|*
name|announce_string
parameter_list|)
block|{
name|struct
name|cam_path
modifier|*
name|path
init|=
name|periph
operator|->
name|path
decl_stmt|;
name|struct
name|xpt_proto
modifier|*
name|proto
decl_stmt|;
name|cam_periph_assert
argument_list|(
name|periph
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|periph
operator|->
name|flags
operator||=
name|CAM_PERIPH_ANNOUNCED
expr_stmt|;
name|printf
argument_list|(
literal|"%s%d at %s%d bus %d scbus%d target %d lun %jx\n"
argument_list|,
name|periph
operator|->
name|periph_name
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|,
name|path
operator|->
name|bus
operator|->
name|sim
operator|->
name|sim_name
argument_list|,
name|path
operator|->
name|bus
operator|->
name|sim
operator|->
name|unit_number
argument_list|,
name|path
operator|->
name|bus
operator|->
name|sim
operator|->
name|bus_id
argument_list|,
name|path
operator|->
name|bus
operator|->
name|path_id
argument_list|,
name|path
operator|->
name|target
operator|->
name|target_id
argument_list|,
operator|(
name|uintmax_t
operator|)
name|path
operator|->
name|device
operator|->
name|lun_id
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s%d: "
argument_list|,
name|periph
operator|->
name|periph_name
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|)
expr_stmt|;
name|proto
operator|=
name|xpt_proto_find
argument_list|(
name|path
operator|->
name|device
operator|->
name|protocol
argument_list|)
expr_stmt|;
if|if
condition|(
name|proto
condition|)
name|proto
operator|->
name|ops
operator|->
name|announce
argument_list|(
name|path
operator|->
name|device
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s%d: Unknown protocol device %d\n"
argument_list|,
name|periph
operator|->
name|periph_name
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|,
name|path
operator|->
name|device
operator|->
name|protocol
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|->
name|device
operator|->
name|serial_num_len
operator|>
literal|0
condition|)
block|{
comment|/* Don't wrap the screen  - print only the first 60 chars */
name|printf
argument_list|(
literal|"%s%d: Serial Number %.60s\n"
argument_list|,
name|periph
operator|->
name|periph_name
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|,
name|path
operator|->
name|device
operator|->
name|serial_num
argument_list|)
expr_stmt|;
block|}
comment|/* Announce transport details. */
name|path
operator|->
name|bus
operator|->
name|xport
operator|->
name|ops
operator|->
name|announce
argument_list|(
name|periph
argument_list|)
expr_stmt|;
comment|/* Announce command queueing. */
if|if
condition|(
name|path
operator|->
name|device
operator|->
name|inq_flags
operator|&
name|SID_CmdQue
operator|||
name|path
operator|->
name|device
operator|->
name|flags
operator|&
name|CAM_DEV_TAG_AFTER_COUNT
condition|)
block|{
name|printf
argument_list|(
literal|"%s%d: Command Queueing enabled\n"
argument_list|,
name|periph
operator|->
name|periph_name
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|)
expr_stmt|;
block|}
comment|/* Announce caller's details if they've passed in. */
if|if
condition|(
name|announce_string
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"%s%d: %s\n"
argument_list|,
name|periph
operator|->
name|periph_name
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|,
name|announce_string
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xpt_announce_quirks
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|quirks
parameter_list|,
name|char
modifier|*
name|bit_string
parameter_list|)
block|{
if|if
condition|(
name|quirks
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s%d: quirks=0x%b\n"
argument_list|,
name|periph
operator|->
name|periph_name
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|,
name|quirks
argument_list|,
name|bit_string
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|xpt_denounce_periph
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|struct
name|cam_path
modifier|*
name|path
init|=
name|periph
operator|->
name|path
decl_stmt|;
name|struct
name|xpt_proto
modifier|*
name|proto
decl_stmt|;
name|cam_periph_assert
argument_list|(
name|periph
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s%d at %s%d bus %d scbus%d target %d lun %jx\n"
argument_list|,
name|periph
operator|->
name|periph_name
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|,
name|path
operator|->
name|bus
operator|->
name|sim
operator|->
name|sim_name
argument_list|,
name|path
operator|->
name|bus
operator|->
name|sim
operator|->
name|unit_number
argument_list|,
name|path
operator|->
name|bus
operator|->
name|sim
operator|->
name|bus_id
argument_list|,
name|path
operator|->
name|bus
operator|->
name|path_id
argument_list|,
name|path
operator|->
name|target
operator|->
name|target_id
argument_list|,
operator|(
name|uintmax_t
operator|)
name|path
operator|->
name|device
operator|->
name|lun_id
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s%d: "
argument_list|,
name|periph
operator|->
name|periph_name
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|)
expr_stmt|;
name|proto
operator|=
name|xpt_proto_find
argument_list|(
name|path
operator|->
name|device
operator|->
name|protocol
argument_list|)
expr_stmt|;
if|if
condition|(
name|proto
condition|)
name|proto
operator|->
name|ops
operator|->
name|denounce
argument_list|(
name|path
operator|->
name|device
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s%d: Unknown protocol device %d\n"
argument_list|,
name|periph
operator|->
name|periph_name
argument_list|,
name|periph
operator|->
name|unit_number
argument_list|,
name|path
operator|->
name|device
operator|->
name|protocol
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|->
name|device
operator|->
name|serial_num_len
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|" s/n %.60s"
argument_list|,
name|path
operator|->
name|device
operator|->
name|serial_num
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" detached\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|xpt_getattr
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|attr
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|)
block|{
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|,
name|l
decl_stmt|;
name|struct
name|ccb_dev_advinfo
name|cdai
decl_stmt|;
name|struct
name|scsi_vpd_id_descriptor
modifier|*
name|idd
decl_stmt|;
name|xpt_path_assert
argument_list|(
name|path
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cdai
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cdai
argument_list|)
argument_list|)
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|cdai
operator|.
name|ccb_h
argument_list|,
name|path
argument_list|,
name|CAM_PRIORITY_NORMAL
argument_list|)
expr_stmt|;
name|cdai
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_DEV_ADVINFO
expr_stmt|;
name|cdai
operator|.
name|bufsiz
operator|=
name|len
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|attr
argument_list|,
literal|"GEOM::ident"
argument_list|)
condition|)
name|cdai
operator|.
name|buftype
operator|=
name|CDAI_TYPE_SERIAL_NUM
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|attr
argument_list|,
literal|"GEOM::physpath"
argument_list|)
condition|)
name|cdai
operator|.
name|buftype
operator|=
name|CDAI_TYPE_PHYS_PATH
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|attr
argument_list|,
literal|"GEOM::lunid"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|attr
argument_list|,
literal|"GEOM::lunname"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cdai
operator|.
name|buftype
operator|=
name|CDAI_TYPE_SCSI_DEVID
expr_stmt|;
name|cdai
operator|.
name|bufsiz
operator|=
name|CAM_SCSI_DEVID_MAXLEN
expr_stmt|;
block|}
else|else
goto|goto
name|out
goto|;
name|cdai
operator|.
name|buf
operator|=
name|malloc
argument_list|(
name|cdai
operator|.
name|bufsiz
argument_list|,
name|M_CAMXPT
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdai
operator|.
name|buf
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|cdai
argument_list|)
expr_stmt|;
comment|/* can only be synchronous */
if|if
condition|(
operator|(
name|cdai
operator|.
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|!=
literal|0
condition|)
name|cam_release_devq
argument_list|(
name|cdai
operator|.
name|ccb_h
operator|.
name|path
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdai
operator|.
name|provsiz
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|cdai
operator|.
name|buftype
operator|==
name|CDAI_TYPE_SCSI_DEVID
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|attr
argument_list|,
literal|"GEOM::lunid"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|idd
operator|=
name|scsi_get_devid
argument_list|(
operator|(
expr|struct
name|scsi_vpd_device_id
operator|*
operator|)
name|cdai
operator|.
name|buf
argument_list|,
name|cdai
operator|.
name|provsiz
argument_list|,
name|scsi_devid_is_lun_naa
argument_list|)
expr_stmt|;
if|if
condition|(
name|idd
operator|==
name|NULL
condition|)
name|idd
operator|=
name|scsi_get_devid
argument_list|(
operator|(
expr|struct
name|scsi_vpd_device_id
operator|*
operator|)
name|cdai
operator|.
name|buf
argument_list|,
name|cdai
operator|.
name|provsiz
argument_list|,
name|scsi_devid_is_lun_eui64
argument_list|)
expr_stmt|;
block|}
else|else
name|idd
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|idd
operator|==
name|NULL
condition|)
name|idd
operator|=
name|scsi_get_devid
argument_list|(
operator|(
expr|struct
name|scsi_vpd_device_id
operator|*
operator|)
name|cdai
operator|.
name|buf
argument_list|,
name|cdai
operator|.
name|provsiz
argument_list|,
name|scsi_devid_is_lun_t10
argument_list|)
expr_stmt|;
if|if
condition|(
name|idd
operator|==
name|NULL
condition|)
name|idd
operator|=
name|scsi_get_devid
argument_list|(
operator|(
expr|struct
name|scsi_vpd_device_id
operator|*
operator|)
name|cdai
operator|.
name|buf
argument_list|,
name|cdai
operator|.
name|provsiz
argument_list|,
name|scsi_devid_is_lun_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|idd
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
name|ret
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|idd
operator|->
name|proto_codeset
operator|&
name|SVPD_ID_CODESET_MASK
operator|)
operator|==
name|SVPD_ID_CODESET_ASCII
condition|)
block|{
if|if
condition|(
name|idd
operator|->
name|length
operator|<
name|len
condition|)
block|{
for|for
control|(
name|l
operator|=
literal|0
init|;
name|l
operator|<
name|idd
operator|->
name|length
condition|;
name|l
operator|++
control|)
name|buf
index|[
name|l
index|]
operator|=
name|idd
operator|->
name|identifier
index|[
name|l
index|]
condition|?
name|idd
operator|->
name|identifier
index|[
name|l
index|]
else|:
literal|' '
expr_stmt|;
name|buf
index|[
name|l
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|EFAULT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|idd
operator|->
name|proto_codeset
operator|&
name|SVPD_ID_CODESET_MASK
operator|)
operator|==
name|SVPD_ID_CODESET_UTF8
condition|)
block|{
name|l
operator|=
name|strnlen
argument_list|(
name|idd
operator|->
name|identifier
argument_list|,
name|idd
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|<
name|len
condition|)
block|{
name|bcopy
argument_list|(
name|idd
operator|->
name|identifier
argument_list|,
name|buf
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|buf
index|[
name|l
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|EFAULT
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|idd
operator|->
name|length
operator|*
literal|2
operator|<
name|len
condition|)
block|{
for|for
control|(
name|l
operator|=
literal|0
init|;
name|l
operator|<
name|idd
operator|->
name|length
condition|;
name|l
operator|++
control|)
name|sprintf
argument_list|(
name|buf
operator|+
name|l
operator|*
literal|2
argument_list|,
literal|"%02x"
argument_list|,
name|idd
operator|->
name|identifier
index|[
name|l
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|EFAULT
expr_stmt|;
block|}
block|}
else|else
block|{
name|ret
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strlcpy
argument_list|(
name|buf
argument_list|,
name|cdai
operator|.
name|buf
argument_list|,
name|len
argument_list|)
operator|>=
name|len
condition|)
name|ret
operator|=
name|EFAULT
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|cdai
operator|.
name|buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|cdai
operator|.
name|buf
argument_list|,
name|M_CAMXPT
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|dev_match_ret
name|xptbusmatch
parameter_list|(
name|struct
name|dev_match_pattern
modifier|*
name|patterns
parameter_list|,
name|u_int
name|num_patterns
parameter_list|,
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|)
block|{
name|dev_match_ret
name|retval
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|retval
operator|=
name|DM_RET_NONE
expr_stmt|;
comment|/* 	 * If we aren't given something to match against, that's an error. 	 */
if|if
condition|(
name|bus
operator|==
name|NULL
condition|)
return|return
operator|(
name|DM_RET_ERROR
operator|)
return|;
comment|/* 	 * If there are no match entries, then this bus matches no 	 * matter what. 	 */
if|if
condition|(
operator|(
name|patterns
operator|==
name|NULL
operator|)
operator|||
operator|(
name|num_patterns
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|DM_RET_DESCEND
operator||
name|DM_RET_COPY
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_patterns
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|bus_match_pattern
modifier|*
name|cur_pattern
decl_stmt|;
comment|/* 		 * If the pattern in question isn't for a bus node, we 		 * aren't interested.  However, we do indicate to the 		 * calling routine that we should continue descending the 		 * tree, since the user wants to match against lower-level 		 * EDT elements. 		 */
if|if
condition|(
name|patterns
index|[
name|i
index|]
operator|.
name|type
operator|!=
name|DEV_MATCH_BUS
condition|)
block|{
if|if
condition|(
operator|(
name|retval
operator|&
name|DM_RET_ACTION_MASK
operator|)
operator|==
name|DM_RET_NONE
condition|)
name|retval
operator||=
name|DM_RET_DESCEND
expr_stmt|;
continue|continue;
block|}
name|cur_pattern
operator|=
operator|&
name|patterns
index|[
name|i
index|]
operator|.
name|pattern
operator|.
name|bus_pattern
expr_stmt|;
comment|/* 		 * If they want to match any bus node, we give them any 		 * device node. 		 */
if|if
condition|(
name|cur_pattern
operator|->
name|flags
operator|==
name|BUS_MATCH_ANY
condition|)
block|{
comment|/* set the copy flag */
name|retval
operator||=
name|DM_RET_COPY
expr_stmt|;
comment|/* 			 * If we've already decided on an action, go ahead 			 * and return. 			 */
if|if
condition|(
operator|(
name|retval
operator|&
name|DM_RET_ACTION_MASK
operator|)
operator|!=
name|DM_RET_NONE
condition|)
return|return
operator|(
name|retval
operator|)
return|;
block|}
comment|/* 		 * Not sure why someone would do this... 		 */
if|if
condition|(
name|cur_pattern
operator|->
name|flags
operator|==
name|BUS_MATCH_NONE
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|cur_pattern
operator|->
name|flags
operator|&
name|BUS_MATCH_PATH
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|cur_pattern
operator|->
name|path_id
operator|!=
name|bus
operator|->
name|path_id
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|cur_pattern
operator|->
name|flags
operator|&
name|BUS_MATCH_BUS_ID
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|cur_pattern
operator|->
name|bus_id
operator|!=
name|bus
operator|->
name|sim
operator|->
name|bus_id
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|cur_pattern
operator|->
name|flags
operator|&
name|BUS_MATCH_UNIT
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|cur_pattern
operator|->
name|unit_number
operator|!=
name|bus
operator|->
name|sim
operator|->
name|unit_number
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|cur_pattern
operator|->
name|flags
operator|&
name|BUS_MATCH_NAME
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|cur_pattern
operator|->
name|dev_name
argument_list|,
name|bus
operator|->
name|sim
operator|->
name|sim_name
argument_list|,
name|DEV_IDLEN
argument_list|)
operator|!=
literal|0
operator|)
condition|)
continue|continue;
comment|/* 		 * If we get to this point, the user definitely wants 		 * information on this bus.  So tell the caller to copy the 		 * data out. 		 */
name|retval
operator||=
name|DM_RET_COPY
expr_stmt|;
comment|/* 		 * If the return action has been set to descend, then we 		 * know that we've already seen a non-bus matching 		 * expression, therefore we need to further descend the tree. 		 * This won't change by continuing around the loop, so we 		 * go ahead and return.  If we haven't seen a non-bus 		 * matching expression, we keep going around the loop until 		 * we exhaust the matching expressions.  We'll set the stop 		 * flag once we fall out of the loop. 		 */
if|if
condition|(
operator|(
name|retval
operator|&
name|DM_RET_ACTION_MASK
operator|)
operator|==
name|DM_RET_DESCEND
condition|)
return|return
operator|(
name|retval
operator|)
return|;
block|}
comment|/* 	 * If the return action hasn't been set to descend yet, that means 	 * we haven't seen anything other than bus matching patterns.  So 	 * tell the caller to stop descending the tree -- the user doesn't 	 * want to match against lower level tree elements. 	 */
if|if
condition|(
operator|(
name|retval
operator|&
name|DM_RET_ACTION_MASK
operator|)
operator|==
name|DM_RET_NONE
condition|)
name|retval
operator||=
name|DM_RET_STOP
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|dev_match_ret
name|xptdevicematch
parameter_list|(
name|struct
name|dev_match_pattern
modifier|*
name|patterns
parameter_list|,
name|u_int
name|num_patterns
parameter_list|,
name|struct
name|cam_ed
modifier|*
name|device
parameter_list|)
block|{
name|dev_match_ret
name|retval
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|retval
operator|=
name|DM_RET_NONE
expr_stmt|;
comment|/* 	 * If we aren't given something to match against, that's an error. 	 */
if|if
condition|(
name|device
operator|==
name|NULL
condition|)
return|return
operator|(
name|DM_RET_ERROR
operator|)
return|;
comment|/* 	 * If there are no match entries, then this device matches no 	 * matter what. 	 */
if|if
condition|(
operator|(
name|patterns
operator|==
name|NULL
operator|)
operator|||
operator|(
name|num_patterns
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|DM_RET_DESCEND
operator||
name|DM_RET_COPY
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_patterns
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|device_match_pattern
modifier|*
name|cur_pattern
decl_stmt|;
name|struct
name|scsi_vpd_device_id
modifier|*
name|device_id_page
decl_stmt|;
comment|/* 		 * If the pattern in question isn't for a device node, we 		 * aren't interested. 		 */
if|if
condition|(
name|patterns
index|[
name|i
index|]
operator|.
name|type
operator|!=
name|DEV_MATCH_DEVICE
condition|)
block|{
if|if
condition|(
operator|(
name|patterns
index|[
name|i
index|]
operator|.
name|type
operator|==
name|DEV_MATCH_PERIPH
operator|)
operator|&&
operator|(
operator|(
name|retval
operator|&
name|DM_RET_ACTION_MASK
operator|)
operator|==
name|DM_RET_NONE
operator|)
condition|)
name|retval
operator||=
name|DM_RET_DESCEND
expr_stmt|;
continue|continue;
block|}
name|cur_pattern
operator|=
operator|&
name|patterns
index|[
name|i
index|]
operator|.
name|pattern
operator|.
name|device_pattern
expr_stmt|;
comment|/* Error out if mutually exclusive options are specified. */
if|if
condition|(
operator|(
name|cur_pattern
operator|->
name|flags
operator|&
operator|(
name|DEV_MATCH_INQUIRY
operator||
name|DEV_MATCH_DEVID
operator|)
operator|)
operator|==
operator|(
name|DEV_MATCH_INQUIRY
operator||
name|DEV_MATCH_DEVID
operator|)
condition|)
return|return
operator|(
name|DM_RET_ERROR
operator|)
return|;
comment|/* 		 * If they want to match any device node, we give them any 		 * device node. 		 */
if|if
condition|(
name|cur_pattern
operator|->
name|flags
operator|==
name|DEV_MATCH_ANY
condition|)
goto|goto
name|copy_dev_node
goto|;
comment|/* 		 * Not sure why someone would do this... 		 */
if|if
condition|(
name|cur_pattern
operator|->
name|flags
operator|==
name|DEV_MATCH_NONE
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|cur_pattern
operator|->
name|flags
operator|&
name|DEV_MATCH_PATH
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|cur_pattern
operator|->
name|path_id
operator|!=
name|device
operator|->
name|target
operator|->
name|bus
operator|->
name|path_id
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|cur_pattern
operator|->
name|flags
operator|&
name|DEV_MATCH_TARGET
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|cur_pattern
operator|->
name|target_id
operator|!=
name|device
operator|->
name|target
operator|->
name|target_id
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|cur_pattern
operator|->
name|flags
operator|&
name|DEV_MATCH_LUN
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|cur_pattern
operator|->
name|target_lun
operator|!=
name|device
operator|->
name|lun_id
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|cur_pattern
operator|->
name|flags
operator|&
name|DEV_MATCH_INQUIRY
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|cam_quirkmatch
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|device
operator|->
name|inq_data
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|cur_pattern
operator|->
name|data
operator|.
name|inq_pat
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|cur_pattern
operator|->
name|data
operator|.
name|inq_pat
argument_list|)
argument_list|,
name|scsi_static_inquiry_match
argument_list|)
operator|==
name|NULL
operator|)
condition|)
continue|continue;
name|device_id_page
operator|=
operator|(
expr|struct
name|scsi_vpd_device_id
operator|*
operator|)
name|device
operator|->
name|device_id
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|cur_pattern
operator|->
name|flags
operator|&
name|DEV_MATCH_DEVID
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|device
operator|->
name|device_id_len
operator|<
name|SVPD_DEVICE_ID_HDR_LEN
operator|||
name|scsi_devid_match
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|device_id_page
operator|->
name|desc_list
argument_list|,
name|device
operator|->
name|device_id_len
operator|-
name|SVPD_DEVICE_ID_HDR_LEN
argument_list|,
name|cur_pattern
operator|->
name|data
operator|.
name|devid_pat
operator|.
name|id
argument_list|,
name|cur_pattern
operator|->
name|data
operator|.
name|devid_pat
operator|.
name|id_len
argument_list|)
operator|!=
literal|0
operator|)
condition|)
continue|continue;
name|copy_dev_node
label|:
comment|/* 		 * If we get to this point, the user definitely wants 		 * information on this device.  So tell the caller to copy 		 * the data out. 		 */
name|retval
operator||=
name|DM_RET_COPY
expr_stmt|;
comment|/* 		 * If the return action has been set to descend, then we 		 * know that we've already seen a peripheral matching 		 * expression, therefore we need to further descend the tree. 		 * This won't change by continuing around the loop, so we 		 * go ahead and return.  If we haven't seen a peripheral 		 * matching expression, we keep going around the loop until 		 * we exhaust the matching expressions.  We'll set the stop 		 * flag once we fall out of the loop. 		 */
if|if
condition|(
operator|(
name|retval
operator|&
name|DM_RET_ACTION_MASK
operator|)
operator|==
name|DM_RET_DESCEND
condition|)
return|return
operator|(
name|retval
operator|)
return|;
block|}
comment|/* 	 * If the return action hasn't been set to descend yet, that means 	 * we haven't seen any peripheral matching patterns.  So tell the 	 * caller to stop descending the tree -- the user doesn't want to 	 * match against lower level tree elements. 	 */
if|if
condition|(
operator|(
name|retval
operator|&
name|DM_RET_ACTION_MASK
operator|)
operator|==
name|DM_RET_NONE
condition|)
name|retval
operator||=
name|DM_RET_STOP
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Match a single peripheral against any number of match patterns.  */
end_comment

begin_function
specifier|static
name|dev_match_ret
name|xptperiphmatch
parameter_list|(
name|struct
name|dev_match_pattern
modifier|*
name|patterns
parameter_list|,
name|u_int
name|num_patterns
parameter_list|,
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|dev_match_ret
name|retval
decl_stmt|;
name|u_int
name|i
decl_stmt|;
comment|/* 	 * If we aren't given something to match against, that's an error. 	 */
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
return|return
operator|(
name|DM_RET_ERROR
operator|)
return|;
comment|/* 	 * If there are no match entries, then this peripheral matches no 	 * matter what. 	 */
if|if
condition|(
operator|(
name|patterns
operator|==
name|NULL
operator|)
operator|||
operator|(
name|num_patterns
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|DM_RET_STOP
operator||
name|DM_RET_COPY
operator|)
return|;
comment|/* 	 * There aren't any nodes below a peripheral node, so there's no 	 * reason to descend the tree any further. 	 */
name|retval
operator|=
name|DM_RET_STOP
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_patterns
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|periph_match_pattern
modifier|*
name|cur_pattern
decl_stmt|;
comment|/* 		 * If the pattern in question isn't for a peripheral, we 		 * aren't interested. 		 */
if|if
condition|(
name|patterns
index|[
name|i
index|]
operator|.
name|type
operator|!=
name|DEV_MATCH_PERIPH
condition|)
continue|continue;
name|cur_pattern
operator|=
operator|&
name|patterns
index|[
name|i
index|]
operator|.
name|pattern
operator|.
name|periph_pattern
expr_stmt|;
comment|/* 		 * If they want to match on anything, then we will do so. 		 */
if|if
condition|(
name|cur_pattern
operator|->
name|flags
operator|==
name|PERIPH_MATCH_ANY
condition|)
block|{
comment|/* set the copy flag */
name|retval
operator||=
name|DM_RET_COPY
expr_stmt|;
comment|/* 			 * We've already set the return action to stop, 			 * since there are no nodes below peripherals in 			 * the tree. 			 */
return|return
operator|(
name|retval
operator|)
return|;
block|}
comment|/* 		 * Not sure why someone would do this... 		 */
if|if
condition|(
name|cur_pattern
operator|->
name|flags
operator|==
name|PERIPH_MATCH_NONE
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|cur_pattern
operator|->
name|flags
operator|&
name|PERIPH_MATCH_PATH
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|cur_pattern
operator|->
name|path_id
operator|!=
name|periph
operator|->
name|path
operator|->
name|bus
operator|->
name|path_id
operator|)
condition|)
continue|continue;
comment|/* 		 * For the target and lun id's, we have to make sure the 		 * target and lun pointers aren't NULL.  The xpt peripheral 		 * has a wildcard target and device. 		 */
if|if
condition|(
operator|(
operator|(
name|cur_pattern
operator|->
name|flags
operator|&
name|PERIPH_MATCH_TARGET
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|periph
operator|->
name|path
operator|->
name|target
operator|==
name|NULL
operator|)
operator|||
operator|(
name|cur_pattern
operator|->
name|target_id
operator|!=
name|periph
operator|->
name|path
operator|->
name|target
operator|->
name|target_id
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|cur_pattern
operator|->
name|flags
operator|&
name|PERIPH_MATCH_LUN
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|periph
operator|->
name|path
operator|->
name|device
operator|==
name|NULL
operator|)
operator|||
operator|(
name|cur_pattern
operator|->
name|target_lun
operator|!=
name|periph
operator|->
name|path
operator|->
name|device
operator|->
name|lun_id
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|cur_pattern
operator|->
name|flags
operator|&
name|PERIPH_MATCH_UNIT
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|cur_pattern
operator|->
name|unit_number
operator|!=
name|periph
operator|->
name|unit_number
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|cur_pattern
operator|->
name|flags
operator|&
name|PERIPH_MATCH_NAME
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|cur_pattern
operator|->
name|periph_name
argument_list|,
name|periph
operator|->
name|periph_name
argument_list|,
name|DEV_IDLEN
argument_list|)
operator|!=
literal|0
operator|)
condition|)
continue|continue;
comment|/* 		 * If we get to this point, the user definitely wants 		 * information on this peripheral.  So tell the caller to 		 * copy the data out. 		 */
name|retval
operator||=
name|DM_RET_COPY
expr_stmt|;
comment|/* 		 * The return action has already been set to stop, since 		 * peripherals don't have any nodes below them in the EDT. 		 */
return|return
operator|(
name|retval
operator|)
return|;
block|}
comment|/* 	 * If we get to this point, the peripheral that was passed in 	 * doesn't match any of the patterns. 	 */
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xptedtbusfunc
parameter_list|(
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ccb_dev_match
modifier|*
name|cdm
decl_stmt|;
name|struct
name|cam_et
modifier|*
name|target
decl_stmt|;
name|dev_match_ret
name|retval
decl_stmt|;
name|cdm
operator|=
operator|(
expr|struct
name|ccb_dev_match
operator|*
operator|)
name|arg
expr_stmt|;
comment|/* 	 * If our position is for something deeper in the tree, that means 	 * that we've already seen this node.  So, we keep going down. 	 */
if|if
condition|(
operator|(
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|&
name|CAM_DEV_POS_BUS
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|bus
operator|==
name|bus
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|&
name|CAM_DEV_POS_TARGET
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|target
operator|!=
name|NULL
operator|)
condition|)
name|retval
operator|=
name|DM_RET_DESCEND
expr_stmt|;
else|else
name|retval
operator|=
name|xptbusmatch
argument_list|(
name|cdm
operator|->
name|patterns
argument_list|,
name|cdm
operator|->
name|num_patterns
argument_list|,
name|bus
argument_list|)
expr_stmt|;
comment|/* 	 * If we got an error, bail out of the search. 	 */
if|if
condition|(
operator|(
name|retval
operator|&
name|DM_RET_ACTION_MASK
operator|)
operator|==
name|DM_RET_ERROR
condition|)
block|{
name|cdm
operator|->
name|status
operator|=
name|CAM_DEV_MATCH_ERROR
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If the copy flag is set, copy this bus out. 	 */
if|if
condition|(
name|retval
operator|&
name|DM_RET_COPY
condition|)
block|{
name|int
name|spaceleft
decl_stmt|,
name|j
decl_stmt|;
name|spaceleft
operator|=
name|cdm
operator|->
name|match_buf_len
operator|-
operator|(
name|cdm
operator|->
name|num_matches
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dev_match_result
argument_list|)
operator|)
expr_stmt|;
comment|/* 		 * If we don't have enough space to put in another 		 * match result, save our position and tell the 		 * user there are more devices to check. 		 */
if|if
condition|(
name|spaceleft
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|dev_match_result
argument_list|)
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|cdm
operator|->
name|pos
argument_list|,
sizeof|sizeof
argument_list|(
name|cdm
operator|->
name|pos
argument_list|)
argument_list|)
expr_stmt|;
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|=
name|CAM_DEV_POS_EDT
operator||
name|CAM_DEV_POS_BUS
expr_stmt|;
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|bus
operator|=
name|bus
expr_stmt|;
name|cdm
operator|->
name|pos
operator|.
name|generations
index|[
name|CAM_BUS_GENERATION
index|]
operator|=
name|xsoftc
operator|.
name|bus_generation
expr_stmt|;
name|cdm
operator|->
name|status
operator|=
name|CAM_DEV_MATCH_MORE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|j
operator|=
name|cdm
operator|->
name|num_matches
expr_stmt|;
name|cdm
operator|->
name|num_matches
operator|++
expr_stmt|;
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|type
operator|=
name|DEV_MATCH_BUS
expr_stmt|;
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|result
operator|.
name|bus_result
operator|.
name|path_id
operator|=
name|bus
operator|->
name|path_id
expr_stmt|;
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|result
operator|.
name|bus_result
operator|.
name|bus_id
operator|=
name|bus
operator|->
name|sim
operator|->
name|bus_id
expr_stmt|;
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|result
operator|.
name|bus_result
operator|.
name|unit_number
operator|=
name|bus
operator|->
name|sim
operator|->
name|unit_number
expr_stmt|;
name|strncpy
argument_list|(
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|result
operator|.
name|bus_result
operator|.
name|dev_name
argument_list|,
name|bus
operator|->
name|sim
operator|->
name|sim_name
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the user is only interested in busses, there's no 	 * reason to descend to the next level in the tree. 	 */
if|if
condition|(
operator|(
name|retval
operator|&
name|DM_RET_ACTION_MASK
operator|)
operator|==
name|DM_RET_STOP
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * If there is a target generation recorded, check it to 	 * make sure the target list hasn't changed. 	 */
name|mtx_lock
argument_list|(
operator|&
name|bus
operator|->
name|eb_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|&
name|CAM_DEV_POS_BUS
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|bus
operator|==
name|bus
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|&
name|CAM_DEV_POS_TARGET
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|target
operator|!=
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|cdm
operator|->
name|pos
operator|.
name|generations
index|[
name|CAM_TARGET_GENERATION
index|]
operator|!=
name|bus
operator|->
name|generation
operator|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|bus
operator|->
name|eb_mtx
argument_list|)
expr_stmt|;
name|cdm
operator|->
name|status
operator|=
name|CAM_DEV_MATCH_LIST_CHANGED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|target
operator|=
operator|(
expr|struct
name|cam_et
operator|*
operator|)
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|target
expr_stmt|;
name|target
operator|->
name|refcount
operator|++
expr_stmt|;
block|}
else|else
name|target
operator|=
name|NULL
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|bus
operator|->
name|eb_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|xpttargettraverse
argument_list|(
name|bus
argument_list|,
name|target
argument_list|,
name|xptedttargetfunc
argument_list|,
name|arg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xptedttargetfunc
parameter_list|(
name|struct
name|cam_et
modifier|*
name|target
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ccb_dev_match
modifier|*
name|cdm
decl_stmt|;
name|struct
name|cam_eb
modifier|*
name|bus
decl_stmt|;
name|struct
name|cam_ed
modifier|*
name|device
decl_stmt|;
name|cdm
operator|=
operator|(
expr|struct
name|ccb_dev_match
operator|*
operator|)
name|arg
expr_stmt|;
name|bus
operator|=
name|target
operator|->
name|bus
expr_stmt|;
comment|/* 	 * If there is a device list generation recorded, check it to 	 * make sure the device list hasn't changed. 	 */
name|mtx_lock
argument_list|(
operator|&
name|bus
operator|->
name|eb_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|&
name|CAM_DEV_POS_BUS
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|bus
operator|==
name|bus
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|&
name|CAM_DEV_POS_TARGET
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|target
operator|==
name|target
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|&
name|CAM_DEV_POS_DEVICE
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|device
operator|!=
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|cdm
operator|->
name|pos
operator|.
name|generations
index|[
name|CAM_DEV_GENERATION
index|]
operator|!=
name|target
operator|->
name|generation
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|bus
operator|->
name|eb_mtx
argument_list|)
expr_stmt|;
name|cdm
operator|->
name|status
operator|=
name|CAM_DEV_MATCH_LIST_CHANGED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|device
operator|=
operator|(
expr|struct
name|cam_ed
operator|*
operator|)
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|device
expr_stmt|;
name|device
operator|->
name|refcount
operator|++
expr_stmt|;
block|}
else|else
name|device
operator|=
name|NULL
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|bus
operator|->
name|eb_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|xptdevicetraverse
argument_list|(
name|target
argument_list|,
name|device
argument_list|,
name|xptedtdevicefunc
argument_list|,
name|arg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xptedtdevicefunc
parameter_list|(
name|struct
name|cam_ed
modifier|*
name|device
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cam_eb
modifier|*
name|bus
decl_stmt|;
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|ccb_dev_match
modifier|*
name|cdm
decl_stmt|;
name|dev_match_ret
name|retval
decl_stmt|;
name|cdm
operator|=
operator|(
expr|struct
name|ccb_dev_match
operator|*
operator|)
name|arg
expr_stmt|;
name|bus
operator|=
name|device
operator|->
name|target
operator|->
name|bus
expr_stmt|;
comment|/* 	 * If our position is for something deeper in the tree, that means 	 * that we've already seen this node.  So, we keep going down. 	 */
if|if
condition|(
operator|(
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|&
name|CAM_DEV_POS_DEVICE
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|device
operator|==
name|device
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|&
name|CAM_DEV_POS_PERIPH
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|periph
operator|!=
name|NULL
operator|)
condition|)
name|retval
operator|=
name|DM_RET_DESCEND
expr_stmt|;
else|else
name|retval
operator|=
name|xptdevicematch
argument_list|(
name|cdm
operator|->
name|patterns
argument_list|,
name|cdm
operator|->
name|num_patterns
argument_list|,
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|retval
operator|&
name|DM_RET_ACTION_MASK
operator|)
operator|==
name|DM_RET_ERROR
condition|)
block|{
name|cdm
operator|->
name|status
operator|=
name|CAM_DEV_MATCH_ERROR
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If the copy flag is set, copy this device out. 	 */
if|if
condition|(
name|retval
operator|&
name|DM_RET_COPY
condition|)
block|{
name|int
name|spaceleft
decl_stmt|,
name|j
decl_stmt|;
name|spaceleft
operator|=
name|cdm
operator|->
name|match_buf_len
operator|-
operator|(
name|cdm
operator|->
name|num_matches
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dev_match_result
argument_list|)
operator|)
expr_stmt|;
comment|/* 		 * If we don't have enough space to put in another 		 * match result, save our position and tell the 		 * user there are more devices to check. 		 */
if|if
condition|(
name|spaceleft
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|dev_match_result
argument_list|)
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|cdm
operator|->
name|pos
argument_list|,
sizeof|sizeof
argument_list|(
name|cdm
operator|->
name|pos
argument_list|)
argument_list|)
expr_stmt|;
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|=
name|CAM_DEV_POS_EDT
operator||
name|CAM_DEV_POS_BUS
operator||
name|CAM_DEV_POS_TARGET
operator||
name|CAM_DEV_POS_DEVICE
expr_stmt|;
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|bus
operator|=
name|device
operator|->
name|target
operator|->
name|bus
expr_stmt|;
name|cdm
operator|->
name|pos
operator|.
name|generations
index|[
name|CAM_BUS_GENERATION
index|]
operator|=
name|xsoftc
operator|.
name|bus_generation
expr_stmt|;
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|target
operator|=
name|device
operator|->
name|target
expr_stmt|;
name|cdm
operator|->
name|pos
operator|.
name|generations
index|[
name|CAM_TARGET_GENERATION
index|]
operator|=
name|device
operator|->
name|target
operator|->
name|bus
operator|->
name|generation
expr_stmt|;
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|device
operator|=
name|device
expr_stmt|;
name|cdm
operator|->
name|pos
operator|.
name|generations
index|[
name|CAM_DEV_GENERATION
index|]
operator|=
name|device
operator|->
name|target
operator|->
name|generation
expr_stmt|;
name|cdm
operator|->
name|status
operator|=
name|CAM_DEV_MATCH_MORE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|j
operator|=
name|cdm
operator|->
name|num_matches
expr_stmt|;
name|cdm
operator|->
name|num_matches
operator|++
expr_stmt|;
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|type
operator|=
name|DEV_MATCH_DEVICE
expr_stmt|;
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|result
operator|.
name|device_result
operator|.
name|path_id
operator|=
name|device
operator|->
name|target
operator|->
name|bus
operator|->
name|path_id
expr_stmt|;
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|result
operator|.
name|device_result
operator|.
name|target_id
operator|=
name|device
operator|->
name|target
operator|->
name|target_id
expr_stmt|;
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|result
operator|.
name|device_result
operator|.
name|target_lun
operator|=
name|device
operator|->
name|lun_id
expr_stmt|;
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|result
operator|.
name|device_result
operator|.
name|protocol
operator|=
name|device
operator|->
name|protocol
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|device
operator|->
name|inq_data
argument_list|,
operator|&
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|result
operator|.
name|device_result
operator|.
name|inq_data
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_inquiry_data
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|device
operator|->
name|ident_data
argument_list|,
operator|&
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|result
operator|.
name|device_result
operator|.
name|ident_data
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ata_params
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Let the user know whether this device is unconfigured */
if|if
condition|(
name|device
operator|->
name|flags
operator|&
name|CAM_DEV_UNCONFIGURED
condition|)
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|result
operator|.
name|device_result
operator|.
name|flags
operator|=
name|DEV_RESULT_UNCONFIGURED
expr_stmt|;
else|else
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|result
operator|.
name|device_result
operator|.
name|flags
operator|=
name|DEV_RESULT_NOFLAG
expr_stmt|;
block|}
comment|/* 	 * If the user isn't interested in peripherals, don't descend 	 * the tree any further. 	 */
if|if
condition|(
operator|(
name|retval
operator|&
name|DM_RET_ACTION_MASK
operator|)
operator|==
name|DM_RET_STOP
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * If there is a peripheral list generation recorded, make sure 	 * it hasn't changed. 	 */
name|xpt_lock_buses
argument_list|()
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|bus
operator|->
name|eb_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|&
name|CAM_DEV_POS_BUS
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|bus
operator|==
name|bus
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|&
name|CAM_DEV_POS_TARGET
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|target
operator|==
name|device
operator|->
name|target
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|&
name|CAM_DEV_POS_DEVICE
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|device
operator|==
name|device
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|&
name|CAM_DEV_POS_PERIPH
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|periph
operator|!=
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|cdm
operator|->
name|pos
operator|.
name|generations
index|[
name|CAM_PERIPH_GENERATION
index|]
operator|!=
name|device
operator|->
name|generation
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|bus
operator|->
name|eb_mtx
argument_list|)
expr_stmt|;
name|xpt_unlock_buses
argument_list|()
expr_stmt|;
name|cdm
operator|->
name|status
operator|=
name|CAM_DEV_MATCH_LIST_CHANGED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|periph
operator|=
operator|(
expr|struct
name|cam_periph
operator|*
operator|)
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|periph
expr_stmt|;
name|periph
operator|->
name|refcount
operator|++
expr_stmt|;
block|}
else|else
name|periph
operator|=
name|NULL
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|bus
operator|->
name|eb_mtx
argument_list|)
expr_stmt|;
name|xpt_unlock_buses
argument_list|()
expr_stmt|;
return|return
operator|(
name|xptperiphtraverse
argument_list|(
name|device
argument_list|,
name|periph
argument_list|,
name|xptedtperiphfunc
argument_list|,
name|arg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xptedtperiphfunc
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ccb_dev_match
modifier|*
name|cdm
decl_stmt|;
name|dev_match_ret
name|retval
decl_stmt|;
name|cdm
operator|=
operator|(
expr|struct
name|ccb_dev_match
operator|*
operator|)
name|arg
expr_stmt|;
name|retval
operator|=
name|xptperiphmatch
argument_list|(
name|cdm
operator|->
name|patterns
argument_list|,
name|cdm
operator|->
name|num_patterns
argument_list|,
name|periph
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|retval
operator|&
name|DM_RET_ACTION_MASK
operator|)
operator|==
name|DM_RET_ERROR
condition|)
block|{
name|cdm
operator|->
name|status
operator|=
name|CAM_DEV_MATCH_ERROR
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If the copy flag is set, copy this peripheral out. 	 */
if|if
condition|(
name|retval
operator|&
name|DM_RET_COPY
condition|)
block|{
name|int
name|spaceleft
decl_stmt|,
name|j
decl_stmt|;
name|spaceleft
operator|=
name|cdm
operator|->
name|match_buf_len
operator|-
operator|(
name|cdm
operator|->
name|num_matches
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dev_match_result
argument_list|)
operator|)
expr_stmt|;
comment|/* 		 * If we don't have enough space to put in another 		 * match result, save our position and tell the 		 * user there are more devices to check. 		 */
if|if
condition|(
name|spaceleft
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|dev_match_result
argument_list|)
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|cdm
operator|->
name|pos
argument_list|,
sizeof|sizeof
argument_list|(
name|cdm
operator|->
name|pos
argument_list|)
argument_list|)
expr_stmt|;
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|=
name|CAM_DEV_POS_EDT
operator||
name|CAM_DEV_POS_BUS
operator||
name|CAM_DEV_POS_TARGET
operator||
name|CAM_DEV_POS_DEVICE
operator||
name|CAM_DEV_POS_PERIPH
expr_stmt|;
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|bus
operator|=
name|periph
operator|->
name|path
operator|->
name|bus
expr_stmt|;
name|cdm
operator|->
name|pos
operator|.
name|generations
index|[
name|CAM_BUS_GENERATION
index|]
operator|=
name|xsoftc
operator|.
name|bus_generation
expr_stmt|;
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|target
operator|=
name|periph
operator|->
name|path
operator|->
name|target
expr_stmt|;
name|cdm
operator|->
name|pos
operator|.
name|generations
index|[
name|CAM_TARGET_GENERATION
index|]
operator|=
name|periph
operator|->
name|path
operator|->
name|bus
operator|->
name|generation
expr_stmt|;
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|device
operator|=
name|periph
operator|->
name|path
operator|->
name|device
expr_stmt|;
name|cdm
operator|->
name|pos
operator|.
name|generations
index|[
name|CAM_DEV_GENERATION
index|]
operator|=
name|periph
operator|->
name|path
operator|->
name|target
operator|->
name|generation
expr_stmt|;
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|periph
operator|=
name|periph
expr_stmt|;
name|cdm
operator|->
name|pos
operator|.
name|generations
index|[
name|CAM_PERIPH_GENERATION
index|]
operator|=
name|periph
operator|->
name|path
operator|->
name|device
operator|->
name|generation
expr_stmt|;
name|cdm
operator|->
name|status
operator|=
name|CAM_DEV_MATCH_MORE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|j
operator|=
name|cdm
operator|->
name|num_matches
expr_stmt|;
name|cdm
operator|->
name|num_matches
operator|++
expr_stmt|;
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|type
operator|=
name|DEV_MATCH_PERIPH
expr_stmt|;
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|result
operator|.
name|periph_result
operator|.
name|path_id
operator|=
name|periph
operator|->
name|path
operator|->
name|bus
operator|->
name|path_id
expr_stmt|;
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|result
operator|.
name|periph_result
operator|.
name|target_id
operator|=
name|periph
operator|->
name|path
operator|->
name|target
operator|->
name|target_id
expr_stmt|;
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|result
operator|.
name|periph_result
operator|.
name|target_lun
operator|=
name|periph
operator|->
name|path
operator|->
name|device
operator|->
name|lun_id
expr_stmt|;
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|result
operator|.
name|periph_result
operator|.
name|unit_number
operator|=
name|periph
operator|->
name|unit_number
expr_stmt|;
name|strncpy
argument_list|(
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|result
operator|.
name|periph_result
operator|.
name|periph_name
argument_list|,
name|periph
operator|->
name|periph_name
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xptedtmatch
parameter_list|(
name|struct
name|ccb_dev_match
modifier|*
name|cdm
parameter_list|)
block|{
name|struct
name|cam_eb
modifier|*
name|bus
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|cdm
operator|->
name|num_matches
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Check the bus list generation.  If it has changed, the user 	 * needs to reset everything and start over. 	 */
name|xpt_lock_buses
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|&
name|CAM_DEV_POS_BUS
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|bus
operator|!=
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|cdm
operator|->
name|pos
operator|.
name|generations
index|[
name|CAM_BUS_GENERATION
index|]
operator|!=
name|xsoftc
operator|.
name|bus_generation
condition|)
block|{
name|xpt_unlock_buses
argument_list|()
expr_stmt|;
name|cdm
operator|->
name|status
operator|=
name|CAM_DEV_MATCH_LIST_CHANGED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|bus
operator|=
operator|(
expr|struct
name|cam_eb
operator|*
operator|)
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|bus
expr_stmt|;
name|bus
operator|->
name|refcount
operator|++
expr_stmt|;
block|}
else|else
name|bus
operator|=
name|NULL
expr_stmt|;
name|xpt_unlock_buses
argument_list|()
expr_stmt|;
name|ret
operator|=
name|xptbustraverse
argument_list|(
name|bus
argument_list|,
name|xptedtbusfunc
argument_list|,
name|cdm
argument_list|)
expr_stmt|;
comment|/* 	 * If we get back 0, that means that we had to stop before fully 	 * traversing the EDT.  It also means that one of the subroutines 	 * has set the status field to the proper value.  If we get back 1, 	 * we've fully traversed the EDT and copied out any matching entries. 	 */
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
name|cdm
operator|->
name|status
operator|=
name|CAM_DEV_MATCH_LAST
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xptplistpdrvfunc
parameter_list|(
name|struct
name|periph_driver
modifier|*
modifier|*
name|pdrv
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|struct
name|ccb_dev_match
modifier|*
name|cdm
decl_stmt|;
name|cdm
operator|=
operator|(
expr|struct
name|ccb_dev_match
operator|*
operator|)
name|arg
expr_stmt|;
name|xpt_lock_buses
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|&
name|CAM_DEV_POS_PDPTR
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|pdrv
operator|==
name|pdrv
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|&
name|CAM_DEV_POS_PERIPH
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|periph
operator|!=
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|cdm
operator|->
name|pos
operator|.
name|generations
index|[
name|CAM_PERIPH_GENERATION
index|]
operator|!=
operator|(
operator|*
name|pdrv
operator|)
operator|->
name|generation
condition|)
block|{
name|xpt_unlock_buses
argument_list|()
expr_stmt|;
name|cdm
operator|->
name|status
operator|=
name|CAM_DEV_MATCH_LIST_CHANGED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|periph
operator|=
operator|(
expr|struct
name|cam_periph
operator|*
operator|)
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|periph
expr_stmt|;
name|periph
operator|->
name|refcount
operator|++
expr_stmt|;
block|}
else|else
name|periph
operator|=
name|NULL
expr_stmt|;
name|xpt_unlock_buses
argument_list|()
expr_stmt|;
return|return
operator|(
name|xptpdperiphtraverse
argument_list|(
name|pdrv
argument_list|,
name|periph
argument_list|,
name|xptplistperiphfunc
argument_list|,
name|arg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xptplistperiphfunc
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ccb_dev_match
modifier|*
name|cdm
decl_stmt|;
name|dev_match_ret
name|retval
decl_stmt|;
name|cdm
operator|=
operator|(
expr|struct
name|ccb_dev_match
operator|*
operator|)
name|arg
expr_stmt|;
name|retval
operator|=
name|xptperiphmatch
argument_list|(
name|cdm
operator|->
name|patterns
argument_list|,
name|cdm
operator|->
name|num_patterns
argument_list|,
name|periph
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|retval
operator|&
name|DM_RET_ACTION_MASK
operator|)
operator|==
name|DM_RET_ERROR
condition|)
block|{
name|cdm
operator|->
name|status
operator|=
name|CAM_DEV_MATCH_ERROR
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If the copy flag is set, copy this peripheral out. 	 */
if|if
condition|(
name|retval
operator|&
name|DM_RET_COPY
condition|)
block|{
name|int
name|spaceleft
decl_stmt|,
name|j
decl_stmt|;
name|spaceleft
operator|=
name|cdm
operator|->
name|match_buf_len
operator|-
operator|(
name|cdm
operator|->
name|num_matches
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dev_match_result
argument_list|)
operator|)
expr_stmt|;
comment|/* 		 * If we don't have enough space to put in another 		 * match result, save our position and tell the 		 * user there are more devices to check. 		 */
if|if
condition|(
name|spaceleft
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|dev_match_result
argument_list|)
condition|)
block|{
name|struct
name|periph_driver
modifier|*
modifier|*
name|pdrv
decl_stmt|;
name|pdrv
operator|=
name|NULL
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|cdm
operator|->
name|pos
argument_list|,
sizeof|sizeof
argument_list|(
name|cdm
operator|->
name|pos
argument_list|)
argument_list|)
expr_stmt|;
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|=
name|CAM_DEV_POS_PDRV
operator||
name|CAM_DEV_POS_PDPTR
operator||
name|CAM_DEV_POS_PERIPH
expr_stmt|;
comment|/* 			 * This may look a bit non-sensical, but it is 			 * actually quite logical.  There are very few 			 * peripheral drivers, and bloating every peripheral 			 * structure with a pointer back to its parent 			 * peripheral driver linker set entry would cost 			 * more in the long run than doing this quick lookup. 			 */
for|for
control|(
name|pdrv
operator|=
name|periph_drivers
init|;
operator|*
name|pdrv
operator|!=
name|NULL
condition|;
name|pdrv
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|(
operator|*
name|pdrv
operator|)
operator|->
name|driver_name
argument_list|,
name|periph
operator|->
name|periph_name
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
operator|*
name|pdrv
operator|==
name|NULL
condition|)
block|{
name|cdm
operator|->
name|status
operator|=
name|CAM_DEV_MATCH_ERROR
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|pdrv
operator|=
name|pdrv
expr_stmt|;
comment|/* 			 * The periph generation slot does double duty, as 			 * does the periph pointer slot.  They are used for 			 * both edt and pdrv lookups and positioning. 			 */
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|periph
operator|=
name|periph
expr_stmt|;
name|cdm
operator|->
name|pos
operator|.
name|generations
index|[
name|CAM_PERIPH_GENERATION
index|]
operator|=
operator|(
operator|*
name|pdrv
operator|)
operator|->
name|generation
expr_stmt|;
name|cdm
operator|->
name|status
operator|=
name|CAM_DEV_MATCH_MORE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|j
operator|=
name|cdm
operator|->
name|num_matches
expr_stmt|;
name|cdm
operator|->
name|num_matches
operator|++
expr_stmt|;
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|type
operator|=
name|DEV_MATCH_PERIPH
expr_stmt|;
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|result
operator|.
name|periph_result
operator|.
name|path_id
operator|=
name|periph
operator|->
name|path
operator|->
name|bus
operator|->
name|path_id
expr_stmt|;
comment|/* 		 * The transport layer peripheral doesn't have a target or 		 * lun. 		 */
if|if
condition|(
name|periph
operator|->
name|path
operator|->
name|target
condition|)
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|result
operator|.
name|periph_result
operator|.
name|target_id
operator|=
name|periph
operator|->
name|path
operator|->
name|target
operator|->
name|target_id
expr_stmt|;
else|else
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|result
operator|.
name|periph_result
operator|.
name|target_id
operator|=
name|CAM_TARGET_WILDCARD
expr_stmt|;
if|if
condition|(
name|periph
operator|->
name|path
operator|->
name|device
condition|)
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|result
operator|.
name|periph_result
operator|.
name|target_lun
operator|=
name|periph
operator|->
name|path
operator|->
name|device
operator|->
name|lun_id
expr_stmt|;
else|else
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|result
operator|.
name|periph_result
operator|.
name|target_lun
operator|=
name|CAM_LUN_WILDCARD
expr_stmt|;
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|result
operator|.
name|periph_result
operator|.
name|unit_number
operator|=
name|periph
operator|->
name|unit_number
expr_stmt|;
name|strncpy
argument_list|(
name|cdm
operator|->
name|matches
index|[
name|j
index|]
operator|.
name|result
operator|.
name|periph_result
operator|.
name|periph_name
argument_list|,
name|periph
operator|->
name|periph_name
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xptperiphlistmatch
parameter_list|(
name|struct
name|ccb_dev_match
modifier|*
name|cdm
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|cdm
operator|->
name|num_matches
operator|=
literal|0
expr_stmt|;
comment|/* 	 * At this point in the edt traversal function, we check the bus 	 * list generation to make sure that no busses have been added or 	 * removed since the user last sent a XPT_DEV_MATCH ccb through. 	 * For the peripheral driver list traversal function, however, we 	 * don't have to worry about new peripheral driver types coming or 	 * going; they're in a linker set, and therefore can't change 	 * without a recompile. 	 */
if|if
condition|(
operator|(
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|&
name|CAM_DEV_POS_PDPTR
operator|)
operator|&&
operator|(
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|pdrv
operator|!=
name|NULL
operator|)
condition|)
name|ret
operator|=
name|xptpdrvtraverse
argument_list|(
operator|(
expr|struct
name|periph_driver
operator|*
operator|*
operator|)
name|cdm
operator|->
name|pos
operator|.
name|cookie
operator|.
name|pdrv
argument_list|,
name|xptplistpdrvfunc
argument_list|,
name|cdm
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|xptpdrvtraverse
argument_list|(
name|NULL
argument_list|,
name|xptplistpdrvfunc
argument_list|,
name|cdm
argument_list|)
expr_stmt|;
comment|/* 	 * If we get back 0, that means that we had to stop before fully 	 * traversing the peripheral driver tree.  It also means that one of 	 * the subroutines has set the status field to the proper value.  If 	 * we get back 1, we've fully traversed the EDT and copied out any 	 * matching entries. 	 */
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
name|cdm
operator|->
name|status
operator|=
name|CAM_DEV_MATCH_LAST
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xptbustraverse
parameter_list|(
name|struct
name|cam_eb
modifier|*
name|start_bus
parameter_list|,
name|xpt_busfunc_t
modifier|*
name|tr_func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cam_eb
modifier|*
name|bus
decl_stmt|,
modifier|*
name|next_bus
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|start_bus
condition|)
name|bus
operator|=
name|start_bus
expr_stmt|;
else|else
block|{
name|xpt_lock_buses
argument_list|()
expr_stmt|;
name|bus
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_busses
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus
operator|==
name|NULL
condition|)
block|{
name|xpt_unlock_buses
argument_list|()
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
name|bus
operator|->
name|refcount
operator|++
expr_stmt|;
name|xpt_unlock_buses
argument_list|()
expr_stmt|;
block|}
for|for
control|(
init|;
name|bus
operator|!=
name|NULL
condition|;
name|bus
operator|=
name|next_bus
control|)
block|{
name|retval
operator|=
name|tr_func
argument_list|(
name|bus
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
block|{
name|xpt_release_bus
argument_list|(
name|bus
argument_list|)
expr_stmt|;
break|break;
block|}
name|xpt_lock_buses
argument_list|()
expr_stmt|;
name|next_bus
operator|=
name|TAILQ_NEXT
argument_list|(
name|bus
argument_list|,
name|links
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_bus
condition|)
name|next_bus
operator|->
name|refcount
operator|++
expr_stmt|;
name|xpt_unlock_buses
argument_list|()
expr_stmt|;
name|xpt_release_bus
argument_list|(
name|bus
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xpttargettraverse
parameter_list|(
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|,
name|struct
name|cam_et
modifier|*
name|start_target
parameter_list|,
name|xpt_targetfunc_t
modifier|*
name|tr_func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cam_et
modifier|*
name|target
decl_stmt|,
modifier|*
name|next_target
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|start_target
condition|)
name|target
operator|=
name|start_target
expr_stmt|;
else|else
block|{
name|mtx_lock
argument_list|(
operator|&
name|bus
operator|->
name|eb_mtx
argument_list|)
expr_stmt|;
name|target
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|bus
operator|->
name|et_entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|bus
operator|->
name|eb_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
name|target
operator|->
name|refcount
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|bus
operator|->
name|eb_mtx
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|target
operator|!=
name|NULL
condition|;
name|target
operator|=
name|next_target
control|)
block|{
name|retval
operator|=
name|tr_func
argument_list|(
name|target
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
block|{
name|xpt_release_target
argument_list|(
name|target
argument_list|)
expr_stmt|;
break|break;
block|}
name|mtx_lock
argument_list|(
operator|&
name|bus
operator|->
name|eb_mtx
argument_list|)
expr_stmt|;
name|next_target
operator|=
name|TAILQ_NEXT
argument_list|(
name|target
argument_list|,
name|links
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_target
condition|)
name|next_target
operator|->
name|refcount
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|bus
operator|->
name|eb_mtx
argument_list|)
expr_stmt|;
name|xpt_release_target
argument_list|(
name|target
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xptdevicetraverse
parameter_list|(
name|struct
name|cam_et
modifier|*
name|target
parameter_list|,
name|struct
name|cam_ed
modifier|*
name|start_device
parameter_list|,
name|xpt_devicefunc_t
modifier|*
name|tr_func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cam_eb
modifier|*
name|bus
decl_stmt|;
name|struct
name|cam_ed
modifier|*
name|device
decl_stmt|,
modifier|*
name|next_device
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
name|bus
operator|=
name|target
operator|->
name|bus
expr_stmt|;
if|if
condition|(
name|start_device
condition|)
name|device
operator|=
name|start_device
expr_stmt|;
else|else
block|{
name|mtx_lock
argument_list|(
operator|&
name|bus
operator|->
name|eb_mtx
argument_list|)
expr_stmt|;
name|device
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|target
operator|->
name|ed_entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|device
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|bus
operator|->
name|eb_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
name|device
operator|->
name|refcount
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|bus
operator|->
name|eb_mtx
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|device
operator|!=
name|NULL
condition|;
name|device
operator|=
name|next_device
control|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|device
operator|->
name|device_mtx
argument_list|)
expr_stmt|;
name|retval
operator|=
name|tr_func
argument_list|(
name|device
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|device
operator|->
name|device_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
block|{
name|xpt_release_device
argument_list|(
name|device
argument_list|)
expr_stmt|;
break|break;
block|}
name|mtx_lock
argument_list|(
operator|&
name|bus
operator|->
name|eb_mtx
argument_list|)
expr_stmt|;
name|next_device
operator|=
name|TAILQ_NEXT
argument_list|(
name|device
argument_list|,
name|links
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_device
condition|)
name|next_device
operator|->
name|refcount
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|bus
operator|->
name|eb_mtx
argument_list|)
expr_stmt|;
name|xpt_release_device
argument_list|(
name|device
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xptperiphtraverse
parameter_list|(
name|struct
name|cam_ed
modifier|*
name|device
parameter_list|,
name|struct
name|cam_periph
modifier|*
name|start_periph
parameter_list|,
name|xpt_periphfunc_t
modifier|*
name|tr_func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cam_eb
modifier|*
name|bus
decl_stmt|;
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|,
modifier|*
name|next_periph
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
name|bus
operator|=
name|device
operator|->
name|target
operator|->
name|bus
expr_stmt|;
if|if
condition|(
name|start_periph
condition|)
name|periph
operator|=
name|start_periph
expr_stmt|;
else|else
block|{
name|xpt_lock_buses
argument_list|()
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|bus
operator|->
name|eb_mtx
argument_list|)
expr_stmt|;
name|periph
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|device
operator|->
name|periphs
argument_list|)
expr_stmt|;
while|while
condition|(
name|periph
operator|!=
name|NULL
operator|&&
operator|(
name|periph
operator|->
name|flags
operator|&
name|CAM_PERIPH_FREE
operator|)
operator|!=
literal|0
condition|)
name|periph
operator|=
name|SLIST_NEXT
argument_list|(
name|periph
argument_list|,
name|periph_links
argument_list|)
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|bus
operator|->
name|eb_mtx
argument_list|)
expr_stmt|;
name|xpt_unlock_buses
argument_list|()
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
name|periph
operator|->
name|refcount
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|bus
operator|->
name|eb_mtx
argument_list|)
expr_stmt|;
name|xpt_unlock_buses
argument_list|()
expr_stmt|;
block|}
for|for
control|(
init|;
name|periph
operator|!=
name|NULL
condition|;
name|periph
operator|=
name|next_periph
control|)
block|{
name|retval
operator|=
name|tr_func
argument_list|(
name|periph
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
block|{
name|cam_periph_release_locked
argument_list|(
name|periph
argument_list|)
expr_stmt|;
break|break;
block|}
name|xpt_lock_buses
argument_list|()
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|bus
operator|->
name|eb_mtx
argument_list|)
expr_stmt|;
name|next_periph
operator|=
name|SLIST_NEXT
argument_list|(
name|periph
argument_list|,
name|periph_links
argument_list|)
expr_stmt|;
while|while
condition|(
name|next_periph
operator|!=
name|NULL
operator|&&
operator|(
name|next_periph
operator|->
name|flags
operator|&
name|CAM_PERIPH_FREE
operator|)
operator|!=
literal|0
condition|)
name|next_periph
operator|=
name|SLIST_NEXT
argument_list|(
name|next_periph
argument_list|,
name|periph_links
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_periph
condition|)
name|next_periph
operator|->
name|refcount
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|bus
operator|->
name|eb_mtx
argument_list|)
expr_stmt|;
name|xpt_unlock_buses
argument_list|()
expr_stmt|;
name|cam_periph_release_locked
argument_list|(
name|periph
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xptpdrvtraverse
parameter_list|(
name|struct
name|periph_driver
modifier|*
modifier|*
name|start_pdrv
parameter_list|,
name|xpt_pdrvfunc_t
modifier|*
name|tr_func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|periph_driver
modifier|*
modifier|*
name|pdrv
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
comment|/* 	 * We don't traverse the peripheral driver list like we do the 	 * other lists, because it is a linker set, and therefore cannot be 	 * changed during runtime.  If the peripheral driver list is ever 	 * re-done to be something other than a linker set (i.e. it can 	 * change while the system is running), the list traversal should 	 * be modified to work like the other traversal functions. 	 */
for|for
control|(
name|pdrv
operator|=
operator|(
name|start_pdrv
condition|?
name|start_pdrv
else|:
name|periph_drivers
operator|)
init|;
operator|*
name|pdrv
operator|!=
name|NULL
condition|;
name|pdrv
operator|++
control|)
block|{
name|retval
operator|=
name|tr_func
argument_list|(
name|pdrv
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
return|return
operator|(
name|retval
operator|)
return|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xptpdperiphtraverse
parameter_list|(
name|struct
name|periph_driver
modifier|*
modifier|*
name|pdrv
parameter_list|,
name|struct
name|cam_periph
modifier|*
name|start_periph
parameter_list|,
name|xpt_periphfunc_t
modifier|*
name|tr_func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|,
modifier|*
name|next_periph
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|start_periph
condition|)
name|periph
operator|=
name|start_periph
expr_stmt|;
else|else
block|{
name|xpt_lock_buses
argument_list|()
expr_stmt|;
name|periph
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
operator|(
operator|*
name|pdrv
operator|)
operator|->
name|units
argument_list|)
expr_stmt|;
while|while
condition|(
name|periph
operator|!=
name|NULL
operator|&&
operator|(
name|periph
operator|->
name|flags
operator|&
name|CAM_PERIPH_FREE
operator|)
operator|!=
literal|0
condition|)
name|periph
operator|=
name|TAILQ_NEXT
argument_list|(
name|periph
argument_list|,
name|unit_links
argument_list|)
expr_stmt|;
if|if
condition|(
name|periph
operator|==
name|NULL
condition|)
block|{
name|xpt_unlock_buses
argument_list|()
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
name|periph
operator|->
name|refcount
operator|++
expr_stmt|;
name|xpt_unlock_buses
argument_list|()
expr_stmt|;
block|}
for|for
control|(
init|;
name|periph
operator|!=
name|NULL
condition|;
name|periph
operator|=
name|next_periph
control|)
block|{
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|retval
operator|=
name|tr_func
argument_list|(
name|periph
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
block|{
name|cam_periph_release
argument_list|(
name|periph
argument_list|)
expr_stmt|;
break|break;
block|}
name|xpt_lock_buses
argument_list|()
expr_stmt|;
name|next_periph
operator|=
name|TAILQ_NEXT
argument_list|(
name|periph
argument_list|,
name|unit_links
argument_list|)
expr_stmt|;
while|while
condition|(
name|next_periph
operator|!=
name|NULL
operator|&&
operator|(
name|next_periph
operator|->
name|flags
operator|&
name|CAM_PERIPH_FREE
operator|)
operator|!=
literal|0
condition|)
name|next_periph
operator|=
name|TAILQ_NEXT
argument_list|(
name|next_periph
argument_list|,
name|unit_links
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_periph
condition|)
name|next_periph
operator|->
name|refcount
operator|++
expr_stmt|;
name|xpt_unlock_buses
argument_list|()
expr_stmt|;
name|cam_periph_release
argument_list|(
name|periph
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xptdefbusfunc
parameter_list|(
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|xpt_traverse_config
modifier|*
name|tr_config
decl_stmt|;
name|tr_config
operator|=
operator|(
expr|struct
name|xpt_traverse_config
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|tr_config
operator|->
name|depth
operator|==
name|XPT_DEPTH_BUS
condition|)
block|{
name|xpt_busfunc_t
modifier|*
name|tr_func
decl_stmt|;
name|tr_func
operator|=
operator|(
name|xpt_busfunc_t
operator|*
operator|)
name|tr_config
operator|->
name|tr_func
expr_stmt|;
return|return
operator|(
name|tr_func
argument_list|(
name|bus
argument_list|,
name|tr_config
operator|->
name|tr_arg
argument_list|)
operator|)
return|;
block|}
else|else
return|return
operator|(
name|xpttargettraverse
argument_list|(
name|bus
argument_list|,
name|NULL
argument_list|,
name|xptdeftargetfunc
argument_list|,
name|arg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xptdeftargetfunc
parameter_list|(
name|struct
name|cam_et
modifier|*
name|target
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|xpt_traverse_config
modifier|*
name|tr_config
decl_stmt|;
name|tr_config
operator|=
operator|(
expr|struct
name|xpt_traverse_config
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|tr_config
operator|->
name|depth
operator|==
name|XPT_DEPTH_TARGET
condition|)
block|{
name|xpt_targetfunc_t
modifier|*
name|tr_func
decl_stmt|;
name|tr_func
operator|=
operator|(
name|xpt_targetfunc_t
operator|*
operator|)
name|tr_config
operator|->
name|tr_func
expr_stmt|;
return|return
operator|(
name|tr_func
argument_list|(
name|target
argument_list|,
name|tr_config
operator|->
name|tr_arg
argument_list|)
operator|)
return|;
block|}
else|else
return|return
operator|(
name|xptdevicetraverse
argument_list|(
name|target
argument_list|,
name|NULL
argument_list|,
name|xptdefdevicefunc
argument_list|,
name|arg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xptdefdevicefunc
parameter_list|(
name|struct
name|cam_ed
modifier|*
name|device
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|xpt_traverse_config
modifier|*
name|tr_config
decl_stmt|;
name|tr_config
operator|=
operator|(
expr|struct
name|xpt_traverse_config
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|tr_config
operator|->
name|depth
operator|==
name|XPT_DEPTH_DEVICE
condition|)
block|{
name|xpt_devicefunc_t
modifier|*
name|tr_func
decl_stmt|;
name|tr_func
operator|=
operator|(
name|xpt_devicefunc_t
operator|*
operator|)
name|tr_config
operator|->
name|tr_func
expr_stmt|;
return|return
operator|(
name|tr_func
argument_list|(
name|device
argument_list|,
name|tr_config
operator|->
name|tr_arg
argument_list|)
operator|)
return|;
block|}
else|else
return|return
operator|(
name|xptperiphtraverse
argument_list|(
name|device
argument_list|,
name|NULL
argument_list|,
name|xptdefperiphfunc
argument_list|,
name|arg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xptdefperiphfunc
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|xpt_traverse_config
modifier|*
name|tr_config
decl_stmt|;
name|xpt_periphfunc_t
modifier|*
name|tr_func
decl_stmt|;
name|tr_config
operator|=
operator|(
expr|struct
name|xpt_traverse_config
operator|*
operator|)
name|arg
expr_stmt|;
name|tr_func
operator|=
operator|(
name|xpt_periphfunc_t
operator|*
operator|)
name|tr_config
operator|->
name|tr_func
expr_stmt|;
comment|/* 	 * Unlike the other default functions, we don't check for depth 	 * here.  The peripheral driver level is the last level in the EDT, 	 * so if we're here, we should execute the function in question. 	 */
return|return
operator|(
name|tr_func
argument_list|(
name|periph
argument_list|,
name|tr_config
operator|->
name|tr_arg
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Execute the given function for every bus in the EDT.  */
end_comment

begin_function
specifier|static
name|int
name|xpt_for_all_busses
parameter_list|(
name|xpt_busfunc_t
modifier|*
name|tr_func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|xpt_traverse_config
name|tr_config
decl_stmt|;
name|tr_config
operator|.
name|depth
operator|=
name|XPT_DEPTH_BUS
expr_stmt|;
name|tr_config
operator|.
name|tr_func
operator|=
name|tr_func
expr_stmt|;
name|tr_config
operator|.
name|tr_arg
operator|=
name|arg
expr_stmt|;
return|return
operator|(
name|xptbustraverse
argument_list|(
name|NULL
argument_list|,
name|xptdefbusfunc
argument_list|,
operator|&
name|tr_config
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Execute the given function for every device in the EDT.  */
end_comment

begin_function
specifier|static
name|int
name|xpt_for_all_devices
parameter_list|(
name|xpt_devicefunc_t
modifier|*
name|tr_func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|xpt_traverse_config
name|tr_config
decl_stmt|;
name|tr_config
operator|.
name|depth
operator|=
name|XPT_DEPTH_DEVICE
expr_stmt|;
name|tr_config
operator|.
name|tr_func
operator|=
name|tr_func
expr_stmt|;
name|tr_config
operator|.
name|tr_arg
operator|=
name|arg
expr_stmt|;
return|return
operator|(
name|xptbustraverse
argument_list|(
name|NULL
argument_list|,
name|xptdefbusfunc
argument_list|,
operator|&
name|tr_config
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xptsetasyncfunc
parameter_list|(
name|struct
name|cam_ed
modifier|*
name|device
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cam_path
name|path
decl_stmt|;
name|struct
name|ccb_getdev
name|cgd
decl_stmt|;
name|struct
name|ccb_setasync
modifier|*
name|csa
init|=
operator|(
expr|struct
name|ccb_setasync
operator|*
operator|)
name|arg
decl_stmt|;
comment|/* 	 * Don't report unconfigured devices (Wildcard devs, 	 * devices only for target mode, device instances 	 * that have been invalidated but are waiting for 	 * their last reference count to be released). 	 */
if|if
condition|(
operator|(
name|device
operator|->
name|flags
operator|&
name|CAM_DEV_UNCONFIGURED
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|xpt_compile_path
argument_list|(
operator|&
name|path
argument_list|,
name|NULL
argument_list|,
name|device
operator|->
name|target
operator|->
name|bus
operator|->
name|path_id
argument_list|,
name|device
operator|->
name|target
operator|->
name|target_id
argument_list|,
name|device
operator|->
name|lun_id
argument_list|)
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|cgd
operator|.
name|ccb_h
argument_list|,
operator|&
name|path
argument_list|,
name|CAM_PRIORITY_NORMAL
argument_list|)
expr_stmt|;
name|cgd
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_GDEV_TYPE
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|cgd
argument_list|)
expr_stmt|;
name|csa
operator|->
name|callback
argument_list|(
name|csa
operator|->
name|callback_arg
argument_list|,
name|AC_FOUND_DEVICE
argument_list|,
operator|&
name|path
argument_list|,
operator|&
name|cgd
argument_list|)
expr_stmt|;
name|xpt_release_path
argument_list|(
operator|&
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xptsetasyncbusfunc
parameter_list|(
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cam_path
name|path
decl_stmt|;
name|struct
name|ccb_pathinq
name|cpi
decl_stmt|;
name|struct
name|ccb_setasync
modifier|*
name|csa
init|=
operator|(
expr|struct
name|ccb_setasync
operator|*
operator|)
name|arg
decl_stmt|;
name|xpt_compile_path
argument_list|(
operator|&
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|bus
operator|->
name|path_id
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
expr_stmt|;
name|xpt_path_lock
argument_list|(
operator|&
name|path
argument_list|)
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|cpi
operator|.
name|ccb_h
argument_list|,
operator|&
name|path
argument_list|,
name|CAM_PRIORITY_NORMAL
argument_list|)
expr_stmt|;
name|cpi
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_PATH_INQ
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|cpi
argument_list|)
expr_stmt|;
name|csa
operator|->
name|callback
argument_list|(
name|csa
operator|->
name|callback_arg
argument_list|,
name|AC_PATH_REGISTERED
argument_list|,
operator|&
name|path
argument_list|,
operator|&
name|cpi
argument_list|)
expr_stmt|;
name|xpt_path_unlock
argument_list|(
operator|&
name|path
argument_list|)
expr_stmt|;
name|xpt_release_path
argument_list|(
operator|&
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|xpt_action
parameter_list|(
name|union
name|ccb
modifier|*
name|start_ccb
parameter_list|)
block|{
name|CAM_DEBUG
argument_list|(
name|start_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"xpt_action: func %#x %s\n"
operator|,
name|start_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|,
name|xpt_action_name
argument_list|(
name|start_ccb
operator|->
name|ccb_h
operator|.
name|func_code
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|start_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INPROG
expr_stmt|;
operator|(
operator|*
operator|(
name|start_ccb
operator|->
name|ccb_h
operator|.
name|path
operator|->
name|bus
operator|->
name|xport
operator|->
name|ops
operator|->
name|action
operator|)
operator|)
operator|(
name|start_ccb
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xpt_action_default
parameter_list|(
name|union
name|ccb
modifier|*
name|start_ccb
parameter_list|)
block|{
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|int
name|lock
decl_stmt|;
name|path
operator|=
name|start_ccb
operator|->
name|ccb_h
operator|.
name|path
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"xpt_action_default: func %#x %s\n"
operator|,
name|start_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|,
name|xpt_action_name
argument_list|(
name|start_ccb
operator|->
name|ccb_h
operator|.
name|func_code
argument_list|)
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|start_ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_SCSI_IO
case|:
block|{
name|struct
name|cam_ed
modifier|*
name|device
decl_stmt|;
comment|/* 		 * For the sake of compatibility with SCSI-1 		 * devices that may not understand the identify 		 * message, we include lun information in the 		 * second byte of all commands.  SCSI-1 specifies 		 * that luns are a 3 bit value and reserves only 3 		 * bits for lun information in the CDB.  Later 		 * revisions of the SCSI spec allow for more than 8 		 * luns, but have deprecated lun information in the 		 * CDB.  So, if the lun won't fit, we must omit. 		 * 		 * Also be aware that during initial probing for devices, 		 * the inquiry information is unknown but initialized to 0. 		 * This means that this code will be exercised while probing 		 * devices with an ANSI revision greater than 2. 		 */
name|device
operator|=
name|path
operator|->
name|device
expr_stmt|;
if|if
condition|(
name|device
operator|->
name|protocol_version
operator|<=
name|SCSI_REV_2
operator|&&
name|start_ccb
operator|->
name|ccb_h
operator|.
name|target_lun
operator|<
literal|8
operator|&&
operator|(
name|start_ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_POINTER
operator|)
operator|==
literal|0
condition|)
block|{
name|start_ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|1
index|]
operator||=
name|start_ccb
operator|->
name|ccb_h
operator|.
name|target_lun
operator|<<
literal|5
expr_stmt|;
block|}
name|start_ccb
operator|->
name|csio
operator|.
name|scsi_status
operator|=
name|SCSI_STATUS_OK
expr_stmt|;
block|}
comment|/* FALLTHROUGH */
case|case
name|XPT_TARGET_IO
case|:
case|case
name|XPT_CONT_TARGET_IO
case|:
name|start_ccb
operator|->
name|csio
operator|.
name|sense_resid
operator|=
literal|0
expr_stmt|;
name|start_ccb
operator|->
name|csio
operator|.
name|resid
operator|=
literal|0
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|XPT_ATA_IO
case|:
if|if
condition|(
name|start_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ATA_IO
condition|)
name|start_ccb
operator|->
name|ataio
operator|.
name|resid
operator|=
literal|0
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|XPT_NVME_IO
case|:
if|if
condition|(
name|start_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_NVME_IO
condition|)
name|start_ccb
operator|->
name|nvmeio
operator|.
name|resid
operator|=
literal|0
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|XPT_RESET_DEV
case|:
case|case
name|XPT_ENG_EXEC
case|:
case|case
name|XPT_SMP_IO
case|:
block|{
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
name|devq
operator|=
name|path
operator|->
name|bus
operator|->
name|sim
operator|->
name|devq
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|devq
operator|->
name|send_mtx
argument_list|)
expr_stmt|;
name|cam_ccbq_insert_ccb
argument_list|(
operator|&
name|path
operator|->
name|device
operator|->
name|ccbq
argument_list|,
name|start_ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|xpt_schedule_devq
argument_list|(
name|devq
argument_list|,
name|path
operator|->
name|device
argument_list|)
operator|!=
literal|0
condition|)
name|xpt_run_devq
argument_list|(
name|devq
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|devq
operator|->
name|send_mtx
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_CALC_GEOMETRY
case|:
comment|/* Filter out garbage */
if|if
condition|(
name|start_ccb
operator|->
name|ccg
operator|.
name|block_size
operator|==
literal|0
operator|||
name|start_ccb
operator|->
name|ccg
operator|.
name|volume_size
operator|==
literal|0
condition|)
block|{
name|start_ccb
operator|->
name|ccg
operator|.
name|cylinders
operator|=
literal|0
expr_stmt|;
name|start_ccb
operator|->
name|ccg
operator|.
name|heads
operator|=
literal|0
expr_stmt|;
name|start_ccb
operator|->
name|ccg
operator|.
name|secs_per_track
operator|=
literal|0
expr_stmt|;
name|start_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
block|}
if|#
directive|if
name|defined
argument_list|(
name|PC98
argument_list|)
operator|||
name|defined
argument_list|(
name|__sparc64__
argument_list|)
comment|/* 		 * In a PC-98 system, geometry translation depens on 		 * the "real" device geometry obtained from mode page 4. 		 * SCSI geometry translation is performed in the 		 * initialization routine of the SCSI BIOS and the result 		 * stored in host memory.  If the translation is available 		 * in host memory, use it.  If not, rely on the default 		 * translation the device driver performs. 		 * For sparc64, we may need adjust the geometry of large 		 * disks in order to fit the limitations of the 16-bit 		 * fields of the VTOC8 disk label. 		 */
if|if
condition|(
name|scsi_da_bios_params
argument_list|(
operator|&
name|start_ccb
operator|->
name|ccg
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|start_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
goto|goto
name|call_sim
goto|;
case|case
name|XPT_ABORT
case|:
block|{
name|union
name|ccb
modifier|*
name|abort_ccb
decl_stmt|;
name|abort_ccb
operator|=
name|start_ccb
operator|->
name|cab
operator|.
name|abort_ccb
expr_stmt|;
if|if
condition|(
name|XPT_FC_IS_DEV_QUEUED
argument_list|(
name|abort_ccb
argument_list|)
condition|)
block|{
name|struct
name|cam_ed
modifier|*
name|device
decl_stmt|;
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
name|device
operator|=
name|abort_ccb
operator|->
name|ccb_h
operator|.
name|path
operator|->
name|device
expr_stmt|;
name|devq
operator|=
name|device
operator|->
name|sim
operator|->
name|devq
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|devq
operator|->
name|send_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|abort_ccb
operator|->
name|ccb_h
operator|.
name|pinfo
operator|.
name|index
operator|>
literal|0
condition|)
block|{
name|cam_ccbq_remove_ccb
argument_list|(
operator|&
name|device
operator|->
name|ccbq
argument_list|,
name|abort_ccb
argument_list|)
expr_stmt|;
name|abort_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_ABORTED
operator||
name|CAM_DEV_QFRZN
expr_stmt|;
name|xpt_freeze_devq_device
argument_list|(
name|device
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|devq
operator|->
name|send_mtx
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|abort_ccb
argument_list|)
expr_stmt|;
name|start_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|devq
operator|->
name|send_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|abort_ccb
operator|->
name|ccb_h
operator|.
name|pinfo
operator|.
name|index
operator|==
name|CAM_UNQUEUED_INDEX
operator|&&
operator|(
name|abort_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_SIM_QUEUED
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * We've caught this ccb en route to 				 * the SIM.  Flag it for abort and the 				 * SIM will do so just before starting 				 * real work on the CCB. 				 */
name|abort_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_ABORTED
operator||
name|CAM_DEV_QFRZN
expr_stmt|;
name|xpt_freeze_devq
argument_list|(
name|abort_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|start_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|XPT_FC_IS_QUEUED
argument_list|(
name|abort_ccb
argument_list|)
operator|&&
operator|(
name|abort_ccb
operator|->
name|ccb_h
operator|.
name|pinfo
operator|.
name|index
operator|==
name|CAM_DONEQ_INDEX
operator|)
condition|)
block|{
comment|/* 			 * It's already completed but waiting 			 * for our SWI to get to it. 			 */
name|start_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_UA_ABORT
expr_stmt|;
break|break;
block|}
comment|/* 		 * If we weren't able to take care of the abort request 		 * in the XPT, pass the request down to the SIM for processing. 		 */
block|}
comment|/* FALLTHROUGH */
case|case
name|XPT_ACCEPT_TARGET_IO
case|:
case|case
name|XPT_EN_LUN
case|:
case|case
name|XPT_IMMED_NOTIFY
case|:
case|case
name|XPT_NOTIFY_ACK
case|:
case|case
name|XPT_RESET_BUS
case|:
case|case
name|XPT_IMMEDIATE_NOTIFY
case|:
case|case
name|XPT_NOTIFY_ACKNOWLEDGE
case|:
case|case
name|XPT_GET_SIM_KNOB_OLD
case|:
case|case
name|XPT_GET_SIM_KNOB
case|:
case|case
name|XPT_SET_SIM_KNOB
case|:
case|case
name|XPT_GET_TRAN_SETTINGS
case|:
case|case
name|XPT_SET_TRAN_SETTINGS
case|:
case|case
name|XPT_PATH_INQ
case|:
name|call_sim
label|:
name|sim
operator|=
name|path
operator|->
name|bus
operator|->
name|sim
expr_stmt|;
name|lock
operator|=
operator|(
name|mtx_owned
argument_list|(
name|sim
operator|->
name|mtx
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|lock
condition|)
name|CAM_SIM_LOCK
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"sim->sim_action: func=%#x\n"
operator|,
name|start_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|)
argument_list|)
expr_stmt|;
operator|(
operator|*
operator|(
name|sim
operator|->
name|sim_action
operator|)
operator|)
operator|(
name|sim
operator|,
name|start_ccb
operator|)
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"sim->sim_action: status=%#x\n"
operator|,
name|start_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock
condition|)
name|CAM_SIM_UNLOCK
argument_list|(
name|sim
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_PATH_STATS
case|:
name|start_ccb
operator|->
name|cpis
operator|.
name|last_reset
operator|=
name|path
operator|->
name|bus
operator|->
name|last_reset
expr_stmt|;
name|start_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
case|case
name|XPT_GDEV_TYPE
case|:
block|{
name|struct
name|cam_ed
modifier|*
name|dev
decl_stmt|;
name|dev
operator|=
name|path
operator|->
name|device
expr_stmt|;
if|if
condition|(
operator|(
name|dev
operator|->
name|flags
operator|&
name|CAM_DEV_UNCONFIGURED
operator|)
operator|!=
literal|0
condition|)
block|{
name|start_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_DEV_NOT_THERE
expr_stmt|;
block|}
else|else
block|{
name|struct
name|ccb_getdev
modifier|*
name|cgd
decl_stmt|;
name|cgd
operator|=
operator|&
name|start_ccb
operator|->
name|cgd
expr_stmt|;
name|cgd
operator|->
name|protocol
operator|=
name|dev
operator|->
name|protocol
expr_stmt|;
name|cgd
operator|->
name|inq_data
operator|=
name|dev
operator|->
name|inq_data
expr_stmt|;
name|cgd
operator|->
name|ident_data
operator|=
name|dev
operator|->
name|ident_data
expr_stmt|;
name|cgd
operator|->
name|inq_flags
operator|=
name|dev
operator|->
name|inq_flags
expr_stmt|;
name|cgd
operator|->
name|nvme_data
operator|=
name|dev
operator|->
name|nvme_data
expr_stmt|;
name|cgd
operator|->
name|nvme_cdata
operator|=
name|dev
operator|->
name|nvme_cdata
expr_stmt|;
name|cgd
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|cgd
operator|->
name|serial_num_len
operator|=
name|dev
operator|->
name|serial_num_len
expr_stmt|;
if|if
condition|(
operator|(
name|dev
operator|->
name|serial_num_len
operator|>
literal|0
operator|)
operator|&&
operator|(
name|dev
operator|->
name|serial_num
operator|!=
name|NULL
operator|)
condition|)
name|bcopy
argument_list|(
name|dev
operator|->
name|serial_num
argument_list|,
name|cgd
operator|->
name|serial_num
argument_list|,
name|dev
operator|->
name|serial_num_len
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|XPT_GDEV_STATS
case|:
block|{
name|struct
name|cam_ed
modifier|*
name|dev
decl_stmt|;
name|dev
operator|=
name|path
operator|->
name|device
expr_stmt|;
if|if
condition|(
operator|(
name|dev
operator|->
name|flags
operator|&
name|CAM_DEV_UNCONFIGURED
operator|)
operator|!=
literal|0
condition|)
block|{
name|start_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_DEV_NOT_THERE
expr_stmt|;
block|}
else|else
block|{
name|struct
name|ccb_getdevstats
modifier|*
name|cgds
decl_stmt|;
name|struct
name|cam_eb
modifier|*
name|bus
decl_stmt|;
name|struct
name|cam_et
modifier|*
name|tar
decl_stmt|;
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
name|cgds
operator|=
operator|&
name|start_ccb
operator|->
name|cgds
expr_stmt|;
name|bus
operator|=
name|path
operator|->
name|bus
expr_stmt|;
name|tar
operator|=
name|path
operator|->
name|target
expr_stmt|;
name|devq
operator|=
name|bus
operator|->
name|sim
operator|->
name|devq
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|devq
operator|->
name|send_mtx
argument_list|)
expr_stmt|;
name|cgds
operator|->
name|dev_openings
operator|=
name|dev
operator|->
name|ccbq
operator|.
name|dev_openings
expr_stmt|;
name|cgds
operator|->
name|dev_active
operator|=
name|dev
operator|->
name|ccbq
operator|.
name|dev_active
expr_stmt|;
name|cgds
operator|->
name|allocated
operator|=
name|dev
operator|->
name|ccbq
operator|.
name|allocated
expr_stmt|;
name|cgds
operator|->
name|queued
operator|=
name|cam_ccbq_pending_ccb_count
argument_list|(
operator|&
name|dev
operator|->
name|ccbq
argument_list|)
expr_stmt|;
name|cgds
operator|->
name|held
operator|=
name|cgds
operator|->
name|allocated
operator|-
name|cgds
operator|->
name|dev_active
operator|-
name|cgds
operator|->
name|queued
expr_stmt|;
name|cgds
operator|->
name|last_reset
operator|=
name|tar
operator|->
name|last_reset
expr_stmt|;
name|cgds
operator|->
name|maxtags
operator|=
name|dev
operator|->
name|maxtags
expr_stmt|;
name|cgds
operator|->
name|mintags
operator|=
name|dev
operator|->
name|mintags
expr_stmt|;
if|if
condition|(
name|timevalcmp
argument_list|(
operator|&
name|tar
operator|->
name|last_reset
argument_list|,
operator|&
name|bus
operator|->
name|last_reset
argument_list|,
operator|<
argument_list|)
condition|)
name|cgds
operator|->
name|last_reset
operator|=
name|bus
operator|->
name|last_reset
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|devq
operator|->
name|send_mtx
argument_list|)
expr_stmt|;
name|cgds
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
block|}
break|break;
block|}
case|case
name|XPT_GDEVLIST
case|:
block|{
name|struct
name|cam_periph
modifier|*
name|nperiph
decl_stmt|;
name|struct
name|periph_list
modifier|*
name|periph_head
decl_stmt|;
name|struct
name|ccb_getdevlist
modifier|*
name|cgdl
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|struct
name|cam_ed
modifier|*
name|device
decl_stmt|;
name|int
name|found
decl_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Don't want anyone mucking with our data. 		 */
name|device
operator|=
name|path
operator|->
name|device
expr_stmt|;
name|periph_head
operator|=
operator|&
name|device
operator|->
name|periphs
expr_stmt|;
name|cgdl
operator|=
operator|&
name|start_ccb
operator|->
name|cgdl
expr_stmt|;
comment|/* 		 * Check and see if the list has changed since the user 		 * last requested a list member.  If so, tell them that the 		 * list has changed, and therefore they need to start over 		 * from the beginning. 		 */
if|if
condition|(
operator|(
name|cgdl
operator|->
name|index
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|cgdl
operator|->
name|generation
operator|!=
name|device
operator|->
name|generation
operator|)
condition|)
block|{
name|cgdl
operator|->
name|status
operator|=
name|CAM_GDEVLIST_LIST_CHANGED
expr_stmt|;
break|break;
block|}
comment|/* 		 * Traverse the list of peripherals and attempt to find 		 * the requested peripheral. 		 */
for|for
control|(
name|nperiph
operator|=
name|SLIST_FIRST
argument_list|(
name|periph_head
argument_list|)
operator|,
name|i
operator|=
literal|0
init|;
operator|(
name|nperiph
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|i
operator|<=
name|cgdl
operator|->
name|index
operator|)
condition|;
name|nperiph
operator|=
name|SLIST_NEXT
argument_list|(
name|nperiph
argument_list|,
name|periph_links
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|cgdl
operator|->
name|index
condition|)
block|{
name|strncpy
argument_list|(
name|cgdl
operator|->
name|periph_name
argument_list|,
name|nperiph
operator|->
name|periph_name
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
name|cgdl
operator|->
name|unit_number
operator|=
name|nperiph
operator|->
name|unit_number
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|found
operator|==
literal|0
condition|)
block|{
name|cgdl
operator|->
name|status
operator|=
name|CAM_GDEVLIST_ERROR
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|nperiph
operator|==
name|NULL
condition|)
name|cgdl
operator|->
name|status
operator|=
name|CAM_GDEVLIST_LAST_DEVICE
expr_stmt|;
else|else
name|cgdl
operator|->
name|status
operator|=
name|CAM_GDEVLIST_MORE_DEVS
expr_stmt|;
name|cgdl
operator|->
name|index
operator|++
expr_stmt|;
name|cgdl
operator|->
name|generation
operator|=
name|device
operator|->
name|generation
expr_stmt|;
name|cgdl
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
block|}
case|case
name|XPT_DEV_MATCH
case|:
block|{
name|dev_pos_type
name|position_type
decl_stmt|;
name|struct
name|ccb_dev_match
modifier|*
name|cdm
decl_stmt|;
name|cdm
operator|=
operator|&
name|start_ccb
operator|->
name|cdm
expr_stmt|;
comment|/* 		 * There are two ways of getting at information in the EDT. 		 * The first way is via the primary EDT tree.  It starts 		 * with a list of busses, then a list of targets on a bus, 		 * then devices/luns on a target, and then peripherals on a 		 * device/lun.  The "other" way is by the peripheral driver 		 * lists.  The peripheral driver lists are organized by 		 * peripheral driver.  (obviously)  So it makes sense to 		 * use the peripheral driver list if the user is looking 		 * for something like "da1", or all "da" devices.  If the 		 * user is looking for something on a particular bus/target 		 * or lun, it's generally better to go through the EDT tree. 		 */
if|if
condition|(
name|cdm
operator|->
name|pos
operator|.
name|position_type
operator|!=
name|CAM_DEV_POS_NONE
condition|)
name|position_type
operator|=
name|cdm
operator|->
name|pos
operator|.
name|position_type
expr_stmt|;
else|else
block|{
name|u_int
name|i
decl_stmt|;
name|position_type
operator|=
name|CAM_DEV_POS_NONE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cdm
operator|->
name|num_patterns
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|cdm
operator|->
name|patterns
index|[
name|i
index|]
operator|.
name|type
operator|==
name|DEV_MATCH_BUS
operator|)
operator|||
operator|(
name|cdm
operator|->
name|patterns
index|[
name|i
index|]
operator|.
name|type
operator|==
name|DEV_MATCH_DEVICE
operator|)
condition|)
block|{
name|position_type
operator|=
name|CAM_DEV_POS_EDT
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|cdm
operator|->
name|num_patterns
operator|==
literal|0
condition|)
name|position_type
operator|=
name|CAM_DEV_POS_EDT
expr_stmt|;
elseif|else
if|if
condition|(
name|position_type
operator|==
name|CAM_DEV_POS_NONE
condition|)
name|position_type
operator|=
name|CAM_DEV_POS_PDRV
expr_stmt|;
block|}
switch|switch
condition|(
name|position_type
operator|&
name|CAM_DEV_POS_TYPEMASK
condition|)
block|{
case|case
name|CAM_DEV_POS_EDT
case|:
name|xptedtmatch
argument_list|(
name|cdm
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_DEV_POS_PDRV
case|:
name|xptperiphlistmatch
argument_list|(
name|cdm
argument_list|)
expr_stmt|;
break|break;
default|default:
name|cdm
operator|->
name|status
operator|=
name|CAM_DEV_MATCH_ERROR
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cdm
operator|->
name|status
operator|==
name|CAM_DEV_MATCH_ERROR
condition|)
name|start_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP_ERR
expr_stmt|;
else|else
name|start_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
block|}
case|case
name|XPT_SASYNC_CB
case|:
block|{
name|struct
name|ccb_setasync
modifier|*
name|csa
decl_stmt|;
name|struct
name|async_node
modifier|*
name|cur_entry
decl_stmt|;
name|struct
name|async_list
modifier|*
name|async_head
decl_stmt|;
name|u_int32_t
name|added
decl_stmt|;
name|csa
operator|=
operator|&
name|start_ccb
operator|->
name|csa
expr_stmt|;
name|added
operator|=
name|csa
operator|->
name|event_enable
expr_stmt|;
name|async_head
operator|=
operator|&
name|path
operator|->
name|device
operator|->
name|asyncs
expr_stmt|;
comment|/* 		 * If there is already an entry for us, simply 		 * update it. 		 */
name|cur_entry
operator|=
name|SLIST_FIRST
argument_list|(
name|async_head
argument_list|)
expr_stmt|;
while|while
condition|(
name|cur_entry
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|cur_entry
operator|->
name|callback_arg
operator|==
name|csa
operator|->
name|callback_arg
operator|)
operator|&&
operator|(
name|cur_entry
operator|->
name|callback
operator|==
name|csa
operator|->
name|callback
operator|)
condition|)
break|break;
name|cur_entry
operator|=
name|SLIST_NEXT
argument_list|(
name|cur_entry
argument_list|,
name|links
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cur_entry
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * If the request has no flags set, 			 * remove the entry. 			 */
name|added
operator|&=
operator|~
name|cur_entry
operator|->
name|event_enable
expr_stmt|;
if|if
condition|(
name|csa
operator|->
name|event_enable
operator|==
literal|0
condition|)
block|{
name|SLIST_REMOVE
argument_list|(
name|async_head
argument_list|,
name|cur_entry
argument_list|,
name|async_node
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|xpt_release_device
argument_list|(
name|path
operator|->
name|device
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cur_entry
argument_list|,
name|M_CAMXPT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cur_entry
operator|->
name|event_enable
operator|=
name|csa
operator|->
name|event_enable
expr_stmt|;
block|}
name|csa
operator|->
name|event_enable
operator|=
name|added
expr_stmt|;
block|}
else|else
block|{
name|cur_entry
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cur_entry
argument_list|)
argument_list|,
name|M_CAMXPT
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_entry
operator|==
name|NULL
condition|)
block|{
name|csa
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
break|break;
block|}
name|cur_entry
operator|->
name|event_enable
operator|=
name|csa
operator|->
name|event_enable
expr_stmt|;
name|cur_entry
operator|->
name|event_lock
operator|=
name|mtx_owned
argument_list|(
name|path
operator|->
name|bus
operator|->
name|sim
operator|->
name|mtx
argument_list|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|cur_entry
operator|->
name|callback_arg
operator|=
name|csa
operator|->
name|callback_arg
expr_stmt|;
name|cur_entry
operator|->
name|callback
operator|=
name|csa
operator|->
name|callback
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
name|async_head
argument_list|,
name|cur_entry
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|xpt_acquire_device
argument_list|(
name|path
operator|->
name|device
argument_list|)
expr_stmt|;
block|}
name|start_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
block|}
case|case
name|XPT_REL_SIMQ
case|:
block|{
name|struct
name|ccb_relsim
modifier|*
name|crs
decl_stmt|;
name|struct
name|cam_ed
modifier|*
name|dev
decl_stmt|;
name|crs
operator|=
operator|&
name|start_ccb
operator|->
name|crs
expr_stmt|;
name|dev
operator|=
name|path
operator|->
name|device
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
block|{
name|crs
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_DEV_NOT_THERE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|crs
operator|->
name|release_flags
operator|&
name|RELSIM_ADJUST_OPENINGS
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Don't ever go below one opening */
if|if
condition|(
name|crs
operator|->
name|openings
operator|>
literal|0
condition|)
block|{
name|xpt_dev_ccbq_resize
argument_list|(
name|path
argument_list|,
name|crs
operator|->
name|openings
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|xpt_print
argument_list|(
name|path
argument_list|,
literal|"number of openings is now %d\n"
argument_list|,
name|crs
operator|->
name|openings
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|mtx_lock
argument_list|(
operator|&
name|dev
operator|->
name|sim
operator|->
name|devq
operator|->
name|send_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|crs
operator|->
name|release_flags
operator|&
name|RELSIM_RELEASE_AFTER_TIMEOUT
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|dev
operator|->
name|flags
operator|&
name|CAM_DEV_REL_TIMEOUT_PENDING
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * Just extend the old timeout and decrement 				 * the freeze count so that a single timeout 				 * is sufficient for releasing the queue. 				 */
name|start_ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&=
operator|~
name|CAM_DEV_QFREEZE
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|dev
operator|->
name|callout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|start_ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFREEZE
expr_stmt|;
block|}
name|callout_reset_sbt
argument_list|(
operator|&
name|dev
operator|->
name|callout
argument_list|,
name|SBT_1MS
operator|*
name|crs
operator|->
name|release_timeout
argument_list|,
literal|0
argument_list|,
name|xpt_release_devq_timeout
argument_list|,
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dev
operator|->
name|flags
operator||=
name|CAM_DEV_REL_TIMEOUT_PENDING
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|crs
operator|->
name|release_flags
operator|&
name|RELSIM_RELEASE_AFTER_CMDCMPLT
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|dev
operator|->
name|flags
operator|&
name|CAM_DEV_REL_ON_COMPLETE
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * Decrement the freeze count so that a single 				 * completion is still sufficient to unfreeze 				 * the queue. 				 */
name|start_ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&=
operator|~
name|CAM_DEV_QFREEZE
expr_stmt|;
block|}
else|else
block|{
name|dev
operator|->
name|flags
operator||=
name|CAM_DEV_REL_ON_COMPLETE
expr_stmt|;
name|start_ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFREEZE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|crs
operator|->
name|release_flags
operator|&
name|RELSIM_RELEASE_AFTER_QEMPTY
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|dev
operator|->
name|flags
operator|&
name|CAM_DEV_REL_ON_QUEUE_EMPTY
operator|)
operator|!=
literal|0
operator|||
operator|(
name|dev
operator|->
name|ccbq
operator|.
name|dev_active
operator|==
literal|0
operator|)
condition|)
block|{
name|start_ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&=
operator|~
name|CAM_DEV_QFREEZE
expr_stmt|;
block|}
else|else
block|{
name|dev
operator|->
name|flags
operator||=
name|CAM_DEV_REL_ON_QUEUE_EMPTY
expr_stmt|;
name|start_ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFREEZE
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|sim
operator|->
name|devq
operator|->
name|send_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|start_ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DEV_QFREEZE
operator|)
operator|==
literal|0
condition|)
name|xpt_release_devq
argument_list|(
name|path
argument_list|,
comment|/*count*/
literal|1
argument_list|,
comment|/*run_queue*/
name|TRUE
argument_list|)
expr_stmt|;
name|start_ccb
operator|->
name|crs
operator|.
name|qfrozen_cnt
operator|=
name|dev
operator|->
name|ccbq
operator|.
name|queue
operator|.
name|qfrozen_cnt
expr_stmt|;
name|start_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
block|}
case|case
name|XPT_DEBUG
case|:
block|{
name|struct
name|cam_path
modifier|*
name|oldpath
decl_stmt|;
comment|/* Check that all request bits are supported. */
if|if
condition|(
name|start_ccb
operator|->
name|cdbg
operator|.
name|flags
operator|&
operator|~
operator|(
name|CAM_DEBUG_COMPILE
operator|)
condition|)
block|{
name|start_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_FUNC_NOTAVAIL
expr_stmt|;
break|break;
block|}
name|cam_dflags
operator|=
name|CAM_DEBUG_NONE
expr_stmt|;
if|if
condition|(
name|cam_dpath
operator|!=
name|NULL
condition|)
block|{
name|oldpath
operator|=
name|cam_dpath
expr_stmt|;
name|cam_dpath
operator|=
name|NULL
expr_stmt|;
name|xpt_free_path
argument_list|(
name|oldpath
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|start_ccb
operator|->
name|cdbg
operator|.
name|flags
operator|!=
name|CAM_DEBUG_NONE
condition|)
block|{
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|cam_dpath
argument_list|,
name|NULL
argument_list|,
name|start_ccb
operator|->
name|ccb_h
operator|.
name|path_id
argument_list|,
name|start_ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|start_ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|start_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
block|}
else|else
block|{
name|cam_dflags
operator|=
name|start_ccb
operator|->
name|cdbg
operator|.
name|flags
expr_stmt|;
name|start_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_print
argument_list|(
name|cam_dpath
argument_list|,
literal|"debugging flags now %x\n"
argument_list|,
name|cam_dflags
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|start_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
block|}
case|case
name|XPT_NOOP
case|:
if|if
condition|(
operator|(
name|start_ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DEV_QFREEZE
operator|)
operator|!=
literal|0
condition|)
name|xpt_freeze_devq
argument_list|(
name|path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|start_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
case|case
name|XPT_REPROBE_LUN
case|:
name|xpt_async
argument_list|(
name|AC_INQ_CHANGED
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|start_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|start_ccb
argument_list|)
expr_stmt|;
break|break;
default|default:
case|case
name|XPT_SDEV_TYPE
case|:
case|case
name|XPT_TERM_IO
case|:
case|case
name|XPT_ENG_INQ
case|:
comment|/* XXX Implement */
name|xpt_print_path
argument_list|(
name|start_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: CCB type %#x %s not supported\n"
argument_list|,
name|__func__
argument_list|,
name|start_ccb
operator|->
name|ccb_h
operator|.
name|func_code
argument_list|,
name|xpt_action_name
argument_list|(
name|start_ccb
operator|->
name|ccb_h
operator|.
name|func_code
argument_list|)
argument_list|)
expr_stmt|;
name|start_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_PROVIDE_FAIL
expr_stmt|;
if|if
condition|(
name|start_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|&
name|XPT_FC_DEV_QUEUED
condition|)
block|{
name|xpt_done
argument_list|(
name|start_ccb
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|CAM_DEBUG
argument_list|(
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"xpt_action_default: func= %#x %s status %#x\n"
operator|,
name|start_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|,
name|xpt_action_name
argument_list|(
name|start_ccb
operator|->
name|ccb_h
operator|.
name|func_code
argument_list|)
operator|,
name|start_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xpt_polled_action
parameter_list|(
name|union
name|ccb
modifier|*
name|start_ccb
parameter_list|)
block|{
name|u_int32_t
name|timeout
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
name|struct
name|cam_ed
modifier|*
name|dev
decl_stmt|;
name|timeout
operator|=
name|start_ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|*
literal|10
expr_stmt|;
name|sim
operator|=
name|start_ccb
operator|->
name|ccb_h
operator|.
name|path
operator|->
name|bus
operator|->
name|sim
expr_stmt|;
name|devq
operator|=
name|sim
operator|->
name|devq
expr_stmt|;
name|dev
operator|=
name|start_ccb
operator|->
name|ccb_h
operator|.
name|path
operator|->
name|device
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|device_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Steal an opening so that no other queued requests 	 * can get it before us while we simulate interrupts. 	 */
name|mtx_lock
argument_list|(
operator|&
name|devq
operator|->
name|send_mtx
argument_list|)
expr_stmt|;
name|dev
operator|->
name|ccbq
operator|.
name|dev_openings
operator|--
expr_stmt|;
while|while
condition|(
operator|(
name|devq
operator|->
name|send_openings
operator|<=
literal|0
operator|||
name|dev
operator|->
name|ccbq
operator|.
name|dev_openings
operator|<
literal|0
operator|)
operator|&&
operator|(
operator|--
name|timeout
operator|>
literal|0
operator|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|devq
operator|->
name|send_mtx
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|CAM_SIM_LOCK
argument_list|(
name|sim
argument_list|)
expr_stmt|;
operator|(
operator|*
operator|(
name|sim
operator|->
name|sim_poll
operator|)
operator|)
operator|(
name|sim
operator|)
expr_stmt|;
name|CAM_SIM_UNLOCK
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|camisr_runqueue
argument_list|()
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|devq
operator|->
name|send_mtx
argument_list|)
expr_stmt|;
block|}
name|dev
operator|->
name|ccbq
operator|.
name|dev_openings
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|devq
operator|->
name|send_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|!=
literal|0
condition|)
block|{
name|xpt_action
argument_list|(
name|start_ccb
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|timeout
operator|>
literal|0
condition|)
block|{
name|CAM_SIM_LOCK
argument_list|(
name|sim
argument_list|)
expr_stmt|;
operator|(
operator|*
operator|(
name|sim
operator|->
name|sim_poll
operator|)
operator|)
operator|(
name|sim
operator|)
expr_stmt|;
name|CAM_SIM_UNLOCK
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|camisr_runqueue
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|start_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_INPROG
condition|)
break|break;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
block|{
comment|/* 			 * XXX Is it worth adding a sim_timeout entry 			 * point so we can attempt recovery?  If 			 * this is only used for dumps, I don't think 			 * it is. 			 */
name|start_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_CMD_TIMEOUT
expr_stmt|;
block|}
block|}
else|else
block|{
name|start_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|dev
operator|->
name|device_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Schedule a peripheral driver to receive a ccb when its  * target device has space for more transactions.  */
end_comment

begin_function
name|void
name|xpt_schedule
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|u_int32_t
name|new_priority
parameter_list|)
block|{
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"xpt_schedule\n"
operator|)
argument_list|)
expr_stmt|;
name|cam_periph_assert
argument_list|(
name|periph
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_priority
operator|<
name|periph
operator|->
name|scheduled_priority
condition|)
block|{
name|periph
operator|->
name|scheduled_priority
operator|=
name|new_priority
expr_stmt|;
name|xpt_run_allocq
argument_list|(
name|periph
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Schedule a device to run on a given queue.  * If the device was inserted as a new entry on the queue,  * return 1 meaning the device queue should be run. If we  * were already queued, implying someone else has already  * started the queue, return 0 so the caller doesn't attempt  * to run the queue.  */
end_comment

begin_function
specifier|static
name|int
name|xpt_schedule_dev
parameter_list|(
name|struct
name|camq
modifier|*
name|queue
parameter_list|,
name|cam_pinfo
modifier|*
name|pinfo
parameter_list|,
name|u_int32_t
name|new_priority
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|u_int32_t
name|old_priority
decl_stmt|;
name|CAM_DEBUG_PRINT
argument_list|(
name|CAM_DEBUG_XPT
argument_list|,
operator|(
literal|"xpt_schedule_dev\n"
operator|)
argument_list|)
expr_stmt|;
name|old_priority
operator|=
name|pinfo
operator|->
name|priority
expr_stmt|;
comment|/* 	 * Are we already queued? 	 */
if|if
condition|(
name|pinfo
operator|->
name|index
operator|!=
name|CAM_UNQUEUED_INDEX
condition|)
block|{
comment|/* Simply reorder based on new priority */
if|if
condition|(
name|new_priority
operator|<
name|old_priority
condition|)
block|{
name|camq_change_priority
argument_list|(
name|queue
argument_list|,
name|pinfo
operator|->
name|index
argument_list|,
name|new_priority
argument_list|)
expr_stmt|;
name|CAM_DEBUG_PRINT
argument_list|(
name|CAM_DEBUG_XPT
argument_list|,
operator|(
literal|"changed priority to %d\n"
operator|,
name|new_priority
operator|)
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|retval
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* New entry on the queue */
if|if
condition|(
name|new_priority
operator|<
name|old_priority
condition|)
name|pinfo
operator|->
name|priority
operator|=
name|new_priority
expr_stmt|;
name|CAM_DEBUG_PRINT
argument_list|(
name|CAM_DEBUG_XPT
argument_list|,
operator|(
literal|"Inserting onto queue\n"
operator|)
argument_list|)
expr_stmt|;
name|pinfo
operator|->
name|generation
operator|=
operator|++
name|queue
operator|->
name|generation
expr_stmt|;
name|camq_insert
argument_list|(
name|queue
argument_list|,
name|pinfo
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xpt_run_allocq_task
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
init|=
name|context
decl_stmt|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|periph
operator|->
name|flags
operator|&=
operator|~
name|CAM_PERIPH_RUN_TASK
expr_stmt|;
name|xpt_run_allocq
argument_list|(
name|periph
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|cam_periph_release
argument_list|(
name|periph
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xpt_run_allocq
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|int
name|sleep
parameter_list|)
block|{
name|struct
name|cam_ed
modifier|*
name|device
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|uint32_t
name|prio
decl_stmt|;
name|cam_periph_assert
argument_list|(
name|periph
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|periph
operator|->
name|periph_allocating
condition|)
return|return;
name|periph
operator|->
name|periph_allocating
operator|=
literal|1
expr_stmt|;
name|CAM_DEBUG_PRINT
argument_list|(
name|CAM_DEBUG_XPT
argument_list|,
operator|(
literal|"xpt_run_allocq(%p)\n"
operator|,
name|periph
operator|)
argument_list|)
expr_stmt|;
name|device
operator|=
name|periph
operator|->
name|path
operator|->
name|device
expr_stmt|;
name|ccb
operator|=
name|NULL
expr_stmt|;
name|restart
label|:
while|while
condition|(
operator|(
name|prio
operator|=
name|min
argument_list|(
name|periph
operator|->
name|scheduled_priority
argument_list|,
name|periph
operator|->
name|immediate_priority
argument_list|)
operator|)
operator|!=
name|CAM_PRIORITY_NONE
operator|&&
operator|(
name|periph
operator|->
name|periph_allocated
operator|-
operator|(
name|ccb
operator|!=
name|NULL
condition|?
literal|1
else|:
literal|0
operator|)
operator|<
name|device
operator|->
name|ccbq
operator|.
name|total_openings
operator|||
name|prio
operator|<=
name|CAM_PRIORITY_OOB
operator|)
condition|)
block|{
if|if
condition|(
name|ccb
operator|==
name|NULL
operator|&&
operator|(
name|ccb
operator|=
name|xpt_get_ccb_nowait
argument_list|(
name|periph
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|sleep
condition|)
block|{
name|ccb
operator|=
name|xpt_get_ccb
argument_list|(
name|periph
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
if|if
condition|(
name|periph
operator|->
name|flags
operator|&
name|CAM_PERIPH_RUN_TASK
condition|)
break|break;
name|cam_periph_doacquire
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|periph
operator|->
name|flags
operator||=
name|CAM_PERIPH_RUN_TASK
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|xsoftc
operator|.
name|xpt_taskq
argument_list|,
operator|&
name|periph
operator|->
name|periph_run_task
argument_list|)
expr_stmt|;
break|break;
block|}
name|xpt_setup_ccb
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|periph
operator|->
name|path
argument_list|,
name|prio
argument_list|)
expr_stmt|;
if|if
condition|(
name|prio
operator|==
name|periph
operator|->
name|immediate_priority
condition|)
block|{
name|periph
operator|->
name|immediate_priority
operator|=
name|CAM_PRIORITY_NONE
expr_stmt|;
name|CAM_DEBUG_PRINT
argument_list|(
name|CAM_DEBUG_XPT
argument_list|,
operator|(
literal|"waking cam_periph_getccb()\n"
operator|)
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|periph
operator|->
name|ccb_list
argument_list|,
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|sle
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|periph
operator|->
name|ccb_list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|periph
operator|->
name|scheduled_priority
operator|=
name|CAM_PRIORITY_NONE
expr_stmt|;
name|CAM_DEBUG_PRINT
argument_list|(
name|CAM_DEBUG_XPT
argument_list|,
operator|(
literal|"calling periph_start()\n"
operator|)
argument_list|)
expr_stmt|;
name|periph
operator|->
name|periph_start
argument_list|(
name|periph
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
block|}
name|ccb
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ccb
operator|!=
name|NULL
condition|)
name|xpt_release_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|periph
operator|->
name|periph_allocating
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xpt_run_devq
parameter_list|(
name|struct
name|cam_devq
modifier|*
name|devq
parameter_list|)
block|{
name|int
name|lock
decl_stmt|;
name|CAM_DEBUG_PRINT
argument_list|(
name|CAM_DEBUG_XPT
argument_list|,
operator|(
literal|"xpt_run_devq\n"
operator|)
argument_list|)
expr_stmt|;
name|devq
operator|->
name|send_queue
operator|.
name|qfrozen_cnt
operator|++
expr_stmt|;
while|while
condition|(
operator|(
name|devq
operator|->
name|send_queue
operator|.
name|entries
operator|>
literal|0
operator|)
operator|&&
operator|(
name|devq
operator|->
name|send_openings
operator|>
literal|0
operator|)
operator|&&
operator|(
name|devq
operator|->
name|send_queue
operator|.
name|qfrozen_cnt
operator|<=
literal|1
operator|)
condition|)
block|{
name|struct
name|cam_ed
modifier|*
name|device
decl_stmt|;
name|union
name|ccb
modifier|*
name|work_ccb
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|struct
name|xpt_proto
modifier|*
name|proto
decl_stmt|;
name|device
operator|=
operator|(
expr|struct
name|cam_ed
operator|*
operator|)
name|camq_remove
argument_list|(
operator|&
name|devq
operator|->
name|send_queue
argument_list|,
name|CAMQ_HEAD
argument_list|)
expr_stmt|;
name|CAM_DEBUG_PRINT
argument_list|(
name|CAM_DEBUG_XPT
argument_list|,
operator|(
literal|"running device %p\n"
operator|,
name|device
operator|)
argument_list|)
expr_stmt|;
name|work_ccb
operator|=
name|cam_ccbq_peek_ccb
argument_list|(
operator|&
name|device
operator|->
name|ccbq
argument_list|,
name|CAMQ_HEAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|work_ccb
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"device on run queue with no ccbs???\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|work_ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_HIGH_POWER
operator|)
operator|!=
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_highpower_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|xsoftc
operator|.
name|num_highpower
operator|<=
literal|0
condition|)
block|{
comment|/* 				 * We got a high power command, but we 				 * don't have any available slots.  Freeze 				 * the device queue until we have a slot 				 * available. 				 */
name|xpt_freeze_devq_device
argument_list|(
name|device
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|xsoftc
operator|.
name|highpowerq
argument_list|,
name|device
argument_list|,
name|highpowerq_entry
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_highpower_lock
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
comment|/* 				 * Consume a high power slot while 				 * this ccb runs. 				 */
name|xsoftc
operator|.
name|num_highpower
operator|--
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_highpower_lock
argument_list|)
expr_stmt|;
block|}
name|cam_ccbq_remove_ccb
argument_list|(
operator|&
name|device
operator|->
name|ccbq
argument_list|,
name|work_ccb
argument_list|)
expr_stmt|;
name|cam_ccbq_send_ccb
argument_list|(
operator|&
name|device
operator|->
name|ccbq
argument_list|,
name|work_ccb
argument_list|)
expr_stmt|;
name|devq
operator|->
name|send_openings
operator|--
expr_stmt|;
name|devq
operator|->
name|send_active
operator|++
expr_stmt|;
name|xpt_schedule_devq
argument_list|(
name|devq
argument_list|,
name|device
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|devq
operator|->
name|send_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|work_ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DEV_QFREEZE
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * The client wants to freeze the queue 			 * after this CCB is sent. 			 */
name|xpt_freeze_devq
argument_list|(
name|work_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* In Target mode, the peripheral driver knows best... */
if|if
condition|(
name|work_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_SCSI_IO
condition|)
block|{
if|if
condition|(
operator|(
name|device
operator|->
name|inq_flags
operator|&
name|SID_CmdQue
operator|)
operator|!=
literal|0
operator|&&
name|work_ccb
operator|->
name|csio
operator|.
name|tag_action
operator|!=
name|CAM_TAG_ACTION_NONE
condition|)
name|work_ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_TAG_ACTION_VALID
expr_stmt|;
else|else
comment|/* 				 * Clear this in case of a retried CCB that 				 * failed due to a rejected tag. 				 */
name|work_ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&=
operator|~
name|CAM_TAG_ACTION_VALID
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|device
operator|==
name|work_ccb
operator|->
name|ccb_h
operator|.
name|path
operator|->
name|device
argument_list|,
operator|(
literal|"device (%p) / path->device (%p) mismatch"
operator|,
name|device
operator|,
name|work_ccb
operator|->
name|ccb_h
operator|.
name|path
operator|->
name|device
operator|)
argument_list|)
expr_stmt|;
name|proto
operator|=
name|xpt_proto_find
argument_list|(
name|device
operator|->
name|protocol
argument_list|)
expr_stmt|;
if|if
condition|(
name|proto
operator|&&
name|proto
operator|->
name|ops
operator|->
name|debug_out
condition|)
name|proto
operator|->
name|ops
operator|->
name|debug_out
argument_list|(
name|work_ccb
argument_list|)
expr_stmt|;
comment|/* 		 * Device queues can be shared among multiple SIM instances 		 * that reside on different busses.  Use the SIM from the 		 * queued device, rather than the one from the calling bus. 		 */
name|sim
operator|=
name|device
operator|->
name|sim
expr_stmt|;
name|lock
operator|=
operator|(
name|mtx_owned
argument_list|(
name|sim
operator|->
name|mtx
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|lock
condition|)
name|CAM_SIM_LOCK
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|work_ccb
operator|->
name|ccb_h
operator|.
name|qos
operator|.
name|sim_data
operator|=
name|sbinuptime
argument_list|()
expr_stmt|;
comment|// xxx uintprt_t too small 32bit platforms
operator|(
operator|*
operator|(
name|sim
operator|->
name|sim_action
operator|)
operator|)
operator|(
name|sim
operator|,
name|work_ccb
operator|)
expr_stmt|;
if|if
condition|(
name|lock
condition|)
name|CAM_SIM_UNLOCK
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|devq
operator|->
name|send_mtx
argument_list|)
expr_stmt|;
block|}
name|devq
operator|->
name|send_queue
operator|.
name|qfrozen_cnt
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function merges stuff from the slave ccb into the master ccb, while  * keeping important fields in the master ccb constant.  */
end_comment

begin_function
name|void
name|xpt_merge_ccb
parameter_list|(
name|union
name|ccb
modifier|*
name|master_ccb
parameter_list|,
name|union
name|ccb
modifier|*
name|slave_ccb
parameter_list|)
block|{
comment|/* 	 * Pull fields that are valid for peripheral drivers to set 	 * into the master CCB along with the CCB "payload". 	 */
name|master_ccb
operator|->
name|ccb_h
operator|.
name|retry_count
operator|=
name|slave_ccb
operator|->
name|ccb_h
operator|.
name|retry_count
expr_stmt|;
name|master_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|slave_ccb
operator|->
name|ccb_h
operator|.
name|func_code
expr_stmt|;
name|master_ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|=
name|slave_ccb
operator|->
name|ccb_h
operator|.
name|timeout
expr_stmt|;
name|master_ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|=
name|slave_ccb
operator|->
name|ccb_h
operator|.
name|flags
expr_stmt|;
name|bcopy
argument_list|(
operator|&
operator|(
operator|&
name|slave_ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
operator|&
operator|(
operator|&
name|master_ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|ccb
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xpt_setup_ccb_flags
parameter_list|(
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|u_int32_t
name|priority
parameter_list|,
name|u_int32_t
name|flags
parameter_list|)
block|{
name|CAM_DEBUG
argument_list|(
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"xpt_setup_ccb\n"
operator|)
argument_list|)
expr_stmt|;
name|ccb_h
operator|->
name|pinfo
operator|.
name|priority
operator|=
name|priority
expr_stmt|;
name|ccb_h
operator|->
name|path
operator|=
name|path
expr_stmt|;
name|ccb_h
operator|->
name|path_id
operator|=
name|path
operator|->
name|bus
operator|->
name|path_id
expr_stmt|;
if|if
condition|(
name|path
operator|->
name|target
condition|)
name|ccb_h
operator|->
name|target_id
operator|=
name|path
operator|->
name|target
operator|->
name|target_id
expr_stmt|;
else|else
name|ccb_h
operator|->
name|target_id
operator|=
name|CAM_TARGET_WILDCARD
expr_stmt|;
if|if
condition|(
name|path
operator|->
name|device
condition|)
block|{
name|ccb_h
operator|->
name|target_lun
operator|=
name|path
operator|->
name|device
operator|->
name|lun_id
expr_stmt|;
name|ccb_h
operator|->
name|pinfo
operator|.
name|generation
operator|=
operator|++
name|path
operator|->
name|device
operator|->
name|ccbq
operator|.
name|queue
operator|.
name|generation
expr_stmt|;
block|}
else|else
block|{
name|ccb_h
operator|->
name|target_lun
operator|=
name|CAM_TARGET_WILDCARD
expr_stmt|;
block|}
name|ccb_h
operator|->
name|pinfo
operator|.
name|index
operator|=
name|CAM_UNQUEUED_INDEX
expr_stmt|;
name|ccb_h
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|ccb_h
operator|->
name|xflags
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xpt_setup_ccb
parameter_list|(
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|u_int32_t
name|priority
parameter_list|)
block|{
name|xpt_setup_ccb_flags
argument_list|(
name|ccb_h
argument_list|,
name|path
argument_list|,
name|priority
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Path manipulation functions */
end_comment

begin_function
name|cam_status
name|xpt_create_path
parameter_list|(
name|struct
name|cam_path
modifier|*
modifier|*
name|new_path_ptr
parameter_list|,
name|struct
name|cam_periph
modifier|*
name|perph
parameter_list|,
name|path_id_t
name|path_id
parameter_list|,
name|target_id_t
name|target_id
parameter_list|,
name|lun_id_t
name|lun_id
parameter_list|)
block|{
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|path
operator|=
operator|(
expr|struct
name|cam_path
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|path
argument_list|)
argument_list|,
name|M_CAMPATH
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
block|{
name|status
operator|=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
name|status
operator|=
name|xpt_compile_path
argument_list|(
name|path
argument_list|,
name|perph
argument_list|,
name|path_id
argument_list|,
name|target_id
argument_list|,
name|lun_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|free
argument_list|(
name|path
argument_list|,
name|M_CAMPATH
argument_list|)
expr_stmt|;
name|path
operator|=
name|NULL
expr_stmt|;
block|}
operator|*
name|new_path_ptr
operator|=
name|path
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
name|cam_status
name|xpt_create_path_unlocked
parameter_list|(
name|struct
name|cam_path
modifier|*
modifier|*
name|new_path_ptr
parameter_list|,
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|path_id_t
name|path_id
parameter_list|,
name|target_id_t
name|target_id
parameter_list|,
name|lun_id_t
name|lun_id
parameter_list|)
block|{
return|return
operator|(
name|xpt_create_path
argument_list|(
name|new_path_ptr
argument_list|,
name|periph
argument_list|,
name|path_id
argument_list|,
name|target_id
argument_list|,
name|lun_id
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|cam_status
name|xpt_compile_path
parameter_list|(
name|struct
name|cam_path
modifier|*
name|new_path
parameter_list|,
name|struct
name|cam_periph
modifier|*
name|perph
parameter_list|,
name|path_id_t
name|path_id
parameter_list|,
name|target_id_t
name|target_id
parameter_list|,
name|lun_id_t
name|lun_id
parameter_list|)
block|{
name|struct
name|cam_eb
modifier|*
name|bus
decl_stmt|;
name|struct
name|cam_et
modifier|*
name|target
decl_stmt|;
name|struct
name|cam_ed
modifier|*
name|device
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
comment|/* Completed without error */
name|target
operator|=
name|NULL
expr_stmt|;
comment|/* Wildcarded */
name|device
operator|=
name|NULL
expr_stmt|;
comment|/* Wildcarded */
comment|/* 	 * We will potentially modify the EDT, so block interrupts 	 * that may attempt to create cam paths. 	 */
name|bus
operator|=
name|xpt_find_bus
argument_list|(
name|path_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus
operator|==
name|NULL
condition|)
block|{
name|status
operator|=
name|CAM_PATH_INVALID
expr_stmt|;
block|}
else|else
block|{
name|xpt_lock_buses
argument_list|()
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|bus
operator|->
name|eb_mtx
argument_list|)
expr_stmt|;
name|target
operator|=
name|xpt_find_target
argument_list|(
name|bus
argument_list|,
name|target_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
name|NULL
condition|)
block|{
comment|/* Create one */
name|struct
name|cam_et
modifier|*
name|new_target
decl_stmt|;
name|new_target
operator|=
name|xpt_alloc_target
argument_list|(
name|bus
argument_list|,
name|target_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_target
operator|==
name|NULL
condition|)
block|{
name|status
operator|=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
block|}
else|else
block|{
name|target
operator|=
name|new_target
expr_stmt|;
block|}
block|}
name|xpt_unlock_buses
argument_list|()
expr_stmt|;
if|if
condition|(
name|target
operator|!=
name|NULL
condition|)
block|{
name|device
operator|=
name|xpt_find_device
argument_list|(
name|target
argument_list|,
name|lun_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|device
operator|==
name|NULL
condition|)
block|{
comment|/* Create one */
name|struct
name|cam_ed
modifier|*
name|new_device
decl_stmt|;
name|new_device
operator|=
operator|(
operator|*
operator|(
name|bus
operator|->
name|xport
operator|->
name|ops
operator|->
name|alloc_device
operator|)
operator|)
operator|(
name|bus
operator|,
name|target
operator|,
name|lun_id
operator|)
expr_stmt|;
if|if
condition|(
name|new_device
operator|==
name|NULL
condition|)
block|{
name|status
operator|=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
block|}
else|else
block|{
name|device
operator|=
name|new_device
expr_stmt|;
block|}
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|bus
operator|->
name|eb_mtx
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Only touch the user's data if we are successful. 	 */
if|if
condition|(
name|status
operator|==
name|CAM_REQ_CMP
condition|)
block|{
name|new_path
operator|->
name|periph
operator|=
name|perph
expr_stmt|;
name|new_path
operator|->
name|bus
operator|=
name|bus
expr_stmt|;
name|new_path
operator|->
name|target
operator|=
name|target
expr_stmt|;
name|new_path
operator|->
name|device
operator|=
name|device
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|new_path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"xpt_compile_path\n"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|device
operator|!=
name|NULL
condition|)
name|xpt_release_device
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|!=
name|NULL
condition|)
name|xpt_release_target
argument_list|(
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus
operator|!=
name|NULL
condition|)
name|xpt_release_bus
argument_list|(
name|bus
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
name|cam_status
name|xpt_clone_path
parameter_list|(
name|struct
name|cam_path
modifier|*
modifier|*
name|new_path_ptr
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|)
block|{
name|struct
name|cam_path
modifier|*
name|new_path
decl_stmt|;
name|new_path
operator|=
operator|(
expr|struct
name|cam_path
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|path
argument_list|)
argument_list|,
name|M_CAMPATH
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_path
operator|==
name|NULL
condition|)
return|return
operator|(
name|CAM_RESRC_UNAVAIL
operator|)
return|;
name|xpt_copy_path
argument_list|(
name|new_path
argument_list|,
name|path
argument_list|)
expr_stmt|;
operator|*
name|new_path_ptr
operator|=
name|new_path
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP
operator|)
return|;
block|}
end_function

begin_function
name|void
name|xpt_copy_path
parameter_list|(
name|struct
name|cam_path
modifier|*
name|new_path
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|)
block|{
operator|*
name|new_path
operator|=
operator|*
name|path
expr_stmt|;
if|if
condition|(
name|path
operator|->
name|bus
operator|!=
name|NULL
condition|)
name|xpt_acquire_bus
argument_list|(
name|path
operator|->
name|bus
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|->
name|target
operator|!=
name|NULL
condition|)
name|xpt_acquire_target
argument_list|(
name|path
operator|->
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|->
name|device
operator|!=
name|NULL
condition|)
name|xpt_acquire_device
argument_list|(
name|path
operator|->
name|device
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xpt_release_path
parameter_list|(
name|struct
name|cam_path
modifier|*
name|path
parameter_list|)
block|{
name|CAM_DEBUG
argument_list|(
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"xpt_release_path\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|->
name|device
operator|!=
name|NULL
condition|)
block|{
name|xpt_release_device
argument_list|(
name|path
operator|->
name|device
argument_list|)
expr_stmt|;
name|path
operator|->
name|device
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|path
operator|->
name|target
operator|!=
name|NULL
condition|)
block|{
name|xpt_release_target
argument_list|(
name|path
operator|->
name|target
argument_list|)
expr_stmt|;
name|path
operator|->
name|target
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|path
operator|->
name|bus
operator|!=
name|NULL
condition|)
block|{
name|xpt_release_bus
argument_list|(
name|path
operator|->
name|bus
argument_list|)
expr_stmt|;
name|path
operator|->
name|bus
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|xpt_free_path
parameter_list|(
name|struct
name|cam_path
modifier|*
name|path
parameter_list|)
block|{
name|CAM_DEBUG
argument_list|(
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"xpt_free_path\n"
operator|)
argument_list|)
expr_stmt|;
name|xpt_release_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|,
name|M_CAMPATH
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xpt_path_counts
parameter_list|(
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|uint32_t
modifier|*
name|bus_ref
parameter_list|,
name|uint32_t
modifier|*
name|periph_ref
parameter_list|,
name|uint32_t
modifier|*
name|target_ref
parameter_list|,
name|uint32_t
modifier|*
name|device_ref
parameter_list|)
block|{
name|xpt_lock_buses
argument_list|()
expr_stmt|;
if|if
condition|(
name|bus_ref
condition|)
block|{
if|if
condition|(
name|path
operator|->
name|bus
condition|)
operator|*
name|bus_ref
operator|=
name|path
operator|->
name|bus
operator|->
name|refcount
expr_stmt|;
else|else
operator|*
name|bus_ref
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|periph_ref
condition|)
block|{
if|if
condition|(
name|path
operator|->
name|periph
condition|)
operator|*
name|periph_ref
operator|=
name|path
operator|->
name|periph
operator|->
name|refcount
expr_stmt|;
else|else
operator|*
name|periph_ref
operator|=
literal|0
expr_stmt|;
block|}
name|xpt_unlock_buses
argument_list|()
expr_stmt|;
if|if
condition|(
name|target_ref
condition|)
block|{
if|if
condition|(
name|path
operator|->
name|target
condition|)
operator|*
name|target_ref
operator|=
name|path
operator|->
name|target
operator|->
name|refcount
expr_stmt|;
else|else
operator|*
name|target_ref
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|device_ref
condition|)
block|{
if|if
condition|(
name|path
operator|->
name|device
condition|)
operator|*
name|device_ref
operator|=
name|path
operator|->
name|device
operator|->
name|refcount
expr_stmt|;
else|else
operator|*
name|device_ref
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Return -1 for failure, 0 for exact match, 1 for match with wildcards  * in path1, 2 for match with wildcards in path2.  */
end_comment

begin_function
name|int
name|xpt_path_comp
parameter_list|(
name|struct
name|cam_path
modifier|*
name|path1
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path2
parameter_list|)
block|{
name|int
name|retval
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|path1
operator|->
name|bus
operator|!=
name|path2
operator|->
name|bus
condition|)
block|{
if|if
condition|(
name|path1
operator|->
name|bus
operator|->
name|path_id
operator|==
name|CAM_BUS_WILDCARD
condition|)
name|retval
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|path2
operator|->
name|bus
operator|->
name|path_id
operator|==
name|CAM_BUS_WILDCARD
condition|)
name|retval
operator|=
literal|2
expr_stmt|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|path1
operator|->
name|target
operator|!=
name|path2
operator|->
name|target
condition|)
block|{
if|if
condition|(
name|path1
operator|->
name|target
operator|->
name|target_id
operator|==
name|CAM_TARGET_WILDCARD
condition|)
block|{
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
name|retval
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|path2
operator|->
name|target
operator|->
name|target_id
operator|==
name|CAM_TARGET_WILDCARD
condition|)
name|retval
operator|=
literal|2
expr_stmt|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|path1
operator|->
name|device
operator|!=
name|path2
operator|->
name|device
condition|)
block|{
if|if
condition|(
name|path1
operator|->
name|device
operator|->
name|lun_id
operator|==
name|CAM_LUN_WILDCARD
condition|)
block|{
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
name|retval
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|path2
operator|->
name|device
operator|->
name|lun_id
operator|==
name|CAM_LUN_WILDCARD
condition|)
name|retval
operator|=
literal|2
expr_stmt|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|xpt_path_comp_dev
parameter_list|(
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|struct
name|cam_ed
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|retval
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|path
operator|->
name|bus
operator|!=
name|dev
operator|->
name|target
operator|->
name|bus
condition|)
block|{
if|if
condition|(
name|path
operator|->
name|bus
operator|->
name|path_id
operator|==
name|CAM_BUS_WILDCARD
condition|)
name|retval
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|dev
operator|->
name|target
operator|->
name|bus
operator|->
name|path_id
operator|==
name|CAM_BUS_WILDCARD
condition|)
name|retval
operator|=
literal|2
expr_stmt|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|path
operator|->
name|target
operator|!=
name|dev
operator|->
name|target
condition|)
block|{
if|if
condition|(
name|path
operator|->
name|target
operator|->
name|target_id
operator|==
name|CAM_TARGET_WILDCARD
condition|)
block|{
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
name|retval
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dev
operator|->
name|target
operator|->
name|target_id
operator|==
name|CAM_TARGET_WILDCARD
condition|)
name|retval
operator|=
literal|2
expr_stmt|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|path
operator|->
name|device
operator|!=
name|dev
condition|)
block|{
if|if
condition|(
name|path
operator|->
name|device
operator|->
name|lun_id
operator|==
name|CAM_LUN_WILDCARD
condition|)
block|{
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
name|retval
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dev
operator|->
name|lun_id
operator|==
name|CAM_LUN_WILDCARD
condition|)
name|retval
operator|=
literal|2
expr_stmt|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|void
name|xpt_print_path
parameter_list|(
name|struct
name|cam_path
modifier|*
name|path
parameter_list|)
block|{
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"(nopath): "
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|path
operator|->
name|periph
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"(%s%d:"
argument_list|,
name|path
operator|->
name|periph
operator|->
name|periph_name
argument_list|,
name|path
operator|->
name|periph
operator|->
name|unit_number
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"(noperiph:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|->
name|bus
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"%s%d:%d:"
argument_list|,
name|path
operator|->
name|bus
operator|->
name|sim
operator|->
name|sim_name
argument_list|,
name|path
operator|->
name|bus
operator|->
name|sim
operator|->
name|unit_number
argument_list|,
name|path
operator|->
name|bus
operator|->
name|sim
operator|->
name|bus_id
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"nobus:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|->
name|target
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"%d:"
argument_list|,
name|path
operator|->
name|target
operator|->
name|target_id
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"X:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|->
name|device
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"%jx): "
argument_list|,
operator|(
name|uintmax_t
operator|)
name|path
operator|->
name|device
operator|->
name|lun_id
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"X): "
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|xpt_print_device
parameter_list|(
name|struct
name|cam_ed
modifier|*
name|device
parameter_list|)
block|{
if|if
condition|(
name|device
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"(nopath): "
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"(noperiph:%s%d:%d:%d:%jx): "
argument_list|,
name|device
operator|->
name|sim
operator|->
name|sim_name
argument_list|,
name|device
operator|->
name|sim
operator|->
name|unit_number
argument_list|,
name|device
operator|->
name|sim
operator|->
name|bus_id
argument_list|,
name|device
operator|->
name|target
operator|->
name|target_id
argument_list|,
operator|(
name|uintmax_t
operator|)
name|device
operator|->
name|lun_id
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|xpt_print
parameter_list|(
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|xpt_print_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vprintf
argument_list|(
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|xpt_path_string
parameter_list|(
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|char
modifier|*
name|str
parameter_list|,
name|size_t
name|str_len
parameter_list|)
block|{
name|struct
name|sbuf
name|sb
decl_stmt|;
name|sbuf_new
argument_list|(
operator|&
name|sb
argument_list|,
name|str
argument_list|,
name|str_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"(nopath): "
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|path
operator|->
name|periph
operator|!=
name|NULL
condition|)
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"(%s%d:"
argument_list|,
name|path
operator|->
name|periph
operator|->
name|periph_name
argument_list|,
name|path
operator|->
name|periph
operator|->
name|unit_number
argument_list|)
expr_stmt|;
else|else
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"(noperiph:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|->
name|bus
operator|!=
name|NULL
condition|)
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"%s%d:%d:"
argument_list|,
name|path
operator|->
name|bus
operator|->
name|sim
operator|->
name|sim_name
argument_list|,
name|path
operator|->
name|bus
operator|->
name|sim
operator|->
name|unit_number
argument_list|,
name|path
operator|->
name|bus
operator|->
name|sim
operator|->
name|bus_id
argument_list|)
expr_stmt|;
else|else
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"nobus:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|->
name|target
operator|!=
name|NULL
condition|)
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"%d:"
argument_list|,
name|path
operator|->
name|target
operator|->
name|target_id
argument_list|)
expr_stmt|;
else|else
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"X:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|->
name|device
operator|!=
name|NULL
condition|)
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"%jx): "
argument_list|,
operator|(
name|uintmax_t
operator|)
name|path
operator|->
name|device
operator|->
name|lun_id
argument_list|)
expr_stmt|;
else|else
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"X): "
argument_list|)
expr_stmt|;
block|}
name|sbuf_finish
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|sbuf_len
argument_list|(
operator|&
name|sb
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|path_id_t
name|xpt_path_path_id
parameter_list|(
name|struct
name|cam_path
modifier|*
name|path
parameter_list|)
block|{
return|return
operator|(
name|path
operator|->
name|bus
operator|->
name|path_id
operator|)
return|;
block|}
end_function

begin_function
name|target_id_t
name|xpt_path_target_id
parameter_list|(
name|struct
name|cam_path
modifier|*
name|path
parameter_list|)
block|{
if|if
condition|(
name|path
operator|->
name|target
operator|!=
name|NULL
condition|)
return|return
operator|(
name|path
operator|->
name|target
operator|->
name|target_id
operator|)
return|;
else|else
return|return
operator|(
name|CAM_TARGET_WILDCARD
operator|)
return|;
block|}
end_function

begin_function
name|lun_id_t
name|xpt_path_lun_id
parameter_list|(
name|struct
name|cam_path
modifier|*
name|path
parameter_list|)
block|{
if|if
condition|(
name|path
operator|->
name|device
operator|!=
name|NULL
condition|)
return|return
operator|(
name|path
operator|->
name|device
operator|->
name|lun_id
operator|)
return|;
else|else
return|return
operator|(
name|CAM_LUN_WILDCARD
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|cam_sim
modifier|*
name|xpt_path_sim
parameter_list|(
name|struct
name|cam_path
modifier|*
name|path
parameter_list|)
block|{
return|return
operator|(
name|path
operator|->
name|bus
operator|->
name|sim
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|cam_periph
modifier|*
name|xpt_path_periph
parameter_list|(
name|struct
name|cam_path
modifier|*
name|path
parameter_list|)
block|{
return|return
operator|(
name|path
operator|->
name|periph
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Release a CAM control block for the caller.  Remit the cost of the structure  * to the device referenced by the path.  If the this device had no 'credits'  * and peripheral drivers have registered async callbacks for this notification  * call them now.  */
end_comment

begin_function
name|void
name|xpt_release_ccb
parameter_list|(
name|union
name|ccb
modifier|*
name|free_ccb
parameter_list|)
block|{
name|struct
name|cam_ed
modifier|*
name|device
decl_stmt|;
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|CAM_DEBUG_PRINT
argument_list|(
name|CAM_DEBUG_XPT
argument_list|,
operator|(
literal|"xpt_release_ccb\n"
operator|)
argument_list|)
expr_stmt|;
name|xpt_path_assert
argument_list|(
name|free_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|device
operator|=
name|free_ccb
operator|->
name|ccb_h
operator|.
name|path
operator|->
name|device
expr_stmt|;
name|periph
operator|=
name|free_ccb
operator|->
name|ccb_h
operator|.
name|path
operator|->
name|periph
expr_stmt|;
name|xpt_free_ccb
argument_list|(
name|free_ccb
argument_list|)
expr_stmt|;
name|periph
operator|->
name|periph_allocated
operator|--
expr_stmt|;
name|cam_ccbq_release_opening
argument_list|(
operator|&
name|device
operator|->
name|ccbq
argument_list|)
expr_stmt|;
name|xpt_run_allocq
argument_list|(
name|periph
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Functions accessed by SIM drivers */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|xpt_xport_ops
name|xport_default_ops
init|=
block|{
operator|.
name|alloc_device
operator|=
name|xpt_alloc_device_default
block|,
operator|.
name|action
operator|=
name|xpt_action_default
block|,
operator|.
name|async
operator|=
name|xpt_dev_async_default
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|xpt_xport
name|xport_default
init|=
block|{
operator|.
name|xport
operator|=
name|XPORT_UNKNOWN
block|,
operator|.
name|name
operator|=
literal|"unknown"
block|,
operator|.
name|ops
operator|=
operator|&
name|xport_default_ops
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|CAM_XPT_XPORT
argument_list|(
name|xport_default
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * A sim structure, listing the SIM entry points and instance  * identification info is passed to xpt_bus_register to hook the SIM  * into the CAM framework.  xpt_bus_register creates a cam_eb entry  * for this new bus and places it in the array of busses and assigns  * it a path_id.  The path_id may be influenced by "hard wiring"  * information specified by the user.  Once interrupt services are  * available, the bus will be probed.  */
end_comment

begin_function
name|int32_t
name|xpt_bus_register
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|device_t
name|parent
parameter_list|,
name|u_int32_t
name|bus
parameter_list|)
block|{
name|struct
name|cam_eb
modifier|*
name|new_bus
decl_stmt|;
name|struct
name|cam_eb
modifier|*
name|old_bus
decl_stmt|;
name|struct
name|ccb_pathinq
name|cpi
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|mtx_assert
argument_list|(
name|sim
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|sim
operator|->
name|bus_id
operator|=
name|bus
expr_stmt|;
name|new_bus
operator|=
operator|(
expr|struct
name|cam_eb
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new_bus
argument_list|)
argument_list|,
name|M_CAMXPT
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_bus
operator|==
name|NULL
condition|)
block|{
comment|/* Couldn't satisfy request */
return|return
operator|(
name|CAM_RESRC_UNAVAIL
operator|)
return|;
block|}
name|mtx_init
argument_list|(
operator|&
name|new_bus
operator|->
name|eb_mtx
argument_list|,
literal|"CAM bus lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|new_bus
operator|->
name|et_entries
argument_list|)
expr_stmt|;
name|cam_sim_hold
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|new_bus
operator|->
name|sim
operator|=
name|sim
expr_stmt|;
name|timevalclear
argument_list|(
operator|&
name|new_bus
operator|->
name|last_reset
argument_list|)
expr_stmt|;
name|new_bus
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|new_bus
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
comment|/* Held until a bus_deregister event */
name|new_bus
operator|->
name|generation
operator|=
literal|0
expr_stmt|;
name|xpt_lock_buses
argument_list|()
expr_stmt|;
name|sim
operator|->
name|path_id
operator|=
name|new_bus
operator|->
name|path_id
operator|=
name|xptpathid
argument_list|(
name|sim
operator|->
name|sim_name
argument_list|,
name|sim
operator|->
name|unit_number
argument_list|,
name|sim
operator|->
name|bus_id
argument_list|)
expr_stmt|;
name|old_bus
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_busses
argument_list|)
expr_stmt|;
while|while
condition|(
name|old_bus
operator|!=
name|NULL
operator|&&
name|old_bus
operator|->
name|path_id
operator|<
name|new_bus
operator|->
name|path_id
condition|)
name|old_bus
operator|=
name|TAILQ_NEXT
argument_list|(
name|old_bus
argument_list|,
name|links
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_bus
operator|!=
name|NULL
condition|)
name|TAILQ_INSERT_BEFORE
argument_list|(
name|old_bus
argument_list|,
name|new_bus
argument_list|,
name|links
argument_list|)
expr_stmt|;
else|else
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_busses
argument_list|,
name|new_bus
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|xsoftc
operator|.
name|bus_generation
operator|++
expr_stmt|;
name|xpt_unlock_buses
argument_list|()
expr_stmt|;
comment|/* 	 * Set a default transport so that a PATH_INQ can be issued to 	 * the SIM.  This will then allow for probing and attaching of 	 * a more appropriate transport. 	 */
name|new_bus
operator|->
name|xport
operator|=
operator|&
name|xport_default
expr_stmt|;
name|status
operator|=
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|sim
operator|->
name|path_id
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_release_bus
argument_list|(
name|new_bus
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|,
name|M_CAMXPT
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_RESRC_UNAVAIL
operator|)
return|;
block|}
name|xpt_setup_ccb
argument_list|(
operator|&
name|cpi
operator|.
name|ccb_h
argument_list|,
name|path
argument_list|,
name|CAM_PRIORITY_NORMAL
argument_list|)
expr_stmt|;
name|cpi
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_PATH_INQ
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|cpi
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpi
operator|.
name|ccb_h
operator|.
name|status
operator|==
name|CAM_REQ_CMP
condition|)
block|{
name|struct
name|xpt_xport
modifier|*
modifier|*
name|xpt
decl_stmt|;
name|SET_FOREACH
argument_list|(
argument|xpt
argument_list|,
argument|cam_xpt_xport_set
argument_list|)
block|{
if|if
condition|(
operator|(
operator|*
name|xpt
operator|)
operator|->
name|xport
operator|==
name|cpi
operator|.
name|transport
condition|)
block|{
name|new_bus
operator|->
name|xport
operator|=
operator|*
name|xpt
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|new_bus
operator|->
name|xport
operator|==
name|NULL
condition|)
block|{
name|xpt_print_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"No transport found for %d\n"
argument_list|,
name|cpi
operator|.
name|transport
argument_list|)
expr_stmt|;
name|xpt_release_bus
argument_list|(
name|new_bus
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|,
name|M_CAMXPT
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_RESRC_UNAVAIL
operator|)
return|;
block|}
block|}
comment|/* Notify interested parties */
if|if
condition|(
name|sim
operator|->
name|path_id
operator|!=
name|CAM_XPT_PATH_ID
condition|)
block|{
name|xpt_async
argument_list|(
name|AC_PATH_REGISTERED
argument_list|,
name|path
argument_list|,
operator|&
name|cpi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cpi
operator|.
name|hba_misc
operator|&
name|PIM_NOSCAN
operator|)
operator|==
literal|0
condition|)
block|{
name|union
name|ccb
modifier|*
name|scan_ccb
decl_stmt|;
comment|/* Initiate bus rescan. */
name|scan_ccb
operator|=
name|xpt_alloc_ccb_nowait
argument_list|()
expr_stmt|;
if|if
condition|(
name|scan_ccb
operator|!=
name|NULL
condition|)
block|{
name|scan_ccb
operator|->
name|ccb_h
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|scan_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SCAN_BUS
expr_stmt|;
name|scan_ccb
operator|->
name|crcn
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|xpt_rescan
argument_list|(
name|scan_ccb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xpt_print
argument_list|(
name|path
argument_list|,
literal|"Can't allocate CCB to scan bus\n"
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
else|else
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|int32_t
name|xpt_bus_deregister
parameter_list|(
name|path_id_t
name|pathid
parameter_list|)
block|{
name|struct
name|cam_path
name|bus_path
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|status
operator|=
name|xpt_compile_path
argument_list|(
operator|&
name|bus_path
argument_list|,
name|NULL
argument_list|,
name|pathid
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
return|return
operator|(
name|status
operator|)
return|;
name|xpt_async
argument_list|(
name|AC_LOST_DEVICE
argument_list|,
operator|&
name|bus_path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xpt_async
argument_list|(
name|AC_PATH_DEREGISTERED
argument_list|,
operator|&
name|bus_path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Release the reference count held while registered. */
name|xpt_release_bus
argument_list|(
name|bus_path
operator|.
name|bus
argument_list|)
expr_stmt|;
name|xpt_release_path
argument_list|(
operator|&
name|bus_path
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|path_id_t
name|xptnextfreepathid
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cam_eb
modifier|*
name|bus
decl_stmt|;
name|path_id_t
name|pathid
decl_stmt|;
specifier|const
name|char
modifier|*
name|strval
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_topo_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|pathid
operator|=
literal|0
expr_stmt|;
name|bus
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_busses
argument_list|)
expr_stmt|;
name|retry
label|:
comment|/* Find an unoccupied pathid */
while|while
condition|(
name|bus
operator|!=
name|NULL
operator|&&
name|bus
operator|->
name|path_id
operator|<=
name|pathid
condition|)
block|{
if|if
condition|(
name|bus
operator|->
name|path_id
operator|==
name|pathid
condition|)
name|pathid
operator|++
expr_stmt|;
name|bus
operator|=
name|TAILQ_NEXT
argument_list|(
name|bus
argument_list|,
name|links
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Ensure that this pathid is not reserved for 	 * a bus that may be registered in the future. 	 */
if|if
condition|(
name|resource_string_value
argument_list|(
literal|"scbus"
argument_list|,
name|pathid
argument_list|,
literal|"at"
argument_list|,
operator|&
name|strval
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|++
name|pathid
expr_stmt|;
comment|/* Start the search over */
goto|goto
name|retry
goto|;
block|}
return|return
operator|(
name|pathid
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|path_id_t
name|xptpathid
parameter_list|(
specifier|const
name|char
modifier|*
name|sim_name
parameter_list|,
name|int
name|sim_unit
parameter_list|,
name|int
name|sim_bus
parameter_list|)
block|{
name|path_id_t
name|pathid
decl_stmt|;
name|int
name|i
decl_stmt|,
name|dunit
decl_stmt|,
name|val
decl_stmt|;
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|dname
decl_stmt|;
name|pathid
operator|=
name|CAM_XPT_PATH_ID
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s%d"
argument_list|,
name|sim_name
argument_list|,
name|sim_unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|buf
argument_list|,
literal|"xpt0"
argument_list|)
operator|==
literal|0
operator|&&
name|sim_bus
operator|==
literal|0
condition|)
return|return
operator|(
name|pathid
operator|)
return|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|resource_find_match
argument_list|(
operator|&
name|i
argument_list|,
operator|&
name|dname
argument_list|,
operator|&
name|dunit
argument_list|,
literal|"at"
argument_list|,
name|buf
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|dname
argument_list|,
literal|"scbus"
argument_list|)
condition|)
block|{
comment|/* Avoid a bit of foot shooting. */
continue|continue;
block|}
if|if
condition|(
name|dunit
operator|<
literal|0
condition|)
comment|/* unwired?! */
continue|continue;
if|if
condition|(
name|resource_int_value
argument_list|(
literal|"scbus"
argument_list|,
name|dunit
argument_list|,
literal|"bus"
argument_list|,
operator|&
name|val
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sim_bus
operator|==
name|val
condition|)
block|{
name|pathid
operator|=
name|dunit
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|sim_bus
operator|==
literal|0
condition|)
block|{
comment|/* Unspecified matches bus 0 */
name|pathid
operator|=
name|dunit
expr_stmt|;
break|break;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Ambiguous scbus configuration for %s%d "
literal|"bus %d, cannot wire down.  The kernel "
literal|"config entry for scbus%d should "
literal|"specify a controller bus.\n"
literal|"Scbus will be assigned dynamically.\n"
argument_list|,
name|sim_name
argument_list|,
name|sim_unit
argument_list|,
name|sim_bus
argument_list|,
name|dunit
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|pathid
operator|==
name|CAM_XPT_PATH_ID
condition|)
name|pathid
operator|=
name|xptnextfreepathid
argument_list|()
expr_stmt|;
return|return
operator|(
name|pathid
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|xpt_async_string
parameter_list|(
name|u_int32_t
name|async_code
parameter_list|)
block|{
switch|switch
condition|(
name|async_code
condition|)
block|{
case|case
name|AC_BUS_RESET
case|:
return|return
operator|(
literal|"AC_BUS_RESET"
operator|)
return|;
case|case
name|AC_UNSOL_RESEL
case|:
return|return
operator|(
literal|"AC_UNSOL_RESEL"
operator|)
return|;
case|case
name|AC_SCSI_AEN
case|:
return|return
operator|(
literal|"AC_SCSI_AEN"
operator|)
return|;
case|case
name|AC_SENT_BDR
case|:
return|return
operator|(
literal|"AC_SENT_BDR"
operator|)
return|;
case|case
name|AC_PATH_REGISTERED
case|:
return|return
operator|(
literal|"AC_PATH_REGISTERED"
operator|)
return|;
case|case
name|AC_PATH_DEREGISTERED
case|:
return|return
operator|(
literal|"AC_PATH_DEREGISTERED"
operator|)
return|;
case|case
name|AC_FOUND_DEVICE
case|:
return|return
operator|(
literal|"AC_FOUND_DEVICE"
operator|)
return|;
case|case
name|AC_LOST_DEVICE
case|:
return|return
operator|(
literal|"AC_LOST_DEVICE"
operator|)
return|;
case|case
name|AC_TRANSFER_NEG
case|:
return|return
operator|(
literal|"AC_TRANSFER_NEG"
operator|)
return|;
case|case
name|AC_INQ_CHANGED
case|:
return|return
operator|(
literal|"AC_INQ_CHANGED"
operator|)
return|;
case|case
name|AC_GETDEV_CHANGED
case|:
return|return
operator|(
literal|"AC_GETDEV_CHANGED"
operator|)
return|;
case|case
name|AC_CONTRACT
case|:
return|return
operator|(
literal|"AC_CONTRACT"
operator|)
return|;
case|case
name|AC_ADVINFO_CHANGED
case|:
return|return
operator|(
literal|"AC_ADVINFO_CHANGED"
operator|)
return|;
case|case
name|AC_UNIT_ATTENTION
case|:
return|return
operator|(
literal|"AC_UNIT_ATTENTION"
operator|)
return|;
block|}
return|return
operator|(
literal|"AC_UNKNOWN"
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xpt_async_size
parameter_list|(
name|u_int32_t
name|async_code
parameter_list|)
block|{
switch|switch
condition|(
name|async_code
condition|)
block|{
case|case
name|AC_BUS_RESET
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|AC_UNSOL_RESEL
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|AC_SCSI_AEN
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|AC_SENT_BDR
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|AC_PATH_REGISTERED
case|:
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_pathinq
argument_list|)
operator|)
return|;
case|case
name|AC_PATH_DEREGISTERED
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|AC_FOUND_DEVICE
case|:
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_getdev
argument_list|)
operator|)
return|;
case|case
name|AC_LOST_DEVICE
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|AC_TRANSFER_NEG
case|:
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_trans_settings
argument_list|)
operator|)
return|;
case|case
name|AC_INQ_CHANGED
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|AC_GETDEV_CHANGED
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|AC_CONTRACT
case|:
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ac_contract
argument_list|)
operator|)
return|;
case|case
name|AC_ADVINFO_CHANGED
case|:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
name|AC_UNIT_ATTENTION
case|:
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_scsiio
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xpt_async_process_dev
parameter_list|(
name|struct
name|cam_ed
modifier|*
name|device
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
init|=
name|arg
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
init|=
name|ccb
operator|->
name|ccb_h
operator|.
name|path
decl_stmt|;
name|void
modifier|*
name|async_arg
init|=
name|ccb
operator|->
name|casync
operator|.
name|async_arg_ptr
decl_stmt|;
name|u_int32_t
name|async_code
init|=
name|ccb
operator|->
name|casync
operator|.
name|async_code
decl_stmt|;
name|int
name|relock
decl_stmt|;
if|if
condition|(
name|path
operator|->
name|device
operator|!=
name|device
operator|&&
name|path
operator|->
name|device
operator|->
name|lun_id
operator|!=
name|CAM_LUN_WILDCARD
operator|&&
name|device
operator|->
name|lun_id
operator|!=
name|CAM_LUN_WILDCARD
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * The async callback could free the device. 	 * If it is a broadcast async, it doesn't hold 	 * device reference, so take our own reference. 	 */
name|xpt_acquire_device
argument_list|(
name|device
argument_list|)
expr_stmt|;
comment|/* 	 * If async for specific device is to be delivered to 	 * the wildcard client, take the specific device lock. 	 * XXX: We may need a way for client to specify it. 	 */
if|if
condition|(
operator|(
name|device
operator|->
name|lun_id
operator|==
name|CAM_LUN_WILDCARD
operator|&&
name|path
operator|->
name|device
operator|->
name|lun_id
operator|!=
name|CAM_LUN_WILDCARD
operator|)
operator|||
operator|(
name|device
operator|->
name|target
operator|->
name|target_id
operator|==
name|CAM_TARGET_WILDCARD
operator|&&
name|path
operator|->
name|target
operator|->
name|target_id
operator|!=
name|CAM_TARGET_WILDCARD
operator|)
operator|||
operator|(
name|device
operator|->
name|target
operator|->
name|bus
operator|->
name|path_id
operator|==
name|CAM_BUS_WILDCARD
operator|&&
name|path
operator|->
name|target
operator|->
name|bus
operator|->
name|path_id
operator|!=
name|CAM_BUS_WILDCARD
operator|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|device
operator|->
name|device_mtx
argument_list|)
expr_stmt|;
name|xpt_path_lock
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|relock
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|relock
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
operator|(
name|device
operator|->
name|target
operator|->
name|bus
operator|->
name|xport
operator|->
name|ops
operator|->
name|async
operator|)
operator|)
operator|(
name|async_code
operator|,
name|device
operator|->
name|target
operator|->
name|bus
operator|,
name|device
operator|->
name|target
operator|,
name|device
operator|,
name|async_arg
operator|)
expr_stmt|;
name|xpt_async_bcast
argument_list|(
operator|&
name|device
operator|->
name|asyncs
argument_list|,
name|async_code
argument_list|,
name|path
argument_list|,
name|async_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|relock
condition|)
block|{
name|xpt_path_unlock
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|device
operator|->
name|device_mtx
argument_list|)
expr_stmt|;
block|}
name|xpt_release_device
argument_list|(
name|device
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xpt_async_process_tgt
parameter_list|(
name|struct
name|cam_et
modifier|*
name|target
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
init|=
name|arg
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
init|=
name|ccb
operator|->
name|ccb_h
operator|.
name|path
decl_stmt|;
if|if
condition|(
name|path
operator|->
name|target
operator|!=
name|target
operator|&&
name|path
operator|->
name|target
operator|->
name|target_id
operator|!=
name|CAM_TARGET_WILDCARD
operator|&&
name|target
operator|->
name|target_id
operator|!=
name|CAM_TARGET_WILDCARD
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|ccb
operator|->
name|casync
operator|.
name|async_code
operator|==
name|AC_SENT_BDR
condition|)
block|{
comment|/* Update our notion of when the last reset occurred */
name|microtime
argument_list|(
operator|&
name|target
operator|->
name|last_reset
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|xptdevicetraverse
argument_list|(
name|target
argument_list|,
name|NULL
argument_list|,
name|xpt_async_process_dev
argument_list|,
name|ccb
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xpt_async_process
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|cam_eb
modifier|*
name|bus
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|void
modifier|*
name|async_arg
decl_stmt|;
name|u_int32_t
name|async_code
decl_stmt|;
name|path
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|path
expr_stmt|;
name|async_code
operator|=
name|ccb
operator|->
name|casync
operator|.
name|async_code
expr_stmt|;
name|async_arg
operator|=
name|ccb
operator|->
name|casync
operator|.
name|async_arg_ptr
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|path
argument_list|,
name|CAM_DEBUG_TRACE
operator||
name|CAM_DEBUG_INFO
argument_list|,
operator|(
literal|"xpt_async(%s)\n"
operator|,
name|xpt_async_string
argument_list|(
name|async_code
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|bus
operator|=
name|path
operator|->
name|bus
expr_stmt|;
if|if
condition|(
name|async_code
operator|==
name|AC_BUS_RESET
condition|)
block|{
comment|/* Update our notion of when the last reset occurred */
name|microtime
argument_list|(
operator|&
name|bus
operator|->
name|last_reset
argument_list|)
expr_stmt|;
block|}
name|xpttargettraverse
argument_list|(
name|bus
argument_list|,
name|NULL
argument_list|,
name|xpt_async_process_tgt
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
comment|/* 	 * If this wasn't a fully wildcarded async, tell all 	 * clients that want all async events. 	 */
if|if
condition|(
name|bus
operator|!=
name|xpt_periph
operator|->
name|path
operator|->
name|bus
condition|)
block|{
name|xpt_path_lock
argument_list|(
name|xpt_periph
operator|->
name|path
argument_list|)
expr_stmt|;
name|xpt_async_process_dev
argument_list|(
name|xpt_periph
operator|->
name|path
operator|->
name|device
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
name|xpt_path_unlock
argument_list|(
name|xpt_periph
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|path
operator|->
name|device
operator|!=
name|NULL
operator|&&
name|path
operator|->
name|device
operator|->
name|lun_id
operator|!=
name|CAM_LUN_WILDCARD
condition|)
name|xpt_release_devq
argument_list|(
name|path
argument_list|,
literal|1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
else|else
name|xpt_release_simq
argument_list|(
name|path
operator|->
name|bus
operator|->
name|sim
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|casync
operator|.
name|async_arg_size
operator|>
literal|0
condition|)
name|free
argument_list|(
name|async_arg
argument_list|,
name|M_CAMXPT
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|xpt_free_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xpt_async_bcast
parameter_list|(
name|struct
name|async_list
modifier|*
name|async_head
parameter_list|,
name|u_int32_t
name|async_code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|async_arg
parameter_list|)
block|{
name|struct
name|async_node
modifier|*
name|cur_entry
decl_stmt|;
name|int
name|lock
decl_stmt|;
name|cur_entry
operator|=
name|SLIST_FIRST
argument_list|(
name|async_head
argument_list|)
expr_stmt|;
while|while
condition|(
name|cur_entry
operator|!=
name|NULL
condition|)
block|{
name|struct
name|async_node
modifier|*
name|next_entry
decl_stmt|;
comment|/* 		 * Grab the next list entry before we call the current 		 * entry's callback.  This is because the callback function 		 * can delete its async callback entry. 		 */
name|next_entry
operator|=
name|SLIST_NEXT
argument_list|(
name|cur_entry
argument_list|,
name|links
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cur_entry
operator|->
name|event_enable
operator|&
name|async_code
operator|)
operator|!=
literal|0
condition|)
block|{
name|lock
operator|=
name|cur_entry
operator|->
name|event_lock
expr_stmt|;
if|if
condition|(
name|lock
condition|)
name|CAM_SIM_LOCK
argument_list|(
name|path
operator|->
name|device
operator|->
name|sim
argument_list|)
expr_stmt|;
name|cur_entry
operator|->
name|callback
argument_list|(
name|cur_entry
operator|->
name|callback_arg
argument_list|,
name|async_code
argument_list|,
name|path
argument_list|,
name|async_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock
condition|)
name|CAM_SIM_UNLOCK
argument_list|(
name|path
operator|->
name|device
operator|->
name|sim
argument_list|)
expr_stmt|;
block|}
name|cur_entry
operator|=
name|next_entry
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|xpt_async
parameter_list|(
name|u_int32_t
name|async_code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|async_arg
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|size
decl_stmt|;
name|ccb
operator|=
name|xpt_alloc_ccb_nowait
argument_list|()
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|xpt_print
argument_list|(
name|path
argument_list|,
literal|"Can't allocate CCB to send %s\n"
argument_list|,
name|xpt_async_string
argument_list|(
name|async_code
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|xpt_clone_path
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|path
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_print
argument_list|(
name|path
argument_list|,
literal|"Can't allocate path to send %s\n"
argument_list|,
name|xpt_async_string
argument_list|(
name|async_code
argument_list|)
argument_list|)
expr_stmt|;
name|xpt_free_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|path
operator|->
name|periph
operator|=
name|NULL
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_ASYNC
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|cbfcnp
operator|=
name|xpt_async_process
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_UNLOCKED
expr_stmt|;
name|ccb
operator|->
name|casync
operator|.
name|async_code
operator|=
name|async_code
expr_stmt|;
name|ccb
operator|->
name|casync
operator|.
name|async_arg_size
operator|=
literal|0
expr_stmt|;
name|size
operator|=
name|xpt_async_size
argument_list|(
name|async_code
argument_list|)
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"xpt_async: func %#x %s aync_code %d %s\n"
operator|,
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|,
name|xpt_action_name
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
argument_list|)
operator|,
name|async_code
operator|,
name|xpt_async_string
argument_list|(
name|async_code
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
operator|&&
name|async_arg
operator|!=
name|NULL
condition|)
block|{
name|ccb
operator|->
name|casync
operator|.
name|async_arg_ptr
operator|=
name|malloc
argument_list|(
name|size
argument_list|,
name|M_CAMXPT
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|casync
operator|.
name|async_arg_ptr
operator|==
name|NULL
condition|)
block|{
name|xpt_print
argument_list|(
name|path
argument_list|,
literal|"Can't allocate argument to send %s\n"
argument_list|,
name|xpt_async_string
argument_list|(
name|async_code
argument_list|)
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|xpt_free_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|memcpy
argument_list|(
name|ccb
operator|->
name|casync
operator|.
name|async_arg_ptr
argument_list|,
name|async_arg
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|casync
operator|.
name|async_arg_size
operator|=
name|size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
name|ccb
operator|->
name|casync
operator|.
name|async_arg_ptr
operator|=
name|async_arg
expr_stmt|;
name|ccb
operator|->
name|casync
operator|.
name|async_arg_size
operator|=
name|size
expr_stmt|;
block|}
if|if
condition|(
name|path
operator|->
name|device
operator|!=
name|NULL
operator|&&
name|path
operator|->
name|device
operator|->
name|lun_id
operator|!=
name|CAM_LUN_WILDCARD
condition|)
name|xpt_freeze_devq
argument_list|(
name|path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|xpt_freeze_simq
argument_list|(
name|path
operator|->
name|bus
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xpt_dev_async_default
parameter_list|(
name|u_int32_t
name|async_code
parameter_list|,
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|,
name|struct
name|cam_et
modifier|*
name|target
parameter_list|,
name|struct
name|cam_ed
modifier|*
name|device
parameter_list|,
name|void
modifier|*
name|async_arg
parameter_list|)
block|{
comment|/* 	 * We only need to handle events for real devices. 	 */
if|if
condition|(
name|target
operator|->
name|target_id
operator|==
name|CAM_TARGET_WILDCARD
operator|||
name|device
operator|->
name|lun_id
operator|==
name|CAM_LUN_WILDCARD
condition|)
return|return;
name|printf
argument_list|(
literal|"%s called\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|xpt_freeze_devq_device
parameter_list|(
name|struct
name|cam_ed
modifier|*
name|dev
parameter_list|,
name|u_int
name|count
parameter_list|)
block|{
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
name|uint32_t
name|freeze
decl_stmt|;
name|devq
operator|=
name|dev
operator|->
name|sim
operator|->
name|devq
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|devq
operator|->
name|send_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|CAM_DEBUG_DEV
argument_list|(
name|dev
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"xpt_freeze_devq_device(%d) %u->%u\n"
operator|,
name|count
operator|,
name|dev
operator|->
name|ccbq
operator|.
name|queue
operator|.
name|qfrozen_cnt
operator|,
name|dev
operator|->
name|ccbq
operator|.
name|queue
operator|.
name|qfrozen_cnt
operator|+
name|count
operator|)
argument_list|)
expr_stmt|;
name|freeze
operator|=
operator|(
name|dev
operator|->
name|ccbq
operator|.
name|queue
operator|.
name|qfrozen_cnt
operator|+=
name|count
operator|)
expr_stmt|;
comment|/* Remove frozen device from sendq. */
if|if
condition|(
name|device_is_queued
argument_list|(
name|dev
argument_list|)
condition|)
name|camq_remove
argument_list|(
operator|&
name|devq
operator|->
name|send_queue
argument_list|,
name|dev
operator|->
name|devq_entry
operator|.
name|index
argument_list|)
expr_stmt|;
return|return
operator|(
name|freeze
operator|)
return|;
block|}
end_function

begin_function
name|u_int32_t
name|xpt_freeze_devq
parameter_list|(
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|u_int
name|count
parameter_list|)
block|{
name|struct
name|cam_ed
modifier|*
name|dev
init|=
name|path
operator|->
name|device
decl_stmt|;
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
name|uint32_t
name|freeze
decl_stmt|;
name|devq
operator|=
name|dev
operator|->
name|sim
operator|->
name|devq
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|devq
operator|->
name|send_mtx
argument_list|)
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"xpt_freeze_devq(%d)\n"
operator|,
name|count
operator|)
argument_list|)
expr_stmt|;
name|freeze
operator|=
name|xpt_freeze_devq_device
argument_list|(
name|dev
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|devq
operator|->
name|send_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|freeze
operator|)
return|;
block|}
end_function

begin_function
name|u_int32_t
name|xpt_freeze_simq
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|u_int
name|count
parameter_list|)
block|{
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
name|uint32_t
name|freeze
decl_stmt|;
name|devq
operator|=
name|sim
operator|->
name|devq
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|devq
operator|->
name|send_mtx
argument_list|)
expr_stmt|;
name|freeze
operator|=
operator|(
name|devq
operator|->
name|send_queue
operator|.
name|qfrozen_cnt
operator|+=
name|count
operator|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|devq
operator|->
name|send_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|freeze
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xpt_release_devq_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cam_ed
modifier|*
name|dev
decl_stmt|;
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
name|dev
operator|=
operator|(
expr|struct
name|cam_ed
operator|*
operator|)
name|arg
expr_stmt|;
name|CAM_DEBUG_DEV
argument_list|(
name|dev
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"xpt_release_devq_timeout\n"
operator|)
argument_list|)
expr_stmt|;
name|devq
operator|=
name|dev
operator|->
name|sim
operator|->
name|devq
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|devq
operator|->
name|send_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|xpt_release_devq_device
argument_list|(
name|dev
argument_list|,
comment|/*count*/
literal|1
argument_list|,
comment|/*run_queue*/
name|TRUE
argument_list|)
condition|)
name|xpt_run_devq
argument_list|(
name|devq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xpt_release_devq
parameter_list|(
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|u_int
name|count
parameter_list|,
name|int
name|run_queue
parameter_list|)
block|{
name|struct
name|cam_ed
modifier|*
name|dev
decl_stmt|;
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"xpt_release_devq(%d, %d)\n"
operator|,
name|count
operator|,
name|run_queue
operator|)
argument_list|)
expr_stmt|;
name|dev
operator|=
name|path
operator|->
name|device
expr_stmt|;
name|devq
operator|=
name|dev
operator|->
name|sim
operator|->
name|devq
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|devq
operator|->
name|send_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|xpt_release_devq_device
argument_list|(
name|dev
argument_list|,
name|count
argument_list|,
name|run_queue
argument_list|)
condition|)
name|xpt_run_devq
argument_list|(
name|dev
operator|->
name|sim
operator|->
name|devq
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|devq
operator|->
name|send_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|xpt_release_devq_device
parameter_list|(
name|struct
name|cam_ed
modifier|*
name|dev
parameter_list|,
name|u_int
name|count
parameter_list|,
name|int
name|run_queue
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|dev
operator|->
name|sim
operator|->
name|devq
operator|->
name|send_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|CAM_DEBUG_DEV
argument_list|(
name|dev
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"xpt_release_devq_device(%d, %d) %u->%u\n"
operator|,
name|count
operator|,
name|run_queue
operator|,
name|dev
operator|->
name|ccbq
operator|.
name|queue
operator|.
name|qfrozen_cnt
operator|,
name|dev
operator|->
name|ccbq
operator|.
name|queue
operator|.
name|qfrozen_cnt
operator|-
name|count
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|dev
operator|->
name|ccbq
operator|.
name|queue
operator|.
name|qfrozen_cnt
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|printf
argument_list|(
literal|"xpt_release_devq(): requested %u> present %u\n"
argument_list|,
name|count
argument_list|,
name|dev
operator|->
name|ccbq
operator|.
name|queue
operator|.
name|qfrozen_cnt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|count
operator|=
name|dev
operator|->
name|ccbq
operator|.
name|queue
operator|.
name|qfrozen_cnt
expr_stmt|;
block|}
name|dev
operator|->
name|ccbq
operator|.
name|queue
operator|.
name|qfrozen_cnt
operator|-=
name|count
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|ccbq
operator|.
name|queue
operator|.
name|qfrozen_cnt
operator|==
literal|0
condition|)
block|{
comment|/* 		 * No longer need to wait for a successful 		 * command completion. 		 */
name|dev
operator|->
name|flags
operator|&=
operator|~
name|CAM_DEV_REL_ON_COMPLETE
expr_stmt|;
comment|/* 		 * Remove any timeouts that might be scheduled 		 * to release this queue. 		 */
if|if
condition|(
operator|(
name|dev
operator|->
name|flags
operator|&
name|CAM_DEV_REL_TIMEOUT_PENDING
operator|)
operator|!=
literal|0
condition|)
block|{
name|callout_stop
argument_list|(
operator|&
name|dev
operator|->
name|callout
argument_list|)
expr_stmt|;
name|dev
operator|->
name|flags
operator|&=
operator|~
name|CAM_DEV_REL_TIMEOUT_PENDING
expr_stmt|;
block|}
comment|/* 		 * Now that we are unfrozen schedule the 		 * device so any pending transactions are 		 * run. 		 */
name|xpt_schedule_devq
argument_list|(
name|dev
operator|->
name|sim
operator|->
name|devq
argument_list|,
name|dev
argument_list|)
expr_stmt|;
block|}
else|else
name|run_queue
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|run_queue
operator|)
return|;
block|}
end_function

begin_function
name|void
name|xpt_release_simq
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|int
name|run_queue
parameter_list|)
block|{
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
name|devq
operator|=
name|sim
operator|->
name|devq
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|devq
operator|->
name|send_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|devq
operator|->
name|send_queue
operator|.
name|qfrozen_cnt
operator|<=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|printf
argument_list|(
literal|"xpt_release_simq: requested 1> present %u\n"
argument_list|,
name|devq
operator|->
name|send_queue
operator|.
name|qfrozen_cnt
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|devq
operator|->
name|send_queue
operator|.
name|qfrozen_cnt
operator|--
expr_stmt|;
if|if
condition|(
name|devq
operator|->
name|send_queue
operator|.
name|qfrozen_cnt
operator|==
literal|0
condition|)
block|{
comment|/* 		 * If there is a timeout scheduled to release this 		 * sim queue, remove it.  The queue frozen count is 		 * already at 0. 		 */
if|if
condition|(
operator|(
name|sim
operator|->
name|flags
operator|&
name|CAM_SIM_REL_TIMEOUT_PENDING
operator|)
operator|!=
literal|0
condition|)
block|{
name|callout_stop
argument_list|(
operator|&
name|sim
operator|->
name|callout
argument_list|)
expr_stmt|;
name|sim
operator|->
name|flags
operator|&=
operator|~
name|CAM_SIM_REL_TIMEOUT_PENDING
expr_stmt|;
block|}
if|if
condition|(
name|run_queue
condition|)
block|{
comment|/* 			 * Now that we are unfrozen run the send queue. 			 */
name|xpt_run_devq
argument_list|(
name|sim
operator|->
name|devq
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|devq
operator|->
name|send_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * XXX Appears to be unused.  */
end_comment

begin_function
specifier|static
name|void
name|xpt_release_simq_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|sim
operator|=
operator|(
expr|struct
name|cam_sim
operator|*
operator|)
name|arg
expr_stmt|;
name|xpt_release_simq
argument_list|(
name|sim
argument_list|,
comment|/* run_queue */
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xpt_done
parameter_list|(
name|union
name|ccb
modifier|*
name|done_ccb
parameter_list|)
block|{
name|struct
name|cam_doneq
modifier|*
name|queue
decl_stmt|;
name|int
name|run
decl_stmt|,
name|hash
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"xpt_done: func= %#x %s status %#x\n"
operator|,
name|done_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|,
name|xpt_action_name
argument_list|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|func_code
argument_list|)
operator|,
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|&
name|XPT_FC_QUEUED
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* Store the time the ccb was in the sim */
name|done_ccb
operator|->
name|ccb_h
operator|.
name|qos
operator|.
name|sim_data
operator|=
name|sbinuptime
argument_list|()
operator|-
name|done_ccb
operator|->
name|ccb_h
operator|.
name|qos
operator|.
name|sim_data
expr_stmt|;
name|hash
operator|=
operator|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|path_id
operator|+
name|done_ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|+
name|done_ccb
operator|->
name|ccb_h
operator|.
name|target_lun
operator|)
operator|%
name|cam_num_doneqs
expr_stmt|;
name|queue
operator|=
operator|&
name|cam_doneqs
index|[
name|hash
index|]
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|queue
operator|->
name|cam_doneq_mtx
argument_list|)
expr_stmt|;
name|run
operator|=
operator|(
name|queue
operator|->
name|cam_doneq_sleep
operator|&&
name|STAILQ_EMPTY
argument_list|(
operator|&
name|queue
operator|->
name|cam_doneq
argument_list|)
operator|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|queue
operator|->
name|cam_doneq
argument_list|,
operator|&
name|done_ccb
operator|->
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|stqe
argument_list|)
expr_stmt|;
name|done_ccb
operator|->
name|ccb_h
operator|.
name|pinfo
operator|.
name|index
operator|=
name|CAM_DONEQ_INDEX
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|queue
operator|->
name|cam_doneq_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|run
condition|)
name|wakeup
argument_list|(
operator|&
name|queue
operator|->
name|cam_doneq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xpt_done_direct
parameter_list|(
name|union
name|ccb
modifier|*
name|done_ccb
parameter_list|)
block|{
name|CAM_DEBUG
argument_list|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"xpt_done_direct: status %#x\n"
operator|,
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|&
name|XPT_FC_QUEUED
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* Store the time the ccb was in the sim */
name|done_ccb
operator|->
name|ccb_h
operator|.
name|qos
operator|.
name|sim_data
operator|=
name|sbinuptime
argument_list|()
operator|-
name|done_ccb
operator|->
name|ccb_h
operator|.
name|qos
operator|.
name|sim_data
expr_stmt|;
name|xpt_done_process
argument_list|(
operator|&
name|done_ccb
operator|->
name|ccb_h
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|union
name|ccb
modifier|*
name|xpt_alloc_ccb
parameter_list|()
block|{
name|union
name|ccb
modifier|*
name|new_ccb
decl_stmt|;
name|new_ccb
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new_ccb
argument_list|)
argument_list|,
name|M_CAMCCB
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
return|return
operator|(
name|new_ccb
operator|)
return|;
block|}
end_function

begin_function
name|union
name|ccb
modifier|*
name|xpt_alloc_ccb_nowait
parameter_list|()
block|{
name|union
name|ccb
modifier|*
name|new_ccb
decl_stmt|;
name|new_ccb
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new_ccb
argument_list|)
argument_list|,
name|M_CAMCCB
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
return|return
operator|(
name|new_ccb
operator|)
return|;
block|}
end_function

begin_function
name|void
name|xpt_free_ccb
parameter_list|(
name|union
name|ccb
modifier|*
name|free_ccb
parameter_list|)
block|{
name|free
argument_list|(
name|free_ccb
argument_list|,
name|M_CAMCCB
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Private XPT functions */
end_comment

begin_comment
comment|/*  * Get a CAM control block for the caller. Charge the structure to the device  * referenced by the path.  If we don't have sufficient resources to allocate  * more ccbs, we return NULL.  */
end_comment

begin_function
specifier|static
name|union
name|ccb
modifier|*
name|xpt_get_ccb_nowait
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|new_ccb
decl_stmt|;
name|new_ccb
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new_ccb
argument_list|)
argument_list|,
name|M_CAMCCB
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_ccb
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|periph
operator|->
name|periph_allocated
operator|++
expr_stmt|;
name|cam_ccbq_take_opening
argument_list|(
operator|&
name|periph
operator|->
name|path
operator|->
name|device
operator|->
name|ccbq
argument_list|)
expr_stmt|;
return|return
operator|(
name|new_ccb
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|union
name|ccb
modifier|*
name|xpt_get_ccb
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|new_ccb
decl_stmt|;
name|cam_periph_unlock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|new_ccb
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new_ccb
argument_list|)
argument_list|,
name|M_CAMCCB
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|cam_periph_lock
argument_list|(
name|periph
argument_list|)
expr_stmt|;
name|periph
operator|->
name|periph_allocated
operator|++
expr_stmt|;
name|cam_ccbq_take_opening
argument_list|(
operator|&
name|periph
operator|->
name|path
operator|->
name|device
operator|->
name|ccbq
argument_list|)
expr_stmt|;
return|return
operator|(
name|new_ccb
operator|)
return|;
block|}
end_function

begin_function
name|union
name|ccb
modifier|*
name|cam_periph_getccb
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|u_int32_t
name|priority
parameter_list|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|periph
operator|->
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"cam_periph_getccb\n"
operator|)
argument_list|)
expr_stmt|;
name|cam_periph_assert
argument_list|(
name|periph
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ccb_h
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|periph
operator|->
name|ccb_list
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|ccb_h
operator|->
name|pinfo
operator|.
name|priority
operator|!=
name|priority
condition|)
block|{
if|if
condition|(
name|priority
operator|<
name|periph
operator|->
name|immediate_priority
condition|)
block|{
name|periph
operator|->
name|immediate_priority
operator|=
name|priority
expr_stmt|;
name|xpt_run_allocq
argument_list|(
name|periph
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|cam_periph_sleep
argument_list|(
name|periph
argument_list|,
operator|&
name|periph
operator|->
name|ccb_list
argument_list|,
name|PRIBIO
argument_list|,
literal|"cgticb"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|periph
operator|->
name|ccb_list
argument_list|,
name|periph_links
operator|.
name|sle
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|ccb_h
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xpt_acquire_bus
parameter_list|(
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|)
block|{
name|xpt_lock_buses
argument_list|()
expr_stmt|;
name|bus
operator|->
name|refcount
operator|++
expr_stmt|;
name|xpt_unlock_buses
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xpt_release_bus
parameter_list|(
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|)
block|{
name|xpt_lock_buses
argument_list|()
expr_stmt|;
name|KASSERT
argument_list|(
name|bus
operator|->
name|refcount
operator|>=
literal|1
argument_list|,
operator|(
literal|"bus->refcount>= 1"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|bus
operator|->
name|refcount
operator|>
literal|0
condition|)
block|{
name|xpt_unlock_buses
argument_list|()
expr_stmt|;
return|return;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_busses
argument_list|,
name|bus
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|xsoftc
operator|.
name|bus_generation
operator|++
expr_stmt|;
name|xpt_unlock_buses
argument_list|()
expr_stmt|;
name|KASSERT
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|bus
operator|->
name|et_entries
argument_list|)
argument_list|,
operator|(
literal|"destroying bus, but target list is not empty"
operator|)
argument_list|)
expr_stmt|;
name|cam_sim_release
argument_list|(
name|bus
operator|->
name|sim
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|bus
operator|->
name|eb_mtx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bus
argument_list|,
name|M_CAMXPT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|cam_et
modifier|*
name|xpt_alloc_target
parameter_list|(
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|,
name|target_id_t
name|target_id
parameter_list|)
block|{
name|struct
name|cam_et
modifier|*
name|cur_target
decl_stmt|,
modifier|*
name|target
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_topo_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|bus
operator|->
name|eb_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|target
operator|=
operator|(
expr|struct
name|cam_et
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|target
argument_list|)
argument_list|,
name|M_CAMXPT
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|TAILQ_INIT
argument_list|(
operator|&
name|target
operator|->
name|ed_entries
argument_list|)
expr_stmt|;
name|target
operator|->
name|bus
operator|=
name|bus
expr_stmt|;
name|target
operator|->
name|target_id
operator|=
name|target_id
expr_stmt|;
name|target
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
name|target
operator|->
name|generation
operator|=
literal|0
expr_stmt|;
name|target
operator|->
name|luns
operator|=
name|NULL
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|target
operator|->
name|luns_mtx
argument_list|,
literal|"CAM LUNs lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|timevalclear
argument_list|(
operator|&
name|target
operator|->
name|last_reset
argument_list|)
expr_stmt|;
comment|/* 	 * Hold a reference to our parent bus so it 	 * will not go away before we do. 	 */
name|bus
operator|->
name|refcount
operator|++
expr_stmt|;
comment|/* Insertion sort into our bus's target list */
name|cur_target
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|bus
operator|->
name|et_entries
argument_list|)
expr_stmt|;
while|while
condition|(
name|cur_target
operator|!=
name|NULL
operator|&&
name|cur_target
operator|->
name|target_id
operator|<
name|target_id
condition|)
name|cur_target
operator|=
name|TAILQ_NEXT
argument_list|(
name|cur_target
argument_list|,
name|links
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_target
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_INSERT_BEFORE
argument_list|(
name|cur_target
argument_list|,
name|target
argument_list|,
name|links
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|bus
operator|->
name|et_entries
argument_list|,
name|target
argument_list|,
name|links
argument_list|)
expr_stmt|;
block|}
name|bus
operator|->
name|generation
operator|++
expr_stmt|;
return|return
operator|(
name|target
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xpt_acquire_target
parameter_list|(
name|struct
name|cam_et
modifier|*
name|target
parameter_list|)
block|{
name|struct
name|cam_eb
modifier|*
name|bus
init|=
name|target
operator|->
name|bus
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|bus
operator|->
name|eb_mtx
argument_list|)
expr_stmt|;
name|target
operator|->
name|refcount
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|bus
operator|->
name|eb_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xpt_release_target
parameter_list|(
name|struct
name|cam_et
modifier|*
name|target
parameter_list|)
block|{
name|struct
name|cam_eb
modifier|*
name|bus
init|=
name|target
operator|->
name|bus
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|bus
operator|->
name|eb_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|target
operator|->
name|refcount
operator|>
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|bus
operator|->
name|eb_mtx
argument_list|)
expr_stmt|;
return|return;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|bus
operator|->
name|et_entries
argument_list|,
name|target
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|bus
operator|->
name|generation
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|bus
operator|->
name|eb_mtx
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|target
operator|->
name|ed_entries
argument_list|)
argument_list|,
operator|(
literal|"destroying target, but device list is not empty"
operator|)
argument_list|)
expr_stmt|;
name|xpt_release_bus
argument_list|(
name|bus
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|target
operator|->
name|luns_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|luns
condition|)
name|free
argument_list|(
name|target
operator|->
name|luns
argument_list|,
name|M_CAMXPT
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|target
argument_list|,
name|M_CAMXPT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|cam_ed
modifier|*
name|xpt_alloc_device_default
parameter_list|(
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|,
name|struct
name|cam_et
modifier|*
name|target
parameter_list|,
name|lun_id_t
name|lun_id
parameter_list|)
block|{
name|struct
name|cam_ed
modifier|*
name|device
decl_stmt|;
name|device
operator|=
name|xpt_alloc_device
argument_list|(
name|bus
argument_list|,
name|target
argument_list|,
name|lun_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|device
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|device
operator|->
name|mintags
operator|=
literal|1
expr_stmt|;
name|device
operator|->
name|maxtags
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|device
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xpt_destroy_device
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|cam_ed
modifier|*
name|device
init|=
name|context
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|device
operator|->
name|device_mtx
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|device
operator|->
name|device_mtx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|device
argument_list|,
name|M_CAMDEV
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|cam_ed
modifier|*
name|xpt_alloc_device
parameter_list|(
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|,
name|struct
name|cam_et
modifier|*
name|target
parameter_list|,
name|lun_id_t
name|lun_id
parameter_list|)
block|{
name|struct
name|cam_ed
modifier|*
name|cur_device
decl_stmt|,
modifier|*
name|device
decl_stmt|;
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|bus
operator|->
name|eb_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* Make space for us in the device queue on our bus */
name|devq
operator|=
name|bus
operator|->
name|sim
operator|->
name|devq
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|devq
operator|->
name|send_mtx
argument_list|)
expr_stmt|;
name|status
operator|=
name|cam_devq_resize
argument_list|(
name|devq
argument_list|,
name|devq
operator|->
name|send_queue
operator|.
name|array_size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|devq
operator|->
name|send_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|device
operator|=
operator|(
expr|struct
name|cam_ed
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|device
argument_list|)
argument_list|,
name|M_CAMDEV
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|device
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|cam_init_pinfo
argument_list|(
operator|&
name|device
operator|->
name|devq_entry
argument_list|)
expr_stmt|;
name|device
operator|->
name|target
operator|=
name|target
expr_stmt|;
name|device
operator|->
name|lun_id
operator|=
name|lun_id
expr_stmt|;
name|device
operator|->
name|sim
operator|=
name|bus
operator|->
name|sim
expr_stmt|;
if|if
condition|(
name|cam_ccbq_init
argument_list|(
operator|&
name|device
operator|->
name|ccbq
argument_list|,
name|bus
operator|->
name|sim
operator|->
name|max_dev_openings
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|device
argument_list|,
name|M_CAMDEV
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|SLIST_INIT
argument_list|(
operator|&
name|device
operator|->
name|asyncs
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|device
operator|->
name|periphs
argument_list|)
expr_stmt|;
name|device
operator|->
name|generation
operator|=
literal|0
expr_stmt|;
name|device
operator|->
name|flags
operator|=
name|CAM_DEV_UNCONFIGURED
expr_stmt|;
name|device
operator|->
name|tag_delay_count
operator|=
literal|0
expr_stmt|;
name|device
operator|->
name|tag_saved_openings
operator|=
literal|0
expr_stmt|;
name|device
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|device
operator|->
name|device_mtx
argument_list|,
literal|"CAM device lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|device
operator|->
name|callout
argument_list|,
operator|&
name|devq
operator|->
name|send_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|device
operator|->
name|device_destroy_task
argument_list|,
literal|0
argument_list|,
name|xpt_destroy_device
argument_list|,
name|device
argument_list|)
expr_stmt|;
comment|/* 	 * Hold a reference to our parent bus so it 	 * will not go away before we do. 	 */
name|target
operator|->
name|refcount
operator|++
expr_stmt|;
name|cur_device
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|target
operator|->
name|ed_entries
argument_list|)
expr_stmt|;
while|while
condition|(
name|cur_device
operator|!=
name|NULL
operator|&&
name|cur_device
operator|->
name|lun_id
operator|<
name|lun_id
condition|)
name|cur_device
operator|=
name|TAILQ_NEXT
argument_list|(
name|cur_device
argument_list|,
name|links
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_device
operator|!=
name|NULL
condition|)
name|TAILQ_INSERT_BEFORE
argument_list|(
name|cur_device
argument_list|,
name|device
argument_list|,
name|links
argument_list|)
expr_stmt|;
else|else
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|target
operator|->
name|ed_entries
argument_list|,
name|device
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|target
operator|->
name|generation
operator|++
expr_stmt|;
return|return
operator|(
name|device
operator|)
return|;
block|}
end_function

begin_function
name|void
name|xpt_acquire_device
parameter_list|(
name|struct
name|cam_ed
modifier|*
name|device
parameter_list|)
block|{
name|struct
name|cam_eb
modifier|*
name|bus
init|=
name|device
operator|->
name|target
operator|->
name|bus
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|bus
operator|->
name|eb_mtx
argument_list|)
expr_stmt|;
name|device
operator|->
name|refcount
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|bus
operator|->
name|eb_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xpt_release_device
parameter_list|(
name|struct
name|cam_ed
modifier|*
name|device
parameter_list|)
block|{
name|struct
name|cam_eb
modifier|*
name|bus
init|=
name|device
operator|->
name|target
operator|->
name|bus
decl_stmt|;
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|bus
operator|->
name|eb_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|device
operator|->
name|refcount
operator|>
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|bus
operator|->
name|eb_mtx
argument_list|)
expr_stmt|;
return|return;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|device
operator|->
name|target
operator|->
name|ed_entries
argument_list|,
name|device
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|device
operator|->
name|target
operator|->
name|generation
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|bus
operator|->
name|eb_mtx
argument_list|)
expr_stmt|;
comment|/* Release our slot in the devq */
name|devq
operator|=
name|bus
operator|->
name|sim
operator|->
name|devq
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|devq
operator|->
name|send_mtx
argument_list|)
expr_stmt|;
name|cam_devq_resize
argument_list|(
name|devq
argument_list|,
name|devq
operator|->
name|send_queue
operator|.
name|array_size
operator|-
literal|1
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|devq
operator|->
name|send_mtx
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|SLIST_EMPTY
argument_list|(
operator|&
name|device
operator|->
name|periphs
argument_list|)
argument_list|,
operator|(
literal|"destroying device, but periphs list is not empty"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|device
operator|->
name|devq_entry
operator|.
name|index
operator|==
name|CAM_UNQUEUED_INDEX
argument_list|,
operator|(
literal|"destroying device while still queued for ccbs"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|device
operator|->
name|flags
operator|&
name|CAM_DEV_REL_TIMEOUT_PENDING
operator|)
operator|!=
literal|0
condition|)
name|callout_stop
argument_list|(
operator|&
name|device
operator|->
name|callout
argument_list|)
expr_stmt|;
name|xpt_release_target
argument_list|(
name|device
operator|->
name|target
argument_list|)
expr_stmt|;
name|cam_ccbq_fini
argument_list|(
operator|&
name|device
operator|->
name|ccbq
argument_list|)
expr_stmt|;
comment|/* 	 * Free allocated memory.  free(9) does nothing if the 	 * supplied pointer is NULL, so it is safe to call without 	 * checking. 	 */
name|free
argument_list|(
name|device
operator|->
name|supported_vpds
argument_list|,
name|M_CAMXPT
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|device
operator|->
name|device_id
argument_list|,
name|M_CAMXPT
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|device
operator|->
name|ext_inq
argument_list|,
name|M_CAMXPT
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|device
operator|->
name|physpath
argument_list|,
name|M_CAMXPT
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|device
operator|->
name|rcap_buf
argument_list|,
name|M_CAMXPT
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|device
operator|->
name|serial_num
argument_list|,
name|M_CAMXPT
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|xsoftc
operator|.
name|xpt_taskq
argument_list|,
operator|&
name|device
operator|->
name|device_destroy_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|u_int32_t
name|xpt_dev_ccbq_resize
parameter_list|(
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|int
name|newopenings
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
name|struct
name|cam_ed
modifier|*
name|dev
decl_stmt|;
name|dev
operator|=
name|path
operator|->
name|device
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dev
operator|->
name|sim
operator|->
name|devq
operator|->
name|send_mtx
argument_list|)
expr_stmt|;
name|result
operator|=
name|cam_ccbq_resize
argument_list|(
operator|&
name|dev
operator|->
name|ccbq
argument_list|,
name|newopenings
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev
operator|->
name|sim
operator|->
name|devq
operator|->
name|send_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dev
operator|->
name|flags
operator|&
name|CAM_DEV_TAG_AFTER_COUNT
operator|)
operator|!=
literal|0
operator|||
operator|(
name|dev
operator|->
name|inq_flags
operator|&
name|SID_CmdQue
operator|)
operator|!=
literal|0
condition|)
name|dev
operator|->
name|tag_saved_openings
operator|=
name|newopenings
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|cam_eb
modifier|*
name|xpt_find_bus
parameter_list|(
name|path_id_t
name|path_id
parameter_list|)
block|{
name|struct
name|cam_eb
modifier|*
name|bus
decl_stmt|;
name|xpt_lock_buses
argument_list|()
expr_stmt|;
for|for
control|(
name|bus
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_busses
argument_list|)
init|;
name|bus
operator|!=
name|NULL
condition|;
name|bus
operator|=
name|TAILQ_NEXT
argument_list|(
name|bus
argument_list|,
name|links
argument_list|)
control|)
block|{
if|if
condition|(
name|bus
operator|->
name|path_id
operator|==
name|path_id
condition|)
block|{
name|bus
operator|->
name|refcount
operator|++
expr_stmt|;
break|break;
block|}
block|}
name|xpt_unlock_buses
argument_list|()
expr_stmt|;
return|return
operator|(
name|bus
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|cam_et
modifier|*
name|xpt_find_target
parameter_list|(
name|struct
name|cam_eb
modifier|*
name|bus
parameter_list|,
name|target_id_t
name|target_id
parameter_list|)
block|{
name|struct
name|cam_et
modifier|*
name|target
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|bus
operator|->
name|eb_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
for|for
control|(
name|target
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|bus
operator|->
name|et_entries
argument_list|)
init|;
name|target
operator|!=
name|NULL
condition|;
name|target
operator|=
name|TAILQ_NEXT
argument_list|(
name|target
argument_list|,
name|links
argument_list|)
control|)
block|{
if|if
condition|(
name|target
operator|->
name|target_id
operator|==
name|target_id
condition|)
block|{
name|target
operator|->
name|refcount
operator|++
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|target
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|cam_ed
modifier|*
name|xpt_find_device
parameter_list|(
name|struct
name|cam_et
modifier|*
name|target
parameter_list|,
name|lun_id_t
name|lun_id
parameter_list|)
block|{
name|struct
name|cam_ed
modifier|*
name|device
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|target
operator|->
name|bus
operator|->
name|eb_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
for|for
control|(
name|device
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|target
operator|->
name|ed_entries
argument_list|)
init|;
name|device
operator|!=
name|NULL
condition|;
name|device
operator|=
name|TAILQ_NEXT
argument_list|(
name|device
argument_list|,
name|links
argument_list|)
control|)
block|{
if|if
condition|(
name|device
operator|->
name|lun_id
operator|==
name|lun_id
condition|)
block|{
name|device
operator|->
name|refcount
operator|++
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|device
operator|)
return|;
block|}
end_function

begin_function
name|void
name|xpt_start_tags
parameter_list|(
name|struct
name|cam_path
modifier|*
name|path
parameter_list|)
block|{
name|struct
name|ccb_relsim
name|crs
decl_stmt|;
name|struct
name|cam_ed
modifier|*
name|device
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|int
name|newopenings
decl_stmt|;
name|device
operator|=
name|path
operator|->
name|device
expr_stmt|;
name|sim
operator|=
name|path
operator|->
name|bus
operator|->
name|sim
expr_stmt|;
name|device
operator|->
name|flags
operator|&=
operator|~
name|CAM_DEV_TAG_AFTER_COUNT
expr_stmt|;
name|xpt_freeze_devq
argument_list|(
name|path
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
name|device
operator|->
name|inq_flags
operator||=
name|SID_CmdQue
expr_stmt|;
if|if
condition|(
name|device
operator|->
name|tag_saved_openings
operator|!=
literal|0
condition|)
name|newopenings
operator|=
name|device
operator|->
name|tag_saved_openings
expr_stmt|;
else|else
name|newopenings
operator|=
name|min
argument_list|(
name|device
operator|->
name|maxtags
argument_list|,
name|sim
operator|->
name|max_tagged_dev_openings
argument_list|)
expr_stmt|;
name|xpt_dev_ccbq_resize
argument_list|(
name|path
argument_list|,
name|newopenings
argument_list|)
expr_stmt|;
name|xpt_async
argument_list|(
name|AC_GETDEV_CHANGED
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|crs
operator|.
name|ccb_h
argument_list|,
name|path
argument_list|,
name|CAM_PRIORITY_NORMAL
argument_list|)
expr_stmt|;
name|crs
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_REL_SIMQ
expr_stmt|;
name|crs
operator|.
name|release_flags
operator|=
name|RELSIM_RELEASE_AFTER_QEMPTY
expr_stmt|;
name|crs
operator|.
name|openings
operator|=
name|crs
operator|.
name|release_timeout
operator|=
name|crs
operator|.
name|qfrozen_cnt
operator|=
literal|0
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|crs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xpt_stop_tags
parameter_list|(
name|struct
name|cam_path
modifier|*
name|path
parameter_list|)
block|{
name|struct
name|ccb_relsim
name|crs
decl_stmt|;
name|struct
name|cam_ed
modifier|*
name|device
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|device
operator|=
name|path
operator|->
name|device
expr_stmt|;
name|sim
operator|=
name|path
operator|->
name|bus
operator|->
name|sim
expr_stmt|;
name|device
operator|->
name|flags
operator|&=
operator|~
name|CAM_DEV_TAG_AFTER_COUNT
expr_stmt|;
name|device
operator|->
name|tag_delay_count
operator|=
literal|0
expr_stmt|;
name|xpt_freeze_devq
argument_list|(
name|path
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
name|device
operator|->
name|inq_flags
operator|&=
operator|~
name|SID_CmdQue
expr_stmt|;
name|xpt_dev_ccbq_resize
argument_list|(
name|path
argument_list|,
name|sim
operator|->
name|max_dev_openings
argument_list|)
expr_stmt|;
name|xpt_async
argument_list|(
name|AC_GETDEV_CHANGED
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|crs
operator|.
name|ccb_h
argument_list|,
name|path
argument_list|,
name|CAM_PRIORITY_NORMAL
argument_list|)
expr_stmt|;
name|crs
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_REL_SIMQ
expr_stmt|;
name|crs
operator|.
name|release_flags
operator|=
name|RELSIM_RELEASE_AFTER_QEMPTY
expr_stmt|;
name|crs
operator|.
name|openings
operator|=
name|crs
operator|.
name|release_timeout
operator|=
name|crs
operator|.
name|qfrozen_cnt
operator|=
literal|0
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|crs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xpt_boot_delay
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|xpt_release_boot
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xpt_config
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
comment|/* 	 * Now that interrupts are enabled, go find our devices 	 */
if|if
condition|(
name|taskqueue_start_threads
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_taskq
argument_list|,
literal|1
argument_list|,
name|PRIBIO
argument_list|,
literal|"CAM taskq"
argument_list|)
condition|)
name|printf
argument_list|(
literal|"xpt_config: failed to create taskqueue thread.\n"
argument_list|)
expr_stmt|;
comment|/* Setup debugging path */
if|if
condition|(
name|cam_dflags
operator|!=
name|CAM_DEBUG_NONE
condition|)
block|{
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|cam_dpath
argument_list|,
name|NULL
argument_list|,
name|CAM_DEBUG_BUS
argument_list|,
name|CAM_DEBUG_TARGET
argument_list|,
name|CAM_DEBUG_LUN
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"xpt_config: xpt_create_path() failed for debug"
literal|" target %d:%d:%d, debugging disabled\n"
argument_list|,
name|CAM_DEBUG_BUS
argument_list|,
name|CAM_DEBUG_TARGET
argument_list|,
name|CAM_DEBUG_LUN
argument_list|)
expr_stmt|;
name|cam_dflags
operator|=
name|CAM_DEBUG_NONE
expr_stmt|;
block|}
block|}
else|else
name|cam_dpath
operator|=
name|NULL
expr_stmt|;
name|periphdriver_init
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|xpt_hold_boot
argument_list|()
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|xsoftc
operator|.
name|boot_callout
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|callout_reset_sbt
argument_list|(
operator|&
name|xsoftc
operator|.
name|boot_callout
argument_list|,
name|SBT_1MS
operator|*
name|xsoftc
operator|.
name|boot_delay
argument_list|,
literal|0
argument_list|,
name|xpt_boot_delay
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Fire up rescan thread. */
if|if
condition|(
name|kproc_kthread_add
argument_list|(
name|xpt_scanner_thread
argument_list|,
name|NULL
argument_list|,
operator|&
name|cam_proc
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cam"
argument_list|,
literal|"scanner"
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"xpt_config: failed to create rescan thread.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|xpt_hold_boot
parameter_list|(
name|void
parameter_list|)
block|{
name|xpt_lock_buses
argument_list|()
expr_stmt|;
name|xsoftc
operator|.
name|buses_to_config
operator|++
expr_stmt|;
name|xpt_unlock_buses
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xpt_release_boot
parameter_list|(
name|void
parameter_list|)
block|{
name|xpt_lock_buses
argument_list|()
expr_stmt|;
name|xsoftc
operator|.
name|buses_to_config
operator|--
expr_stmt|;
if|if
condition|(
name|xsoftc
operator|.
name|buses_to_config
operator|==
literal|0
operator|&&
name|xsoftc
operator|.
name|buses_config_done
operator|==
literal|0
condition|)
block|{
name|struct
name|xpt_task
modifier|*
name|task
decl_stmt|;
name|xsoftc
operator|.
name|buses_config_done
operator|=
literal|1
expr_stmt|;
name|xpt_unlock_buses
argument_list|()
expr_stmt|;
comment|/* Call manually because we don't have any busses */
name|task
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|xpt_task
argument_list|)
argument_list|,
name|M_CAMXPT
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|task
operator|!=
name|NULL
condition|)
block|{
name|TASK_INIT
argument_list|(
operator|&
name|task
operator|->
name|task
argument_list|,
literal|0
argument_list|,
name|xpt_finishconfig_task
argument_list|,
name|task
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|task
operator|->
name|task
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|xpt_unlock_buses
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * If the given device only has one peripheral attached to it, and if that  * peripheral is the passthrough driver, announce it.  This insures that the  * user sees some sort of announcement for every peripheral in their system.  */
end_comment

begin_function
specifier|static
name|int
name|xptpassannouncefunc
parameter_list|(
name|struct
name|cam_ed
modifier|*
name|device
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cam_periph
modifier|*
name|periph
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|periph
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|device
operator|->
name|periphs
argument_list|)
operator|,
name|i
operator|=
literal|0
init|;
name|periph
operator|!=
name|NULL
condition|;
name|periph
operator|=
name|SLIST_NEXT
argument_list|(
name|periph
argument_list|,
name|periph_links
argument_list|)
operator|,
name|i
operator|++
control|)
empty_stmt|;
name|periph
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|device
operator|->
name|periphs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|==
literal|1
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|periph
operator|->
name|periph_name
argument_list|,
literal|"pass"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|xpt_announce_periph
argument_list|(
name|periph
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xpt_finishconfig_task
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|periphdriver_init
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* 	 * Check for devices with no "standard" peripheral driver 	 * attached.  For any devices like that, announce the 	 * passthrough driver so the user will see something. 	 */
if|if
condition|(
operator|!
name|bootverbose
condition|)
name|xpt_for_all_devices
argument_list|(
name|xptpassannouncefunc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Release our hook so that the boot can continue. */
name|config_intrhook_disestablish
argument_list|(
name|xsoftc
operator|.
name|xpt_config_hook
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|xsoftc
operator|.
name|xpt_config_hook
argument_list|,
name|M_CAMXPT
argument_list|)
expr_stmt|;
name|xsoftc
operator|.
name|xpt_config_hook
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|context
argument_list|,
name|M_CAMXPT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|cam_status
name|xpt_register_async
parameter_list|(
name|int
name|event
parameter_list|,
name|ac_callback_t
modifier|*
name|cbfunc
parameter_list|,
name|void
modifier|*
name|cbarg
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|)
block|{
name|struct
name|ccb_setasync
name|csa
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|int
name|xptpath
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
block|{
name|status
operator|=
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|CAM_XPT_PATH_ID
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
return|return
operator|(
name|status
operator|)
return|;
name|xpt_path_lock
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|xptpath
operator|=
literal|1
expr_stmt|;
block|}
name|xpt_setup_ccb
argument_list|(
operator|&
name|csa
operator|.
name|ccb_h
argument_list|,
name|path
argument_list|,
name|CAM_PRIORITY_NORMAL
argument_list|)
expr_stmt|;
name|csa
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SASYNC_CB
expr_stmt|;
name|csa
operator|.
name|event_enable
operator|=
name|event
expr_stmt|;
name|csa
operator|.
name|callback
operator|=
name|cbfunc
expr_stmt|;
name|csa
operator|.
name|callback_arg
operator|=
name|cbarg
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|csa
argument_list|)
expr_stmt|;
name|status
operator|=
name|csa
operator|.
name|ccb_h
operator|.
name|status
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|csa
operator|.
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"xpt_register_async: func %p\n"
operator|,
name|cbfunc
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xptpath
condition|)
block|{
name|xpt_path_unlock
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|status
operator|==
name|CAM_REQ_CMP
operator|)
operator|&&
operator|(
name|csa
operator|.
name|event_enable
operator|&
name|AC_FOUND_DEVICE
operator|)
condition|)
block|{
comment|/* 		 * Get this peripheral up to date with all 		 * the currently existing devices. 		 */
name|xpt_for_all_devices
argument_list|(
name|xptsetasyncfunc
argument_list|,
operator|&
name|csa
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|status
operator|==
name|CAM_REQ_CMP
operator|)
operator|&&
operator|(
name|csa
operator|.
name|event_enable
operator|&
name|AC_PATH_REGISTERED
operator|)
condition|)
block|{
comment|/* 		 * Get this peripheral up to date with all 		 * the currently existing busses. 		 */
name|xpt_for_all_busses
argument_list|(
name|xptsetasyncbusfunc
argument_list|,
operator|&
name|csa
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xptaction
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|work_ccb
parameter_list|)
block|{
name|CAM_DEBUG
argument_list|(
name|work_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"xptaction\n"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|work_ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
comment|/* Common cases first */
case|case
name|XPT_PATH_INQ
case|:
comment|/* Path routing inquiry */
block|{
name|struct
name|ccb_pathinq
modifier|*
name|cpi
decl_stmt|;
name|cpi
operator|=
operator|&
name|work_ccb
operator|->
name|cpi
expr_stmt|;
name|cpi
operator|->
name|version_num
operator|=
literal|1
expr_stmt|;
comment|/* XXX??? */
name|cpi
operator|->
name|hba_inquiry
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|target_sprt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_misc
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_eng_cnt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|max_target
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|max_lun
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|initiator_id
operator|=
literal|0
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|sim_vid
argument_list|,
literal|"FreeBSD"
argument_list|,
name|SIM_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|hba_vid
argument_list|,
literal|""
argument_list|,
name|HBA_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|dev_name
argument_list|,
name|sim
operator|->
name|sim_name
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|unit_number
operator|=
name|sim
operator|->
name|unit_number
expr_stmt|;
name|cpi
operator|->
name|bus_id
operator|=
name|sim
operator|->
name|bus_id
expr_stmt|;
name|cpi
operator|->
name|base_transfer_speed
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|protocol
operator|=
name|PROTO_UNSPECIFIED
expr_stmt|;
name|cpi
operator|->
name|protocol_version
operator|=
name|PROTO_VERSION_UNSPECIFIED
expr_stmt|;
name|cpi
operator|->
name|transport
operator|=
name|XPORT_UNSPECIFIED
expr_stmt|;
name|cpi
operator|->
name|transport_version
operator|=
name|XPORT_VERSION_UNSPECIFIED
expr_stmt|;
name|cpi
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|work_ccb
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|work_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|work_ccb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * The xpt as a "controller" has no interrupt sources, so polling  * is a no-op.  */
end_comment

begin_function
specifier|static
name|void
name|xptpoll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|xpt_lock_buses
parameter_list|(
name|void
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_topo_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xpt_unlock_buses
parameter_list|(
name|void
parameter_list|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_topo_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|mtx
modifier|*
name|xpt_path_mtx
parameter_list|(
name|struct
name|cam_path
modifier|*
name|path
parameter_list|)
block|{
return|return
operator|(
operator|&
name|path
operator|->
name|device
operator|->
name|device_mtx
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xpt_done_process
parameter_list|(
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
parameter_list|)
block|{
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
name|struct
name|mtx
modifier|*
name|mtx
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_HIGH_POWER
condition|)
block|{
name|struct
name|highpowerlist
modifier|*
name|hphead
decl_stmt|;
name|struct
name|cam_ed
modifier|*
name|device
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_highpower_lock
argument_list|)
expr_stmt|;
name|hphead
operator|=
operator|&
name|xsoftc
operator|.
name|highpowerq
expr_stmt|;
name|device
operator|=
name|STAILQ_FIRST
argument_list|(
name|hphead
argument_list|)
expr_stmt|;
comment|/* 		 * Increment the count since this command is done. 		 */
name|xsoftc
operator|.
name|num_highpower
operator|++
expr_stmt|;
comment|/* 		 * Any high powered commands queued up? 		 */
if|if
condition|(
name|device
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
name|hphead
argument_list|,
name|highpowerq_entry
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_highpower_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|device
operator|->
name|sim
operator|->
name|devq
operator|->
name|send_mtx
argument_list|)
expr_stmt|;
name|xpt_release_devq_device
argument_list|(
name|device
argument_list|,
comment|/*count*/
literal|1
argument_list|,
comment|/*runqueue*/
name|TRUE
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|device
operator|->
name|sim
operator|->
name|devq
operator|->
name|send_mtx
argument_list|)
expr_stmt|;
block|}
else|else
name|mtx_unlock
argument_list|(
operator|&
name|xsoftc
operator|.
name|xpt_highpower_lock
argument_list|)
expr_stmt|;
block|}
name|sim
operator|=
name|ccb_h
operator|->
name|path
operator|->
name|bus
operator|->
name|sim
expr_stmt|;
if|if
condition|(
name|ccb_h
operator|->
name|status
operator|&
name|CAM_RELEASE_SIMQ
condition|)
block|{
name|xpt_release_simq
argument_list|(
name|sim
argument_list|,
comment|/*run_queue*/
name|FALSE
argument_list|)
expr_stmt|;
name|ccb_h
operator|->
name|status
operator|&=
operator|~
name|CAM_RELEASE_SIMQ
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_DEV_QFRZDIS
operator|)
operator|&&
operator|(
name|ccb_h
operator|->
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
condition|)
block|{
name|xpt_release_devq
argument_list|(
name|ccb_h
operator|->
name|path
argument_list|,
comment|/*count*/
literal|1
argument_list|,
comment|/*run_queue*/
name|TRUE
argument_list|)
expr_stmt|;
name|ccb_h
operator|->
name|status
operator|&=
operator|~
name|CAM_DEV_QFRZN
expr_stmt|;
block|}
name|devq
operator|=
name|sim
operator|->
name|devq
expr_stmt|;
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|func_code
operator|&
name|XPT_FC_USER_CCB
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|cam_ed
modifier|*
name|dev
init|=
name|ccb_h
operator|->
name|path
operator|->
name|device
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|devq
operator|->
name|send_mtx
argument_list|)
expr_stmt|;
name|devq
operator|->
name|send_active
operator|--
expr_stmt|;
name|devq
operator|->
name|send_openings
operator|++
expr_stmt|;
name|cam_ccbq_ccb_done
argument_list|(
operator|&
name|dev
operator|->
name|ccbq
argument_list|,
operator|(
expr|union
name|ccb
operator|*
operator|)
name|ccb_h
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|dev
operator|->
name|flags
operator|&
name|CAM_DEV_REL_ON_QUEUE_EMPTY
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|dev
operator|->
name|ccbq
operator|.
name|dev_active
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|dev
operator|->
name|flags
operator|&=
operator|~
name|CAM_DEV_REL_ON_QUEUE_EMPTY
expr_stmt|;
name|xpt_release_devq_device
argument_list|(
name|dev
argument_list|,
comment|/*count*/
literal|1
argument_list|,
comment|/*run_queue*/
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|dev
operator|->
name|flags
operator|&
name|CAM_DEV_REL_ON_COMPLETE
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ccb_h
operator|->
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQUEUE_REQ
operator|)
condition|)
block|{
name|dev
operator|->
name|flags
operator|&=
operator|~
name|CAM_DEV_REL_ON_COMPLETE
expr_stmt|;
name|xpt_release_devq_device
argument_list|(
name|dev
argument_list|,
comment|/*count*/
literal|1
argument_list|,
comment|/*run_queue*/
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|device_is_queued
argument_list|(
name|dev
argument_list|)
condition|)
operator|(
name|void
operator|)
name|xpt_schedule_devq
argument_list|(
name|devq
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|xpt_run_devq
argument_list|(
name|devq
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|devq
operator|->
name|send_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dev
operator|->
name|flags
operator|&
name|CAM_DEV_TAG_AFTER_COUNT
operator|)
operator|!=
literal|0
condition|)
block|{
name|mtx
operator|=
name|xpt_path_mtx
argument_list|(
name|ccb_h
operator|->
name|path
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dev
operator|->
name|flags
operator|&
name|CAM_DEV_TAG_AFTER_COUNT
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|--
name|dev
operator|->
name|tag_delay_count
operator|==
literal|0
operator|)
condition|)
name|xpt_start_tags
argument_list|(
name|ccb_h
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_UNLOCKED
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mtx
operator|==
name|NULL
condition|)
block|{
name|mtx
operator|=
name|xpt_path_mtx
argument_list|(
name|ccb_h
operator|->
name|path
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
name|mtx
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|mtx
operator|!=
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
name|mtx
argument_list|)
expr_stmt|;
name|mtx
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Call the peripheral driver's callback */
name|ccb_h
operator|->
name|pinfo
operator|.
name|index
operator|=
name|CAM_UNQUEUED_INDEX
expr_stmt|;
call|(
modifier|*
name|ccb_h
operator|->
name|cbfcnp
call|)
argument_list|(
name|ccb_h
operator|->
name|path
operator|->
name|periph
argument_list|,
operator|(
expr|union
name|ccb
operator|*
operator|)
name|ccb_h
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtx
operator|!=
name|NULL
condition|)
name|mtx_unlock
argument_list|(
name|mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xpt_done_td
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cam_doneq
modifier|*
name|queue
init|=
name|arg
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|ccb_hdr
argument_list|)
name|doneq
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|doneq
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|queue
operator|->
name|cam_doneq_mtx
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
while|while
condition|(
name|STAILQ_EMPTY
argument_list|(
operator|&
name|queue
operator|->
name|cam_doneq
argument_list|)
condition|)
block|{
name|queue
operator|->
name|cam_doneq_sleep
operator|=
literal|1
expr_stmt|;
name|msleep
argument_list|(
operator|&
name|queue
operator|->
name|cam_doneq
argument_list|,
operator|&
name|queue
operator|->
name|cam_doneq_mtx
argument_list|,
name|PRIBIO
argument_list|,
literal|"-"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|queue
operator|->
name|cam_doneq_sleep
operator|=
literal|0
expr_stmt|;
block|}
name|STAILQ_CONCAT
argument_list|(
operator|&
name|doneq
argument_list|,
operator|&
name|queue
operator|->
name|cam_doneq
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|queue
operator|->
name|cam_doneq_mtx
argument_list|)
expr_stmt|;
name|THREAD_NO_SLEEPING
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|ccb_h
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|doneq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|doneq
argument_list|,
name|sim_links
operator|.
name|stqe
argument_list|)
expr_stmt|;
name|xpt_done_process
argument_list|(
name|ccb_h
argument_list|)
expr_stmt|;
block|}
name|THREAD_SLEEPING_OK
argument_list|()
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|queue
operator|->
name|cam_doneq_mtx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|camisr_runqueue
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
name|struct
name|cam_doneq
modifier|*
name|queue
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Process global queues. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cam_num_doneqs
condition|;
name|i
operator|++
control|)
block|{
name|queue
operator|=
operator|&
name|cam_doneqs
index|[
name|i
index|]
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|queue
operator|->
name|cam_doneq_mtx
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ccb_h
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|queue
operator|->
name|cam_doneq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|queue
operator|->
name|cam_doneq
argument_list|,
name|sim_links
operator|.
name|stqe
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|queue
operator|->
name|cam_doneq_mtx
argument_list|)
expr_stmt|;
name|xpt_done_process
argument_list|(
name|ccb_h
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|queue
operator|->
name|cam_doneq_mtx
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|queue
operator|->
name|cam_doneq_mtx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_struct
struct|struct
name|kv
block|{
name|uint32_t
name|v
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|kv
name|map
index|[]
init|=
block|{
block|{
name|XPT_NOOP
block|,
literal|"XPT_NOOP"
block|}
block|,
block|{
name|XPT_SCSI_IO
block|,
literal|"XPT_SCSI_IO"
block|}
block|,
block|{
name|XPT_GDEV_TYPE
block|,
literal|"XPT_GDEV_TYPE"
block|}
block|,
block|{
name|XPT_GDEVLIST
block|,
literal|"XPT_GDEVLIST"
block|}
block|,
block|{
name|XPT_PATH_INQ
block|,
literal|"XPT_PATH_INQ"
block|}
block|,
block|{
name|XPT_REL_SIMQ
block|,
literal|"XPT_REL_SIMQ"
block|}
block|,
block|{
name|XPT_SASYNC_CB
block|,
literal|"XPT_SASYNC_CB"
block|}
block|,
block|{
name|XPT_SDEV_TYPE
block|,
literal|"XPT_SDEV_TYPE"
block|}
block|,
block|{
name|XPT_SCAN_BUS
block|,
literal|"XPT_SCAN_BUS"
block|}
block|,
block|{
name|XPT_DEV_MATCH
block|,
literal|"XPT_DEV_MATCH"
block|}
block|,
block|{
name|XPT_DEBUG
block|,
literal|"XPT_DEBUG"
block|}
block|,
block|{
name|XPT_PATH_STATS
block|,
literal|"XPT_PATH_STATS"
block|}
block|,
block|{
name|XPT_GDEV_STATS
block|,
literal|"XPT_GDEV_STATS"
block|}
block|,
block|{
name|XPT_DEV_ADVINFO
block|,
literal|"XPT_DEV_ADVINFO"
block|}
block|,
block|{
name|XPT_ASYNC
block|,
literal|"XPT_ASYNC"
block|}
block|,
block|{
name|XPT_ABORT
block|,
literal|"XPT_ABORT"
block|}
block|,
block|{
name|XPT_RESET_BUS
block|,
literal|"XPT_RESET_BUS"
block|}
block|,
block|{
name|XPT_RESET_DEV
block|,
literal|"XPT_RESET_DEV"
block|}
block|,
block|{
name|XPT_TERM_IO
block|,
literal|"XPT_TERM_IO"
block|}
block|,
block|{
name|XPT_SCAN_LUN
block|,
literal|"XPT_SCAN_LUN"
block|}
block|,
block|{
name|XPT_GET_TRAN_SETTINGS
block|,
literal|"XPT_GET_TRAN_SETTINGS"
block|}
block|,
block|{
name|XPT_SET_TRAN_SETTINGS
block|,
literal|"XPT_SET_TRAN_SETTINGS"
block|}
block|,
block|{
name|XPT_CALC_GEOMETRY
block|,
literal|"XPT_CALC_GEOMETRY"
block|}
block|,
block|{
name|XPT_ATA_IO
block|,
literal|"XPT_ATA_IO"
block|}
block|,
block|{
name|XPT_GET_SIM_KNOB
block|,
literal|"XPT_GET_SIM_KNOB"
block|}
block|,
block|{
name|XPT_SET_SIM_KNOB
block|,
literal|"XPT_SET_SIM_KNOB"
block|}
block|,
block|{
name|XPT_NVME_IO
block|,
literal|"XPT_NVME_IO"
block|}
block|,
block|{
name|XPT_MMCSD_IO
block|,
literal|"XPT_MMCSD_IO"
block|}
block|,
block|{
name|XPT_SMP_IO
block|,
literal|"XPT_SMP_IO"
block|}
block|,
block|{
name|XPT_SCAN_TGT
block|,
literal|"XPT_SCAN_TGT"
block|}
block|,
block|{
name|XPT_ENG_INQ
block|,
literal|"XPT_ENG_INQ"
block|}
block|,
block|{
name|XPT_ENG_EXEC
block|,
literal|"XPT_ENG_EXEC"
block|}
block|,
block|{
name|XPT_EN_LUN
block|,
literal|"XPT_EN_LUN"
block|}
block|,
block|{
name|XPT_TARGET_IO
block|,
literal|"XPT_TARGET_IO"
block|}
block|,
block|{
name|XPT_ACCEPT_TARGET_IO
block|,
literal|"XPT_ACCEPT_TARGET_IO"
block|}
block|,
block|{
name|XPT_CONT_TARGET_IO
block|,
literal|"XPT_CONT_TARGET_IO"
block|}
block|,
block|{
name|XPT_IMMED_NOTIFY
block|,
literal|"XPT_IMMED_NOTIFY"
block|}
block|,
block|{
name|XPT_NOTIFY_ACK
block|,
literal|"XPT_NOTIFY_ACK"
block|}
block|,
block|{
name|XPT_IMMEDIATE_NOTIFY
block|,
literal|"XPT_IMMEDIATE_NOTIFY"
block|}
block|,
block|{
name|XPT_NOTIFY_ACKNOWLEDGE
block|,
literal|"XPT_NOTIFY_ACKNOWLEDGE"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|xpt_action_name
parameter_list|(
name|uint32_t
name|action
parameter_list|)
block|{
specifier|static
name|char
name|buffer
index|[
literal|32
index|]
decl_stmt|;
comment|/* Only for unknown messages -- racy */
name|struct
name|kv
modifier|*
name|walker
init|=
name|map
decl_stmt|;
while|while
condition|(
name|walker
operator|->
name|name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|walker
operator|->
name|v
operator|==
name|action
condition|)
return|return
operator|(
name|walker
operator|->
name|name
operator|)
return|;
name|walker
operator|++
expr_stmt|;
block|}
name|snprintf
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|"%#x"
argument_list|,
name|action
argument_list|)
expr_stmt|;
return|return
operator|(
name|buffer
operator|)
return|;
block|}
end_function

end_unit

