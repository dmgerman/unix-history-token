begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (C) 2007 Semihalf, Rafal Jaworowski<raj@semihalf.com>  * Copyright (C) 2006 Semihalf, Marian Balakowicz<m8@semihalf.com>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN  * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * Some hw specific parts of this pmap were derived or influenced  * by NetBSD's ibm4xx pmap module. More generic code is shared with  * a few other pmap modules from the FreeBSD tree.  */
end_comment

begin_comment
comment|/*   * VM layout notes:   *   * Kernel and user threads run within one common virtual address space   * defined by AS=0.   *   * Virtual address space layout:   * -----------------------------   * 0x0000_0000 - 0xbfff_efff	: user process   * 0xc000_0000 - 0xc1ff_ffff	: kerel reserved   *   0xc000_0000 - kernelend	: kernel code&data   *   0xc1ff_c000 - 0xc200_0000	: kstack0   * 0xc200_0000 - 0xffef_ffff	: KVA   *   0xc200_0000 - 0xc200_3fff : reserved for page zero/copy   *   0xc200_4000 - ptbl buf end: reserved for ptbl bufs   *   ptbl buf end- 0xffef_ffff	: actual free KVA space   * 0xfff0_0000 - 0xffff_ffff	: I/O devices region   */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/msgbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pageout.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pager.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/pcb.h>
end_include

begin_include
include|#
directive|include
file|<machine/powerpc.h>
end_include

begin_include
include|#
directive|include
file|<machine/tlb.h>
end_include

begin_include
include|#
directive|include
file|<machine/spr.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmparam.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/mmuvar.h>
end_include

begin_include
include|#
directive|include
file|<machine/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/pte.h>
end_include

begin_include
include|#
directive|include
file|"mmu_if.h"
end_include

begin_define
define|#
directive|define
name|DEBUG
end_define

begin_undef
undef|#
directive|undef
name|DEBUG
end_undef

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|debugf
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
value|printf(fmt, ##args)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|debugf
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|TODO
value|panic("%s: not implemented", __func__);
end_define

begin_define
define|#
directive|define
name|memmove
parameter_list|(
name|d
parameter_list|,
name|s
parameter_list|,
name|l
parameter_list|)
value|bcopy(s, d, l)
end_define

begin_include
include|#
directive|include
file|"opt_sched.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|SCHED_4BSD
end_ifndef

begin_error
error|#
directive|error
literal|"e500 only works with SCHED_4BSD which uses a global scheduler lock."
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|struct
name|mtx
name|sched_lock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Kernel physical load address. */
end_comment

begin_decl_stmt
specifier|extern
name|uint32_t
name|kernload
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mem_region
name|availmem_regions
index|[
name|MEM_REGIONS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|availmem_regions_sz
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Reserved KVA space and mutex for mmu_booke_zero_page. */
end_comment

begin_decl_stmt
specifier|static
name|vm_offset_t
name|zero_page_va
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|zero_page_mutex
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Reserved KVA space for mmu_booke_zero_page_idle. This is used  * by idle thred only, no lock required.  */
end_comment

begin_decl_stmt
specifier|static
name|vm_offset_t
name|zero_page_idle_va
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Reserved KVA space and mutex for mmu_booke_copy_page. */
end_comment

begin_decl_stmt
specifier|static
name|vm_offset_t
name|copy_page_src_va
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vm_offset_t
name|copy_page_dst_va
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|copy_page_mutex
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**************************************************************************/
end_comment

begin_comment
comment|/* PMAP */
end_comment

begin_comment
comment|/**************************************************************************/
end_comment

begin_function_decl
specifier|static
name|void
name|mmu_booke_enter_locked
parameter_list|(
name|mmu_t
parameter_list|,
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_page_t
parameter_list|,
name|vm_prot_t
parameter_list|,
name|boolean_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|unsigned
name|int
name|kptbl_min
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index of the first kernel ptbl. */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|kernel_ptbls
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of KVA ptbls. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pagedaemon_waken
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * If user pmap is processed with mmu_booke_remove and the resident count  * drops to 0, there are no more pages to remove, so we need not continue.  */
end_comment

begin_define
define|#
directive|define
name|PMAP_REMOVE_DONE
parameter_list|(
name|pmap
parameter_list|)
define|\
value|((pmap) != kernel_pmap&& (pmap)->pm_stats.resident_count == 0)
end_define

begin_function_decl
specifier|extern
name|void
name|load_pid0
parameter_list|(
name|tlbtid_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**************************************************************************/
end_comment

begin_comment
comment|/* TLB and TID handling */
end_comment

begin_comment
comment|/**************************************************************************/
end_comment

begin_comment
comment|/* Translation ID busy table */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|pmap_t
name|tidbusy
index|[
name|TID_MAX
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Actual maximum number of TLB0 entries.  * This number differs between e500 core revisions.  */
end_comment

begin_decl_stmt
name|u_int32_t
name|tlb0_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int32_t
name|tlb0_nways
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int32_t
name|tlb0_nentries_per_way
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TLB0_SIZE
value|(tlb0_size)
end_define

begin_define
define|#
directive|define
name|TLB0_NWAYS
value|(tlb0_nways)
end_define

begin_define
define|#
directive|define
name|TLB0_ENTRIES_PER_WAY
value|(tlb0_nentries_per_way)
end_define

begin_comment
comment|/* Pointer to kernel tlb0 table, allocated in mmu_booke_bootstrap() */
end_comment

begin_decl_stmt
name|tlb_entry_t
modifier|*
name|tlb0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Spinlock to assure proper locking between threads and  * between tlb miss handler and kernel.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|tlb0_mutex
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TLB1_SIZE
value|16
end_define

begin_comment
comment|/* In-ram copy of the TLB1 */
end_comment

begin_decl_stmt
specifier|static
name|tlb_entry_t
name|tlb1
index|[
name|TLB1_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Next free entry in the TLB1 */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|tlb1_idx
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|tlbtid_t
name|tid_alloc
parameter_list|(
name|struct
name|pmap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tid_flush
parameter_list|(
name|tlbtid_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|tlb1_inval_va
parameter_list|(
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|tlb0_inval_va
parameter_list|(
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tlb_print_entry
parameter_list|(
name|int
parameter_list|,
name|u_int32_t
parameter_list|,
name|u_int32_t
parameter_list|,
name|u_int32_t
parameter_list|,
name|u_int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tlb1_set_entry
parameter_list|(
name|vm_offset_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_size_t
parameter_list|,
name|u_int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|__tlb1_set_entry
parameter_list|(
name|unsigned
name|int
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_size_t
parameter_list|,
name|u_int32_t
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tlb1_write_entry
parameter_list|(
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tlb1_iomapped
parameter_list|(
name|int
parameter_list|,
name|vm_paddr_t
parameter_list|,
name|vm_size_t
parameter_list|,
name|vm_offset_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vm_size_t
name|tlb1_mapin_region
parameter_list|(
name|vm_offset_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vm_size_t
name|tsize2size
parameter_list|(
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|size2tsize
parameter_list|(
name|vm_size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|ilog2
parameter_list|(
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_mas4_defaults
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tlb0_inval_entry
parameter_list|(
name|vm_offset_t
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|unsigned
name|int
name|tlb0_tableidx
parameter_list|(
name|vm_offset_t
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tlb0_write_entry
parameter_list|(
name|unsigned
name|int
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tlb0_flush_entry
parameter_list|(
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tlb0_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**************************************************************************/
end_comment

begin_comment
comment|/* Page table management */
end_comment

begin_comment
comment|/**************************************************************************/
end_comment

begin_comment
comment|/* Data for the pv entry allocation mechanism */
end_comment

begin_decl_stmt
specifier|static
name|uma_zone_t
name|pvzone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vm_object
name|pvzone_obj
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pv_entry_count
init|=
literal|0
decl_stmt|,
name|pv_entry_max
init|=
literal|0
decl_stmt|,
name|pv_entry_high_water
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PV_ENTRY_ZONE_MIN
value|2048
end_define

begin_comment
comment|/* min pv entries in uma zone */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PMAP_SHPGPERPROC
end_ifndef

begin_define
define|#
directive|define
name|PMAP_SHPGPERPROC
value|200
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|ptbl_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ptbl_buf
modifier|*
name|ptbl_buf_alloc
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ptbl_buf_free
parameter_list|(
name|struct
name|ptbl_buf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ptbl_free_pmap_ptbl
parameter_list|(
name|pmap_t
parameter_list|,
name|pte_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ptbl_alloc
parameter_list|(
name|mmu_t
parameter_list|,
name|pmap_t
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ptbl_free
parameter_list|(
name|mmu_t
parameter_list|,
name|pmap_t
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ptbl_hold
parameter_list|(
name|mmu_t
parameter_list|,
name|pmap_t
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ptbl_unhold
parameter_list|(
name|mmu_t
parameter_list|,
name|pmap_t
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vm_paddr_t
name|pte_vatopa
parameter_list|(
name|mmu_t
parameter_list|,
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pte_t
modifier|*
name|pte_find
parameter_list|(
name|mmu_t
parameter_list|,
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|pte_enter
parameter_list|(
name|mmu_t
parameter_list|,
name|pmap_t
parameter_list|,
name|vm_page_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|u_int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pte_remove
parameter_list|(
name|mmu_t
parameter_list|,
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|u_int8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|pv_entry_t
name|pv_alloc
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pv_free
parameter_list|(
name|pv_entry_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pv_insert
parameter_list|(
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_page_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pv_remove
parameter_list|(
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_page_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Number of kva ptbl buffers, each covering one ptbl (PTBL_PAGES). */
end_comment

begin_define
define|#
directive|define
name|PTBL_BUFS
value|(128 * 16)
end_define

begin_struct
struct|struct
name|ptbl_buf
block|{
name|TAILQ_ENTRY
argument_list|(
argument|ptbl_buf
argument_list|)
name|link
expr_stmt|;
comment|/* list link */
name|vm_offset_t
name|kva
decl_stmt|;
comment|/* va of mapping */
block|}
struct|;
end_struct

begin_comment
comment|/* ptbl free list and a lock used for access synchronization. */
end_comment

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|ptbl_buf
argument_list|)
name|ptbl_buf_freelist
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|ptbl_buf_freelist_lock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Base address of kva space allocated fot ptbl bufs. */
end_comment

begin_decl_stmt
specifier|static
name|vm_offset_t
name|ptbl_buf_pool_vabase
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to ptbl_buf structures. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ptbl_buf
modifier|*
name|ptbl_bufs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Kernel MMU interface  */
end_comment

begin_function_decl
specifier|static
name|vm_offset_t
name|mmu_booke_addr_hint
parameter_list|(
name|mmu_t
parameter_list|,
name|vm_object_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mmu_booke_change_wiring
parameter_list|(
name|mmu_t
parameter_list|,
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|boolean_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mmu_booke_clear_modify
parameter_list|(
name|mmu_t
parameter_list|,
name|vm_page_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mmu_booke_clear_reference
parameter_list|(
name|mmu_t
parameter_list|,
name|vm_page_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mmu_booke_copy
parameter_list|(
name|pmap_t
parameter_list|,
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_size_t
parameter_list|,
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mmu_booke_copy_page
parameter_list|(
name|mmu_t
parameter_list|,
name|vm_page_t
parameter_list|,
name|vm_page_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mmu_booke_enter
parameter_list|(
name|mmu_t
parameter_list|,
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_page_t
parameter_list|,
name|vm_prot_t
parameter_list|,
name|boolean_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mmu_booke_enter_object
parameter_list|(
name|mmu_t
parameter_list|,
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_page_t
parameter_list|,
name|vm_prot_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mmu_booke_enter_quick
parameter_list|(
name|mmu_t
parameter_list|,
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_page_t
parameter_list|,
name|vm_prot_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vm_paddr_t
name|mmu_booke_extract
parameter_list|(
name|mmu_t
parameter_list|,
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vm_page_t
name|mmu_booke_extract_and_hold
parameter_list|(
name|mmu_t
parameter_list|,
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_prot_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mmu_booke_init
parameter_list|(
name|mmu_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean_t
name|mmu_booke_is_modified
parameter_list|(
name|mmu_t
parameter_list|,
name|vm_page_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean_t
name|mmu_booke_is_prefaultable
parameter_list|(
name|mmu_t
parameter_list|,
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean_t
name|mmu_booke_ts_referenced
parameter_list|(
name|mmu_t
parameter_list|,
name|vm_page_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vm_offset_t
name|mmu_booke_map
parameter_list|(
name|mmu_t
parameter_list|,
name|vm_offset_t
modifier|*
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mmu_booke_mincore
parameter_list|(
name|mmu_t
parameter_list|,
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mmu_booke_object_init_pt
parameter_list|(
name|mmu_t
parameter_list|,
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_object_t
parameter_list|,
name|vm_pindex_t
parameter_list|,
name|vm_size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean_t
name|mmu_booke_page_exists_quick
parameter_list|(
name|mmu_t
parameter_list|,
name|pmap_t
parameter_list|,
name|vm_page_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mmu_booke_page_init
parameter_list|(
name|mmu_t
parameter_list|,
name|vm_page_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mmu_booke_page_wired_mappings
parameter_list|(
name|mmu_t
parameter_list|,
name|vm_page_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mmu_booke_pinit
parameter_list|(
name|mmu_t
parameter_list|,
name|pmap_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mmu_booke_pinit0
parameter_list|(
name|mmu_t
parameter_list|,
name|pmap_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mmu_booke_protect
parameter_list|(
name|mmu_t
parameter_list|,
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_prot_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mmu_booke_qenter
parameter_list|(
name|mmu_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_page_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mmu_booke_qremove
parameter_list|(
name|mmu_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mmu_booke_release
parameter_list|(
name|mmu_t
parameter_list|,
name|pmap_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mmu_booke_remove
parameter_list|(
name|mmu_t
parameter_list|,
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mmu_booke_remove_all
parameter_list|(
name|mmu_t
parameter_list|,
name|vm_page_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mmu_booke_remove_write
parameter_list|(
name|mmu_t
parameter_list|,
name|vm_page_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mmu_booke_zero_page
parameter_list|(
name|mmu_t
parameter_list|,
name|vm_page_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mmu_booke_zero_page_area
parameter_list|(
name|mmu_t
parameter_list|,
name|vm_page_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mmu_booke_zero_page_idle
parameter_list|(
name|mmu_t
parameter_list|,
name|vm_page_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mmu_booke_activate
parameter_list|(
name|mmu_t
parameter_list|,
name|struct
name|thread
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mmu_booke_deactivate
parameter_list|(
name|mmu_t
parameter_list|,
name|struct
name|thread
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mmu_booke_bootstrap
parameter_list|(
name|mmu_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|mmu_booke_mapdev
parameter_list|(
name|mmu_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mmu_booke_unmapdev
parameter_list|(
name|mmu_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vm_offset_t
name|mmu_booke_kextract
parameter_list|(
name|mmu_t
parameter_list|,
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mmu_booke_kenter
parameter_list|(
name|mmu_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mmu_booke_kremove
parameter_list|(
name|mmu_t
parameter_list|,
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean_t
name|mmu_booke_dev_direct_mapped
parameter_list|(
name|mmu_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean_t
name|mmu_booke_page_executable
parameter_list|(
name|mmu_t
parameter_list|,
name|vm_page_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|mmu_method_t
name|mmu_booke_methods
index|[]
init|=
block|{
comment|/* pmap dispatcher interface */
name|MMUMETHOD
argument_list|(
name|mmu_addr_hint
argument_list|,
name|mmu_booke_addr_hint
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_change_wiring
argument_list|,
name|mmu_booke_change_wiring
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_clear_modify
argument_list|,
name|mmu_booke_clear_modify
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_clear_reference
argument_list|,
name|mmu_booke_clear_reference
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_copy
argument_list|,
name|mmu_booke_copy
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_copy_page
argument_list|,
name|mmu_booke_copy_page
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_enter
argument_list|,
name|mmu_booke_enter
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_enter_object
argument_list|,
name|mmu_booke_enter_object
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_enter_quick
argument_list|,
name|mmu_booke_enter_quick
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_extract
argument_list|,
name|mmu_booke_extract
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_extract_and_hold
argument_list|,
name|mmu_booke_extract_and_hold
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_init
argument_list|,
name|mmu_booke_init
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_is_modified
argument_list|,
name|mmu_booke_is_modified
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_is_prefaultable
argument_list|,
name|mmu_booke_is_prefaultable
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_ts_referenced
argument_list|,
name|mmu_booke_ts_referenced
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_map
argument_list|,
name|mmu_booke_map
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_mincore
argument_list|,
name|mmu_booke_mincore
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_object_init_pt
argument_list|,
name|mmu_booke_object_init_pt
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_page_exists_quick
argument_list|,
name|mmu_booke_page_exists_quick
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_page_init
argument_list|,
name|mmu_booke_page_init
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_page_wired_mappings
argument_list|,
name|mmu_booke_page_wired_mappings
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_pinit
argument_list|,
name|mmu_booke_pinit
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_pinit0
argument_list|,
name|mmu_booke_pinit0
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_protect
argument_list|,
name|mmu_booke_protect
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_qenter
argument_list|,
name|mmu_booke_qenter
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_qremove
argument_list|,
name|mmu_booke_qremove
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_release
argument_list|,
name|mmu_booke_release
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_remove
argument_list|,
name|mmu_booke_remove
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_remove_all
argument_list|,
name|mmu_booke_remove_all
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_remove_write
argument_list|,
name|mmu_booke_remove_write
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_zero_page
argument_list|,
name|mmu_booke_zero_page
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_zero_page_area
argument_list|,
name|mmu_booke_zero_page_area
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_zero_page_idle
argument_list|,
name|mmu_booke_zero_page_idle
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_activate
argument_list|,
name|mmu_booke_activate
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_deactivate
argument_list|,
name|mmu_booke_deactivate
argument_list|)
block|,
comment|/* Internal interfaces */
name|MMUMETHOD
argument_list|(
name|mmu_bootstrap
argument_list|,
name|mmu_booke_bootstrap
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_dev_direct_mapped
argument_list|,
name|mmu_booke_dev_direct_mapped
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_mapdev
argument_list|,
name|mmu_booke_mapdev
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_kenter
argument_list|,
name|mmu_booke_kenter
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_kextract
argument_list|,
name|mmu_booke_kextract
argument_list|)
block|,
comment|/*	MMUMETHOD(mmu_kremove,		mmu_booke_kremove),	*/
name|MMUMETHOD
argument_list|(
name|mmu_page_executable
argument_list|,
name|mmu_booke_page_executable
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_unmapdev
argument_list|,
name|mmu_booke_unmapdev
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mmu_def_t
name|booke_mmu
init|=
block|{
name|MMU_TYPE_BOOKE
block|,
name|mmu_booke_methods
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MMU_DEF
argument_list|(
name|booke_mmu
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * This routine defines the region(s) of memory that should  * not be tested for the modified bit.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|track_modified_needed
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
if|if
condition|(
name|pmap
operator|==
name|kernel_pmap
condition|)
return|return
operator|(
operator|(
name|va
operator|<
name|kmi
operator|.
name|clean_sva
operator|)
operator|||
operator|(
name|va
operator|>=
name|kmi
operator|.
name|clean_eva
operator|)
operator|)
return|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return number of entries in TLB0. */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|tlb0_get_tlbconf
parameter_list|(
name|void
parameter_list|)
block|{
name|uint32_t
name|tlb0_cfg
decl_stmt|;
name|tlb0_cfg
operator|=
name|mfspr
argument_list|(
name|SPR_TLB0CFG
argument_list|)
expr_stmt|;
name|tlb0_size
operator|=
name|tlb0_cfg
operator|&
name|TLBCFG_NENTRY_MASK
expr_stmt|;
name|tlb0_nways
operator|=
operator|(
name|tlb0_cfg
operator|&
name|TLBCFG_ASSOC_MASK
operator|)
operator|>>
name|TLBCFG_ASSOC_SHIFT
expr_stmt|;
name|tlb0_nentries_per_way
operator|=
name|tlb0_size
operator|/
name|tlb0_nways
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize pool of kva ptbl buffers. */
end_comment

begin_function
specifier|static
name|void
name|ptbl_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|//debugf("ptbl_init: s (ptbl_bufs = 0x%08x size 0x%08x)\n",
comment|//		(u_int32_t)ptbl_bufs, sizeof(struct ptbl_buf) * PTBL_BUFS);
comment|//debugf("ptbl_init: s (ptbl_buf_pool_vabase = 0x%08x size = 0x%08x)\n",
comment|//		ptbl_buf_pool_vabase, PTBL_BUFS * PTBL_PAGES * PAGE_SIZE);
name|mtx_init
argument_list|(
operator|&
name|ptbl_buf_freelist_lock
argument_list|,
literal|"ptbl bufs lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|ptbl_buf_freelist
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PTBL_BUFS
condition|;
name|i
operator|++
control|)
block|{
name|ptbl_bufs
index|[
name|i
index|]
operator|.
name|kva
operator|=
name|ptbl_buf_pool_vabase
operator|+
name|i
operator|*
name|PTBL_PAGES
operator|*
name|PAGE_SIZE
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ptbl_buf_freelist
argument_list|,
operator|&
name|ptbl_bufs
index|[
name|i
index|]
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
comment|//debugf("ptbl_init: e\n");
block|}
end_function

begin_comment
comment|/* Get an sf_buf from the freelist. */
end_comment

begin_function
specifier|static
name|struct
name|ptbl_buf
modifier|*
name|ptbl_buf_alloc
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ptbl_buf
modifier|*
name|buf
decl_stmt|;
comment|//debugf("ptbl_buf_alloc: s\n");
name|mtx_lock
argument_list|(
operator|&
name|ptbl_buf_freelist_lock
argument_list|)
expr_stmt|;
name|buf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ptbl_buf_freelist
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ptbl_buf_freelist
argument_list|,
name|buf
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ptbl_buf_freelist_lock
argument_list|)
expr_stmt|;
comment|//debugf("ptbl_buf_alloc: e (buf = 0x%08x)\n", (u_int32_t)buf);
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return ptbl buff to free pool. */
end_comment

begin_function
specifier|static
name|void
name|ptbl_buf_free
parameter_list|(
name|struct
name|ptbl_buf
modifier|*
name|buf
parameter_list|)
block|{
comment|//debugf("ptbl_buf_free: s (buf = 0x%08x)\n", (u_int32_t)buf);
name|mtx_lock
argument_list|(
operator|&
name|ptbl_buf_freelist_lock
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ptbl_buf_freelist
argument_list|,
name|buf
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ptbl_buf_freelist_lock
argument_list|)
expr_stmt|;
comment|//debugf("ptbl_buf_free: e\n");
block|}
end_function

begin_comment
comment|/*  * Search the list of allocated ptbl bufs and find   * on list of allocated ptbls  */
end_comment

begin_function
specifier|static
name|void
name|ptbl_free_pmap_ptbl
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|pte_t
modifier|*
name|ptbl
parameter_list|)
block|{
name|struct
name|ptbl_buf
modifier|*
name|pbuf
decl_stmt|;
comment|//debugf("ptbl_free_pmap_ptbl: s (pmap = 0x%08x ptbl = 0x%08x)\n",
comment|//		(u_int32_t)pmap, (u_int32_t)ptbl);
name|TAILQ_FOREACH
argument_list|(
argument|pbuf
argument_list|,
argument|&pmap->ptbl_list
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|pbuf
operator|->
name|kva
operator|==
operator|(
name|vm_offset_t
operator|)
name|ptbl
condition|)
block|{
comment|/* Remove from pmap ptbl buf list. */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pmap
operator|->
name|ptbl_list
argument_list|,
name|pbuf
argument_list|,
name|link
argument_list|)
expr_stmt|;
comment|/* Free correspondig ptbl buf. */
name|ptbl_buf_free
argument_list|(
name|pbuf
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|//debugf("ptbl_free_pmap_ptbl: e\n");
block|}
end_function

begin_comment
comment|/* Allocate page table. */
end_comment

begin_function
specifier|static
name|void
name|ptbl_alloc
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|pmap_t
name|pmap
parameter_list|,
name|unsigned
name|int
name|pdir_idx
parameter_list|)
block|{
name|vm_page_t
name|mtbl
index|[
name|PTBL_PAGES
index|]
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|struct
name|ptbl_buf
modifier|*
name|pbuf
decl_stmt|;
name|unsigned
name|int
name|pidx
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|//int su = (pmap == kernel_pmap);
comment|//debugf("ptbl_alloc: s (pmap = 0x%08x su = %d pdir_idx = %d)\n", (u_int32_t)pmap, su, pdir_idx);
name|KASSERT
argument_list|(
operator|(
name|pdir_idx
operator|<=
operator|(
name|VM_MAXUSER_ADDRESS
operator|/
name|PDIR_SIZE
operator|)
operator|)
argument_list|,
operator|(
literal|"ptbl_alloc: invalid pdir_idx"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|pmap
operator|->
name|pm_pdir
index|[
name|pdir_idx
index|]
operator|==
name|NULL
operator|)
argument_list|,
operator|(
literal|"pte_alloc: valid ptbl entry exists!"
operator|)
argument_list|)
expr_stmt|;
name|pbuf
operator|=
name|ptbl_buf_alloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|pbuf
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"pte_alloc: couldn't alloc kernel virtual memory"
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_pdir
index|[
name|pdir_idx
index|]
operator|=
operator|(
name|pte_t
operator|*
operator|)
name|pbuf
operator|->
name|kva
expr_stmt|;
comment|//debugf("ptbl_alloc: kva = 0x%08x\n", (u_int32_t)pmap->pm_pdir[pdir_idx]);
comment|/* Allocate ptbl pages, this will sleep! */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PTBL_PAGES
condition|;
name|i
operator|++
control|)
block|{
name|pidx
operator|=
operator|(
name|PTBL_PAGES
operator|*
name|pdir_idx
operator|)
operator|+
name|i
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|vm_page_alloc
argument_list|(
name|NULL
argument_list|,
name|pidx
argument_list|,
name|VM_ALLOC_NOOBJ
operator||
name|VM_ALLOC_WIRED
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
name|VM_WAIT
expr_stmt|;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
name|mtbl
index|[
name|i
index|]
operator|=
name|m
expr_stmt|;
block|}
comment|/* Map in allocated pages into kernel_pmap. */
name|mmu_booke_qenter
argument_list|(
name|mmu
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|pmap
operator|->
name|pm_pdir
index|[
name|pdir_idx
index|]
argument_list|,
name|mtbl
argument_list|,
name|PTBL_PAGES
argument_list|)
expr_stmt|;
comment|/* Zero whole ptbl. */
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|pmap
operator|->
name|pm_pdir
index|[
name|pdir_idx
index|]
argument_list|,
name|PTBL_PAGES
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
comment|/* Add pbuf to the pmap ptbl bufs list. */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pmap
operator|->
name|ptbl_list
argument_list|,
name|pbuf
argument_list|,
name|link
argument_list|)
expr_stmt|;
comment|//debugf("ptbl_alloc: e\n");
block|}
end_function

begin_comment
comment|/* Free ptbl pages and invalidate pdir entry. */
end_comment

begin_function
specifier|static
name|void
name|ptbl_free
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|pmap_t
name|pmap
parameter_list|,
name|unsigned
name|int
name|pdir_idx
parameter_list|)
block|{
name|pte_t
modifier|*
name|ptbl
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|//int su = (pmap == kernel_pmap);
comment|//debugf("ptbl_free: s (pmap = 0x%08x su = %d pdir_idx = %d)\n", (u_int32_t)pmap, su, pdir_idx);
name|KASSERT
argument_list|(
operator|(
name|pdir_idx
operator|<=
operator|(
name|VM_MAXUSER_ADDRESS
operator|/
name|PDIR_SIZE
operator|)
operator|)
argument_list|,
operator|(
literal|"ptbl_free: invalid pdir_idx"
operator|)
argument_list|)
expr_stmt|;
name|ptbl
operator|=
name|pmap
operator|->
name|pm_pdir
index|[
name|pdir_idx
index|]
expr_stmt|;
comment|//debugf("ptbl_free: ptbl = 0x%08x\n", (u_int32_t)ptbl);
name|KASSERT
argument_list|(
operator|(
name|ptbl
operator|!=
name|NULL
operator|)
argument_list|,
operator|(
literal|"ptbl_free: null ptbl"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PTBL_PAGES
condition|;
name|i
operator|++
control|)
block|{
name|va
operator|=
operator|(
operator|(
name|vm_offset_t
operator|)
name|ptbl
operator|+
operator|(
name|i
operator|*
name|PAGE_SIZE
operator|)
operator|)
expr_stmt|;
name|pa
operator|=
name|pte_vatopa
argument_list|(
name|mmu
argument_list|,
name|kernel_pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|vm_page_free_zero
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|cnt
operator|.
name|v_wire_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mmu_booke_kremove
argument_list|(
name|mmu
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
name|ptbl_free_pmap_ptbl
argument_list|(
name|pmap
argument_list|,
name|ptbl
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_pdir
index|[
name|pdir_idx
index|]
operator|=
name|NULL
expr_stmt|;
comment|//debugf("ptbl_free: e\n");
block|}
end_function

begin_comment
comment|/*  * Decrement ptbl pages hold count and attempt to free ptbl pages.  * Called when removing pte entry from ptbl.  *  * Return 1 if ptbl pages were freed.  */
end_comment

begin_function
specifier|static
name|int
name|ptbl_unhold
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|pmap_t
name|pmap
parameter_list|,
name|unsigned
name|int
name|pdir_idx
parameter_list|)
block|{
name|pte_t
modifier|*
name|ptbl
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|//int su = (pmap == kernel_pmap);
comment|//debugf("ptbl_unhold: s (pmap = %08x su = %d pdir_idx = %d)\n",
comment|//		(u_int32_t)pmap, su, pdir_idx);
name|KASSERT
argument_list|(
operator|(
name|pdir_idx
operator|<=
operator|(
name|VM_MAXUSER_ADDRESS
operator|/
name|PDIR_SIZE
operator|)
operator|)
argument_list|,
operator|(
literal|"ptbl_unhold: invalid pdir_idx"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|pmap
operator|!=
name|kernel_pmap
operator|)
argument_list|,
operator|(
literal|"ptbl_unhold: unholding kernel ptbl!"
operator|)
argument_list|)
expr_stmt|;
name|ptbl
operator|=
name|pmap
operator|->
name|pm_pdir
index|[
name|pdir_idx
index|]
expr_stmt|;
comment|//debugf("ptbl_unhold: ptbl = 0x%08x\n", (u_int32_t)ptbl);
name|KASSERT
argument_list|(
operator|(
operator|(
name|vm_offset_t
operator|)
name|ptbl
operator|>=
name|VM_MIN_KERNEL_ADDRESS
operator|)
argument_list|,
operator|(
literal|"ptbl_unhold: non kva ptbl"
operator|)
argument_list|)
expr_stmt|;
comment|/* decrement hold count */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PTBL_PAGES
condition|;
name|i
operator|++
control|)
block|{
name|pa
operator|=
name|pte_vatopa
argument_list|(
name|mmu
argument_list|,
name|kernel_pmap
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|ptbl
operator|+
operator|(
name|i
operator|*
name|PAGE_SIZE
operator|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|m
operator|->
name|wire_count
operator|--
expr_stmt|;
block|}
comment|/* 	 * Free ptbl pages if there are no pte etries in this ptbl. 	 * wire_count has the same value for all ptbl pages, so check 	 * the last page. 	 */
if|if
condition|(
name|m
operator|->
name|wire_count
operator|==
literal|0
condition|)
block|{
name|ptbl_free
argument_list|(
name|mmu
argument_list|,
name|pmap
argument_list|,
name|pdir_idx
argument_list|)
expr_stmt|;
comment|//debugf("ptbl_unhold: e (freed ptbl)\n");
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|//debugf("ptbl_unhold: e\n");
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Increment hold count for ptbl pages. This routine is used when  * new pte entry is being inserted into ptbl.  */
end_comment

begin_function
specifier|static
name|void
name|ptbl_hold
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|pmap_t
name|pmap
parameter_list|,
name|unsigned
name|int
name|pdir_idx
parameter_list|)
block|{
name|vm_paddr_t
name|pa
decl_stmt|;
name|pte_t
modifier|*
name|ptbl
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|//debugf("ptbl_hold: s (pmap = 0x%08x pdir_idx = %d)\n", (u_int32_t)pmap, pdir_idx);
name|KASSERT
argument_list|(
operator|(
name|pdir_idx
operator|<=
operator|(
name|VM_MAXUSER_ADDRESS
operator|/
name|PDIR_SIZE
operator|)
operator|)
argument_list|,
operator|(
literal|"ptbl_hold: invalid pdir_idx"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|pmap
operator|!=
name|kernel_pmap
operator|)
argument_list|,
operator|(
literal|"ptbl_hold: holding kernel ptbl!"
operator|)
argument_list|)
expr_stmt|;
name|ptbl
operator|=
name|pmap
operator|->
name|pm_pdir
index|[
name|pdir_idx
index|]
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|ptbl
operator|!=
name|NULL
operator|)
argument_list|,
operator|(
literal|"ptbl_hold: null ptbl"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PTBL_PAGES
condition|;
name|i
operator|++
control|)
block|{
name|pa
operator|=
name|pte_vatopa
argument_list|(
name|mmu
argument_list|,
name|kernel_pmap
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|ptbl
operator|+
operator|(
name|i
operator|*
name|PAGE_SIZE
operator|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|m
operator|->
name|wire_count
operator|++
expr_stmt|;
block|}
comment|//debugf("ptbl_hold: e\n");
block|}
end_function

begin_comment
comment|/* Allocate pv_entry structure. */
end_comment

begin_function
name|pv_entry_t
name|pv_alloc
parameter_list|(
name|void
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
name|debugf
argument_list|(
literal|"pv_alloc: s\n"
argument_list|)
expr_stmt|;
name|pv_entry_count
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|pv_entry_count
operator|>
name|pv_entry_high_water
operator|)
operator|&&
operator|(
name|pagedaemon_waken
operator|==
literal|0
operator|)
condition|)
block|{
name|pagedaemon_waken
operator|=
literal|1
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|vm_pages_needed
argument_list|)
expr_stmt|;
block|}
name|pv
operator|=
name|uma_zalloc
argument_list|(
name|pvzone
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|debugf
argument_list|(
literal|"pv_alloc: e\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|pv
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Free pv_entry structure. */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|pv_free
parameter_list|(
name|pv_entry_t
name|pve
parameter_list|)
block|{
comment|//debugf("pv_free: s\n");
name|pv_entry_count
operator|--
expr_stmt|;
name|uma_zfree
argument_list|(
name|pvzone
argument_list|,
name|pve
argument_list|)
expr_stmt|;
comment|//debugf("pv_free: e\n");
block|}
end_function

begin_comment
comment|/* Allocate and initialize pv_entry structure. */
end_comment

begin_function
specifier|static
name|void
name|pv_insert
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|pv_entry_t
name|pve
decl_stmt|;
comment|//int su = (pmap == kernel_pmap);
comment|//debugf("pv_insert: s (su = %d pmap = 0x%08x va = 0x%08x m = 0x%08x)\n", su,
comment|//	(u_int32_t)pmap, va, (u_int32_t)m);
name|pve
operator|=
name|pv_alloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|pve
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"pv_insert: no pv entries!"
argument_list|)
expr_stmt|;
name|pve
operator|->
name|pv_pmap
operator|=
name|pmap
expr_stmt|;
name|pve
operator|->
name|pv_va
operator|=
name|va
expr_stmt|;
comment|/* add to pv_list */
name|PMAP_LOCK_ASSERT
argument_list|(
name|pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|vm_page_queue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pve
argument_list|,
name|pv_link
argument_list|)
expr_stmt|;
comment|//debugf("pv_insert: e\n");
block|}
end_function

begin_comment
comment|/* Destroy pv entry. */
end_comment

begin_function
specifier|static
name|void
name|pv_remove
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|pv_entry_t
name|pve
decl_stmt|;
comment|//int su = (pmap == kernel_pmap);
comment|//debugf("pv_remove: s (su = %d pmap = 0x%08x va = 0x%08x)\n", su, (u_int32_t)pmap, va);
name|PMAP_LOCK_ASSERT
argument_list|(
name|pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|vm_page_queue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* find pv entry */
name|TAILQ_FOREACH
argument_list|(
argument|pve
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_link
argument_list|)
block|{
if|if
condition|(
operator|(
name|pmap
operator|==
name|pve
operator|->
name|pv_pmap
operator|)
operator|&&
operator|(
name|va
operator|==
name|pve
operator|->
name|pv_va
operator|)
condition|)
block|{
comment|/* remove from pv_list */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pve
argument_list|,
name|pv_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
condition|)
name|vm_page_flag_clear
argument_list|(
name|m
argument_list|,
name|PG_WRITEABLE
argument_list|)
expr_stmt|;
comment|/* free pv entry struct */
name|pv_free
argument_list|(
name|pve
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|//debugf("pv_remove: e\n");
block|}
end_function

begin_comment
comment|/*  * Clean pte entry, try to free page table page if requested.  *  * Return 1 if ptbl pages were freed, otherwise return 0.  */
end_comment

begin_function
specifier|static
name|int
name|pte_remove
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|u_int8_t
name|flags
parameter_list|)
block|{
name|unsigned
name|int
name|pdir_idx
init|=
name|PDIR_IDX
argument_list|(
name|va
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|ptbl_idx
init|=
name|PTBL_IDX
argument_list|(
name|va
argument_list|)
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|pte_t
modifier|*
name|ptbl
decl_stmt|;
name|pte_t
modifier|*
name|pte
decl_stmt|;
comment|//int su = (pmap == kernel_pmap);
comment|//debugf("pte_remove: s (su = %d pmap = 0x%08x va = 0x%08x flags = %d)\n",
comment|//		su, (u_int32_t)pmap, va, flags);
name|ptbl
operator|=
name|pmap
operator|->
name|pm_pdir
index|[
name|pdir_idx
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|ptbl
argument_list|,
operator|(
literal|"pte_remove: null ptbl"
operator|)
argument_list|)
expr_stmt|;
name|pte
operator|=
operator|&
name|ptbl
index|[
name|ptbl_idx
index|]
expr_stmt|;
if|if
condition|(
name|pte
operator|==
name|NULL
operator|||
operator|!
name|PTE_ISVALID
argument_list|(
name|pte
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Get vm_page_t for mapped pte. */
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|PTE_PA
argument_list|(
name|pte
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|PTE_ISWIRED
argument_list|(
name|pte
argument_list|)
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|PTE_ISFAKE
argument_list|(
name|pte
argument_list|)
condition|)
block|{
comment|/* Handle managed entry. */
if|if
condition|(
name|PTE_ISMANAGED
argument_list|(
name|pte
argument_list|)
condition|)
block|{
comment|/* Handle modified pages. */
if|if
condition|(
name|PTE_ISMODIFIED
argument_list|(
name|pte
argument_list|)
condition|)
block|{
if|if
condition|(
name|track_modified_needed
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
condition|)
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* Referenced pages. */
if|if
condition|(
name|PTE_ISREFERENCED
argument_list|(
name|pte
argument_list|)
condition|)
name|vm_page_flag_set
argument_list|(
name|m
argument_list|,
name|PG_REFERENCED
argument_list|)
expr_stmt|;
comment|/* Remove pv_entry from pv_list. */
name|pv_remove
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
name|pte
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|pte
operator|->
name|rpn
operator|=
literal|0
expr_stmt|;
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|--
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|PTBL_UNHOLD
condition|)
block|{
comment|//debugf("pte_remove: e (unhold)\n");
return|return
operator|(
name|ptbl_unhold
argument_list|(
name|mmu
argument_list|,
name|pmap
argument_list|,
name|pdir_idx
argument_list|)
operator|)
return|;
block|}
comment|//debugf("pte_remove: e\n");
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Insert PTE for a given page and virtual address.  */
end_comment

begin_function
name|void
name|pte_enter
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|pmap_t
name|pmap
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|u_int32_t
name|flags
parameter_list|)
block|{
name|unsigned
name|int
name|pdir_idx
init|=
name|PDIR_IDX
argument_list|(
name|va
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|ptbl_idx
init|=
name|PTBL_IDX
argument_list|(
name|va
argument_list|)
decl_stmt|;
name|pte_t
modifier|*
name|ptbl
decl_stmt|;
name|pte_t
modifier|*
name|pte
decl_stmt|;
comment|//int su = (pmap == kernel_pmap);
comment|//debugf("pte_enter: s (su = %d pmap = 0x%08x va = 0x%08x)\n", su, (u_int32_t)pmap, va);
comment|/* Get the page table pointer. */
name|ptbl
operator|=
name|pmap
operator|->
name|pm_pdir
index|[
name|pdir_idx
index|]
expr_stmt|;
if|if
condition|(
name|ptbl
condition|)
block|{
comment|/* 		 * Check if there is valid mapping for requested 		 * va, if there is, remove it. 		 */
name|pte
operator|=
operator|&
name|pmap
operator|->
name|pm_pdir
index|[
name|pdir_idx
index|]
index|[
name|ptbl_idx
index|]
expr_stmt|;
if|if
condition|(
name|PTE_ISVALID
argument_list|(
name|pte
argument_list|)
condition|)
block|{
name|pte_remove
argument_list|(
name|mmu
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|,
name|PTBL_HOLD
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * pte is not used, increment hold count 			 * for ptbl pages. 			 */
if|if
condition|(
name|pmap
operator|!=
name|kernel_pmap
condition|)
name|ptbl_hold
argument_list|(
name|mmu
argument_list|,
name|pmap
argument_list|,
name|pdir_idx
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Allocate page table pages. */
name|ptbl_alloc
argument_list|(
name|mmu
argument_list|,
name|pmap
argument_list|,
name|pdir_idx
argument_list|)
expr_stmt|;
block|}
comment|/* Flush entry from TLB. */
name|tlb0_flush_entry
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|pte
operator|=
operator|&
operator|(
name|pmap
operator|->
name|pm_pdir
index|[
name|pdir_idx
index|]
index|[
name|ptbl_idx
index|]
operator|)
expr_stmt|;
comment|/* 	 * Insert pv_entry into pv_list for mapped page 	 * if part of managed memory. 	 */
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_UNMANAGED
operator|)
operator|==
literal|0
condition|)
block|{
name|pte
operator|->
name|flags
operator||=
name|PTE_MANAGED
expr_stmt|;
comment|/* Create and insert pv entry. */
name|pv_insert
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|pte
operator|->
name|flags
operator||=
name|PTE_FAKE
expr_stmt|;
block|}
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|++
expr_stmt|;
name|pte
operator|->
name|rpn
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
operator|&
operator|~
name|PTE_PA_MASK
expr_stmt|;
name|pte
operator|->
name|flags
operator||=
operator|(
name|PTE_VALID
operator||
name|flags
operator|)
expr_stmt|;
comment|//debugf("pte_enter: e\n");
block|}
end_function

begin_comment
comment|/* Return the pa for the given pmap/va. */
end_comment

begin_function
specifier|static
name|vm_paddr_t
name|pte_vatopa
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|vm_paddr_t
name|pa
init|=
literal|0
decl_stmt|;
name|pte_t
modifier|*
name|pte
decl_stmt|;
name|pte
operator|=
name|pte_find
argument_list|(
name|mmu
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pte
operator|!=
name|NULL
operator|)
operator|&&
name|PTE_ISVALID
argument_list|(
name|pte
argument_list|)
condition|)
name|pa
operator|=
operator|(
name|PTE_PA
argument_list|(
name|pte
argument_list|)
operator||
operator|(
name|va
operator|&
name|PTE_PA_MASK
operator|)
operator|)
expr_stmt|;
return|return
operator|(
name|pa
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get a pointer to a PTE in a page table. */
end_comment

begin_function
specifier|static
name|pte_t
modifier|*
name|pte_find
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|unsigned
name|int
name|pdir_idx
init|=
name|PDIR_IDX
argument_list|(
name|va
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|ptbl_idx
init|=
name|PTBL_IDX
argument_list|(
name|va
argument_list|)
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|pmap
operator|!=
name|NULL
operator|)
argument_list|,
operator|(
literal|"pte_find: invalid pmap"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap
operator|->
name|pm_pdir
index|[
name|pdir_idx
index|]
condition|)
return|return
operator|(
operator|&
operator|(
name|pmap
operator|->
name|pm_pdir
index|[
name|pdir_idx
index|]
index|[
name|ptbl_idx
index|]
operator|)
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************/
end_comment

begin_comment
comment|/* PMAP related */
end_comment

begin_comment
comment|/**************************************************************************/
end_comment

begin_comment
comment|/*  * This is called during e500_init, before the system is really initialized.  */
end_comment

begin_function
specifier|static
name|void
name|mmu_booke_bootstrap
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|vm_offset_t
name|kernelstart
parameter_list|,
name|vm_offset_t
name|kernelend
parameter_list|)
block|{
name|vm_offset_t
name|phys_kernelend
decl_stmt|;
name|struct
name|mem_region
modifier|*
name|mp
decl_stmt|,
modifier|*
name|mp1
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|u_int
name|s
decl_stmt|,
name|e
decl_stmt|,
name|sz
decl_stmt|;
name|u_int
name|phys_avail_count
decl_stmt|;
name|vm_size_t
name|physsz
decl_stmt|,
name|hwphyssz
decl_stmt|;
name|vm_offset_t
name|kernel_pdir
decl_stmt|;
name|debugf
argument_list|(
literal|"mmu_booke_bootstrap: entered\n"
argument_list|)
expr_stmt|;
comment|/* Align kernel start and end address (kernel image). */
name|kernelstart
operator|=
name|trunc_page
argument_list|(
name|kernelstart
argument_list|)
expr_stmt|;
name|kernelend
operator|=
name|round_page
argument_list|(
name|kernelend
argument_list|)
expr_stmt|;
comment|/* Allocate space for the message buffer. */
name|msgbufp
operator|=
operator|(
expr|struct
name|msgbuf
operator|*
operator|)
name|kernelend
expr_stmt|;
name|kernelend
operator|+=
name|MSGBUF_SIZE
expr_stmt|;
name|debugf
argument_list|(
literal|" msgbufp at 0x%08x end = 0x%08x\n"
argument_list|,
operator|(
name|u_int32_t
operator|)
name|msgbufp
argument_list|,
name|kernelend
argument_list|)
expr_stmt|;
name|kernelend
operator|=
name|round_page
argument_list|(
name|kernelend
argument_list|)
expr_stmt|;
comment|/* Allocate space for tlb0 table. */
name|tlb0_get_tlbconf
argument_list|()
expr_stmt|;
comment|/* Read TLB0 size and associativity. */
name|tlb0
operator|=
operator|(
name|tlb_entry_t
operator|*
operator|)
name|kernelend
expr_stmt|;
name|kernelend
operator|+=
sizeof|sizeof
argument_list|(
name|tlb_entry_t
argument_list|)
operator|*
name|tlb0_size
expr_stmt|;
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
name|tlb0
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tlb_entry_t
argument_list|)
operator|*
name|tlb0_size
argument_list|)
expr_stmt|;
name|debugf
argument_list|(
literal|" tlb0 at 0x%08x end = 0x%08x\n"
argument_list|,
operator|(
name|u_int32_t
operator|)
name|tlb0
argument_list|,
name|kernelend
argument_list|)
expr_stmt|;
name|kernelend
operator|=
name|round_page
argument_list|(
name|kernelend
argument_list|)
expr_stmt|;
comment|/* Allocate space for ptbl_bufs. */
name|ptbl_bufs
operator|=
operator|(
expr|struct
name|ptbl_buf
operator|*
operator|)
name|kernelend
expr_stmt|;
name|kernelend
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ptbl_buf
argument_list|)
operator|*
name|PTBL_BUFS
expr_stmt|;
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ptbl_bufs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ptbl_buf
argument_list|)
operator|*
name|PTBL_SIZE
argument_list|)
expr_stmt|;
name|debugf
argument_list|(
literal|" ptbl_bufs at 0x%08x end = 0x%08x\n"
argument_list|,
operator|(
name|u_int32_t
operator|)
name|ptbl_bufs
argument_list|,
name|kernelend
argument_list|)
expr_stmt|;
name|kernelend
operator|=
name|round_page
argument_list|(
name|kernelend
argument_list|)
expr_stmt|;
comment|/* Allocate PTE tables for kernel KVA. */
name|kernel_pdir
operator|=
name|kernelend
expr_stmt|;
name|kernel_ptbls
operator|=
operator|(
name|VM_MAX_KERNEL_ADDRESS
operator|-
name|VM_MIN_KERNEL_ADDRESS
operator|+
name|PDIR_SIZE
operator|-
literal|1
operator|)
operator|/
name|PDIR_SIZE
expr_stmt|;
name|kernelend
operator|+=
name|kernel_ptbls
operator|*
name|PTBL_PAGES
operator|*
name|PAGE_SIZE
expr_stmt|;
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
name|kernel_pdir
argument_list|,
literal|0
argument_list|,
name|kernel_ptbls
operator|*
name|PTBL_PAGES
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|debugf
argument_list|(
literal|" kernel ptbls: %d\n"
argument_list|,
name|kernel_ptbls
argument_list|)
expr_stmt|;
name|debugf
argument_list|(
literal|" kernel pdir at 0x%08x\n"
argument_list|,
name|kernel_pdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|kernelend
operator|-
name|kernelstart
operator|>
literal|0x1000000
condition|)
block|{
name|kernelend
operator|=
operator|(
name|kernelend
operator|+
literal|0x3fffff
operator|)
operator|&
operator|~
literal|0x3fffff
expr_stmt|;
name|tlb1_mapin_region
argument_list|(
name|kernelstart
operator|+
literal|0x1000000
argument_list|,
name|kernload
operator|+
literal|0x1000000
argument_list|,
name|kernelend
operator|-
name|kernelstart
operator|-
literal|0x1000000
argument_list|)
expr_stmt|;
block|}
else|else
name|kernelend
operator|=
operator|(
name|kernelend
operator|+
literal|0xffffff
operator|)
operator|&
operator|~
literal|0xffffff
expr_stmt|;
comment|/*******************************************************/
comment|/* Set the start and end of kva. */
comment|/*******************************************************/
name|virtual_avail
operator|=
name|kernelend
expr_stmt|;
name|virtual_end
operator|=
name|VM_MAX_KERNEL_ADDRESS
expr_stmt|;
comment|/* Allocate KVA space for page zero/copy operations. */
name|zero_page_va
operator|=
name|virtual_avail
expr_stmt|;
name|virtual_avail
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|zero_page_idle_va
operator|=
name|virtual_avail
expr_stmt|;
name|virtual_avail
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|copy_page_src_va
operator|=
name|virtual_avail
expr_stmt|;
name|virtual_avail
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|copy_page_dst_va
operator|=
name|virtual_avail
expr_stmt|;
name|virtual_avail
operator|+=
name|PAGE_SIZE
expr_stmt|;
comment|/* Initialize page zero/copy mutexes. */
name|mtx_init
argument_list|(
operator|&
name|zero_page_mutex
argument_list|,
literal|"mmu_booke_zero_page"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|copy_page_mutex
argument_list|,
literal|"mmu_booke_copy_page"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* Initialize tlb0 table mutex. */
name|mtx_init
argument_list|(
operator|&
name|tlb0_mutex
argument_list|,
literal|"tlb0"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
operator||
name|MTX_RECURSE
argument_list|)
expr_stmt|;
comment|/* Allocate KVA space for ptbl bufs. */
name|ptbl_buf_pool_vabase
operator|=
name|virtual_avail
expr_stmt|;
name|virtual_avail
operator|+=
name|PTBL_BUFS
operator|*
name|PTBL_PAGES
operator|*
name|PAGE_SIZE
expr_stmt|;
name|debugf
argument_list|(
literal|"ptbl_buf_pool_vabase = 0x%08x\n"
argument_list|,
name|ptbl_buf_pool_vabase
argument_list|)
expr_stmt|;
name|debugf
argument_list|(
literal|"virtual_avail = %08x\n"
argument_list|,
name|virtual_avail
argument_list|)
expr_stmt|;
name|debugf
argument_list|(
literal|"virtual_end   = %08x\n"
argument_list|,
name|virtual_end
argument_list|)
expr_stmt|;
comment|/* Calculate corresponding physical addresses for the kernel region. */
name|phys_kernelend
operator|=
name|kernload
operator|+
operator|(
name|kernelend
operator|-
name|kernelstart
operator|)
expr_stmt|;
name|debugf
argument_list|(
literal|"kernel image and allocated data:\n"
argument_list|)
expr_stmt|;
name|debugf
argument_list|(
literal|" kernload    = 0x%08x\n"
argument_list|,
name|kernload
argument_list|)
expr_stmt|;
name|debugf
argument_list|(
literal|" kernelstart = 0x%08x\n"
argument_list|,
name|kernelstart
argument_list|)
expr_stmt|;
name|debugf
argument_list|(
literal|" kernelend   = 0x%08x\n"
argument_list|,
name|kernelend
argument_list|)
expr_stmt|;
name|debugf
argument_list|(
literal|" kernel size = 0x%08x\n"
argument_list|,
name|kernelend
operator|-
name|kernelstart
argument_list|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|phys_avail
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|phys_avail
index|[
literal|0
index|]
argument_list|)
operator|<
name|availmem_regions_sz
condition|)
name|panic
argument_list|(
literal|"mmu_booke_bootstrap: phys_avail too small"
argument_list|)
expr_stmt|;
comment|/* 	 * Removed kernel physical address range from avail 	 * regions list. Page align all regions. 	 * Non-page aligned memory isn't very interesting to us. 	 * Also, sort the entries for ascending addresses. 	 */
name|sz
operator|=
literal|0
expr_stmt|;
name|cnt
operator|=
name|availmem_regions_sz
expr_stmt|;
name|debugf
argument_list|(
literal|"processing avail regions:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|mp
operator|=
name|availmem_regions
init|;
name|mp
operator|->
name|mr_size
condition|;
name|mp
operator|++
control|)
block|{
name|s
operator|=
name|mp
operator|->
name|mr_start
expr_stmt|;
name|e
operator|=
name|mp
operator|->
name|mr_start
operator|+
name|mp
operator|->
name|mr_size
expr_stmt|;
name|debugf
argument_list|(
literal|" %08x-%08x -> "
argument_list|,
name|s
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* Check whether this region holds all of the kernel. */
if|if
condition|(
name|s
operator|<
name|kernload
operator|&&
name|e
operator|>
name|phys_kernelend
condition|)
block|{
name|availmem_regions
index|[
name|cnt
index|]
operator|.
name|mr_start
operator|=
name|phys_kernelend
expr_stmt|;
name|availmem_regions
index|[
name|cnt
operator|++
index|]
operator|.
name|mr_size
operator|=
name|e
operator|-
name|phys_kernelend
expr_stmt|;
name|e
operator|=
name|kernload
expr_stmt|;
block|}
comment|/* Look whether this regions starts within the kernel. */
if|if
condition|(
name|s
operator|>=
name|kernload
operator|&&
name|s
operator|<
name|phys_kernelend
condition|)
block|{
if|if
condition|(
name|e
operator|<=
name|phys_kernelend
condition|)
goto|goto
name|empty
goto|;
name|s
operator|=
name|phys_kernelend
expr_stmt|;
block|}
comment|/* Now look whether this region ends within the kernel. */
if|if
condition|(
name|e
operator|>
name|kernload
operator|&&
name|e
operator|<=
name|phys_kernelend
condition|)
block|{
if|if
condition|(
name|s
operator|>=
name|kernload
condition|)
goto|goto
name|empty
goto|;
name|e
operator|=
name|kernload
expr_stmt|;
block|}
comment|/* Now page align the start and size of the region. */
name|s
operator|=
name|round_page
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|e
operator|=
name|trunc_page
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|<
name|s
condition|)
name|e
operator|=
name|s
expr_stmt|;
name|sz
operator|=
name|e
operator|-
name|s
expr_stmt|;
name|debugf
argument_list|(
literal|"%08x-%08x = %x\n"
argument_list|,
name|s
argument_list|,
name|e
argument_list|,
name|sz
argument_list|)
expr_stmt|;
comment|/* Check whether some memory is left here. */
if|if
condition|(
name|sz
operator|==
literal|0
condition|)
block|{
name|empty
label|:
name|memmove
argument_list|(
name|mp
argument_list|,
name|mp
operator|+
literal|1
argument_list|,
operator|(
name|cnt
operator|-
operator|(
name|mp
operator|-
name|availmem_regions
operator|)
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|cnt
operator|--
expr_stmt|;
name|mp
operator|--
expr_stmt|;
continue|continue;
block|}
comment|/* Do an insertion sort. */
for|for
control|(
name|mp1
operator|=
name|availmem_regions
init|;
name|mp1
operator|<
name|mp
condition|;
name|mp1
operator|++
control|)
if|if
condition|(
name|s
operator|<
name|mp1
operator|->
name|mr_start
condition|)
break|break;
if|if
condition|(
name|mp1
operator|<
name|mp
condition|)
block|{
name|memmove
argument_list|(
name|mp1
operator|+
literal|1
argument_list|,
name|mp1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|mp
operator|-
operator|(
name|char
operator|*
operator|)
name|mp1
argument_list|)
expr_stmt|;
name|mp1
operator|->
name|mr_start
operator|=
name|s
expr_stmt|;
name|mp1
operator|->
name|mr_size
operator|=
name|sz
expr_stmt|;
block|}
else|else
block|{
name|mp
operator|->
name|mr_start
operator|=
name|s
expr_stmt|;
name|mp
operator|->
name|mr_size
operator|=
name|sz
expr_stmt|;
block|}
block|}
name|availmem_regions_sz
operator|=
name|cnt
expr_stmt|;
comment|/*******************************************************/
comment|/* Fill in phys_avail table, based on availmem_regions */
comment|/*******************************************************/
name|phys_avail_count
operator|=
literal|0
expr_stmt|;
name|physsz
operator|=
literal|0
expr_stmt|;
name|hwphyssz
operator|=
literal|0
expr_stmt|;
name|TUNABLE_ULONG_FETCH
argument_list|(
literal|"hw.physmem"
argument_list|,
operator|(
name|u_long
operator|*
operator|)
operator|&
name|hwphyssz
argument_list|)
expr_stmt|;
name|debugf
argument_list|(
literal|"fill in phys_avail:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|availmem_regions_sz
condition|;
name|i
operator|++
operator|,
name|j
operator|+=
literal|2
control|)
block|{
name|debugf
argument_list|(
literal|" region: 0x%08x - 0x%08x (0x%08x)\n"
argument_list|,
name|availmem_regions
index|[
name|i
index|]
operator|.
name|mr_start
argument_list|,
name|availmem_regions
index|[
name|i
index|]
operator|.
name|mr_start
operator|+
name|availmem_regions
index|[
name|i
index|]
operator|.
name|mr_size
argument_list|,
name|availmem_regions
index|[
name|i
index|]
operator|.
name|mr_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|hwphyssz
operator|!=
literal|0
operator|&&
operator|(
name|physsz
operator|+
name|availmem_regions
index|[
name|i
index|]
operator|.
name|mr_size
operator|)
operator|>=
name|hwphyssz
condition|)
block|{
name|debugf
argument_list|(
literal|" hw.physmem adjust\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|physsz
operator|<
name|hwphyssz
condition|)
block|{
name|phys_avail
index|[
name|j
index|]
operator|=
name|availmem_regions
index|[
name|i
index|]
operator|.
name|mr_start
expr_stmt|;
name|phys_avail
index|[
name|j
operator|+
literal|1
index|]
operator|=
name|availmem_regions
index|[
name|i
index|]
operator|.
name|mr_start
operator|+
name|hwphyssz
operator|-
name|physsz
expr_stmt|;
name|physsz
operator|=
name|hwphyssz
expr_stmt|;
name|phys_avail_count
operator|++
expr_stmt|;
block|}
break|break;
block|}
name|phys_avail
index|[
name|j
index|]
operator|=
name|availmem_regions
index|[
name|i
index|]
operator|.
name|mr_start
expr_stmt|;
name|phys_avail
index|[
name|j
operator|+
literal|1
index|]
operator|=
name|availmem_regions
index|[
name|i
index|]
operator|.
name|mr_start
operator|+
name|availmem_regions
index|[
name|i
index|]
operator|.
name|mr_size
expr_stmt|;
name|phys_avail_count
operator|++
expr_stmt|;
name|physsz
operator|+=
name|availmem_regions
index|[
name|i
index|]
operator|.
name|mr_size
expr_stmt|;
block|}
name|physmem
operator|=
name|btoc
argument_list|(
name|physsz
argument_list|)
expr_stmt|;
comment|/* Calculate the last available physical address. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|phys_avail
index|[
name|i
operator|+
literal|2
index|]
operator|!=
literal|0
condition|;
name|i
operator|+=
literal|2
control|)
empty_stmt|;
name|Maxmem
operator|=
name|powerpc_btop
argument_list|(
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|debugf
argument_list|(
literal|"Maxmem = 0x%08lx\n"
argument_list|,
name|Maxmem
argument_list|)
expr_stmt|;
name|debugf
argument_list|(
literal|"phys_avail_count = %d\n"
argument_list|,
name|phys_avail_count
argument_list|)
expr_stmt|;
name|debugf
argument_list|(
literal|"physsz = 0x%08x physmem = %ld (0x%08lx)\n"
argument_list|,
name|physsz
argument_list|,
name|physmem
argument_list|,
name|physmem
argument_list|)
expr_stmt|;
comment|/*******************************************************/
comment|/* Initialize (statically allocated) kernel pmap. */
comment|/*******************************************************/
name|PMAP_LOCK_INIT
argument_list|(
name|kernel_pmap
argument_list|)
expr_stmt|;
name|kptbl_min
operator|=
name|VM_MIN_KERNEL_ADDRESS
operator|/
name|PDIR_SIZE
expr_stmt|;
name|debugf
argument_list|(
literal|"kernel_pmap = 0x%08x\n"
argument_list|,
operator|(
name|u_int32_t
operator|)
name|kernel_pmap
argument_list|)
expr_stmt|;
name|debugf
argument_list|(
literal|"kptbl_min = %d, kernel_kptbls = %d\n"
argument_list|,
name|kptbl_min
argument_list|,
name|kernel_ptbls
argument_list|)
expr_stmt|;
name|debugf
argument_list|(
literal|"kernel pdir range: 0x%08x - 0x%08x\n"
argument_list|,
name|kptbl_min
operator|*
name|PDIR_SIZE
argument_list|,
operator|(
name|kptbl_min
operator|+
name|kernel_ptbls
operator|)
operator|*
name|PDIR_SIZE
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Initialize kernel pdir */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|kernel_ptbls
condition|;
name|i
operator|++
control|)
name|kernel_pmap
operator|->
name|pm_pdir
index|[
name|kptbl_min
operator|+
name|i
index|]
operator|=
operator|(
name|pte_t
operator|*
operator|)
operator|(
name|kernel_pdir
operator|+
operator|(
name|i
operator|*
name|PAGE_SIZE
operator|*
name|PTBL_PAGES
operator|)
operator|)
expr_stmt|;
name|kernel_pmap
operator|->
name|pm_tid
operator|=
name|KERNEL_TID
expr_stmt|;
name|kernel_pmap
operator|->
name|pm_active
operator|=
operator|~
literal|0
expr_stmt|;
comment|/* Initialize tidbusy with kenel_pmap entry. */
name|tidbusy
index|[
literal|0
index|]
operator|=
name|kernel_pmap
expr_stmt|;
comment|/*******************************************************/
comment|/* Final setup */
comment|/*******************************************************/
comment|/* Initialize TLB0 handling. */
name|tlb0_init
argument_list|()
expr_stmt|;
name|debugf
argument_list|(
literal|"mmu_booke_bootstrap: exit\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get the physical page address for the given pmap/virtual address.  */
end_comment

begin_function
specifier|static
name|vm_paddr_t
name|mmu_booke_extract
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|vm_paddr_t
name|pa
decl_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pa
operator|=
name|pte_vatopa
argument_list|(
name|mmu
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|pa
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Extract the physical page address associated with the given  * kernel virtual address.  */
end_comment

begin_function
specifier|static
name|vm_paddr_t
name|mmu_booke_kextract
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
return|return
operator|(
name|pte_vatopa
argument_list|(
name|mmu
argument_list|,
name|kernel_pmap
argument_list|,
name|va
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize the pmap module.  * Called by vm_init, to initialize any structures that the pmap  * system needs to map virtual memory.  */
end_comment

begin_function
specifier|static
name|void
name|mmu_booke_init
parameter_list|(
name|mmu_t
name|mmu
parameter_list|)
block|{
name|int
name|shpgperproc
init|=
name|PMAP_SHPGPERPROC
decl_stmt|;
comment|//debugf("mmu_booke_init: s\n");
comment|/* 	 * Initialize the address space (zone) for the pv entries.  Set a 	 * high water mark so that the system can recover from excessive 	 * numbers of pv entries. 	 */
name|pvzone
operator|=
name|uma_zcreate
argument_list|(
literal|"PV ENTRY"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pv_entry
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
name|UMA_ZONE_VM
operator||
name|UMA_ZONE_NOFREE
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"vm.pmap.shpgperproc"
argument_list|,
operator|&
name|shpgperproc
argument_list|)
expr_stmt|;
name|pv_entry_max
operator|=
name|shpgperproc
operator|*
name|maxproc
operator|+
name|cnt
operator|.
name|v_page_count
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"vm.pmap.pv_entries"
argument_list|,
operator|&
name|pv_entry_max
argument_list|)
expr_stmt|;
name|pv_entry_high_water
operator|=
literal|9
operator|*
operator|(
name|pv_entry_max
operator|/
literal|10
operator|)
expr_stmt|;
name|uma_zone_set_obj
argument_list|(
name|pvzone
argument_list|,
operator|&
name|pvzone_obj
argument_list|,
name|pv_entry_max
argument_list|)
expr_stmt|;
comment|/* Pre-fill pvzone with initial number of pv entries. */
name|uma_prealloc
argument_list|(
name|pvzone
argument_list|,
name|PV_ENTRY_ZONE_MIN
argument_list|)
expr_stmt|;
comment|/* Initialize ptbl allocation. */
name|ptbl_init
argument_list|()
expr_stmt|;
comment|//debugf("mmu_booke_init: e\n");
block|}
end_function

begin_comment
comment|/*  * Map a list of wired pages into kernel virtual address space.  This is  * intended for temporary mappings which do not need page modification or  * references recorded.  Existing mappings in the region are overwritten.  */
end_comment

begin_function
specifier|static
name|void
name|mmu_booke_qenter
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|,
name|vm_page_t
modifier|*
name|m
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|vm_offset_t
name|va
decl_stmt|;
comment|//debugf("mmu_booke_qenter: s (sva = 0x%08x count = %d)\n", sva, count);
name|va
operator|=
name|sva
expr_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
name|mmu_booke_kenter
argument_list|(
name|mmu
argument_list|,
name|va
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
operator|*
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|va
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|m
operator|++
expr_stmt|;
block|}
comment|//debugf("mmu_booke_qenter: e\n");
block|}
end_function

begin_comment
comment|/*  * Remove page mappings from kernel virtual address space.  Intended for  * temporary mappings entered by mmu_booke_qenter.  */
end_comment

begin_function
specifier|static
name|void
name|mmu_booke_qremove
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|vm_offset_t
name|va
decl_stmt|;
comment|//debugf("mmu_booke_qremove: s (sva = 0x%08x count = %d)\n", sva, count);
name|va
operator|=
name|sva
expr_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
name|mmu_booke_kremove
argument_list|(
name|mmu
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|va
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
comment|//debugf("mmu_booke_qremove: e\n");
block|}
end_function

begin_comment
comment|/*  * Map a wired page into kernel virtual address space.  */
end_comment

begin_function
specifier|static
name|void
name|mmu_booke_kenter
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_offset_t
name|pa
parameter_list|)
block|{
name|unsigned
name|int
name|pdir_idx
init|=
name|PDIR_IDX
argument_list|(
name|va
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|ptbl_idx
init|=
name|PTBL_IDX
argument_list|(
name|va
argument_list|)
decl_stmt|;
name|u_int32_t
name|flags
decl_stmt|;
name|pte_t
modifier|*
name|pte
decl_stmt|;
comment|//debugf("mmu_booke_kenter: s (pdir_idx = %d ptbl_idx = %d va=0x%08x pa=0x%08x)\n",
comment|//		pdir_idx, ptbl_idx, va, pa);
name|KASSERT
argument_list|(
operator|(
operator|(
name|va
operator|>=
name|VM_MIN_KERNEL_ADDRESS
operator|)
operator|&&
operator|(
name|va
operator|<=
name|VM_MAX_KERNEL_ADDRESS
operator|)
operator|)
argument_list|,
operator|(
literal|"mmu_booke_kenter: invalid va"
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* assume IO mapping, set I, G bits */
block|flags = (PTE_G | PTE_I | PTE_FAKE);
comment|/* if mapping is within system memory, do not set I, G bits */
block|for (i = 0; i< totalmem_regions_sz; i++) { 		if ((pa>= totalmem_regions[i].mr_start)&& 				(pa< (totalmem_regions[i].mr_start + 				       totalmem_regions[i].mr_size))) { 			flags&= ~(PTE_I | PTE_G | PTE_FAKE); 			break; 		} 	}
else|#
directive|else
name|flags
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|flags
operator||=
operator|(
name|PTE_SR
operator||
name|PTE_SW
operator||
name|PTE_SX
operator||
name|PTE_WIRED
operator||
name|PTE_VALID
operator|)
expr_stmt|;
name|pte
operator|=
operator|&
operator|(
name|kernel_pmap
operator|->
name|pm_pdir
index|[
name|pdir_idx
index|]
index|[
name|ptbl_idx
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|PTE_ISVALID
argument_list|(
name|pte
argument_list|)
condition|)
block|{
comment|//debugf("mmu_booke_kenter: replacing entry!\n");
comment|/* Flush entry from TLB0 */
name|tlb0_flush_entry
argument_list|(
name|kernel_pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
name|pte
operator|->
name|rpn
operator|=
name|pa
operator|&
operator|~
name|PTE_PA_MASK
expr_stmt|;
name|pte
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
comment|//debugf("mmu_booke_kenter: pdir_idx = %d ptbl_idx = %d va=0x%08x "
comment|//		"pa=0x%08x rpn=0x%08x flags=0x%08x\n",
comment|//		pdir_idx, ptbl_idx, va, pa, pte->rpn, pte->flags);
comment|/* Flush the real memory from the instruction cache. */
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|PTE_I
operator||
name|PTE_G
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|__syncicache
argument_list|(
operator|(
name|void
operator|*
operator|)
name|va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
comment|//debugf("mmu_booke_kenter: e\n");
block|}
end_function

begin_comment
comment|/*  * Remove a page from kernel page table.  */
end_comment

begin_function
specifier|static
name|void
name|mmu_booke_kremove
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|unsigned
name|int
name|pdir_idx
init|=
name|PDIR_IDX
argument_list|(
name|va
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|ptbl_idx
init|=
name|PTBL_IDX
argument_list|(
name|va
argument_list|)
decl_stmt|;
name|pte_t
modifier|*
name|pte
decl_stmt|;
comment|//debugf("mmu_booke_kremove: s (va = 0x%08x)\n", va);
name|KASSERT
argument_list|(
operator|(
operator|(
name|va
operator|>=
name|VM_MIN_KERNEL_ADDRESS
operator|)
operator|&&
operator|(
name|va
operator|<=
name|VM_MAX_KERNEL_ADDRESS
operator|)
operator|)
argument_list|,
operator|(
literal|"mmu_booke_kremove: invalid va"
operator|)
argument_list|)
expr_stmt|;
name|pte
operator|=
operator|&
operator|(
name|kernel_pmap
operator|->
name|pm_pdir
index|[
name|pdir_idx
index|]
index|[
name|ptbl_idx
index|]
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|PTE_ISVALID
argument_list|(
name|pte
argument_list|)
condition|)
block|{
comment|//debugf("mmu_booke_kremove: e (invalid pte)\n");
return|return;
block|}
comment|/* Invalidate entry in TLB0. */
name|tlb0_flush_entry
argument_list|(
name|kernel_pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|pte
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|pte
operator|->
name|rpn
operator|=
literal|0
expr_stmt|;
comment|//debugf("mmu_booke_kremove: e\n");
block|}
end_function

begin_comment
comment|/*  * Initialize pmap associated with process 0.  */
end_comment

begin_function
specifier|static
name|void
name|mmu_booke_pinit0
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|pmap_t
name|pmap
parameter_list|)
block|{
comment|//debugf("mmu_booke_pinit0: s (pmap = 0x%08x)\n", (u_int32_t)pmap);
name|mmu_booke_pinit
argument_list|(
name|mmu
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
name|PCPU_SET
argument_list|(
name|curpmap
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
comment|//debugf("mmu_booke_pinit0: e\n");
block|}
end_function

begin_comment
comment|/*  * Initialize a preallocated and zeroed pmap structure,  * such as one in a vmspace structure.  */
end_comment

begin_function
specifier|static
name|void
name|mmu_booke_pinit
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|pmap_t
name|pmap
parameter_list|)
block|{
comment|//struct thread *td;
comment|//struct proc *p;
comment|//td = PCPU_GET(curthread);
comment|//p = td->td_proc;
comment|//debugf("mmu_booke_pinit: s (pmap = 0x%08x)\n", (u_int32_t)pmap);
comment|//printf("mmu_booke_pinit: proc %d '%s'\n", p->p_pid, p->p_comm);
name|KASSERT
argument_list|(
operator|(
name|pmap
operator|!=
name|kernel_pmap
operator|)
argument_list|,
operator|(
literal|"mmu_booke_pinit: initializing kernel_pmap"
operator|)
argument_list|)
expr_stmt|;
name|PMAP_LOCK_INIT
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_tid
operator|=
literal|0
expr_stmt|;
name|pmap
operator|->
name|pm_active
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|pmap
operator|->
name|pm_stats
argument_list|,
sizeof|sizeof
argument_list|(
name|pmap
operator|->
name|pm_stats
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pdir
argument_list|,
sizeof|sizeof
argument_list|(
name|pte_t
operator|*
argument_list|)
operator|*
name|PDIR_NENTRIES
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|pmap
operator|->
name|ptbl_list
argument_list|)
expr_stmt|;
comment|//debugf("mmu_booke_pinit: e\n");
block|}
end_function

begin_comment
comment|/*  * Release any resources held by the given physical map.  * Called when a pmap initialized by mmu_booke_pinit is being released.  * Should only be called if the map contains no valid mappings.  */
end_comment

begin_function
specifier|static
name|void
name|mmu_booke_release
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|pmap_t
name|pmap
parameter_list|)
block|{
comment|//debugf("mmu_booke_release: s\n");
name|PMAP_LOCK_DESTROY
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
comment|//debugf("mmu_booke_release: e\n");
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Not needed, kernel page tables are statically allocated. */
end_comment

begin_endif
unit|void mmu_booke_growkernel(vm_offset_t maxkvaddr) { }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Insert the given physical page at the specified virtual address in the  * target physical map with the protection requested. If specified the page  * will be wired down.  */
end_comment

begin_function
specifier|static
name|void
name|mmu_booke_enter
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|boolean_t
name|wired
parameter_list|)
block|{
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|mmu_booke_enter_locked
argument_list|(
name|mmu
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|,
name|m
argument_list|,
name|prot
argument_list|,
name|wired
argument_list|)
expr_stmt|;
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mmu_booke_enter_locked
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|boolean_t
name|wired
parameter_list|)
block|{
name|pte_t
modifier|*
name|pte
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|u_int32_t
name|flags
decl_stmt|;
name|int
name|su
decl_stmt|,
name|sync
decl_stmt|;
name|pa
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|su
operator|=
operator|(
name|pmap
operator|==
name|kernel_pmap
operator|)
expr_stmt|;
name|sync
operator|=
literal|0
expr_stmt|;
comment|//debugf("mmu_booke_enter_locked: s (pmap=0x%08x su=%d tid=%d m=0x%08x va=0x%08x "
comment|//		"pa=0x%08x prot=0x%08x wired=%d)\n",
comment|//		(u_int32_t)pmap, su, pmap->pm_tid,
comment|//		(u_int32_t)m, va, pa, prot, wired);
if|if
condition|(
name|su
condition|)
block|{
name|KASSERT
argument_list|(
operator|(
operator|(
name|va
operator|>=
name|virtual_avail
operator|)
operator|&&
operator|(
name|va
operator|<=
name|VM_MAX_KERNEL_ADDRESS
operator|)
operator|)
argument_list|,
operator|(
literal|"mmu_booke_enter_locked: kernel pmap, non kernel va"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
operator|(
name|va
operator|<=
name|VM_MAXUSER_ADDRESS
operator|)
argument_list|,
operator|(
literal|"mmu_booke_enter_locked: user pmap, non user va"
operator|)
argument_list|)
expr_stmt|;
block|}
name|PMAP_LOCK_ASSERT
argument_list|(
name|pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * If there is an existing mapping, and the physical address has not 	 * changed, must be protection or wiring change. 	 */
if|if
condition|(
operator|(
operator|(
name|pte
operator|=
name|pte_find
argument_list|(
name|mmu
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|PTE_ISVALID
argument_list|(
name|pte
argument_list|)
operator|)
operator|&&
operator|(
name|PTE_PA
argument_list|(
name|pte
argument_list|)
operator|==
name|pa
operator|)
condition|)
block|{
comment|//debugf("mmu_booke_enter_locked: update\n");
comment|/* Wiring change, just update stats. */
if|if
condition|(
name|wired
condition|)
block|{
if|if
condition|(
operator|!
name|PTE_ISWIRED
argument_list|(
name|pte
argument_list|)
condition|)
block|{
name|pte
operator|->
name|flags
operator||=
name|PTE_WIRED
expr_stmt|;
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|PTE_ISWIRED
argument_list|(
name|pte
argument_list|)
condition|)
block|{
name|pte
operator|->
name|flags
operator|&=
operator|~
name|PTE_WIRED
expr_stmt|;
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
block|}
block|}
comment|/* Save the old bits and clear the ones we're interested in. */
name|flags
operator|=
name|pte
operator|->
name|flags
expr_stmt|;
name|pte
operator|->
name|flags
operator|&=
operator|~
operator|(
name|PTE_UW
operator||
name|PTE_UX
operator||
name|PTE_SW
operator||
name|PTE_SX
operator||
name|PTE_MODIFIED
operator|)
expr_stmt|;
if|if
condition|(
name|prot
operator|&
name|VM_PROT_WRITE
condition|)
block|{
comment|/* Add write permissions. */
name|pte
operator|->
name|flags
operator||=
name|PTE_SW
expr_stmt|;
if|if
condition|(
operator|!
name|su
condition|)
name|pte
operator|->
name|flags
operator||=
name|PTE_UW
expr_stmt|;
block|}
else|else
block|{
comment|/* Handle modified pages, sense modify status. */
if|if
condition|(
name|PTE_ISMODIFIED
argument_list|(
name|pte
argument_list|)
condition|)
block|{
if|if
condition|(
name|track_modified_needed
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
condition|)
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we're turning on execute permissions, flush the icache. */
if|if
condition|(
name|prot
operator|&
name|VM_PROT_EXECUTE
condition|)
block|{
name|pte
operator|->
name|flags
operator||=
name|PTE_SX
expr_stmt|;
if|if
condition|(
operator|!
name|su
condition|)
name|pte
operator|->
name|flags
operator||=
name|PTE_UX
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|PTE_UX
operator||
name|PTE_SX
operator|)
operator|)
operator|==
literal|0
condition|)
name|sync
operator|++
expr_stmt|;
block|}
comment|/* Flush the old mapping from TLB0. */
name|pte
operator|->
name|flags
operator|&=
operator|~
name|PTE_REFERENCED
expr_stmt|;
name|tlb0_flush_entry
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * If there is an existing mapping, but its for a different 		 * physical address, pte_enter() will delete the old mapping. 		 */
comment|//if ((pte != NULL)&& PTE_ISVALID(pte))
comment|//	debugf("mmu_booke_enter_locked: replace\n");
comment|//else
comment|//	debugf("mmu_booke_enter_locked: new\n");
comment|/* Now set up the flags and install the new mapping. */
name|flags
operator|=
operator|(
name|PTE_SR
operator||
name|PTE_VALID
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|su
condition|)
name|flags
operator||=
name|PTE_UR
expr_stmt|;
if|if
condition|(
name|prot
operator|&
name|VM_PROT_WRITE
condition|)
block|{
name|flags
operator||=
name|PTE_SW
expr_stmt|;
if|if
condition|(
operator|!
name|su
condition|)
name|flags
operator||=
name|PTE_UW
expr_stmt|;
block|}
if|if
condition|(
name|prot
operator|&
name|VM_PROT_EXECUTE
condition|)
block|{
name|flags
operator||=
name|PTE_SX
expr_stmt|;
if|if
condition|(
operator|!
name|su
condition|)
name|flags
operator||=
name|PTE_UX
expr_stmt|;
block|}
comment|/* If its wired update stats. */
if|if
condition|(
name|wired
condition|)
block|{
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|++
expr_stmt|;
name|flags
operator||=
name|PTE_WIRED
expr_stmt|;
block|}
name|pte_enter
argument_list|(
name|mmu
argument_list|,
name|pmap
argument_list|,
name|m
argument_list|,
name|va
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* Flush the real memory from the instruction cache. */
if|if
condition|(
name|prot
operator|&
name|VM_PROT_EXECUTE
condition|)
name|sync
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|sync
operator|&&
operator|(
name|su
operator|||
name|pmap
operator|==
name|PCPU_GET
argument_list|(
name|curpmap
argument_list|)
operator|)
condition|)
block|{
name|__syncicache
argument_list|(
operator|(
name|void
operator|*
operator|)
name|va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|sync
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sync
condition|)
block|{
comment|/* Create a temporary mapping. */
name|pmap
operator|=
name|PCPU_GET
argument_list|(
name|curpmap
argument_list|)
expr_stmt|;
name|va
operator|=
literal|0
expr_stmt|;
name|pte
operator|=
name|pte_find
argument_list|(
name|mmu
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pte
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s:%d"
operator|,
name|__func__
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|flags
operator|=
name|PTE_SR
operator||
name|PTE_VALID
operator||
name|PTE_UR
expr_stmt|;
name|pte_enter
argument_list|(
name|mmu
argument_list|,
name|pmap
argument_list|,
name|m
argument_list|,
name|va
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|__syncicache
argument_list|(
operator|(
name|void
operator|*
operator|)
name|va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|pte_remove
argument_list|(
name|mmu
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|,
name|PTBL_UNHOLD
argument_list|)
expr_stmt|;
block|}
comment|//debugf("mmu_booke_enter_locked: e\n");
block|}
end_function

begin_comment
comment|/*  * Maps a sequence of resident pages belonging to the same object.  * The sequence begins with the given page m_start.  This page is  * mapped at the given virtual address start.  Each subsequent page is  * mapped at a virtual address that is offset from start by the same  * amount as the page is offset from m_start within the object.  The  * last page in the sequence is the page with the largest offset from  * m_start that can be mapped at a virtual address less than the given  * virtual address end.  Not every virtual page between start and end  * is mapped; only those for which a resident page exists with the  * corresponding offset from m_start are mapped.  */
end_comment

begin_function
specifier|static
name|void
name|mmu_booke_enter_object
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|start
parameter_list|,
name|vm_offset_t
name|end
parameter_list|,
name|vm_page_t
name|m_start
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|vm_page_t
name|m
decl_stmt|;
name|vm_pindex_t
name|diff
decl_stmt|,
name|psize
decl_stmt|;
name|psize
operator|=
name|atop
argument_list|(
name|end
operator|-
name|start
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_start
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
while|while
condition|(
name|m
operator|!=
name|NULL
operator|&&
operator|(
name|diff
operator|=
name|m
operator|->
name|pindex
operator|-
name|m_start
operator|->
name|pindex
operator|)
operator|<
name|psize
condition|)
block|{
name|mmu_booke_enter_locked
argument_list|(
name|mmu
argument_list|,
name|pmap
argument_list|,
name|start
operator|+
name|ptoa
argument_list|(
name|diff
argument_list|)
argument_list|,
name|m
argument_list|,
name|prot
operator|&
operator|(
name|VM_PROT_READ
operator||
name|VM_PROT_EXECUTE
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|m
operator|=
name|TAILQ_NEXT
argument_list|(
name|m
argument_list|,
name|listq
argument_list|)
expr_stmt|;
block|}
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mmu_booke_enter_quick
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
comment|//debugf("mmu_booke_enter_quick: s\n");
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|mmu_booke_enter_locked
argument_list|(
name|mmu
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|,
name|m
argument_list|,
name|prot
operator|&
operator|(
name|VM_PROT_READ
operator||
name|VM_PROT_EXECUTE
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
comment|//debugf("mmu_booke_enter_quick e\n");
block|}
end_function

begin_comment
comment|/*  * Remove the given range of addresses from the specified map.  *  * It is assumed that the start and end are properly rounded to the page size.  */
end_comment

begin_function
specifier|static
name|void
name|mmu_booke_remove
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_offset_t
name|endva
parameter_list|)
block|{
name|pte_t
modifier|*
name|pte
decl_stmt|;
name|u_int8_t
name|hold_flag
decl_stmt|;
name|int
name|su
init|=
operator|(
name|pmap
operator|==
name|kernel_pmap
operator|)
decl_stmt|;
comment|//debugf("mmu_booke_remove: s (su = %d pmap=0x%08x tid=%d va=0x%08x endva=0x%08x)\n",
comment|//		su, (u_int32_t)pmap, pmap->pm_tid, va, endva);
if|if
condition|(
name|su
condition|)
block|{
name|KASSERT
argument_list|(
operator|(
operator|(
name|va
operator|>=
name|virtual_avail
operator|)
operator|&&
operator|(
name|va
operator|<=
name|VM_MAX_KERNEL_ADDRESS
operator|)
operator|)
argument_list|,
operator|(
literal|"mmu_booke_enter: kernel pmap, non kernel va"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
operator|(
name|va
operator|<=
name|VM_MAXUSER_ADDRESS
operator|)
argument_list|,
operator|(
literal|"mmu_booke_enter: user pmap, non user va"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PMAP_REMOVE_DONE
argument_list|(
name|pmap
argument_list|)
condition|)
block|{
comment|//debugf("mmu_booke_remove: e (empty)\n");
return|return;
block|}
name|hold_flag
operator|=
name|PTBL_HOLD_FLAG
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
comment|//debugf("mmu_booke_remove: hold_flag = %d\n", hold_flag);
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|va
operator|<
name|endva
condition|;
name|va
operator|+=
name|PAGE_SIZE
control|)
block|{
name|pte
operator|=
name|pte_find
argument_list|(
name|mmu
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pte
operator|!=
name|NULL
operator|)
operator|&&
name|PTE_ISVALID
argument_list|(
name|pte
argument_list|)
condition|)
block|{
name|pte_remove
argument_list|(
name|mmu
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|,
name|hold_flag
argument_list|)
expr_stmt|;
comment|/* Flush mapping from TLB0. */
name|tlb0_flush_entry
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
block|}
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
comment|//debugf("mmu_booke_remove: e\n");
block|}
end_function

begin_comment
comment|/*  * Remove physical page from all pmaps in which it resides.  */
end_comment

begin_function
specifier|static
name|void
name|mmu_booke_remove_all
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|,
name|pvn
decl_stmt|;
name|u_int8_t
name|hold_flag
decl_stmt|;
comment|//debugf("mmu_booke_remove_all: s\n");
name|mtx_assert
argument_list|(
operator|&
name|vm_page_queue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
for|for
control|(
name|pv
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
init|;
name|pv
operator|!=
name|NULL
condition|;
name|pv
operator|=
name|pvn
control|)
block|{
name|pvn
operator|=
name|TAILQ_NEXT
argument_list|(
name|pv
argument_list|,
name|pv_link
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|)
expr_stmt|;
name|hold_flag
operator|=
name|PTBL_HOLD_FLAG
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|)
expr_stmt|;
name|pte_remove
argument_list|(
name|mmu
argument_list|,
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
name|hold_flag
argument_list|)
expr_stmt|;
comment|/* Flush mapping from TLB0. */
name|tlb0_flush_entry
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|)
expr_stmt|;
block|}
name|vm_page_flag_clear
argument_list|(
name|m
argument_list|,
name|PG_WRITEABLE
argument_list|)
expr_stmt|;
comment|//debugf("mmu_booke_remove_all: e\n");
block|}
end_function

begin_comment
comment|/*  * Map a range of physical addresses into kernel virtual address space.  *  * The value passed in *virt is a suggested virtual address for the mapping.  * Architectures which can support a direct-mapped physical to virtual region  * can return the appropriate address within that region, leaving '*virt'  * unchanged.  We cannot and therefore do not; *virt is updated with the  * first usable address after the mapped region.  */
end_comment

begin_function
specifier|static
name|vm_offset_t
name|mmu_booke_map
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|vm_offset_t
modifier|*
name|virt
parameter_list|,
name|vm_offset_t
name|pa_start
parameter_list|,
name|vm_offset_t
name|pa_end
parameter_list|,
name|int
name|prot
parameter_list|)
block|{
name|vm_offset_t
name|sva
init|=
operator|*
name|virt
decl_stmt|;
name|vm_offset_t
name|va
init|=
name|sva
decl_stmt|;
comment|//debugf("mmu_booke_map: s (sva = 0x%08x pa_start = 0x%08x pa_end = 0x%08x)\n",
comment|//		sva, pa_start, pa_end);
while|while
condition|(
name|pa_start
operator|<
name|pa_end
condition|)
block|{
name|mmu_booke_kenter
argument_list|(
name|mmu
argument_list|,
name|va
argument_list|,
name|pa_start
argument_list|)
expr_stmt|;
name|va
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|pa_start
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
operator|*
name|virt
operator|=
name|va
expr_stmt|;
comment|//debugf("mmu_booke_map: e (va = 0x%08x)\n", va);
return|return
operator|(
name|sva
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The pmap must be activated before it's address space can be accessed in any  * way.  */
end_comment

begin_function
specifier|static
name|void
name|mmu_booke_activate
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|pmap_t
name|pmap
decl_stmt|;
name|pmap
operator|=
operator|&
name|td
operator|->
name|td_proc
operator|->
name|p_vmspace
operator|->
name|vm_pmap
expr_stmt|;
comment|//debugf("mmu_booke_activate: s (proc = '%s', id = %d, pmap = 0x%08x)\n",
comment|//		td->td_proc->p_comm, td->td_proc->p_pid, pmap);
name|KASSERT
argument_list|(
operator|(
name|pmap
operator|!=
name|kernel_pmap
operator|)
argument_list|,
operator|(
literal|"mmu_booke_activate: kernel_pmap!"
operator|)
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_active
operator||=
name|PCPU_GET
argument_list|(
name|cpumask
argument_list|)
expr_stmt|;
name|PCPU_SET
argument_list|(
name|curpmap
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pmap
operator|->
name|pm_tid
condition|)
name|tid_alloc
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
comment|/* Load PID0 register with pmap tid value. */
name|load_pid0
argument_list|(
name|pmap
operator|->
name|pm_tid
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
comment|//debugf("mmu_booke_activate: e (tid = %d for '%s')\n", pmap->pm_tid,
comment|//		td->td_proc->p_comm);
block|}
end_function

begin_comment
comment|/*  * Deactivate the specified process's address space.  */
end_comment

begin_function
specifier|static
name|void
name|mmu_booke_deactivate
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|pmap_t
name|pmap
decl_stmt|;
name|pmap
operator|=
operator|&
name|td
operator|->
name|td_proc
operator|->
name|p_vmspace
operator|->
name|vm_pmap
expr_stmt|;
name|pmap
operator|->
name|pm_active
operator|&=
operator|~
operator|(
name|PCPU_GET
argument_list|(
name|cpumask
argument_list|)
operator|)
expr_stmt|;
name|PCPU_SET
argument_list|(
name|curpmap
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Copy the range specified by src_addr/len  * from the source map to the range dst_addr/len  * in the destination map.  *  * This routine is only advisory and need not do anything.  */
end_comment

begin_function
specifier|static
name|void
name|mmu_booke_copy
parameter_list|(
name|pmap_t
name|dst_pmap
parameter_list|,
name|pmap_t
name|src_pmap
parameter_list|,
name|vm_offset_t
name|dst_addr
parameter_list|,
name|vm_size_t
name|len
parameter_list|,
name|vm_offset_t
name|src_addr
parameter_list|)
block|{  }
end_function

begin_comment
comment|/*  * Set the physical protection on the specified range of this map as requested.  */
end_comment

begin_function
specifier|static
name|void
name|mmu_booke_protect
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|,
name|vm_offset_t
name|eva
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|vm_offset_t
name|va
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|pte_t
modifier|*
name|pte
decl_stmt|;
if|if
condition|(
operator|(
name|prot
operator|&
name|VM_PROT_READ
operator|)
operator|==
name|VM_PROT_NONE
condition|)
block|{
name|mmu_booke_remove
argument_list|(
name|mmu
argument_list|,
name|pmap
argument_list|,
name|sva
argument_list|,
name|eva
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|prot
operator|&
name|VM_PROT_WRITE
condition|)
return|return;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
for|for
control|(
name|va
operator|=
name|sva
init|;
name|va
operator|<
name|eva
condition|;
name|va
operator|+=
name|PAGE_SIZE
control|)
block|{
if|if
condition|(
operator|(
name|pte
operator|=
name|pte_find
argument_list|(
name|mmu
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|PTE_ISVALID
argument_list|(
name|pte
argument_list|)
condition|)
block|{
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|PTE_PA
argument_list|(
name|pte
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Handle modified pages. */
if|if
condition|(
name|PTE_ISMODIFIED
argument_list|(
name|pte
argument_list|)
condition|)
block|{
if|if
condition|(
name|track_modified_needed
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
condition|)
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* Referenced pages. */
if|if
condition|(
name|PTE_ISREFERENCED
argument_list|(
name|pte
argument_list|)
condition|)
name|vm_page_flag_set
argument_list|(
name|m
argument_list|,
name|PG_REFERENCED
argument_list|)
expr_stmt|;
comment|/* Flush mapping from TLB0. */
name|pte
operator|->
name|flags
operator|&=
operator|~
operator|(
name|PTE_UW
operator||
name|PTE_SW
operator||
name|PTE_MODIFIED
operator||
name|PTE_REFERENCED
operator|)
expr_stmt|;
name|tlb0_flush_entry
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Clear the write and modified bits in each of the given page's mappings.  */
end_comment

begin_function
specifier|static
name|void
name|mmu_booke_remove_write
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
name|pte_t
modifier|*
name|pte
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|vm_page_queue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
operator|(
name|PG_FICTITIOUS
operator||
name|PG_UNMANAGED
operator|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_WRITEABLE
operator|)
operator|==
literal|0
condition|)
return|return;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_link
argument_list|)
block|{
name|PMAP_LOCK
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pte
operator|=
name|pte_find
argument_list|(
name|mmu
argument_list|,
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|PTE_ISVALID
argument_list|(
name|pte
argument_list|)
condition|)
block|{
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|PTE_PA
argument_list|(
name|pte
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Handle modified pages. */
if|if
condition|(
name|PTE_ISMODIFIED
argument_list|(
name|pte
argument_list|)
condition|)
block|{
if|if
condition|(
name|track_modified_needed
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
condition|)
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* Referenced pages. */
if|if
condition|(
name|PTE_ISREFERENCED
argument_list|(
name|pte
argument_list|)
condition|)
name|vm_page_flag_set
argument_list|(
name|m
argument_list|,
name|PG_REFERENCED
argument_list|)
expr_stmt|;
comment|/* Flush mapping from TLB0. */
name|pte
operator|->
name|flags
operator|&=
operator|~
operator|(
name|PTE_UW
operator||
name|PTE_SW
operator||
name|PTE_MODIFIED
operator||
name|PTE_REFERENCED
operator|)
expr_stmt|;
name|tlb0_flush_entry
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
block|}
block|}
name|PMAP_UNLOCK
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|)
expr_stmt|;
block|}
name|vm_page_flag_clear
argument_list|(
name|m
argument_list|,
name|PG_WRITEABLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|mmu_booke_page_executable
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
name|pte_t
modifier|*
name|pte
decl_stmt|;
name|boolean_t
name|executable
decl_stmt|;
name|executable
operator|=
name|FALSE
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_link
argument_list|)
block|{
name|PMAP_LOCK
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pte_find
argument_list|(
name|mmu
argument_list|,
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|!=
name|NULL
operator|&&
name|PTE_ISVALID
argument_list|(
name|pte
argument_list|)
operator|&&
operator|(
name|pte
operator|->
name|flags
operator|&
name|PTE_UX
operator|)
condition|)
name|executable
operator|=
name|TRUE
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|executable
condition|)
break|break;
block|}
return|return
operator|(
name|executable
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Atomically extract and hold the physical page with the given  * pmap and virtual address pair if that mapping permits the given  * protection.  */
end_comment

begin_function
specifier|static
name|vm_page_t
name|mmu_booke_extract_and_hold
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|pte_t
modifier|*
name|pte
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|u_int32_t
name|pte_wbit
decl_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pte_find
argument_list|(
name|mmu
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pte
operator|!=
name|NULL
operator|)
operator|&&
name|PTE_ISVALID
argument_list|(
name|pte
argument_list|)
condition|)
block|{
if|if
condition|(
name|pmap
operator|==
name|kernel_pmap
condition|)
name|pte_wbit
operator|=
name|PTE_SW
expr_stmt|;
else|else
name|pte_wbit
operator|=
name|PTE_UW
expr_stmt|;
if|if
condition|(
operator|(
name|pte
operator|->
name|flags
operator|&
name|pte_wbit
operator|)
operator|||
operator|(
operator|(
name|prot
operator|&
name|VM_PROT_WRITE
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|PTE_PA
argument_list|(
name|pte
argument_list|)
argument_list|)
expr_stmt|;
name|vm_page_hold
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize a vm_page's machine-dependent fields.  */
end_comment

begin_function
specifier|static
name|void
name|mmu_booke_page_init
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * mmu_booke_zero_page_area zeros the specified hardware page by  * mapping it into virtual memory and using bzero to clear  * its contents.  *  * off and size must reside within a single page.  */
end_comment

begin_function
specifier|static
name|void
name|mmu_booke_zero_page_area
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|vm_offset_t
name|va
decl_stmt|;
comment|//debugf("mmu_booke_zero_page_area: s\n");
name|mtx_lock
argument_list|(
operator|&
name|zero_page_mutex
argument_list|)
expr_stmt|;
name|va
operator|=
name|zero_page_va
expr_stmt|;
name|mmu_booke_kenter
argument_list|(
name|mmu
argument_list|,
name|va
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|va
operator|+
name|off
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|mmu_booke_kremove
argument_list|(
name|mmu
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|zero_page_mutex
argument_list|)
expr_stmt|;
comment|//debugf("mmu_booke_zero_page_area: e\n");
block|}
end_function

begin_comment
comment|/*  * mmu_booke_zero_page zeros the specified hardware page.  */
end_comment

begin_function
specifier|static
name|void
name|mmu_booke_zero_page
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
comment|//debugf("mmu_booke_zero_page: s\n");
name|mmu_booke_zero_page_area
argument_list|(
name|mmu
argument_list|,
name|m
argument_list|,
literal|0
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
comment|//debugf("mmu_booke_zero_page: e\n");
block|}
end_function

begin_comment
comment|/*  * mmu_booke_copy_page copies the specified (machine independent) page by  * mapping the page into virtual memory and using memcopy to copy the page,  * one machine dependent page at a time.  */
end_comment

begin_function
specifier|static
name|void
name|mmu_booke_copy_page
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|vm_page_t
name|sm
parameter_list|,
name|vm_page_t
name|dm
parameter_list|)
block|{
name|vm_offset_t
name|sva
decl_stmt|,
name|dva
decl_stmt|;
comment|//debugf("mmu_booke_copy_page: s\n");
name|mtx_lock
argument_list|(
operator|&
name|copy_page_mutex
argument_list|)
expr_stmt|;
name|sva
operator|=
name|copy_page_src_va
expr_stmt|;
name|dva
operator|=
name|copy_page_dst_va
expr_stmt|;
name|mmu_booke_kenter
argument_list|(
name|mmu
argument_list|,
name|sva
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|sm
argument_list|)
argument_list|)
expr_stmt|;
name|mmu_booke_kenter
argument_list|(
name|mmu
argument_list|,
name|dva
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|caddr_t
operator|)
name|dva
argument_list|,
operator|(
name|caddr_t
operator|)
name|sva
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|mmu_booke_kremove
argument_list|(
name|mmu
argument_list|,
name|dva
argument_list|)
expr_stmt|;
name|mmu_booke_kremove
argument_list|(
name|mmu
argument_list|,
name|sva
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|copy_page_mutex
argument_list|)
expr_stmt|;
comment|//debugf("mmu_booke_copy_page: e\n");
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * Remove all pages from specified address space, this aids process exit  * speeds. This is much faster than mmu_booke_remove in the case of running  * down an entire address space. Only works for the current pmap.  */
end_comment

begin_endif
unit|void mmu_booke_remove_pages(pmap_t pmap) { }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * mmu_booke_zero_page_idle zeros the specified hardware page by mapping it  * into virtual memory and using bzero to clear its contents. This is intended  * to be called from the vm_pagezero process only and outside of Giant. No  * lock is required.  */
end_comment

begin_function
specifier|static
name|void
name|mmu_booke_zero_page_idle
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|vm_offset_t
name|va
decl_stmt|;
comment|//debugf("mmu_booke_zero_page_idle: s\n");
name|va
operator|=
name|zero_page_idle_va
expr_stmt|;
name|mmu_booke_kenter
argument_list|(
name|mmu
argument_list|,
name|va
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|mmu_booke_kremove
argument_list|(
name|mmu
argument_list|,
name|va
argument_list|)
expr_stmt|;
comment|//debugf("mmu_booke_zero_page_idle: e\n");
block|}
end_function

begin_comment
comment|/*  * Return whether or not the specified physical page was modified  * in any of physical maps.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|mmu_booke_is_modified
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|pte_t
modifier|*
name|pte
decl_stmt|;
name|pv_entry_t
name|pv
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|vm_page_queue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
operator|(
name|PG_FICTITIOUS
operator||
name|PG_UNMANAGED
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_link
argument_list|)
block|{
name|PMAP_LOCK
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pte
operator|=
name|pte_find
argument_list|(
name|mmu
argument_list|,
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|PTE_ISVALID
argument_list|(
name|pte
argument_list|)
condition|)
goto|goto
name|make_sure_to_unlock
goto|;
if|if
condition|(
operator|!
name|track_modified_needed
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
condition|)
goto|goto
name|make_sure_to_unlock
goto|;
if|if
condition|(
name|PTE_ISMODIFIED
argument_list|(
name|pte
argument_list|)
condition|)
block|{
name|PMAP_UNLOCK
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
name|make_sure_to_unlock
label|:
name|PMAP_UNLOCK
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return whether or not the specified virtual address is elgible  * for prefault.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|mmu_booke_is_prefaultable
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Clear the modify bits on the specified physical page.  */
end_comment

begin_function
specifier|static
name|void
name|mmu_booke_clear_modify
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|pte_t
modifier|*
name|pte
decl_stmt|;
name|pv_entry_t
name|pv
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|vm_page_queue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
operator|(
name|PG_FICTITIOUS
operator||
name|PG_UNMANAGED
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_link
argument_list|)
block|{
name|PMAP_LOCK
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pte
operator|=
name|pte_find
argument_list|(
name|mmu
argument_list|,
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|PTE_ISVALID
argument_list|(
name|pte
argument_list|)
condition|)
goto|goto
name|make_sure_to_unlock
goto|;
if|if
condition|(
name|pte
operator|->
name|flags
operator|&
operator|(
name|PTE_SW
operator||
name|PTE_UW
operator||
name|PTE_MODIFIED
operator|)
condition|)
block|{
name|pte
operator|->
name|flags
operator|&=
operator|~
operator|(
name|PTE_SW
operator||
name|PTE_UW
operator||
name|PTE_MODIFIED
operator||
name|PTE_REFERENCED
operator|)
expr_stmt|;
name|tlb0_flush_entry
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
block|}
block|}
name|make_sure_to_unlock
label|:
name|PMAP_UNLOCK
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Return a count of reference bits for a page, clearing those bits.  * It is not necessary for every reference bit to be cleared, but it  * is necessary that 0 only be returned when there are truly no  * reference bits set.  *  * XXX: The exact number of bits to check and clear is a matter that  * should be tested and standardized at some point in the future for  * optimal aging of shared pages.  */
end_comment

begin_function
specifier|static
name|int
name|mmu_booke_ts_referenced
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|pte_t
modifier|*
name|pte
decl_stmt|;
name|pv_entry_t
name|pv
decl_stmt|;
name|int
name|count
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|vm_page_queue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
operator|(
name|PG_FICTITIOUS
operator||
name|PG_UNMANAGED
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|count
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_link
argument_list|)
block|{
name|PMAP_LOCK
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pte
operator|=
name|pte_find
argument_list|(
name|mmu
argument_list|,
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|PTE_ISVALID
argument_list|(
name|pte
argument_list|)
condition|)
goto|goto
name|make_sure_to_unlock
goto|;
if|if
condition|(
operator|!
name|track_modified_needed
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
condition|)
goto|goto
name|make_sure_to_unlock
goto|;
if|if
condition|(
name|PTE_ISREFERENCED
argument_list|(
name|pte
argument_list|)
condition|)
block|{
name|pte
operator|->
name|flags
operator|&=
operator|~
name|PTE_REFERENCED
expr_stmt|;
name|tlb0_flush_entry
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|count
operator|>
literal|4
condition|)
block|{
name|PMAP_UNLOCK
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|make_sure_to_unlock
label|:
name|PMAP_UNLOCK
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Clear the reference bit on the specified physical page.  */
end_comment

begin_function
specifier|static
name|void
name|mmu_booke_clear_reference
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|pte_t
modifier|*
name|pte
decl_stmt|;
name|pv_entry_t
name|pv
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|vm_page_queue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
operator|(
name|PG_FICTITIOUS
operator||
name|PG_UNMANAGED
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_link
argument_list|)
block|{
name|PMAP_LOCK
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pte
operator|=
name|pte_find
argument_list|(
name|mmu
argument_list|,
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|PTE_ISVALID
argument_list|(
name|pte
argument_list|)
condition|)
goto|goto
name|make_sure_to_unlock
goto|;
if|if
condition|(
name|PTE_ISREFERENCED
argument_list|(
name|pte
argument_list|)
condition|)
block|{
name|pte
operator|->
name|flags
operator|&=
operator|~
name|PTE_REFERENCED
expr_stmt|;
name|tlb0_flush_entry
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
block|}
block|}
name|make_sure_to_unlock
label|:
name|PMAP_UNLOCK
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Change wiring attribute for a map/virtual-address pair.  */
end_comment

begin_function
specifier|static
name|void
name|mmu_booke_change_wiring
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|boolean_t
name|wired
parameter_list|)
block|{
name|pte_t
modifier|*
name|pte
decl_stmt|;
empty_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pte
operator|=
name|pte_find
argument_list|(
name|mmu
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|wired
condition|)
block|{
if|if
condition|(
operator|!
name|PTE_ISWIRED
argument_list|(
name|pte
argument_list|)
condition|)
block|{
name|pte
operator|->
name|flags
operator||=
name|PTE_WIRED
expr_stmt|;
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|PTE_ISWIRED
argument_list|(
name|pte
argument_list|)
condition|)
block|{
name|pte
operator|->
name|flags
operator|&=
operator|~
name|PTE_WIRED
expr_stmt|;
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
block|}
block|}
block|}
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return true if the pmap's pv is one of the first 16 pvs linked to from this  * page.  This count may be changed upwards or downwards in the future; it is  * only necessary that true be returned for a small subset of pmaps for proper  * page aging.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|mmu_booke_page_exists_quick
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|pmap_t
name|pmap
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
name|int
name|loops
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|vm_page_queue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
operator|(
name|PG_FICTITIOUS
operator||
name|PG_UNMANAGED
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|loops
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_link
argument_list|)
block|{
if|if
condition|(
name|pv
operator|->
name|pv_pmap
operator|==
name|pmap
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
if|if
condition|(
operator|++
name|loops
operator|>=
literal|16
condition|)
break|break;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the number of managed mappings to the given physical page that are  * wired.  */
end_comment

begin_function
specifier|static
name|int
name|mmu_booke_page_wired_mappings
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
name|pte_t
modifier|*
name|pte
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|count
operator|)
return|;
name|mtx_assert
argument_list|(
operator|&
name|vm_page_queue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_link
argument_list|)
block|{
name|PMAP_LOCK
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pte
operator|=
name|pte_find
argument_list|(
name|mmu
argument_list|,
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
if|if
condition|(
name|PTE_ISVALID
argument_list|(
name|pte
argument_list|)
operator|&&
name|PTE_ISWIRED
argument_list|(
name|pte
argument_list|)
condition|)
name|count
operator|++
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mmu_booke_dev_direct_mapped
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|vm_offset_t
name|pa
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
comment|/* 	 * This currently does not work for entries that 	 * overlap TLB1 entries. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tlb1_idx
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|tlb1_iomapped
argument_list|(
name|i
argument_list|,
name|pa
argument_list|,
name|size
argument_list|,
operator|&
name|va
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Map a set of physical memory pages into the kernel virtual address space.  * Return a pointer to where it is mapped. This routine is intended to be used  * for mapping device memory, NOT real memory.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|mmu_booke_mapdev
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|vm_offset_t
name|pa
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
name|uintptr_t
name|va
decl_stmt|;
name|va
operator|=
operator|(
name|pa
operator|>=
literal|0x80000000
operator|)
condition|?
name|pa
else|:
operator|(
literal|0xe2000000
operator|+
name|pa
operator|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Wiring VA=%x to PA=%x (size=%x), using TLB1[%d]\n"
argument_list|,
name|va
argument_list|,
name|pa
argument_list|,
name|size
argument_list|,
name|tlb1_idx
argument_list|)
expr_stmt|;
name|tlb1_set_entry
argument_list|(
name|va
argument_list|,
name|pa
argument_list|,
name|size
argument_list|,
name|_TLB_ENTRY_IO
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|void
operator|*
operator|)
name|va
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * 'Unmap' a range mapped by mmu_booke_mapdev().  */
end_comment

begin_function
specifier|static
name|void
name|mmu_booke_unmapdev
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
name|vm_offset_t
name|base
decl_stmt|,
name|offset
decl_stmt|;
comment|//debugf("mmu_booke_unmapdev: s (va = 0x%08x)\n", va);
comment|/* 	 * Unmap only if this is inside kernel virtual space. 	 */
if|if
condition|(
operator|(
name|va
operator|>=
name|VM_MIN_KERNEL_ADDRESS
operator|)
operator|&&
operator|(
name|va
operator|<=
name|VM_MAX_KERNEL_ADDRESS
operator|)
condition|)
block|{
name|base
operator|=
name|trunc_page
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|offset
operator|=
name|va
operator|&
name|PAGE_MASK
expr_stmt|;
name|size
operator|=
name|roundup
argument_list|(
name|offset
operator|+
name|size
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|kernel_map
argument_list|,
name|base
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
comment|//debugf("mmu_booke_unmapdev: e\n");
block|}
end_function

begin_comment
comment|/*  * mmu_booke_object_init_pt preloads the ptes for a given object  * into the specified pmap. This eliminates the blast of soft  * faults on process startup and immediately after an mmap.  */
end_comment

begin_function
specifier|static
name|void
name|mmu_booke_object_init_pt
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|,
name|vm_object_t
name|object
parameter_list|,
name|vm_pindex_t
name|pindex
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
name|VM_OBJECT_LOCK_ASSERT
argument_list|(
name|object
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|object
operator|->
name|type
operator|==
name|OBJT_DEVICE
argument_list|,
operator|(
literal|"mmu_booke_object_init_pt: non-device object"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Perform the pmap work for mincore.  */
end_comment

begin_function
specifier|static
name|int
name|mmu_booke_mincore
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|)
block|{
name|TODO
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|vm_offset_t
name|mmu_booke_addr_hint
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|vm_object_t
name|object
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
return|return
operator|(
name|va
operator|)
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************/
end_comment

begin_comment
comment|/* TID handling */
end_comment

begin_comment
comment|/**************************************************************************/
end_comment

begin_comment
comment|/*  * Flush all entries from TLB0 matching given tid.  */
end_comment

begin_function
specifier|static
name|void
name|tid_flush
parameter_list|(
name|tlbtid_t
name|tid
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|entryidx
decl_stmt|,
name|way
decl_stmt|;
comment|//debugf("tid_flush: s (tid = %d)\n", tid);
name|mtx_lock_spin
argument_list|(
operator|&
name|tlb0_mutex
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TLB0_SIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|MAS1_GETTID
argument_list|(
name|tlb0
index|[
name|i
index|]
operator|.
name|mas1
argument_list|)
operator|==
name|tid
condition|)
block|{
name|way
operator|=
name|i
operator|/
name|TLB0_ENTRIES_PER_WAY
expr_stmt|;
name|entryidx
operator|=
name|i
operator|-
operator|(
name|way
operator|*
name|TLB0_ENTRIES_PER_WAY
operator|)
expr_stmt|;
comment|//debugf("tid_flush: inval tlb0 entry %d\n", i);
name|tlb0_inval_entry
argument_list|(
name|entryidx
operator|<<
name|MAS2_TLB0_ENTRY_IDX_SHIFT
argument_list|,
name|way
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|tlb0_mutex
argument_list|)
expr_stmt|;
comment|//debugf("tid_flush: e\n");
block|}
end_function

begin_comment
comment|/*  * Allocate a TID. If necessary, steal one from someone else.  * The new TID is flushed from the TLB before returning.  */
end_comment

begin_function
specifier|static
name|tlbtid_t
name|tid_alloc
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
name|tlbtid_t
name|tid
decl_stmt|;
specifier|static
name|tlbtid_t
name|next_tid
init|=
name|TID_MIN
decl_stmt|;
comment|//struct thread *td;
comment|//struct proc *p;
comment|//td = PCPU_GET(curthread);
comment|//p = td->td_proc;
comment|//debugf("tid_alloc: s (pmap = 0x%08x)\n", (u_int32_t)pmap);
comment|//printf("tid_alloc: proc %d '%s'\n", p->p_pid, p->p_comm);
name|KASSERT
argument_list|(
operator|(
name|pmap
operator|!=
name|kernel_pmap
operator|)
argument_list|,
operator|(
literal|"tid_alloc: kernel pmap"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Find a likely TID, allocate unused if possible, 	 * skip reserved entries. 	 */
name|tid
operator|=
name|next_tid
expr_stmt|;
while|while
condition|(
name|tidbusy
index|[
name|tid
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|tid
operator|==
name|next_tid
condition|)
break|break;
if|if
condition|(
name|tid
operator|==
name|TID_MAX
condition|)
name|tid
operator|=
name|TID_MIN
expr_stmt|;
else|else
name|tid
operator|++
expr_stmt|;
block|}
comment|/* Now clean it out */
name|tid_flush
argument_list|(
name|tid
argument_list|)
expr_stmt|;
comment|/* If we are stealing pmap then clear its tid */
if|if
condition|(
name|tidbusy
index|[
name|tid
index|]
condition|)
block|{
comment|//debugf("warning: stealing tid %d\n", tid);
name|tidbusy
index|[
name|tid
index|]
operator|->
name|pm_tid
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Calculate next tid */
if|if
condition|(
name|tid
operator|==
name|TID_MAX
condition|)
name|next_tid
operator|=
name|TID_MIN
expr_stmt|;
else|else
name|next_tid
operator|=
name|tid
operator|+
literal|1
expr_stmt|;
name|tidbusy
index|[
name|tid
index|]
operator|=
name|pmap
expr_stmt|;
name|pmap
operator|->
name|pm_tid
operator|=
name|tid
expr_stmt|;
comment|//debugf("tid_alloc: e (%02d next = %02d)\n", tid, next_tid);
return|return
operator|(
name|tid
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * Free this pmap's TID.  */
end_comment

begin_ifdef
unit|static void tid_free(pmap_t pmap) { 	tlbtid_t oldtid;  	oldtid = pmap->pm_tid;  	if (oldtid == 0) { 		panic("tid_free: freeing kernel tid"); 	}
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_endif
unit|if (tidbusy[oldtid] == 0) 		debugf("tid_free: freeing free tid %d\n", oldtid); 	if (tidbusy[oldtid] != pmap) { 		debugf("tid_free: freeing someone esle's tid\n " 		       "tidbusy[%d] = 0x%08x pmap = 0x%08x\n", 		       oldtid, (u_int32_t)tidbusy[oldtid], (u_int32_t)pmap); 	}
endif|#
directive|endif
end_endif

begin_endif
unit|tidbusy[oldtid] = NULL; 	tid_flush(oldtid); }
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_if
if|#
directive|if
name|DEBUG
end_if

begin_endif
unit|static void tid_print_busy(void) { 	int i;  	for (i = 0; i< TID_MAX; i++) { 		debugf("tid %d = pmap 0x%08x", i, (u_int32_t)tidbusy[i]); 		if (tidbusy[i]) 			debugf(" pmap->tid = %d", tidbusy[i]->pm_tid); 		debugf("\n"); 	}  }
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**************************************************************************/
end_comment

begin_comment
comment|/* TLB0 handling */
end_comment

begin_comment
comment|/**************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|tlb_print_entry
parameter_list|(
name|int
name|i
parameter_list|,
name|u_int32_t
name|mas1
parameter_list|,
name|u_int32_t
name|mas2
parameter_list|,
name|u_int32_t
name|mas3
parameter_list|,
name|u_int32_t
name|mas7
parameter_list|)
block|{
name|int
name|as
decl_stmt|;
name|char
name|desc
index|[
literal|3
index|]
decl_stmt|;
name|tlbtid_t
name|tid
decl_stmt|;
name|vm_size_t
name|size
decl_stmt|;
name|unsigned
name|int
name|tsize
decl_stmt|;
name|desc
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|mas1
operator|&
name|MAS1_VALID
condition|)
name|desc
index|[
literal|0
index|]
operator|=
literal|'V'
expr_stmt|;
else|else
name|desc
index|[
literal|0
index|]
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|mas1
operator|&
name|MAS1_IPROT
condition|)
name|desc
index|[
literal|1
index|]
operator|=
literal|'P'
expr_stmt|;
else|else
name|desc
index|[
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
name|as
operator|=
operator|(
name|mas1
operator|&
name|MAS1_TS
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|tid
operator|=
name|MAS1_GETTID
argument_list|(
name|mas1
argument_list|)
expr_stmt|;
name|tsize
operator|=
operator|(
name|mas1
operator|&
name|MAS1_TSIZE_MASK
operator|)
operator|>>
name|MAS1_TSIZE_SHIFT
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tsize
condition|)
name|size
operator|=
name|tsize2size
argument_list|(
name|tsize
argument_list|)
expr_stmt|;
name|debugf
argument_list|(
literal|"%3d: (%s) [AS=%d] "
literal|"sz = 0x%08x tsz = %d tid = %d mas1 = 0x%08x "
literal|"mas2(va) = 0x%08x mas3(pa) = 0x%08x mas7 = 0x%08x\n"
argument_list|,
name|i
argument_list|,
name|desc
argument_list|,
name|as
argument_list|,
name|size
argument_list|,
name|tsize
argument_list|,
name|tid
argument_list|,
name|mas1
argument_list|,
name|mas2
argument_list|,
name|mas3
argument_list|,
name|mas7
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert TLB0 va and way number to tlb0[] table index. */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|int
name|tlb0_tableidx
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|unsigned
name|int
name|way
parameter_list|)
block|{
name|unsigned
name|int
name|idx
decl_stmt|;
name|idx
operator|=
operator|(
name|way
operator|*
name|TLB0_ENTRIES_PER_WAY
operator|)
expr_stmt|;
name|idx
operator|+=
operator|(
name|va
operator|&
name|MAS2_TLB0_ENTRY_IDX_MASK
operator|)
operator|>>
name|MAS2_TLB0_ENTRY_IDX_SHIFT
expr_stmt|;
return|return
operator|(
name|idx
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write given entry to TLB0 hardware.  * Use 32 bit pa, clear 4 high-order bits of RPN (mas7).  */
end_comment

begin_function
specifier|static
name|void
name|tlb0_write_entry
parameter_list|(
name|unsigned
name|int
name|idx
parameter_list|,
name|unsigned
name|int
name|way
parameter_list|)
block|{
name|u_int32_t
name|mas0
decl_stmt|,
name|mas7
decl_stmt|,
name|nv
decl_stmt|;
comment|/* Clear high order RPN bits. */
name|mas7
operator|=
literal|0
expr_stmt|;
comment|/* Preserve NV. */
name|mas0
operator|=
name|mfspr
argument_list|(
name|SPR_MAS0
argument_list|)
expr_stmt|;
name|nv
operator|=
name|mas0
operator|&
operator|(
name|TLB0_NWAYS
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* Select entry. */
name|mas0
operator|=
name|MAS0_TLBSEL
argument_list|(
literal|0
argument_list|)
operator||
name|MAS0_ESEL
argument_list|(
name|way
argument_list|)
operator||
name|nv
expr_stmt|;
comment|//debugf("tlb0_write_entry: s (idx=%d way=%d mas0=0x%08x "
comment|//		"mas1=0x%08x mas2=0x%08x mas3=0x%08x)\n",
comment|//		idx, way, mas0, tlb0[idx].mas1,
comment|//		tlb0[idx].mas2, tlb0[idx].mas3);
name|mtspr
argument_list|(
name|SPR_MAS0
argument_list|,
name|mas0
argument_list|)
expr_stmt|;
asm|__asm volatile("isync");
name|mtspr
argument_list|(
name|SPR_MAS1
argument_list|,
name|tlb0
index|[
name|idx
index|]
operator|.
name|mas1
argument_list|)
expr_stmt|;
asm|__asm volatile("isync");
name|mtspr
argument_list|(
name|SPR_MAS2
argument_list|,
name|tlb0
index|[
name|idx
index|]
operator|.
name|mas2
argument_list|)
expr_stmt|;
asm|__asm volatile("isync");
name|mtspr
argument_list|(
name|SPR_MAS3
argument_list|,
name|tlb0
index|[
name|idx
index|]
operator|.
name|mas3
argument_list|)
expr_stmt|;
asm|__asm volatile("isync");
name|mtspr
argument_list|(
name|SPR_MAS7
argument_list|,
name|mas7
argument_list|)
expr_stmt|;
asm|__asm volatile("isync; tlbwe; isync; msync");
comment|//debugf("tlb0_write_entry: e\n");
block|}
end_function

begin_comment
comment|/*  * Invalidate TLB0 entry, clear correspondig tlb0 table element.  */
end_comment

begin_function
specifier|static
name|void
name|tlb0_inval_entry
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|unsigned
name|int
name|way
parameter_list|)
block|{
name|int
name|idx
init|=
name|tlb0_tableidx
argument_list|(
name|va
argument_list|,
name|way
argument_list|)
decl_stmt|;
comment|//debugf("tlb0_inval_entry: s (va=0x%08x way=%d idx=%d)\n",
comment|//		va, way, idx);
name|tlb0
index|[
name|idx
index|]
operator|.
name|mas1
operator|=
literal|1
operator|<<
name|MAS1_TSIZE_SHIFT
expr_stmt|;
comment|/* !MAS1_VALID */
name|tlb0
index|[
name|idx
index|]
operator|.
name|mas2
operator|=
name|va
operator|&
name|MAS2_EPN
expr_stmt|;
name|tlb0
index|[
name|idx
index|]
operator|.
name|mas3
operator|=
literal|0
expr_stmt|;
name|tlb0_write_entry
argument_list|(
name|idx
argument_list|,
name|way
argument_list|)
expr_stmt|;
comment|//debugf("tlb0_inval_entry: e\n");
block|}
end_function

begin_comment
comment|/*  * Invalidate TLB0 entry that corresponds to pmap/va.  */
end_comment

begin_function
specifier|static
name|void
name|tlb0_flush_entry
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|int
name|idx
decl_stmt|,
name|way
decl_stmt|;
comment|//debugf("tlb0_flush_entry: s (pmap=0x%08x va=0x%08x)\n",
comment|//		(u_int32_t)pmap, va);
name|mtx_lock_spin
argument_list|(
operator|&
name|tlb0_mutex
argument_list|)
expr_stmt|;
comment|/* Check all TLB0 ways. */
for|for
control|(
name|way
operator|=
literal|0
init|;
name|way
operator|<
name|TLB0_NWAYS
condition|;
name|way
operator|++
control|)
block|{
name|idx
operator|=
name|tlb0_tableidx
argument_list|(
name|va
argument_list|,
name|way
argument_list|)
expr_stmt|;
comment|/* Invalidate only if entry matches va and pmap tid. */
if|if
condition|(
operator|(
operator|(
name|MAS1_GETTID
argument_list|(
name|tlb0
index|[
name|idx
index|]
operator|.
name|mas1
argument_list|)
operator|==
name|pmap
operator|->
name|pm_tid
operator|)
operator|&&
operator|(
operator|(
name|tlb0
index|[
name|idx
index|]
operator|.
name|mas2
operator|&
name|MAS2_EPN
operator|)
operator|==
name|va
operator|)
operator|)
condition|)
block|{
name|tlb0_inval_entry
argument_list|(
name|va
argument_list|,
name|way
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|tlb0_mutex
argument_list|)
expr_stmt|;
comment|//debugf("tlb0_flush_entry: e\n");
block|}
end_function

begin_comment
comment|/* Clean TLB0 hardware and tlb0[] table. */
end_comment

begin_function
specifier|static
name|void
name|tlb0_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|entryidx
decl_stmt|,
name|way
decl_stmt|;
name|debugf
argument_list|(
literal|"tlb0_init: TLB0_SIZE = %d TLB0_NWAYS = %d\n"
argument_list|,
name|TLB0_SIZE
argument_list|,
name|TLB0_NWAYS
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|tlb0_mutex
argument_list|)
expr_stmt|;
for|for
control|(
name|way
operator|=
literal|0
init|;
name|way
operator|<
name|TLB0_NWAYS
condition|;
name|way
operator|++
control|)
block|{
for|for
control|(
name|entryidx
operator|=
literal|0
init|;
name|entryidx
operator|<
name|TLB0_ENTRIES_PER_WAY
condition|;
name|entryidx
operator|++
control|)
block|{
name|tlb0_inval_entry
argument_list|(
name|entryidx
operator|<<
name|MAS2_TLB0_ENTRY_IDX_SHIFT
argument_list|,
name|way
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|tlb0_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_if
if|#
directive|if
name|DEBUG
end_if

begin_comment
comment|/* Print out tlb0 entries for given va. */
end_comment

begin_comment
unit|static void tlb0_print_tlbentries_va(vm_offset_t va) { 	u_int32_t mas0, mas1, mas2, mas3, mas7; 	int way, idx;  	debugf("TLB0 entries for va = 0x%08x:\n", va); 	for (way = 0; way< TLB0_NWAYS; way ++) { 		mas0 = MAS0_TLBSEL(0) | MAS0_ESEL(way); 		mtspr(SPR_MAS0, mas0); 		__asm volatile("isync");  		mas2 = va& MAS2_EPN; 		mtspr(SPR_MAS2, mas2); 		__asm volatile("isync; tlbre");  		mas1 = mfspr(SPR_MAS1); 		mas2 = mfspr(SPR_MAS2); 		mas3 = mfspr(SPR_MAS3); 		mas7 = mfspr(SPR_MAS7);  		idx = tlb0_tableidx(va, way); 		tlb_print_entry(idx, mas1, mas2, mas3, mas7); 	} }
comment|/* Print out contents of the MAS registers for each TLB0 entry */
end_comment

begin_comment
unit|static void tlb0_print_tlbentries(void) { 	u_int32_t mas0, mas1, mas2, mas3, mas7; 	int entryidx, way, idx;  	debugf("TLB0 entries:\n"); 	for (way = 0; way< TLB0_NWAYS; way ++) { 		for (entryidx = 0; entryidx< TLB0_ENTRIES_PER_WAY; entryidx++) {  			mas0 = MAS0_TLBSEL(0) | MAS0_ESEL(way); 			mtspr(SPR_MAS0, mas0); 			__asm volatile("isync");  			mas2 = entryidx<< MAS2_TLB0_ENTRY_IDX_SHIFT; 			mtspr(SPR_MAS2, mas2);  			__asm volatile("isync; tlbre");  			mas1 = mfspr(SPR_MAS1); 			mas2 = mfspr(SPR_MAS2); 			mas3 = mfspr(SPR_MAS3); 			mas7 = mfspr(SPR_MAS7);  			idx = tlb0_tableidx(mas2, way); 			tlb_print_entry(idx, mas1, mas2, mas3, mas7); 		} 	} }
comment|/* Print out kernel tlb0[] table. */
end_comment

begin_endif
unit|static void tlb0_print_entries(void) { 	int i;  	debugf("tlb0[] table entries:\n"); 	for (i = 0; i< TLB0_SIZE; i++) { 		tlb_print_entry(i, tlb0[i].mas1, 				tlb0[i].mas2, tlb0[i].mas3, 0); 	} }
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**************************************************************************/
end_comment

begin_comment
comment|/* TLB1 handling */
end_comment

begin_comment
comment|/**************************************************************************/
end_comment

begin_comment
comment|/*  * Write given entry to TLB1 hardware.  * Use 32 bit pa, clear 4 high-order bits of RPN (mas7).  */
end_comment

begin_function
specifier|static
name|void
name|tlb1_write_entry
parameter_list|(
name|unsigned
name|int
name|idx
parameter_list|)
block|{
name|u_int32_t
name|mas0
decl_stmt|,
name|mas7
decl_stmt|;
comment|//debugf("tlb1_write_entry: s\n");
comment|/* Clear high order RPN bits */
name|mas7
operator|=
literal|0
expr_stmt|;
comment|/* Select entry */
name|mas0
operator|=
name|MAS0_TLBSEL
argument_list|(
literal|1
argument_list|)
operator||
name|MAS0_ESEL
argument_list|(
name|idx
argument_list|)
expr_stmt|;
comment|//debugf("tlb1_write_entry: mas0 = 0x%08x\n", mas0);
name|mtspr
argument_list|(
name|SPR_MAS0
argument_list|,
name|mas0
argument_list|)
expr_stmt|;
asm|__asm volatile("isync");
name|mtspr
argument_list|(
name|SPR_MAS1
argument_list|,
name|tlb1
index|[
name|idx
index|]
operator|.
name|mas1
argument_list|)
expr_stmt|;
asm|__asm volatile("isync");
name|mtspr
argument_list|(
name|SPR_MAS2
argument_list|,
name|tlb1
index|[
name|idx
index|]
operator|.
name|mas2
argument_list|)
expr_stmt|;
asm|__asm volatile("isync");
name|mtspr
argument_list|(
name|SPR_MAS3
argument_list|,
name|tlb1
index|[
name|idx
index|]
operator|.
name|mas3
argument_list|)
expr_stmt|;
asm|__asm volatile("isync");
name|mtspr
argument_list|(
name|SPR_MAS7
argument_list|,
name|mas7
argument_list|)
expr_stmt|;
asm|__asm volatile("isync; tlbwe; isync; msync");
comment|//debugf("tlb1_write_entry: e\n");;
block|}
end_function

begin_comment
comment|/*  * Return the largest uint value log such that 2^log<= num.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|ilog2
parameter_list|(
name|unsigned
name|int
name|num
parameter_list|)
block|{
name|int
name|lz
decl_stmt|;
asm|__asm ("cntlzw %0, %1" : "=r" (lz) : "r" (num));
return|return
operator|(
literal|31
operator|-
name|lz
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert TLB TSIZE value to mapped region size.  */
end_comment

begin_function
specifier|static
name|vm_size_t
name|tsize2size
parameter_list|(
name|unsigned
name|int
name|tsize
parameter_list|)
block|{
comment|/* 	 * size = 4^tsize KB 	 * size = 4^tsize * 2^10 = 2^(2 * tsize - 10) 	 */
return|return
operator|(
operator|(
literal|1
operator|<<
operator|(
literal|2
operator|*
name|tsize
operator|)
operator|)
operator|*
literal|1024
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert region size (must be power of 4) to TLB TSIZE value.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|size2tsize
parameter_list|(
name|vm_size_t
name|size
parameter_list|)
block|{
comment|/* 	 * tsize = log2(size) / 2 - 5 	 */
return|return
operator|(
name|ilog2
argument_list|(
name|size
argument_list|)
operator|/
literal|2
operator|-
literal|5
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Setup entry in a sw tlb1 table, write entry to TLB1 hardware.  * This routine is used for low level operations on the TLB1,  * for creating temporaray as well as permanent mappings (tlb_set_entry).  *  * We assume kernel mappings only, thus all entries created have supervisor  * permission bits set nad user permission bits cleared.  *  * Provided mapping size must be a power of 4.  * Mapping flags must be a combination of MAS2_[WIMG].  * Entry TID is set to _tid which must not exceed 8 bit value.  * Entry TS is set to either 0 or MAS1_TS based on provided _ts.  */
end_comment

begin_function
specifier|static
name|void
name|__tlb1_set_entry
parameter_list|(
name|unsigned
name|int
name|idx
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_offset_t
name|pa
parameter_list|,
name|vm_size_t
name|size
parameter_list|,
name|u_int32_t
name|flags
parameter_list|,
name|unsigned
name|int
name|_tid
parameter_list|,
name|unsigned
name|int
name|_ts
parameter_list|)
block|{
name|int
name|tsize
decl_stmt|;
name|u_int32_t
name|ts
decl_stmt|,
name|tid
decl_stmt|;
comment|//debugf("__tlb1_set_entry: s (idx = %d va = 0x%08x pa = 0x%08x "
comment|//		"size = 0x%08x flags = 0x%08x _tid = %d _ts = %d\n",
comment|//		idx, va, pa, size, flags, _tid, _ts);
comment|/* Convert size to TSIZE */
name|tsize
operator|=
name|size2tsize
argument_list|(
name|size
argument_list|)
expr_stmt|;
comment|//debugf("__tlb1_set_entry: tsize = %d\n", tsize);
name|tid
operator|=
operator|(
name|_tid
operator|<<
name|MAS1_TID_SHIFT
operator|)
operator|&
name|MAS1_TID_MASK
expr_stmt|;
name|ts
operator|=
operator|(
name|_ts
operator|)
condition|?
name|MAS1_TS
else|:
literal|0
expr_stmt|;
name|tlb1
index|[
name|idx
index|]
operator|.
name|mas1
operator|=
name|MAS1_VALID
operator||
name|MAS1_IPROT
operator||
name|ts
operator||
name|tid
expr_stmt|;
name|tlb1
index|[
name|idx
index|]
operator|.
name|mas1
operator||=
operator|(
operator|(
name|tsize
operator|<<
name|MAS1_TSIZE_SHIFT
operator|)
operator|&
name|MAS1_TSIZE_MASK
operator|)
expr_stmt|;
name|tlb1
index|[
name|idx
index|]
operator|.
name|mas2
operator|=
operator|(
name|va
operator|&
name|MAS2_EPN
operator|)
operator||
name|flags
expr_stmt|;
comment|/* Set supervisor rwx permission bits */
name|tlb1
index|[
name|idx
index|]
operator|.
name|mas3
operator|=
operator|(
name|pa
operator|&
name|MAS3_RPN
operator|)
operator||
name|MAS3_SR
operator||
name|MAS3_SW
operator||
name|MAS3_SX
expr_stmt|;
comment|//debugf("__tlb1_set_entry: mas1 = %08x mas2 = %08x mas3 = 0x%08x\n",
comment|//		tlb1[idx].mas1, tlb1[idx].mas2, tlb1[idx].mas3);
name|tlb1_write_entry
argument_list|(
name|idx
argument_list|)
expr_stmt|;
comment|//debugf("__tlb1_set_entry: e\n");
block|}
end_function

begin_comment
comment|/*  * Register permanent kernel mapping in TLB1.  *  * Entries are created starting from index 0 (current free entry is  * kept in tlb1_idx) and are not supposed to be invalidated.  */
end_comment

begin_function
specifier|static
name|int
name|tlb1_set_entry
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_offset_t
name|pa
parameter_list|,
name|vm_size_t
name|size
parameter_list|,
name|u_int32_t
name|flags
parameter_list|)
block|{
comment|//debugf("tlb1_set_entry: s (tlb1_idx = %d va = 0x%08x pa = 0x%08x "
comment|//		"size = 0x%08x flags = 0x%08x\n",
comment|//		tlb1_idx, va, pa, size, flags);
if|if
condition|(
name|tlb1_idx
operator|>=
name|TLB1_SIZE
condition|)
block|{
comment|//debugf("tlb1_set_entry: e (tlb1 full!)\n");
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* TS = 0, TID = 0 */
name|__tlb1_set_entry
argument_list|(
name|tlb1_idx
operator|++
argument_list|,
name|va
argument_list|,
name|pa
argument_list|,
name|size
argument_list|,
name|flags
argument_list|,
name|KERNEL_TID
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|//debugf("tlb1_set_entry: e\n");
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Invalidate TLB1 entry, clear correspondig tlb1 table element.  * This routine is used to clear temporary entries created  * early in a locore.S or through the use of __tlb1_set_entry().  */
end_comment

begin_function
name|void
name|tlb1_inval_entry
parameter_list|(
name|unsigned
name|int
name|idx
parameter_list|)
block|{
name|vm_offset_t
name|va
decl_stmt|;
name|va
operator|=
name|tlb1
index|[
name|idx
index|]
operator|.
name|mas2
operator|&
name|MAS2_EPN
expr_stmt|;
name|tlb1
index|[
name|idx
index|]
operator|.
name|mas1
operator|=
literal|0
expr_stmt|;
comment|/* !MAS1_VALID */
name|tlb1
index|[
name|idx
index|]
operator|.
name|mas2
operator|=
literal|0
expr_stmt|;
name|tlb1
index|[
name|idx
index|]
operator|.
name|mas3
operator|=
literal|0
expr_stmt|;
name|tlb1_write_entry
argument_list|(
name|idx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|tlb1_entry_size_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|vm_size_t
modifier|*
name|sza
decl_stmt|;
specifier|const
name|vm_size_t
modifier|*
name|szb
decl_stmt|;
name|sza
operator|=
name|a
expr_stmt|;
name|szb
operator|=
name|b
expr_stmt|;
if|if
condition|(
operator|*
name|sza
operator|>
operator|*
name|szb
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
operator|*
name|sza
operator|<
operator|*
name|szb
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Mapin contiguous RAM region into the TLB1 using maximum of  * KERNEL_REGION_MAX_TLB_ENTRIES entries.  *  * If necessarry round up last entry size and return total size  * used by all allocated entries.  */
end_comment

begin_function
name|vm_size_t
name|tlb1_mapin_region
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_offset_t
name|pa
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
name|vm_size_t
name|entry_size
index|[
name|KERNEL_REGION_MAX_TLB_ENTRIES
index|]
decl_stmt|;
name|vm_size_t
name|mapped_size
decl_stmt|,
name|sz
decl_stmt|,
name|esz
decl_stmt|;
name|unsigned
name|int
name|log
decl_stmt|;
name|int
name|i
decl_stmt|;
name|debugf
argument_list|(
literal|"tlb1_mapin_region:\n"
argument_list|)
expr_stmt|;
name|debugf
argument_list|(
literal|" region size = 0x%08x va = 0x%08x pa = 0x%08x\n"
argument_list|,
name|size
argument_list|,
name|va
argument_list|,
name|pa
argument_list|)
expr_stmt|;
name|mapped_size
operator|=
literal|0
expr_stmt|;
name|sz
operator|=
name|size
expr_stmt|;
name|memset
argument_list|(
name|entry_size
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|entry_size
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Calculate entry sizes. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|KERNEL_REGION_MAX_TLB_ENTRIES
operator|&&
name|sz
operator|>
literal|0
condition|;
name|i
operator|++
control|)
block|{
comment|/* Largest region that is power of 4 and fits within size */
name|log
operator|=
name|ilog2
argument_list|(
name|sz
argument_list|)
operator|/
literal|2
expr_stmt|;
name|esz
operator|=
literal|1
operator|<<
operator|(
literal|2
operator|*
name|log
operator|)
expr_stmt|;
comment|/* Minimum region size is 4KB */
if|if
condition|(
name|esz
operator|<
operator|(
literal|1
operator|<<
literal|12
operator|)
condition|)
name|esz
operator|=
literal|1
operator|<<
literal|12
expr_stmt|;
comment|/* If this is last entry cover remaining size. */
if|if
condition|(
name|i
operator|==
name|KERNEL_REGION_MAX_TLB_ENTRIES
operator|-
literal|1
condition|)
block|{
while|while
condition|(
name|esz
operator|<
name|sz
condition|)
name|esz
operator|=
name|esz
operator|<<
literal|2
expr_stmt|;
block|}
name|entry_size
index|[
name|i
index|]
operator|=
name|esz
expr_stmt|;
name|mapped_size
operator|+=
name|esz
expr_stmt|;
if|if
condition|(
name|esz
operator|<
name|sz
condition|)
name|sz
operator|-=
name|esz
expr_stmt|;
else|else
name|sz
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Sort entry sizes, required to get proper entry address alignment. */
name|qsort
argument_list|(
name|entry_size
argument_list|,
name|KERNEL_REGION_MAX_TLB_ENTRIES
argument_list|,
sizeof|sizeof
argument_list|(
name|vm_size_t
argument_list|)
argument_list|,
name|tlb1_entry_size_cmp
argument_list|)
expr_stmt|;
comment|/* Load TLB1 entries. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|KERNEL_REGION_MAX_TLB_ENTRIES
condition|;
name|i
operator|++
control|)
block|{
name|esz
operator|=
name|entry_size
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|esz
condition|)
break|break;
name|debugf
argument_list|(
literal|"  entry %d: sz  = 0x%08x (va = 0x%08x pa = 0x%08x)\n"
argument_list|,
name|tlb1_idx
argument_list|,
name|esz
argument_list|,
name|va
argument_list|,
name|pa
argument_list|)
expr_stmt|;
name|tlb1_set_entry
argument_list|(
name|va
argument_list|,
name|pa
argument_list|,
name|esz
argument_list|,
name|_TLB_ENTRY_MEM
argument_list|)
expr_stmt|;
name|va
operator|+=
name|esz
expr_stmt|;
name|pa
operator|+=
name|esz
expr_stmt|;
block|}
name|debugf
argument_list|(
literal|" mapped size 0x%08x (wasted space 0x%08x)\n"
argument_list|,
name|mapped_size
argument_list|,
name|mapped_size
operator|-
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|mapped_size
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * TLB1 initialization routine, to be called after the very first  * assembler level setup done in locore.S.  */
end_comment

begin_function
name|void
name|tlb1_init
parameter_list|(
name|vm_offset_t
name|ccsrbar
parameter_list|)
block|{
name|uint32_t
name|mas0
decl_stmt|;
comment|/* TBL1[1] is used to map the kernel. Save that entry. */
name|mas0
operator|=
name|MAS0_TLBSEL
argument_list|(
literal|1
argument_list|)
operator||
name|MAS0_ESEL
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|mtspr
argument_list|(
name|SPR_MAS0
argument_list|,
name|mas0
argument_list|)
expr_stmt|;
asm|__asm __volatile("isync; tlbre");
name|tlb1
index|[
literal|1
index|]
operator|.
name|mas1
operator|=
name|mfspr
argument_list|(
name|SPR_MAS1
argument_list|)
expr_stmt|;
name|tlb1
index|[
literal|1
index|]
operator|.
name|mas2
operator|=
name|mfspr
argument_list|(
name|SPR_MAS2
argument_list|)
expr_stmt|;
name|tlb1
index|[
literal|1
index|]
operator|.
name|mas3
operator|=
name|mfspr
argument_list|(
name|SPR_MAS3
argument_list|)
expr_stmt|;
comment|/* Mapin CCSRBAR in TLB1[0] */
name|__tlb1_set_entry
argument_list|(
literal|0
argument_list|,
name|CCSRBAR_VA
argument_list|,
name|ccsrbar
argument_list|,
name|CCSRBAR_SIZE
argument_list|,
name|_TLB_ENTRY_IO
argument_list|,
name|KERNEL_TID
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Setup TLB miss defaults */
name|set_mas4_defaults
argument_list|()
expr_stmt|;
comment|/* Reset next available TLB1 entry index. */
name|tlb1_idx
operator|=
literal|2
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Setup MAS4 defaults.  * These values are loaded to MAS0-2 on a TLB miss.  */
end_comment

begin_function
specifier|static
name|void
name|set_mas4_defaults
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int32_t
name|mas4
decl_stmt|;
comment|/* Defaults: TLB0, PID0, TSIZED=4K */
name|mas4
operator|=
name|MAS4_TLBSELD0
expr_stmt|;
name|mas4
operator||=
operator|(
name|TLB_SIZE_4K
operator|<<
name|MAS4_TSIZED_SHIFT
operator|)
operator|&
name|MAS4_TSIZED_MASK
expr_stmt|;
name|mtspr
argument_list|(
name|SPR_MAS4
argument_list|,
name|mas4
argument_list|)
expr_stmt|;
asm|__asm volatile("isync");
block|}
end_function

begin_comment
comment|/*  * Print out contents of the MAS registers for each TLB1 entry  */
end_comment

begin_function
name|void
name|tlb1_print_tlbentries
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int32_t
name|mas0
decl_stmt|,
name|mas1
decl_stmt|,
name|mas2
decl_stmt|,
name|mas3
decl_stmt|,
name|mas7
decl_stmt|;
name|int
name|i
decl_stmt|;
name|debugf
argument_list|(
literal|"TLB1 entries:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TLB1_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|mas0
operator|=
name|MAS0_TLBSEL
argument_list|(
literal|1
argument_list|)
operator||
name|MAS0_ESEL
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|mtspr
argument_list|(
name|SPR_MAS0
argument_list|,
name|mas0
argument_list|)
expr_stmt|;
asm|__asm volatile("isync; tlbre");
name|mas1
operator|=
name|mfspr
argument_list|(
name|SPR_MAS1
argument_list|)
expr_stmt|;
name|mas2
operator|=
name|mfspr
argument_list|(
name|SPR_MAS2
argument_list|)
expr_stmt|;
name|mas3
operator|=
name|mfspr
argument_list|(
name|SPR_MAS3
argument_list|)
expr_stmt|;
name|mas7
operator|=
name|mfspr
argument_list|(
name|SPR_MAS7
argument_list|)
expr_stmt|;
name|tlb_print_entry
argument_list|(
name|i
argument_list|,
name|mas1
argument_list|,
name|mas2
argument_list|,
name|mas3
argument_list|,
name|mas7
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Print out contents of the in-ram tlb1 table.  */
end_comment

begin_function
name|void
name|tlb1_print_entries
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|debugf
argument_list|(
literal|"tlb1[] table entries:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TLB1_SIZE
condition|;
name|i
operator|++
control|)
name|tlb_print_entry
argument_list|(
name|i
argument_list|,
name|tlb1
index|[
name|i
index|]
operator|.
name|mas1
argument_list|,
name|tlb1
index|[
name|i
index|]
operator|.
name|mas2
argument_list|,
name|tlb1
index|[
name|i
index|]
operator|.
name|mas3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return 0 if the physical IO range is encompassed by one of the  * the TLB1 entries, otherwise return related error code.  */
end_comment

begin_function
specifier|static
name|int
name|tlb1_iomapped
parameter_list|(
name|int
name|i
parameter_list|,
name|vm_paddr_t
name|pa
parameter_list|,
name|vm_size_t
name|size
parameter_list|,
name|vm_offset_t
modifier|*
name|va
parameter_list|)
block|{
name|u_int32_t
name|prot
decl_stmt|;
name|vm_paddr_t
name|pa_start
decl_stmt|;
name|vm_paddr_t
name|pa_end
decl_stmt|;
name|unsigned
name|int
name|entry_tsize
decl_stmt|;
name|vm_size_t
name|entry_size
decl_stmt|;
operator|*
name|va
operator|=
operator|(
name|vm_offset_t
operator|)
name|NULL
expr_stmt|;
comment|/* Skip invalid entries */
if|if
condition|(
operator|!
operator|(
name|tlb1
index|[
name|i
index|]
operator|.
name|mas1
operator|&
name|MAS1_VALID
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * The entry must be cache-inhibited, guarded, and r/w 	 * so it can function as an i/o page 	 */
name|prot
operator|=
name|tlb1
index|[
name|i
index|]
operator|.
name|mas2
operator|&
operator|(
name|MAS2_I
operator||
name|MAS2_G
operator|)
expr_stmt|;
if|if
condition|(
name|prot
operator|!=
operator|(
name|MAS2_I
operator||
name|MAS2_G
operator|)
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|prot
operator|=
name|tlb1
index|[
name|i
index|]
operator|.
name|mas3
operator|&
operator|(
name|MAS3_SR
operator||
name|MAS3_SW
operator|)
expr_stmt|;
if|if
condition|(
name|prot
operator|!=
operator|(
name|MAS3_SR
operator||
name|MAS3_SW
operator|)
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
comment|/* The address should be within the entry range. */
name|entry_tsize
operator|=
operator|(
name|tlb1
index|[
name|i
index|]
operator|.
name|mas1
operator|&
name|MAS1_TSIZE_MASK
operator|)
operator|>>
name|MAS1_TSIZE_SHIFT
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|entry_tsize
operator|)
argument_list|,
operator|(
literal|"tlb1_iomapped: invalid entry tsize"
operator|)
argument_list|)
expr_stmt|;
name|entry_size
operator|=
name|tsize2size
argument_list|(
name|entry_tsize
argument_list|)
expr_stmt|;
name|pa_start
operator|=
name|tlb1
index|[
name|i
index|]
operator|.
name|mas3
operator|&
name|MAS3_RPN
expr_stmt|;
name|pa_end
operator|=
name|pa_start
operator|+
name|entry_size
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|pa
operator|<
name|pa_start
operator|)
operator|||
operator|(
operator|(
name|pa
operator|+
name|size
operator|)
operator|>
name|pa_end
operator|)
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
comment|/* Return virtual address of this mapping. */
operator|*
name|va
operator|=
operator|(
name|tlb1
index|[
name|i
index|]
operator|.
name|mas2
operator|&
name|MAS2_EPN
operator|)
operator|+
operator|(
name|pa
operator|-
name|pa_start
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

