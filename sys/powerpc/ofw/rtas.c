begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2011 Nathan Whitehorn  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/pcb.h>
end_include

begin_include
include|#
directive|include
file|<machine/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/rtas.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/openfirm.h>
end_include

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_RTAS
argument_list|,
literal|"rtas"
argument_list|,
literal|"Run Time Abstraction Service"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|vm_offset_t
name|rtas_bounce_phys
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|caddr_t
name|rtas_bounce_virt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|off_t
name|rtas_bounce_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|rtas_bounce_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uintptr_t
name|rtas_private_data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|rtas_mtx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|phandle_t
name|rtas
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* From ofwcall.S */
end_comment

begin_function_decl
name|int
name|rtascall
parameter_list|(
name|vm_offset_t
name|callbuffer
parameter_list|,
name|uintptr_t
name|rtas_privdat
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|uintptr_t
name|rtas_entry
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|register_t
name|rtasmsr
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|setfault
parameter_list|(
name|faultbuf
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* defined in locore.S */
end_comment

begin_comment
comment|/*  * After the VM is up, allocate RTAS memory and instantiate it  */
end_comment

begin_function_decl
specifier|static
name|void
name|rtas_setup
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSINIT
argument_list|(
name|rtas_setup
argument_list|,
name|SI_SUB_KMEM
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|rtas_setup
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|rtas_setup
parameter_list|(
name|void
modifier|*
name|junk
parameter_list|)
block|{
name|ihandle_t
name|rtasi
decl_stmt|;
name|cell_t
name|rtas_size
init|=
literal|0
decl_stmt|,
name|rtas_ptr
decl_stmt|;
name|char
name|path
index|[
literal|31
index|]
decl_stmt|;
name|int
name|result
decl_stmt|;
name|rtas
operator|=
name|OF_finddevice
argument_list|(
literal|"/rtas"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtas
operator|==
operator|-
literal|1
condition|)
block|{
name|rtas
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|OF_package_to_path
argument_list|(
name|rtas
argument_list|,
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|rtasi
operator|=
name|OF_open
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtasi
operator|==
literal|0
condition|)
block|{
name|rtas
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"Error initializing RTAS: could not open node\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|mtx_init
argument_list|(
operator|&
name|rtas_mtx
argument_list|,
literal|"RTAS"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
comment|/* RTAS must be called with everything turned off in MSR */
name|rtasmsr
operator|=
name|mfmsr
argument_list|()
expr_stmt|;
name|rtasmsr
operator|&=
operator|~
operator|(
name|PSL_IR
operator||
name|PSL_DR
operator||
name|PSL_EE
operator||
name|PSL_SE
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__powerpc64__
name|rtasmsr
operator|&=
operator|~
name|PSL_SF
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Allocate rtas_size + one page of contiguous, wired physical memory 	 * that can fit into a 32-bit address space and accessed from real mode. 	 * This is used both to bounce arguments and for RTAS private data. 	 * 	 * It must be 4KB-aligned and not cross a 256 MB boundary. 	 */
name|OF_getprop
argument_list|(
name|rtas
argument_list|,
literal|"rtas-size"
argument_list|,
operator|&
name|rtas_size
argument_list|,
sizeof|sizeof
argument_list|(
name|rtas_size
argument_list|)
argument_list|)
expr_stmt|;
name|rtas_size
operator|=
name|round_page
argument_list|(
name|rtas_size
argument_list|)
expr_stmt|;
name|rtas_bounce_virt
operator|=
name|contigmalloc
argument_list|(
name|rtas_size
operator|+
name|PAGE_SIZE
argument_list|,
name|M_RTAS
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ulmin
argument_list|(
name|platform_real_maxaddr
argument_list|()
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|)
argument_list|,
literal|4096
argument_list|,
literal|256
operator|*
literal|1024
operator|*
literal|1024
argument_list|)
expr_stmt|;
name|rtas_private_data
operator|=
name|vtophys
argument_list|(
name|rtas_bounce_virt
argument_list|)
expr_stmt|;
name|rtas_bounce_virt
operator|+=
name|rtas_size
expr_stmt|;
comment|/* Actual bounce area */
name|rtas_bounce_phys
operator|=
name|vtophys
argument_list|(
name|rtas_bounce_virt
argument_list|)
expr_stmt|;
name|rtas_bounce_size
operator|=
name|PAGE_SIZE
expr_stmt|;
comment|/* 	 * Instantiate RTAS. We always use the 32-bit version. 	 */
name|result
operator|=
name|OF_call_method
argument_list|(
literal|"instantiate-rtas"
argument_list|,
name|rtasi
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|(
name|cell_t
operator|)
name|rtas_private_data
argument_list|,
operator|&
name|rtas_ptr
argument_list|)
expr_stmt|;
name|OF_close
argument_list|(
name|rtasi
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
name|rtas
operator|=
literal|0
expr_stmt|;
name|rtas_ptr
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"Error initializing RTAS (%d)\n"
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return;
block|}
name|rtas_entry
operator|=
call|(
name|uintptr_t
call|)
argument_list|(
name|rtas_ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|cell_t
name|rtas_real_map
parameter_list|(
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|cell_t
name|phys
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|rtas_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure the bounce page offset satisfies any reasonable 	 * alignment constraint. 	 */
name|rtas_bounce_offset
operator|+=
sizeof|sizeof
argument_list|(
name|register_t
argument_list|)
operator|-
operator|(
name|rtas_bounce_offset
operator|%
sizeof|sizeof
argument_list|(
name|register_t
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|rtas_bounce_offset
operator|+
name|len
operator|>
name|rtas_bounce_size
condition|)
block|{
name|panic
argument_list|(
literal|"Oversize RTAS call!"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|memcpy
argument_list|(
name|rtas_bounce_virt
operator|+
name|rtas_bounce_offset
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
name|phys
operator|=
name|rtas_bounce_phys
operator|+
name|rtas_bounce_offset
expr_stmt|;
name|rtas_bounce_offset
operator|+=
name|len
expr_stmt|;
return|return
operator|(
name|phys
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rtas_real_unmap
parameter_list|(
name|cell_t
name|physaddr
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|rtas_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|physaddr
operator|==
literal|0
condition|)
return|return;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|rtas_bounce_virt
operator|+
operator|(
name|physaddr
operator|-
name|rtas_bounce_phys
operator|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check if we have RTAS */
end_comment

begin_function
name|int
name|rtas_exists
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|rtas
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Call an RTAS method by token */
end_comment

begin_function
name|int
name|rtas_call_method
parameter_list|(
name|cell_t
name|token
parameter_list|,
name|int
name|nargs
parameter_list|,
name|int
name|nreturns
parameter_list|,
modifier|...
parameter_list|)
block|{
name|vm_offset_t
name|argsptr
decl_stmt|;
name|faultbuf
name|env
decl_stmt|,
modifier|*
name|oldfaultbuf
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
struct|struct
block|{
name|cell_t
name|token
decl_stmt|;
name|cell_t
name|nargs
decl_stmt|;
name|cell_t
name|nreturns
decl_stmt|;
name|cell_t
name|args_n_results
index|[
literal|12
index|]
decl_stmt|;
block|}
name|args
struct|;
name|int
name|n
decl_stmt|,
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|rtas_exists
argument_list|()
operator|||
name|nargs
operator|+
name|nreturns
operator|>
literal|12
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|args
operator|.
name|token
operator|=
name|token
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|nreturns
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|rtas_mtx
argument_list|)
expr_stmt|;
name|rtas_bounce_offset
operator|=
literal|0
expr_stmt|;
name|args
operator|.
name|nargs
operator|=
name|nargs
expr_stmt|;
name|args
operator|.
name|nreturns
operator|=
name|nreturns
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nargs
condition|;
name|n
operator|++
control|)
name|args
operator|.
name|args_n_results
index|[
name|n
index|]
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|cell_t
argument_list|)
expr_stmt|;
name|argsptr
operator|=
name|rtas_real_map
argument_list|(
operator|&
name|args
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get rid of any stale machine checks that have been waiting.  */
asm|__asm __volatile ("sync; isync");
name|oldfaultbuf
operator|=
name|curthread
operator|->
name|td_pcb
operator|->
name|pcb_onfault
expr_stmt|;
if|if
condition|(
operator|!
name|setfault
argument_list|(
name|env
argument_list|)
condition|)
block|{
asm|__asm __volatile ("sync");
name|result
operator|=
name|rtascall
argument_list|(
name|argsptr
argument_list|,
name|rtas_private_data
argument_list|)
expr_stmt|;
asm|__asm __volatile ("sync; isync");
block|}
else|else
block|{
name|result
operator|=
name|RTAS_HW_ERROR
expr_stmt|;
block|}
name|curthread
operator|->
name|td_pcb
operator|->
name|pcb_onfault
operator|=
name|oldfaultbuf
expr_stmt|;
asm|__asm __volatile ("sync");
name|rtas_real_unmap
argument_list|(
name|argsptr
argument_list|,
operator|&
name|args
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|rtas_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
return|return
operator|(
name|result
operator|)
return|;
for|for
control|(
name|n
operator|=
name|nargs
init|;
name|n
operator|<
name|nargs
operator|+
name|nreturns
condition|;
name|n
operator|++
control|)
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|cell_t
operator|*
argument_list|)
operator|=
name|args
operator|.
name|args_n_results
index|[
name|n
index|]
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Look up an RTAS token */
end_comment

begin_function
name|cell_t
name|rtas_token_lookup
parameter_list|(
specifier|const
name|char
modifier|*
name|method
parameter_list|)
block|{
name|cell_t
name|token
decl_stmt|;
if|if
condition|(
operator|!
name|rtas_exists
argument_list|()
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|OF_getprop
argument_list|(
name|rtas
argument_list|,
name|method
argument_list|,
operator|&
name|token
argument_list|,
sizeof|sizeof
argument_list|(
name|token
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|token
operator|)
return|;
block|}
end_function

end_unit

