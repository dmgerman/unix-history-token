begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001 The NetBSD Foundation, Inc.  * All rights reserved.  *  * This code is derived from software contributed to The NetBSD Foundation  * by Matt Thomas<matt@3am-software.com> of Allegro Networks, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*-  * Copyright (C) 1995, 1996 Wolfgang Solfrank.  * Copyright (C) 1995, 1996 TooLs GmbH.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by TooLs GmbH.  * 4. The name of TooLs GmbH may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $NetBSD: pmap.c,v 1.28 2000/03/26 20:42:36 kleink Exp $  */
end_comment

begin_comment
comment|/*-  * Copyright (C) 2001 Benno Rice.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY Benno Rice ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Manages physical address maps.  *  * Since the information managed by this module is also stored by the  * logical address mapping module, this module may throw away valid virtual  * to physical mappings at almost any time.  However, invalidations of  * mappings must be done as requested.  *  * In order to cope with hardware architectures which make virtual to  * physical map invalidates expensive, this module may delay invalidate  * reduced protection operations until such time as they are actually  * necessary.  This module is given full information as to which processors  * are currently using which maps, and to when physical maps must be made  * correct.  */
end_comment

begin_include
include|#
directive|include
file|"opt_kstack_pages.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/cpuset.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/msgbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/openfirm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pageout.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/platform.h>
end_include

begin_include
include|#
directive|include
file|<machine/bat.h>
end_include

begin_include
include|#
directive|include
file|<machine/frame.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/psl.h>
end_include

begin_include
include|#
directive|include
file|<machine/pte.h>
end_include

begin_include
include|#
directive|include
file|<machine/smp.h>
end_include

begin_include
include|#
directive|include
file|<machine/sr.h>
end_include

begin_include
include|#
directive|include
file|<machine/mmuvar.h>
end_include

begin_include
include|#
directive|include
file|<machine/trap.h>
end_include

begin_include
include|#
directive|include
file|"mmu_if.h"
end_include

begin_define
define|#
directive|define
name|MOEA_DEBUG
end_define

begin_define
define|#
directive|define
name|TODO
value|panic("%s: not implemented", __func__);
end_define

begin_define
define|#
directive|define
name|VSID_MAKE
parameter_list|(
name|sr
parameter_list|,
name|hash
parameter_list|)
value|((sr) | (((hash)& 0xfffff)<< 4))
end_define

begin_define
define|#
directive|define
name|VSID_TO_SR
parameter_list|(
name|vsid
parameter_list|)
value|((vsid)& 0xf)
end_define

begin_define
define|#
directive|define
name|VSID_TO_HASH
parameter_list|(
name|vsid
parameter_list|)
value|(((vsid)>> 4)& 0xfffff)
end_define

begin_struct
struct|struct
name|ofw_map
block|{
name|vm_offset_t
name|om_va
decl_stmt|;
name|vm_size_t
name|om_len
decl_stmt|;
name|vm_offset_t
name|om_pa
decl_stmt|;
name|u_int
name|om_mode
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|unsigned
name|char
name|_etext
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|char
name|_end
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|dumpsys_minidump
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Map of physical memory regions.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mem_region
modifier|*
name|regions
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mem_region
modifier|*
name|pregions
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|phys_avail_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|regions_sz
decl_stmt|,
name|pregions_sz
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ofw_map
modifier|*
name|translations
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Lock for the pteg and pvo tables.  */
end_comment

begin_decl_stmt
name|struct
name|mtx
name|moea_table_mutex
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mtx
name|moea_vsid_mutex
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tlbie instruction synchronization */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|tlbie_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * PTEG data.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|pteg
modifier|*
name|moea_pteg_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|moea_pteg_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|moea_pteg_mask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * PVO data.  */
end_comment

begin_decl_stmt
name|struct
name|pvo_head
modifier|*
name|moea_pvo_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pvo entries by pteg index */
end_comment

begin_decl_stmt
name|struct
name|pvo_head
name|moea_pvo_kunmanaged
init|=
name|LIST_HEAD_INITIALIZER
argument_list|(
name|moea_pvo_kunmanaged
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of unmanaged pages */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|rwlock_padalign
name|pvh_global_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uma_zone_t
name|moea_upvo_zone
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* zone for pvo entries for unmanaged pages */
end_comment

begin_decl_stmt
name|uma_zone_t
name|moea_mpvo_zone
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* zone for pvo entries for managed pages */
end_comment

begin_define
define|#
directive|define
name|BPVO_POOL_SIZE
value|32768
end_define

begin_decl_stmt
specifier|static
name|struct
name|pvo_entry
modifier|*
name|moea_bpvo_pool
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|moea_bpvo_pool_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|VSID_NBPW
value|(sizeof(u_int32_t) * 8)
end_define

begin_decl_stmt
specifier|static
name|u_int
name|moea_vsid_bitmap
index|[
name|NPMAPS
operator|/
name|VSID_NBPW
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean_t
name|moea_initialized
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Statistics.  */
end_comment

begin_decl_stmt
name|u_int
name|moea_pte_valid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|moea_pte_overflow
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|moea_pte_replacements
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|moea_pvo_entries
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|moea_pvo_enter_calls
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|moea_pvo_remove_calls
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|moea_pte_spills
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|moea_pte_valid
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|moea_pte_valid
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|moea_pte_overflow
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|moea_pte_overflow
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|moea_pte_replacements
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|moea_pte_replacements
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|moea_pvo_entries
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|moea_pvo_entries
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|moea_pvo_enter_calls
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|moea_pvo_enter_calls
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|moea_pvo_remove_calls
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|moea_pvo_remove_calls
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|moea_pte_spills
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|moea_pte_spills
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Allocate physical memory for use in moea_bootstrap.  */
end_comment

begin_function_decl
specifier|static
name|vm_offset_t
name|moea_bootstrap_alloc
parameter_list|(
name|vm_size_t
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * PTE calls.  */
end_comment

begin_function_decl
specifier|static
name|int
name|moea_pte_insert
parameter_list|(
name|u_int
parameter_list|,
name|struct
name|pte
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * PVO calls.  */
end_comment

begin_function_decl
specifier|static
name|int
name|moea_pvo_enter
parameter_list|(
name|pmap_t
parameter_list|,
name|uma_zone_t
parameter_list|,
name|struct
name|pvo_head
modifier|*
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|u_int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|moea_pvo_remove
parameter_list|(
name|struct
name|pvo_entry
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|pvo_entry
modifier|*
name|moea_pvo_find_va
parameter_list|(
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|pte
modifier|*
name|moea_pvo_to_pte
parameter_list|(
specifier|const
name|struct
name|pvo_entry
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Utility routines.  */
end_comment

begin_function_decl
specifier|static
name|int
name|moea_enter_locked
parameter_list|(
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_page_t
parameter_list|,
name|vm_prot_t
parameter_list|,
name|u_int
parameter_list|,
name|int8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|moea_syncicache
parameter_list|(
name|vm_offset_t
parameter_list|,
name|vm_size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean_t
name|moea_query_bit
parameter_list|(
name|vm_page_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|moea_clear_bit
parameter_list|(
name|vm_page_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|moea_kremove
parameter_list|(
name|mmu_t
parameter_list|,
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|moea_pte_spill
parameter_list|(
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Kernel MMU interface  */
end_comment

begin_function_decl
name|void
name|moea_change_wiring
parameter_list|(
name|mmu_t
parameter_list|,
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|boolean_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|moea_clear_modify
parameter_list|(
name|mmu_t
parameter_list|,
name|vm_page_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|moea_copy_page
parameter_list|(
name|mmu_t
parameter_list|,
name|vm_page_t
parameter_list|,
name|vm_page_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|moea_copy_pages
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|vm_page_t
modifier|*
name|ma
parameter_list|,
name|vm_offset_t
name|a_offset
parameter_list|,
name|vm_page_t
modifier|*
name|mb
parameter_list|,
name|vm_offset_t
name|b_offset
parameter_list|,
name|int
name|xfersize
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|moea_enter
parameter_list|(
name|mmu_t
parameter_list|,
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_page_t
parameter_list|,
name|vm_prot_t
parameter_list|,
name|u_int
parameter_list|,
name|int8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|moea_enter_object
parameter_list|(
name|mmu_t
parameter_list|,
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_page_t
parameter_list|,
name|vm_prot_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|moea_enter_quick
parameter_list|(
name|mmu_t
parameter_list|,
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_page_t
parameter_list|,
name|vm_prot_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|vm_paddr_t
name|moea_extract
parameter_list|(
name|mmu_t
parameter_list|,
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|vm_page_t
name|moea_extract_and_hold
parameter_list|(
name|mmu_t
parameter_list|,
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_prot_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|moea_init
parameter_list|(
name|mmu_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|boolean_t
name|moea_is_modified
parameter_list|(
name|mmu_t
parameter_list|,
name|vm_page_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|boolean_t
name|moea_is_prefaultable
parameter_list|(
name|mmu_t
parameter_list|,
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|boolean_t
name|moea_is_referenced
parameter_list|(
name|mmu_t
parameter_list|,
name|vm_page_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|moea_ts_referenced
parameter_list|(
name|mmu_t
parameter_list|,
name|vm_page_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|vm_offset_t
name|moea_map
parameter_list|(
name|mmu_t
parameter_list|,
name|vm_offset_t
modifier|*
parameter_list|,
name|vm_paddr_t
parameter_list|,
name|vm_paddr_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|boolean_t
name|moea_page_exists_quick
parameter_list|(
name|mmu_t
parameter_list|,
name|pmap_t
parameter_list|,
name|vm_page_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|moea_page_wired_mappings
parameter_list|(
name|mmu_t
parameter_list|,
name|vm_page_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|moea_pinit
parameter_list|(
name|mmu_t
parameter_list|,
name|pmap_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|moea_pinit0
parameter_list|(
name|mmu_t
parameter_list|,
name|pmap_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|moea_protect
parameter_list|(
name|mmu_t
parameter_list|,
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_prot_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|moea_qenter
parameter_list|(
name|mmu_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_page_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|moea_qremove
parameter_list|(
name|mmu_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|moea_release
parameter_list|(
name|mmu_t
parameter_list|,
name|pmap_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|moea_remove
parameter_list|(
name|mmu_t
parameter_list|,
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|moea_remove_all
parameter_list|(
name|mmu_t
parameter_list|,
name|vm_page_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|moea_remove_write
parameter_list|(
name|mmu_t
parameter_list|,
name|vm_page_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|moea_zero_page
parameter_list|(
name|mmu_t
parameter_list|,
name|vm_page_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|moea_zero_page_area
parameter_list|(
name|mmu_t
parameter_list|,
name|vm_page_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|moea_zero_page_idle
parameter_list|(
name|mmu_t
parameter_list|,
name|vm_page_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|moea_activate
parameter_list|(
name|mmu_t
parameter_list|,
name|struct
name|thread
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|moea_deactivate
parameter_list|(
name|mmu_t
parameter_list|,
name|struct
name|thread
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|moea_cpu_bootstrap
parameter_list|(
name|mmu_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|moea_bootstrap
parameter_list|(
name|mmu_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
modifier|*
name|moea_mapdev
parameter_list|(
name|mmu_t
parameter_list|,
name|vm_paddr_t
parameter_list|,
name|vm_size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
modifier|*
name|moea_mapdev_attr
parameter_list|(
name|mmu_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_size_t
parameter_list|,
name|vm_memattr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|moea_unmapdev
parameter_list|(
name|mmu_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|vm_paddr_t
name|moea_kextract
parameter_list|(
name|mmu_t
parameter_list|,
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|moea_kenter_attr
parameter_list|(
name|mmu_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_memattr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|moea_kenter
parameter_list|(
name|mmu_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_paddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|moea_page_set_memattr
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_memattr_t
name|ma
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|boolean_t
name|moea_dev_direct_mapped
parameter_list|(
name|mmu_t
parameter_list|,
name|vm_paddr_t
parameter_list|,
name|vm_size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|moea_sync_icache
parameter_list|(
name|mmu_t
parameter_list|,
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|vm_offset_t
name|moea_dumpsys_map
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|struct
name|pmap_md
modifier|*
name|md
parameter_list|,
name|vm_size_t
name|ofs
parameter_list|,
name|vm_size_t
modifier|*
name|sz
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|pmap_md
modifier|*
name|moea_scan_md
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|struct
name|pmap_md
modifier|*
name|prev
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|mmu_method_t
name|moea_methods
index|[]
init|=
block|{
name|MMUMETHOD
argument_list|(
name|mmu_change_wiring
argument_list|,
name|moea_change_wiring
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_clear_modify
argument_list|,
name|moea_clear_modify
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_copy_page
argument_list|,
name|moea_copy_page
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_copy_pages
argument_list|,
name|moea_copy_pages
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_enter
argument_list|,
name|moea_enter
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_enter_object
argument_list|,
name|moea_enter_object
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_enter_quick
argument_list|,
name|moea_enter_quick
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_extract
argument_list|,
name|moea_extract
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_extract_and_hold
argument_list|,
name|moea_extract_and_hold
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_init
argument_list|,
name|moea_init
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_is_modified
argument_list|,
name|moea_is_modified
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_is_prefaultable
argument_list|,
name|moea_is_prefaultable
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_is_referenced
argument_list|,
name|moea_is_referenced
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_ts_referenced
argument_list|,
name|moea_ts_referenced
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_map
argument_list|,
name|moea_map
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_page_exists_quick
argument_list|,
name|moea_page_exists_quick
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_page_wired_mappings
argument_list|,
name|moea_page_wired_mappings
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_pinit
argument_list|,
name|moea_pinit
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_pinit0
argument_list|,
name|moea_pinit0
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_protect
argument_list|,
name|moea_protect
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_qenter
argument_list|,
name|moea_qenter
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_qremove
argument_list|,
name|moea_qremove
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_release
argument_list|,
name|moea_release
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_remove
argument_list|,
name|moea_remove
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_remove_all
argument_list|,
name|moea_remove_all
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_remove_write
argument_list|,
name|moea_remove_write
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_sync_icache
argument_list|,
name|moea_sync_icache
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_zero_page
argument_list|,
name|moea_zero_page
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_zero_page_area
argument_list|,
name|moea_zero_page_area
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_zero_page_idle
argument_list|,
name|moea_zero_page_idle
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_activate
argument_list|,
name|moea_activate
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_deactivate
argument_list|,
name|moea_deactivate
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_page_set_memattr
argument_list|,
name|moea_page_set_memattr
argument_list|)
block|,
comment|/* Internal interfaces */
name|MMUMETHOD
argument_list|(
name|mmu_bootstrap
argument_list|,
name|moea_bootstrap
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_cpu_bootstrap
argument_list|,
name|moea_cpu_bootstrap
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_mapdev_attr
argument_list|,
name|moea_mapdev_attr
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_mapdev
argument_list|,
name|moea_mapdev
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_unmapdev
argument_list|,
name|moea_unmapdev
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_kextract
argument_list|,
name|moea_kextract
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_kenter
argument_list|,
name|moea_kenter
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_kenter_attr
argument_list|,
name|moea_kenter_attr
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_dev_direct_mapped
argument_list|,
name|moea_dev_direct_mapped
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_scan_md
argument_list|,
name|moea_scan_md
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_dumpsys_map
argument_list|,
name|moea_dumpsys_map
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MMU_DEF
argument_list|(
name|oea_mmu
argument_list|,
name|MMU_TYPE_OEA
argument_list|,
name|moea_methods
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|__inline
name|uint32_t
name|moea_calc_wimg
parameter_list|(
name|vm_offset_t
name|pa
parameter_list|,
name|vm_memattr_t
name|ma
parameter_list|)
block|{
name|uint32_t
name|pte_lo
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ma
operator|!=
name|VM_MEMATTR_DEFAULT
condition|)
block|{
switch|switch
condition|(
name|ma
condition|)
block|{
case|case
name|VM_MEMATTR_UNCACHEABLE
case|:
return|return
operator|(
name|PTE_I
operator||
name|PTE_G
operator|)
return|;
case|case
name|VM_MEMATTR_WRITE_COMBINING
case|:
case|case
name|VM_MEMATTR_WRITE_BACK
case|:
case|case
name|VM_MEMATTR_PREFETCHABLE
case|:
return|return
operator|(
name|PTE_I
operator|)
return|;
case|case
name|VM_MEMATTR_WRITE_THROUGH
case|:
return|return
operator|(
name|PTE_W
operator||
name|PTE_M
operator|)
return|;
block|}
block|}
comment|/* 	 * Assume the page is cache inhibited and access is guarded unless 	 * it's in our available memory array. 	 */
name|pte_lo
operator|=
name|PTE_I
operator||
name|PTE_G
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pregions_sz
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|pa
operator|>=
name|pregions
index|[
name|i
index|]
operator|.
name|mr_start
operator|)
operator|&&
operator|(
name|pa
operator|<
operator|(
name|pregions
index|[
name|i
index|]
operator|.
name|mr_start
operator|+
name|pregions
index|[
name|i
index|]
operator|.
name|mr_size
operator|)
operator|)
condition|)
block|{
name|pte_lo
operator|=
name|PTE_M
expr_stmt|;
break|break;
block|}
block|}
return|return
name|pte_lo
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tlbie
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|tlbie_mtx
argument_list|)
expr_stmt|;
asm|__asm __volatile("ptesync");
asm|__asm __volatile("tlbie %0" :: "r"(va));
asm|__asm __volatile("eieio; tlbsync; ptesync");
name|mtx_unlock_spin
argument_list|(
operator|&
name|tlbie_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tlbia
parameter_list|(
name|void
parameter_list|)
block|{
name|vm_offset_t
name|va
decl_stmt|;
for|for
control|(
name|va
operator|=
literal|0
init|;
name|va
operator|<
literal|0x00040000
condition|;
name|va
operator|+=
literal|0x00001000
control|)
block|{
asm|__asm __volatile("tlbie %0" :: "r"(va));
name|powerpc_sync
argument_list|()
expr_stmt|;
block|}
asm|__asm __volatile("tlbsync");
name|powerpc_sync
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|va_to_sr
parameter_list|(
name|u_int
modifier|*
name|sr
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
return|return
operator|(
name|sr
index|[
operator|(
name|uintptr_t
operator|)
name|va
operator|>>
name|ADDR_SR_SHFT
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|u_int
name|va_to_pteg
parameter_list|(
name|u_int
name|sr
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|)
block|{
name|u_int
name|hash
decl_stmt|;
name|hash
operator|=
operator|(
name|sr
operator|&
name|SR_VSID_MASK
operator|)
operator|^
operator|(
operator|(
operator|(
name|u_int
operator|)
name|addr
operator|&
name|ADDR_PIDX
operator|)
operator|>>
name|ADDR_PIDX_SHFT
operator|)
expr_stmt|;
return|return
operator|(
name|hash
operator|&
name|moea_pteg_mask
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|pvo_head
operator|*
name|vm_page_to_pvoh
argument_list|(
argument|vm_page_t m
argument_list|)
block|{
return|return
operator|(
operator|&
name|m
operator|->
name|md
operator|.
name|mdpg_pvoh
operator|)
return|;
block|}
end_expr_stmt

begin_function
specifier|static
name|__inline
name|void
name|moea_attr_clear
parameter_list|(
name|vm_page_t
name|m
parameter_list|,
name|int
name|ptebit
parameter_list|)
block|{
name|rw_assert
argument_list|(
operator|&
name|pvh_global_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|mdpg_attrs
operator|&=
operator|~
name|ptebit
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|moea_attr_fetch
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
return|return
operator|(
name|m
operator|->
name|md
operator|.
name|mdpg_attrs
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|moea_attr_save
parameter_list|(
name|vm_page_t
name|m
parameter_list|,
name|int
name|ptebit
parameter_list|)
block|{
name|rw_assert
argument_list|(
operator|&
name|pvh_global_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|mdpg_attrs
operator||=
name|ptebit
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|moea_pte_compare
parameter_list|(
specifier|const
name|struct
name|pte
modifier|*
name|pt
parameter_list|,
specifier|const
name|struct
name|pte
modifier|*
name|pvo_pt
parameter_list|)
block|{
if|if
condition|(
name|pt
operator|->
name|pte_hi
operator|==
name|pvo_pt
operator|->
name|pte_hi
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|moea_pte_match
parameter_list|(
name|struct
name|pte
modifier|*
name|pt
parameter_list|,
name|u_int
name|sr
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|int
name|which
parameter_list|)
block|{
return|return
operator|(
name|pt
operator|->
name|pte_hi
operator|&
operator|~
name|PTE_VALID
operator|)
operator|==
operator|(
operator|(
operator|(
name|sr
operator|&
name|SR_VSID_MASK
operator|)
operator|<<
name|PTE_VSID_SHFT
operator|)
operator||
operator|(
operator|(
name|va
operator|>>
name|ADDR_API_SHFT
operator|)
operator|&
name|PTE_API
operator|)
operator||
name|which
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|moea_pte_create
parameter_list|(
name|struct
name|pte
modifier|*
name|pt
parameter_list|,
name|u_int
name|sr
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|u_int
name|pte_lo
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|moea_table_mutex
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * Construct a PTE.  Default to IMB initially.  Valid bit only gets 	 * set when the real pte is set in memory. 	 * 	 * Note: Don't set the valid bit for correct operation of tlb update. 	 */
name|pt
operator|->
name|pte_hi
operator|=
operator|(
operator|(
name|sr
operator|&
name|SR_VSID_MASK
operator|)
operator|<<
name|PTE_VSID_SHFT
operator|)
operator||
operator|(
operator|(
operator|(
name|va
operator|&
name|ADDR_PIDX
operator|)
operator|>>
name|ADDR_API_SHFT
operator|)
operator|&
name|PTE_API
operator|)
expr_stmt|;
name|pt
operator|->
name|pte_lo
operator|=
name|pte_lo
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|moea_pte_synch
parameter_list|(
name|struct
name|pte
modifier|*
name|pt
parameter_list|,
name|struct
name|pte
modifier|*
name|pvo_pt
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|moea_table_mutex
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|pvo_pt
operator|->
name|pte_lo
operator||=
name|pt
operator|->
name|pte_lo
operator|&
operator|(
name|PTE_REF
operator||
name|PTE_CHG
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|moea_pte_clear
parameter_list|(
name|struct
name|pte
modifier|*
name|pt
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|int
name|ptebit
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|moea_table_mutex
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * As shown in Section 7.6.3.2.3 	 */
name|pt
operator|->
name|pte_lo
operator|&=
operator|~
name|ptebit
expr_stmt|;
name|tlbie
argument_list|(
name|va
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|moea_pte_set
parameter_list|(
name|struct
name|pte
modifier|*
name|pt
parameter_list|,
name|struct
name|pte
modifier|*
name|pvo_pt
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|moea_table_mutex
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|pvo_pt
operator|->
name|pte_hi
operator||=
name|PTE_VALID
expr_stmt|;
comment|/* 	 * Update the PTE as defined in section 7.6.3.1. 	 * Note that the REF/CHG bits are from pvo_pt and thus should have 	 * been saved so this routine can restore them (if desired). 	 */
name|pt
operator|->
name|pte_lo
operator|=
name|pvo_pt
operator|->
name|pte_lo
expr_stmt|;
name|powerpc_sync
argument_list|()
expr_stmt|;
name|pt
operator|->
name|pte_hi
operator|=
name|pvo_pt
operator|->
name|pte_hi
expr_stmt|;
name|powerpc_sync
argument_list|()
expr_stmt|;
name|moea_pte_valid
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|moea_pte_unset
parameter_list|(
name|struct
name|pte
modifier|*
name|pt
parameter_list|,
name|struct
name|pte
modifier|*
name|pvo_pt
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|moea_table_mutex
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|pvo_pt
operator|->
name|pte_hi
operator|&=
operator|~
name|PTE_VALID
expr_stmt|;
comment|/* 	 * Force the reg& chg bits back into the PTEs. 	 */
name|powerpc_sync
argument_list|()
expr_stmt|;
comment|/* 	 * Invalidate the pte. 	 */
name|pt
operator|->
name|pte_hi
operator|&=
operator|~
name|PTE_VALID
expr_stmt|;
name|tlbie
argument_list|(
name|va
argument_list|)
expr_stmt|;
comment|/* 	 * Save the reg& chg bits. 	 */
name|moea_pte_synch
argument_list|(
name|pt
argument_list|,
name|pvo_pt
argument_list|)
expr_stmt|;
name|moea_pte_valid
operator|--
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|moea_pte_change
parameter_list|(
name|struct
name|pte
modifier|*
name|pt
parameter_list|,
name|struct
name|pte
modifier|*
name|pvo_pt
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
comment|/* 	 * Invalidate the PTE 	 */
name|moea_pte_unset
argument_list|(
name|pt
argument_list|,
name|pvo_pt
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|moea_pte_set
argument_list|(
name|pt
argument_list|,
name|pvo_pt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Quick sort callout for comparing memory regions.  */
end_comment

begin_function_decl
specifier|static
name|int
name|om_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|om_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|struct
name|ofw_map
modifier|*
name|mapa
decl_stmt|;
specifier|const
name|struct
name|ofw_map
modifier|*
name|mapb
decl_stmt|;
name|mapa
operator|=
name|a
expr_stmt|;
name|mapb
operator|=
name|b
expr_stmt|;
if|if
condition|(
name|mapa
operator|->
name|om_pa
operator|<
name|mapb
operator|->
name|om_pa
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|mapa
operator|->
name|om_pa
operator|>
name|mapb
operator|->
name|om_pa
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|moea_cpu_bootstrap
parameter_list|(
name|mmu_t
name|mmup
parameter_list|,
name|int
name|ap
parameter_list|)
block|{
name|u_int
name|sdr
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ap
condition|)
block|{
name|powerpc_sync
argument_list|()
expr_stmt|;
asm|__asm __volatile("mtdbatu 0,%0" :: "r"(battable[0].batu));
asm|__asm __volatile("mtdbatl 0,%0" :: "r"(battable[0].batl));
name|isync
argument_list|()
expr_stmt|;
asm|__asm __volatile("mtibatu 0,%0" :: "r"(battable[0].batu));
asm|__asm __volatile("mtibatl 0,%0" :: "r"(battable[0].batl));
name|isync
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|WII
comment|/* 	 * Special case for the Wii: don't install the PCI BAT. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|installed_platform
argument_list|()
argument_list|,
literal|"wii"
argument_list|)
operator|!=
literal|0
condition|)
block|{
endif|#
directive|endif
asm|__asm __volatile("mtdbatu 1,%0" :: "r"(battable[8].batu));
asm|__asm __volatile("mtdbatl 1,%0" :: "r"(battable[8].batl));
ifdef|#
directive|ifdef
name|WII
block|}
endif|#
directive|endif
name|isync
argument_list|()
expr_stmt|;
asm|__asm __volatile("mtibatu 1,%0" :: "r"(0));
asm|__asm __volatile("mtdbatu 2,%0" :: "r"(0));
asm|__asm __volatile("mtibatu 2,%0" :: "r"(0));
asm|__asm __volatile("mtdbatu 3,%0" :: "r"(0));
asm|__asm __volatile("mtibatu 3,%0" :: "r"(0));
name|isync
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|mtsrin
argument_list|(
name|i
operator|<<
name|ADDR_SR_SHFT
argument_list|,
name|kernel_pmap
operator|->
name|pm_sr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|powerpc_sync
argument_list|()
expr_stmt|;
name|sdr
operator|=
operator|(
name|u_int
operator|)
name|moea_pteg_table
operator||
operator|(
name|moea_pteg_mask
operator|>>
literal|10
operator|)
expr_stmt|;
asm|__asm __volatile("mtsdr1 %0" :: "r"(sdr));
name|isync
argument_list|()
expr_stmt|;
name|tlbia
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|moea_bootstrap
parameter_list|(
name|mmu_t
name|mmup
parameter_list|,
name|vm_offset_t
name|kernelstart
parameter_list|,
name|vm_offset_t
name|kernelend
parameter_list|)
block|{
name|ihandle_t
name|mmui
decl_stmt|;
name|phandle_t
name|chosen
decl_stmt|,
name|mmu
decl_stmt|;
name|int
name|sz
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|vm_size_t
name|size
decl_stmt|,
name|physsz
decl_stmt|,
name|hwphyssz
decl_stmt|;
name|vm_offset_t
name|pa
decl_stmt|,
name|va
decl_stmt|,
name|off
decl_stmt|;
name|void
modifier|*
name|dpcpu
decl_stmt|;
name|register_t
name|msr
decl_stmt|;
comment|/*          * Set up BAT0 to map the lowest 256 MB area          */
name|battable
index|[
literal|0x0
index|]
operator|.
name|batl
operator|=
name|BATL
argument_list|(
literal|0x00000000
argument_list|,
name|BAT_M
argument_list|,
name|BAT_PP_RW
argument_list|)
expr_stmt|;
name|battable
index|[
literal|0x0
index|]
operator|.
name|batu
operator|=
name|BATU
argument_list|(
literal|0x00000000
argument_list|,
name|BAT_BL_256M
argument_list|,
name|BAT_Vs
argument_list|)
expr_stmt|;
comment|/* 	 * Map PCI memory space. 	 */
name|battable
index|[
literal|0x8
index|]
operator|.
name|batl
operator|=
name|BATL
argument_list|(
literal|0x80000000
argument_list|,
name|BAT_I
operator||
name|BAT_G
argument_list|,
name|BAT_PP_RW
argument_list|)
expr_stmt|;
name|battable
index|[
literal|0x8
index|]
operator|.
name|batu
operator|=
name|BATU
argument_list|(
literal|0x80000000
argument_list|,
name|BAT_BL_256M
argument_list|,
name|BAT_Vs
argument_list|)
expr_stmt|;
name|battable
index|[
literal|0x9
index|]
operator|.
name|batl
operator|=
name|BATL
argument_list|(
literal|0x90000000
argument_list|,
name|BAT_I
operator||
name|BAT_G
argument_list|,
name|BAT_PP_RW
argument_list|)
expr_stmt|;
name|battable
index|[
literal|0x9
index|]
operator|.
name|batu
operator|=
name|BATU
argument_list|(
literal|0x90000000
argument_list|,
name|BAT_BL_256M
argument_list|,
name|BAT_Vs
argument_list|)
expr_stmt|;
name|battable
index|[
literal|0xa
index|]
operator|.
name|batl
operator|=
name|BATL
argument_list|(
literal|0xa0000000
argument_list|,
name|BAT_I
operator||
name|BAT_G
argument_list|,
name|BAT_PP_RW
argument_list|)
expr_stmt|;
name|battable
index|[
literal|0xa
index|]
operator|.
name|batu
operator|=
name|BATU
argument_list|(
literal|0xa0000000
argument_list|,
name|BAT_BL_256M
argument_list|,
name|BAT_Vs
argument_list|)
expr_stmt|;
name|battable
index|[
literal|0xb
index|]
operator|.
name|batl
operator|=
name|BATL
argument_list|(
literal|0xb0000000
argument_list|,
name|BAT_I
operator||
name|BAT_G
argument_list|,
name|BAT_PP_RW
argument_list|)
expr_stmt|;
name|battable
index|[
literal|0xb
index|]
operator|.
name|batu
operator|=
name|BATU
argument_list|(
literal|0xb0000000
argument_list|,
name|BAT_BL_256M
argument_list|,
name|BAT_Vs
argument_list|)
expr_stmt|;
comment|/* 	 * Map obio devices. 	 */
name|battable
index|[
literal|0xf
index|]
operator|.
name|batl
operator|=
name|BATL
argument_list|(
literal|0xf0000000
argument_list|,
name|BAT_I
operator||
name|BAT_G
argument_list|,
name|BAT_PP_RW
argument_list|)
expr_stmt|;
name|battable
index|[
literal|0xf
index|]
operator|.
name|batu
operator|=
name|BATU
argument_list|(
literal|0xf0000000
argument_list|,
name|BAT_BL_256M
argument_list|,
name|BAT_Vs
argument_list|)
expr_stmt|;
comment|/* 	 * Use an IBAT and a DBAT to map the bottom segment of memory 	 * where we are. Turn off instruction relocation temporarily 	 * to prevent faults while reprogramming the IBAT. 	 */
name|msr
operator|=
name|mfmsr
argument_list|()
expr_stmt|;
name|mtmsr
argument_list|(
name|msr
operator|&
operator|~
name|PSL_IR
argument_list|)
expr_stmt|;
asm|__asm (".balign 32; \n"
literal|"mtibatu 0,%0; mtibatl 0,%1; isync; \n"
literal|"mtdbatu 0,%0; mtdbatl 0,%1; isync"
operator|::
literal|"r"
operator|(
name|battable
index|[
literal|0
index|]
operator|.
name|batu
operator|)
operator|,
literal|"r"
operator|(
name|battable
index|[
literal|0
index|]
operator|.
name|batl
operator|)
block|)
function|;
end_function

begin_expr_stmt
name|mtmsr
argument_list|(
name|msr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|WII
end_ifdef

begin_if
if|if
condition|(
name|strcmp
argument_list|(
name|installed_platform
argument_list|()
argument_list|,
literal|"wii"
argument_list|)
operator|!=
literal|0
condition|)
block|{
endif|#
directive|endif
comment|/* map pci space */
asm|__asm __volatile("mtdbatu 1,%0" :: "r"(battable[8].batu));
asm|__asm __volatile("mtdbatl 1,%0" :: "r"(battable[8].batl));
ifdef|#
directive|ifdef
name|WII
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|isync
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* set global direct map flag */
end_comment

begin_expr_stmt
name|hw_direct_map
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|mem_regions
argument_list|(
operator|&
name|pregions
argument_list|,
operator|&
name|pregions_sz
argument_list|,
operator|&
name|regions
argument_list|,
operator|&
name|regions_sz
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTR0
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"moea_bootstrap: physical memory"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pregions_sz
condition|;
name|i
operator|++
control|)
block|{
name|vm_offset_t
name|pa
decl_stmt|;
name|vm_offset_t
name|end
decl_stmt|;
name|CTR3
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"physregion: %#x - %#x (%#x)"
argument_list|,
name|pregions
index|[
name|i
index|]
operator|.
name|mr_start
argument_list|,
name|pregions
index|[
name|i
index|]
operator|.
name|mr_start
operator|+
name|pregions
index|[
name|i
index|]
operator|.
name|mr_size
argument_list|,
name|pregions
index|[
name|i
index|]
operator|.
name|mr_size
argument_list|)
expr_stmt|;
comment|/* 		 * Install entries into the BAT table to allow all 		 * of physmem to be convered by on-demand BAT entries. 		 * The loop will sometimes set the same battable element 		 * twice, but that's fine since they won't be used for 		 * a while yet. 		 */
name|pa
operator|=
name|pregions
index|[
name|i
index|]
operator|.
name|mr_start
operator|&
literal|0xf0000000
expr_stmt|;
name|end
operator|=
name|pregions
index|[
name|i
index|]
operator|.
name|mr_start
operator|+
name|pregions
index|[
name|i
index|]
operator|.
name|mr_size
expr_stmt|;
do|do
block|{
name|u_int
name|n
init|=
name|pa
operator|>>
name|ADDR_SR_SHFT
decl_stmt|;
name|battable
index|[
name|n
index|]
operator|.
name|batl
operator|=
name|BATL
argument_list|(
name|pa
argument_list|,
name|BAT_M
argument_list|,
name|BAT_PP_RW
argument_list|)
expr_stmt|;
name|battable
index|[
name|n
index|]
operator|.
name|batu
operator|=
name|BATU
argument_list|(
name|pa
argument_list|,
name|BAT_BL_256M
argument_list|,
name|BAT_Vs
argument_list|)
expr_stmt|;
name|pa
operator|+=
name|SEGMENT_LENGTH
expr_stmt|;
block|}
do|while
condition|(
name|pa
operator|<
name|end
condition|)
do|;
block|}
end_for

begin_if
if|if
condition|(
sizeof|sizeof
argument_list|(
name|phys_avail
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|phys_avail
index|[
literal|0
index|]
argument_list|)
operator|<
name|regions_sz
condition|)
name|panic
argument_list|(
literal|"moea_bootstrap: phys_avail too small"
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|phys_avail_count
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|physsz
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|hwphyssz
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_ULONG_FETCH
argument_list|(
literal|"hw.physmem"
argument_list|,
operator|(
name|u_long
operator|*
operator|)
operator|&
name|hwphyssz
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|regions_sz
condition|;
name|i
operator|++
operator|,
name|j
operator|+=
literal|2
control|)
block|{
name|CTR3
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"region: %#x - %#x (%#x)"
argument_list|,
name|regions
index|[
name|i
index|]
operator|.
name|mr_start
argument_list|,
name|regions
index|[
name|i
index|]
operator|.
name|mr_start
operator|+
name|regions
index|[
name|i
index|]
operator|.
name|mr_size
argument_list|,
name|regions
index|[
name|i
index|]
operator|.
name|mr_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|hwphyssz
operator|!=
literal|0
operator|&&
operator|(
name|physsz
operator|+
name|regions
index|[
name|i
index|]
operator|.
name|mr_size
operator|)
operator|>=
name|hwphyssz
condition|)
block|{
if|if
condition|(
name|physsz
operator|<
name|hwphyssz
condition|)
block|{
name|phys_avail
index|[
name|j
index|]
operator|=
name|regions
index|[
name|i
index|]
operator|.
name|mr_start
expr_stmt|;
name|phys_avail
index|[
name|j
operator|+
literal|1
index|]
operator|=
name|regions
index|[
name|i
index|]
operator|.
name|mr_start
operator|+
name|hwphyssz
operator|-
name|physsz
expr_stmt|;
name|physsz
operator|=
name|hwphyssz
expr_stmt|;
name|phys_avail_count
operator|++
expr_stmt|;
block|}
break|break;
block|}
name|phys_avail
index|[
name|j
index|]
operator|=
name|regions
index|[
name|i
index|]
operator|.
name|mr_start
expr_stmt|;
name|phys_avail
index|[
name|j
operator|+
literal|1
index|]
operator|=
name|regions
index|[
name|i
index|]
operator|.
name|mr_start
operator|+
name|regions
index|[
name|i
index|]
operator|.
name|mr_size
expr_stmt|;
name|phys_avail_count
operator|++
expr_stmt|;
name|physsz
operator|+=
name|regions
index|[
name|i
index|]
operator|.
name|mr_size
expr_stmt|;
block|}
end_for

begin_comment
comment|/* Check for overlap with the kernel and exception vectors */
end_comment

begin_for
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
operator|*
name|phys_avail_count
condition|;
name|j
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|phys_avail
index|[
name|j
index|]
operator|<
name|EXC_LAST
condition|)
name|phys_avail
index|[
name|j
index|]
operator|+=
name|EXC_LAST
expr_stmt|;
if|if
condition|(
name|kernelstart
operator|>=
name|phys_avail
index|[
name|j
index|]
operator|&&
name|kernelstart
operator|<
name|phys_avail
index|[
name|j
operator|+
literal|1
index|]
condition|)
block|{
if|if
condition|(
name|kernelend
operator|<
name|phys_avail
index|[
name|j
operator|+
literal|1
index|]
condition|)
block|{
name|phys_avail
index|[
literal|2
operator|*
name|phys_avail_count
index|]
operator|=
operator|(
name|kernelend
operator|&
operator|~
name|PAGE_MASK
operator|)
operator|+
name|PAGE_SIZE
expr_stmt|;
name|phys_avail
index|[
literal|2
operator|*
name|phys_avail_count
operator|+
literal|1
index|]
operator|=
name|phys_avail
index|[
name|j
operator|+
literal|1
index|]
expr_stmt|;
name|phys_avail_count
operator|++
expr_stmt|;
block|}
name|phys_avail
index|[
name|j
operator|+
literal|1
index|]
operator|=
name|kernelstart
operator|&
operator|~
name|PAGE_MASK
expr_stmt|;
block|}
if|if
condition|(
name|kernelend
operator|>=
name|phys_avail
index|[
name|j
index|]
operator|&&
name|kernelend
operator|<
name|phys_avail
index|[
name|j
operator|+
literal|1
index|]
condition|)
block|{
if|if
condition|(
name|kernelstart
operator|>
name|phys_avail
index|[
name|j
index|]
condition|)
block|{
name|phys_avail
index|[
literal|2
operator|*
name|phys_avail_count
index|]
operator|=
name|phys_avail
index|[
name|j
index|]
expr_stmt|;
name|phys_avail
index|[
literal|2
operator|*
name|phys_avail_count
operator|+
literal|1
index|]
operator|=
name|kernelstart
operator|&
operator|~
name|PAGE_MASK
expr_stmt|;
name|phys_avail_count
operator|++
expr_stmt|;
block|}
name|phys_avail
index|[
name|j
index|]
operator|=
operator|(
name|kernelend
operator|&
operator|~
name|PAGE_MASK
operator|)
operator|+
name|PAGE_SIZE
expr_stmt|;
block|}
block|}
end_for

begin_expr_stmt
name|physmem
operator|=
name|btoc
argument_list|(
name|physsz
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	 * Allocate PTEG table. 	 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PTEGCOUNT
end_ifdef

begin_expr_stmt
name|moea_pteg_count
operator|=
name|PTEGCOUNT
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|moea_pteg_count
operator|=
literal|0x1000
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|moea_pteg_count
operator|<
name|physmem
condition|)
name|moea_pteg_count
operator|<<=
literal|1
expr_stmt|;
end_while

begin_expr_stmt
name|moea_pteg_count
operator|>>=
literal|1
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PTEGCOUNT */
end_comment

begin_expr_stmt
name|size
operator|=
name|moea_pteg_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pteg
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"moea_bootstrap: %d PTEGs, %d bytes"
argument_list|,
name|moea_pteg_count
argument_list|,
name|size
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|moea_pteg_table
operator|=
operator|(
expr|struct
name|pteg
operator|*
operator|)
name|moea_bootstrap_alloc
argument_list|(
name|size
argument_list|,
name|size
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTR1
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"moea_bootstrap: PTEG table at %p"
argument_list|,
name|moea_pteg_table
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|moea_pteg_table
argument_list|,
name|moea_pteg_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pteg
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|moea_pteg_mask
operator|=
name|moea_pteg_count
operator|-
literal|1
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	 * Allocate pv/overflow lists. 	 */
end_comment

begin_expr_stmt
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|pvo_head
argument_list|)
operator|*
name|moea_pteg_count
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|moea_pvo_table
operator|=
operator|(
expr|struct
name|pvo_head
operator|*
operator|)
name|moea_bootstrap_alloc
argument_list|(
name|size
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTR1
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"moea_bootstrap: PVO table at %p"
argument_list|,
name|moea_pvo_table
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|moea_pteg_count
condition|;
name|i
operator|++
control|)
name|LIST_INIT
argument_list|(
operator|&
name|moea_pvo_table
index|[
name|i
index|]
argument_list|)
expr_stmt|;
end_for

begin_comment
comment|/* 	 * Initialize the lock that synchronizes access to the pteg and pvo 	 * tables. 	 */
end_comment

begin_expr_stmt
name|mtx_init
argument_list|(
operator|&
name|moea_table_mutex
argument_list|,
literal|"pmap table"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
operator||
name|MTX_RECURSE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|mtx_init
argument_list|(
operator|&
name|moea_vsid_mutex
argument_list|,
literal|"VSID table"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|mtx_init
argument_list|(
operator|&
name|tlbie_mtx
argument_list|,
literal|"tlbie"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	 * Initialise the unmanaged pvo pool. 	 */
end_comment

begin_expr_stmt
name|moea_bpvo_pool
operator|=
operator|(
expr|struct
name|pvo_entry
operator|*
operator|)
name|moea_bootstrap_alloc
argument_list|(
name|BPVO_POOL_SIZE
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pvo_entry
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|moea_bpvo_pool_index
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	 * Make sure kernel vsid is allocated as well as VSID 0. 	 */
end_comment

begin_expr_stmt
name|moea_vsid_bitmap
index|[
operator|(
name|KERNEL_VSIDBITS
operator|&
operator|(
name|NPMAPS
operator|-
literal|1
operator|)
operator|)
operator|/
name|VSID_NBPW
index|]
operator||=
literal|1
operator|<<
operator|(
name|KERNEL_VSIDBITS
operator|%
name|VSID_NBPW
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|moea_vsid_bitmap
index|[
literal|0
index|]
operator||=
literal|1
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	 * Initialize the kernel pmap (which is statically allocated). 	 */
end_comment

begin_expr_stmt
name|PMAP_LOCK_INIT
argument_list|(
name|kernel_pmap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|kernel_pmap
operator|->
name|pm_sr
index|[
name|i
index|]
operator|=
name|EMPTY_SEGMENT
operator|+
name|i
expr_stmt|;
end_for

begin_expr_stmt
name|CPU_FILL
argument_list|(
operator|&
name|kernel_pmap
operator|->
name|pm_active
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|RB_INIT
argument_list|(
operator|&
name|kernel_pmap
operator|->
name|pmap_pvo
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	 * Initialize the global pv list lock. 	 */
end_comment

begin_expr_stmt
name|rw_init
argument_list|(
operator|&
name|pvh_global_lock
argument_list|,
literal|"pmap pv global"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	 * Set up the Open Firmware mappings 	 */
end_comment

begin_expr_stmt
name|chosen
operator|=
name|OF_finddevice
argument_list|(
literal|"/chosen"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|chosen
operator|!=
operator|-
literal|1
operator|&&
name|OF_getprop
argument_list|(
name|chosen
argument_list|,
literal|"mmu"
argument_list|,
operator|&
name|mmui
argument_list|,
literal|4
argument_list|)
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|mmu
operator|=
name|OF_instance_to_package
argument_list|(
name|mmui
argument_list|)
operator|)
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|sz
operator|=
name|OF_getproplen
argument_list|(
name|mmu
argument_list|,
literal|"translations"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|translations
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|phys_avail
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
operator|>=
name|sz
condition|)
block|{
name|translations
operator|=
operator|(
expr|struct
name|ofw_map
operator|*
operator|)
name|phys_avail
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|translations
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"moea_bootstrap: no space to copy translations"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|translations
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|OF_getprop
argument_list|(
name|mmu
argument_list|,
literal|"translations"
argument_list|,
name|translations
argument_list|,
name|sz
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"moea_bootstrap: can't get ofw translations"
argument_list|)
expr_stmt|;
name|CTR0
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"moea_bootstrap: translations"
argument_list|)
expr_stmt|;
name|sz
operator|/=
sizeof|sizeof
argument_list|(
operator|*
name|translations
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|translations
argument_list|,
name|sz
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|translations
argument_list|)
argument_list|,
name|om_cmp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sz
condition|;
name|i
operator|++
control|)
block|{
name|CTR3
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"translation: pa=%#x va=%#x len=%#x"
argument_list|,
name|translations
index|[
name|i
index|]
operator|.
name|om_pa
argument_list|,
name|translations
index|[
name|i
index|]
operator|.
name|om_va
argument_list|,
name|translations
index|[
name|i
index|]
operator|.
name|om_len
argument_list|)
expr_stmt|;
comment|/* 			 * If the mapping is 1:1, let the RAM and device 			 * on-demand BAT tables take care of the translation. 			 */
if|if
condition|(
name|translations
index|[
name|i
index|]
operator|.
name|om_va
operator|==
name|translations
index|[
name|i
index|]
operator|.
name|om_pa
condition|)
continue|continue;
comment|/* Enter the pages */
for|for
control|(
name|off
operator|=
literal|0
init|;
name|off
operator|<
name|translations
index|[
name|i
index|]
operator|.
name|om_len
condition|;
name|off
operator|+=
name|PAGE_SIZE
control|)
name|moea_kenter
argument_list|(
name|mmup
argument_list|,
name|translations
index|[
name|i
index|]
operator|.
name|om_va
operator|+
name|off
argument_list|,
name|translations
index|[
name|i
index|]
operator|.
name|om_pa
operator|+
name|off
argument_list|)
expr_stmt|;
block|}
block|}
end_if

begin_comment
comment|/* 	 * Calculate the last available physical address. 	 */
end_comment

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|phys_avail
index|[
name|i
operator|+
literal|2
index|]
operator|!=
literal|0
condition|;
name|i
operator|+=
literal|2
control|)
empty_stmt|;
end_for

begin_expr_stmt
name|Maxmem
operator|=
name|powerpc_btop
argument_list|(
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|moea_cpu_bootstrap
argument_list|(
name|mmup
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|pmap_bootstrapped
operator|++
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	 * Set the start and end of kva. 	 */
end_comment

begin_expr_stmt
name|virtual_avail
operator|=
name|VM_MIN_KERNEL_ADDRESS
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|virtual_end
operator|=
name|VM_MAX_SAFE_KERNEL_ADDRESS
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	 * Allocate a kernel stack with a guard page for thread0 and map it 	 * into the kernel page map. 	 */
end_comment

begin_expr_stmt
name|pa
operator|=
name|moea_bootstrap_alloc
argument_list|(
name|KSTACK_PAGES
operator|*
name|PAGE_SIZE
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|va
operator|=
name|virtual_avail
operator|+
name|KSTACK_GUARD_PAGES
operator|*
name|PAGE_SIZE
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|virtual_avail
operator|=
name|va
operator|+
name|KSTACK_PAGES
operator|*
name|PAGE_SIZE
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"moea_bootstrap: kstack0 at %#x (%#x)"
argument_list|,
name|pa
argument_list|,
name|va
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|thread0
operator|.
name|td_kstack
operator|=
name|va
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|thread0
operator|.
name|td_kstack_pages
operator|=
name|KSTACK_PAGES
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|KSTACK_PAGES
condition|;
name|i
operator|++
control|)
block|{
name|moea_kenter
argument_list|(
name|mmup
argument_list|,
name|va
argument_list|,
name|pa
argument_list|)
expr_stmt|;
name|pa
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|va
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
end_for

begin_comment
comment|/* 	 * Allocate virtual address space for the message buffer. 	 */
end_comment

begin_expr_stmt
name|pa
operator|=
name|msgbuf_phys
operator|=
name|moea_bootstrap_alloc
argument_list|(
name|msgbufsize
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|msgbufp
operator|=
operator|(
expr|struct
name|msgbuf
operator|*
operator|)
name|virtual_avail
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|va
operator|=
name|virtual_avail
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|virtual_avail
operator|+=
name|round_page
argument_list|(
name|msgbufsize
argument_list|)
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|va
operator|<
name|virtual_avail
condition|)
block|{
name|moea_kenter
argument_list|(
name|mmup
argument_list|,
name|va
argument_list|,
name|pa
argument_list|)
expr_stmt|;
name|pa
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|va
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
end_while

begin_comment
comment|/* 	 * Allocate virtual address space for the dynamic percpu area. 	 */
end_comment

begin_expr_stmt
name|pa
operator|=
name|moea_bootstrap_alloc
argument_list|(
name|DPCPU_SIZE
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dpcpu
operator|=
operator|(
name|void
operator|*
operator|)
name|virtual_avail
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|va
operator|=
name|virtual_avail
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|virtual_avail
operator|+=
name|DPCPU_SIZE
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|va
operator|<
name|virtual_avail
condition|)
block|{
name|moea_kenter
argument_list|(
name|mmup
argument_list|,
name|va
argument_list|,
name|pa
argument_list|)
expr_stmt|;
name|pa
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|va
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
end_while

begin_expr_stmt
name|dpcpu_init
argument_list|(
name|dpcpu
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/*  * Activate a user pmap.  The pmap must be activated before it's address  * space can be accessed in any way.  */
end_comment

begin_macro
unit|void
name|moea_activate
argument_list|(
argument|mmu_t mmu
argument_list|,
argument|struct thread *td
argument_list|)
end_macro

begin_block
block|{
name|pmap_t
name|pm
decl_stmt|,
name|pmr
decl_stmt|;
comment|/* 	 * Load all the data we need up front to encourage the compiler to 	 * not issue any loads while we have interrupts disabled below. 	 */
name|pm
operator|=
operator|&
name|td
operator|->
name|td_proc
operator|->
name|p_vmspace
operator|->
name|vm_pmap
expr_stmt|;
name|pmr
operator|=
name|pm
operator|->
name|pmap_phys
expr_stmt|;
name|CPU_SET
argument_list|(
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|,
operator|&
name|pm
operator|->
name|pm_active
argument_list|)
expr_stmt|;
name|PCPU_SET
argument_list|(
name|curpmap
argument_list|,
name|pmr
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|void
name|moea_deactivate
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|pmap_t
name|pm
decl_stmt|;
name|pm
operator|=
operator|&
name|td
operator|->
name|td_proc
operator|->
name|p_vmspace
operator|->
name|vm_pmap
expr_stmt|;
name|CPU_CLR
argument_list|(
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|,
operator|&
name|pm
operator|->
name|pm_active
argument_list|)
expr_stmt|;
name|PCPU_SET
argument_list|(
name|curpmap
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|moea_change_wiring
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|boolean_t
name|wired
parameter_list|)
block|{
name|struct
name|pvo_entry
modifier|*
name|pvo
decl_stmt|;
name|PMAP_LOCK
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|pvo
operator|=
name|moea_pvo_find_va
argument_list|(
name|pm
argument_list|,
name|va
operator|&
operator|~
name|ADDR_POFF
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvo
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|wired
condition|)
block|{
if|if
condition|(
operator|(
name|pvo
operator|->
name|pvo_vaddr
operator|&
name|PVO_WIRED
operator|)
operator|==
literal|0
condition|)
name|pm
operator|->
name|pm_stats
operator|.
name|wired_count
operator|++
expr_stmt|;
name|pvo
operator|->
name|pvo_vaddr
operator||=
name|PVO_WIRED
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|pvo
operator|->
name|pvo_vaddr
operator|&
name|PVO_WIRED
operator|)
operator|!=
literal|0
condition|)
name|pm
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
name|pvo
operator|->
name|pvo_vaddr
operator|&=
operator|~
name|PVO_WIRED
expr_stmt|;
block|}
block|}
name|PMAP_UNLOCK
argument_list|(
name|pm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|moea_copy_page
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|vm_page_t
name|msrc
parameter_list|,
name|vm_page_t
name|mdst
parameter_list|)
block|{
name|vm_offset_t
name|dst
decl_stmt|;
name|vm_offset_t
name|src
decl_stmt|;
name|dst
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|mdst
argument_list|)
expr_stmt|;
name|src
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|msrc
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|src
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dst
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|moea_copy_pages
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|vm_page_t
modifier|*
name|ma
parameter_list|,
name|vm_offset_t
name|a_offset
parameter_list|,
name|vm_page_t
modifier|*
name|mb
parameter_list|,
name|vm_offset_t
name|b_offset
parameter_list|,
name|int
name|xfersize
parameter_list|)
block|{
name|void
modifier|*
name|a_cp
decl_stmt|,
modifier|*
name|b_cp
decl_stmt|;
name|vm_offset_t
name|a_pg_offset
decl_stmt|,
name|b_pg_offset
decl_stmt|;
name|int
name|cnt
decl_stmt|;
while|while
condition|(
name|xfersize
operator|>
literal|0
condition|)
block|{
name|a_pg_offset
operator|=
name|a_offset
operator|&
name|PAGE_MASK
expr_stmt|;
name|cnt
operator|=
name|min
argument_list|(
name|xfersize
argument_list|,
name|PAGE_SIZE
operator|-
name|a_pg_offset
argument_list|)
expr_stmt|;
name|a_cp
operator|=
operator|(
name|char
operator|*
operator|)
name|VM_PAGE_TO_PHYS
argument_list|(
name|ma
index|[
name|a_offset
operator|>>
name|PAGE_SHIFT
index|]
argument_list|)
operator|+
name|a_pg_offset
expr_stmt|;
name|b_pg_offset
operator|=
name|b_offset
operator|&
name|PAGE_MASK
expr_stmt|;
name|cnt
operator|=
name|min
argument_list|(
name|cnt
argument_list|,
name|PAGE_SIZE
operator|-
name|b_pg_offset
argument_list|)
expr_stmt|;
name|b_cp
operator|=
operator|(
name|char
operator|*
operator|)
name|VM_PAGE_TO_PHYS
argument_list|(
name|mb
index|[
name|b_offset
operator|>>
name|PAGE_SHIFT
index|]
argument_list|)
operator|+
name|b_pg_offset
expr_stmt|;
name|bcopy
argument_list|(
name|a_cp
argument_list|,
name|b_cp
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|a_offset
operator|+=
name|cnt
expr_stmt|;
name|b_offset
operator|+=
name|cnt
expr_stmt|;
name|xfersize
operator|-=
name|cnt
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Zero a page of physical memory by temporarily mapping it into the tlb.  */
end_comment

begin_function
name|void
name|moea_zero_page
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|vm_offset_t
name|off
decl_stmt|,
name|pa
init|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
decl_stmt|;
for|for
control|(
name|off
operator|=
literal|0
init|;
name|off
operator|<
name|PAGE_SIZE
condition|;
name|off
operator|+=
name|cacheline_size
control|)
asm|__asm __volatile("dcbz 0,%0" :: "r"(pa + off));
block|}
end_function

begin_function
name|void
name|moea_zero_page_area
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|vm_offset_t
name|pa
init|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|void
modifier|*
name|va
init|=
operator|(
name|void
operator|*
operator|)
operator|(
name|pa
operator|+
name|off
operator|)
decl_stmt|;
name|bzero
argument_list|(
name|va
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|moea_zero_page_idle
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|moea_zero_page
argument_list|(
name|mmu
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Map the given physical page at the specified virtual address in the  * target pmap with the protection requested.  If specified the page  * will be wired down.  */
end_comment

begin_function
name|int
name|moea_enter
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|u_int
name|flags
parameter_list|,
name|int8_t
name|psind
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|error
operator|=
name|moea_enter_locked
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|m
argument_list|,
name|prot
argument_list|,
name|flags
argument_list|,
name|psind
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOMEM
condition|)
return|return
operator|(
name|KERN_SUCCESS
operator|)
return|;
if|if
condition|(
operator|(
name|flags
operator|&
name|PMAP_ENTER_NOSLEEP
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|KERN_RESOURCE_SHORTAGE
operator|)
return|;
name|VM_OBJECT_ASSERT_UNLOCKED
argument_list|(
name|m
operator|->
name|object
argument_list|)
expr_stmt|;
name|VM_WAIT
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Map the given physical page at the specified virtual address in the  * target pmap with the protection requested.  If specified the page  * will be wired down.  *  * The page queues and pmap must be locked.  */
end_comment

begin_function
specifier|static
name|int
name|moea_enter_locked
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|u_int
name|flags
parameter_list|,
name|int8_t
name|psind
name|__unused
parameter_list|)
block|{
name|struct
name|pvo_head
modifier|*
name|pvo_head
decl_stmt|;
name|uma_zone_t
name|zone
decl_stmt|;
name|vm_page_t
name|pg
decl_stmt|;
name|u_int
name|pte_lo
decl_stmt|,
name|pvo_flags
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|!
name|moea_initialized
condition|)
block|{
name|pvo_head
operator|=
operator|&
name|moea_pvo_kunmanaged
expr_stmt|;
name|zone
operator|=
name|moea_upvo_zone
expr_stmt|;
name|pvo_flags
operator|=
literal|0
expr_stmt|;
name|pg
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|pvo_head
operator|=
name|vm_page_to_pvoh
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|pg
operator|=
name|m
expr_stmt|;
name|zone
operator|=
name|moea_mpvo_zone
expr_stmt|;
name|pvo_flags
operator|=
name|PVO_MANAGED
expr_stmt|;
block|}
if|if
condition|(
name|pmap_bootstrapped
condition|)
name|rw_assert
argument_list|(
operator|&
name|pvh_global_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
expr_stmt|;
name|PMAP_LOCK_ASSERT
argument_list|(
name|pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
operator|&&
operator|!
name|vm_page_xbusied
argument_list|(
name|m
argument_list|)
condition|)
name|VM_OBJECT_ASSERT_LOCKED
argument_list|(
name|m
operator|->
name|object
argument_list|)
expr_stmt|;
comment|/* XXX change the pvo head for fake pages */
if|if
condition|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|!=
literal|0
condition|)
block|{
name|pvo_flags
operator|&=
operator|~
name|PVO_MANAGED
expr_stmt|;
name|pvo_head
operator|=
operator|&
name|moea_pvo_kunmanaged
expr_stmt|;
name|zone
operator|=
name|moea_upvo_zone
expr_stmt|;
block|}
name|pte_lo
operator|=
name|moea_calc_wimg
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|,
name|pmap_page_get_memattr
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prot
operator|&
name|VM_PROT_WRITE
condition|)
block|{
name|pte_lo
operator||=
name|PTE_BW
expr_stmt|;
if|if
condition|(
name|pmap_bootstrapped
operator|&&
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
condition|)
name|vm_page_aflag_set
argument_list|(
name|m
argument_list|,
name|PGA_WRITEABLE
argument_list|)
expr_stmt|;
block|}
else|else
name|pte_lo
operator||=
name|PTE_BR
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|PMAP_ENTER_WIRED
operator|)
operator|!=
literal|0
condition|)
name|pvo_flags
operator||=
name|PVO_WIRED
expr_stmt|;
name|error
operator|=
name|moea_pvo_enter
argument_list|(
name|pmap
argument_list|,
name|zone
argument_list|,
name|pvo_head
argument_list|,
name|va
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|,
name|pte_lo
argument_list|,
name|pvo_flags
argument_list|)
expr_stmt|;
comment|/* 	 * Flush the real page from the instruction cache. This has be done 	 * for all user mappings to prevent information leakage via the 	 * instruction cache. moea_pvo_enter() returns ENOENT for the first 	 * mapping for a page. 	 */
if|if
condition|(
name|pmap
operator|!=
name|kernel_pmap
operator|&&
name|error
operator|==
name|ENOENT
operator|&&
operator|(
name|pte_lo
operator|&
operator|(
name|PTE_I
operator||
name|PTE_G
operator|)
operator|)
operator|==
literal|0
condition|)
name|moea_syncicache
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Maps a sequence of resident pages belonging to the same object.  * The sequence begins with the given page m_start.  This page is  * mapped at the given virtual address start.  Each subsequent page is  * mapped at a virtual address that is offset from start by the same  * amount as the page is offset from m_start within the object.  The  * last page in the sequence is the page with the largest offset from  * m_start that can be mapped at a virtual address less than the given  * virtual address end.  Not every virtual page between start and end  * is mapped; only those for which a resident page exists with the  * corresponding offset from m_start are mapped.  */
end_comment

begin_function
name|void
name|moea_enter_object
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|start
parameter_list|,
name|vm_offset_t
name|end
parameter_list|,
name|vm_page_t
name|m_start
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|vm_page_t
name|m
decl_stmt|;
name|vm_pindex_t
name|diff
decl_stmt|,
name|psize
decl_stmt|;
name|VM_OBJECT_ASSERT_LOCKED
argument_list|(
name|m_start
operator|->
name|object
argument_list|)
expr_stmt|;
name|psize
operator|=
name|atop
argument_list|(
name|end
operator|-
name|start
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_start
expr_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pm
argument_list|)
expr_stmt|;
while|while
condition|(
name|m
operator|!=
name|NULL
operator|&&
operator|(
name|diff
operator|=
name|m
operator|->
name|pindex
operator|-
name|m_start
operator|->
name|pindex
operator|)
operator|<
name|psize
condition|)
block|{
name|moea_enter_locked
argument_list|(
name|pm
argument_list|,
name|start
operator|+
name|ptoa
argument_list|(
name|diff
argument_list|)
argument_list|,
name|m
argument_list|,
name|prot
operator|&
operator|(
name|VM_PROT_READ
operator||
name|VM_PROT_EXECUTE
operator|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|m
operator|=
name|TAILQ_NEXT
argument_list|(
name|m
argument_list|,
name|listq
argument_list|)
expr_stmt|;
block|}
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|moea_enter_quick
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|moea_enter_locked
argument_list|(
name|pm
argument_list|,
name|va
argument_list|,
name|m
argument_list|,
name|prot
operator|&
operator|(
name|VM_PROT_READ
operator||
name|VM_PROT_EXECUTE
operator|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|vm_paddr_t
name|moea_extract
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|struct
name|pvo_entry
modifier|*
name|pvo
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|PMAP_LOCK
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|pvo
operator|=
name|moea_pvo_find_va
argument_list|(
name|pm
argument_list|,
name|va
operator|&
operator|~
name|ADDR_POFF
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvo
operator|==
name|NULL
condition|)
name|pa
operator|=
literal|0
expr_stmt|;
else|else
name|pa
operator|=
operator|(
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte
operator|.
name|pte_lo
operator|&
name|PTE_RPGN
operator|)
operator||
operator|(
name|va
operator|&
name|ADDR_POFF
operator|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pm
argument_list|)
expr_stmt|;
return|return
operator|(
name|pa
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Atomically extract and hold the physical page with the given  * pmap and virtual address pair if that mapping permits the given  * protection.  */
end_comment

begin_function
name|vm_page_t
name|moea_extract_and_hold
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|struct
name|pvo_entry
modifier|*
name|pvo
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
name|pa
operator|=
literal|0
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|retry
label|:
name|pvo
operator|=
name|moea_pvo_find_va
argument_list|(
name|pmap
argument_list|,
name|va
operator|&
operator|~
name|ADDR_POFF
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvo
operator|!=
name|NULL
operator|&&
operator|(
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte
operator|.
name|pte_hi
operator|&
name|PTE_VALID
operator|)
operator|&&
operator|(
operator|(
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte
operator|.
name|pte_lo
operator|&
name|PTE_PP
operator|)
operator|==
name|PTE_RW
operator|||
operator|(
name|prot
operator|&
name|VM_PROT_WRITE
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|vm_page_pa_tryrelock
argument_list|(
name|pmap
argument_list|,
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte
operator|.
name|pte_lo
operator|&
name|PTE_RPGN
argument_list|,
operator|&
name|pa
argument_list|)
condition|)
goto|goto
name|retry
goto|;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte
operator|.
name|pte_lo
operator|&
name|PTE_RPGN
argument_list|)
expr_stmt|;
name|vm_page_hold
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|PA_UNLOCK_COND
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_function
name|void
name|moea_init
parameter_list|(
name|mmu_t
name|mmu
parameter_list|)
block|{
name|moea_upvo_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"UPVO entry"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pvo_entry
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
name|UMA_ZONE_VM
operator||
name|UMA_ZONE_NOFREE
argument_list|)
expr_stmt|;
name|moea_mpvo_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"MPVO entry"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pvo_entry
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
name|UMA_ZONE_VM
operator||
name|UMA_ZONE_NOFREE
argument_list|)
expr_stmt|;
name|moea_initialized
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_function
name|boolean_t
name|moea_is_referenced
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|boolean_t
name|rv
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"moea_is_referenced: page %p is not managed"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|rv
operator|=
name|moea_query_bit
argument_list|(
name|m
argument_list|,
name|PTE_REF
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|moea_is_modified
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|boolean_t
name|rv
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"moea_is_modified: page %p is not managed"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If the page is not exclusive busied, then PGA_WRITEABLE cannot be 	 * concurrently set while the object is locked.  Thus, if PGA_WRITEABLE 	 * is clear, no PTEs can have PTE_CHG set. 	 */
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|m
operator|->
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vm_page_xbusied
argument_list|(
name|m
argument_list|)
operator|&&
operator|(
name|m
operator|->
name|aflags
operator|&
name|PGA_WRITEABLE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|rv
operator|=
name|moea_query_bit
argument_list|(
name|m
argument_list|,
name|PTE_CHG
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|moea_is_prefaultable
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|struct
name|pvo_entry
modifier|*
name|pvo
decl_stmt|;
name|boolean_t
name|rv
decl_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pvo
operator|=
name|moea_pvo_find_va
argument_list|(
name|pmap
argument_list|,
name|va
operator|&
operator|~
name|ADDR_POFF
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rv
operator|=
name|pvo
operator|==
name|NULL
operator|||
operator|(
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte
operator|.
name|pte_hi
operator|&
name|PTE_VALID
operator|)
operator|==
literal|0
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
name|void
name|moea_clear_modify
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"moea_clear_modify: page %p is not managed"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|m
operator|->
name|object
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|vm_page_xbusied
argument_list|(
name|m
argument_list|)
argument_list|,
operator|(
literal|"moea_clear_modify: page %p is exclusive busy"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If the page is not PGA_WRITEABLE, then no PTEs can have PTE_CHG 	 * set.  If the object containing the page is locked and the page is 	 * not exclusive busied, then PGA_WRITEABLE cannot be concurrently set. 	 */
if|if
condition|(
operator|(
name|m
operator|->
name|aflags
operator|&
name|PGA_WRITEABLE
operator|)
operator|==
literal|0
condition|)
return|return;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|moea_clear_bit
argument_list|(
name|m
argument_list|,
name|PTE_CHG
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Clear the write and modified bits in each of the given page's mappings.  */
end_comment

begin_function
name|void
name|moea_remove_write
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|struct
name|pvo_entry
modifier|*
name|pvo
decl_stmt|;
name|struct
name|pte
modifier|*
name|pt
decl_stmt|;
name|pmap_t
name|pmap
decl_stmt|;
name|u_int
name|lo
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"moea_remove_write: page %p is not managed"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If the page is not exclusive busied, then PGA_WRITEABLE cannot be 	 * set by another thread while the object is locked.  Thus, 	 * if PGA_WRITEABLE is clear, no page table entries need updating. 	 */
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|m
operator|->
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vm_page_xbusied
argument_list|(
name|m
argument_list|)
operator|&&
operator|(
name|m
operator|->
name|aflags
operator|&
name|PGA_WRITEABLE
operator|)
operator|==
literal|0
condition|)
return|return;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|lo
operator|=
name|moea_attr_fetch
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|powerpc_sync
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|pvo
argument_list|,
argument|vm_page_to_pvoh(m)
argument_list|,
argument|pvo_vlink
argument_list|)
block|{
name|pmap
operator|=
name|pvo
operator|->
name|pvo_pmap
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte
operator|.
name|pte_lo
operator|&
name|PTE_PP
operator|)
operator|!=
name|PTE_BR
condition|)
block|{
name|pt
operator|=
name|moea_pvo_to_pte
argument_list|(
name|pvo
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte
operator|.
name|pte_lo
operator|&=
operator|~
name|PTE_PP
expr_stmt|;
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte
operator|.
name|pte_lo
operator||=
name|PTE_BR
expr_stmt|;
if|if
condition|(
name|pt
operator|!=
name|NULL
condition|)
block|{
name|moea_pte_synch
argument_list|(
name|pt
argument_list|,
operator|&
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte
argument_list|)
expr_stmt|;
name|lo
operator||=
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte
operator|.
name|pte_lo
expr_stmt|;
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte
operator|.
name|pte_lo
operator|&=
operator|~
name|PTE_CHG
expr_stmt|;
name|moea_pte_change
argument_list|(
name|pt
argument_list|,
operator|&
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte
argument_list|,
name|pvo
operator|->
name|pvo_vaddr
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|moea_table_mutex
argument_list|)
expr_stmt|;
block|}
block|}
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|lo
operator|&
name|PTE_CHG
operator|)
operator|!=
literal|0
condition|)
block|{
name|moea_attr_clear
argument_list|(
name|m
argument_list|,
name|PTE_CHG
argument_list|)
expr_stmt|;
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|vm_page_aflag_clear
argument_list|(
name|m
argument_list|,
name|PGA_WRITEABLE
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	moea_ts_referenced:  *  *	Return a count of reference bits for a page, clearing those bits.  *	It is not necessary for every reference bit to be cleared, but it  *	is necessary that 0 only be returned when there are truly no  *	reference bits set.  *  *	XXX: The exact number of bits to check and clear is a matter that  *	should be tested and standardized at some point in the future for  *	optimal aging of shared pages.  */
end_comment

begin_function
name|int
name|moea_ts_referenced
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|int
name|count
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"moea_ts_referenced: page %p is not managed"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|count
operator|=
name|moea_clear_bit
argument_list|(
name|m
argument_list|,
name|PTE_REF
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Modify the WIMG settings of all mappings for a page.  */
end_comment

begin_function
name|void
name|moea_page_set_memattr
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_memattr_t
name|ma
parameter_list|)
block|{
name|struct
name|pvo_entry
modifier|*
name|pvo
decl_stmt|;
name|struct
name|pvo_head
modifier|*
name|pvo_head
decl_stmt|;
name|struct
name|pte
modifier|*
name|pt
decl_stmt|;
name|pmap_t
name|pmap
decl_stmt|;
name|u_int
name|lo
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|!=
literal|0
condition|)
block|{
name|m
operator|->
name|md
operator|.
name|mdpg_cache_attrs
operator|=
name|ma
expr_stmt|;
return|return;
block|}
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|pvo_head
operator|=
name|vm_page_to_pvoh
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|lo
operator|=
name|moea_calc_wimg
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|,
name|ma
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|pvo
argument_list|,
argument|pvo_head
argument_list|,
argument|pvo_vlink
argument_list|)
block|{
name|pmap
operator|=
name|pvo
operator|->
name|pvo_pmap
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pt
operator|=
name|moea_pvo_to_pte
argument_list|(
name|pvo
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte
operator|.
name|pte_lo
operator|&=
operator|~
name|PTE_WIMG
expr_stmt|;
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte
operator|.
name|pte_lo
operator||=
name|lo
expr_stmt|;
if|if
condition|(
name|pt
operator|!=
name|NULL
condition|)
block|{
name|moea_pte_change
argument_list|(
name|pt
argument_list|,
operator|&
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte
argument_list|,
name|pvo
operator|->
name|pvo_vaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvo
operator|->
name|pvo_pmap
operator|==
name|kernel_pmap
condition|)
name|isync
argument_list|()
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|moea_table_mutex
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
name|m
operator|->
name|md
operator|.
name|mdpg_cache_attrs
operator|=
name|ma
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Map a wired page into kernel virtual address space.  */
end_comment

begin_function
name|void
name|moea_kenter
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_paddr_t
name|pa
parameter_list|)
block|{
name|moea_kenter_attr
argument_list|(
name|mmu
argument_list|,
name|va
argument_list|,
name|pa
argument_list|,
name|VM_MEMATTR_DEFAULT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|moea_kenter_attr
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_offset_t
name|pa
parameter_list|,
name|vm_memattr_t
name|ma
parameter_list|)
block|{
name|u_int
name|pte_lo
decl_stmt|;
name|int
name|error
decl_stmt|;
if|#
directive|if
literal|0
block|if (va< VM_MIN_KERNEL_ADDRESS) 		panic("moea_kenter: attempt to enter non-kernel address %#x", 		    va);
endif|#
directive|endif
name|pte_lo
operator|=
name|moea_calc_wimg
argument_list|(
name|pa
argument_list|,
name|ma
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|kernel_pmap
argument_list|)
expr_stmt|;
name|error
operator|=
name|moea_pvo_enter
argument_list|(
name|kernel_pmap
argument_list|,
name|moea_upvo_zone
argument_list|,
operator|&
name|moea_pvo_kunmanaged
argument_list|,
name|va
argument_list|,
name|pa
argument_list|,
name|pte_lo
argument_list|,
name|PVO_WIRED
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|ENOENT
condition|)
name|panic
argument_list|(
literal|"moea_kenter: failed to enter va %#x pa %#x: %d"
argument_list|,
name|va
argument_list|,
name|pa
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|kernel_pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Extract the physical page address associated with the given kernel virtual  * address.  */
end_comment

begin_function
name|vm_paddr_t
name|moea_kextract
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|struct
name|pvo_entry
modifier|*
name|pvo
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
comment|/* 	 * Allow direct mappings on 32-bit OEA 	 */
if|if
condition|(
name|va
operator|<
name|VM_MIN_KERNEL_ADDRESS
condition|)
block|{
return|return
operator|(
name|va
operator|)
return|;
block|}
name|PMAP_LOCK
argument_list|(
name|kernel_pmap
argument_list|)
expr_stmt|;
name|pvo
operator|=
name|moea_pvo_find_va
argument_list|(
name|kernel_pmap
argument_list|,
name|va
operator|&
operator|~
name|ADDR_POFF
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pvo
operator|!=
name|NULL
argument_list|,
operator|(
literal|"moea_kextract: no addr found"
operator|)
argument_list|)
expr_stmt|;
name|pa
operator|=
operator|(
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte
operator|.
name|pte_lo
operator|&
name|PTE_RPGN
operator|)
operator||
operator|(
name|va
operator|&
name|ADDR_POFF
operator|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|kernel_pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|pa
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove a wired page from kernel virtual address space.  */
end_comment

begin_function
name|void
name|moea_kremove
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|moea_remove
argument_list|(
name|mmu
argument_list|,
name|kernel_pmap
argument_list|,
name|va
argument_list|,
name|va
operator|+
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Map a range of physical addresses into kernel virtual address space.  *  * The value passed in *virt is a suggested virtual address for the mapping.  * Architectures which can support a direct-mapped physical to virtual region  * can return the appropriate address within that region, leaving '*virt'  * unchanged.  We cannot and therefore do not; *virt is updated with the  * first usable address after the mapped region.  */
end_comment

begin_function
name|vm_offset_t
name|moea_map
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|vm_offset_t
modifier|*
name|virt
parameter_list|,
name|vm_paddr_t
name|pa_start
parameter_list|,
name|vm_paddr_t
name|pa_end
parameter_list|,
name|int
name|prot
parameter_list|)
block|{
name|vm_offset_t
name|sva
decl_stmt|,
name|va
decl_stmt|;
name|sva
operator|=
operator|*
name|virt
expr_stmt|;
name|va
operator|=
name|sva
expr_stmt|;
for|for
control|(
init|;
name|pa_start
operator|<
name|pa_end
condition|;
name|pa_start
operator|+=
name|PAGE_SIZE
operator|,
name|va
operator|+=
name|PAGE_SIZE
control|)
name|moea_kenter
argument_list|(
name|mmu
argument_list|,
name|va
argument_list|,
name|pa_start
argument_list|)
expr_stmt|;
operator|*
name|virt
operator|=
name|va
expr_stmt|;
return|return
operator|(
name|sva
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns true if the pmap's pv is one of the first  * 16 pvs linked to from this page.  This count may  * be changed upwards or downwards in the future; it  * is only necessary that true be returned for a small  * subset of pmaps for proper page aging.  */
end_comment

begin_function
name|boolean_t
name|moea_page_exists_quick
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|pmap_t
name|pmap
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|int
name|loops
decl_stmt|;
name|struct
name|pvo_entry
modifier|*
name|pvo
decl_stmt|;
name|boolean_t
name|rv
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"moea_page_exists_quick: page %p is not managed"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|loops
operator|=
literal|0
expr_stmt|;
name|rv
operator|=
name|FALSE
expr_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|pvo
argument_list|,
argument|vm_page_to_pvoh(m)
argument_list|,
argument|pvo_vlink
argument_list|)
block|{
if|if
condition|(
name|pvo
operator|->
name|pvo_pmap
operator|==
name|pmap
condition|)
block|{
name|rv
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|++
name|loops
operator|>=
literal|16
condition|)
break|break;
block|}
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the number of managed mappings to the given physical page  * that are wired.  */
end_comment

begin_function
name|int
name|moea_page_wired_mappings
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|struct
name|pvo_entry
modifier|*
name|pvo
decl_stmt|;
name|int
name|count
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|count
operator|)
return|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|pvo
argument_list|,
argument|vm_page_to_pvoh(m)
argument_list|,
argument|pvo_vlink
argument_list|)
if|if
condition|(
operator|(
name|pvo
operator|->
name|pvo_vaddr
operator|&
name|PVO_WIRED
operator|)
operator|!=
literal|0
condition|)
name|count
operator|++
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|u_int
name|moea_vsidcontext
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|moea_pinit
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|pmap_t
name|pmap
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|mask
decl_stmt|;
name|u_int
name|entropy
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|int
operator|)
name|pmap
operator|<
name|VM_MIN_KERNEL_ADDRESS
argument_list|,
operator|(
literal|"moea_pinit: virt pmap"
operator|)
argument_list|)
expr_stmt|;
name|RB_INIT
argument_list|(
operator|&
name|pmap
operator|->
name|pmap_pvo
argument_list|)
expr_stmt|;
name|entropy
operator|=
literal|0
expr_stmt|;
asm|__asm __volatile("mftb %0" : "=r"(entropy));
if|if
condition|(
operator|(
name|pmap
operator|->
name|pmap_phys
operator|=
operator|(
name|pmap_t
operator|)
name|moea_kextract
argument_list|(
name|mmu
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|pmap
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|pmap
operator|->
name|pmap_phys
operator|=
name|pmap
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|moea_vsid_mutex
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate some segment registers for this pmap. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NPMAPS
condition|;
name|i
operator|+=
name|VSID_NBPW
control|)
block|{
name|u_int
name|hash
decl_stmt|,
name|n
decl_stmt|;
comment|/* 		 * Create a new value by mutiplying by a prime and adding in 		 * entropy from the timebase register.  This is to make the 		 * VSID more random so that the PT hash function collides 		 * less often.  (Note that the prime casues gcc to do shifts 		 * instead of a multiply.) 		 */
name|moea_vsidcontext
operator|=
operator|(
name|moea_vsidcontext
operator|*
literal|0x1105
operator|)
operator|+
name|entropy
expr_stmt|;
name|hash
operator|=
name|moea_vsidcontext
operator|&
operator|(
name|NPMAPS
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|hash
operator|==
literal|0
condition|)
comment|/* 0 is special, avoid it */
continue|continue;
name|n
operator|=
name|hash
operator|>>
literal|5
expr_stmt|;
name|mask
operator|=
literal|1
operator|<<
operator|(
name|hash
operator|&
operator|(
name|VSID_NBPW
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|hash
operator|=
operator|(
name|moea_vsidcontext
operator|&
literal|0xfffff
operator|)
expr_stmt|;
if|if
condition|(
name|moea_vsid_bitmap
index|[
name|n
index|]
operator|&
name|mask
condition|)
block|{
comment|/* collision? */
comment|/* anything free in this bucket? */
if|if
condition|(
name|moea_vsid_bitmap
index|[
name|n
index|]
operator|==
literal|0xffffffff
condition|)
block|{
name|entropy
operator|=
operator|(
name|moea_vsidcontext
operator|>>
literal|20
operator|)
expr_stmt|;
continue|continue;
block|}
name|i
operator|=
name|ffs
argument_list|(
operator|~
name|moea_vsid_bitmap
index|[
name|n
index|]
argument_list|)
operator|-
literal|1
expr_stmt|;
name|mask
operator|=
literal|1
operator|<<
name|i
expr_stmt|;
name|hash
operator|&=
literal|0xfffff
operator|&
operator|~
operator|(
name|VSID_NBPW
operator|-
literal|1
operator|)
expr_stmt|;
name|hash
operator||=
name|i
expr_stmt|;
block|}
name|KASSERT
argument_list|(
operator|!
operator|(
name|moea_vsid_bitmap
index|[
name|n
index|]
operator|&
name|mask
operator|)
argument_list|,
operator|(
literal|"Allocating in-use VSID group %#x\n"
operator|,
name|hash
operator|)
argument_list|)
expr_stmt|;
name|moea_vsid_bitmap
index|[
name|n
index|]
operator||=
name|mask
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|pmap
operator|->
name|pm_sr
index|[
name|i
index|]
operator|=
name|VSID_MAKE
argument_list|(
name|i
argument_list|,
name|hash
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|moea_vsid_mutex
argument_list|)
expr_stmt|;
return|return;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|moea_vsid_mutex
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"moea_pinit: out of segments"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize the pmap associated with process 0.  */
end_comment

begin_function
name|void
name|moea_pinit0
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|pmap_t
name|pm
parameter_list|)
block|{
name|PMAP_LOCK_INIT
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|moea_pinit
argument_list|(
name|mmu
argument_list|,
name|pm
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|pm
operator|->
name|pm_stats
argument_list|,
sizeof|sizeof
argument_list|(
name|pm
operator|->
name|pm_stats
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the physical protection on the specified range of this map as requested.  */
end_comment

begin_function
name|void
name|moea_protect
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|,
name|vm_offset_t
name|eva
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|struct
name|pvo_entry
modifier|*
name|pvo
decl_stmt|,
modifier|*
name|tpvo
decl_stmt|,
name|key
decl_stmt|;
name|struct
name|pte
modifier|*
name|pt
decl_stmt|;
name|KASSERT
argument_list|(
name|pm
operator|==
operator|&
name|curproc
operator|->
name|p_vmspace
operator|->
name|vm_pmap
operator|||
name|pm
operator|==
name|kernel_pmap
argument_list|,
operator|(
literal|"moea_protect: non current pmap"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|prot
operator|&
name|VM_PROT_READ
operator|)
operator|==
name|VM_PROT_NONE
condition|)
block|{
name|moea_remove
argument_list|(
name|mmu
argument_list|,
name|pm
argument_list|,
name|sva
argument_list|,
name|eva
argument_list|)
expr_stmt|;
return|return;
block|}
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|key
operator|.
name|pvo_vaddr
operator|=
name|sva
expr_stmt|;
for|for
control|(
name|pvo
operator|=
name|RB_NFIND
argument_list|(
name|pvo_tree
argument_list|,
operator|&
name|pm
operator|->
name|pmap_pvo
argument_list|,
operator|&
name|key
argument_list|)
init|;
name|pvo
operator|!=
name|NULL
operator|&&
name|PVO_VADDR
argument_list|(
name|pvo
argument_list|)
operator|<
name|eva
condition|;
name|pvo
operator|=
name|tpvo
control|)
block|{
name|tpvo
operator|=
name|RB_NEXT
argument_list|(
name|pvo_tree
argument_list|,
operator|&
name|pm
operator|->
name|pmap_pvo
argument_list|,
name|pvo
argument_list|)
expr_stmt|;
comment|/* 		 * Grab the PTE pointer before we diddle with the cached PTE 		 * copy. 		 */
name|pt
operator|=
name|moea_pvo_to_pte
argument_list|(
name|pvo
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * Change the protection of the page. 		 */
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte
operator|.
name|pte_lo
operator|&=
operator|~
name|PTE_PP
expr_stmt|;
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte
operator|.
name|pte_lo
operator||=
name|PTE_BR
expr_stmt|;
comment|/* 		 * If the PVO is in the page table, update that pte as well. 		 */
if|if
condition|(
name|pt
operator|!=
name|NULL
condition|)
block|{
name|moea_pte_change
argument_list|(
name|pt
argument_list|,
operator|&
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte
argument_list|,
name|pvo
operator|->
name|pvo_vaddr
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|moea_table_mutex
argument_list|)
expr_stmt|;
block|}
block|}
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Map a list of wired pages into kernel virtual address space.  This is  * intended for temporary mappings which do not need page modification or  * references recorded.  Existing mappings in the region are overwritten.  */
end_comment

begin_function
name|void
name|moea_qenter
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|,
name|vm_page_t
modifier|*
name|m
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|vm_offset_t
name|va
decl_stmt|;
name|va
operator|=
name|sva
expr_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
name|moea_kenter
argument_list|(
name|mmu
argument_list|,
name|va
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
operator|*
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|va
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|m
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Remove page mappings from kernel virtual address space.  Intended for  * temporary mappings entered by moea_qenter.  */
end_comment

begin_function
name|void
name|moea_qremove
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|vm_offset_t
name|va
decl_stmt|;
name|va
operator|=
name|sva
expr_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
name|moea_kremove
argument_list|(
name|mmu
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|va
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|moea_release
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|pmap_t
name|pmap
parameter_list|)
block|{
name|int
name|idx
decl_stmt|,
name|mask
decl_stmt|;
comment|/* 	 * Free segment register's VSID 	 */
if|if
condition|(
name|pmap
operator|->
name|pm_sr
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"moea_release"
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|moea_vsid_mutex
argument_list|)
expr_stmt|;
name|idx
operator|=
name|VSID_TO_HASH
argument_list|(
name|pmap
operator|->
name|pm_sr
index|[
literal|0
index|]
argument_list|)
operator|&
operator|(
name|NPMAPS
operator|-
literal|1
operator|)
expr_stmt|;
name|mask
operator|=
literal|1
operator|<<
operator|(
name|idx
operator|%
name|VSID_NBPW
operator|)
expr_stmt|;
name|idx
operator|/=
name|VSID_NBPW
expr_stmt|;
name|moea_vsid_bitmap
index|[
name|idx
index|]
operator|&=
operator|~
name|mask
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|moea_vsid_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove the given range of addresses from the specified map.  */
end_comment

begin_function
name|void
name|moea_remove
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|,
name|vm_offset_t
name|eva
parameter_list|)
block|{
name|struct
name|pvo_entry
modifier|*
name|pvo
decl_stmt|,
modifier|*
name|tpvo
decl_stmt|,
name|key
decl_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|key
operator|.
name|pvo_vaddr
operator|=
name|sva
expr_stmt|;
for|for
control|(
name|pvo
operator|=
name|RB_NFIND
argument_list|(
name|pvo_tree
argument_list|,
operator|&
name|pm
operator|->
name|pmap_pvo
argument_list|,
operator|&
name|key
argument_list|)
init|;
name|pvo
operator|!=
name|NULL
operator|&&
name|PVO_VADDR
argument_list|(
name|pvo
argument_list|)
operator|<
name|eva
condition|;
name|pvo
operator|=
name|tpvo
control|)
block|{
name|tpvo
operator|=
name|RB_NEXT
argument_list|(
name|pvo_tree
argument_list|,
operator|&
name|pm
operator|->
name|pmap_pvo
argument_list|,
name|pvo
argument_list|)
expr_stmt|;
name|moea_pvo_remove
argument_list|(
name|pvo
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|PMAP_UNLOCK
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove physical page from all pmaps in which it resides. moea_pvo_remove()  * will reflect changes in pte's back to the vm_page.  */
end_comment

begin_function
name|void
name|moea_remove_all
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|struct
name|pvo_head
modifier|*
name|pvo_head
decl_stmt|;
name|struct
name|pvo_entry
modifier|*
name|pvo
decl_stmt|,
modifier|*
name|next_pvo
decl_stmt|;
name|pmap_t
name|pmap
decl_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|pvo_head
operator|=
name|vm_page_to_pvoh
argument_list|(
name|m
argument_list|)
expr_stmt|;
for|for
control|(
name|pvo
operator|=
name|LIST_FIRST
argument_list|(
name|pvo_head
argument_list|)
init|;
name|pvo
operator|!=
name|NULL
condition|;
name|pvo
operator|=
name|next_pvo
control|)
block|{
name|next_pvo
operator|=
name|LIST_NEXT
argument_list|(
name|pvo
argument_list|,
name|pvo_vlink
argument_list|)
expr_stmt|;
name|pmap
operator|=
name|pvo
operator|->
name|pvo_pmap
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|moea_pvo_remove
argument_list|(
name|pvo
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|m
operator|->
name|aflags
operator|&
name|PGA_WRITEABLE
operator|)
operator|&&
name|moea_query_bit
argument_list|(
name|m
argument_list|,
name|PTE_CHG
argument_list|)
condition|)
block|{
name|moea_attr_clear
argument_list|(
name|m
argument_list|,
name|PTE_CHG
argument_list|)
expr_stmt|;
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|vm_page_aflag_clear
argument_list|(
name|m
argument_list|,
name|PGA_WRITEABLE
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a physical page of memory directly from the phys_avail map.  * Can only be called from moea_bootstrap before avail start and end are  * calculated.  */
end_comment

begin_function
specifier|static
name|vm_offset_t
name|moea_bootstrap_alloc
parameter_list|(
name|vm_size_t
name|size
parameter_list|,
name|u_int
name|align
parameter_list|)
block|{
name|vm_offset_t
name|s
decl_stmt|,
name|e
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|size
operator|=
name|round_page
argument_list|(
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
operator|!=
literal|0
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|align
operator|!=
literal|0
condition|)
name|s
operator|=
operator|(
name|phys_avail
index|[
name|i
index|]
operator|+
name|align
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|align
operator|-
literal|1
operator|)
expr_stmt|;
else|else
name|s
operator|=
name|phys_avail
index|[
name|i
index|]
expr_stmt|;
name|e
operator|=
name|s
operator|+
name|size
expr_stmt|;
if|if
condition|(
name|s
operator|<
name|phys_avail
index|[
name|i
index|]
operator|||
name|e
operator|>
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
condition|)
continue|continue;
if|if
condition|(
name|s
operator|==
name|phys_avail
index|[
name|i
index|]
condition|)
block|{
name|phys_avail
index|[
name|i
index|]
operator|+=
name|size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|e
operator|==
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
condition|)
block|{
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
operator|-=
name|size
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|j
operator|=
name|phys_avail_count
operator|*
literal|2
init|;
name|j
operator|>
name|i
condition|;
name|j
operator|-=
literal|2
control|)
block|{
name|phys_avail
index|[
name|j
index|]
operator|=
name|phys_avail
index|[
name|j
operator|-
literal|2
index|]
expr_stmt|;
name|phys_avail
index|[
name|j
operator|+
literal|1
index|]
operator|=
name|phys_avail
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|phys_avail
index|[
name|i
operator|+
literal|3
index|]
operator|=
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|s
expr_stmt|;
name|phys_avail
index|[
name|i
operator|+
literal|2
index|]
operator|=
name|e
expr_stmt|;
name|phys_avail_count
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|s
operator|)
return|;
block|}
name|panic
argument_list|(
literal|"moea_bootstrap_alloc: could not allocate memory"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|moea_syncicache
parameter_list|(
name|vm_offset_t
name|pa
parameter_list|,
name|vm_size_t
name|len
parameter_list|)
block|{
name|__syncicache
argument_list|(
operator|(
name|void
operator|*
operator|)
name|pa
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|moea_pvo_enter
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|uma_zone_t
name|zone
parameter_list|,
name|struct
name|pvo_head
modifier|*
name|pvo_head
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_offset_t
name|pa
parameter_list|,
name|u_int
name|pte_lo
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|pvo_entry
modifier|*
name|pvo
decl_stmt|;
name|u_int
name|sr
decl_stmt|;
name|int
name|first
decl_stmt|;
name|u_int
name|ptegidx
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|bootstrap
decl_stmt|;
name|moea_pvo_enter_calls
operator|++
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
name|bootstrap
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Compute the PTE Group index. 	 */
name|va
operator|&=
operator|~
name|ADDR_POFF
expr_stmt|;
name|sr
operator|=
name|va_to_sr
argument_list|(
name|pm
operator|->
name|pm_sr
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|ptegidx
operator|=
name|va_to_pteg
argument_list|(
name|sr
argument_list|,
name|va
argument_list|)
expr_stmt|;
comment|/* 	 * Remove any existing mapping for this page.  Reuse the pvo entry if 	 * there is a mapping. 	 */
name|mtx_lock
argument_list|(
operator|&
name|moea_table_mutex
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|pvo
argument_list|,
argument|&moea_pvo_table[ptegidx]
argument_list|,
argument|pvo_olink
argument_list|)
block|{
if|if
condition|(
name|pvo
operator|->
name|pvo_pmap
operator|==
name|pm
operator|&&
name|PVO_VADDR
argument_list|(
name|pvo
argument_list|)
operator|==
name|va
condition|)
block|{
if|if
condition|(
operator|(
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte
operator|.
name|pte_lo
operator|&
name|PTE_RPGN
operator|)
operator|==
name|pa
operator|&&
operator|(
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte
operator|.
name|pte_lo
operator|&
name|PTE_PP
operator|)
operator|==
operator|(
name|pte_lo
operator|&
name|PTE_PP
operator|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|moea_table_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|moea_pvo_remove
argument_list|(
name|pvo
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * If we aren't overwriting a mapping, try to allocate. 	 */
if|if
condition|(
name|moea_initialized
condition|)
block|{
name|pvo
operator|=
name|uma_zalloc
argument_list|(
name|zone
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|moea_bpvo_pool_index
operator|>=
name|BPVO_POOL_SIZE
condition|)
block|{
name|panic
argument_list|(
literal|"moea_enter: bpvo pool exhausted, %d, %d, %d"
argument_list|,
name|moea_bpvo_pool_index
argument_list|,
name|BPVO_POOL_SIZE
argument_list|,
name|BPVO_POOL_SIZE
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pvo_entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pvo
operator|=
operator|&
name|moea_bpvo_pool
index|[
name|moea_bpvo_pool_index
index|]
expr_stmt|;
name|moea_bpvo_pool_index
operator|++
expr_stmt|;
name|bootstrap
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|pvo
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|moea_table_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|moea_pvo_entries
operator|++
expr_stmt|;
name|pvo
operator|->
name|pvo_vaddr
operator|=
name|va
expr_stmt|;
name|pvo
operator|->
name|pvo_pmap
operator|=
name|pm
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|moea_pvo_table
index|[
name|ptegidx
index|]
argument_list|,
name|pvo
argument_list|,
name|pvo_olink
argument_list|)
expr_stmt|;
name|pvo
operator|->
name|pvo_vaddr
operator|&=
operator|~
name|ADDR_POFF
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|PVO_WIRED
condition|)
name|pvo
operator|->
name|pvo_vaddr
operator||=
name|PVO_WIRED
expr_stmt|;
if|if
condition|(
name|pvo_head
operator|!=
operator|&
name|moea_pvo_kunmanaged
condition|)
name|pvo
operator|->
name|pvo_vaddr
operator||=
name|PVO_MANAGED
expr_stmt|;
if|if
condition|(
name|bootstrap
condition|)
name|pvo
operator|->
name|pvo_vaddr
operator||=
name|PVO_BOOTSTRAP
expr_stmt|;
name|moea_pte_create
argument_list|(
operator|&
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte
argument_list|,
name|sr
argument_list|,
name|va
argument_list|,
name|pa
operator||
name|pte_lo
argument_list|)
expr_stmt|;
comment|/* 	 * Add to pmap list 	 */
name|RB_INSERT
argument_list|(
name|pvo_tree
argument_list|,
operator|&
name|pm
operator|->
name|pmap_pvo
argument_list|,
name|pvo
argument_list|)
expr_stmt|;
comment|/* 	 * Remember if the list was empty and therefore will be the first 	 * item. 	 */
if|if
condition|(
name|LIST_FIRST
argument_list|(
name|pvo_head
argument_list|)
operator|==
name|NULL
condition|)
name|first
operator|=
literal|1
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|pvo_head
argument_list|,
name|pvo
argument_list|,
name|pvo_vlink
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte
operator|.
name|pte_lo
operator|&
name|PVO_WIRED
condition|)
name|pm
operator|->
name|pm_stats
operator|.
name|wired_count
operator|++
expr_stmt|;
name|pm
operator|->
name|pm_stats
operator|.
name|resident_count
operator|++
expr_stmt|;
name|i
operator|=
name|moea_pte_insert
argument_list|(
name|ptegidx
argument_list|,
operator|&
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|i
operator|<
literal|8
argument_list|,
operator|(
literal|"Invalid PTE index"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|PVO_PTEGIDX_SET
argument_list|(
name|pvo
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|panic
argument_list|(
literal|"moea_pvo_enter: overflow"
argument_list|)
expr_stmt|;
name|moea_pte_overflow
operator|++
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|moea_table_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|first
condition|?
name|ENOENT
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|moea_pvo_remove
parameter_list|(
name|struct
name|pvo_entry
modifier|*
name|pvo
parameter_list|,
name|int
name|pteidx
parameter_list|)
block|{
name|struct
name|pte
modifier|*
name|pt
decl_stmt|;
comment|/* 	 * If there is an active pte entry, we need to deactivate it (and 	 * save the ref& cfg bits). 	 */
name|pt
operator|=
name|moea_pvo_to_pte
argument_list|(
name|pvo
argument_list|,
name|pteidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|pt
operator|!=
name|NULL
condition|)
block|{
name|moea_pte_unset
argument_list|(
name|pt
argument_list|,
operator|&
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte
argument_list|,
name|pvo
operator|->
name|pvo_vaddr
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|moea_table_mutex
argument_list|)
expr_stmt|;
name|PVO_PTEGIDX_CLR
argument_list|(
name|pvo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|moea_pte_overflow
operator|--
expr_stmt|;
block|}
comment|/* 	 * Update our statistics. 	 */
name|pvo
operator|->
name|pvo_pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|--
expr_stmt|;
if|if
condition|(
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte
operator|.
name|pte_lo
operator|&
name|PVO_WIRED
condition|)
name|pvo
operator|->
name|pvo_pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
comment|/* 	 * Save the REF/CHG bits into their cache if the page is managed. 	 */
if|if
condition|(
operator|(
name|pvo
operator|->
name|pvo_vaddr
operator|&
name|PVO_MANAGED
operator|)
operator|==
name|PVO_MANAGED
condition|)
block|{
name|struct
name|vm_page
modifier|*
name|pg
decl_stmt|;
name|pg
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte
operator|.
name|pte_lo
operator|&
name|PTE_RPGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|pg
operator|!=
name|NULL
condition|)
block|{
name|moea_attr_save
argument_list|(
name|pg
argument_list|,
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte
operator|.
name|pte_lo
operator|&
operator|(
name|PTE_REF
operator||
name|PTE_CHG
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Remove this PVO from the PV and pmap lists. 	 */
name|LIST_REMOVE
argument_list|(
name|pvo
argument_list|,
name|pvo_vlink
argument_list|)
expr_stmt|;
name|RB_REMOVE
argument_list|(
name|pvo_tree
argument_list|,
operator|&
name|pvo
operator|->
name|pvo_pmap
operator|->
name|pmap_pvo
argument_list|,
name|pvo
argument_list|)
expr_stmt|;
comment|/* 	 * Remove this from the overflow list and return it to the pool 	 * if we aren't going to reuse it. 	 */
name|LIST_REMOVE
argument_list|(
name|pvo
argument_list|,
name|pvo_olink
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pvo
operator|->
name|pvo_vaddr
operator|&
name|PVO_BOOTSTRAP
operator|)
condition|)
name|uma_zfree
argument_list|(
name|pvo
operator|->
name|pvo_vaddr
operator|&
name|PVO_MANAGED
condition|?
name|moea_mpvo_zone
else|:
name|moea_upvo_zone
argument_list|,
name|pvo
argument_list|)
expr_stmt|;
name|moea_pvo_entries
operator|--
expr_stmt|;
name|moea_pvo_remove_calls
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|moea_pvo_pte_index
parameter_list|(
specifier|const
name|struct
name|pvo_entry
modifier|*
name|pvo
parameter_list|,
name|int
name|ptegidx
parameter_list|)
block|{
name|int
name|pteidx
decl_stmt|;
comment|/* 	 * We can find the actual pte entry without searching by grabbing 	 * the PTEG index from 3 unused bits in pte_lo[11:9] and by 	 * noticing the HID bit. 	 */
name|pteidx
operator|=
name|ptegidx
operator|*
literal|8
operator|+
name|PVO_PTEGIDX_GET
argument_list|(
name|pvo
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte
operator|.
name|pte_hi
operator|&
name|PTE_HID
condition|)
name|pteidx
operator|^=
name|moea_pteg_mask
operator|*
literal|8
expr_stmt|;
return|return
operator|(
name|pteidx
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|pvo_entry
modifier|*
name|moea_pvo_find_va
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|int
modifier|*
name|pteidx_p
parameter_list|)
block|{
name|struct
name|pvo_entry
modifier|*
name|pvo
decl_stmt|;
name|int
name|ptegidx
decl_stmt|;
name|u_int
name|sr
decl_stmt|;
name|va
operator|&=
operator|~
name|ADDR_POFF
expr_stmt|;
name|sr
operator|=
name|va_to_sr
argument_list|(
name|pm
operator|->
name|pm_sr
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|ptegidx
operator|=
name|va_to_pteg
argument_list|(
name|sr
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|moea_table_mutex
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|pvo
argument_list|,
argument|&moea_pvo_table[ptegidx]
argument_list|,
argument|pvo_olink
argument_list|)
block|{
if|if
condition|(
name|pvo
operator|->
name|pvo_pmap
operator|==
name|pm
operator|&&
name|PVO_VADDR
argument_list|(
name|pvo
argument_list|)
operator|==
name|va
condition|)
block|{
if|if
condition|(
name|pteidx_p
condition|)
operator|*
name|pteidx_p
operator|=
name|moea_pvo_pte_index
argument_list|(
name|pvo
argument_list|,
name|ptegidx
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|moea_table_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|pvo
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|pte
modifier|*
name|moea_pvo_to_pte
parameter_list|(
specifier|const
name|struct
name|pvo_entry
modifier|*
name|pvo
parameter_list|,
name|int
name|pteidx
parameter_list|)
block|{
name|struct
name|pte
modifier|*
name|pt
decl_stmt|;
comment|/* 	 * If we haven't been supplied the ptegidx, calculate it. 	 */
if|if
condition|(
name|pteidx
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|ptegidx
decl_stmt|;
name|u_int
name|sr
decl_stmt|;
name|sr
operator|=
name|va_to_sr
argument_list|(
name|pvo
operator|->
name|pvo_pmap
operator|->
name|pm_sr
argument_list|,
name|pvo
operator|->
name|pvo_vaddr
argument_list|)
expr_stmt|;
name|ptegidx
operator|=
name|va_to_pteg
argument_list|(
name|sr
argument_list|,
name|pvo
operator|->
name|pvo_vaddr
argument_list|)
expr_stmt|;
name|pteidx
operator|=
name|moea_pvo_pte_index
argument_list|(
name|pvo
argument_list|,
name|ptegidx
argument_list|)
expr_stmt|;
block|}
name|pt
operator|=
operator|&
name|moea_pteg_table
index|[
name|pteidx
operator|>>
literal|3
index|]
operator|.
name|pt
index|[
name|pteidx
operator|&
literal|7
index|]
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|moea_table_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte
operator|.
name|pte_hi
operator|&
name|PTE_VALID
operator|)
operator|&&
operator|!
name|PVO_PTEGIDX_ISSET
argument_list|(
name|pvo
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"moea_pvo_to_pte: pvo %p has valid pte in pvo but no "
literal|"valid pte index"
argument_list|,
name|pvo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte
operator|.
name|pte_hi
operator|&
name|PTE_VALID
operator|)
operator|==
literal|0
operator|&&
name|PVO_PTEGIDX_ISSET
argument_list|(
name|pvo
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"moea_pvo_to_pte: pvo %p has valid pte index in pvo "
literal|"pvo but no valid pte"
argument_list|,
name|pvo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pt
operator|->
name|pte_hi
operator|^
operator|(
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte
operator|.
name|pte_hi
operator|&
operator|~
name|PTE_VALID
operator|)
operator|)
operator|==
name|PTE_VALID
condition|)
block|{
if|if
condition|(
operator|(
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte
operator|.
name|pte_hi
operator|&
name|PTE_VALID
operator|)
operator|==
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"moea_pvo_to_pte: pvo %p has valid pte in "
literal|"moea_pteg_table %p but invalid in pvo"
argument_list|,
name|pvo
argument_list|,
name|pt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|pt
operator|->
name|pte_lo
operator|^
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte
operator|.
name|pte_lo
operator|)
operator|&
operator|~
operator|(
name|PTE_CHG
operator||
name|PTE_REF
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"moea_pvo_to_pte: pvo %p pte does not match "
literal|"pte %p in moea_pteg_table"
argument_list|,
name|pvo
argument_list|,
name|pt
argument_list|)
expr_stmt|;
block|}
name|mtx_assert
argument_list|(
operator|&
name|moea_table_mutex
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
return|return
operator|(
name|pt
operator|)
return|;
block|}
if|if
condition|(
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte
operator|.
name|pte_hi
operator|&
name|PTE_VALID
condition|)
block|{
name|panic
argument_list|(
literal|"moea_pvo_to_pte: pvo %p has invalid pte %p in "
literal|"moea_pteg_table but valid in pvo: %8x, %8x"
argument_list|,
name|pvo
argument_list|,
name|pt
argument_list|,
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte
operator|.
name|pte_hi
argument_list|,
name|pt
operator|->
name|pte_hi
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|moea_table_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * XXX: THIS STUFF SHOULD BE IN pte.c?  */
end_comment

begin_function
name|int
name|moea_pte_spill
parameter_list|(
name|vm_offset_t
name|addr
parameter_list|)
block|{
name|struct
name|pvo_entry
modifier|*
name|source_pvo
decl_stmt|,
modifier|*
name|victim_pvo
decl_stmt|;
name|struct
name|pvo_entry
modifier|*
name|pvo
decl_stmt|;
name|int
name|ptegidx
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|u_int
name|sr
decl_stmt|;
name|struct
name|pteg
modifier|*
name|pteg
decl_stmt|;
name|struct
name|pte
modifier|*
name|pt
decl_stmt|;
name|moea_pte_spills
operator|++
expr_stmt|;
name|sr
operator|=
name|mfsrin
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|ptegidx
operator|=
name|va_to_pteg
argument_list|(
name|sr
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* 	 * Have to substitute some entry.  Use the primary hash for this. 	 * Use low bits of timebase as random generator. 	 */
name|pteg
operator|=
operator|&
name|moea_pteg_table
index|[
name|ptegidx
index|]
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|moea_table_mutex
argument_list|)
expr_stmt|;
asm|__asm __volatile("mftb %0" : "=r"(i));
name|i
operator|&=
literal|7
expr_stmt|;
name|pt
operator|=
operator|&
name|pteg
operator|->
name|pt
index|[
name|i
index|]
expr_stmt|;
name|source_pvo
operator|=
name|NULL
expr_stmt|;
name|victim_pvo
operator|=
name|NULL
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|pvo
argument_list|,
argument|&moea_pvo_table[ptegidx]
argument_list|,
argument|pvo_olink
argument_list|)
block|{
comment|/* 		 * We need to find a pvo entry for this address. 		 */
if|if
condition|(
name|source_pvo
operator|==
name|NULL
operator|&&
name|moea_pte_match
argument_list|(
operator|&
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte
argument_list|,
name|sr
argument_list|,
name|addr
argument_list|,
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte
operator|.
name|pte_hi
operator|&
name|PTE_HID
argument_list|)
condition|)
block|{
comment|/* 			 * Now found an entry to be spilled into the pteg. 			 * The PTE is now valid, so we know it's active. 			 */
name|j
operator|=
name|moea_pte_insert
argument_list|(
name|ptegidx
argument_list|,
operator|&
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|>=
literal|0
condition|)
block|{
name|PVO_PTEGIDX_SET
argument_list|(
name|pvo
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|moea_pte_overflow
operator|--
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|moea_table_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|source_pvo
operator|=
name|pvo
expr_stmt|;
if|if
condition|(
name|victim_pvo
operator|!=
name|NULL
condition|)
break|break;
block|}
comment|/* 		 * We also need the pvo entry of the victim we are replacing 		 * so save the R& C bits of the PTE. 		 */
if|if
condition|(
operator|(
name|pt
operator|->
name|pte_hi
operator|&
name|PTE_HID
operator|)
operator|==
literal|0
operator|&&
name|victim_pvo
operator|==
name|NULL
operator|&&
name|moea_pte_compare
argument_list|(
name|pt
argument_list|,
operator|&
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte
argument_list|)
condition|)
block|{
name|victim_pvo
operator|=
name|pvo
expr_stmt|;
if|if
condition|(
name|source_pvo
operator|!=
name|NULL
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|source_pvo
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|moea_table_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|victim_pvo
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|pt
operator|->
name|pte_hi
operator|&
name|PTE_HID
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"moea_pte_spill: victim p-pte (%p) has no pvo"
literal|"entry"
argument_list|,
name|pt
argument_list|)
expr_stmt|;
comment|/* 		 * If this is a secondary PTE, we need to search it's primary 		 * pvo bucket for the matching PVO. 		 */
name|LIST_FOREACH
argument_list|(
argument|pvo
argument_list|,
argument|&moea_pvo_table[ptegidx ^ moea_pteg_mask]
argument_list|,
argument|pvo_olink
argument_list|)
block|{
comment|/* 			 * We also need the pvo entry of the victim we are 			 * replacing so save the R& C bits of the PTE. 			 */
if|if
condition|(
name|moea_pte_compare
argument_list|(
name|pt
argument_list|,
operator|&
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte
argument_list|)
condition|)
block|{
name|victim_pvo
operator|=
name|pvo
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|victim_pvo
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"moea_pte_spill: victim s-pte (%p) has no pvo"
literal|"entry"
argument_list|,
name|pt
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We are invalidating the TLB entry for the EA we are replacing even 	 * though it's valid.  If we don't, we lose any ref/chg bit changes 	 * contained in the TLB entry. 	 */
name|source_pvo
operator|->
name|pvo_pte
operator|.
name|pte
operator|.
name|pte_hi
operator|&=
operator|~
name|PTE_HID
expr_stmt|;
name|moea_pte_unset
argument_list|(
name|pt
argument_list|,
operator|&
name|victim_pvo
operator|->
name|pvo_pte
operator|.
name|pte
argument_list|,
name|victim_pvo
operator|->
name|pvo_vaddr
argument_list|)
expr_stmt|;
name|moea_pte_set
argument_list|(
name|pt
argument_list|,
operator|&
name|source_pvo
operator|->
name|pvo_pte
operator|.
name|pte
argument_list|)
expr_stmt|;
name|PVO_PTEGIDX_CLR
argument_list|(
name|victim_pvo
argument_list|)
expr_stmt|;
name|PVO_PTEGIDX_SET
argument_list|(
name|source_pvo
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|moea_pte_replacements
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|moea_table_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|pvo_entry
operator|*
name|moea_pte_spillable_ident
argument_list|(
argument|u_int ptegidx
argument_list|)
block|{ 	struct
name|pte
operator|*
name|pt
block|; 	struct
name|pvo_entry
operator|*
name|pvo_walk
block|,
operator|*
name|pvo
operator|=
name|NULL
block|;
name|LIST_FOREACH
argument_list|(
argument|pvo_walk
argument_list|,
argument|&moea_pvo_table[ptegidx]
argument_list|,
argument|pvo_olink
argument_list|)
block|{
if|if
condition|(
name|pvo_walk
operator|->
name|pvo_vaddr
operator|&
name|PVO_WIRED
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|pvo_walk
operator|->
name|pvo_pte
operator|.
name|pte
operator|.
name|pte_hi
operator|&
name|PTE_VALID
operator|)
condition|)
continue|continue;
name|pt
operator|=
name|moea_pvo_to_pte
argument_list|(
name|pvo_walk
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|pt
operator|==
name|NULL
condition|)
continue|continue;
end_if

begin_expr_stmt
name|pvo
operator|=
name|pvo_walk
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|mtx_unlock
argument_list|(
operator|&
name|moea_table_mutex
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
operator|(
name|pt
operator|->
name|pte_lo
operator|&
name|PTE_REF
operator|)
condition|)
return|return
operator|(
name|pvo_walk
operator|)
return|;
end_if

begin_expr_stmt
unit|} 	 	return
operator|(
name|pvo
operator|)
expr_stmt|;
end_expr_stmt

begin_function
unit|}  static
name|int
name|moea_pte_insert
parameter_list|(
name|u_int
name|ptegidx
parameter_list|,
name|struct
name|pte
modifier|*
name|pvo_pt
parameter_list|)
block|{
name|struct
name|pte
modifier|*
name|pt
decl_stmt|;
name|struct
name|pvo_entry
modifier|*
name|victim_pvo
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|victim_idx
decl_stmt|;
name|u_int
name|pteg_bkpidx
init|=
name|ptegidx
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|moea_table_mutex
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * First try primary hash. 	 */
for|for
control|(
name|pt
operator|=
name|moea_pteg_table
index|[
name|ptegidx
index|]
operator|.
name|pt
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
operator|,
name|pt
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|pt
operator|->
name|pte_hi
operator|&
name|PTE_VALID
operator|)
operator|==
literal|0
condition|)
block|{
name|pvo_pt
operator|->
name|pte_hi
operator|&=
operator|~
name|PTE_HID
expr_stmt|;
name|moea_pte_set
argument_list|(
name|pt
argument_list|,
name|pvo_pt
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
block|}
comment|/* 	 * Now try secondary hash. 	 */
name|ptegidx
operator|^=
name|moea_pteg_mask
expr_stmt|;
for|for
control|(
name|pt
operator|=
name|moea_pteg_table
index|[
name|ptegidx
index|]
operator|.
name|pt
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
operator|,
name|pt
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|pt
operator|->
name|pte_hi
operator|&
name|PTE_VALID
operator|)
operator|==
literal|0
condition|)
block|{
name|pvo_pt
operator|->
name|pte_hi
operator||=
name|PTE_HID
expr_stmt|;
name|moea_pte_set
argument_list|(
name|pt
argument_list|,
name|pvo_pt
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
block|}
comment|/* Try again, but this time try to force a PTE out. */
name|ptegidx
operator|=
name|pteg_bkpidx
expr_stmt|;
name|victim_pvo
operator|=
name|moea_pte_spillable_ident
argument_list|(
name|ptegidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|victim_pvo
operator|==
name|NULL
condition|)
block|{
name|ptegidx
operator|^=
name|moea_pteg_mask
expr_stmt|;
name|victim_pvo
operator|=
name|moea_pte_spillable_ident
argument_list|(
name|ptegidx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|victim_pvo
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"moea_pte_insert: overflow"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|victim_idx
operator|=
name|moea_pvo_pte_index
argument_list|(
name|victim_pvo
argument_list|,
name|ptegidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|pteg_bkpidx
operator|==
name|ptegidx
condition|)
name|pvo_pt
operator|->
name|pte_hi
operator|&=
operator|~
name|PTE_HID
expr_stmt|;
else|else
name|pvo_pt
operator|->
name|pte_hi
operator||=
name|PTE_HID
expr_stmt|;
comment|/* 	 * Synchronize the sacrifice PTE with its PVO, then mark both 	 * invalid. The PVO will be reused when/if the VM system comes 	 * here after a fault. 	 */
name|pt
operator|=
operator|&
name|moea_pteg_table
index|[
name|victim_idx
operator|>>
literal|3
index|]
operator|.
name|pt
index|[
name|victim_idx
operator|&
literal|7
index|]
expr_stmt|;
if|if
condition|(
name|pt
operator|->
name|pte_hi
operator|!=
name|victim_pvo
operator|->
name|pvo_pte
operator|.
name|pte
operator|.
name|pte_hi
condition|)
name|panic
argument_list|(
literal|"Victim PVO doesn't match PTE! PVO: %8x, PTE: %8x"
argument_list|,
name|victim_pvo
operator|->
name|pvo_pte
operator|.
name|pte
operator|.
name|pte_hi
argument_list|,
name|pt
operator|->
name|pte_hi
argument_list|)
expr_stmt|;
comment|/* 	 * Set the new PTE. 	 */
name|moea_pte_unset
argument_list|(
name|pt
argument_list|,
operator|&
name|victim_pvo
operator|->
name|pvo_pte
operator|.
name|pte
argument_list|,
name|victim_pvo
operator|->
name|pvo_vaddr
argument_list|)
expr_stmt|;
name|PVO_PTEGIDX_CLR
argument_list|(
name|victim_pvo
argument_list|)
expr_stmt|;
name|moea_pte_overflow
operator|++
expr_stmt|;
name|moea_pte_set
argument_list|(
name|pt
argument_list|,
name|pvo_pt
argument_list|)
expr_stmt|;
return|return
operator|(
name|victim_idx
operator|&
literal|7
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|moea_query_bit
parameter_list|(
name|vm_page_t
name|m
parameter_list|,
name|int
name|ptebit
parameter_list|)
block|{
name|struct
name|pvo_entry
modifier|*
name|pvo
decl_stmt|;
name|struct
name|pte
modifier|*
name|pt
decl_stmt|;
name|rw_assert
argument_list|(
operator|&
name|pvh_global_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
name|moea_attr_fetch
argument_list|(
name|m
argument_list|)
operator|&
name|ptebit
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
name|LIST_FOREACH
argument_list|(
argument|pvo
argument_list|,
argument|vm_page_to_pvoh(m)
argument_list|,
argument|pvo_vlink
argument_list|)
block|{
comment|/* 		 * See if we saved the bit off.  If so, cache it and return 		 * success. 		 */
if|if
condition|(
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte
operator|.
name|pte_lo
operator|&
name|ptebit
condition|)
block|{
name|moea_attr_save
argument_list|(
name|m
argument_list|,
name|ptebit
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
comment|/* 	 * No luck, now go through the hard part of looking at the PTEs 	 * themselves.  Sync so that any pending REF/CHG bits are flushed to 	 * the PTEs. 	 */
name|powerpc_sync
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|pvo
argument_list|,
argument|vm_page_to_pvoh(m)
argument_list|,
argument|pvo_vlink
argument_list|)
block|{
comment|/* 		 * See if this pvo has a valid PTE.  if so, fetch the 		 * REF/CHG bits from the valid PTE.  If the appropriate 		 * ptebit is set, cache it and return success. 		 */
name|pt
operator|=
name|moea_pvo_to_pte
argument_list|(
name|pvo
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pt
operator|!=
name|NULL
condition|)
block|{
name|moea_pte_synch
argument_list|(
name|pt
argument_list|,
operator|&
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|moea_table_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte
operator|.
name|pte_lo
operator|&
name|ptebit
condition|)
block|{
name|moea_attr_save
argument_list|(
name|m
argument_list|,
name|ptebit
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|moea_clear_bit
parameter_list|(
name|vm_page_t
name|m
parameter_list|,
name|int
name|ptebit
parameter_list|)
block|{
name|u_int
name|count
decl_stmt|;
name|struct
name|pvo_entry
modifier|*
name|pvo
decl_stmt|;
name|struct
name|pte
modifier|*
name|pt
decl_stmt|;
name|rw_assert
argument_list|(
operator|&
name|pvh_global_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
expr_stmt|;
comment|/* 	 * Clear the cached value. 	 */
name|moea_attr_clear
argument_list|(
name|m
argument_list|,
name|ptebit
argument_list|)
expr_stmt|;
comment|/* 	 * Sync so that any pending REF/CHG bits are flushed to the PTEs (so 	 * we can reset the right ones).  note that since the pvo entries and 	 * list heads are accessed via BAT0 and are never placed in the page 	 * table, we don't have to worry about further accesses setting the 	 * REF/CHG bits. 	 */
name|powerpc_sync
argument_list|()
expr_stmt|;
comment|/* 	 * For each pvo entry, clear the pvo's ptebit.  If this pvo has a 	 * valid pte clear the ptebit from the valid pte. 	 */
name|count
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|pvo
argument_list|,
argument|vm_page_to_pvoh(m)
argument_list|,
argument|pvo_vlink
argument_list|)
block|{
name|pt
operator|=
name|moea_pvo_to_pte
argument_list|(
name|pvo
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pt
operator|!=
name|NULL
condition|)
block|{
name|moea_pte_synch
argument_list|(
name|pt
argument_list|,
operator|&
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte
operator|.
name|pte_lo
operator|&
name|ptebit
condition|)
block|{
name|count
operator|++
expr_stmt|;
name|moea_pte_clear
argument_list|(
name|pt
argument_list|,
name|PVO_VADDR
argument_list|(
name|pvo
argument_list|)
argument_list|,
name|ptebit
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|moea_table_mutex
argument_list|)
expr_stmt|;
block|}
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte
operator|.
name|pte_lo
operator|&=
operator|~
name|ptebit
expr_stmt|;
block|}
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return true if the physical range is encompassed by the battable[idx]  */
end_comment

begin_function
specifier|static
name|int
name|moea_bat_mapped
parameter_list|(
name|int
name|idx
parameter_list|,
name|vm_offset_t
name|pa
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
name|u_int
name|prot
decl_stmt|;
name|u_int32_t
name|start
decl_stmt|;
name|u_int32_t
name|end
decl_stmt|;
name|u_int32_t
name|bat_ble
decl_stmt|;
comment|/* 	 * Return immediately if not a valid mapping 	 */
if|if
condition|(
operator|!
operator|(
name|battable
index|[
name|idx
index|]
operator|.
name|batu
operator|&
name|BAT_Vs
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * The BAT entry must be cache-inhibited, guarded, and r/w 	 * so it can function as an i/o page 	 */
name|prot
operator|=
name|battable
index|[
name|idx
index|]
operator|.
name|batl
operator|&
operator|(
name|BAT_I
operator||
name|BAT_G
operator||
name|BAT_PP_RW
operator|)
expr_stmt|;
if|if
condition|(
name|prot
operator|!=
operator|(
name|BAT_I
operator||
name|BAT_G
operator||
name|BAT_PP_RW
operator|)
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
comment|/* 	 * The address should be within the BAT range. Assume that the 	 * start address in the BAT has the correct alignment (thus 	 * not requiring masking) 	 */
name|start
operator|=
name|battable
index|[
name|idx
index|]
operator|.
name|batl
operator|&
name|BAT_PBS
expr_stmt|;
name|bat_ble
operator|=
operator|(
name|battable
index|[
name|idx
index|]
operator|.
name|batu
operator|&
operator|~
operator|(
name|BAT_EBS
operator|)
operator|)
operator||
literal|0x03
expr_stmt|;
name|end
operator|=
name|start
operator||
operator|(
name|bat_ble
operator|<<
literal|15
operator|)
operator||
literal|0x7fff
expr_stmt|;
if|if
condition|(
operator|(
name|pa
operator|<
name|start
operator|)
operator|||
operator|(
operator|(
name|pa
operator|+
name|size
operator|)
operator|>
name|end
operator|)
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|moea_dev_direct_mapped
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|vm_paddr_t
name|pa
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* 	 * This currently does not work for entries that  	 * overlap 256M BAT segments. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|moea_bat_mapped
argument_list|(
name|i
argument_list|,
name|pa
argument_list|,
name|size
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Map a set of physical memory pages into the kernel virtual  * address space. Return a pointer to where it is mapped. This  * routine is intended to be used for mapping device memory,  * NOT real memory.  */
end_comment

begin_function
name|void
modifier|*
name|moea_mapdev
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|vm_paddr_t
name|pa
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
return|return
operator|(
name|moea_mapdev_attr
argument_list|(
name|mmu
argument_list|,
name|pa
argument_list|,
name|size
argument_list|,
name|VM_MEMATTR_DEFAULT
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|moea_mapdev_attr
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|vm_offset_t
name|pa
parameter_list|,
name|vm_size_t
name|size
parameter_list|,
name|vm_memattr_t
name|ma
parameter_list|)
block|{
name|vm_offset_t
name|va
decl_stmt|,
name|tmpva
decl_stmt|,
name|ppa
decl_stmt|,
name|offset
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ppa
operator|=
name|trunc_page
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|offset
operator|=
name|pa
operator|&
name|PAGE_MASK
expr_stmt|;
name|size
operator|=
name|roundup
argument_list|(
name|offset
operator|+
name|size
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
comment|/* 	 * If the physical address lies within a valid BAT table entry, 	 * return the 1:1 mapping. This currently doesn't work 	 * for regions that overlap 256M BAT segments. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|moea_bat_mapped
argument_list|(
name|i
argument_list|,
name|pa
argument_list|,
name|size
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|(
name|void
operator|*
operator|)
name|pa
operator|)
return|;
block|}
name|va
operator|=
name|kva_alloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|va
condition|)
name|panic
argument_list|(
literal|"moea_mapdev: Couldn't alloc kernel virtual memory"
argument_list|)
expr_stmt|;
for|for
control|(
name|tmpva
operator|=
name|va
init|;
name|size
operator|>
literal|0
condition|;
control|)
block|{
name|moea_kenter_attr
argument_list|(
name|mmu
argument_list|,
name|tmpva
argument_list|,
name|ppa
argument_list|,
name|ma
argument_list|)
expr_stmt|;
name|tlbie
argument_list|(
name|tmpva
argument_list|)
expr_stmt|;
name|size
operator|-=
name|PAGE_SIZE
expr_stmt|;
name|tmpva
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|ppa
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|void
operator|*
operator|)
operator|(
name|va
operator|+
name|offset
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|moea_unmapdev
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
name|vm_offset_t
name|base
decl_stmt|,
name|offset
decl_stmt|;
comment|/* 	 * If this is outside kernel virtual space, then it's a 	 * battable entry and doesn't require unmapping 	 */
if|if
condition|(
operator|(
name|va
operator|>=
name|VM_MIN_KERNEL_ADDRESS
operator|)
operator|&&
operator|(
name|va
operator|<=
name|virtual_end
operator|)
condition|)
block|{
name|base
operator|=
name|trunc_page
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|offset
operator|=
name|va
operator|&
name|PAGE_MASK
expr_stmt|;
name|size
operator|=
name|roundup
argument_list|(
name|offset
operator|+
name|size
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|kva_free
argument_list|(
name|base
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|moea_sync_icache
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_size_t
name|sz
parameter_list|)
block|{
name|struct
name|pvo_entry
modifier|*
name|pvo
decl_stmt|;
name|vm_offset_t
name|lim
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|vm_size_t
name|len
decl_stmt|;
name|PMAP_LOCK
argument_list|(
name|pm
argument_list|)
expr_stmt|;
while|while
condition|(
name|sz
operator|>
literal|0
condition|)
block|{
name|lim
operator|=
name|round_page
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|len
operator|=
name|MIN
argument_list|(
name|lim
operator|-
name|va
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|pvo
operator|=
name|moea_pvo_find_va
argument_list|(
name|pm
argument_list|,
name|va
operator|&
operator|~
name|ADDR_POFF
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvo
operator|!=
name|NULL
condition|)
block|{
name|pa
operator|=
operator|(
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte
operator|.
name|pte_lo
operator|&
name|PTE_RPGN
operator|)
operator||
operator|(
name|va
operator|&
name|ADDR_POFF
operator|)
expr_stmt|;
name|moea_syncicache
argument_list|(
name|pa
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|va
operator|+=
name|len
expr_stmt|;
name|sz
operator|-=
name|len
expr_stmt|;
block|}
name|PMAP_UNLOCK
argument_list|(
name|pm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|vm_offset_t
name|moea_dumpsys_map
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|struct
name|pmap_md
modifier|*
name|md
parameter_list|,
name|vm_size_t
name|ofs
parameter_list|,
name|vm_size_t
modifier|*
name|sz
parameter_list|)
block|{
if|if
condition|(
name|md
operator|->
name|md_vaddr
operator|==
operator|~
literal|0UL
condition|)
return|return
operator|(
name|md
operator|->
name|md_paddr
operator|+
name|ofs
operator|)
return|;
else|else
return|return
operator|(
name|md
operator|->
name|md_vaddr
operator|+
name|ofs
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|pmap_md
modifier|*
name|moea_scan_md
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|struct
name|pmap_md
modifier|*
name|prev
parameter_list|)
block|{
specifier|static
name|struct
name|pmap_md
name|md
decl_stmt|;
name|struct
name|pvo_entry
modifier|*
name|pvo
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
if|if
condition|(
name|dumpsys_minidump
condition|)
block|{
name|md
operator|.
name|md_paddr
operator|=
operator|~
literal|0UL
expr_stmt|;
comment|/* Minidumps use virtual addresses. */
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
block|{
comment|/* 1st: kernel .data and .bss. */
name|md
operator|.
name|md_index
operator|=
literal|1
expr_stmt|;
name|md
operator|.
name|md_vaddr
operator|=
name|trunc_page
argument_list|(
operator|(
name|uintptr_t
operator|)
name|_etext
argument_list|)
expr_stmt|;
name|md
operator|.
name|md_size
operator|=
name|round_page
argument_list|(
operator|(
name|uintptr_t
operator|)
name|_end
argument_list|)
operator|-
name|md
operator|.
name|md_vaddr
expr_stmt|;
return|return
operator|(
operator|&
name|md
operator|)
return|;
block|}
switch|switch
condition|(
name|prev
operator|->
name|md_index
condition|)
block|{
case|case
literal|1
case|:
comment|/* 2nd: msgbuf and tables (see pmap_bootstrap()). */
name|md
operator|.
name|md_index
operator|=
literal|2
expr_stmt|;
name|md
operator|.
name|md_vaddr
operator|=
operator|(
name|vm_offset_t
operator|)
name|msgbufp
operator|->
name|msg_ptr
expr_stmt|;
name|md
operator|.
name|md_size
operator|=
name|round_page
argument_list|(
name|msgbufp
operator|->
name|msg_size
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* 3rd: kernel VM. */
name|va
operator|=
name|prev
operator|->
name|md_vaddr
operator|+
name|prev
operator|->
name|md_size
expr_stmt|;
comment|/* Find start of next chunk (from va). */
while|while
condition|(
name|va
operator|<
name|virtual_end
condition|)
block|{
comment|/* Don't dump the buffer cache. */
if|if
condition|(
name|va
operator|>=
name|kmi
operator|.
name|buffer_sva
operator|&&
name|va
operator|<
name|kmi
operator|.
name|buffer_eva
condition|)
block|{
name|va
operator|=
name|kmi
operator|.
name|buffer_eva
expr_stmt|;
continue|continue;
block|}
name|pvo
operator|=
name|moea_pvo_find_va
argument_list|(
name|kernel_pmap
argument_list|,
name|va
operator|&
operator|~
name|ADDR_POFF
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvo
operator|!=
name|NULL
operator|&&
operator|(
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte
operator|.
name|pte_hi
operator|&
name|PTE_VALID
operator|)
condition|)
break|break;
name|va
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
if|if
condition|(
name|va
operator|<
name|virtual_end
condition|)
block|{
name|md
operator|.
name|md_vaddr
operator|=
name|va
expr_stmt|;
name|va
operator|+=
name|PAGE_SIZE
expr_stmt|;
comment|/* Find last page in chunk. */
while|while
condition|(
name|va
operator|<
name|virtual_end
condition|)
block|{
comment|/* Don't run into the buffer cache. */
if|if
condition|(
name|va
operator|==
name|kmi
operator|.
name|buffer_sva
condition|)
break|break;
name|pvo
operator|=
name|moea_pvo_find_va
argument_list|(
name|kernel_pmap
argument_list|,
name|va
operator|&
operator|~
name|ADDR_POFF
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvo
operator|==
name|NULL
operator|||
operator|!
operator|(
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte
operator|.
name|pte_hi
operator|&
name|PTE_VALID
operator|)
condition|)
break|break;
name|va
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
name|md
operator|.
name|md_size
operator|=
name|va
operator|-
name|md
operator|.
name|md_vaddr
expr_stmt|;
break|break;
block|}
name|md
operator|.
name|md_index
operator|=
literal|3
expr_stmt|;
comment|/* FALLTHROUGH */
default|default:
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* minidumps */
name|mem_regions
argument_list|(
operator|&
name|pregions
argument_list|,
operator|&
name|pregions_sz
argument_list|,
operator|&
name|regions
argument_list|,
operator|&
name|regions_sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
block|{
comment|/* first physical chunk. */
name|md
operator|.
name|md_paddr
operator|=
name|pregions
index|[
literal|0
index|]
operator|.
name|mr_start
expr_stmt|;
name|md
operator|.
name|md_size
operator|=
name|pregions
index|[
literal|0
index|]
operator|.
name|mr_size
expr_stmt|;
name|md
operator|.
name|md_vaddr
operator|=
operator|~
literal|0UL
expr_stmt|;
name|md
operator|.
name|md_index
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|md
operator|.
name|md_index
operator|<
name|pregions_sz
condition|)
block|{
name|md
operator|.
name|md_paddr
operator|=
name|pregions
index|[
name|md
operator|.
name|md_index
index|]
operator|.
name|mr_start
expr_stmt|;
name|md
operator|.
name|md_size
operator|=
name|pregions
index|[
name|md
operator|.
name|md_index
index|]
operator|.
name|mr_size
expr_stmt|;
name|md
operator|.
name|md_vaddr
operator|=
operator|~
literal|0UL
expr_stmt|;
name|md
operator|.
name|md_index
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* There's no next physical chunk. */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
return|return
operator|(
operator|&
name|md
operator|)
return|;
block|}
end_function

end_unit

