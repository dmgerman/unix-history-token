begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 1995, 1996 Wolfgang Solfrank.  * Copyright (C) 1995, 1996 TooLs GmbH.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by TooLs GmbH.  * 4. The name of TooLs GmbH may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $NetBSD: pmap.c,v 1.28 2000/03/26 20:42:36 kleink Exp $  */
end_comment

begin_comment
comment|/*  * Copyright (C) 2001 Benno Rice.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY Benno Rice ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/msgbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pageout.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pager.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_zone.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<machine/bat.h>
end_include

begin_include
include|#
directive|include
file|<machine/pcb.h>
end_include

begin_include
include|#
directive|include
file|<machine/powerpc.h>
end_include

begin_include
include|#
directive|include
file|<machine/pte.h>
end_include

begin_decl_stmt
name|pte_t
modifier|*
name|ptable
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ptab_cnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|ptab_mask
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|HTABSIZE
value|(ptab_cnt * 64)
end_define

begin_define
define|#
directive|define
name|MINPV
value|2048
end_define

begin_struct
struct|struct
name|pte_ovfl
block|{
name|LIST_ENTRY
argument_list|(
argument|pte_ovfl
argument_list|)
name|po_list
expr_stmt|;
comment|/* Linked list of overflow entries */
name|struct
name|pte
name|po_pte
decl_stmt|;
comment|/* PTE for this mapping */
block|}
struct|;
end_struct

begin_expr_stmt
name|LIST_HEAD
argument_list|(
name|pte_ovtab
argument_list|,
name|pte_ovfl
argument_list|)
operator|*
name|potable
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Overflow entries for ptable */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|pmap
name|kernel_pmap_store
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pmap_t
name|kernel_pmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|npgs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|nextavail
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|MSGBUFADDR
end_ifndef

begin_decl_stmt
specifier|extern
name|vm_offset_t
name|msgbuf_paddr
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|mem_region
modifier|*
name|mem
decl_stmt|,
modifier|*
name|avail
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|avail_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|avail_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|virtual_avail
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|virtual_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|kernel_vm_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pmap_pagedaemon_waken
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|int
name|Maxmem
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ATTRSHFT
value|4
end_define

begin_decl_stmt
name|struct
name|pv_entry
modifier|*
name|pv_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vm_zone_t
name|pvzone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vm_zone
name|pvzone_store
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vm_object
name|pvzone_obj
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pv_entry_count
init|=
literal|0
decl_stmt|,
name|pv_entry_max
init|=
literal|0
decl_stmt|,
name|pv_entry_high_water
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pv_entry
modifier|*
name|pvinit
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PMAP_SHPGPERPROC
argument_list|)
end_if

begin_define
define|#
directive|define
name|PMAP_SHPGPERPROC
value|200
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct_decl
struct_decl|struct
name|pv_page
struct_decl|;
end_struct_decl

begin_struct
struct|struct
name|pv_page_info
block|{
name|LIST_ENTRY
argument_list|(
argument|pv_page
argument_list|)
name|pgi_list
expr_stmt|;
name|struct
name|pv_entry
modifier|*
name|pgi_freelist
decl_stmt|;
name|int
name|pgi_nfree
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NPVPPG
value|((PAGE_SIZE - sizeof(struct pv_page_info)) / sizeof(struct pv_entry))
end_define

begin_struct
struct|struct
name|pv_page
block|{
name|struct
name|pv_page_info
name|pvp_pgi
decl_stmt|;
name|struct
name|pv_entry
name|pvp_pv
index|[
name|NPVPPG
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|LIST_HEAD
argument_list|(
argument|pv_page_list
argument_list|,
argument|pv_page
argument_list|)
end_macro

begin_expr_stmt
name|pv_page_freelist
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|pv_nfree
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pv_pcnt
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|struct
name|pv_entry
modifier|*
name|pmap_alloc_pv
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_free_pv
parameter_list|(
name|struct
name|pv_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_struct_decl
struct_decl|struct
name|po_page
struct_decl|;
end_struct_decl

begin_struct
struct|struct
name|po_page_info
block|{
name|LIST_ENTRY
argument_list|(
argument|po_page
argument_list|)
name|pgi_list
expr_stmt|;
name|vm_page_t
name|pgi_page
decl_stmt|;
name|LIST_HEAD
argument_list|(
argument|po_freelist
argument_list|,
argument|pte_ovfl
argument_list|)
name|pgi_freelist
expr_stmt|;
name|int
name|pgi_nfree
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NPOPPG
value|((PAGE_SIZE - sizeof(struct po_page_info)) / sizeof(struct pte_ovfl))
end_define

begin_struct
struct|struct
name|po_page
block|{
name|struct
name|po_page_info
name|pop_pgi
decl_stmt|;
name|struct
name|pte_ovfl
name|pop_po
index|[
name|NPOPPG
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|LIST_HEAD
argument_list|(
argument|po_page_list
argument_list|,
argument|po_page
argument_list|)
end_macro

begin_expr_stmt
name|po_page_freelist
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|po_nfree
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|po_pcnt
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|struct
name|pte_ovfl
modifier|*
name|poalloc
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pofree
parameter_list|(
name|struct
name|pte_ovfl
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|u_int
name|usedsr
index|[
name|NPMAPS
operator|/
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
operator|/
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pmap_initialized
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|pte_spill
parameter_list|(
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * These small routines may have to be replaced,  * if/when we support processors other that the 604.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|tlbie
parameter_list|(
name|vm_offset_t
name|ea
parameter_list|)
block|{
asm|__asm __volatile ("tlbie %0" :: "r"(ea));
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|tlbsync
parameter_list|(
name|void
parameter_list|)
block|{
asm|__asm __volatile ("sync; tlbsync; sync");
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|tlbia
parameter_list|(
name|void
parameter_list|)
block|{
name|vm_offset_t
name|i
decl_stmt|;
asm|__asm __volatile ("sync");
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|vm_offset_t
operator|)
literal|0x00040000
condition|;
name|i
operator|+=
literal|0x00001000
control|)
block|{
name|tlbie
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|tlbsync
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|ptesr
parameter_list|(
name|sr_t
modifier|*
name|sr
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|)
block|{
return|return
name|sr
index|[
operator|(
name|u_int
operator|)
name|addr
operator|>>
name|ADDR_SR_SHFT
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|pteidx
parameter_list|(
name|sr_t
name|sr
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|)
block|{
name|int
name|hash
decl_stmt|;
name|hash
operator|=
operator|(
name|sr
operator|&
name|SR_VSID
operator|)
operator|^
operator|(
operator|(
operator|(
name|u_int
operator|)
name|addr
operator|&
name|ADDR_PIDX
operator|)
operator|>>
name|ADDR_PIDX_SHFT
operator|)
expr_stmt|;
return|return
name|hash
operator|&
name|ptab_mask
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|ptematch
parameter_list|(
name|pte_t
modifier|*
name|ptp
parameter_list|,
name|sr_t
name|sr
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|int
name|which
parameter_list|)
block|{
return|return
name|ptp
operator|->
name|pte_hi
operator|==
operator|(
operator|(
operator|(
name|sr
operator|&
name|SR_VSID
operator|)
operator|<<
name|PTE_VSID_SHFT
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int
operator|)
name|va
operator|>>
name|ADDR_API_SHFT
operator|)
operator|&
name|PTE_API
operator|)
operator||
name|which
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|pv_entry
operator|*
name|pa_to_pv
argument_list|(
argument|vm_offset_t pa
argument_list|)
block|{
if|#
directive|if
literal|0
comment|/* XXX */
block|int	bank, pg;  	bank = vm_physseg_find(atop(pa),&pg); 	if (bank == -1) 		return NULL; 	return&vm_physmem[bank].pmseg.pvent[pg];
endif|#
directive|endif
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_expr_stmt

begin_function
specifier|static
name|__inline
name|char
modifier|*
name|pa_to_attr
parameter_list|(
name|vm_offset_t
name|pa
parameter_list|)
block|{
if|#
directive|if
literal|0
comment|/* XXX */
block|int	bank, pg;  	bank = vm_physseg_find(atop(pa),&pg); 	if (bank == -1) 		return NULL; 	return&vm_physmem[bank].pmseg.attrs[pg];
endif|#
directive|endif
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Try to insert page table entry *pt into the ptable at idx.  *  * Note: *pt mustn't have PTE_VALID set.  * This is done here as required by Book III, 4.12.  */
end_comment

begin_function
specifier|static
name|int
name|pte_insert
parameter_list|(
name|int
name|idx
parameter_list|,
name|pte_t
modifier|*
name|pt
parameter_list|)
block|{
name|pte_t
modifier|*
name|ptp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * First try primary hash. 	 */
for|for
control|(
name|ptp
operator|=
name|ptable
operator|+
name|idx
operator|*
literal|8
operator|,
name|i
operator|=
literal|8
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|ptp
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|ptp
operator|->
name|pte_hi
operator|&
name|PTE_VALID
operator|)
condition|)
block|{
operator|*
name|ptp
operator|=
operator|*
name|pt
expr_stmt|;
name|ptp
operator|->
name|pte_hi
operator|&=
operator|~
name|PTE_HID
expr_stmt|;
asm|__asm __volatile ("sync");
name|ptp
operator|->
name|pte_hi
operator||=
name|PTE_VALID
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* 	 * Then try secondary hash. 	 */
name|idx
operator|^=
name|ptab_mask
expr_stmt|;
for|for
control|(
name|ptp
operator|=
name|ptable
operator|+
name|idx
operator|*
literal|8
operator|,
name|i
operator|=
literal|8
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|ptp
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|ptp
operator|->
name|pte_hi
operator|&
name|PTE_VALID
operator|)
condition|)
block|{
operator|*
name|ptp
operator|=
operator|*
name|pt
expr_stmt|;
name|ptp
operator|->
name|pte_hi
operator||=
name|PTE_HID
expr_stmt|;
asm|__asm __volatile ("sync");
name|ptp
operator|->
name|pte_hi
operator||=
name|PTE_VALID
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Spill handler.  *  * Tries to spill a page table entry from the overflow area.  * Note that this routine runs in real mode on a separate stack,  * with interrupts disabled.  */
end_comment

begin_function
name|int
name|pte_spill
parameter_list|(
name|vm_offset_t
name|addr
parameter_list|)
block|{
name|int
name|idx
decl_stmt|,
name|i
decl_stmt|;
name|sr_t
name|sr
decl_stmt|;
name|struct
name|pte_ovfl
modifier|*
name|po
decl_stmt|;
name|pte_t
name|ps
decl_stmt|;
name|pte_t
modifier|*
name|pt
decl_stmt|;
asm|__asm ("mfsrin %0,%1" : "=r"(sr) : "r"(addr));
name|idx
operator|=
name|pteidx
argument_list|(
name|sr
argument_list|,
name|addr
argument_list|)
expr_stmt|;
for|for
control|(
name|po
operator|=
name|potable
index|[
name|idx
index|]
operator|.
name|lh_first
init|;
name|po
condition|;
name|po
operator|=
name|po
operator|->
name|po_list
operator|.
name|le_next
control|)
block|{
if|if
condition|(
name|ptematch
argument_list|(
operator|&
name|po
operator|->
name|po_pte
argument_list|,
name|sr
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* 			 * Now found an entry to be spilled into the real 			 * ptable. 			 */
if|if
condition|(
name|pte_insert
argument_list|(
name|idx
argument_list|,
operator|&
name|po
operator|->
name|po_pte
argument_list|)
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|po
argument_list|,
name|po_list
argument_list|)
expr_stmt|;
name|pofree
argument_list|(
name|po
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* 			 * Have to substitute some entry. Use the primary 			 * hash for this. 			 * 			 * Use low bits of timebase as random generator 			 */
asm|__asm ("mftb %0" : "=r"(i));
name|pt
operator|=
name|ptable
operator|+
name|idx
operator|*
literal|8
operator|+
operator|(
name|i
operator|&
literal|7
operator|)
expr_stmt|;
name|pt
operator|->
name|pte_hi
operator|&=
operator|~
name|PTE_VALID
expr_stmt|;
name|ps
operator|=
operator|*
name|pt
expr_stmt|;
asm|__asm __volatile ("sync");
name|tlbie
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|tlbsync
argument_list|()
expr_stmt|;
operator|*
name|pt
operator|=
name|po
operator|->
name|po_pte
expr_stmt|;
asm|__asm __volatile ("sync");
name|pt
operator|->
name|pte_hi
operator||=
name|PTE_VALID
expr_stmt|;
name|po
operator|->
name|po_pte
operator|=
name|ps
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|pte_hi
operator|&
name|PTE_HID
condition|)
block|{
comment|/* 				 * We took an entry that was on the alternate 				 * hash chain, so move it to it's original 				 * chain. 				 */
name|po
operator|->
name|po_pte
operator|.
name|pte_hi
operator|&=
operator|~
name|PTE_HID
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|po
argument_list|,
name|po_list
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|potable
operator|+
operator|(
name|idx
operator|^
name|ptab_mask
operator|)
argument_list|,
name|po
argument_list|,
name|po_list
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * This is called during powerpc_init, before the system is really initialized.  */
end_comment

begin_function
name|void
name|pmap_setavailmem
parameter_list|(
name|u_int
name|kernelstart
parameter_list|,
name|u_int
name|kernelend
parameter_list|)
block|{
name|struct
name|mem_region
modifier|*
name|mp
decl_stmt|,
modifier|*
name|mp1
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|i
decl_stmt|;
name|u_int
name|s
decl_stmt|,
name|e
decl_stmt|,
name|sz
decl_stmt|;
comment|/* 	 * Get memory. 	 */
name|mem_regions
argument_list|(
operator|&
name|mem
argument_list|,
operator|&
name|avail
argument_list|)
expr_stmt|;
for|for
control|(
name|mp
operator|=
name|mem
init|;
name|mp
operator|->
name|size
condition|;
name|mp
operator|++
control|)
name|Maxmem
operator|+=
name|btoc
argument_list|(
name|mp
operator|->
name|size
argument_list|)
expr_stmt|;
comment|/* 	 * Count the number of available entries. 	 */
for|for
control|(
name|cnt
operator|=
literal|0
operator|,
name|mp
operator|=
name|avail
init|;
name|mp
operator|->
name|size
condition|;
name|mp
operator|++
control|)
block|{
name|cnt
operator|++
expr_stmt|;
block|}
comment|/* 	 * Page align all regions. 	 * Non-page aligned memory isn't very interesting to us. 	 * Also, sort the entries for ascending addresses. 	 */
name|kernelstart
operator|&=
operator|~
name|PAGE_MASK
expr_stmt|;
name|kernelend
operator|=
operator|(
name|kernelend
operator|+
name|PAGE_MASK
operator|)
operator|&
operator|~
name|PAGE_MASK
expr_stmt|;
for|for
control|(
name|mp
operator|=
name|avail
init|;
name|mp
operator|->
name|size
condition|;
name|mp
operator|++
control|)
block|{
name|s
operator|=
name|mp
operator|->
name|start
expr_stmt|;
name|e
operator|=
name|mp
operator|->
name|start
operator|+
name|mp
operator|->
name|size
expr_stmt|;
comment|/* 		 * Check whether this region holds all of the kernel. 		 */
if|if
condition|(
name|s
operator|<
name|kernelstart
operator|&&
name|e
operator|>
name|kernelend
condition|)
block|{
name|avail
index|[
name|cnt
index|]
operator|.
name|start
operator|=
name|kernelend
expr_stmt|;
name|avail
index|[
name|cnt
operator|++
index|]
operator|.
name|size
operator|=
name|e
operator|-
name|kernelend
expr_stmt|;
name|e
operator|=
name|kernelstart
expr_stmt|;
block|}
comment|/* 		 * Look whether this regions starts within the kernel. 		 */
if|if
condition|(
name|s
operator|>=
name|kernelstart
operator|&&
name|s
operator|<
name|kernelend
condition|)
block|{
if|if
condition|(
name|e
operator|<=
name|kernelend
condition|)
goto|goto
name|empty
goto|;
name|s
operator|=
name|kernelend
expr_stmt|;
block|}
comment|/* 		 * Now look whether this region ends within the kernel. 		 */
if|if
condition|(
name|e
operator|>
name|kernelstart
operator|&&
name|e
operator|<=
name|kernelend
condition|)
block|{
if|if
condition|(
name|s
operator|>=
name|kernelstart
condition|)
goto|goto
name|empty
goto|;
name|e
operator|=
name|kernelstart
expr_stmt|;
block|}
comment|/* 		 * Now page align the start and size of the region. 		 */
name|s
operator|=
name|round_page
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|e
operator|=
name|trunc_page
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|<
name|s
condition|)
block|{
name|e
operator|=
name|s
expr_stmt|;
block|}
name|sz
operator|=
name|e
operator|-
name|s
expr_stmt|;
comment|/* 		 * Check whether some memory is left here. 		 */
if|if
condition|(
name|sz
operator|==
literal|0
condition|)
block|{
name|empty
label|:
name|bcopy
argument_list|(
name|mp
operator|+
literal|1
argument_list|,
name|mp
argument_list|,
operator|(
name|cnt
operator|-
operator|(
name|mp
operator|-
name|avail
operator|)
operator|)
operator|*
sizeof|sizeof
expr|*
name|mp
argument_list|)
expr_stmt|;
name|cnt
operator|--
expr_stmt|;
name|mp
operator|--
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Do an insertion sort. 		 */
name|npgs
operator|+=
name|btoc
argument_list|(
name|sz
argument_list|)
expr_stmt|;
for|for
control|(
name|mp1
operator|=
name|avail
init|;
name|mp1
operator|<
name|mp
condition|;
name|mp1
operator|++
control|)
block|{
if|if
condition|(
name|s
operator|<
name|mp1
operator|->
name|start
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|mp1
operator|<
name|mp
condition|)
block|{
name|bcopy
argument_list|(
name|mp1
argument_list|,
name|mp1
operator|+
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|mp
operator|-
operator|(
name|char
operator|*
operator|)
name|mp1
argument_list|)
expr_stmt|;
name|mp1
operator|->
name|start
operator|=
name|s
expr_stmt|;
name|mp1
operator|->
name|size
operator|=
name|sz
expr_stmt|;
block|}
else|else
block|{
name|mp
operator|->
name|start
operator|=
name|s
expr_stmt|;
name|mp
operator|->
name|size
operator|=
name|sz
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|HTABENTS
name|ptab_cnt
operator|=
name|HTABENTS
expr_stmt|;
else|#
directive|else
name|ptab_cnt
operator|=
operator|(
name|Maxmem
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
comment|/* The minimum is 1024 PTEGs. */
if|if
condition|(
name|ptab_cnt
operator|<
literal|1024
condition|)
block|{
name|ptab_cnt
operator|=
literal|1024
expr_stmt|;
block|}
comment|/* Round up to power of 2. */
asm|__asm ("cntlzw %0,%1" : "=r"(i) : "r"(ptab_cnt - 1));
name|ptab_cnt
operator|=
literal|1
operator|<<
operator|(
literal|32
operator|-
name|i
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Find suitably aligned memory for HTAB. 	 */
for|for
control|(
name|mp
operator|=
name|avail
init|;
name|mp
operator|->
name|size
condition|;
name|mp
operator|++
control|)
block|{
name|s
operator|=
name|roundup
argument_list|(
name|mp
operator|->
name|start
argument_list|,
name|HTABSIZE
argument_list|)
operator|-
name|mp
operator|->
name|start
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|size
operator|<
name|s
operator|+
name|HTABSIZE
condition|)
block|{
continue|continue;
block|}
name|ptable
operator|=
operator|(
name|pte_t
operator|*
operator|)
operator|(
name|mp
operator|->
name|start
operator|+
name|s
operator|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|size
operator|==
name|s
operator|+
name|HTABSIZE
condition|)
block|{
if|if
condition|(
name|s
condition|)
name|mp
operator|->
name|size
operator|=
name|s
expr_stmt|;
else|else
block|{
name|bcopy
argument_list|(
name|mp
operator|+
literal|1
argument_list|,
name|mp
argument_list|,
operator|(
name|cnt
operator|-
operator|(
name|mp
operator|-
name|avail
operator|)
operator|)
operator|*
sizeof|sizeof
expr|*
name|mp
argument_list|)
expr_stmt|;
name|mp
operator|=
name|avail
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|s
operator|!=
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|mp
argument_list|,
name|mp
operator|+
literal|1
argument_list|,
operator|(
name|cnt
operator|-
operator|(
name|mp
operator|-
name|avail
operator|)
operator|)
operator|*
sizeof|sizeof
expr|*
name|mp
argument_list|)
expr_stmt|;
name|mp
operator|++
operator|->
name|size
operator|=
name|s
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
block|}
name|mp
operator|->
name|start
operator|+=
name|s
operator|+
name|HTABSIZE
expr_stmt|;
name|mp
operator|->
name|size
operator|-=
name|s
operator|+
name|HTABSIZE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|mp
operator|->
name|size
condition|)
block|{
name|panic
argument_list|(
literal|"not enough memory?"
argument_list|)
expr_stmt|;
block|}
name|npgs
operator|-=
name|btoc
argument_list|(
name|HTABSIZE
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ptable
argument_list|,
name|HTABSIZE
argument_list|)
expr_stmt|;
name|ptab_mask
operator|=
name|ptab_cnt
operator|-
literal|1
expr_stmt|;
comment|/* 	 * We cannot do pmap_steal_memory here, 	 * since we don't run with translation enabled yet. 	 */
name|s
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|pte_ovtab
argument_list|)
operator|*
name|ptab_cnt
expr_stmt|;
name|sz
operator|=
name|round_page
argument_list|(
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|mp
operator|=
name|avail
init|;
name|mp
operator|->
name|size
condition|;
name|mp
operator|++
control|)
block|{
if|if
condition|(
name|mp
operator|->
name|size
operator|>=
name|sz
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|mp
operator|->
name|size
condition|)
block|{
name|panic
argument_list|(
literal|"not enough memory?"
argument_list|)
expr_stmt|;
block|}
name|npgs
operator|-=
name|btoc
argument_list|(
name|sz
argument_list|)
expr_stmt|;
name|potable
operator|=
operator|(
expr|struct
name|pte_ovtab
operator|*
operator|)
name|mp
operator|->
name|start
expr_stmt|;
name|mp
operator|->
name|size
operator|-=
name|sz
expr_stmt|;
name|mp
operator|->
name|start
operator|+=
name|sz
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|size
operator|<=
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|mp
operator|+
literal|1
argument_list|,
name|mp
argument_list|,
operator|(
name|cnt
operator|-
operator|(
name|mp
operator|-
name|avail
operator|)
operator|)
operator|*
sizeof|sizeof
expr|*
name|mp
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ptab_cnt
condition|;
name|i
operator|++
control|)
block|{
name|LIST_INIT
argument_list|(
name|potable
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|MSGBUFADDR
comment|/* 	 * allow for msgbuf 	 */
name|sz
operator|=
name|round_page
argument_list|(
name|MSGBUFSIZE
argument_list|)
expr_stmt|;
name|mp
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|mp1
operator|=
name|avail
init|;
name|mp1
operator|->
name|size
condition|;
name|mp1
operator|++
control|)
block|{
if|if
condition|(
name|mp1
operator|->
name|size
operator|>=
name|sz
condition|)
block|{
name|mp
operator|=
name|mp1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mp
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"not enough memory?"
argument_list|)
expr_stmt|;
block|}
name|npgs
operator|-=
name|btoc
argument_list|(
name|sz
argument_list|)
expr_stmt|;
name|msgbuf_paddr
operator|=
name|mp
operator|->
name|start
operator|+
name|mp
operator|->
name|size
operator|-
name|sz
expr_stmt|;
name|mp
operator|->
name|size
operator|-=
name|sz
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|size
operator|<=
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|mp
operator|+
literal|1
argument_list|,
name|mp
argument_list|,
operator|(
name|cnt
operator|-
operator|(
name|mp
operator|-
name|avail
operator|)
operator|)
operator|*
sizeof|sizeof
expr|*
name|mp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|nextavail
operator|=
name|avail
operator|->
name|start
expr_stmt|;
name|avail_start
operator|=
name|avail
operator|->
name|start
expr_stmt|;
for|for
control|(
name|mp
operator|=
name|avail
operator|,
name|i
operator|=
literal|0
init|;
name|mp
operator|->
name|size
condition|;
name|mp
operator|++
control|)
block|{
name|avail_end
operator|=
name|mp
operator|->
name|start
operator|+
name|mp
operator|->
name|size
expr_stmt|;
name|phys_avail
index|[
name|i
operator|++
index|]
operator|=
name|mp
operator|->
name|start
expr_stmt|;
name|phys_avail
index|[
name|i
operator|++
index|]
operator|=
name|mp
operator|->
name|start
operator|+
name|mp
operator|->
name|size
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|pmap_bootstrap
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|u_int32_t
name|batl
decl_stmt|,
name|batu
decl_stmt|;
comment|/* 	 * Initialize kernel pmap and hardware. 	 */
name|kernel_pmap
operator|=
operator|&
name|kernel_pmap_store
expr_stmt|;
name|batu
operator|=
name|BATU
argument_list|(
literal|0x80000000
argument_list|,
name|BAT_BL_256M
argument_list|,
name|BAT_Vs
argument_list|)
expr_stmt|;
name|batl
operator|=
name|BATL
argument_list|(
literal|0x80000000
argument_list|,
name|BAT_M
argument_list|,
name|BAT_PP_RW
argument_list|)
expr_stmt|;
asm|__asm ("mtdbatu 1,%0; mtdbatl 1,%1" :: "r" (batu), "r" (batl));
if|#
directive|if
name|NPMAPS
operator|>=
name|KERNEL_SEGMENT
operator|/
literal|16
name|usedsr
index|[
name|KERNEL_SEGMENT
operator|/
literal|16
operator|/
operator|(
sizeof|sizeof
name|usedsr
index|[
literal|0
index|]
operator|*
literal|8
operator|)
index|]
operator||=
literal|1
operator|<<
operator|(
operator|(
name|KERNEL_SEGMENT
operator|/
literal|16
operator|)
operator|%
operator|(
sizeof|sizeof
name|usedsr
index|[
literal|0
index|]
operator|*
literal|8
operator|)
operator|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* XXX */
block|for (i = 0; i< 16; i++) { 		kernel_pmap->pm_sr[i] = EMPTY_SEGMENT; 		__asm __volatile ("mtsrin %0,%1" 			      :: "r"(EMPTY_SEGMENT), "r"(i<< ADDR_SR_SHFT)); 	}
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
asm|__asm __volatile ("mfsrin %0,%1"
block|:
literal|"=r"
operator|(
name|j
operator|)
operator|:
literal|"r"
operator|(
name|i
operator|<<
name|ADDR_SR_SHFT
operator|)
block|)
empty_stmt|;
name|kernel_pmap
operator|->
name|pm_sr
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|kernel_pmap
operator|->
name|pm_sr
index|[
name|KERNEL_SR
index|]
operator|=
name|KERNEL_SEGMENT
expr_stmt|;
end_expr_stmt

begin_asm
asm|__asm __volatile ("mtsr %0,%1"
end_asm

begin_expr_stmt
operator|::
literal|"n"
operator|(
name|KERNEL_SR
operator|)
operator|,
literal|"r"
operator|(
name|KERNEL_SEGMENT
operator|)
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_asm
asm|__asm __volatile ("sync; mtsdr1 %0; isync"
end_asm

begin_expr_stmt
operator|::
literal|"r"
operator|(
operator|(
name|u_int
operator|)
name|ptable
operator||
operator|(
name|ptab_mask
operator|>>
literal|10
operator|)
operator|)
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|tlbia
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|virtual_avail
operator|=
name|VM_MIN_KERNEL_ADDRESS
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|virtual_end
operator|=
name|VM_MAX_KERNEL_ADDRESS
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/*  * Initialize anything else for pmap handling.  * Called during vm_init().  */
end_comment

begin_macro
unit|void
name|pmap_init
argument_list|(
argument|vm_offset_t phys_start
argument_list|,
argument|vm_offset_t phys_end
argument_list|)
end_macro

begin_block
block|{
name|int
name|initial_pvs
decl_stmt|;
comment|/* 	 * init the pv free list 	 */
name|initial_pvs
operator|=
name|vm_page_array_size
expr_stmt|;
if|if
condition|(
name|initial_pvs
operator|<
name|MINPV
condition|)
block|{
name|initial_pvs
operator|=
name|MINPV
expr_stmt|;
block|}
name|pvzone
operator|=
operator|&
name|pvzone_store
expr_stmt|;
name|pvinit
operator|=
operator|(
expr|struct
name|pv_entry
operator|*
operator|)
name|kmem_alloc
argument_list|(
name|kernel_map
argument_list|,
name|initial_pvs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pv_entry
argument_list|)
argument_list|)
expr_stmt|;
name|zbootinit
argument_list|(
name|pvzone
argument_list|,
literal|"PV ENTRY"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pv_entry
argument_list|)
argument_list|,
name|pvinit
argument_list|,
name|vm_page_array_size
argument_list|)
expr_stmt|;
name|pmap_initialized
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Initialize a preallocated and zeroed pmap structure.  */
end_comment

begin_function
name|void
name|pmap_pinit
parameter_list|(
name|struct
name|pmap
modifier|*
name|pm
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* 	 * Allocate some segment registers for this pmap. 	 */
name|pm
operator|->
name|pm_refs
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
name|usedsr
operator|/
sizeof|sizeof
name|usedsr
index|[
literal|0
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|usedsr
index|[
name|i
index|]
operator|!=
literal|0xffffffff
condition|)
block|{
name|j
operator|=
name|ffs
argument_list|(
operator|~
name|usedsr
index|[
name|i
index|]
argument_list|)
operator|-
literal|1
expr_stmt|;
name|usedsr
index|[
name|i
index|]
operator||=
literal|1
operator|<<
name|j
expr_stmt|;
name|pm
operator|->
name|pm_sr
index|[
literal|0
index|]
operator|=
operator|(
name|i
operator|*
sizeof|sizeof
name|usedsr
index|[
literal|0
index|]
operator|*
literal|8
operator|+
name|j
operator|)
operator|*
literal|16
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|pm
operator|->
name|pm_sr
index|[
name|i
index|]
operator|=
name|pm
operator|->
name|pm_sr
index|[
name|i
operator|-
literal|1
index|]
operator|+
literal|1
expr_stmt|;
block|}
return|return;
block|}
block|}
name|panic
argument_list|(
literal|"out of segments"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_pinit2
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
comment|/* 	 * Nothing to be done. 	 */
return|return;
block|}
end_function

begin_comment
comment|/*  * Add a reference to the given pmap.  */
end_comment

begin_function
name|void
name|pmap_reference
parameter_list|(
name|struct
name|pmap
modifier|*
name|pm
parameter_list|)
block|{
name|pm
operator|->
name|pm_refs
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Retire the given pmap from service.  * Should only be called if the map contains no valid mappings.  */
end_comment

begin_function
name|void
name|pmap_destroy
parameter_list|(
name|struct
name|pmap
modifier|*
name|pm
parameter_list|)
block|{
if|if
condition|(
operator|--
name|pm
operator|->
name|pm_refs
operator|==
literal|0
condition|)
block|{
name|pmap_release
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|pm
argument_list|,
name|M_VMPGDATA
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Release any resources held by the given physical map.  * Called when a pmap initialized by pmap_pinit is being released.  */
end_comment

begin_function
name|void
name|pmap_release
parameter_list|(
name|struct
name|pmap
modifier|*
name|pm
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|pm
operator|->
name|pm_sr
index|[
literal|0
index|]
condition|)
block|{
name|panic
argument_list|(
literal|"pmap_release"
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|pm
operator|->
name|pm_sr
index|[
literal|0
index|]
operator|/
literal|16
expr_stmt|;
name|j
operator|=
name|i
operator|%
operator|(
sizeof|sizeof
name|usedsr
index|[
literal|0
index|]
operator|*
literal|8
operator|)
expr_stmt|;
name|i
operator|/=
sizeof|sizeof
name|usedsr
index|[
literal|0
index|]
operator|*
literal|8
expr_stmt|;
name|usedsr
index|[
name|i
index|]
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|j
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Copy the range specified by src_addr/len  * from the source map to the range dst_addr/len  * in the destination map.  *  * This routine is only advisory and need not do anything.  */
end_comment

begin_function
name|void
name|pmap_copy
parameter_list|(
name|struct
name|pmap
modifier|*
name|dst_pmap
parameter_list|,
name|struct
name|pmap
modifier|*
name|src_pmap
parameter_list|,
name|vm_offset_t
name|dst_addr
parameter_list|,
name|vm_size_t
name|len
parameter_list|,
name|vm_offset_t
name|src_addr
parameter_list|)
block|{
return|return;
block|}
end_function

begin_comment
comment|/*  * Garbage collects the physical map system for  * pages which are no longer used.  * Success need not be guaranteed -- that is, there  * may well be pages which are not referenced, but  * others may be collected.  * Called by the pageout daemon when pages are scarce.  */
end_comment

begin_function
name|void
name|pmap_collect
parameter_list|(
name|void
parameter_list|)
block|{
return|return;
block|}
end_function

begin_comment
comment|/*  * Fill the given physical page with zeroes.  */
end_comment

begin_function
name|void
name|pmap_zero_page
parameter_list|(
name|vm_offset_t
name|pa
parameter_list|)
block|{
if|#
directive|if
literal|0
block|bzero((caddr_t)pa, PAGE_SIZE);
else|#
directive|else
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|PAGE_SIZE
operator|/
name|CACHELINESIZE
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
asm|__asm __volatile ("dcbz 0,%0" :: "r"(pa));
name|pa
operator|+=
name|CACHELINESIZE
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|pmap_zero_page_area
parameter_list|(
name|vm_offset_t
name|pa
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|pa
operator|+
name|off
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Copy the given physical source page to its destination.  */
end_comment

begin_function
name|void
name|pmap_copy_page
parameter_list|(
name|vm_offset_t
name|src
parameter_list|,
name|vm_offset_t
name|dst
parameter_list|)
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|src
argument_list|,
operator|(
name|caddr_t
operator|)
name|dst
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|pv_entry
modifier|*
name|pmap_alloc_pv
parameter_list|()
block|{
name|pv_entry_count
operator|++
expr_stmt|;
if|if
condition|(
name|pv_entry_high_water
operator|&&
operator|(
name|pv_entry_count
operator|>
name|pv_entry_high_water
operator|)
operator|&&
operator|(
name|pmap_pagedaemon_waken
operator|==
literal|0
operator|)
condition|)
block|{
name|pmap_pagedaemon_waken
operator|=
literal|1
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|vm_pages_needed
argument_list|)
expr_stmt|;
block|}
return|return
name|zalloc
argument_list|(
name|pvzone
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pmap_free_pv
parameter_list|(
name|struct
name|pv_entry
modifier|*
name|pv
parameter_list|)
block|{
name|pv_entry_count
operator|--
expr_stmt|;
name|zfree
argument_list|(
name|pvzone
argument_list|,
name|pv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * We really hope that we don't need overflow entries  * before the VM system is initialized!  *  * XXX: Should really be switched over to the zone allocator.  */
end_comment

begin_function
specifier|static
name|struct
name|pte_ovfl
modifier|*
name|poalloc
parameter_list|()
block|{
name|struct
name|po_page
modifier|*
name|pop
decl_stmt|;
name|struct
name|pte_ovfl
modifier|*
name|po
decl_stmt|;
name|vm_page_t
name|mem
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|pmap_initialized
condition|)
block|{
name|panic
argument_list|(
literal|"poalloc"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|po_nfree
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Since we cannot use maps for potable allocation, 		 * we have to steal some memory from the VM system.			XXX 		 */
name|mem
operator|=
name|vm_page_alloc
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|VM_ALLOC_SYSTEM
argument_list|)
expr_stmt|;
name|po_pcnt
operator|++
expr_stmt|;
name|pop
operator|=
operator|(
expr|struct
name|po_page
operator|*
operator|)
name|VM_PAGE_TO_PHYS
argument_list|(
name|mem
argument_list|)
expr_stmt|;
name|pop
operator|->
name|pop_pgi
operator|.
name|pgi_page
operator|=
name|mem
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|pop
operator|->
name|pop_pgi
operator|.
name|pgi_freelist
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|NPOPPG
operator|-
literal|1
operator|,
name|po
operator|=
name|pop
operator|->
name|pop_po
operator|+
literal|1
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|po
operator|++
control|)
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|pop
operator|->
name|pop_pgi
operator|.
name|pgi_freelist
argument_list|,
name|po
argument_list|,
name|po_list
argument_list|)
expr_stmt|;
block|}
name|po_nfree
operator|+=
name|pop
operator|->
name|pop_pgi
operator|.
name|pgi_nfree
operator|=
name|NPOPPG
operator|-
literal|1
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|po_page_freelist
argument_list|,
name|pop
argument_list|,
name|pop_pgi
operator|.
name|pgi_list
argument_list|)
expr_stmt|;
name|po
operator|=
name|pop
operator|->
name|pop_po
expr_stmt|;
block|}
else|else
block|{
name|po_nfree
operator|--
expr_stmt|;
name|pop
operator|=
name|po_page_freelist
operator|.
name|lh_first
expr_stmt|;
if|if
condition|(
operator|--
name|pop
operator|->
name|pop_pgi
operator|.
name|pgi_nfree
operator|<=
literal|0
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|pop
argument_list|,
name|pop_pgi
operator|.
name|pgi_list
argument_list|)
expr_stmt|;
block|}
name|po
operator|=
name|pop
operator|->
name|pop_pgi
operator|.
name|pgi_freelist
operator|.
name|lh_first
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|po
argument_list|,
name|po_list
argument_list|)
expr_stmt|;
block|}
return|return
name|po
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pofree
parameter_list|(
name|struct
name|pte_ovfl
modifier|*
name|po
parameter_list|,
name|int
name|freepage
parameter_list|)
block|{
name|struct
name|po_page
modifier|*
name|pop
decl_stmt|;
name|pop
operator|=
operator|(
expr|struct
name|po_page
operator|*
operator|)
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|po
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|++
name|pop
operator|->
name|pop_pgi
operator|.
name|pgi_nfree
condition|)
block|{
case|case
name|NPOPPG
case|:
if|if
condition|(
operator|!
name|freepage
condition|)
block|{
break|break;
block|}
name|po_nfree
operator|-=
name|NPOPPG
operator|-
literal|1
expr_stmt|;
name|po_pcnt
operator|--
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|pop
argument_list|,
name|pop_pgi
operator|.
name|pgi_list
argument_list|)
expr_stmt|;
name|vm_page_free
argument_list|(
name|pop
operator|->
name|pop_pgi
operator|.
name|pgi_page
argument_list|)
expr_stmt|;
return|return;
case|case
literal|1
case|:
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|po_page_freelist
argument_list|,
name|pop
argument_list|,
name|pop_pgi
operator|.
name|pgi_list
argument_list|)
expr_stmt|;
default|default:
break|break;
block|}
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|pop
operator|->
name|pop_pgi
operator|.
name|pgi_freelist
argument_list|,
name|po
argument_list|,
name|po_list
argument_list|)
expr_stmt|;
name|po_nfree
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This returns whether this is the first mapping of a page.  */
end_comment

begin_function
specifier|static
name|int
name|pmap_enter_pv
parameter_list|(
name|int
name|pteidx
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_offset_t
name|pa
parameter_list|)
block|{
name|struct
name|pv_entry
modifier|*
name|pv
decl_stmt|,
modifier|*
name|npv
decl_stmt|;
name|int
name|s
decl_stmt|,
name|first
decl_stmt|;
if|if
condition|(
operator|!
name|pmap_initialized
condition|)
block|{
return|return
literal|0
return|;
block|}
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|pv
operator|=
name|pa_to_pv
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|first
operator|=
name|pv
operator|->
name|pv_idx
expr_stmt|;
if|if
condition|(
name|pv
operator|->
name|pv_idx
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 		 * No entries yet, use header as the first entry. 		 */
name|pv
operator|->
name|pv_va
operator|=
name|va
expr_stmt|;
name|pv
operator|->
name|pv_idx
operator|=
name|pteidx
expr_stmt|;
name|pv
operator|->
name|pv_next
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * There is at least one other VA mapping this page. 		 * Place this entry after the header. 		 */
name|npv
operator|=
name|pmap_alloc_pv
argument_list|()
expr_stmt|;
name|npv
operator|->
name|pv_va
operator|=
name|va
expr_stmt|;
name|npv
operator|->
name|pv_idx
operator|=
name|pteidx
expr_stmt|;
name|npv
operator|->
name|pv_next
operator|=
name|pv
operator|->
name|pv_next
expr_stmt|;
name|pv
operator|->
name|pv_next
operator|=
name|npv
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|first
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pmap_remove_pv
parameter_list|(
name|int
name|pteidx
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_offset_t
name|pa
parameter_list|,
name|struct
name|pte
modifier|*
name|pte
parameter_list|)
block|{
name|struct
name|pv_entry
modifier|*
name|pv
decl_stmt|,
modifier|*
name|npv
decl_stmt|;
name|char
modifier|*
name|attr
decl_stmt|;
comment|/* 	 * First transfer reference/change bits to cache. 	 */
name|attr
operator|=
name|pa_to_attr
argument_list|(
name|pa
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
operator|*
name|attr
operator||=
operator|(
name|pte
operator|->
name|pte_lo
operator|&
operator|(
name|PTE_REF
operator||
name|PTE_CHG
operator|)
operator|)
operator|>>
name|ATTRSHFT
expr_stmt|;
comment|/* 	 * Remove from the PV table. 	 */
name|pv
operator|=
name|pa_to_pv
argument_list|(
name|pa
argument_list|)
expr_stmt|;
comment|/* 	 * If it is the first entry on the list, it is actually 	 * in the header and we must copy the following entry up 	 * to the header.  Otherwise we must search the list for 	 * the entry.  In either case we free the now unused entry. 	 */
if|if
condition|(
name|pteidx
operator|==
name|pv
operator|->
name|pv_idx
operator|&&
name|va
operator|==
name|pv
operator|->
name|pv_va
condition|)
block|{
name|npv
operator|=
name|pv
operator|->
name|pv_next
expr_stmt|;
if|if
condition|(
name|npv
condition|)
block|{
operator|*
name|pv
operator|=
operator|*
name|npv
expr_stmt|;
name|pmap_free_pv
argument_list|(
name|npv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pv
operator|->
name|pv_idx
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
init|;
operator|(
name|npv
operator|=
name|pv
operator|->
name|pv_next
operator|)
condition|;
name|pv
operator|=
name|npv
control|)
block|{
if|if
condition|(
name|pteidx
operator|==
name|npv
operator|->
name|pv_idx
operator|&&
name|va
operator|==
name|npv
operator|->
name|pv_va
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|npv
condition|)
block|{
name|pv
operator|->
name|pv_next
operator|=
name|npv
operator|->
name|pv_next
expr_stmt|;
name|pmap_free_pv
argument_list|(
name|npv
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DIAGNOSTIC
else|else
block|{
name|panic
argument_list|(
literal|"pmap_remove_pv: not on list\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/*  * Insert physical page at pa into the given pmap at virtual address va.  */
end_comment

begin_function
name|void
name|pmap_enter
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|pg
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|boolean_t
name|wired
parameter_list|)
block|{
name|sr_t
name|sr
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|s
decl_stmt|;
name|pte_t
name|pte
decl_stmt|;
name|struct
name|pte_ovfl
modifier|*
name|po
decl_stmt|;
name|struct
name|mem_region
modifier|*
name|mp
decl_stmt|;
name|vm_offset_t
name|pa
decl_stmt|;
name|pa
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|pg
argument_list|)
operator|&
operator|~
name|PAGE_MASK
expr_stmt|;
comment|/* 	 * Have to remove any existing mapping first. 	 */
name|pmap_remove
argument_list|(
name|pm
argument_list|,
name|va
argument_list|,
name|va
operator|+
name|PAGE_SIZE
argument_list|)
expr_stmt|;
comment|/* 	 * Compute the HTAB index. 	 */
name|idx
operator|=
name|pteidx
argument_list|(
name|sr
operator|=
name|ptesr
argument_list|(
name|pm
operator|->
name|pm_sr
argument_list|,
name|va
argument_list|)
argument_list|,
name|va
argument_list|)
expr_stmt|;
comment|/* 	 * Construct the PTE. 	 * 	 * Note: Don't set the valid bit for correct operation of tlb update. 	 */
name|pte
operator|.
name|pte_hi
operator|=
operator|(
operator|(
name|sr
operator|&
name|SR_VSID
operator|)
operator|<<
name|PTE_VSID_SHFT
operator|)
operator||
operator|(
operator|(
name|va
operator|&
name|ADDR_PIDX
operator|)
operator|>>
name|ADDR_API_SHFT
operator|)
expr_stmt|;
name|pte
operator|.
name|pte_lo
operator|=
operator|(
name|pa
operator|&
name|PTE_RPGN
operator|)
operator||
name|PTE_M
operator||
name|PTE_I
operator||
name|PTE_G
expr_stmt|;
for|for
control|(
name|mp
operator|=
name|mem
init|;
name|mp
operator|->
name|size
condition|;
name|mp
operator|++
control|)
block|{
if|if
condition|(
name|pa
operator|>=
name|mp
operator|->
name|start
operator|&&
name|pa
operator|<
name|mp
operator|->
name|start
operator|+
name|mp
operator|->
name|size
condition|)
block|{
name|pte
operator|.
name|pte_lo
operator|&=
operator|~
operator|(
name|PTE_I
operator||
name|PTE_G
operator|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|prot
operator|&
name|VM_PROT_WRITE
condition|)
block|{
name|pte
operator|.
name|pte_lo
operator||=
name|PTE_RW
expr_stmt|;
block|}
else|else
block|{
name|pte
operator|.
name|pte_lo
operator||=
name|PTE_RO
expr_stmt|;
block|}
comment|/* 	 * Now record mapping for later back-translation. 	 */
if|if
condition|(
name|pmap_initialized
operator|&&
operator|(
name|pg
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pmap_enter_pv
argument_list|(
name|idx
argument_list|,
name|va
argument_list|,
name|pa
argument_list|)
condition|)
block|{
comment|/*  			 * Flush the real memory from the cache. 			 */
name|__syncicache
argument_list|(
operator|(
name|void
operator|*
operator|)
name|pa
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
block|}
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|pm
operator|->
name|pm_stats
operator|.
name|resident_count
operator|++
expr_stmt|;
comment|/* 	 * Try to insert directly into HTAB. 	 */
if|if
condition|(
name|pte_insert
argument_list|(
name|idx
argument_list|,
operator|&
name|pte
argument_list|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Have to allocate overflow entry. 	 * 	 * Note, that we must use real addresses for these. 	 */
name|po
operator|=
name|poalloc
argument_list|()
expr_stmt|;
name|po
operator|->
name|po_pte
operator|=
name|pte
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|potable
operator|+
name|idx
argument_list|,
name|po
argument_list|,
name|po_list
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_kenter
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_offset_t
name|pa
parameter_list|)
block|{
name|struct
name|vm_page
name|pg
decl_stmt|;
name|pg
operator|.
name|phys_addr
operator|=
name|pa
expr_stmt|;
name|pmap_enter
argument_list|(
name|kernel_pmap
argument_list|,
name|va
argument_list|,
operator|&
name|pg
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_kremove
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
name|pmap_remove
argument_list|(
name|kernel_pmap
argument_list|,
name|va
argument_list|,
name|va
operator|+
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove the given range of mapping entries.  */
end_comment

begin_function
name|void
name|pmap_remove
parameter_list|(
name|struct
name|pmap
modifier|*
name|pm
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_offset_t
name|endva
parameter_list|)
block|{
name|int
name|idx
decl_stmt|,
name|i
decl_stmt|,
name|s
decl_stmt|;
name|sr_t
name|sr
decl_stmt|;
name|pte_t
modifier|*
name|ptp
decl_stmt|;
name|struct
name|pte_ovfl
modifier|*
name|po
decl_stmt|,
modifier|*
name|npo
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
while|while
condition|(
name|va
operator|<
name|endva
condition|)
block|{
name|idx
operator|=
name|pteidx
argument_list|(
name|sr
operator|=
name|ptesr
argument_list|(
name|pm
operator|->
name|pm_sr
argument_list|,
name|va
argument_list|)
argument_list|,
name|va
argument_list|)
expr_stmt|;
for|for
control|(
name|ptp
operator|=
name|ptable
operator|+
name|idx
operator|*
literal|8
operator|,
name|i
operator|=
literal|8
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|ptp
operator|++
control|)
block|{
if|if
condition|(
name|ptematch
argument_list|(
name|ptp
argument_list|,
name|sr
argument_list|,
name|va
argument_list|,
name|PTE_VALID
argument_list|)
condition|)
block|{
name|pmap_remove_pv
argument_list|(
name|idx
argument_list|,
name|va
argument_list|,
name|ptp
operator|->
name|pte_lo
argument_list|,
name|ptp
argument_list|)
expr_stmt|;
name|ptp
operator|->
name|pte_hi
operator|&=
operator|~
name|PTE_VALID
expr_stmt|;
asm|__asm __volatile ("sync");
name|tlbie
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|tlbsync
argument_list|()
expr_stmt|;
name|pm
operator|->
name|pm_stats
operator|.
name|resident_count
operator|--
expr_stmt|;
block|}
block|}
for|for
control|(
name|ptp
operator|=
name|ptable
operator|+
operator|(
name|idx
operator|^
name|ptab_mask
operator|)
operator|*
literal|8
operator|,
name|i
operator|=
literal|8
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|ptp
operator|++
control|)
block|{
if|if
condition|(
name|ptematch
argument_list|(
name|ptp
argument_list|,
name|sr
argument_list|,
name|va
argument_list|,
name|PTE_VALID
operator||
name|PTE_HID
argument_list|)
condition|)
block|{
name|pmap_remove_pv
argument_list|(
name|idx
argument_list|,
name|va
argument_list|,
name|ptp
operator|->
name|pte_lo
argument_list|,
name|ptp
argument_list|)
expr_stmt|;
name|ptp
operator|->
name|pte_hi
operator|&=
operator|~
name|PTE_VALID
expr_stmt|;
asm|__asm __volatile ("sync");
name|tlbie
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|tlbsync
argument_list|()
expr_stmt|;
name|pm
operator|->
name|pm_stats
operator|.
name|resident_count
operator|--
expr_stmt|;
block|}
block|}
for|for
control|(
name|po
operator|=
name|potable
index|[
name|idx
index|]
operator|.
name|lh_first
init|;
name|po
condition|;
name|po
operator|=
name|npo
control|)
block|{
name|npo
operator|=
name|po
operator|->
name|po_list
operator|.
name|le_next
expr_stmt|;
if|if
condition|(
name|ptematch
argument_list|(
operator|&
name|po
operator|->
name|po_pte
argument_list|,
name|sr
argument_list|,
name|va
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|pmap_remove_pv
argument_list|(
name|idx
argument_list|,
name|va
argument_list|,
name|po
operator|->
name|po_pte
operator|.
name|pte_lo
argument_list|,
operator|&
name|po
operator|->
name|po_pte
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|po
argument_list|,
name|po_list
argument_list|)
expr_stmt|;
name|pofree
argument_list|(
name|po
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pm
operator|->
name|pm_stats
operator|.
name|resident_count
operator|--
expr_stmt|;
block|}
block|}
name|va
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|pte_t
modifier|*
name|pte_find
parameter_list|(
name|struct
name|pmap
modifier|*
name|pm
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|int
name|idx
decl_stmt|,
name|i
decl_stmt|;
name|sr_t
name|sr
decl_stmt|;
name|pte_t
modifier|*
name|ptp
decl_stmt|;
name|struct
name|pte_ovfl
modifier|*
name|po
decl_stmt|;
name|idx
operator|=
name|pteidx
argument_list|(
name|sr
operator|=
name|ptesr
argument_list|(
name|pm
operator|->
name|pm_sr
argument_list|,
name|va
argument_list|)
argument_list|,
name|va
argument_list|)
expr_stmt|;
for|for
control|(
name|ptp
operator|=
name|ptable
operator|+
name|idx
operator|*
literal|8
operator|,
name|i
operator|=
literal|8
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|ptp
operator|++
control|)
block|{
if|if
condition|(
name|ptematch
argument_list|(
name|ptp
argument_list|,
name|sr
argument_list|,
name|va
argument_list|,
name|PTE_VALID
argument_list|)
condition|)
block|{
return|return
name|ptp
return|;
block|}
block|}
for|for
control|(
name|ptp
operator|=
name|ptable
operator|+
operator|(
name|idx
operator|^
name|ptab_mask
operator|)
operator|*
literal|8
operator|,
name|i
operator|=
literal|8
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|ptp
operator|++
control|)
block|{
if|if
condition|(
name|ptematch
argument_list|(
name|ptp
argument_list|,
name|sr
argument_list|,
name|va
argument_list|,
name|PTE_VALID
operator||
name|PTE_HID
argument_list|)
condition|)
block|{
return|return
name|ptp
return|;
block|}
block|}
for|for
control|(
name|po
operator|=
name|potable
index|[
name|idx
index|]
operator|.
name|lh_first
init|;
name|po
condition|;
name|po
operator|=
name|po
operator|->
name|po_list
operator|.
name|le_next
control|)
block|{
if|if
condition|(
name|ptematch
argument_list|(
operator|&
name|po
operator|->
name|po_pte
argument_list|,
name|sr
argument_list|,
name|va
argument_list|,
literal|0
argument_list|)
condition|)
block|{
return|return
operator|&
name|po
operator|->
name|po_pte
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Get the physical page address for the given pmap/virtual address.  */
end_comment

begin_function
name|vm_offset_t
name|pmap_extract
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|pte_t
modifier|*
name|ptp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ptp
operator|=
name|pte_find
argument_list|(
name|pm
argument_list|,
name|va
argument_list|)
operator|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|ptp
operator|->
name|pte_lo
operator|&
name|PTE_RPGN
operator|)
operator||
operator|(
name|va
operator|&
name|ADDR_POFF
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lower the protection on the specified range of this pmap.  *  * There are only two cases: either the protection is going to 0,  * or it is going to read-only.  */
end_comment

begin_function
name|void
name|pmap_protect
parameter_list|(
name|struct
name|pmap
modifier|*
name|pm
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|,
name|vm_offset_t
name|eva
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|pte_t
modifier|*
name|ptp
decl_stmt|;
name|int
name|valid
decl_stmt|,
name|s
decl_stmt|;
if|if
condition|(
name|prot
operator|&
name|VM_PROT_READ
condition|)
block|{
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
while|while
condition|(
name|sva
operator|<
name|eva
condition|)
block|{
name|ptp
operator|=
name|pte_find
argument_list|(
name|pm
argument_list|,
name|sva
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptp
condition|)
block|{
name|valid
operator|=
name|ptp
operator|->
name|pte_hi
operator|&
name|PTE_VALID
expr_stmt|;
name|ptp
operator|->
name|pte_hi
operator|&=
operator|~
name|PTE_VALID
expr_stmt|;
asm|__asm __volatile ("sync");
name|tlbie
argument_list|(
name|sva
argument_list|)
expr_stmt|;
name|tlbsync
argument_list|()
expr_stmt|;
name|ptp
operator|->
name|pte_lo
operator|&=
operator|~
name|PTE_PP
expr_stmt|;
name|ptp
operator|->
name|pte_lo
operator||=
name|PTE_RO
expr_stmt|;
asm|__asm __volatile ("sync");
name|ptp
operator|->
name|pte_hi
operator||=
name|valid
expr_stmt|;
block|}
name|sva
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|pmap_remove
argument_list|(
name|pm
argument_list|,
name|sva
argument_list|,
name|eva
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|boolean_t
name|ptemodify
parameter_list|(
name|vm_page_t
name|pg
parameter_list|,
name|u_int
name|mask
parameter_list|,
name|u_int
name|val
parameter_list|)
block|{
name|vm_offset_t
name|pa
decl_stmt|;
name|struct
name|pv_entry
modifier|*
name|pv
decl_stmt|;
name|pte_t
modifier|*
name|ptp
decl_stmt|;
name|struct
name|pte_ovfl
modifier|*
name|po
decl_stmt|;
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
name|char
modifier|*
name|attr
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|pa
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|pg
argument_list|)
expr_stmt|;
comment|/* 	 * First modify bits in cache. 	 */
name|attr
operator|=
name|pa_to_attr
argument_list|(
name|pa
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|==
name|NULL
condition|)
block|{
return|return
name|FALSE
return|;
block|}
operator|*
name|attr
operator|&=
operator|~
name|mask
operator|>>
name|ATTRSHFT
expr_stmt|;
operator|*
name|attr
operator||=
name|val
operator|>>
name|ATTRSHFT
expr_stmt|;
name|pv
operator|=
name|pa_to_pv
argument_list|(
name|pa
argument_list|)
expr_stmt|;
if|if
condition|(
name|pv
operator|->
name|pv_idx
operator|<
literal|0
condition|)
block|{
return|return
name|FALSE
return|;
block|}
name|rv
operator|=
name|FALSE
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|pv
condition|;
name|pv
operator|=
name|pv
operator|->
name|pv_next
control|)
block|{
for|for
control|(
name|ptp
operator|=
name|ptable
operator|+
name|pv
operator|->
name|pv_idx
operator|*
literal|8
operator|,
name|i
operator|=
literal|8
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|ptp
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ptp
operator|->
name|pte_hi
operator|&
name|PTE_VALID
operator|)
operator|&&
operator|(
name|ptp
operator|->
name|pte_lo
operator|&
name|PTE_RPGN
operator|)
operator|==
name|pa
condition|)
block|{
name|ptp
operator|->
name|pte_hi
operator|&=
operator|~
name|PTE_VALID
expr_stmt|;
asm|__asm __volatile ("sync");
name|tlbie
argument_list|(
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|tlbsync
argument_list|()
expr_stmt|;
name|rv
operator||=
name|ptp
operator|->
name|pte_lo
operator|&
name|mask
expr_stmt|;
name|ptp
operator|->
name|pte_lo
operator|&=
operator|~
name|mask
expr_stmt|;
name|ptp
operator|->
name|pte_lo
operator||=
name|val
expr_stmt|;
asm|__asm __volatile ("sync");
name|ptp
operator|->
name|pte_hi
operator||=
name|PTE_VALID
expr_stmt|;
block|}
block|}
for|for
control|(
name|ptp
operator|=
name|ptable
operator|+
operator|(
name|pv
operator|->
name|pv_idx
operator|^
name|ptab_mask
operator|)
operator|*
literal|8
operator|,
name|i
operator|=
literal|8
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|ptp
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ptp
operator|->
name|pte_hi
operator|&
name|PTE_VALID
operator|)
operator|&&
operator|(
name|ptp
operator|->
name|pte_lo
operator|&
name|PTE_RPGN
operator|)
operator|==
name|pa
condition|)
block|{
name|ptp
operator|->
name|pte_hi
operator|&=
operator|~
name|PTE_VALID
expr_stmt|;
asm|__asm __volatile ("sync");
name|tlbie
argument_list|(
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|tlbsync
argument_list|()
expr_stmt|;
name|rv
operator||=
name|ptp
operator|->
name|pte_lo
operator|&
name|mask
expr_stmt|;
name|ptp
operator|->
name|pte_lo
operator|&=
operator|~
name|mask
expr_stmt|;
name|ptp
operator|->
name|pte_lo
operator||=
name|val
expr_stmt|;
asm|__asm __volatile ("sync");
name|ptp
operator|->
name|pte_hi
operator||=
name|PTE_VALID
expr_stmt|;
block|}
block|}
for|for
control|(
name|po
operator|=
name|potable
index|[
name|pv
operator|->
name|pv_idx
index|]
operator|.
name|lh_first
init|;
name|po
condition|;
name|po
operator|=
name|po
operator|->
name|po_list
operator|.
name|le_next
control|)
block|{
if|if
condition|(
operator|(
name|po
operator|->
name|po_pte
operator|.
name|pte_lo
operator|&
name|PTE_RPGN
operator|)
operator|==
name|pa
condition|)
block|{
name|rv
operator||=
name|ptp
operator|->
name|pte_lo
operator|&
name|mask
expr_stmt|;
name|po
operator|->
name|po_pte
operator|.
name|pte_lo
operator|&=
operator|~
name|mask
expr_stmt|;
name|po
operator|->
name|po_pte
operator|.
name|pte_lo
operator||=
name|val
expr_stmt|;
block|}
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|rv
operator|!=
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ptebits
parameter_list|(
name|vm_page_t
name|pg
parameter_list|,
name|int
name|bit
parameter_list|)
block|{
name|struct
name|pv_entry
modifier|*
name|pv
decl_stmt|;
name|pte_t
modifier|*
name|ptp
decl_stmt|;
name|struct
name|pte_ovfl
modifier|*
name|po
decl_stmt|;
name|int
name|i
decl_stmt|,
name|s
decl_stmt|,
name|bits
decl_stmt|;
name|char
modifier|*
name|attr
decl_stmt|;
name|vm_offset_t
name|pa
decl_stmt|;
name|bits
operator|=
literal|0
expr_stmt|;
name|pa
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|pg
argument_list|)
expr_stmt|;
comment|/* 	 * First try the cache. 	 */
name|attr
operator|=
name|pa_to_attr
argument_list|(
name|pa
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|==
name|NULL
condition|)
block|{
return|return
literal|0
return|;
block|}
name|bits
operator||=
operator|(
operator|*
name|attr
operator|<<
name|ATTRSHFT
operator|)
operator|&
name|bit
expr_stmt|;
if|if
condition|(
name|bits
operator|==
name|bit
condition|)
block|{
return|return
name|bits
return|;
block|}
name|pv
operator|=
name|pa_to_pv
argument_list|(
name|pa
argument_list|)
expr_stmt|;
if|if
condition|(
name|pv
operator|->
name|pv_idx
operator|<
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|pv
condition|;
name|pv
operator|=
name|pv
operator|->
name|pv_next
control|)
block|{
for|for
control|(
name|ptp
operator|=
name|ptable
operator|+
name|pv
operator|->
name|pv_idx
operator|*
literal|8
operator|,
name|i
operator|=
literal|8
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|ptp
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ptp
operator|->
name|pte_hi
operator|&
name|PTE_VALID
operator|)
operator|&&
operator|(
name|ptp
operator|->
name|pte_lo
operator|&
name|PTE_RPGN
operator|)
operator|==
name|pa
condition|)
block|{
name|bits
operator||=
name|ptp
operator|->
name|pte_lo
operator|&
name|bit
expr_stmt|;
if|if
condition|(
name|bits
operator|==
name|bit
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|bits
return|;
block|}
block|}
block|}
for|for
control|(
name|ptp
operator|=
name|ptable
operator|+
operator|(
name|pv
operator|->
name|pv_idx
operator|^
name|ptab_mask
operator|)
operator|*
literal|8
operator|,
name|i
operator|=
literal|8
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|ptp
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ptp
operator|->
name|pte_hi
operator|&
name|PTE_VALID
operator|)
operator|&&
operator|(
name|ptp
operator|->
name|pte_lo
operator|&
name|PTE_RPGN
operator|)
operator|==
name|pa
condition|)
block|{
name|bits
operator||=
name|ptp
operator|->
name|pte_lo
operator|&
name|bit
expr_stmt|;
if|if
condition|(
name|bits
operator|==
name|bit
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|bits
return|;
block|}
block|}
block|}
for|for
control|(
name|po
operator|=
name|potable
index|[
name|pv
operator|->
name|pv_idx
index|]
operator|.
name|lh_first
init|;
name|po
condition|;
name|po
operator|=
name|po
operator|->
name|po_list
operator|.
name|le_next
control|)
block|{
if|if
condition|(
operator|(
name|po
operator|->
name|po_pte
operator|.
name|pte_lo
operator|&
name|PTE_RPGN
operator|)
operator|==
name|pa
condition|)
block|{
name|bits
operator||=
name|po
operator|->
name|po_pte
operator|.
name|pte_lo
operator|&
name|bit
expr_stmt|;
if|if
condition|(
name|bits
operator|==
name|bit
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|bits
return|;
block|}
block|}
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|bits
return|;
block|}
end_function

begin_comment
comment|/*  * Lower the protection on the specified physical page.  *  * There are only two cases: either the protection is going to 0,  * or it is going to read-only.  */
end_comment

begin_function
name|void
name|pmap_page_protect
parameter_list|(
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|vm_offset_t
name|pa
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|pte_t
modifier|*
name|ptp
decl_stmt|;
name|struct
name|pte_ovfl
modifier|*
name|po
decl_stmt|,
modifier|*
name|npo
decl_stmt|;
name|int
name|i
decl_stmt|,
name|s
decl_stmt|,
name|idx
decl_stmt|;
name|struct
name|pv_entry
modifier|*
name|pv
decl_stmt|;
name|pa
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|pa
operator|&=
operator|~
name|ADDR_POFF
expr_stmt|;
if|if
condition|(
name|prot
operator|&
name|VM_PROT_READ
condition|)
block|{
name|ptemodify
argument_list|(
name|m
argument_list|,
name|PTE_PP
argument_list|,
name|PTE_RO
argument_list|)
expr_stmt|;
return|return;
block|}
name|pv
operator|=
name|pa_to_pv
argument_list|(
name|pa
argument_list|)
expr_stmt|;
if|if
condition|(
name|pv
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
while|while
condition|(
name|pv
operator|->
name|pv_idx
operator|>=
literal|0
condition|)
block|{
name|idx
operator|=
name|pv
operator|->
name|pv_idx
expr_stmt|;
name|va
operator|=
name|pv
operator|->
name|pv_va
expr_stmt|;
for|for
control|(
name|ptp
operator|=
name|ptable
operator|+
name|idx
operator|*
literal|8
operator|,
name|i
operator|=
literal|8
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|ptp
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ptp
operator|->
name|pte_hi
operator|&
name|PTE_VALID
operator|)
operator|&&
operator|(
name|ptp
operator|->
name|pte_lo
operator|&
name|PTE_RPGN
operator|)
operator|==
name|pa
condition|)
block|{
name|pmap_remove_pv
argument_list|(
name|idx
argument_list|,
name|va
argument_list|,
name|pa
argument_list|,
name|ptp
argument_list|)
expr_stmt|;
name|ptp
operator|->
name|pte_hi
operator|&=
operator|~
name|PTE_VALID
expr_stmt|;
asm|__asm __volatile ("sync");
name|tlbie
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|tlbsync
argument_list|()
expr_stmt|;
goto|goto
name|next
goto|;
block|}
block|}
for|for
control|(
name|ptp
operator|=
name|ptable
operator|+
operator|(
name|idx
operator|^
name|ptab_mask
operator|)
operator|*
literal|8
operator|,
name|i
operator|=
literal|8
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|ptp
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ptp
operator|->
name|pte_hi
operator|&
name|PTE_VALID
operator|)
operator|&&
operator|(
name|ptp
operator|->
name|pte_lo
operator|&
name|PTE_RPGN
operator|)
operator|==
name|pa
condition|)
block|{
name|pmap_remove_pv
argument_list|(
name|idx
argument_list|,
name|va
argument_list|,
name|pa
argument_list|,
name|ptp
argument_list|)
expr_stmt|;
name|ptp
operator|->
name|pte_hi
operator|&=
operator|~
name|PTE_VALID
expr_stmt|;
asm|__asm __volatile ("sync");
name|tlbie
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|tlbsync
argument_list|()
expr_stmt|;
goto|goto
name|next
goto|;
block|}
block|}
for|for
control|(
name|po
operator|=
name|potable
index|[
name|idx
index|]
operator|.
name|lh_first
init|;
name|po
condition|;
name|po
operator|=
name|npo
control|)
block|{
name|npo
operator|=
name|po
operator|->
name|po_list
operator|.
name|le_next
expr_stmt|;
if|if
condition|(
operator|(
name|po
operator|->
name|po_pte
operator|.
name|pte_lo
operator|&
name|PTE_RPGN
operator|)
operator|==
name|pa
condition|)
block|{
name|pmap_remove_pv
argument_list|(
name|idx
argument_list|,
name|va
argument_list|,
name|pa
argument_list|,
operator|&
name|po
operator|->
name|po_pte
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|po
argument_list|,
name|po_list
argument_list|)
expr_stmt|;
name|pofree
argument_list|(
name|po
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
block|}
name|next
label|:
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Activate the address space for the specified process.  If the process  * is the current process, load the new MMU context.  */
end_comment

begin_function
name|void
name|pmap_activate
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|pcb
modifier|*
name|pcb
decl_stmt|;
name|pmap_t
name|pmap
decl_stmt|;
name|pmap_t
name|rpm
decl_stmt|;
name|int
name|psl
decl_stmt|,
name|i
decl_stmt|,
name|ksr
decl_stmt|,
name|seg
decl_stmt|;
name|pcb
operator|=
name|td
operator|->
name|td_pcb
expr_stmt|;
name|pmap
operator|=
name|vmspace_pmap
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_vmspace
argument_list|)
expr_stmt|;
comment|/* 	 * XXX Normally performed in cpu_fork(). 	 */
if|if
condition|(
name|pcb
operator|->
name|pcb_pm
operator|!=
name|pmap
condition|)
block|{
name|pcb
operator|->
name|pcb_pm
operator|=
name|pmap
expr_stmt|;
operator|(
name|vm_offset_t
operator|)
name|pcb
operator|->
name|pcb_pmreal
operator|=
name|pmap_extract
argument_list|(
name|kernel_pmap
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|pcb
operator|->
name|pcb_pm
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|td
operator|==
name|curthread
condition|)
block|{
comment|/* Disable interrupts while switching. */
name|psl
operator|=
name|mfmsr
argument_list|()
expr_stmt|;
name|mtmsr
argument_list|(
name|psl
operator|&
operator|~
name|PSL_EE
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX */
comment|/* Store pointer to new current pmap. */
block|curpm = pcb->pcb_pmreal;
endif|#
directive|endif
comment|/* Save kernel SR. */
asm|__asm __volatile("mfsr %0,14" : "=r"(ksr) :);
comment|/* 		 * Set new segment registers.  We use the pmap's real 		 * address to avoid accessibility problems. 		 */
name|rpm
operator|=
name|pcb
operator|->
name|pcb_pmreal
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|seg
operator|=
name|rpm
operator|->
name|pm_sr
index|[
name|i
index|]
expr_stmt|;
asm|__asm __volatile("mtsrin %0,%1"
operator|::
literal|"r"
operator|(
name|seg
operator|)
operator|,
literal|"r"
operator|(
name|i
operator|<<
name|ADDR_SR_SHFT
operator|)
block|)
empty_stmt|;
block|}
comment|/* Restore kernel SR. */
asm|__asm __volatile("mtsr 14,%0" :: "r"(ksr));
comment|/* Interrupts are OK again. */
name|mtmsr
argument_list|(
name|psl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
unit|}
comment|/*  * Add a list of wired pages to the kva  * this routine is only used for temporary  * kernel mappings that do not need to have  * page modification or references recorded.  * Note that old mappings are simply written  * over.  The page *must* be wired.  */
end_comment

begin_macro
unit|void
name|pmap_qenter
argument_list|(
argument|vm_offset_t va
argument_list|,
argument|vm_page_t *m
argument_list|,
argument|int count
argument_list|)
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|vm_offset_t
name|tva
init|=
name|va
operator|+
name|i
operator|*
name|PAGE_SIZE
decl_stmt|;
name|pmap_kenter
argument_list|(
name|tva
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * this routine jerks page mappings from the  * kernel -- it is meant only for temporary mappings.  */
end_comment

begin_function
name|void
name|pmap_qremove
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|vm_offset_t
name|end_va
decl_stmt|;
name|end_va
operator|=
name|va
operator|+
name|count
operator|*
name|PAGE_SIZE
expr_stmt|;
while|while
condition|(
name|va
operator|<
name|end_va
condition|)
block|{
name|unsigned
modifier|*
name|pte
decl_stmt|;
name|pte
operator|=
operator|(
name|unsigned
operator|*
operator|)
name|vtopte
argument_list|(
name|va
argument_list|)
expr_stmt|;
operator|*
name|pte
operator|=
literal|0
expr_stmt|;
name|tlbie
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|va
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * 	pmap_ts_referenced:  *  *	Return the count of reference bits for a page, clearing all of them.  */
end_comment

begin_function
name|int
name|pmap_ts_referenced
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
comment|/* XXX: coming soon... */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * this routine returns true if a physical page resides  * in the given pmap.  */
end_comment

begin_function
name|boolean_t
name|pmap_page_exists
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
if|#
directive|if
literal|0
comment|/* XXX: This must go! */
block|register pv_entry_t pv; 	int s;  	if (!pmap_initialized || (m->flags& PG_FICTITIOUS)) 		return FALSE;  	s = splvm();
comment|/* 	 * Not found, check current mappings returning immediately if found. 	 */
block|for (pv = pv_table; pv; pv = pv->pv_next) { 		if (pv->pv_pmap == pmap) { 			splx(s); 			return TRUE; 		} 	} 	splx(s);
endif|#
directive|endif
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Used to map a range of physical addresses into kernel  *	virtual address space.  *  *	For now, VM is already on, we only need to map the  *	specified memory.  */
end_comment

begin_function
name|vm_offset_t
name|pmap_map
parameter_list|(
name|vm_offset_t
modifier|*
name|virt
parameter_list|,
name|vm_offset_t
name|start
parameter_list|,
name|vm_offset_t
name|end
parameter_list|,
name|int
name|prot
parameter_list|)
block|{
name|vm_offset_t
name|sva
decl_stmt|,
name|va
decl_stmt|;
name|sva
operator|=
operator|*
name|virt
expr_stmt|;
name|va
operator|=
name|sva
expr_stmt|;
while|while
condition|(
name|start
operator|<
name|end
condition|)
block|{
name|pmap_kenter
argument_list|(
name|va
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|va
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|start
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
operator|*
name|virt
operator|=
name|va
expr_stmt|;
return|return
operator|(
name|sva
operator|)
return|;
block|}
end_function

begin_function
name|vm_offset_t
name|pmap_addr_hint
parameter_list|(
name|vm_object_t
name|obj
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
return|return
operator|(
name|addr
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pmap_mincore
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|)
block|{
comment|/* XXX: coming soon... */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pmap_object_init_pt
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|,
name|vm_object_t
name|object
parameter_list|,
name|vm_pindex_t
name|pindex
parameter_list|,
name|vm_size_t
name|size
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
comment|/* XXX: coming soon... */
return|return;
block|}
end_function

begin_function
name|void
name|pmap_growkernel
parameter_list|(
name|vm_offset_t
name|addr
parameter_list|)
block|{
comment|/* XXX: coming soon... */
return|return;
block|}
end_function

begin_comment
comment|/*  * Initialize the address space (zone) for the pv_entries.  Set a  * high water mark so that the system can recover from excessive  * numbers of pv entries.  */
end_comment

begin_function
name|void
name|pmap_init2
parameter_list|()
block|{
name|int
name|shpgperproc
init|=
name|PMAP_SHPGPERPROC
decl_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"vm.pmap.shpgperproc"
argument_list|,
operator|&
name|shpgperproc
argument_list|)
expr_stmt|;
name|pv_entry_max
operator|=
name|shpgperproc
operator|*
name|maxproc
operator|+
name|vm_page_array_size
expr_stmt|;
name|pv_entry_high_water
operator|=
literal|9
operator|*
operator|(
name|pv_entry_max
operator|/
literal|10
operator|)
expr_stmt|;
name|zinitna
argument_list|(
name|pvzone
argument_list|,
operator|&
name|pvzone_obj
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|pv_entry_max
argument_list|,
name|ZONE_INTERRUPT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_swapin_proc
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
comment|/* XXX: coming soon... */
return|return;
block|}
end_function

begin_function
name|void
name|pmap_swapout_proc
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
comment|/* XXX: coming soon... */
return|return;
block|}
end_function

begin_comment
comment|/*  * Create the kernel stack (including pcb for i386) for a new thread.  * This routine directly affects the fork perf for a process and  * create performance for a thread.  */
end_comment

begin_function
name|void
name|pmap_new_thread
parameter_list|(
name|td
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
comment|/* XXX: coming soon... */
return|return;
block|}
end_function

begin_comment
comment|/*  * Dispose the kernel stack for a thread that has exited.  * This routine directly impacts the exit perf of a process and thread.  */
end_comment

begin_function
name|void
name|pmap_dispose_thread
parameter_list|(
name|td
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
comment|/* XXX: coming soon... */
return|return;
block|}
end_function

begin_comment
comment|/*  * Allow the Kernel stack for a thread to be prejudicially paged out.  */
end_comment

begin_function
name|void
name|pmap_swapout_thread
parameter_list|(
name|td
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|vm_object_t
name|ksobj
decl_stmt|;
name|vm_offset_t
name|ks
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|ksobj
operator|=
name|td
operator|->
name|td_kstack_obj
expr_stmt|;
name|ks
operator|=
name|td
operator|->
name|td_kstack
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|KSTACK_PAGES
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|ksobj
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"pmap_swapout_thread: kstack already missing?"
argument_list|)
expr_stmt|;
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_unwire
argument_list|(
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pmap_kremove
argument_list|(
name|ks
operator|+
name|i
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Bring the kernel stack for a specified thread back in.  */
end_comment

begin_function
name|void
name|pmap_swapin_thread
parameter_list|(
name|td
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|rv
decl_stmt|;
name|vm_object_t
name|ksobj
decl_stmt|;
name|vm_offset_t
name|ks
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|ksobj
operator|=
name|td
operator|->
name|td_kstack_obj
expr_stmt|;
name|ks
operator|=
name|td
operator|->
name|td_kstack
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|KSTACK_PAGES
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|vm_page_grab
argument_list|(
name|ksobj
argument_list|,
name|i
argument_list|,
name|VM_ALLOC_NORMAL
operator||
name|VM_ALLOC_RETRY
argument_list|)
expr_stmt|;
name|pmap_kenter
argument_list|(
name|ks
operator|+
name|i
operator|*
name|PAGE_SIZE
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|valid
operator|!=
name|VM_PAGE_BITS_ALL
condition|)
block|{
name|rv
operator|=
name|vm_pager_get_pages
argument_list|(
name|ksobj
argument_list|,
operator|&
name|m
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|VM_PAGER_OK
condition|)
name|panic
argument_list|(
literal|"pmap_swapin_thread: cannot get kstack for proc: %d\n"
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|)
expr_stmt|;
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|ksobj
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|m
operator|->
name|valid
operator|=
name|VM_PAGE_BITS_ALL
expr_stmt|;
block|}
name|vm_page_wire
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_wakeup
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_flag_set
argument_list|(
name|m
argument_list|,
name|PG_MAPPED
operator||
name|PG_WRITEABLE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|pmap_pageable
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|,
name|vm_offset_t
name|eva
parameter_list|,
name|boolean_t
name|pageable
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
name|void
name|pmap_change_wiring
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|boolean_t
name|wired
parameter_list|)
block|{
comment|/* XXX: coming soon... */
return|return;
block|}
end_function

begin_function
name|void
name|pmap_prefault
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|addra
parameter_list|,
name|vm_map_entry_t
name|entry
parameter_list|)
block|{
comment|/* XXX: coming soon... */
return|return;
block|}
end_function

begin_function
name|void
name|pmap_remove_pages
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|,
name|vm_offset_t
name|eva
parameter_list|)
block|{
comment|/* XXX: coming soon... */
return|return;
block|}
end_function

begin_function
name|void
name|pmap_pinit0
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
comment|/* XXX: coming soon... */
return|return;
block|}
end_function

begin_function
name|void
name|pmap_dispose_proc
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
comment|/* XXX: coming soon... */
return|return;
block|}
end_function

begin_function
name|vm_offset_t
name|pmap_steal_memory
parameter_list|(
name|vm_size_t
name|size
parameter_list|)
block|{
name|vm_size_t
name|bank_size
decl_stmt|;
name|vm_offset_t
name|pa
decl_stmt|;
name|size
operator|=
name|round_page
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|bank_size
operator|=
name|phys_avail
index|[
literal|1
index|]
operator|-
name|phys_avail
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
name|size
operator|>
name|bank_size
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|phys_avail
index|[
name|i
operator|+
literal|2
index|]
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|phys_avail
index|[
name|i
index|]
operator|=
name|phys_avail
index|[
name|i
operator|+
literal|2
index|]
expr_stmt|;
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|phys_avail
index|[
name|i
operator|+
literal|3
index|]
expr_stmt|;
block|}
name|phys_avail
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|phys_avail
index|[
literal|0
index|]
condition|)
name|panic
argument_list|(
literal|"pmap_steal_memory: out of memory"
argument_list|)
expr_stmt|;
name|bank_size
operator|=
name|phys_avail
index|[
literal|1
index|]
operator|-
name|phys_avail
index|[
literal|0
index|]
expr_stmt|;
block|}
name|pa
operator|=
name|phys_avail
index|[
literal|0
index|]
expr_stmt|;
name|phys_avail
index|[
literal|0
index|]
operator|+=
name|size
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|pa
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|pa
return|;
block|}
end_function

begin_comment
comment|/*  * Create the UAREA_PAGES for a new process.  * This routine directly affects the fork perf for a process.  */
end_comment

begin_function
name|void
name|pmap_new_proc
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|vm_object_t
name|upobj
decl_stmt|;
name|vm_offset_t
name|up
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|pte_t
name|pte
decl_stmt|;
name|sr_t
name|sr
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
comment|/* 	 * allocate object for the upages 	 */
name|upobj
operator|=
name|p
operator|->
name|p_upages_obj
expr_stmt|;
if|if
condition|(
name|upobj
operator|==
name|NULL
condition|)
block|{
name|upobj
operator|=
name|vm_object_allocate
argument_list|(
name|OBJT_DEFAULT
argument_list|,
name|UAREA_PAGES
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_upages_obj
operator|=
name|upobj
expr_stmt|;
block|}
comment|/* get a kernel virtual address for the UAREA_PAGES for this proc */
name|up
operator|=
operator|(
name|vm_offset_t
operator|)
name|p
operator|->
name|p_uarea
expr_stmt|;
if|if
condition|(
name|up
operator|==
literal|0
condition|)
block|{
name|up
operator|=
name|kmem_alloc_nofault
argument_list|(
name|kernel_map
argument_list|,
name|UAREA_PAGES
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"pmap_new_proc: upage allocation failed"
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_uarea
operator|=
operator|(
expr|struct
name|user
operator|*
operator|)
name|up
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UAREA_PAGES
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * Get a kernel stack page 		 */
name|m
operator|=
name|vm_page_grab
argument_list|(
name|upobj
argument_list|,
name|i
argument_list|,
name|VM_ALLOC_NORMAL
operator||
name|VM_ALLOC_RETRY
argument_list|)
expr_stmt|;
comment|/* 		 * Wire the page 		 */
name|m
operator|->
name|wire_count
operator|++
expr_stmt|;
name|cnt
operator|.
name|v_wire_count
operator|++
expr_stmt|;
comment|/* 		 * Enter the page into the kernel address space. 		 */
name|va
operator|=
name|up
operator|+
name|i
operator|*
name|PAGE_SIZE
expr_stmt|;
name|idx
operator|=
name|pteidx
argument_list|(
name|sr
operator|=
name|ptesr
argument_list|(
name|kernel_pmap
operator|->
name|pm_sr
argument_list|,
name|va
argument_list|)
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|pte
operator|.
name|pte_hi
operator|=
operator|(
operator|(
name|sr
operator|&
name|SR_VSID
operator|)
operator|<<
name|PTE_VSID_SHFT
operator|)
operator||
operator|(
operator|(
name|va
operator|&
name|ADDR_PIDX
operator|)
operator|>>
name|ADDR_API_SHFT
operator|)
expr_stmt|;
name|pte
operator|.
name|pte_lo
operator|=
operator|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
operator|&
name|PTE_RPGN
operator|)
operator||
name|PTE_M
operator||
name|PTE_I
operator||
name|PTE_G
operator||
name|PTE_RW
expr_stmt|;
if|if
condition|(
operator|!
name|pte_insert
argument_list|(
name|idx
argument_list|,
operator|&
name|pte
argument_list|)
condition|)
block|{
name|struct
name|pte_ovfl
modifier|*
name|po
decl_stmt|;
name|po
operator|=
name|poalloc
argument_list|()
expr_stmt|;
name|po
operator|->
name|po_pte
operator|=
name|pte
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|potable
operator|+
name|idx
argument_list|,
name|po
argument_list|,
name|po_list
argument_list|)
expr_stmt|;
block|}
name|tlbie
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|vm_page_wakeup
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_flag_clear
argument_list|(
name|m
argument_list|,
name|PG_ZERO
argument_list|)
expr_stmt|;
name|vm_page_flag_set
argument_list|(
name|m
argument_list|,
name|PG_MAPPED
operator||
name|PG_WRITEABLE
argument_list|)
expr_stmt|;
name|m
operator|->
name|valid
operator|=
name|VM_PAGE_BITS_ALL
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
modifier|*
name|pmap_mapdev
parameter_list|(
name|vm_offset_t
name|pa
parameter_list|,
name|vm_size_t
name|len
parameter_list|)
block|{
name|vm_offset_t
name|faddr
decl_stmt|;
name|vm_offset_t
name|taddr
decl_stmt|,
name|va
decl_stmt|;
name|int
name|off
decl_stmt|;
name|faddr
operator|=
name|trunc_page
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|off
operator|=
name|pa
operator|-
name|faddr
expr_stmt|;
name|len
operator|=
name|round_page
argument_list|(
name|off
operator|+
name|len
argument_list|)
expr_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
name|va
operator|=
name|taddr
operator|=
name|kmem_alloc_pageable
argument_list|(
name|kernel_map
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|va
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
for|for
control|(
init|;
name|len
operator|>
literal|0
condition|;
name|len
operator|-=
name|PAGE_SIZE
control|)
block|{
name|pmap_kenter
argument_list|(
name|taddr
argument_list|,
name|faddr
argument_list|)
expr_stmt|;
name|faddr
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|taddr
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
return|return
operator|(
name|void
operator|*
operator|)
operator|(
name|va
operator|+
name|off
operator|)
return|;
block|}
end_function

end_unit

