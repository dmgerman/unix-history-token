begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2001 The NetBSD Foundation, Inc.  * All rights reserved.  *  * This code is derived from software contributed to The NetBSD Foundation  * by Matt Thomas<matt@3am-software.com> of Allegro Networks, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *        This product includes software developed by the NetBSD  *        Foundation, Inc. and its contributors.  * 4. Neither the name of The NetBSD Foundation nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Copyright (C) 1995, 1996 Wolfgang Solfrank.  * Copyright (C) 1995, 1996 TooLs GmbH.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by TooLs GmbH.  * 4. The name of TooLs GmbH may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $NetBSD: pmap.c,v 1.28 2000/03/26 20:42:36 kleink Exp $  */
end_comment

begin_comment
comment|/*  * Copyright (C) 2001 Benno Rice.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY Benno Rice ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Manages physical address maps.  *  * In addition to hardware address maps, this module is called upon to  * provide software-use-only maps which may or may not be stored in the  * same form as hardware maps.  These pseudo-maps are used to store  * intermediate results from copy operations to and from address spaces.  *  * Since the information managed by this module is also stored by the  * logical address mapping module, this module may throw away valid virtual  * to physical mappings at almost any time.  However, invalidations of  * mappings must be done as requested.  *  * In order to cope with hardware architectures which make virtual to  * physical map invalidates expensive, this module may delay invalidate  * reduced protection operations until such time as they are actually  * necessary.  This module is given full information as to which processors  * are currently using which maps, and to when physical maps must be made  * correct.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/msgbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/openfirm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pageout.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pager.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<machine/powerpc.h>
end_include

begin_include
include|#
directive|include
file|<machine/bat.h>
end_include

begin_include
include|#
directive|include
file|<machine/frame.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/psl.h>
end_include

begin_include
include|#
directive|include
file|<machine/pte.h>
end_include

begin_include
include|#
directive|include
file|<machine/sr.h>
end_include

begin_define
define|#
directive|define
name|PMAP_DEBUG
end_define

begin_define
define|#
directive|define
name|TODO
value|panic("%s: not implemented", __func__);
end_define

begin_define
define|#
directive|define
name|PMAP_LOCK
parameter_list|(
name|pm
parameter_list|)
end_define

begin_define
define|#
directive|define
name|PMAP_UNLOCK
parameter_list|(
name|pm
parameter_list|)
end_define

begin_define
define|#
directive|define
name|TLBIE
parameter_list|(
name|va
parameter_list|)
value|__asm __volatile("tlbie %0" :: "r"(va))
end_define

begin_define
define|#
directive|define
name|TLBSYNC
parameter_list|()
value|__asm __volatile("tlbsync");
end_define

begin_define
define|#
directive|define
name|SYNC
parameter_list|()
value|__asm __volatile("sync");
end_define

begin_define
define|#
directive|define
name|EIEIO
parameter_list|()
value|__asm __volatile("eieio");
end_define

begin_define
define|#
directive|define
name|VSID_MAKE
parameter_list|(
name|sr
parameter_list|,
name|hash
parameter_list|)
value|((sr) | (((hash)& 0xfffff)<< 4))
end_define

begin_define
define|#
directive|define
name|VSID_TO_SR
parameter_list|(
name|vsid
parameter_list|)
value|((vsid)& 0xf)
end_define

begin_define
define|#
directive|define
name|VSID_TO_HASH
parameter_list|(
name|vsid
parameter_list|)
value|(((vsid)>> 4)& 0xfffff)
end_define

begin_define
define|#
directive|define
name|PVO_PTEGIDX_MASK
value|0x0007
end_define

begin_comment
comment|/* which PTEG slot */
end_comment

begin_define
define|#
directive|define
name|PVO_PTEGIDX_VALID
value|0x0008
end_define

begin_comment
comment|/* slot is valid */
end_comment

begin_define
define|#
directive|define
name|PVO_WIRED
value|0x0010
end_define

begin_comment
comment|/* PVO entry is wired */
end_comment

begin_define
define|#
directive|define
name|PVO_MANAGED
value|0x0020
end_define

begin_comment
comment|/* PVO entry is managed */
end_comment

begin_define
define|#
directive|define
name|PVO_EXECUTABLE
value|0x0040
end_define

begin_comment
comment|/* PVO entry is executable */
end_comment

begin_define
define|#
directive|define
name|PVO_BOOTSTRAP
value|0x0080
end_define

begin_comment
comment|/* PVO entry allocated during 						   bootstrap */
end_comment

begin_define
define|#
directive|define
name|PVO_VADDR
parameter_list|(
name|pvo
parameter_list|)
value|((pvo)->pvo_vaddr& ~ADDR_POFF)
end_define

begin_define
define|#
directive|define
name|PVO_ISEXECUTABLE
parameter_list|(
name|pvo
parameter_list|)
value|((pvo)->pvo_vaddr& PVO_EXECUTABLE)
end_define

begin_define
define|#
directive|define
name|PVO_PTEGIDX_GET
parameter_list|(
name|pvo
parameter_list|)
value|((pvo)->pvo_vaddr& PVO_PTEGIDX_MASK)
end_define

begin_define
define|#
directive|define
name|PVO_PTEGIDX_ISSET
parameter_list|(
name|pvo
parameter_list|)
value|((pvo)->pvo_vaddr& PVO_PTEGIDX_VALID)
end_define

begin_define
define|#
directive|define
name|PVO_PTEGIDX_CLR
parameter_list|(
name|pvo
parameter_list|)
define|\
value|((void)((pvo)->pvo_vaddr&= ~(PVO_PTEGIDX_VALID|PVO_PTEGIDX_MASK)))
end_define

begin_define
define|#
directive|define
name|PVO_PTEGIDX_SET
parameter_list|(
name|pvo
parameter_list|,
name|i
parameter_list|)
define|\
value|((void)((pvo)->pvo_vaddr |= (i)|PVO_PTEGIDX_VALID))
end_define

begin_define
define|#
directive|define
name|PMAP_PVO_CHECK
parameter_list|(
name|pvo
parameter_list|)
end_define

begin_struct
struct|struct
name|ofw_map
block|{
name|vm_offset_t
name|om_va
decl_stmt|;
name|vm_size_t
name|om_len
decl_stmt|;
name|vm_offset_t
name|om_pa
decl_stmt|;
name|u_int
name|om_mode
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|int
name|pmap_bootstrapped
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Virtual and physical address of message buffer.  */
end_comment

begin_decl_stmt
name|struct
name|msgbuf
modifier|*
name|msgbufp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|msgbuf_phys
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Physical addresses of first and last available physical page.  */
end_comment

begin_decl_stmt
name|vm_offset_t
name|avail_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|avail_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pmap_pagedaemon_waken
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Map of physical memory regions.  */
end_comment

begin_decl_stmt
name|vm_offset_t
name|phys_avail
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|phys_avail_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mem_region
modifier|*
name|regions
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mem_region
modifier|*
name|pregions
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|regions_sz
decl_stmt|,
name|pregions_sz
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ofw_map
modifier|*
name|translations
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * First and last available kernel virtual addresses.  */
end_comment

begin_decl_stmt
name|vm_offset_t
name|virtual_avail
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|virtual_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|kernel_vm_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Kernel pmap.  */
end_comment

begin_decl_stmt
name|struct
name|pmap
name|kernel_pmap_store
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|pmap
name|ofw_pmap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * PTEG data.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|pteg
modifier|*
name|pmap_pteg_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|pmap_pteg_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|pmap_pteg_mask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * PVO data.  */
end_comment

begin_decl_stmt
name|struct
name|pvo_head
modifier|*
name|pmap_pvo_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pvo entries by pteg index */
end_comment

begin_decl_stmt
name|struct
name|pvo_head
name|pmap_pvo_kunmanaged
init|=
name|LIST_HEAD_INITIALIZER
argument_list|(
name|pmap_pvo_kunmanaged
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of unmanaged pages */
end_comment

begin_decl_stmt
name|struct
name|pvo_head
name|pmap_pvo_unmanaged
init|=
name|LIST_HEAD_INITIALIZER
argument_list|(
name|pmap_pvo_unmanaged
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of unmanaged pages */
end_comment

begin_decl_stmt
name|uma_zone_t
name|pmap_upvo_zone
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* zone for pvo entries for unmanaged pages */
end_comment

begin_decl_stmt
name|uma_zone_t
name|pmap_mpvo_zone
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* zone for pvo entries for managed pages */
end_comment

begin_decl_stmt
name|struct
name|vm_object
name|pmap_upvo_zone_obj
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vm_object
name|pmap_mpvo_zone_obj
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|BPVO_POOL_SIZE
value|32768
end_define

begin_decl_stmt
specifier|static
name|struct
name|pvo_entry
modifier|*
name|pmap_bpvo_pool
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pmap_bpvo_pool_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|VSID_NBPW
value|(sizeof(u_int32_t) * 8)
end_define

begin_decl_stmt
specifier|static
name|u_int
name|pmap_vsid_bitmap
index|[
name|NPMAPS
operator|/
name|VSID_NBPW
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean_t
name|pmap_initialized
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Statistics.  */
end_comment

begin_decl_stmt
name|u_int
name|pmap_pte_valid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|pmap_pte_overflow
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|pmap_pte_replacements
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|pmap_pvo_entries
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|pmap_pvo_enter_calls
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|pmap_pvo_remove_calls
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|pmap_pte_spills
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|pmap_pte_valid
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pmap_pte_valid
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|pmap_pte_overflow
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pmap_pte_overflow
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|pmap_pte_replacements
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pmap_pte_replacements
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|pmap_pvo_entries
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pmap_pvo_entries
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|pmap_pvo_enter_calls
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pmap_pvo_enter_calls
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|pmap_pvo_remove_calls
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pmap_pvo_remove_calls
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|pmap_pte_spills
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pmap_pte_spills
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|pvo_entry
modifier|*
name|pmap_pvo_zeropage
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|pmap_rkva_start
init|=
name|VM_MIN_KERNEL_ADDRESS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|pmap_rkva_count
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Allocate physical memory for use in pmap_bootstrap.  */
end_comment

begin_function_decl
specifier|static
name|vm_offset_t
name|pmap_bootstrap_alloc
parameter_list|(
name|vm_size_t
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * PTE calls.  */
end_comment

begin_function_decl
specifier|static
name|int
name|pmap_pte_insert
parameter_list|(
name|u_int
parameter_list|,
name|struct
name|pte
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * PVO calls.  */
end_comment

begin_function_decl
specifier|static
name|int
name|pmap_pvo_enter
parameter_list|(
name|pmap_t
parameter_list|,
name|uma_zone_t
parameter_list|,
name|struct
name|pvo_head
modifier|*
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|u_int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_pvo_remove
parameter_list|(
name|struct
name|pvo_entry
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|pvo_entry
modifier|*
name|pmap_pvo_find_va
parameter_list|(
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|pte
modifier|*
name|pmap_pvo_to_pte
parameter_list|(
specifier|const
name|struct
name|pvo_entry
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Utility routines.  */
end_comment

begin_function_decl
specifier|static
name|void
modifier|*
name|pmap_pvo_allocf
parameter_list|(
name|uma_zone_t
parameter_list|,
name|int
parameter_list|,
name|u_int8_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|pvo_entry
modifier|*
name|pmap_rkva_alloc
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_pa_map
parameter_list|(
name|struct
name|pvo_entry
modifier|*
parameter_list|,
name|vm_offset_t
parameter_list|,
name|struct
name|pte
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_pa_unmap
parameter_list|(
name|struct
name|pvo_entry
modifier|*
parameter_list|,
name|struct
name|pte
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_syncicache
parameter_list|(
name|vm_offset_t
parameter_list|,
name|vm_size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean_t
name|pmap_query_bit
parameter_list|(
name|vm_page_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|pmap_clear_bit
parameter_list|(
name|vm_page_t
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tlbia
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|__inline
name|int
name|va_to_sr
parameter_list|(
name|u_int
modifier|*
name|sr
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
return|return
operator|(
name|sr
index|[
operator|(
name|uintptr_t
operator|)
name|va
operator|>>
name|ADDR_SR_SHFT
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|u_int
name|va_to_pteg
parameter_list|(
name|u_int
name|sr
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|)
block|{
name|u_int
name|hash
decl_stmt|;
name|hash
operator|=
operator|(
name|sr
operator|&
name|SR_VSID_MASK
operator|)
operator|^
operator|(
operator|(
operator|(
name|u_int
operator|)
name|addr
operator|&
name|ADDR_PIDX
operator|)
operator|>>
name|ADDR_PIDX_SHFT
operator|)
expr_stmt|;
return|return
operator|(
name|hash
operator|&
name|pmap_pteg_mask
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|pvo_head
operator|*
name|pa_to_pvoh
argument_list|(
argument|vm_offset_t pa
argument_list|,
argument|vm_page_t *pg_p
argument_list|)
block|{ 	struct
name|vm_page
operator|*
name|pg
block|;
name|pg
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
block|;
if|if
condition|(
name|pg_p
operator|!=
name|NULL
condition|)
operator|*
name|pg_p
operator|=
name|pg
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|pg
operator|==
name|NULL
condition|)
return|return
operator|(
operator|&
name|pmap_pvo_unmanaged
operator|)
return|;
end_if

begin_return
return|return
operator|(
operator|&
name|pg
operator|->
name|md
operator|.
name|mdpg_pvoh
operator|)
return|;
end_return

begin_function
unit|}  static
name|__inline
name|struct
name|pvo_head
modifier|*
name|vm_page_to_pvoh
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
return|return
operator|(
operator|&
name|m
operator|->
name|md
operator|.
name|mdpg_pvoh
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|pmap_attr_clear
parameter_list|(
name|vm_page_t
name|m
parameter_list|,
name|int
name|ptebit
parameter_list|)
block|{
name|m
operator|->
name|md
operator|.
name|mdpg_attrs
operator|&=
operator|~
name|ptebit
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|pmap_attr_fetch
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
return|return
operator|(
name|m
operator|->
name|md
operator|.
name|mdpg_attrs
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|pmap_attr_save
parameter_list|(
name|vm_page_t
name|m
parameter_list|,
name|int
name|ptebit
parameter_list|)
block|{
name|m
operator|->
name|md
operator|.
name|mdpg_attrs
operator||=
name|ptebit
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|pmap_pte_compare
parameter_list|(
specifier|const
name|struct
name|pte
modifier|*
name|pt
parameter_list|,
specifier|const
name|struct
name|pte
modifier|*
name|pvo_pt
parameter_list|)
block|{
if|if
condition|(
name|pt
operator|->
name|pte_hi
operator|==
name|pvo_pt
operator|->
name|pte_hi
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|pmap_pte_match
parameter_list|(
name|struct
name|pte
modifier|*
name|pt
parameter_list|,
name|u_int
name|sr
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|int
name|which
parameter_list|)
block|{
return|return
operator|(
name|pt
operator|->
name|pte_hi
operator|&
operator|~
name|PTE_VALID
operator|)
operator|==
operator|(
operator|(
operator|(
name|sr
operator|&
name|SR_VSID_MASK
operator|)
operator|<<
name|PTE_VSID_SHFT
operator|)
operator||
operator|(
operator|(
name|va
operator|>>
name|ADDR_API_SHFT
operator|)
operator|&
name|PTE_API
operator|)
operator||
name|which
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|pmap_pte_create
parameter_list|(
name|struct
name|pte
modifier|*
name|pt
parameter_list|,
name|u_int
name|sr
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|u_int
name|pte_lo
parameter_list|)
block|{
comment|/* 	 * Construct a PTE.  Default to IMB initially.  Valid bit only gets 	 * set when the real pte is set in memory. 	 * 	 * Note: Don't set the valid bit for correct operation of tlb update. 	 */
name|pt
operator|->
name|pte_hi
operator|=
operator|(
operator|(
name|sr
operator|&
name|SR_VSID_MASK
operator|)
operator|<<
name|PTE_VSID_SHFT
operator|)
operator||
operator|(
operator|(
operator|(
name|va
operator|&
name|ADDR_PIDX
operator|)
operator|>>
name|ADDR_API_SHFT
operator|)
operator|&
name|PTE_API
operator|)
expr_stmt|;
name|pt
operator|->
name|pte_lo
operator|=
name|pte_lo
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|pmap_pte_synch
parameter_list|(
name|struct
name|pte
modifier|*
name|pt
parameter_list|,
name|struct
name|pte
modifier|*
name|pvo_pt
parameter_list|)
block|{
name|pvo_pt
operator|->
name|pte_lo
operator||=
name|pt
operator|->
name|pte_lo
operator|&
operator|(
name|PTE_REF
operator||
name|PTE_CHG
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|pmap_pte_clear
parameter_list|(
name|struct
name|pte
modifier|*
name|pt
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|int
name|ptebit
parameter_list|)
block|{
comment|/* 	 * As shown in Section 7.6.3.2.3 	 */
name|pt
operator|->
name|pte_lo
operator|&=
operator|~
name|ptebit
expr_stmt|;
name|TLBIE
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|EIEIO
argument_list|()
expr_stmt|;
name|TLBSYNC
argument_list|()
expr_stmt|;
name|SYNC
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|pmap_pte_set
parameter_list|(
name|struct
name|pte
modifier|*
name|pt
parameter_list|,
name|struct
name|pte
modifier|*
name|pvo_pt
parameter_list|)
block|{
name|pvo_pt
operator|->
name|pte_hi
operator||=
name|PTE_VALID
expr_stmt|;
comment|/* 	 * Update the PTE as defined in section 7.6.3.1. 	 * Note that the REF/CHG bits are from pvo_pt and thus should havce 	 * been saved so this routine can restore them (if desired). 	 */
name|pt
operator|->
name|pte_lo
operator|=
name|pvo_pt
operator|->
name|pte_lo
expr_stmt|;
name|EIEIO
argument_list|()
expr_stmt|;
name|pt
operator|->
name|pte_hi
operator|=
name|pvo_pt
operator|->
name|pte_hi
expr_stmt|;
name|SYNC
argument_list|()
expr_stmt|;
name|pmap_pte_valid
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|pmap_pte_unset
parameter_list|(
name|struct
name|pte
modifier|*
name|pt
parameter_list|,
name|struct
name|pte
modifier|*
name|pvo_pt
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|pvo_pt
operator|->
name|pte_hi
operator|&=
operator|~
name|PTE_VALID
expr_stmt|;
comment|/* 	 * Force the reg& chg bits back into the PTEs. 	 */
name|SYNC
argument_list|()
expr_stmt|;
comment|/* 	 * Invalidate the pte. 	 */
name|pt
operator|->
name|pte_hi
operator|&=
operator|~
name|PTE_VALID
expr_stmt|;
name|SYNC
argument_list|()
expr_stmt|;
name|TLBIE
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|EIEIO
argument_list|()
expr_stmt|;
name|TLBSYNC
argument_list|()
expr_stmt|;
name|SYNC
argument_list|()
expr_stmt|;
comment|/* 	 * Save the reg& chg bits. 	 */
name|pmap_pte_synch
argument_list|(
name|pt
argument_list|,
name|pvo_pt
argument_list|)
expr_stmt|;
name|pmap_pte_valid
operator|--
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|pmap_pte_change
parameter_list|(
name|struct
name|pte
modifier|*
name|pt
parameter_list|,
name|struct
name|pte
modifier|*
name|pvo_pt
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
comment|/* 	 * Invalidate the PTE 	 */
name|pmap_pte_unset
argument_list|(
name|pt
argument_list|,
name|pvo_pt
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|pmap_pte_set
argument_list|(
name|pt
argument_list|,
name|pvo_pt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Quick sort callout for comparing memory regions.  */
end_comment

begin_function_decl
specifier|static
name|int
name|mr_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|om_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|mr_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|struct
name|mem_region
modifier|*
name|regiona
decl_stmt|;
specifier|const
name|struct
name|mem_region
modifier|*
name|regionb
decl_stmt|;
name|regiona
operator|=
name|a
expr_stmt|;
name|regionb
operator|=
name|b
expr_stmt|;
if|if
condition|(
name|regiona
operator|->
name|mr_start
operator|<
name|regionb
operator|->
name|mr_start
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|regiona
operator|->
name|mr_start
operator|>
name|regionb
operator|->
name|mr_start
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|om_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|struct
name|ofw_map
modifier|*
name|mapa
decl_stmt|;
specifier|const
name|struct
name|ofw_map
modifier|*
name|mapb
decl_stmt|;
name|mapa
operator|=
name|a
expr_stmt|;
name|mapb
operator|=
name|b
expr_stmt|;
if|if
condition|(
name|mapa
operator|->
name|om_pa
operator|<
name|mapb
operator|->
name|om_pa
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|mapa
operator|->
name|om_pa
operator|>
name|mapb
operator|->
name|om_pa
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pmap_bootstrap
parameter_list|(
name|vm_offset_t
name|kernelstart
parameter_list|,
name|vm_offset_t
name|kernelend
parameter_list|)
block|{
name|ihandle_t
name|mmui
decl_stmt|;
name|phandle_t
name|chosen
decl_stmt|,
name|mmu
decl_stmt|;
name|int
name|sz
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|ofw_mappings
decl_stmt|;
name|vm_size_t
name|size
decl_stmt|,
name|physsz
decl_stmt|;
name|vm_offset_t
name|pa
decl_stmt|,
name|va
decl_stmt|,
name|off
decl_stmt|;
name|u_int
name|batl
decl_stmt|,
name|batu
decl_stmt|;
comment|/*          * Set up BAT0 to map the lowest 256 MB area          */
name|battable
index|[
literal|0x0
index|]
operator|.
name|batl
operator|=
name|BATL
argument_list|(
literal|0x00000000
argument_list|,
name|BAT_M
argument_list|,
name|BAT_PP_RW
argument_list|)
expr_stmt|;
name|battable
index|[
literal|0x0
index|]
operator|.
name|batu
operator|=
name|BATU
argument_list|(
literal|0x00000000
argument_list|,
name|BAT_BL_256M
argument_list|,
name|BAT_Vs
argument_list|)
expr_stmt|;
comment|/*          * Map PCI memory space.          */
name|battable
index|[
literal|0x8
index|]
operator|.
name|batl
operator|=
name|BATL
argument_list|(
literal|0x80000000
argument_list|,
name|BAT_I
operator||
name|BAT_G
argument_list|,
name|BAT_PP_RW
argument_list|)
expr_stmt|;
name|battable
index|[
literal|0x8
index|]
operator|.
name|batu
operator|=
name|BATU
argument_list|(
literal|0x80000000
argument_list|,
name|BAT_BL_256M
argument_list|,
name|BAT_Vs
argument_list|)
expr_stmt|;
name|battable
index|[
literal|0x9
index|]
operator|.
name|batl
operator|=
name|BATL
argument_list|(
literal|0x90000000
argument_list|,
name|BAT_I
operator||
name|BAT_G
argument_list|,
name|BAT_PP_RW
argument_list|)
expr_stmt|;
name|battable
index|[
literal|0x9
index|]
operator|.
name|batu
operator|=
name|BATU
argument_list|(
literal|0x90000000
argument_list|,
name|BAT_BL_256M
argument_list|,
name|BAT_Vs
argument_list|)
expr_stmt|;
name|battable
index|[
literal|0xa
index|]
operator|.
name|batl
operator|=
name|BATL
argument_list|(
literal|0xa0000000
argument_list|,
name|BAT_I
operator||
name|BAT_G
argument_list|,
name|BAT_PP_RW
argument_list|)
expr_stmt|;
name|battable
index|[
literal|0xa
index|]
operator|.
name|batu
operator|=
name|BATU
argument_list|(
literal|0xa0000000
argument_list|,
name|BAT_BL_256M
argument_list|,
name|BAT_Vs
argument_list|)
expr_stmt|;
name|battable
index|[
literal|0xb
index|]
operator|.
name|batl
operator|=
name|BATL
argument_list|(
literal|0xb0000000
argument_list|,
name|BAT_I
operator||
name|BAT_G
argument_list|,
name|BAT_PP_RW
argument_list|)
expr_stmt|;
name|battable
index|[
literal|0xb
index|]
operator|.
name|batu
operator|=
name|BATU
argument_list|(
literal|0xb0000000
argument_list|,
name|BAT_BL_256M
argument_list|,
name|BAT_Vs
argument_list|)
expr_stmt|;
comment|/*          * Map obio devices.          */
name|battable
index|[
literal|0xf
index|]
operator|.
name|batl
operator|=
name|BATL
argument_list|(
literal|0xf0000000
argument_list|,
name|BAT_I
operator||
name|BAT_G
argument_list|,
name|BAT_PP_RW
argument_list|)
expr_stmt|;
name|battable
index|[
literal|0xf
index|]
operator|.
name|batu
operator|=
name|BATU
argument_list|(
literal|0xf0000000
argument_list|,
name|BAT_BL_256M
argument_list|,
name|BAT_Vs
argument_list|)
expr_stmt|;
comment|/* 	 * Use an IBAT and a DBAT to map the bottom segment of memory 	 * where we are. 	 */
name|batu
operator|=
name|BATU
argument_list|(
literal|0x00000000
argument_list|,
name|BAT_BL_256M
argument_list|,
name|BAT_Vs
argument_list|)
expr_stmt|;
name|batl
operator|=
name|BATL
argument_list|(
literal|0x00000000
argument_list|,
name|BAT_M
argument_list|,
name|BAT_PP_RW
argument_list|)
expr_stmt|;
asm|__asm ("mtibatu 0,%0; mtibatl 0,%1; mtdbatu 0,%0; mtdbatl 0,%1"
operator|::
literal|"r"
operator|(
name|batu
operator|)
operator|,
literal|"r"
operator|(
name|batl
operator|)
block|)
function|;
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* map frame buffer */
end_comment

begin_endif
unit|batu = BATU(0x90000000, BAT_BL_256M, BAT_Vs); 	batl = BATL(0x90000000, BAT_I|BAT_G, BAT_PP_RW); 	__asm ("mtdbatu 1,%0; mtdbatl 1,%1" 	    :: "r"(batu), "r"(batl));
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|1
end_if

begin_comment
comment|/* map pci space */
end_comment

begin_expr_stmt
name|batu
operator|=
name|BATU
argument_list|(
literal|0x80000000
argument_list|,
name|BAT_BL_256M
argument_list|,
name|BAT_Vs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|batl
operator|=
name|BATL
argument_list|(
literal|0x80000000
argument_list|,
name|BAT_I
operator||
name|BAT_G
argument_list|,
name|BAT_PP_RW
argument_list|)
expr_stmt|;
end_expr_stmt

begin_asm
asm|__asm ("mtdbatu 1,%0; mtdbatl 1,%1"
end_asm

begin_expr_stmt
operator|::
literal|"r"
operator|(
name|batu
operator|)
operator|,
literal|"r"
operator|(
name|batl
operator|)
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* 	 * Set the start and end of kva. 	 */
end_comment

begin_expr_stmt
name|virtual_avail
operator|=
name|VM_MIN_KERNEL_ADDRESS
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|virtual_end
operator|=
name|VM_MAX_KERNEL_ADDRESS
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|mem_regions
argument_list|(
operator|&
name|pregions
argument_list|,
operator|&
name|pregions_sz
argument_list|,
operator|&
name|regions
argument_list|,
operator|&
name|regions_sz
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTR0
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_bootstrap: physical memory"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|qsort
argument_list|(
name|pregions
argument_list|,
name|pregions_sz
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pregions
argument_list|)
argument_list|,
name|mr_cmp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pregions_sz
condition|;
name|i
operator|++
control|)
block|{
name|vm_offset_t
name|pa
decl_stmt|;
name|vm_offset_t
name|end
decl_stmt|;
name|CTR3
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"physregion: %#x - %#x (%#x)"
argument_list|,
name|pregions
index|[
name|i
index|]
operator|.
name|mr_start
argument_list|,
name|pregions
index|[
name|i
index|]
operator|.
name|mr_start
operator|+
name|pregions
index|[
name|i
index|]
operator|.
name|mr_size
argument_list|,
name|pregions
index|[
name|i
index|]
operator|.
name|mr_size
argument_list|)
expr_stmt|;
comment|/* 		 * Install entries into the BAT table to allow all 		 * of physmem to be convered by on-demand BAT entries. 		 * The loop will sometimes set the same battable element 		 * twice, but that's fine since they won't be used for 		 * a while yet. 		 */
name|pa
operator|=
name|pregions
index|[
name|i
index|]
operator|.
name|mr_start
operator|&
literal|0xf0000000
expr_stmt|;
name|end
operator|=
name|pregions
index|[
name|i
index|]
operator|.
name|mr_start
operator|+
name|pregions
index|[
name|i
index|]
operator|.
name|mr_size
expr_stmt|;
do|do
block|{
name|u_int
name|n
init|=
name|pa
operator|>>
name|ADDR_SR_SHFT
decl_stmt|;
name|battable
index|[
name|n
index|]
operator|.
name|batl
operator|=
name|BATL
argument_list|(
name|pa
argument_list|,
name|BAT_M
argument_list|,
name|BAT_PP_RW
argument_list|)
expr_stmt|;
name|battable
index|[
name|n
index|]
operator|.
name|batu
operator|=
name|BATU
argument_list|(
name|pa
argument_list|,
name|BAT_BL_256M
argument_list|,
name|BAT_Vs
argument_list|)
expr_stmt|;
name|pa
operator|+=
name|SEGMENT_LENGTH
expr_stmt|;
block|}
do|while
condition|(
name|pa
operator|<
name|end
condition|)
do|;
block|}
end_for

begin_if
if|if
condition|(
sizeof|sizeof
argument_list|(
name|phys_avail
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|phys_avail
index|[
literal|0
index|]
argument_list|)
operator|<
name|regions_sz
condition|)
name|panic
argument_list|(
literal|"pmap_bootstrap: phys_avail too small"
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|qsort
argument_list|(
name|regions
argument_list|,
name|regions_sz
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|regions
argument_list|)
argument_list|,
name|mr_cmp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|phys_avail_count
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|physsz
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|regions_sz
condition|;
name|i
operator|++
operator|,
name|j
operator|+=
literal|2
control|)
block|{
name|CTR3
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"region: %#x - %#x (%#x)"
argument_list|,
name|regions
index|[
name|i
index|]
operator|.
name|mr_start
argument_list|,
name|regions
index|[
name|i
index|]
operator|.
name|mr_start
operator|+
name|regions
index|[
name|i
index|]
operator|.
name|mr_size
argument_list|,
name|regions
index|[
name|i
index|]
operator|.
name|mr_size
argument_list|)
expr_stmt|;
name|phys_avail
index|[
name|j
index|]
operator|=
name|regions
index|[
name|i
index|]
operator|.
name|mr_start
expr_stmt|;
name|phys_avail
index|[
name|j
operator|+
literal|1
index|]
operator|=
name|regions
index|[
name|i
index|]
operator|.
name|mr_start
operator|+
name|regions
index|[
name|i
index|]
operator|.
name|mr_size
expr_stmt|;
name|phys_avail_count
operator|++
expr_stmt|;
name|physsz
operator|+=
name|regions
index|[
name|i
index|]
operator|.
name|mr_size
expr_stmt|;
block|}
end_for

begin_expr_stmt
name|physmem
operator|=
name|btoc
argument_list|(
name|physsz
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	 * Allocate PTEG table. 	 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PTEGCOUNT
end_ifdef

begin_expr_stmt
name|pmap_pteg_count
operator|=
name|PTEGCOUNT
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|pmap_pteg_count
operator|=
literal|0x1000
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|pmap_pteg_count
operator|<
name|physmem
condition|)
name|pmap_pteg_count
operator|<<=
literal|1
expr_stmt|;
end_while

begin_expr_stmt
name|pmap_pteg_count
operator|>>=
literal|1
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PTEGCOUNT */
end_comment

begin_expr_stmt
name|size
operator|=
name|pmap_pteg_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pteg
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_bootstrap: %d PTEGs, %d bytes"
argument_list|,
name|pmap_pteg_count
argument_list|,
name|size
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|pmap_pteg_table
operator|=
operator|(
expr|struct
name|pteg
operator|*
operator|)
name|pmap_bootstrap_alloc
argument_list|(
name|size
argument_list|,
name|size
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTR1
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_bootstrap: PTEG table at %p"
argument_list|,
name|pmap_pteg_table
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|pmap_pteg_table
argument_list|,
name|pmap_pteg_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pteg
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|pmap_pteg_mask
operator|=
name|pmap_pteg_count
operator|-
literal|1
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	 * Allocate pv/overflow lists. 	 */
end_comment

begin_expr_stmt
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|pvo_head
argument_list|)
operator|*
name|pmap_pteg_count
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|pmap_pvo_table
operator|=
operator|(
expr|struct
name|pvo_head
operator|*
operator|)
name|pmap_bootstrap_alloc
argument_list|(
name|size
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTR1
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_bootstrap: PVO table at %p"
argument_list|,
name|pmap_pvo_table
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pmap_pteg_count
condition|;
name|i
operator|++
control|)
name|LIST_INIT
argument_list|(
operator|&
name|pmap_pvo_table
index|[
name|i
index|]
argument_list|)
expr_stmt|;
end_for

begin_comment
comment|/* 	 * Allocate the message buffer. 	 */
end_comment

begin_expr_stmt
name|msgbuf_phys
operator|=
name|pmap_bootstrap_alloc
argument_list|(
name|MSGBUF_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	 * Initialise the unmanaged pvo pool. 	 */
end_comment

begin_expr_stmt
name|pmap_bpvo_pool
operator|=
operator|(
expr|struct
name|pvo_entry
operator|*
operator|)
name|pmap_bootstrap_alloc
argument_list|(
name|BPVO_POOL_SIZE
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pvo_entry
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|pmap_bpvo_pool_index
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	 * Make sure kernel vsid is allocated as well as VSID 0. 	 */
end_comment

begin_expr_stmt
name|pmap_vsid_bitmap
index|[
operator|(
name|KERNEL_VSIDBITS
operator|&
operator|(
name|NPMAPS
operator|-
literal|1
operator|)
operator|)
operator|/
name|VSID_NBPW
index|]
operator||=
literal|1
operator|<<
operator|(
name|KERNEL_VSIDBITS
operator|%
name|VSID_NBPW
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|pmap_vsid_bitmap
index|[
literal|0
index|]
operator||=
literal|1
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	 * Set up the OpenFirmware pmap and add it's mappings. 	 */
end_comment

begin_expr_stmt
name|pmap_pinit
argument_list|(
operator|&
name|ofw_pmap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ofw_pmap
operator|.
name|pm_sr
index|[
name|KERNEL_SR
index|]
operator|=
name|KERNEL_SEGMENT
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|(
name|chosen
operator|=
name|OF_finddevice
argument_list|(
literal|"/chosen"
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"pmap_bootstrap: can't find /chosen"
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|OF_getprop
argument_list|(
name|chosen
argument_list|,
literal|"mmu"
argument_list|,
operator|&
name|mmui
argument_list|,
literal|4
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|(
name|mmu
operator|=
name|OF_instance_to_package
argument_list|(
name|mmui
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"pmap_bootstrap: can't get mmu package"
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
operator|(
name|sz
operator|=
name|OF_getproplen
argument_list|(
name|mmu
argument_list|,
literal|"translations"
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"pmap_bootstrap: can't get ofw translation count"
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|translations
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|phys_avail
index|[
name|i
operator|+
literal|2
index|]
operator|!=
literal|0
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
operator|>=
name|sz
condition|)
name|translations
operator|=
operator|(
expr|struct
name|ofw_map
operator|*
operator|)
name|phys_avail
index|[
name|i
index|]
expr_stmt|;
block|}
end_for

begin_if
if|if
condition|(
name|translations
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"pmap_bootstrap: no space to copy translations"
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|bzero
argument_list|(
name|translations
argument_list|,
name|sz
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|OF_getprop
argument_list|(
name|mmu
argument_list|,
literal|"translations"
argument_list|,
name|translations
argument_list|,
name|sz
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"pmap_bootstrap: can't get ofw translations"
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|CTR0
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_bootstrap: translations"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|sz
operator|/=
sizeof|sizeof
argument_list|(
operator|*
name|translations
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|qsort
argument_list|(
name|translations
argument_list|,
name|sz
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|translations
argument_list|)
argument_list|,
name|om_cmp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ofw_mappings
operator|=
literal|0
init|;
name|i
operator|<
name|sz
condition|;
name|i
operator|++
control|)
block|{
name|CTR3
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"translation: pa=%#x va=%#x len=%#x"
argument_list|,
name|translations
index|[
name|i
index|]
operator|.
name|om_pa
argument_list|,
name|translations
index|[
name|i
index|]
operator|.
name|om_va
argument_list|,
name|translations
index|[
name|i
index|]
operator|.
name|om_len
argument_list|)
expr_stmt|;
comment|/* 		 * If the mapping is 1:1, let the RAM and device on-demand 		 * BAT tables take care of the translation. 		 */
if|if
condition|(
name|translations
index|[
name|i
index|]
operator|.
name|om_va
operator|==
name|translations
index|[
name|i
index|]
operator|.
name|om_pa
condition|)
continue|continue;
comment|/* Enter the pages */
for|for
control|(
name|off
operator|=
literal|0
init|;
name|off
operator|<
name|translations
index|[
name|i
index|]
operator|.
name|om_len
condition|;
name|off
operator|+=
name|PAGE_SIZE
control|)
block|{
name|struct
name|vm_page
name|m
decl_stmt|;
name|m
operator|.
name|phys_addr
operator|=
name|translations
index|[
name|i
index|]
operator|.
name|om_pa
operator|+
name|off
expr_stmt|;
name|pmap_enter
argument_list|(
operator|&
name|ofw_pmap
argument_list|,
name|translations
index|[
name|i
index|]
operator|.
name|om_va
operator|+
name|off
argument_list|,
operator|&
name|m
argument_list|,
name|VM_PROT_ALL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ofw_mappings
operator|++
expr_stmt|;
block|}
block|}
end_for

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_expr_stmt
name|TLBSYNC
argument_list|()
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* 	 * Initialize the kernel pmap (which is statically allocated). 	 */
end_comment

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|kernel_pmap
operator|->
name|pm_sr
index|[
name|i
index|]
operator|=
name|EMPTY_SEGMENT
expr_stmt|;
block|}
end_for

begin_expr_stmt
name|kernel_pmap
operator|->
name|pm_sr
index|[
name|KERNEL_SR
index|]
operator|=
name|KERNEL_SEGMENT
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|kernel_pmap
operator|->
name|pm_active
operator|=
operator|~
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	 * Allocate a kernel stack with a guard page for thread0 and map it 	 * into the kernel page map. 	 */
end_comment

begin_expr_stmt
name|pa
operator|=
name|pmap_bootstrap_alloc
argument_list|(
name|KSTACK_PAGES
operator|*
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|kstack0_phys
operator|=
name|pa
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|kstack0
operator|=
name|virtual_avail
operator|+
operator|(
name|KSTACK_GUARD_PAGES
operator|*
name|PAGE_SIZE
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_bootstrap: kstack0 at %#x (%#x)"
argument_list|,
name|kstack0_phys
argument_list|,
name|kstack0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|virtual_avail
operator|+=
operator|(
name|KSTACK_PAGES
operator|+
name|KSTACK_GUARD_PAGES
operator|)
operator|*
name|PAGE_SIZE
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|KSTACK_PAGES
condition|;
name|i
operator|++
control|)
block|{
name|pa
operator|=
name|kstack0_phys
operator|+
name|i
operator|*
name|PAGE_SIZE
expr_stmt|;
name|va
operator|=
name|kstack0
operator|+
name|i
operator|*
name|PAGE_SIZE
expr_stmt|;
name|pmap_kenter
argument_list|(
name|va
argument_list|,
name|pa
argument_list|)
expr_stmt|;
name|TLBIE
argument_list|(
name|va
argument_list|)
expr_stmt|;
block|}
end_for

begin_comment
comment|/* 	 * Calculate the first and last available physical addresses. 	 */
end_comment

begin_expr_stmt
name|avail_start
operator|=
name|phys_avail
index|[
literal|0
index|]
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|phys_avail
index|[
name|i
operator|+
literal|2
index|]
operator|!=
literal|0
condition|;
name|i
operator|+=
literal|2
control|)
empty_stmt|;
end_for

begin_expr_stmt
name|avail_end
operator|=
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Maxmem
operator|=
name|powerpc_btop
argument_list|(
name|avail_end
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	 * Allocate virtual address space for the message buffer. 	 */
end_comment

begin_expr_stmt
name|msgbufp
operator|=
operator|(
expr|struct
name|msgbuf
operator|*
operator|)
name|virtual_avail
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|virtual_avail
operator|+=
name|round_page
argument_list|(
name|MSGBUF_SIZE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	 * Initialize hardware. 	 */
end_comment

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|mtsrin
argument_list|(
name|i
operator|<<
name|ADDR_SR_SHFT
argument_list|,
name|EMPTY_SEGMENT
argument_list|)
expr_stmt|;
block|}
end_for

begin_asm
asm|__asm __volatile ("mtsr %0,%1"
end_asm

begin_expr_stmt
operator|::
literal|"n"
operator|(
name|KERNEL_SR
operator|)
operator|,
literal|"r"
operator|(
name|KERNEL_SEGMENT
operator|)
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_asm
asm|__asm __volatile ("sync; mtsdr1 %0; isync"
end_asm

begin_expr_stmt
operator|::
literal|"r"
operator|(
operator|(
name|u_int
operator|)
name|pmap_pteg_table
operator||
operator|(
name|pmap_pteg_mask
operator|>>
literal|10
operator|)
operator|)
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|tlbia
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|pmap_bootstrapped
operator|++
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/*  * Activate a user pmap.  The pmap must be activated before it's address  * space can be accessed in any way.  */
end_comment

begin_macro
unit|void
name|pmap_activate
argument_list|(
argument|struct thread *td
argument_list|)
end_macro

begin_block
block|{
name|pmap_t
name|pm
decl_stmt|,
name|pmr
decl_stmt|;
comment|/* 	 * Load all the data we need up front to encourage the compiler to 	 * not issue any loads while we have interrupts disabled below. 	 */
name|pm
operator|=
operator|&
name|td
operator|->
name|td_proc
operator|->
name|p_vmspace
operator|->
name|vm_pmap
expr_stmt|;
if|if
condition|(
operator|(
name|pmr
operator|=
operator|(
name|pmap_t
operator|)
name|pmap_kextract
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|pm
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|pmr
operator|=
name|pm
expr_stmt|;
name|pm
operator|->
name|pm_active
operator||=
name|PCPU_GET
argument_list|(
name|cpumask
argument_list|)
expr_stmt|;
name|PCPU_SET
argument_list|(
name|curpmap
argument_list|,
name|pmr
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|void
name|pmap_deactivate
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|pmap_t
name|pm
decl_stmt|;
name|pm
operator|=
operator|&
name|td
operator|->
name|td_proc
operator|->
name|p_vmspace
operator|->
name|vm_pmap
expr_stmt|;
name|pm
operator|->
name|pm_active
operator|&=
operator|~
operator|(
name|PCPU_GET
argument_list|(
name|cpumask
argument_list|)
operator|)
expr_stmt|;
name|PCPU_SET
argument_list|(
name|curpmap
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|vm_offset_t
name|pmap_addr_hint
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
return|return
operator|(
name|va
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pmap_change_wiring
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|boolean_t
name|wired
parameter_list|)
block|{
name|struct
name|pvo_entry
modifier|*
name|pvo
decl_stmt|;
name|pvo
operator|=
name|pmap_pvo_find_va
argument_list|(
name|pm
argument_list|,
name|va
operator|&
operator|~
name|ADDR_POFF
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvo
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|wired
condition|)
block|{
if|if
condition|(
operator|(
name|pvo
operator|->
name|pvo_vaddr
operator|&
name|PVO_WIRED
operator|)
operator|==
literal|0
condition|)
name|pm
operator|->
name|pm_stats
operator|.
name|wired_count
operator|++
expr_stmt|;
name|pvo
operator|->
name|pvo_vaddr
operator||=
name|PVO_WIRED
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|pvo
operator|->
name|pvo_vaddr
operator|&
name|PVO_WIRED
operator|)
operator|!=
literal|0
condition|)
name|pm
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
name|pvo
operator|->
name|pvo_vaddr
operator|&=
operator|~
name|PVO_WIRED
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|pmap_copy
parameter_list|(
name|pmap_t
name|dst_pmap
parameter_list|,
name|pmap_t
name|src_pmap
parameter_list|,
name|vm_offset_t
name|dst_addr
parameter_list|,
name|vm_size_t
name|len
parameter_list|,
name|vm_offset_t
name|src_addr
parameter_list|)
block|{
comment|/* 	 * This is not needed as it's mainly an optimisation. 	 * It may want to be implemented later though. 	 */
block|}
end_function

begin_function
name|void
name|pmap_copy_page
parameter_list|(
name|vm_page_t
name|msrc
parameter_list|,
name|vm_page_t
name|mdst
parameter_list|)
block|{
name|vm_offset_t
name|dst
decl_stmt|;
name|vm_offset_t
name|src
decl_stmt|;
name|dst
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|mdst
argument_list|)
expr_stmt|;
name|src
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|msrc
argument_list|)
expr_stmt|;
name|kcopy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|src
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dst
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Zero a page of physical memory by temporarily mapping it into the tlb.  */
end_comment

begin_function
name|void
name|pmap_zero_page
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|vm_offset_t
name|pa
init|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|caddr_t
name|va
decl_stmt|;
if|if
condition|(
name|pa
operator|<
name|SEGMENT_LENGTH
condition|)
block|{
name|va
operator|=
operator|(
name|caddr_t
operator|)
name|pa
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pmap_initialized
condition|)
block|{
if|if
condition|(
name|pmap_pvo_zeropage
operator|==
name|NULL
condition|)
name|pmap_pvo_zeropage
operator|=
name|pmap_rkva_alloc
argument_list|()
expr_stmt|;
name|pmap_pa_map
argument_list|(
name|pmap_pvo_zeropage
argument_list|,
name|pa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|va
operator|=
operator|(
name|caddr_t
operator|)
name|PVO_VADDR
argument_list|(
name|pmap_pvo_zeropage
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|panic
argument_list|(
literal|"pmap_zero_page: can't zero pa %#x"
argument_list|,
name|pa
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
name|va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa
operator|>=
name|SEGMENT_LENGTH
condition|)
name|pmap_pa_unmap
argument_list|(
name|pmap_pvo_zeropage
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_zero_page_area
parameter_list|(
name|vm_page_t
name|m
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|vm_offset_t
name|pa
init|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|caddr_t
name|va
decl_stmt|;
if|if
condition|(
name|pa
operator|<
name|SEGMENT_LENGTH
condition|)
block|{
name|va
operator|=
operator|(
name|caddr_t
operator|)
name|pa
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pmap_initialized
condition|)
block|{
if|if
condition|(
name|pmap_pvo_zeropage
operator|==
name|NULL
condition|)
name|pmap_pvo_zeropage
operator|=
name|pmap_rkva_alloc
argument_list|()
expr_stmt|;
name|pmap_pa_map
argument_list|(
name|pmap_pvo_zeropage
argument_list|,
name|pa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|va
operator|=
operator|(
name|caddr_t
operator|)
name|PVO_VADDR
argument_list|(
name|pmap_pvo_zeropage
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|panic
argument_list|(
literal|"pmap_zero_page: can't zero pa %#x"
argument_list|,
name|pa
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
name|va
operator|+
name|off
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa
operator|>=
name|SEGMENT_LENGTH
condition|)
name|pmap_pa_unmap
argument_list|(
name|pmap_pvo_zeropage
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_zero_page_idle
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
comment|/* XXX this is called outside of Giant, is pmap_zero_page safe? */
comment|/* XXX maybe have a dedicated mapping for this to avoid the problem? */
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|pmap_zero_page
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Map the given physical page at the specified virtual address in the  * target pmap with the protection requested.  If specified the page  * will be wired down.  */
end_comment

begin_function
name|void
name|pmap_enter
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|boolean_t
name|wired
parameter_list|)
block|{
name|struct
name|pvo_head
modifier|*
name|pvo_head
decl_stmt|;
name|uma_zone_t
name|zone
decl_stmt|;
name|vm_page_t
name|pg
decl_stmt|;
name|u_int
name|pte_lo
decl_stmt|,
name|pvo_flags
decl_stmt|,
name|was_exec
decl_stmt|,
name|i
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|!
name|pmap_initialized
condition|)
block|{
name|pvo_head
operator|=
operator|&
name|pmap_pvo_kunmanaged
expr_stmt|;
name|zone
operator|=
name|pmap_upvo_zone
expr_stmt|;
name|pvo_flags
operator|=
literal|0
expr_stmt|;
name|pg
operator|=
name|NULL
expr_stmt|;
name|was_exec
operator|=
name|PTE_EXEC
expr_stmt|;
block|}
else|else
block|{
name|pvo_head
operator|=
name|vm_page_to_pvoh
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|pg
operator|=
name|m
expr_stmt|;
name|zone
operator|=
name|pmap_mpvo_zone
expr_stmt|;
name|pvo_flags
operator|=
name|PVO_MANAGED
expr_stmt|;
name|was_exec
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * If this is a managed page, and it's the first reference to the page, 	 * clear the execness of the page.  Otherwise fetch the execness. 	 */
if|if
condition|(
name|pg
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|LIST_EMPTY
argument_list|(
name|pvo_head
argument_list|)
condition|)
block|{
name|pmap_attr_clear
argument_list|(
name|pg
argument_list|,
name|PTE_EXEC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|was_exec
operator|=
name|pmap_attr_fetch
argument_list|(
name|pg
argument_list|)
operator|&
name|PTE_EXEC
expr_stmt|;
block|}
block|}
comment|/* 	 * Assume the page is cache inhibited and access is guarded unless 	 * it's in our available memory array. 	 */
name|pte_lo
operator|=
name|PTE_I
operator||
name|PTE_G
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pregions_sz
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
operator|>=
name|pregions
index|[
name|i
index|]
operator|.
name|mr_start
operator|)
operator|&&
operator|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
operator|<
operator|(
name|pregions
index|[
name|i
index|]
operator|.
name|mr_start
operator|+
name|pregions
index|[
name|i
index|]
operator|.
name|mr_size
operator|)
operator|)
condition|)
block|{
name|pte_lo
operator|&=
operator|~
operator|(
name|PTE_I
operator||
name|PTE_G
operator|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|prot
operator|&
name|VM_PROT_WRITE
condition|)
name|pte_lo
operator||=
name|PTE_BW
expr_stmt|;
else|else
name|pte_lo
operator||=
name|PTE_BR
expr_stmt|;
name|pvo_flags
operator||=
operator|(
name|prot
operator|&
name|VM_PROT_EXECUTE
operator|)
expr_stmt|;
if|if
condition|(
name|wired
condition|)
name|pvo_flags
operator||=
name|PVO_WIRED
expr_stmt|;
name|error
operator|=
name|pmap_pvo_enter
argument_list|(
name|pmap
argument_list|,
name|zone
argument_list|,
name|pvo_head
argument_list|,
name|va
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|,
name|pte_lo
argument_list|,
name|pvo_flags
argument_list|)
expr_stmt|;
comment|/* 	 * Flush the real page from the instruction cache if this page is 	 * mapped executable and cacheable and was not previously mapped (or 	 * was not mapped executable). 	 */
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|(
name|pvo_flags
operator|&
name|PVO_EXECUTABLE
operator|)
operator|&&
operator|(
name|pte_lo
operator|&
name|PTE_I
operator|)
operator|==
literal|0
operator|&&
name|was_exec
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Flush the real memory from the cache. 		 */
name|pmap_syncicache
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pg
operator|!=
name|NULL
condition|)
name|pmap_attr_save
argument_list|(
name|pg
argument_list|,
name|PTE_EXEC
argument_list|)
expr_stmt|;
block|}
comment|/* XXX syncicache always until problems are sorted */
name|pmap_syncicache
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|vm_page_t
name|pmap_enter_quick
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_page_t
name|mpte
parameter_list|)
block|{
name|pmap_enter
argument_list|(
name|pm
argument_list|,
name|va
argument_list|,
name|m
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_EXECUTE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|vm_offset_t
name|pmap_extract
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|struct
name|pvo_entry
modifier|*
name|pvo
decl_stmt|;
name|pvo
operator|=
name|pmap_pvo_find_va
argument_list|(
name|pm
argument_list|,
name|va
operator|&
operator|~
name|ADDR_POFF
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvo
operator|!=
name|NULL
condition|)
block|{
return|return
operator|(
operator|(
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte_lo
operator|&
name|PTE_RPGN
operator|)
operator||
operator|(
name|va
operator|&
name|ADDR_POFF
operator|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Grow the number of kernel page table entries.  Unneeded.  */
end_comment

begin_function
name|void
name|pmap_growkernel
parameter_list|(
name|vm_offset_t
name|addr
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|pmap_init
parameter_list|(
name|vm_offset_t
name|phys_start
parameter_list|,
name|vm_offset_t
name|phys_end
parameter_list|)
block|{
name|CTR0
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_init"
argument_list|)
expr_stmt|;
name|pmap_upvo_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"UPVO entry"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pvo_entry
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
name|UMA_ZONE_VM
argument_list|)
expr_stmt|;
name|uma_zone_set_allocf
argument_list|(
name|pmap_upvo_zone
argument_list|,
name|pmap_pvo_allocf
argument_list|)
expr_stmt|;
name|pmap_mpvo_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"MPVO entry"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pvo_entry
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
name|UMA_ZONE_VM
argument_list|)
expr_stmt|;
name|uma_zone_set_allocf
argument_list|(
name|pmap_mpvo_zone
argument_list|,
name|pmap_pvo_allocf
argument_list|)
expr_stmt|;
name|pmap_initialized
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_init2
parameter_list|(
name|void
parameter_list|)
block|{
name|CTR0
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_init2"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|boolean_t
name|pmap_is_modified
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
operator|(
name|PG_FICTITIOUS
operator||
name|PG_UNMANAGED
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|pmap_query_bit
argument_list|(
name|m
argument_list|,
name|PTE_CHG
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pmap_clear_reference
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
operator|(
name|PG_FICTITIOUS
operator||
name|PG_UNMANAGED
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return;
name|pmap_clear_bit
argument_list|(
name|m
argument_list|,
name|PTE_REF
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_clear_modify
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
operator|(
name|PG_FICTITIOUS
operator||
name|PG_UNMANAGED
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return;
name|pmap_clear_bit
argument_list|(
name|m
argument_list|,
name|PTE_CHG
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	pmap_ts_referenced:  *  *	Return a count of reference bits for a page, clearing those bits.  *	It is not necessary for every reference bit to be cleared, but it  *	is necessary that 0 only be returned when there are truly no  *	reference bits set.  *  *	XXX: The exact number of bits to check and clear is a matter that  *	should be tested and standardized at some point in the future for  *	optimal aging of shared pages.  */
end_comment

begin_function
name|int
name|pmap_ts_referenced
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|int
name|count
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
operator|(
name|PG_FICTITIOUS
operator||
name|PG_UNMANAGED
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|count
operator|=
name|pmap_clear_bit
argument_list|(
name|m
argument_list|,
name|PTE_REF
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Map a wired page into kernel virtual address space.  */
end_comment

begin_function
name|void
name|pmap_kenter
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_offset_t
name|pa
parameter_list|)
block|{
name|u_int
name|pte_lo
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|i
decl_stmt|;
if|#
directive|if
literal|0
block|if (va< VM_MIN_KERNEL_ADDRESS) 		panic("pmap_kenter: attempt to enter non-kernel address %#x", 		    va);
endif|#
directive|endif
name|pte_lo
operator|=
name|PTE_I
operator||
name|PTE_G
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pregions_sz
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|pa
operator|>=
name|pregions
index|[
name|i
index|]
operator|.
name|mr_start
operator|)
operator|&&
operator|(
name|pa
operator|<
operator|(
name|pregions
index|[
name|i
index|]
operator|.
name|mr_start
operator|+
name|pregions
index|[
name|i
index|]
operator|.
name|mr_size
operator|)
operator|)
condition|)
block|{
name|pte_lo
operator|&=
operator|~
operator|(
name|PTE_I
operator||
name|PTE_G
operator|)
expr_stmt|;
break|break;
block|}
block|}
name|error
operator|=
name|pmap_pvo_enter
argument_list|(
name|kernel_pmap
argument_list|,
name|pmap_upvo_zone
argument_list|,
operator|&
name|pmap_pvo_kunmanaged
argument_list|,
name|va
argument_list|,
name|pa
argument_list|,
name|pte_lo
argument_list|,
name|PVO_WIRED
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|ENOENT
condition|)
name|panic
argument_list|(
literal|"pmap_kenter: failed to enter va %#x pa %#x: %d"
argument_list|,
name|va
argument_list|,
name|pa
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* 	 * Flush the real memory from the instruction cache. 	 */
if|if
condition|(
operator|(
name|pte_lo
operator|&
operator|(
name|PTE_I
operator||
name|PTE_G
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|pmap_syncicache
argument_list|(
name|pa
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Extract the physical page address associated with the given kernel virtual  * address.  */
end_comment

begin_function
name|vm_offset_t
name|pmap_kextract
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
name|struct
name|pvo_entry
modifier|*
name|pvo
decl_stmt|;
name|pvo
operator|=
name|pmap_pvo_find_va
argument_list|(
name|kernel_pmap
argument_list|,
name|va
operator|&
operator|~
name|ADDR_POFF
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvo
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|(
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte_lo
operator|&
name|PTE_RPGN
operator|)
operator||
operator|(
name|va
operator|&
name|ADDR_POFF
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove a wired page from kernel virtual address space.  */
end_comment

begin_function
name|void
name|pmap_kremove
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
name|pmap_remove
argument_list|(
name|kernel_pmap
argument_list|,
name|va
argument_list|,
name|va
operator|+
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Map a range of physical addresses into kernel virtual address space.  *  * The value passed in *virt is a suggested virtual address for the mapping.  * Architectures which can support a direct-mapped physical to virtual region  * can return the appropriate address within that region, leaving '*virt'  * unchanged.  We cannot and therefore do not; *virt is updated with the  * first usable address after the mapped region.  */
end_comment

begin_function
name|vm_offset_t
name|pmap_map
parameter_list|(
name|vm_offset_t
modifier|*
name|virt
parameter_list|,
name|vm_offset_t
name|pa_start
parameter_list|,
name|vm_offset_t
name|pa_end
parameter_list|,
name|int
name|prot
parameter_list|)
block|{
name|vm_offset_t
name|sva
decl_stmt|,
name|va
decl_stmt|;
name|sva
operator|=
operator|*
name|virt
expr_stmt|;
name|va
operator|=
name|sva
expr_stmt|;
for|for
control|(
init|;
name|pa_start
operator|<
name|pa_end
condition|;
name|pa_start
operator|+=
name|PAGE_SIZE
operator|,
name|va
operator|+=
name|PAGE_SIZE
control|)
name|pmap_kenter
argument_list|(
name|va
argument_list|,
name|pa_start
argument_list|)
expr_stmt|;
operator|*
name|virt
operator|=
name|va
expr_stmt|;
return|return
operator|(
name|sva
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pmap_mincore
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|)
block|{
name|TODO
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pmap_object_init_pt
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|,
name|vm_object_t
name|object
parameter_list|,
name|vm_pindex_t
name|pindex
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
name|VM_OBJECT_LOCK_ASSERT
argument_list|(
name|object
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|object
operator|->
name|type
operator|==
name|OBJT_DEVICE
argument_list|,
operator|(
literal|"pmap_object_init_pt: non-device object"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pm
operator|==
operator|&
name|curproc
operator|->
name|p_vmspace
operator|->
name|vm_pmap
operator|||
name|pm
operator|==
name|kernel_pmap
argument_list|,
operator|(
literal|"pmap_object_init_pt: non current pmap"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Lower the permission for all mappings to a given page.  */
end_comment

begin_function
name|void
name|pmap_page_protect
parameter_list|(
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|struct
name|pvo_head
modifier|*
name|pvo_head
decl_stmt|;
name|struct
name|pvo_entry
modifier|*
name|pvo
decl_stmt|,
modifier|*
name|next_pvo
decl_stmt|;
name|struct
name|pte
modifier|*
name|pt
decl_stmt|;
comment|/* 	 * Since the routine only downgrades protection, if the 	 * maximal protection is desired, there isn't any change 	 * to be made. 	 */
if|if
condition|(
operator|(
name|prot
operator|&
operator|(
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
operator|)
operator|)
operator|==
operator|(
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
operator|)
condition|)
return|return;
name|pvo_head
operator|=
name|vm_page_to_pvoh
argument_list|(
name|m
argument_list|)
expr_stmt|;
for|for
control|(
name|pvo
operator|=
name|LIST_FIRST
argument_list|(
name|pvo_head
argument_list|)
init|;
name|pvo
operator|!=
name|NULL
condition|;
name|pvo
operator|=
name|next_pvo
control|)
block|{
name|next_pvo
operator|=
name|LIST_NEXT
argument_list|(
name|pvo
argument_list|,
name|pvo_vlink
argument_list|)
expr_stmt|;
name|PMAP_PVO_CHECK
argument_list|(
name|pvo
argument_list|)
expr_stmt|;
comment|/* sanity check */
comment|/* 		 * Downgrading to no mapping at all, we just remove the entry. 		 */
if|if
condition|(
operator|(
name|prot
operator|&
name|VM_PROT_READ
operator|)
operator|==
literal|0
condition|)
block|{
name|pmap_pvo_remove
argument_list|(
name|pvo
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * If EXEC permission is being revoked, just clear the flag 		 * in the PVO. 		 */
if|if
condition|(
operator|(
name|prot
operator|&
name|VM_PROT_EXECUTE
operator|)
operator|==
literal|0
condition|)
name|pvo
operator|->
name|pvo_vaddr
operator|&=
operator|~
name|PVO_EXECUTABLE
expr_stmt|;
comment|/* 		 * If this entry is already RO, don't diddle with the page 		 * table. 		 */
if|if
condition|(
operator|(
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte_lo
operator|&
name|PTE_PP
operator|)
operator|==
name|PTE_BR
condition|)
block|{
name|PMAP_PVO_CHECK
argument_list|(
name|pvo
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Grab the PTE before we diddle the bits so pvo_to_pte can 		 * verify the pte contents are as expected. 		 */
name|pt
operator|=
name|pmap_pvo_to_pte
argument_list|(
name|pvo
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte_lo
operator|&=
operator|~
name|PTE_PP
expr_stmt|;
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte_lo
operator||=
name|PTE_BR
expr_stmt|;
if|if
condition|(
name|pt
operator|!=
name|NULL
condition|)
name|pmap_pte_change
argument_list|(
name|pt
argument_list|,
operator|&
name|pvo
operator|->
name|pvo_pte
argument_list|,
name|pvo
operator|->
name|pvo_vaddr
argument_list|)
expr_stmt|;
name|PMAP_PVO_CHECK
argument_list|(
name|pvo
argument_list|)
expr_stmt|;
comment|/* sanity check */
block|}
block|}
end_function

begin_comment
comment|/*  * Returns true if the pmap's pv is one of the first  * 16 pvs linked to from this page.  This count may  * be changed upwards or downwards in the future; it  * is only necessary that true be returned for a small  * subset of pmaps for proper page aging.  */
end_comment

begin_function
name|boolean_t
name|pmap_page_exists_quick
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|int
name|loops
decl_stmt|;
name|struct
name|pvo_entry
modifier|*
name|pvo
decl_stmt|;
if|if
condition|(
operator|!
name|pmap_initialized
operator|||
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
condition|)
return|return
name|FALSE
return|;
name|loops
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|pvo
argument_list|,
argument|vm_page_to_pvoh(m)
argument_list|,
argument|pvo_vlink
argument_list|)
block|{
if|if
condition|(
name|pvo
operator|->
name|pvo_pmap
operator|==
name|pmap
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
if|if
condition|(
operator|++
name|loops
operator|>=
literal|16
condition|)
break|break;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|u_int
name|pmap_vsidcontext
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|pmap_pinit
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|mask
decl_stmt|;
name|u_int
name|entropy
decl_stmt|;
name|entropy
operator|=
literal|0
expr_stmt|;
asm|__asm __volatile("mftb %0" : "=r"(entropy));
comment|/* 	 * Allocate some segment registers for this pmap. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NPMAPS
condition|;
name|i
operator|+=
name|VSID_NBPW
control|)
block|{
name|u_int
name|hash
decl_stmt|,
name|n
decl_stmt|;
comment|/* 		 * Create a new value by mutiplying by a prime and adding in 		 * entropy from the timebase register.  This is to make the 		 * VSID more random so that the PT hash function collides 		 * less often.  (Note that the prime casues gcc to do shifts 		 * instead of a multiply.) 		 */
name|pmap_vsidcontext
operator|=
operator|(
name|pmap_vsidcontext
operator|*
literal|0x1105
operator|)
operator|+
name|entropy
expr_stmt|;
name|hash
operator|=
name|pmap_vsidcontext
operator|&
operator|(
name|NPMAPS
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|hash
operator|==
literal|0
condition|)
comment|/* 0 is special, avoid it */
continue|continue;
name|n
operator|=
name|hash
operator|>>
literal|5
expr_stmt|;
name|mask
operator|=
literal|1
operator|<<
operator|(
name|hash
operator|&
operator|(
name|VSID_NBPW
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|hash
operator|=
operator|(
name|pmap_vsidcontext
operator|&
literal|0xfffff
operator|)
expr_stmt|;
if|if
condition|(
name|pmap_vsid_bitmap
index|[
name|n
index|]
operator|&
name|mask
condition|)
block|{
comment|/* collision? */
comment|/* anything free in this bucket? */
if|if
condition|(
name|pmap_vsid_bitmap
index|[
name|n
index|]
operator|==
literal|0xffffffff
condition|)
block|{
name|entropy
operator|=
operator|(
name|pmap_vsidcontext
operator|>>
literal|20
operator|)
expr_stmt|;
continue|continue;
block|}
name|i
operator|=
name|ffs
argument_list|(
operator|~
name|pmap_vsid_bitmap
index|[
name|i
index|]
argument_list|)
operator|-
literal|1
expr_stmt|;
name|mask
operator|=
literal|1
operator|<<
name|i
expr_stmt|;
name|hash
operator|&=
literal|0xfffff
operator|&
operator|~
operator|(
name|VSID_NBPW
operator|-
literal|1
operator|)
expr_stmt|;
name|hash
operator||=
name|i
expr_stmt|;
block|}
name|pmap_vsid_bitmap
index|[
name|n
index|]
operator||=
name|mask
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|pmap
operator|->
name|pm_sr
index|[
name|i
index|]
operator|=
name|VSID_MAKE
argument_list|(
name|i
argument_list|,
name|hash
argument_list|)
expr_stmt|;
return|return;
block|}
name|panic
argument_list|(
literal|"pmap_pinit: out of segments"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize the pmap associated with process 0.  */
end_comment

begin_function
name|void
name|pmap_pinit0
parameter_list|(
name|pmap_t
name|pm
parameter_list|)
block|{
name|pmap_pinit
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|pm
operator|->
name|pm_stats
argument_list|,
sizeof|sizeof
argument_list|(
name|pm
operator|->
name|pm_stats
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_pinit2
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
comment|/* XXX: Remove this stub when no longer called */
block|}
end_function

begin_function
name|void
name|pmap_prefault
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_map_entry_t
name|entry
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|pm
operator|==
operator|&
name|curproc
operator|->
name|p_vmspace
operator|->
name|vm_pmap
operator|||
name|pm
operator|==
name|kernel_pmap
argument_list|,
operator|(
literal|"pmap_prefault: non current pmap"
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX */
block|}
end_function

begin_comment
comment|/*  * Set the physical protection on the specified range of this map as requested.  */
end_comment

begin_function
name|void
name|pmap_protect
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|,
name|vm_offset_t
name|eva
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|struct
name|pvo_entry
modifier|*
name|pvo
decl_stmt|;
name|struct
name|pte
modifier|*
name|pt
decl_stmt|;
name|int
name|pteidx
decl_stmt|;
name|CTR4
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_protect: pm=%p sva=%#x eva=%#x prot=%#x"
argument_list|,
name|pm
argument_list|,
name|sva
argument_list|,
name|eva
argument_list|,
name|prot
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pm
operator|==
operator|&
name|curproc
operator|->
name|p_vmspace
operator|->
name|vm_pmap
operator|||
name|pm
operator|==
name|kernel_pmap
argument_list|,
operator|(
literal|"pmap_protect: non current pmap"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|prot
operator|&
name|VM_PROT_READ
operator|)
operator|==
name|VM_PROT_NONE
condition|)
block|{
name|pmap_remove
argument_list|(
name|pm
argument_list|,
name|sva
argument_list|,
name|eva
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
init|;
name|sva
operator|<
name|eva
condition|;
name|sva
operator|+=
name|PAGE_SIZE
control|)
block|{
name|pvo
operator|=
name|pmap_pvo_find_va
argument_list|(
name|pm
argument_list|,
name|sva
argument_list|,
operator|&
name|pteidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvo
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
name|prot
operator|&
name|VM_PROT_EXECUTE
operator|)
operator|==
literal|0
condition|)
name|pvo
operator|->
name|pvo_vaddr
operator|&=
operator|~
name|PVO_EXECUTABLE
expr_stmt|;
comment|/* 		 * Grab the PTE pointer before we diddle with the cached PTE 		 * copy. 		 */
name|pt
operator|=
name|pmap_pvo_to_pte
argument_list|(
name|pvo
argument_list|,
name|pteidx
argument_list|)
expr_stmt|;
comment|/* 		 * Change the protection of the page. 		 */
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte_lo
operator|&=
operator|~
name|PTE_PP
expr_stmt|;
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte_lo
operator||=
name|PTE_BR
expr_stmt|;
comment|/* 		 * If the PVO is in the page table, update that pte as well. 		 */
if|if
condition|(
name|pt
operator|!=
name|NULL
condition|)
name|pmap_pte_change
argument_list|(
name|pt
argument_list|,
operator|&
name|pvo
operator|->
name|pvo_pte
argument_list|,
name|pvo
operator|->
name|pvo_vaddr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Map a list of wired pages into kernel virtual address space.  This is  * intended for temporary mappings which do not need page modification or  * references recorded.  Existing mappings in the region are overwritten.  */
end_comment

begin_function
name|void
name|pmap_qenter
parameter_list|(
name|vm_offset_t
name|sva
parameter_list|,
name|vm_page_t
modifier|*
name|m
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|vm_offset_t
name|va
decl_stmt|;
name|va
operator|=
name|sva
expr_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
name|pmap_kenter
argument_list|(
name|va
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
operator|*
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|va
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|m
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Remove page mappings from kernel virtual address space.  Intended for  * temporary mappings entered by pmap_qenter.  */
end_comment

begin_function
name|void
name|pmap_qremove
parameter_list|(
name|vm_offset_t
name|sva
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|vm_offset_t
name|va
decl_stmt|;
name|va
operator|=
name|sva
expr_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
name|pmap_kremove
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|va
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|pmap_release
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
name|int
name|idx
decl_stmt|,
name|mask
decl_stmt|;
comment|/* 	 * Free segment register's VSID 	 */
if|if
condition|(
name|pmap
operator|->
name|pm_sr
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"pmap_release"
argument_list|)
expr_stmt|;
name|idx
operator|=
name|VSID_TO_HASH
argument_list|(
name|pmap
operator|->
name|pm_sr
index|[
literal|0
index|]
argument_list|)
operator|&
operator|(
name|NPMAPS
operator|-
literal|1
operator|)
expr_stmt|;
name|mask
operator|=
literal|1
operator|<<
operator|(
name|idx
operator|%
name|VSID_NBPW
operator|)
expr_stmt|;
name|idx
operator|/=
name|VSID_NBPW
expr_stmt|;
name|pmap_vsid_bitmap
index|[
name|idx
index|]
operator|&=
operator|~
name|mask
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove the given range of addresses from the specified map.  */
end_comment

begin_function
name|void
name|pmap_remove
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|,
name|vm_offset_t
name|eva
parameter_list|)
block|{
name|struct
name|pvo_entry
modifier|*
name|pvo
decl_stmt|;
name|int
name|pteidx
decl_stmt|;
for|for
control|(
init|;
name|sva
operator|<
name|eva
condition|;
name|sva
operator|+=
name|PAGE_SIZE
control|)
block|{
name|pvo
operator|=
name|pmap_pvo_find_va
argument_list|(
name|pm
argument_list|,
name|sva
argument_list|,
operator|&
name|pteidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvo
operator|!=
name|NULL
condition|)
block|{
name|pmap_pvo_remove
argument_list|(
name|pvo
argument_list|,
name|pteidx
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Remove physical page from all pmaps in which it resides. pmap_pvo_remove()  * will reflect changes in pte's back to the vm_page.  */
end_comment

begin_function
name|void
name|pmap_remove_all
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|struct
name|pvo_head
modifier|*
name|pvo_head
decl_stmt|;
name|struct
name|pvo_entry
modifier|*
name|pvo
decl_stmt|,
modifier|*
name|next_pvo
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|flags
operator|&
operator|(
name|PG_FICTITIOUS
operator||
name|PG_UNMANAGED
operator|)
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pv_remove_all: illegal for unmanaged page %#x"
operator|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|pvo_head
operator|=
name|vm_page_to_pvoh
argument_list|(
name|m
argument_list|)
expr_stmt|;
for|for
control|(
name|pvo
operator|=
name|LIST_FIRST
argument_list|(
name|pvo_head
argument_list|)
init|;
name|pvo
operator|!=
name|NULL
condition|;
name|pvo
operator|=
name|next_pvo
control|)
block|{
name|next_pvo
operator|=
name|LIST_NEXT
argument_list|(
name|pvo
argument_list|,
name|pvo_vlink
argument_list|)
expr_stmt|;
name|PMAP_PVO_CHECK
argument_list|(
name|pvo
argument_list|)
expr_stmt|;
comment|/* sanity check */
name|pmap_pvo_remove
argument_list|(
name|pvo
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|vm_page_flag_clear
argument_list|(
name|m
argument_list|,
name|PG_WRITEABLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove all pages from specified address space, this aids process exit  * speeds.  This is much faster than pmap_remove in the case of running down  * an entire address space.  Only works for the current pmap.  */
end_comment

begin_function
name|void
name|pmap_remove_pages
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|,
name|vm_offset_t
name|eva
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|pm
operator|==
operator|&
name|curproc
operator|->
name|p_vmspace
operator|->
name|vm_pmap
operator|||
name|pm
operator|==
name|kernel_pmap
argument_list|,
operator|(
literal|"pmap_remove_pages: non current pmap"
operator|)
argument_list|)
expr_stmt|;
name|pmap_remove
argument_list|(
name|pm
argument_list|,
name|sva
argument_list|,
name|eva
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a physical page of memory directly from the phys_avail map.  * Can only be called from pmap_bootstrap before avail start and end are  * calculated.  */
end_comment

begin_function
specifier|static
name|vm_offset_t
name|pmap_bootstrap_alloc
parameter_list|(
name|vm_size_t
name|size
parameter_list|,
name|u_int
name|align
parameter_list|)
block|{
name|vm_offset_t
name|s
decl_stmt|,
name|e
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|size
operator|=
name|round_page
argument_list|(
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
operator|!=
literal|0
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|align
operator|!=
literal|0
condition|)
name|s
operator|=
operator|(
name|phys_avail
index|[
name|i
index|]
operator|+
name|align
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|align
operator|-
literal|1
operator|)
expr_stmt|;
else|else
name|s
operator|=
name|phys_avail
index|[
name|i
index|]
expr_stmt|;
name|e
operator|=
name|s
operator|+
name|size
expr_stmt|;
if|if
condition|(
name|s
operator|<
name|phys_avail
index|[
name|i
index|]
operator|||
name|e
operator|>
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
condition|)
continue|continue;
if|if
condition|(
name|s
operator|==
name|phys_avail
index|[
name|i
index|]
condition|)
block|{
name|phys_avail
index|[
name|i
index|]
operator|+=
name|size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|e
operator|==
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
condition|)
block|{
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
operator|-=
name|size
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|j
operator|=
name|phys_avail_count
operator|*
literal|2
init|;
name|j
operator|>
name|i
condition|;
name|j
operator|-=
literal|2
control|)
block|{
name|phys_avail
index|[
name|j
index|]
operator|=
name|phys_avail
index|[
name|j
operator|-
literal|2
index|]
expr_stmt|;
name|phys_avail
index|[
name|j
operator|+
literal|1
index|]
operator|=
name|phys_avail
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|phys_avail
index|[
name|i
operator|+
literal|3
index|]
operator|=
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|s
expr_stmt|;
name|phys_avail
index|[
name|i
operator|+
literal|2
index|]
operator|=
name|e
expr_stmt|;
name|phys_avail_count
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|s
operator|)
return|;
block|}
name|panic
argument_list|(
literal|"pmap_bootstrap_alloc: could not allocate memory"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return an unmapped pvo for a kernel virtual address.  * Used by pmap functions that operate on physical pages.  */
end_comment

begin_function
specifier|static
name|struct
name|pvo_entry
modifier|*
name|pmap_rkva_alloc
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|pvo_entry
modifier|*
name|pvo
decl_stmt|;
name|struct
name|pte
modifier|*
name|pt
decl_stmt|;
name|vm_offset_t
name|kva
decl_stmt|;
name|int
name|pteidx
decl_stmt|;
if|if
condition|(
name|pmap_rkva_count
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"pmap_rkva_alloc: no more reserved KVAs"
argument_list|)
expr_stmt|;
name|kva
operator|=
name|pmap_rkva_start
operator|+
operator|(
name|PAGE_SIZE
operator|*
operator|--
name|pmap_rkva_count
operator|)
expr_stmt|;
name|pmap_kenter
argument_list|(
name|kva
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pvo
operator|=
name|pmap_pvo_find_va
argument_list|(
name|kernel_pmap
argument_list|,
name|kva
argument_list|,
operator|&
name|pteidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvo
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"pmap_kva_alloc: pmap_pvo_find_va failed"
argument_list|)
expr_stmt|;
name|pt
operator|=
name|pmap_pvo_to_pte
argument_list|(
name|pvo
argument_list|,
name|pteidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|pt
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"pmap_kva_alloc: pmap_pvo_to_pte failed"
argument_list|)
expr_stmt|;
name|pmap_pte_unset
argument_list|(
name|pt
argument_list|,
operator|&
name|pvo
operator|->
name|pvo_pte
argument_list|,
name|pvo
operator|->
name|pvo_vaddr
argument_list|)
expr_stmt|;
name|PVO_PTEGIDX_CLR
argument_list|(
name|pvo
argument_list|)
expr_stmt|;
name|pmap_pte_overflow
operator|++
expr_stmt|;
return|return
operator|(
name|pvo
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pmap_pa_map
parameter_list|(
name|struct
name|pvo_entry
modifier|*
name|pvo
parameter_list|,
name|vm_offset_t
name|pa
parameter_list|,
name|struct
name|pte
modifier|*
name|saved_pt
parameter_list|,
name|int
modifier|*
name|depth_p
parameter_list|)
block|{
name|struct
name|pte
modifier|*
name|pt
decl_stmt|;
comment|/* 	 * If this pvo already has a valid pte, we need to save it so it can 	 * be restored later.  We then just reload the new PTE over the old 	 * slot. 	 */
if|if
condition|(
name|saved_pt
operator|!=
name|NULL
condition|)
block|{
name|pt
operator|=
name|pmap_pvo_to_pte
argument_list|(
name|pvo
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pt
operator|!=
name|NULL
condition|)
block|{
name|pmap_pte_unset
argument_list|(
name|pt
argument_list|,
operator|&
name|pvo
operator|->
name|pvo_pte
argument_list|,
name|pvo
operator|->
name|pvo_vaddr
argument_list|)
expr_stmt|;
name|PVO_PTEGIDX_CLR
argument_list|(
name|pvo
argument_list|)
expr_stmt|;
name|pmap_pte_overflow
operator|++
expr_stmt|;
block|}
operator|*
name|saved_pt
operator|=
name|pvo
operator|->
name|pvo_pte
expr_stmt|;
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte_lo
operator|&=
operator|~
name|PTE_RPGN
expr_stmt|;
block|}
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte_lo
operator||=
name|pa
expr_stmt|;
if|if
condition|(
operator|!
name|pmap_pte_spill
argument_list|(
name|pvo
operator|->
name|pvo_vaddr
argument_list|)
condition|)
name|panic
argument_list|(
literal|"pmap_pa_map: could not spill pvo %p"
argument_list|,
name|pvo
argument_list|)
expr_stmt|;
if|if
condition|(
name|depth_p
operator|!=
name|NULL
condition|)
operator|(
operator|*
name|depth_p
operator|)
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pmap_pa_unmap
parameter_list|(
name|struct
name|pvo_entry
modifier|*
name|pvo
parameter_list|,
name|struct
name|pte
modifier|*
name|saved_pt
parameter_list|,
name|int
modifier|*
name|depth_p
parameter_list|)
block|{
name|struct
name|pte
modifier|*
name|pt
decl_stmt|;
name|pt
operator|=
name|pmap_pvo_to_pte
argument_list|(
name|pvo
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pt
operator|!=
name|NULL
condition|)
block|{
name|pmap_pte_unset
argument_list|(
name|pt
argument_list|,
operator|&
name|pvo
operator|->
name|pvo_pte
argument_list|,
name|pvo
operator|->
name|pvo_vaddr
argument_list|)
expr_stmt|;
name|PVO_PTEGIDX_CLR
argument_list|(
name|pvo
argument_list|)
expr_stmt|;
name|pmap_pte_overflow
operator|++
expr_stmt|;
block|}
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte_lo
operator|&=
operator|~
name|PTE_RPGN
expr_stmt|;
comment|/* 	 * If there is a saved PTE and it's valid, restore it and return. 	 */
if|if
condition|(
name|saved_pt
operator|!=
name|NULL
operator|&&
operator|(
name|saved_pt
operator|->
name|pte_lo
operator|&
name|PTE_RPGN
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|depth_p
operator|!=
name|NULL
operator|&&
operator|--
operator|(
operator|*
name|depth_p
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"pmap_pa_unmap: restoring but depth == 0"
argument_list|)
expr_stmt|;
name|pvo
operator|->
name|pvo_pte
operator|=
operator|*
name|saved_pt
expr_stmt|;
if|if
condition|(
operator|!
name|pmap_pte_spill
argument_list|(
name|pvo
operator|->
name|pvo_vaddr
argument_list|)
condition|)
name|panic
argument_list|(
literal|"pmap_pa_unmap: could not spill pvo %p"
argument_list|,
name|pvo
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pmap_syncicache
parameter_list|(
name|vm_offset_t
name|pa
parameter_list|,
name|vm_size_t
name|len
parameter_list|)
block|{
name|__syncicache
argument_list|(
operator|(
name|void
operator|*
operator|)
name|pa
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tlbia
parameter_list|(
name|void
parameter_list|)
block|{
name|caddr_t
name|i
decl_stmt|;
name|SYNC
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|caddr_t
operator|)
literal|0x00040000
condition|;
name|i
operator|+=
literal|0x00001000
control|)
block|{
name|TLBIE
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|EIEIO
argument_list|()
expr_stmt|;
block|}
name|TLBSYNC
argument_list|()
expr_stmt|;
name|SYNC
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pmap_pvo_enter
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|uma_zone_t
name|zone
parameter_list|,
name|struct
name|pvo_head
modifier|*
name|pvo_head
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_offset_t
name|pa
parameter_list|,
name|u_int
name|pte_lo
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|pvo_entry
modifier|*
name|pvo
decl_stmt|;
name|u_int
name|sr
decl_stmt|;
name|int
name|first
decl_stmt|;
name|u_int
name|ptegidx
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|bootstrap
decl_stmt|;
name|pmap_pvo_enter_calls
operator|++
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
name|bootstrap
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Compute the PTE Group index. 	 */
name|va
operator|&=
operator|~
name|ADDR_POFF
expr_stmt|;
name|sr
operator|=
name|va_to_sr
argument_list|(
name|pm
operator|->
name|pm_sr
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|ptegidx
operator|=
name|va_to_pteg
argument_list|(
name|sr
argument_list|,
name|va
argument_list|)
expr_stmt|;
comment|/* 	 * Remove any existing mapping for this page.  Reuse the pvo entry if 	 * there is a mapping. 	 */
name|LIST_FOREACH
argument_list|(
argument|pvo
argument_list|,
argument|&pmap_pvo_table[ptegidx]
argument_list|,
argument|pvo_olink
argument_list|)
block|{
if|if
condition|(
name|pvo
operator|->
name|pvo_pmap
operator|==
name|pm
operator|&&
name|PVO_VADDR
argument_list|(
name|pvo
argument_list|)
operator|==
name|va
condition|)
block|{
if|if
condition|(
operator|(
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte_lo
operator|&
name|PTE_RPGN
operator|)
operator|==
name|pa
operator|&&
operator|(
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte_lo
operator|&
name|PTE_PP
operator|)
operator|==
operator|(
name|pte_lo
operator|&
name|PTE_PP
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|pmap_pvo_remove
argument_list|(
name|pvo
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * If we aren't overwriting a mapping, try to allocate. 	 */
if|if
condition|(
name|pmap_initialized
condition|)
block|{
name|pvo
operator|=
name|uma_zalloc
argument_list|(
name|zone
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pmap_bpvo_pool_index
operator|>=
name|BPVO_POOL_SIZE
condition|)
block|{
name|panic
argument_list|(
literal|"pmap_enter: bpvo pool exhausted, %d, %d, %d"
argument_list|,
name|pmap_bpvo_pool_index
argument_list|,
name|BPVO_POOL_SIZE
argument_list|,
name|BPVO_POOL_SIZE
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pvo_entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pvo
operator|=
operator|&
name|pmap_bpvo_pool
index|[
name|pmap_bpvo_pool_index
index|]
expr_stmt|;
name|pmap_bpvo_pool_index
operator|++
expr_stmt|;
name|bootstrap
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|pvo
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|pmap_pvo_entries
operator|++
expr_stmt|;
name|pvo
operator|->
name|pvo_vaddr
operator|=
name|va
expr_stmt|;
name|pvo
operator|->
name|pvo_pmap
operator|=
name|pm
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|pmap_pvo_table
index|[
name|ptegidx
index|]
argument_list|,
name|pvo
argument_list|,
name|pvo_olink
argument_list|)
expr_stmt|;
name|pvo
operator|->
name|pvo_vaddr
operator|&=
operator|~
name|ADDR_POFF
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|VM_PROT_EXECUTE
condition|)
name|pvo
operator|->
name|pvo_vaddr
operator||=
name|PVO_EXECUTABLE
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|PVO_WIRED
condition|)
name|pvo
operator|->
name|pvo_vaddr
operator||=
name|PVO_WIRED
expr_stmt|;
if|if
condition|(
name|pvo_head
operator|!=
operator|&
name|pmap_pvo_kunmanaged
condition|)
name|pvo
operator|->
name|pvo_vaddr
operator||=
name|PVO_MANAGED
expr_stmt|;
if|if
condition|(
name|bootstrap
condition|)
name|pvo
operator|->
name|pvo_vaddr
operator||=
name|PVO_BOOTSTRAP
expr_stmt|;
name|pmap_pte_create
argument_list|(
operator|&
name|pvo
operator|->
name|pvo_pte
argument_list|,
name|sr
argument_list|,
name|va
argument_list|,
name|pa
operator||
name|pte_lo
argument_list|)
expr_stmt|;
comment|/* 	 * Remember if the list was empty and therefore will be the first 	 * item. 	 */
if|if
condition|(
name|LIST_FIRST
argument_list|(
name|pvo_head
argument_list|)
operator|==
name|NULL
condition|)
name|first
operator|=
literal|1
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|pvo_head
argument_list|,
name|pvo
argument_list|,
name|pvo_vlink
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte_lo
operator|&
name|PVO_WIRED
condition|)
name|pvo
operator|->
name|pvo_pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|++
expr_stmt|;
name|pvo
operator|->
name|pvo_pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|++
expr_stmt|;
comment|/* 	 * We hope this succeeds but it isn't required. 	 */
name|i
operator|=
name|pmap_pte_insert
argument_list|(
name|ptegidx
argument_list|,
operator|&
name|pvo
operator|->
name|pvo_pte
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|PVO_PTEGIDX_SET
argument_list|(
name|pvo
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|panic
argument_list|(
literal|"pmap_pvo_enter: overflow"
argument_list|)
expr_stmt|;
name|pmap_pte_overflow
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|first
condition|?
name|ENOENT
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pmap_pvo_remove
parameter_list|(
name|struct
name|pvo_entry
modifier|*
name|pvo
parameter_list|,
name|int
name|pteidx
parameter_list|)
block|{
name|struct
name|pte
modifier|*
name|pt
decl_stmt|;
comment|/* 	 * If there is an active pte entry, we need to deactivate it (and 	 * save the ref& cfg bits). 	 */
name|pt
operator|=
name|pmap_pvo_to_pte
argument_list|(
name|pvo
argument_list|,
name|pteidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|pt
operator|!=
name|NULL
condition|)
block|{
name|pmap_pte_unset
argument_list|(
name|pt
argument_list|,
operator|&
name|pvo
operator|->
name|pvo_pte
argument_list|,
name|pvo
operator|->
name|pvo_vaddr
argument_list|)
expr_stmt|;
name|PVO_PTEGIDX_CLR
argument_list|(
name|pvo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pmap_pte_overflow
operator|--
expr_stmt|;
block|}
comment|/* 	 * Update our statistics. 	 */
name|pvo
operator|->
name|pvo_pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|--
expr_stmt|;
if|if
condition|(
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte_lo
operator|&
name|PVO_WIRED
condition|)
name|pvo
operator|->
name|pvo_pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
comment|/* 	 * Save the REF/CHG bits into their cache if the page is managed. 	 */
if|if
condition|(
name|pvo
operator|->
name|pvo_vaddr
operator|&
name|PVO_MANAGED
condition|)
block|{
name|struct
name|vm_page
modifier|*
name|pg
decl_stmt|;
name|pg
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte_lo
operator|&
name|PTE_RPGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|pg
operator|!=
name|NULL
condition|)
block|{
name|pmap_attr_save
argument_list|(
name|pg
argument_list|,
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte_lo
operator|&
operator|(
name|PTE_REF
operator||
name|PTE_CHG
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Remove this PVO from the PV list. 	 */
name|LIST_REMOVE
argument_list|(
name|pvo
argument_list|,
name|pvo_vlink
argument_list|)
expr_stmt|;
comment|/* 	 * Remove this from the overflow list and return it to the pool 	 * if we aren't going to reuse it. 	 */
name|LIST_REMOVE
argument_list|(
name|pvo
argument_list|,
name|pvo_olink
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pvo
operator|->
name|pvo_vaddr
operator|&
name|PVO_BOOTSTRAP
operator|)
condition|)
name|uma_zfree
argument_list|(
name|pvo
operator|->
name|pvo_vaddr
operator|&
name|PVO_MANAGED
condition|?
name|pmap_mpvo_zone
else|:
name|pmap_upvo_zone
argument_list|,
name|pvo
argument_list|)
expr_stmt|;
name|pmap_pvo_entries
operator|--
expr_stmt|;
name|pmap_pvo_remove_calls
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|pmap_pvo_pte_index
parameter_list|(
specifier|const
name|struct
name|pvo_entry
modifier|*
name|pvo
parameter_list|,
name|int
name|ptegidx
parameter_list|)
block|{
name|int
name|pteidx
decl_stmt|;
comment|/* 	 * We can find the actual pte entry without searching by grabbing 	 * the PTEG index from 3 unused bits in pte_lo[11:9] and by 	 * noticing the HID bit. 	 */
name|pteidx
operator|=
name|ptegidx
operator|*
literal|8
operator|+
name|PVO_PTEGIDX_GET
argument_list|(
name|pvo
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte_hi
operator|&
name|PTE_HID
condition|)
name|pteidx
operator|^=
name|pmap_pteg_mask
operator|*
literal|8
expr_stmt|;
return|return
operator|(
name|pteidx
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|pvo_entry
modifier|*
name|pmap_pvo_find_va
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|int
modifier|*
name|pteidx_p
parameter_list|)
block|{
name|struct
name|pvo_entry
modifier|*
name|pvo
decl_stmt|;
name|int
name|ptegidx
decl_stmt|;
name|u_int
name|sr
decl_stmt|;
name|va
operator|&=
operator|~
name|ADDR_POFF
expr_stmt|;
name|sr
operator|=
name|va_to_sr
argument_list|(
name|pm
operator|->
name|pm_sr
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|ptegidx
operator|=
name|va_to_pteg
argument_list|(
name|sr
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|pvo
argument_list|,
argument|&pmap_pvo_table[ptegidx]
argument_list|,
argument|pvo_olink
argument_list|)
block|{
if|if
condition|(
name|pvo
operator|->
name|pvo_pmap
operator|==
name|pm
operator|&&
name|PVO_VADDR
argument_list|(
name|pvo
argument_list|)
operator|==
name|va
condition|)
block|{
if|if
condition|(
name|pteidx_p
condition|)
operator|*
name|pteidx_p
operator|=
name|pmap_pvo_pte_index
argument_list|(
name|pvo
argument_list|,
name|ptegidx
argument_list|)
expr_stmt|;
return|return
operator|(
name|pvo
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|pte
modifier|*
name|pmap_pvo_to_pte
parameter_list|(
specifier|const
name|struct
name|pvo_entry
modifier|*
name|pvo
parameter_list|,
name|int
name|pteidx
parameter_list|)
block|{
name|struct
name|pte
modifier|*
name|pt
decl_stmt|;
comment|/* 	 * If we haven't been supplied the ptegidx, calculate it. 	 */
if|if
condition|(
name|pteidx
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|ptegidx
decl_stmt|;
name|u_int
name|sr
decl_stmt|;
name|sr
operator|=
name|va_to_sr
argument_list|(
name|pvo
operator|->
name|pvo_pmap
operator|->
name|pm_sr
argument_list|,
name|pvo
operator|->
name|pvo_vaddr
argument_list|)
expr_stmt|;
name|ptegidx
operator|=
name|va_to_pteg
argument_list|(
name|sr
argument_list|,
name|pvo
operator|->
name|pvo_vaddr
argument_list|)
expr_stmt|;
name|pteidx
operator|=
name|pmap_pvo_pte_index
argument_list|(
name|pvo
argument_list|,
name|ptegidx
argument_list|)
expr_stmt|;
block|}
name|pt
operator|=
operator|&
name|pmap_pteg_table
index|[
name|pteidx
operator|>>
literal|3
index|]
operator|.
name|pt
index|[
name|pteidx
operator|&
literal|7
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte_hi
operator|&
name|PTE_VALID
operator|)
operator|&&
operator|!
name|PVO_PTEGIDX_ISSET
argument_list|(
name|pvo
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"pmap_pvo_to_pte: pvo %p has valid pte in pvo but no "
literal|"valid pte index"
argument_list|,
name|pvo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte_hi
operator|&
name|PTE_VALID
operator|)
operator|==
literal|0
operator|&&
name|PVO_PTEGIDX_ISSET
argument_list|(
name|pvo
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"pmap_pvo_to_pte: pvo %p has valid pte index in pvo "
literal|"pvo but no valid pte"
argument_list|,
name|pvo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pt
operator|->
name|pte_hi
operator|^
operator|(
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte_hi
operator|&
operator|~
name|PTE_VALID
operator|)
operator|)
operator|==
name|PTE_VALID
condition|)
block|{
if|if
condition|(
operator|(
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte_hi
operator|&
name|PTE_VALID
operator|)
operator|==
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"pmap_pvo_to_pte: pvo %p has valid pte in "
literal|"pmap_pteg_table %p but invalid in pvo"
argument_list|,
name|pvo
argument_list|,
name|pt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|pt
operator|->
name|pte_lo
operator|^
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte_lo
operator|)
operator|&
operator|~
operator|(
name|PTE_CHG
operator||
name|PTE_REF
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"pmap_pvo_to_pte: pvo %p pte does not match "
literal|"pte %p in pmap_pteg_table"
argument_list|,
name|pvo
argument_list|,
name|pt
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|pt
operator|)
return|;
block|}
if|if
condition|(
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte_hi
operator|&
name|PTE_VALID
condition|)
block|{
name|panic
argument_list|(
literal|"pmap_pvo_to_pte: pvo %p has invalid pte %p in "
literal|"pmap_pteg_table but valid in pvo"
argument_list|,
name|pvo
argument_list|,
name|pt
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|pmap_pvo_allocf
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|int
name|bytes
parameter_list|,
name|u_int8_t
modifier|*
name|flags
parameter_list|,
name|int
name|wait
parameter_list|)
block|{
specifier|static
name|vm_pindex_t
name|color
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
if|if
condition|(
name|bytes
operator|!=
name|PAGE_SIZE
condition|)
name|panic
argument_list|(
literal|"pmap_pvo_allocf: benno was shortsighted.  hit him."
argument_list|)
expr_stmt|;
operator|*
name|flags
operator|=
name|UMA_SLAB_PRIV
expr_stmt|;
comment|/* 	 * The color is only a hint.  Thus, a data race in the read- 	 * modify-write operation below isn't a catastrophe. 	 */
name|m
operator|=
name|vm_page_alloc
argument_list|(
name|NULL
argument_list|,
name|color
operator|++
argument_list|,
name|VM_ALLOC_NOOBJ
operator||
name|VM_ALLOC_SYSTEM
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
operator|(
name|void
operator|*
operator|)
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * XXX: THIS STUFF SHOULD BE IN pte.c?  */
end_comment

begin_function
name|int
name|pmap_pte_spill
parameter_list|(
name|vm_offset_t
name|addr
parameter_list|)
block|{
name|struct
name|pvo_entry
modifier|*
name|source_pvo
decl_stmt|,
modifier|*
name|victim_pvo
decl_stmt|;
name|struct
name|pvo_entry
modifier|*
name|pvo
decl_stmt|;
name|int
name|ptegidx
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|u_int
name|sr
decl_stmt|;
name|struct
name|pteg
modifier|*
name|pteg
decl_stmt|;
name|struct
name|pte
modifier|*
name|pt
decl_stmt|;
name|pmap_pte_spills
operator|++
expr_stmt|;
name|sr
operator|=
name|mfsrin
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|ptegidx
operator|=
name|va_to_pteg
argument_list|(
name|sr
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* 	 * Have to substitute some entry.  Use the primary hash for this. 	 * Use low bits of timebase as random generator. 	 */
name|pteg
operator|=
operator|&
name|pmap_pteg_table
index|[
name|ptegidx
index|]
expr_stmt|;
asm|__asm __volatile("mftb %0" : "=r"(i));
name|i
operator|&=
literal|7
expr_stmt|;
name|pt
operator|=
operator|&
name|pteg
operator|->
name|pt
index|[
name|i
index|]
expr_stmt|;
name|source_pvo
operator|=
name|NULL
expr_stmt|;
name|victim_pvo
operator|=
name|NULL
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|pvo
argument_list|,
argument|&pmap_pvo_table[ptegidx]
argument_list|,
argument|pvo_olink
argument_list|)
block|{
comment|/* 		 * We need to find a pvo entry for this address. 		 */
name|PMAP_PVO_CHECK
argument_list|(
name|pvo
argument_list|)
expr_stmt|;
if|if
condition|(
name|source_pvo
operator|==
name|NULL
operator|&&
name|pmap_pte_match
argument_list|(
operator|&
name|pvo
operator|->
name|pvo_pte
argument_list|,
name|sr
argument_list|,
name|addr
argument_list|,
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte_hi
operator|&
name|PTE_HID
argument_list|)
condition|)
block|{
comment|/* 			 * Now found an entry to be spilled into the pteg. 			 * The PTE is now valid, so we know it's active. 			 */
name|j
operator|=
name|pmap_pte_insert
argument_list|(
name|ptegidx
argument_list|,
operator|&
name|pvo
operator|->
name|pvo_pte
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|>=
literal|0
condition|)
block|{
name|PVO_PTEGIDX_SET
argument_list|(
name|pvo
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|pmap_pte_overflow
operator|--
expr_stmt|;
name|PMAP_PVO_CHECK
argument_list|(
name|pvo
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|source_pvo
operator|=
name|pvo
expr_stmt|;
if|if
condition|(
name|victim_pvo
operator|!=
name|NULL
condition|)
break|break;
block|}
comment|/* 		 * We also need the pvo entry of the victim we are replacing 		 * so save the R& C bits of the PTE. 		 */
if|if
condition|(
operator|(
name|pt
operator|->
name|pte_hi
operator|&
name|PTE_HID
operator|)
operator|==
literal|0
operator|&&
name|victim_pvo
operator|==
name|NULL
operator|&&
name|pmap_pte_compare
argument_list|(
name|pt
argument_list|,
operator|&
name|pvo
operator|->
name|pvo_pte
argument_list|)
condition|)
block|{
name|victim_pvo
operator|=
name|pvo
expr_stmt|;
if|if
condition|(
name|source_pvo
operator|!=
name|NULL
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|source_pvo
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|victim_pvo
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|pt
operator|->
name|pte_hi
operator|&
name|PTE_HID
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"pmap_pte_spill: victim p-pte (%p) has no pvo"
literal|"entry"
argument_list|,
name|pt
argument_list|)
expr_stmt|;
comment|/* 		 * If this is a secondary PTE, we need to search it's primary 		 * pvo bucket for the matching PVO. 		 */
name|LIST_FOREACH
argument_list|(
argument|pvo
argument_list|,
argument|&pmap_pvo_table[ptegidx ^ pmap_pteg_mask]
argument_list|,
argument|pvo_olink
argument_list|)
block|{
name|PMAP_PVO_CHECK
argument_list|(
name|pvo
argument_list|)
expr_stmt|;
comment|/* 			 * We also need the pvo entry of the victim we are 			 * replacing so save the R& C bits of the PTE. 			 */
if|if
condition|(
name|pmap_pte_compare
argument_list|(
name|pt
argument_list|,
operator|&
name|pvo
operator|->
name|pvo_pte
argument_list|)
condition|)
block|{
name|victim_pvo
operator|=
name|pvo
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|victim_pvo
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"pmap_pte_spill: victim s-pte (%p) has no pvo"
literal|"entry"
argument_list|,
name|pt
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We are invalidating the TLB entry for the EA we are replacing even 	 * though it's valid.  If we don't, we lose any ref/chg bit changes 	 * contained in the TLB entry. 	 */
name|source_pvo
operator|->
name|pvo_pte
operator|.
name|pte_hi
operator|&=
operator|~
name|PTE_HID
expr_stmt|;
name|pmap_pte_unset
argument_list|(
name|pt
argument_list|,
operator|&
name|victim_pvo
operator|->
name|pvo_pte
argument_list|,
name|victim_pvo
operator|->
name|pvo_vaddr
argument_list|)
expr_stmt|;
name|pmap_pte_set
argument_list|(
name|pt
argument_list|,
operator|&
name|source_pvo
operator|->
name|pvo_pte
argument_list|)
expr_stmt|;
name|PVO_PTEGIDX_CLR
argument_list|(
name|victim_pvo
argument_list|)
expr_stmt|;
name|PVO_PTEGIDX_SET
argument_list|(
name|source_pvo
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|pmap_pte_replacements
operator|++
expr_stmt|;
name|PMAP_PVO_CHECK
argument_list|(
name|victim_pvo
argument_list|)
expr_stmt|;
name|PMAP_PVO_CHECK
argument_list|(
name|source_pvo
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pmap_pte_insert
parameter_list|(
name|u_int
name|ptegidx
parameter_list|,
name|struct
name|pte
modifier|*
name|pvo_pt
parameter_list|)
block|{
name|struct
name|pte
modifier|*
name|pt
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * First try primary hash. 	 */
for|for
control|(
name|pt
operator|=
name|pmap_pteg_table
index|[
name|ptegidx
index|]
operator|.
name|pt
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
operator|,
name|pt
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|pt
operator|->
name|pte_hi
operator|&
name|PTE_VALID
operator|)
operator|==
literal|0
condition|)
block|{
name|pvo_pt
operator|->
name|pte_hi
operator|&=
operator|~
name|PTE_HID
expr_stmt|;
name|pmap_pte_set
argument_list|(
name|pt
argument_list|,
name|pvo_pt
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
block|}
comment|/* 	 * Now try secondary hash. 	 */
name|ptegidx
operator|^=
name|pmap_pteg_mask
expr_stmt|;
name|ptegidx
operator|++
expr_stmt|;
for|for
control|(
name|pt
operator|=
name|pmap_pteg_table
index|[
name|ptegidx
index|]
operator|.
name|pt
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
operator|,
name|pt
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|pt
operator|->
name|pte_hi
operator|&
name|PTE_VALID
operator|)
operator|==
literal|0
condition|)
block|{
name|pvo_pt
operator|->
name|pte_hi
operator||=
name|PTE_HID
expr_stmt|;
name|pmap_pte_set
argument_list|(
name|pt
argument_list|,
name|pvo_pt
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
block|}
name|panic
argument_list|(
literal|"pmap_pte_insert: overflow"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|pmap_query_bit
parameter_list|(
name|vm_page_t
name|m
parameter_list|,
name|int
name|ptebit
parameter_list|)
block|{
name|struct
name|pvo_entry
modifier|*
name|pvo
decl_stmt|;
name|struct
name|pte
modifier|*
name|pt
decl_stmt|;
if|if
condition|(
name|pmap_attr_fetch
argument_list|(
name|m
argument_list|)
operator|&
name|ptebit
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
name|LIST_FOREACH
argument_list|(
argument|pvo
argument_list|,
argument|vm_page_to_pvoh(m)
argument_list|,
argument|pvo_vlink
argument_list|)
block|{
name|PMAP_PVO_CHECK
argument_list|(
name|pvo
argument_list|)
expr_stmt|;
comment|/* sanity check */
comment|/* 		 * See if we saved the bit off.  If so, cache it and return 		 * success. 		 */
if|if
condition|(
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte_lo
operator|&
name|ptebit
condition|)
block|{
name|pmap_attr_save
argument_list|(
name|m
argument_list|,
name|ptebit
argument_list|)
expr_stmt|;
name|PMAP_PVO_CHECK
argument_list|(
name|pvo
argument_list|)
expr_stmt|;
comment|/* sanity check */
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
comment|/* 	 * No luck, now go through the hard part of looking at the PTEs 	 * themselves.  Sync so that any pending REF/CHG bits are flushed to 	 * the PTEs. 	 */
name|SYNC
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|pvo
argument_list|,
argument|vm_page_to_pvoh(m)
argument_list|,
argument|pvo_vlink
argument_list|)
block|{
name|PMAP_PVO_CHECK
argument_list|(
name|pvo
argument_list|)
expr_stmt|;
comment|/* sanity check */
comment|/* 		 * See if this pvo has a valid PTE.  if so, fetch the 		 * REF/CHG bits from the valid PTE.  If the appropriate 		 * ptebit is set, cache it and return success. 		 */
name|pt
operator|=
name|pmap_pvo_to_pte
argument_list|(
name|pvo
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pt
operator|!=
name|NULL
condition|)
block|{
name|pmap_pte_synch
argument_list|(
name|pt
argument_list|,
operator|&
name|pvo
operator|->
name|pvo_pte
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte_lo
operator|&
name|ptebit
condition|)
block|{
name|pmap_attr_save
argument_list|(
name|m
argument_list|,
name|ptebit
argument_list|)
expr_stmt|;
name|PMAP_PVO_CHECK
argument_list|(
name|pvo
argument_list|)
expr_stmt|;
comment|/* sanity check */
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|pmap_clear_bit
parameter_list|(
name|vm_page_t
name|m
parameter_list|,
name|int
name|ptebit
parameter_list|,
name|int
modifier|*
name|origbit
parameter_list|)
block|{
name|u_int
name|count
decl_stmt|;
name|struct
name|pvo_entry
modifier|*
name|pvo
decl_stmt|;
name|struct
name|pte
modifier|*
name|pt
decl_stmt|;
name|int
name|rv
decl_stmt|;
comment|/* 	 * Clear the cached value. 	 */
name|rv
operator|=
name|pmap_attr_fetch
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|pmap_attr_clear
argument_list|(
name|m
argument_list|,
name|ptebit
argument_list|)
expr_stmt|;
comment|/* 	 * Sync so that any pending REF/CHG bits are flushed to the PTEs (so 	 * we can reset the right ones).  note that since the pvo entries and 	 * list heads are accessed via BAT0 and are never placed in the page 	 * table, we don't have to worry about further accesses setting the 	 * REF/CHG bits. 	 */
name|SYNC
argument_list|()
expr_stmt|;
comment|/* 	 * For each pvo entry, clear the pvo's ptebit.  If this pvo has a 	 * valid pte clear the ptebit from the valid pte. 	 */
name|count
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|pvo
argument_list|,
argument|vm_page_to_pvoh(m)
argument_list|,
argument|pvo_vlink
argument_list|)
block|{
name|PMAP_PVO_CHECK
argument_list|(
name|pvo
argument_list|)
expr_stmt|;
comment|/* sanity check */
name|pt
operator|=
name|pmap_pvo_to_pte
argument_list|(
name|pvo
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pt
operator|!=
name|NULL
condition|)
block|{
name|pmap_pte_synch
argument_list|(
name|pt
argument_list|,
operator|&
name|pvo
operator|->
name|pvo_pte
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte_lo
operator|&
name|ptebit
condition|)
block|{
name|count
operator|++
expr_stmt|;
name|pmap_pte_clear
argument_list|(
name|pt
argument_list|,
name|PVO_VADDR
argument_list|(
name|pvo
argument_list|)
argument_list|,
name|ptebit
argument_list|)
expr_stmt|;
block|}
block|}
name|rv
operator||=
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte_lo
expr_stmt|;
name|pvo
operator|->
name|pvo_pte
operator|.
name|pte_lo
operator|&=
operator|~
name|ptebit
expr_stmt|;
name|PMAP_PVO_CHECK
argument_list|(
name|pvo
argument_list|)
expr_stmt|;
comment|/* sanity check */
block|}
if|if
condition|(
name|origbit
operator|!=
name|NULL
condition|)
block|{
operator|*
name|origbit
operator|=
name|rv
expr_stmt|;
block|}
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return true if the physical range is encompassed by the battable[idx]  */
end_comment

begin_function
specifier|static
name|int
name|pmap_bat_mapped
parameter_list|(
name|int
name|idx
parameter_list|,
name|vm_offset_t
name|pa
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
name|u_int
name|prot
decl_stmt|;
name|u_int32_t
name|start
decl_stmt|;
name|u_int32_t
name|end
decl_stmt|;
name|u_int32_t
name|bat_ble
decl_stmt|;
comment|/* 	 * Return immediately if not a valid mapping 	 */
if|if
condition|(
operator|!
name|battable
index|[
name|idx
index|]
operator|.
name|batu
operator|&
name|BAT_Vs
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * The BAT entry must be cache-inhibited, guarded, and r/w 	 * so it can function as an i/o page 	 */
name|prot
operator|=
name|battable
index|[
name|idx
index|]
operator|.
name|batl
operator|&
operator|(
name|BAT_I
operator||
name|BAT_G
operator||
name|BAT_PP_RW
operator|)
expr_stmt|;
if|if
condition|(
name|prot
operator|!=
operator|(
name|BAT_I
operator||
name|BAT_G
operator||
name|BAT_PP_RW
operator|)
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
comment|/* 	 * The address should be within the BAT range. Assume that the 	 * start address in the BAT has the correct alignment (thus 	 * not requiring masking) 	 */
name|start
operator|=
name|battable
index|[
name|idx
index|]
operator|.
name|batl
operator|&
name|BAT_PBS
expr_stmt|;
name|bat_ble
operator|=
operator|(
name|battable
index|[
name|idx
index|]
operator|.
name|batu
operator|&
operator|~
operator|(
name|BAT_EBS
operator|)
operator|)
operator||
literal|0x03
expr_stmt|;
name|end
operator|=
name|start
operator||
operator|(
name|bat_ble
operator|<<
literal|15
operator|)
operator||
literal|0x7fff
expr_stmt|;
if|if
condition|(
operator|(
name|pa
operator|<
name|start
operator|)
operator|||
operator|(
operator|(
name|pa
operator|+
name|size
operator|)
operator|>
name|end
operator|)
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Map a set of physical memory pages into the kernel virtual  * address space. Return a pointer to where it is mapped. This  * routine is intended to be used for mapping device memory,  * NOT real memory.  */
end_comment

begin_function
name|void
modifier|*
name|pmap_mapdev
parameter_list|(
name|vm_offset_t
name|pa
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
name|vm_offset_t
name|va
decl_stmt|,
name|tmpva
decl_stmt|,
name|ppa
decl_stmt|,
name|offset
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ppa
operator|=
name|trunc_page
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|offset
operator|=
name|pa
operator|&
name|PAGE_MASK
expr_stmt|;
name|size
operator|=
name|roundup
argument_list|(
name|offset
operator|+
name|size
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
comment|/* 	 * If the physical address lies within a valid BAT table entry, 	 * return the 1:1 mapping. This currently doesn't work 	 * for regions that overlap 256M BAT segments. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pmap_bat_mapped
argument_list|(
name|i
argument_list|,
name|pa
argument_list|,
name|size
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|(
name|void
operator|*
operator|)
name|pa
operator|)
return|;
block|}
name|va
operator|=
name|kmem_alloc_pageable
argument_list|(
name|kernel_map
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|va
condition|)
name|panic
argument_list|(
literal|"pmap_mapdev: Couldn't alloc kernel virtual memory"
argument_list|)
expr_stmt|;
for|for
control|(
name|tmpva
operator|=
name|va
init|;
name|size
operator|>
literal|0
condition|;
control|)
block|{
name|pmap_kenter
argument_list|(
name|tmpva
argument_list|,
name|ppa
argument_list|)
expr_stmt|;
name|TLBIE
argument_list|(
name|tmpva
argument_list|)
expr_stmt|;
comment|/* XXX or should it be invalidate-all ? */
name|size
operator|-=
name|PAGE_SIZE
expr_stmt|;
name|tmpva
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|ppa
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|void
operator|*
operator|)
operator|(
name|va
operator|+
name|offset
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pmap_unmapdev
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
name|vm_offset_t
name|base
decl_stmt|,
name|offset
decl_stmt|;
comment|/* 	 * If this is outside kernel virtual space, then it's a 	 * battable entry and doesn't require unmapping 	 */
if|if
condition|(
operator|(
name|va
operator|>=
name|VM_MIN_KERNEL_ADDRESS
operator|)
operator|&&
operator|(
name|va
operator|<=
name|VM_MAX_KERNEL_ADDRESS
operator|)
condition|)
block|{
name|base
operator|=
name|trunc_page
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|offset
operator|=
name|va
operator|&
name|PAGE_MASK
expr_stmt|;
name|size
operator|=
name|roundup
argument_list|(
name|offset
operator|+
name|size
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|kernel_map
argument_list|,
name|base
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

