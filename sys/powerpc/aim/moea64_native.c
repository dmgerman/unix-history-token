begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001 The NetBSD Foundation, Inc.  * All rights reserved.  *  * This code is derived from software contributed to The NetBSD Foundation  * by Matt Thomas<matt@3am-software.com> of Allegro Networks, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *        This product includes software developed by the NetBSD  *        Foundation, Inc. and its contributors.  * 4. Neither the name of The NetBSD Foundation nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*-  * Copyright (C) 1995, 1996 Wolfgang Solfrank.  * Copyright (C) 1995, 1996 TooLs GmbH.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by TooLs GmbH.  * 4. The name of TooLs GmbH may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $NetBSD: pmap.c,v 1.28 2000/03/26 20:42:36 kleink Exp $  */
end_comment

begin_comment
comment|/*-  * Copyright (C) 2001 Benno Rice.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY Benno Rice ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Native 64-bit page table operations for running without a hypervisor.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pageout.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pager.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/mmuvar.h>
end_include

begin_include
include|#
directive|include
file|"mmu_oea64.h"
end_include

begin_include
include|#
directive|include
file|"mmu_if.h"
end_include

begin_include
include|#
directive|include
file|"moea64_if.h"
end_include

begin_define
define|#
directive|define
name|PTESYNC
parameter_list|()
value|__asm __volatile("ptesync");
end_define

begin_define
define|#
directive|define
name|TLBSYNC
parameter_list|()
value|__asm __volatile("tlbsync; ptesync");
end_define

begin_define
define|#
directive|define
name|SYNC
parameter_list|()
value|__asm __volatile("sync");
end_define

begin_define
define|#
directive|define
name|EIEIO
parameter_list|()
value|__asm __volatile("eieio");
end_define

begin_define
define|#
directive|define
name|VSID_HASH_MASK
value|0x0000007fffffffffULL
end_define

begin_comment
comment|/*  * The tlbie instruction must be executed in 64-bit mode  * so we have to twiddle MSR[SF] around every invocation.  * Just to add to the fun, exceptions must be off as well  * so that we can't trap in 64-bit mode. What a pain.  */
end_comment

begin_decl_stmt
name|struct
name|mtx
name|tlbie_mutex
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|__inline
name|void
name|TLBIE
parameter_list|(
name|uint64_t
name|vpn
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|__powerpc64__
name|register_t
name|vpn_hi
decl_stmt|,
name|vpn_lo
decl_stmt|;
name|register_t
name|msr
decl_stmt|;
name|register_t
name|scratch
decl_stmt|;
endif|#
directive|endif
name|vpn
operator|<<=
name|ADDR_PIDX_SHFT
expr_stmt|;
name|vpn
operator|&=
operator|~
operator|(
literal|0xffffULL
operator|<<
literal|48
operator|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|tlbie_mutex
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__powerpc64__
asm|__asm __volatile("\ 	    ptesync; \ 	    tlbie %0; \ 	    eieio; \ 	    tlbsync; \ 	    ptesync;"
operator|::
literal|"r"
operator|(
name|vpn
operator|)
operator|:
literal|"memory"
block|)
function|;
end_function

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|vpn_hi
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|vpn
operator|>>
literal|32
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|vpn_lo
operator|=
operator|(
name|uint32_t
operator|)
name|vpn
expr_stmt|;
end_expr_stmt

begin_asm
asm|__asm __volatile("\ 	    mfmsr %0; \ 	    mr %1, %0; \ 	    insrdi %1,%5,1,0; \ 	    mtmsrd %1; isync; \ 	    ptesync; \ 	    \ 	    sld %1,%2,%4; \ 	    or %1,%1,%3; \ 	    tlbie %1; \ 	    \ 	    mtmsrd %0; isync; \ 	    eieio; \ 	    tlbsync; \ 	    ptesync;"
end_asm

begin_expr_stmt
unit|:
literal|"=r"
operator|(
name|msr
operator|)
operator|,
literal|"=r"
operator|(
name|scratch
operator|)
operator|:
literal|"r"
operator|(
name|vpn_hi
operator|)
operator|,
literal|"r"
operator|(
name|vpn_lo
operator|)
operator|,
literal|"r"
operator|(
literal|32
operator|)
operator|,
literal|"r"
operator|(
literal|1
operator|)
operator|:
literal|"memory"
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|mtx_unlock_spin
argument_list|(
operator|&
name|tlbie_mutex
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
unit|}
define|#
directive|define
name|DISABLE_TRANS
parameter_list|(
name|msr
parameter_list|)
value|msr = mfmsr(); mtmsr(msr& ~PSL_DR); isync()
end_define

begin_define
define|#
directive|define
name|ENABLE_TRANS
parameter_list|(
name|msr
parameter_list|)
value|mtmsr(msr); isync()
end_define

begin_comment
comment|/*  * PTEG data.  */
end_comment

begin_decl_stmt
unit|static
name|struct
name|lpteg
modifier|*
name|moea64_pteg_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * PTE calls.  */
end_comment

begin_function_decl
specifier|static
name|int
name|moea64_pte_insert_native
parameter_list|(
name|mmu_t
parameter_list|,
name|u_int
parameter_list|,
name|struct
name|lpte
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uintptr_t
name|moea64_pvo_to_pte_native
parameter_list|(
name|mmu_t
parameter_list|,
specifier|const
name|struct
name|pvo_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|moea64_pte_synch_native
parameter_list|(
name|mmu_t
parameter_list|,
name|uintptr_t
name|pt
parameter_list|,
name|struct
name|lpte
modifier|*
name|pvo_pt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|moea64_pte_clear_native
parameter_list|(
name|mmu_t
parameter_list|,
name|uintptr_t
name|pt
parameter_list|,
name|struct
name|lpte
modifier|*
name|pvo_pt
parameter_list|,
name|uint64_t
name|vpn
parameter_list|,
name|uint64_t
name|ptebit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|moea64_pte_change_native
parameter_list|(
name|mmu_t
parameter_list|,
name|uintptr_t
name|pt
parameter_list|,
name|struct
name|lpte
modifier|*
name|pvo_pt
parameter_list|,
name|uint64_t
name|vpn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|moea64_pte_unset_native
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|uintptr_t
name|pt
parameter_list|,
name|struct
name|lpte
modifier|*
name|pvo_pt
parameter_list|,
name|uint64_t
name|vpn
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Utility routines.  */
end_comment

begin_function_decl
specifier|static
name|void
name|moea64_bootstrap_native
parameter_list|(
name|mmu_t
name|mmup
parameter_list|,
name|vm_offset_t
name|kernelstart
parameter_list|,
name|vm_offset_t
name|kernelend
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|moea64_cpu_bootstrap_native
parameter_list|(
name|mmu_t
parameter_list|,
name|int
name|ap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tlbia
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|mmu_method_t
name|moea64_native_methods
index|[]
init|=
block|{
comment|/* Internal interfaces */
name|MMUMETHOD
argument_list|(
name|mmu_bootstrap
argument_list|,
name|moea64_bootstrap_native
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_cpu_bootstrap
argument_list|,
name|moea64_cpu_bootstrap_native
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|moea64_pte_synch
argument_list|,
name|moea64_pte_synch_native
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|moea64_pte_clear
argument_list|,
name|moea64_pte_clear_native
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|moea64_pte_unset
argument_list|,
name|moea64_pte_unset_native
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|moea64_pte_change
argument_list|,
name|moea64_pte_change_native
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|moea64_pte_insert
argument_list|,
name|moea64_pte_insert_native
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|moea64_pvo_to_pte
argument_list|,
name|moea64_pvo_to_pte_native
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MMU_DEF_INHERIT
argument_list|(
name|oea64_mmu_native
argument_list|,
name|MMU_TYPE_G5
argument_list|,
name|moea64_native_methods
argument_list|,
literal|0
argument_list|,
name|oea64_mmu
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|__inline
name|u_int
name|va_to_pteg
parameter_list|(
name|uint64_t
name|vsid
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|,
name|int
name|large
parameter_list|)
block|{
name|uint64_t
name|hash
decl_stmt|;
name|int
name|shift
decl_stmt|;
name|shift
operator|=
name|large
condition|?
name|moea64_large_page_shift
else|:
name|ADDR_PIDX_SHFT
expr_stmt|;
name|hash
operator|=
operator|(
name|vsid
operator|&
name|VSID_HASH_MASK
operator|)
operator|^
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|addr
operator|&
name|ADDR_PIDX
operator|)
operator|>>
name|shift
operator|)
expr_stmt|;
return|return
operator|(
name|hash
operator|&
name|moea64_pteg_mask
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|moea64_pte_synch_native
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|uintptr_t
name|pt_cookie
parameter_list|,
name|struct
name|lpte
modifier|*
name|pvo_pt
parameter_list|)
block|{
name|struct
name|lpte
modifier|*
name|pt
init|=
operator|(
expr|struct
name|lpte
operator|*
operator|)
name|pt_cookie
decl_stmt|;
name|pvo_pt
operator|->
name|pte_lo
operator||=
name|pt
operator|->
name|pte_lo
operator|&
operator|(
name|LPTE_REF
operator||
name|LPTE_CHG
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|moea64_pte_clear_native
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|uintptr_t
name|pt_cookie
parameter_list|,
name|struct
name|lpte
modifier|*
name|pvo_pt
parameter_list|,
name|uint64_t
name|vpn
parameter_list|,
name|uint64_t
name|ptebit
parameter_list|)
block|{
name|struct
name|lpte
modifier|*
name|pt
init|=
operator|(
expr|struct
name|lpte
operator|*
operator|)
name|pt_cookie
decl_stmt|;
comment|/* 	 * As shown in Section 7.6.3.2.3 	 */
name|pt
operator|->
name|pte_lo
operator|&=
operator|~
name|ptebit
expr_stmt|;
name|TLBIE
argument_list|(
name|vpn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|moea64_pte_set_native
parameter_list|(
name|struct
name|lpte
modifier|*
name|pt
parameter_list|,
name|struct
name|lpte
modifier|*
name|pvo_pt
parameter_list|)
block|{
name|pvo_pt
operator|->
name|pte_hi
operator||=
name|LPTE_VALID
expr_stmt|;
comment|/* 	 * Update the PTE as defined in section 7.6.3.1. 	 * Note that the REF/CHG bits are from pvo_pt and thus should have 	 * been saved so this routine can restore them (if desired). 	 */
name|pt
operator|->
name|pte_lo
operator|=
name|pvo_pt
operator|->
name|pte_lo
expr_stmt|;
name|EIEIO
argument_list|()
expr_stmt|;
name|pt
operator|->
name|pte_hi
operator|=
name|pvo_pt
operator|->
name|pte_hi
expr_stmt|;
name|PTESYNC
argument_list|()
expr_stmt|;
name|moea64_pte_valid
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|moea64_pte_unset_native
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|uintptr_t
name|pt_cookie
parameter_list|,
name|struct
name|lpte
modifier|*
name|pvo_pt
parameter_list|,
name|uint64_t
name|vpn
parameter_list|)
block|{
name|struct
name|lpte
modifier|*
name|pt
init|=
operator|(
expr|struct
name|lpte
operator|*
operator|)
name|pt_cookie
decl_stmt|;
name|pvo_pt
operator|->
name|pte_hi
operator|&=
operator|~
name|LPTE_VALID
expr_stmt|;
comment|/* Finish all pending operations */
name|isync
argument_list|()
expr_stmt|;
comment|/* 	 * Force the reg& chg bits back into the PTEs. 	 */
name|SYNC
argument_list|()
expr_stmt|;
comment|/* 	 * Invalidate the pte. 	 */
name|pt
operator|->
name|pte_hi
operator|&=
operator|~
name|LPTE_VALID
expr_stmt|;
name|TLBIE
argument_list|(
name|vpn
argument_list|)
expr_stmt|;
comment|/* 	 * Save the reg& chg bits. 	 */
name|moea64_pte_synch_native
argument_list|(
name|mmu
argument_list|,
name|pt_cookie
argument_list|,
name|pvo_pt
argument_list|)
expr_stmt|;
name|moea64_pte_valid
operator|--
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|moea64_pte_change_native
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|uintptr_t
name|pt
parameter_list|,
name|struct
name|lpte
modifier|*
name|pvo_pt
parameter_list|,
name|uint64_t
name|vpn
parameter_list|)
block|{
comment|/* 	 * Invalidate the PTE 	 */
name|moea64_pte_unset_native
argument_list|(
name|mmu
argument_list|,
name|pt
argument_list|,
name|pvo_pt
argument_list|,
name|vpn
argument_list|)
expr_stmt|;
name|moea64_pte_set_native
argument_list|(
operator|(
expr|struct
name|lpte
operator|*
operator|)
name|pt
argument_list|,
name|pvo_pt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|moea64_cpu_bootstrap_native
parameter_list|(
name|mmu_t
name|mmup
parameter_list|,
name|int
name|ap
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|__powerpc64__
name|struct
name|slb
modifier|*
name|slb
init|=
name|PCPU_GET
argument_list|(
name|slb
argument_list|)
decl_stmt|;
name|register_t
name|seg0
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * Initialize segment registers and MMU 	 */
name|mtmsr
argument_list|(
name|mfmsr
argument_list|()
operator|&
operator|~
name|PSL_DR
operator|&
operator|~
name|PSL_IR
argument_list|)
expr_stmt|;
name|isync
argument_list|()
expr_stmt|;
comment|/* 	 * Install kernel SLB entries 	 */
ifdef|#
directive|ifdef
name|__powerpc64__
asm|__asm __volatile ("slbia");
asm|__asm __volatile ("slbmfee %0,%1; slbie %0;" : "=r"(seg0) :
literal|"r"
operator|(
literal|0
operator|)
block|)
function|;
end_function

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|slb
index|[
name|i
index|]
operator|.
name|slbe
operator|&
name|SLBE_VALID
operator|)
condition|)
continue|continue;
asm|__asm __volatile ("slbmte %0, %1" ::
literal|"r"
operator|(
name|slb
index|[
name|i
index|]
operator|.
name|slbv
operator|)
operator|,
literal|"r"
operator|(
name|slb
index|[
name|i
index|]
operator|.
name|slbe
operator|)
block|)
empty_stmt|;
end_for

begin_else
unit|}
else|#
directive|else
end_else

begin_expr_stmt
unit|for
operator|(
name|i
operator|=
literal|0
expr|;
name|i
operator|<
literal|16
expr|;
name|i
operator|++
operator|)
name|mtsrin
argument_list|(
name|i
operator|<<
name|ADDR_SR_SHFT
argument_list|,
name|kernel_pmap
operator|->
name|pm_sr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* 	 * Install page table 	 */
end_comment

begin_asm
asm|__asm __volatile ("ptesync; mtsdr1 %0; isync"
end_asm

begin_expr_stmt
operator|::
literal|"r"
operator|(
operator|(
name|uintptr_t
operator|)
name|moea64_pteg_table
operator||
call|(
name|uintptr_t
call|)
argument_list|(
name|flsl
argument_list|(
name|moea64_pteg_mask
operator|>>
literal|11
argument_list|)
argument_list|)
operator|)
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|tlbia
argument_list|()
expr_stmt|;
end_expr_stmt

begin_function
unit|}  static
name|void
name|moea64_bootstrap_native
parameter_list|(
name|mmu_t
name|mmup
parameter_list|,
name|vm_offset_t
name|kernelstart
parameter_list|,
name|vm_offset_t
name|kernelend
parameter_list|)
block|{
name|vm_size_t
name|size
decl_stmt|;
name|vm_offset_t
name|off
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|register_t
name|msr
decl_stmt|;
name|moea64_early_bootstrap
argument_list|(
name|mmup
argument_list|,
name|kernelstart
argument_list|,
name|kernelend
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate PTEG table. 	 */
name|size
operator|=
name|moea64_pteg_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|lpteg
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"moea64_bootstrap: %d PTEGs, %d bytes"
argument_list|,
name|moea64_pteg_count
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* 	 * We now need to allocate memory. This memory, to be allocated, 	 * has to reside in a page table. The page table we are about to 	 * allocate. We don't have BAT. So drop to data real mode for a minute 	 * as a measure of last resort. We do this a couple times. 	 */
name|moea64_pteg_table
operator|=
operator|(
expr|struct
name|lpteg
operator|*
operator|)
name|moea64_bootstrap_alloc
argument_list|(
name|size
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|DISABLE_TRANS
argument_list|(
name|msr
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|moea64_pteg_table
argument_list|,
name|moea64_pteg_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|lpteg
argument_list|)
argument_list|)
expr_stmt|;
name|ENABLE_TRANS
argument_list|(
name|msr
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"moea64_bootstrap: PTEG table at %p"
argument_list|,
name|moea64_pteg_table
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the TLBIE lock. TLBIE can only be executed by one CPU. 	 */
name|mtx_init
argument_list|(
operator|&
name|tlbie_mutex
argument_list|,
literal|"tlbie mutex"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
name|moea64_mid_bootstrap
argument_list|(
name|mmup
argument_list|,
name|kernelstart
argument_list|,
name|kernelend
argument_list|)
expr_stmt|;
comment|/* 	 * Add a mapping for the page table itself if there is no direct map. 	 */
if|if
condition|(
operator|!
name|hw_direct_map
condition|)
block|{
name|size
operator|=
name|moea64_pteg_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|lpteg
argument_list|)
expr_stmt|;
name|off
operator|=
call|(
name|vm_offset_t
call|)
argument_list|(
name|moea64_pteg_table
argument_list|)
expr_stmt|;
name|DISABLE_TRANS
argument_list|(
name|msr
argument_list|)
expr_stmt|;
for|for
control|(
name|pa
operator|=
name|off
init|;
name|pa
operator|<
name|off
operator|+
name|size
condition|;
name|pa
operator|+=
name|PAGE_SIZE
control|)
name|pmap_kenter
argument_list|(
name|pa
argument_list|,
name|pa
argument_list|)
expr_stmt|;
name|ENABLE_TRANS
argument_list|(
name|msr
argument_list|)
expr_stmt|;
block|}
comment|/* Bring up virtual memory */
name|moea64_late_bootstrap
argument_list|(
name|mmup
argument_list|,
name|kernelstart
argument_list|,
name|kernelend
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tlbia
parameter_list|(
name|void
parameter_list|)
block|{
name|vm_offset_t
name|i
decl_stmt|;
ifndef|#
directive|ifndef
name|__powerpc64__
name|register_t
name|msr
decl_stmt|,
name|scratch
decl_stmt|;
endif|#
directive|endif
name|TLBSYNC
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0xFF000
condition|;
name|i
operator|+=
literal|0x00001000
control|)
block|{
ifdef|#
directive|ifdef
name|__powerpc64__
asm|__asm __volatile("tlbiel %0" :: "r"(i));
else|#
directive|else
asm|__asm __volatile("\ 		    mfmsr %0; \ 		    mr %1, %0; \ 		    insrdi %1,%3,1,0; \ 		    mtmsrd %1; \ 		    isync; \ 		    \ 		    tlbiel %2; \ 		    \ 		    mtmsrd %0; \ 		    isync;"
block|:
literal|"=r"
operator|(
name|msr
operator|)
operator|,
literal|"=r"
operator|(
name|scratch
operator|)
operator|:
literal|"r"
operator|(
name|i
operator|)
operator|,
literal|"r"
operator|(
literal|1
operator|)
block|)
empty_stmt|;
endif|#
directive|endif
block|}
end_function

begin_expr_stmt
name|EIEIO
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TLBSYNC
argument_list|()
expr_stmt|;
end_expr_stmt

begin_function
unit|}  static
name|uintptr_t
name|moea64_pvo_to_pte_native
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
specifier|const
name|struct
name|pvo_entry
modifier|*
name|pvo
parameter_list|)
block|{
name|struct
name|lpte
modifier|*
name|pt
decl_stmt|;
name|int
name|pteidx
decl_stmt|,
name|ptegidx
decl_stmt|;
name|uint64_t
name|vsid
decl_stmt|;
comment|/* If the PTEG index is not set, then there is no page table entry */
if|if
condition|(
operator|!
name|PVO_PTEGIDX_ISSET
argument_list|(
name|pvo
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Calculate the ptegidx 	 */
name|vsid
operator|=
name|PVO_VSID
argument_list|(
name|pvo
argument_list|)
expr_stmt|;
name|ptegidx
operator|=
name|va_to_pteg
argument_list|(
name|vsid
argument_list|,
name|PVO_VADDR
argument_list|(
name|pvo
argument_list|)
argument_list|,
name|pvo
operator|->
name|pvo_vaddr
operator|&
name|PVO_LARGE
argument_list|)
expr_stmt|;
comment|/* 	 * We can find the actual pte entry without searching by grabbing 	 * the PTEG index from 3 unused bits in pvo_vaddr and by 	 * noticing the HID bit. 	 */
if|if
condition|(
name|pvo
operator|->
name|pvo_pte
operator|.
name|lpte
operator|.
name|pte_hi
operator|&
name|LPTE_HID
condition|)
name|ptegidx
operator|^=
name|moea64_pteg_mask
expr_stmt|;
name|pteidx
operator|=
operator|(
name|ptegidx
operator|<<
literal|3
operator|)
operator||
name|PVO_PTEGIDX_GET
argument_list|(
name|pvo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pvo
operator|->
name|pvo_pte
operator|.
name|lpte
operator|.
name|pte_hi
operator|&
name|LPTE_VALID
operator|)
operator|&&
operator|!
name|PVO_PTEGIDX_ISSET
argument_list|(
name|pvo
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"moea64_pvo_to_pte: pvo %p has valid pte in pvo but no "
literal|"valid pte index"
argument_list|,
name|pvo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pvo
operator|->
name|pvo_pte
operator|.
name|lpte
operator|.
name|pte_hi
operator|&
name|LPTE_VALID
operator|)
operator|==
literal|0
operator|&&
name|PVO_PTEGIDX_ISSET
argument_list|(
name|pvo
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"moea64_pvo_to_pte: pvo %p has valid pte index in pvo "
literal|"pvo but no valid pte"
argument_list|,
name|pvo
argument_list|)
expr_stmt|;
block|}
name|pt
operator|=
operator|&
name|moea64_pteg_table
index|[
name|pteidx
operator|>>
literal|3
index|]
operator|.
name|pt
index|[
name|pteidx
operator|&
literal|7
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|pt
operator|->
name|pte_hi
operator|^
operator|(
name|pvo
operator|->
name|pvo_pte
operator|.
name|lpte
operator|.
name|pte_hi
operator|&
operator|~
name|LPTE_VALID
operator|)
operator|)
operator|==
name|LPTE_VALID
condition|)
block|{
if|if
condition|(
operator|(
name|pvo
operator|->
name|pvo_pte
operator|.
name|lpte
operator|.
name|pte_hi
operator|&
name|LPTE_VALID
operator|)
operator|==
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"moea64_pvo_to_pte: pvo %p has valid pte in "
literal|"moea64_pteg_table %p but invalid in pvo"
argument_list|,
name|pvo
argument_list|,
name|pt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|pt
operator|->
name|pte_lo
operator|^
name|pvo
operator|->
name|pvo_pte
operator|.
name|lpte
operator|.
name|pte_lo
operator|)
operator|&
operator|~
operator|(
name|LPTE_M
operator||
name|LPTE_CHG
operator||
name|LPTE_REF
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"moea64_pvo_to_pte: pvo %p pte does not match "
literal|"pte %p in moea64_pteg_table difference is %#x"
argument_list|,
name|pvo
argument_list|,
name|pt
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|pt
operator|->
name|pte_lo
operator|^
name|pvo
operator|->
name|pvo_pte
operator|.
name|lpte
operator|.
name|pte_lo
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|uintptr_t
operator|)
name|pt
operator|)
return|;
block|}
if|if
condition|(
name|pvo
operator|->
name|pvo_pte
operator|.
name|lpte
operator|.
name|pte_hi
operator|&
name|LPTE_VALID
condition|)
block|{
name|panic
argument_list|(
literal|"moea64_pvo_to_pte: pvo %p has invalid pte %p in "
literal|"moea64_pteg_table but valid in pvo"
argument_list|,
name|pvo
argument_list|,
name|pt
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|moea64_pte_spillable_ident
parameter_list|(
name|u_int
name|ptegidx
parameter_list|)
block|{
name|struct
name|lpte
modifier|*
name|pt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
comment|/* Start at a random slot */
name|i
operator|=
name|mftb
argument_list|()
operator|%
literal|8
expr_stmt|;
name|k
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
block|{
name|pt
operator|=
operator|&
name|moea64_pteg_table
index|[
name|ptegidx
index|]
operator|.
name|pt
index|[
operator|(
name|i
operator|+
name|j
operator|)
operator|%
literal|8
index|]
expr_stmt|;
if|if
condition|(
name|pt
operator|->
name|pte_hi
operator|&
operator|(
name|LPTE_LOCKED
operator||
name|LPTE_WIRED
operator|)
condition|)
continue|continue;
comment|/* This is a candidate, so remember it */
name|k
operator|=
operator|(
name|i
operator|+
name|j
operator|)
operator|%
literal|8
expr_stmt|;
comment|/* Try to get a page that has not been used lately */
if|if
condition|(
operator|!
operator|(
name|pt
operator|->
name|pte_lo
operator|&
name|LPTE_REF
operator|)
condition|)
return|return
operator|(
name|k
operator|)
return|;
block|}
return|return
operator|(
name|k
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|moea64_pte_insert_native
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|u_int
name|ptegidx
parameter_list|,
name|struct
name|lpte
modifier|*
name|pvo_pt
parameter_list|)
block|{
name|struct
name|lpte
modifier|*
name|pt
decl_stmt|;
name|struct
name|pvo_entry
modifier|*
name|pvo
decl_stmt|;
name|u_int
name|pteg_bktidx
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * First try primary hash. 	 */
name|pteg_bktidx
operator|=
name|ptegidx
expr_stmt|;
for|for
control|(
name|pt
operator|=
name|moea64_pteg_table
index|[
name|pteg_bktidx
index|]
operator|.
name|pt
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
operator|,
name|pt
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|pt
operator|->
name|pte_hi
operator|&
operator|(
name|LPTE_VALID
operator||
name|LPTE_LOCKED
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|pvo_pt
operator|->
name|pte_hi
operator|&=
operator|~
name|LPTE_HID
expr_stmt|;
name|moea64_pte_set_native
argument_list|(
name|pt
argument_list|,
name|pvo_pt
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
block|}
comment|/* 	 * Now try secondary hash. 	 */
name|pteg_bktidx
operator|^=
name|moea64_pteg_mask
expr_stmt|;
for|for
control|(
name|pt
operator|=
name|moea64_pteg_table
index|[
name|pteg_bktidx
index|]
operator|.
name|pt
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
operator|,
name|pt
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|pt
operator|->
name|pte_hi
operator|&
operator|(
name|LPTE_VALID
operator||
name|LPTE_LOCKED
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|pvo_pt
operator|->
name|pte_hi
operator||=
name|LPTE_HID
expr_stmt|;
name|moea64_pte_set_native
argument_list|(
name|pt
argument_list|,
name|pvo_pt
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
block|}
comment|/* 	 * Out of luck. Find a PTE to sacrifice. 	 */
name|pteg_bktidx
operator|=
name|ptegidx
expr_stmt|;
name|i
operator|=
name|moea64_pte_spillable_ident
argument_list|(
name|pteg_bktidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|pteg_bktidx
operator|^=
name|moea64_pteg_mask
expr_stmt|;
name|i
operator|=
name|moea64_pte_spillable_ident
argument_list|(
name|pteg_bktidx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
comment|/* No freeable slots in either PTEG? We're hosed. */
name|panic
argument_list|(
literal|"moea64_pte_insert: overflow"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|pteg_bktidx
operator|==
name|ptegidx
condition|)
name|pvo_pt
operator|->
name|pte_hi
operator|&=
operator|~
name|LPTE_HID
expr_stmt|;
else|else
name|pvo_pt
operator|->
name|pte_hi
operator||=
name|LPTE_HID
expr_stmt|;
comment|/* 	 * Synchronize the sacrifice PTE with its PVO, then mark both 	 * invalid. The PVO will be reused when/if the VM system comes 	 * here after a fault. 	 */
name|pt
operator|=
operator|&
name|moea64_pteg_table
index|[
name|pteg_bktidx
index|]
operator|.
name|pt
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|pt
operator|->
name|pte_hi
operator|&
name|LPTE_HID
condition|)
name|pteg_bktidx
operator|^=
name|moea64_pteg_mask
expr_stmt|;
comment|/* PTEs indexed by primary */
name|LIST_FOREACH
argument_list|(
argument|pvo
argument_list|,
argument|&moea64_pvo_table[pteg_bktidx]
argument_list|,
argument|pvo_olink
argument_list|)
block|{
if|if
condition|(
name|pvo
operator|->
name|pvo_pte
operator|.
name|lpte
operator|.
name|pte_hi
operator|==
name|pt
operator|->
name|pte_hi
condition|)
block|{
name|KASSERT
argument_list|(
name|pvo
operator|->
name|pvo_pte
operator|.
name|lpte
operator|.
name|pte_hi
operator|&
name|LPTE_VALID
argument_list|,
operator|(
literal|"Invalid PVO for valid PTE!"
operator|)
argument_list|)
expr_stmt|;
name|moea64_pte_unset_native
argument_list|(
name|mmu
argument_list|,
operator|(
name|uintptr_t
operator|)
name|pt
argument_list|,
operator|&
name|pvo
operator|->
name|pvo_pte
operator|.
name|lpte
argument_list|,
name|pvo
operator|->
name|pvo_vpn
argument_list|)
expr_stmt|;
name|PVO_PTEGIDX_CLR
argument_list|(
name|pvo
argument_list|)
expr_stmt|;
name|moea64_pte_overflow
operator|++
expr_stmt|;
break|break;
block|}
block|}
name|KASSERT
argument_list|(
name|pvo
operator|->
name|pvo_pte
operator|.
name|lpte
operator|.
name|pte_hi
operator|==
name|pt
operator|->
name|pte_hi
argument_list|,
operator|(
literal|"Unable to find PVO for spilled PTE"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Set the new PTE. 	 */
name|moea64_pte_set_native
argument_list|(
name|pt
argument_list|,
name|pvo_pt
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

end_unit

