begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001 The NetBSD Foundation, Inc.  * All rights reserved.  *  * This code is derived from software contributed to The NetBSD Foundation  * by Matt Thomas<matt@3am-software.com> of Allegro Networks, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*-  * Copyright (C) 1995, 1996 Wolfgang Solfrank.  * Copyright (C) 1995, 1996 TooLs GmbH.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by TooLs GmbH.  * 4. The name of TooLs GmbH may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $NetBSD: pmap.c,v 1.28 2000/03/26 20:42:36 kleink Exp $  */
end_comment

begin_comment
comment|/*-  * Copyright (C) 2001 Benno Rice.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY Benno Rice ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Native 64-bit page table operations for running without a hypervisor.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pageout.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/mmuvar.h>
end_include

begin_include
include|#
directive|include
file|"mmu_oea64.h"
end_include

begin_include
include|#
directive|include
file|"mmu_if.h"
end_include

begin_include
include|#
directive|include
file|"moea64_if.h"
end_include

begin_define
define|#
directive|define
name|PTESYNC
parameter_list|()
value|__asm __volatile("ptesync");
end_define

begin_define
define|#
directive|define
name|TLBSYNC
parameter_list|()
value|__asm __volatile("tlbsync; ptesync");
end_define

begin_define
define|#
directive|define
name|SYNC
parameter_list|()
value|__asm __volatile("sync");
end_define

begin_define
define|#
directive|define
name|EIEIO
parameter_list|()
value|__asm __volatile("eieio");
end_define

begin_define
define|#
directive|define
name|VSID_HASH_MASK
value|0x0000007fffffffffULL
end_define

begin_function
specifier|static
name|__inline
name|void
name|TLBIE
parameter_list|(
name|uint64_t
name|vpn
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|__powerpc64__
name|register_t
name|vpn_hi
decl_stmt|,
name|vpn_lo
decl_stmt|;
name|register_t
name|msr
decl_stmt|;
name|register_t
name|scratch
decl_stmt|,
name|intr
decl_stmt|;
endif|#
directive|endif
specifier|static
specifier|volatile
name|u_int
name|tlbie_lock
init|=
literal|0
decl_stmt|;
name|vpn
operator|<<=
name|ADDR_PIDX_SHFT
expr_stmt|;
name|vpn
operator|&=
operator|~
operator|(
literal|0xffffULL
operator|<<
literal|48
operator|)
expr_stmt|;
comment|/* Hobo spinlock: we need stronger guarantees than mutexes provide */
while|while
condition|(
operator|!
name|atomic_cmpset_int
argument_list|(
operator|&
name|tlbie_lock
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
empty_stmt|;
name|isync
argument_list|()
expr_stmt|;
comment|/* Flush instruction queue once lock acquired */
ifdef|#
directive|ifdef
name|__powerpc64__
asm|__asm __volatile("tlbie %0" :: "r"(vpn) : "memory");
asm|__asm __volatile("eieio; tlbsync; ptesync" ::: "memory");
else|#
directive|else
name|vpn_hi
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|vpn
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|vpn_lo
operator|=
operator|(
name|uint32_t
operator|)
name|vpn
expr_stmt|;
name|intr
operator|=
name|intr_disable
argument_list|()
expr_stmt|;
asm|__asm __volatile("\ 	    mfmsr %0; \ 	    mr %1, %0; \ 	    insrdi %1,%5,1,0; \ 	    mtmsrd %1; isync; \ 	    \ 	    sld %1,%2,%4; \ 	    or %1,%1,%3; \ 	    tlbie %1; \ 	    \ 	    mtmsrd %0; isync; \ 	    eieio; \ 	    tlbsync; \ 	    ptesync;"
block|:
literal|"=r"
operator|(
name|msr
operator|)
operator|,
literal|"=r"
operator|(
name|scratch
operator|)
operator|:
literal|"r"
operator|(
name|vpn_hi
operator|)
operator|,
literal|"r"
operator|(
name|vpn_lo
operator|)
operator|,
literal|"r"
operator|(
literal|32
operator|)
operator|,
literal|"r"
operator|(
literal|1
operator|)
operator|:
literal|"memory"
block|)
function|;
end_function

begin_expr_stmt
name|intr_restore
argument_list|(
name|intr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* No barriers or special ops -- taken care of by ptesync above */
end_comment

begin_expr_stmt
name|tlbie_lock
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_define
unit|}
define|#
directive|define
name|DISABLE_TRANS
parameter_list|(
name|msr
parameter_list|)
value|msr = mfmsr(); mtmsr(msr& ~PSL_DR)
end_define

begin_define
define|#
directive|define
name|ENABLE_TRANS
parameter_list|(
name|msr
parameter_list|)
value|mtmsr(msr)
end_define

begin_comment
comment|/*  * PTEG data.  */
end_comment

begin_decl_stmt
unit|static
specifier|volatile
name|struct
name|lpte
modifier|*
name|moea64_pteg_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|rwlock
name|moea64_eviction_lock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * PTE calls.  */
end_comment

begin_function_decl
specifier|static
name|int
name|moea64_pte_insert_native
parameter_list|(
name|mmu_t
parameter_list|,
name|struct
name|pvo_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int64_t
name|moea64_pte_synch_native
parameter_list|(
name|mmu_t
parameter_list|,
name|struct
name|pvo_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int64_t
name|moea64_pte_clear_native
parameter_list|(
name|mmu_t
parameter_list|,
name|struct
name|pvo_entry
modifier|*
parameter_list|,
name|uint64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int64_t
name|moea64_pte_replace_native
parameter_list|(
name|mmu_t
parameter_list|,
name|struct
name|pvo_entry
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int64_t
name|moea64_pte_unset_native
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|struct
name|pvo_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Utility routines.  */
end_comment

begin_function_decl
specifier|static
name|void
name|moea64_bootstrap_native
parameter_list|(
name|mmu_t
name|mmup
parameter_list|,
name|vm_offset_t
name|kernelstart
parameter_list|,
name|vm_offset_t
name|kernelend
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|moea64_cpu_bootstrap_native
parameter_list|(
name|mmu_t
parameter_list|,
name|int
name|ap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tlbia
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|mmu_method_t
name|moea64_native_methods
index|[]
init|=
block|{
comment|/* Internal interfaces */
name|MMUMETHOD
argument_list|(
name|mmu_bootstrap
argument_list|,
name|moea64_bootstrap_native
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|mmu_cpu_bootstrap
argument_list|,
name|moea64_cpu_bootstrap_native
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|moea64_pte_synch
argument_list|,
name|moea64_pte_synch_native
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|moea64_pte_clear
argument_list|,
name|moea64_pte_clear_native
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|moea64_pte_unset
argument_list|,
name|moea64_pte_unset_native
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|moea64_pte_replace
argument_list|,
name|moea64_pte_replace_native
argument_list|)
block|,
name|MMUMETHOD
argument_list|(
name|moea64_pte_insert
argument_list|,
name|moea64_pte_insert_native
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MMU_DEF_INHERIT
argument_list|(
name|oea64_mmu_native
argument_list|,
name|MMU_TYPE_G5
argument_list|,
name|moea64_native_methods
argument_list|,
literal|0
argument_list|,
name|oea64_mmu
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int64_t
name|moea64_pte_synch_native
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|struct
name|pvo_entry
modifier|*
name|pvo
parameter_list|)
block|{
specifier|volatile
name|struct
name|lpte
modifier|*
name|pt
init|=
name|moea64_pteg_table
operator|+
name|pvo
operator|->
name|pvo_pte
operator|.
name|slot
decl_stmt|;
name|struct
name|lpte
name|properpt
decl_stmt|;
name|uint64_t
name|ptelo
decl_stmt|;
name|PMAP_LOCK_ASSERT
argument_list|(
name|pvo
operator|->
name|pvo_pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|moea64_pte_from_pvo
argument_list|(
name|pvo
argument_list|,
operator|&
name|properpt
argument_list|)
expr_stmt|;
name|rw_rlock
argument_list|(
operator|&
name|moea64_eviction_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|be64toh
argument_list|(
name|pt
operator|->
name|pte_hi
argument_list|)
operator|&
name|LPTE_AVPN_MASK
operator|)
operator|!=
operator|(
name|properpt
operator|.
name|pte_hi
operator|&
name|LPTE_AVPN_MASK
operator|)
condition|)
block|{
comment|/* Evicted */
name|rw_runlock
argument_list|(
operator|&
name|moea64_eviction_lock
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|PTESYNC
argument_list|()
expr_stmt|;
name|ptelo
operator|=
name|be64toh
argument_list|(
name|pt
operator|->
name|pte_lo
argument_list|)
expr_stmt|;
name|rw_runlock
argument_list|(
operator|&
name|moea64_eviction_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ptelo
operator|&
operator|(
name|LPTE_REF
operator||
name|LPTE_CHG
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int64_t
name|moea64_pte_clear_native
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|struct
name|pvo_entry
modifier|*
name|pvo
parameter_list|,
name|uint64_t
name|ptebit
parameter_list|)
block|{
specifier|volatile
name|struct
name|lpte
modifier|*
name|pt
init|=
name|moea64_pteg_table
operator|+
name|pvo
operator|->
name|pvo_pte
operator|.
name|slot
decl_stmt|;
name|struct
name|lpte
name|properpt
decl_stmt|;
name|uint64_t
name|ptelo
decl_stmt|;
name|PMAP_LOCK_ASSERT
argument_list|(
name|pvo
operator|->
name|pvo_pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|moea64_pte_from_pvo
argument_list|(
name|pvo
argument_list|,
operator|&
name|properpt
argument_list|)
expr_stmt|;
name|rw_rlock
argument_list|(
operator|&
name|moea64_eviction_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|be64toh
argument_list|(
name|pt
operator|->
name|pte_hi
argument_list|)
operator|&
name|LPTE_AVPN_MASK
operator|)
operator|!=
operator|(
name|properpt
operator|.
name|pte_hi
operator|&
name|LPTE_AVPN_MASK
operator|)
condition|)
block|{
comment|/* Evicted */
name|rw_runlock
argument_list|(
operator|&
name|moea64_eviction_lock
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ptebit
operator|==
name|LPTE_REF
condition|)
block|{
comment|/* See "Resetting the Reference Bit" in arch manual */
name|PTESYNC
argument_list|()
expr_stmt|;
comment|/* 2-step here safe: precision is not guaranteed */
name|ptelo
operator|=
name|be64toh
argument_list|(
name|pt
operator|->
name|pte_lo
argument_list|)
expr_stmt|;
comment|/* One-byte store to avoid touching the C bit */
operator|(
operator|(
specifier|volatile
name|uint8_t
operator|*
operator|)
operator|(
operator|&
name|pt
operator|->
name|pte_lo
operator|)
operator|)
index|[
literal|6
index|]
operator|=
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
operator|(
operator|(
name|uint8_t
operator|*
operator|)
operator|(
operator|&
name|properpt
operator|.
name|pte_lo
operator|)
operator|)
index|[
literal|6
index|]
expr_stmt|;
else|#
directive|else
operator|(
operator|(
name|uint8_t
operator|*
operator|)
operator|(
operator|&
name|properpt
operator|.
name|pte_lo
operator|)
operator|)
index|[
literal|1
index|]
expr_stmt|;
endif|#
directive|endif
name|rw_runlock
argument_list|(
operator|&
name|moea64_eviction_lock
argument_list|)
expr_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
name|TLBIE
argument_list|(
name|pvo
operator|->
name|pvo_vpn
argument_list|)
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|rw_runlock
argument_list|(
operator|&
name|moea64_eviction_lock
argument_list|)
expr_stmt|;
name|ptelo
operator|=
name|moea64_pte_unset_native
argument_list|(
name|mmu
argument_list|,
name|pvo
argument_list|)
expr_stmt|;
name|moea64_pte_insert_native
argument_list|(
name|mmu
argument_list|,
name|pvo
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ptelo
operator|&
operator|(
name|LPTE_REF
operator||
name|LPTE_CHG
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int64_t
name|moea64_pte_unset_native
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|struct
name|pvo_entry
modifier|*
name|pvo
parameter_list|)
block|{
specifier|volatile
name|struct
name|lpte
modifier|*
name|pt
init|=
name|moea64_pteg_table
operator|+
name|pvo
operator|->
name|pvo_pte
operator|.
name|slot
decl_stmt|;
name|struct
name|lpte
name|properpt
decl_stmt|;
name|uint64_t
name|ptelo
decl_stmt|;
name|moea64_pte_from_pvo
argument_list|(
name|pvo
argument_list|,
operator|&
name|properpt
argument_list|)
expr_stmt|;
name|rw_rlock
argument_list|(
operator|&
name|moea64_eviction_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|be64toh
argument_list|(
name|pt
operator|->
name|pte_hi
operator|&
name|LPTE_AVPN_MASK
argument_list|)
operator|)
operator|!=
operator|(
name|properpt
operator|.
name|pte_hi
operator|&
name|LPTE_AVPN_MASK
operator|)
condition|)
block|{
comment|/* Evicted */
name|moea64_pte_overflow
operator|--
expr_stmt|;
name|rw_runlock
argument_list|(
operator|&
name|moea64_eviction_lock
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Invalidate the pte, briefly locking it to collect RC bits. No 	 * atomics needed since this is protected against eviction by the lock. 	 */
name|isync
argument_list|()
expr_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
name|pt
operator|->
name|pte_hi
operator|=
name|be64toh
argument_list|(
operator|(
name|pt
operator|->
name|pte_hi
operator|&
operator|~
name|LPTE_VALID
operator|)
operator||
name|LPTE_LOCKED
argument_list|)
expr_stmt|;
name|PTESYNC
argument_list|()
expr_stmt|;
name|TLBIE
argument_list|(
name|pvo
operator|->
name|pvo_vpn
argument_list|)
expr_stmt|;
name|ptelo
operator|=
name|be64toh
argument_list|(
name|pt
operator|->
name|pte_lo
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
specifier|volatile
name|int32_t
operator|*
operator|)
operator|(
operator|&
name|pt
operator|->
name|pte_hi
operator|)
operator|+
literal|1
operator|)
operator|=
literal|0
expr_stmt|;
comment|/* Release lock */
name|critical_exit
argument_list|()
expr_stmt|;
name|rw_runlock
argument_list|(
operator|&
name|moea64_eviction_lock
argument_list|)
expr_stmt|;
comment|/* Keep statistics */
name|moea64_pte_valid
operator|--
expr_stmt|;
return|return
operator|(
name|ptelo
operator|&
operator|(
name|LPTE_CHG
operator||
name|LPTE_REF
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int64_t
name|moea64_pte_replace_native
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|struct
name|pvo_entry
modifier|*
name|pvo
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
specifier|volatile
name|struct
name|lpte
modifier|*
name|pt
init|=
name|moea64_pteg_table
operator|+
name|pvo
operator|->
name|pvo_pte
operator|.
name|slot
decl_stmt|;
name|struct
name|lpte
name|properpt
decl_stmt|;
name|int64_t
name|ptelo
decl_stmt|;
if|if
condition|(
name|flags
operator|==
literal|0
condition|)
block|{
comment|/* Just some software bits changing. */
name|moea64_pte_from_pvo
argument_list|(
name|pvo
argument_list|,
operator|&
name|properpt
argument_list|)
expr_stmt|;
name|rw_rlock
argument_list|(
operator|&
name|moea64_eviction_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|be64toh
argument_list|(
name|pt
operator|->
name|pte_hi
argument_list|)
operator|&
name|LPTE_AVPN_MASK
operator|)
operator|!=
operator|(
name|properpt
operator|.
name|pte_hi
operator|&
name|LPTE_AVPN_MASK
operator|)
condition|)
block|{
name|rw_runlock
argument_list|(
operator|&
name|moea64_eviction_lock
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|pt
operator|->
name|pte_hi
operator|=
name|htobe64
argument_list|(
name|properpt
operator|.
name|pte_hi
argument_list|)
expr_stmt|;
name|ptelo
operator|=
name|be64toh
argument_list|(
name|pt
operator|->
name|pte_lo
argument_list|)
expr_stmt|;
name|rw_runlock
argument_list|(
operator|&
name|moea64_eviction_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise, need reinsertion and deletion */
name|ptelo
operator|=
name|moea64_pte_unset_native
argument_list|(
name|mmu
argument_list|,
name|pvo
argument_list|)
expr_stmt|;
name|moea64_pte_insert_native
argument_list|(
name|mmu
argument_list|,
name|pvo
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ptelo
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|moea64_cpu_bootstrap_native
parameter_list|(
name|mmu_t
name|mmup
parameter_list|,
name|int
name|ap
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|__powerpc64__
name|struct
name|slb
modifier|*
name|slb
init|=
name|PCPU_GET
argument_list|(
name|slb
argument_list|)
decl_stmt|;
name|register_t
name|seg0
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * Initialize segment registers and MMU 	 */
name|mtmsr
argument_list|(
name|mfmsr
argument_list|()
operator|&
operator|~
name|PSL_DR
operator|&
operator|~
name|PSL_IR
argument_list|)
expr_stmt|;
comment|/* 	 * Install kernel SLB entries 	 */
ifdef|#
directive|ifdef
name|__powerpc64__
asm|__asm __volatile ("slbia");
asm|__asm __volatile ("slbmfee %0,%1; slbie %0;" : "=r"(seg0) :
literal|"r"
operator|(
literal|0
operator|)
block|)
function|;
end_function

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|slb
index|[
name|i
index|]
operator|.
name|slbe
operator|&
name|SLBE_VALID
operator|)
condition|)
continue|continue;
asm|__asm __volatile ("slbmte %0, %1" ::
literal|"r"
operator|(
name|slb
index|[
name|i
index|]
operator|.
name|slbv
operator|)
operator|,
literal|"r"
operator|(
name|slb
index|[
name|i
index|]
operator|.
name|slbe
operator|)
block|)
empty_stmt|;
end_for

begin_else
unit|}
else|#
directive|else
end_else

begin_expr_stmt
unit|for
operator|(
name|i
operator|=
literal|0
expr|;
name|i
operator|<
literal|16
expr|;
name|i
operator|++
operator|)
name|mtsrin
argument_list|(
name|i
operator|<<
name|ADDR_SR_SHFT
argument_list|,
name|kernel_pmap
operator|->
name|pm_sr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* 	 * Install page table 	 */
end_comment

begin_asm
asm|__asm __volatile ("ptesync; mtsdr1 %0; isync"
end_asm

begin_expr_stmt
operator|::
literal|"r"
operator|(
operator|(
name|uintptr_t
operator|)
name|moea64_pteg_table
operator||
call|(
name|uintptr_t
call|)
argument_list|(
name|flsl
argument_list|(
name|moea64_pteg_mask
operator|>>
literal|11
argument_list|)
argument_list|)
operator|)
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|tlbia
argument_list|()
expr_stmt|;
end_expr_stmt

begin_function
unit|}  static
name|void
name|moea64_bootstrap_native
parameter_list|(
name|mmu_t
name|mmup
parameter_list|,
name|vm_offset_t
name|kernelstart
parameter_list|,
name|vm_offset_t
name|kernelend
parameter_list|)
block|{
name|vm_size_t
name|size
decl_stmt|;
name|vm_offset_t
name|off
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|register_t
name|msr
decl_stmt|;
name|moea64_early_bootstrap
argument_list|(
name|mmup
argument_list|,
name|kernelstart
argument_list|,
name|kernelend
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate PTEG table. 	 */
name|size
operator|=
name|moea64_pteg_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|lpteg
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"moea64_bootstrap: %d PTEGs, %d bytes"
argument_list|,
name|moea64_pteg_count
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|rw_init
argument_list|(
operator|&
name|moea64_eviction_lock
argument_list|,
literal|"pte eviction"
argument_list|)
expr_stmt|;
comment|/* 	 * We now need to allocate memory. This memory, to be allocated, 	 * has to reside in a page table. The page table we are about to 	 * allocate. We don't have BAT. So drop to data real mode for a minute 	 * as a measure of last resort. We do this a couple times. 	 */
name|moea64_pteg_table
operator|=
operator|(
expr|struct
name|lpte
operator|*
operator|)
name|moea64_bootstrap_alloc
argument_list|(
name|size
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|DISABLE_TRANS
argument_list|(
name|msr
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|__DEVOLATILE
argument_list|(
name|void
operator|*
argument_list|,
name|moea64_pteg_table
argument_list|)
argument_list|,
name|moea64_pteg_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|lpteg
argument_list|)
argument_list|)
expr_stmt|;
name|ENABLE_TRANS
argument_list|(
name|msr
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"moea64_bootstrap: PTEG table at %p"
argument_list|,
name|moea64_pteg_table
argument_list|)
expr_stmt|;
name|moea64_mid_bootstrap
argument_list|(
name|mmup
argument_list|,
name|kernelstart
argument_list|,
name|kernelend
argument_list|)
expr_stmt|;
comment|/* 	 * Add a mapping for the page table itself if there is no direct map. 	 */
if|if
condition|(
operator|!
name|hw_direct_map
condition|)
block|{
name|size
operator|=
name|moea64_pteg_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|lpteg
argument_list|)
expr_stmt|;
name|off
operator|=
call|(
name|vm_offset_t
call|)
argument_list|(
name|moea64_pteg_table
argument_list|)
expr_stmt|;
name|DISABLE_TRANS
argument_list|(
name|msr
argument_list|)
expr_stmt|;
for|for
control|(
name|pa
operator|=
name|off
init|;
name|pa
operator|<
name|off
operator|+
name|size
condition|;
name|pa
operator|+=
name|PAGE_SIZE
control|)
name|pmap_kenter
argument_list|(
name|pa
argument_list|,
name|pa
argument_list|)
expr_stmt|;
name|ENABLE_TRANS
argument_list|(
name|msr
argument_list|)
expr_stmt|;
block|}
comment|/* Bring up virtual memory */
name|moea64_late_bootstrap
argument_list|(
name|mmup
argument_list|,
name|kernelstart
argument_list|,
name|kernelend
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tlbia
parameter_list|(
name|void
parameter_list|)
block|{
name|vm_offset_t
name|i
decl_stmt|;
ifndef|#
directive|ifndef
name|__powerpc64__
name|register_t
name|msr
decl_stmt|,
name|scratch
decl_stmt|;
endif|#
directive|endif
name|TLBSYNC
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0xFF000
condition|;
name|i
operator|+=
literal|0x00001000
control|)
block|{
ifdef|#
directive|ifdef
name|__powerpc64__
asm|__asm __volatile("tlbiel %0" :: "r"(i));
else|#
directive|else
asm|__asm __volatile("\ 		    mfmsr %0; \ 		    mr %1, %0; \ 		    insrdi %1,%3,1,0; \ 		    mtmsrd %1; \ 		    isync; \ 		    \ 		    tlbiel %2; \ 		    \ 		    mtmsrd %0; \ 		    isync;"
block|:
literal|"=r"
operator|(
name|msr
operator|)
operator|,
literal|"=r"
operator|(
name|scratch
operator|)
operator|:
literal|"r"
operator|(
name|i
operator|)
operator|,
literal|"r"
operator|(
literal|1
operator|)
block|)
empty_stmt|;
endif|#
directive|endif
block|}
end_function

begin_expr_stmt
name|EIEIO
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TLBSYNC
argument_list|()
expr_stmt|;
end_expr_stmt

begin_function
unit|}  static
name|int
name|atomic_pte_lock
parameter_list|(
specifier|volatile
name|struct
name|lpte
modifier|*
name|pte
parameter_list|,
name|uint64_t
name|bitmask
parameter_list|,
name|uint64_t
modifier|*
name|oldhi
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|uint32_t
name|oldhihalf
decl_stmt|;
comment|/* 	 * Note: in principle, if just the locked bit were set here, we 	 * could avoid needing the eviction lock. However, eviction occurs 	 * so rarely that it isn't worth bothering about in practice. 	 */
asm|__asm __volatile (
literal|"1:\tlwarx %1, 0, %3\n\t"
comment|/* load old value */
literal|"and. %0,%1,%4\n\t"
comment|/* check if any bits set */
literal|"bne 2f\n\t"
comment|/* exit if any set */
literal|"stwcx. %5, 0, %3\n\t"
comment|/* attempt to store */
literal|"bne- 1b\n\t"
comment|/* spin if failed */
literal|"li %0, 1\n\t"
comment|/* success - retval = 1 */
literal|"b 3f\n\t"
comment|/* we've succeeded */
literal|"2:\n\t"
literal|"stwcx. %1, 0, %3\n\t"
comment|/* clear reservation (74xx) */
literal|"li %0, 0\n\t"
comment|/* failure - retval = 0 */
literal|"3:\n\t"
operator|:
literal|"=&r"
operator|(
name|ret
operator|)
operator|,
literal|"=&r"
operator|(
name|oldhihalf
operator|)
operator|,
literal|"=m"
operator|(
name|pte
operator|->
name|pte_hi
operator|)
operator|:
literal|"r"
operator|(
operator|(
specifier|volatile
name|char
operator|*
operator|)
operator|&
name|pte
operator|->
name|pte_hi
operator|+
literal|4
operator|)
operator|,
literal|"r"
operator|(
operator|(
name|uint32_t
operator|)
name|bitmask
operator|)
operator|,
literal|"r"
operator|(
operator|(
name|uint32_t
operator|)
name|LPTE_LOCKED
operator|)
operator|,
literal|"m"
operator|(
name|pte
operator|->
name|pte_hi
operator|)
operator|:
literal|"cr0"
operator|,
literal|"cr1"
operator|,
literal|"cr2"
operator|,
literal|"memory"
block|)
function|;
end_function

begin_expr_stmt
operator|*
name|oldhi
operator|=
operator|(
name|pte
operator|->
name|pte_hi
operator|&
literal|0xffffffff00000000ULL
operator|)
operator||
name|oldhihalf
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|ret
operator|)
return|;
end_return

begin_function
unit|}  static
name|uintptr_t
name|moea64_insert_to_pteg_native
parameter_list|(
name|struct
name|lpte
modifier|*
name|pvo_pt
parameter_list|,
name|uintptr_t
name|slotbase
parameter_list|,
name|uint64_t
name|mask
parameter_list|)
block|{
specifier|volatile
name|struct
name|lpte
modifier|*
name|pt
decl_stmt|;
name|uint64_t
name|oldptehi
decl_stmt|,
name|va
decl_stmt|;
name|uintptr_t
name|k
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* Start at a random slot */
name|i
operator|=
name|mftb
argument_list|()
operator|%
literal|8
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
block|{
name|k
operator|=
name|slotbase
operator|+
operator|(
name|i
operator|+
name|j
operator|)
operator|%
literal|8
expr_stmt|;
name|pt
operator|=
operator|&
name|moea64_pteg_table
index|[
name|k
index|]
expr_stmt|;
comment|/* Invalidate and seize lock only if no bits in mask set */
if|if
condition|(
name|atomic_pte_lock
argument_list|(
name|pt
argument_list|,
name|mask
argument_list|,
operator|&
name|oldptehi
argument_list|)
condition|)
comment|/* Lock obtained */
break|break;
block|}
if|if
condition|(
name|j
operator|==
literal|8
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|oldptehi
operator|&
name|LPTE_VALID
condition|)
block|{
name|KASSERT
argument_list|(
operator|!
operator|(
name|oldptehi
operator|&
name|LPTE_WIRED
operator|)
argument_list|,
operator|(
literal|"Unmapped wired entry"
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Need to invalidate old entry completely: see 		 * "Modifying a Page Table Entry". Need to reconstruct 		 * the virtual address for the outgoing entry to do that. 		 */
if|if
condition|(
name|oldptehi
operator|&
name|LPTE_BIG
condition|)
name|va
operator|=
name|oldptehi
operator|>>
name|moea64_large_page_shift
expr_stmt|;
else|else
name|va
operator|=
name|oldptehi
operator|>>
name|ADDR_PIDX_SHFT
expr_stmt|;
if|if
condition|(
name|oldptehi
operator|&
name|LPTE_HID
condition|)
name|va
operator|=
operator|(
operator|(
operator|(
name|k
operator|>>
literal|3
operator|)
operator|^
name|moea64_pteg_mask
operator|)
operator|^
name|va
operator|)
operator|&
name|VSID_HASH_MASK
expr_stmt|;
else|else
name|va
operator|=
operator|(
operator|(
name|k
operator|>>
literal|3
operator|)
operator|^
name|va
operator|)
operator|&
name|VSID_HASH_MASK
expr_stmt|;
name|va
operator||=
operator|(
name|oldptehi
operator|&
name|LPTE_AVPN_MASK
operator|)
operator|<<
operator|(
name|ADDR_API_SHFT64
operator|-
name|ADDR_PIDX_SHFT
operator|)
expr_stmt|;
name|PTESYNC
argument_list|()
expr_stmt|;
name|TLBIE
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|moea64_pte_valid
operator|--
expr_stmt|;
name|moea64_pte_overflow
operator|++
expr_stmt|;
block|}
comment|/* 	 * Update the PTE as per "Adding a Page Table Entry". Lock is released 	 * by setting the high doubleworld. 	 */
name|pt
operator|->
name|pte_lo
operator|=
name|htobe64
argument_list|(
name|pvo_pt
operator|->
name|pte_lo
argument_list|)
expr_stmt|;
name|EIEIO
argument_list|()
expr_stmt|;
name|pt
operator|->
name|pte_hi
operator|=
name|htobe64
argument_list|(
name|pvo_pt
operator|->
name|pte_hi
argument_list|)
expr_stmt|;
name|PTESYNC
argument_list|()
expr_stmt|;
comment|/* Keep statistics */
name|moea64_pte_valid
operator|++
expr_stmt|;
return|return
operator|(
name|k
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|moea64_pte_insert_native
parameter_list|(
name|mmu_t
name|mmu
parameter_list|,
name|struct
name|pvo_entry
modifier|*
name|pvo
parameter_list|)
block|{
name|struct
name|lpte
name|insertpt
decl_stmt|;
name|uintptr_t
name|slot
decl_stmt|;
comment|/* Initialize PTE */
name|moea64_pte_from_pvo
argument_list|(
name|pvo
argument_list|,
operator|&
name|insertpt
argument_list|)
expr_stmt|;
comment|/* Make sure further insertion is locked out during evictions */
name|rw_rlock
argument_list|(
operator|&
name|moea64_eviction_lock
argument_list|)
expr_stmt|;
comment|/* 	 * First try primary hash. 	 */
name|pvo
operator|->
name|pvo_pte
operator|.
name|slot
operator|&=
operator|~
literal|7ULL
expr_stmt|;
comment|/* Base slot address */
name|slot
operator|=
name|moea64_insert_to_pteg_native
argument_list|(
operator|&
name|insertpt
argument_list|,
name|pvo
operator|->
name|pvo_pte
operator|.
name|slot
argument_list|,
name|LPTE_VALID
operator||
name|LPTE_WIRED
operator||
name|LPTE_LOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|!=
operator|-
literal|1
condition|)
block|{
name|rw_runlock
argument_list|(
operator|&
name|moea64_eviction_lock
argument_list|)
expr_stmt|;
name|pvo
operator|->
name|pvo_pte
operator|.
name|slot
operator|=
name|slot
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Now try secondary hash. 	 */
name|pvo
operator|->
name|pvo_vaddr
operator|^=
name|PVO_HID
expr_stmt|;
name|insertpt
operator|.
name|pte_hi
operator|^=
name|LPTE_HID
expr_stmt|;
name|pvo
operator|->
name|pvo_pte
operator|.
name|slot
operator|^=
operator|(
name|moea64_pteg_mask
operator|<<
literal|3
operator|)
expr_stmt|;
name|slot
operator|=
name|moea64_insert_to_pteg_native
argument_list|(
operator|&
name|insertpt
argument_list|,
name|pvo
operator|->
name|pvo_pte
operator|.
name|slot
argument_list|,
name|LPTE_VALID
operator||
name|LPTE_WIRED
operator||
name|LPTE_LOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|!=
operator|-
literal|1
condition|)
block|{
name|rw_runlock
argument_list|(
operator|&
name|moea64_eviction_lock
argument_list|)
expr_stmt|;
name|pvo
operator|->
name|pvo_pte
operator|.
name|slot
operator|=
name|slot
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Out of luck. Find a PTE to sacrifice. 	 */
comment|/* Lock out all insertions for a bit */
if|if
condition|(
operator|!
name|rw_try_upgrade
argument_list|(
operator|&
name|moea64_eviction_lock
argument_list|)
condition|)
block|{
name|rw_runlock
argument_list|(
operator|&
name|moea64_eviction_lock
argument_list|)
expr_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|moea64_eviction_lock
argument_list|)
expr_stmt|;
block|}
name|slot
operator|=
name|moea64_insert_to_pteg_native
argument_list|(
operator|&
name|insertpt
argument_list|,
name|pvo
operator|->
name|pvo_pte
operator|.
name|slot
argument_list|,
name|LPTE_WIRED
operator||
name|LPTE_LOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|!=
operator|-
literal|1
condition|)
block|{
name|rw_wunlock
argument_list|(
operator|&
name|moea64_eviction_lock
argument_list|)
expr_stmt|;
name|pvo
operator|->
name|pvo_pte
operator|.
name|slot
operator|=
name|slot
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Try other hash table. Now we're getting desperate... */
name|pvo
operator|->
name|pvo_vaddr
operator|^=
name|PVO_HID
expr_stmt|;
name|insertpt
operator|.
name|pte_hi
operator|^=
name|LPTE_HID
expr_stmt|;
name|pvo
operator|->
name|pvo_pte
operator|.
name|slot
operator|^=
operator|(
name|moea64_pteg_mask
operator|<<
literal|3
operator|)
expr_stmt|;
name|slot
operator|=
name|moea64_insert_to_pteg_native
argument_list|(
operator|&
name|insertpt
argument_list|,
name|pvo
operator|->
name|pvo_pte
operator|.
name|slot
argument_list|,
name|LPTE_WIRED
operator||
name|LPTE_LOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|!=
operator|-
literal|1
condition|)
block|{
name|rw_wunlock
argument_list|(
operator|&
name|moea64_eviction_lock
argument_list|)
expr_stmt|;
name|pvo
operator|->
name|pvo_pte
operator|.
name|slot
operator|=
name|slot
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* No freeable slots in either PTEG? We're hosed. */
name|rw_wunlock
argument_list|(
operator|&
name|moea64_eviction_lock
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"moea64_pte_insert: overflow"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

end_unit

