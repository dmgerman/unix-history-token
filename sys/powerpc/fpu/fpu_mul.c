begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: fpu_mul.c,v 1.4 2005/12/11 12:18:42 christos Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This software was developed by the Computer Systems Engineering group  * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and  * contributed to Berkeley.  *  * All advertising materials mentioning features or use of this software  * must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Lawrence Berkeley Laboratory.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)fpu_mul.c	8.1 (Berkeley) 6/11/93  */
end_comment

begin_comment
comment|/*  * Perform an FPU multiply (return x * y).  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<machine/fpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_include
include|#
directive|include
file|<powerpc/fpu/fpu_arith.h>
end_include

begin_include
include|#
directive|include
file|<powerpc/fpu/fpu_emu.h>
end_include

begin_comment
comment|/*  * The multiplication algorithm for normal numbers is as follows:  *  * The fraction of the product is built in the usual stepwise fashion.  * Each step consists of shifting the accumulator right one bit  * (maintaining any guard bits) and, if the next bit in y is set,  * adding the multiplicand (x) to the accumulator.  Then, in any case,  * we advance one bit leftward in y.  Algorithmically:  *  *	A = 0;  *	for (bit = 0; bit< FP_NMANT; bit++) {  *		sticky |= A& 1, A>>= 1;  *		if (Y& (1<< bit))  *			A += X;  *	}  *  * (X and Y here represent the mantissas of x and y respectively.)  * The resultant accumulator (A) is the product's mantissa.  It may  * be as large as 11.11111... in binary and hence may need to be  * shifted right, but at most one bit.  *  * Since we do not have efficient multiword arithmetic, we code the  * accumulator as four separate words, just like any other mantissa.  * We use local variables in the hope that this is faster than memory.  * We keep x->fp_mant in locals for the same reason.  *  * In the algorithm above, the bits in y are inspected one at a time.  * We will pick them up 32 at a time and then deal with those 32, one  * at a time.  Note, however, that we know several things about y:  *  *    - the guard and round bits at the bottom are sure to be zero;  *  *    - often many low bits are zero (y is often from a single or double  *	precision source);  *  *    - bit FP_NMANT-1 is set, and FP_1*2 fits in a word.  *  * We can also test for 32-zero-bits swiftly.  In this case, the center  * part of the loop---setting sticky, shifting A, and not adding---will  * run 32 times without adding X to A.  We can do a 32-bit shift faster  * by simply moving words.  Since zeros are common, we optimize this case.  * Furthermore, since A is initially zero, we can omit the shift as well  * until we reach a nonzero word.  */
end_comment

begin_function
name|struct
name|fpn
modifier|*
name|fpu_mul
parameter_list|(
name|struct
name|fpemu
modifier|*
name|fe
parameter_list|)
block|{
name|struct
name|fpn
modifier|*
name|x
init|=
operator|&
name|fe
operator|->
name|fe_f1
decl_stmt|,
modifier|*
name|y
init|=
operator|&
name|fe
operator|->
name|fe_f2
decl_stmt|;
name|u_int
name|a3
decl_stmt|,
name|a2
decl_stmt|,
name|a1
decl_stmt|,
name|a0
decl_stmt|,
name|x3
decl_stmt|,
name|x2
decl_stmt|,
name|x1
decl_stmt|,
name|x0
decl_stmt|,
name|bit
decl_stmt|,
name|m
decl_stmt|;
name|int
name|sticky
decl_stmt|;
name|FPU_DECL_CARRY
expr_stmt|;
comment|/* 	 * Put the `heavier' operand on the right (see fpu_emu.h). 	 * Then we will have one of the following cases, taken in the 	 * following order: 	 * 	 *  - y = NaN.  Implied: if only one is a signalling NaN, y is. 	 *	The result is y. 	 *  - y = Inf.  Implied: x != NaN (is 0, number, or Inf: the NaN 	 *    case was taken care of earlier). 	 *	If x = 0, the result is NaN.  Otherwise the result 	 *	is y, with its sign reversed if x is negative. 	 *  - x = 0.  Implied: y is 0 or number. 	 *	The result is 0 (with XORed sign as usual). 	 *  - other.  Implied: both x and y are numbers. 	 *	The result is x * y (XOR sign, multiply bits, add exponents). 	 */
name|DPRINTF
argument_list|(
name|FPE_REG
argument_list|,
operator|(
literal|"fpu_mul:\n"
operator|)
argument_list|)
expr_stmt|;
name|DUMPFPN
argument_list|(
name|FPE_REG
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|DUMPFPN
argument_list|(
name|FPE_REG
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|FPE_REG
argument_list|,
operator|(
literal|"=>\n"
operator|)
argument_list|)
expr_stmt|;
name|ORDER
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISNAN
argument_list|(
name|y
argument_list|)
condition|)
block|{
name|y
operator|->
name|fp_sign
operator|^=
name|x
operator|->
name|fp_sign
expr_stmt|;
name|fe
operator|->
name|fe_cx
operator||=
name|FPSCR_VXSNAN
expr_stmt|;
name|DUMPFPN
argument_list|(
name|FPE_REG
argument_list|,
name|y
argument_list|)
expr_stmt|;
return|return
operator|(
name|y
operator|)
return|;
block|}
if|if
condition|(
name|ISINF
argument_list|(
name|y
argument_list|)
condition|)
block|{
if|if
condition|(
name|ISZERO
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|fe
operator|->
name|fe_cx
operator||=
name|FPSCR_VXIMZ
expr_stmt|;
return|return
operator|(
name|fpu_newnan
argument_list|(
name|fe
argument_list|)
operator|)
return|;
block|}
name|y
operator|->
name|fp_sign
operator|^=
name|x
operator|->
name|fp_sign
expr_stmt|;
name|DUMPFPN
argument_list|(
name|FPE_REG
argument_list|,
name|y
argument_list|)
expr_stmt|;
return|return
operator|(
name|y
operator|)
return|;
block|}
if|if
condition|(
name|ISZERO
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|x
operator|->
name|fp_sign
operator|^=
name|y
operator|->
name|fp_sign
expr_stmt|;
name|DUMPFPN
argument_list|(
name|FPE_REG
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
comment|/* 	 * Setup.  In the code below, the mask `m' will hold the current 	 * mantissa byte from y.  The variable `bit' denotes the bit 	 * within m.  We also define some macros to deal with everything. 	 */
name|x3
operator|=
name|x
operator|->
name|fp_mant
index|[
literal|3
index|]
expr_stmt|;
name|x2
operator|=
name|x
operator|->
name|fp_mant
index|[
literal|2
index|]
expr_stmt|;
name|x1
operator|=
name|x
operator|->
name|fp_mant
index|[
literal|1
index|]
expr_stmt|;
name|x0
operator|=
name|x
operator|->
name|fp_mant
index|[
literal|0
index|]
expr_stmt|;
name|sticky
operator|=
name|a3
operator|=
name|a2
operator|=
name|a1
operator|=
name|a0
operator|=
literal|0
expr_stmt|;
define|#
directive|define
name|ADD
comment|/* A += X */
define|\
value|FPU_ADDS(a3, a3, x3); \ 	FPU_ADDCS(a2, a2, x2); \ 	FPU_ADDCS(a1, a1, x1); \ 	FPU_ADDC(a0, a0, x0)
define|#
directive|define
name|SHR1
comment|/* A>>= 1, with sticky */
define|\
value|sticky |= a3& 1, a3 = (a3>> 1) | (a2<< 31), \ 	a2 = (a2>> 1) | (a1<< 31), a1 = (a1>> 1) | (a0<< 31), a0>>= 1
define|#
directive|define
name|SHR32
comment|/* A>>= 32, with sticky */
define|\
value|sticky |= a3, a3 = a2, a2 = a1, a1 = a0, a0 = 0
define|#
directive|define
name|STEP
comment|/* each 1-bit step of the multiplication */
define|\
value|SHR1; if (bit& m) { ADD; }; bit<<= 1
comment|/* 	 * We are ready to begin.  The multiply loop runs once for each 	 * of the four 32-bit words.  Some words, however, are special. 	 * As noted above, the low order bits of Y are often zero.  Even 	 * if not, the first loop can certainly skip the guard bits. 	 * The last word of y has its highest 1-bit in position FP_NMANT-1, 	 * so we stop the loop when we move past that bit. 	 */
if|if
condition|(
operator|(
name|m
operator|=
name|y
operator|->
name|fp_mant
index|[
literal|3
index|]
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* SHR32; */
comment|/* unneeded since A==0 */
block|}
else|else
block|{
name|bit
operator|=
literal|1
operator|<<
name|FP_NG
expr_stmt|;
do|do
block|{
name|STEP
expr_stmt|;
block|}
do|while
condition|(
name|bit
operator|!=
literal|0
condition|)
do|;
block|}
if|if
condition|(
operator|(
name|m
operator|=
name|y
operator|->
name|fp_mant
index|[
literal|2
index|]
operator|)
operator|==
literal|0
condition|)
block|{
name|SHR32
expr_stmt|;
block|}
else|else
block|{
name|bit
operator|=
literal|1
expr_stmt|;
do|do
block|{
name|STEP
expr_stmt|;
block|}
do|while
condition|(
name|bit
operator|!=
literal|0
condition|)
do|;
block|}
if|if
condition|(
operator|(
name|m
operator|=
name|y
operator|->
name|fp_mant
index|[
literal|1
index|]
operator|)
operator|==
literal|0
condition|)
block|{
name|SHR32
expr_stmt|;
block|}
else|else
block|{
name|bit
operator|=
literal|1
expr_stmt|;
do|do
block|{
name|STEP
expr_stmt|;
block|}
do|while
condition|(
name|bit
operator|!=
literal|0
condition|)
do|;
block|}
name|m
operator|=
name|y
operator|->
name|fp_mant
index|[
literal|0
index|]
expr_stmt|;
comment|/* definitely != 0 */
name|bit
operator|=
literal|1
expr_stmt|;
do|do
block|{
name|STEP
expr_stmt|;
block|}
do|while
condition|(
name|bit
operator|<=
name|m
condition|)
do|;
comment|/* 	 * Done with mantissa calculation.  Get exponent and handle 	 * 11.111...1 case, then put result in place.  We reuse x since 	 * it already has the right class (FP_NUM). 	 */
name|m
operator|=
name|x
operator|->
name|fp_exp
operator|+
name|y
operator|->
name|fp_exp
expr_stmt|;
if|if
condition|(
name|a0
operator|>=
name|FP_2
condition|)
block|{
name|SHR1
expr_stmt|;
name|m
operator|++
expr_stmt|;
block|}
name|x
operator|->
name|fp_sign
operator|^=
name|y
operator|->
name|fp_sign
expr_stmt|;
name|x
operator|->
name|fp_exp
operator|=
name|m
expr_stmt|;
name|x
operator|->
name|fp_sticky
operator|=
name|sticky
expr_stmt|;
name|x
operator|->
name|fp_mant
index|[
literal|3
index|]
operator|=
name|a3
expr_stmt|;
name|x
operator|->
name|fp_mant
index|[
literal|2
index|]
operator|=
name|a2
expr_stmt|;
name|x
operator|->
name|fp_mant
index|[
literal|1
index|]
operator|=
name|a1
expr_stmt|;
name|x
operator|->
name|fp_mant
index|[
literal|0
index|]
operator|=
name|a0
expr_stmt|;
name|DUMPFPN
argument_list|(
name|FPE_REG
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

end_unit

