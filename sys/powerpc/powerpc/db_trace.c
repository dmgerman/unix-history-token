begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$FreeBSD$ */
end_comment

begin_comment
comment|/*	$NetBSD: db_trace.c,v 1.20 2002/05/13 20:30:09 matt Exp $	*/
end_comment

begin_comment
comment|/*	$OpenBSD: db_trace.c,v 1.3 1997/03/21 02:10:48 niklas Exp $	*/
end_comment

begin_comment
comment|/*-  * Mach Operating System  * Copyright (c) 1992 Carnegie Mellon University  * All Rights Reserved.  *  * Permission to use, copy, modify and distribute this software and its  * documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR  * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie Mellon  * the rights to redistribute these changes.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/stack.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<machine/db_machdep.h>
end_include

begin_include
include|#
directive|include
file|<machine/pcb.h>
end_include

begin_include
include|#
directive|include
file|<machine/spr.h>
end_include

begin_include
include|#
directive|include
file|<machine/trap.h>
end_include

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_include
include|#
directive|include
file|<ddb/db_access.h>
end_include

begin_include
include|#
directive|include
file|<ddb/db_sym.h>
end_include

begin_include
include|#
directive|include
file|<ddb/db_variables.h>
end_include

begin_decl_stmt
specifier|static
name|db_varfcn_t
name|db_frame
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DB_OFFSET
parameter_list|(
name|x
parameter_list|)
value|(db_expr_t *)offsetof(struct trapframe, x)
end_define

begin_decl_stmt
name|struct
name|db_variable
name|db_regs
index|[]
init|=
block|{
block|{
literal|"r0"
block|,
name|DB_OFFSET
argument_list|(
name|fixreg
index|[
literal|0
index|]
argument_list|)
block|,
name|db_frame
block|}
block|,
block|{
literal|"r1"
block|,
name|DB_OFFSET
argument_list|(
name|fixreg
index|[
literal|1
index|]
argument_list|)
block|,
name|db_frame
block|}
block|,
block|{
literal|"r2"
block|,
name|DB_OFFSET
argument_list|(
name|fixreg
index|[
literal|2
index|]
argument_list|)
block|,
name|db_frame
block|}
block|,
block|{
literal|"r3"
block|,
name|DB_OFFSET
argument_list|(
name|fixreg
index|[
literal|3
index|]
argument_list|)
block|,
name|db_frame
block|}
block|,
block|{
literal|"r4"
block|,
name|DB_OFFSET
argument_list|(
name|fixreg
index|[
literal|4
index|]
argument_list|)
block|,
name|db_frame
block|}
block|,
block|{
literal|"r5"
block|,
name|DB_OFFSET
argument_list|(
name|fixreg
index|[
literal|5
index|]
argument_list|)
block|,
name|db_frame
block|}
block|,
block|{
literal|"r6"
block|,
name|DB_OFFSET
argument_list|(
name|fixreg
index|[
literal|6
index|]
argument_list|)
block|,
name|db_frame
block|}
block|,
block|{
literal|"r7"
block|,
name|DB_OFFSET
argument_list|(
name|fixreg
index|[
literal|7
index|]
argument_list|)
block|,
name|db_frame
block|}
block|,
block|{
literal|"r8"
block|,
name|DB_OFFSET
argument_list|(
name|fixreg
index|[
literal|8
index|]
argument_list|)
block|,
name|db_frame
block|}
block|,
block|{
literal|"r9"
block|,
name|DB_OFFSET
argument_list|(
name|fixreg
index|[
literal|9
index|]
argument_list|)
block|,
name|db_frame
block|}
block|,
block|{
literal|"r10"
block|,
name|DB_OFFSET
argument_list|(
name|fixreg
index|[
literal|10
index|]
argument_list|)
block|,
name|db_frame
block|}
block|,
block|{
literal|"r11"
block|,
name|DB_OFFSET
argument_list|(
name|fixreg
index|[
literal|11
index|]
argument_list|)
block|,
name|db_frame
block|}
block|,
block|{
literal|"r12"
block|,
name|DB_OFFSET
argument_list|(
name|fixreg
index|[
literal|12
index|]
argument_list|)
block|,
name|db_frame
block|}
block|,
block|{
literal|"r13"
block|,
name|DB_OFFSET
argument_list|(
name|fixreg
index|[
literal|13
index|]
argument_list|)
block|,
name|db_frame
block|}
block|,
block|{
literal|"r14"
block|,
name|DB_OFFSET
argument_list|(
name|fixreg
index|[
literal|14
index|]
argument_list|)
block|,
name|db_frame
block|}
block|,
block|{
literal|"r15"
block|,
name|DB_OFFSET
argument_list|(
name|fixreg
index|[
literal|15
index|]
argument_list|)
block|,
name|db_frame
block|}
block|,
block|{
literal|"r16"
block|,
name|DB_OFFSET
argument_list|(
name|fixreg
index|[
literal|16
index|]
argument_list|)
block|,
name|db_frame
block|}
block|,
block|{
literal|"r17"
block|,
name|DB_OFFSET
argument_list|(
name|fixreg
index|[
literal|17
index|]
argument_list|)
block|,
name|db_frame
block|}
block|,
block|{
literal|"r18"
block|,
name|DB_OFFSET
argument_list|(
name|fixreg
index|[
literal|18
index|]
argument_list|)
block|,
name|db_frame
block|}
block|,
block|{
literal|"r19"
block|,
name|DB_OFFSET
argument_list|(
name|fixreg
index|[
literal|19
index|]
argument_list|)
block|,
name|db_frame
block|}
block|,
block|{
literal|"r20"
block|,
name|DB_OFFSET
argument_list|(
name|fixreg
index|[
literal|20
index|]
argument_list|)
block|,
name|db_frame
block|}
block|,
block|{
literal|"r21"
block|,
name|DB_OFFSET
argument_list|(
name|fixreg
index|[
literal|21
index|]
argument_list|)
block|,
name|db_frame
block|}
block|,
block|{
literal|"r22"
block|,
name|DB_OFFSET
argument_list|(
name|fixreg
index|[
literal|22
index|]
argument_list|)
block|,
name|db_frame
block|}
block|,
block|{
literal|"r23"
block|,
name|DB_OFFSET
argument_list|(
name|fixreg
index|[
literal|23
index|]
argument_list|)
block|,
name|db_frame
block|}
block|,
block|{
literal|"r24"
block|,
name|DB_OFFSET
argument_list|(
name|fixreg
index|[
literal|24
index|]
argument_list|)
block|,
name|db_frame
block|}
block|,
block|{
literal|"r25"
block|,
name|DB_OFFSET
argument_list|(
name|fixreg
index|[
literal|25
index|]
argument_list|)
block|,
name|db_frame
block|}
block|,
block|{
literal|"r26"
block|,
name|DB_OFFSET
argument_list|(
name|fixreg
index|[
literal|26
index|]
argument_list|)
block|,
name|db_frame
block|}
block|,
block|{
literal|"r27"
block|,
name|DB_OFFSET
argument_list|(
name|fixreg
index|[
literal|27
index|]
argument_list|)
block|,
name|db_frame
block|}
block|,
block|{
literal|"r28"
block|,
name|DB_OFFSET
argument_list|(
name|fixreg
index|[
literal|28
index|]
argument_list|)
block|,
name|db_frame
block|}
block|,
block|{
literal|"r29"
block|,
name|DB_OFFSET
argument_list|(
name|fixreg
index|[
literal|29
index|]
argument_list|)
block|,
name|db_frame
block|}
block|,
block|{
literal|"r30"
block|,
name|DB_OFFSET
argument_list|(
name|fixreg
index|[
literal|30
index|]
argument_list|)
block|,
name|db_frame
block|}
block|,
block|{
literal|"r31"
block|,
name|DB_OFFSET
argument_list|(
name|fixreg
index|[
literal|31
index|]
argument_list|)
block|,
name|db_frame
block|}
block|,
block|{
literal|"srr0"
block|,
name|DB_OFFSET
argument_list|(
name|srr0
argument_list|)
block|,
name|db_frame
block|}
block|,
block|{
literal|"srr1"
block|,
name|DB_OFFSET
argument_list|(
name|srr1
argument_list|)
block|,
name|db_frame
block|}
block|,
block|{
literal|"lr"
block|,
name|DB_OFFSET
argument_list|(
name|lr
argument_list|)
block|,
name|db_frame
block|}
block|,
block|{
literal|"ctr"
block|,
name|DB_OFFSET
argument_list|(
name|ctr
argument_list|)
block|,
name|db_frame
block|}
block|,
block|{
literal|"cr"
block|,
name|DB_OFFSET
argument_list|(
name|cr
argument_list|)
block|,
name|db_frame
block|}
block|,
block|{
literal|"xer"
block|,
name|DB_OFFSET
argument_list|(
name|xer
argument_list|)
block|,
name|db_frame
block|}
block|,
block|{
literal|"dar"
block|,
name|DB_OFFSET
argument_list|(
name|dar
argument_list|)
block|,
name|db_frame
block|}
block|,
block|{
literal|"dsisr"
block|,
name|DB_OFFSET
argument_list|(
name|dsisr
argument_list|)
block|,
name|db_frame
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|db_variable
modifier|*
name|db_eregs
init|=
name|db_regs
operator|+
sizeof|sizeof
argument_list|(
name|db_regs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|db_regs
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|trapexit
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|end
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * register variable handling  */
end_comment

begin_function
specifier|static
name|int
name|db_frame
parameter_list|(
name|struct
name|db_variable
modifier|*
name|vp
parameter_list|,
name|db_expr_t
modifier|*
name|valuep
parameter_list|,
name|int
name|op
parameter_list|)
block|{
name|uint32_t
modifier|*
name|reg
decl_stmt|;
if|if
condition|(
name|kdb_frame
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|reg
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|kdb_frame
operator|+
operator|(
name|uintptr_t
operator|)
name|vp
operator|->
name|valuep
operator|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|DB_VAR_GET
condition|)
operator|*
name|valuep
operator|=
operator|*
name|reg
expr_stmt|;
else|else
operator|*
name|reg
operator|=
operator|*
name|valuep
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Frame tracing.  */
end_comment

begin_function
specifier|static
name|int
name|db_backtrace
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|db_addr_t
name|fp
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|db_addr_t
name|stackframe
decl_stmt|,
name|lr
decl_stmt|,
modifier|*
name|args
decl_stmt|;
name|db_expr_t
name|diff
decl_stmt|;
name|c_db_sym_t
name|sym
decl_stmt|;
specifier|const
name|char
modifier|*
name|symname
decl_stmt|;
name|boolean_t
name|kernel_only
init|=
name|TRUE
decl_stmt|;
name|boolean_t
name|full
init|=
name|FALSE
decl_stmt|;
name|int
name|quit
decl_stmt|;
if|#
directive|if
literal|0
block|{ 		register char *cp = modif; 		register char c;  		while ((c = *cp++) != 0) { 			if (c == 't') 				trace_thread = TRUE; 			if (c == 'u') 				kernel_only = FALSE; 			if (c == 'f') 				full = TRUE; 		} 	}
endif|#
directive|endif
name|stackframe
operator|=
name|fp
expr_stmt|;
name|quit
operator|=
literal|0
expr_stmt|;
name|db_setup_paging
argument_list|(
name|db_simple_pager
argument_list|,
operator|&
name|quit
argument_list|,
name|db_lines_per_page
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|quit
condition|)
block|{
if|if
condition|(
name|stackframe
operator|<
name|PAGE_SIZE
condition|)
break|break;
comment|/* 		 * Locate the next frame by grabbing the backchain ptr 		 * from frame[0] 		 */
name|stackframe
operator|=
operator|*
operator|(
name|db_addr_t
operator|*
operator|)
name|stackframe
expr_stmt|;
name|next_frame
label|:
comment|/* The saved arg values start at frame[2] */
name|args
operator|=
operator|(
name|db_addr_t
operator|*
operator|)
operator|(
name|stackframe
operator|+
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|stackframe
operator|<
name|PAGE_SIZE
condition|)
break|break;
if|if
condition|(
name|count
operator|--
operator|==
literal|0
condition|)
break|break;
comment|/* 		 * Extract link register from frame and subtract 		 * 4 to convert into calling address (as opposed to 		 * return address) 		 */
name|lr
operator|=
operator|*
operator|(
name|db_addr_t
operator|*
operator|)
operator|(
name|stackframe
operator|+
literal|4
operator|)
operator|-
literal|4
expr_stmt|;
if|if
condition|(
operator|(
name|lr
operator|&
literal|3
operator|)
operator|||
operator|(
name|lr
operator|<
literal|0x100
operator|)
condition|)
block|{
name|db_printf
argument_list|(
literal|"saved LR(0x%x) is invalid."
argument_list|,
name|lr
argument_list|)
expr_stmt|;
break|break;
block|}
name|db_printf
argument_list|(
literal|"0x%08x: "
argument_list|,
name|stackframe
argument_list|)
expr_stmt|;
comment|/* 		 * The trap code labels the return address from the 		 * call to C code as 'trapexit'. Use this to determine 		 * if the callframe has to traverse a saved trap context 		 */
if|if
condition|(
name|lr
operator|+
literal|4
operator|==
operator|(
name|db_addr_t
operator|)
operator|&
name|trapexit
condition|)
block|{
specifier|const
name|char
modifier|*
name|trapstr
decl_stmt|;
name|struct
name|trapframe
modifier|*
name|tf
init|=
operator|(
expr|struct
name|trapframe
operator|*
operator|)
operator|(
name|stackframe
operator|+
literal|8
operator|)
decl_stmt|;
name|db_printf
argument_list|(
literal|"%s "
argument_list|,
name|tf
operator|->
name|srr1
operator|&
name|PSL_PR
condition|?
literal|"user"
else|:
literal|"kernel"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tf
operator|->
name|exc
condition|)
block|{
case|case
name|EXC_DSI
case|:
name|db_printf
argument_list|(
literal|"DSI %s trap @ %#x by "
argument_list|,
name|tf
operator|->
name|dsisr
operator|&
name|DSISR_STORE
condition|?
literal|"write"
else|:
literal|"read"
argument_list|,
name|tf
operator|->
name|dar
argument_list|)
expr_stmt|;
goto|goto
name|print_trap
goto|;
case|case
name|EXC_ALI
case|:
name|db_printf
argument_list|(
literal|"ALI trap @ %#x (DSISR %#x) "
argument_list|,
name|tf
operator|->
name|dar
argument_list|,
name|tf
operator|->
name|dsisr
argument_list|)
expr_stmt|;
goto|goto
name|print_trap
goto|;
case|case
name|EXC_ISI
case|:
name|trapstr
operator|=
literal|"ISI"
expr_stmt|;
break|break;
case|case
name|EXC_PGM
case|:
name|trapstr
operator|=
literal|"PGM"
expr_stmt|;
break|break;
case|case
name|EXC_SC
case|:
name|trapstr
operator|=
literal|"SC"
expr_stmt|;
break|break;
case|case
name|EXC_EXI
case|:
name|trapstr
operator|=
literal|"EXI"
expr_stmt|;
break|break;
case|case
name|EXC_MCHK
case|:
name|trapstr
operator|=
literal|"MCHK"
expr_stmt|;
break|break;
case|case
name|EXC_VEC
case|:
name|trapstr
operator|=
literal|"VEC"
expr_stmt|;
break|break;
case|case
name|EXC_FPU
case|:
name|trapstr
operator|=
literal|"FPU"
expr_stmt|;
break|break;
case|case
name|EXC_FPA
case|:
name|trapstr
operator|=
literal|"FPA"
expr_stmt|;
break|break;
case|case
name|EXC_DECR
case|:
name|trapstr
operator|=
literal|"DECR"
expr_stmt|;
break|break;
case|case
name|EXC_BPT
case|:
name|trapstr
operator|=
literal|"BPT"
expr_stmt|;
break|break;
case|case
name|EXC_TRC
case|:
name|trapstr
operator|=
literal|"TRC"
expr_stmt|;
break|break;
case|case
name|EXC_RUNMODETRC
case|:
name|trapstr
operator|=
literal|"RUNMODETRC"
expr_stmt|;
break|break;
case|case
name|EXC_PERF
case|:
name|trapstr
operator|=
literal|"PERF"
expr_stmt|;
break|break;
case|case
name|EXC_SMI
case|:
name|trapstr
operator|=
literal|"SMI"
expr_stmt|;
break|break;
case|case
name|EXC_RST
case|:
name|trapstr
operator|=
literal|"RST"
expr_stmt|;
break|break;
default|default:
name|trapstr
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|trapstr
operator|!=
name|NULL
condition|)
block|{
name|db_printf
argument_list|(
literal|"%s trap by "
argument_list|,
name|trapstr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|db_printf
argument_list|(
literal|"trap %#x by "
argument_list|,
name|tf
operator|->
name|exc
argument_list|)
expr_stmt|;
block|}
name|print_trap
label|:
name|lr
operator|=
operator|(
name|db_addr_t
operator|)
name|tf
operator|->
name|srr0
expr_stmt|;
name|diff
operator|=
literal|0
expr_stmt|;
name|symname
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|db_search_symbol
argument_list|(
name|lr
argument_list|,
name|DB_STGY_ANY
argument_list|,
operator|&
name|diff
argument_list|)
expr_stmt|;
name|db_symbol_values
argument_list|(
name|sym
argument_list|,
operator|&
name|symname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|symname
operator|==
name|NULL
operator|||
operator|!
name|strcmp
argument_list|(
name|symname
argument_list|,
literal|"end"
argument_list|)
condition|)
block|{
name|db_printf
argument_list|(
literal|"%#x: srr1=%#x\n"
argument_list|,
name|lr
argument_list|,
name|tf
operator|->
name|srr1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|db_printf
argument_list|(
literal|"%s+%#x: srr1=%#x\n"
argument_list|,
name|symname
argument_list|,
name|diff
argument_list|,
name|tf
operator|->
name|srr1
argument_list|)
expr_stmt|;
block|}
name|db_printf
argument_list|(
literal|"%-10s  r1=%#x cr=%#x xer=%#x ctr=%#x"
argument_list|,
literal|""
argument_list|,
name|tf
operator|->
name|fixreg
index|[
literal|1
index|]
argument_list|,
name|tf
operator|->
name|cr
argument_list|,
name|tf
operator|->
name|xer
argument_list|,
name|tf
operator|->
name|ctr
argument_list|)
expr_stmt|;
if|if
condition|(
name|tf
operator|->
name|exc
operator|==
name|EXC_DSI
condition|)
name|db_printf
argument_list|(
literal|" dsisr=%#x"
argument_list|,
name|tf
operator|->
name|dsisr
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|stackframe
operator|=
operator|(
name|db_addr_t
operator|)
name|tf
operator|->
name|fixreg
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|kernel_only
operator|&&
operator|(
name|tf
operator|->
name|srr1
operator|&
name|PSL_PR
operator|)
condition|)
break|break;
goto|goto
name|next_frame
goto|;
block|}
name|diff
operator|=
literal|0
expr_stmt|;
name|symname
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|db_search_symbol
argument_list|(
name|lr
argument_list|,
name|DB_STGY_ANY
argument_list|,
operator|&
name|diff
argument_list|)
expr_stmt|;
name|db_symbol_values
argument_list|(
name|sym
argument_list|,
operator|&
name|symname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|symname
operator|==
name|NULL
operator|||
operator|!
name|strcmp
argument_list|(
name|symname
argument_list|,
literal|"end"
argument_list|)
condition|)
name|db_printf
argument_list|(
literal|"at %x"
argument_list|,
name|lr
argument_list|)
expr_stmt|;
else|else
name|db_printf
argument_list|(
literal|"at %s+%#x"
argument_list|,
name|symname
argument_list|,
name|diff
argument_list|)
expr_stmt|;
if|if
condition|(
name|full
condition|)
comment|/* Print all the args stored in that stackframe. */
name|db_printf
argument_list|(
literal|"(%x, %x, %x, %x, %x, %x, %x, %x)"
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|,
name|args
index|[
literal|2
index|]
argument_list|,
name|args
index|[
literal|3
index|]
argument_list|,
name|args
index|[
literal|4
index|]
argument_list|,
name|args
index|[
literal|5
index|]
argument_list|,
name|args
index|[
literal|6
index|]
argument_list|,
name|args
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|db_trace_self
parameter_list|(
name|void
parameter_list|)
block|{
name|db_addr_t
name|addr
decl_stmt|;
name|addr
operator|=
operator|(
name|db_addr_t
operator|)
name|__builtin_frame_address
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|db_backtrace
argument_list|(
name|curthread
argument_list|,
name|addr
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|db_trace_thread
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|pcb
modifier|*
name|ctx
decl_stmt|;
name|ctx
operator|=
name|kdb_thr_ctx
argument_list|(
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|db_backtrace
argument_list|(
name|td
argument_list|,
operator|(
name|db_addr_t
operator|)
name|ctx
operator|->
name|pcb_sp
argument_list|,
name|count
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|stack_save
parameter_list|(
name|struct
name|stack
modifier|*
name|st
parameter_list|)
block|{
name|vm_offset_t
name|callpc
decl_stmt|;
name|db_addr_t
name|stackframe
decl_stmt|;
name|stack_zero
argument_list|(
name|st
argument_list|)
expr_stmt|;
name|stackframe
operator|=
operator|(
name|db_addr_t
operator|)
name|__builtin_frame_address
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stackframe
operator|<
name|PAGE_SIZE
condition|)
return|return;
while|while
condition|(
literal|1
condition|)
block|{
name|stackframe
operator|=
operator|*
operator|(
name|db_addr_t
operator|*
operator|)
name|stackframe
expr_stmt|;
if|if
condition|(
name|stackframe
operator|<
name|PAGE_SIZE
condition|)
break|break;
name|callpc
operator|=
operator|*
operator|(
name|vm_offset_t
operator|*
operator|)
operator|(
name|stackframe
operator|+
literal|4
operator|)
operator|-
literal|4
expr_stmt|;
if|if
condition|(
operator|(
name|callpc
operator|&
literal|3
operator|)
operator|||
operator|(
name|callpc
operator|<
literal|0x100
operator|)
condition|)
break|break;
if|if
condition|(
name|stack_put
argument_list|(
name|st
argument_list|,
name|callpc
argument_list|)
operator|==
operator|-
literal|1
condition|)
break|break;
block|}
block|}
end_function

end_unit

