begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1995 Per Fogelstrom  * Copyright (c) 1993, 1994 Charles M. Hannum.  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * William Jolitz and Don Ahn.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$NetBSD: extintr.c,v 1.12 2000/02/14 12:45:52 tsubai Exp $  *	@(#)isa.c	7.2 (Berkeley) 5/12/91  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/interrupt.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<machine/autoconf.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr.h>
end_include

begin_include
include|#
directive|include
file|<machine/psl.h>
end_include

begin_include
include|#
directive|include
file|<machine/pio.h>
end_include

begin_include
include|#
directive|include
file|<machine/openpicreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/openfirm.h>
end_include

begin_define
define|#
directive|define
name|NIRQ
value|32
end_define

begin_define
define|#
directive|define
name|HWIRQ_MAX
value|(NIRQ - 4 - 1)
end_define

begin_define
define|#
directive|define
name|HWIRQ_MASK
value|0x0fffffff
end_define

begin_decl_stmt
name|void
name|intr_calculatemasks
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|intr_typename
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fakeintr
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|__inline
name|int
name|cntlzw
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|__inline
name|int
name|read_irq
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|__inline
name|int
name|mapirq
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|enable_irq
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|__inline
name|u_int
name|openpic_read
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|__inline
name|void
name|openpic_write
name|__P
argument_list|(
operator|(
name|int
operator|,
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|openpic_enable_irq
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|openpic_disable_irq
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|openpic_set_priority
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|__inline
name|int
name|openpic_read_irq
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|__inline
name|void
name|openpic_eoi
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|imen
init|=
literal|0xffffffff
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|cpl
decl_stmt|,
name|ipending
decl_stmt|,
name|tickspending
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|astpending
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|imask
index|[
name|NIPL
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|intrtype
index|[
name|NIRQ
index|]
decl_stmt|,
name|intrmask
index|[
name|NIRQ
index|]
decl_stmt|,
name|intrlevel
index|[
name|NIRQ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|intrhand
modifier|*
name|intrhand
index|[
name|NIRQ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|hwirq
index|[
name|NIRQ
index|]
decl_stmt|,
name|virq
index|[
name|ICU_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|virq_max
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
modifier|*
name|obio_base
decl_stmt|,
modifier|*
name|openpic_base
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* XXX */
end_comment

begin_endif
unit|extern u_int	*heathrow_FCR;
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|void
name|install_extint
parameter_list|(
name|void
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|void
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|interrupt_reg
value|(obio_base + 0x10)
end_define

begin_define
define|#
directive|define
name|INT_STATE_REG_H
value|(interrupt_reg + 0x00)
end_define

begin_define
define|#
directive|define
name|INT_ENABLE_REG_H
value|(interrupt_reg + 0x04)
end_define

begin_define
define|#
directive|define
name|INT_CLEAR_REG_H
value|(interrupt_reg + 0x08)
end_define

begin_define
define|#
directive|define
name|INT_LEVEL_REG_H
value|(interrupt_reg + 0x0c)
end_define

begin_define
define|#
directive|define
name|INT_STATE_REG_L
value|(interrupt_reg + 0x10)
end_define

begin_define
define|#
directive|define
name|INT_ENABLE_REG_L
value|(interrupt_reg + 0x14)
end_define

begin_define
define|#
directive|define
name|INT_CLEAR_REG_L
value|(interrupt_reg + 0x18)
end_define

begin_define
define|#
directive|define
name|INT_LEVEL_REG_L
value|(interrupt_reg + 0x1c)
end_define

begin_define
define|#
directive|define
name|have_openpic
value|(openpic_base != NULL)
end_define

begin_comment
comment|/*  * Map 64 irqs into 32 (bits).  */
end_comment

begin_function
name|int
name|mapirq
parameter_list|(
name|irq
parameter_list|)
name|int
name|irq
decl_stmt|;
block|{
name|int
name|v
decl_stmt|;
if|if
condition|(
name|irq
operator|<
literal|0
operator|||
name|irq
operator|>=
name|ICU_LEN
condition|)
name|panic
argument_list|(
literal|"invalid irq"
argument_list|)
expr_stmt|;
if|if
condition|(
name|virq
index|[
name|irq
index|]
condition|)
return|return
name|virq
index|[
name|irq
index|]
return|;
name|virq_max
operator|++
expr_stmt|;
name|v
operator|=
name|virq_max
expr_stmt|;
if|if
condition|(
name|v
operator|>
name|HWIRQ_MAX
condition|)
name|panic
argument_list|(
literal|"virq overflow"
argument_list|)
expr_stmt|;
name|hwirq
index|[
name|v
index|]
operator|=
name|irq
expr_stmt|;
name|virq
index|[
name|irq
index|]
operator|=
name|v
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_comment
comment|/*  * Count leading zeros.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|cntlzw
parameter_list|(
name|x
parameter_list|)
name|int
name|x
decl_stmt|;
block|{
name|int
name|a
decl_stmt|;
asm|__asm __volatile ("cntlzw %0,%1" : "=r"(a) : "r"(x));
return|return
name|a
return|;
block|}
end_function

begin_function
name|int
name|read_irq
parameter_list|()
block|{
name|int
name|rv
decl_stmt|,
name|lo
decl_stmt|,
name|hi
decl_stmt|,
name|p
decl_stmt|;
name|rv
operator|=
literal|0
expr_stmt|;
name|lo
operator|=
name|in32rb
argument_list|(
name|INT_STATE_REG_L
argument_list|)
expr_stmt|;
if|if
condition|(
name|lo
condition|)
name|out32rb
argument_list|(
name|INT_CLEAR_REG_L
argument_list|,
name|lo
argument_list|)
expr_stmt|;
while|while
condition|(
name|lo
condition|)
block|{
name|p
operator|=
literal|31
operator|-
name|cntlzw
argument_list|(
name|lo
argument_list|)
expr_stmt|;
name|rv
operator||=
literal|1
operator|<<
name|virq
index|[
name|p
index|]
expr_stmt|;
name|lo
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|p
operator|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* XXX */
block|if (heathrow_FCR)
comment|/* has heathrow? */
block|hi = in32rb(INT_STATE_REG_H); 	else
endif|#
directive|endif
name|hi
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hi
condition|)
name|out32rb
argument_list|(
name|INT_CLEAR_REG_H
argument_list|,
name|hi
argument_list|)
expr_stmt|;
while|while
condition|(
name|hi
condition|)
block|{
name|p
operator|=
literal|31
operator|-
name|cntlzw
argument_list|(
name|hi
argument_list|)
expr_stmt|;
name|rv
operator||=
literal|1
operator|<<
name|virq
index|[
name|p
operator|+
literal|32
index|]
expr_stmt|;
name|hi
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|p
operator|)
expr_stmt|;
block|}
comment|/* 1<< 0 is invalid. */
return|return
name|rv
operator|&
operator|~
literal|1
return|;
block|}
end_function

begin_function
name|void
name|enable_irq
parameter_list|(
name|x
parameter_list|)
name|int
name|x
decl_stmt|;
block|{
name|int
name|lo
decl_stmt|,
name|hi
decl_stmt|,
name|v
decl_stmt|,
name|irq
decl_stmt|;
name|x
operator|&=
name|HWIRQ_MASK
expr_stmt|;
comment|/* XXX Higher bits are software interrupts. */
name|lo
operator|=
name|hi
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|x
condition|)
block|{
name|v
operator|=
literal|31
operator|-
name|cntlzw
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|irq
operator|=
name|hwirq
index|[
name|v
index|]
expr_stmt|;
if|if
condition|(
name|irq
operator|<
literal|32
condition|)
name|lo
operator||=
literal|1
operator|<<
name|irq
expr_stmt|;
else|else
name|hi
operator||=
literal|1
operator|<<
operator|(
name|irq
operator|-
literal|32
operator|)
expr_stmt|;
name|x
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|v
operator|)
expr_stmt|;
block|}
name|out32rb
argument_list|(
name|INT_ENABLE_REG_L
argument_list|,
name|lo
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX */
block|if (heathrow_FCR) 		out32rb(INT_ENABLE_REG_H, hi);
endif|#
directive|endif
block|}
end_function

begin_function
name|u_int
name|openpic_read
parameter_list|(
name|reg
parameter_list|)
name|int
name|reg
decl_stmt|;
block|{
name|char
modifier|*
name|addr
decl_stmt|;
name|addr
operator|=
name|openpic_base
operator|+
name|reg
expr_stmt|;
return|return
name|in32rb
argument_list|(
name|addr
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|openpic_write
parameter_list|(
name|reg
parameter_list|,
name|val
parameter_list|)
name|int
name|reg
decl_stmt|;
name|u_int
name|val
decl_stmt|;
block|{
name|char
modifier|*
name|addr
decl_stmt|;
name|addr
operator|=
name|openpic_base
operator|+
name|reg
expr_stmt|;
name|out32rb
argument_list|(
name|addr
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|openpic_enable_irq
parameter_list|(
name|irq
parameter_list|)
name|int
name|irq
decl_stmt|;
block|{
name|u_int
name|x
decl_stmt|;
name|x
operator|=
name|openpic_read
argument_list|(
name|OPENPIC_SRC_VECTOR
argument_list|(
name|irq
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|&=
operator|~
name|OPENPIC_IMASK
expr_stmt|;
name|openpic_write
argument_list|(
name|OPENPIC_SRC_VECTOR
argument_list|(
name|irq
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|openpic_disable_irq
parameter_list|(
name|irq
parameter_list|)
name|int
name|irq
decl_stmt|;
block|{
name|u_int
name|x
decl_stmt|;
name|x
operator|=
name|openpic_read
argument_list|(
name|OPENPIC_SRC_VECTOR
argument_list|(
name|irq
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator||=
name|OPENPIC_IMASK
expr_stmt|;
name|openpic_write
argument_list|(
name|OPENPIC_SRC_VECTOR
argument_list|(
name|irq
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|openpic_set_priority
parameter_list|(
name|cpu
parameter_list|,
name|pri
parameter_list|)
name|int
name|cpu
decl_stmt|,
name|pri
decl_stmt|;
block|{
name|u_int
name|x
decl_stmt|;
name|x
operator|=
name|openpic_read
argument_list|(
name|OPENPIC_CPU_PRIORITY
argument_list|(
name|cpu
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|&=
operator|~
name|OPENPIC_CPU_PRIORITY_MASK
expr_stmt|;
name|x
operator||=
name|pri
expr_stmt|;
name|openpic_write
argument_list|(
name|OPENPIC_CPU_PRIORITY
argument_list|(
name|cpu
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|openpic_read_irq
parameter_list|(
name|cpu
parameter_list|)
name|int
name|cpu
decl_stmt|;
block|{
return|return
name|openpic_read
argument_list|(
name|OPENPIC_IACK
argument_list|(
name|cpu
argument_list|)
argument_list|)
operator|&
name|OPENPIC_VECTOR_MASK
return|;
block|}
end_function

begin_function
name|void
name|openpic_eoi
parameter_list|(
name|cpu
parameter_list|)
name|int
name|cpu
decl_stmt|;
block|{
name|openpic_write
argument_list|(
name|OPENPIC_EOI
argument_list|(
name|cpu
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|openpic_read
argument_list|(
name|OPENPIC_EOI
argument_list|(
name|cpu
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Recalculate the interrupt masks from scratch.  * We could code special registry and deregistry versions of this function that  * would be faster, but the code would be nastier, and we don't expect this to  * happen very much anyway.  */
end_comment

begin_function
name|void
name|intr_calculatemasks
parameter_list|()
block|{
name|int
name|irq
decl_stmt|,
name|level
decl_stmt|,
name|irqs
decl_stmt|;
name|struct
name|intrhand
modifier|*
name|q
decl_stmt|;
name|irqs
operator|=
literal|0
expr_stmt|;
comment|/* First, figure out which levels each IRQ uses. */
if|#
directive|if
literal|0
comment|/* XXX */
block|for (irq = 0; irq< NIRQ; irq++) { 		register int levels = 0; 		for (q = intrhand[irq]; q; q = q->ih_next) 			levels |= 1<< q->ih_level; 		intrlevel[irq] = levels; 	}
endif|#
directive|endif
comment|/* Then figure out which IRQs use each level. */
for|for
control|(
name|level
operator|=
literal|0
init|;
name|level
operator|<
name|NIPL
condition|;
name|level
operator|++
control|)
block|{
specifier|register
name|int
name|irqs
init|=
literal|0
decl_stmt|;
for|for
control|(
name|irq
operator|=
literal|0
init|;
name|irq
operator|<
name|NIRQ
condition|;
name|irq
operator|++
control|)
if|if
condition|(
name|intrlevel
index|[
name|irq
index|]
operator|&
operator|(
literal|1
operator|<<
name|level
operator|)
condition|)
name|irqs
operator||=
literal|1
operator|<<
name|irq
expr_stmt|;
name|imask
index|[
name|level
index|]
operator|=
name|irqs
expr_stmt|;
block|}
comment|/* 	 * IPL_CLOCK should mask clock interrupt even if interrupt handler 	 * is not registered. 	 */
name|imask
index|[
name|IPL_CLOCK
index|]
operator||=
literal|1
operator|<<
name|SPL_CLOCK
expr_stmt|;
comment|/* 	 * Initialize soft interrupt masks to block themselves. 	 */
name|imask
index|[
name|IPL_SOFTCLOCK
index|]
operator|=
literal|1
operator|<<
name|SIR_CLOCK
expr_stmt|;
name|imask
index|[
name|IPL_SOFTNET
index|]
operator|=
literal|1
operator|<<
name|SIR_NET
expr_stmt|;
name|imask
index|[
name|IPL_SOFTSERIAL
index|]
operator|=
literal|1
operator|<<
name|SIR_SERIAL
expr_stmt|;
comment|/* 	 * IPL_NONE is used for hardware interrupts that are never blocked, 	 * and do not block anything else. 	 */
name|imask
index|[
name|IPL_NONE
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Enforce a hierarchy that gives slow devices a better chance at not 	 * dropping data. 	 */
name|imask
index|[
name|IPL_SOFTCLOCK
index|]
operator||=
name|imask
index|[
name|IPL_NONE
index|]
expr_stmt|;
name|imask
index|[
name|IPL_SOFTNET
index|]
operator||=
name|imask
index|[
name|IPL_SOFTCLOCK
index|]
expr_stmt|;
name|imask
index|[
name|IPL_BIO
index|]
operator||=
name|imask
index|[
name|IPL_SOFTNET
index|]
expr_stmt|;
name|imask
index|[
name|IPL_NET
index|]
operator||=
name|imask
index|[
name|IPL_BIO
index|]
expr_stmt|;
name|imask
index|[
name|IPL_SOFTSERIAL
index|]
operator||=
name|imask
index|[
name|IPL_NET
index|]
expr_stmt|;
name|imask
index|[
name|IPL_TTY
index|]
operator||=
name|imask
index|[
name|IPL_SOFTSERIAL
index|]
expr_stmt|;
comment|/* 	 * There are tty, network and disk drivers that use free() at interrupt 	 * time, so imp> (tty | net | bio). 	 */
name|imask
index|[
name|IPL_IMP
index|]
operator||=
name|imask
index|[
name|IPL_TTY
index|]
expr_stmt|;
name|imask
index|[
name|IPL_AUDIO
index|]
operator||=
name|imask
index|[
name|IPL_IMP
index|]
expr_stmt|;
comment|/* 	 * Since run queues may be manipulated by both the statclock and tty, 	 * network, and disk drivers, clock> imp. 	 */
name|imask
index|[
name|IPL_CLOCK
index|]
operator||=
name|imask
index|[
name|IPL_AUDIO
index|]
expr_stmt|;
comment|/* 	 * IPL_HIGH must block everything that can manipulate a run queue. 	 */
name|imask
index|[
name|IPL_HIGH
index|]
operator||=
name|imask
index|[
name|IPL_CLOCK
index|]
expr_stmt|;
comment|/* 	 * We need serial drivers to run at the absolute highest priority to 	 * avoid overruns, so serial> high. 	 */
name|imask
index|[
name|IPL_SERIAL
index|]
operator||=
name|imask
index|[
name|IPL_HIGH
index|]
expr_stmt|;
comment|/* And eventually calculate the complete masks. */
if|#
directive|if
literal|0
comment|/* XXX */
block|for (irq = 0; irq< NIRQ; irq++) { 		register int irqs = 1<< irq; 		for (q = intrhand[irq]; q; q = q->ih_next) 			irqs |= imask[q->ih_level]; 		intrmask[irq] = irqs; 	}
endif|#
directive|endif
comment|/* Lastly, determine which IRQs are actually in use. */
for|for
control|(
name|irq
operator|=
literal|0
init|;
name|irq
operator|<
name|NIRQ
condition|;
name|irq
operator|++
control|)
if|if
condition|(
name|intrhand
index|[
name|irq
index|]
condition|)
name|irqs
operator||=
literal|1
operator|<<
name|irq
expr_stmt|;
if|if
condition|(
name|have_openpic
condition|)
block|{
for|for
control|(
name|irq
operator|=
literal|0
init|;
name|irq
operator|<
name|NIRQ
condition|;
name|irq
operator|++
control|)
block|{
if|if
condition|(
name|irqs
operator|&
operator|(
literal|1
operator|<<
name|irq
operator|)
condition|)
name|openpic_enable_irq
argument_list|(
name|hwirq
index|[
name|irq
index|]
argument_list|)
expr_stmt|;
else|else
name|openpic_disable_irq
argument_list|(
name|hwirq
index|[
name|irq
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|imen
operator|=
operator|~
name|irqs
expr_stmt|;
name|enable_irq
argument_list|(
operator|~
name|imen
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|fakeintr
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|LEGAL_IRQ
parameter_list|(
name|x
parameter_list|)
value|((x)>= 0&& (x)< NIRQ)
end_define

begin_function
name|char
modifier|*
name|intr_typename
parameter_list|(
name|type
parameter_list|)
name|int
name|type
decl_stmt|;
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|IST_NONE
case|:
return|return
operator|(
literal|"none"
operator|)
return|;
case|case
name|IST_PULSE
case|:
return|return
operator|(
literal|"pulsed"
operator|)
return|;
case|case
name|IST_EDGE
case|:
return|return
operator|(
literal|"edge-triggered"
operator|)
return|;
case|case
name|IST_LEVEL
case|:
return|return
operator|(
literal|"level-triggered"
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"intr_typename: invalid type %d"
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
comment|/* XXX */
return|return
operator|(
literal|"unknown"
operator|)
return|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/*  * Register an interrupt handler.  */
end_comment

begin_function
name|void
modifier|*
name|intr_establish
parameter_list|(
name|int
name|irq
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|level
parameter_list|,
name|int
function_decl|(
modifier|*
name|ih_fun
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|ih_arg
parameter_list|)
block|{
name|struct
name|intrhand
modifier|*
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|ih
decl_stmt|;
specifier|static
name|struct
name|intrhand
name|fakehand
init|=
block|{
name|fakeintr
block|}
decl_stmt|;
name|irq
operator|=
name|mapirq
argument_list|(
name|irq
argument_list|)
expr_stmt|;
comment|/* no point in sleeping unless someone can free memory. */
name|ih
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|ih
argument_list|,
name|M_DEVBUF
argument_list|,
name|cold
condition|?
name|M_NOWAIT
else|:
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|ih
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"intr_establish: can't malloc handler info"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|LEGAL_IRQ
argument_list|(
name|irq
argument_list|)
operator|||
name|type
operator|==
name|IST_NONE
condition|)
name|panic
argument_list|(
literal|"intr_establish: bogus irq or type"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|intrtype
index|[
name|irq
index|]
condition|)
block|{
case|case
name|IST_NONE
case|:
name|intrtype
index|[
name|irq
index|]
operator|=
name|type
expr_stmt|;
break|break;
case|case
name|IST_EDGE
case|:
case|case
name|IST_LEVEL
case|:
if|if
condition|(
name|type
operator|==
name|intrtype
index|[
name|irq
index|]
condition|)
break|break;
case|case
name|IST_PULSE
case|:
if|if
condition|(
name|type
operator|!=
name|IST_NONE
condition|)
name|panic
argument_list|(
literal|"intr_establish: can't share %s with %s"
argument_list|,
name|intr_typename
argument_list|(
name|intrtype
index|[
name|irq
index|]
argument_list|)
argument_list|,
name|intr_typename
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	 * Figure out where to put the handler. 	 * This is O(N^2), but we want to preserve the order, and N is 	 * generally small. 	 */
if|#
directive|if
literal|0
comment|/* XXX */
block|for (p =&intrhand[irq]; (q = *p) != NULL; p =&q->ih_next) 		;
endif|#
directive|endif
comment|/* 	 * Actually install a fake handler momentarily, since we might be doing 	 * this with interrupts enabled and don't want the real routine called 	 * until masking is set up. 	 */
if|#
directive|if
literal|0
comment|/* XXX */
block|fakehand.ih_level = level;
endif|#
directive|endif
operator|*
name|p
operator|=
operator|&
name|fakehand
expr_stmt|;
name|intr_calculatemasks
argument_list|()
expr_stmt|;
comment|/* 	 * Poke the real handler in now. 	 */
if|#
directive|if
literal|0
block|ih->ih_fun = ih_fun; 	ih->ih_arg = ih_arg; 	ih->ih_count = 0; 	ih->ih_next = NULL; 	ih->ih_level = level; 	ih->ih_irq = irq;
endif|#
directive|endif
operator|*
name|p
operator|=
name|ih
expr_stmt|;
return|return
operator|(
name|ih
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Deregister an interrupt handler.  */
end_comment

begin_function
name|void
name|intr_disestablish
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|intrhand
modifier|*
name|ih
decl_stmt|,
modifier|*
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|int
name|irq
decl_stmt|;
if|#
directive|if
literal|0
comment|/* XXX */
block|irq = ih->ih_irq;
endif|#
directive|endif
name|ih
operator|=
name|arg
expr_stmt|;
if|if
condition|(
operator|!
name|LEGAL_IRQ
argument_list|(
name|irq
argument_list|)
condition|)
name|panic
argument_list|(
literal|"intr_disestablish: bogus irq"
argument_list|)
expr_stmt|;
comment|/* 	 * Remove the handler from the chain. 	 * This is O(n^2), too. 	 */
for|for
control|(
name|p
operator|=
operator|&
name|intrhand
index|[
name|irq
index|]
init|;
operator|(
name|q
operator|=
operator|*
name|p
operator|)
operator|!=
name|NULL
operator|&&
name|q
operator|!=
name|ih
condition|;
name|p
operator|=
operator|&
name|q
operator|->
name|ih_next
control|)
empty_stmt|;
if|if
condition|(
name|q
condition|)
if|#
directive|if
literal|0
comment|/* XXX */
then|*p = q->ih_next;
else|#
directive|else
name|p
operator|=
name|p
expr_stmt|;
endif|#
directive|endif
else|else
name|panic
argument_list|(
literal|"intr_disestablish: handler not registered"
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ih
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|intr_calculatemasks
argument_list|()
expr_stmt|;
if|if
condition|(
name|intrhand
index|[
name|irq
index|]
operator|==
name|NULL
condition|)
name|intrtype
index|[
name|irq
index|]
operator|=
name|IST_NONE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * external interrupt handler  */
end_comment

begin_function
name|void
name|ext_intr
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|irq
decl_stmt|;
name|int
name|o_imen
decl_stmt|,
name|r_imen
decl_stmt|;
name|int
name|pcpl
decl_stmt|;
name|struct
name|intrhand
modifier|*
name|ih
decl_stmt|;
specifier|volatile
name|unsigned
name|long
name|int_state
decl_stmt|;
name|pcpl
operator|=
name|splhigh
argument_list|()
expr_stmt|;
comment|/* Turn off all */
name|int_state
operator|=
name|read_irq
argument_list|()
expr_stmt|;
if|if
condition|(
name|int_state
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
name|start
label|:
name|irq
operator|=
literal|31
operator|-
name|cntlzw
argument_list|(
name|int_state
argument_list|)
expr_stmt|;
name|o_imen
operator|=
name|imen
expr_stmt|;
name|r_imen
operator|=
literal|1
operator|<<
name|irq
expr_stmt|;
if|if
condition|(
operator|(
name|pcpl
operator|&
name|r_imen
operator|)
operator|!=
literal|0
condition|)
block|{
name|ipending
operator||=
name|r_imen
expr_stmt|;
comment|/* Masked! Mark this as pending */
name|imen
operator||=
name|r_imen
expr_stmt|;
name|enable_irq
argument_list|(
operator|~
name|imen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ih
operator|=
name|intrhand
index|[
name|irq
index|]
expr_stmt|;
while|while
condition|(
name|ih
condition|)
block|{
if|#
directive|if
literal|0
comment|/* XXX */
block|(*ih->ih_fun)(ih->ih_arg); 			ih = ih->ih_next;
endif|#
directive|endif
block|}
name|intrcnt
index|[
name|hwirq
index|[
name|irq
index|]
index|]
operator|++
expr_stmt|;
block|}
name|int_state
operator|&=
operator|~
name|r_imen
expr_stmt|;
if|if
condition|(
name|int_state
condition|)
goto|goto
name|start
goto|;
name|out
label|:
name|splx
argument_list|(
name|pcpl
argument_list|)
expr_stmt|;
comment|/* Process pendings. */
block|}
end_function

begin_function
name|void
name|ext_intr_openpic
parameter_list|()
block|{
name|int
name|irq
decl_stmt|,
name|realirq
decl_stmt|;
name|int
name|r_imen
decl_stmt|;
name|int
name|pcpl
decl_stmt|;
name|struct
name|intrhand
modifier|*
name|ih
decl_stmt|;
name|pcpl
operator|=
name|splhigh
argument_list|()
expr_stmt|;
comment|/* Turn off all */
name|realirq
operator|=
name|openpic_read_irq
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|realirq
operator|==
literal|255
condition|)
block|{
name|printf
argument_list|(
literal|"sprious interrupt\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|start
label|:
name|irq
operator|=
name|virq
index|[
name|realirq
index|]
expr_stmt|;
comment|/* XXX check range */
name|r_imen
operator|=
literal|1
operator|<<
name|irq
expr_stmt|;
if|if
condition|(
operator|(
name|pcpl
operator|&
name|r_imen
operator|)
operator|!=
literal|0
condition|)
block|{
name|ipending
operator||=
name|r_imen
expr_stmt|;
comment|/* Masked! Mark this as pending */
name|openpic_disable_irq
argument_list|(
name|realirq
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ih
operator|=
name|intrhand
index|[
name|irq
index|]
expr_stmt|;
while|while
condition|(
name|ih
condition|)
block|{
if|#
directive|if
literal|0
comment|/* XXX */
block|(*ih->ih_fun)(ih->ih_arg); 			ih = ih->ih_next;
endif|#
directive|endif
block|}
name|intrcnt
index|[
name|hwirq
index|[
name|irq
index|]
index|]
operator|++
expr_stmt|;
block|}
name|openpic_eoi
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|realirq
operator|=
name|openpic_read_irq
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|realirq
operator|!=
literal|255
condition|)
goto|goto
name|start
goto|;
name|out
label|:
name|splx
argument_list|(
name|pcpl
argument_list|)
expr_stmt|;
comment|/* Process pendings. */
block|}
end_function

begin_function
name|void
name|do_pending_int
parameter_list|()
block|{
name|struct
name|intrhand
modifier|*
name|ih
decl_stmt|;
name|int
name|irq
decl_stmt|;
name|int
name|pcpl
decl_stmt|;
name|int
name|hwpend
decl_stmt|;
name|int
name|emsr
decl_stmt|,
name|dmsr
decl_stmt|;
specifier|static
name|int
name|processing
decl_stmt|;
return|return;
comment|/* XXX */
if|if
condition|(
name|processing
condition|)
return|return;
name|processing
operator|=
literal|1
expr_stmt|;
name|emsr
operator|=
name|mfmsr
argument_list|()
expr_stmt|;
name|dmsr
operator|=
name|emsr
operator|&
operator|~
name|PSL_EE
expr_stmt|;
name|mtmsr
argument_list|(
name|dmsr
argument_list|)
expr_stmt|;
name|pcpl
operator|=
name|splhigh
argument_list|()
expr_stmt|;
comment|/* Turn off all */
name|hwpend
operator|=
name|ipending
operator|&
operator|~
name|pcpl
expr_stmt|;
comment|/* Do now unmasked pendings */
if|if
condition|(
operator|!
name|have_openpic
condition|)
block|{
name|imen
operator|&=
operator|~
name|hwpend
expr_stmt|;
name|enable_irq
argument_list|(
operator|~
name|imen
argument_list|)
expr_stmt|;
block|}
name|hwpend
operator|&=
name|HWIRQ_MASK
expr_stmt|;
while|while
condition|(
name|hwpend
condition|)
block|{
name|irq
operator|=
literal|31
operator|-
name|cntlzw
argument_list|(
name|hwpend
argument_list|)
expr_stmt|;
name|hwpend
operator|&=
operator|~
operator|(
literal|1L
operator|<<
name|irq
operator|)
expr_stmt|;
name|ih
operator|=
name|intrhand
index|[
name|irq
index|]
expr_stmt|;
while|while
condition|(
name|ih
condition|)
block|{
if|#
directive|if
literal|0
comment|/* XXX */
block|(*ih->ih_fun)(ih->ih_arg); 			ih = ih->ih_next;
endif|#
directive|endif
block|}
name|intrcnt
index|[
name|hwirq
index|[
name|irq
index|]
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|have_openpic
condition|)
name|openpic_enable_irq
argument_list|(
name|hwirq
index|[
name|irq
index|]
argument_list|)
expr_stmt|;
block|}
comment|/*out32rb(INT_ENABLE_REG, ~imen);*/
if|if
condition|(
operator|(
name|ipending
operator|&
operator|~
name|pcpl
operator|)
operator|&
operator|(
literal|1
operator|<<
name|SIR_CLOCK
operator|)
condition|)
block|{
name|ipending
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|SIR_CLOCK
operator|)
expr_stmt|;
name|softclock
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|intrcnt
index|[
name|CNT_SOFTCLOCK
index|]
operator|++
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* XXX */
block|if ((ipending& ~pcpl)& (1<< SIR_NET)) { 		ipending&= ~(1<< SIR_NET); 		softnet(); 		intrcnt[CNT_SOFTNET]++; 	} 	if ((ipending& ~pcpl)& (1<< SIR_SERIAL)) { 		ipending&= ~(1<< SIR_SERIAL); 		softserial(); 		intrcnt[CNT_SOFTSERIAL]++; 	}
endif|#
directive|endif
name|ipending
operator|&=
name|pcpl
expr_stmt|;
name|cpl
operator|=
name|pcpl
expr_stmt|;
comment|/* Don't use splx... we are here already! */
name|mtmsr
argument_list|(
name|emsr
argument_list|)
expr_stmt|;
name|processing
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|openpic_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|irq
decl_stmt|;
name|u_int
name|x
decl_stmt|;
comment|/* disable all interrupts */
for|for
control|(
name|irq
operator|=
literal|0
init|;
name|irq
operator|<
literal|256
condition|;
name|irq
operator|++
control|)
name|openpic_write
argument_list|(
name|OPENPIC_SRC_VECTOR
argument_list|(
name|irq
argument_list|)
argument_list|,
name|OPENPIC_IMASK
argument_list|)
expr_stmt|;
name|openpic_set_priority
argument_list|(
literal|0
argument_list|,
literal|15
argument_list|)
expr_stmt|;
comment|/* we don't need 8259 pass through mode */
name|x
operator|=
name|openpic_read
argument_list|(
name|OPENPIC_CONFIG
argument_list|)
expr_stmt|;
name|x
operator||=
name|OPENPIC_CONFIG_8259_PASSTHRU_DISABLE
expr_stmt|;
name|openpic_write
argument_list|(
name|OPENPIC_CONFIG
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* send all interrupts to cpu 0 */
for|for
control|(
name|irq
operator|=
literal|0
init|;
name|irq
operator|<
name|ICU_LEN
condition|;
name|irq
operator|++
control|)
name|openpic_write
argument_list|(
name|OPENPIC_IDEST
argument_list|(
name|irq
argument_list|)
argument_list|,
literal|1
operator|<<
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|irq
operator|=
literal|0
init|;
name|irq
operator|<
name|ICU_LEN
condition|;
name|irq
operator|++
control|)
block|{
name|x
operator|=
name|irq
expr_stmt|;
name|x
operator||=
name|OPENPIC_IMASK
expr_stmt|;
name|x
operator||=
name|OPENPIC_POLARITY_POSITIVE
expr_stmt|;
name|x
operator||=
name|OPENPIC_SENSE_LEVEL
expr_stmt|;
name|x
operator||=
literal|8
operator|<<
name|OPENPIC_PRIORITY_SHIFT
expr_stmt|;
name|openpic_write
argument_list|(
name|OPENPIC_SRC_VECTOR
argument_list|(
name|irq
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
comment|/* XXX set spurious intr vector */
name|openpic_set_priority
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* clear all pending interrunts */
for|for
control|(
name|irq
operator|=
literal|0
init|;
name|irq
operator|<
literal|256
condition|;
name|irq
operator|++
control|)
block|{
name|openpic_read_irq
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|openpic_eoi
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|irq
operator|=
literal|0
init|;
name|irq
operator|<
name|ICU_LEN
condition|;
name|irq
operator|++
control|)
name|openpic_disable_irq
argument_list|(
name|irq
argument_list|)
expr_stmt|;
name|install_extint
argument_list|(
name|ext_intr_openpic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|legacy_int_init
parameter_list|(
name|void
parameter_list|)
block|{
name|out32rb
argument_list|(
name|INT_ENABLE_REG_L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable all intr. */
name|out32rb
argument_list|(
name|INT_CLEAR_REG_L
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
comment|/* clear pending intr. */
name|install_extint
argument_list|(
name|ext_intr
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|HEATHROW_FCR_OFFSET
value|0x38
end_define

begin_comment
comment|/* XXX should not here */
end_comment

begin_define
define|#
directive|define
name|GC_OBIO_BASE
value|0xf3000000
end_define

begin_function
name|void
name|init_interrupt
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|chosen
decl_stmt|;
name|int
name|mac_io
decl_stmt|,
name|reg
index|[
literal|5
index|]
decl_stmt|;
name|int32_t
name|ictlr
decl_stmt|;
name|char
name|type
index|[
literal|32
index|]
decl_stmt|;
name|openpic_base
operator|=
name|NULL
expr_stmt|;
name|mac_io
operator|=
name|OF_finddevice
argument_list|(
literal|"mac-io"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mac_io
operator|==
operator|-
literal|1
condition|)
name|mac_io
operator|=
name|OF_finddevice
argument_list|(
literal|"/pci/mac-io"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mac_io
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 		 * No mac-io.  Assume Grand-Central or OHare. 		 */
name|obio_base
operator|=
operator|(
name|void
operator|*
operator|)
name|GC_OBIO_BASE
expr_stmt|;
name|legacy_int_init
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|OF_getprop
argument_list|(
name|mac_io
argument_list|,
literal|"assigned-addresses"
argument_list|,
name|reg
argument_list|,
sizeof|sizeof
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|<
literal|20
condition|)
goto|goto
name|failed
goto|;
name|obio_base
operator|=
operator|(
name|void
operator|*
operator|)
name|reg
index|[
literal|2
index|]
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX */
block|heathrow_FCR = (void *)(obio_base + HEATHROW_FCR_OFFSET);
endif|#
directive|endif
name|bzero
argument_list|(
name|type
argument_list|,
sizeof|sizeof
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|chosen
operator|=
name|OF_finddevice
argument_list|(
literal|"/chosen"
argument_list|)
expr_stmt|;
if|if
condition|(
name|OF_getprop
argument_list|(
name|chosen
argument_list|,
literal|"interrupt-controller"
argument_list|,
operator|&
name|ictlr
argument_list|,
literal|4
argument_list|)
operator|==
literal|4
condition|)
name|OF_getprop
argument_list|(
name|ictlr
argument_list|,
literal|"device_type"
argument_list|,
name|type
argument_list|,
sizeof|sizeof
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"open-pic"
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Not an open-pic.  Must be a Heathrow (compatible). 		 */
name|legacy_int_init
argument_list|()
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* 		 * We have an Open PIC. 		 */
if|if
condition|(
name|OF_getprop
argument_list|(
name|ictlr
argument_list|,
literal|"reg"
argument_list|,
name|reg
argument_list|,
sizeof|sizeof
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|<
literal|8
condition|)
goto|goto
name|failed
goto|;
name|openpic_base
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|obio_base
operator|+
name|reg
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|openpic_init
argument_list|()
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"unknown interrupt controller\n"
argument_list|)
expr_stmt|;
name|failed
label|:
name|panic
argument_list|(
literal|"init_interrupt: failed to initialize interrupt controller"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

